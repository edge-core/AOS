/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.scalar.conf,v 1.5 2002/07/18 14:18:52 dts12 Exp $
 */
#include "sys_cpnt.h"
#include "sys_imghdr.h"
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "rfc_2021.h"
#include "sysORTable.h"
#include "leaf_2021.h"
#include "stktplg_mgr.h"
#include "stkctrl_task.h"
#include "stktplg_pmgr.h"
#include "stkctrl_pmgr.h"
#include "sys_mgr.h"
#include "xfer_pmgr.h"
#include "l_inet.h"
#include "snmp_mgr.h"
//#include "cli_mgr.h"
#include "sysfun.h"
#include "ip_lib.h"
#include "l_stdlib.h"
#include "leaf_sys.h"
#include "fs.h"
//#include "netcfg_mgr.h"
#include "netcfg_type.h"
#include "netcfg_pom_ip.h"
#include "netcfg_pmgr_ip.h"
#include "netcfg_pmgr_route.h"
#include "sys_time.h"
#include "sys_adpt.h"
#include "leaf_es3626a.h"
#include "l_prefix.h"
/** Initializes the probeConfig module */
void
init_probeConfig(void)
{
    oid             mib_module_oid[] = { SNMP_OID_MIB2, 16, 19 };

    static oid      probeCapabilities_oid[] =
        { 1, 3, 6, 1, 2, 1, 16, 19, 1, 0 };
    static oid      probeDownloadFile_oid[] =
        { 1, 3, 6, 1, 2, 1, 16, 19, 6, 0 };
    static oid      probeDownloadTFTPServer_oid[] =
        { 1, 3, 6, 1, 2, 1, 16, 19, 7, 0 };
    static oid      probeSoftwareRev_oid[] =
        { 1, 3, 6, 1, 2, 1, 16, 19, 2, 0 };
    static oid      probeDownloadAction_oid[] =
        { 1, 3, 6, 1, 2, 1, 16, 19, 8, 0 };
    static oid      probeResetControl_oid[] =
        { 1, 3, 6, 1, 2, 1, 16, 19, 5, 0 };
    static oid      probeHardwareRev_oid[] =
        { 1, 3, 6, 1, 2, 1, 16, 19, 3, 0 };
    static oid      netDefaultGateway_oid[] =
        { 1, 3, 6, 1, 2, 1, 16, 19, 12, 0 };
    static oid      probeDateTime_oid[] =
        { 1, 3, 6, 1, 2, 1, 16, 19, 4, 0 };
    static oid      probeDownloadStatus_oid[] =
        { 1, 3, 6, 1, 2, 1, 16, 19, 9, 0 };

    DEBUGMSGTL(("probeConfig", "Initializing\n"));

    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("probeCapabilities",
                                         get_probeCapabilities,
                                         probeCapabilities_oid,
                                         OID_LENGTH(probeCapabilities_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("probeDownloadFile",
                               do_probeDownloadFile,
                               probeDownloadFile_oid,
                               OID_LENGTH(probeDownloadFile_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("probeDownloadTFTPServer",
                               do_probeDownloadTFTPServer,
                               probeDownloadTFTPServer_oid,
                               OID_LENGTH(probeDownloadTFTPServer_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("probeSoftwareRev",
                                         get_probeSoftwareRev,
                                         probeSoftwareRev_oid,
                                         OID_LENGTH(probeSoftwareRev_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("probeDownloadAction",
                               do_probeDownloadAction,
                               probeDownloadAction_oid,
                               OID_LENGTH(probeDownloadAction_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("probeResetControl",
                               do_probeResetControl,
                               probeResetControl_oid,
                               OID_LENGTH(probeResetControl_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("probeHardwareRev",
                                         get_probeHardwareRev,
                                         probeHardwareRev_oid,
                                         OID_LENGTH(probeHardwareRev_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("netDefaultGateway",
                               do_netDefaultGateway_2,
                               netDefaultGateway_oid,
                               OID_LENGTH(netDefaultGateway_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("probeDateTime",
                               do_probeDateTime,
                               probeDateTime_oid,
                               OID_LENGTH(probeDateTime_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("probeDownloadStatus",
                                         get_probeDownloadStatus,
                                         probeDownloadStatus_oid,
                                         OID_LENGTH
                                         (probeDownloadStatus_oid),
                                         HANDLER_CAN_RONLY));
    REGISTER_SYSOR_ENTRY(mib_module_oid,
                         "The RMONII Probe Config MIB.");
}

int
get_probeCapabilities(netsnmp_mib_handler *handler,
                     netsnmp_handler_registration *reginfo,
                     netsnmp_agent_request_info *reqinfo,
                     netsnmp_request_info *requests)
{
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one.
     */

    switch (reqinfo->mode)
    {
        case MODE_GET:
        {
            UI32_T data, temp;
            temp = SYS_VAL_probeCapabilities_etherStats |
                   SYS_VAL_probeCapabilities_historyControl |
                   SYS_VAL_probeCapabilities_etherHistory |
                   SYS_VAL_probeCapabilities_alarm |
                   SYS_VAL_probeCapabilities_event |
                   SYS_VAL_probeCapabilities_probeConfig;

            data = L_STDLIB_Hton32(temp);
            memcpy( return_buf, &data,sizeof(data));
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, (u_char *) return_buf, 4);
        }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error
             */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_probeDownloadFile(netsnmp_mib_handler *handler,
                     netsnmp_handler_registration *reginfo,
                     netsnmp_agent_request_info *reqinfo,
                     netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode)
    {
        case MODE_GET:
        {
            XFER_MGR_FileCopyMgt_T data;
            if (XFER_PMGR_GetFileCopyMgtEntry(&data)==TRUE)
            {
                strcpy((char *)return_buf, (char *)data.src_file_name);
                snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, (u_char *) return_buf, strlen((char *)return_buf));
            }
            break;
        }

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
			if (requests->requestvb->type != ASN_OCTET_STR)
            {
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_WRONGTYPE);
                break;
            }
            if ((requests->requestvb->val_len<MINSIZE_probeDownloadFile)  ||    (requests->requestvb->val_len>MAXSIZE_probeDownloadFile))
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_WRONGLENGTH);
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */

            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
               /* XXX: perform the value change here */
           {
               UI8_T  download[MAXSIZE_probeDownloadFile+1];

               #if   (SYS_CPNT_DBSYNC_TXT == TRUE)
              /* kinghong add for 3com autosave*/
               if   (!SNMP_MGR_SetTmpDirty(0))
                  SYSFUN_Debug_Printf("autoSave   Fail\n");
               #endif

               memcpy(download, requests->requestvb->val.string, requests->requestvb->val_len);
               download[requests->requestvb->val_len]= '\0';

               if (!L_STDLIB_StrIsAsciiPrintWithCount((char *)download,requests->requestvb->val_len ))
               {
                   netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
               }

               if (XFER_PMGR_SetFileCopySrcFileName(download)!=TRUE)
               {
                   netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
               }
           }
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */

            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */

            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_probeDownloadTFTPServer(netsnmp_mib_handler *handler,
                           netsnmp_handler_registration *reginfo,
                           netsnmp_agent_request_info *reqinfo,
                           netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode)
    {
        case MODE_GET:
        {
            XFER_MGR_FileCopyMgt_T data;
            if (XFER_PMGR_GetFileCopyMgtEntry(&data))
            {
                IP_LIB_ArraytoUI32(data.server_address.addr, &ipaddr_return);
                snmp_set_var_typed_value(requests->requestvb, ASN_IPADDRESS, (u_char *) &ipaddr_return, sizeof(ipaddr_return));
            }
        }
           break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
			if (requests->requestvb->type != ASN_IPADDRESS)
            {
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_WRONGTYPE);
                break;
            }

            if (requests->requestvb->val_len != SYS_ADPT_IPV4_ADDR_LEN)
            {
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_WRONGLENGTH);
                break;
            }
        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */

            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
        {
            L_INET_AddrIp_T iIp;

            #if   (SYS_CPNT_DBSYNC_TXT == TRUE)
            /* kinghong add for 3com autosave*/
            if   (!SNMP_MGR_SetTmpDirty(0))
              SYSFUN_Debug_Printf("autoSave   Fail\n");
            #endif
            iIp.addrlen = SYS_ADPT_IPV4_ADDR_LEN;
            iIp.type = VAL_fileCopyServerInetAddressType_ipv4;
            IP_LIB_UI32toArray(*requests->requestvb->val.integer, iIp.addr);

            if(TRUE == L_INET_ADDR_IS_IPV4_LINK_LOCAL(iIp.addr))
            {
                iIp.type = VAL_fileCopyServerInetAddressType_ipv4z;
            }
            else
            {
                iIp.type = VAL_fileCopyServerInetAddressType_ipv4;
            }
            if (XFER_PMGR_SetFileCopyTftpServer(&iIp)!=TRUE)
            {
               netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
            }
       }
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */

            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */

            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_probeSoftwareRev(netsnmp_mib_handler *handler,
                     netsnmp_handler_registration *reginfo,
                     netsnmp_agent_request_info *reqinfo,
                     netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode)
    {
        case MODE_GET:
        {
            STKTPLG_MGR_Switch_Info_T data;
            UI8_T buffer[MAXSIZE_probeSoftwareRev+1];

#if (SYS_CPNT_3COM_CLI == TRUE)
            UI32_T version;
            UI32_T version1 = 0, version2 = 0, version3 = 0, version4 = 0;
#endif

            memset(&data, 0, sizeof(data));
            /* This variables always  used index = 1 to get*/
            data.sw_unit_index = 1;

            if(STKTPLG_PMGR_GetSwitchInfo(&data))
            {
                strncpy((char *)buffer, (char *)data.sw_opcode_ver, MAXSIZE_probeSoftwareRev + 1);
                buffer[MAXSIZE_probeSoftwareRev] = 0;
#if (SYS_CPNT_3COM_CLI == TRUE)
                sscanf(buffer, "%lu.%lu.%lu.%lu", &version1, &version2, &version3, &version4);

                version = (version1 << 24 | version2 << 16 | version3 << 8 | version4);

                CLI_MGR_GetVersionNumberDisplayString(version, IMGHDR_IMAGE_RUNTIMETYPE, buffer);
#endif  /*end of #if (SYS_CPNT_3COM_CLI == TRUE) */
                strcpy((char *)return_buf, (char *)buffer);
                snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, (u_char *) return_buf, strlen((char *)return_buf));
            }

            break;
        }

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

/*------------------------------------------------------------------------
 * ROUTINE NAME - fileCopyUserInfo_get
 *------------------------------------------------------------------------
 * FUNCTION: Get file copry user information
 * INPUT   : reqinfo      -- request information
 *           user_info_p  -- user information entry
 * OUTPUT  : None
 * RETURN  : TRUE/FALSE
 * NOTE    : None
 *------------------------------------------------------------------------
 */
static BOOL_T
fileCopyUserInfo_get(
    netsnmp_agent_request_info *reqinfo,
    XFER_MGR_UserInfo_T *user_info_p)
{
    L_INET_AddrIp_T      rem_ip_addr;
    L_INET_AddrIp_T      nexthop_addr;
    struct sockaddr *sock_addr_in = (struct sockaddr *)reqinfo->asp->pdu->transport_data;

    user_info_p->session_type = VAL_trapVarSessionType_snmp;

    /* get user name
     */
    switch (reqinfo->asp->pdu->securityModel)
    {
        case SNMP_SEC_MODEL_SNMPv1:
        case SNMP_SEC_MODEL_SNMPv2c:
            strncpy(user_info_p->user_name, (char *)reqinfo->asp->pdu->community,
                sizeof(user_info_p->user_name)-1);
            break;

        case SNMP_SEC_MODEL_USM:
            strncpy(user_info_p->user_name, reqinfo->asp->pdu->securityName,
                sizeof(user_info_p->user_name)-1);
            break;

        default:
            return FALSE;
    }

    user_info_p->user_name[sizeof(user_info_p->user_name)-1] = '\0';

    /* get user ip
     */
    if (FALSE == L_INET_SockaddrToInaddr(sock_addr_in, &rem_ip_addr))
    {
        return FALSE;
    }

    memcpy(&user_info_p->user_ip, &rem_ip_addr, sizeof(user_info_p->user_ip));

    /* get user mac
     */
    if (NETCFG_TYPE_FAIL == NETCFG_PMGR_ROUTE_GetReversePathIpMac(&rem_ip_addr,
        &nexthop_addr, user_info_p->user_mac))
    {
        return FALSE;
    }

    return TRUE;
}/* End of fileCopyUserInfo_get */

int
do_probeDownloadAction(netsnmp_mib_handler *handler,
                       netsnmp_handler_registration *reginfo,
                       netsnmp_agent_request_info *reqinfo,
                       netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode)
    {
        case MODE_GET:
        {
            XFER_MGR_FileCopyMgt_T data;
            if (XFER_PMGR_GetFileCopyMgtEntry(&data))
            {
                long_return = data.action;
                switch (long_return)
                {
                    case VAL_fileCopyAction_notCopying:
                        long_return = VAL_probeDownloadAction_notDownloading;
                        break;

                    case VAL_fileCopyAction_copy:
                        long_return = VAL_probeDownloadAction_downloadToPROM;
                        break;
                }
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
            }
        }
        break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
        {
            if (requests->requestvb->type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }

            if (   (*requests->requestvb->val.integer < VAL_probeDownloadAction_notDownloading)
                || (*requests->requestvb->val.integer > VAL_probeDownloadAction_downloadToRAM))
            {
                return SNMP_ERR_WRONGVALUE;
            }

            if (*requests->requestvb->val.integer != VAL_probeDownloadAction_downloadToPROM)
            {
                return SNMP_ERR_INCONSISTENTVALUE;
            }
	    }

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */

#if(SYS_CPNT_3COM_TWO_OPCODES == TRUE)
            #if   (SYS_CPNT_DBSYNC_TXT == TRUE)
            /* kinghong add for 3com autosave*/
                if (!SNMP_MGR_SetTmpDirty(0))
                    SYSFUN_Debug_Printf("autoSave   Fail\n");
            #endif
            if (!XFER_MGR_SetTftpToStartupOpCodeAction())
            {
               netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
            }
#else
            {
                XFER_MGR_UserInfo_T  user_info;
                FS_File_Attr_T entry;
                UI32_T drive = 0;
                BOOL_T is_find;

                memset(&entry, 0, sizeof(entry));
                entry.file_type_mask = FS_FILE_TYPE_MASK(FS_TYPE_OPCODE_FILE_TYPE);
                is_find = FALSE;

                /* find the start file name. */
                while ((FS_GetNextFileInfo(&drive, &entry)) == FS_RETURN_OK)
                {
/* [ES3528MO-FLF-38-00374], beacuse of fs.c different between mo and acpv3,
 * we need to add compiler option.
 */
#if ((SYS_CPNT_STACKING == TRUE) && (SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK != 1))
                    if ((drive == 1) &&
                        (entry.file_type == FS_TYPE_OPCODE_FILE_TYPE) &&
                        (entry.startup_file == TRUE))
#else
                    if ((entry.file_type == FS_TYPE_OPCODE_FILE_TYPE) &&
                        (entry.startup_file == TRUE))
#endif
                    {
                        is_find = TRUE;
                        break;
                    }
                }

                /* It have found the start file name. */
                if (is_find == TRUE)
                {
                    XFER_PMGR_SetFileCopySrcOperType(VAL_fileCopyDestOperType_tftp);
                    XFER_PMGR_SetFileCopyDestOperType(VAL_fileCopyDestOperType_file);
                    XFER_PMGR_SetFileCopyFileType(VAL_fileCopyFileType_opcode);

                    memset(&user_info, 0, sizeof(user_info));
                    fileCopyUserInfo_get(reqinfo, &user_info);

                    if (XFER_PMGR_SetFileCopyDestFileName(entry.file_name) != TRUE)
                    {
                        netsnmp_set_request_error(reqinfo, requests,
                                                  SNMP_ERR_COMMITFAILED);
                    }
                    else if (XFER_PMGR_SetFileCopyAction(&user_info, VAL_fileCopyAction_copy, 0, 0, 0) != TRUE)
                    {
                        netsnmp_set_request_error(reqinfo, requests,
                                                  SNMP_ERR_COMMITFAILED);
                    }
                }
                else
                {
                    netsnmp_set_request_error(reqinfo, requests,
                                              SNMP_ERR_COMMITFAILED);
                }
            }
#endif /* end of #if(SYS_CPNT_3COM_TWO_OPCODES == TRUE) */

            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_probeResetControl(netsnmp_mib_handler *handler,
                     netsnmp_handler_registration *reginfo,
                     netsnmp_agent_request_info *reqinfo,
                     netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode)
    {
        case MODE_GET:
            long_return=VAL_restartControl_running;
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
        break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
        {
            if (requests->requestvb->type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }

            if (   (*requests->requestvb->val.integer < VAL_probeResetControl_running)
                || (*requests->requestvb->val.integer > VAL_probeResetControl_coldBoot))
            {
                return SNMP_ERR_WRONGVALUE;
            }
        }

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */

            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */

        {
            UI32_T restartControl;
            restartControl = (*requests->requestvb->val.integer);
            switch ( restartControl)
            {
                case VAL_restartControl_running: /* set to running just return ok */
                    break;

                case VAL_restartControl_warmBoot:  /* Warm Start*/
#if   (SYS_CPNT_DBSYNC_TXT == TRUE)
                    /* kinghong add for 3com autosave*/
                    if  (!SNMP_MGR_SetTmpDirty(0))
                    SYSFUN_Debug_Printf("autoSave   Fail\n");
#endif
                    STKCTRL_PMGR_WarmStartSystem();
                    break;

             case VAL_restartControl_coldBoot:  /* Cold Start*/
#if(SYS_CPNT_DBSYNC_TXT == TRUE)
                    /* kinghong add for 3com autosave*/
                    if (!SNMP_MGR_SetTmpDirty(0))
                        SYSFUN_Debug_Printf("autoSave   Fail\n");
#endif

#if (SYS_CPNT_3COM_CLI == TRUE)
                    if (!CLI_MGR_InitAndKeepIp())
                    {
                        netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
                    }
#else
                    STKCTRL_PMGR_ColdStartSystem();
#endif
                    break;
            }
        }
        break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */

            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */

            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_probeHardwareRev(netsnmp_mib_handler *handler,
                     netsnmp_handler_registration *reginfo,
                     netsnmp_agent_request_info *reqinfo,
                     netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode)
    {
        case MODE_GET:
        {
            STKTPLG_MGR_Switch_Info_T data;

            memset(&data, 0, sizeof(data));

            /* This variables always  used index = 1 to get*/
            data.sw_unit_index = 1;

            if (!STKTPLG_PMGR_GetSwitchInfo(&data))
            {
                return SNMP_ERR_GENERR;
            }

            strcpy((char *)return_buf, (char *)data.sw_hardware_ver);
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, (u_char *) return_buf, strlen((char *)return_buf));
        }
            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_netDefaultGateway_2(netsnmp_mib_handler *handler,
                     netsnmp_handler_registration *reginfo,
                     netsnmp_agent_request_info *reqinfo,
                     netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode)
    {

        case MODE_GET:
        {
            L_INET_AddrIp_T default_gateway;
            memset(&default_gateway, 0, sizeof(default_gateway));
            default_gateway.type = L_INET_ADDR_TYPE_IPV4;
            default_gateway.addrlen = SYS_ADPT_IPV4_ADDR_LEN;
            NETCFG_PMGR_ROUTE_GetDefaultGateway(&default_gateway);
            IP_LIB_ArraytoUI32(default_gateway.addr, &ipaddr_return);
            snmp_set_var_typed_value(requests->requestvb, ASN_IPADDRESS, (u_char *) &ipaddr_return, sizeof(ipaddr_return));
        }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            if (requests->requestvb->type != ASN_IPADDRESS)
            {
                return SNMP_ERR_WRONGTYPE;
            }

            if (requests->requestvb->val_len != SYS_ADPT_IPV4_ADDR_LEN)
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */

            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
            {
                UI32_T value;
                L_INET_AddrIp_T default_gateway_ip;
                UI32_T ret;
                UI8_T byte_ip[SYS_ADPT_IPV4_ADDR_LEN];
                memset(&default_gateway_ip,0,sizeof(L_INET_AddrIp_T));
                value = (*requests->requestvb->val.integer);

                /* writing 0.0.0.0 needs special treatment: deletion
                 * Zhong Qiyao, 2004.07.22
                 */
                if (value == 0)
                {
                    /* read original gateway */
					default_gateway_ip.type = L_INET_ADDR_TYPE_IPV4;
					default_gateway_ip.addrlen = SYS_ADPT_IPV4_ADDR_LEN;
					NETCFG_PMGR_ROUTE_GetDefaultGateway(&default_gateway_ip);

                    /* delete it */
                    if (default_gateway_ip.addr!= NULL)
                    {
                        ret = NETCFG_PMGR_ROUTE_DeleteDefaultGateway(&default_gateway_ip);

                        if (ret != NETCFG_TYPE_OK)
                        {
                            netsnmp_set_request_error(reqinfo, requests,
                                                      SNMP_ERR_COMMITFAILED);
                        }
                    }
                }
                /* writing non-zero, just set it in */
                else
                {
					default_gateway_ip.type = L_INET_ADDR_TYPE_IPV4;
					IP_LIB_UI32toArray(value, byte_ip);
					memcpy(default_gateway_ip.addr, byte_ip, SYS_ADPT_IPV4_ADDR_LEN);
					default_gateway_ip.addrlen = SYS_ADPT_IPV4_ADDR_LEN;

					if(NETCFG_PMGR_ROUTE_AddDefaultGateway(&default_gateway_ip, SYS_DFLT_DEFAULT_GATEWAY_METRIC)!=NETCFG_TYPE_OK)
                    {
                        netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
                    }
                }
            }
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */

            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */

            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_probeDateTime(netsnmp_mib_handler *handler,
                 netsnmp_handler_registration *reginfo,
                 netsnmp_agent_request_info *reqinfo,
                 netsnmp_request_info *requests)
{
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one.
     */

    switch (reqinfo->mode)
    {
        case MODE_GET:
        {
            UI8_T probe_date_time[11] = {0};
            UI32_T probe_date_time_len = 0;

            if (SYS_TIME_GetDayAndTime(probe_date_time, &probe_date_time_len) == TRUE)
            {
                memcpy(return_buf, probe_date_time, probe_date_time_len);
                snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, (u_char *) return_buf, probe_date_time_len);
            }
            else
            {
                return SNMP_ERR_GENERR;
            }
        }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            if (requests->requestvb->type != ASN_OCTET_STR)
            {
                return SNMP_ERR_WRONGTYPE;
            }

            if (   (requests->requestvb->val_len != SIZE_probeDateTime_2)
                && (requests->requestvb->val_len != SIZE_probeDateTime_3))
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer
             */
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called.
             */
            break;

        case MODE_SET_ACTION:
            /*
             * XXX: perform the value change here
             */
        {
            UI8_T probe_date_time[11] = {0};
            UI32_T probe_date_time_len = 0;

            memcpy(probe_date_time, requests->requestvb->val.string,
                   requests->requestvb->val_len);
            probe_date_time_len = (requests->requestvb->val_len);

        }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage
             */
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object
             */
            break;

        default:
            /*
             * we should never get here, so this is a really bad error
             */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_probeDownloadStatus(netsnmp_mib_handler *handler,
                        netsnmp_handler_registration *reginfo,
                        netsnmp_agent_request_info *reqinfo,
                        netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode)
    {
        case MODE_GET:
        {

            XFER_MGR_FileCopyMgt_T data;
            /* ericali said that this api never return the following values:
            case  VAL_fileCopyStatus_fileCopyTftpCompleted
            case  VAL_fileCopyStatus_fileCopyWriteFlashFinish
            case  VAL_fileCopyStatus_fileCopyWriteFlashProgramming
            case  VAL_fileCopyStatus_fileCopyCompleted
            */
            if (XFER_PMGR_GetFileCopyMgtEntry(&data))
            {
                switch(data.status)
                {
                    case  VAL_fileCopyStatus_fileCopySuccess:
                        long_return=VAL_probeDownloadStatus_downloadSuccess;
                        break;

                    case  VAL_fileCopyStatus_fileCopyUnknown:
                        long_return=VAL_probeDownloadStatus_downloadStatusUnknown;
                        break;

                    case  VAL_fileCopyStatus_fileCopyStorageFull:
                    case  VAL_fileCopyStatus_fileCopyTftpIllegalOperation:
                    case  VAL_fileCopyStatus_fileCopyTftpUnkownTransferId:
                    case  VAL_fileCopyStatus_fileCopyTftpFileExisted:
                    case  VAL_fileCopyStatus_fileCopyTftpSendError:
                    case  VAL_fileCopyStatus_fileCopyTftpNoSuchUser:
                    case  VAL_fileCopyStatus_fileCopyTftpReceiverError:
                    case  VAL_fileCopyStatus_fileCopyTftpSocketOpenError:
                    case  VAL_fileCopyStatus_fileCopyTftpSocketBindError:
                    case  VAL_fileCopyStatus_fileCopyTftpUserCancel:
                    case  VAL_fileCopyStatus_fileCopyParaError:
                    case  VAL_fileCopyStatus_fileCopyBusy:
                    case  VAL_fileCopyStatus_fileCopyReadFileError:
                    case  VAL_fileCopyStatus_fileCopySetStartupError:
                    case  VAL_fileCopyStatus_fileCopyFileSizeExceed:
                    case  VAL_fileCopyStatus_fileCopyMagicWordError:
                    case  VAL_fileCopyStatus_fileCopyImageTypeError:
                    case  VAL_fileCopyStatus_fileCopyWriteFlashError:
                    case  VAL_fileCopyStatus_fileCopyError:
                        long_return=VAL_probeDownloadStatus_downloadGeneralError;
                        break;

                    case  VAL_fileCopyStatus_fileCopyTimeout:
                        long_return=VAL_probeDownloadStatus_downloadNoResponseFromServer;
                        break;

                    case  VAL_fileCopyStatus_fileCopyHeaderChecksumError:
                    case  VAL_fileCopyStatus_fileCopyImageChecksumError:
                        long_return=VAL_probeDownloadStatus_downloadChecksumError;
                        break;

                    case  VAL_fileCopyStatus_fileCopyFileNotFound:
                        long_return=VAL_probeDownloadStatus_downloadTftpFileNotFound;
                        break;

                    case  VAL_fileCopyStatus_fileCopyServerPermissionDenied:
                        long_return=VAL_probeDownloadStatus_downloadTftpAccessViolation;
                        break;

                    default:
                        SYSFUN_Debug_Printf ("\r\nrfc2021.c: XFER_MGR_GetFileCopyMgtEntry gives unrecognised status\r\n");
                        long_return=VAL_probeDownloadStatus_downloadStatusUnknown;
                        break;
                }
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *)&long_return, sizeof(long_return));
            }
        }
        break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}


/*
 * trapDestTable2_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid             trapDestTable2_variables_oid[] =
    { 1, 3, 6, 1, 2, 1, 16, 19 };

/*
 * variable4 trapDestTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */

struct variable3 trapDestTable2_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */

    {TRAPDESTCOMMUNITY, ASN_OCTET_STR, RWRITE, var_trapDestTable2, 3,
     {13, 1, 2}},
    {TRAPDESTPROTOCOL, ASN_INTEGER, RWRITE, var_trapDestTable2, 3,
     {13, 1, 3}},
    {TRAPDESTADDRESS, ASN_OCTET_STR, RWRITE, var_trapDestTable2, 3,
     {13, 1, 4}},
    {TRAPDESTOWNER, ASN_OCTET_STR, RWRITE, var_trapDestTable2, 3,
     {13, 1, 5}},
    {TRAPDESTSTATUS, ASN_INTEGER, RWRITE, var_trapDestTable2, 3,
     {13, 1, 6}},
};
/*
 * (L = length of the oidsuffix)
 */


/** Initializes the trapDestTable module */
void
init_trapDestTable2(void)
{

    DEBUGMSGTL(("trapDestTable2", "Initializing\n"));

    /*
     * register ourselves with the agent to handle our mib tree
     */
    REGISTER_MIB("trapDestTable2", trapDestTable2_variables, variable3,
                 trapDestTable2_variables_oid);

    /*
     * place any other initialization junk you need here
     */
}



static int
header_trapDestTable2(struct variable *vp,
               oid * name,
               size_t * length,
               int exact, size_t * var_len, WriteMethod ** write_method)
{
#define OID_NAME_LENGTH 11
    oid             newname[MAX_OID_LEN];
    UI32_T         interface;
    int             result;
    SNMP_MGR_TrapDestEntry_T  entry;
    UI32_T ifIndex = 0;
    BOOL_T return_val;
    memcpy((char *) newname, (char *) vp->name,
           (int) vp->namelen * sizeof(oid));
    /*
     * find "next" interface
     */

     while (  (return_val= SNMP_MGR_GetNextTrapReceiverByIndex( &ifIndex,&entry))==SNMP_MGR_ERROR_OK)
     {
        newname[OID_NAME_LENGTH] = (oid) ifIndex;
        result =
            snmp_oid_compare(name, *length, newname,
                             (int) vp->namelen + 1);
        if ((exact && (result == 0)) || (!exact && (result < 0)))
            break;
    }
    if (return_val!= SNMP_MGR_ERROR_OK ) {
        DEBUGMSGTL(("mibII/interfaces", "... index out of range\n"));
        return MATCH_FAILED;
    }


    memcpy((char *) name, (char *) newname,
           ((int) vp->namelen + 1) * sizeof(oid));
    *length = vp->namelen + 1;
    *write_method = 0;
    *var_len = sizeof(long);    /* default to 'long' results */
    interface = newname[OID_NAME_LENGTH];

    DEBUGMSGTL(("mibII/interfaces", "... get I/F stats "));
    DEBUGMSGOID(("mibII/interfaces", name, *length));
    DEBUGMSG(("mibII/interfaces", "\n"));

    return interface;
}

/* This entry is used for entry which have the ability to row create*/
static SNMP_MGR_TrapDestEntry_T trapDestEntry;



/*
 * var_trapDestTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_trapDestTable2(struct variable *vp,
                  oid * name,
                  size_t * length,
                  int exact, size_t * var_len, WriteMethod ** write_method)
{
    SNMP_MGR_TrapDestEntry_T  entry;
    int             interface;

    /* Give default value for the record first
     * We use the row_status = 0 to indicate if this set operation is Set by field
     * or set by record(included row creation), if the row_status =0, this record
     * mean set by field, otherwise, we just think it is a normal set operation
     */
    if (SNMP_MGR_GetDefaultTrapDestEntry (&trapDestEntry)!= SNMP_MGR_ERROR_OK)
    {
        return NULL;
    }
    trapDestEntry.trap_dest_status = 0;

    switch(vp->magic)
    {
        case TRAPDESTCOMMUNITY:
            *write_method = write_trapDestCommunity2;
            strcpy((char *)return_buf, entry.trap_dest_community);
            break;

        case TRAPDESTPROTOCOL:
            *write_method = write_trapDestProtocol2;
            break;

        case TRAPDESTADDRESS:
            *write_method = write_trapDestAddress2;
            break;

        case TRAPDESTOWNER:
            *write_method = write_trapDestOwner2;
            break;

        case TRAPDESTSTATUS:
            *write_method = write_trapDestStatus2;
            break;

        default:
            *write_method =0;
    }

    memset( &entry, 0, sizeof(entry));
    interface =
        header_trapDestTable2(vp, name, length, exact, var_len, write_method);
    if (interface == MATCH_FAILED)
        return NULL;

    if (SNMP_MGR_GetTrapReceiverByIndex(interface, &entry)!= SNMP_MGR_ERROR_OK)
        return NULL;

    /*
     * * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic)
    {
      case TRAPDESTCOMMUNITY:
          *write_method = write_trapDestCommunity2;
          strcpy((char *)return_buf, entry.trap_dest_community);
          *var_len= strlen((char *)return_buf);
          return (u_char*)return_buf;

      case TRAPDESTPROTOCOL:
          *write_method = write_trapDestProtocol2;
          long_return = VAL_trapDestProtocol_ip;
          return (u_char*) &long_return;

      case TRAPDESTADDRESS:
      {
          UI16_T   udpport16;

          *write_method = write_trapDestAddress2;
          memcpy( return_buf, (UI8_T*)&entry.trap_dest_address, sizeof(UI32_T));
          udpport16 = (UI16_T)entry.trap_dest_port;
          memcpy( &return_buf[4], &udpport16, 2);
          //return_buf[4] = 0;
          //return_buf[5] = 162;
          *var_len= 6;
          return (u_char*)return_buf;
      }

      case TRAPDESTOWNER:
          *write_method = write_trapDestOwner2;
          strcpy((char *)return_buf, entry.trap_dest_owner);
          *var_len= strlen((char *)return_buf);
          return (u_char*)return_buf;

      case TRAPDESTSTATUS:
          *write_method = write_trapDestStatus2;
          long_return = entry.trap_dest_status;
          return (u_char*) &long_return;

      default:
          ERROR_MSG("");
    }
    return NULL;
}


int
write_trapDestCommunity2(int action,
                        u_char * var_val,
                        u_char var_val_type,
                        size_t var_val_len,
                        u_char * statP, oid * name, size_t name_len)
{
    UI32_T oid_name_length = 11;

      /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch ( action )
    {
        case RESERVE1:
            if (var_val_type != ASN_OCTET_STR)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(char)*SYS_ADPT_MAX_COMM_STR_NAME_LEN) {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;

        case RESERVE2:
            /* In reserve2, we overwrite the set value to trapDestEntry*/
            memcpy(trapDestEntry.trap_dest_community, var_val, var_val_len);
            trapDestEntry.trap_dest_community[var_val_len]=0;
            break;

        case FREE:
            /* Release any resources that have been allocated */
            break;

        case ACTION:
            /* For row creation, if row_status =0, mean that this is a normal
             * operation, we do the normal set operation, otherwise it is a row
             * creation operation, will do nothing here, and the overall entry
             * will perform in the write_xxxRowStatus function.
             */
            if (trapDestEntry.trap_dest_status == 0)
            {
                if (!L_STDLIB_StrIsAsciiPrintWithCount(trapDestEntry.trap_dest_community, var_val_len))
                {
                    return SNMP_ERR_COMMITFAILED;
                }
                if (SNMP_MGR_ERROR_OK!=SNMP_MGR_SetTrapReceiverCommStringNameByIndex (name[11], (UI8_T *)(trapDestEntry.trap_dest_community)))
                {
                    return SNMP_ERR_COMMITFAILED;
                }
            }
            break;

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_trapDestProtocol2(int action,
                       u_char * var_val,
                       u_char var_val_type,
                       size_t var_val_len,
                       u_char * statP, oid * name, size_t name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;

        case RESERVE2:
            /* In reserve2, we overwrite the set value to trapDestEntry*/
            trapDestEntry.trap_dest_protocol = *(long *)var_val;
            if (trapDestEntry.trap_dest_protocol != 1)
               return SNMP_ERR_WRONGVALUE;
            break;

        case FREE:
            /*
             * Release any resources that have been allocated
             */
            break;

        case ACTION:
            /* For row creation, if row_status =0, mean that this is a normal
              * operation, we do the normal set operation, otherwise it is a row
              * creation operation, will do nothing here, and the overall entry
              * will perform in the write_xxxRowStatus function.
             */
              if (trapDestEntry.trap_dest_status == 0)
              {
                  /* not support set operation*/
              }
            break;

        case UNDO:
            /*
             * Back out any changes made in the ACTION case
             */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }

    return SNMP_ERR_NOERROR;
}

int
write_trapDestAddress2(int action,
                      u_char * var_val,
                      u_char var_val_type,
                      size_t var_val_len,
                      u_char * statP, oid * name, size_t name_len)
{

    UI32_T oid_name_length = 11;

      /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch ( action )
    {
        case RESERVE1:
        {
            UI8_T iIp[SYS_ADPT_IPV4_ADDR_LEN] = {0};
            if (var_val_type != ASN_OCTET_STR)
            {
                return SNMP_ERR_WRONGTYPE;
            }

            memcpy(iIp,var_val, 4);

            if ((var_val_len < sizeof(char)*4)||(var_val_len > sizeof(char)*6))
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            if ( IP_LIB_IsValidForNetworkInterface(iIp)!= TRUE)
            {
                return SNMP_ERR_WRONGVALUE;
            }
        }
            break;

        case RESERVE2:
            /* In reserve2, we overwrite the set value to trapDestEntry*/
            memcpy(&trapDestEntry.trap_dest_address, var_val, 4);
            if (var_val_len <6)
            {
                trapDestEntry.trap_dest_port = 162;
            }
            else
            {
                trapDestEntry.trap_dest_port = ntohs((var_val[4]<<8) + var_val[5]);
            }
            break;
        case FREE:
            /* Release any resources that have been allocated */
            break;

        case ACTION:
            /* For row creation, if row_status =0, mean that this is a normal
            * operation, we do the normal set operation, otherwise it is a row
            * creation operation, will do nothing here, and the overall entry
            * will perform in the write_xxxRowStatus function.
            */
            if (trapDestEntry.trap_dest_status == 0)
            {
                if (SNMP_MGR_ERROR_OK!=SNMP_MGR_SetTrapDestAddressByIndex (name[11], trapDestEntry.trap_dest_port, &trapDestEntry.trap_dest_address) )
                {
                    return SNMP_ERR_COMMITFAILED;
                }
            }
            break;

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }

    return SNMP_ERR_NOERROR;
}

int
write_trapDestOwner2(int action,
                    u_char * var_val,
                    u_char var_val_type,
                    size_t var_val_len,
                    u_char * statP, oid * name, size_t name_len)
{
    UI32_T oid_name_length = 11;

    /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch ( action )
    {
        case RESERVE1:
            if (var_val_type != ASN_OCTET_STR)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(char)*MAXSIZE_trapDestOwner)
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;

        case RESERVE2:
            /* In reserve2, we overwrite the set value to trapDestEntry*/
            memcpy(trapDestEntry.trap_dest_owner, var_val, var_val_len);
            trapDestEntry.trap_dest_owner[var_val_len]=0;
            break;
        case FREE:
            /* Release any resources that have been allocated */
            break;

        case ACTION:
            /* For row creation, if row_status =0, mean that this is a normal
             * operation, we do the normal set operation, otherwise it is a row
             * creation operation, will do nothing here, and the overall entry
             * will perform in the write_xxxRowStatus function.
             */
            if (trapDestEntry.trap_dest_status == 0)
            {
                if (!L_STDLIB_StrIsAsciiPrintWithCount(trapDestEntry.trap_dest_owner, var_val_len))
                {
                    return SNMP_ERR_COMMITFAILED;
                }
                if (SNMP_MGR_ERROR_OK!=SNMP_MGR_SetTrapDestOwnerByIndex (name[11], (UI8_T *)(trapDestEntry.trap_dest_owner)))
                {
                    return SNMP_ERR_COMMITFAILED;
                }
             }
             break;

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }

    return SNMP_ERR_NOERROR;
}

int
write_trapDestStatus2(int action,
                     u_char * var_val,
                     u_char var_val_type,
                     size_t var_val_len,
                     u_char * statP, oid * name, size_t name_len)
{
    UI32_T value;
    UI32_T oid_name_length = 11;

      /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch (action)
    {
        case RESERVE1:
        {
            value = *(long *)var_val;

            if ((value < 1) || (value > 6))
                return SNMP_ERR_WRONGVALUE;

            break;
        }

        case RESERVE2:
        {
            /* In reserve2, we overwrite the set value to trapDestEntry*/
            trapDestEntry.trap_dest_status = *(long *)var_val;
            break;
        }

        case FREE:
            /* Release any resources that have been allocated */
            break;

        case ACTION:
        {
            SNMP_MGR_TrapDestEntry_T entry;
            UI32_T status;

            status = *(long *)var_val;

            /* give default value for the record first */
            if (SNMP_MGR_ERROR_OK != SNMP_MGR_GetDefaultTrapDestEntry(&entry))
            {
                return SNMP_ERR_COMMITFAILED;
            }
            if (status == VAL_trapDestStatus_createAndGo)
            {
                if (SNMP_MGR_SetTrapDestEntryByIndex(name[11], &trapDestEntry) != SNMP_MGR_ERROR_OK)
                {
                    return SNMP_ERR_COMMITFAILED;
                }
            }
            else if (status == VAL_trapDestStatus_active)
            {
                if (SNMP_MGR_ERROR_OK!=SNMP_MGR_GetTrapReceiverByIndex(name[11],&entry))
                {
                        return SNMP_ERR_COMMITFAILED;
                }
            }
           else if (status == VAL_trapDestStatus_createAndWait)
           {
               if (SNMP_MGR_SetTrapDestEntryByIndex(name[11], &trapDestEntry) != SNMP_MGR_ERROR_OK)
               {
                   return SNMP_ERR_COMMITFAILED;
               }
           }
           else if (status == VAL_trapDestStatus_destroy)
           {
               SNMP_MGR_TrapDestEntry_T trap_receiver;

               /* Check if the entry(v1 or v2) exists, if not, return failed
                */
               if (SNMP_MGR_GetTrapReceiverByIndex(name[11], &trap_receiver) != SNMP_MGR_ERROR_OK)
                   return SNMP_ERR_COMMITFAILED;

               entry.trap_dest_status = 6;

               if (SNMP_MGR_SetTrapReceiverStatusByIndex(name[11],entry.trap_dest_status)!=SNMP_MGR_ERROR_OK)
               {
                   return SNMP_ERR_COMMITFAILED;
               }
           }
           else
           {
               return SNMP_ERR_COMMITFAILED;
           }
           break;
        }

        case UNDO:
             /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
            break;
    }

    return SNMP_ERR_NOERROR;
}

/********************************************
 ****************netConfigTable****************
 ********************************************
 */

/*
 * netConfigTable_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */
oid netConfigTable2_variables_oid[] = {SNMP_OID_MIB2, 16, 19};

/*
 * variable4 netConfigTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */

struct variable3 netConfigTable2_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */
    {NETCONFIGIPADDRESS2, ASN_IPADDRESS, RWRITE, var_netConfigTable2, 3,
     {11, 1, 1}},
    {NETCONFIGSUBNETMASK2, ASN_IPADDRESS, RWRITE, var_netConfigTable2, 3,
     {11, 1, 2}},
    {NETCONFIGSTATUS2, ASN_INTEGER, RWRITE, var_netConfigTable2, 3,
     {11, 1, 3}},
};
/*
 * (L = length of the oidsuffix)
 */


/** Initializes the netConfigTable module */
void
init_netConfigTable2(void)
{

    DEBUGMSGTL(("netConfigTable2", "Initializing\n"));

    /*
     * register ourselves with the agent to handle our mib tree
     */
    REGISTER_MIB("netConfigTable2", netConfigTable2_variables, variable3,
                 netConfigTable2_variables_oid);

    /*
     * place any other initialization junk you need here
     */
}

#define netConfigEntry_INSTANCE_LEN 1

/* FUNCTION NAME : netConfigTable2_get
 * PURPOSE:
 *          It is called for get data.
 * INPUT:
 *          compc -- the counter of the index
 *        compl  -- the list of the index
 *        data       -- the data storage
 *
 * OUTPUT:
 *          data
 * RETURN:
 *          TRUE:
 *        FALSE:
 * NOTES:
 *
 */
 /* use NETCFG_MGR_GetRifConfigFromInterface function */

static BOOL_T netConfigTable2_get(int      compc,
                                oid     *compl,
                                NETCFG_TYPE_InetRifConfig_T *data)
{
    UI32_T  vid_ifIndex = 0;

    if (compc != netConfigEntry_INSTANCE_LEN)
    {
         return FALSE;
    }

   vid_ifIndex= compl[0];

   if(SNMP_MGR_IsDebugMode())
       SYSFUN_Debug_Printf("netConfigTable2_get:data->vid_ifIndex=[%lu]\n", vid_ifIndex);
   data->ifindex = vid_ifIndex;
   data->addr.type = L_INET_ADDR_TYPE_IPV4;
   data->addr.addrlen = SYS_ADPT_IPV4_ADDR_LEN;
   if (NETCFG_POM_IP_GetPrimaryRifFromInterface(data) != NETCFG_TYPE_OK)
    {
        if(SNMP_MGR_IsDebugMode())
            SYSFUN_Debug_Printf("netConfigTable2_get:NETCFG_GetRifInfo return false\n");

        return FALSE;
    }
    else
    {
        return TRUE;
    }
}


 /* use NETCFG_MGR_GetNextRifFromInterface and  NETCFG_MGR_GetRifConfig function*/


static BOOL_T netConfigTable2_next(int      compc,
                                 oid     *compl,
                                 NETCFG_TYPE_InetRifConfig_T    *data)
{
    UI32_T  vid_ifIndex = 0;
    UI32_T	mode = 0;

    vid_ifIndex=compl[0];

    if(SNMP_MGR_IsDebugMode())
        SYSFUN_Debug_Printf("netConfigTable2_next:data->vid_ifIndex=[%lu]\n", vid_ifIndex);

    if (compc < netConfigEntry_INSTANCE_LEN)
    {
       /*get vid_ifindex = 0
        */
	   data->ifindex = vid_ifIndex;
	   data->addr.type = L_INET_ADDR_TYPE_IPV4;
	   data->addr.addrlen = SYS_ADPT_IPV4_ADDR_LEN;
	   if (NETCFG_POM_IP_GetPrimaryRifFromInterface(data) == NETCFG_TYPE_OK)
        {
            return TRUE;
        }
    }

    if(NETCFG_POM_IP_GetNextIpAddressMode(&vid_ifIndex, &mode) == NETCFG_TYPE_OK)
    {
		data->ifindex = vid_ifIndex;
		data->addr.type = L_INET_ADDR_TYPE_IPV4;
		data->addr.addrlen = SYS_ADPT_IPV4_ADDR_LEN;
        if (NETCFG_POM_IP_GetNextRifFromInterface(data) == NETCFG_TYPE_OK)
        {

            if ((NETCFG_POM_IP_GetRifConfig(data))==NETCFG_TYPE_OK)
            {
                return TRUE;
            }
        }
    }

    if(SNMP_MGR_IsDebugMode())
        SYSFUN_Debug_Printf("netConfigTable2_next: get return false\n");
    return FALSE;
}


/*
 * var_netConfigTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */

unsigned char  *
var_netConfigTable2(struct variable *vp,
                   oid * name,
                   size_t * length,
                   int exact,
                   size_t * var_len, WriteMethod ** write_method)
{

    /*
     * variables we may use later
     */
    UI32_T compc=0;
    oid compl[netConfigEntry_INSTANCE_LEN]={0};
    oid best_inst[netConfigEntry_INSTANCE_LEN]={0};
    NETCFG_TYPE_InetRifConfig_T rif_config;

    /*
     * * this is where we do the value assignments for the mib results.
     */

    /* init */
    memset(&rif_config, 0, sizeof(rif_config));

    switch (vp->magic)
    {
        case NETCONFIGIPADDRESS2:
            *write_method = write_netConfigIPAddress2;
            break;

        case NETCONFIGSUBNETMASK2:
            *write_method = write_netConfigSubnetMask2;
            break;

        case NETCONFIGSTATUS2:
            *write_method = write_netConfigStatus2;
            break;

        default:
            *write_method = 0;
            break;
    }

    /*check compc, retrive compl*/
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,compl, netConfigEntry_INSTANCE_LEN);

    if (exact)/*get,set*/
    {
        if (!netConfigTable2_get(compc, compl, &rif_config))
        return NULL;
    }
    else/*getnext*/
    {
        if (!netConfigTable2_next(compc, compl, &rif_config))
        {
            return NULL;
        }
    }

    memcpy(name, vp->name, vp->namelen*sizeof(oid));
    best_inst[0]= rif_config.ifindex;

    memcpy(name + vp->namelen, best_inst, netConfigEntry_INSTANCE_LEN*sizeof(oid));
    *length = vp->namelen +netConfigEntry_INSTANCE_LEN;

    *var_len = sizeof(long_return);

    /*
     * * this is where we do the value assignments for the mib results.
     */
    switch(vp->magic)
    {
        case NETCONFIGIPADDRESS2:
            *var_len = sizeof(ipaddr_return);
            IP_LIB_ArraytoUI32(rif_config.addr.addr, &ipaddr_return);
            return (u_char*) &ipaddr_return;

        case NETCONFIGSUBNETMASK2:
            *var_len = sizeof(ipaddr_return);
            L_PREFIX_MaskLen2Ip(rif_config.addr.preflen, &ipaddr_return);
            return (u_char*) &ipaddr_return;
        case NETCONFIGSTATUS2:
            long_return = rif_config.row_status;
            return (u_char*) &long_return;

        default:
            ERROR_MSG("");
    }

    return NULL;
}


int
write_netConfigIPAddress2(int action,
                         u_char * var_val,
                         u_char var_val_type,
                         size_t var_val_len,
                         u_char * statP, oid * name, size_t name_len)
{
    u_long          value;
    UI32_T oid_name_length = 11;

    /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  netConfigEntry_INSTANCE_LEN + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch (action)
    {
    case RESERVE1:
        if (var_val_type != ASN_IPADDRESS)
        {
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len != SYS_ADPT_IPV4_ADDR_LEN)
        {
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        break;

    case FREE:
        /*
         * Release any resources that have been allocated
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
    {
        UI32_T vid_ifIndex =0;
        NETCFG_TYPE_InetRifConfig_T      data;

        vid_ifIndex = name[oid_name_length];
        memcpy(&value, var_val, var_val_len);

		data.ifindex = vid_ifIndex;
		data.addr.type = L_INET_ADDR_TYPE_IPV4;
		data.addr.addrlen = SYS_ADPT_IPV4_ADDR_LEN;
		if(NETCFG_POM_IP_GetPrimaryRifFromInterface(&data) != NETCFG_TYPE_OK)
        {
            return SNMP_ERR_COMMITFAILED;
        }
		if(IP_LIB_UI32toArray(value, data.addr.addr)!=IP_LIB_OK)
		{
			return SNMP_ERR_COMMITFAILED;
		}
		data.row_status = VAL_netConfigStatus_2_createAndGo;
		if(NETCFG_PMGR_IP_SetInetRif(&data, NETCFG_TYPE_IP_CONFIGURATION_TYPE_CLI_WEB) != NETCFG_TYPE_OK)
		{
			return SNMP_ERR_COMMITFAILED;
		}
        break;
    }

    case UNDO:
        /*
         * Back out any changes made in the ACTION case
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }

    return SNMP_ERR_NOERROR;
}


int
write_netConfigSubnetMask2(int action,
                         u_char * var_val,
                         u_char var_val_type,
                         size_t var_val_len,
                         u_char * statP, oid * name, size_t name_len)
{
    u_long          value;
    UI32_T oid_name_length = 11;

    /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  netConfigEntry_INSTANCE_LEN + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_IPADDRESS)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len != SYS_ADPT_IPV4_ADDR_LEN)
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;

        case RESERVE2:
            break;

        case FREE:
            /*
             * Release any resources that have been allocated
             */
            break;

        case ACTION:
            /*
             * The variable has been stored in 'value' for you to use,
             * and you have just been asked to do something with it.
             * Note that anything done here must be reversable in the UNDO case
             */
        {
            UI32_T vid_ifIndex =0;
            NETCFG_TYPE_InetRifConfig_T      data;

            memset(&data,0,sizeof(data));
            vid_ifIndex = name[oid_name_length];
            memcpy(&value, var_val, var_val_len);
			data.ifindex = vid_ifIndex;
			data.addr.type = L_INET_ADDR_TYPE_IPV4;
			data.addr.addrlen = SYS_ADPT_IPV4_ADDR_LEN;
			if (NETCFG_POM_IP_GetPrimaryRifFromInterface(&data) != NETCFG_TYPE_OK)
            {
                return SNMP_ERR_COMMITFAILED;
            }
			data.addr.preflen = L_PREFIX_Ip2MaskLen(value);
			data.row_status = VAL_netConfigStatus_2_createAndGo;
            if(NETCFG_PMGR_IP_SetInetRif(&data, NETCFG_TYPE_IP_CONFIGURATION_TYPE_CLI_WEB) != NETCFG_TYPE_OK)
            {
                return SNMP_ERR_COMMITFAILED;
            }
            break;
        }

        case UNDO:
            /*
             * Back out any changes made in the ACTION case
             */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }

    return SNMP_ERR_NOERROR;
}


int
write_netConfigStatus2(int action,
                      u_char * var_val,
                      u_char var_val_type,
                      size_t var_val_len,
                      u_char * statP, oid * name, size_t name_len)
{
    long            value;
   // UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
    UI32_T oid_name_length = 11;

   /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  netConfigEntry_INSTANCE_LEN + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }

    case RESERVE2:
    {
        value = *(long *)var_val;
        if((value < VAL_netConfigStatus_2_active) || (value > VAL_netConfigStatus_2_destroy))
        return SNMP_ERR_WRONGVALUE;
        break;
    }

    case FREE:
        /*
         * Release any resources that have been allocated
         */
        break;

    case ACTION:
    {
        UI32_T vid_ifIndex =0,temp_vid_ifindex=0;
        UI32_T mode=0;
        NETCFG_TYPE_InetRifConfig_T      data;

        vid_ifIndex = name[oid_name_length];
        value = *(long *)var_val;

        /*We can change othe magement vlan using old IP.*/
        if(value==VAL_netConfigStatus_2_createAndGo)
        {
			if(NETCFG_POM_IP_GetNextIpAddressMode(&temp_vid_ifindex, &mode) == NETCFG_TYPE_OK)
			{
				data.ifindex = temp_vid_ifindex;
				data.addr.type = L_INET_ADDR_TYPE_IPV4;
				data.addr.addrlen = SYS_ADPT_IPV4_ADDR_LEN;
				if (NETCFG_POM_IP_GetNextRifFromInterface(&data) == NETCFG_TYPE_OK)
				{
					if ((NETCFG_POM_IP_GetRifConfig(&data))==NETCFG_TYPE_OK)
                    {
                    	data.ifindex = vid_ifIndex;
						data.row_status = value;
						if(NETCFG_PMGR_IP_SetInetRif(&data, NETCFG_TYPE_IP_CONFIGURATION_TYPE_CLI_WEB) != NETCFG_TYPE_OK)
                        {
                            break;
                        }
                    }
                }
            }
            return SNMP_ERR_COMMITFAILED;
        }
        else
        {
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }

    case UNDO:
        /*
         * Back out any changes made in the ACTION case
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }

    return SNMP_ERR_NOERROR;
}


