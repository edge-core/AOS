/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.old-api.conf,v 1.2 2002/07/18 15:37:37 dts12 Exp $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "rfc_2737.h"
#include "sysORTable.h"
#include "stktplg_pmgr.h"
#include "sys_type.h"
#include "leaf_2737.h"
#include "l_charset.h"

/*
 * entPhysicalTable_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid entity_mib_modules_oid[]= { SNMP_OID_MIB2, 47 };
oid entPhysicalTable_variables_oid[] = { 1,3,6,1,2,1,47,1,1 };

/*
 * variable4 entPhysicalTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */

struct variable3 entPhysicalTable_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */

#define ENTPHYSICALINDEX		1
{ENTPHYSICALINDEX,  ASN_INTEGER,  NOACCESS,   var_entPhysicalTable, 3,  { 1, 1, 1 }},
#define ENTPHYSICALDESCR		2
{ENTPHYSICALDESCR,  ASN_OCTET_STR,  RONLY,   var_entPhysicalTable, 3,  { 1, 1, 2 }},
#define ENTPHYSICALVENDORTYPE		3
{ENTPHYSICALVENDORTYPE,  ASN_OBJECT_ID,  RONLY,   var_entPhysicalTable, 3,  { 1, 1, 3 }},
#define ENTPHYSICALCONTAINEDIN		4
{ENTPHYSICALCONTAINEDIN,  ASN_INTEGER,  RONLY,   var_entPhysicalTable, 3,  { 1, 1, 4 }},
#define ENTPHYSICALCLASS		5
{ENTPHYSICALCLASS,  ASN_INTEGER,  RONLY,   var_entPhysicalTable, 3,  { 1, 1, 5 }},
#define ENTPHYSICALPARENTRELPOS		6
{ENTPHYSICALPARENTRELPOS,  ASN_INTEGER,  RONLY,   var_entPhysicalTable, 3,  { 1, 1, 6 }},
#define ENTPHYSICALNAME		7
{ENTPHYSICALNAME,  ASN_OCTET_STR,  RONLY,   var_entPhysicalTable, 3,  { 1, 1, 7 }},
#define ENTPHYSICALHARDWAREREV		8
{ENTPHYSICALHARDWAREREV,  ASN_OCTET_STR,  RONLY,   var_entPhysicalTable, 3,  { 1, 1, 8 }},
#define ENTPHYSICALFIRMWAREREV		9
{ENTPHYSICALFIRMWAREREV,  ASN_OCTET_STR,  RONLY,   var_entPhysicalTable, 3,  { 1, 1, 9 }},
#define ENTPHYSICALSOFTWAREREV		10
{ENTPHYSICALSOFTWAREREV,  ASN_OCTET_STR,  RONLY,   var_entPhysicalTable, 3,  { 1, 1, 10 }},
#define ENTPHYSICALSERIALNUM		11
{ENTPHYSICALSERIALNUM,  ASN_OCTET_STR,  RWRITE,  var_entPhysicalTable, 3,  { 1, 1, 11 }},
#define ENTPHYSICALMFGNAME		12
{ENTPHYSICALMFGNAME,  ASN_OCTET_STR,  RONLY,   var_entPhysicalTable, 3,  { 1, 1, 12 }},
#define ENTPHYSICALMODELNAME		13
{ENTPHYSICALMODELNAME,  ASN_OCTET_STR,  RONLY,   var_entPhysicalTable, 3,  { 1, 1, 13 }},
#define ENTPHYSICALALIAS		14
{ENTPHYSICALALIAS,  ASN_OCTET_STR,  RWRITE,  var_entPhysicalTable, 3,  { 1, 1, 14 }},
#define ENTPHYSICALASSETID		15
{ENTPHYSICALASSETID,  ASN_OCTET_STR,  RWRITE,  var_entPhysicalTable, 3,  { 1, 1, 15 }},
#define ENTPHYSICALISFRU		16
{ENTPHYSICALISFRU,  ASN_INTEGER,  RONLY,   var_entPhysicalTable, 3,  { 1, 1, 16 }},
};
/*    (L = length of the oidsuffix) */


/** Initializes the entPhysicalTable module */
void
init_entPhysicalTable(void)
{

    DEBUGMSGTL(("entPhysicalTable", "Initializing\n"));

    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("entPhysicalTable", entPhysicalTable_variables, variable3,
               entPhysicalTable_variables_oid);

     REGISTER_SYSOR_ENTRY(entity_mib_modules_oid,
                         "The Rfc2737 Entity MIB.");

    /* place any other initialization junk you need here */
}

static int
header_entPhysicalTable(struct variable *vp,
               oid * name,
               size_t * length,
               int exact, size_t * var_len, WriteMethod ** write_method)
{
#define OID_NAME_LENGTH	12
    oid             newname[MAX_OID_LEN];
    int    interface;
    int             result;
   STKTPLG_OM_EntPhysicalEntry_T  entry;
   UI32_T  ifIndex = 0;
   BOOL_T return_val;


    memcpy((char *) newname, (char *) vp->name,
           (int) vp->namelen * sizeof(oid));
    /*
     * find "next" interface
     */

    memset(&entry, 0, sizeof(entry));

     while (  (return_val= STKTPLG_OM_GetNextEntPhysicalEntry( &entry))==TRUE)
     {
        ifIndex = entry.ent_physical_index;
        newname[OID_NAME_LENGTH] = (oid) ifIndex;
        result =
            snmp_oid_compare(name, *length, newname,
                             (int) vp->namelen + 1);
        if ((exact && (result == 0)) || (!exact && (result < 0)))
            break;
    }
    if (!return_val ) {
        return MATCH_FAILED;
    }


    memcpy((char *) name, (char *) newname,
           ((int) vp->namelen + 1) * sizeof(oid));
    *length = vp->namelen + 1;
    *write_method = 0;
    *var_len = sizeof(long);    /* default to 'long' results */
    interface = newname[OID_NAME_LENGTH];


    return interface;
}


/*
 * var_entPhysicalTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *
var_entPhysicalTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{
   STKTPLG_OM_EntPhysicalEntry_T  entry;
    int             interface;



   memset( &entry, 0, sizeof(entry));
    interface =
        header_entPhysicalTable(vp, name, length, exact, var_len, write_method);
    if (interface == MATCH_FAILED)
        return NULL;


   entry.ent_physical_index = interface;
   if (STKTPLG_OM_GetEntPhysicalEntry( &entry)!= TRUE)
            return NULL;

    /*
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {

     case ENTPHYSICALDESCR:
        strcpy((char*)return_buf, (char*)entry.ent_physical_descr);
        *var_len = strlen((char*)return_buf);
        return (u_char*) return_buf;
     case ENTPHYSICALVENDORTYPE:
       {
        memcpy ( oid_return, entry.ent_physical_vendor_type.component_list,  entry.ent_physical_vendor_type.num_components * sizeof(oid));
        *var_len = entry.ent_physical_vendor_type.num_components * sizeof(oid);
        return (u_char*) oid_return;
       }
     case ENTPHYSICALCONTAINEDIN:
       long_return =entry.ent_physical_contained_in;
        return (u_char*) &long_return ;
     case ENTPHYSICALCLASS:
         long_return =entry.ent_physical_class;
        return (u_char*) &long_return ;
     case ENTPHYSICALPARENTRELPOS:
         long_return =entry.ent_physical_parent_rel_pos;
        return (u_char*) &long_return ;
     case ENTPHYSICALNAME:
         strcpy( (char*)return_buf, (char*)entry.ent_physical_name);
         *var_len = strlen((char*)return_buf);
         return (u_char*) return_buf;
     case ENTPHYSICALHARDWAREREV:
         strcpy( (char*)return_buf, (char*)entry.ent_physical_hardware_rev);
         *var_len = strlen((char*)return_buf);
         return (u_char*) return_buf;
     case ENTPHYSICALFIRMWAREREV:
        strcpy((char*)return_buf, (char*)entry.ent_physical_firmware_rev);
        *var_len = strlen((char*)return_buf);
         return (u_char*) return_buf;
     case ENTPHYSICALSOFTWAREREV:
        strcpy((char*)return_buf, (char*)entry.ent_physical_software_rev);
        *var_len = strlen((char*)return_buf);
         return (u_char*) return_buf;
     case ENTPHYSICALSERIALNUM:
        *write_method = write_entPhysicalSerialNum;
         strcpy((char*)return_buf, (char*)entry.ent_physical_entry_rw.ent_physical_serial_num);
         *var_len = strlen((char*)return_buf);
         return (u_char*) return_buf;
     case ENTPHYSICALMFGNAME:
       strcpy((char*)return_buf, (char*)entry.ent_physical_mfg_name);
       *var_len = strlen((char*)return_buf);
         return (u_char*) return_buf;
    case  ENTPHYSICALMODELNAME:
         strcpy((char*)return_buf, (char*)entry.ent_physical_model_name);
         *var_len = strlen((char*)return_buf);
         return (u_char*) return_buf;
    case  ENTPHYSICALALIAS:
        *write_method = write_entPhysicalAlias;
        strcpy((char*)return_buf, (char*)entry.ent_physical_entry_rw.ent_physical_alias);
        *var_len = strlen((char*)return_buf);
         return (u_char*) return_buf;
    case ENTPHYSICALASSETID:
        *write_method = write_entPhysicalAssetID;
         strcpy((char*)return_buf, (char*)entry.ent_physical_entry_rw.ent_physical_asset_id);
         *var_len = strlen((char*)return_buf);
         return (u_char*) return_buf;
     case ENTPHYSICALISFRU:
           long_return =entry.ent_physical_is_fru;
        return (u_char*) &long_return ;
    default:
      ERROR_MSG("");
    }
    return NULL;
}

int
write_entPhysicalSerialNum(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    char stringBuffer[MAXSIZE_entPhysicalAlias + 1];

    if (name_len !=  13)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_OCTET_STR)
            {
                return SNMP_ERR_WRONGTYPE;
            }

            if (var_val_len >= (MAXSIZE_entPhysicalSerialNum + 1))
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;

        case RESERVE2:
            memcpy(stringBuffer, var_val, var_val_len);
            stringBuffer[var_val_len] = '\0';

            if (   ('\0' != stringBuffer[0])
                && (0 == L_CHARSET_IsValidUserNameString(stringBuffer)))
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            /* Release any resources that have been allocated */
            break;

        case ACTION:
            memcpy(stringBuffer, var_val, var_val_len);
            stringBuffer[var_val_len] = '\0';

            if (STKTPLG_PMGR_SetEntPhysicalSeriaNum(name[12], (UI8_T *)stringBuffer) != TRUE)
          	{
                return SNMP_ERR_COMMITFAILED;
          	}
            break;

        case UNDO:
            /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }

    return SNMP_ERR_NOERROR;
}

int
write_entPhysicalAlias(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    char stringBuffer[MAXSIZE_entPhysicalAlias + 1];

    if ((char) name[11] != ENTPHYSICALALIAS)
    {
        return SNMP_ERR_NOTWRITABLE;
    }

    if (name_len !=  13)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_OCTET_STR)
            {
                return SNMP_ERR_WRONGTYPE;
            }

            if (var_val_len >= (MAXSIZE_entPhysicalAlias + 1))
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;

        case RESERVE2:
            memcpy(stringBuffer, var_val, var_val_len);
            stringBuffer[var_val_len] = '\0';

            if (   ('\0' != stringBuffer[0])
                && (0 == L_CHARSET_IsValidUserNameString(stringBuffer)))
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            /* Release any resources that have been allocated */
            break;

        case ACTION:
            /*
             * The variable has been stored in 'value' for you to use,
             * and you have just been asked to do something with it.
             * Note that anything done here must be reversable in the UNDO case
             */
            memcpy(stringBuffer, var_val, var_val_len);
            stringBuffer[var_val_len] = '\0';

            if (STKTPLG_PMGR_SetEntPhysicalAlias(name[12], (UI8_T *)stringBuffer) != TRUE)
            {
                return SNMP_ERR_COMMITFAILED;
            }
            break;

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }

    return SNMP_ERR_NOERROR;
}

int
write_entPhysicalAssetID(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    char stringBuffer[MAXSIZE_entPhysicalAssetID + 1];

    if ((char) name[11] != ENTPHYSICALASSETID)
    {
        return SNMP_ERR_NOTWRITABLE;
    }

    if (name_len!=  13)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_OCTET_STR)
            {
                return SNMP_ERR_WRONGTYPE;
            }

            if (var_val_len >= (MAXSIZE_entPhysicalAssetID + 1)) {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;

        case RESERVE2:
            memcpy(stringBuffer, var_val, var_val_len);
            stringBuffer[var_val_len] = '\0';

            if (   ('\0' != stringBuffer[0])
                && (0 == L_CHARSET_IsValidUserNameString(stringBuffer)))
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            /* Release any resources that have been allocated */
            break;

        case ACTION:
            /*
             * The variable has been stored in 'value' for you to use,
             * and you have just been asked to do something with it.
             * Note that anything done here must be reversable in the UNDO case
             */
            memcpy(stringBuffer, var_val, var_val_len);
            stringBuffer[var_val_len] = '\0';

            if (STKTPLG_PMGR_SetEntPhysicalAssetId(name[12], (UI8_T *)stringBuffer) != TRUE)
            {
                return SNMP_ERR_COMMITFAILED;
            }
            break;

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }

    return SNMP_ERR_NOERROR;
}
