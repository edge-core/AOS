/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.scalar.conf,v 1.5 2002/07/18 14:18:52 dts12 Exp $
 */
#include "sys_cpnt.h"
#if (SYS_CPNT_BRIDGE == TRUE)
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "rfc_2674p.h"
#include "sysORTable.h"
#include "extbrg_pmgr.h"
#include "sys_type.h"
#include "pri_mgr.h"
#include "pri_pmgr.h"
#include "leaf_2674p.h"
#include "sys_adpt.h"
#include "nmtr_mgr.h"
#include "nmtr_pmgr.h"
#include "l_stdlib.h"
#include "snmp_mgr.h"
#include "l_cvrt.h"
#include "l_snmp.h"

/** Initializes the dot1dExtBase module */
void
init_dot1dExtBase(void)
{
    oid            dot1pBridge_oid[] = { SNMP_OID_MIB2, 17, 6 };

    static oid dot1dDeviceCapabilities_oid[]=  { 1,3,6,1,2,1,17,6,1,1,1, 0 };
    static oid dot1dTrafficClassesEnabled_oid[] = { 1,3,6,1,2,1,17,6,1,1,2, 0 };
    static oid dot1dGmrpStatus_oid[] = { 1,3,6,1,2,1,17,6,1,1,3, 0 };

  DEBUGMSGTL(("dot1dExtBase", "Initializing\n"));


    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("dot1dDeviceCapabilities",
                                         get_dot1dDeviceCapabilities,
                                         dot1dDeviceCapabilities_oid,
                                         OID_LENGTH(dot1dDeviceCapabilities_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("dot1dTrafficClassesEnabled",
                               do_dot1dTrafficClassesEnabled,
                               dot1dTrafficClassesEnabled_oid,
                               OID_LENGTH(dot1dTrafficClassesEnabled_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("dot1dGmrpStatus",
                               do_dot1dGmrpStatus,
                               dot1dGmrpStatus_oid,
                               OID_LENGTH(dot1dGmrpStatus_oid),
                               HANDLER_CAN_RWRITE));

      REGISTER_SYSOR_ENTRY(dot1pBridge_oid,
                         "The MIB module to describe P-BRIDGE MIB.");
}


int
get_dot1dDeviceCapabilities(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    UI32_T dot1dDeviceCapabilities;
    UI8_T temp_buffer[sizeof(dot1dDeviceCapabilities)];
    I32_T i;
    UI8_T *p_dot1dDeviceCapabilities;

    if (EXTBRG_PMGR_GetDot1dDeviceCapabilities( &dot1dDeviceCapabilities) != TRUE)
	  return SNMP_ERR_GENERR;

    /* step-1 Network order
     */
    dot1dDeviceCapabilities = L_STDLIB_Hton32(dot1dDeviceCapabilities);

    p_dot1dDeviceCapabilities = (UI8_T *)&dot1dDeviceCapabilities;
    for(i=sizeof(dot1dDeviceCapabilities)-1;i>=0;i--)
    {
        /* step-2 convert SNMP byte order to adjust memory map, ex: 00 00 00 07 => 07 00 00 00
         */
        temp_buffer[i] = *p_dot1dDeviceCapabilities;

        /* step-3 adjust bit order, ex: 07 => E0 */
        temp_buffer[i] = L_CVRT_ByteFlip(temp_buffer[i]);
        p_dot1dDeviceCapabilities++;
    }


    memcpy(return_buf,temp_buffer,sizeof(dot1dDeviceCapabilities));

    switch(reqinfo->mode)
    {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, (u_char *) return_buf, sizeof(dot1dDeviceCapabilities));
            break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_dot1dTrafficClassesEnabled(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */



    switch(reqinfo->mode) {

        case MODE_GET:
        {
        	  UI32_T dot1dTrafficClassesEnabled;
		/* Values:
		 *  true(1)  = VAL_dot1dTrafficClassesEnabled_true
		 *  false(2) = VAL_dot1dTrafficClassesEnabled_false
		 */
	    if (EXTBRG_PMGR_GetDot1dTrafficClassesEnabled(&dot1dTrafficClassesEnabled) != TRUE)
	       return SNMP_ERR_GENERR;

                     long_return = dot1dTrafficClassesEnabled;
                     snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));


          }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
        {
       		UI32_T dot1dTrafficClassesEnabled;
       		dot1dTrafficClassesEnabled = (*requests->requestvb->val.integer);
			if ((requests->requestvb->type)!= ASN_INTEGER)
			{
				netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_WRONGTYPE);
				break;
			}

       		if (( dot1dTrafficClassesEnabled != 1 )  && (dot1dTrafficClassesEnabled != 2))
       	   		netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_WRONGVALUE);

			break;
    	}
        case MODE_SET_RESERVE2:

            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
              {
       	UI32_T dot1dTrafficClassesEnabled;
       	dot1dTrafficClassesEnabled = (*requests->requestvb->val.integer);

                if(EXTBRG_PMGR_SetDot1dTrafficClassesEnabled(dot1dTrafficClassesEnabled) != TRUE)
                       netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
               }
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */

            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
do_dot1dGmrpStatus(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
        {
           UI32_T dot1dGmrpStatus;

           if (EXTBRG_PMGR_GetDot1dGmrpStatus(&dot1dGmrpStatus) != TRUE)
                 return SNMP_ERR_GENERR;

            long_return = dot1dGmrpStatus;

            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
        }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
            }
            break;

        case MODE_SET_RESERVE2:
            switch (*requests->requestvb->val.integer)
            {
                case VAL_dot1dGmrpStatus_enabled:
                    break;

                case VAL_dot1dGmrpStatus_disabled:
                    break;

                default:
                    netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
           {
       	UI32_T dot1dGmrpStatus;
       	dot1dGmrpStatus = (*requests->requestvb->val.integer);

               if(EXTBRG_PMGR_SetDot1dGmrpStatus(dot1dGmrpStatus)!= TRUE)
                       netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
               }
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

/*
 * dot1dPortPriorityTable_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid dot1dPortPriorityTable_variables_oid[] = { 1,3,6,1,2,1,17,6,1,2 };

/*
 * variable4 dot1dPortPriorityTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */

struct variable3 dot1dPortPriorityTable_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */

#define DOT1DPORTDEFAULTUSERPRIORITY		1
{DOT1DPORTDEFAULTUSERPRIORITY,  ASN_INTEGER,  RWRITE,  var_dot1dPortPriorityTable, 3,  { 1, 1, 1 }},
#define DOT1DPORTNUMTRAFFICCLASSES		2
{DOT1DPORTNUMTRAFFICCLASSES,  ASN_INTEGER,  RWRITE,  var_dot1dPortPriorityTable, 3,  { 1, 1, 2 }},
};
/*    (L = length of the oidsuffix) */


/** Initializes the dot1dPortPriorityTable module */
void
init_dot1dPortPriorityTable(void)
{

    DEBUGMSGTL(("dot1dPortPriorityTable", "Initializing\n"));

    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("dot1dPortPriorityTable", dot1dPortPriorityTable_variables, variable3,
               dot1dPortPriorityTable_variables_oid);

    /* place any other initialization junk you need here */
}

#define dot1dEntry_INSTANCE_LEN 1
static int
header_dot1dPortPriorityTable(struct variable *vp,
               oid * name,
               size_t * length,
               int exact, size_t * var_len, WriteMethod ** write_method,UI32_T *ifindex)
{
    UI32_T      compc=0,ifindex1;
    oid         compl[dot1dEntry_INSTANCE_LEN];
    PRI_MGR_Dot1dPortPriorityEntry_T  entry;
    int         i;

    memset( &entry, 0, sizeof(entry));
    /*check compc, retrive compl*/
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,compl, dot1dEntry_INSTANCE_LEN);

    if (exact)/*get,set*/
    {
        if(compl[0]>0 && compl[0]<=SYS_ADPT_TOTAL_NBR_OF_LPORT)
        {
            *ifindex = compl[0];
            return 0;
        }
        return -1;
    }
    else/*getnext*/
    {
        if(compc == 0)
        {
            ifindex1 = 1;
        }
        else if(compl[0]>0 && compl[0]<SYS_ADPT_TOTAL_NBR_OF_LPORT)
        {
            ifindex1 = compl[0]+1;
        }
        else
            return -1;

        for (i = ifindex1;i <= SYS_ADPT_TOTAL_NBR_OF_LPORT; i++)
        {
            if (TRUE == PRI_PMGR_GetDot1dPortPriorityEntry(i,&entry))
            {
                *ifindex = i;
                return 0;
            }
        }
        return -1;
    }
}



/*
 * var_dot1dPortPriorityTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *
var_dot1dPortPriorityTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{

    PRI_MGR_Dot1dPortPriorityEntry_T  entry;
    UI32_T            interface = 0;
    oid best_inst[dot1dEntry_INSTANCE_LEN];

   switch(vp->magic)
    {
    case DOT1DPORTDEFAULTUSERPRIORITY:
        *write_method = write_dot1dPortDefaultUserPriority;
    break;

    case DOT1DPORTNUMTRAFFICCLASSES:
        *write_method = write_dot1dPortNumTrafficClasses;
    break;
    }


    if(MATCH_FAILED == header_dot1dPortPriorityTable(vp, name, length, exact, var_len, write_method, &interface))
    {
        return NULL;
    }

    if (!PRI_PMGR_GetDot1dPortPriorityEntry(interface, &entry))
              return NULL;

    memcpy(name, vp->name, vp->namelen*sizeof(oid));
    best_inst[0] = interface;
    memcpy(name + vp->namelen, best_inst, dot1dEntry_INSTANCE_LEN*sizeof(oid));
    *length = vp->namelen + dot1dEntry_INSTANCE_LEN;
    *var_len = sizeof(long);    /* default to 'long' results */
    /*
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic)
     {
    case DOT1DPORTDEFAULTUSERPRIORITY:

        long_return = entry.dot1d_port_default_user_priority;
        return (u_char*) &long_return;
    case DOT1DPORTNUMTRAFFICCLASSES:
        *write_method = write_dot1dPortNumTrafficClasses;
        long_return = entry.dot1d_port_num_traffic_classes;
        return (u_char*) &long_return;
    default:
      ERROR_MSG("");
    }
    return NULL;
}


int
write_dot1dPortDefaultUserPriority(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    if ((char) name[12] != DOT1DPORTDEFAULTUSERPRIORITY)
     {
        return SNMP_ERR_NOTWRITABLE;
    }
    if (name_len!=  14)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }

        break;
        case RESERVE2:
          value = *(long *)var_val;

          if ((value< 0) || (value >7))
            {
               return SNMP_ERR_WRONGVALUE;
            }
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
            value = *(long *)var_val;
            if (PRI_PMGR_SetDot1dPortDefaultUserPriority(name[13], value) != TRUE)
                       return SNMP_ERR_COMMITFAILED;
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_dot1dPortNumTrafficClasses(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

   if ((char) name[12] != DOT1DPORTNUMTRAFFICCLASSES)
     {
        return SNMP_ERR_NOTWRITABLE;
    }

    if (name_len!=  14)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          value = *(long *)var_val;

          if ((value< 1) || (value >8))
              return SNMP_ERR_WRONGVALUE;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             value = *(long *)var_val;
             if (PRI_PMGR_SetDot1dPortNumTrafficClasses(name[13],  value) != TRUE)

                return SNMP_ERR_COMMITFAILED;
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


/*
 * dot1dPortCapabilitiesTable_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid dot1dPortCapabilitiesTable_variables_oid[] = { 1,3,6,1,2,1,17,6,1,1 };

/*
 * variable4 dot1dPortCapabilitiesTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */

struct variable3 dot1dPortCapabilitiesTable_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */

#define DOT1DPORTCAPABILITIES		1
{DOT1DPORTCAPABILITIES,  ASN_OCTET_STR ,  RONLY,   var_dot1dPortCapabilitiesTable, 3,  { 4, 1, 1 }},
};
/*    (L = length of the oidsuffix) */


/** Initializes the dot1dPortCapabilitiesTable module */
void
init_dot1dPortCapabilitiesTable(void)
{

    DEBUGMSGTL(("dot1dPortCapabilitiesTable", "Initializing\n"));

    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("dot1dPortCapabilitiesTable", dot1dPortCapabilitiesTable_variables, variable3,
               dot1dPortCapabilitiesTable_variables_oid);

    /* place any other initialization junk you need here */
}


static int
header_dot1dPortCapabilitiesTable(struct variable *vp,
               oid * name,
               size_t * length,
               int exact, size_t * var_len, WriteMethod ** write_method, UI32_T *ifindex)
{
    UI32_T      compc = 0;
    oid         compl[dot1dEntry_INSTANCE_LEN];
    int    i;
    UI32_T capability;
    UI32_T ifindex1;

    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,compl, dot1dEntry_INSTANCE_LEN);

    if (exact)/*get,set*/
    {
        if(compl[0]>0 && compl[0]<=SYS_ADPT_TOTAL_NBR_OF_LPORT)
        {
            *ifindex = compl[0];
            return 0;
        }
        return -1;
    }
    else/*getnext*/
    {
        if(compc == 0)
        {
            ifindex1 = 1;
        }
        else if(compl[0]>0 && compl[0]<SYS_ADPT_TOTAL_NBR_OF_LPORT)
        {
            ifindex1 = compl[0]+1;
        }
        else
            return -1;

        for (i = ifindex1;i <= SYS_ADPT_TOTAL_NBR_OF_LPORT; i++)
        {
            if (TRUE == EXTBRG_PMGR_GetDot1dPortCapabilities(i,&capability))
            {
                *ifindex = i;
                return 0;
            }
        }
        return -1;
    }
}


/*
 * var_dot1dPortCapabilitiesTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *
var_dot1dPortCapabilitiesTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{

    UI32_T  capabilitiy = 0;
    UI32_T  interface = 0;
    oid best_inst[dot1dEntry_INSTANCE_LEN];

    if(MATCH_FAILED == header_dot1dPortCapabilitiesTable(vp, name, length, exact, var_len, write_method, &interface))
    {
        return NULL;
    }

       	if (!EXTBRG_PMGR_GetDot1dPortCapabilities(interface, &capabilitiy))
        return NULL;
    memcpy(name, vp->name, vp->namelen*sizeof(oid));
    best_inst[0] = interface;
    memcpy(name + vp->namelen, best_inst, dot1dEntry_INSTANCE_LEN*sizeof(oid));
    *length = vp->namelen + dot1dEntry_INSTANCE_LEN;
    *var_len = sizeof(long);    /* default to 'long' results */

    /*
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic)
    {
        case DOT1DPORTCAPABILITIES:
        {
             UI8_T temp_buffer[sizeof(capabilitiy)];
             I32_T i;
             UI8_T *p_capability;

             /* step-1 Network order
              */
             capabilitiy = L_STDLIB_Hton32(capabilitiy);

             p_capability = (UI8_T *)&capabilitiy;
             for(i=sizeof(capabilitiy)-1;i>=0;i--)
            {
                 /* step-2 convert SNMP byte order to adjust memory map, ex: 00 00 00 07 => 07 00 00 00
                  */
                 temp_buffer[i] = *p_capability;

                 /* step-3 adjust bit order, ex: 07 => E0
                  */
                 temp_buffer[i] = L_CVRT_ByteFlip(temp_buffer[i]);
                 p_capability++;
            }

            *var_len = SIZE_dot1dPortCapabilities;
             memcpy(return_buf,temp_buffer,*var_len);

            return (u_char*) return_buf;
        }
        default:
            ERROR_MSG("");
    }

    return NULL;
}


/*
 * dot1dUserPriorityRegenTable_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid dot1dUserPriorityRegenTable_variables_oid[] = { 1,3,6,1,2,1,17,6,1,2};

/*
 * variable4 dot1dUserPriorityRegenTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */

struct variable3 dot1dUserPriorityRegenTable_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */

#define DOT1DUSERPRIORITY		1
#define DOT1DREGENUSERPRIORITY		2
{DOT1DREGENUSERPRIORITY,  ASN_INTEGER,  RWRITE,  var_dot1dUserPriorityRegenTable, 3,  { 2, 1, 2 }},
};
/*    (L = length of the oidsuffix) */


/** Initializes the dot1dUserPriorityRegenTable module */
void
init_dot1dUserPriorityRegenTable(void)
{

    DEBUGMSGTL(("dot1dUserPriorityRegenTable", "Initializing\n"));

    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("dot1dUserPriorityRegenTable", dot1dUserPriorityRegenTable_variables, variable3,
               dot1dUserPriorityRegenTable_variables_oid);

    /* place any other initialization junk you need here */
}


#define dot1dUserPriorityRegenEntry_INSTANCE_LEN 2
static int
header_dot1dUserPriorityRegenTable(struct variable *vp,
               oid * name,
               size_t * length,
               int exact, size_t * var_len, WriteMethod ** write_method,
               UI32_T *index1, UI32_T *index2)
{
   UI32_T      compc=0;
   oid         compl[dot1dUserPriorityRegenEntry_INSTANCE_LEN];
   PRI_MGR_Dot1dUserPriorityRegenEntry_T  entry;
   UI32_T ifIndex1=0, ifIndex2 = 0;

   memset(  &entry, 0 , sizeof(entry));
   SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,compl, dot1dUserPriorityRegenEntry_INSTANCE_LEN);

    if (exact)/*get,set*/
    {
        *index1 = compl[0];
        *index2 = compl[1];
        entry.dot1d_user_priority = compl[1];
        return 0;
    }
    else/*getnext*/
    {
        if(compc == dot1dUserPriorityRegenEntry_INSTANCE_LEN)
        {
            ifIndex1 = compl[0];
            entry.dot1d_user_priority = compl[1];
        }
        //entry.dot1d_user_priority = ifIndex2;
        if( TRUE == PRI_PMGR_GetNextDot1dUserPriorityRegenEntry( &ifIndex1, &entry))
        {
            //ifIndex2 =  entry.dot1d_user_priority;
            *index1 = ifIndex1;
            *index2 = entry.dot1d_user_priority;
            return 0;
        }
        else
            return MATCH_FAILED;
    }

}


/*
 * var_dot1dUserPriorityRegenTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *
var_dot1dUserPriorityRegenTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{
    /* variables we may use later */

    UI32_T index1=0, index2=0;
    oid best_inst[dot1dUserPriorityRegenEntry_INSTANCE_LEN];
    PRI_MGR_Dot1dUserPriorityRegenEntry_T  entry;

   /*Since this table allow for entry that does not exist, (creation). we need to know the write method first*/
    switch(vp->magic)
     {
    case DOT1DREGENUSERPRIORITY:
        *write_method = write_dot1dRegenUserPriority;
     break;

    }

    memset( &entry, 0, sizeof(entry));

    if(MATCH_FAILED == header_dot1dUserPriorityRegenTable(vp, name, length, exact, var_len, write_method,  &index1,& index2))
    {
        return NULL;
    }
   entry.dot1d_user_priority =index2;
   if (PRI_PMGR_GetDot1dUserPriorityRegenEntry(index1, &entry)!= TRUE)
    {

            return NULL;

    }
    memcpy(name, vp->name, vp->namelen*sizeof(oid));
    best_inst[0] = index1;
    best_inst[1] = index2;
    memcpy(name + vp->namelen, best_inst, dot1dUserPriorityRegenEntry_INSTANCE_LEN*sizeof(oid));
    *length = vp->namelen + dot1dUserPriorityRegenEntry_INSTANCE_LEN;
    *var_len = sizeof(long);    /* default to 'long' results */

    /*
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic)
    {
   case DOT1DREGENUSERPRIORITY:
        *write_method = write_dot1dRegenUserPriority;
        long_return =  entry.dot1d_regen_user_priority;
        return (u_char*) &long_return;
    default:
      ERROR_MSG("");
    }
    return NULL;
}


int
write_dot1dRegenUserPriority(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

       if ((char) name[12] != DOT1DREGENUSERPRIORITY)
     {
        return SNMP_ERR_NOTWRITABLE;
    }
    if (name_len!=  15)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          value = *(long *)var_val;

          if ( (value < 0) || (value >7))
              return SNMP_ERR_WRONGVALUE;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
        {
           PRI_MGR_Dot1dUserPriorityRegenEntry_T entry;
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            value = *(long *)var_val;

          entry.dot1d_user_priority = name[14];
          entry.dot1d_regen_user_priority = value;
          if (PRI_PMGR_SetDot1dUserPriorityRegenEntry(name[13], entry)!= TRUE)
             return SNMP_ERR_COMMITFAILED;
        }
         break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

/*
 * dot1dTrafficClassTable_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid dot1dTrafficClassTable_variables_oid[] = { 1,3,6,1,2,1,17,6,1,2 };

/*
 * variable4 dot1dTrafficClassTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */

struct variable3 dot1dTrafficClassTable_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */

#define DOT1DTRAFFICCLASSPRIORITY		1
#define DOT1DTRAFFICCLASS		2
{DOT1DTRAFFICCLASS,  ASN_INTEGER,  RWRITE,  var_dot1dTrafficClassTable, 3,  { 3, 1, 2 }},
};
/*    (L = length of the oidsuffix) */


/** Initializes the dot1dTrafficClassTable module */
void
init_dot1dTrafficClassTable(void)
{

    DEBUGMSGTL(("dot1dTrafficClassTable", "Initializing\n"));

    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("dot1dTrafficClassTable", dot1dTrafficClassTable_variables, variable3,
               dot1dTrafficClassTable_variables_oid);

    /* place any other initialization junk you need here */
}

#define dot1dTrafficClassEntry_INSTANCE_LEN 2
static int
header_dot1dTrafficClassTable(struct variable *vp,
               oid * name,
               size_t * length,
               int exact, size_t * var_len, WriteMethod ** write_method,
               UI32_T *index1, UI32_T *index2)
{
   UI32_T      compc=0;
   oid         compl[dot1dTrafficClassEntry_INSTANCE_LEN];
   PRI_MGR_Dot1dTrafficClassEntry_T  entry;
   UI32_T ifIndex1 = 0, ifIndex2 = 0;

    memset(  &entry, 0 , sizeof(entry));

   SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,compl, dot1dTrafficClassEntry_INSTANCE_LEN);

    if (exact)/*get,set*/
    {
        *index1 = compl[0];
        *index2 = compl[1];
        return 0;
    }
    else/*getnext*/
     {
        if(compc == dot1dTrafficClassEntry_INSTANCE_LEN)
        {
            ifIndex1 = compl[0];
            ifIndex2 = compl[1];
        }
        if( TRUE == PRI_PMGR_GetNextDot1dTrafficClassEntry( &ifIndex1, &ifIndex2, &entry))
        {
            *index1 = ifIndex1;
            *index2 = ifIndex2;
            return 0;
        }
        else
            return MATCH_FAILED;
    }
    return 0;

}






/*
 * var_dot1dTrafficClassTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *
var_dot1dTrafficClassTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{
    /* variables we may use later */

    UI32_T index1 = 0, index2 = 0;
    oid best_inst[dot1dTrafficClassEntry_INSTANCE_LEN];
    PRI_MGR_Dot1dTrafficClassEntry_T  entry;


   /*Since this table allow for entry that does not exist, (creation). we need to know the write method first*/
    switch(vp->magic)
     {
    case DOT1DTRAFFICCLASS:
        *write_method = write_dot1dTrafficClass;
     break;

    }

    memset( &entry, 0, sizeof(entry));

    if(MATCH_FAILED == header_dot1dTrafficClassTable(vp, name, length, exact, var_len, write_method,  &index1,& index2))
    {
        return NULL;
    }

   if (PRI_PMGR_GetDot1dTrafficClassEntry(index1,index2, &entry)!= TRUE)
            return NULL;
    memcpy(name, vp->name, vp->namelen*sizeof(oid));
    best_inst[0] = index1;
    best_inst[1] = index2;
    memcpy(name + vp->namelen, best_inst, dot1dTrafficClassEntry_INSTANCE_LEN*sizeof(oid));
    *length = vp->namelen + dot1dTrafficClassEntry_INSTANCE_LEN;
    *var_len = sizeof(long);    /* default to 'long' results */

    /*
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
   case  DOT1DTRAFFICCLASS:
        long_return = entry.dot1d_traffic_class;
        return (u_char*) &long_return;
    default:
      ERROR_MSG("");
    }
    return NULL;
}


int
write_dot1dTrafficClass(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

     if ((char) name[12] != DOT1DTRAFFICCLASS)
     {
        return SNMP_ERR_NOTWRITABLE;
    }
    if (name_len!=  15)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;


        case RESERVE2:
          value = *(long *)var_val;

          if ( (value < 0) || (value >7))
              return SNMP_ERR_WRONGVALUE;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             value = *(long *)var_val;
          if (PRI_PMGR_SetDot1dTrafficClass(name[13], name[14], value) != TRUE)
               return SNMP_ERR_COMMITFAILED;
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

/*
 * dot1dPortGarpTable_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid dot1dPortGarpTable_variables_oid[] = { 1,3,6,1,2,1,17,6,1,3 };

/*
 * variable4 dot1dPortGarpTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */

struct variable3 dot1dPortGarpTable_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */

#define DOT1DPORTGARPJOINTIME		1
{DOT1DPORTGARPJOINTIME,  ASN_INTEGER,  RWRITE,  var_dot1dPortGarpTable, 3,  { 1, 1, 1 }},
#define DOT1DPORTGARPLEAVETIME		2
{DOT1DPORTGARPLEAVETIME,  ASN_INTEGER,  RWRITE,  var_dot1dPortGarpTable, 3,  { 1, 1, 2 }},
#define DOT1DPORTGARPLEAVEALLTIME		3
{DOT1DPORTGARPLEAVEALLTIME,  ASN_INTEGER,  RWRITE,  var_dot1dPortGarpTable, 3,  { 1, 1, 3 }},
};
/*    (L = length of the oidsuffix) */


/** Initializes the dot1dPortGarpTable module */
void
init_dot1dPortGarpTable(void)
{

    DEBUGMSGTL(("dot1dPortGarpTable", "Initializing\n"));

    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("dot1dPortGarpTable", dot1dPortGarpTable_variables, variable3,
               dot1dPortGarpTable_variables_oid);

    /* place any other initialization junk you need here */
}


static int
header_dot1dPortGarpTable(struct variable *vp,
               oid * name,
               size_t * length,
               int exact, size_t * var_len, WriteMethod ** write_method)
{
     unsigned int ifIndex = 0;

    if(l_snmp_index_get(vp,name,length,&ifIndex,exact) < 0 )
      return MATCH_FAILED;

    if(!exact)
     {
         return MATCH_FAILED;

        l_snmp_index_set(vp,name,length,ifIndex);

     }
    else
    {
            return MATCH_FAILED;
    }

   /*EPR: ES3628BT-FLF-ZZ-01119
Problem:gvrpmib:cannot set  value of gvrp timer in the

dot1dPortGarpEntry
Rootcause: the write function is set null later
Solution:not set the write fuction null
Files:rfc_2674.c*/
    /**write_method = 0;*/
    *var_len = sizeof(long);    /* default to 'long' results */

    return ifIndex;

}


/*
 * var_dot1dPortGarpTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *
var_dot1dPortGarpTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{

switch(vp->magic) {
   case  DOT1DPORTGARPJOINTIME:
        *write_method = write_dot1dPortGarpJoinTime;
    break;
    case DOT1DPORTGARPLEAVETIME:
        *write_method = write_dot1dPortGarpLeaveTime;
    break;
    case DOT1DPORTGARPLEAVEALLTIME:
        *write_method = write_dot1dPortGarpLeaveAllTime;
    break;
}


   if(MATCH_FAILED == header_dot1dPortGarpTable(vp, name, length, exact, var_len, write_method))
        return NULL;

    /*
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
   case  DOT1DPORTGARPJOINTIME:
       long_return = 0;
        return (u_char*) &long_return;
    case DOT1DPORTGARPLEAVETIME:
      long_return = 0;
        return (u_char*) &long_return;
    case DOT1DPORTGARPLEAVEALLTIME:
      long_return = 0;
        return (u_char*) &long_return;
    default:
      ERROR_MSG("");
    }
    return NULL;
}


int
write_dot1dPortGarpJoinTime(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    if ((char) name[12] != DOT1DPORTGARPJOINTIME)
     {
        return SNMP_ERR_NOTWRITABLE;
    }
    if (name_len!=  14)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          value = *(long *)var_val;

          if ( (value < SYS_ADPT_GARP_MIN_JOIN_TIME) || (value >SYS_ADPT_GARP_MAX_JOIN_TIME) )
              return SNMP_ERR_WRONGVALUE;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             value = *(long *)var_val;

             return SNMP_ERR_COMMITFAILED;


          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_dot1dPortGarpLeaveTime(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    if ((char) name[12] != DOT1DPORTGARPLEAVETIME)
     {
        return SNMP_ERR_NOTWRITABLE;
    }
    if (name_len!=  14)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          value = *(long *)var_val;

          if ((value <SYS_ADPT_GARP_MIN_LEAVE_TIME) || (value >SYS_ADPT_GARP_MAX_LEAVE_TIME))
             return SNMP_ERR_WRONGVALUE;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             value = *(long *)var_val;


            return SNMP_ERR_COMMITFAILED;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_dot1dPortGarpLeaveAllTime(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    if ((char) name[12] != DOT1DPORTGARPLEAVEALLTIME)
     {
        return SNMP_ERR_NOTWRITABLE;
    }
    if (name_len!=  14)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          value = *(long *)var_val;
          if ( (value < SYS_ADPT_GARP_MIN_LEAVEALL_TIME) || (value >SYS_ADPT_GARP_MAX_LEAVEALL_TIME))
              return SNMP_ERR_WRONGVALUE;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             value = *(long *)var_val;

                   return SNMP_ERR_COMMITFAILED;
        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


/* dot1dTpHCPortTable */
oid dot1dTpHCPortTable_variables_oid[] = {1, 3, 6, 1, 2, 1, 17, 4};

struct variable3 dot1dTpHCPortTable_variables[] =
{
#define DOT1DTPHCPORTINFRAMES   1
    {DOT1DTPHCPORTINFRAMES, ASN_COUNTER64, RONLY, var_dot1dTpHCPortTable, 3, {5, 1, 1}},
#define DOT1DTPHCPORTOUTFRAMES  2
    {DOT1DTPHCPORTOUTFRAMES, ASN_COUNTER64, RONLY, var_dot1dTpHCPortTable, 3, {5, 1, 2}},
#define DOT1DTPHCPORTINDISCARDS 3
    {DOT1DTPHCPORTINDISCARDS, ASN_COUNTER64, RONLY, var_dot1dTpHCPortTable, 3, {5, 1, 3}},
};


void init_dot1dTpHCPortTable(void)
{
    DEBUGMSGTL(("dot1dTpHCPortTable", "Initializing\n"));
    REGISTER_MIB("dot1dTpHCPortTable", dot1dTpHCPortTable_variables, variable3, dot1dTpHCPortTable_variables_oid);
}


static int header_dot1dTpHCPortTable(struct variable *vp,
                                     oid             *name,
                                     size_t          *length,
                                     int             exact,
                                     size_t          *var_len,
                                     WriteMethod     **write_method, UI32_T *ifindex)
{
    UI32_T      compc=0,ifindex1;
    oid         compl[dot1dEntry_INSTANCE_LEN];
    NMTR_MGR_Dot1dTpHCPortEntry_T  entry;
    int         i;

    memset(&entry, 0 , sizeof(entry));
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,compl, dot1dEntry_INSTANCE_LEN);

    if (exact)/*get,set*/
    {
        if(compl[0]>0 && compl[0]<=SYS_ADPT_TOTAL_NBR_OF_LPORT)
        {
            *ifindex = compl[0];
            return 0;
        }
        return -1;
    }
    else/*getnext*/
    {
        if(compc == 0)
        {
            ifindex1 = 1;
        }
        else if(compl[0]>0 && compl[0]<SYS_ADPT_TOTAL_NBR_OF_LPORT)
        {
            ifindex1 = compl[0]+1;
        }
        else
            return -1;

        for (i = ifindex1;i <= SYS_ADPT_TOTAL_NBR_OF_LPORT; i++)
        {
            entry.dot1d_tp_port = i;
            if (TRUE == NMTR_PMGR_GetDot1dTpHCPortEntry(&entry))
            {
                *ifindex = i;
                return 0;
            }
        }
        return -1;
    }
}


unsigned char* var_dot1dTpHCPortTable(struct variable *vp,
                                      oid             *name,
                                      size_t          *length,
                                      int             exact,
                                      size_t          *var_len,
                                      WriteMethod     **write_method)
{
    UI32_T     interface = 0;
    oid best_inst[dot1dEntry_INSTANCE_LEN];
    NMTR_MGR_Dot1dTpHCPortEntry_T entry;

    if(MATCH_FAILED == header_dot1dTpHCPortTable(vp, name, length, exact, var_len, write_method, &interface))
    {
        return NULL;
    }

    memset(&entry, 0, sizeof(NMTR_MGR_Dot1dTpHCPortEntry_T));
    entry.dot1d_tp_port = interface;

    if(!NMTR_PMGR_GetDot1dTpHCPortEntry(&entry))
        return NULL;

    memcpy(name, vp->name, vp->namelen*sizeof(oid));
    best_inst[0] = interface;
    memcpy(name + vp->namelen, best_inst, dot1dEntry_INSTANCE_LEN*sizeof(oid));
    *length = vp->namelen + dot1dEntry_INSTANCE_LEN;
    *var_len = sizeof(long64_return);

    switch(vp->magic)
    {
        case DOT1DTPHCPORTINFRAMES:
            SNMP_MGR_UI64_T_TO_COUNTER64(long64_return, entry.dot1d_tp_hc_port_in_frames);
            return (u_char*)&long64_return;
        case DOT1DTPHCPORTOUTFRAMES:
            SNMP_MGR_UI64_T_TO_COUNTER64(long64_return, entry.dot1d_tp_hc_port_out_frames);
            return (u_char*)&long64_return;
        case DOT1DTPHCPORTINDISCARDS:
            SNMP_MGR_UI64_T_TO_COUNTER64(long64_return, entry.dot1d_tp_hc_port_in_discards);
            return (u_char*)&long64_return;
        default:
            ERROR_MSG("");
    }

    return NULL;
}


/* dot1dTpPortOverflowTable */
oid dot1dTpPortOverflowTable_variables_oid[] = {1, 3, 6, 1, 2, 1, 17, 4};

struct variable3 dot1dTpPortOverflowTable_variables[] =
{
#define DOT1DTPPORTINOVERFLOWFRAMES   1
    {DOT1DTPPORTINOVERFLOWFRAMES, ASN_COUNTER, RONLY, var_dot1dTpPortOverflowTable, 3, {6, 1, 1}},
#define DOT1DTPPORTOUTOVERFLOWFRAMES  2
    {DOT1DTPPORTOUTOVERFLOWFRAMES, ASN_COUNTER, RONLY, var_dot1dTpPortOverflowTable, 3, {6, 1, 2}},
#define DOT1DTPPORTINOVERFLOWDISCARDS 3
    {DOT1DTPPORTINOVERFLOWDISCARDS, ASN_COUNTER, RONLY, var_dot1dTpPortOverflowTable, 3, {6, 1, 3}},
};


void init_dot1dTpPortOverflowTable(void)
{
    DEBUGMSGTL(("dot1dTpPortOverflowTable", "Initializing\n"));
    REGISTER_MIB("dot1dTpPortOverflowTable", dot1dTpPortOverflowTable_variables, variable3, dot1dTpPortOverflowTable_variables_oid);
}

#define DOT1DTPPORTOVERFLOWENTRY_INSTANCE_LEN  1

BOOL_T dot1dTpPortOverflowTable_oid_index_to_data(UI32_T exact, UI32_T compc,
            oid * compl ,NMTR_MGR_Dot1dTpPortOverflowEntry_T *entry)
{

    /* get or write
     */
    if(exact)
    {

        /* check the index length
         */
        if(compc != DOT1DTPPORTOVERFLOWENTRY_INSTANCE_LEN) /* the constant size index*/
        {
            return FALSE;
        }

    }

    /* assign the index to data
     */
    entry->dot1d_tp_port=compl[0];

    return TRUE;
}

unsigned char* var_dot1dTpPortOverflowTable(struct variable *vp,
                                            oid             *name,
                                            size_t          *length,
                                            int             exact,
                                            size_t          *var_len,
                                            WriteMethod     **write_method)
{
    /* variables we may use later */
    UI32_T compc=0;
    oid compl[DOT1DTPPORTOVERFLOWENTRY_INSTANCE_LEN];
    oid best_inst[DOT1DTPPORTOVERFLOWENTRY_INSTANCE_LEN];
    NMTR_MGR_Dot1dTpPortOverflowEntry_T  entry;

    /*check compc, retrive compl*/
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,compl, DOT1DTPPORTOVERFLOWENTRY_INSTANCE_LEN);

    memset(&entry, 0, sizeof(entry));

    if (exact)/*get,set*/
    {

        if(dot1dTpPortOverflowTable_oid_index_to_data(exact,compc,compl,&entry)==FALSE)
        {
            return NULL;
        }

        /*get data
         */
        if (NMTR_PMGR_GetDot1dTpPortOverflowEntry( &entry)!=TRUE)
        {
            return NULL;
        }
    }
    else/*getnext*/
    {

        dot1dTpPortOverflowTable_oid_index_to_data(exact,compc,compl,&entry);

        /* check the length of inputing index,if <1 we should try get {0.0.0.0.0...}
         */
        if (compc< DOT1DTPPORTOVERFLOWENTRY_INSTANCE_LEN)
        {

            if ( NMTR_PMGR_GetDot1dTpPortOverflowEntry( &entry)!=TRUE)
            {

                /*get next data*/
                if ( NMTR_PMGR_GetNextDot1dTpPortOverflowEntry(&entry)!=TRUE)
                {
                    return NULL;
                }
            }
        }
        else
        {

            /*get next data*/
            if ( NMTR_PMGR_GetNextDot1dTpPortOverflowEntry(&entry)!=TRUE)
            {
                return NULL;
            }
        }
    }

    memcpy(name, vp->name, vp->namelen*sizeof(oid));

    /* assign data to the oid index
     */
    best_inst[0] = entry.dot1d_tp_port;
    memcpy(name + vp->namelen, best_inst, DOT1DTPPORTOVERFLOWENTRY_INSTANCE_LEN*sizeof(oid));
    *length = vp->namelen +DOT1DTPPORTOVERFLOWENTRY_INSTANCE_LEN;
    *var_len = sizeof(long_return);

    switch(vp->magic)
    {
        case DOT1DTPPORTINOVERFLOWFRAMES:
            long_return = entry.dot1d_tp_port_in_overflow_frames;
            return (u_char*)&long_return;
        case DOT1DTPPORTOUTOVERFLOWFRAMES:
            long_return = entry.dot1d_tp_port_out_overflow_frames;
            return (u_char*)&long_return;
        case DOT1DTPPORTINOVERFLOWDISCARDS:
            long_return = entry.dot1d_tp_port_in_overflow_discards;
            return (u_char*)&long_return;
        default:
            ERROR_MSG("");
    }

    return NULL;
}
#endif
