/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.scalar.conf,v 1.5 2002/07/18 14:18:52 dts12 Exp $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "rfc_2011.h"
#include "ip_lib.h"
#include "netcfg_type.h"
#include "netcfg_pom_ip.h"
#include "netcfg_pmgr_nd.h"
#include "sysORTable.h"
#include "sys_type.h"
#include "snmp_mgr.h"
#include "sys_adpt.h"
#include "leaf_2011.h"
#include "netcfg_pmgr_arp.h"
#include "l_prefix.h"

#include "ipal_types.h"
#include "ipal_if.h"
#include "ipal_route.h"

#define ipNetToMediaEntry_INSTANCE_LEN 5
#define ipNetToMediaEntry_OID_NAME_LEN 10


/** Initializes the ip module */
void
init_ip(void)
{
   oid             ip_module_oid[] = { SNMP_OID_MIB2, 4 };

    static oid ipReasmFails_oid[] = { 1,3,6,1,2,1,4,16, 0 };
    static oid ipFragCreates_oid[] = { 1,3,6,1,2,1,4,19, 0 };
    static oid ipInReceives_oid[] = { 1,3,6,1,2,1,4,3, 0 };
    static oid ipFragOKs_oid[] = { 1,3,6,1,2,1,4,17, 0 };
    static oid ipInUnknownProtos_oid[] = { 1,3,6,1,2,1,4,7, 0 };
    static oid ipInAddrErrors_oid[] = { 1,3,6,1,2,1,4,5, 0 };
    static oid ipFragFails_oid[] = { 1,3,6,1,2,1,4,18, 0 };
    static oid ipInHdrErrors_oid[] = { 1,3,6,1,2,1,4,4, 0 };
    static oid ipForwDatagrams_oid[] = { 1,3,6,1,2,1,4,6, 0 };
    static oid ipForwarding_oid[] = { 1,3,6,1,2,1,4,1, 0 };
    static oid ipOutRequests_oid[] = { 1,3,6,1,2,1,4,10, 0 };
    static oid ipInDelivers_oid[] = { 1,3,6,1,2,1,4,9, 0 };
    static oid ipRoutingDiscards_oid[] = { 1,3,6,1,2,1,4,23, 0 };
    static oid ipReasmReqds_oid[] = { 1,3,6,1,2,1,4,14, 0 };
    static oid ipOutNoRoutes_oid[] = { 1,3,6,1,2,1,4,12, 0 };
    static oid ipDefaultTTL_oid[] = { 1,3,6,1,2,1,4,2, 0 };
    static oid ipReasmTimeout_oid[] = { 1,3,6,1,2,1,4,13, 0 };
    static oid ipInDiscards_oid[] = { 1,3,6,1,2,1,4,8, 0 };
    static oid ipOutDiscards_oid[] = { 1,3,6,1,2,1,4,11, 0 };
    static oid ipReasmOKs_oid[] = { 1,3,6,1,2,1,4,15, 0 };

  DEBUGMSGTL(("ip", "Initializing\n"));

    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("ipReasmFails",
                                         get_ipReasmFails,
                                         ipReasmFails_oid,
                                         OID_LENGTH(ipReasmFails_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("ipFragCreates",
                                         get_ipFragCreates,
                                         ipFragCreates_oid,
                                         OID_LENGTH(ipFragCreates_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("ipInReceives",
                                         get_ipInReceives,
                                         ipInReceives_oid,
                                         OID_LENGTH(ipInReceives_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("ipFragOKs",
                                         get_ipFragOKs,
                                         ipFragOKs_oid,
                                         OID_LENGTH(ipFragOKs_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("ipInUnknownProtos",
                                         get_ipInUnknownProtos,
                                         ipInUnknownProtos_oid,
                                         OID_LENGTH(ipInUnknownProtos_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("ipInAddrErrors",
                                         get_ipInAddrErrors,
                                         ipInAddrErrors_oid,
                                         OID_LENGTH(ipInAddrErrors_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("ipFragFails",
                                         get_ipFragFails,
                                         ipFragFails_oid,
                                         OID_LENGTH(ipFragFails_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("ipInHdrErrors",
                                         get_ipInHdrErrors,
                                         ipInHdrErrors_oid,
                                         OID_LENGTH(ipInHdrErrors_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("ipForwDatagrams",
                                         get_ipForwDatagrams,
                                         ipForwDatagrams_oid,
                                         OID_LENGTH(ipForwDatagrams_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("ipForwarding",
                               do_ipForwarding,
                               ipForwarding_oid,
                               OID_LENGTH(ipForwarding_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("ipOutRequests",
                                         get_ipOutRequests,
                                         ipOutRequests_oid,
                                         OID_LENGTH(ipOutRequests_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("ipInDelivers",
                                         get_ipInDelivers,
                                         ipInDelivers_oid,
                                         OID_LENGTH(ipInDelivers_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("ipRoutingDiscards",
                                         get_ipRoutingDiscards,
                                         ipRoutingDiscards_oid,
                                         OID_LENGTH(ipRoutingDiscards_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("ipReasmReqds",
                                         get_ipReasmReqds,
                                         ipReasmReqds_oid,
                                         OID_LENGTH(ipReasmReqds_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("ipOutNoRoutes",
                                         get_ipOutNoRoutes,
                                         ipOutNoRoutes_oid,
                                         OID_LENGTH(ipOutNoRoutes_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("ipDefaultTTL",
                               do_ipDefaultTTL,
                               ipDefaultTTL_oid,
                               OID_LENGTH(ipDefaultTTL_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("ipReasmTimeout",
                                         get_ipReasmTimeout,
                                         ipReasmTimeout_oid,
                                         OID_LENGTH(ipReasmTimeout_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("ipInDiscards",
                                         get_ipInDiscards,
                                         ipInDiscards_oid,
                                         OID_LENGTH(ipInDiscards_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("ipOutDiscards",
                                         get_ipOutDiscards,
                                         ipOutDiscards_oid,
                                         OID_LENGTH(ipOutDiscards_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("ipReasmOKs",
                                         get_ipReasmOKs,
                                         ipReasmOKs_oid,
                                         OID_LENGTH(ipReasmOKs_oid),
                                         HANDLER_CAN_RONLY));

    REGISTER_SYSOR_ENTRY(ip_module_oid,
                         "The MIB module to describe  ipMIB and IcmpMIB.");
}

int
get_ipReasmFails(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

   struct ip_mib ipstat;

    if (IPAL_IF_GetAllIpv4Statistic(&ipstat)!= IPAL_RESULT_OK)
        return SNMP_ERR_GENERR;

    long_return = ipstat.ipReasmFails;

    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *)&long_return, sizeof(long_return));
            break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
get_ipFragCreates(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
   struct ip_mib ipstat;

   if (IPAL_IF_GetAllIpv4Statistic(&ipstat)!= IPAL_RESULT_OK)
       return SNMP_ERR_GENERR;

   long_return = ipstat.ipFragCreates;

    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *) &long_return , sizeof(long_return) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
get_ipInReceives(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
   struct ip_mib ipstat;

   if (IPAL_IF_GetAllIpv4Statistic(&ipstat)!= IPAL_RESULT_OK)
       return SNMP_ERR_GENERR;

   long_return = ipstat.ipInReceives;

    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *)&long_return, sizeof(long_return));
            break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
get_ipFragOKs(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
   struct ip_mib ipstat;

   if (IPAL_IF_GetAllIpv4Statistic(&ipstat)!= IPAL_RESULT_OK)
       return SNMP_ERR_GENERR;

   long_return = ipstat.ipFragOKs;

    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *)&long_return, sizeof(long_return));
            break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
get_ipInUnknownProtos(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
   struct ip_mib ipstat;

   if (IPAL_IF_GetAllIpv4Statistic(&ipstat)!= IPAL_RESULT_OK)
       return SNMP_ERR_GENERR;

   long_return = ipstat.ipInUnknownProtos;

    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *) &long_return, sizeof(long_return));
            break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
get_ipInAddrErrors(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
   struct ip_mib ipstat;

   if (IPAL_IF_GetAllIpv4Statistic(&ipstat)!= IPAL_RESULT_OK)
       return SNMP_ERR_GENERR;

   long_return = ipstat.ipInAddrErrors;

    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *)&long_return , sizeof(long_return));
            break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
get_ipFragFails(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
   struct ip_mib ipstat;

   if (IPAL_IF_GetAllIpv4Statistic(&ipstat)!= IPAL_RESULT_OK)
       return SNMP_ERR_GENERR;

   long_return = ipstat.ipFragFails;

    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *) &long_return, sizeof(long_return) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
get_ipInHdrErrors(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
   struct ip_mib ipstat;

   if (IPAL_IF_GetAllIpv4Statistic(&ipstat)!= IPAL_RESULT_OK)
       return SNMP_ERR_GENERR;

   long_return = ipstat.ipInHdrErrors;

    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *)&long_return, sizeof(long_return) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
get_ipForwDatagrams(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
   struct ip_mib ipstat;

   if (IPAL_IF_GetAllIpv4Statistic(&ipstat)!= IPAL_RESULT_OK)
       return SNMP_ERR_GENERR;

   long_return = ipstat.ipForwDatagrams;

    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *) &long_return, sizeof(long_return) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
do_ipForwarding(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
        {
            I32_T ipForwarding;

            if (IPAL_ROUTE_GetIpv4Forwarding(&ipForwarding) != IPAL_RESULT_OK)
                return SNMP_ERR_GENERR;

            if(0 == ipForwarding)
            {
                long_return = VAL_ipForwarding_notForwarding;
            }
            else
            {
                long_return = 0;
            }

            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return) );

        }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:

       {
       	UI32_T ipForwarding;

        if(requests->requestvb->type != ASN_INTEGER)
        {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
            break;
        }
        if(requests->requestvb->val_len > sizeof(long))
        {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGLENGTH);
            break;
        }
       	ipForwarding = (*requests->requestvb->val.integer);

       	if (( ipForwarding != 1 ) && (ipForwarding != 2))
       	{
            netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_WRONGVALUE);
            break;
       	}
       }
            break;

        case MODE_SET_RESERVE2:

            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
        {
            /* XXX: perform the value change here */
	          UI32_T ipForwarding;
			  UI32_T result;

#if 0  /* not support set currently */
	          ipForwarding = *requests->requestvb->val.integer;
	          if(ipForwarding == 1)
			      result = IPAL_ROUTE_EnableIpv4Forwarding();
			  else
			  	  result = IPAL_ROUTE_DisableIpv4Forwarding();

			  if(result != IPAL_RESULT_OK)
#endif
			  	 netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);

         }
           break;

        case MODE_SET_COMMIT:

            break;

        case MODE_SET_UNDO:

            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
get_ipOutRequests(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

	struct ip_mib ipstat;

    if (IPAL_IF_GetAllIpv4Statistic(&ipstat)!= IPAL_RESULT_OK)
  	  return SNMP_ERR_GENERR;

    long_return = ipstat.ipOutRequests;

    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *)&long_return, sizeof(long_return));
            break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
get_ipInDelivers(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    struct ip_mib ipstat;

    if (IPAL_IF_GetAllIpv4Statistic(&ipstat)!= IPAL_RESULT_OK)
  	  return SNMP_ERR_GENERR;

    long_return = ipstat.ipInDelivers;

    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *)&long_return, sizeof(long_return));
            break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
get_ipRoutingDiscards(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    struct ip_mib ipstat;

    if (IPAL_IF_GetAllIpv4Statistic(&ipstat)!= IPAL_RESULT_OK)
  	  return SNMP_ERR_GENERR;

    long_return = ipstat.ipRoutingDiscards;

    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *)&long_return , sizeof(long_return));
            break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
get_ipReasmReqds(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    struct ip_mib ipstat;

    if (IPAL_IF_GetAllIpv4Statistic(&ipstat)!= IPAL_RESULT_OK)
  	  return SNMP_ERR_GENERR;

    long_return = ipstat.ipReasmReqds;

    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *) &long_return, sizeof(long_return));
            break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
get_ipOutNoRoutes(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
	struct ip_mib ipstat;

    if (IPAL_IF_GetAllIpv4Statistic(&ipstat)!= IPAL_RESULT_OK)
 	 return SNMP_ERR_GENERR;

    long_return = ipstat.ipOutNoRoutes;

    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *) &long_return, sizeof(long_return));
            break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
do_ipDefaultTTL(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
          {
           	struct ip_mib ipstat;

			if (IPAL_IF_GetAllIpv4Statistic(&ipstat)!= IPAL_RESULT_OK)
				 return SNMP_ERR_GENERR;

			long_return = ipstat.ipDefaultTTL;

            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *)&long_return, sizeof(long_return));

          }
           break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:

        {
        	UI32_T ipDefaultTTL;
            if(requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
                break;
            }
            if(requests->requestvb->val_len > sizeof(long))
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGLENGTH);
                break;
            }
        	ipDefaultTTL = *requests->requestvb->val.integer;

            if (( ipDefaultTTL <= 0 )|| (ipDefaultTTL >255))
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
                break;
            }

        }
          break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */

            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
            {
		        UI32_T ipDefaultTTL;

		        ipDefaultTTL = *requests->requestvb->val.integer;
		        if (IPAL_IF_SetIpv4DefaultTtl(ipDefaultTTL) != IPAL_RESULT_OK)
		            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            }

            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */

            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */

            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
get_ipReasmTimeout(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
	struct ip_mib ipstat;

	if (IPAL_IF_GetAllIpv4Statistic(&ipstat)!= IPAL_RESULT_OK)
		 return SNMP_ERR_GENERR;

	long_return = ipstat.ipReasmTimeout;

    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *)&long_return , sizeof(long_return));
            break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
get_ipInDiscards(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

	struct ip_mib ipstat;

	if (IPAL_IF_GetAllIpv4Statistic(&ipstat)!= IPAL_RESULT_OK)
		 return SNMP_ERR_GENERR;

	long_return = ipstat.ipInDiscards;

    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *)&long_return, sizeof(long_return));
            break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
get_ipOutDiscards(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    struct ip_mib ipstat;

	if (IPAL_IF_GetAllIpv4Statistic(&ipstat)!= IPAL_RESULT_OK)
		 return SNMP_ERR_GENERR;

	long_return = ipstat.ipOutDiscards;

    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *)&long_return, sizeof(long_return));
            break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
get_ipReasmOKs(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    struct ip_mib ipstat;

	if (IPAL_IF_GetAllIpv4Statistic(&ipstat)!= IPAL_RESULT_OK)
		 return SNMP_ERR_GENERR;

	long_return = ipstat.ipReasmOKs;

    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *)&long_return , sizeof(long_return));
            break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}


/*
 * define the structure we're going to ask the agent to register our
 * information at
 */
struct variable1 ipaddr_variables[] = {
    {IPADADDR,      ASN_IPADDRESS, RONLY, var_ipAddrEntry, 1, {1}},
    {IPADIFINDEX,   ASN_INTEGER,   RONLY, var_ipAddrEntry, 1, {2}},
    {IPADNETMASK,   ASN_IPADDRESS, RONLY, var_ipAddrEntry, 1, {3}},
    {IPADBCASTADDR, ASN_INTEGER,   RONLY, var_ipAddrEntry, 1, {4}},
    {IPADREASMMAX,  ASN_INTEGER,   RONLY, var_ipAddrEntry, 1, {5}}
};

/*
 * Define the OID pointer to the top of the mib tree that we're
 * registering underneath, and the OID of the MIB module
 */
static oid             ipaddr_variables_oid[]  = { SNMP_OID_MIB2, 4, 20, 1 };


void
init_ipAddrEntry(void)
{
    /*
     * register ourselves with the agent to handle our mib tree
     */
    REGISTER_MIB("mibII/ipaddr", ipaddr_variables, variable1, ipaddr_variables_oid);

    REGISTER_SYSOR_ENTRY(ipaddr_variables_oid,
                         "The MIB module to describe generic objects for network interface sub-layers");
}



static int
header_ipAddrEntry(struct variable *vp,
               oid * name,
               size_t * length,
               int exact, size_t * var_len, WriteMethod ** write_method, UI32_T *index)
{
#define IPADDRENTRY_NAME_LENGTH	10
    oid             newname[MAX_OID_LEN];
    int             result;
   NETCFG_TYPE_InetRifConfig_T  entry;
   UI32_T Index = 0;
   UI32_T return_val = 0;
   oid  next_inst[4];

     memcpy((char *) newname, (char *) vp->name,
           (int) vp->namelen * sizeof(oid));
    /*
     * find "next" interface
     */
    memset(  &entry, 0 , sizeof(entry));

    /*
     * find "next" interface
     */

  while (return_val == 0)
     {
        return_val = NETCFG_POM_IP_GetNextRifConfig( &entry);
        IP_LIB_ArraytoUI32(entry.addr.addr, &Index);
        SNMP_MGR_BindIpInstance( Index, 0, next_inst);

        memcpy( (char*)&newname[IPADDRENTRY_NAME_LENGTH], (char*) next_inst,  4*sizeof(oid));
        result =
            snmp_oid_compare(name, *length, newname,
                             (int) vp->namelen +4);
        if ((exact && (result == 0)) || (!exact && (result < 0)))
            break;
    }
    if (return_val != NETCFG_TYPE_OK) {
        DEBUGMSGTL(("mibII/ip/ipAddrTable", "... index out of range\n"));
        return MATCH_FAILED;
    }
    memcpy((char *) name, (char *) newname,
           ((int) vp->namelen + 4) * sizeof(oid));
    *length = vp->namelen + 4;
    *write_method = 0;
    *var_len = sizeof(long);    /* default to 'long' results */
    *index = Index;
    return MATCH_SUCCEEDED;
}

/*
 * var_ipAddrTable():
 *   This function is called every time the agent gets a request for
 *   a scalar variable that might be found within your mib section
 *   registered above.  It is up to you to do the right thing and
 *   return the correct value.
 *     You should also correct the value of "var_len" if necessary.
 *
 *   Please see the documentation for more information about writing
 *   module extensions, and check out the examples in the examples
 *   and mibII directories.
 */
unsigned char *
var_ipAddrEntry(struct variable *vp,
                oid     *name,
                size_t  *length,
                int     exact,
                size_t  *var_len,
                WriteMethod **write_method)
{
    /* variables we may use later */
    int ret_val;
    UI32_T index;
    UI32_T mask = 0;
    NETCFG_TYPE_InetRifConfig_T  entry;

    memset( &entry, 0, sizeof(entry));
    ret_val =
        header_ipAddrEntry(vp, name, length, exact, var_len, write_method, &index);
    if (ret_val == MATCH_FAILED)
        return NULL;

    /* convert UI32 IP to array */
    if(IP_LIB_UI32toArray(index, entry.addr.addr)!=0)
    {
        return NULL; //SNMP_ERR_COMMITFAILED;
    }

    entry.addr.type = L_INET_ADDR_TYPE_IPV4;
    if (NETCFG_POM_IP_GetRifFromExactIp( &entry)!= NETCFG_TYPE_OK)
        return NULL;

    /*
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {

    case  IPADADDR:
    {
        *var_len = sizeof(ipaddr_return);
        memcpy(&ipaddr_return, entry.addr.addr, *var_len);
        return (u_char*) &ipaddr_return;
    }
    break;
    case  IPADIFINDEX:
    {
        long_return  = entry.ifindex;
        return (u_char*) &long_return;
    }
    break;
    case IPADNETMASK:
    {
        *var_len = sizeof(ipaddr_return);
        L_PREFIX_MaskLen2Ip((UI8_T)entry.addr.preflen, &mask);
        memcpy(&ipaddr_return, &mask, *var_len);
        return (u_char*) &ipaddr_return;
    }
    break;
    case IPADBCASTADDR:
    {
        long_return  = 1;
        return (u_char*) &long_return;
    }
    case  IPADREASMMAX:
    {
        /* Vai Wang, use 1500 temp. value, MUST be modified later */
        long_return = 1500;
        return (u_char*) &long_return;
    }
    default:
      ERROR_MSG("");
    }
    return NULL;
}



/*
 * define the structure we're going to ask the agent to register our
 * information at
 */
struct variable1 ipNetToMedia_variables[] = {
    {IPNETTOMEDIAIFINDEX,      ASN_INTEGER, RWRITE,  var_ipNetToMediaTable, 1, {1}},
    {IPNETTOMEDIAPHYSADDRESS,   ASN_OCTET_STR,   RWRITE,  var_ipNetToMediaTable, 1, {2}},
    {IPNETTOMEDIANETADDRESS,   ASN_IPADDRESS, RWRITE,  var_ipNetToMediaTable, 1, {3}},
    {IPNETTOMEDIATYPE,  ASN_INTEGER,   RWRITE,  var_ipNetToMediaTable, 1, {4}},
};


/*
 * ipNetToMediaTable_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

static oid             ipNetToMedia_variables_oid[]  = { SNMP_OID_MIB2, 4, 22, 1 };


void
init_ipNetToMediaTable(void)
{
    /*
     * register ourselves with the agent to handle our mib tree
     */

    REGISTER_MIB("mibII/ipNetToMedia", ipNetToMedia_variables, variable1, ipNetToMedia_variables_oid);

    REGISTER_SYSOR_ENTRY(ipNetToMedia_variables_oid,
                         "The MIB module to describe generic objects for mapping from IP address to physical address");
}


static BOOL_T
ipNetToMediaTable_get(int compc,
                            oid *compl,
                            NETCFG_TYPE_IpNetToMediaEntry_T *data)
{

    if(compc != ipNetToMediaEntry_INSTANCE_LEN)
    {
        return FALSE;
    }

    data->ip_net_to_media_if_index = compl[0];
    SNMP_MGR_ReadIpFromCompl(compl, 1, &data->ip_net_to_media_net_address);

    if(NETCFG_PMGR_ND_GetIpNetToMediaEntry(data) != TRUE)
    {

        return FALSE;
    }

    return TRUE;

}

static BOOL_T
ipNetToMediaTable_next(int compc,
                            oid *compl,
                            NETCFG_TYPE_IpNetToMediaEntry_T *data)
{
    oid tmp_compl[ipNetToMediaEntry_INSTANCE_LEN];

    memcpy(tmp_compl, compl, sizeof(tmp_compl));

    SNMP_MGR_checkCompl(1, 4, tmp_compl, 255);
    SNMP_MGR_ConvertRemainToZero(compc, ipNetToMediaEntry_INSTANCE_LEN, tmp_compl);

    data->ip_net_to_media_if_index = compl[0];
    SNMP_MGR_ReadIpFromCompl(compl, 1, &data->ip_net_to_media_net_address);
    if(NETCFG_PMGR_ND_GetNextIpNetToMediaEntry(data) != NETCFG_TYPE_OK)
    {
        return FALSE;
    }

    return TRUE;
}

/*
 * var_ipNetToMediaTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *
var_ipNetToMediaTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{

    UI32_T compc = 0;
    oid compl[ipNetToMediaEntry_INSTANCE_LEN];
    oid best_inst[ipNetToMediaEntry_INSTANCE_LEN];


    NETCFG_TYPE_IpNetToMediaEntry_T  data;
    int i=0;

    static  UI8_T   phy_addresst_string[NETCFG_TYPE_PHY_ADDRESEE_LENGTH];


     memset(&data, 0, sizeof(NETCFG_TYPE_IpNetToMediaEntry_T));

    switch(vp->magic)
     {
        case IPNETTOMEDIAPHYSADDRESS:
            *write_method = write_ipNetToMediaPhysAddress;
            break;
        case IPNETTOMEDIATYPE:
            *write_method = write_ipNetToMediaType;
            break;
        default:
            *write_method = 0;
            break;
    }

    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl, ipNetToMediaEntry_INSTANCE_LEN);

    if(exact)
    {
        if(!ipNetToMediaTable_get(compc, compl, &data))
        {
            return NULL;
        }
    }
    else
    {
        if(!ipNetToMediaTable_next(compc, compl, &data))
        {
            return NULL;
        }
    }

    memcpy(name, vp->name, vp->namelen*sizeof(oid));

    best_inst[0] = data.ip_net_to_media_if_index;
    SNMP_MGR_BindIpInstance(data.ip_net_to_media_net_address,1,best_inst);


    memcpy(name + vp->namelen, best_inst, ipNetToMediaEntry_INSTANCE_LEN*sizeof(oid));
    *length = vp->namelen + ipNetToMediaEntry_INSTANCE_LEN;

    /*
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic)
     {
    case IPNETTOMEDIAIFINDEX:
        *var_len = sizeof(long_return);
        long_return = data.ip_net_to_media_if_index;
        return (u_char*)&long_return;
    case IPNETTOMEDIAPHYSADDRESS:
         *var_len = data.ip_net_to_media_phys_address.phy_address_len;
         memcpy(phy_addresst_string, data.ip_net_to_media_phys_address.phy_address_cctet_string, *var_len);
        return (u_char*)& phy_addresst_string;
    case IPNETTOMEDIANETADDRESS:
        *var_len = sizeof(data.ip_net_to_media_net_address);
        long_return = data.ip_net_to_media_net_address;
        return (u_char*)&long_return;
    case IPNETTOMEDIATYPE:
        *var_len = sizeof(long_return);
        long_return = data.ip_net_to_media_type;
        switch(long_return)
        {
            case VAL_ipNetToMediaType_other:
                return (u_char*)&long_return;
            case VAL_ipNetToMediaType_invalid:
                return (u_char*)&long_return;
            case VAL_ipNetToMediaType_dynamic:
                return (u_char*)&long_return;
            case VAL_ipNetToMediaType_static:
                return (u_char*)&long_return;

            default:
                long_return = VAL_ipNetToMediaType_other;
                return (u_char*)&long_return;
        }
      default:
        break;

    }
    return NULL;
}



int
write_ipNetToMediaPhysAddress(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    NETCFG_TYPE_IpNetToMediaEntry_T data;
    long value=0;
    int size=0;

    UI16_T index_offset = ipNetToMediaEntry_OID_NAME_LEN;
    UI16_T ip_net_offset = ipNetToMediaEntry_OID_NAME_LEN +1;
    switch ( action )
        {
            case RESERVE1:
                if (var_val_type != ASN_OCTET_STR)
                {
                    return SNMP_ERR_WRONGTYPE;
                }

                if(name_len != ipNetToMediaEntry_OID_NAME_LEN + ipNetToMediaEntry_INSTANCE_LEN)
                {
                    return SNMP_ERR_WRONGLENGTH;
                }

                if (var_val_len > data.ip_net_to_media_phys_address.phy_address_len)
                {
                    return SNMP_ERR_WRONGLENGTH;
                }
                break;

            case RESERVE2:
                size  = var_val_len;
                memcpy(&value, var_val, size);
                if (value < 0)
                    return SNMP_ERR_WRONGVALUE;
                break;

            case FREE:
                 /* Release any resources that have been allocated */
              break;

            case ACTION:
                {
                   // data.ip_net_to_media_if_index = (UI32_T)name[index_offset];
                   data.ip_net_to_media_if_index = name[index_offset];
                    SNMP_MGR_ReadIpFromCompl(name, ip_net_offset, &data.ip_net_to_media_net_address);
                    memcpy(&data.ip_net_to_media_phys_address.phy_address_cctet_string, var_val, var_val_len);


                    if (NETCFG_PMGR_ND_AddStaticIpNetToMediaEntry(0, data.ip_net_to_media_net_address, SYS_ADPT_MAC_ADDR_LEN, data.ip_net_to_media_phys_address.phy_address_cctet_string)  != NETCFG_TYPE_OK)
                        return SNMP_ERR_COMMITFAILED;
                    break;
                }
        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}



int
write_ipNetToMediaType(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    NETCFG_TYPE_StaticIpNetToMediaEntry_T data;
    long value=0;
    int type=0;
    UI16_T index_offset = ipNetToMediaEntry_OID_NAME_LEN;
    UI16_T ip_net_offset = ipNetToMediaEntry_OID_NAME_LEN +1;
    switch ( action )
        {
            case RESERVE1:
                if (var_val_type != ASN_INTEGER)
                {
                    return SNMP_ERR_WRONGTYPE;
                }

                if(name_len != ipNetToMediaEntry_OID_NAME_LEN + ipNetToMediaEntry_INSTANCE_LEN)
                {
                    return SNMP_ERR_WRONGLENGTH;
                }

                if (var_val_len > sizeof(long))
                {
                    return SNMP_ERR_WRONGLENGTH;
                }
                break;

            case RESERVE2:
                value = *(long *)var_val;
                if (value < VAL_ipNetToMediaType_other || value> VAL_ipNetToMediaType_static)
                    return SNMP_ERR_WRONGVALUE;
                break;

            case FREE:
                 /* Release any resources that have been allocated */
              break;

            case ACTION:
                {
                    data.ip_net_to_media_entry.ip_net_to_media_if_index = name[index_offset];
                    SNMP_MGR_ReadIpFromCompl(name, ip_net_offset, &data.ip_net_to_media_entry.ip_net_to_media_net_address);

                    if( NETCFG_PMGR_ND_GetIpNetToMediaEntry(&data.ip_net_to_media_entry) != TRUE)
                        return SNMP_ERR_COMMITFAILED;

                    type = *(long *)var_val;


                    if (NETCFG_PMGR_ND_SetStaticIpNetToMediaEntry(&data, type)  != NETCFG_TYPE_OK)
                        return SNMP_ERR_COMMITFAILED;

                }
        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}



/** Initializes the icmp module */
void
init_icmp(void)
{

  static oid icmpOutSrcQuenchs_oid[] = { 1,3,6,1,2,1,5,19, 0 };
    static oid icmpInAddrMaskReps_oid[] = { 1,3,6,1,2,1,5,13, 0 };
    static oid icmpOutAddrMaskReps_oid[] = { 1,3,6,1,2,1,5,26, 0 };
    static oid icmpInRedirects_oid[] = { 1,3,6,1,2,1,5,7, 0 };
    static oid icmpInTimeExcds_oid[] = { 1,3,6,1,2,1,5,4, 0 };
    static oid icmpOutRedirects_oid[] = { 1,3,6,1,2,1,5,20, 0 };
    static oid icmpInTimestamps_oid[] = { 1,3,6,1,2,1,5,10, 0 };
    static oid icmpOutTimeExcds_oid[] = { 1,3,6,1,2,1,5,17, 0 };
    static oid icmpOutTimestamps_oid[] = { 1,3,6,1,2,1,5,23, 0 };
    static oid icmpInDestUnreachs_oid[] = { 1,3,6,1,2,1,5,3, 0 };
    static oid icmpOutDestUnreachs_oid[] = { 1,3,6,1,2,1,5,16, 0 };
    static oid icmpInTimestampReps_oid[] = { 1,3,6,1,2,1,5,11, 0 };
    static oid icmpOutTimestampReps_oid[] = { 1,3,6,1,2,1,5,24, 0 };
    static oid icmpInEchos_oid[] = { 1,3,6,1,2,1,5,8, 0 };
    static oid icmpOutEchos_oid[] = { 1,3,6,1,2,1,5,21, 0 };
    static oid icmpInParmProbs_oid[] = { 1,3,6,1,2,1,5,5, 0 };
    static oid icmpOutParmProbs_oid[] = { 1,3,6,1,2,1,5,18, 0 };
    static oid icmpInEchoReps_oid[] = { 1,3,6,1,2,1,5,9, 0 };
    static oid icmpInMsgs_oid[] = { 1,3,6,1,2,1,5,1, 0 };
    static oid icmpOutEchoReps_oid[] = { 1,3,6,1,2,1,5,22, 0 };
    static oid icmpInAddrMasks_oid[] = { 1,3,6,1,2,1,5,12, 0 };
    static oid icmpOutMsgs_oid[] = { 1,3,6,1,2,1,5,14, 0 };
    static oid icmpOutAddrMasks_oid[] = { 1,3,6,1,2,1,5,25, 0 };
    static oid icmpInErrors_oid[] = { 1,3,6,1,2,1,5,2, 0 };
    static oid icmpOutErrors_oid[] = { 1,3,6,1,2,1,5,15, 0 };
    static oid icmpInSrcQuenchs_oid[] = { 1,3,6,1,2,1,5,6, 0 };

  DEBUGMSGTL(("icmp", "Initializing\n"));

    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("icmpOutSrcQuenchs",
                                         get_icmpOutSrcQuenchs,
                                         icmpOutSrcQuenchs_oid,
                                         OID_LENGTH(icmpOutSrcQuenchs_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("icmpInAddrMaskReps",
                                         get_icmpInAddrMaskReps,
                                         icmpInAddrMaskReps_oid,
                                         OID_LENGTH(icmpInAddrMaskReps_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("icmpOutAddrMaskReps",
                                         get_icmpOutAddrMaskReps,
                                         icmpOutAddrMaskReps_oid,
                                         OID_LENGTH(icmpOutAddrMaskReps_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("icmpInRedirects",
                                         get_icmpInRedirects,
                                         icmpInRedirects_oid,
                                         OID_LENGTH(icmpInRedirects_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("icmpInTimeExcds",
                                         get_icmpInTimeExcds,
                                         icmpInTimeExcds_oid,
                                         OID_LENGTH(icmpInTimeExcds_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("icmpOutRedirects",
                                         get_icmpOutRedirects,
                                         icmpOutRedirects_oid,
                                         OID_LENGTH(icmpOutRedirects_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("icmpInTimestamps",
                                         get_icmpInTimestamps,
                                         icmpInTimestamps_oid,
                                         OID_LENGTH(icmpInTimestamps_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("icmpOutTimeExcds",
                                         get_icmpOutTimeExcds,
                                         icmpOutTimeExcds_oid,
                                         OID_LENGTH(icmpOutTimeExcds_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("icmpOutTimestamps",
                                         get_icmpOutTimestamps,
                                         icmpOutTimestamps_oid,
                                         OID_LENGTH(icmpOutTimestamps_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("icmpInDestUnreachs",
                                         get_icmpInDestUnreachs,
                                         icmpInDestUnreachs_oid,
                                         OID_LENGTH(icmpInDestUnreachs_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("icmpOutDestUnreachs",
                                         get_icmpOutDestUnreachs,
                                         icmpOutDestUnreachs_oid,
                                         OID_LENGTH(icmpOutDestUnreachs_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("icmpInTimestampReps",
                                         get_icmpInTimestampReps,
                                         icmpInTimestampReps_oid,
                                         OID_LENGTH(icmpInTimestampReps_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("icmpOutTimestampReps",
                                         get_icmpOutTimestampReps,
                                         icmpOutTimestampReps_oid,
                                         OID_LENGTH(icmpOutTimestampReps_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("icmpInEchos",
                                         get_icmpInEchos,
                                         icmpInEchos_oid,
                                         OID_LENGTH(icmpInEchos_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("icmpOutEchos",
                                         get_icmpOutEchos,
                                         icmpOutEchos_oid,
                                         OID_LENGTH(icmpOutEchos_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("icmpInParmProbs",
                                         get_icmpInParmProbs,
                                         icmpInParmProbs_oid,
                                         OID_LENGTH(icmpInParmProbs_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("icmpOutParmProbs",
                                         get_icmpOutParmProbs,
                                         icmpOutParmProbs_oid,
                                         OID_LENGTH(icmpOutParmProbs_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("icmpInEchoReps",
                                         get_icmpInEchoReps,
                                         icmpInEchoReps_oid,
                                         OID_LENGTH(icmpInEchoReps_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("icmpInMsgs",
                                         get_icmpInMsgs,
                                         icmpInMsgs_oid,
                                         OID_LENGTH(icmpInMsgs_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("icmpOutEchoReps",
                                         get_icmpOutEchoReps,
                                         icmpOutEchoReps_oid,
                                         OID_LENGTH(icmpOutEchoReps_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("icmpInAddrMasks",
                                         get_icmpInAddrMasks,
                                         icmpInAddrMasks_oid,
                                         OID_LENGTH(icmpInAddrMasks_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("icmpOutMsgs",
                                         get_icmpOutMsgs,
                                         icmpOutMsgs_oid,
                                         OID_LENGTH(icmpOutMsgs_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("icmpOutAddrMasks",
                                         get_icmpOutAddrMasks,
                                         icmpOutAddrMasks_oid,
                                         OID_LENGTH(icmpOutAddrMasks_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("icmpInErrors",
                                         get_icmpInErrors,
                                         icmpInErrors_oid,
                                         OID_LENGTH(icmpInErrors_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("icmpOutErrors",
                                         get_icmpOutErrors,
                                         icmpOutErrors_oid,
                                         OID_LENGTH(icmpOutErrors_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("icmpInSrcQuenchs",
                                         get_icmpInSrcQuenchs,
                                         icmpInSrcQuenchs_oid,
                                         OID_LENGTH(icmpInSrcQuenchs_oid),
                                         HANDLER_CAN_RONLY));
}

int
get_icmpOutSrcQuenchs(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
	struct icmp_mib icmpstat;

	if (IPAL_IF_GetAllIcmpStatistic(&icmpstat)!= IPAL_RESULT_OK)
		 return SNMP_ERR_GENERR;

	long_return = icmpstat.icmpOutSrcQuenchs;

    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *) &long_return , sizeof(long_return) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
get_icmpInAddrMaskReps(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
	struct icmp_mib icmpstat;

	if (IPAL_IF_GetAllIcmpStatistic(&icmpstat)!= IPAL_RESULT_OK)
		 return SNMP_ERR_GENERR;

	long_return = icmpstat.icmpInAddrMaskReps;

    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *) &long_return , sizeof(long_return) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
get_icmpOutAddrMaskReps(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
	struct icmp_mib icmpstat;

	if (IPAL_IF_GetAllIcmpStatistic(&icmpstat)!= IPAL_RESULT_OK)
		 return SNMP_ERR_GENERR;

	long_return = icmpstat.icmpOutAddrMaskReps;

    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *) &long_return , sizeof(long_return) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_icmpInRedirects(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
	struct icmp_mib icmpstat;

	if (IPAL_IF_GetAllIcmpStatistic(&icmpstat)!= IPAL_RESULT_OK)
		 return SNMP_ERR_GENERR;

	long_return = icmpstat.icmpInRedirects;

    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *) &long_return , sizeof(long_return) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_icmpInTimeExcds(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
	struct icmp_mib icmpstat;

	if (IPAL_IF_GetAllIcmpStatistic(&icmpstat)!= IPAL_RESULT_OK)
		 return SNMP_ERR_GENERR;

	long_return = icmpstat.icmpInTimeExcds;

    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *) &long_return , sizeof(long_return) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_icmpOutRedirects(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
	struct icmp_mib icmpstat;

	if (IPAL_IF_GetAllIcmpStatistic(&icmpstat)!= IPAL_RESULT_OK)
		 return SNMP_ERR_GENERR;

	long_return = icmpstat.icmpOutRedirects;

    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *) &long_return , sizeof(long_return) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_icmpInTimestamps(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
	struct icmp_mib icmpstat;

	if (IPAL_IF_GetAllIcmpStatistic(&icmpstat)!= IPAL_RESULT_OK)
		 return SNMP_ERR_GENERR;

	long_return = icmpstat.icmpInTimestamps;

    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *) &long_return , sizeof(long_return) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_icmpOutTimeExcds(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
	struct icmp_mib icmpstat;

	if (IPAL_IF_GetAllIcmpStatistic(&icmpstat)!= IPAL_RESULT_OK)
		 return SNMP_ERR_GENERR;

	long_return = icmpstat.icmpOutTimeExcds;

    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *) &long_return , sizeof(long_return) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_icmpOutTimestamps(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
	struct icmp_mib icmpstat;

	if (IPAL_IF_GetAllIcmpStatistic(&icmpstat)!= IPAL_RESULT_OK)
		 return SNMP_ERR_GENERR;

	long_return = icmpstat.icmpOutTimestamps;

    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *) &long_return , sizeof(long_return) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}


int
get_icmpInDestUnreachs(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
	struct icmp_mib icmpstat;

	if (IPAL_IF_GetAllIcmpStatistic(&icmpstat)!= IPAL_RESULT_OK)
		 return SNMP_ERR_GENERR;

	long_return = icmpstat.icmpInDestUnreachs;

    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *) &long_return , sizeof(long_return) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_icmpOutDestUnreachs(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
	struct icmp_mib icmpstat;

	if (IPAL_IF_GetAllIcmpStatistic(&icmpstat)!= IPAL_RESULT_OK)
		 return SNMP_ERR_GENERR;

	long_return = icmpstat.icmpOutDestUnreachs;

    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *) &long_return , sizeof(long_return) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}


int
get_icmpInTimestampReps(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
	struct icmp_mib icmpstat;

	if (IPAL_IF_GetAllIcmpStatistic(&icmpstat)!= IPAL_RESULT_OK)
		 return SNMP_ERR_GENERR;

	long_return = icmpstat.icmpInTimestampReps;

    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *) &long_return , sizeof(long_return) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_icmpOutTimestampReps(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
	struct icmp_mib icmpstat;

	if (IPAL_IF_GetAllIcmpStatistic(&icmpstat)!= IPAL_RESULT_OK)
		 return SNMP_ERR_GENERR;

	long_return = icmpstat.icmpOutTimestampReps;

    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *) &long_return , sizeof(long_return) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_icmpInEchos(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
	struct icmp_mib icmpstat;

	if (IPAL_IF_GetAllIcmpStatistic(&icmpstat)!= IPAL_RESULT_OK)
		 return SNMP_ERR_GENERR;

	long_return = icmpstat.icmpInEchos;

    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *) &long_return , sizeof(long_return) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_icmpOutEchos(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
	struct icmp_mib icmpstat;

	if (IPAL_IF_GetAllIcmpStatistic(&icmpstat)!= IPAL_RESULT_OK)
		 return SNMP_ERR_GENERR;

	long_return = icmpstat.icmpOutEchos;

    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *) &long_return , sizeof(long_return) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_icmpInParmProbs(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
	struct icmp_mib icmpstat;

	if (IPAL_IF_GetAllIcmpStatistic(&icmpstat)!= IPAL_RESULT_OK)
		 return SNMP_ERR_GENERR;

	long_return = icmpstat.icmpInParmProbs;

    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *) &long_return , sizeof(long_return) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_icmpOutParmProbs(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
	struct icmp_mib icmpstat;

	if (IPAL_IF_GetAllIcmpStatistic(&icmpstat)!= IPAL_RESULT_OK)
		 return SNMP_ERR_GENERR;

	long_return = icmpstat.icmpOutParmProbs;

    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *) &long_return , sizeof(long_return) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_icmpInEchoReps(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
	struct icmp_mib icmpstat;

	if (IPAL_IF_GetAllIcmpStatistic(&icmpstat)!= IPAL_RESULT_OK)
		 return SNMP_ERR_GENERR;

	long_return = icmpstat.icmpInEchoReps;

    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *) &long_return , sizeof(long_return) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_icmpInMsgs(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
	struct icmp_mib icmpstat;

	if (IPAL_IF_GetAllIcmpStatistic(&icmpstat)!= IPAL_RESULT_OK)
		 return SNMP_ERR_GENERR;

	long_return = icmpstat.icmpInMsgs;

    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *) &long_return , sizeof(long_return) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}


int
get_icmpOutEchoReps(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
	struct icmp_mib icmpstat;

	if (IPAL_IF_GetAllIcmpStatistic(&icmpstat)!= IPAL_RESULT_OK)
		 return SNMP_ERR_GENERR;

	long_return = icmpstat.icmpOutEchoReps;

    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *) &long_return , sizeof(long_return) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_icmpInAddrMasks(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
	struct icmp_mib icmpstat;

	if (IPAL_IF_GetAllIcmpStatistic(&icmpstat)!= IPAL_RESULT_OK)
		 return SNMP_ERR_GENERR;

	long_return = icmpstat.icmpInAddrMasks;

    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *) &long_return , sizeof(long_return) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_icmpOutMsgs(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
	struct icmp_mib icmpstat;

	if (IPAL_IF_GetAllIcmpStatistic(&icmpstat)!= IPAL_RESULT_OK)
		 return SNMP_ERR_GENERR;

	long_return = icmpstat.icmpOutMsgs;

    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *) &long_return , sizeof(long_return) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_icmpOutAddrMasks(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
	struct icmp_mib icmpstat;

	if (IPAL_IF_GetAllIcmpStatistic(&icmpstat)!= IPAL_RESULT_OK)
		 return SNMP_ERR_GENERR;

	long_return = icmpstat.icmpOutAddrMasks;

    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *) &long_return , sizeof(long_return) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_icmpInErrors(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
	struct icmp_mib icmpstat;

	if (IPAL_IF_GetAllIcmpStatistic(&icmpstat)!= IPAL_RESULT_OK)
		 return SNMP_ERR_GENERR;

	long_return = icmpstat.icmpInErrors;

    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *) &long_return , sizeof(long_return) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_icmpOutErrors(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
	struct icmp_mib icmpstat;

	if (IPAL_IF_GetAllIcmpStatistic(&icmpstat)!= IPAL_RESULT_OK)
		 return SNMP_ERR_GENERR;

	long_return = icmpstat.icmpOutErrors;

    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *) &long_return , sizeof(long_return) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_icmpInSrcQuenchs(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
	struct icmp_mib icmpstat;

	if (IPAL_IF_GetAllIcmpStatistic(&icmpstat)!= IPAL_RESULT_OK)
		 return SNMP_ERR_GENERR;

	long_return = icmpstat.icmpInSrcQuenchs;

    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *) &long_return , sizeof(long_return) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

