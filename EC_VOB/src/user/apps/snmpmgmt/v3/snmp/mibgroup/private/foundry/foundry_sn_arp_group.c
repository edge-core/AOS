/* MODULE NAME:  foundry_sn_arp_group.c
 *
 * PURPOSE: For SNMP to access Brocade's FOUNDRY-SN-ARP-GROUP-MIB:
 *
 * foundry(1991).products(1).switch(1).snSwitch(3).snArpInfo(22)
 *
 * NOTES:
 *
 * HISTORY (mm/dd/yyyy)
 *    05/28/2011 - Qiyao Zhong, Created
 *
 * Copyright(C)      Accton Corporation, 2011
 */

/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.scalar.conf,v 1.8 2004/10/14 12:57:34 dts12 Exp $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

/* system
 */
#include "sys_type.h"
#include "sys_adpt.h"
#include "sys_cpnt.h"
#include "leaf_sys.h"
#include "leaf_foundry_sn_arp_group.h"

/* core (L3)
 */
#include "netcfg_type.h"
#include "netcfg_pmgr_main.h"

/* SNMP itself
 */
#include "snmp_mgr.h"
#include "sysORTable.h"
#include "foundry_lib.h"
#include "foundry_sn_arp_group.h"

#if (SYS_CPNT_ROUTING == TRUE)  /* from near-beginning to end of file */
/* ------------------------------------------------------------------------
 * SCALAR NAME - 1.1.3.22.1.1 snArpStatsTotalReceived
 * ------------------------------------------------------------------------
 */
void init_snArpStatsTotalReceived(void)
{
    static oid snArpStatsTotalReceived_oid[] = { 1,3,6,1,4,1,1991,1,1,3,22,1,1, 0 };

    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("snArpStatsTotalReceived",
                                         get_snArpStatsTotalReceived,
                                         snArpStatsTotalReceived_oid,
                                         OID_LENGTH(snArpStatsTotalReceived_oid),
                                         HANDLER_CAN_RONLY));
}

int get_snArpStatsTotalReceived(netsnmp_mib_handler *handler,
    netsnmp_handler_registration *reginfo,
    netsnmp_agent_request_info *reqinfo,
    netsnmp_request_info *requests)
{
    /* dispatch get vs. set
     */
    switch (reqinfo->mode)
    {
        /*
         * GET REQUEST
         */
        case MODE_GET:
        {
            NETCFG_TYPE_IpNetToMedia_Statistics_T stat;

            /* get from core layer
             */
            memset(&stat, 0, sizeof(NETCFG_TYPE_IpNetToMedia_Statistics_T));

            if (NETCFG_PMGR_ND_GetStatistics(&stat) != NETCFG_TYPE_OK)
            {
                return SNMP_ERR_GENERR;
            }
            else
            {
                long_return = stat.in_request + stat.in_reply;
                snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER,
                    (u_char *) &long_return, sizeof(UI32_T));
            }

            break;
        }

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

/* ------------------------------------------------------------------------
 * SCALAR NAME - 1.1.3.22.1.2 snArpStatsRequestReceived
 * ------------------------------------------------------------------------
 */
void init_snArpStatsRequestReceived(void)
{
    static oid snArpStatsRequestReceived_oid[] = { 1,3,6,1,4,1,1991,1,1,3,22,1,2, 0 };

    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("snArpStatsRequestReceived",
                                         get_snArpStatsRequestReceived,
                                         snArpStatsRequestReceived_oid,
                                         OID_LENGTH(snArpStatsRequestReceived_oid),
                                         HANDLER_CAN_RONLY));
}

int get_snArpStatsRequestReceived(netsnmp_mib_handler *handler,
    netsnmp_handler_registration *reginfo,
    netsnmp_agent_request_info *reqinfo,
    netsnmp_request_info *requests)
{
    /* dispatch get vs. set
     */
    switch (reqinfo->mode)
    {
        /*
         * GET REQUEST
         */
        case MODE_GET:
        {
            NETCFG_TYPE_IpNetToMedia_Statistics_T stat;

            /* get from core layer
             */
            memset(&stat, 0, sizeof(NETCFG_TYPE_IpNetToMedia_Statistics_T));

            if (NETCFG_PMGR_ND_GetStatistics(&stat) != NETCFG_TYPE_OK)
            {
                return SNMP_ERR_GENERR;
            }
            else
            {
                long_return = stat.in_request;
                snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER,
                    (u_char *) &long_return, sizeof(UI32_T));
            }

            break;
        }

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

/* ------------------------------------------------------------------------
 * SCALAR NAME - 1.1.3.22.1.3 snArpStatsRequestSent
 * ------------------------------------------------------------------------
 */
void init_snArpStatsRequestSent(void)
{
    static oid snArpStatsRequestSent_oid[] = { 1,3,6,1,4,1,1991,1,1,3,22,1,3, 0 };

    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("snArpStatsRequestSent",
                                         get_snArpStatsRequestSent,
                                         snArpStatsRequestSent_oid,
                                         OID_LENGTH(snArpStatsRequestSent_oid),
                                         HANDLER_CAN_RONLY));
}

int get_snArpStatsRequestSent(netsnmp_mib_handler *handler,
    netsnmp_handler_registration *reginfo,
    netsnmp_agent_request_info *reqinfo,
    netsnmp_request_info *requests)
{
    /* dispatch get vs. set
     */
    switch (reqinfo->mode)
    {
        /*
         * GET REQUEST
         */
        case MODE_GET:
        {
            NETCFG_TYPE_IpNetToMedia_Statistics_T stat;

            /* get from core layer
             */
            memset(&stat, 0, sizeof(NETCFG_TYPE_IpNetToMedia_Statistics_T));

            if (NETCFG_PMGR_ND_GetStatistics(&stat) != NETCFG_TYPE_OK)
            {
                return SNMP_ERR_GENERR;
            }
            else
            {
                long_return = stat.out_request;
                snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER,
                    (u_char *) &long_return, sizeof(UI32_T));
            }

            break;
        }

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

/* ------------------------------------------------------------------------
 * SCALAR NAME - 1.1.3.22.1.4 snArpStatsRepliesSent
 * ------------------------------------------------------------------------
 */
void init_snArpStatsRepliesSent(void)
{
    static oid snArpStatsRepliesSent_oid[] = { 1,3,6,1,4,1,1991,1,1,3,22,1,4, 0 };

    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("snArpStatsRepliesSent",
                                         get_snArpStatsRepliesSent,
                                         snArpStatsRepliesSent_oid,
                                         OID_LENGTH(snArpStatsRepliesSent_oid),
                                         HANDLER_CAN_RONLY));
}

int get_snArpStatsRepliesSent(netsnmp_mib_handler *handler,
    netsnmp_handler_registration *reginfo,
    netsnmp_agent_request_info *reqinfo,
    netsnmp_request_info *requests)
{
    /* dispatch get vs. set
     */
    switch (reqinfo->mode)
    {
        /*
         * GET REQUEST
         */
        case MODE_GET:
        {
            NETCFG_TYPE_IpNetToMedia_Statistics_T stat;

            /* get from core layer
             */
            memset(&stat, 0, sizeof(NETCFG_TYPE_IpNetToMedia_Statistics_T));

            if (NETCFG_PMGR_ND_GetStatistics(&stat) != NETCFG_TYPE_OK)
            {
                return SNMP_ERR_GENERR;
            }
            else
            {
                long_return = stat.out_reply;
                snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER,
                    (u_char *) &long_return, sizeof(UI32_T));
            }

            break;
        }

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

/* ------------------------------------------------------------------------
 * FUNCTION NAME - init_snArpInfo
 * ------------------------------------------------------------------------
 * PURPOSE  :   This is the entry point into this file for initialisation.
 *
 * INPUT    :   None.
 *
 * OUTPUT   :   None.
 *
 * RETURN   :   None.
 *
 * NOTES    :   None.
 * ------------------------------------------------------------------------
 */
void init_snArpInfo(void)
{
    oid snSwitch_oid[] = { 1,3,6,1,4,1,1991,1,1,3,22 };

    /* register individual scalars
     */
    init_snArpStatsTotalReceived();     /* 1.1 */
    init_snArpStatsRequestReceived();   /* 1.2 */
    init_snArpStatsRequestSent();       /* 1.3 */
    init_snArpStatsRepliesSent();       /* 1.4 */    

    /* register individual subtrees
     */

    /* register ourselves in the sysORTable
     */
    REGISTER_SYSOR_ENTRY(snSwitch_oid,
        "The Enterprise MIB for ARP support in SNMP.");
}
#endif  /* (SYS_CPNT_ROUTING == TRUE); from near-beginning to end of file */ */
