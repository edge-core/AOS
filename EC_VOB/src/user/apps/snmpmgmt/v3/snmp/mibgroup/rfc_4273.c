/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.scalar.conf,v 1.8 2004/10/14 12:57:34 dts12 Exp $
 */
#include "sys_cpnt.h"
#if (SYS_CPNT_BGP == TRUE)
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "rfc_4273.h"
#include "leaf_4273.h"
#include "bgp_type.h"
#include "bgp_pmgr.h"
#include "l_inet.h"
#include "snmp_mgr.h"

void init_bgpVersion(void)
{
    static oid bgpVersion_oid[] = { 1,3,6,1,2,1,15,1,0 };

    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("bgpVersion",
                                         get_bgpVersion,
                                         bgpVersion_oid,
                                         OID_LENGTH(bgpVersion_oid),
                                         HANDLER_CAN_RONLY));
}

int get_bgpVersion(netsnmp_mib_handler *handler,
    netsnmp_handler_registration *reginfo,
    netsnmp_agent_request_info *reqinfo,
    netsnmp_request_info *requests)
{
    switch (reqinfo->mode)
    {
        case MODE_GET:
        {
            UI32_T var_len = 0;

            if (BGP_PMGR_MIB_GetBgpVersion((char *)return_buf) == BGP_TYPE_RESULT_OK)
            {
                var_len = strlen((char *)return_buf);
                snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, (u_char *)return_buf, var_len);
            }
            else
            {
                return SNMP_ERR_GENERR;
            }

            break;
        }


        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

void init_bgpLocalAs(void)
{
    static oid bgpLocalAs_oid[] = { 1,3,6,1,2,1,15,2,0 };

    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("bgpLocalAs",
                                         get_bgpLocalAs,
                                         bgpLocalAs_oid,
                                         OID_LENGTH(bgpLocalAs_oid),
                                         HANDLER_CAN_RONLY));
}

int get_bgpLocalAs(netsnmp_mib_handler *handler,
    netsnmp_handler_registration *reginfo,
    netsnmp_agent_request_info *reqinfo,
    netsnmp_request_info *requests)
{
    switch (reqinfo->mode)
    {
        case MODE_GET:
        {
            UI32_T value = 0;

            if (BGP_PMGR_MIB_GetBgpLocalAs(&value) == BGP_TYPE_RESULT_OK)
            {
                long_return = value;
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *)&long_return, sizeof(long_return));
            }
            else
            {
                return SNMP_ERR_GENERR;
            }

            break;
        }


        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}


oid bgpPeerTable_variables_oid[] = { 1,3,6,1,2,1,15 };

/* variable3 bgpPeerTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */
struct variable3 bgpPeerTable_variables[] =
{
/* magic number, variable type, ro/rw, callback fn, L, oidsuffix
 */
    { LEAF_bgpPeerIdentifier, ASN_IPADDRESS, RONLY, var_bgpPeerTable, 3, { 3, 1, 1 }},
    { LEAF_bgpPeerState, ASN_INTEGER, RONLY, var_bgpPeerTable, 3, { 3, 1, 2 }},
    { LEAF_bgpPeerAdminStatus, ASN_INTEGER, RWRITE, var_bgpPeerTable, 3, { 3, 1, 3 }},
    { LEAF_bgpPeerNegotiatedVersion, ASN_INTEGER, RONLY, var_bgpPeerTable, 3, { 3, 1, 4 }},
    { LEAF_bgpPeerLocalAddr, ASN_IPADDRESS, RONLY, var_bgpPeerTable, 3, { 3, 1, 5 }},
    { LEAF_bgpPeerLocalPort, ASN_INTEGER, RONLY, var_bgpPeerTable, 3, { 3, 1, 6 }},
    { LEAF_bgpPeerRemoteAddr, ASN_IPADDRESS, RONLY, var_bgpPeerTable, 3, { 3, 1, 7 }},
    { LEAF_bgpPeerRemotePort, ASN_INTEGER, RONLY, var_bgpPeerTable, 3, { 3, 1, 8 }},
    { LEAF_bgpPeerRemoteAs, ASN_INTEGER, RONLY, var_bgpPeerTable, 3, { 3, 1, 9 }},
    { LEAF_bgpPeerInUpdates, ASN_COUNTER, RONLY, var_bgpPeerTable, 3, { 3, 1, 10 }},
    { LEAF_bgpPeerOutUpdates, ASN_COUNTER, RONLY, var_bgpPeerTable, 3, { 3, 1, 11 }},
    { LEAF_bgpPeerInTotalMessages, ASN_COUNTER, RONLY, var_bgpPeerTable, 3, { 3, 1, 12 }},
    { LEAF_bgpPeerOutTotalMessages, ASN_COUNTER, RONLY, var_bgpPeerTable, 3, { 3, 1, 13 }},
    { LEAF_bgpPeerLastError, ASN_OCTET_STR, RONLY, var_bgpPeerTable, 3, { 3, 1, 14 }},
    { LEAF_bgpPeerFsmEstablishedTransitions, ASN_COUNTER, RONLY, var_bgpPeerTable, 3, { 3, 1, 15 }},
    { LEAF_bgpPeerFsmEstablishedTime, ASN_GAUGE, RONLY, var_bgpPeerTable, 3, { 3, 1, 16 }},
    { LEAF_bgpPeerConnectRetryInterval, ASN_INTEGER, RWRITE, var_bgpPeerTable, 3, { 3, 1, 17 }},
    { LEAF_bgpPeerHoldTime, ASN_INTEGER, RONLY, var_bgpPeerTable, 3, { 3, 1, 18 }},
    { LEAF_bgpPeerKeepAlive, ASN_INTEGER, RONLY, var_bgpPeerTable, 3, { 3, 1, 19 }},
    { LEAF_bgpPeerHoldTimeConfigured, ASN_INTEGER, RWRITE, var_bgpPeerTable, 3, { 3, 1, 20 }},
    { LEAF_bgpPeerKeepAliveConfigured, ASN_INTEGER, RWRITE, var_bgpPeerTable, 3, { 3, 1, 21 }},
    { LEAF_bgpPeerMinASOriginationInterval, ASN_INTEGER, RWRITE, var_bgpPeerTable, 3, { 3, 1, 22 }},
    { LEAF_bgpPeerMinRouteAdvertisementInterval, ASN_INTEGER, RWRITE, var_bgpPeerTable, 3, { 3, 1, 23 }},
    { LEAF_bgpPeerInUpdateElapsedTime, ASN_GAUGE, RONLY, var_bgpPeerTable, 3, { 3, 1, 24 }},
};

void init_bgpPeerTable(void)
{
    REGISTER_MIB("bgpPeerTable", bgpPeerTable_variables, variable3,
                 bgpPeerTable_variables_oid);
}

#define BGPPEERENTRY_INSTANCE_LEN  4

BOOL_T bgpPeerTable_OidIndexToData(UI32_T exact, UI32_T compc,
    oid *compl, L_INET_AddrIp_T *bgpPeerRemoteAddr)
{
    /* get or set
     */
    if (exact)
    {
        /* check the index length
         */
        if (compc != BGPPEERENTRY_INSTANCE_LEN) /* the constant size index */
        {
            return FALSE;
        }
    }

    memset(bgpPeerRemoteAddr, 0, sizeof(L_INET_AddrIp_T));
    bgpPeerRemoteAddr->addr[0]=(UI8_T)compl[0];
    bgpPeerRemoteAddr->addr[1]=(UI8_T)compl[1];
    bgpPeerRemoteAddr->addr[2]=(UI8_T)compl[2];
    bgpPeerRemoteAddr->addr[3]=(UI8_T)compl[3];
    bgpPeerRemoteAddr->type = L_INET_ADDR_TYPE_IPV4;
    bgpPeerRemoteAddr->addrlen = SYS_ADPT_IPV4_ADDR_LEN;

    return TRUE;
}

/*
 * var_bgpPeerTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *var_bgpPeerTable(struct variable *vp,
    oid *name,
    size_t *length,
    int exact,
    size_t *var_len,
    WriteMethod **write_method)
{
    UI32_T compc = 0;
    oid compl[BGPPEERENTRY_INSTANCE_LEN] = {0};
    oid best_inst[BGPPEERENTRY_INSTANCE_LEN] = {0};
    BGP_TYPE_MIB_BgpPeerEntry_T entry;

    switch (vp->magic)
    {
        case LEAF_bgpPeerAdminStatus:
            *write_method = write_bgpPeerAdminStatus;
            break;

        case LEAF_bgpPeerConnectRetryInterval:
            *write_method = write_bgpPeerConnectRetryInterval;
            break;

        case LEAF_bgpPeerHoldTimeConfigured:
            *write_method = write_bgpPeerHoldTimeConfigured;
            break;

        case LEAF_bgpPeerKeepAliveConfigured:
            *write_method = write_bgpPeerKeepAliveConfigured;
            break;

        case LEAF_bgpPeerMinASOriginationInterval:
            *write_method = write_bgpPeerMinASOriginationInterval;
            break;

        case LEAF_bgpPeerMinRouteAdvertisementInterval:
            *write_method = write_bgpPeerMinRouteAdvertisementInterval;
            break;

        default:
            *write_method = 0;
            break;
    }

    /* check compc, retrive compl
     */
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl, BGPPEERENTRY_INSTANCE_LEN);

    memset(&entry, 0, sizeof(entry));

    if (exact) /* get or set */
    {
        if (bgpPeerTable_OidIndexToData(exact, compc, compl, &entry.bgpPeerRemoteAddr) == FALSE)
        {
            return NULL;
        }

        if (BGP_PMGR_MIB_GetBgpPeerEntry(&entry) != BGP_TYPE_RESULT_OK)
        {
            return NULL;
        }
    }
    else /* getnext */
    {
        bgpPeerTable_OidIndexToData(exact, compc, compl, &entry.bgpPeerRemoteAddr);

        /* check the length of inputing index,if < 1 we should try get
         * {0.0.0.0.0...}
         */
        if (compc < 1)
        {
            if (BGP_PMGR_MIB_GetBgpPeerEntry(&entry) != BGP_TYPE_RESULT_OK)
            {
                if (BGP_PMGR_MIB_GetNextBgpPeerEntry(&entry) != BGP_TYPE_RESULT_OK)
                {
                    return NULL;
                }
            }
        }
        else
        {
            if (BGP_PMGR_MIB_GetNextBgpPeerEntry(&entry) != BGP_TYPE_RESULT_OK)
            {
                return NULL;
            }
        }
    }

    memcpy(name, vp->name, vp->namelen * sizeof(oid));

    /* assign data to the oid index
     */
    best_inst[0] = entry.bgpPeerRemoteAddr.addr[0];
    best_inst[1] = entry.bgpPeerRemoteAddr.addr[1];
    best_inst[2] = entry.bgpPeerRemoteAddr.addr[2];
    best_inst[3] = entry.bgpPeerRemoteAddr.addr[3];
    memcpy(name + vp->namelen, best_inst, BGPPEERENTRY_INSTANCE_LEN * sizeof(oid));
    *length = vp->namelen + BGPPEERENTRY_INSTANCE_LEN;

    switch (vp->magic)
    {
        case LEAF_bgpPeerIdentifier:
            *var_len = sizeof(ipaddr_return);
            ipaddr_return = entry.bgpPeerIdentifier;
            return (u_char *) &ipaddr_return;

        case LEAF_bgpPeerState:
            *var_len = sizeof(long_return);
            long_return = entry.bgpPeerState;
            return (u_char *) &long_return;

        case LEAF_bgpPeerAdminStatus:
            *var_len = sizeof(long_return);
            long_return = entry.bgpPeerAdminStatus;
            return (u_char *) &long_return;

        case LEAF_bgpPeerNegotiatedVersion:
            *var_len = sizeof(long_return);
            long_return = entry.bgpPeerNegotiatedVersion;
            return (u_char *) &long_return;

        case LEAF_bgpPeerLocalAddr:
            *var_len = sizeof(ipaddr_return);
            memcpy(&ipaddr_return, entry.bgpPeerLocalAddr.addr, *var_len);
            return (u_char *) &ipaddr_return;

        case LEAF_bgpPeerLocalPort:
            *var_len = sizeof(long_return);
            long_return = entry.bgpPeerLocalPort;
            return (u_char *) &long_return;

        case LEAF_bgpPeerRemoteAddr:
            *var_len = sizeof(ipaddr_return);
            memcpy(&ipaddr_return, entry.bgpPeerRemoteAddr.addr, *var_len);
            return (u_char *) &ipaddr_return;

        case LEAF_bgpPeerRemotePort:
            *var_len = sizeof(long_return);
            long_return = entry.bgpPeerRemotePort;
            return (u_char *) &long_return;

        case LEAF_bgpPeerRemoteAs:
            *var_len = sizeof(long_return);
            long_return = entry.bgpPeerRemoteAs;
            return (u_char *) &long_return;

        case LEAF_bgpPeerInUpdates:
            *var_len = sizeof(long_return);
            long_return = entry.bgpPeerInUpdates;
            return (u_char *) &long_return;

        case LEAF_bgpPeerOutUpdates:
            *var_len = sizeof(long_return);
            long_return = entry.bgpPeerOutUpdates;
            return (u_char *) &long_return;

        case LEAF_bgpPeerInTotalMessages:
            *var_len = sizeof(long_return);
            long_return = entry.bgpPeerInTotalMessages;
            return (u_char *) &long_return;

        case LEAF_bgpPeerOutTotalMessages:
            *var_len = sizeof(long_return);
            long_return = entry.bgpPeerOutTotalMessages;
            return (u_char *) &long_return;

        case LEAF_bgpPeerLastError:
            *var_len = SIZE_bgpPeerLastError;
            memcpy(return_buf, entry.bgpPeerLastError, *var_len);
            return (u_char *) return_buf;

        case LEAF_bgpPeerFsmEstablishedTransitions:
            *var_len = sizeof(long_return);
            long_return = entry.bgpPeerFsmEstablishedTransitions;
            return (u_char *) &long_return;

        case LEAF_bgpPeerFsmEstablishedTime:
            *var_len = sizeof(long_return);
            long_return = entry.bgpPeerFsmEstablishedTime;
            return (u_char *) &long_return;

        case LEAF_bgpPeerConnectRetryInterval:
            *var_len = sizeof(long_return);
            long_return = entry.bgpPeerConnectRetryInterval;
            return (u_char *) &long_return;

        case LEAF_bgpPeerHoldTime:
            *var_len = sizeof(long_return);
            long_return = entry.bgpPeerHoldTime;
            return (u_char *) &long_return;

        case LEAF_bgpPeerKeepAlive:
            *var_len = sizeof(long_return);
            long_return = entry.bgpPeerKeepAlive;
            return (u_char *) &long_return;

        case LEAF_bgpPeerHoldTimeConfigured:
            *var_len = sizeof(long_return);
            long_return = entry.bgpPeerHoldTimeConfigured;
            return (u_char *) &long_return;

        case LEAF_bgpPeerKeepAliveConfigured:
            *var_len = sizeof(long_return);
            long_return = entry.bgpPeerKeepAliveConfigured;
            return (u_char *) &long_return;

        case LEAF_bgpPeerMinASOriginationInterval:
            *var_len = sizeof(long_return);
            long_return = entry.bgpPeerMinASOriginationInterval;
            return (u_char *) &long_return;

        case LEAF_bgpPeerMinRouteAdvertisementInterval:
            *var_len = sizeof(long_return);
            long_return = entry.bgpPeerMinRouteAdvertisementInterval;
            return (u_char *) &long_return;

        case LEAF_bgpPeerInUpdateElapsedTime:
            *var_len = sizeof(long_return);
            long_return = entry.bgpPeerInUpdateElapsedTime;
            return (u_char *) &long_return;

        default:
            ERROR_MSG("");
    }

    return NULL;
}

int write_bgpPeerAdminStatus(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            switch (*(long *)var_val)
            {
                case VAL_bgpPeerAdminStatus_stop:
                    break;

                case VAL_bgpPeerAdminStatus_start:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = 10;
            I32_T value = 0;
            L_INET_AddrIp_T bgpPeerRemoteAddr;

            if (bgpPeerTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &bgpPeerRemoteAddr) == FALSE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            value = *(long *)var_val;

            if (BGP_PMGR_MIB_SetBgpPeerAdminStatus(&bgpPeerRemoteAddr, value) != BGP_TYPE_RESULT_OK)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

int write_bgpPeerConnectRetryInterval(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            if (MIN_bgpPeerConnectRetryInterval > *(long *)var_val || *(long *)var_val > MAX_bgpPeerConnectRetryInterval)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = 10;
            I32_T value = 0;
            L_INET_AddrIp_T bgpPeerRemoteAddr;

            if (bgpPeerTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &bgpPeerRemoteAddr) == FALSE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            value = *(long *)var_val;

            if (BGP_PMGR_MIB_SetBgpPeerConnectRetryInterval(&bgpPeerRemoteAddr, value) != BGP_TYPE_RESULT_OK)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

int write_bgpPeerHoldTimeConfigured(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            if (MIN_bgpPeerHoldTimeConfigured > *(long *)var_val || *(long *)var_val > MAX_bgpPeerHoldTimeConfigured)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = 10;
            I32_T value = 0;
            L_INET_AddrIp_T bgpPeerRemoteAddr;

            if (bgpPeerTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &bgpPeerRemoteAddr) == FALSE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            value = *(long *)var_val;

            if (BGP_PMGR_MIB_SetBgpPeerHoldTimeConfigured(&bgpPeerRemoteAddr, value) != BGP_TYPE_RESULT_OK)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

int write_bgpPeerKeepAliveConfigured(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            if (MIN_bgpPeerKeepAliveConfigured > *(long *)var_val || *(long *)var_val > MAX_bgpPeerKeepAliveConfigured)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = 10;
            I32_T value = 0;
            L_INET_AddrIp_T bgpPeerRemoteAddr;

            if (bgpPeerTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &bgpPeerRemoteAddr) == FALSE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            value = *(long *)var_val;

            if (BGP_PMGR_MIB_SetBgpPeerKeepAliveConfigured(&bgpPeerRemoteAddr, value) != BGP_TYPE_RESULT_OK)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

int write_bgpPeerMinASOriginationInterval(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            if (MIN_bgpPeerMinASOriginationInterval > *(long *)var_val || *(long *)var_val > MAX_bgpPeerMinASOriginationInterval)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = 10;
            I32_T value = 0;
            L_INET_AddrIp_T bgpPeerRemoteAddr;

            if (bgpPeerTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &bgpPeerRemoteAddr) == FALSE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            value = *(long *)var_val;

            if (BGP_PMGR_MIB_SetBgpPeerMinASOriginationInterval(&bgpPeerRemoteAddr, value) != BGP_TYPE_RESULT_OK)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

int write_bgpPeerMinRouteAdvertisementInterval(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            if (MIN_bgpPeerMinRouteAdvertisementInterval > *(long *)var_val || *(long *)var_val > MAX_bgpPeerMinRouteAdvertisementInterval)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = 10;
            I32_T value = 0;
            L_INET_AddrIp_T bgpPeerRemoteAddr;

            if (bgpPeerTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &bgpPeerRemoteAddr) == FALSE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            value = *(long *)var_val;

            if (BGP_PMGR_MIB_SetBgpPeerMinRouteAdvertisementInterval(&bgpPeerRemoteAddr, value) != BGP_TYPE_RESULT_OK)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}


void init_bgpIdentifier(void)
{
    static oid bgpIdentifier_oid[] = { 1,3,6,1,2,1,15,4,0 };

    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("bgpIdentifier",
                                         get_bgpIdentifier,
                                         bgpIdentifier_oid,
                                         OID_LENGTH(bgpIdentifier_oid),
                                         HANDLER_CAN_RONLY));
}

int get_bgpIdentifier(netsnmp_mib_handler *handler,
    netsnmp_handler_registration *reginfo,
    netsnmp_agent_request_info *reqinfo,
    netsnmp_request_info *requests)
{
    switch (reqinfo->mode)
    {
        case MODE_GET:
        {
            UI32_T value = 0;

            if (BGP_PMGR_MIB_GetBgpIdentifier(&value) == BGP_TYPE_RESULT_OK)
            {
                ipaddr_return = value;
                snmp_set_var_typed_value(requests->requestvb, ASN_IPADDRESS, (u_char *)&ipaddr_return, sizeof(ipaddr_return));
            }
            else
            {
                return SNMP_ERR_GENERR;
            }

            break;
        }


        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}


oid bgp4PathAttrTable_variables_oid[] = { 1,3,6,1,2,1,15 };

/* variable3 bgp4PathAttrTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */
struct variable3 bgp4PathAttrTable_variables[] =
{
/* magic number, variable type, ro/rw, callback fn, L, oidsuffix
 */
    { LEAF_bgp4PathAttrPeer, ASN_IPADDRESS, RONLY, var_bgp4PathAttrTable, 3, { 6, 1, 1 }},
    { LEAF_bgp4PathAttrIpAddrPrefixLen, ASN_INTEGER, RONLY, var_bgp4PathAttrTable, 3, { 6, 1, 2 }},
    { LEAF_bgp4PathAttrIpAddrPrefix, ASN_IPADDRESS, RONLY, var_bgp4PathAttrTable, 3, { 6, 1, 3 }},
    { LEAF_bgp4PathAttrOrigin, ASN_INTEGER, RONLY, var_bgp4PathAttrTable, 3, { 6, 1, 4 }},
    { LEAF_bgp4PathAttrASPathSegment, ASN_OCTET_STR, RONLY, var_bgp4PathAttrTable, 3, { 6, 1, 5 }},
    { LEAF_bgp4PathAttrNextHop, ASN_IPADDRESS, RONLY, var_bgp4PathAttrTable, 3, { 6, 1, 6 }},
    { LEAF_bgp4PathAttrMultiExitDisc, ASN_INTEGER, RONLY, var_bgp4PathAttrTable, 3, { 6, 1, 7 }},
    { LEAF_bgp4PathAttrLocalPref, ASN_INTEGER, RONLY, var_bgp4PathAttrTable, 3, { 6, 1, 8 }},
    { LEAF_bgp4PathAttrAtomicAggregate, ASN_INTEGER, RONLY, var_bgp4PathAttrTable, 3, { 6, 1, 9 }},
    { LEAF_bgp4PathAttrAggregatorAS, ASN_INTEGER, RONLY, var_bgp4PathAttrTable, 3, { 6, 1, 10 }},
    { LEAF_bgp4PathAttrAggregatorAddr, ASN_IPADDRESS, RONLY, var_bgp4PathAttrTable, 3, { 6, 1, 11 }},
    { LEAF_bgp4PathAttrCalcLocalPref, ASN_INTEGER, RONLY, var_bgp4PathAttrTable, 3, { 6, 1, 12 }},
    { LEAF_bgp4PathAttrBest, ASN_INTEGER, RONLY, var_bgp4PathAttrTable, 3, { 6, 1, 13 }},
    { LEAF_bgp4PathAttrUnknown, ASN_OCTET_STR, RONLY, var_bgp4PathAttrTable, 3, { 6, 1, 14 }},
};

void init_bgp4PathAttrTable(void)
{
    REGISTER_MIB("bgp4PathAttrTable", bgp4PathAttrTable_variables, variable3,
                 bgp4PathAttrTable_variables_oid);
}

#define BGP4PATHATTRENTRY_INSTANCE_LEN  9

BOOL_T bgp4PathAttrTable_OidIndexToData(UI32_T exact, UI32_T compc,
    oid *compl, L_INET_AddrIp_T *bgp4PathAttrIpAddrPrefix, /*UI32_T *bgp4PathAttrIpAddrPrefixLen,*/ L_INET_AddrIp_T *bgp4PathAttrPeer)
{
    /* get or set
     */
    if (exact)
    {
        /* check the index length
         */
        if (compc != BGP4PATHATTRENTRY_INSTANCE_LEN) /* the constant size index */
        {
            return FALSE;
        }
    }

    memset(bgp4PathAttrIpAddrPrefix, 0, sizeof(L_INET_AddrIp_T));
    bgp4PathAttrIpAddrPrefix->addr[0]=(UI8_T)compl[0];
    bgp4PathAttrIpAddrPrefix->addr[1]=(UI8_T)compl[1];
    bgp4PathAttrIpAddrPrefix->addr[2]=(UI8_T)compl[2];
    bgp4PathAttrIpAddrPrefix->addr[3]=(UI8_T)compl[3];
    bgp4PathAttrIpAddrPrefix->preflen=(UI16_T)compl[4];
    bgp4PathAttrIpAddrPrefix->type = L_INET_ADDR_TYPE_IPV4;
    bgp4PathAttrIpAddrPrefix->addrlen = SYS_ADPT_IPV4_ADDR_LEN;

    memset(bgp4PathAttrPeer, 0, sizeof(L_INET_AddrIp_T));
    bgp4PathAttrPeer->addr[0]=(UI8_T)compl[5];
    bgp4PathAttrPeer->addr[1]=(UI8_T)compl[6];
    bgp4PathAttrPeer->addr[2]=(UI8_T)compl[7];
    bgp4PathAttrPeer->addr[3]=(UI8_T)compl[8];
    bgp4PathAttrPeer->type = L_INET_ADDR_TYPE_IPV4;
    bgp4PathAttrPeer->addrlen = SYS_ADPT_IPV4_ADDR_LEN;

    return TRUE;
}

/*
 * var_bgp4PathAttrTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *var_bgp4PathAttrTable(struct variable *vp,
    oid *name,
    size_t *length,
    int exact,
    size_t *var_len,
    WriteMethod **write_method)
{
    UI32_T compc = 0;
    oid compl[BGP4PATHATTRENTRY_INSTANCE_LEN] = {0};
    oid best_inst[BGP4PATHATTRENTRY_INSTANCE_LEN] = {0};
    BGP_TYPE_MIB_Bgp4PathAttrEntry_T entry;

    switch (vp->magic)
    {
        default:
            *write_method = 0;
            break;
    }

    /* check compc, retrive compl
     */
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl, BGP4PATHATTRENTRY_INSTANCE_LEN);

    memset(&entry, 0, sizeof(entry));

    if (exact) /* get or set */
    {
        if (bgp4PathAttrTable_OidIndexToData(exact, compc, compl, &entry.bgp4PathAttrIpAddrPrefix, &entry.bgp4PathAttrPeer) == FALSE)
        {
            return NULL;
        }

        if (BGP_PMGR_MIB_GetBgp4PathAttrEntry(&entry) != BGP_TYPE_RESULT_OK)
        {
            return NULL;
        }
    }
    else /* getnext */
    {
        bgp4PathAttrTable_OidIndexToData(exact, compc, compl, &entry.bgp4PathAttrIpAddrPrefix, &entry.bgp4PathAttrPeer);

        /* check the length of inputing index,if < 1 we should try get
         * {0.0.0.0.0...}
         */
        if (compc < 1)
        {
            if (BGP_PMGR_MIB_GetBgp4PathAttrEntry(&entry) != BGP_TYPE_RESULT_OK)
            {
                if (BGP_PMGR_MIB_GetNextBgp4PathAttrEntry(&entry) != BGP_TYPE_RESULT_OK)
                {
                    return NULL;
                }
            }
        }
        else
        {
            if (BGP_PMGR_MIB_GetNextBgp4PathAttrEntry(&entry) != BGP_TYPE_RESULT_OK)
            {
                return NULL;
            }
        }
    }

    memcpy(name, vp->name, vp->namelen * sizeof(oid));

    /* assign data to the oid index
     */
    best_inst[0] = *((UI8_T *)&entry.bgp4PathAttrIpAddrPrefix.addr[0]);
    best_inst[1] = *((UI8_T *)&entry.bgp4PathAttrIpAddrPrefix.addr[1]);
    best_inst[2] = *((UI8_T *)&entry.bgp4PathAttrIpAddrPrefix.addr[2]);
    best_inst[3] = *((UI8_T *)&entry.bgp4PathAttrIpAddrPrefix.addr[3]);
    best_inst[4] = entry.bgp4PathAttrIpAddrPrefix.preflen;
    best_inst[5] = *((UI8_T *)&entry.bgp4PathAttrPeer.addr[0]);
    best_inst[6] = *((UI8_T *)&entry.bgp4PathAttrPeer.addr[1]);
    best_inst[7] = *((UI8_T *)&entry.bgp4PathAttrPeer.addr[2]);
    best_inst[8] = *((UI8_T *)&entry.bgp4PathAttrPeer.addr[3]);
    memcpy(name + vp->namelen, best_inst, BGP4PATHATTRENTRY_INSTANCE_LEN * sizeof(oid));
    *length = vp->namelen + BGP4PATHATTRENTRY_INSTANCE_LEN;

    switch (vp->magic)
    {
        case LEAF_bgp4PathAttrPeer:
            *var_len = sizeof(ipaddr_return);
            memcpy(&ipaddr_return, entry.bgp4PathAttrPeer.addr, *var_len);
            return (u_char *) &ipaddr_return;

        case LEAF_bgp4PathAttrIpAddrPrefixLen:
            *var_len = sizeof(long_return);
            long_return = entry.bgp4PathAttrIpAddrPrefix.preflen;
            return (u_char *) &long_return;

        case LEAF_bgp4PathAttrIpAddrPrefix:
            *var_len = sizeof(ipaddr_return);
            memcpy(&ipaddr_return, entry.bgp4PathAttrIpAddrPrefix.addr, *var_len);
            return (u_char *) &ipaddr_return;

        case LEAF_bgp4PathAttrOrigin:
            *var_len = sizeof(long_return);
            long_return = entry.bgp4PathAttrOrigin;
            return (u_char *) &long_return;

        case LEAF_bgp4PathAttrASPathSegment:
            *var_len = entry.bgp4PathAttrASPathSegment_len;
            memcpy(return_buf, entry.bgp4PathAttrASPathSegment, *var_len);
            return (u_char *) return_buf;

        case LEAF_bgp4PathAttrNextHop:
            *var_len = sizeof(ipaddr_return);
            memcpy(&ipaddr_return, entry.bgp4PathAttrNextHop.addr, *var_len);
            return (u_char *) &ipaddr_return;

        case LEAF_bgp4PathAttrMultiExitDisc:
            *var_len = sizeof(long_return);
            long_return = entry.bgp4PathAttrMultiExitDisc;
            return (u_char *) &long_return;

        case LEAF_bgp4PathAttrLocalPref:
            *var_len = sizeof(long_return);
            long_return = entry.bgp4PathAttrLocalPref;
            return (u_char *) &long_return;

        case LEAF_bgp4PathAttrAtomicAggregate:
            *var_len = sizeof(long_return);
            long_return = entry.bgp4PathAttrAtomicAggregate;
            return (u_char *) &long_return;

        case LEAF_bgp4PathAttrAggregatorAS:
            *var_len = sizeof(long_return);
            long_return = entry.bgp4PathAttrAggregatorAS;
            return (u_char *) &long_return;

        case LEAF_bgp4PathAttrAggregatorAddr:
            *var_len = sizeof(ipaddr_return);
            memcpy(&ipaddr_return, entry.bgp4PathAttrAggregatorAddr.addr, *var_len);
            return (u_char *) &ipaddr_return;

        case LEAF_bgp4PathAttrCalcLocalPref:
            *var_len = sizeof(long_return);
            long_return = entry.bgp4PathAttrCalcLocalPref;
            return (u_char *) &long_return;

        case LEAF_bgp4PathAttrBest:
            *var_len = sizeof(long_return);
            long_return = entry.bgp4PathAttrBest;
            return (u_char *) &long_return;

        case LEAF_bgp4PathAttrUnknown:
            *var_len = entry.bgp4PathAttrUnknown_len;
            memcpy(return_buf, entry.bgp4PathAttrUnknown, *var_len);
            return (u_char *) return_buf;

        default:
            ERROR_MSG("");
    }

    return NULL;
}

#endif /* #if (SYS_CPNT_BGP == TRUE) */

