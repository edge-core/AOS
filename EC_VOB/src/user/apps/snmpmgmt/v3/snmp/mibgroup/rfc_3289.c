//5978
/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.old-api.conf,v 1.3 2002/10/17 09:40:46 dts12 Exp $
 */
#include "sys_cpnt.h"
#if (SYS_CPNT_QOS == SYS_CPNT_QOS_DIFFSERV)
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "l4_ds_mgr.h"
#include "l4_ds_type.h"
#include "rfc_3289.h"
#include "snmp_type.h"
#include "snmp_mgr.h"
#include "sysORTable.h"
#include "sysfun.h"
#undef LEAF_diffServActionStatus
#undef VAL_diffServActionStatus_active
#undef VAL_diffServActionStatus_notInService
#undef VAL_diffServActionStatus_notReady
#undef VAL_diffServActionStatus_createAndGo
#undef VAL_diffServActionStatus_createAndWait
#undef VAL_diffServActionStatus_destroy
#include "leaf_3289.h"

static oid             diffserv_module_oid[] = { SNMP_OID_MIB2, 4 };
/*
for debug used only
*/
static void print_snmpoid(SNMP_TYPE_Oid_T *snmpoid)
{
    int i;
    if (snmpoid->oid_len>0)
        SYSFUN_Debug_Printf("print_snmpoid:");
    for (i=0; i<=snmpoid->oid_len; i++)
    {
        SYSFUN_Debug_Printf("%lu",snmpoid->oid[i]);
        if (i<snmpoid->oid_len)
            SYSFUN_Debug_Printf(".");
        else
            SYSFUN_Debug_Printf("\n");
    }
}

static void print_dsoid(L4_DS_TYPE_Oid_T *dsoid)
{
    SYSFUN_Debug_Printf("print_dsoid:table=[%d], index=[%d]\n", dsoid->table, dsoid->index);
}
/*
 * diffServDataPathTable_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid             diffServDataPathTable_variables_oid[] =
    { 1, 3, 6, 1, 2, 1, 97, 1, 1 };

#define diffServDataPathEntry_INSTANCE_LEN 2
#define diffServDataPathEntry_OID_NAME_LEN 12

/*
 * variable4 diffServDataPathTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */

struct variable3 diffServDataPathTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */

#define DIFFSERVDATAPATHIFDIRECTION		1
    {DIFFSERVDATAPATHIFDIRECTION, ASN_INTEGER, RONLY,
     var_diffServDataPathTable, 3, {1, 1, 1}},
#define DIFFSERVDATAPATHSTART		2
    {DIFFSERVDATAPATHSTART, ASN_OBJECT_ID, RWRITE,
     var_diffServDataPathTable, 3, {1, 1, 2}},
#define DIFFSERVDATAPATHSTORAGE		3
    {DIFFSERVDATAPATHSTORAGE, ASN_INTEGER, RWRITE,
     var_diffServDataPathTable, 3, {1, 1, 3}},
#define DIFFSERVDATAPATHSTATUS		4
    {DIFFSERVDATAPATHSTATUS, ASN_INTEGER, RWRITE,
     var_diffServDataPathTable, 3, {1, 1, 4}},
};
/*
 * (L = length of the oidsuffix)
 */


/** Initializes the diffServDataPathTable module */
void
init_diffServDataPathTable(void)
{
    /*
     * register ourselves with the agent to handle our mib tree
     */
    REGISTER_MIB("diffServDataPathTable", diffServDataPathTable_variables,
                 variable3, diffServDataPathTable_variables_oid);

    /*
     * place any other initialization junk you need here
     */
     REGISTER_SYSOR_ENTRY(diffserv_module_oid,
                         "The RFC3289 diffServMib. This MIB defines the objects necessary to manage a device that uses the Differentiated Services Architecture described in RFC 2475.");
}

static BOOL_T diffServDataPathTable_get(int      compc,
                                oid     *compl,
                                L4_TYPE_diffServDataPathEntry_T   *data)
{
    if (compc !=diffServDataPathEntry_INSTANCE_LEN)
    {
 	    return FALSE;
    }
    data->ifindex=compl[0];
    data->direction=compl[1];

    if(SNMP_MGR_IsDebugMode())
        SYSFUN_Debug_Printf("diffServDataPathTable_get:data->ifindex=[%lu], data->direction=[%d]\n", data->ifindex, data->direction);

	if (!L4_DS_MGR_GetDataPath(data->ifindex, data->direction, data))
	{
	    if(SNMP_MGR_IsDebugMode())
	        SYSFUN_Debug_Printf("diffServDataPathTable_get:L4_DS_MGR_GetDataPath return false\n");
		return FALSE;
	}
	else
	{
		return TRUE;
	} /*End of if */
}

static BOOL_T diffServDataPathTable_next(int      compc,
                                 oid     *compl,
                                 L4_TYPE_diffServDataPathEntry_T    *data)
{
  	oid tmp_compl[diffServDataPathEntry_INSTANCE_LEN];

 	/* Generate the instance of each table entry and find the
	 * smallest instance that's larger than compc/compl.
	 *
	 * Step 1: Verify and extract the input key from "compc" and "compl"
	 * Note: The number of input key is defined by "compc".
	 *       The key for the specified instance is defined in compl.
	 */

	memcpy(tmp_compl, compl, sizeof(tmp_compl));
	SNMP_MGR_checkCompl(1, 1, tmp_compl,VAL_diffServDataPathIfDirection_outbound);
	SNMP_MGR_ConvertRemainToZero(compc,diffServDataPathEntry_INSTANCE_LEN, tmp_compl);
	data->ifindex=tmp_compl[0];
	data->direction=tmp_compl[1];

	if(SNMP_MGR_IsDebugMode())
        SYSFUN_Debug_Printf("diffServDataPathTable_next:data->ifindex=[%lu], data->direction=[%d]\n", data->ifindex, data->direction);

	if (compc<diffServDataPathEntry_INSTANCE_LEN)
	{
		if (!L4_DS_MGR_GetDataPath(data->ifindex, data->direction, data))
        {
            if (!L4_DS_MGR_GetNextDataPath(&data->ifindex, (UI32_T *)&data->direction, data))
   	        {
   	            if(SNMP_MGR_IsDebugMode())
   	                SYSFUN_Debug_Printf("diffServDataPathTable_next: get & genext return false\n");
   		        return FALSE;
   		    }
        }
	}
	else
	{
		if (!L4_DS_MGR_GetNextDataPath(&data->ifindex, (UI32_T *)&data->direction, data))
		{
		    if(SNMP_MGR_IsDebugMode())
   	            SYSFUN_Debug_Printf("diffServDataPathTable_next: get return false\n");
			return FALSE;
		}
	}
	return TRUE;
}

/*
 * var_diffServDataPathTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_diffServDataPathTable(struct variable *vp,
                          oid * name,
                          size_t * length,
                          int exact,
                          size_t * var_len, WriteMethod ** write_method)
{
    UI32_T compc=0;
    oid compl[diffServDataPathEntry_INSTANCE_LEN];
    oid best_inst[diffServDataPathEntry_INSTANCE_LEN];
    L4_TYPE_diffServDataPathEntry_T data;

   /*Since this table allow for entry that does not exist, (creation). we need to know the write method first*/
    switch (vp->magic)
    {
      case DIFFSERVDATAPATHSTART:
        *write_method = write_diffServDataPathStart;
        break;
      case DIFFSERVDATAPATHSTORAGE:
        *write_method = write_diffServDataPathStorage;
        break;
      case DIFFSERVDATAPATHSTATUS:
        *write_method = write_diffServDataPathStatus;
        break;
      default:
        *write_method =0;
         break;
    }

    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl, diffServDataPathEntry_INSTANCE_LEN);

     /*check compc, retrive compl*/
    if (exact)/*get,set*/
    {
        if (!diffServDataPathTable_get(compc, compl, &data))
            return NULL;
    }
    else/*getnext*/
    {
        if (!diffServDataPathTable_next(compc, compl, &data))
            return NULL;
    }
    memcpy(name, vp->name, vp->namelen*sizeof(oid));
    best_inst[0]=data.ifindex;
    best_inst[1]=data.direction;

    memcpy(name + vp->namelen, best_inst, diffServDataPathEntry_INSTANCE_LEN*sizeof(oid));
    *length = vp->namelen +diffServDataPathEntry_INSTANCE_LEN;

    *var_len = sizeof(long_return);

    /*
     * * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
      case DIFFSERVDATAPATHSTART:
      {
        SNMP_TYPE_Oid_T snmpoid;
        if(SNMP_MGR_IsDebugMode())
            print_dsoid(&data.start);
        if (L4_DS_MGR_DiffServRowPointerToOid(&data.start, &snmpoid))
        {
            *var_len = snmpoid.oid_len * sizeof(UI32_T);
            memcpy(oid_return, snmpoid.oid, *var_len);
            return (u_char *) oid_return;
        }
        else
        {
            if(SNMP_MGR_IsDebugMode())
   	            SYSFUN_Debug_Printf("var_diffServDataPathTable:L4_DS_MGR_DiffServRowPointerToOid return false\n");
            return NULL;
        }
      }
      case DIFFSERVDATAPATHSTORAGE:
        long_return = data.storage;
        return (u_char*) &long_return;
      case DIFFSERVDATAPATHSTATUS:
        long_return = data.status;
        return (u_char*) &long_return;
    default:
        ERROR_MSG("");
    }
    return NULL;
}


int
write_diffServDataPathStart(int action,
                            u_char * var_val,
                            u_char var_val_type,
                            size_t var_val_len,
                            u_char * statP, oid * name, size_t name_len)
{


    switch (action) {
    case RESERVE1:
        /* check 1: check if the input index is exactly match, if not return fail*/
        if (name_len!=  diffServDataPathEntry_OID_NAME_LEN + diffServDataPathEntry_INSTANCE_LEN )
        {
            return SNMP_ERR_WRONGLENGTH;
        }
        if (var_val_type != ASN_OBJECT_ID) {

            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > (SYS_ADPT_MAX_OID_COUNT * sizeof(UI32_T))) {

            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        break;
    case FREE:
        /*
         * Release any resources that have been allocated
         */
        break;
    case ACTION:
    {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
         SNMP_TYPE_Oid_T snmpoid;
         L4_DS_TYPE_Oid_T dsoid;
         UI32_T ifindex, direction;
         ifindex=name[diffServDataPathEntry_OID_NAME_LEN];
         direction=name[diffServDataPathEntry_OID_NAME_LEN+1];
         memcpy(snmpoid.oid, var_val, var_val_len);
         snmpoid.oid_len=var_val_len;
         if(SNMP_MGR_IsDebugMode())
            print_snmpoid(&snmpoid);
         if (L4_DS_MGR_OidToDiffServRowPointer(&snmpoid, &dsoid))
         {
             if(SNMP_MGR_IsDebugMode())
             {
                 SYSFUN_Debug_Printf("write_diffServDataPathStart:ifindex=[%lu], direction=[%lu]\n", ifindex, direction);
                 print_dsoid(&dsoid);
             }
             if (!L4_DS_MGR_SetdiffServDataPathStart(ifindex, direction, &dsoid))
             {
                if(SNMP_MGR_IsDebugMode())
                    SYSFUN_Debug_Printf("write_diffServDataPathStart:L4_DS_MGR_SetdiffServDataPathStart return false\n");
                return SNMP_ERR_COMMITFAILED;
             }
         }
         else
         {
            if(SNMP_MGR_IsDebugMode())
                SYSFUN_Debug_Printf("write_diffServDataPathStart:L4_DS_MGR_OidToDiffServRowPointer return false\n");
         }
         break;
    }
    case UNDO:
        /*
         * Back out any changes made in the ACTION case
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_diffServDataPathStorage(int action,
                              u_char * var_val,
                              u_char var_val_type,
                              size_t var_val_len,
                              u_char * statP, oid * name, size_t name_len)
{
    long            value;

    switch (action) {
    case RESERVE1:
        /* check 1: check if the input index is exactly match, if not return fail*/
        if (name_len!=  diffServDataPathEntry_OID_NAME_LEN + diffServDataPathEntry_INSTANCE_LEN )
        {
            return SNMP_ERR_WRONGLENGTH;
        }
        if (var_val_type != ASN_INTEGER) {

            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {

            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        value = *(long *)var_val;
        switch(value)
        {
          case VAL_diffServDataPathStorage_other:
          case VAL_diffServDataPathStorage_volatile:
          case VAL_diffServDataPathStorage_nonVolatile:
          case VAL_diffServDataPathStorage_permanent:
          case VAL_diffServDataPathStorage_readOnly:
            break;
          default:
            return SNMP_ERR_WRONGVALUE;
        }
        break;

    case FREE:
        /*
         * Release any resources that have been allocated
         */
        break;

    case ACTION:
    {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        UI32_T ifindex, direction;
        ifindex=name[diffServDataPathEntry_OID_NAME_LEN];
        direction=name[diffServDataPathEntry_OID_NAME_LEN+1];
        value = *(long *)var_val;
        if(SNMP_MGR_IsDebugMode())
             SYSFUN_Debug_Printf("write_diffServDataPathStorage:ifindex=[%lu], direction=[%lu], value=[%lu]\n", ifindex, direction, value);

        if (!L4_DS_MGR_SetDiffServDataPathStorage(ifindex, direction, value))
        {
            if(SNMP_MGR_IsDebugMode())
                SYSFUN_Debug_Printf("write_diffServDataPathStorage:L4_DS_MGR_SetDiffServDataPathStorage return false\n");
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    case UNDO:
        /*
         * Back out any changes made in the ACTION case
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_diffServDataPathStatus(int action,
                             u_char * var_val,
                             u_char var_val_type,
                             size_t var_val_len,
                             u_char * statP, oid * name, size_t name_len)
{
    long            value;

    switch (action) {
    case RESERVE1:
        /* check 1: check if the input index is exactly match, if not return fail*/
        if (name_len!=  diffServDataPathEntry_OID_NAME_LEN + diffServDataPathEntry_INSTANCE_LEN )
        {
            return SNMP_ERR_WRONGLENGTH;
        }
        if (var_val_type != ASN_INTEGER) {

            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {

            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        value = *(long *)var_val;
        switch(value)
        {
          case VAL_diffServDataPathStatus_active:
          case VAL_diffServDataPathStatus_notInService:
          case VAL_diffServDataPathStatus_notReady:
          case VAL_diffServDataPathStatus_createAndGo:
          case VAL_diffServDataPathStatus_createAndWait:
          case VAL_diffServDataPathStatus_destroy:
            break;
          default:
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    case FREE:
        /*
         * Release any resources that have been allocated
         */
        break;

    case ACTION:
    {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        UI32_T ifindex, direction;
        ifindex=name[diffServDataPathEntry_OID_NAME_LEN];
        direction=name[diffServDataPathEntry_OID_NAME_LEN+1];
        value = *(long *)var_val;
        if(SNMP_MGR_IsDebugMode())
             SYSFUN_Debug_Printf("write_diffServDataPathStatus:ifindex=[%lu], direction=[%lu], value=[%lu]\n", ifindex, direction, value);

        if (!L4_DS_MGR_SetdiffServDataPathStatus(ifindex, direction, value))
        {
            if(SNMP_MGR_IsDebugMode())
                SYSFUN_Debug_Printf("write_diffServDataPathStatus:L4_DS_MGR_SetdiffServDataPathStatus return false\n");
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    case UNDO:
        /*
         * Back out any changes made in the ACTION case
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}


/*
 * diffServClfrTable_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */
#define diffServClfrEntry_INSTANCE_LEN 1
#define diffServClfrEntry_OID_NAME_LEN 12

oid             diffServClfrTable_variables_oid[] =
    { 1, 3, 6, 1, 2, 1, 97, 1, 2 };

/*
 * variable4 diffServClfrTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */

struct variable3 diffServClfrTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */

#define DIFFSERVCLFRID		1
    {DIFFSERVCLFRID, ASN_UNSIGNED, RONLY, var_diffServClfrTable, 3,
     {2, 1, 1}},
#define DIFFSERVCLFRSTORAGE		2
    {DIFFSERVCLFRSTORAGE, ASN_INTEGER, RWRITE, var_diffServClfrTable, 3,
     {2, 1, 2}},
#define DIFFSERVCLFRSTATUS		3
    {DIFFSERVCLFRSTATUS, ASN_INTEGER, RWRITE, var_diffServClfrTable, 3,
     {2, 1, 3}},
};
/*
 * (L = length of the oidsuffix)
 */


/** Initializes the diffServClfrTable module */
void
init_diffServClfrTable(void)
{
    /*
     * register ourselves with the agent to handle our mib tree
     */
    REGISTER_MIB("diffServClfrTable", diffServClfrTable_variables,
                 variable3, diffServClfrTable_variables_oid);

    /*
     * place any other initialization junk you need here
     */
}

static BOOL_T diffServClfrTable_get(int      compc,
                                oid     *compl,
                                L4_TYPE_diffServClfrEntry_T   *data)
{
    if (compc !=diffServClfrEntry_INSTANCE_LEN)
    {
 	    return FALSE;
    }
    data->id=compl[0];

    if(SNMP_MGR_IsDebugMode())
        SYSFUN_Debug_Printf("diffServClfrTable_get:data->id=[%lu]\n", data->id);

	if (!L4_DS_MGR_GetClfr(data->id, data))
	{
	    if(SNMP_MGR_IsDebugMode())
	        SYSFUN_Debug_Printf("diffServClfrTable_get:L4_DS_MGR_GetClfr return false\n");
		return FALSE;
	}
	else
	{
		return TRUE;

	} /*End of if */
}

static BOOL_T diffServClfrTable_next(int      compc,
                                 oid     *compl,
                                 L4_TYPE_diffServClfrEntry_T    *data)
{
  	oid tmp_compl[diffServClfrEntry_INSTANCE_LEN];

 	/* Generate the instance of each table entry and find the
	 * smallest instance that's larger than compc/compl.
	 *
	 * Step 1: Verify and extract the input key from "compc" and "compl"
	 * Note: The number of input key is defined by "compc".
	 *       The key for the specified instance is defined in compl.
	 */

	memcpy(tmp_compl, compl, sizeof(tmp_compl));
	SNMP_MGR_ConvertRemainToZero(compc,diffServClfrEntry_INSTANCE_LEN, tmp_compl);
	data->id=tmp_compl[0];

    if(SNMP_MGR_IsDebugMode())
        SYSFUN_Debug_Printf("diffServClfrTable_next:data->id=[%lu]\n", data->id);

	if (compc<diffServClfrEntry_INSTANCE_LEN)
	{
		if (!L4_DS_MGR_GetClfr(data->id, data))
        {
            if (!L4_DS_MGR_GetNextClfr(&data->id, data))
   	        {
   	            if(SNMP_MGR_IsDebugMode())
   	                SYSFUN_Debug_Printf("diffServClfrTable_next: get & genext return false\n");
   		        return FALSE;
   		    }
        }
	}
	else
	{
		if (!L4_DS_MGR_GetNextClfr(&data->id, data))
		{
		    if(SNMP_MGR_IsDebugMode())
   	            SYSFUN_Debug_Printf("diffServClfrTable_next: get return false\n");
			return FALSE;
		}
	}
	return TRUE;
}

/*
 * var_diffServClfrTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_diffServClfrTable(struct variable *vp,
                      oid * name,
                      size_t * length,
                      int exact,
                      size_t * var_len, WriteMethod ** write_method)
{
    UI32_T compc=0;
    oid compl[diffServClfrEntry_INSTANCE_LEN];
    oid best_inst[diffServClfrEntry_INSTANCE_LEN];
    L4_TYPE_diffServClfrEntry_T data;

   /*Since this table allow for entry that does not exist, (creation). we need to know the write method first*/
    switch (vp->magic)
    {
      case DIFFSERVCLFRSTORAGE:
        *write_method = write_diffServClfrStorage;
        break;
      case DIFFSERVCLFRSTATUS:
        *write_method = write_diffServClfrStatus;
        break;
      default:
        *write_method =0;
         break;
    }

    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl, diffServClfrEntry_INSTANCE_LEN);

     /*check compc, retrive compl*/
    if (exact)/*get,set*/
    {
        if (!diffServClfrTable_get(compc, compl, &data))
            return NULL;
    }
    else/*getnext*/
    {
        if (!diffServClfrTable_next(compc, compl, &data))
            return NULL;
    }
    memcpy(name, vp->name, vp->namelen*sizeof(oid));
    best_inst[0]=data.id;

    memcpy(name + vp->namelen, best_inst, diffServClfrEntry_INSTANCE_LEN*sizeof(oid));
    *length = vp->namelen +diffServClfrEntry_INSTANCE_LEN;

    *var_len = sizeof(long_return);

    /*
     * * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
      case DIFFSERVCLFRSTORAGE:
        long_return = data.storage;
        return (u_char*) &long_return;
      case DIFFSERVCLFRSTATUS:
        long_return = data.status;
        return (u_char*) &long_return;
    default:
        ERROR_MSG("");
    }
    return NULL;
}


int
write_diffServClfrStorage(int action,
                          u_char * var_val,
                          u_char var_val_type,
                          size_t var_val_len,
                          u_char * statP, oid * name, size_t name_len)
{
    long            value;

    switch (action) {
    case RESERVE1:
        /* check 1: check if the input index is exactly match, if not return fail*/
        if (name_len!=  diffServClfrEntry_OID_NAME_LEN + diffServClfrEntry_INSTANCE_LEN )
        {
            return SNMP_ERR_WRONGLENGTH;
        }
        if (var_val_type != ASN_INTEGER) {

            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {

            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        value = *(long *)var_val;
        switch(value)
        {
          case VAL_diffServClfrStorage_other:
          case VAL_diffServClfrStorage_volatile:
          case VAL_diffServClfrStorage_nonVolatile:
          case VAL_diffServClfrStorage_permanent:
          case VAL_diffServClfrStorage_readOnly:
            break;
          default:
            return SNMP_ERR_WRONGVALUE;
        }
    case FREE:
        /*
         * Release any resources that have been allocated
         */
        break;

    case ACTION:
    {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        UI32_T id;
        id=name[diffServClfrEntry_OID_NAME_LEN];
        value = *(long *)var_val;
        if(SNMP_MGR_IsDebugMode())
             SYSFUN_Debug_Printf("write_diffServClfrStorage:id=[%lu], value=[%lu]\n", id, value);

        if (!L4_DS_MGR_SetDiffServClfrStorage(id, value))
        {
            if(SNMP_MGR_IsDebugMode())
                SYSFUN_Debug_Printf("write_diffServClfrStorage:L4_DS_MGR_SetDiffServClfrStorage return false\n");
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    case UNDO:
        /*
         * Back out any changes made in the ACTION case
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_diffServClfrStatus(int action,
                         u_char * var_val,
                         u_char var_val_type,
                         size_t var_val_len,
                         u_char * statP, oid * name, size_t name_len)
{
    long            value;

    switch (action) {
    case RESERVE1:
        /* check 1: check if the input index is exactly match, if not return fail*/
        if (name_len!=  diffServClfrEntry_OID_NAME_LEN + diffServClfrEntry_INSTANCE_LEN )
        {
            return SNMP_ERR_WRONGLENGTH;
        }
        if (var_val_type != ASN_INTEGER) {

            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        value = *(long *)var_val;
        switch(value)
        {
          case VAL_diffServClfrStatus_active:
          case VAL_diffServClfrStatus_notInService:
          case VAL_diffServClfrStatus_notReady:
          case VAL_diffServClfrStatus_createAndGo:
          case VAL_diffServClfrStatus_createAndWait:
          case VAL_diffServClfrStatus_destroy:
            break;
          default:
            return SNMP_ERR_WRONGVALUE;
        }
        break;

    case FREE:
        /*
         * Release any resources that have been allocated
         */
        break;

    case ACTION:
    {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        UI32_T id;
        id=name[diffServClfrEntry_OID_NAME_LEN];
        value = *(long *)var_val;
        if(SNMP_MGR_IsDebugMode())
             SYSFUN_Debug_Printf("write_diffServClfrStatus:id=[%lu], value=[%lu]\n", id, value);

        if (!L4_DS_MGR_SetdiffServClfrStatus(id, value))
        {
            if(SNMP_MGR_IsDebugMode())
                SYSFUN_Debug_Printf("write_diffServClfrStatus:L4_DS_MGR_SetdiffServClfrStatus return false\n");
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    case UNDO:
        /*
         * Back out any changes made in the ACTION case
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}


/*
 * diffServClfrElementTable_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */
#define diffServClfrElementEntry_INSTANCE_LEN 2
#define diffServClfrElementEntry_OID_NAME_LEN 12

oid             diffServClfrElementTable_variables_oid[] =
    { 1, 3, 6, 1, 2, 1, 97, 1, 2 };

/*
 * variable4 diffServClfrElementTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */

struct variable3 diffServClfrElementTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */

#define DIFFSERVCLFRELEMENTID		1
    {DIFFSERVCLFRELEMENTID, ASN_UNSIGNED, RONLY,
     var_diffServClfrElementTable, 3, {4, 1, 1}},
#define DIFFSERVCLFRELEMENTPRECEDENCE		2
    {DIFFSERVCLFRELEMENTPRECEDENCE, ASN_UNSIGNED, RWRITE,
     var_diffServClfrElementTable, 3, {4, 1, 2}},
#define DIFFSERVCLFRELEMENTNEXT		3
    {DIFFSERVCLFRELEMENTNEXT, ASN_OBJECT_ID, RWRITE,
     var_diffServClfrElementTable, 3, {4, 1, 3}},
#define DIFFSERVCLFRELEMENTSPECIFIC		4
    {DIFFSERVCLFRELEMENTSPECIFIC, ASN_OBJECT_ID, RWRITE,
     var_diffServClfrElementTable, 3, {4, 1, 4}},
#define DIFFSERVCLFRELEMENTSTORAGE		5
    {DIFFSERVCLFRELEMENTSTORAGE, ASN_INTEGER, RWRITE,
     var_diffServClfrElementTable, 3, {4, 1, 5}},
#define DIFFSERVCLFRELEMENTSTATUS		6
    {DIFFSERVCLFRELEMENTSTATUS, ASN_INTEGER, RWRITE,
     var_diffServClfrElementTable, 3, {4, 1, 6}},
};
/*
 * (L = length of the oidsuffix)
 */


/** Initializes the diffServClfrElementTable module */
void
init_diffServClfrElementTable(void)
{
    /*
     * register ourselves with the agent to handle our mib tree
     */
    REGISTER_MIB("diffServClfrElementTable",
                 diffServClfrElementTable_variables, variable3,
                 diffServClfrElementTable_variables_oid);

    /*
     * place any other initialization junk you need here
     */
}

static BOOL_T diffServClfrElementTable_get(int      compc,
                                oid     *compl,
                                L4_TYPE_diffServClfrElementEntry_T   *data)
{
    if (compc !=diffServClfrElementEntry_INSTANCE_LEN)
    {
 	    return FALSE;
    }
    data->clfr_id=compl[0];
    data->id=compl[1];

    if(SNMP_MGR_IsDebugMode())
        SYSFUN_Debug_Printf("diffServClfrElementTable_get:data->clfr_id=[%lu], data->id=[%lu]\n", data->clfr_id, data->id);

	if (!L4_DS_MGR_GetClfrElement(data->clfr_id, data->id, data))
	{
	    if(SNMP_MGR_IsDebugMode())
	        SYSFUN_Debug_Printf("diffServClfrElementTable_get:L4_DS_MGR_GetClfrElement return false\n");
		return FALSE;
	}
	else
	{
		return TRUE;
	} /*End of if */
}

static BOOL_T diffServClfrElementTable_next(int      compc,
                                 oid     *compl,
                                 L4_TYPE_diffServClfrElementEntry_T    *data)
{
  	oid tmp_compl[diffServClfrElementEntry_INSTANCE_LEN];

 	/* Generate the instance of each table entry and find the
	 * smallest instance that's larger than compc/compl.
	 *
	 * Step 1: Verify and extract the input key from "compc" and "compl"
	 * Note: The number of input key is defined by "compc".
	 *       The key for the specified instance is defined in compl.
	 */

	memcpy(tmp_compl, compl, sizeof(tmp_compl));
	SNMP_MGR_ConvertRemainToZero(compc,diffServClfrElementEntry_INSTANCE_LEN, tmp_compl);
	data->clfr_id=tmp_compl[0];
	data->id=tmp_compl[1];

    if(SNMP_MGR_IsDebugMode())
        SYSFUN_Debug_Printf("diffServClfrElementTable_next:data->clfr_id=[%lu], data->id=[%lu]\n", data->clfr_id, data->id);

	if (compc<diffServClfrElementEntry_INSTANCE_LEN)
	{
		if (!L4_DS_MGR_GetClfrElement(data->clfr_id, data->id, data))
        {
            if (!L4_DS_MGR_GetNextClfrElement(&data->clfr_id, &data->id, data))
   	        {
   	            if(SNMP_MGR_IsDebugMode())
   	                SYSFUN_Debug_Printf("diffServClfrElementTable_next: get & genext return false\n");
   		        return FALSE;
   		    }
        }
	}
	else
	{
		if (!L4_DS_MGR_GetNextClfrElement(&data->clfr_id, &data->id, data))
		{
		    if(SNMP_MGR_IsDebugMode())
   	            SYSFUN_Debug_Printf("diffServClfrElementTable_next: get return false\n");
			return FALSE;
		}
	}
	return TRUE;
}

/*
 * var_diffServClfrElementTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_diffServClfrElementTable(struct variable *vp,
                             oid * name,
                             size_t * length,
                             int exact,
                             size_t * var_len, WriteMethod ** write_method)
{
    UI32_T compc=0;
    oid compl[diffServClfrElementEntry_INSTANCE_LEN];
    oid best_inst[diffServClfrElementEntry_INSTANCE_LEN];
    L4_TYPE_diffServClfrElementEntry_T data;

   /*Since this table allow for entry that does not exist, (creation). we need to know the write method first*/
    switch (vp->magic)
    {
      case DIFFSERVCLFRELEMENTPRECEDENCE:
        *write_method = write_diffServClfrElementPrecedence;
        break;
      case DIFFSERVCLFRELEMENTNEXT:
        *write_method = write_diffServClfrElementNext;
        break;
      case DIFFSERVCLFRELEMENTSPECIFIC:
        *write_method = write_diffServClfrElementSpecific;
        break;
      case DIFFSERVCLFRELEMENTSTORAGE:
        *write_method = write_diffServClfrElementStorage;
        break;
      case DIFFSERVCLFRELEMENTSTATUS:
        *write_method = write_diffServClfrElementStatus;
        break;
      default:
        *write_method =0;
         break;
    }

    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl, diffServClfrElementEntry_INSTANCE_LEN);

     /*check compc, retrive compl*/
    if (exact)/*get,set*/
    {
        if (!diffServClfrElementTable_get(compc, compl, &data))
            return NULL;
    }
    else/*getnext*/
    {
        if (!diffServClfrElementTable_next(compc, compl, &data))
            return NULL;
    }
    memcpy(name, vp->name, vp->namelen*sizeof(oid));
    best_inst[0]=data.clfr_id;
    best_inst[1]=data.id;

    memcpy(name + vp->namelen, best_inst, diffServClfrElementEntry_INSTANCE_LEN*sizeof(oid));
    *length = vp->namelen +diffServClfrElementEntry_INSTANCE_LEN;

    *var_len = sizeof(long_return);
    /*
     * * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
      case DIFFSERVCLFRELEMENTPRECEDENCE:
        long_return = data.precedence;
        return (u_char*) &long_return;
      case DIFFSERVCLFRELEMENTNEXT:
       {
        SNMP_TYPE_Oid_T snmpoid;
        if(SNMP_MGR_IsDebugMode())
            print_dsoid(&data.next);
        if (L4_DS_MGR_DiffServRowPointerToOid(&data.next, &snmpoid))
        {
            *var_len = snmpoid.oid_len * sizeof(UI32_T);
            memcpy(oid_return, snmpoid.oid, *var_len);
            return (u_char *) oid_return;
        }
        else
        {
            if(SNMP_MGR_IsDebugMode())
   	            SYSFUN_Debug_Printf("var_diffServClfrElementTable:L4_DS_MGR_DiffServRowPointerToOid return false\n");
            return NULL;
        }
      }
      case DIFFSERVCLFRELEMENTSPECIFIC:
       {
        SNMP_TYPE_Oid_T snmpoid;
        if(SNMP_MGR_IsDebugMode())
            print_dsoid(&data.specific);
        if (L4_DS_MGR_DiffServRowPointerToOid(&data.specific, &snmpoid))
        {
            *var_len = snmpoid.oid_len * sizeof(UI32_T);
            memcpy(oid_return, snmpoid.oid, *var_len);
            return (u_char *) oid_return;
        }
        else
        {
            if(SNMP_MGR_IsDebugMode())
   	            SYSFUN_Debug_Printf("var_diffServClfrElementTable:L4_DS_MGR_DiffServRowPointerToOid return false\n");
            return NULL;
        }
      }
      case DIFFSERVCLFRELEMENTSTORAGE:
        long_return = data.storage;
        return (u_char*) &long_return;
      case DIFFSERVCLFRELEMENTSTATUS:
        long_return = data.status;
        return (u_char*) &long_return;
    default:
        ERROR_MSG("");
    }
    return NULL;
}


int
write_diffServClfrElementPrecedence(int action,
                                    u_char * var_val,
                                    u_char var_val_type,
                                    size_t var_val_len,
                                    u_char * statP,
                                    oid * name, size_t name_len)
{
    u_long          value;

    switch (action) {
    case RESERVE1:
        /* check 1: check if the input index is exactly match, if not return fail*/
        if (name_len!=  diffServClfrElementEntry_OID_NAME_LEN + diffServClfrElementEntry_INSTANCE_LEN )
        {
            return SNMP_ERR_WRONGLENGTH;
        }
        if (var_val_type != ASN_UNSIGNED) {

            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(u_long)) {

            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        break;
    case FREE:
        /*
         * Release any resources that have been allocated
         */
        break;

    case ACTION:
    {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        UI32_T clfr_id, id;
        clfr_id=name[diffServClfrElementEntry_OID_NAME_LEN];
        id=name[diffServClfrElementEntry_OID_NAME_LEN+1];
        value = *(u_long *)var_val;
        if(SNMP_MGR_IsDebugMode())
             SYSFUN_Debug_Printf("write_diffServClfrElementPrecedence:clfr_id=[%lu], id=[%lu], value=[%lu]\n", clfr_id, id, value);

        if (!L4_DS_MGR_SetDiffServClfrElementPrecedence(clfr_id, id, value))
        {
            if(SNMP_MGR_IsDebugMode())
                SYSFUN_Debug_Printf("write_diffServClfrElementPrecedence:L4_DS_MGR_SetDiffServClfrElementPrecedence return false\n");
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    case UNDO:
        /*
         * Back out any changes made in the ACTION case
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_diffServClfrElementNext(int action,
                              u_char * var_val,
                              u_char var_val_type,
                              size_t var_val_len,
                              u_char * statP, oid * name, size_t name_len)
{


    switch (action) {
    case RESERVE1:
         /* check 1: check if the input index is exactly match, if not return fail*/
        if (name_len!=  diffServClfrElementEntry_OID_NAME_LEN + diffServClfrElementEntry_INSTANCE_LEN )
        {
            return SNMP_ERR_WRONGLENGTH;
        }
        if (var_val_type != ASN_OBJECT_ID) {

            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > (SYS_ADPT_MAX_OID_COUNT * sizeof(UI32_T))) {

            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        break;
    case FREE:
        /*
         * Release any resources that have been allocated
         */
        break;

    case ACTION:
    {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
         SNMP_TYPE_Oid_T snmpoid;
         L4_DS_TYPE_Oid_T dsoid;
         UI32_T clfr_id, id;
         clfr_id=name[diffServClfrElementEntry_OID_NAME_LEN];
         id=name[diffServClfrElementEntry_OID_NAME_LEN+1];
         memcpy(snmpoid.oid, var_val, var_val_len);
         snmpoid.oid_len=var_val_len;
         if(SNMP_MGR_IsDebugMode())
            print_snmpoid(&snmpoid);
         if (L4_DS_MGR_OidToDiffServRowPointer(&snmpoid, &dsoid))
         {
             if(SNMP_MGR_IsDebugMode())
             {
                 SYSFUN_Debug_Printf("write_diffServClfrElementNext:clfr_id=[%lu], id=[%lu]\n", clfr_id, id);
                 print_dsoid(&dsoid);
             }
             if (!L4_DS_MGR_SetDiffServClfrElementNext(clfr_id, id, &dsoid))
             {
                if(SNMP_MGR_IsDebugMode())
                    SYSFUN_Debug_Printf("write_diffServClfrElementNext:L4_DS_MGR_SetDiffServClfrElementNext return false\n");
                return SNMP_ERR_COMMITFAILED;
             }
         }
         else
         {
            if(SNMP_MGR_IsDebugMode())
                SYSFUN_Debug_Printf("write_diffServClfrElementNext:L4_DS_MGR_OidToDiffServRowPointer return false\n");
         }
         break;
    }
    case UNDO:
        /*
         * Back out any changes made in the ACTION case
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_diffServClfrElementSpecific(int action,
                                  u_char * var_val,
                                  u_char var_val_type,
                                  size_t var_val_len,
                                  u_char * statP,
                                  oid * name, size_t name_len)
{


    switch (action) {
    case RESERVE1:
        /* check 1: check if the input index is exactly match, if not return fail*/
        if (name_len!=  diffServClfrElementEntry_OID_NAME_LEN + diffServClfrElementEntry_INSTANCE_LEN )
        {
            return SNMP_ERR_WRONGLENGTH;
        }
        if (var_val_type != ASN_OBJECT_ID) {

            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > (SYS_ADPT_MAX_OID_COUNT * sizeof(UI32_T))) {

            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        break;
    case FREE:
        /*
         * Release any resources that have been allocated
         */
        break;

    case ACTION:
    {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
         SNMP_TYPE_Oid_T snmpoid;
         L4_DS_TYPE_Oid_T dsoid;
         UI32_T clfr_id, id;
         clfr_id=name[diffServClfrElementEntry_OID_NAME_LEN];
         id=name[diffServClfrElementEntry_OID_NAME_LEN+1];
         memcpy(snmpoid.oid, var_val, var_val_len);
         snmpoid.oid_len=var_val_len;
         if(SNMP_MGR_IsDebugMode())
            print_snmpoid(&snmpoid);
         if (L4_DS_MGR_OidToDiffServRowPointer(&snmpoid, &dsoid))
         {
             if(SNMP_MGR_IsDebugMode())
             {
                 SYSFUN_Debug_Printf("write_diffServClfrElementSpecific:clfr_id=[%lu], id=[%lu]\n", clfr_id, id);
                 print_dsoid(&dsoid);
             }
             if (!L4_DS_MGR_SetDiffServClfrElementSpecific(clfr_id, id, &dsoid))
             {
                if(SNMP_MGR_IsDebugMode())
                    SYSFUN_Debug_Printf("write_diffServClfrElementSpecific:L4_DS_MGR_SetDiffServClfrElementSpecific return false\n");
                return SNMP_ERR_COMMITFAILED;
             }
         }
         else
         {
            if(SNMP_MGR_IsDebugMode())
                SYSFUN_Debug_Printf("write_diffServClfrElementSpecific:L4_DS_MGR_OidToDiffServRowPointer return false\n");
         }
         break;
    }
    case UNDO:
        /*
         * Back out any changes made in the ACTION case
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_diffServClfrElementStorage(int action,
                                 u_char * var_val,
                                 u_char var_val_type,
                                 size_t var_val_len,
                                 u_char * statP,
                                 oid * name, size_t name_len)
{
    long            value;

    switch (action) {
    case RESERVE1:
        /* check 1: check if the input index is exactly match, if not return fail*/
        if (name_len!=  diffServClfrElementEntry_OID_NAME_LEN + diffServClfrElementEntry_INSTANCE_LEN )
        {
            return SNMP_ERR_WRONGLENGTH;
        }
        if (var_val_type != ASN_INTEGER) {

            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {

            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        value = *(long *)var_val;
        switch(value)
        {
          case VAL_diffServClfrElementStorage_other:
          case VAL_diffServClfrElementStorage_volatile:
          case VAL_diffServClfrElementStorage_nonVolatile:
          case VAL_diffServClfrElementStorage_permanent:
          case VAL_diffServClfrElementStorage_readOnly:
            break;
          default:
            return SNMP_ERR_WRONGVALUE;
        }
        break;

    case FREE:
        /*
         * Release any resources that have been allocated
         */
        break;

    case ACTION:
    {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        UI32_T clfr_id, id;
        clfr_id=name[diffServClfrElementEntry_OID_NAME_LEN];
        id=name[diffServClfrElementEntry_OID_NAME_LEN+1];
        value = *(long *)var_val;
        if(SNMP_MGR_IsDebugMode())
             SYSFUN_Debug_Printf("write_diffServClfrElementStorage:clfr_id=[%lu], id=[%lu], value=[%lu]\n", clfr_id, id, value);

        if (!L4_DS_MGR_SetDiffServClfrElementStorage(clfr_id, id, value))
        {
            if(SNMP_MGR_IsDebugMode())
                SYSFUN_Debug_Printf("write_diffServClfrElementStorage:L4_DS_MGR_SetDiffServClfrElementStorage return false\n");
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    case UNDO:
        /*
         * Back out any changes made in the ACTION case
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_diffServClfrElementStatus(int action,
                                u_char * var_val,
                                u_char var_val_type,
                                size_t var_val_len,
                                u_char * statP,
                                oid * name, size_t name_len)
{
    long            value;

    switch (action) {
    case RESERVE1:
        /* check 1: check if the input index is exactly match, if not return fail*/
        if (name_len!=  diffServClfrElementEntry_OID_NAME_LEN + diffServClfrElementEntry_INSTANCE_LEN )
        {
            return SNMP_ERR_WRONGLENGTH;
        }
        if (var_val_type != ASN_INTEGER) {

            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {

            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        value = *(long *)var_val;
        switch(value)
        {
          case VAL_diffServClfrElementStatus_active:
          case VAL_diffServClfrElementStatus_notInService:
          case VAL_diffServClfrElementStatus_notReady:
          case VAL_diffServClfrElementStatus_createAndGo:
          case VAL_diffServClfrElementStatus_createAndWait:
          case VAL_diffServClfrElementStatus_destroy:
            break;
          default:
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    case FREE:
        /*
         * Release any resources that have been allocated
         */
        break;

    case ACTION:
    {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        UI32_T clfr_id, id;
        clfr_id=name[diffServClfrElementEntry_OID_NAME_LEN];
        id=name[diffServClfrElementEntry_OID_NAME_LEN+1];
        value = *(long *)var_val;
        if(SNMP_MGR_IsDebugMode())
             SYSFUN_Debug_Printf("write_diffServClfrElementStatus:clfr_id=[%lu], id=[%lu], value=[%lu]\n", clfr_id, id, value);

        if (!L4_DS_MGR_SetDiffServClfrElementStatus(clfr_id, id, value))
        {
            if(SNMP_MGR_IsDebugMode())
                SYSFUN_Debug_Printf("write_diffServClfrElementStatus:L4_DS_MGR_SetDiffServClfrElementStatus return false\n");
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    case UNDO:
        /*
         * Back out any changes made in the ACTION case
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}


/*
 * diffServMultiFieldClfrTable_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */
#define diffServMultiFieldClfrEntry_INSTANCE_LEN 1
#define diffServMultiFieldClfrEntry_OID_NAME_LEN 12

oid             diffServMultiFieldClfrTable_variables_oid[] =
    { 1, 3, 6, 1, 2, 1, 97, 1, 2 };

/*
 * variable4 diffServMultiFieldClfrTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */

struct variable3 diffServMultiFieldClfrTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */

#define DIFFSERVMULTIFIELDCLFRID		1
    {DIFFSERVMULTIFIELDCLFRID, ASN_UNSIGNED, RONLY,
     var_diffServMultiFieldClfrTable, 3, {6, 1, 1}},
#define DIFFSERVMULTIFIELDCLFRADDRTYPE		2
    {DIFFSERVMULTIFIELDCLFRADDRTYPE, ASN_INTEGER, RWRITE,
     var_diffServMultiFieldClfrTable, 3, {6, 1, 2}},
#define DIFFSERVMULTIFIELDCLFRDSTADDR		3
    {DIFFSERVMULTIFIELDCLFRDSTADDR, ASN_OCTET_STR, RWRITE,
     var_diffServMultiFieldClfrTable, 3, {6, 1, 3}},
#define DIFFSERVMULTIFIELDCLFRDSTPREFIXLENGTH		4
    {DIFFSERVMULTIFIELDCLFRDSTPREFIXLENGTH, ASN_UNSIGNED, RWRITE,
     var_diffServMultiFieldClfrTable, 3, {6, 1, 4}},
#define DIFFSERVMULTIFIELDCLFRSRCADDR		5
    {DIFFSERVMULTIFIELDCLFRSRCADDR, ASN_OCTET_STR, RWRITE,
     var_diffServMultiFieldClfrTable, 3, {6, 1, 5}},
#define DIFFSERVMULTIFIELDCLFRSRCPREFIXLENGTH		6
    {DIFFSERVMULTIFIELDCLFRSRCPREFIXLENGTH, ASN_UNSIGNED, RWRITE,
     var_diffServMultiFieldClfrTable, 3, {6, 1, 6}},
#define DIFFSERVMULTIFIELDCLFRDSCP		7
    {DIFFSERVMULTIFIELDCLFRDSCP, ASN_INTEGER, RWRITE,
     var_diffServMultiFieldClfrTable, 3, {6, 1, 7}},
#define DIFFSERVMULTIFIELDCLFRFLOWID		8
    {DIFFSERVMULTIFIELDCLFRFLOWID, ASN_UNSIGNED, RWRITE,
     var_diffServMultiFieldClfrTable, 3, {6, 1, 8}},
#define DIFFSERVMULTIFIELDCLFRPROTOCOL		9
    {DIFFSERVMULTIFIELDCLFRPROTOCOL, ASN_UNSIGNED, RWRITE,
     var_diffServMultiFieldClfrTable, 3, {6, 1, 9}},
#define DIFFSERVMULTIFIELDCLFRDSTL4PORTMIN		10
    {DIFFSERVMULTIFIELDCLFRDSTL4PORTMIN, ASN_UNSIGNED, RWRITE,
     var_diffServMultiFieldClfrTable, 3, {6, 1, 10}},
#define DIFFSERVMULTIFIELDCLFRDSTL4PORTMAX		11
    {DIFFSERVMULTIFIELDCLFRDSTL4PORTMAX, ASN_UNSIGNED, RWRITE,
     var_diffServMultiFieldClfrTable, 3, {6, 1, 11}},
#define DIFFSERVMULTIFIELDCLFRSRCL4PORTMIN		12
    {DIFFSERVMULTIFIELDCLFRSRCL4PORTMIN, ASN_UNSIGNED, RWRITE,
     var_diffServMultiFieldClfrTable, 3, {6, 1, 12}},
#define DIFFSERVMULTIFIELDCLFRSRCL4PORTMAX		13
    {DIFFSERVMULTIFIELDCLFRSRCL4PORTMAX, ASN_UNSIGNED, RWRITE,
     var_diffServMultiFieldClfrTable, 3, {6, 1, 13}},
#define DIFFSERVMULTIFIELDCLFRSTORAGE		14
    {DIFFSERVMULTIFIELDCLFRSTORAGE, ASN_INTEGER, RWRITE,
     var_diffServMultiFieldClfrTable, 3, {6, 1, 14}},
#define DIFFSERVMULTIFIELDCLFRSTATUS		15
    {DIFFSERVMULTIFIELDCLFRSTATUS, ASN_INTEGER, RWRITE,
     var_diffServMultiFieldClfrTable, 3, {6, 1, 15}},
};
/*
 * (L = length of the oidsuffix)
 */


/** Initializes the diffServMultiFieldClfrTable module */
void
init_diffServMultiFieldClfrTable(void)
{
    /*
     * register ourselves with the agent to handle our mib tree
     */
    REGISTER_MIB("diffServMultiFieldClfrTable",
                 diffServMultiFieldClfrTable_variables, variable3,
                 diffServMultiFieldClfrTable_variables_oid);

    /*
     * place any other initialization junk you need here
     */
}

static BOOL_T diffServMultiFieldClfrTable_get(int      compc,
                                oid     *compl,
                                L4_TYPE_diffServMultiFieldClfrEntry_T   *data)
{
    if (compc !=diffServMultiFieldClfrEntry_INSTANCE_LEN)
    {
 	    return FALSE;
    }
    data->id=compl[0];

    if(SNMP_MGR_IsDebugMode())
        SYSFUN_Debug_Printf("diffServMultiFieldClfrTable_get:data->id=[%lu]\n", data->id);

	if (!L4_DS_MGR_GetMultiFieldClfr(data->id, data))
	{
	    if(SNMP_MGR_IsDebugMode())
	        SYSFUN_Debug_Printf("diffServMultiFieldClfrTable_get:L4_DS_MGR_GetMultiFieldClfr return false\n");
		return FALSE;
	}
	else
	{
		return TRUE;
	} /*End of if */
}

static BOOL_T diffServMultiFieldClfrTable_next(int      compc,
                                 oid     *compl,
                                 L4_TYPE_diffServMultiFieldClfrEntry_T    *data)
{
  	oid tmp_compl[diffServMultiFieldClfrEntry_INSTANCE_LEN];

 	/* Generate the instance of each table entry and find the
	 * smallest instance that's larger than compc/compl.
	 *
	 * Step 1: Verify and extract the input key from "compc" and "compl"
	 * Note: The number of input key is defined by "compc".
	 *       The key for the specified instance is defined in compl.
	 */

	memcpy(tmp_compl, compl, sizeof(tmp_compl));
	SNMP_MGR_ConvertRemainToZero(compc,diffServMultiFieldClfrEntry_INSTANCE_LEN, tmp_compl);
	data->id=tmp_compl[0];

    if(SNMP_MGR_IsDebugMode())
        SYSFUN_Debug_Printf("diffServMultiFieldClfrTable_next:data->id=[%lu]\n", data->id);

	if (compc<diffServMultiFieldClfrEntry_INSTANCE_LEN)
	{
		if (!L4_DS_MGR_GetMultiFieldClfr(data->id, data))
        {
            if (!L4_DS_MGR_GetNextMultiFieldClfr(&data->id, data))
   	        {
   	            if(SNMP_MGR_IsDebugMode())
   	                SYSFUN_Debug_Printf("diffServMultiFieldClfrTable_next: get & genext return false\n");
   		        return FALSE;
   		    }
        }
	}
	else
	{
		if (!L4_DS_MGR_GetNextMultiFieldClfr(&data->id, data))
		{
		    if(SNMP_MGR_IsDebugMode())
   	            SYSFUN_Debug_Printf("diffServMultiFieldClfrTable_next: get return false\n");
			return FALSE;
		}
	}
	return TRUE;
}

/*
 * var_diffServMultiFieldClfrTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_diffServMultiFieldClfrTable(struct variable *vp,
                                oid * name,
                                size_t * length,
                                int exact,
                                size_t * var_len,
                                WriteMethod ** write_method)
{
    UI32_T compc=0;
    oid compl[diffServMultiFieldClfrEntry_INSTANCE_LEN];
    oid best_inst[diffServMultiFieldClfrEntry_INSTANCE_LEN];
    L4_TYPE_diffServMultiFieldClfrEntry_T data;

   /*Since this table allow for entry that does not exist, (creation). we need to know the write method first*/
    switch (vp->magic)
    {
      case DIFFSERVMULTIFIELDCLFRADDRTYPE:
        *write_method = write_diffServMultiFieldClfrAddrType;
        break;
      case DIFFSERVMULTIFIELDCLFRDSTADDR:
        *write_method = write_diffServMultiFieldClfrDstAddr;
        break;
      case DIFFSERVMULTIFIELDCLFRDSTPREFIXLENGTH:
        *write_method = write_diffServMultiFieldClfrDstPrefixLength;
        break;
      case DIFFSERVMULTIFIELDCLFRSRCADDR:
        *write_method = write_diffServMultiFieldClfrSrcAddr;
        break;
      case DIFFSERVMULTIFIELDCLFRSRCPREFIXLENGTH:
        *write_method = write_diffServMultiFieldClfrSrcPrefixLength;
        break;
      case DIFFSERVMULTIFIELDCLFRDSCP:
        *write_method = write_diffServMultiFieldClfrDscp;
        break;
      case DIFFSERVMULTIFIELDCLFRFLOWID:
        *write_method = write_diffServMultiFieldClfrFlowId;
        break;
      case DIFFSERVMULTIFIELDCLFRPROTOCOL:
        *write_method = write_diffServMultiFieldClfrProtocol;
        break;
      case DIFFSERVMULTIFIELDCLFRDSTL4PORTMIN:
        *write_method = write_diffServMultiFieldClfrDstL4PortMin;
        break;
      case DIFFSERVMULTIFIELDCLFRDSTL4PORTMAX:
        *write_method = write_diffServMultiFieldClfrDstL4PortMax;
        break;
      case DIFFSERVMULTIFIELDCLFRSRCL4PORTMIN:
        *write_method = write_diffServMultiFieldClfrSrcL4PortMin;
        break;
      case DIFFSERVMULTIFIELDCLFRSRCL4PORTMAX:
        *write_method = write_diffServMultiFieldClfrSrcL4PortMax;
        break;
      case DIFFSERVMULTIFIELDCLFRSTORAGE:
        *write_method = write_diffServMultiFieldClfrStorage;
        break;
      case DIFFSERVMULTIFIELDCLFRSTATUS:
        *write_method = write_diffServMultiFieldClfrStatus;
        break;
      default:
        *write_method =0;
         break;
    }

    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl, diffServMultiFieldClfrEntry_INSTANCE_LEN);

     /*check compc, retrive compl*/
    if (exact)/*get,set*/
    {
        if (!diffServMultiFieldClfrTable_get(compc, compl, &data))
            return NULL;
    }
    else/*getnext*/
    {
        if (!diffServMultiFieldClfrTable_next(compc, compl, &data))
            return NULL;
    }
    memcpy(name, vp->name, vp->namelen*sizeof(oid));
    best_inst[0]=data.id;

    memcpy(name + vp->namelen, best_inst, diffServMultiFieldClfrEntry_INSTANCE_LEN*sizeof(oid));
    *length = vp->namelen +diffServMultiFieldClfrEntry_INSTANCE_LEN;

    *var_len = sizeof(long_return);

    /*
     * * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
      case DIFFSERVMULTIFIELDCLFRADDRTYPE:
        long_return = 0;/*lower layer not support*/
        return (u_char*) &long_return;
      case DIFFSERVMULTIFIELDCLFRDSTADDR:
        memcpy(return_buf, &data.dst_addr, sizeof(data.dst_addr));
        *var_len=sizeof(data.dst_addr);
        return (u_char*) return_buf;
      case DIFFSERVMULTIFIELDCLFRDSTPREFIXLENGTH:
        long_return = data.dst_prefix_length;
        return (u_char*) &long_return;
      case DIFFSERVMULTIFIELDCLFRSRCADDR:
        long_return = data.src_addr;
        return (u_char*) &long_return;
      case DIFFSERVMULTIFIELDCLFRSRCPREFIXLENGTH:
        long_return = data.src_prefix_length;
        return (u_char*) &long_return;
      case DIFFSERVMULTIFIELDCLFRDSCP:
        long_return = data.dscp;
        return (u_char*) &long_return;
      case DIFFSERVMULTIFIELDCLFRFLOWID:
        long_return = 0;/*lower layer not support*/
        return (u_char*) &long_return;
      case DIFFSERVMULTIFIELDCLFRPROTOCOL:
        long_return = data.protocol;
        return (u_char*) &long_return;
      case DIFFSERVMULTIFIELDCLFRDSTL4PORTMIN:
        long_return = data.dst_port_min;
        return (u_char*) &long_return;
      case DIFFSERVMULTIFIELDCLFRDSTL4PORTMAX:
        long_return = data.dst_port_max;
        return (u_char*) &long_return;
      case DIFFSERVMULTIFIELDCLFRSRCL4PORTMIN:
        long_return = data.src_port_min;
        return (u_char*) &long_return;
      case DIFFSERVMULTIFIELDCLFRSRCL4PORTMAX:
        long_return = data.src_port_max;
        return (u_char*) &long_return;
      case DIFFSERVMULTIFIELDCLFRSTORAGE:
        long_return = data.storage;
        return (u_char*) &long_return;
      case DIFFSERVMULTIFIELDCLFRSTATUS:
        long_return = data.status;
        return (u_char*) &long_return;
    default:
        ERROR_MSG("");
    }
    return NULL;
}


int
write_diffServMultiFieldClfrAddrType(int action,
                                     u_char * var_val,
                                     u_char var_val_type,
                                     size_t var_val_len,
                                     u_char * statP,
                                     oid * name, size_t name_len)
{
    long            value;

    switch (action) {
    case RESERVE1:
        /*lower layer not support*/
        return SNMP_ERR_COMMITFAILED;

        /* check 1: check if the input index is exactly match, if not return fail*/
        if (name_len!=  diffServMultiFieldClfrEntry_OID_NAME_LEN + diffServMultiFieldClfrEntry_INSTANCE_LEN )
        {
            return SNMP_ERR_WRONGLENGTH;
        }
        if (var_val_type != ASN_INTEGER) {

            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {

            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        value = *(long *)var_val;
        switch(value)
        {
          case VAL_diffServMultiFieldClfrAddrType_unknown:
          case VAL_diffServMultiFieldClfrAddrType_ipv4:
          case VAL_diffServMultiFieldClfrAddrType_ipv6:
          case VAL_diffServMultiFieldClfrAddrType_ipv4z:
          case VAL_diffServMultiFieldClfrAddrType_ipv6z:
          case VAL_diffServMultiFieldClfrAddrType_dns:
            break;
          default:
            return SNMP_ERR_WRONGVALUE;
        }
        break;
        break;

    case FREE:
        /*
         * Release any resources that have been allocated
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_diffServMultiFieldClfrDstAddr(int action,
                                    u_char * var_val,
                                    u_char var_val_type,
                                    size_t var_val_len,
                                    u_char * statP,
                                    oid * name, size_t name_len)
{
    UI8_T buffer[MAXSIZE_diffServMultiFieldClfrDstAddr];

    switch (action) {
    case RESERVE1:
        /* check 1: check if the input index is exactly match, if not return fail*/
        if (name_len!=  diffServMultiFieldClfrEntry_OID_NAME_LEN + diffServMultiFieldClfrEntry_INSTANCE_LEN )
        {
            return SNMP_ERR_WRONGLENGTH;
        }
        if (var_val_type != ASN_OCTET_STR) {

            return SNMP_ERR_WRONGTYPE;
        }
        if (!((var_val_len >= MINSIZE_diffServMultiFieldClfrDstAddr) &&
              (var_val_len <= MAXSIZE_diffServMultiFieldClfrDstAddr))) {

            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        break;

    case FREE:
        /*
         * Release any resources that have been allocated
         */
        break;

    case ACTION:
    {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        UI32_T id, value;
        id=name[diffServMultiFieldClfrEntry_OID_NAME_LEN];
        memcpy(buffer, var_val, var_val_len);
        memcpy(&value, buffer, sizeof(UI32_T));
        if(SNMP_MGR_IsDebugMode())
             SYSFUN_Debug_Printf("write_diffServMultiFieldClfrDstAddr:id=[%lu],value=[%lu]\n", id, value);

        if (!L4_DS_MGR_SetDiffServMultiFieldClfrDstAddr(id, value))
        {
            if(SNMP_MGR_IsDebugMode())
                SYSFUN_Debug_Printf("write_diffServMultiFieldClfrDstAddr:L4_DS_MGR_SetDiffServMultiFieldClfrDstAddr return false\n");
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }

    case UNDO:
        /*
         * Back out any changes made in the ACTION case
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_diffServMultiFieldClfrDstPrefixLength(int action,
                                            u_char * var_val,
                                            u_char var_val_type,
                                            size_t var_val_len,
                                            u_char * statP,
                                            oid * name, size_t name_len)
{
    u_long          value;

    switch (action) {
    case RESERVE1:
        /* check 1: check if the input index is exactly match, if not return fail*/
        if (name_len!=  diffServMultiFieldClfrEntry_OID_NAME_LEN + diffServMultiFieldClfrEntry_INSTANCE_LEN )
        {
            return SNMP_ERR_WRONGLENGTH;
        }
        if (var_val_type != ASN_UNSIGNED) {

            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(u_long)) {

            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        break;
    case FREE:
        /*
         * Release any resources that have been allocated
         */
        break;
    case ACTION:
    {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        UI32_T id;
        id=name[diffServMultiFieldClfrEntry_OID_NAME_LEN];
        value = *(u_long *)var_val;
        if(SNMP_MGR_IsDebugMode())
             SYSFUN_Debug_Printf("write_diffServMultiFieldClfrDstPrefixLength:id=[%lu], value=[%lu]\n", id, value);

        if (!L4_DS_MGR_SetDiffServMultiFieldClfrDstPrefixLength(id, value))
        {
            if(SNMP_MGR_IsDebugMode())
                SYSFUN_Debug_Printf("write_diffServMultiFieldClfrDstPrefixLength:L4_DS_MGR_SetDiffServMultiFieldClfrDstPrefixLength return false\n");
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    case UNDO:
        /*
         * Back out any changes made in the ACTION case
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_diffServMultiFieldClfrSrcAddr(int action,
                                    u_char * var_val,
                                    u_char var_val_type,
                                    size_t var_val_len,
                                    u_char * statP,
                                    oid * name, size_t name_len)
{
    UI8_T buffer[MAXSIZE_diffServMultiFieldClfrSrcAddr];

    switch (action) {
    case RESERVE1:
        /* check 1: check if the input index is exactly match, if not return fail*/
        if (name_len!=  diffServMultiFieldClfrEntry_OID_NAME_LEN + diffServMultiFieldClfrEntry_INSTANCE_LEN )
        {
            return SNMP_ERR_WRONGLENGTH;
        }
        if (var_val_type != ASN_OCTET_STR) {

            return SNMP_ERR_WRONGTYPE;
        }
        if (!((var_val_len >= MINSIZE_diffServMultiFieldClfrSrcAddr) &&
              (var_val_len <= MAXSIZE_diffServMultiFieldClfrSrcAddr))) {

            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        break;
    case FREE:
        /*
         * Release any resources that have been allocated
         */
        break;

    case ACTION:
    {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        UI32_T id, value;
        id=name[diffServMultiFieldClfrEntry_OID_NAME_LEN];
        memcpy(buffer, var_val, var_val_len);
        memcpy(&value, buffer, sizeof(UI32_T));
        if(SNMP_MGR_IsDebugMode())
             SYSFUN_Debug_Printf("write_diffServMultiFieldClfrSrcAddr:id=[%lu], value=[%lu]\n", id, value);

        if (!L4_DS_MGR_SetDiffServMultiFieldClfrSrcAddr(id, value))
        {
            if(SNMP_MGR_IsDebugMode())
                SYSFUN_Debug_Printf("write_diffServMultiFieldClfrSrcAddr:L4_DS_MGR_SetDiffServMultiFieldClfrSrcAddr return false\n");
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    case UNDO:
        /*
         * Back out any changes made in the ACTION case
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_diffServMultiFieldClfrSrcPrefixLength(int action,
                                            u_char * var_val,
                                            u_char var_val_type,
                                            size_t var_val_len,
                                            u_char * statP,
                                            oid * name, size_t name_len)
{
    u_long          value;

    switch (action) {
    case RESERVE1:
        /* check 1: check if the input index is exactly match, if not return fail*/
        if (name_len!=  diffServMultiFieldClfrEntry_OID_NAME_LEN + diffServMultiFieldClfrEntry_INSTANCE_LEN )
        {
            return SNMP_ERR_WRONGLENGTH;
        }
        if (var_val_type != ASN_UNSIGNED) {

            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(u_long)) {

            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        break;
    case FREE:
        /*
         * Release any resources that have been allocated
         */
        break;

    case ACTION:
    {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        UI32_T id;
        id=name[diffServMultiFieldClfrEntry_OID_NAME_LEN];
        value = *(u_long *)var_val;
        if(SNMP_MGR_IsDebugMode())
             SYSFUN_Debug_Printf("write_diffServMultiFieldClfrSrcPrefixLength:id=[%lu], value=[%lu]\n", id, value);

        if (!L4_DS_MGR_SetDiffServMultiFieldClfrDstPrefixLength(id, value))
        {
            if(SNMP_MGR_IsDebugMode())
                SYSFUN_Debug_Printf("write_diffServMultiFieldClfrSrcPrefixLength:L4_DS_MGR_SetDiffServMultiFieldClfrDstPrefixLength return false\n");
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    case UNDO:
        /*
         * Back out any changes made in the ACTION case
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_diffServMultiFieldClfrDscp(int action,
                                 u_char * var_val,
                                 u_char var_val_type,
                                 size_t var_val_len,
                                 u_char * statP,
                                 oid * name, size_t name_len)
{
    long            value;

    switch (action) {
    case RESERVE1:
        /* check 1: check if the input index is exactly match, if not return fail*/
        if (name_len!=  diffServMultiFieldClfrEntry_OID_NAME_LEN + diffServMultiFieldClfrEntry_INSTANCE_LEN )
        {
            return SNMP_ERR_WRONGLENGTH;
        }
        if (var_val_type != ASN_INTEGER) {

            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {

            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        value = *(long *)var_val;
        if (!((value >= MIN_diffServMultiFieldClfrDscp) &&
              (value <= MAX_diffServMultiFieldClfrDscp)))
            return SNMP_ERR_WRONGVALUE;
        break;

    case FREE:
        /*
         * Release any resources that have been allocated
         */
        break;

    case ACTION:
    {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        UI32_T id;
        id=name[diffServMultiFieldClfrEntry_OID_NAME_LEN];

        value = *(long *)var_val;
        if(SNMP_MGR_IsDebugMode())
             SYSFUN_Debug_Printf("write_diffServMultiFieldClfrDscp:id=[%lu], value=[%lu]\n", id, value);

        if (!L4_DS_MGR_SetDiffServMultiFieldClfrDscp(id, value))
        {
            if(SNMP_MGR_IsDebugMode())
                SYSFUN_Debug_Printf("write_diffServMultiFieldClfrDscp:L4_DS_MGR_SetDiffServMultiFieldClfrDscp return false\n");
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }

    case UNDO:
        /*
         * Back out any changes made in the ACTION case
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_diffServMultiFieldClfrFlowId(int action,
                                   u_char * var_val,
                                   u_char var_val_type,
                                   size_t var_val_len,
                                   u_char * statP,
                                   oid * name, size_t name_len)
{

    switch (action) {
    case RESERVE1:
        /*lower layer not support*/
        return SNMP_ERR_COMMITFAILED;
        /* check 1: check if the input index is exactly match, if not return fail*/
        if (name_len!=  diffServMultiFieldClfrEntry_OID_NAME_LEN + diffServMultiFieldClfrEntry_INSTANCE_LEN )
        {
            return SNMP_ERR_WRONGLENGTH;
        }
        if (var_val_type != ASN_UNSIGNED) {

            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(u_long)) {

            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:

        break;

    case FREE:
        /*
         * Release any resources that have been allocated
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_diffServMultiFieldClfrProtocol(int action,
                                     u_char * var_val,
                                     u_char var_val_type,
                                     size_t var_val_len,
                                     u_char * statP,
                                     oid * name, size_t name_len)
{
    u_long          value;

    switch (action) {
    case RESERVE1:
        /* check 1: check if the input index is exactly match, if not return fail*/
        if (name_len!=  diffServMultiFieldClfrEntry_OID_NAME_LEN + diffServMultiFieldClfrEntry_INSTANCE_LEN )
        {
            return SNMP_ERR_WRONGLENGTH;
        }
        if (var_val_type != ASN_UNSIGNED) {

            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(u_long)) {

            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:

        break;

    case FREE:
        /*
         * Release any resources that have been allocated
         */
        break;

    case ACTION:
    {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        UI32_T id;
        id=name[diffServMultiFieldClfrEntry_OID_NAME_LEN];
        value = *(u_long *)var_val;
        if(SNMP_MGR_IsDebugMode())
             SYSFUN_Debug_Printf("write_diffServMultiFieldClfrProtocol:id=[%lu], value=[%lu]\n", id, value);

        if (!L4_DS_MGR_SetDiffServMultiFieldClfrProtocol(id, value))
        {
            if(SNMP_MGR_IsDebugMode())
                SYSFUN_Debug_Printf("write_diffServMultiFieldClfrProtocol:L4_DS_MGR_SetDiffServMultiFieldClfrProtocol return false\n");
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    case UNDO:
        /*
         * Back out any changes made in the ACTION case
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_diffServMultiFieldClfrDstL4PortMin(int action,
                                         u_char * var_val,
                                         u_char var_val_type,
                                         size_t var_val_len,
                                         u_char * statP,
                                         oid * name, size_t name_len)
{
    u_long          value;

    switch (action) {
    case RESERVE1:
        /* check 1: check if the input index is exactly match, if not return fail*/
        if (name_len!=  diffServMultiFieldClfrEntry_OID_NAME_LEN + diffServMultiFieldClfrEntry_INSTANCE_LEN )
        {
            return SNMP_ERR_WRONGLENGTH;
        }
        if (var_val_type != ASN_UNSIGNED) {

            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(u_long)) {

            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        break;

    case FREE:
        /*
         * Release any resources that have been allocated
         */
        break;

    case ACTION:
    {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        UI32_T id;
        id=name[diffServMultiFieldClfrEntry_OID_NAME_LEN];
        value = *(u_long *)var_val;
        if(SNMP_MGR_IsDebugMode())
             SYSFUN_Debug_Printf("write_diffServMultiFieldClfrDstL4PortMin:id=[%lu], value=[%lu]\n", id, value);

        if (!L4_DS_MGR_SetDiffServMultiFieldClfrDstL4PortMin(id, value))
        {
            if(SNMP_MGR_IsDebugMode())
                SYSFUN_Debug_Printf("write_diffServMultiFieldClfrDstL4PortMin:L4_DS_MGR_SetDiffServMultiFieldClfrDstL4PortMin return false\n");
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    case UNDO:
        /*
         * Back out any changes made in the ACTION case
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_diffServMultiFieldClfrDstL4PortMax(int action,
                                         u_char * var_val,
                                         u_char var_val_type,
                                         size_t var_val_len,
                                         u_char * statP,
                                         oid * name, size_t name_len)
{
    u_long          value;

    switch (action) {
    case RESERVE1:
        /* check 1: check if the input index is exactly match, if not return fail*/
        if (name_len!=  diffServMultiFieldClfrEntry_OID_NAME_LEN + diffServMultiFieldClfrEntry_INSTANCE_LEN )
        {
            return SNMP_ERR_WRONGLENGTH;
        }
        if (var_val_type != ASN_UNSIGNED) {

            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(u_long)) {

            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        break;
    case FREE:
        /*
         * Release any resources that have been allocated
         */
        break;

    case ACTION:
    {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        UI32_T id;
        id=name[diffServMultiFieldClfrEntry_OID_NAME_LEN];
        value = *(u_long *)var_val;
        if(SNMP_MGR_IsDebugMode())
             SYSFUN_Debug_Printf("write_diffServMultiFieldClfrDstL4PortMax:id=[%lu], value=[%lu]\n", id, value);

        if (!L4_DS_MGR_SetDiffServMultiFieldClfrDstL4PortMax(id, value))
        {
            if(SNMP_MGR_IsDebugMode())
                SYSFUN_Debug_Printf("write_diffServMultiFieldClfrDstL4PortMax:L4_DS_MGR_SetDiffServMultiFieldClfrDstL4PortMin return false\n");
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    case UNDO:
        /*
         * Back out any changes made in the ACTION case
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_diffServMultiFieldClfrSrcL4PortMin(int action,
                                         u_char * var_val,
                                         u_char var_val_type,
                                         size_t var_val_len,
                                         u_char * statP,
                                         oid * name, size_t name_len)
{
    u_long          value;

    switch (action) {
    case RESERVE1:
        /* check 1: check if the input index is exactly match, if not return fail*/
        if (name_len!=  diffServMultiFieldClfrEntry_OID_NAME_LEN + diffServMultiFieldClfrEntry_INSTANCE_LEN )
        {
            return SNMP_ERR_WRONGLENGTH;
        }
        if (var_val_type != ASN_UNSIGNED) {

            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(u_long)) {

            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        break;
    case FREE:
        /*
         * Release any resources that have been allocated
         */
        break;

    case ACTION:
    {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        UI32_T id;
        id=name[diffServMultiFieldClfrEntry_OID_NAME_LEN];
        value = *(u_long *)var_val;
        if(SNMP_MGR_IsDebugMode())
             SYSFUN_Debug_Printf("write_diffServMultiFieldClfrSrcL4PortMin:id=[%lu], value=[%lu]\n", id, value);

        if (!L4_DS_MGR_SetDiffServMultiFieldClfrSrcL4PortMin(id, value))
        {
            if(SNMP_MGR_IsDebugMode())
                SYSFUN_Debug_Printf("write_diffServMultiFieldClfrSrcL4PortMin:L4_DS_MGR_SetDiffServMultiFieldClfrSrcL4PortMin return false\n");
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    case UNDO:
        /*
         * Back out any changes made in the ACTION case
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_diffServMultiFieldClfrSrcL4PortMax(int action,
                                         u_char * var_val,
                                         u_char var_val_type,
                                         size_t var_val_len,
                                         u_char * statP,
                                         oid * name, size_t name_len)
{
    u_long          value;

    switch (action) {
    case RESERVE1:
        /* check 1: check if the input index is exactly match, if not return fail*/
        if (name_len!=  diffServMultiFieldClfrEntry_OID_NAME_LEN + diffServMultiFieldClfrEntry_INSTANCE_LEN )
        {
            return SNMP_ERR_WRONGLENGTH;
        }
        if (var_val_type != ASN_UNSIGNED) {

            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(u_long)) {

            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:

        break;

    case FREE:
        /*
         * Release any resources that have been allocated
         */
        break;

    case ACTION:
   {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        UI32_T id;
        id=name[diffServMultiFieldClfrEntry_OID_NAME_LEN];
        value = *(u_long *)var_val;
        if(SNMP_MGR_IsDebugMode())
             SYSFUN_Debug_Printf("write_diffServMultiFieldClfrSrcL4PortMax:id=[%lu], value=[%lu]\n", id, value);

        if (!L4_DS_MGR_SetDiffServMultiFieldClfrSrcL4PortMax(id, value))
        {
            if(SNMP_MGR_IsDebugMode())
                SYSFUN_Debug_Printf("write_diffServMultiFieldClfrSrcL4PortMax:L4_DS_MGR_SetDiffServMultiFieldClfrSrcL4PortMax return false\n");
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    case UNDO:
        /*
         * Back out any changes made in the ACTION case
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_diffServMultiFieldClfrStorage(int action,
                                    u_char * var_val,
                                    u_char var_val_type,
                                    size_t var_val_len,
                                    u_char * statP,
                                    oid * name, size_t name_len)
{
    long            value;

    switch (action) {
    case RESERVE1:
        /* check 1: check if the input index is exactly match, if not return fail*/
        if (name_len!=  diffServMultiFieldClfrEntry_OID_NAME_LEN + diffServMultiFieldClfrEntry_INSTANCE_LEN )
        {
            return SNMP_ERR_WRONGLENGTH;
        }
        if (var_val_type != ASN_INTEGER) {

            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {

            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        value = *(long *)var_val;
        switch(value)
        {
          case VAL_diffServMultiFieldClfrStorage_other:
          case VAL_diffServMultiFieldClfrStorage_volatile:
          case VAL_diffServMultiFieldClfrStorage_nonVolatile:
          case VAL_diffServMultiFieldClfrStorage_permanent:
          case VAL_diffServMultiFieldClfrStorage_readOnly:
            break;
          default:
            return SNMP_ERR_WRONGVALUE;
        }
        break;

    case FREE:
        /*
         * Release any resources that have been allocated
         */
        break;

    case ACTION:
    {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        UI32_T id;
        id=name[diffServMultiFieldClfrEntry_OID_NAME_LEN];
        value = *(long *)var_val;
        if(SNMP_MGR_IsDebugMode())
             SYSFUN_Debug_Printf("write_diffServMultiFieldClfrStorage:id=[%lu], value=[%lu]\n", id, value);

        if (!L4_DS_MGR_SetDiffServMultiFieldClfrStorage(id, value))
        {
            if(SNMP_MGR_IsDebugMode())
                SYSFUN_Debug_Printf("write_diffServMultiFieldClfrStorage:L4_DS_MGR_SetDiffServMultiFieldClfrStorage return false\n");
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    case UNDO:
        /*
         * Back out any changes made in the ACTION case
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_diffServMultiFieldClfrStatus(int action,
                                   u_char * var_val,
                                   u_char var_val_type,
                                   size_t var_val_len,
                                   u_char * statP,
                                   oid * name, size_t name_len)
{
    long            value;

    switch (action) {
    case RESERVE1:
        /* check 1: check if the input index is exactly match, if not return fail*/
        if (name_len!=  diffServMultiFieldClfrEntry_OID_NAME_LEN + diffServMultiFieldClfrEntry_INSTANCE_LEN )
        {
            return SNMP_ERR_WRONGLENGTH;
        }
        if (var_val_type != ASN_INTEGER) {

            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {

            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        value = *(long *)var_val;
        switch(value)
        {
          case VAL_diffServMultiFieldClfrStatus_active:
          case VAL_diffServMultiFieldClfrStatus_notInService:
          case VAL_diffServMultiFieldClfrStatus_notReady:
          case VAL_diffServMultiFieldClfrStatus_createAndGo:
          case VAL_diffServMultiFieldClfrStatus_createAndWait:
          case VAL_diffServMultiFieldClfrStatus_destroy:
            break;
          default:
            return SNMP_ERR_WRONGVALUE;
        }
        break;

    case FREE:
        /*
         * Release any resources that have been allocated
         */
        break;

    case ACTION:
     {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        UI32_T id;
        id=name[diffServMultiFieldClfrEntry_OID_NAME_LEN];
        value = *(long *)var_val;
        if(SNMP_MGR_IsDebugMode())
             SYSFUN_Debug_Printf("write_diffServMultiFieldClfrStatus:id=[%lu], value=[%lu]\n", id, value);

        if (!L4_DS_MGR_SetDiffServMultiFieldClfrStatus(id, value))
        {
            if(SNMP_MGR_IsDebugMode())
                SYSFUN_Debug_Printf("write_diffServMultiFieldClfrStatus:L4_DS_MGR_SetDiffServMultiFieldClfrStatus return false\n");
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    case UNDO:
        /*
         * Back out any changes made in the ACTION case
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

/*
 * diffServActionTable_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */
#define diffServActionEntry_INSTANCE_LEN 1
#define diffServActionEntry_OID_NAME_LEN 12

oid             diffServActionTable_variables_oid[] =
    { 1, 3, 6, 1, 2, 1, 97, 1, 5 };

/*
 * variable4 diffServActionTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */

struct variable3 diffServActionTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */

#define DIFFSERVACTIONID		1
    {DIFFSERVACTIONID, ASN_UNSIGNED, RONLY, var_diffServActionTable, 3,
     {2, 1, 1}},
#define DIFFSERVACTIONINTERFACE		2
    {DIFFSERVACTIONINTERFACE, ASN_INTEGER, RWRITE, var_diffServActionTable,
     3, {2, 1, 2}},
#define DIFFSERVACTIONNEXT		3
    {DIFFSERVACTIONNEXT, ASN_OBJECT_ID, RWRITE, var_diffServActionTable, 3,
     {2, 1, 3}},
#define DIFFSERVACTIONSPECIFIC		4
    {DIFFSERVACTIONSPECIFIC, ASN_OBJECT_ID, RWRITE,
     var_diffServActionTable, 3, {2, 1, 4}},
#define DIFFSERVACTIONSTORAGE		5
    {DIFFSERVACTIONSTORAGE, ASN_INTEGER, RWRITE, var_diffServActionTable,
     3, {2, 1, 5}},
#define DIFFSERVACTIONSTATUS		6
    {DIFFSERVACTIONSTATUS, ASN_INTEGER, RWRITE, var_diffServActionTable, 3,
     {2, 1, 6}},
};
/*
 * (L = length of the oidsuffix)
 */


/** Initializes the diffServActionTable module */
void
init_diffServActionTable(void)
{

    /*
     * register ourselves with the agent to handle our mib tree
     */
    REGISTER_MIB("diffServActionTable", diffServActionTable_variables,
                 variable3, diffServActionTable_variables_oid);

    /*
     * place any other initialization junk you need here
     */
}

static BOOL_T diffServActionTable_get(int      compc,
                                oid     *compl,
                                L4_TYPE_diffServActionEntry_T   *data)
{
    if (compc !=diffServActionEntry_INSTANCE_LEN)
    {
 	    return FALSE;
    }
    data->id=compl[0];

    if(SNMP_MGR_IsDebugMode())
        SYSFUN_Debug_Printf("diffServActionTable_get:data->id=[%lu]\n", data->id);

	if (!L4_DS_MGR_GetAction(data->id, data))
	{
	    if(SNMP_MGR_IsDebugMode())
	        SYSFUN_Debug_Printf("diffServActionTable_get:L4_DS_MGR_GetAction return false\n");
		return FALSE;
	}
	else
	{
		return TRUE;
	} /*End of if */
}

static BOOL_T diffServActionTable_next(int      compc,
                                 oid     *compl,
                                 L4_TYPE_diffServActionEntry_T    *data)
{
  	oid tmp_compl[diffServActionEntry_INSTANCE_LEN];

 	/* Generate the instance of each table entry and find the
	 * smallest instance that's larger than compc/compl.
	 *
	 * Step 1: Verify and extract the input key from "compc" and "compl"
	 * Note: The number of input key is defined by "compc".
	 *       The key for the specified instance is defined in compl.
	 */

	memcpy(tmp_compl, compl, sizeof(tmp_compl));
	SNMP_MGR_ConvertRemainToZero(compc,diffServActionEntry_INSTANCE_LEN, tmp_compl);
	data->id=tmp_compl[0];

    if(SNMP_MGR_IsDebugMode())
        SYSFUN_Debug_Printf("diffServActionTable_next:data->id=[%lu]\n", data->id);

	if (compc<diffServActionEntry_INSTANCE_LEN)
	{
		if (!L4_DS_MGR_GetAction(data->id, data))
        {
            if (!L4_DS_MGR_GetNextAction(&data->id, data))
   	        {
   	            if(SNMP_MGR_IsDebugMode())
   	                SYSFUN_Debug_Printf("diffServActionTable_next: get & genext return false\n");
   		        return FALSE;
   		    }
        }
	}
	else
	{
		if (!L4_DS_MGR_GetNextAction(&data->id, data))
		{
		    if(SNMP_MGR_IsDebugMode())
   	            SYSFUN_Debug_Printf("diffServActionTable_next: get return false\n");
			return FALSE;
		}
	}
	return TRUE;
}

/*
 * var_diffServActionTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_diffServActionTable(struct variable *vp,
                        oid * name,
                        size_t * length,
                        int exact,
                        size_t * var_len, WriteMethod ** write_method)
{
    UI32_T compc=0;
    oid compl[diffServActionEntry_INSTANCE_LEN];
    oid best_inst[diffServActionEntry_INSTANCE_LEN];
    L4_TYPE_diffServActionEntry_T data;

   /*Since this table allow for entry that does not exist, (creation). we need to know the write method first*/
    switch (vp->magic)
    {
      case DIFFSERVACTIONINTERFACE:
        *write_method = write_diffServActionInterface;
        break;
      case DIFFSERVACTIONNEXT:
        *write_method = write_diffServActionNext;
        break;
      case DIFFSERVACTIONSPECIFIC:
        *write_method = write_diffServActionSpecific;
        break;
      case DIFFSERVACTIONSTORAGE:
        *write_method = write_diffServActionStorage;
        break;
      case DIFFSERVACTIONSTATUS:
        *write_method = write_diffServActionStatus;
        break;
      default:
        *write_method =0;
         break;
    }

    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl, diffServActionEntry_INSTANCE_LEN);

     /*check compc, retrive compl*/
    if (exact)/*get,set*/
    {
        if (!diffServActionTable_get(compc, compl, &data))
            return NULL;
    }
    else/*getnext*/
    {
        if (!diffServActionTable_next(compc, compl, &data))
            return NULL;
    }
    memcpy(name, vp->name, vp->namelen*sizeof(oid));
    best_inst[0]=data.id;

    memcpy(name + vp->namelen, best_inst, diffServActionEntry_INSTANCE_LEN*sizeof(oid));
    *length = vp->namelen +diffServActionEntry_INSTANCE_LEN;

    *var_len = sizeof(long_return);

    /*
     * * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
      case DIFFSERVACTIONINTERFACE:
        long_return = data.interface;
        return (u_char*) &long_return;
      case DIFFSERVACTIONNEXT:
        {
        SNMP_TYPE_Oid_T snmpoid;
        if(SNMP_MGR_IsDebugMode())
            print_dsoid(&data.next);
        if (L4_DS_MGR_DiffServRowPointerToOid(&data.next, &snmpoid))
        {
            *var_len = snmpoid.oid_len * sizeof(UI32_T);
            memcpy(oid_return, snmpoid.oid, *var_len);
            return (u_char *) oid_return;
        }
        else
        {
            if(SNMP_MGR_IsDebugMode())
   	            SYSFUN_Debug_Printf("var_diffServActionTable:L4_DS_MGR_DiffServRowPointerToOid return false\n");
            return NULL;
        }
      }
      case DIFFSERVACTIONSPECIFIC:
      {
        SNMP_TYPE_Oid_T snmpoid;
        if(SNMP_MGR_IsDebugMode())
            print_dsoid(&data.next);
        if (L4_DS_MGR_DiffServRowPointerToOid(&data.specific, &snmpoid))
        {
            *var_len = snmpoid.oid_len * sizeof(UI32_T);
            memcpy(oid_return, snmpoid.oid, *var_len);
            return (u_char *) oid_return;
        }
        else
        {
            if(SNMP_MGR_IsDebugMode())
   	            SYSFUN_Debug_Printf("var_diffServActionTable:L4_DS_MGR_DiffServRowPointerToOid return false\n");
            return NULL;
        }
      }
      case DIFFSERVACTIONSTORAGE:
        long_return = data.storage;
        return (u_char*) &long_return;
      case DIFFSERVACTIONSTATUS:
        long_return = data.status;
        return (u_char*) &long_return;
    default:
        ERROR_MSG("");
    }
    return NULL;
}


int
write_diffServActionInterface(int action,
                              u_char * var_val,
                              u_char var_val_type,
                              size_t var_val_len,
                              u_char * statP, oid * name, size_t name_len)
{
    long            value;

    switch (action) {
    case RESERVE1:
        /* check 1: check if the input index is exactly match, if not return fail*/
        if (name_len!=  diffServActionEntry_OID_NAME_LEN + diffServActionEntry_INSTANCE_LEN )
        {
            return SNMP_ERR_WRONGLENGTH;
        }
        if (var_val_type != ASN_INTEGER) {

            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {

            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        value = *(long *)var_val;
        if (!((value >= MIN_diffServActionInterface) &&
              (value <= MAX_diffServActionInterface)))
            return SNMP_ERR_WRONGVALUE;
        break;
    case FREE:
        /*
         * Release any resources that have been allocated
         */
        break;

    case ACTION:
    {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        UI32_T id;
        id=name[diffServActionEntry_OID_NAME_LEN];
        value = *(long *)var_val;
        if(SNMP_MGR_IsDebugMode())
             SYSFUN_Debug_Printf("write_diffServActionInterface:id=[%lu], value=[%lu]\n", id, value);

        if (!L4_DS_MGR_SetDiffServActionInterface(id, value))
        {
            if(SNMP_MGR_IsDebugMode())
                SYSFUN_Debug_Printf("write_diffServActionInterface:L4_DS_MGR_SetDiffServActionInterface return false\n");
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }

    case UNDO:
        /*
         * Back out any changes made in the ACTION case
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_diffServActionNext(int action,
                         u_char * var_val,
                         u_char var_val_type,
                         size_t var_val_len,
                         u_char * statP, oid * name, size_t name_len)
{

    switch (action) {
    case RESERVE1:
        /* check 1: check if the input index is exactly match, if not return fail*/
        if (name_len!=  diffServActionEntry_OID_NAME_LEN + diffServActionEntry_INSTANCE_LEN )
        {
            return SNMP_ERR_WRONGLENGTH;
        }
        if (var_val_type != ASN_OBJECT_ID) {

            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > (SYS_ADPT_MAX_OID_COUNT * sizeof(UI32_T))) {
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        break;
    case FREE:
        /*
         * Release any resources that have been allocated
         */
        break;

    case ACTION:
    {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
         SNMP_TYPE_Oid_T snmpoid;
         L4_DS_TYPE_Oid_T dsoid;
         UI32_T id;
         id=name[diffServActionEntry_OID_NAME_LEN];
         memcpy(snmpoid.oid, var_val, var_val_len);
         snmpoid.oid_len=var_val_len;
         if(SNMP_MGR_IsDebugMode())
            print_snmpoid(&snmpoid);
         if (L4_DS_MGR_OidToDiffServRowPointer(&snmpoid, &dsoid))
         {
             if(SNMP_MGR_IsDebugMode())
             {
                 SYSFUN_Debug_Printf("write_diffServActionNext:id=[%lu]\n", id);
                 print_dsoid(&dsoid);
             }
             if (!L4_DS_MGR_SetDiffServActionNext(id, &dsoid))
             {
                if(SNMP_MGR_IsDebugMode())
                    SYSFUN_Debug_Printf("write_diffServActionNext:L4_DS_MGR_SetDiffServActionNext return false\n");
                return SNMP_ERR_COMMITFAILED;
             }
         }
         else
         {
            if(SNMP_MGR_IsDebugMode())
                SYSFUN_Debug_Printf("write_diffServActionNext:L4_DS_MGR_OidToDiffServRowPointer return false\n");
         }
         break;
    }
    case UNDO:
        /*
         * Back out any changes made in the ACTION case
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_diffServActionSpecific(int action,
                             u_char * var_val,
                             u_char var_val_type,
                             size_t var_val_len,
                             u_char * statP, oid * name, size_t name_len)
{

    switch (action) {
    case RESERVE1:
        /* check 1: check if the input index is exactly match, if not return fail*/
        if (name_len!=  diffServActionEntry_OID_NAME_LEN + diffServActionEntry_INSTANCE_LEN )
        {
            return SNMP_ERR_WRONGLENGTH;
        }
        if (var_val_type != ASN_OBJECT_ID) {

            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > (SYS_ADPT_MAX_OID_COUNT * sizeof(UI32_T))) {
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        break;
    case FREE:
        /*
         * Release any resources that have been allocated
         */
        break;

    case ACTION:
    {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
         SNMP_TYPE_Oid_T snmpoid;
         L4_DS_TYPE_Oid_T dsoid;
         UI32_T id;
         id=name[diffServActionEntry_OID_NAME_LEN];
         memcpy(snmpoid.oid, var_val, var_val_len);
         snmpoid.oid_len=var_val_len;
         if(SNMP_MGR_IsDebugMode())
            print_snmpoid(&snmpoid);
         if (L4_DS_MGR_OidToDiffServRowPointer(&snmpoid, &dsoid))
         {
             if(SNMP_MGR_IsDebugMode())
             {
                 SYSFUN_Debug_Printf("write_diffServActionSpecific:id=[%lu]\n", id);
                 print_dsoid(&dsoid);
             }
             if (!L4_DS_MGR_SetDiffServActionSpecific(id, &dsoid))
             {
                if(SNMP_MGR_IsDebugMode())
                    SYSFUN_Debug_Printf("write_diffServActionSpecific:L4_DS_MGR_SetDiffServActionSpecific return false\n");
                return SNMP_ERR_COMMITFAILED;
             }
         }
         else
         {
            if(SNMP_MGR_IsDebugMode())
                SYSFUN_Debug_Printf("write_diffServActionSpecific:L4_DS_MGR_OidToDiffServRowPointer return false\n");
         }
         break;
    }
    case UNDO:
        /*
         * Back out any changes made in the ACTION case
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_diffServActionStorage(int action,
                            u_char * var_val,
                            u_char var_val_type,
                            size_t var_val_len,
                            u_char * statP, oid * name, size_t name_len)
{
    long            value;

    switch (action) {
    case RESERVE1:
        /* check 1: check if the input index is exactly match, if not return fail*/
        if (name_len!=  diffServActionEntry_OID_NAME_LEN + diffServActionEntry_INSTANCE_LEN )
        {
            return SNMP_ERR_WRONGLENGTH;
        }
        if (var_val_type != ASN_INTEGER) {

            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {

            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        value = *(long *)var_val;
        switch(value)
        {
          case VAL_diffServActionStorage_other:
          case VAL_diffServActionStorage_volatile:
          case VAL_diffServActionStorage_nonVolatile:
          case VAL_diffServActionStorage_permanent:
          case VAL_diffServActionStorage_readOnly:
            break;
          default:
            return SNMP_ERR_WRONGVALUE;
        }
        break;

    case FREE:
        /*
         * Release any resources that have been allocated
         */
        break;

    case ACTION:
    {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        UI32_T id;
        id=name[diffServActionEntry_OID_NAME_LEN];
        value = *(long *)var_val;
        if(SNMP_MGR_IsDebugMode())
             SYSFUN_Debug_Printf("write_diffServActionStorage:id=[%lu], value=[%lu]\n", id, value);

        if (!L4_DS_MGR_SetDiffServActionStorage (id, value))
        {
            if(SNMP_MGR_IsDebugMode())
                SYSFUN_Debug_Printf("write_diffServActionStorage:L4_DS_MGR_SetDiffServActionStorage return false\n");
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    case UNDO:
        /*
         * Back out any changes made in the ACTION case
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_diffServActionStatus(int action,
                           u_char * var_val,
                           u_char var_val_type,
                           size_t var_val_len,
                           u_char * statP, oid * name, size_t name_len)
{
    long            value;

    switch (action) {
    case RESERVE1:
        /* check 1: check if the input index is exactly match, if not return fail*/
        if (name_len!=  diffServActionEntry_OID_NAME_LEN + diffServActionEntry_INSTANCE_LEN )
        {
            return SNMP_ERR_WRONGLENGTH;
        }
        if (var_val_type != ASN_INTEGER) {

            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        value = *(long *)var_val;
        switch(value)
        {
          case VAL_diffServActionStatus_active:
          case VAL_diffServActionStatus_notInService:
          case VAL_diffServActionStatus_notReady:
          case VAL_diffServActionStatus_createAndGo:
          case VAL_diffServActionStatus_createAndWait:
          case VAL_diffServActionStatus_destroy:
            break;
          default:
            return SNMP_ERR_WRONGVALUE;
        }
        break;

    case FREE:
        /*
         * Release any resources that have been allocated
         */
        break;

    case ACTION:
    {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        UI32_T id;
        id=name[diffServActionEntry_OID_NAME_LEN];
        value = *(long *)var_val;
        if(SNMP_MGR_IsDebugMode())
             SYSFUN_Debug_Printf("write_diffServActionStatus:id=[%lu], value=[%lu]\n", id, value);

        if (!L4_DS_MGR_SetDiffServActionStatus (id, value))
        {
            if(SNMP_MGR_IsDebugMode())
                SYSFUN_Debug_Printf("write_diffServActionStatus:L4_DS_MGR_SetDiffServActionStatus return false\n");
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    case UNDO:
        /*
         * Back out any changes made in the ACTION case
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

/*
 * diffServMeterTable_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */
#define diffServMeterEntry_INSTANCE_LEN 1
#define diffServMeterEntry_OID_NAME_LEN 12

oid             diffServMeterTable_variables_oid[] =
    { 1, 3, 6, 1, 2, 1, 97, 1, 3 };

/*
 * variable4 diffServMeterTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */

struct variable3 diffServMeterTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */

#define DIFFSERVMETERID		1
    {DIFFSERVMETERID, ASN_UNSIGNED, RONLY, var_diffServMeterTable, 3,
     {2, 1, 1}},
#define DIFFSERVMETERSUCCEEDNEXT		2
    {DIFFSERVMETERSUCCEEDNEXT, ASN_OBJECT_ID, RWRITE,
     var_diffServMeterTable, 3, {2, 1, 2}},
#define DIFFSERVMETERFAILNEXT		3
    {DIFFSERVMETERFAILNEXT, ASN_OBJECT_ID, RWRITE, var_diffServMeterTable,
     3, {2, 1, 3}},
#define DIFFSERVMETERSPECIFIC		4
    {DIFFSERVMETERSPECIFIC, ASN_OBJECT_ID, RWRITE, var_diffServMeterTable,
     3, {2, 1, 4}},
#define DIFFSERVMETERSTORAGE		5
    {DIFFSERVMETERSTORAGE, ASN_INTEGER, RWRITE, var_diffServMeterTable, 3,
     {2, 1, 5}},
#define DIFFSERVMETERSTATUS		6
    {DIFFSERVMETERSTATUS, ASN_INTEGER, RWRITE, var_diffServMeterTable, 3,
     {2, 1, 6}},
};
/*
 * (L = length of the oidsuffix)
 */


/** Initializes the diffServMeterTable module */
void
init_diffServMeterTable(void)
{

    /*
     * register ourselves with the agent to handle our mib tree
     */
    REGISTER_MIB("diffServMeterTable", diffServMeterTable_variables,
                 variable3, diffServMeterTable_variables_oid);

    /*
     * place any other initialization junk you need here
     */
}

static BOOL_T diffServMeterTable_get(int      compc,
                                oid     *compl,
                                L4_TYPE_diffServMeterEntry_T   *data)
{
    if (compc !=diffServMeterEntry_INSTANCE_LEN)
    {
 	    return FALSE;
    }
    data->id=compl[0];

    if(SNMP_MGR_IsDebugMode())
        SYSFUN_Debug_Printf("diffServMeterTable_get:data->id=[%lu]\n", data->id);

	if (!L4_DS_MGR_GetMeter(data->id, data))
	{
	    if(SNMP_MGR_IsDebugMode())
	        SYSFUN_Debug_Printf("diffServMeterTable_get:L4_DS_MGR_GetMeter return false\n");
		return FALSE;
	}
	else
	{
		return TRUE;
	} /*End of if */
}

static BOOL_T diffServMeterTable_next(int      compc,
                                 oid     *compl,
                                 L4_TYPE_diffServMeterEntry_T    *data)
{
  	oid tmp_compl[diffServMeterEntry_INSTANCE_LEN];

 	/* Generate the instance of each table entry and find the
	 * smallest instance that's larger than compc/compl.
	 *
	 * Step 1: Verify and extract the input key from "compc" and "compl"
	 * Note: The number of input key is defined by "compc".
	 *       The key for the specified instance is defined in compl.
	 */

	memcpy(tmp_compl, compl, sizeof(tmp_compl));
	SNMP_MGR_ConvertRemainToZero(compc,diffServMeterEntry_INSTANCE_LEN, tmp_compl);
	data->id=tmp_compl[0];

    if(SNMP_MGR_IsDebugMode())
        SYSFUN_Debug_Printf("diffServMeterTable_next:data->id=[%lu]\n", data->id);

	if (compc<diffServMeterEntry_INSTANCE_LEN)
	{
		if (!L4_DS_MGR_GetMeter(data->id, data))
        {
            if (!L4_DS_MGR_GetNextMeter(&data->id, data))
   	        {
   	            if(SNMP_MGR_IsDebugMode())
   	                SYSFUN_Debug_Printf("diffServMeterTable_next: get & genext return false\n");
   		        return FALSE;
   		    }
        }
	}
	else
	{
		if (!L4_DS_MGR_GetNextMeter(&data->id, data))
		{
		    if(SNMP_MGR_IsDebugMode())
   	            SYSFUN_Debug_Printf("diffServMeterTable_next: get return false\n");
			return FALSE;
		}
	}
	return TRUE;
}

/*
 * var_diffServMeterTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_diffServMeterTable(struct variable *vp,
                       oid * name,
                       size_t * length,
                       int exact,
                       size_t * var_len, WriteMethod ** write_method)
{
    UI32_T compc=0;
    oid compl[diffServMeterEntry_INSTANCE_LEN];
    oid best_inst[diffServMeterEntry_INSTANCE_LEN];
    L4_TYPE_diffServMeterEntry_T data;

   /*Since this table allow for entry that does not exist, (creation). we need to know the write method first*/
    switch (vp->magic)
    {
      case DIFFSERVMETERSUCCEEDNEXT:
        *write_method = write_diffServMeterSucceedNext;
        break;
      case DIFFSERVMETERFAILNEXT:
        *write_method = write_diffServMeterFailNext;
        break;
      case DIFFSERVMETERSPECIFIC:
        *write_method = write_diffServMeterSpecific;
        break;
      case DIFFSERVMETERSTORAGE:
        *write_method = write_diffServMeterStorage;
        break;
      case DIFFSERVMETERSTATUS:
        *write_method = write_diffServMeterStatus;
        break;
      default:
        *write_method =0;
         break;
    }

    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl, diffServMeterEntry_INSTANCE_LEN);

     /*check compc, retrive compl*/
    if (exact)/*get,set*/
    {
        if (!diffServMeterTable_get(compc, compl, &data))
            return NULL;
    }
    else/*getnext*/
    {
        if (!diffServMeterTable_next(compc, compl, &data))
            return NULL;
    }
    memcpy(name, vp->name, vp->namelen*sizeof(oid));
    best_inst[0]=data.id;

    memcpy(name + vp->namelen, best_inst, diffServMeterEntry_INSTANCE_LEN*sizeof(oid));
    *length = vp->namelen +diffServMeterEntry_INSTANCE_LEN;

    *var_len = sizeof(long_return);

    /*
     * * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
      case DIFFSERVMETERSUCCEEDNEXT:
      {
        SNMP_TYPE_Oid_T snmpoid;
        if(SNMP_MGR_IsDebugMode())
            print_dsoid(&data.succeed_next);
        if (L4_DS_MGR_DiffServRowPointerToOid(&data.succeed_next, &snmpoid))
        {
            *var_len = snmpoid.oid_len * sizeof(UI32_T);
            memcpy(oid_return, snmpoid.oid, *var_len);
            return (u_char *) oid_return;
        }
        else
        {
            if(SNMP_MGR_IsDebugMode())
   	            SYSFUN_Debug_Printf("var_diffServMeterTable:L4_DS_MGR_DiffServRowPointerToOid return false\n");
            return NULL;
        }
      }
      case DIFFSERVMETERFAILNEXT:
      {
        SNMP_TYPE_Oid_T snmpoid;
        if(SNMP_MGR_IsDebugMode())
            print_dsoid(&data.fail_next);
        if (L4_DS_MGR_DiffServRowPointerToOid(&data.fail_next, &snmpoid))
        {
            *var_len = snmpoid.oid_len * sizeof(UI32_T);
            memcpy(oid_return, snmpoid.oid, *var_len);
            return (u_char *) oid_return;
        }
        else
        {
            if(SNMP_MGR_IsDebugMode())
   	            SYSFUN_Debug_Printf("var_diffServMeterTable:L4_DS_MGR_DiffServRowPointerToOid return false\n");
            return NULL;
        }
      }
      case DIFFSERVMETERSPECIFIC:
      {
        SNMP_TYPE_Oid_T snmpoid;
        if(SNMP_MGR_IsDebugMode())
            print_dsoid(&data.specific);
        if (L4_DS_MGR_DiffServRowPointerToOid(&data.specific, &snmpoid))
        {
            *var_len = snmpoid.oid_len * sizeof(UI32_T);
            memcpy(oid_return, snmpoid.oid, *var_len);
            return (u_char *) oid_return;
        }
        else
        {
            if(SNMP_MGR_IsDebugMode())
   	            SYSFUN_Debug_Printf("var_diffServMeterTable:L4_DS_MGR_DiffServRowPointerToOid return false\n");
            return NULL;
        }
      }
      case DIFFSERVMETERSTORAGE:
        long_return = data.storage;
        return (u_char*) &long_return;
      case DIFFSERVMETERSTATUS:
        long_return = data.status;
        return (u_char*) &long_return;
    default:
        ERROR_MSG("");
    }
    return NULL;
}


int
write_diffServMeterSucceedNext(int action,
                               u_char * var_val,
                               u_char var_val_type,
                               size_t var_val_len,
                               u_char * statP, oid * name, size_t name_len)
{

    switch (action) {
    case RESERVE1:
        /* check 1: check if the input index is exactly match, if not return fail*/
        if (name_len!=  diffServMeterEntry_OID_NAME_LEN + diffServMeterEntry_INSTANCE_LEN )
        {
            return SNMP_ERR_WRONGLENGTH;
        }
        if (var_val_type != ASN_OBJECT_ID) {

            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > (SYS_ADPT_MAX_OID_COUNT * sizeof(UI32_T))) {
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        break;
    case FREE:
        /*
         * Release any resources that have been allocated
         */
        break;
    case ACTION:
     {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
         SNMP_TYPE_Oid_T snmpoid;
         L4_DS_TYPE_Oid_T dsoid;
         UI32_T id;
         id=name[diffServMeterEntry_OID_NAME_LEN];
         memcpy(snmpoid.oid, var_val, var_val_len);
         snmpoid.oid_len=var_val_len;
         if(SNMP_MGR_IsDebugMode())
            print_snmpoid(&snmpoid);
         if (L4_DS_MGR_OidToDiffServRowPointer(&snmpoid, &dsoid))
         {
             if(SNMP_MGR_IsDebugMode())
             {
                 SYSFUN_Debug_Printf("write_diffServMeterSucceedNext:id=[%lu]\n", id);
                 print_dsoid(&dsoid);
             }
             if (!L4_DS_MGR_SetDiffServMeterSucceedNext(id, &dsoid))
             {
                if(SNMP_MGR_IsDebugMode())
                    SYSFUN_Debug_Printf("write_diffServMeterSucceedNext:L4_DS_MGR_SetDiffServMeterSucceedNext return false\n");
                return SNMP_ERR_COMMITFAILED;
             }
         }
         else
         {
            if(SNMP_MGR_IsDebugMode())
                SYSFUN_Debug_Printf("write_diffServMeterSucceedNext:L4_DS_MGR_OidToDiffServRowPointer return false\n");
         }
         break;
    }
    case UNDO:
        /*
         * Back out any changes made in the ACTION case
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_diffServMeterFailNext(int action,
                            u_char * var_val,
                            u_char var_val_type,
                            size_t var_val_len,
                            u_char * statP, oid * name, size_t name_len)
{

    switch (action) {
    case RESERVE1:
        /* check 1: check if the input index is exactly match, if not return fail*/
        if (name_len!=  diffServMeterEntry_OID_NAME_LEN + diffServMeterEntry_INSTANCE_LEN )
        {
            return SNMP_ERR_WRONGLENGTH;
        }
        if (var_val_type != ASN_OBJECT_ID) {

            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > (SYS_ADPT_MAX_OID_COUNT * sizeof(UI32_T))) {
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        break;

    case FREE:
        /*
         * Release any resources that have been allocated
         */
        break;

    case ACTION:
  {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
         SNMP_TYPE_Oid_T snmpoid;
         L4_DS_TYPE_Oid_T dsoid;
         UI32_T id;
         id=name[diffServMeterEntry_OID_NAME_LEN];
         memcpy(snmpoid.oid, var_val, var_val_len);
         snmpoid.oid_len=var_val_len;
         if(SNMP_MGR_IsDebugMode())
            print_snmpoid(&snmpoid);
         if (L4_DS_MGR_OidToDiffServRowPointer(&snmpoid, &dsoid))
         {
             if(SNMP_MGR_IsDebugMode())
             {
                 SYSFUN_Debug_Printf("write_diffServMeterFailNext:id=[%lu]\n", id);
                 print_dsoid(&dsoid);
             }
             if (!L4_DS_MGR_SetDiffServMeterFailNext(id, &dsoid))
             {
                if(SNMP_MGR_IsDebugMode())
                    SYSFUN_Debug_Printf("write_diffServMeterFailNext:L4_DS_MGR_SetDiffServMeterFailNext return false\n");
                return SNMP_ERR_COMMITFAILED;
             }
         }
         else
         {
            if(SNMP_MGR_IsDebugMode())
                SYSFUN_Debug_Printf("write_diffServMeterFailNext:L4_DS_MGR_OidToDiffServRowPointer return false\n");
         }
         break;
    }

    case UNDO:
        /*
         * Back out any changes made in the ACTION case
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_diffServMeterSpecific(int action,
                            u_char * var_val,
                            u_char var_val_type,
                            size_t var_val_len,
                            u_char * statP, oid * name, size_t name_len)
{


    switch (action) {
    case RESERVE1:
        /* check 1: check if the input index is exactly match, if not return fail*/
        if (name_len!=  diffServMeterEntry_OID_NAME_LEN + diffServMeterEntry_INSTANCE_LEN )
        {
            return SNMP_ERR_WRONGLENGTH;
        }
        if (var_val_type != ASN_OBJECT_ID) {

            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > (SYS_ADPT_MAX_OID_COUNT * sizeof(UI32_T))) {
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        break;

    case FREE:
        /*
         * Release any resources that have been allocated
         */
        break;

    case ACTION:
    {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
         SNMP_TYPE_Oid_T snmpoid;
         L4_DS_TYPE_Oid_T dsoid;
         UI32_T id;
         id=name[diffServMeterEntry_OID_NAME_LEN];
         memcpy(snmpoid.oid, var_val, var_val_len);
         snmpoid.oid_len=var_val_len;
         if(SNMP_MGR_IsDebugMode())
            print_snmpoid(&snmpoid);
         if (L4_DS_MGR_OidToDiffServRowPointer(&snmpoid, &dsoid))
         {
             if(SNMP_MGR_IsDebugMode())
             {
                 SYSFUN_Debug_Printf("write_diffServMeterSpecific:id=[%lu]\n", id);
                 print_dsoid(&dsoid);
             }
             if (!L4_DS_MGR_SetDiffServMeterSpecific(id, &dsoid))
             {
                if(SNMP_MGR_IsDebugMode())
                    SYSFUN_Debug_Printf("write_diffServMeterSpecific:L4_DS_MGR_SetDiffServMeterSpecific return false\n");
                return SNMP_ERR_COMMITFAILED;
             }
         }
         else
         {
            if(SNMP_MGR_IsDebugMode())
                SYSFUN_Debug_Printf("write_diffServMeterSpecific:L4_DS_MGR_OidToDiffServRowPointer return false\n");
         }
         break;
    }

    case UNDO:
        /*
         * Back out any changes made in the ACTION case
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_diffServMeterStorage(int action,
                           u_char * var_val,
                           u_char var_val_type,
                           size_t var_val_len,
                           u_char * statP, oid * name, size_t name_len)
{
    long            value;

    switch (action) {
    case RESERVE1:
        /* check 1: check if the input index is exactly match, if not return fail*/
        if (name_len!=  diffServMeterEntry_OID_NAME_LEN + diffServMeterEntry_INSTANCE_LEN )
        {
            return SNMP_ERR_WRONGLENGTH;
        }
        if (var_val_type != ASN_INTEGER) {

            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        value = *(long *)var_val;
        switch(value)
        {
          case VAL_diffServMeterStorage_other:
          case VAL_diffServMeterStorage_volatile:
          case VAL_diffServMeterStorage_nonVolatile:
          case VAL_diffServMeterStorage_permanent:
          case VAL_diffServMeterStorage_readOnly:
            break;
          default:
            return SNMP_ERR_WRONGVALUE;
        }
        break;

    case FREE:
        /*
         * Release any resources that have been allocated
         */
        break;

    case ACTION:
     {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        UI32_T id;
        id=name[diffServMeterEntry_OID_NAME_LEN];
        value = *(long *)var_val;
        if(SNMP_MGR_IsDebugMode())
             SYSFUN_Debug_Printf("write_diffServMeterStorage:id=[%lu], value=[%lu]\n", id, value);

        if (!L4_DS_MGR_SetDiffServMeterStorage(id, value))
        {
            if(SNMP_MGR_IsDebugMode())
                SYSFUN_Debug_Printf("write_diffServMeterStorage:L4_DS_MGR_SetDiffServMeterStorage return false\n");
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }

    case UNDO:
        /*
         * Back out any changes made in the ACTION case
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_diffServMeterStatus(int action,
                          u_char * var_val,
                          u_char var_val_type,
                          size_t var_val_len,
                          u_char * statP, oid * name, size_t name_len)
{
    long            value;

    switch (action) {
    case RESERVE1:
        /* check 1: check if the input index is exactly match, if not return fail*/
        if (name_len!=  diffServMeterEntry_OID_NAME_LEN + diffServMeterEntry_INSTANCE_LEN )
        {
            return SNMP_ERR_WRONGLENGTH;
        }
        if (var_val_type != ASN_INTEGER) {

            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        value = *(long *)var_val;
        switch(value)
        {
          case VAL_diffServMeterStatus_active:
          case VAL_diffServMeterStatus_notInService:
          case VAL_diffServMeterStatus_notReady:
          case VAL_diffServMeterStatus_createAndGo:
          case VAL_diffServMeterStatus_createAndWait:
          case VAL_diffServMeterStatus_destroy:
            break;
          default:
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    case FREE:
        /*
         * Release any resources that have been allocated
         */
        break;

    case ACTION:
    {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        UI32_T id;
        id=name[diffServMeterEntry_OID_NAME_LEN];
        value = *(long *)var_val;
        if(SNMP_MGR_IsDebugMode())
             SYSFUN_Debug_Printf("write_diffServMeterStatus:id=[%lu], value=[%lu]\n", id, value);

        if (!L4_DS_MGR_SetDiffServMeterStatus(id, value))
        {
            if(SNMP_MGR_IsDebugMode())
                SYSFUN_Debug_Printf("write_diffServMeterStatus:L4_DS_MGR_SetDiffServMeterStorage return false\n");
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    case UNDO:
        /*
         * Back out any changes made in the ACTION case
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

/*
 * diffServTBParamTable_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */
#define diffServTBParamEntry_INSTANCE_LEN 1
#define diffServTBParamEntry_OID_NAME_LEN 12

oid             diffServTBParamTable_variables_oid[] =
    { 1, 3, 6, 1, 2, 1, 97, 1, 4 };

/*
 * variable4 diffServTBParamTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */

struct variable3 diffServTBParamTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */

#define DIFFSERVTBPARAMID		1
    {DIFFSERVTBPARAMID, ASN_UNSIGNED, RONLY, var_diffServTBParamTable, 3,
     {2, 1, 1}},
#define DIFFSERVTBPARAMTYPE		2
    {DIFFSERVTBPARAMTYPE, ASN_OBJECT_ID, RWRITE, var_diffServTBParamTable,
     3, {2, 1, 2}},
#define DIFFSERVTBPARAMRATE		3
    {DIFFSERVTBPARAMRATE, ASN_UNSIGNED, RWRITE, var_diffServTBParamTable,
     3, {2, 1, 3}},
#define DIFFSERVTBPARAMBURSTSIZE		4
    {DIFFSERVTBPARAMBURSTSIZE, ASN_INTEGER, RWRITE,
     var_diffServTBParamTable, 3, {2, 1, 4}},
#define DIFFSERVTBPARAMINTERVAL		5
    {DIFFSERVTBPARAMINTERVAL, ASN_UNSIGNED, RWRITE,
     var_diffServTBParamTable, 3, {2, 1, 5}},
#define DIFFSERVTBPARAMSTORAGE		6
    {DIFFSERVTBPARAMSTORAGE, ASN_INTEGER, RWRITE, var_diffServTBParamTable,
     3, {2, 1, 6}},
#define DIFFSERVTBPARAMSTATUS		7
    {DIFFSERVTBPARAMSTATUS, ASN_INTEGER, RWRITE, var_diffServTBParamTable,
     3, {2, 1, 7}},
};
/*
 * (L = length of the oidsuffix)
 */


/** Initializes the diffServTBParamTable module */
void
init_diffServTBParamTable(void)
{
    /*
     * register ourselves with the agent to handle our mib tree
     */
    REGISTER_MIB("diffServTBParamTable", diffServTBParamTable_variables,
                 variable3, diffServTBParamTable_variables_oid);

    /*
     * place any other initialization junk you need here
     */
}

static BOOL_T diffServTBParamTable_get(int      compc,
                                oid     *compl,
                                L4_TYPE_diffServTBParamEntry_T   *data)
{
    if (compc !=diffServTBParamEntry_INSTANCE_LEN)
    {
 	    return FALSE;
    }
    data->id=compl[0];

    if(SNMP_MGR_IsDebugMode())
        SYSFUN_Debug_Printf("diffServTBParamTable_get:data->id=[%lu]\n", data->id);

	if (!L4_DS_MGR_GetTBParam(data->id, data))
	{
	    if(SNMP_MGR_IsDebugMode())
	        SYSFUN_Debug_Printf("diffServTBParamTable_get:L4_DS_MGR_GetTBParam return false\n");
		return FALSE;
	}
	else
	{
		return TRUE;
	} /*End of if */
}

static BOOL_T diffServTBParamTable_next(int      compc,
                                 oid     *compl,
                                 L4_TYPE_diffServTBParamEntry_T    *data)
{
  	oid tmp_compl[diffServTBParamEntry_INSTANCE_LEN];

 	/* Generate the instance of each table entry and find the
	 * smallest instance that's larger than compc/compl.
	 *
	 * Step 1: Verify and extract the input key from "compc" and "compl"
	 * Note: The number of input key is defined by "compc".
	 *       The key for the specified instance is defined in compl.
	 */

	memcpy(tmp_compl, compl, sizeof(tmp_compl));
	SNMP_MGR_ConvertRemainToZero(compc,diffServTBParamEntry_INSTANCE_LEN, tmp_compl);
	data->id=tmp_compl[0];

	if(SNMP_MGR_IsDebugMode())
        SYSFUN_Debug_Printf("diffServTBParamTable_next:data->id=[%lu]\n", data->id);

	if (compc<diffServTBParamEntry_INSTANCE_LEN)
	{
		if (!L4_DS_MGR_GetTBParam(data->id, data))
        {
            if (!L4_DS_MGR_GetNextTBParam(&data->id, data))
   	        {
   	            if(SNMP_MGR_IsDebugMode())
   	                SYSFUN_Debug_Printf("diffServTBParamTable_next get & genext return false\n");
   		        return FALSE;
   		    }
        }
	}
	else
	{
		if (!L4_DS_MGR_GetNextTBParam(&data->id, data))
		{
		    if(SNMP_MGR_IsDebugMode())
   	            SYSFUN_Debug_Printf("diffServTBParamTable_next: get return false\n");
			return FALSE;
		}
	}
	return TRUE;
}



/*
 * var_diffServTBParamTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_diffServTBParamTable(struct variable *vp,
                         oid * name,
                         size_t * length,
                         int exact,
                         size_t * var_len, WriteMethod ** write_method)
{
    UI32_T compc=0;
    oid compl[diffServTBParamEntry_INSTANCE_LEN];
    oid best_inst[diffServTBParamEntry_INSTANCE_LEN];
    L4_TYPE_diffServTBParamEntry_T data;

   /*Since this table allow for entry that does not exist, (creation). we need to know the write method first*/
    switch (vp->magic)
    {
      case DIFFSERVTBPARAMTYPE:
        *write_method = write_diffServTBParamType;
        break;
      case DIFFSERVTBPARAMRATE:
        *write_method = write_diffServTBParamRate;
        break;
      case DIFFSERVTBPARAMBURSTSIZE:
        *write_method = write_diffServTBParamBurstSize;
        break;
      case DIFFSERVTBPARAMINTERVAL:
        *write_method = write_diffServTBParamInterval;
        break;
      case DIFFSERVTBPARAMSTORAGE:
        *write_method = write_diffServTBParamStorage;
        break;
      case DIFFSERVTBPARAMSTATUS:
        *write_method = write_diffServTBParamStatus;
        break;
      default:
        *write_method =0;
         break;
    }

    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl, diffServTBParamEntry_INSTANCE_LEN);

     /*check compc, retrive compl*/
    if (exact)/*get,set*/
    {
        if (!diffServTBParamTable_get(compc, compl, &data))
            return NULL;
    }
    else/*getnext*/
    {
        if (!diffServTBParamTable_next(compc, compl, &data))
            return NULL;
    }
    memcpy(name, vp->name, vp->namelen*sizeof(oid));
    best_inst[0]=data.id;

    memcpy(name + vp->namelen, best_inst, diffServTBParamEntry_INSTANCE_LEN*sizeof(oid));
    *length = vp->namelen +diffServTBParamEntry_INSTANCE_LEN;

    *var_len = sizeof(long_return);
    /*
     * * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
      case DIFFSERVTBPARAMTYPE:
        *var_len = data.type.oid_len * sizeof(UI32_T);
        memcpy(oid_return, data.type.oid, *var_len);
        return (u_char *) oid_return;
      case DIFFSERVTBPARAMRATE:
        long_return = data.rate;
        return (u_char*) &long_return;
      case DIFFSERVTBPARAMBURSTSIZE:
        long_return = data.burst_size;
        return (u_char*) &long_return;
      case DIFFSERVTBPARAMINTERVAL:
        long_return = data.interval;
        return (u_char*) &long_return;
      case DIFFSERVTBPARAMSTORAGE:
        long_return = data.storage;
        return (u_char*) &long_return;
      case DIFFSERVTBPARAMSTATUS:
        long_return = data.status;
        return (u_char*) &long_return;
    default:
        ERROR_MSG("");
    }
    return NULL;
}


int
write_diffServTBParamType(int action,
                          u_char * var_val,
                          u_char var_val_type,
                          size_t var_val_len,
                          u_char * statP, oid * name, size_t name_len)
{

    switch (action) {
    case RESERVE1:
        /* check 1: check if the input index is exactly match, if not return fail*/
        if (name_len!=  diffServTBParamEntry_OID_NAME_LEN + diffServTBParamEntry_INSTANCE_LEN )
        {
            return SNMP_ERR_WRONGLENGTH;
        }
        if (var_val_type != ASN_OBJECT_ID) {

            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > (SYS_ADPT_MAX_OID_COUNT * sizeof(UI32_T))) {

            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        break;
    case FREE:
        /*
         * Release any resources that have been allocated
         */
        break;

    case ACTION:
    {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
         SNMP_TYPE_Oid_T snmpoid;
         UI32_T id;
         id=name[diffServTBParamEntry_INSTANCE_LEN];
         memcpy(snmpoid.oid, var_val, var_val_len);
         snmpoid.oid_len=var_val_len;
         if (!L4_DS_MGR_SetDiffServTBParamType(id, &snmpoid))
         {
            if(SNMP_MGR_IsDebugMode())
                SYSFUN_Debug_Printf("write_diffServTBParamType:L4_DS_MGR_SetDiffServTBParamType return false\n");
            return SNMP_ERR_COMMITFAILED;
         }
         break;
    }
    case UNDO:
        /*
         * Back out any changes made in the ACTION case
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_diffServTBParamRate(int action,
                          u_char * var_val,
                          u_char var_val_type,
                          size_t var_val_len,
                          u_char * statP, oid * name, size_t name_len)
{
    u_long          value;

    switch (action) {
    case RESERVE1:
        /* check 1: check if the input index is exactly match, if not return fail*/
        if (name_len!=  diffServTBParamEntry_OID_NAME_LEN + diffServTBParamEntry_INSTANCE_LEN )
        {
            return SNMP_ERR_WRONGLENGTH;
        }
        if (var_val_type != ASN_UNSIGNED) {

            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(u_long)) {
            return SNMP_ERR_WRONGLENGTH;
        }
        break;
    case RESERVE2:
        break;
    case FREE:
        /*
         * Release any resources that have been allocated
         */
        break;

    case ACTION:
    {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        UI32_T id;
        id=name[diffServTBParamEntry_OID_NAME_LEN];
        value = *(u_long *)var_val;
        if(SNMP_MGR_IsDebugMode())
             SYSFUN_Debug_Printf("write_diffServTBParamRate:id=[%lu], value=[%lu]\n", id, value);

        if (!L4_DS_MGR_SetDiffServTBParamRate(id, value))
        {
            if(SNMP_MGR_IsDebugMode())
                SYSFUN_Debug_Printf("write_diffServTBParamRate:L4_DS_MGR_SetDiffServTBParamRate return false\n");
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    case UNDO:
        /*
         * Back out any changes made in the ACTION case
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_diffServTBParamBurstSize(int action,
                               u_char * var_val,
                               u_char var_val_type,
                               size_t var_val_len,
                               u_char * statP, oid * name, size_t name_len)
{
    long            value;

    switch (action) {
    case RESERVE1:
        /* check 1: check if the input index is exactly match, if not return fail*/
        if (name_len!=  diffServTBParamEntry_OID_NAME_LEN + diffServTBParamEntry_INSTANCE_LEN )
        {
            return SNMP_ERR_WRONGLENGTH;
        }
        if (var_val_type != ASN_INTEGER) {

            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        value = *(long *)var_val;
        if (!((value >= MIN_diffServTBParamBurstSize) &&
              (value <= MAX_diffServTBParamBurstSize)))
            return SNMP_ERR_WRONGVALUE;
        break;
    case FREE:
        /*
         * Release any resources that have been allocated
         */
        break;

    case ACTION:
    {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        UI32_T id;
        id=name[diffServTBParamEntry_OID_NAME_LEN];
        value = *(long *)var_val;
        if(SNMP_MGR_IsDebugMode())
             SYSFUN_Debug_Printf("write_diffServTBParamBurstSize:id=[%lu], value=[%lu]\n", id, value);

        if (!L4_DS_MGR_SetDiffServTBParamBurstSize(id, value))
        {
            if(SNMP_MGR_IsDebugMode())
                SYSFUN_Debug_Printf("write_diffServTBParamBurstSize:L4_DS_MGR_SetDiffServTBParamBurstSize return false\n");
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    case UNDO:
        /*
         * Back out any changes made in the ACTION case
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_diffServTBParamInterval(int action,
                              u_char * var_val,
                              u_char var_val_type,
                              size_t var_val_len,
                              u_char * statP, oid * name, size_t name_len)
{
    u_long          value;

    switch (action) {
    case RESERVE1:
        /* check 1: check if the input index is exactly match, if not return fail*/
        if (name_len!=  diffServTBParamEntry_OID_NAME_LEN + diffServTBParamEntry_INSTANCE_LEN )
        {
            return SNMP_ERR_WRONGLENGTH;
        }
        if (var_val_type != ASN_UNSIGNED) {

            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(u_long)) {
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        break;
    case FREE:
        /*
         * Release any resources that have been allocated
         */
        break;

    case ACTION:
    {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        UI32_T id;
        id=name[diffServTBParamEntry_OID_NAME_LEN];
        value = *(u_long *)var_val;
        if(SNMP_MGR_IsDebugMode())
             SYSFUN_Debug_Printf("write_diffServTBParamInterval:id=[%lu], value=[%lu]\n", id, value);

        if (!L4_DS_MGR_SetDiffServTBParamInterval(id, value))
        {
            if(SNMP_MGR_IsDebugMode())
                SYSFUN_Debug_Printf("write_diffServTBParamInterval:L4_DS_MGR_SetDiffServTBParamInterval return false\n");
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    case UNDO:
        /*
         * Back out any changes made in the ACTION case
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_diffServTBParamStorage(int action,
                             u_char * var_val,
                             u_char var_val_type,
                             size_t var_val_len,
                             u_char * statP, oid * name, size_t name_len)
{
    long            value;

    switch (action) {
    case RESERVE1:
        /* check 1: check if the input index is exactly match, if not return fail*/
        if (name_len!=  diffServTBParamEntry_OID_NAME_LEN + diffServTBParamEntry_INSTANCE_LEN )
        {
            return SNMP_ERR_WRONGLENGTH;
        }
        if (var_val_type != ASN_INTEGER) {

            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        value = *(long *)var_val;
        switch(value)
        {
          case VAL_diffServTBParamStorage_other:
          case VAL_diffServTBParamStorage_volatile:
          case VAL_diffServTBParamStorage_nonVolatile:
          case VAL_diffServTBParamStorage_permanent:
          case VAL_diffServTBParamStorage_readOnly:
            break;
          default:
            return SNMP_ERR_WRONGVALUE;
        }

        break;

    case FREE:
        /*
         * Release any resources that have been allocated
         */
        break;

    case ACTION:
    {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        UI32_T id;
        id=name[diffServTBParamEntry_OID_NAME_LEN];
        value = *(long *)var_val;
        if(SNMP_MGR_IsDebugMode())
             SYSFUN_Debug_Printf("write_diffServTBParamStorage:id=[%lu], value=[%lu]\n", id, value);

        if (!L4_DS_MGR_SetDiffServTBParamStorage(id, value))
        {
            if(SNMP_MGR_IsDebugMode())
                SYSFUN_Debug_Printf("write_diffServTBParamStorage:L4_DS_MGR_SetDiffServTBParamStorage return false\n");
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    case UNDO:
        /*
         * Back out any changes made in the ACTION case
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_diffServTBParamStatus(int action,
                            u_char * var_val,
                            u_char var_val_type,
                            size_t var_val_len,
                            u_char * statP, oid * name, size_t name_len)
{
    long            value;

    switch (action) {
    case RESERVE1:
        /* check 1: check if the input index is exactly match, if not return fail*/
        if (name_len!=  diffServTBParamEntry_OID_NAME_LEN + diffServTBParamEntry_INSTANCE_LEN )
        {
            return SNMP_ERR_WRONGLENGTH;
        }
        if (var_val_type != ASN_INTEGER) {

            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        value = *(long *)var_val;
        switch(value)
        {
          case VAL_diffServTBParamStatus_active:
          case VAL_diffServTBParamStatus_notInService:
          case VAL_diffServTBParamStatus_notReady:
          case VAL_diffServTBParamStatus_createAndGo:
          case VAL_diffServTBParamStatus_createAndWait:
          case VAL_diffServTBParamStatus_destroy:
            break;
          default:
            return SNMP_ERR_WRONGVALUE;
        }

        break;

    case FREE:
        /*
         * Release any resources that have been allocated
         */
        break;

    case ACTION:
     {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        UI32_T id;
        id=name[diffServTBParamEntry_OID_NAME_LEN];
        value = *(long *)var_val;
        if(SNMP_MGR_IsDebugMode())
             SYSFUN_Debug_Printf("write_diffServTBParamStatus:id=[%lu], value=[%lu]\n", id, value);

        if (!L4_DS_MGR_SetDiffServTBParamStatus(id, value))
        {
            if(SNMP_MGR_IsDebugMode())
                SYSFUN_Debug_Printf("write_diffServTBParamStatus:L4_DS_MGR_SetDiffServTBParamStatus return false\n");
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    case UNDO:
        /*
         * Back out any changes made in the ACTION case
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}


/*
 * diffServDscpMarkActTable_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */
#define diffServDscpMarkActEntry_INSTANCE_LEN 1

oid             diffServDscpMarkActTable_variables_oid[] =
    { 1, 3, 6, 1, 2, 1, 97, 1, 5 };

/*
 * variable4 diffServDscpMarkActTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */

struct variable3 diffServDscpMarkActTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */

#define DIFFSERVDSCPMARKACTDSCP		1
    {DIFFSERVDSCPMARKACTDSCP, ASN_INTEGER, RONLY,
     var_diffServDscpMarkActTable, 3, {3, 1, 1}},
};
/*
 * (L = length of the oidsuffix)
 */


/** Initializes the diffServDscpMarkActTable module */
void
init_diffServDscpMarkActTable(void)
{
    /*
     * register ourselves with the agent to handle our mib tree
     */
    REGISTER_MIB("diffServDscpMarkActTable",
                 diffServDscpMarkActTable_variables, variable3,
                 diffServDscpMarkActTable_variables_oid);

    /*
     * place any other initialization junk you need here
     */
}

static BOOL_T diffServDscpMarkActTable_get(int      compc,
                                oid     *compl,
                                UI32_T   *data)
{
    if (compc !=diffServDscpMarkActEntry_INSTANCE_LEN)
    {
 	    return FALSE;
    }
    *data=compl[0];

    if(SNMP_MGR_IsDebugMode())
        SYSFUN_Debug_Printf("diffServDscpMarkActTable_get:data=[%lu]\n", *data);

	if (!L4_DS_MGR_GetDiffServDscpMarkActDscp(data))
	{
	    if(SNMP_MGR_IsDebugMode())
	        SYSFUN_Debug_Printf("diffServDscpMarkActTable_get:L4_DS_MGR_GetDiffServDscpMarkActDscp return false\n");
		return FALSE;
	}
	else
	{
		return TRUE;
	} /*End of if */
}

static BOOL_T diffServDscpMarkActTable_next(int      compc,
                                 oid     *compl,
                                 UI32_T    *data)
{
  	oid tmp_compl[diffServDscpMarkActEntry_INSTANCE_LEN];

 	/* Generate the instance of each table entry and find the
	 * smallest instance that's larger than compc/compl.
	 *
	 * Step 1: Verify and extract the input key from "compc" and "compl"
	 * Note: The number of input key is defined by "compc".
	 *       The key for the specified instance is defined in compl.
	 */

	memcpy(tmp_compl, compl, sizeof(tmp_compl));
	SNMP_MGR_checkCompl(0, 0, tmp_compl,MAX_diffServDscpMarkActDscp);
	SNMP_MGR_ConvertRemainToZero(compc,diffServDscpMarkActEntry_INSTANCE_LEN, tmp_compl);
	*data=tmp_compl[0];

    if(SNMP_MGR_IsDebugMode())
        SYSFUN_Debug_Printf("diffServDscpMarkActTable_next:data=[%lu]\n", *data);

	if (compc<diffServDscpMarkActEntry_INSTANCE_LEN)
	{
		if (!L4_DS_MGR_GetDiffServDscpMarkActDscp(data))
        {
            if (!L4_DS_MGR_GetNextDiffServDscpMarkActDscp(data))
   	        {
   	            if(SNMP_MGR_IsDebugMode())
   	                SYSFUN_Debug_Printf("diffServDscpMarkActTable_next: get & genext return false\n");
   		        return FALSE;
   		    }
        }
	}
	else
	{
		if (!L4_DS_MGR_GetNextDiffServDscpMarkActDscp(data))
		{
		    if(SNMP_MGR_IsDebugMode())
   	            SYSFUN_Debug_Printf("diffServDscpMarkActTable_next: get return false\n");
			return FALSE;
		}
	}
	return TRUE;
}

/*
 * var_diffServDscpMarkActTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_diffServDscpMarkActTable(struct variable *vp,
                             oid * name,
                             size_t * length,
                             int exact,
                             size_t * var_len, WriteMethod ** write_method)
{
    UI32_T compc=0;
    oid compl[diffServDscpMarkActEntry_INSTANCE_LEN];
    oid best_inst[diffServDscpMarkActEntry_INSTANCE_LEN];
    UI32_T    data;


    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl, diffServDscpMarkActEntry_INSTANCE_LEN);

     /*check compc, retrive compl*/
    if (exact)/*get,set*/
    {
        if (!diffServDscpMarkActTable_get(compc, compl, &data))
            return NULL;
    }
    else/*getnext*/
    {
        if (!diffServDscpMarkActTable_next(compc, compl, &data))
            return NULL;
    }
    memcpy(name, vp->name, vp->namelen*sizeof(oid));
    best_inst[0]=data;

    memcpy(name + vp->namelen, best_inst, diffServDscpMarkActEntry_INSTANCE_LEN*sizeof(oid));
    *length = vp->namelen +diffServDscpMarkActEntry_INSTANCE_LEN;

    *var_len = sizeof(long_return);


    /*
     * * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
      case DIFFSERVDSCPMARKACTDSCP:
        long_return = data;
        return (u_char*) &long_return;
    default:
        ERROR_MSG("");
    }
    return NULL;
}

/*
 * diffServAlgDropTable_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */
#define diffServAlgDropEntry_INSTANCE_LEN 1
#define diffServAlgDropEntry_OID_NAME_LEN 12

oid             diffServAlgDropTable_variables_oid[] =
    { 1, 3, 6, 1, 2, 1, 97, 1, 6 };

/*
 * variable4 diffServAlgDropTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */

struct variable3 diffServAlgDropTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */

#define DIFFSERVALGDROPID		1
    {DIFFSERVALGDROPID, ASN_UNSIGNED, RONLY, var_diffServAlgDropTable, 3,
     {2, 1, 1}},
#define DIFFSERVALGDROPTYPE		2
    {DIFFSERVALGDROPTYPE, ASN_INTEGER, RWRITE, var_diffServAlgDropTable, 3,
     {2, 1, 2}},
#define DIFFSERVALGDROPNEXT		3
    {DIFFSERVALGDROPNEXT, ASN_OBJECT_ID, RWRITE, var_diffServAlgDropTable,
     3, {2, 1, 3}},
#define DIFFSERVALGDROPQMEASURE		4
    {DIFFSERVALGDROPQMEASURE, ASN_OBJECT_ID, RWRITE,
     var_diffServAlgDropTable, 3, {2, 1, 4}},
#define DIFFSERVALGDROPQTHRESHOLD		5
    {DIFFSERVALGDROPQTHRESHOLD, ASN_UNSIGNED, RWRITE,
     var_diffServAlgDropTable, 3, {2, 1, 5}},
#define DIFFSERVALGDROPSPECIFIC		6
    {DIFFSERVALGDROPSPECIFIC, ASN_OBJECT_ID, RWRITE,
     var_diffServAlgDropTable, 3, {2, 1, 6}},
#define DIFFSERVALGDROPOCTETS		7
    {DIFFSERVALGDROPOCTETS, ASN_COUNTER64, RONLY, var_diffServAlgDropTable,
     3, {2, 1, 7}},
#define DIFFSERVALGDROPPKTS		8
    {DIFFSERVALGDROPPKTS, ASN_COUNTER64, RONLY, var_diffServAlgDropTable,
     3, {2, 1, 8}},
#define DIFFSERVALGRANDOMDROPOCTETS		9
    {DIFFSERVALGRANDOMDROPOCTETS, ASN_COUNTER64, RONLY,
     var_diffServAlgDropTable, 3, {2, 1, 9}},
#define DIFFSERVALGRANDOMDROPPKTS		10
    {DIFFSERVALGRANDOMDROPPKTS, ASN_COUNTER64, RONLY,
     var_diffServAlgDropTable, 3, {2, 1, 10}},
#define DIFFSERVALGDROPSTORAGE		11
    {DIFFSERVALGDROPSTORAGE, ASN_INTEGER, RWRITE, var_diffServAlgDropTable,
     3, {2, 1, 11}},
#define DIFFSERVALGDROPSTATUS		12
    {DIFFSERVALGDROPSTATUS, ASN_INTEGER, RWRITE, var_diffServAlgDropTable,
     3, {2, 1, 12}},
};
/*
 * (L = length of the oidsuffix)
 */


/** Initializes the diffServAlgDropTable module */
void
init_diffServAlgDropTable(void)
{

    /*
     * register ourselves with the agent to handle our mib tree
     */
    REGISTER_MIB("diffServAlgDropTable", diffServAlgDropTable_variables,
                 variable3, diffServAlgDropTable_variables_oid);

    /*
     * place any other initialization junk you need here
     */
}

static BOOL_T diffServAlgDropTable_get(int      compc,
                                oid     *compl,
                                L4_TYPE_diffServAlgDropEntry_T   *data)
{
    if (compc !=diffServAlgDropEntry_INSTANCE_LEN)
    {
 	    return FALSE;
    }
    data->id=compl[0];

    if(SNMP_MGR_IsDebugMode())
        SYSFUN_Debug_Printf("diffServAlgDropTable_get:data->id=[%lu]\n", data->id);

	if (!L4_DS_MGR_GetAlgDrop(data->id, data))
	{
	    if(SNMP_MGR_IsDebugMode())
	        SYSFUN_Debug_Printf("diffServAlgDropTable_get:L4_DS_MGR_GetAlgDrop return false\n");
		return FALSE;
	}
	else
	{
		return TRUE;
	} /*End of if */
}

static BOOL_T diffServAlgDropTable_next(int      compc,
                                 oid     *compl,
                                 L4_TYPE_diffServAlgDropEntry_T    *data)
{
  	oid tmp_compl[diffServAlgDropEntry_INSTANCE_LEN];

 	/* Generate the instance of each table entry and find the
	 * smallest instance that's larger than compc/compl.
	 *
	 * Step 1: Verify and extract the input key from "compc" and "compl"
	 * Note: The number of input key is defined by "compc".
	 *       The key for the specified instance is defined in compl.
	 */

	memcpy(tmp_compl, compl, sizeof(tmp_compl));
	SNMP_MGR_ConvertRemainToZero(compc,diffServAlgDropEntry_INSTANCE_LEN, tmp_compl);
	data->id=tmp_compl[0];

    if(SNMP_MGR_IsDebugMode())
        SYSFUN_Debug_Printf("diffServAlgDropTable_next:data->id=[%lu]\n", data->id);

	if (compc<diffServAlgDropEntry_INSTANCE_LEN)
	{
		if (!L4_DS_MGR_GetAlgDrop(data->id, data))
        {
            if (!L4_DS_MGR_GetNextAlgDrop(&data->id, data))
   	        {
   	            if(SNMP_MGR_IsDebugMode())
   	                SYSFUN_Debug_Printf("diffServAlgDropTable_next: get & genext return false\n");
   		        return FALSE;
   		    }
        }
	}
	else
	{
		if (!L4_DS_MGR_GetNextAlgDrop(&data->id, data))
		{
		    if(SNMP_MGR_IsDebugMode())
   	            SYSFUN_Debug_Printf("diffServAlgDropTable_next: get return false\n");
			return FALSE;
		}
	}
	return TRUE;
}


/*
 * var_diffServAlgDropTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_diffServAlgDropTable(struct variable *vp,
                         oid * name,
                         size_t * length,
                         int exact,
                         size_t * var_len, WriteMethod ** write_method)
{
    UI32_T compc=0;
    oid compl[diffServAlgDropEntry_INSTANCE_LEN];
    oid best_inst[diffServAlgDropEntry_INSTANCE_LEN];
    L4_TYPE_diffServAlgDropEntry_T data;

   /*Since this table allow for entry that does not exist, (creation). we need to know the write method first*/
    switch (vp->magic)
    {
      case DIFFSERVALGDROPTYPE:
        *write_method = write_diffServAlgDropType;
        break;
      case DIFFSERVALGDROPNEXT:
        *write_method = write_diffServAlgDropNext;
        break;
      case DIFFSERVALGDROPQMEASURE:
        *write_method = write_diffServAlgDropQMeasure;
        break;
      case DIFFSERVALGDROPQTHRESHOLD:
        *write_method = write_diffServAlgDropQThreshold;
        break;
      case DIFFSERVALGDROPSPECIFIC:
        *write_method = write_diffServAlgDropSpecific;
        break;
      case DIFFSERVALGDROPSTORAGE:
        *write_method = write_diffServAlgDropStorage;
        break;
      case DIFFSERVALGDROPSTATUS:
        *write_method = write_diffServAlgDropStatus;
        break;
      default:
        *write_method =0;
         break;
    }

    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl, diffServAlgDropEntry_INSTANCE_LEN);

     /*check compc, retrive compl*/
    if (exact)/*get,set*/
    {
        if (!diffServAlgDropTable_get(compc, compl, &data))
            return NULL;
    }
    else/*getnext*/
    {
        if (!diffServAlgDropTable_next(compc, compl, &data))
            return NULL;
    }
    memcpy(name, vp->name, vp->namelen*sizeof(oid));
    best_inst[0]=data.id;

    memcpy(name + vp->namelen, best_inst, diffServAlgDropEntry_INSTANCE_LEN*sizeof(oid));
    *length = vp->namelen +diffServAlgDropEntry_INSTANCE_LEN;

    *var_len = sizeof(long_return);
    /*
     * * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
      case DIFFSERVALGDROPTYPE:
        long_return = data.type;
        return (u_char*) &long_return;
      case DIFFSERVALGDROPNEXT:
        {
        SNMP_TYPE_Oid_T snmpoid;
        if(SNMP_MGR_IsDebugMode())
            print_dsoid(&data.next);
        if (L4_DS_MGR_DiffServRowPointerToOid(&data.next, &snmpoid))
        {
            *var_len = snmpoid.oid_len * sizeof(UI32_T);
            memcpy(oid_return, snmpoid.oid, *var_len);
            return (u_char *) oid_return;
        }
        else
        {
            if(SNMP_MGR_IsDebugMode())
   	            SYSFUN_Debug_Printf("var_diffServAlgDropTable:L4_DS_MGR_DiffServRowPointerToOid return false\n");
            return NULL;
        }
      }
      case DIFFSERVALGDROPQMEASURE:
      {
        SNMP_TYPE_Oid_T snmpoid;
        if(SNMP_MGR_IsDebugMode())
            print_dsoid(&data.q_measure);
        if (L4_DS_MGR_DiffServRowPointerToOid(&data.q_measure, &snmpoid))
        {
            *var_len = snmpoid.oid_len * sizeof(UI32_T);
            memcpy(oid_return, snmpoid.oid, *var_len);
            return (u_char *) oid_return;
        }
        else
        {
            if(SNMP_MGR_IsDebugMode())
   	            SYSFUN_Debug_Printf("var_diffServAlgDropTable:L4_DS_MGR_DiffServRowPointerToOid return false\n");
            return NULL;
        }
      }
      case DIFFSERVALGDROPQTHRESHOLD:
        long_return = data.q_threshold;
        return (u_char*) &long_return;
      case DIFFSERVALGDROPSPECIFIC:
       {
        SNMP_TYPE_Oid_T snmpoid;
        if(SNMP_MGR_IsDebugMode())
            print_dsoid(&data.specific);
        if (L4_DS_MGR_DiffServRowPointerToOid(&data.specific, &snmpoid))
        {
            *var_len = snmpoid.oid_len * sizeof(UI32_T);
            memcpy(oid_return, snmpoid.oid, *var_len);
            return (u_char *) oid_return;
        }
        else
        {
            if(SNMP_MGR_IsDebugMode())
   	            SYSFUN_Debug_Printf("var_diffServAlgDropTable:L4_DS_MGR_DiffServRowPointerToOid return false\n");
            return NULL;
        }
      }
      case DIFFSERVALGDROPOCTETS:
        long_return = data.octets;
        return (u_char*) &long_return;
      case DIFFSERVALGDROPPKTS:
        long_return = data.pkts;
        return (u_char*) &long_return;
      case DIFFSERVALGRANDOMDROPOCTETS:
        long_return = data.random_drop_octets;
        return (u_char*) &long_return;
      case DIFFSERVALGRANDOMDROPPKTS:
        long_return = data.random_drop_pkts;
        return (u_char*) &long_return;
      case DIFFSERVALGDROPSTORAGE:
        long_return = data.storage;
        return (u_char*) &long_return;
      case DIFFSERVALGDROPSTATUS:
        long_return = data.status;
        return (u_char*) &long_return;
    default:
        ERROR_MSG("");
    }
    return NULL;
}


int
write_diffServAlgDropType(int action,
                          u_char * var_val,
                          u_char var_val_type,
                          size_t var_val_len,
                          u_char * statP, oid * name, size_t name_len)
{
    long            value;

    switch (action) {
    case RESERVE1:
        /* check 1: check if the input index is exactly match, if not return fail*/
        if (name_len!=  diffServAlgDropEntry_OID_NAME_LEN + diffServAlgDropEntry_INSTANCE_LEN )
        {
            return SNMP_ERR_WRONGLENGTH;
        }
        if (var_val_type != ASN_INTEGER) {

            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        value = *(long *)var_val;
        switch(value)
        {
          case VAL_diffServAlgDropType_other:
          case VAL_diffServAlgDropType_tailDrop:
          case VAL_diffServAlgDropType_headDrop:
          case VAL_diffServAlgDropType_randomDrop:
          case VAL_diffServAlgDropType_alwaysDrop:
            break;
          default:
            return SNMP_ERR_WRONGVALUE;
        }
        break;

    case FREE:
        /*
         * Release any resources that have been allocated
         */
        break;

    case ACTION:
    {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        UI32_T id;
        id=name[diffServAlgDropEntry_OID_NAME_LEN];
        value = *(long *)var_val;

        if(SNMP_MGR_IsDebugMode())
             SYSFUN_Debug_Printf("write_diffServAlgDropType:id=[%lu], value=[%lu]\n", id, value);

        if (!L4_DS_MGR_SetDiffServAlgDropType(id, value))
        {
            if(SNMP_MGR_IsDebugMode())
                SYSFUN_Debug_Printf("write_diffServAlgDropType:L4_DS_MGR_SetDiffServAlgDropType return false\n");
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    case UNDO:
        /*
         * Back out any changes made in the ACTION case
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_diffServAlgDropNext(int action,
                          u_char * var_val,
                          u_char var_val_type,
                          size_t var_val_len,
                          u_char * statP, oid * name, size_t name_len)
{

    switch (action) {
    case RESERVE1:
        /* check 1: check if the input index is exactly match, if not return fail*/
        if (name_len!=  diffServAlgDropEntry_OID_NAME_LEN + diffServAlgDropEntry_INSTANCE_LEN )
        {
            return SNMP_ERR_WRONGLENGTH;
        }
        if (var_val_type != ASN_OBJECT_ID) {

            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > (SYS_ADPT_MAX_OID_COUNT * sizeof(UI32_T))) {
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        break;
    case FREE:
        /*
         * Release any resources that have been allocated
         */
        break;

    case ACTION:
    {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
         SNMP_TYPE_Oid_T snmpoid;
         L4_DS_TYPE_Oid_T dsoid;
         UI32_T id;
         id=name[diffServAlgDropEntry_OID_NAME_LEN];
         memcpy(snmpoid.oid, var_val, var_val_len);
         snmpoid.oid_len=var_val_len;
         if(SNMP_MGR_IsDebugMode())
            print_snmpoid(&snmpoid);
         if (L4_DS_MGR_OidToDiffServRowPointer(&snmpoid, &dsoid))
         {
             if(SNMP_MGR_IsDebugMode())
             {
                 SYSFUN_Debug_Printf("write_diffServAlgDropNext:id=[%lu]\n", id);
                 print_dsoid(&dsoid);
             }
             if (!L4_DS_MGR_SetDiffServAlgDropNext(id, &dsoid))
             {
                if(SNMP_MGR_IsDebugMode())
                    SYSFUN_Debug_Printf("write_diffServAlgDropNext:L4_DS_MGR_SetDiffServAlgDropNext return false\n");
                return SNMP_ERR_COMMITFAILED;
             }
         }
         else
         {
            if(SNMP_MGR_IsDebugMode())
                SYSFUN_Debug_Printf("write_diffServAlgDropNext:L4_DS_MGR_OidToDiffServRowPointer return false\n");
         }
         break;
    }
    case UNDO:
        /*
         * Back out any changes made in the ACTION case
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_diffServAlgDropQMeasure(int action,
                              u_char * var_val,
                              u_char var_val_type,
                              size_t var_val_len,
                              u_char * statP, oid * name, size_t name_len)
{

    switch (action) {
    case RESERVE1:
        /* check 1: check if the input index is exactly match, if not return fail*/
        if (name_len!=  diffServAlgDropEntry_OID_NAME_LEN + diffServAlgDropEntry_INSTANCE_LEN )
        {
            return SNMP_ERR_WRONGLENGTH;
        }
        if (var_val_type != ASN_OBJECT_ID) {

            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > (SYS_ADPT_MAX_OID_COUNT * sizeof(UI32_T))) {
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        break;
    case FREE:
        /*
         * Release any resources that have been allocated
         */
        break;
    case ACTION:
    {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
         SNMP_TYPE_Oid_T snmpoid;
         L4_DS_TYPE_Oid_T dsoid;
         UI32_T id;
         id=name[diffServAlgDropEntry_OID_NAME_LEN];
         memcpy(snmpoid.oid, var_val, var_val_len);
         snmpoid.oid_len=var_val_len;
         if(SNMP_MGR_IsDebugMode())
            print_snmpoid(&snmpoid);
         if (L4_DS_MGR_OidToDiffServRowPointer(&snmpoid, &dsoid))
         {
             if(SNMP_MGR_IsDebugMode())
             {
                 SYSFUN_Debug_Printf("write_diffServAlgDropQMeasure:id=[%lu]\n", id);
                 print_dsoid(&dsoid);
             }
             if (!L4_DS_MGR_SetDiffServAlgDropQMeasure(id, &dsoid))
             {
                if(SNMP_MGR_IsDebugMode())
                    SYSFUN_Debug_Printf("write_diffServAlgDropQMeasure:L4_DS_MGR_SetDiffServAlgDropQMeasure return false\n");
                return SNMP_ERR_COMMITFAILED;
             }
         }
         else
         {
            if(SNMP_MGR_IsDebugMode())
                SYSFUN_Debug_Printf("write_diffServAlgDropQMeasure:L4_DS_MGR_OidToDiffServRowPointer return false\n");
         }
         break;
    }
    case UNDO:
        /*
         * Back out any changes made in the ACTION case
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_diffServAlgDropQThreshold(int action,
                                u_char * var_val,
                                u_char var_val_type,
                                size_t var_val_len,
                                u_char * statP,
                                oid * name, size_t name_len)
{
    u_long          value;

    switch (action) {
    case RESERVE1:
        /* check 1: check if the input index is exactly match, if not return fail*/
        if (name_len!=  diffServAlgDropEntry_OID_NAME_LEN + diffServAlgDropEntry_INSTANCE_LEN )
        {
            return SNMP_ERR_WRONGLENGTH;
        }
        if (var_val_type != ASN_UNSIGNED) {

            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(u_long)) {
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        break;
    case FREE:
        /*
         * Release any resources that have been allocated
         */
        break;

    case ACTION:
    {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        UI32_T id;
        id=name[diffServAlgDropEntry_OID_NAME_LEN];
        value = *(u_long *)var_val;
        if(SNMP_MGR_IsDebugMode())
             SYSFUN_Debug_Printf("write_diffServAlgDropQThreshold:id=[%lu], value=[%lu]\n", id, value);

        if (!L4_DS_MGR_SetDiffServAlgDropQThreshold(id, value))
        {
            if(SNMP_MGR_IsDebugMode())
                SYSFUN_Debug_Printf("write_diffServAlgDropQThreshold:L4_DS_MGR_SetDiffServAlgDropQThreshold return false\n");
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }

    case UNDO:
        /*
         * Back out any changes made in the ACTION case
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_diffServAlgDropSpecific(int action,
                              u_char * var_val,
                              u_char var_val_type,
                              size_t var_val_len,
                              u_char * statP, oid * name, size_t name_len)
{

    switch (action) {
    case RESERVE1:
        /* check 1: check if the input index is exactly match, if not return fail*/
        if (name_len!=  diffServAlgDropEntry_OID_NAME_LEN + diffServAlgDropEntry_INSTANCE_LEN )
        {
            return SNMP_ERR_WRONGLENGTH;
        }
        if (var_val_type != ASN_OBJECT_ID) {

            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > (SYS_ADPT_MAX_OID_COUNT * sizeof(UI32_T))) {

            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        break;
    case FREE:
        /*
         * Release any resources that have been allocated
         */
        break;
    case ACTION:
    {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
         SNMP_TYPE_Oid_T snmpoid;
         L4_DS_TYPE_Oid_T dsoid;
         UI32_T id;
         id=name[diffServAlgDropEntry_OID_NAME_LEN];
         memcpy(snmpoid.oid, var_val, var_val_len);
         snmpoid.oid_len=var_val_len;
         if(SNMP_MGR_IsDebugMode())
            print_snmpoid(&snmpoid);
         if (L4_DS_MGR_OidToDiffServRowPointer(&snmpoid, &dsoid))
         {
             if(SNMP_MGR_IsDebugMode())
             {
                 SYSFUN_Debug_Printf("write_diffServAlgDropSpecific:id=[%lu]\n", id);
                 print_dsoid(&dsoid);
             }
             if (!L4_DS_MGR_SetDiffServAlgDropSpecific(id, &dsoid))
             {
                if(SNMP_MGR_IsDebugMode())
                    SYSFUN_Debug_Printf("write_diffServAlgDropSpecific:L4_DS_MGR_SetDiffServAlgDropSpecific return false\n");
                return SNMP_ERR_COMMITFAILED;
             }
         }
         else
         {
            if(SNMP_MGR_IsDebugMode())
                SYSFUN_Debug_Printf("write_diffServAlgDropSpecific:L4_DS_MGR_OidToDiffServRowPointer return false\n");
         }
         break;
    }
    case UNDO:
        /*
         * Back out any changes made in the ACTION case
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_diffServAlgDropStorage(int action,
                             u_char * var_val,
                             u_char var_val_type,
                             size_t var_val_len,
                             u_char * statP, oid * name, size_t name_len)
{
    long            value;

    switch (action) {
    case RESERVE1:
        /* check 1: check if the input index is exactly match, if not return fail*/
        if (name_len!=  diffServAlgDropEntry_OID_NAME_LEN + diffServAlgDropEntry_INSTANCE_LEN )
        {
            return SNMP_ERR_WRONGLENGTH;
        }
        if (var_val_type != ASN_INTEGER) {

            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        value = *(long *)var_val;
        switch(value)
        {
          case VAL_diffServAlgDropStorage_other:
          case VAL_diffServAlgDropStorage_volatile:
          case VAL_diffServAlgDropStorage_nonVolatile:
          case VAL_diffServAlgDropStorage_permanent:
          case VAL_diffServAlgDropStorage_readOnly:
            break;
          default:
            return SNMP_ERR_WRONGVALUE;
        }
        break;

    case FREE:
        /*
         * Release any resources that have been allocated
         */
        break;

    case ACTION:
    {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        UI32_T id;
        id=name[diffServAlgDropEntry_OID_NAME_LEN];
        value = *(long *)var_val;
        if(SNMP_MGR_IsDebugMode())
             SYSFUN_Debug_Printf("write_diffServAlgDropStorage:id=[%lu], value=[%lu]\n", id, value);

        if (!L4_DS_MGR_SetSetDiffServAlgDropStorage(id, value))
        {
            if(SNMP_MGR_IsDebugMode())
                SYSFUN_Debug_Printf("write_diffServAlgDropStorage:L4_DS_MGR_SetSetDiffServAlgDropStorage return false\n");
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    case UNDO:
        /*
         * Back out any changes made in the ACTION case
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_diffServAlgDropStatus(int action,
                            u_char * var_val,
                            u_char var_val_type,
                            size_t var_val_len,
                            u_char * statP, oid * name, size_t name_len)
{
    long            value;

    switch (action) {
    case RESERVE1:
        /* check 1: check if the input index is exactly match, if not return fail*/
        if (name_len!=  diffServAlgDropEntry_OID_NAME_LEN + diffServAlgDropEntry_INSTANCE_LEN )
        {
            return SNMP_ERR_WRONGLENGTH;
        }
        if (var_val_type != ASN_INTEGER) {

            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        value = *(long *)var_val;
        switch(value)
        {
          case VAL_diffServAlgDropStatus_active:
          case VAL_diffServAlgDropStatus_notInService:
          case VAL_diffServAlgDropStatus_notReady:
          case VAL_diffServAlgDropStatus_createAndGo:
          case VAL_diffServAlgDropStatus_createAndWait:
          case VAL_diffServAlgDropStatus_destroy:
            break;
          default:
            return SNMP_ERR_WRONGVALUE;
        }
        break;

    case FREE:
        /*
         * Release any resources that have been allocated
         */
        break;

    case ACTION:
    {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        UI32_T id;
        id=name[diffServAlgDropEntry_OID_NAME_LEN];
        value = *(long *)var_val;
        if(SNMP_MGR_IsDebugMode())
             SYSFUN_Debug_Printf("write_diffServAlgDropStatus:id=[%lu], value=[%lu]\n", id, value);

        if (!L4_DS_MGR_SetDiffServAlgDropStatus(id, value))
        {
            if(SNMP_MGR_IsDebugMode())
                SYSFUN_Debug_Printf("write_diffServAlgDropStatus:L4_DS_MGR_SetSetDiffServAlgDropStorage return false\n");
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    }
    case UNDO:
        /*
         * Back out any changes made in the ACTION case
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}


/** Initializes the diffServClassifier module */
void
init_diffServClassifier(void)
{
    static oid      diffServClfrElementNextFree_oid[] =
        { 1, 3, 6, 1, 2, 1, 97, 1, 2, 3, 0 };
    static oid      diffServClfrNextFree_oid[] =
        { 1, 3, 6, 1, 2, 1, 97, 1, 2, 1, 0 };
    static oid      diffServMultiFieldClfrNextFree_oid[] =
        { 1, 3, 6, 1, 2, 1, 97, 1, 2, 5, 0 };

    DEBUGMSGTL(("diffServClassifier", "Initializing\n"));

    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("diffServClfrElementNextFree",
                                         get_diffServClfrElementNextFree,
                                         diffServClfrElementNextFree_oid,
                                         OID_LENGTH
                                         (diffServClfrElementNextFree_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("diffServClfrNextFree",
                                         get_diffServClfrNextFree,
                                         diffServClfrNextFree_oid,
                                         OID_LENGTH
                                         (diffServClfrNextFree_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("diffServMultiFieldClfrNextFree",
                                         get_diffServMultiFieldClfrNextFree,
                                         diffServMultiFieldClfrNextFree_oid,
                                         OID_LENGTH
                                         (diffServMultiFieldClfrNextFree_oid),
                                         HANDLER_CAN_RONLY));
}

int
get_diffServClfrElementNextFree(netsnmp_mib_handler *handler,
                                netsnmp_handler_registration *reginfo,
                                netsnmp_agent_request_info *reqinfo,
                                netsnmp_request_info *requests)
{
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one.
     */

    switch (reqinfo->mode) {

    case MODE_GET:
    {
            UI32_T value;
            if (L4_DS_MGR_GetDiffServClfrElementNextFree(&value))
            {
                long_return=value;
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *)&long_return, sizeof(long_return));
            }
            else
            {
                if(SNMP_MGR_IsDebugMode())
                    SYSFUN_Debug_Printf("get_diffServClfrElementNextFree:L4_DS_MGR_GetDiffServClfrElementNextFree return false\n");
            	return SNMP_ERR_GENERR;
            }
    	    break;
     }
    default:
        /*
         * we should never get here, so this is a really bad error
         */
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_diffServClfrNextFree(netsnmp_mib_handler *handler,
                         netsnmp_handler_registration *reginfo,
                         netsnmp_agent_request_info *reqinfo,
                         netsnmp_request_info *requests)
{
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one.
     */

    switch (reqinfo->mode) {

    case MODE_GET:
     {
        UI32_T value;
        if (L4_DS_MGR_GetDiffServClfrNextFree(&value))
        {
            long_return=value;
            snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, (u_char *)&long_return, sizeof(long_return));
        }
        else
        {
            if(SNMP_MGR_IsDebugMode())
                SYSFUN_Debug_Printf("get_diffServClfrNextFree:L4_DS_MGR_GetDiffServClfrNextFree return false\n");
        	return SNMP_ERR_GENERR;
        }
	    break;
     }
    default:
        /*
         * we should never get here, so this is a really bad error
         */
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_diffServMultiFieldClfrNextFree(netsnmp_mib_handler *handler,
                                   netsnmp_handler_registration *reginfo,
                                   netsnmp_agent_request_info *reqinfo,
                                   netsnmp_request_info *requests)
{
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one.
     */

    switch (reqinfo->mode) {

    case MODE_GET:
     {
        UI32_T value;
        if (L4_DS_MGR_GetDiffServMultiFieldClfrNextFree(&value))
        {
            long_return=value;
            snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, (u_char *)&long_return, sizeof(long_return));
        }
        else
        {
            if(SNMP_MGR_IsDebugMode())
                SYSFUN_Debug_Printf("get_diffServMultiFieldClfrNextFree:L4_DS_MGR_GetDiffServMultiFieldClfrNextFree return false\n");
        	return SNMP_ERR_GENERR;
        }
	    break;
     }
    default:
        /*
         * we should never get here, so this is a really bad error
         */
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}


/** Initializes the diffServAction module */
void
init_diffServAction(void)
{
    static oid      diffServActionNextFree_oid[] =
        { 1, 3, 6, 1, 2, 1, 97, 1, 5, 1, 0 };
    static oid      diffServCountActNextFree_oid[] =
        { 1, 3, 6, 1, 2, 1, 97, 1, 5, 4, 0 };

    DEBUGMSGTL(("diffServAction", "Initializing\n"));

    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("diffServActionNextFree",
                                         get_diffServActionNextFree,
                                         diffServActionNextFree_oid,
                                         OID_LENGTH
                                         (diffServActionNextFree_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("diffServCountActNextFree",
                                         get_diffServCountActNextFree,
                                         diffServCountActNextFree_oid,
                                         OID_LENGTH
                                         (diffServCountActNextFree_oid),
                                         HANDLER_CAN_RONLY));
}

int
get_diffServActionNextFree(netsnmp_mib_handler *handler,
                           netsnmp_handler_registration *reginfo,
                           netsnmp_agent_request_info *reqinfo,
                           netsnmp_request_info *requests)
{
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one.
     */

    switch (reqinfo->mode) {

    case MODE_GET:
    {
        UI32_T value;
        if (L4_DS_MGR_GetDiffServActionNextFree(&value))
        {
            long_return=value;
            snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, (u_char *)&long_return, sizeof(long_return));
        }
        else
        {
            if(SNMP_MGR_IsDebugMode())
                SYSFUN_Debug_Printf("get_diffServActionNextFree:L4_DS_MGR_GetDiffServActionNextFree return false\n");
        	return SNMP_ERR_GENERR;
        }
	    break;
     }
    default:
        /*
         * we should never get here, so this is a really bad error
         */
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_diffServCountActNextFree(netsnmp_mib_handler *handler,
                             netsnmp_handler_registration *reginfo,
                             netsnmp_agent_request_info *reqinfo,
                             netsnmp_request_info *requests)
{
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one.
     */

    switch (reqinfo->mode) {

    case MODE_GET:
    {
        UI32_T value;
        if (L4_DS_MGR_GetDiffServCountActNextFree(&value))
        {
            long_return=value;
            snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, (u_char *)&long_return, sizeof(long_return));
        }
        else
        {
            if(SNMP_MGR_IsDebugMode())
                SYSFUN_Debug_Printf("get_diffServCountActNextFree:L4_DS_MGR_GetDiffServCountActNextFree return false\n");
        	return SNMP_ERR_GENERR;
        }
	    break;
     }
    default:
        /*
         * we should never get here, so this is a really bad error
         */
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}


/** Initializes the diffServMeter module */
void
init_diffServMeter(void)
{
    static oid      diffServMeterNextFree_oid[] =
        { 1, 3, 6, 1, 2, 1, 97, 1, 3, 1, 0 };

    DEBUGMSGTL(("diffServMeter", "Initializing\n"));

    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("diffServMeterNextFree",
                                         get_diffServMeterNextFree,
                                         diffServMeterNextFree_oid,
                                         OID_LENGTH
                                         (diffServMeterNextFree_oid),
                                         HANDLER_CAN_RONLY));
}

int
get_diffServMeterNextFree(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one.
     */

    switch (reqinfo->mode) {

    case MODE_GET:
    {
        UI32_T value;
        if (L4_DS_MGR_GetDiffServMeterNextFree(&value))
        {
            long_return=value;
            snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, (u_char *)&long_return, sizeof(long_return));
        }
        else
        {
            if(SNMP_MGR_IsDebugMode())
                SYSFUN_Debug_Printf("get_diffServMeterNextFree:L4_DS_MGR_GetDiffServMeterNextFree return false\n");
        	return SNMP_ERR_GENERR;
        }
	    break;
     }
    default:
        /*
         * we should never get here, so this is a really bad error
         */
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}


/** Initializes the diffServTBParam module */
void
init_diffServTBParam(void)
{
    static oid      diffServTBParamNextFree_oid[] =
        { 1, 3, 6, 1, 2, 1, 97, 1, 4, 1, 0 };

    DEBUGMSGTL(("diffServTBParam", "Initializing\n"));

    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("diffServTBParamNextFree",
                                         get_diffServTBParamNextFree,
                                         diffServTBParamNextFree_oid,
                                         OID_LENGTH
                                         (diffServTBParamNextFree_oid),
                                         HANDLER_CAN_RONLY));
}

int
get_diffServTBParamNextFree(netsnmp_mib_handler *handler,
                            netsnmp_handler_registration *reginfo,
                            netsnmp_agent_request_info *reqinfo,
                            netsnmp_request_info *requests)
{
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one.
     */

    switch (reqinfo->mode) {

    case MODE_GET:
    {
        UI32_T value;
        if (L4_DS_MGR_GetDiffServTBParamNextFree(&value))
        {
            long_return=value;
            snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, (u_char *)&long_return, sizeof(long_return));
        }
        else
        {
            if(SNMP_MGR_IsDebugMode())
                SYSFUN_Debug_Printf("get_diffServTBParamNextFree:L4_DS_MGR_GetDiffServTBParamNextFree return false\n");
        	return SNMP_ERR_GENERR;
        }
	    break;
     }
    default:
        /*
         * we should never get here, so this is a really bad error
         */
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}



/** Initializes the diffServAlgDrop module */
void
init_diffServAlgDrop(void)
{
    static oid      diffServRandomDropNextFree_oid[] =
        { 1, 3, 6, 1, 2, 1, 97, 1, 6, 3, 0 };
    static oid      diffServAlgDropNextFree_oid[] =
        { 1, 3, 6, 1, 2, 1, 97, 1, 6, 1, 0 };

    DEBUGMSGTL(("diffServAlgDrop", "Initializing\n"));

    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("diffServRandomDropNextFree",
                                         get_diffServRandomDropNextFree,
                                         diffServRandomDropNextFree_oid,
                                         OID_LENGTH
                                         (diffServRandomDropNextFree_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("diffServAlgDropNextFree",
                                         get_diffServAlgDropNextFree,
                                         diffServAlgDropNextFree_oid,
                                         OID_LENGTH
                                         (diffServAlgDropNextFree_oid),
                                         HANDLER_CAN_RONLY));
}

int
get_diffServRandomDropNextFree(netsnmp_mib_handler *handler,
                               netsnmp_handler_registration *reginfo,
                               netsnmp_agent_request_info *reqinfo,
                               netsnmp_request_info *requests)
{
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one.
     */

    switch (reqinfo->mode) {

    case MODE_GET:
    {
        UI32_T value;
        if (L4_DS_MGR_GetDiffServRandomDropNextFree(&value))
        {
            long_return=value;
            snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, (u_char *)&long_return, sizeof(long_return));
        }
        else
        {
            if(SNMP_MGR_IsDebugMode())
                SYSFUN_Debug_Printf("get_diffServRandomDropNextFree:L4_DS_MGR_GetDiffServRandomDropNextFree return false\n");
        	return SNMP_ERR_GENERR;
        }
	    break;
     }

    default:
        /*
         * we should never get here, so this is a really bad error
         */
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_diffServAlgDropNextFree(netsnmp_mib_handler *handler,
                            netsnmp_handler_registration *reginfo,
                            netsnmp_agent_request_info *reqinfo,
                            netsnmp_request_info *requests)
{
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one.
     */

    switch (reqinfo->mode) {

    case MODE_GET:
    {
        UI32_T value;
        if (L4_DS_MGR_GetDiffServAlgDropNextFree(&value))
        {
            long_return=value;
            snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, (u_char *)&long_return, sizeof(long_return));
        }
        else
        {
            if(SNMP_MGR_IsDebugMode())
                SYSFUN_Debug_Printf("get_diffServAlgDropNextFree:L4_DS_MGR_GetDiffServAlgDropNextFree return false\n");
        	return SNMP_ERR_GENERR;
        }
	    break;
     }
    default:
        /*
         * we should never get here, so this is a really bad error
         */
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

#endif/*end of #if (SYS_CPNT_QOS == SYS_CPNT_QOS_DIFFSERV)*/
