/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.old-api.conf,v 1.2 2002/07/18 15:37:37 dts12 Exp $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "rfc_2576.h"
#include "sysORTable.h"
#include "snmp_mgr.h"
#include "sys_type.h"
#include "sys_adpt.h"
#include "leaf_3411.h"

/*
 * snmpCommunityTable_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */
oid communityMIB_module_oid[] = { 1,3,6,1,6,3,18 };
oid snmpCommunityTable_variables_oid[] = { 1,3,6,1,6,3,18,1 };

/*
 * variable4 snmpCommunityTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */

struct variable3 snmpCommunityTable_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */

#define SNMPCOMMUNITYNAME       2
{SNMPCOMMUNITYNAME,  ASN_OCTET_STR,  RWRITE,  var_snmpCommunityTable, 3,  { 1, 1, 2 }},
#define SNMPCOMMUNITYSECURITYNAME       3
{SNMPCOMMUNITYSECURITYNAME,  ASN_OCTET_STR,  RWRITE,  var_snmpCommunityTable, 3,  { 1, 1, 3 }},
#define SNMPCOMMUNITYCONTEXTENGINEID        4
{SNMPCOMMUNITYCONTEXTENGINEID,  ASN_OCTET_STR,  RWRITE,  var_snmpCommunityTable, 3,  { 1, 1, 4 }},
#define SNMPCOMMUNITYCONTEXTNAME        5
{SNMPCOMMUNITYCONTEXTNAME,  ASN_OCTET_STR,  RWRITE,  var_snmpCommunityTable, 3,  { 1, 1, 5 }},
#define SNMPCOMMUNITYTRANSPORTTAG       6
{SNMPCOMMUNITYTRANSPORTTAG,  ASN_OCTET_STR,  RWRITE,  var_snmpCommunityTable, 3,  { 1, 1, 6 }},
#define SNMPCOMMUNITYSTORAGETYPE        7
{SNMPCOMMUNITYSTORAGETYPE,  ASN_INTEGER,  RWRITE,  var_snmpCommunityTable, 3,  { 1, 1, 7 }},
#define SNMPCOMMUNITYSTATUS  8
{SNMPCOMMUNITYSTATUS,  ASN_INTEGER,  RWRITE,  var_snmpCommunityTable, 3,  { 1, 1, 8 }},
};
/*    (L = length of the oidsuffix) */


/** Initializes the snmpCommunityTable module */
void
init_snmpCommunityTable(void)
{

    DEBUGMSGTL(("snmpCommunityTable", "Initializing\n"));

    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("snmpCommunityTable", snmpCommunityTable_variables, variable3,
               snmpCommunityTable_variables_oid);

    /* place any other initialization junk you need here */
    REGISTER_SYSOR_ENTRY(communityMIB_module_oid,
                         "Rfc2576 SNMP-COMMUNITY MIB.");
}

/* This entry is used for entry which have the ability to row create*/
static SNMP_MGR_SnmpCommunityEntry_T snmpCommunityEntry;

static int
header_snmpCommunityTable(struct variable *vp,
               oid * name,
               size_t * length,
               int exact, size_t * var_len, WriteMethod ** write_method,
               UI8_T *index)
{
#define OID_NAME_LENGTH 11

    oid             newname[MAX_OID_LEN];
    int             result;
    SNMP_MGR_SnmpCommunityEntry_T  entry;
    UI32_T return_val=SNMP_MGR_ERROR_FAIL;
    oid next_inst[SYS_ADPT_MAX_COMM_STR_NAME_LEN+1];
    UI32_T next_inst_length=0;
    int i;

    memcpy((char *) newname, (char *) vp->name,
           (int) vp->namelen * sizeof(oid));
    /*
     * find "next" interface
     */
    memset(&entry, 0 , sizeof(entry));

    /*
     * find "next" interface
     */
    while (  (return_val= SNMP_MGR_GetNextSnmpCommunityEntry(&entry)) == SNMP_MGR_ERROR_OK)
    {
        next_inst_length = strlen(entry.snmp_community_index);

        for ( i = 0; i<= next_inst_length; i++)
        {
            next_inst[i] = (oid)entry.snmp_community_index[i];
        }

        memcpy( (char*)&newname[OID_NAME_LENGTH], (char*)next_inst,  next_inst_length*sizeof(oid));
        result =
            snmp_oid_compare(name, *length, newname,
                             (int) vp->namelen +next_inst_length);
        if ((exact && (result == 0)) || (!exact && (result < 0)))
            break;
    }

    if (return_val== SNMP_MGR_ERROR_FAIL ) {
        DEBUGMSGTL(("mibII/interfaces", "... index out of range\n"));
        return MATCH_FAILED;
    }
    memcpy((char *) name, (char *) newname,
           ((int) vp->namelen + next_inst_length ) * sizeof(oid));
    *length = vp->namelen + next_inst_length;
    *var_len = sizeof(long);    /* default to 'long' results */

    strcpy((char *)index, entry.snmp_community_index);
    return TRUE;
}

/*
 * var_snmpCommunityTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *
var_snmpCommunityTable(struct variable *vp,
            oid     *name,
            size_t  *length,
            int     exact,
            size_t  *var_len,
            WriteMethod **write_method)
{
    SNMP_MGR_SnmpCommunityEntry_T entry;

    UI8_T comm_index[SYS_ADPT_MAX_COMM_STR_NAME_LEN+1];
    UI32_T retval;

    /* Give default value for the record first,
     * We use the row_status = 0 to indicate if this set operation is Set by field
     * or set by record(included row creation), if the row_status =0, this record
     * mean set by field, otherwise, we just think it is a normal set operation
     */
    SNMP_MGR_GetDefaultSnmpCommunityEntry(&snmpCommunityEntry);
    snmpCommunityEntry.snmp_community_status = 0;

    switch(vp->magic) {
        case SNMPCOMMUNITYNAME:
            *write_method = write_snmpCommunityName;
            break;
        case SNMPCOMMUNITYSECURITYNAME:
            *write_method = write_snmpCommunitySecurityName;
            break;
        case SNMPCOMMUNITYCONTEXTENGINEID:
            *write_method = write_snmpCommunityContextEngineID;
            break;
        case SNMPCOMMUNITYCONTEXTNAME:
            *write_method = write_snmpCommunityContextName;
            break;
        case SNMPCOMMUNITYTRANSPORTTAG:
            *write_method = write_snmpCommunityTransportTag;
            break;
        case SNMPCOMMUNITYSTORAGETYPE:
            *write_method = write_snmpCommunityStorageType;
            break;
        case SNMPCOMMUNITYSTATUS:
            *write_method = write_snmpCommunityStatus;
            break;
    }

    memset( &entry, 0, sizeof(entry));
    retval =
        header_snmpCommunityTable(vp, name, length, exact, var_len, write_method, comm_index);
    if (retval == MATCH_FAILED)
        return NULL;

    strcpy(entry.snmp_community_index, (char *)comm_index);

    if (SNMP_MGR_GetSnmpCommunityEntry(&entry)!= SNMP_MGR_ERROR_OK)
        return NULL;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch(vp->magic) {
        case SNMPCOMMUNITYNAME:
            strcpy((char *)return_buf,  entry.snmp_community_name);
            *var_len = strlen((char *)return_buf);
            return (u_char*) return_buf;
        case SNMPCOMMUNITYSECURITYNAME:
            strcpy((char *)return_buf,  entry.snmp_community_security_name);
            *var_len = strlen((char *)return_buf);
            return (u_char*) return_buf;
        case SNMPCOMMUNITYCONTEXTENGINEID:
            *var_len = entry.snmp_community_engine_id_length;
            memcpy( return_buf, entry.snmp_community_context_engine_id, *var_len);
            return (u_char*) return_buf;
        case SNMPCOMMUNITYCONTEXTNAME:
            strcpy((char *)return_buf,  (char *)entry.snmp_community_context_name);
            *var_len = strlen((char *)return_buf);
            return (u_char*) return_buf;
        case SNMPCOMMUNITYTRANSPORTTAG:
            strcpy((char *)return_buf,  (char *)entry.snmp_community_transport_tag);
            *var_len = strlen((char *)return_buf);
            return (u_char*) return_buf;
        case SNMPCOMMUNITYSTORAGETYPE:
            long_return =entry.snmp_community_storage_type;
            return (u_char*) &long_return;
        case SNMPCOMMUNITYSTATUS:
            long_return =entry.snmp_community_status;
            return (u_char*) &long_return;
        default:
            ERROR_MSG("");
    }

    return NULL;
}

int
write_snmpCommunityName(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    int i;
    char comm_index[SYS_ADPT_MAX_COMM_STR_NAME_LEN+1];

    if ((char) name[10] != SNMPCOMMUNITYNAME)
    {
        return SNMP_ERR_NOTWRITABLE;
    }

    if (name_len-11 > SYS_ADPT_MAX_COMM_STR_NAME_LEN+1)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    for (i = 0; i<= name_len-11; i++)
    {
        comm_index[i] = name[11+i];
    }
    comm_index[name_len-11]= '\0';

    switch ( action ) {
        case RESERVE1:
            if (var_val_type != ASN_OCTET_STR) {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len >SYS_ADPT_MAX_COMM_STR_NAME_LEN+1)
            {

                return SNMP_ERR_WRONGLENGTH;
            }
            break;

        case RESERVE2:
            /* Overwrite the set value to snmpCommunityEntry which will be used
             * in write_xxxRowStatus function.
             */
            strncpy((char *)snmpCommunityEntry.snmp_community_name, (char *)var_val, var_val_len);
            snmpCommunityEntry.snmp_community_name[var_val_len]= '\0';
            break;

        case FREE:
            /* Release any resources that have been allocated */
            break;

        case ACTION:
            /* For row creation, if row_status =0, mean that this is a normal
             * operation, we do the normal set operation, otherwise it is a row
             * creation operation, will do nothing here, and the overall entry
             * will perform in the write_xxxRowStatus function.
             */
            if (snmpCommunityEntry.snmp_community_status == 0)
            {
                if (SNMP_MGR_SetSnmpCommunityName(comm_index, snmpCommunityEntry.snmp_community_name) != SNMP_MGR_ERROR_OK)
                {
                    return SNMP_ERR_COMMITFAILED;
                }
            }
            break;

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }

    return SNMP_ERR_NOERROR;
}

int
write_snmpCommunitySecurityName(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    char comm_index[SYS_ADPT_MAX_COMM_STR_NAME_LEN+1];
    int i;

    if ((char) name[10] != SNMPCOMMUNITYSECURITYNAME)
    {
        return SNMP_ERR_NOTWRITABLE;
    }

    if (name_len-11 > SYS_ADPT_MAX_COMM_STR_NAME_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    for (i = 0; i<= name_len-11; i++)
    {
        comm_index[i] = name[11+i];
    }
    comm_index[name_len-11]= '\0';

    switch ( action ) {
        case RESERVE1:
            if (var_val_type != ASN_OCTET_STR)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if ((var_val_len < 1 ) || (var_val_len >SYS_ADPT_MAX_COMM_STR_NAME_LEN))
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;

        case RESERVE2:
            /* Overwrite the set value to snmpCommunityEntry which will be used
             * in write_xxxRowStatus function.
             */
            strncpy((char *)snmpCommunityEntry.snmp_community_security_name, (char *)var_val, var_val_len);
            snmpCommunityEntry.snmp_community_security_name[var_val_len]= '\0';
            break;

        case FREE:
            /* Release any resources that have been allocated */
            break;

        case ACTION:
            /* For row creation, if row_status =0, mean that this is a normal
             * operation, we do the normal set operation, otherwise it is a row
             * creation operation, will do nothing here, and the overall entry
             * will perform in the write_xxxRowStatus function.
             */
            if (snmpCommunityEntry.snmp_community_status == 0)
            {
                if (SNMP_MGR_SetSnmpCommunitySecurityName(comm_index, snmpCommunityEntry.snmp_community_security_name) != SNMP_MGR_ERROR_OK)
                {
                    return SNMP_ERR_COMMITFAILED;
                }
            }
            break;

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }

    return SNMP_ERR_NOERROR;
}

int
write_snmpCommunityContextEngineID(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    char comm_index[SYS_ADPT_MAX_COMM_STR_NAME_LEN+1];
    int i;

    if ((char) name[10] != SNMPCOMMUNITYCONTEXTENGINEID)
    {
        return SNMP_ERR_NOTWRITABLE;
    }

     if (name_len-11 > SYS_ADPT_MAX_COMM_STR_NAME_LEN+1)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    for (i = 0; i<= name_len-11; i++)
    {
        comm_index[i] = name[11+i];
    }
    comm_index[name_len-11]= '\0';

    switch ( action ) {
        case RESERVE1:
            if (var_val_type != ASN_OCTET_STR)
            {
                return SNMP_ERR_WRONGTYPE;
            }

            if (   (var_val_len < 5)
                || (var_val_len > MAXSIZE_snmpCommunityContextEngineID))
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;

        case RESERVE2:
            /* Overwrite the set value to snmpCommunityEntry which will be used
             * in write_xxxRowStatus function.
             */
            snmpCommunityEntry.snmp_community_engine_id_length = var_val_len;
            memcpy(snmpCommunityEntry.snmp_community_context_engine_id, var_val, var_val_len);
            break;

        case FREE:
            /* Release any resources that have been allocated */
            break;

        case ACTION:
            /* For row creation, if row_status =0, mean that this is a normal
             * operation, we do the normal set operation, otherwise it is a row
             * creation operation, will do nothing here, and the overall entry
             * will perform in the write_xxxRowStatus function.
             */
            if (snmpCommunityEntry.snmp_community_status == 0)
            {
                if (SNMP_MGR_SetSnmpCommunityContextEngineID(comm_index, snmpCommunityEntry.snmp_community_context_engine_id) != SNMP_MGR_ERROR_OK)
                {
                    return SNMP_ERR_COMMITFAILED;
                }
            }
            break;

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }

    return SNMP_ERR_NOERROR;
}

int
write_snmpCommunityContextName(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    char comm_index[SYS_ADPT_MAX_COMM_STR_NAME_LEN+1];
    int i;

    if ((char) name[10] != SNMPCOMMUNITYCONTEXTNAME)
    {
        return SNMP_ERR_NOTWRITABLE;
    }

    if (name_len-11 > SYS_ADPT_MAX_COMM_STR_NAME_LEN+1)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    for (i = 0; i<= name_len-11; i++)
    {
        comm_index[i] = name[11+i];
    }
    comm_index[name_len-11]= '\0';

    switch ( action ) {
        case RESERVE1:
            if (var_val_type != ASN_OCTET_STR) {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len >= MAXSIZE_snmpCommunityContextName) {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;

        case RESERVE2:
            /* Overwrite the set value to snmpCommunityEntry which will be used
             * in write_xxxRowStatus function.
             */
            strncpy((char *)snmpCommunityEntry.snmp_community_context_name, (char *)var_val, var_val_len);
            snmpCommunityEntry.snmp_community_context_name[var_val_len]= '\0';
            break;

        case FREE:
            /* Release any resources that have been allocated */
            break;

        case ACTION:
            /* For row creation, if row_status =0, mean that this is a normal
             * operation, we do the normal set operation, otherwise it is a row
             * creation operation, will do nothing here, and the overall entry
             * will perform in the write_xxxRowStatus function.
             */
            if (snmpCommunityEntry.snmp_community_status == 0)
            {
                if (SNMP_MGR_SetSnmpCommunityContextName(comm_index, snmpCommunityEntry.snmp_community_context_name) != SNMP_MGR_ERROR_OK)
                {
                    return SNMP_ERR_COMMITFAILED;
                }
            }
            break;

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }

    return SNMP_ERR_NOERROR;
}

int
write_snmpCommunityTransportTag(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    char comm_index[SYS_ADPT_MAX_COMM_STR_NAME_LEN+1];
    int i;

    if ((char) name[10] != SNMPCOMMUNITYTRANSPORTTAG)
    {
        return SNMP_ERR_NOTWRITABLE;
    }

    if (name_len-11 > SYS_ADPT_MAX_COMM_STR_NAME_LEN+1)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    for (i = 0; i<= name_len-11; i++)
    {
        comm_index[i] = name[11+i];
    }
    comm_index[name_len-11]= '\0';

    switch ( action ) {
        case RESERVE1:
            if (var_val_type != ASN_OCTET_STR) {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len >MAXSIZE_snmpCommunityTransportTag) {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;

        case RESERVE2:
            /* Overwrite the set value to snmpCommunityEntry which will be used
             * in write_xxxRowStatus function.
             */
            strncpy((char *)snmpCommunityEntry.snmp_community_transport_tag, (char *)var_val, var_val_len);
            snmpCommunityEntry.snmp_community_transport_tag[var_val_len]= '\0';
            break;

        case FREE:
            /* Release any resources that have been allocated */
            break;

        case ACTION:
            /* For row creation, if row_status =0, mean that this is a normal
             * operation, we do the normal set operation, otherwise it is a row
             * creation operation, will do nothing here, and the overall entry
             * will perform in the write_xxxRowStatus function.
             */
            if (snmpCommunityEntry.snmp_community_status == 0)
            {
                if (SNMP_MGR_SetSnmpCommunityTransportTag(comm_index, snmpCommunityEntry.snmp_community_transport_tag) != SNMP_MGR_ERROR_OK)
                {
                    return SNMP_ERR_COMMITFAILED;
                }
            }
            break;

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }

    return SNMP_ERR_NOERROR;
}

int
write_snmpCommunityStorageType(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    char comm_index[SYS_ADPT_MAX_COMM_STR_NAME_LEN+1];
    int i;

    if ((char) name[10] != SNMPCOMMUNITYSTORAGETYPE)
    {
        return SNMP_ERR_NOTWRITABLE;
    }

    if (name_len-11 > SYS_ADPT_MAX_COMM_STR_NAME_LEN+1)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    for (i = 0; i<= name_len-11; i++)
    {
        comm_index[i] = name[11+i];
    }
    comm_index[name_len-11]= '\0';

    switch ( action ) {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER) {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                return SNMP_ERR_WRONGLENGTH;
            }
            value = *(long *)var_val;
            if ((value <1) || (value >5))
                return SNMP_ERR_WRONGVALUE;

            break;

        case RESERVE2:
            /* Overwrite the set value to snmpCommunityEntry which will be used
             * in write_xxxRowStatus function.
             */
            snmpCommunityEntry.snmp_community_storage_type = *(long *)var_val;
            break;

        case FREE:
            /* Release any resources that have been allocated */
            break;

        case ACTION:
            /* For row creation, if row_status =0, mean that this is a normal
             * operation, we do the normal set operation, otherwise it is a row
             * creation operation, will do nothing here, and the overall entry
             * will perform in the write_xxxRowStatus function.
             */
            if (snmpCommunityEntry.snmp_community_status == 0)
            {
                if (SNMP_MGR_SetSnmpCommunityStorageType(comm_index, snmpCommunityEntry.snmp_community_storage_type) != SNMP_MGR_ERROR_OK)
                {
                    return SNMP_ERR_WRONGVALUE;
                }
            }
            break;

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }

    return SNMP_ERR_NOERROR;
}

int
write_snmpCommunityStatus(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    char comm_index[SYS_ADPT_MAX_COMM_STR_NAME_LEN+1];
    int i;

    if ((char) name[10] != SNMPCOMMUNITYSTATUS)
    {
        return SNMP_ERR_NOTWRITABLE;
    }

    if (name_len-11 > SYS_ADPT_MAX_COMM_STR_NAME_LEN+1)
    {
        return SNMP_ERR_WRONGLENGTH;
    }


    for (i = 0; i<= name_len-11; i++)
    {
        comm_index[i] = name[11+i];
    }
    comm_index[name_len-11]= '\0';

    switch ( action ) {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER) {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;

        case RESERVE2:
            /* Overwrite the set value to snmpCommunityEntry which will be used
             * in write_xxxRowStatus function.
             */
            if ((*(long *)var_val < VAL_snmpCommunityStatus_active) || (*(long *)var_val > VAL_snmpCommunityStatus_destroy))
                return SNMP_ERR_WRONGVALUE;

            snmpCommunityEntry.snmp_community_status = *(long *)var_val;
            break;

        case FREE:
            /* Release any resources that have been allocated */
            break;

        case ACTION:
        {
            /* We perform the row creation here. The accept operations are
             * createAndGo, active and destroy only. The created entry is not
             * allow for modify because the entry index must be identical to
             * snmpCommunityName.
             */
            switch (snmpCommunityEntry.snmp_community_status)
            {
                case VAL_snmpCommunityStatus_createAndGo:
                    strcpy(snmpCommunityEntry.snmp_community_index, (char *)comm_index);
                    if (SNMP_MGR_SetSnmpCommunityEntry(&snmpCommunityEntry) != SNMP_MGR_ERROR_OK)
                    {
                        return SNMP_ERR_COMMITFAILED;
                    }
                    break;

                case VAL_snmpCommunityStatus_active:
                case VAL_snmpCommunityStatus_destroy:
                    if (SNMP_MGR_SetSnmpCommunityStatus(comm_index, snmpCommunityEntry.snmp_community_status) != SNMP_MGR_ERROR_OK)
                    {
                        return SNMP_ERR_COMMITFAILED;
                    }
                    break;

                default:
                    return SNMP_ERR_COMMITFAILED;
            }
            break;
        }

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }

    return SNMP_ERR_NOERROR;
}
