/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.scalar.conf,v 1.5 2002/07/18 14:18:52 dts12 Exp $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "rfc_2013.h"

#include "sysORTable.h"
#include "sys_type.h"
#include "snmp_mgr.h"

#include "l_prefix.h"

#include "ipal_types.h"
#include "ipal_if.h"

/** Initializes the udp module */
void
init_udp(void)
{
     oid             udp_module_oid[] = { SNMP_OID_MIB2, 7 };

    static oid udpInDatagrams_oid[] = { 1,3,6,1,2,1,7,1, 0 };
    static oid udpInErrors_oid[] = { 1,3,6,1,2,1,7,3, 0 };
    static oid udpOutDatagrams_oid[] = { 1,3,6,1,2,1,7,4, 0 };
    static oid udpNoPorts_oid[] = { 1,3,6,1,2,1,7,2, 0 };

  DEBUGMSGTL(("udp", "Initializing\n"));

    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("udpInDatagrams",
                                         get_udpInDatagrams,
                                         udpInDatagrams_oid,
                                         OID_LENGTH(udpInDatagrams_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("udpInErrors",
                                         get_udpInErrors,
                                         udpInErrors_oid,
                                         OID_LENGTH(udpInErrors_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("udpOutDatagrams",
                                         get_udpOutDatagrams,
                                         udpOutDatagrams_oid,
                                         OID_LENGTH(udpOutDatagrams_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("udpNoPorts",
                                         get_udpNoPorts,
                                         udpNoPorts_oid,
                                         OID_LENGTH(udpNoPorts_oid),
                                         HANDLER_CAN_RONLY));

      REGISTER_SYSOR_ENTRY(udp_module_oid,
                         "The MIB module to describe  UDP MIB.");
}

int
get_udpInDatagrams(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
	struct udp_mib udpstat;

    if (IPAL_IF_GetAllUdpStatistic(&udpstat)!= IPAL_RESULT_OK)
	    return SNMP_ERR_GENERR;

    long_return = udpstat.udpInDatagrams;

    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *)&long_return, sizeof(long_return));
            break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_udpInErrors(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

	struct udp_mib udpstat;

    if (IPAL_IF_GetAllUdpStatistic(&udpstat)!= IPAL_RESULT_OK)
	    return SNMP_ERR_GENERR;

    long_return = udpstat.udpInErrors;

    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *)&long_return, sizeof(long_return));
            break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_udpOutDatagrams(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    struct udp_mib udpstat;

    if (IPAL_IF_GetAllUdpStatistic(&udpstat)!= IPAL_RESULT_OK)
	    return SNMP_ERR_GENERR;

    long_return = udpstat.udpOutDatagrams;

    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *)&long_return, sizeof(long_return));
            break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_udpNoPorts(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    struct udp_mib udpstat;

    if (IPAL_IF_GetAllUdpStatistic(&udpstat)!= IPAL_RESULT_OK)
	    return SNMP_ERR_GENERR;

    long_return = udpstat.udpNoPorts;

    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *)&long_return, sizeof(long_return));
            break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

/*
 * udpTable_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */
//static oid             udpTable_variables_oid[] = { SNMP_OID_MIB2, 7 };
oid udpTable_variables_oid[] = { 1,3,6,1,2,1,7};

/*
 * variable4 udpTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */

struct variable3 udpTable_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */


{UDPLOCALADDRESS,  ASN_IPADDRESS,  RONLY,   var_udpTable, 3,  { 5, 1, 1 }},
{UDPLOCALPORT,  ASN_INTEGER,  RONLY,   var_udpTable, 3,  { 5, 1, 2 }},
};
/*    (L = length of the oidsuffix) */


/** Initializes the udpTable module */
void
init_udpTable(void)
{

    DEBUGMSGTL(("udpTable", "Initializing\n"));

    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("udpTable", udpTable_variables, variable3,
               udpTable_variables_oid);

    /* place any other initialization junk you need here */
}


static int
header_udpTable(struct variable *vp,
               oid * name,
               size_t * length,
               int exact, size_t * var_len, WriteMethod ** write_method,
               UI32_T *index1, UI32_T *index2)
{
#define UDPENTRY_NAME_LENGTH	10
    oid             newname[MAX_OID_LEN];
    int             result;
   IPAL_IF_Udpv4Entry_T entry;
   UI32_T localIndex1=0, localIndex2 = 0;
   BOOL_T return_val;
   oid  next_inst[5];


     memcpy((char *) newname, (char *) vp->name,
           (int) vp->namelen * sizeof(oid));
    /*
     * find "next" interface
     */
    memset(  &entry, 0 , sizeof(entry));

    /*
     * find "next" interface
     */

    while ((return_val=IPAL_IF_GetNextUdpEntry(&entry)) == IPAL_RESULT_OK)
    {
       localIndex1 = entry.udp_local_address;
       localIndex2 =  entry.udp_local_port;
       SNMP_MGR_BindIpInstance( localIndex1, 0, next_inst);
       next_inst[4]= localIndex2;

        memcpy( (char*)&newname[UDPENTRY_NAME_LENGTH], (char*) next_inst,  5*sizeof(oid));
        result =
            snmp_oid_compare(name, *length, newname,
                             (int) vp->namelen +5);
        if ((exact && (result == 0)) || (!exact && (result < 0)))
            break;
    }
    if (return_val != IPAL_RESULT_OK)
    {
        DEBUGMSGTL(("mibII/interfaces", "... index out of range\n"));
        return MATCH_FAILED;
    }
    memcpy((char *) name, (char *) newname,
           ((int) vp->namelen + 5) * sizeof(oid));
    *write_method =0;
    *length = vp->namelen + 5;
    *var_len = sizeof(long);    /* default to 'long' results */

    *index1 = localIndex1;
    *index2 = next_inst[4];
     return TRUE;
}



/*
 * var_udpTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *
var_udpTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{
    /* variables we may use later */

    UI32_T index1, index2, retval;

    IPAL_IF_Udpv4Entry_T entry;
    static u_long   ulret;





    memset( &entry, 0, sizeof(entry));

     retval  = header_udpTable(vp, name, length, exact, var_len, write_method,  &index1,& index2);

    if (retval == MATCH_FAILED)
        return NULL;


  entry.udp_local_address =index1;
  entry.udp_local_port = index2;


   if (IPAL_IF_GetUdpEntry( &entry)!= IPAL_RESULT_OK)
            return NULL;


    /*
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
    case UDPLOCALADDRESS:
        *var_len = sizeof(ipaddr_return);
        ipaddr_return  = entry.udp_local_address;
        return (u_char*) &ipaddr_return;
    case UDPLOCALPORT:
        ulret  = entry.udp_local_port;
        return (u_char*) &ulret;
    default:
      ERROR_MSG("");
    }
    return NULL;
}
