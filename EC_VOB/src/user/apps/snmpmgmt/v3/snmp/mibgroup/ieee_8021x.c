/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.scalar.conf,v 1.5 2002/07/18 14:18:52 dts12 Exp $
 */
#include "sys_cpnt.h"
#if (SYS_CPNT_DOT1X == TRUE)
#include "sysfun.h"
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "ieee_8021x.h"
#include "sysORTable.h"
#include "leaf_ieee8021x.h"
#include "1x_mgr.h"

#include "sys_type.h"
#include "snmp_mgr.h"

#if (SYS_CPNT_NETACCESS == TRUE)
    #include "netaccess_type.h"
    #include "netaccess_pmgr.h"
#else
    #include "1x_om.h"
    #include "1x_pmgr.h"
    #include "1x_pom.h"
#endif

/** Initializes the dot1xPaeSystem module */
void
init_dot1xPaeSystem(void)
{
    oid             dot1x_module_oid[] = { 1, 0, 8802, 1, 1 };
    static oid      dot1xPaeSystemAuthControl_oid[] =
        { 1, 0, 8802, 1, 1, 1, 1, 1, 1, 0 };

    DEBUGMSGTL(("dot1xPaeSystem", "Initializing\n"));

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("dot1xPaeSystemAuthControl",
                               do_dot1xPaeSystemAuthControl,
                               dot1xPaeSystemAuthControl_oid,
                               OID_LENGTH(dot1xPaeSystemAuthControl_oid),
                               HANDLER_CAN_RWRITE));

    REGISTER_SYSOR_ENTRY(dot1x_module_oid,
                         "The IEEE 802.1X MIB.");
}

int
do_dot1xPaeSystemAuthControl(netsnmp_mib_handler *handler,
                             netsnmp_handler_registration *reginfo,
                             netsnmp_agent_request_info *reqinfo,
                             netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode)
    {
        case MODE_GET:
        {
            UI32_T dot1xPaeSystemAuthControl;

#if (SYS_CPNT_NETACCESS == TRUE)
            NETACCESS_PMGR_GetDot1xSystemAuthControl(&dot1xPaeSystemAuthControl);
#else
            dot1xPaeSystemAuthControl= DOT1X_POM_Get_SystemAuthControl();
#endif
            long_return = dot1xPaeSystemAuthControl;
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
        }
             break;
        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
            }
            break;

        case MODE_SET_RESERVE2:
            switch (*requests->requestvb->val.integer)
            {
                case VAL_dot1xPaeSystemAuthControl_enabled:
                    break;

                case VAL_dot1xPaeSystemAuthControl_disabled:
                    break;

                default:
                    netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
          {
               UI32_T dot1xPaeSystemAuthControl;
               dot1xPaeSystemAuthControl = (*requests->requestvb->val.integer);

#if (SYS_CPNT_NETACCESS == TRUE)
               if (NETACCESS_PMGR_SetDot1xSystemAuthControl(dot1xPaeSystemAuthControl) != TRUE)
#else
               if (DOT1X_PMGR_Set_SystemAuthControl(dot1xPaeSystemAuthControl) != TRUE)
#endif
               {
                   netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
               }
           }
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */

            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */

            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}



/*
 * dot1xPaePortTable_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid             dot1xPaePortTable_variables_oid[] =
    { 1, 0, 8802, 1, 1, 1, 1, 1 };

/*
 * variable4 dot1xPaePortTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */

struct variable3 dot1xPaePortTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */

#define DOT1XPAEPORTPROTOCOLVERSION		2
    {DOT1XPAEPORTPROTOCOLVERSION, ASN_UNSIGNED, RONLY,
     var_dot1xPaePortTable, 3, {2, 1, 2}},
#define DOT1XPAEPORTCAPABILITIES		3
    {DOT1XPAEPORTCAPABILITIES,ASN_OCTET_STR, RONLY, var_dot1xPaePortTable, 3,
     {2, 1, 3}},
#define DOT1XPAEPORTINITIALIZE		4
    {DOT1XPAEPORTINITIALIZE, ASN_INTEGER, RWRITE, var_dot1xPaePortTable, 3,
     {2, 1, 4}},
#define DOT1XPAEPORTREAUTHENTICATE		5
    {DOT1XPAEPORTREAUTHENTICATE, ASN_INTEGER, RWRITE,
     var_dot1xPaePortTable, 3, {2, 1, 5}},
};
/*
 * (L = length of the oidsuffix)
 */


/** Initializes the dot1xPaePortTable module */
void
init_dot1xPaePortTable(void)
{

    DEBUGMSGTL(("dot1xPaePortTable", "Initializing\n"));

    /*
     * register ourselves with the agent to handle our mib tree
     */
    REGISTER_MIB("dot1xPaePortTable", dot1xPaePortTable_variables,
                 variable3, dot1xPaePortTable_variables_oid);

    /*
     * place any other initialization junk you need here
     */
}


static int
header_dot1xPaePortTable(struct variable *vp,
               oid * name,
               size_t * length,
               int exact, size_t * var_len, WriteMethod ** write_method)
{
#define ENTRY_NAME_LENGTH	11
    oid             newname[MAX_OID_LEN];
    int    interface;
    DOT1X_PaePortEntry_T entry;

   UI32_T ifIndex = 0;
   BOOL_T return_val;
   int  result;


    memcpy((char *) newname, (char *) vp->name,
           (int) vp->namelen * sizeof(oid));
    /*
     * find "next" interface
     */

     memset( &entry, 0, sizeof(entry));

#if (SYS_CPNT_NETACCESS == TRUE)
     while (  (return_val= NETACCESS_PMGR_GetNextDot1xPaePortEntry( &ifIndex, &entry))==TRUE)
#else
     while (  (return_val= DOT1X_POM_Get_Next_Pae_Port_Table( &ifIndex, &entry))==TRUE)
#endif
     {

        newname[ENTRY_NAME_LENGTH] = (oid) ifIndex;
        result =
            snmp_oid_compare(name, *length, newname,
                             (int) vp->namelen + 1);

        if ((exact && (result == 0)) || (!exact && (result < 0)))
        {

            break;
         }
    }

    if (!return_val ) {
        return MATCH_FAILED;
    }


    memcpy((char *) name, (char *) newname,
           ((int) vp->namelen + 1) * sizeof(oid));
    *length = vp->namelen + 1;
    *write_method = 0;
    *var_len = sizeof(long);    /* default to 'long' results */
    interface = newname[ENTRY_NAME_LENGTH];

    return interface;
}



/*
 * var_dot1xPaePortTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_dot1xPaePortTable(struct variable *vp,
                      oid * name,
                      size_t * length,
                      int exact,
                      size_t * var_len, WriteMethod ** write_method)
{
    DOT1X_PaePortEntry_T entry;
    int             interface;


    memset( &entry, 0, sizeof(entry));
    interface =
        header_dot1xPaePortTable(vp, name, length, exact, var_len, write_method);
    if (interface == MATCH_FAILED)
        return NULL;

#if (SYS_CPNT_NETACCESS == TRUE)
    if (!NETACCESS_PMGR_GetDot1xPaePortEntry(interface, &entry))
#else
    if (!DOT1X_POM_Pae_Port_Table(interface, &entry))
#endif
        return NULL;


    /*
     * * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic)
    {
      case DOT1XPAEPORTPROTOCOLVERSION:
        long_return = entry.dot1xPaePortProtocolVersion;
        return (u_char *) & long_return;
      case DOT1XPAEPORTCAPABILITIES:
         long_return = L_STDLIB_Hton32(entry.dot1xPaePortCapabilities);
         *var_len = sizeof(long_return);
         return (u_char*) &long_return;
      case DOT1XPAEPORTINITIALIZE:
        *write_method = write_dot1xPaePortInitialize;
        long_return = entry.dot1xPaePortInitialize;
            return (u_char *) & long_return;
      case DOT1XPAEPORTREAUTHENTICATE:
        *write_method = write_dot1xPaePortReauthenticate;
         long_return = entry.dot1xPaePortReauthenticate;
        return (u_char *) & long_return;
    default:
        ERROR_MSG("");
    }
    return NULL;
}


int
write_dot1xPaePortInitialize(int action,
                             u_char * var_val,
                             u_char var_val_type,
                             size_t var_val_len,
                             u_char * statP, oid * name, size_t name_len)
{
    long value;
    int size;


    UI32_T  dot1xPaePortInitialize;

    if ((char) name[10] != DOT1XPAEPORTINITIALIZE)
     {
        return SNMP_ERR_NOTWRITABLE;
    }
    if (name_len!=  12)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    memcpy (& dot1xPaePortInitialize, var_val,  4);

    switch ( action )
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }

            if ((dot1xPaePortInitialize < VAL_dot1xPaePortInitialize_true)
                || (dot1xPaePortInitialize > VAL_dot1xPaePortInitialize_false))
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;


        case RESERVE2:
            size  = var_val_len;
            value = * (long *) var_val;

            break;

        case FREE:
             /* Release any resources that have been allocated */
            break;

        case ACTION:
#if (SYS_CPNT_NETACCESS == TRUE)
            if (NETACCESS_PMGR_SetDot1xPortPaePortInitialize(name[11], dot1xPaePortInitialize) != TRUE)
#else
            if (DOT1X_PMGR_Set_PaePortInitialize(name[11], dot1xPaePortInitialize) != TRUE)
#endif
       return SNMP_ERR_COMMITFAILED;
            break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
            break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot1xPaePortReauthenticate(int action,
                                 u_char * var_val,
                                 u_char var_val_type,
                                 size_t var_val_len,
                                 u_char * statP,
                                 oid * name, size_t name_len)
{
    long value;
    int size;


    UI32_T  dot1xPaePortReauthenticate;

    if ((char) name[10] != DOT1XPAEPORTREAUTHENTICATE)
    {
        return SNMP_ERR_NOTWRITABLE;
    }
    if (name_len!=  12)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    memcpy (& dot1xPaePortReauthenticate, var_val,  4);

    switch ( action )
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }

            if ((dot1xPaePortReauthenticate < VAL_dot1xPaePortReauthenticate_true)
                || (dot1xPaePortReauthenticate > VAL_dot1xPaePortReauthenticate_false))
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;


        case RESERVE2:
            size  = var_val_len;
            value = * (long *) var_val;

            break;

        case FREE:
             /* Release any resources that have been allocated */
            break;

        case ACTION:
            if (VAL_dot1xPaePortReauthenticate_true == dot1xPaePortReauthenticate)
            {
#if (SYS_CPNT_NETACCESS == TRUE)
                if (NETACCESS_PMGR_DoDot1xReAuthenticate(name[11]) != TRUE)
#else
                if (DOT1X_PMGR_Do_ReAuthenticate(name[11], NULL, 0) != TRUE)
#endif
                {
                    return SNMP_ERR_COMMITFAILED;
                }
            }
            break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
            break;
    }
    return SNMP_ERR_NOERROR;
}


/*
 * dot1xAuthStatsTable_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid             dot1xAuthStatsTable_variables_oid[] =
    { 1, 0, 8802, 1, 1, 1, 1, 2};

/*
 * variable4 dot1xAuthStatsTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */

struct variable3 dot1xAuthStatsTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */

#define DOT1XAUTHEAPOLFRAMESRX		1
    {DOT1XAUTHEAPOLFRAMESRX, ASN_COUNTER, RONLY, var_dot1xAuthStatsTable,
     3, {2, 1, 1}},
#define DOT1XAUTHEAPOLFRAMESTX		2
    {DOT1XAUTHEAPOLFRAMESTX, ASN_COUNTER, RONLY, var_dot1xAuthStatsTable,
     3, {2, 1, 2}},
#define DOT1XAUTHEAPOLSTARTFRAMESRX		3
    {DOT1XAUTHEAPOLSTARTFRAMESRX, ASN_COUNTER, RONLY,
     var_dot1xAuthStatsTable, 3, {2, 1, 3}},
#define DOT1XAUTHEAPOLLOGOFFFRAMESRX		4
    {DOT1XAUTHEAPOLLOGOFFFRAMESRX, ASN_COUNTER, RONLY,
     var_dot1xAuthStatsTable, 3, {2, 1, 4}},
#define DOT1XAUTHEAPOLRESPIDFRAMESRX		5
    {DOT1XAUTHEAPOLRESPIDFRAMESRX, ASN_COUNTER, RONLY,
     var_dot1xAuthStatsTable, 3, {2, 1, 5}},
#define DOT1XAUTHEAPOLRESPFRAMESRX		6
    {DOT1XAUTHEAPOLRESPFRAMESRX, ASN_COUNTER, RONLY,
     var_dot1xAuthStatsTable, 3, {2, 1, 6}},
#define DOT1XAUTHEAPOLREQIDFRAMESTX		7
    {DOT1XAUTHEAPOLREQIDFRAMESTX, ASN_COUNTER, RONLY,
     var_dot1xAuthStatsTable, 3, {2, 1, 7}},
#define DOT1XAUTHEAPOLREQFRAMESTX		8
    {DOT1XAUTHEAPOLREQFRAMESTX, ASN_COUNTER, RONLY,
     var_dot1xAuthStatsTable, 3, {2, 1, 8}},
#define DOT1XAUTHINVALIDEAPOLFRAMESRX		9
    {DOT1XAUTHINVALIDEAPOLFRAMESRX, ASN_COUNTER, RONLY,
     var_dot1xAuthStatsTable, 3, {2, 1, 9}},
#define DOT1XAUTHEAPLENGTHERRORFRAMESRX		10
    {DOT1XAUTHEAPLENGTHERRORFRAMESRX, ASN_COUNTER, RONLY,
     var_dot1xAuthStatsTable, 3, {2, 1, 10}},
#define DOT1XAUTHLASTEAPOLFRAMEVERSION		11
    {DOT1XAUTHLASTEAPOLFRAMEVERSION, ASN_UNSIGNED, RONLY,
     var_dot1xAuthStatsTable, 3, {2, 1, 11}},
#define DOT1XAUTHLASTEAPOLFRAMESOURCE		12
    {DOT1XAUTHLASTEAPOLFRAMESOURCE, ASN_OCTET_STR, RONLY,
     var_dot1xAuthStatsTable, 3, {2, 1, 12}},
};
/*
 * (L = length of the oidsuffix)
 */

/*
 * dot1xAuthConfigTable_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid             dot1xAuthConfigTable_variables_oid[] =
    { 1, 0, 8802, 1, 1, 1, 1, 2};

/*
 * variable4 dot1xAuthConfigTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */

struct variable3 dot1xAuthConfigTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */

#define DOT1XAUTHPAESTATE		1
    {DOT1XAUTHPAESTATE, ASN_INTEGER, RONLY, var_dot1xAuthConfigTable, 3,
     {1, 1, 1}},
#define DOT1XAUTHBACKENDAUTHSTATE		2
    {DOT1XAUTHBACKENDAUTHSTATE, ASN_INTEGER, RONLY,
     var_dot1xAuthConfigTable, 3, {1, 1, 2}},
#define DOT1XAUTHADMINCONTROLLEDDIRECTIONS		3
    {DOT1XAUTHADMINCONTROLLEDDIRECTIONS, ASN_INTEGER, RWRITE,
     var_dot1xAuthConfigTable, 3, {1, 1, 3}},
#define DOT1XAUTHOPERCONTROLLEDDIRECTIONS		4
    {DOT1XAUTHOPERCONTROLLEDDIRECTIONS, ASN_INTEGER, RONLY,
     var_dot1xAuthConfigTable, 3, {1, 1, 4}},
#define DOT1XAUTHAUTHCONTROLLEDPORTSTATUS		5
    {DOT1XAUTHAUTHCONTROLLEDPORTSTATUS, ASN_INTEGER, RONLY,
     var_dot1xAuthConfigTable, 3, {1, 1, 5}},
#define DOT1XAUTHAUTHCONTROLLEDPORTCONTROL		6
    {DOT1XAUTHAUTHCONTROLLEDPORTCONTROL, ASN_INTEGER, RWRITE,
     var_dot1xAuthConfigTable, 3, {1, 1, 6}},
#define DOT1XAUTHQUIETPERIOD		7
    {DOT1XAUTHQUIETPERIOD, ASN_UNSIGNED, RWRITE, var_dot1xAuthConfigTable,
     3, {1, 1, 7}},
#define DOT1XAUTHTXPERIOD		8
    {DOT1XAUTHTXPERIOD, ASN_UNSIGNED, RWRITE, var_dot1xAuthConfigTable, 3,
     {1, 1, 8}},
#define DOT1XAUTHSUPPTIMEOUT		9
    {DOT1XAUTHSUPPTIMEOUT, ASN_UNSIGNED, RWRITE, var_dot1xAuthConfigTable,
     3, {1, 1, 9}},
#define DOT1XAUTHSERVERTIMEOUT		10
    {DOT1XAUTHSERVERTIMEOUT, ASN_UNSIGNED, RWRITE,
     var_dot1xAuthConfigTable, 3, {1, 1, 10}},
#define DOT1XAUTHMAXREQ		11
    {DOT1XAUTHMAXREQ, ASN_UNSIGNED, RWRITE, var_dot1xAuthConfigTable, 3,
     {1, 1, 11}},
#define DOT1XAUTHREAUTHPERIOD		12
    {DOT1XAUTHREAUTHPERIOD, ASN_UNSIGNED, RWRITE, var_dot1xAuthConfigTable,
     3, {1, 1, 12}},
#define DOT1XAUTHREAUTHENABLED		13
    {DOT1XAUTHREAUTHENABLED, ASN_INTEGER, RWRITE, var_dot1xAuthConfigTable,
     3, {1, 1, 13}},
#define DOT1XAUTHKEYTXENABLED		14
    {DOT1XAUTHKEYTXENABLED, ASN_INTEGER, RWRITE, var_dot1xAuthConfigTable,
     3, {1, 1, 14}},
};
/*
 * (L = length of the oidsuffix)
 */


/** Initializes the dot1xAuthConfigTable module */
void
init_dot1xAuthConfigTable(void)
{

    DEBUGMSGTL(("dot1xAuthConfigTable", "Initializing\n"));

    /*
     * register ourselves with the agent to handle our mib tree
     */
    REGISTER_MIB("dot1xAuthConfigTable", dot1xAuthConfigTable_variables,
                 variable3, dot1xAuthConfigTable_variables_oid);

    /*
     * place any other initialization junk you need here
     */
}


static int
header_dot1xAuthConfigTable(struct variable *vp,
               oid * name,
               size_t * length,
               int exact, size_t * var_len, WriteMethod ** write_method)
{
#define ENTRY_NAME_LENGTH	11
    oid             newname[MAX_OID_LEN];
    int    interface;
    DOT1X_AuthConfigEntry_T entry;

   UI32_T ifIndex = 0;
   BOOL_T return_val;
   int  result;


    memcpy((char *) newname, (char *) vp->name,
           (int) vp->namelen * sizeof(oid));
    /*
     * find "next" interface
     */

     memset( &entry, 0, sizeof(entry));

#if (SYS_CPNT_NETACCESS == TRUE)
       while (  (return_val= NETACCESS_PMGR_GetNextDot1xAuthConfigEntry( &ifIndex, &entry))==TRUE)
#else
       while (  (return_val= DOT1X_POM_Get_Next_Auth_Config_Table( &ifIndex, &entry))==TRUE)
#endif
     {

        newname[ENTRY_NAME_LENGTH] = (oid) ifIndex;

        result =
            snmp_oid_compare(name, *length, newname,
                             (int) vp->namelen + 1);

        if ((exact && (result == 0)) || (!exact && (result < 0)))
        {

            break;
         }
    }

    if (!return_val ) {
        return MATCH_FAILED;
    }


    memcpy((char *) name, (char *) newname,
           ((int) vp->namelen + 1) * sizeof(oid));
    *length = vp->namelen + 1;
    *write_method = 0;
    *var_len = sizeof(long);    /* default to 'long' results */
    interface = newname[ENTRY_NAME_LENGTH];

    return interface;
}


/*
 * var_dot1xAuthConfigTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_dot1xAuthConfigTable(struct variable *vp,
                         oid * name,
                         size_t * length,
                         int exact,
                         size_t * var_len, WriteMethod ** write_method)
{
    DOT1X_AuthConfigEntry_T entry;
    int             interface;


    memset( &entry, 0, sizeof(entry));
    interface =
        header_dot1xAuthConfigTable(vp, name, length, exact, var_len, write_method);
    if (interface == MATCH_FAILED)
        return NULL;

#if (SYS_CPNT_NETACCESS == TRUE)
    if (!NETACCESS_PMGR_GetDot1xAuthConfigEntry(interface, &entry))
#else
    if (!DOT1X_POM_Auth_Config_Table(interface, &entry))
#endif
        return NULL;

    /*
     * * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
      case DOT1XAUTHPAESTATE:
        long_return = entry.dot1xAuthPaeState;
        return (u_char *) & long_return;
      case DOT1XAUTHBACKENDAUTHSTATE:
        long_return = entry.dot1xAuthBackendAuthState;
        return (u_char *) & long_return;
      case DOT1XAUTHADMINCONTROLLEDDIRECTIONS:
        *write_method = write_dot1xAuthAdminControlledDirections;
       long_return = entry.dot1xAuthAdminControlledDirections;
        return (u_char *) & long_return;
      case DOT1XAUTHOPERCONTROLLEDDIRECTIONS:
        long_return = entry.dot1xAuthOperControlledDirections;
        return (u_char *) & long_return;
      case DOT1XAUTHAUTHCONTROLLEDPORTSTATUS:
        long_return = entry.dot1xAuthAuthControlledPortStatus;
        return (u_char *) & long_return;
      case DOT1XAUTHAUTHCONTROLLEDPORTCONTROL:
        *write_method = write_dot1xAuthAuthControlledPortControl;
       long_return = entry.dot1xAuthAuthControlledPortControl;
        return (u_char *) & long_return;
      case DOT1XAUTHQUIETPERIOD:
        *write_method = write_dot1xAuthQuietPeriod;
        long_return = entry.dot1xAuthQuietPeriod;
        return (u_char *) & long_return;
      case DOT1XAUTHTXPERIOD:
        *write_method = write_dot1xAuthTxPeriod;
        long_return = entry.dot1xAuthTxPeriod;
        return (u_char *) & long_return;
      case DOT1XAUTHSUPPTIMEOUT:
        *write_method = write_dot1xAuthSuppTimeout;
        long_return = entry.dot1xAuthSuppTimeout;
        return (u_char *) & long_return;
      case DOT1XAUTHSERVERTIMEOUT:
        *write_method = write_dot1xAuthServerTimeout;
        long_return = entry.dot1xAuthServerTimeout;
        return (u_char *) & long_return;
      case DOT1XAUTHMAXREQ:
        *write_method = write_dot1xAuthMaxReq;
        long_return = entry.dot1xAuthMaxReq;
        return (u_char *) & long_return;
      case DOT1XAUTHREAUTHPERIOD:
        *write_method = write_dot1xAuthReAuthPeriod;
        long_return = entry.dot1xAuthReAuthPeriod;
        return (u_char *) & long_return;
      case DOT1XAUTHREAUTHENABLED:
        *write_method = write_dot1xAuthReAuthEnabled;
        long_return = entry.dot1xAuthReAuthEnabled;
        return (u_char *) & long_return;
      case DOT1XAUTHKEYTXENABLED:
        *write_method = write_dot1xAuthKeyTxEnabled;
        long_return = entry.dot1xAuthKeyTxEnabled;
        return (u_char *) & long_return;
    default:
        ERROR_MSG("");
    }
    return NULL;
}


int
write_dot1xAuthAdminControlledDirections(int action,
                                         u_char * var_val,
                                         u_char var_val_type,
                                         size_t var_val_len,
                                         u_char * statP,
                                         oid * name, size_t name_len)
{
    long value;
    int size;


    UI32_T  dot1xAuthAdminControlledDirections;

    if ((char) name[10] != DOT1XAUTHADMINCONTROLLEDDIRECTIONS)
     {
        return SNMP_ERR_NOTWRITABLE;
    }
    if (name_len!=  12)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    memcpy (& dot1xAuthAdminControlledDirections, var_val,  4);

    switch ( action )
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }

            if ((dot1xAuthAdminControlledDirections < VAL_dot1xAuthAdminControlledDirections_both)
                || (dot1xAuthAdminControlledDirections > VAL_dot1xAuthAdminControlledDirections_in))
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;


        case RESERVE2:
            size  = var_val_len;
            value = * (long *) var_val;

            break;

        case FREE:
             /* Release any resources that have been allocated */
            break;

        case ACTION:

#if (SYS_CPNT_NETACCESS == TRUE)
            if (NETACCESS_PMGR_SetDot1xPortAdminCtrlDirections(name[11], dot1xAuthAdminControlledDirections) != TRUE)
#else
            if (DOT1X_PMGR_Set_AdminCtrlDirections(name[11], dot1xAuthAdminControlledDirections) != TRUE)
#endif
                return SNMP_ERR_COMMITFAILED;
            break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
            break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot1xAuthAuthControlledPortControl(int action,
                                         u_char * var_val,
                                         u_char var_val_type,
                                         size_t var_val_len,
                                         u_char * statP,
                                         oid * name, size_t name_len)
{
    long value;
    int size;


    UI32_T  dot1xAuthAuthControlledPortControl;

    if ((char) name[10] != DOT1XAUTHAUTHCONTROLLEDPORTCONTROL)
     {
        return SNMP_ERR_NOTWRITABLE;
    }
    if (name_len!=  12)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    memcpy (& dot1xAuthAuthControlledPortControl, var_val,  4);

    switch ( action )
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }

            if ((dot1xAuthAuthControlledPortControl < VAL_dot1xAuthAuthControlledPortControl_forceUnauthorized)
                || (dot1xAuthAuthControlledPortControl > VAL_dot1xAuthAuthControlledPortControl_forceAuthorized))
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;


        case RESERVE2:
            size  = var_val_len;
            value = * (long *) var_val;

            break;

        case FREE:
             /* Release any resources that have been allocated */
            break;

        case ACTION:
#if (SYS_CPNT_NETACCESS == TRUE)
            if (!NETACCESS_PMGR_SetDot1xPortControlMode(name[11], dot1xAuthAuthControlledPortControl))
                return SNMP_ERR_COMMITFAILED;
#else
            if (!DOT1X_PMGR_Set_CtrlPortControl(name[11], dot1xAuthAuthControlledPortControl))
                return SNMP_ERR_COMMITFAILED;
#endif /* end of #if (SYS_CPNT_NETACCESS == TRUE) */

            break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
            break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot1xAuthQuietPeriod(int action,
                           u_char * var_val,
                           u_char var_val_type,
                           size_t var_val_len,
                           u_char * statP, oid * name, size_t name_len)
{
    UI32_T  dot1xAuthQuietPeriod;

    if ((char) name[10] != DOT1XAUTHQUIETPERIOD)
     {
        return SNMP_ERR_NOTWRITABLE;
    }
    if (name_len!=  12)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    dot1xAuthQuietPeriod = *(u_long *)var_val;

    switch ( action )
    {
        case RESERVE1:
            if (var_val_type != ASN_UNSIGNED)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(u_long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }

            if ((dot1xAuthQuietPeriod < 1) || (dot1xAuthQuietPeriod > 65535))
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;


        case RESERVE2:
            break;

        case FREE:
             /* Release any resources that have been allocated */
            break;

        case ACTION:

#if (SYS_CPNT_NETACCESS == TRUE)
            if (NETACCESS_PMGR_SetDot1xPortQuietPeriod(name[11], dot1xAuthQuietPeriod) != TRUE)
#else
            if (DOT1X_PMGR_Set_PortQuietPeriod(name[11], dot1xAuthQuietPeriod) != TRUE)
#endif
                return SNMP_ERR_COMMITFAILED;
            break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
            break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot1xAuthTxPeriod(int action,
                        u_char * var_val,
                        u_char var_val_type,
                        size_t var_val_len,
                        u_char * statP, oid * name, size_t name_len)
{
    UI32_T  dot1xAuthTxPeriod;

    if ((char) name[10] != DOT1XAUTHTXPERIOD)
    {
        return SNMP_ERR_NOTWRITABLE;
    }
    if (name_len!=  12)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    dot1xAuthTxPeriod = *(u_long *)var_val;

    switch ( action )
    {
        case RESERVE1:
            if (var_val_type != ASN_UNSIGNED)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(u_long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }

            if ((dot1xAuthTxPeriod <1) || (dot1xAuthTxPeriod >65535))
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;

        case RESERVE2:
            break;

        case FREE:
             /* Release any resources that have been allocated */
            break;

        case ACTION:

#if (SYS_CPNT_NETACCESS == TRUE)
            if (NETACCESS_PMGR_SetDot1xPortTxPeriod(name[11], dot1xAuthTxPeriod) != TRUE)
#else
            if (DOT1X_PMGR_Set_PortTxPeriod(name[11], dot1xAuthTxPeriod) != TRUE)
#endif
                return SNMP_ERR_COMMITFAILED;
            break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
            break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot1xAuthSuppTimeout(int action,
                           u_char * var_val,
                           u_char var_val_type,
                           size_t var_val_len,
                           u_char * statP, oid * name, size_t name_len)
{
    UI32_T  dot1xAuthSuppTimeout;

    if ((char) name[10] != DOT1XAUTHSUPPTIMEOUT)
    {
        return SNMP_ERR_NOTWRITABLE;
    }
    if (name_len!=  12)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    dot1xAuthSuppTimeout = *(u_long *)var_val;

    switch ( action )
    {
        case RESERVE1:
            if (var_val_type != ASN_UNSIGNED)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(u_long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }

            if ((dot1xAuthSuppTimeout < 1) || (dot1xAuthSuppTimeout > 65535))
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;


        case RESERVE2:
            break;

        case FREE:
             /* Release any resources that have been allocated */
            break;

        case ACTION:

#if (SYS_CPNT_NETACCESS == TRUE)
            if (NETACCESS_PMGR_SetDot1xPortAuthSuppTimeout(name[11], dot1xAuthSuppTimeout) != TRUE)
#else
            if (DOT1X_PMGR_Set_AuthSuppTimeout(name[11], dot1xAuthSuppTimeout) != TRUE)
#endif
                return SNMP_ERR_COMMITFAILED;
            break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
            break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot1xAuthServerTimeout(int action,
                             u_char * var_val,
                             u_char var_val_type,
                             size_t var_val_len,
                             u_char * statP, oid * name, size_t name_len)
{
    UI32_T  dot1xAuthServerTimeout;

    if ((char) name[10] != DOT1XAUTHSERVERTIMEOUT)
    {
        return SNMP_ERR_NOTWRITABLE;
    }
    if (name_len!=  12)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    dot1xAuthServerTimeout = *(u_long *)var_val;

    switch ( action )
    {
        case RESERVE1:
            if (var_val_type != ASN_UNSIGNED)
            {
              return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(u_long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }

            if ((dot1xAuthServerTimeout < 1) || (dot1xAuthServerTimeout > 65535))
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;


        case RESERVE2:
            break;

        case FREE:
             /* Release any resources that have been allocated */
            break;

        case ACTION:
#if (SYS_CPNT_NETACCESS == TRUE)
            if (NETACCESS_PMGR_SetDot1xPortAuthServerTimeout(name[11], dot1xAuthServerTimeout) != TRUE)
#else
            if (DOT1X_PMGR_Set_AuthServerTimeout(name[11], dot1xAuthServerTimeout) != TRUE)
#endif
                return SNMP_ERR_COMMITFAILED;
            break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
            break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot1xAuthMaxReq(int action,
                      u_char * var_val,
                      u_char var_val_type,
                      size_t var_val_len,
                      u_char * statP, oid * name, size_t name_len)
{
    UI32_T  dot1xAuthMaxReq;

    if ((char) name[10] != DOT1XAUTHMAXREQ)
    {
        return SNMP_ERR_NOTWRITABLE;
    }
    if (name_len!=  12)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    dot1xAuthMaxReq = *(u_long *)var_val;

    switch ( action )
    {
        case RESERVE1:
            if (var_val_type != ASN_UNSIGNED)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(u_long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }

            if ((dot1xAuthMaxReq < 1) || (dot1xAuthMaxReq > 10))
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;


        case RESERVE2:
            break;

        case FREE:
             /* Release any resources that have been allocated */
            break;

        case ACTION:
#if (SYS_CPNT_NETACCESS == TRUE)
            if (NETACCESS_PMGR_SetDot1xPortMaxReq(name[11], dot1xAuthMaxReq) != TRUE)
#else
            if (DOT1X_PMGR_Set_PortMaxReq(name[11], dot1xAuthMaxReq) != TRUE)
#endif
                return SNMP_ERR_COMMITFAILED;
            break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
            break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot1xAuthReAuthPeriod(int action,
                            u_char * var_val,
                            u_char var_val_type,
                            size_t var_val_len,
                            u_char * statP, oid * name, size_t name_len)
{
    UI32_T  dot1xAuthReAuthPeriod;

    if ((char) name[10] != DOT1XAUTHREAUTHPERIOD)
    {
        return SNMP_ERR_NOTWRITABLE;
    }
    if (name_len!=  12)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    dot1xAuthReAuthPeriod = *(u_long *)var_val;

    switch ( action )
    {
        case RESERVE1:
            if (var_val_type != ASN_UNSIGNED)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(u_long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }

            if ((dot1xAuthReAuthPeriod < 1) || (dot1xAuthReAuthPeriod > 65535))
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;


        case RESERVE2:
            break;

        case FREE:
             /* Release any resources that have been allocated */
            break;

        case ACTION:
#if (SYS_CPNT_NETACCESS == TRUE)
            if (NETACCESS_PMGR_SetDot1xPortReAuthPeriod(name[11], dot1xAuthReAuthPeriod) != TRUE)
#else
            if (DOT1X_PMGR_Set_PortReAuthPeriod(name[11], dot1xAuthReAuthPeriod) != TRUE)
#endif
                return SNMP_ERR_COMMITFAILED;
            break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
            break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot1xAuthReAuthEnabled(int action,
                             u_char * var_val,
                             u_char var_val_type,
                             size_t var_val_len,
                             u_char * statP, oid * name, size_t name_len)
{
    long value;
    int size;


    UI32_T  dot1xAuthReAuthEnabled;

    if ((char) name[10] != DOT1XAUTHREAUTHENABLED)
    {
        return SNMP_ERR_NOTWRITABLE;
    }
    if (name_len!=  12)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    memcpy (& dot1xAuthReAuthEnabled, var_val,  4);

    switch ( action )
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }


            if ((dot1xAuthReAuthEnabled < VAL_dot1xAuthReAuthEnabled_true)
                || (dot1xAuthReAuthEnabled > VAL_dot1xAuthReAuthEnabled_false))
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;


        case RESERVE2:
            size  = var_val_len;
            value = * (long *) var_val;

            break;

        case FREE:
             /* Release any resources that have been allocated */
            break;

        case ACTION:
#if (SYS_CPNT_NETACCESS == TRUE)
            if (NETACCESS_PMGR_SetDot1xPortReAuthEnabled(name[11], dot1xAuthReAuthEnabled) != TRUE)
#else
            if (DOT1X_PMGR_Set_PortReAuthEnabled(name[11], dot1xAuthReAuthEnabled) != TRUE)
#endif
                return SNMP_ERR_COMMITFAILED;
            break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot1xAuthKeyTxEnabled(int action,
                            u_char * var_val,
                            u_char var_val_type,
                            size_t var_val_len,
                            u_char * statP, oid * name, size_t name_len)
{
    long value;
    int size;


    UI32_T  dot1xAuthKeyTxEnabled;

    if ((char) name[10] != DOT1XAUTHKEYTXENABLED)
    {
        return SNMP_ERR_NOTWRITABLE;
    }
    if (name_len!=  12)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    memcpy (& dot1xAuthKeyTxEnabled, var_val,  4);

    switch ( action )
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }


            if ((dot1xAuthKeyTxEnabled < VAL_dot1xAuthKeyTxEnabled_true)
                || (dot1xAuthKeyTxEnabled > VAL_dot1xAuthKeyTxEnabled_false))
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;


        case RESERVE2:
            size  = var_val_len;
            value = * (long *) var_val;

            break;

        case FREE:
             /* Release any resources that have been allocated */
            break;

        case ACTION:
#if (SYS_CPNT_NETACCESS == TRUE)
            if (NETACCESS_PMGR_SetDot1xPortAuthTxEnabled(name[11], dot1xAuthKeyTxEnabled) != TRUE)
#else
            if (DOT1X_PMGR_Set_AuthTxEnabled(name[11], dot1xAuthKeyTxEnabled) != TRUE)
#endif
                return SNMP_ERR_COMMITFAILED;
            break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
            break;
    }
    return SNMP_ERR_NOERROR;
}


/** Initializes the dot1xAuthStatsTable module */
void
init_dot1xAuthStatsTable(void)
{

    DEBUGMSGTL(("dot1xAuthStatsTable", "Initializing\n"));

    /*
     * register ourselves with the agent to handle our mib tree
     */
    REGISTER_MIB("dot1xAuthStatsTable", dot1xAuthStatsTable_variables,
                 variable3, dot1xAuthStatsTable_variables_oid);

    /*
     * place any other initialization junk you need here
     */
}

static int
header_dot1xAuthStatsTable(struct variable *vp,
               oid * name,
               size_t * length,
               int exact, size_t * var_len, WriteMethod ** write_method)
{
#define ENTRY_NAME_LENGTH	11
    oid             newname[MAX_OID_LEN];
    int    interface;
    DOT1X_AuthStatsEntry_T entry;

    UI32_T ifIndex = 0;
    BOOL_T return_val;
    int  result;

    memcpy((char *) newname, (char *) vp->name,
           (int) vp->namelen * sizeof(oid));
    /*
     * find "next" interface
     */

    memset( &entry, 0, sizeof(entry));

#if (SYS_CPNT_NETACCESS == TRUE)
    while (  (return_val= NETACCESS_PMGR_GetNextDot1xAuthStatsEntry( &ifIndex, &entry))==TRUE)
#else
    while (  (return_val= DOT1X_POM_Get_Next_Auth_Stats_Table( &ifIndex, &entry))== TRUE)
#endif
    {
        newname[ENTRY_NAME_LENGTH] = (oid) ifIndex;

        result =
            snmp_oid_compare(name, *length, newname,
                             (int) vp->namelen + 1);

        if ((exact && (result == 0)) || (!exact && (result < 0)))
        {
            break;
        }
     }

    if (!return_val ) {
        return MATCH_FAILED;
    }


    memcpy((char *) name, (char *) newname,
           ((int) vp->namelen + 1) * sizeof(oid));
    *length = vp->namelen + 1;
    *write_method = 0;
    *var_len = sizeof(long);    /* default to 'long' results */
    interface = newname[ENTRY_NAME_LENGTH];

    return interface;
}

/*
 * var_dot1xAuthStatsTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_dot1xAuthStatsTable(struct variable *vp,
                        oid * name,
                        size_t * length,
                        int exact,
                        size_t * var_len, WriteMethod ** write_method)
{
    DOT1X_AuthStatsEntry_T entry;
    int             interface;


    memset( &entry, 0, sizeof(entry));
    interface =
        header_dot1xAuthStatsTable(vp, name, length, exact, var_len, write_method);
    if (interface == MATCH_FAILED)
        return NULL;

#if (SYS_CPNT_NETACCESS == TRUE)
    if (!NETACCESS_PMGR_GetDot1xAuthStatsEntry(interface, &entry))
#else
    if (!DOT1X_POM_Auth_Stats_Table(interface, &entry))
#endif
        return NULL;

    /*
     * * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
      case DOT1XAUTHEAPOLFRAMESRX:
        long_return = entry.dot1xAuthEapolFramesRx;
        return (u_char *) & long_return;
      case DOT1XAUTHEAPOLFRAMESTX:
        long_return = entry.dot1xAuthEapolFramesTx;
        return (u_char *) & long_return;
      case DOT1XAUTHEAPOLSTARTFRAMESRX:
        long_return = entry.dot1xAuthEapolStartFramesRx;
        return (u_char *) & long_return;
      case DOT1XAUTHEAPOLLOGOFFFRAMESRX:
        long_return = entry.dot1xAuthEapolLogoffFramesRx;
        return (u_char *) & long_return;
      case DOT1XAUTHEAPOLRESPIDFRAMESRX:
        long_return = entry.dot1xAuthEapolRespIdFramesRx;
        return (u_char *) & long_return;
      case DOT1XAUTHEAPOLRESPFRAMESRX:
        long_return = entry.dot1xAuthEapolRepsFramesRx;
        return (u_char *) & long_return;
      case DOT1XAUTHEAPOLREQIDFRAMESTX:
       long_return = entry.dot1xAuthEapolReqIdFramesTx;
        return (u_char *) & long_return;
      case DOT1XAUTHEAPOLREQFRAMESTX:
        long_return = entry.dot1xAuthEapolReqFramesTx;
        return (u_char *) & long_return;
      case DOT1XAUTHINVALIDEAPOLFRAMESRX:
        long_return = entry.dot1xAuthInvalidEapolFramesRx;
        return (u_char *) & long_return;
      case DOT1XAUTHEAPLENGTHERRORFRAMESRX:
        long_return = entry.dot1xAuthEapLengthErrorFramesRx;
        return (u_char *) & long_return;
      case DOT1XAUTHLASTEAPOLFRAMEVERSION:
        long_return = entry.dot1xAuthLastEapolFrameVersion;
        return (u_char *) & long_return;
      case DOT1XAUTHLASTEAPOLFRAMESOURCE:
         memcpy(return_buf,&entry.dot1xAuthLastEapolFramesSource, 6);
        *var_len = 6;
        return (u_char*) return_buf;
    default:
        ERROR_MSG("");
    }
    return NULL;
}


/*
 * dot1xAuthDiagTable_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid             dot1xAuthDiagTable_variables_oid[] =
    { 1, 0, 8802, 1, 1, 1, 1, 2};

/*
 * variable4 dot1xAuthDiagTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */

struct variable3 dot1xAuthDiagTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */

#define DOT1XAUTHENTERSCONNECTING		1
    {DOT1XAUTHENTERSCONNECTING, ASN_COUNTER, RONLY, var_dot1xAuthDiagTable,
     3, {3, 1, 1}},
#define DOT1XAUTHEAPLOGOFFSWHILECONNECTING		2
    {DOT1XAUTHEAPLOGOFFSWHILECONNECTING, ASN_COUNTER, RONLY,
     var_dot1xAuthDiagTable, 3, {3, 1, 2}},
#define DOT1XAUTHENTERSAUTHENTICATING		3
    {DOT1XAUTHENTERSAUTHENTICATING, ASN_COUNTER, RONLY,
     var_dot1xAuthDiagTable, 3, {3, 1, 3}},
#define DOT1XAUTHAUTHSUCCESSWHILEAUTHENTICATING		4
    {DOT1XAUTHAUTHSUCCESSWHILEAUTHENTICATING, ASN_COUNTER, RONLY,
     var_dot1xAuthDiagTable, 3, {3, 1, 4}},
#define DOT1XAUTHAUTHTIMEOUTSWHILEAUTHENTICATING		5
    {DOT1XAUTHAUTHTIMEOUTSWHILEAUTHENTICATING, ASN_COUNTER, RONLY,
     var_dot1xAuthDiagTable, 3, {3, 1, 5}},
#define DOT1XAUTHAUTHFAILWHILEAUTHENTICATING		6
    {DOT1XAUTHAUTHFAILWHILEAUTHENTICATING, ASN_COUNTER, RONLY,
     var_dot1xAuthDiagTable, 3, {3, 1, 6}},
#define DOT1XAUTHAUTHREAUTHSWHILEAUTHENTICATING		7
    {DOT1XAUTHAUTHREAUTHSWHILEAUTHENTICATING, ASN_COUNTER, RONLY,
     var_dot1xAuthDiagTable, 3, {3, 1, 7}},
#define DOT1XAUTHAUTHEAPSTARTSWHILEAUTHENTICATING		8
    {DOT1XAUTHAUTHEAPSTARTSWHILEAUTHENTICATING, ASN_COUNTER, RONLY,
     var_dot1xAuthDiagTable, 3, {3, 1, 8}},
#define DOT1XAUTHAUTHEAPLOGOFFWHILEAUTHENTICATING		9
    {DOT1XAUTHAUTHEAPLOGOFFWHILEAUTHENTICATING, ASN_COUNTER, RONLY,
     var_dot1xAuthDiagTable, 3, {3, 1, 9}},
#define DOT1XAUTHAUTHREAUTHSWHILEAUTHENTICATED		10
    {DOT1XAUTHAUTHREAUTHSWHILEAUTHENTICATED, ASN_COUNTER, RONLY,
     var_dot1xAuthDiagTable, 3, {3, 1, 10}},
#define DOT1XAUTHAUTHEAPSTARTSWHILEAUTHENTICATED		11
    {DOT1XAUTHAUTHEAPSTARTSWHILEAUTHENTICATED, ASN_COUNTER, RONLY,
     var_dot1xAuthDiagTable, 3, {3, 1, 11}},
#define DOT1XAUTHAUTHEAPLOGOFFWHILEAUTHENTICATED		12
    {DOT1XAUTHAUTHEAPLOGOFFWHILEAUTHENTICATED, ASN_COUNTER, RONLY,
     var_dot1xAuthDiagTable, 3, {3, 1, 12}},
#define DOT1XAUTHBACKENDRESPONSES		13
    {DOT1XAUTHBACKENDRESPONSES, ASN_COUNTER, RONLY, var_dot1xAuthDiagTable,
     3, {3, 1, 13}},
#define DOT1XAUTHBACKENDACCESSCHALLENGES		14
    {DOT1XAUTHBACKENDACCESSCHALLENGES, ASN_COUNTER, RONLY,
     var_dot1xAuthDiagTable, 3, {3, 1, 14}},
#define DOT1XAUTHBACKENDOTHERREQUESTSTOSUPPLICANT		15
    {DOT1XAUTHBACKENDOTHERREQUESTSTOSUPPLICANT, ASN_COUNTER, RONLY,
     var_dot1xAuthDiagTable, 3, {3, 1, 15}},
#define DOT1XAUTHBACKENDNONNAKRESPONSESFROMSUPPLICANT		16
    {DOT1XAUTHBACKENDNONNAKRESPONSESFROMSUPPLICANT, ASN_COUNTER, RONLY,
     var_dot1xAuthDiagTable, 3, {3, 1, 16}},
#define DOT1XAUTHBACKENDAUTHSUCCESSES		17
    {DOT1XAUTHBACKENDAUTHSUCCESSES, ASN_COUNTER, RONLY,
     var_dot1xAuthDiagTable, 3, {3, 1, 17}},
#define DOT1XAUTHBACKENDAUTHFAILS		18
    {DOT1XAUTHBACKENDAUTHFAILS, ASN_COUNTER, RONLY, var_dot1xAuthDiagTable,
     3, {3, 1, 18}},
};
/*
 * (L = length of the oidsuffix)
 */


/** Initializes the dot1xAuthDiagTable module */
void
init_dot1xAuthDiagTable(void)
{

    DEBUGMSGTL(("dot1xAuthDiagTable", "Initializing\n"));

    /*
     * register ourselves with the agent to handle our mib tree
     */
    REGISTER_MIB("dot1xAuthDiagTable", dot1xAuthDiagTable_variables,
                 variable3, dot1xAuthDiagTable_variables_oid);

    /*
     * place any other initialization junk you need here
     */
}

static int
header_dot1xAuthDiagTable(struct variable *vp,
               oid * name,
               size_t * length,
               int exact, size_t * var_len, WriteMethod ** write_method)
{
#define ENTRY_NAME_LENGTH	11
    oid             newname[MAX_OID_LEN];
    int    interface;
    DOT1X_AuthDiagEntry_T entry;

    UI32_T ifIndex = 0;
    BOOL_T return_val;
    int  result;


    memcpy((char *) newname, (char *) vp->name,
           (int) vp->namelen * sizeof(oid));
    /*
     * find "next" interface
     */

     memset( &entry, 0, sizeof(entry));

#if (SYS_CPNT_NETACCESS == TRUE)
     while (  (return_val= NETACCESS_PMGR_GetNextDot1xAuthDiagEntry( &ifIndex, &entry))==TRUE)
#else
     while (  (return_val= DOT1X_POM_Get_Next_Auth_Diag_Table( &ifIndex, &entry))==TRUE)
#endif
     {

        newname[ENTRY_NAME_LENGTH] = (oid) ifIndex;

        result =
            snmp_oid_compare(name, *length, newname,
                             (int) vp->namelen + 1);

        if ((exact && (result == 0)) || (!exact && (result < 0)))
        {

            break;
         }
    }

    if (!return_val ) {
        return MATCH_FAILED;
    }


    memcpy((char *) name, (char *) newname,
           ((int) vp->namelen + 1) * sizeof(oid));
    *length = vp->namelen + 1;
    *write_method = 0;
    *var_len = sizeof(long);    /* default to 'long' results */
    interface = newname[ENTRY_NAME_LENGTH];

    return interface;
}



/*
 * var_dot1xAuthDiagTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_dot1xAuthDiagTable(struct variable *vp,
                       oid * name,
                       size_t * length,
                       int exact,
                       size_t * var_len, WriteMethod ** write_method)
{
    DOT1X_AuthDiagEntry_T entry;
    int             interface;


    memset( &entry, 0, sizeof(entry));
    interface =
        header_dot1xAuthDiagTable(vp, name, length, exact, var_len, write_method);
    if (interface == MATCH_FAILED)
        return NULL;

#if (SYS_CPNT_NETACCESS == TRUE)
    if (!NETACCESS_PMGR_GetDot1xAuthDiagEntry(interface, &entry))
#else
    if (!DOT1X_POM_Auth_Diag_Table(interface, &entry))
#endif
        return NULL;

    /*
     * * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
      case DOT1XAUTHENTERSCONNECTING:
        long_return = entry.dot1xAuthEntersConnecting;
        return (u_char *) & long_return;
      case DOT1XAUTHEAPLOGOFFSWHILECONNECTING:
        long_return = entry.dot1xAuthEapLogoffsWhileConnecting;
        return (u_char *) & long_return;
      case DOT1XAUTHENTERSAUTHENTICATING:
        long_return = entry.dot1xAuthEntersAuthenticating;
        return (u_char *) & long_return;
      case DOT1XAUTHAUTHSUCCESSWHILEAUTHENTICATING:
        long_return = entry.dot1xAuthAuthSuccessWhileAuthenticating;
        return (u_char *) & long_return;
      case DOT1XAUTHAUTHTIMEOUTSWHILEAUTHENTICATING:
        long_return = entry.dot1xAuthAuthTimeoutsWhileAuthenticating;
        return (u_char *) & long_return;
      case DOT1XAUTHAUTHFAILWHILEAUTHENTICATING:
        long_return = entry.dot1xAuthAuthFailWhileAuthenticating;
        return (u_char *) & long_return;
      case DOT1XAUTHAUTHREAUTHSWHILEAUTHENTICATING:
        long_return = entry.dot1xAuthAuthReauthsWhileAuthenticating;
        return (u_char *) & long_return;
      case DOT1XAUTHAUTHEAPSTARTSWHILEAUTHENTICATING:
        long_return = entry.dot1xAuthAuthEapStartsWhileAuthenticating;
        return (u_char *) & long_return;
      case DOT1XAUTHAUTHEAPLOGOFFWHILEAUTHENTICATING:
        long_return = entry.dot1xAuthAuthEapLogoffWhileAuthenticating;
        return (u_char *) & long_return;
      case DOT1XAUTHAUTHREAUTHSWHILEAUTHENTICATED:
        long_return = entry.dot1xAuthAuthReauthsWhileAuthenticated;
        return (u_char *) & long_return;
      case DOT1XAUTHAUTHEAPSTARTSWHILEAUTHENTICATED:
        long_return = entry.dot1xAuthAuthEapStartsWhileAuthenticated;
        return (u_char *) & long_return;
      case DOT1XAUTHAUTHEAPLOGOFFWHILEAUTHENTICATED:
        long_return = entry.dot1xAuthAuthEapLogoffWhileAuthenticated;
        return (u_char *) & long_return;
      case DOT1XAUTHBACKENDRESPONSES:
        long_return = entry.dot1xAuthBackendResponses;
        return (u_char *) & long_return;
      case DOT1XAUTHBACKENDACCESSCHALLENGES:
        long_return = entry.dot1xAuthBackendAccessChallenges;
        return (u_char *) & long_return;
      case DOT1XAUTHBACKENDOTHERREQUESTSTOSUPPLICANT:
        long_return = entry.dot1xAuthBackendOtherRequestsToSupplicant;
        return (u_char *) & long_return;
      case DOT1XAUTHBACKENDNONNAKRESPONSESFROMSUPPLICANT:
        long_return = entry.dot1xAuthBackendNonNakResponsesFromSupplicant;
        return (u_char *) & long_return;
      case DOT1XAUTHBACKENDAUTHSUCCESSES:
        long_return = entry.dot1xAuthBackendAuthSuccesses;
        return (u_char *) & long_return;
      case DOT1XAUTHBACKENDAUTHFAILS:
        long_return = entry.dot1xAuthBackendAuthFails;
        return (u_char *) & long_return;
    default:
        ERROR_MSG("");
    }
    return NULL;
}




static int
header_dot1xAuthSessionStatsTable(struct variable *vp,
               oid * name,
               size_t * length,
               int exact, size_t * var_len, WriteMethod ** write_method);

/*
 * dot1xAuthSessionStatsTable_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid             dot1xAuthSessionStatsTable_variables_oid[] =
    { 1, 0, 8802, 1, 1, 1, 1, 2 };

/*
 * variable4 dot1xAuthSessionStatsTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */

struct variable3 dot1xAuthSessionStatsTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */

#define DOT1XAUTHSESSIONOCTETSRX		1
    {DOT1XAUTHSESSIONOCTETSRX, ASN_COUNTER64, RONLY,
     var_dot1xAuthSessionStatsTable, 3, {4, 1, 1}},
#define DOT1XAUTHSESSIONOCTETSTX		2
    {DOT1XAUTHSESSIONOCTETSTX, ASN_COUNTER64, RONLY,
     var_dot1xAuthSessionStatsTable, 3, {4, 1, 2}},
#define DOT1XAUTHSESSIONFRAMESRX		3
    {DOT1XAUTHSESSIONFRAMESRX, ASN_COUNTER, RONLY,
     var_dot1xAuthSessionStatsTable, 3, {4, 1, 3}},
#define DOT1XAUTHSESSIONFRAMESTX		4
    {DOT1XAUTHSESSIONFRAMESTX, ASN_COUNTER, RONLY,
     var_dot1xAuthSessionStatsTable, 3, {4, 1, 4}},
#define DOT1XAUTHSESSIONID		5
    {DOT1XAUTHSESSIONID, ASN_OCTET_STR, RONLY,
     var_dot1xAuthSessionStatsTable, 3, {4, 1, 5}},
#define DOT1XAUTHSESSIONAUTHENTICMETHOD		6
    {DOT1XAUTHSESSIONAUTHENTICMETHOD, ASN_INTEGER, RONLY,
     var_dot1xAuthSessionStatsTable, 3, {4, 1, 6}},
#define DOT1XAUTHSESSIONTIME		7
    {DOT1XAUTHSESSIONTIME, ASN_TIMETICKS, RONLY,
     var_dot1xAuthSessionStatsTable, 3, {4, 1, 7}},
#define DOT1XAUTHSESSIONTERMINATECAUSE		8
    {DOT1XAUTHSESSIONTERMINATECAUSE, ASN_INTEGER, RONLY,
     var_dot1xAuthSessionStatsTable, 3, {4, 1, 8}},
#define DOT1XAUTHSESSIONUSERNAME		9
    {DOT1XAUTHSESSIONUSERNAME, ASN_OCTET_STR, RONLY,
     var_dot1xAuthSessionStatsTable, 3, {4, 1, 9}},
};
/*
 * (L = length of the oidsuffix)
 */


/** Initializes the dot1xAuthSessionStatsTable module */
void
init_dot1xAuthSessionStatsTable(void)
{

    DEBUGMSGTL(("dot1xAuthSessionStatsTable", "Initializing\n"));

    /*
     * register ourselves with the agent to handle our mib tree
     */
    REGISTER_MIB("dot1xAuthSessionStatsTable",
                 dot1xAuthSessionStatsTable_variables, variable3,
                 dot1xAuthSessionStatsTable_variables_oid);

    /*
     * place any other initialization junk you need here
     */
}

static int
header_dot1xAuthSessionStatsTable(struct variable *vp,
               oid * name,
               size_t * length,
               int exact, size_t * var_len, WriteMethod ** write_method)
{
#define ENTRY_NAME_LENGTH	11
    oid             newname[MAX_OID_LEN];
    int    interface;
    DOT1X_AuthSessionStatsEntry_T entry;

   UI32_T ifIndex = 0;
   BOOL_T return_val;
   int  result;


    memcpy((char *) newname, (char *) vp->name,
           (int) vp->namelen * sizeof(oid));
    /*
     * find "next" interface
     */

     memset( &entry, 0, sizeof(entry));
#if (SYS_CPNT_NETACCESS == TRUE)
     while (  (return_val= NETACCESS_PMGR_GetNextDot1xSessionStatsEntry( &ifIndex, &entry))==TRUE)
#else
     while (  (return_val= DOT1X_PMGR_Get_Next_Session_Stats_Table( &ifIndex, &entry))==TRUE)
#endif
     {

        newname[ENTRY_NAME_LENGTH] = (oid) ifIndex;

        result =
            snmp_oid_compare(name, *length, newname,
                             (int) vp->namelen + 1);

        if ((exact && (result == 0)) || (!exact && (result < 0)))
        {

            break;
         }
    }

    if (!return_val ) {
        return MATCH_FAILED;
    }


    memcpy((char *) name, (char *) newname,
           ((int) vp->namelen + 1) * sizeof(oid));
    *length = vp->namelen + 1;
    *write_method = 0;
    *var_len = sizeof(long);    /* default to 'long' results */
    interface = newname[ENTRY_NAME_LENGTH];

    return interface;
}


/*
 * var_dot1xAuthSessionStatsTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_dot1xAuthSessionStatsTable(struct variable *vp,
                               oid * name,
                               size_t * length,
                               int exact,
                               size_t * var_len,
                               WriteMethod ** write_method)
{
    DOT1X_AuthSessionStatsEntry_T entry;

    int             interface;


    memset( &entry, 0, sizeof(entry));
    interface =
        header_dot1xAuthSessionStatsTable(vp, name, length, exact, var_len, write_method);
    if (interface == MATCH_FAILED)
        return NULL;

#if (SYS_CPNT_NETACCESS == TRUE)
    if (!NETACCESS_PMGR_GetDot1xSessionStatsEntry(interface, &entry))
#else
    if (!DOT1X_PMGR_Session_Stats_Table(interface, &entry))
#endif
        return NULL;

    /*
     * * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
      case DOT1XAUTHSESSIONOCTETSRX:
        SNMP_MGR_UI64_T_TO_COUNTER64(long64_return, entry.dot1xAuthSessionOctetsRx);
        *var_len = sizeof(long64_return);
        return (u_char*) &long64_return;
      case DOT1XAUTHSESSIONOCTETSTX:
        SNMP_MGR_UI64_T_TO_COUNTER64(long64_return, entry.dot1xAuthSessionOctetsTx);
        *var_len = sizeof(long64_return);
        return (u_char*) &long64_return;
      case DOT1XAUTHSESSIONFRAMESRX:
        long_return = entry.dot1xAuthSessionFramesRx;
        return (u_char *) & long_return;
      case DOT1XAUTHSESSIONFRAMESTX:
        long_return = entry.dot1xAuthSessionFramesTx;
        return (u_char *) & long_return;
      case DOT1XAUTHSESSIONID:
        strncpy((char *)return_buf, (char *)entry.dot1xAuthSessionId, DOT1X_SESSION_ID_LENGTH);
        return_buf[DOT1X_SESSION_ID_LENGTH] = '\0';
        *var_len = strlen((char *)return_buf);
        return (u_char *) return_buf;
      case DOT1XAUTHSESSIONAUTHENTICMETHOD:
        long_return = entry.dot1xAuthSessionAuthenticMethod;
        return (u_char *) & long_return;
      case DOT1XAUTHSESSIONTIME:
        long_return = entry.dot1xAuthSessionTime;
        return (u_char *) & long_return;
      case DOT1XAUTHSESSIONTERMINATECAUSE:
        long_return = entry.dot1xAuthSessionTerminateCause;
        return (u_char *) & long_return;
      case DOT1XAUTHSESSIONUSERNAME:
        strncpy((char *)return_buf, (char *)entry.dot1xAuthSessionUserName, DOT1X_USERNAME_LENGTH);
        return_buf[DOT1X_USERNAME_LENGTH] = '\0';
        *var_len = strlen((char *)return_buf);
        return (u_char *) return_buf;
    default:
        ERROR_MSG("");
    }
    return NULL;
}

#endif
