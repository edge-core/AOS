/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.scalar.conf,v 1.5 2002/07/18 14:18:52 dts12 Exp $
 */
#include "sys_cpnt.h"
#if (SYS_CPNT_BRIDGE == TRUE)
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "rfc_2674q.h"
#include "sys_type.h"
#include "sysORTable.h"
#include "vlan_mgr.h"
#include "amtr_mgr.h"
#include "sys_adpt.h"
#include "leaf_2674q.h"
#include "vlan_pmgr.h"
#include "vlan_pom.h"
#include "vlan_lib.h"
#include "amtr_pmgr.h"
#include "snmp_mgr.h"
#include "l_snmp.h"
/** Initializes the dot1qBase module */
void
init_dot1qBase(void)
{
      oid             dot1qBridge_oid[] = { SNMP_OID_MIB2, 17,7 };
    static oid dot1qVlanVersionNumber_oid[] = { 1,3,6,1,2,1,17,7,1,1,1, 0 };
    static oid dot1qMaxSupportedVlans_oid[] = { 1,3,6,1,2,1,17,7,1,1,3, 0 };
    static oid dot1qGvrpStatus_oid[] = { 1,3,6,1,2,1,17,7,1,1,5, 0 };
    static oid dot1qMaxVlanId_oid[] = { 1,3,6,1,2,1,17,7,1,1,2, 0 };
    static oid dot1qNumVlans_oid[] = { 1,3,6,1,2,1,17,7,1,1,4, 0 };

  DEBUGMSGTL(("dot1qBase", "Initializing\n"));

    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("dot1qVlanVersionNumber",
                                         get_dot1qVlanVersionNumber,
                                         dot1qVlanVersionNumber_oid,
                                         OID_LENGTH(dot1qVlanVersionNumber_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("dot1qMaxSupportedVlans",
                                         get_dot1qMaxSupportedVlans,
                                         dot1qMaxSupportedVlans_oid,
                                         OID_LENGTH(dot1qMaxSupportedVlans_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("dot1qGvrpStatus",
                               do_dot1qGvrpStatus,
                               dot1qGvrpStatus_oid,
                               OID_LENGTH(dot1qGvrpStatus_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("dot1qMaxVlanId",
                                         get_dot1qMaxVlanId,
                                         dot1qMaxVlanId_oid,
                                         OID_LENGTH(dot1qMaxVlanId_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("dot1qNumVlans",
                                         get_dot1qNumVlans,
                                         dot1qNumVlans_oid,
                                         OID_LENGTH(dot1qNumVlans_oid),
                                         HANDLER_CAN_RONLY));

    REGISTER_SYSOR_ENTRY(dot1qBridge_oid,
                         "The MIB module to describe Q-BRIDGE MIB.");
}
/*----------------------------------------------------------------------------*/
/* FUNCTION NAME - str_is_invlid                                              */
/* PURPOSE  :  check if the string has any invalid value (The '?'  ':'and ' ' is  */
/*                                                                   invlid)  */
/*                                                                            */
/* ARG      :                                                                 */
/*                 1. value the string which need to check                    */
/* RETURN   :                                                                 */
/*                0 --no invlidaalpha -1----has invlidalpha                   */
/* NOTES    :                                                                 */
/*                                                                            */
/*----------------------------------------------------------------------------*/

int str_is_invlid(char * value)
{

  if(value==NULL || *value=='\0')
    return -1;
  while(*value!='\0')
  {
      if((*value == '?')||(*value == ' ') || (*value == ':'))
        return -1;
     value++;
  }
  return 0;
}

int
get_dot1qVlanVersionNumber(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
   UI32_T dot1qVlanVersionNumber;

    dot1qVlanVersionNumber = VLAN_POM_GetDot1qVlanVersionNumber();

    long_return = dot1qVlanVersionNumber;
    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
            break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
get_dot1qMaxSupportedVlans(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    UI32_T dot1qMaxSupportedVlans;

    dot1qMaxSupportedVlans = VLAN_POM_GetDot1qMaxSupportedVlans();

    long_return= dot1qMaxSupportedVlans;
    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, (u_char *)&long_return, sizeof(long_return));
            break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_dot1qGvrpStatus(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

     UI32_T dot1qGvrpStatus;

    dot1qGvrpStatus =2;

    long_return = dot1qGvrpStatus;


    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
            }
            break;

        case MODE_SET_RESERVE2:
            switch (*requests->requestvb->val.integer)
            {
                case VAL_dot1qGvrpStatus_enabled:
                    break;

                case VAL_dot1qGvrpStatus_disabled:
                    break;

                default:
                    netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
              {
       	UI32_T dot1qGvrpStatus;
       	dot1qGvrpStatus = (*requests->requestvb->val.integer);

            switch(dot1qGvrpStatus)
            {
                case 2:
                    dot1qGvrpStatus = 0;
                    break;
                default:
                    netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
                    break;
            }

           }
        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_dot1qMaxVlanId(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

       UI32_T dot1qMaxVlanId;

       dot1qMaxVlanId = VLAN_POM_GetDot1qMaxVlanId();

       long_return = dot1qMaxVlanId ;

    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
            break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
get_dot1qNumVlans(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    UI32_T dot1qNumVlans;
    dot1qNumVlans = VLAN_POM_GetDot1qNumVlans();

    long_return = dot1qNumVlans;
    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, (u_char *)&long_return, sizeof(long_return));
            break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

oid dot1qFdbTable_variables_oid[] = { 1,3,6,1,2,1,17,7,1,2};

/* variable3 dot1qFdbTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */
struct variable3 dot1qFdbTable_variables[] =
{
/* magic number, variable type, ro/rw, callback fn, L, oidsuffix
 */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_dot1qFdbId, ASN_UNSIGNED, RONLY, var_dot1qFdbTable, 3, { 1, 1, 1 }},
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

    { LEAF_dot1qFdbDynamicCount, ASN_COUNTER, RONLY, var_dot1qFdbTable, 3, { 1, 1, 2 }},
};

void init_dot1qFdbTable(void)
{
    REGISTER_MIB("dot1qFdbTable", dot1qFdbTable_variables, variable3,
               dot1qFdbTable_variables_oid);
}

#define DOT1QFDBENTRY_INSTANCE_LEN  1

BOOL_T dot1qFdbTable_OidIndexToData(UI32_T exact, UI32_T compc,
    oid *compl, UI32_T *dot1qFdbId)
    {
    /* get or set
     */
    if (exact)
    {
        /* check the index length
         */
        if (compc != DOT1QFDBENTRY_INSTANCE_LEN) /* the constant size index */
        {
            return FALSE;
        }
    }

    *dot1qFdbId = compl[0];

    return TRUE;
}

/*
 * var_dot1qFdbTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *var_dot1qFdbTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{
    UI32_T compc = 0;
    oid compl[DOT1QFDBENTRY_INSTANCE_LEN] = {0};
    oid best_inst[DOT1QFDBENTRY_INSTANCE_LEN] = {0};
    AMTR_MGR_Dot1qFdbEntry_T entry;

    switch (vp->magic)
    {
        default:
            *write_method = 0;
            break;
    }

    /* check compc, retrive compl
     */
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl, DOT1QFDBENTRY_INSTANCE_LEN);

   memset( &entry, 0, sizeof(entry));

    if (exact) /* get or set */
    {
        if (dot1qFdbTable_OidIndexToData(exact, compc, compl, &entry.dot1q_fdb_id) == FALSE)
        {
        return NULL;
        }

        if (AMTR_PMGR_GetDot1qFdbEntry(&entry) != TRUE)
        {
            return NULL;
        }
    }
    else /* getnext */
    {
        dot1qFdbTable_OidIndexToData(exact, compc, compl, &entry.dot1q_fdb_id);

        /* check the length of inputing index,if < 1 we should try get
         * {0.0.0.0.0...}
   */
        if (compc < 1)
        {
            if (AMTR_PMGR_GetDot1qFdbEntry(&entry) != TRUE)
            {
                if (AMTR_PMGR_GetNextDot1qFdbEntry(&entry) != TRUE)
                {
                    return NULL;
                }
            }
        }
        else
        {
            if (AMTR_PMGR_GetNextDot1qFdbEntry(&entry) != TRUE)
            {
                return NULL;
            }
        }
    }

    memcpy(name, vp->name, vp->namelen * sizeof(oid));

    /* assign data to the oid index
     */
    best_inst[0] = entry.dot1q_fdb_id;
    memcpy(name + vp->namelen, best_inst, DOT1QFDBENTRY_INSTANCE_LEN * sizeof(oid));
    *length = vp->namelen + DOT1QFDBENTRY_INSTANCE_LEN;

    switch (vp->magic)
    {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case LEAF_dot1qFdbId:
            *var_len = sizeof(long_return);
            long_return = entry.dot1q_fdb_id;
            return (u_char *) &long_return;
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

        case LEAF_dot1qFdbDynamicCount:
            *var_len = sizeof(long_return);
       long_return = entry.dot1q_fdb_dynamic_count;
        return (u_char*) &long_return;

    default:
      ERROR_MSG("");
    }

    return NULL;
}

/********************
*dot1qTpFdbTable
*********************/
/*
 * dot1qTpFdbTable_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */
oid dot1qTpFdbTable_variables_oid[] = { 1,3,6,1,2,1,17,7,1,2 };
#define dot1qTpFdbEntry_INSTANCE_LEN 7
/*
 * variable4 dot1qTpFdbTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */

struct variable3 dot1qTpFdbTable_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */

#define DOT1QTPFDBADDRESS		1
{DOT1QTPFDBADDRESS,  ASN_OCTET_STR,  NOACCESS,   var_dot1qTpFdbTable, 3,  { 2, 1, 1 }},
#define DOT1QTPFDBPORT		2
{DOT1QTPFDBPORT,  ASN_INTEGER,  RONLY,   var_dot1qTpFdbTable, 3,  { 2, 1, 2 }},
#define DOT1QTPFDBSTATUS		3
{DOT1QTPFDBSTATUS,  ASN_INTEGER,  RONLY,   var_dot1qTpFdbTable, 3,  { 2, 1, 3 }},
};
/*    (L = length of the oidsuffix) */


/** Initializes the dot1qTpFdbTable module */
void
init_dot1qTpFdbTable(void)
{

    DEBUGMSGTL(("dot1qTpFdbTable", "Initializing\n"));

    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("dot1qTpFdbTable", dot1qTpFdbTable_variables, variable3,
               dot1qTpFdbTable_variables_oid);

    /* place any other initialization junk you need here */
}



static BOOL_T dot1qTpFdbTable_get(int      compc,
                                oid     *compl,
                                UI32_T  *idx,
                                AMTR_MGR_Dot1qTpFdbEntry_T   *data)
{

    if (compc !=dot1qTpFdbEntry_INSTANCE_LEN)
    {
 	    return FALSE;
    }
    *idx=compl[0];
    SNMP_MGR_ReadOctetFromCompl(compl, 1, 6, data->dot1q_tp_fdb_address);

    if(SNMP_MGR_IsDebugMode())
    {
        int i;
        printf("dot1qTpFdbTable_get:idx=[%lu]\n", *idx);
        for (i=0; i<6; i++)
            printf("dot1qTpFdbTable_get:data->dot1q_tp_fdb_address[%d]=%d\n", i, data->dot1q_tp_fdb_address[i]);
    }
	if (!AMTR_PMGR_GetDot1qTpFdbEntry(*idx, data))
	{
	    if(SNMP_MGR_IsDebugMode())
	        printf("dot1qTpFdbTable_get:AMTR_PMGR_GetDot1qTpFdbEntry return false\n");
		return FALSE;
	}
	else
	{
		return TRUE;
	} /*End of if */
}

static BOOL_T dot1qTpFdbTable_next(int      compc,
                                 oid     *compl,
                                 UI32_T  *idx,
                                 AMTR_MGR_Dot1qTpFdbEntry_T    *data)
{
  	oid tmp_compl[dot1qTpFdbEntry_INSTANCE_LEN];

 	/* Generate the instance of each table entry and find the
	 * smallest instance that's larger than compc/compl.
	 *
	 * Step 1: Verify and extract the input key from "compc" and "compl"
	 * Note: The number of input key is defined by "compc".
	 *       The key for the specified instance is defined in compl.
	 */

	memcpy(tmp_compl, compl, sizeof(tmp_compl));
	SNMP_MGR_ConvertRemainToZero(compc,dot1qTpFdbEntry_INSTANCE_LEN, tmp_compl);
	*idx=tmp_compl[0];
	SNMP_MGR_ReadOctetFromCompl(tmp_compl, 1, 6, data->dot1q_tp_fdb_address);

	if(SNMP_MGR_IsDebugMode())
    {
        int i;
        printf("dot1qTpFdbTable_next:idx=[%lu]\n", *idx);
        for (i=0; i<6; i++)
            printf("dot1qTpFdbTable_next:data->dot1q_tp_fdb_address[%d]=%d\n", i, data->dot1q_tp_fdb_address[i]);
    }

	if (compc<dot1qTpFdbEntry_INSTANCE_LEN)
	{
		if (!AMTR_PMGR_GetDot1qTpFdbEntry(*idx, data))
        {
            if (!AMTR_PMGR_GetNextDot1qTpFdbEntry(idx, data))
   	        {
   	            if(SNMP_MGR_IsDebugMode())
   	                printf("dot1qTpFdbTable_next: get & genext return false\n");
   		        return FALSE;
   		    }
        }
	}
	else
	{
		if (!AMTR_PMGR_GetNextDot1qTpFdbEntry(idx, data))
		{
		    if(SNMP_MGR_IsDebugMode())
   	            printf("dot1qTpFdbTable_next: getnext return false\n");
			return FALSE;
		}
	}
	return TRUE;
}

/*
 * var_dot1qTpFdbTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *
var_dot1qTpFdbTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{
    UI32_T compc=0;
    oid compl[dot1qTpFdbEntry_INSTANCE_LEN];
    oid best_inst[dot1qTpFdbEntry_INSTANCE_LEN];
    UI32_T idx;
    AMTR_MGR_Dot1qTpFdbEntry_T data;

    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl, dot1qTpFdbEntry_INSTANCE_LEN);

     /*check compc, retrive compl*/
    if (exact)/*get,set*/
    {
        if (!dot1qTpFdbTable_get(compc, compl, &idx, &data))
            return NULL;
    }
    else/*getnext*/
    {
        if (!dot1qTpFdbTable_next(compc, compl, &idx, &data))
            return NULL;
    }
    memcpy(name, vp->name, vp->namelen*sizeof(oid));
    best_inst[0]=idx;
    SNMP_MGR_BindOctetInstance(data.dot1q_tp_fdb_address, 1, 6, best_inst);

    memcpy(name + vp->namelen, best_inst, dot1qTpFdbEntry_INSTANCE_LEN*sizeof(oid));
    *length = vp->namelen +dot1qTpFdbEntry_INSTANCE_LEN;

    *var_len = sizeof(long_return);

    /*
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {

    case DOT1QTPFDBPORT:
       long_return = data.dot1q_tp_fdb_port;
        return (u_char*) &long_return;
   case DOT1QTPFDBSTATUS:
       long_return = data.dot1q_tp_fdb_status;
        return (u_char*) &long_return;
    default:
      ERROR_MSG("");
    }
    return NULL;
}

/*
 * dot1qStaticUnicastTable_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid dot1qStaticUnicastTable_variables_oid[] = { 1,3,6,1,2,1,17,7,1,3};

/*
 * variable4 dot1qStaticUnicastTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */

struct variable3 dot1qStaticUnicastTable_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */

#define DOT1QSTATICUNICASTADDRESS		1
{DOT1QSTATICUNICASTADDRESS,  ASN_OCTET_STR,  NOACCESS,   var_dot1qStaticUnicastTable, 3,  { 1, 1, 1 }},
#define DOT1QSTATICUNICASTRECEIVEPORT		2
{DOT1QSTATICUNICASTRECEIVEPORT,  ASN_INTEGER,  NOACCESS,   var_dot1qStaticUnicastTable, 3,  { 1, 1, 2 }},
#define DOT1QSTATICUNICASTALLOWEDTOGOTO		3
{DOT1QSTATICUNICASTALLOWEDTOGOTO,  ASN_OCTET_STR,  RWRITE,  var_dot1qStaticUnicastTable, 3,  { 1, 1, 3 }},
#define DOT1QSTATICUNICASTSTATUS		4
{DOT1QSTATICUNICASTSTATUS,  ASN_INTEGER,  RWRITE,  var_dot1qStaticUnicastTable, 3,  { 1, 1, 4 }},
};
/*    (L = length of the oidsuffix) */


/** Initializes the dot1qStaticUnicastTable module */
void
init_dot1qStaticUnicastTable(void)
{

    DEBUGMSGTL(("dot1qStaticUnicastTable", "Initializing\n"));

    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("dot1qStaticUnicastTable", dot1qStaticUnicastTable_variables, variable3,
               dot1qStaticUnicastTable_variables_oid);

    /* place any other initialization junk you need here */
}

static int
header_dot1qStaticUnicastTable(struct variable *vp,
               oid * name,
               size_t * length,
               int exact, size_t * var_len, WriteMethod ** write_method,
               AMTR_MGR_Dot1qStaticUnicastEntry_T  *entry)
{
#if 0
#define OID_NAME_LENGTH	13


    oid             newname[MAX_OID_LEN];
    UI32_T     local_index1=0;
    int             result,i;
   AMTR_MGR_Dot1qStaticUnicastEntry_T  entry;
   BOOL_T return_val;
   oid  next_inst[8];


     memcpy((char *) newname, (char *) vp->name,
           (int) vp->namelen * sizeof(oid));
    /*
     * find "next" interface
     */
    memset(  &entry, 0 , sizeof(entry));

    /*
     * find "next" interface
     */

  while (  (return_val= AMTR_PMGR_GetNextDot1qStaticUnicastEntry( &local_index1,&entry))==TRUE)
     {
      next_inst[0] = local_index1;
       for(i=1; i<7;i++)
            next_inst[i] =  (oid) entry.dot1q_static_unicast_address[i-1];
       next_inst[7] =entry.dot1q_static_unicast_receive_port;

        memcpy( (char*)&newname[OID_NAME_LENGTH],   (char*)next_inst,  8*sizeof(oid));
        result =
            snmp_oid_compare(name, *length, newname,
                             (int) vp->namelen +8);
        if ((exact && (result == 0)) || (!exact && (result < 0)))
            break;
    }
    if (!return_val ) {
        DEBUGMSGTL(("mibII/interfaces", "... index out of range\n"));
        return MATCH_FAILED;
    }
    memcpy((char *) name, (char *) newname,
           ((int) vp->namelen + 8) * sizeof(oid));
    *length = vp->namelen + 8;
    *var_len = sizeof(long);    /* default to 'long' results */


     *index1 = local_index1;
     for (i=1; i<7; i++)
             index2[i-1] = (UI8_T) next_inst[i];
    *index3 =  next_inst[7];
    return TRUE;
 #else

    int     local_index1=0,port = 0,ret;

    /*
     * find "next" interface
     */

    if(!entry)
      return MATCH_FAILED;

    ret = l_snmp_int_mac_addr_int_index_get(vp, name, length, &local_index1, (struct L_SNMP_MAC_ADDR *)(entry->dot1q_static_unicast_address), &port, exact);
    if (ret < 0)
      return MATCH_FAILED;

    /*
     * find "next" interface
     */
    entry->dot1q_static_unicast_receive_port = port;
    /*get,getnext*/
    if (!exact)
    {
        if (AMTR_PMGR_GetNextDot1qStaticUnicastEntry((UI32_T *)&local_index1,entry) != TRUE)
            return MATCH_FAILED;
        l_snmp_int_mac_addr_int_index_set(vp, name, length, local_index1, (struct L_SNMP_MAC_ADDR *)(entry->dot1q_static_unicast_address), entry->dot1q_static_unicast_receive_port);
    }
    else
    {
        if (AMTR_PMGR_GetDot1qStaticUnicastEntry((UI32_T)local_index1,entry) != TRUE)
            return MATCH_FAILED;
    }

    *var_len = sizeof(long);    /* default to 'long' results */

    return TRUE;
 #endif
}



/*
 * var_dot1qStaticUnicastTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *
var_dot1qStaticUnicastTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{
    /* variables we may use later */


    UI32_T retval;

    AMTR_MGR_Dot1qStaticUnicastEntry_T  entry;


     /* Since may be row creation, we should specific the write function first, kinghong*/
  switch(vp->magic) {

    case DOT1QSTATICUNICASTALLOWEDTOGOTO:
        *write_method = write_dot1qStaticUnicastAllowedToGoTo;
     break;
    case DOT1QSTATICUNICASTSTATUS:
        *write_method = write_dot1qStaticUnicastStatus;
     break;
   }


    memset( &entry, 0, sizeof(entry));

     retval  = header_dot1qStaticUnicastTable(vp, name, length, exact, var_len, write_method,&entry );

    if (retval == MATCH_FAILED)
        return NULL;

    /*
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {

    case  DOT1QSTATICUNICASTALLOWEDTOGOTO:

       {
         memcpy( return_buf, entry.dot1q_static_unicast_allowed_to_go_to, SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST);
        *var_len = SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST;
        return (u_char*) return_buf;
      }
    case DOT1QSTATICUNICASTSTATUS:
      {
      long_return = entry.dot1q_static_unicast_status;
        return (u_char*) &long_return;
     }
    default:
      ERROR_MSG("");
    }
    return NULL;
}

int
write_dot1qStaticUnicastAllowedToGoTo(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    UI8_T  value[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST];
    UI8_T   mac[6];
    UI32_T vid;
    int size,i;

    if ((char) name[12] != DOT1QSTATICUNICASTALLOWEDTOGOTO)
    {
        return SNMP_ERR_NOTWRITABLE;
    }
    if (name_len!=  21)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    vid = name[13];

    /* MAC address, must assign integer to byte, cannot do "memcpy".
     * Zhong Qiyao, 2004.07.28, based on Jenny Hsieh
     */
    for (i = 0; i<6; i++)
    {
        mac[i] = (UI8_T)name[14+i];
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              return SNMP_ERR_WRONGTYPE;
          }
        /* The var_val_len is sizeof(char)*SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST".
         * Eli Lin, 2005.06.16
         */
          if (var_val_len > sizeof(char)*SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
         size  = var_val_len;
            memcpy( value, var_val, size);

           for (i =  size; i<SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST ; i ++)
            value[i] = 0;

      if (AMTR_PMGR_SetDot1qStaticUnicastAllowedToGoTo(vid,mac,value)!= TRUE)
          return SNMP_ERR_COMMITFAILED;
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot1qStaticUnicastStatus(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    UI8_T   mac[6];
    UI32_T vid;
    int i;
    UI32_T value;

    if ((char) name[12] != DOT1QSTATICUNICASTSTATUS)
    {
        return SNMP_ERR_NOTWRITABLE;
    }
    if (name_len!=  21)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    /* VLAN ID
     */
    vid = name[13];

    /* MAC address, must assign integer to byte, cannot do "memcpy".
     * Zhong Qiyao, 2004.07.26, based on Jenny Hsieh
     */
    for (i = 0; i<6; i++)
    {
        mac[i] = (UI8_T)name[14+i];
    }

    /* Action
     */
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          value = *(long *)var_val;
          if ((value <1) || (value >5))
              return SNMP_ERR_WRONGVALUE;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             value = *(long *)var_val;

              if(AMTR_PMGR_SetDot1qStaticUnicastStatus(vid, mac , value)!= TRUE)
                 return SNMP_ERR_COMMITFAILED;
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

/** Initializes the dot1qVlan module */
void
init_dot1qVlan(void)
{
    static oid dot1qVlanNumDeletes_oid[] = { 1,3,6,1,2,1,17,7,1,4,1, 0 };
    static oid dot1qConstraintTypeDefault_oid[] = { 1,3,6,1,2,1,17,7,1,4,10, 0 };
    static oid dot1qNextFreeLocalVlanIndex_oid[] = { 1,3,6,1,2,1,17,7,1,4,4, 0 };
    static oid dot1qConstraintSetDefault_oid[] = { 1,3,6,1,2,1,17,7,1,4,9, 0 };

  DEBUGMSGTL(("dot1qVlan", "Initializing\n"));

    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("dot1qVlanNumDeletes",
                                         get_dot1qVlanNumDeletes,
                                         dot1qVlanNumDeletes_oid,
                                         OID_LENGTH(dot1qVlanNumDeletes_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("dot1qConstraintTypeDefault",
                               do_dot1qConstraintTypeDefault,
                               dot1qConstraintTypeDefault_oid,
                               OID_LENGTH(dot1qConstraintTypeDefault_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("dot1qNextFreeLocalVlanIndex",
                                         get_dot1qNextFreeLocalVlanIndex,
                                         dot1qNextFreeLocalVlanIndex_oid,
                                         OID_LENGTH(dot1qNextFreeLocalVlanIndex_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("dot1qConstraintSetDefault",
                               do_dot1qConstraintSetDefault,
                               dot1qConstraintSetDefault_oid,
                               OID_LENGTH(dot1qConstraintSetDefault_oid),
                               HANDLER_CAN_RWRITE));
}

int
get_dot1qVlanNumDeletes(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */


    UI32_T dot1qVlanNumDeletes;

    dot1qVlanNumDeletes = VLAN_POM_GetDot1qVlanNumDeletes();

    long_return = dot1qVlanNumDeletes;

    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *) &long_return, sizeof(long_return));
            break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
do_dot1qConstraintTypeDefault(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    UI32_T dot1qConstraintTypeDefault;

     if (VLAN_POM_GetDot1qConstraintTypeDefault(&dot1qConstraintTypeDefault) != TRUE)
        return SNMP_ERR_GENERR;

    long_return = dot1qConstraintTypeDefault;
    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
            }
            break;

        case MODE_SET_RESERVE2:
            switch (*requests->requestvb->val.integer)
            {
                case VAL_dot1qConstraintTypeDefault_independent:
                    break;

                case VAL_dot1qConstraintTypeDefault_shared:
                    break;

                default:
                    netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:

            {
            	UI32_T dot1qConstraintTypeDefault;
            	dot1qConstraintTypeDefault = (*requests->requestvb->val.integer);
             if(VLAN_PMGR_SetDot1qConstraintTypeDefault(dot1qConstraintTypeDefault)!= TRUE)
                 netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_COMMIT:

            break;

        case MODE_SET_UNDO:

            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}


int
get_dot1qNextFreeLocalVlanIndex(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    UI32_T dot1qNextFreeLocalVlanIndex;
    if (VLAN_POM_GetDot1qNextFreeLocalVlanIndex(&dot1qNextFreeLocalVlanIndex) !=TRUE)
    {
        dot1qNextFreeLocalVlanIndex = 0; /*If there isn't  NextFreeLocalVlanIndex exist, NextFreeLocalVlanIndex need be set to 0 -- xiongyu 20081205*/
    }

     long_return = dot1qNextFreeLocalVlanIndex;
    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *)&long_return, sizeof(long_return));
            break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
do_dot1qConstraintSetDefault(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    /*we do not support this variables*/
    long_return = 0;

    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
            }
            break;

        case MODE_SET_RESERVE2:

            if (*requests->requestvb->val.integer < MIN_dot1qConstraintSetDefault ||
                *requests->requestvb->val.integer > MAX_dot1qConstraintSetDefault)
            {
               netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            break;

        case MODE_SET_COMMIT:
        /*we do not support this variables*/
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
            break;

        case MODE_SET_UNDO:
            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

oid dot1qVlanCurrentTable_variables_oid[] = { 1,3,6,1,2,1,17,7,1,4 };
/*
 * variable3 dot1qVlanCurrentTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */
struct variable3 dot1qVlanCurrentTable_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
{LEAF_dot1qVlanTimeMark,                ASN_TIMETICKS,  RONLY,  var_dot1qVlanCurrentTable, 3, { 2, 1, 1 }},
{LEAF_dot1qVlanIndex,                   ASN_UNSIGNED,   RONLY,  var_dot1qVlanCurrentTable, 3, { 2, 1, 2 }},
#endif

{LEAF_dot1qVlanFdbId,                   ASN_UNSIGNED,   RONLY,  var_dot1qVlanCurrentTable, 3, { 2, 1, 3 }},
{LEAF_dot1qVlanCurrentEgressPorts,      ASN_OCTET_STR,  RONLY,  var_dot1qVlanCurrentTable, 3, { 2, 1, 4 }},
{LEAF_dot1qVlanCurrentUntaggedPorts,    ASN_OCTET_STR,  RONLY,  var_dot1qVlanCurrentTable, 3, { 2, 1, 5 }},
{LEAF_dot1qVlanStatus,                  ASN_INTEGER,    RONLY,  var_dot1qVlanCurrentTable, 3, { 2, 1, 6 }},
{LEAF_dot1qVlanCreationTime,            ASN_TIMETICKS,  RONLY,  var_dot1qVlanCurrentTable, 3, { 2, 1, 7 }},
};

/** Initializes the dot1qVlanCurrentTable module */
void
init_dot1qVlanCurrentTable(void)
{
    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("dot1qVlanCurrentTable", dot1qVlanCurrentTable_variables, variable3,
               dot1qVlanCurrentTable_variables_oid);
}

#define DOT1QVLANCURRENTENTRY_INSTANCE_LEN  2

BOOL_T dot1qVlanCurrentTable_OidIndexToData(UI32_T exact, UI32_T compc,
            oid *compl, UI32_T *index1, UI32_T *index2)
    {
    /* get or write */
    if (exact)
       {
        /* check the index length */
        if (compc != DOT1QVLANCURRENTENTRY_INSTANCE_LEN) /* the constant size index */
          {
            return FALSE;
      }
    }

    *index1 = compl[0];
    *index2 = compl[1];

    return TRUE;
}

/*
 * var_dot1qVlanCurrentTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *
var_dot1qVlanCurrentTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{
    /* variables we may use later */
    UI32_T compc = 0;
    UI32_T index1;
    UI32_T index2;
    oid compl[DOT1QVLANCURRENTENTRY_INSTANCE_LEN] = {0};
    oid best_inst[DOT1QVLANCURRENTENTRY_INSTANCE_LEN] = {0};
    VLAN_OM_Dot1qVlanCurrentEntry_T  entry;

    switch (vp->magic)
    {
        default:
            *write_method = 0;
            break;
    }

    /* check compc, retrive compl */
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,
                           compl, DOT1QVLANCURRENTENTRY_INSTANCE_LEN);

    memset( &entry, 0, sizeof(entry));

    if (exact) /* get,set */
    {
        /* get index */
        if (dot1qVlanCurrentTable_OidIndexToData(exact, compc, compl, &index1, &index2) == FALSE)
        {
        return NULL;
        }

        /* get data */
        if (VLAN_POM_GetDot1qVlanCurrentEntry(index1, index2, &entry) != TRUE)
        {
            return NULL;
        }
    }
    else /* getnext */
    {
        /* get index */
        dot1qVlanCurrentTable_OidIndexToData(exact, compc, compl, &index1, &index2);

        /* check the length of inputing index,if < 1 we should try get
         * {0.0.0.0.0...}
         */
        if (compc < 1)
        {
            /* get data */
   if (VLAN_POM_GetDot1qVlanCurrentEntry(index1,index2, &entry)!= TRUE)
            {
                /* get next data */
                if (VLAN_OM_GetNextDot1qVlanCurrentEntrySortByTimemark(index1, &index2, &entry) != TRUE)
                {
                    return NULL;
                }
            }
        }
        else
        {
            /* get next data */
            if (VLAN_OM_GetNextDot1qVlanCurrentEntrySortByTimemark(index1, &index2, &entry) != TRUE)
            {
            return NULL;
            }
        }
    }

    memcpy(name, vp->name, vp->namelen * sizeof(oid));

    /* assign data to the oid index */
    best_inst[0] = entry.dot1q_vlan_time_mark;
    best_inst[1] = index2;
    memcpy(name + vp->namelen, best_inst,
           DOT1QVLANCURRENTENTRY_INSTANCE_LEN * sizeof(oid));
    *length = vp->namelen + DOT1QVLANCURRENTENTRY_INSTANCE_LEN;

    /* this is where we do the value assignments for the mib results. */
    switch (vp->magic)
    {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case LEAF_dot1qVlanTimeMark:
            *var_len = sizeof(long_return);
            long_return = entry.dot1q_vlan_time_mark;
            return (u_char *) &long_return;

        case LEAF_dot1qVlanIndex:
            *var_len = sizeof(long_return);
            long_return = entry.dot1q_vlan_index;
            return (u_char *) &long_return;
#endif

        case LEAF_dot1qVlanFdbId:
            *var_len = sizeof(long_return);
        long_return =index2;
        return (u_char*) &long_return;

        case LEAF_dot1qVlanCurrentEgressPorts:
         *var_len = SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST;
            memcpy(return_buf, entry.dot1q_vlan_current_egress_ports, *var_len);
        return (u_char*) return_buf;

        case LEAF_dot1qVlanCurrentUntaggedPorts:
         *var_len = SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST;
            memcpy(return_buf, entry.dot1q_vlan_current_untagged_ports, *var_len);
        return (u_char*) return_buf;

        case LEAF_dot1qVlanStatus:
            *var_len = sizeof(long_return);
        long_return = entry.dot1q_vlan_status;
        return (u_char*) &long_return;

        case LEAF_dot1qVlanCreationTime:
            *var_len = sizeof(long_return);
       long_return = entry.dot1q_vlan_creation_time;
        return (u_char*) &long_return;

    default:
      ERROR_MSG("");
    }

    return NULL;
}

oid dot1qVlanStaticTable_variables_oid[] = { 1,3,6,1,2,1,17,7,1,4 };
/*
 * variable3 dot1qVlanStaticTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */
struct variable3 dot1qVlanStaticTable_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
{LEAF_dot1qVlanStaticName,              ASN_OCTET_STR,  RWRITE, var_dot1qVlanStaticTable, 3, { 3, 1, 1 }},
{LEAF_dot1qVlanStaticEgressPorts,       ASN_OCTET_STR,  RWRITE, var_dot1qVlanStaticTable, 3, { 3, 1, 2 }},
{LEAF_dot1qVlanForbiddenEgressPorts,    ASN_OCTET_STR,  RWRITE, var_dot1qVlanStaticTable, 3, { 3, 1, 3 }},
{LEAF_dot1qVlanStaticUntaggedPorts,     ASN_OCTET_STR,  RWRITE, var_dot1qVlanStaticTable, 3, { 3, 1, 4 }},
{LEAF_dot1qVlanStaticRowStatus,         ASN_INTEGER,    RWRITE, var_dot1qVlanStaticTable, 3, { 3, 1, 5 }},
};

/** Initializes the dot1qVlanStaticTable module */
void
init_dot1qVlanStaticTable(void)
{
    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("dot1qVlanStaticTable", dot1qVlanStaticTable_variables, variable3,
               dot1qVlanStaticTable_variables_oid);
    }

#define DOT1QVLANSTATICENTRY_INSTANCE_LEN  1

BOOL_T dot1qVlanStaticTable_OidIndexToData(UI32_T exact, UI32_T compc,
            oid *compl, UI32_T *index)
	{
    /* get or write */
	if(exact)
	{
        /* check the index length */
        if (compc != DOT1QVLANSTATICENTRY_INSTANCE_LEN) /* the constant size index */
            {
            return FALSE;
        }
	}

    if ((0 > compl[0]) || (compl[0] > SYS_DFLT_DOT1QMAXVLANID))
    {
        return FALSE;
    }

    *index = compl[0];

    return TRUE;
}

/*
 * var_dot1qVlanStaticTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *
var_dot1qVlanStaticTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{
    /* variables we may use later */
    UI32_T compc = 0;
    UI32_T index;
    oid compl[DOT1QVLANSTATICENTRY_INSTANCE_LEN] = {0};
    oid best_inst[DOT1QVLANSTATICENTRY_INSTANCE_LEN] = {0};
    VLAN_MGR_Dot1qVlanStaticEntry_T entry;

    switch (vp->magic)
    {
        case LEAF_dot1qVlanStaticName:
        *write_method = write_dot1qVlanStaticName;
    break;

        case LEAF_dot1qVlanStaticEgressPorts:
        *write_method = write_dot1qVlanStaticEgressPorts;
      break;

        case LEAF_dot1qVlanForbiddenEgressPorts:
        *write_method = write_dot1qVlanForbiddenEgressPorts;
      break;

        case LEAF_dot1qVlanStaticUntaggedPorts:
        *write_method = write_dot1qVlanStaticUntaggedPorts;
       break;

        case LEAF_dot1qVlanStaticRowStatus:
        *write_method = write_dot1qVlanStaticRowStatus;
        break;

        default:
            *write_method = 0;
            break;
      }

    /* check compc, retrive compl */
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,
                           compl, DOT1QVLANSTATICENTRY_INSTANCE_LEN);

   memset( &entry, 0, sizeof(entry));

    if (exact) /* get,set */
    {
        /* get index */
        if (dot1qVlanStaticTable_OidIndexToData(exact, compc, compl, &index) == FALSE)
        {
            return NULL;
        }

        /* get data */
        if (VLAN_POM_GetDot1qVlanStaticEntry(index, &entry) != TRUE)
    {
        return NULL;
    }
    }
    else /* getnext */
    {
        /* get index */
        dot1qVlanStaticTable_OidIndexToData(exact, compc, compl, &index);

        /* check the length of inputing index,if < 1 we should try get
         * {0.0.0.0.0...}
         */
        if (compc < 1)
        {
            /* get data */
            if (VLAN_POM_GetDot1qVlanStaticEntry(index, &entry) != TRUE)
            {
                /* get next data */
                if (VLAN_POM_GetNextDot1qVlanStaticEntry(&index, &entry) != TRUE)
                {
                    return NULL;
                }
            }
        }
        else
        {
            /* get next data */
            if (VLAN_POM_GetNextDot1qVlanStaticEntry(&index, &entry) != TRUE)
            {
                return NULL;
            }
        }
    }

    memcpy(name, vp->name, vp->namelen * sizeof(oid));

    /* assign data to the oid index */
    best_inst[0] = index;
    memcpy(name + vp->namelen, best_inst,
           DOT1QVLANSTATICENTRY_INSTANCE_LEN * sizeof(oid));
    *length = vp->namelen + DOT1QVLANSTATICENTRY_INSTANCE_LEN;

    /* this is where we do the value assignments for the mib results. */
    switch (vp->magic)
    {
        case LEAF_dot1qVlanStaticName:
            *var_len = strlen(entry.dot1q_vlan_static_name);
            memcpy(return_buf, entry.dot1q_vlan_static_name, *var_len);
            return (u_char*)return_buf;

        case LEAF_dot1qVlanStaticEgressPorts:
            *var_len = SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST;
            memcpy(return_buf, entry.dot1q_vlan_static_egress_ports, *var_len);
            return (u_char*)return_buf;

        case LEAF_dot1qVlanForbiddenEgressPorts:
            *var_len = SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST;
            memcpy(return_buf, entry.dot1q_vlan_forbidden_egress_ports, *var_len);
            return (u_char*)return_buf;

        case LEAF_dot1qVlanStaticUntaggedPorts:
            *var_len = SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST;
            memcpy(return_buf, entry.dot1q_vlan_static_untagged_ports, *var_len);
            return (u_char*)return_buf;

        case LEAF_dot1qVlanStaticRowStatus:
            *var_len = sizeof(long_return);
            long_return = entry.dot1q_vlan_static_row_status;
            return (u_char *) &long_return;

        default:
            ERROR_MSG("");
    }

    return NULL;
}

int
write_dot1qVlanStaticName(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_OCTET_STR)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len < MINSIZE_dot1qVlanStaticName ||
                var_val_len > MAXSIZE_dot1qVlanStaticName)
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;

        case RESERVE2:
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = 13;
            UI8_T byte_buffer[MAXSIZE_dot1qVlanStaticName + 1] = {0};
            UI32_T index = 0;

            if (dot1qVlanStaticTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &index) == FALSE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            memcpy(byte_buffer, var_val, var_val_len);
            byte_buffer[var_val_len] = '\0';

            if (VLAN_PMGR_SetDot1qVlanStaticName(index, (char *)byte_buffer) != TRUE)
            {
                return SNMP_ERR_COMMITFAILED;
            }
        }
            break;

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

int
write_dot1qVlanStaticEgressPorts(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_OCTET_STR)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST * sizeof(char))
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;

        case RESERVE2:
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = 13;
            UI8_T byte_buffer[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST] = {0};
            UI32_T index = 0;
            UI32_T i;

            if (dot1qVlanStaticTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &index) == FALSE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            memcpy(byte_buffer, var_val, var_val_len);

            /* set zero to the remaining bit
             */
            for (i = var_val_len; i < SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST; i++)
            {
                byte_buffer[i] = 0;
            }

            if (VLAN_PMGR_SetDot1qVlanStaticEgressPorts(index, byte_buffer, VAL_dot1qVlanStatus_permanent) != TRUE)
            {
                return SNMP_ERR_COMMITFAILED;
            }
        }
            break;

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

int
write_dot1qVlanForbiddenEgressPorts(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_OCTET_STR)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST * sizeof(char))
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;

        case RESERVE2:
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = 13;
            UI8_T byte_buffer[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST] = {0};
            UI32_T index = 0;
            UI32_T i;

            if (dot1qVlanStaticTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &index) == FALSE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            memcpy(byte_buffer, var_val, var_val_len);

            /* set zero to the remaining bit
             */
            for (i = var_val_len; i < SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST; i++)
            {
                byte_buffer[i] = 0;
            }

            if (VLAN_PMGR_SetDot1qVlanForbiddenEgressPorts(index, byte_buffer, VAL_dot1qVlanStatus_permanent) != TRUE)
            {
                return SNMP_ERR_COMMITFAILED;
            }
        }
            break;

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

int
write_dot1qVlanStaticUntaggedPorts(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_OCTET_STR)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST * sizeof(char))
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;

        case RESERVE2:
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = 13;
            UI8_T byte_buffer[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST] = {0};
            UI32_T index = 0;
            UI32_T i;

            if (dot1qVlanStaticTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &index) == FALSE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            memcpy(byte_buffer, var_val, var_val_len);

            /* set zero to the remaining bit
             */
            for (i = var_val_len; i < SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST; i++)
            {
                byte_buffer[i] = 0;
            }

            if (VLAN_PMGR_SetDot1qVlanStaticUntaggedPorts(index, byte_buffer, VAL_dot1qVlanStatus_permanent) != TRUE)
            {
                return SNMP_ERR_COMMITFAILED;
            }
        }
            break;

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

int
write_dot1qVlanStaticRowStatus(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            switch (*(long *)var_val)
            {
                case VAL_dot1qVlanStaticRowStatus_active:
                    break;

                case VAL_dot1qVlanStaticRowStatus_notInService:
                    break;

                case VAL_dot1qVlanStaticRowStatus_notReady:
                    break;

                case VAL_dot1qVlanStaticRowStatus_createAndGo:
                    break;

                case VAL_dot1qVlanStaticRowStatus_createAndWait:
                    break;

                case VAL_dot1qVlanStaticRowStatus_destroy:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = 13;
            I32_T value = 0;
            UI32_T index = 0;
            VLAN_MGR_Dot1qVlanStaticEntry_T entry;

            if (dot1qVlanStaticTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &index) == FALSE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            value = *(long *)var_val;

            memset(&entry, 0, sizeof(entry));
            entry.dot1q_vlan_index = index;
            entry.dot1q_vlan_static_row_status = value;

            switch (value)
            {
                case VAL_dot1qConstraintStatus_createAndGo:
                case VAL_dot1qConstraintStatus_createAndWait:
                    if (VLAN_PMGR_SetDot1qVlanStaticEntry(&entry) != TRUE)
                    {
                        return SNMP_ERR_COMMITFAILED;
                    }
                    break;

                case VAL_dot1qConstraintStatus_active:
                case VAL_dot1qConstraintStatus_notInService:
                case VAL_dot1qConstraintStatus_notReady:
                case VAL_dot1qConstraintStatus_destroy:
                    if (VLAN_PMGR_SetDot1qVlanStaticRowStatus(index, value) != TRUE)
                    {
                        return SNMP_ERR_COMMITFAILED;
                    }
                    break;

                default:
                    return SNMP_ERR_COMMITFAILED;
            }
        }
            break;

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

/*
 * dot1qPortVlanTable_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid dot1qPortVlanTable_variables_oid[] = { 1,3,6,1,2,1,17,7,1,4};

/*
 * variable4 dot1qPortVlanTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */

struct variable3 dot1qPortVlanTable_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */

#define DOT1QPVID		1
{DOT1QPVID,  ASN_UNSIGNED,  RWRITE,  var_dot1qPortVlanTable, 3,  { 5, 1, 1 }},
#define DOT1QPORTACCEPTABLEFRAMETYPES		2
{DOT1QPORTACCEPTABLEFRAMETYPES,  ASN_INTEGER,  RWRITE,  var_dot1qPortVlanTable, 3,  { 5, 1, 2 }},
#define DOT1QPORTINGRESSFILTERING		3
{DOT1QPORTINGRESSFILTERING,  ASN_INTEGER,  RWRITE,  var_dot1qPortVlanTable, 3,  { 5, 1, 3 }},
#define DOT1QPORTGVRPSTATUS		4
{DOT1QPORTGVRPSTATUS,  ASN_INTEGER,  RWRITE,  var_dot1qPortVlanTable, 3,  { 5, 1, 4 }},
#define DOT1QPORTGVRPFAILEDREGISTRATIONS		5
{DOT1QPORTGVRPFAILEDREGISTRATIONS,  ASN_COUNTER,  RONLY,   var_dot1qPortVlanTable, 3,  { 5, 1, 5 }},
#define DOT1QPORTGVRPLASTPDUORIGIN		6
{DOT1QPORTGVRPLASTPDUORIGIN,  ASN_OCTET_STR,  RONLY,   var_dot1qPortVlanTable, 3,  { 5, 1, 6 }},
};
/*    (L = length of the oidsuffix) */


/** Initializes the dot1qPortVlanTable module */
void
init_dot1qPortVlanTable(void)
{

    DEBUGMSGTL(("dot1qPortVlanTable", "Initializing\n"));

    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("dot1qPortVlanTable", dot1qPortVlanTable_variables, variable3,
               dot1qPortVlanTable_variables_oid);

    /* place any other initialization junk you need here */
}


static int
header_dot1qPortVlanTable(struct variable *vp,
               oid * name,
               size_t * length,
               int exact, size_t * var_len, WriteMethod ** write_method,
               VLAN_OM_Dot1qPortVlanEntry_T  *entry)
{
     unsigned int ifIndex = 0;

    if(!entry || l_snmp_index_get(vp,name,length,&ifIndex,exact) < 0 )
      return MATCH_FAILED;

    if(!exact)
     {
        if(VLAN_PMGR_GetNextDot1qPortVlanEntry( (UI32_T*)(&ifIndex), entry)!=TRUE)
         return MATCH_FAILED;

        l_snmp_index_set(vp,name,length,ifIndex);

     }
    else
    {
      if(VLAN_PMGR_GetDot1qPortVlanEntry(ifIndex,entry)!=TRUE)
            return MATCH_FAILED;
    }


    *var_len = sizeof(long);    /* default to 'long' results */

    return ifIndex;
}


/*
 * var_dot1qPortVlanTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *
var_dot1qPortVlanTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{
    VLAN_OM_Dot1qPortVlanEntry_T entry;


    int             interface;



  switch(vp->magic) {
   case  DOT1QPVID:
        *write_method = write_dot1qPvid;
       break;
   case  DOT1QPORTACCEPTABLEFRAMETYPES:
        *write_method = write_dot1qPortAcceptableFrameTypes;
      break;
   case  DOT1QPORTINGRESSFILTERING:
        *write_method = write_dot1qPortIngressFiltering;
        break;
   case  DOT1QPORTGVRPSTATUS:
        *write_method = write_dot1qPortGvrpStatus;
    break;
   }

   memset( &entry, 0, sizeof(entry));
    interface =
        header_dot1qPortVlanTable(vp, name, length, exact, var_len, write_method,&entry);
    if (interface == MATCH_FAILED)
        return NULL;

    /*
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
    case DOT1QPVID:
        long_return = entry.dot1q_pvid_index;
        return (u_char*) &long_return;
    case DOT1QPORTACCEPTABLEFRAMETYPES:
        long_return = entry.dot1q_port_acceptable_frame_types;
        return (u_char*) &long_return;
    case DOT1QPORTINGRESSFILTERING:
        long_return = entry.dot1q_port_ingress_filtering;
        return (u_char*) &long_return;
   case  DOT1QPORTGVRPSTATUS:
   {

    long_return =VAL_dot1qPortGvrpStatus_disabled;
    return (u_char*) &long_return;

  }
   case  DOT1QPORTGVRPFAILEDREGISTRATIONS:
        long_return = entry.dot1q_port_gvrp_failed_registrations;
        return (u_char*) &long_return;
   case  DOT1QPORTGVRPLASTPDUORIGIN:
           memcpy(return_buf, entry.dot1q_port_gvrp_last_pdu_origin, 6);
           *var_len = 6;
        return (u_char*) return_buf;
    default:
      ERROR_MSG("");
    }
    return NULL;
}


int
write_dot1qPvid(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    u_long value;
    int size;


   UI32_T  dot1qPvid;

    if ((char) name[12] != DOT1QPVID)
     {
        return SNMP_ERR_NOTWRITABLE;
    }
    if (name_len!=  14)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    dot1qPvid = *(u_long *)var_val;



    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_UNSIGNED) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(u_long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
         value = *(u_long *)var_val;
         if (value >    SYS_ADPT_MAX_VLAN_ID)
            return SNMP_ERR_WRONGVALUE;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
/*  when vlan provding dual mode,dot1qPvid cloude not be set*/
#if(SYS_CPNT_VLAN_PROVIDING_DUAL_MODE==TRUE)
              return SNMP_ERR_COMMITFAILED;
#else
                if(VLAN_PMGR_SetDot1qPvid (name[13],dot1qPvid) != TRUE)
                   return SNMP_ERR_COMMITFAILED;
#endif/*end of #if(SYS_CPNT_VLAN_PROVIDING_DUAL_MODE==TRUE)*/
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_dot1qPortAcceptableFrameTypes(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

   UI32_T  type;

    if ((char) name[12] != DOT1QPORTACCEPTABLEFRAMETYPES)
     {
        return SNMP_ERR_NOTWRITABLE;
    }
    if (name_len!=  14)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    type = *(long *)var_val;



    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          value = *(long *)var_val;

          if( (value <1) ||  (value >2))
              return SNMP_ERR_WRONGVALUE;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
/*  when vlan provding dual mode,Dot1qPortAcceptableFrameTypes cloude not be set*/
#if(SYS_CPNT_VLAN_PROVIDING_DUAL_MODE==TRUE)
              return SNMP_ERR_COMMITFAILED;
#else
          if (VLAN_PMGR_SetDot1qPortAcceptableFrameTypes( name[13],type)!=TRUE)
              return SNMP_ERR_COMMITFAILED;
#endif/*end of #if(SYS_CPNT_VLAN_PROVIDING_DUAL_MODE==TRUE)*/

          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_dot1qPortIngressFiltering(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;

   UI32_T  filter;

    if ((char) name[12] != DOT1QPORTINGRESSFILTERING)
     {
        return SNMP_ERR_NOTWRITABLE;
    }
    if (name_len!=  14)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    filter = *(long *)var_val;



    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
         value = *(long *)var_val;
         if ((value !=1) &&(value !=2))
            return SNMP_ERR_WRONGVALUE;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
                if(VLAN_PMGR_SetDot1qIngressFilter ( name[13],filter) != TRUE)
                  return SNMP_ERR_COMMITFAILED;
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_dot1qPortGvrpStatus(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

   UI32_T  status;

    if ((char) name[12] != DOT1QPORTGVRPSTATUS)
     {
        return SNMP_ERR_NOTWRITABLE;
    }
    if (name_len!=  14)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    status = *(long *)var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          value = *(long *)var_val;
          if ((value!=1) &&(value!=2))
             return SNMP_ERR_WRONGVALUE;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */

    switch(status)
    {
        case 2:
            status =0;
            break;
        default:
            return SNMP_ERR_COMMITFAILED;
            break;
    }

          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
#endif
