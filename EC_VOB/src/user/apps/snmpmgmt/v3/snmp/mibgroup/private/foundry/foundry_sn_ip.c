/* MODULE NAME:  foundry_sn_ip.c
 *
 * PURPOSE: For SNMP to access Brocade's FOUNDRY-SN-IP-MIB:
 *
 * foundry(1991).products(1).router(2).snIp(2)
 *
 * NOTES:
 *
 * HISTORY (mm/dd/yyyy)
 *    05/31/2011 - Qiyao Zhong, Created
 *
 * Copyright(C)      Accton Corporation, 2011
 */

/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.scalar.conf,v 1.8 2004/10/14 12:57:34 dts12 Exp $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

/* system
 */
#include "sys_type.h"
#include "sys_adpt.h"
#include "sys_cpnt.h"
#include "leaf_sys.h"
#include "leaf_foundry_sn_ip.h"

/* core (L3)
 */
#include "netcfg_type.h"
#include "netcfg_pmgr_nd.h"

/* SNMP itself
 */
#include "snmp_mgr.h"
#include "sysORTable.h"
#include "foundry_lib.h"
#include "foundry_sn_ip.h"

/* ------------------------------------------------------------------------
 * SCALAR NAME - 1.2.2.1.1 snRtClearArpCache
 * ------------------------------------------------------------------------
 */
void init_snRtClearArpCache(void)
{
    static oid snRtClearArpCache_oid[] = { 1,3,6,1,4,1,1991,1,2,2,1,1, 0 };

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("snRtClearArpCache",
                               do_snRtClearArpCache,
                               snRtClearArpCache_oid,
                               OID_LENGTH(snRtClearArpCache_oid),
                               HANDLER_CAN_RWRITE));
}

int do_snRtClearArpCache(netsnmp_mib_handler *handler,
    netsnmp_handler_registration *reginfo,
    netsnmp_agent_request_info *reqinfo,
    netsnmp_request_info *requests)
{
    /* dispatch get vs. set
     */
    switch (reqinfo->mode)
    {
        /*
         * GET REQUEST
         */
        case MODE_GET:
        {
            UI32_T var_len = 0;
            UI32_T value = VAL_snRtClearArpCache_normal;  /* fixed */

            /* get fixed value
             */
            var_len = 4;
            memcpy(return_buf, &value, sizeof(value));
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                (u_char *) return_buf, var_len);

            break;
        }

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            /* check type and length
             */
            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
                return SNMP_ERR_NOERROR;
            }

            break;

        case MODE_SET_RESERVE2:
            switch (*requests->requestvb->val.integer)
            {
                case VAL_snRtClearArpCache_normal:
                    break;

                case VAL_snRtClearArpCache_clear:
                    break;

                default:
                    netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
                    return SNMP_ERR_NOERROR;
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called.
             */
            break;

        case MODE_SET_ACTION:
        {
            /* set to core layer
             */
            if ( (*requests->requestvb->val.integer == VAL_snRtClearArpCache_clear)
                && (NETCFG_PMGR_ND_DeleteAllDynamicIpv4NetToMediaEntry() != NETCFG_TYPE_OK) )
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
                return SNMP_ERR_NOERROR;
            }

            break;
        }

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

/* ------------------------------------------------------------------------
 * FUNCTION NAME - init_snIp
 * ------------------------------------------------------------------------
 * PURPOSE  :   This is the entry point into this file for initialisation.
 *
 * INPUT    :   None.
 *
 * OUTPUT   :   None.
 *
 * RETURN   :   None.
 *
 * NOTES    :   None.
 * ------------------------------------------------------------------------
 */
void init_snIp(void)
{
    oid snSwitch_oid[] = { 1,3,6,1,4,1,1991,1,2,2 };

    /* register individual scalars
     */
    init_snRtClearArpCache();   /* 1.1 */

    /* register ourselves in the sysORTable
     */
    REGISTER_SYSOR_ENTRY(snSwitch_oid,
        "The Enterprise MIB for IP support in SNMP.");  /* not copied from Description */
}
