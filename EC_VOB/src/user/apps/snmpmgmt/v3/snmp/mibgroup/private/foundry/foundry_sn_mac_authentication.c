/* MODULE NAME:  foundry_sn_mac_authentication.c
 *
 * PURPOSE: For SNMP to access Brocade's FOUNDRY-SN-MAC-AUTHENTICATION-MIB:
 *
 * foundry(1991).products(1).switch(1).snSwitch(3).snMacAuth(28)
 *
 * NOTES:
 *
 * HISTORY (mm/dd/yyyy)
 *    04/29/2011 - Qiyao Zhong, Created
 *
 * Copyright(C)      Accton Corporation, 2011
 */

/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.scalar.conf,v 1.8 2004/10/14 12:57:34 dts12 Exp $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

#include "sys_type.h"
#include "sys_adpt.h"
#include "sys_cpnt.h"
#include "leaf_foundry_sn_mac_authentication.h"
#include "l_stdlib.h"
#include "sys_time.h"

#include "snmp_mgr.h"
#include "sysORTable.h"
#include "foundry_lib.h"
#include "foundry_sn_mac_authentication.h"

#if (SYS_CPNT_NETACCESS == TRUE)
#include "netaccess_pmgr.h"
#include "netaccess_type.h"
#endif  /* (SYS_CPNT_NETACCESS == TRUE) */

#if (SYS_CPNT_NETACCESS_MACAUTH == TRUE)  /* from near-beginning to end of file */
/* ------------------------------------------------------------------------
 * SCALAR NAME - 1.1.3.28.1 snMacAuthGlobal.snMacAuthClearGlobalCmd(1)
 * ------------------------------------------------------------------------
 */
void init_snMacAuthClearGlobalCmd(void)
{
    static oid snMacAuthClearGlobalCmd_oid[] = { 1,3,6,1,4,1,1991,1,1,3,28,1,1, 0 };

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("snMacAuthClearGlobalCmd",
                               do_snMacAuthClearGlobalCmd,
                               snMacAuthClearGlobalCmd_oid,
                               OID_LENGTH(snMacAuthClearGlobalCmd_oid),
                               HANDLER_CAN_RWRITE));
}

int do_snMacAuthClearGlobalCmd(netsnmp_mib_handler *handler,
    netsnmp_handler_registration *reginfo,
    netsnmp_agent_request_info *reqinfo,
    netsnmp_request_info *requests)
{
    /* dispatch get vs. set
     */
    switch (reqinfo->mode)
    {
        /*
         * GET REQUEST
         */
        case MODE_GET:
        {
            UI32_T var_len = 0;
            UI32_T value = VAL_snMacAuthClearGlobalCmd_valid;

            /* hard-coded value
             */
            var_len = 4;
            memcpy(return_buf, &value, sizeof(value));
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                (u_char *) return_buf, var_len);

            break;
        }

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
                return SNMP_ERR_NOERROR;
            }
            break;

        case MODE_SET_RESERVE2:
            switch (*requests->requestvb->val.integer)
            {
                case VAL_snMacAuthClearGlobalCmd_valid:
                    break;

                case VAL_snMacAuthClearGlobalCmd_clear:
                    break;

                default:
                    netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
                    return SNMP_ERR_NOERROR;
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called.
             */
            break;

        case MODE_SET_ACTION:
        {
            NETACCESS_MGR_SecureAddressFilter_T in_filter;

            /* set to core layer
             */
            switch (*requests->requestvb->val.integer)
            {
                /* nothing to do
                 */
                case VAL_snMacAuthClearGlobalCmd_valid:
                    break;

                /* clear
                 */
                case VAL_snMacAuthClearGlobalCmd_clear:
                    memset(&in_filter, 0, sizeof(NETACCESS_MGR_SecureAddressFilter_T));
                    in_filter.type = NETACCESS_ADDRESS_ENTRY_TYPE_DYNAMIC;

                    if (! NETACCESS_PMGR_ClearSecureAddressEntryByFilter(&in_filter))
                    {
                        netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
                    }
                    break;

                /* should not bappen
                 */
                default:
                    break;
            }

            break;
        }

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

/* ------------------------------------------------------------------------
 * TABLE NAME - 1.1.3.28.2 snMacAuthClearIfCmdTable
 * ------------------------------------------------------------------------
 */
oid snMacAuthClearIfCmdTable_variables_oid[] = { 1,3,6,1,4,1,1991,1,1,3,28 };

/* variable3 snMacAuthClearIfCmdTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */
struct variable3 snMacAuthClearIfCmdTable_variables[] =
{
    /* magic number, variable type, ro/rw, callback fn, L, oidsuffix
     *     (L = length of the oidsuffix)
     */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_snMacAuthClearIfCmdIfIndex, ASN_INTEGER, RONLY, var_snMacAuthClearIfCmdTable, 3, { 2, 1, 1 }},
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

    { LEAF_snMacAuthClearIfCmdAction, ASN_INTEGER, RWRITE, var_snMacAuthClearIfCmdTable, 3, { 2, 1, 2 }},
};

void init_snMacAuthClearIfCmdTable(void)
{
    /* Register ourselves with the agent to handle our MIB tree
     */
    REGISTER_MIB("snMacAuthClearIfCmdTable", snMacAuthClearIfCmdTable_variables, variable3,
                 snMacAuthClearIfCmdTable_variables_oid);
}

#define SNMACAUTHCLEARIFCMDENTRY_INSTANCE_LEN  1

BOOL_T snMacAuthClearIfCmdTable_OidIndexToData(UI32_T exact, UI32_T compc,
    oid *compl, UI32_T *snMacAuthClearIfCmdIfIndex)
{
    /* get or set
     */
    if (exact)
    {
        /* check the index length
         */
        if (compc != SNMACAUTHCLEARIFCMDENTRY_INSTANCE_LEN) /* the constant size index */
        {
            return FALSE;
        }
    }

    *snMacAuthClearIfCmdIfIndex = compl[0];

    return TRUE;
}

/*
 * var_snMacAuthClearIfCmdTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *var_snMacAuthClearIfCmdTable(struct variable *vp,
    oid *name,
    size_t *length,
    int exact,
    size_t *var_len,
    WriteMethod **write_method)
{
    UI32_T compc = 0;
    oid compl[SNMACAUTHCLEARIFCMDENTRY_INSTANCE_LEN] = {0};
    oid best_inst[SNMACAUTHCLEARIFCMDENTRY_INSTANCE_LEN] = {0};

    /* table-specific variables
     */
    NETACCESS_MGR_SecurePortEntry_T entry;
    UI32_T index, used_buffer;

    /* dispatch node to set write method
     */
    switch (vp->magic)
    {
        case LEAF_snMacAuthClearIfCmdAction:
            *write_method = write_snMacAuthClearIfCmdAction;
            break;

        default:
            *write_method = 0;
            break;
    }

    /* check compc, retrive compl
     */
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl,
        SNMACAUTHCLEARIFCMDENTRY_INSTANCE_LEN);

    memset(&entry, 0, sizeof(entry));

    /* dispatch get-exact versus get-next
     */
    if (exact) /* get or set */
    {
        /* extract index
         */
        if (! snMacAuthClearIfCmdTable_OidIndexToData(exact, compc, compl,
            &index))
        {
            return NULL;
        }

        /* get-exact from core layer;
         * borrow Port Security (in networkAccessPortTable) for indexes
         */
        if (NETACCESS_PMGR_GetSecurePortEntry(SYS_TYPE_FID_ALL, &index, &entry,
            sizeof(NETACCESS_MGR_SecurePortEntry_T), &used_buffer) != 0)
        {
            return NULL;
        }
    }
    else /* get-next */
    {
        /* extract index
         */
        snMacAuthClearIfCmdTable_OidIndexToData(exact, compc, compl,
            &index);

        /* Check the length of inputing index. If compc is less than instance
         * length, we should try get {A.B.C.0.0...}, where A.B.C was
         * obtained from the "..._OidIndexToData" function call, and
         * 0.0... was initialized in the beginning of this function.
         * This instance may exist in the core layer.
         */
        if (compc < SNMACAUTHCLEARIFCMDENTRY_INSTANCE_LEN)  /* incomplete index */
        {
            /* get-exact, in case this instance exists
             */
            if (NETACCESS_PMGR_GetSecurePortEntry(SYS_TYPE_FID_ALL, &index, &entry,
                sizeof(NETACCESS_MGR_SecurePortEntry_T), &used_buffer) != 0)
            {
                /* get-next according to lexicographic order; if none, fail
                 */
                if (NETACCESS_PMGR_GetNextSecurePortEntry(SYS_TYPE_FID_ALL, &index, &entry,
                    sizeof(NETACCESS_MGR_SecurePortEntry_T), &used_buffer) != 0)
                {
                    return NULL;
                }
            }
        }
        else  /* complete index */
        {
            /* get-next according to lexicographic order; if none, fail
             */
            if (NETACCESS_PMGR_GetNextSecurePortEntry(SYS_TYPE_FID_ALL, &index, &entry,
                    sizeof(NETACCESS_MGR_SecurePortEntry_T), &used_buffer) != 0)
            {
                return NULL;
            }
        }
    }

    /* copy base OID (without index) to output
     */
    memcpy(name, vp->name, vp->namelen * sizeof(oid));

    /* assign data to the OID index
     */
    best_inst[0] = index;
    memcpy(name + vp->namelen, best_inst, SNMACAUTHCLEARIFCMDENTRY_INSTANCE_LEN * sizeof(oid));
    *length = vp->namelen + SNMACAUTHCLEARIFCMDENTRY_INSTANCE_LEN;

    /* dispatch node to read value
     */
    switch (vp->magic)
    {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case LEAF_snMacAuthClearIfCmdIfIndex:
            *var_len = 4;
            long_return = index;
            return (u_char *) &long_return;
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

        case LEAF_snMacAuthClearIfCmdAction:
            *var_len = 4;
            long_return = VAL_snMacAuthClearIfCmdAction_valid;  /* always */
            return (u_char *) &long_return;

        default:
            ERROR_MSG("");
            break;
    }

    /* return failure
     */
    return NULL;
}

int write_snMacAuthClearIfCmdAction(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    /* dispatch action
     */
    switch (action)
    {
        case RESERVE1:
            /* check type and length
             */
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            /* check valid values
             */
            switch (*(long *) var_val)
            {
                case VAL_snMacAuthClearIfCmdAction_valid:
                    break;

                case VAL_snMacAuthClearIfCmdAction_clear:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = 14;
            I32_T value = 0;

            /* table-specific variables
             */
            NETACCESS_MGR_SecureAddressFilter_T in_filter;
            UI32_T snMacAuthClearIfCmdIfIndex = 0;

            /* extract index
             */
            if (! snMacAuthClearIfCmdTable_OidIndexToData(TRUE,
                name_len - oid_name_length,
                &(name[oid_name_length]),
                &snMacAuthClearIfCmdIfIndex))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            /* get user value
             */
            memcpy(&value, var_val, sizeof(I32_T));

            /* set to core layer
             */
            switch (value)
            {
                /* nothing to do
                 */
                case VAL_snMacAuthClearIfCmdAction_valid:
                    break;

                /* clear
                 */
                case VAL_snMacAuthClearIfCmdAction_clear:
                    memset(&in_filter, 0, sizeof(in_filter));
                    in_filter.type = NETACCESS_ADDRESS_ENTRY_TYPE_ALL;
                    in_filter.sort = NETACCESS_ADDRESS_ENTRY_SORT_INTERFACE;
                    in_filter.lport = snMacAuthClearIfCmdIfIndex;

                    if (!NETACCESS_PMGR_ClearSecureAddressEntryByFilter(&in_filter))
                    {
                        return SNMP_ERR_COMMITFAILED;
                    }

                    break;

                /* should not happen
                 */
                default:
                    return SNMP_ERR_WRONGVALUE;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    /* return success
     */
    return SNMP_ERR_NOERROR;
}

/* ------------------------------------------------------------------------
 * TABLE NAME - 1.1.3.28.3 snMacAuthTable
 * ------------------------------------------------------------------------
 */
oid snMacAuthTable_variables_oid[] = { 1,3,6,1,4,1,1991,1,1,3,28 };

/* variable3 snMacAuthTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */
struct variable3 snMacAuthTable_variables[] =
{
    /* magic number, variable type, ro/rw, callback fn, L, oidsuffix
     *     (L = length of the oidsuffix)
     */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_snMacAuthIfIndex, ASN_INTEGER, RONLY, var_snMacAuthTable, 3, { 3, 1, 1 }},
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_snMacAuthVlanId, ASN_INTEGER, RONLY, var_snMacAuthTable, 3, { 3, 1, 2 }},
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_snMacAuthMac, ASN_OCTET_STR, RONLY, var_snMacAuthTable, 3, { 3, 1, 3 }},
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

    { LEAF_snMacAuthState, ASN_INTEGER, RONLY, var_snMacAuthTable, 3, { 3, 1, 4 }},
    { LEAF_snMacAuthTimeStamp, ASN_TIMETICKS, RONLY, var_snMacAuthTable, 3, { 3, 1, 5 }},
    { LEAF_snMacAuthAge, ASN_INTEGER, RONLY, var_snMacAuthTable, 3, { 3, 1, 6 }},
    { LEAF_snMacAuthDot1x, ASN_INTEGER, RONLY, var_snMacAuthTable, 3, { 3, 1, 7 }},
};

void init_snMacAuthTable(void)
{
    /* Register ourselves with the agent to handle our MIB tree
     */
    REGISTER_MIB("snMacAuthTable", snMacAuthTable_variables, variable3,
                 snMacAuthTable_variables_oid);
}

#define SNMACAUTHENTRY_INSTANCE_LEN  8

BOOL_T snMacAuthTable_OidIndexToData(UI32_T exact, UI32_T compc,
    oid *compl, UI32_T *snMacAuthIfIndex, UI32_T *snMacAuthVlanId, UI8_T *snMacAuthMac)
{
    int i;

    /* get or set
     */
    if (exact)
    {
        /* check the index length
         */
        if (compc != SNMACAUTHENTRY_INSTANCE_LEN) /* the constant size index */
        {
            return FALSE;
        }
    }

    *snMacAuthIfIndex = compl[0];
    *snMacAuthVlanId = compl[1];

    for (i=0; i < SIZE_snMacAuthMac; i++)
    {
        snMacAuthMac[i] = compl[2 + i];
    }

    return TRUE;
}

/*
 * var_snMacAuthTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *var_snMacAuthTable(struct variable *vp,
    oid *name,
    size_t *length,
    int exact,
    size_t *var_len,
    WriteMethod **write_method)
{
    UI32_T compc = 0;
    oid compl[SNMACAUTHENTRY_INSTANCE_LEN] = {0};
    oid best_inst[SNMACAUTHENTRY_INSTANCE_LEN] = {0};

    /* table-specific variables
     */
    NETACCESS_MGR_SecureAddressEntryKeyFilter_T entry_key_filter;
    NETACCESS_MGR_SecureAddressEntry_T entry;
    UI32_T lport, dummy_vlan, used_buffer, i;
    UI8_T mac_addr_ar[SYS_TYPE_MAC_ADDR_LEN];

    /* dispatch node to set write method
     */
    switch (vp->magic)
    {
        default:
            *write_method = 0;
            break;
    }

    /* check compc, retrive compl
     */
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl,
        SNMACAUTHENTRY_INSTANCE_LEN);

    memset(&entry_key_filter, 0, sizeof(entry_key_filter));
    entry_key_filter.filter.type = NETACCESS_ADDRESS_ENTRY_TYPE_ALL;
    entry_key_filter.filter.sort = NETACCESS_ADDRESS_ENTRY_SORT_INTERFACE;

    memset(&entry, 0, sizeof(entry));

    /* dispatch get-exact versus get-next
     */
    if (exact) /* get or set */
    {
        /* structure for function "NETACCESS_PMGR_GetSecureAddressEntry"
         */
        NETACCESS_MGR_SecureAddressEntryKey_T entry_key = {0};

        /* extract index
         */
        if (! snMacAuthTable_OidIndexToData(exact, compc, compl,
            &lport, &dummy_vlan, mac_addr_ar))
        {
            return NULL;
        }

        /* get-exact from core layer
         */
        entry_key.lport = lport;
        memcpy(entry_key.mac_address, mac_addr_ar, SYS_TYPE_MAC_ADDR_LEN);

        if (NETACCESS_PMGR_GetSecureAddressEntry(SYS_TYPE_FID_ALL,
             &entry_key, &entry, sizeof(entry), &used_buffer) != 0)
        {
            return NULL;
        }
    }
    else /* get-next */
    {
        /* extract index
         */
        snMacAuthTable_OidIndexToData(exact, compc, compl,
            &lport, &dummy_vlan, mac_addr_ar);

        /* Check the length of inputing index. If compc is less than instance
         * length, we should try get {A.B.C.0.0...}, where A.B.C was
         * obtained from the "..._OidIndexToData" function call, and
         * 0.0... was initialized in the beginning of this function.
         * This instance may exist in the core layer.
         */
        if (compc < SNMACAUTHENTRY_INSTANCE_LEN)  /* incomplete index */
        {
            /* structure for function "NETACCESS_PMGR_GetSecureAddressEntry"
             */
            NETACCESS_MGR_SecureAddressEntryKey_T entry_key = {0};

            /* get-exact, in case this instance exists
             */
            entry_key.lport = lport;
            memcpy(entry_key.mac_address, mac_addr_ar, SYS_TYPE_MAC_ADDR_LEN);

            if (NETACCESS_PMGR_GetSecureAddressEntry(SYS_TYPE_FID_ALL,
                 &entry_key, &entry, sizeof(entry), &used_buffer) != 0)
            {
                /* get-next according to lexicographic order; if none, fail
                 */
                entry_key_filter.lport = lport;
                memcpy(entry_key_filter.mac_address, mac_addr_ar, SYS_TYPE_MAC_ADDR_LEN);

                if (NETACCESS_PMGR_GetNextSecureAddressEntryByFilter(SYS_TYPE_FID_ALL,
                    &entry_key_filter, &entry, sizeof(NETACCESS_MGR_SecureAddressEntry_T),
                    &used_buffer) != 0)
                {
                    return NULL;
                }
            }
        }
        else  /* complete index */
        {
            /* get-next according to lexicographic order; if none, fail
             */
            entry_key_filter.lport = lport;
            memcpy(entry_key_filter.mac_address, mac_addr_ar, SYS_TYPE_MAC_ADDR_LEN);

            if (NETACCESS_PMGR_GetNextSecureAddressEntryByFilter(SYS_TYPE_FID_ALL,
                &entry_key_filter, &entry, sizeof(NETACCESS_MGR_SecureAddressEntry_T),
                &used_buffer) != 0)
            {
                return NULL;
            }
        }
    }

    /* copy base OID (without index) to output
     */
    memcpy(name, vp->name, vp->namelen * sizeof(oid));

    /* assign data to the OID index
     */
    best_inst[0] = entry.addr_lport;
    best_inst[1] = 0;  /* snMacAuthVlanId not supported */

    for (i = 0; i < SIZE_snMacAuthMac; i++)
    {
        best_inst[2 + i] = entry_key_filter.mac_address[i];
    }

    memcpy(name + vp->namelen, best_inst, SNMACAUTHENTRY_INSTANCE_LEN * sizeof(oid));
    *length = vp->namelen + SNMACAUTHENTRY_INSTANCE_LEN;

    /* dispatch node to read value
     */
    switch (vp->magic)
    {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case LEAF_snMacAuthIfIndex:
            *var_len = 4;
            long_return = entry.addr_lport;
            return (u_char *) &long_return;
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case LEAF_snMacAuthVlanId:
            *var_len = 4;
            long_return = 0;  /* snMacAuthVlanId not supported */
            return (u_char *) &long_return;
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case LEAF_snMacAuthMac:
            *var_len = SIZE_snMacAuthMac;
            memcpy(return_buf, entry.addr_MAC, *var_len);
            return (u_char *) return_buf;
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

        case LEAF_snMacAuthState:
            *var_len = 4;
            long_return = VAL_snMacAuthState_authenticate;  /* not supported */
            return (u_char *) &long_return;

        case LEAF_snMacAuthTimeStamp:
            {
                UI32_T uptime_timeticks;    /* sysUpTime */
                UI32_T now_unixseconds;     /* date-time */

                /* Input "entry.record_time" is Unix time to the second.
                 * Output "snMacAuthTimeStamp" is of type TimesStamp (sysUpTime).
                 */
                SYS_TIME_GetSystemUpTimeByTick(&uptime_timeticks);
                SYS_TIME_GetSoftwareClockBySec(&now_unixseconds);

                *var_len = 4;

                long_return = uptime_timeticks - (now_unixseconds - entry.record_time) * 100;
                return (u_char *) &long_return;
            }

        case LEAF_snMacAuthAge:
            {
                UI32_T now_unixseconds;     /* date-time */

                /* Input "entry.record_time" is Unix time to the second.
                 * Output "snMacAuthAge" is of type TimesStamp (TimeTicks).
                 */
                SYS_TIME_GetSoftwareClockBySec(&now_unixseconds);

                *var_len = 4;

                long_return = (now_unixseconds - entry.record_time) * 100;
            }

            return (u_char *) &long_return;

        case LEAF_snMacAuthDot1x:
            *var_len = 4;
            long_return = VAL_snMacAuthDot1x_disabled;  /* not supported */
            return (u_char *) &long_return;

        default:
            ERROR_MSG("");
            break;
    }

    /* return failure
     */
    return NULL;
}

/* ------------------------------------------------------------------------
 * TABLE NAME - 1.1.3.28.4 snMacAuthClearMacSessionTable
 * ------------------------------------------------------------------------
 */
oid snMacAuthClearMacSessionTable_variables_oid[] = { 1,3,6,1,4,1,1991,1,1,3,28 };

/* variable3 snMacAuthClearMacSessionTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */
struct variable3 snMacAuthClearMacSessionTable_variables[] =
{
    /* magic number, variable type, ro/rw, callback fn, L, oidsuffix
     *     (L = length of the oidsuffix)
     */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_snMacAuthClearMacSessionIfIndex, ASN_INTEGER, RONLY, var_snMacAuthClearMacSessionTable, 3, { 4, 1, 1 }},
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_snMacAuthClearMacSessionMac, ASN_OCTET_STR, RONLY, var_snMacAuthClearMacSessionTable, 3, { 4, 1, 2 }},
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

    { LEAF_snMacAuthClearMacSessionAction, ASN_INTEGER, RWRITE, var_snMacAuthClearMacSessionTable, 3, { 4, 1, 3 }},
};

void init_snMacAuthClearMacSessionTable(void)
{
    /* Register ourselves with the agent to handle our MIB tree
     */
    REGISTER_MIB("snMacAuthClearMacSessionTable", snMacAuthClearMacSessionTable_variables, variable3,
                 snMacAuthClearMacSessionTable_variables_oid);
}

#define SNMACAUTHCLEARMACSESSIONENTRY_INSTANCE_LEN  7

BOOL_T snMacAuthClearMacSessionTable_OidIndexToData(UI32_T exact, UI32_T compc,
    oid *compl, UI32_T *snMacAuthClearMacSessionIfIndex, UI8_T *snMacAuthClearMacSessionMac)
{
    int i;

    /* get or set
     */
    if (exact)
    {
        /* check the index length
         */
        if (compc != SNMACAUTHCLEARMACSESSIONENTRY_INSTANCE_LEN) /* the constant size index */
        {
            return FALSE;
        }
    }

    *snMacAuthClearMacSessionIfIndex = compl[0];

    for (i=0; i < SIZE_snMacAuthClearMacSessionMac; i++)
    {
        snMacAuthClearMacSessionMac[i] = compl[1 + i];
    }

    return TRUE;
}

/*
 * var_snMacAuthClearMacSessionTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *var_snMacAuthClearMacSessionTable(struct variable *vp,
    oid *name,
    size_t *length,
    int exact,
    size_t *var_len,
    WriteMethod **write_method)
{
    UI32_T compc = 0;
    oid compl[SNMACAUTHCLEARMACSESSIONENTRY_INSTANCE_LEN] = {0};
    oid best_inst[SNMACAUTHCLEARMACSESSIONENTRY_INSTANCE_LEN] = {0};

    /* table-specific variables
     */
    NETACCESS_MGR_SecureAddressEntryKeyFilter_T entry_key_filter;
    NETACCESS_MGR_SecureAddressEntry_T entry;
    UI32_T lport, used_buffer, i;
    UI8_T mac_addr_ar[SYS_TYPE_MAC_ADDR_LEN];

    /* dispatch node to set write method
     */
    switch (vp->magic)
    {
        case LEAF_snMacAuthClearMacSessionAction:
            *write_method = write_snMacAuthClearMacSessionAction;
            break;

        default:
            *write_method = 0;
            break;
    }

    /* check compc, retrive compl
     */
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl,
        SNMACAUTHCLEARMACSESSIONENTRY_INSTANCE_LEN);

    memset(&entry_key_filter, 0, sizeof(entry_key_filter));
    entry_key_filter.filter.type = NETACCESS_ADDRESS_ENTRY_TYPE_ALL;
    entry_key_filter.filter.sort = NETACCESS_ADDRESS_ENTRY_SORT_INTERFACE;

    memset(&entry, 0, sizeof(entry));

    /* dispatch get-exact versus get-next
     */
    if (exact) /* get or set */
    {
        /* structure for function "NETACCESS_PMGR_GetSecureAddressEntry"
         */
        NETACCESS_MGR_SecureAddressEntryKey_T entry_key = {0};

        /* extract index
         */
        if (! snMacAuthClearMacSessionTable_OidIndexToData(exact, compc, compl,
            &lport, mac_addr_ar))
        {
            return NULL;
        }

        /* get-exact from core layer
         */
        entry_key.lport = lport;
        memcpy(entry_key.mac_address, mac_addr_ar, SYS_TYPE_MAC_ADDR_LEN);

        if (NETACCESS_PMGR_GetSecureAddressEntry(SYS_TYPE_FID_ALL,
             &entry_key, &entry, sizeof(entry), &used_buffer) != 0)
        {
            return NULL;
        }
    }
    else /* get-next */
    {
        /* extract index
         */
        snMacAuthClearMacSessionTable_OidIndexToData(exact, compc, compl,
            &lport, mac_addr_ar);

        /* Check the length of inputing index. If compc is less than instance
         * length, we should try get {A.B.C.0.0...}, where A.B.C was
         * obtained from the "..._OidIndexToData" function call, and
         * 0.0... was initialized in the beginning of this function.
         * This instance may exist in the core layer.
         */
        if (compc < SNMACAUTHCLEARMACSESSIONENTRY_INSTANCE_LEN)  /* incomplete index */
        {
            /* structure for function "NETACCESS_PMGR_GetSecureAddressEntry"
             */
            NETACCESS_MGR_SecureAddressEntryKey_T entry_key = {0};

            /* get-exact, in case this instance exists
             */
            entry_key.lport = lport;
            memcpy(entry_key.mac_address, mac_addr_ar, SYS_TYPE_MAC_ADDR_LEN);

            if (NETACCESS_PMGR_GetSecureAddressEntry(SYS_TYPE_FID_ALL,
                 &entry_key, &entry, sizeof(entry), &used_buffer) != 0)
            {
                /* get-next according to lexicographic order; if none, fail
                 */
                entry_key_filter.lport = lport;
                memcpy(entry_key_filter.mac_address, mac_addr_ar, SYS_TYPE_MAC_ADDR_LEN);

                if (NETACCESS_PMGR_GetNextSecureAddressEntryByFilter(SYS_TYPE_FID_ALL,
                    &entry_key_filter, &entry, sizeof(NETACCESS_MGR_SecureAddressEntry_T),
                    &used_buffer) != 0)
                {
                    return NULL;
                }
            }
        }
        else  /* complete index */
        {
            /* get-next according to lexicographic order; if none, fail
             */
            entry_key_filter.lport = lport;
            memcpy(entry_key_filter.mac_address, mac_addr_ar, SYS_TYPE_MAC_ADDR_LEN);

            if (NETACCESS_PMGR_GetNextSecureAddressEntryByFilter(SYS_TYPE_FID_ALL,
                &entry_key_filter, &entry, sizeof(NETACCESS_MGR_SecureAddressEntry_T),
                &used_buffer) != 0)
            {
                return NULL;
            }
        }
    }

    /* copy base OID (without index) to output
     */
    memcpy(name, vp->name, vp->namelen * sizeof(oid));

    /* assign data to the OID index
     */
    best_inst[0] = entry.addr_lport;

    for (i = 0; i < SIZE_snMacAuthClearMacSessionMac; i++)
    {
        best_inst[1 + i] = entry_key_filter.mac_address[i];
    }

    memcpy(name + vp->namelen, best_inst, SNMACAUTHCLEARMACSESSIONENTRY_INSTANCE_LEN * sizeof(oid));
    *length = vp->namelen + SNMACAUTHCLEARMACSESSIONENTRY_INSTANCE_LEN;

    /* dispatch node to read value
     */
    switch (vp->magic)
    {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case LEAF_snMacAuthClearMacSessionIfIndex:
            *var_len = 4;
            long_return = entry.addr_lport;
            return (u_char *) &long_return;
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case LEAF_snMacAuthClearMacSessionMac:
            *var_len = SIZE_snMacAuthClearMacSessionMac;
            memcpy(return_buf, entry.addr_MAC, *var_len);
            return (u_char *) return_buf;
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

        case LEAF_snMacAuthClearMacSessionAction:
            *var_len = 4;
            long_return = VAL_snMacAuthClearMacSessionAction_valid;  /* fixed */
            return (u_char *) &long_return;

        default:
            ERROR_MSG("");
            break;
    }

    /* return failure
     */
    return NULL;
}

int write_snMacAuthClearMacSessionAction(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    /* dispatch action
     */
    switch (action)
    {
        case RESERVE1:
            /* check type and length
             */
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            /* check valid values
             */
            switch (*(long *) var_val)
            {
                case VAL_snMacAuthClearMacSessionAction_valid:
                    break;

                case VAL_snMacAuthClearMacSessionAction_clear:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = 14;
            I32_T value = 0;

            /* table-specific variables
             */
            NETACCESS_MGR_SecureAddressFilter_T in_filter;
            UI32_T snMacAuthClearMacSessionIfIndex = 0;
            UI8_T snMacAuthClearMacSessionMac[SIZE_snMacAuthClearMacSessionMac] = {0};

            /* extract index
             */
            if (! snMacAuthClearMacSessionTable_OidIndexToData(TRUE,
                name_len - oid_name_length,
                &(name[oid_name_length]),
                &snMacAuthClearMacSessionIfIndex, snMacAuthClearMacSessionMac))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            /* get user value
             */
            memcpy(&value, var_val, sizeof(I32_T));

            switch (value)
            {
                /* nothing to do
                 */
                case VAL_snMacAuthClearIfCmdAction_valid:
                    break;

                /* clear
                 */
                case VAL_snMacAuthClearIfCmdAction_clear:
                    memset(&in_filter, 0, sizeof(in_filter));
                    in_filter.type = NETACCESS_ADDRESS_ENTRY_TYPE_ALL;
                    in_filter.sort = NETACCESS_ADDRESS_ENTRY_SORT_INTERFACE;
                    in_filter.lport = snMacAuthClearMacSessionIfIndex;
                    memcpy(in_filter.mac, snMacAuthClearMacSessionMac, SYS_TYPE_MAC_ADDR_LEN);

                    if (!NETACCESS_PMGR_ClearSecureAddressEntryByFilter(&in_filter))
                    {
                        return SNMP_ERR_COMMITFAILED;
                    }

                    break;

                /* should not happen
                 */
                default:
                    return SNMP_ERR_WRONGVALUE;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    /* return success
     */
    return SNMP_ERR_NOERROR;
}

/* ------------------------------------------------------------------------
 * FUNCTION NAME - init_snMacAuth
 * ------------------------------------------------------------------------
 * PURPOSE  :   The is the entry point into this file for initialisation.
 *
 * INPUT    :   None.
 *
 * OUTPUT   :   None.
 *
 * RETURN   :   None.
 *
 * NOTES    :   None.
 * ------------------------------------------------------------------------
 */
void init_snMacAuth(void)
{
    oid snMacAuth_oid[] = { 1,3,6,1,4,1,1991,1,1,3,28 };

    /* register individual scalars
     */
    init_snMacAuthClearGlobalCmd();

    /* register individual tables
     */
    init_snMacAuthClearIfCmdTable();
    init_snMacAuthTable();
    init_snMacAuthClearMacSessionTable();

    /* register ourselves in the sysORTable
     */
    REGISTER_SYSOR_ENTRY(snMacAuth_oid,
        "Management Information Base module for MAC authentication "
 	    "configuration and statistics.");
}
#endif  /* (SYS_CPNT_NETACCESS_MACAUTH == TRUE); from near-beginning to end of file */
