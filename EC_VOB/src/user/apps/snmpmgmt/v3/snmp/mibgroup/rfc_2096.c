/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.scalar.conf,v 1.5 2002/07/18 14:18:52 dts12 Exp $
 */
#include "sys_cpnt.h"
#if (SYS_CPNT_ROUTING == TRUE)
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "sysORTable.h"
#include "rfc_2096.h"
#include "leaf_2096.h"
#include "ip_lib.h"
#include "netcfg_type.h"
#if (SYS_CPNT_NSM == TRUE)
#include "nsm_type.h"
#include "nsm_mgr.h"
#include "nsm_pmgr.h"
#endif
#include "snmp_mgr.h"

#define ipCidrRouteEntry_INSTANCE_LEN 13
#define ipCidrRouteEntry_OID_NAME_LEN 11

/** Initializes the ipForwardNumber module */
void
init_ipForwardNumber(void)
{
    static oid      ipForwardNumber_oid[] =
        { 1, 3, 6, 1, 2, 1, 4, 24, 1, 0 };

    DEBUGMSGTL(("ipForwardNumber", "Initializing\n"));

    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("ipForwardNumber",
                                         get_ipForwardNumber,
                                         ipForwardNumber_oid,
                                         OID_LENGTH(ipForwardNumber_oid),
                                         HANDLER_CAN_RONLY));
}

int
get_ipForwardNumber(netsnmp_mib_handler *handler,
                    netsnmp_handler_registration *reginfo,
                    netsnmp_agent_request_info *reqinfo,
                    netsnmp_request_info *requests)
{
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one.
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        {/* 2004/May/24 kelin added. not auto-generated */
            /*not support now always return 0*/
            long_return = 0;
            snmp_set_var_typed_value(requests->requestvb, ASN_GAUGE, (u_char *)&long_return, sizeof(long_return));
            break;
        }
        break;


    default:
        /*
         * we should never get here, so this is a really bad error
         */
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

/** Initializes the ipCidrRouteNumber module */
void
init_ipCidrRouteNumber(void)
{
    static oid      ipCidrRouteNumber_oid[] =
        { 1, 3, 6, 1, 2, 1, 4, 24, 3, 0 };

    DEBUGMSGTL(("ipCidrRouteNumber", "Initializing\n"));

    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("ipCidrRouteNumber",
                                         get_ipCidrRouteNumber,
                                         ipCidrRouteNumber_oid,
                                         OID_LENGTH(ipCidrRouteNumber_oid),
                                         HANDLER_CAN_RONLY));
}

int
get_ipCidrRouteNumber(netsnmp_mib_handler *handler,
                      netsnmp_handler_registration *reginfo,
                      netsnmp_agent_request_info *reqinfo,
                      netsnmp_request_info *requests)
{
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one.
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        {/* 2004/May/24 kelin added. not auto-generated */
            UI32_T ipCidrRouteNumber;
            UI32_T fib_number = 0;
            UI8_T multipath_num = 0;

            if (NSM_PMGR_GetRouteNumber(NSM_MGR_ROUTE_TYPE_IPV4_ALL, &ipCidrRouteNumber,
                                    &fib_number, &multipath_num) != NSM_TYPE_RESULT_OK)
            {
                return SNMP_ERR_GENERR;
            }

            long_return = ipCidrRouteNumber;
            snmp_set_var_typed_value(requests->requestvb, ASN_GAUGE, (u_char *)&long_return, sizeof(long_return));
            break;
        }
        break;


    default:
        /*
         * we should never get here, so this is a really bad error
         */
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

/*
 * ipCidrRouteTable_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid             ipCidrRouteTable_variables_oid[] =
    { 1, 3, 6, 1, 2, 1, 4, 24 };

/*
 * variable3 ipCidrRouteTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */

struct variable3 ipCidrRouteTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */

#define IPCIDRROUTEDEST     1
    {IPCIDRROUTEDEST, ASN_IPADDRESS, RONLY, var_ipCidrRouteTable, 3,
     {4, 1, 1}},
#define IPCIDRROUTEMASK     2
    {IPCIDRROUTEMASK, ASN_IPADDRESS, RONLY, var_ipCidrRouteTable, 3,
     {4, 1, 2}},
#define IPCIDRROUTETOS      3
    {IPCIDRROUTETOS, ASN_INTEGER, RONLY, var_ipCidrRouteTable, 3,
     {4, 1, 3}},
#define IPCIDRROUTENEXTHOP      4
    {IPCIDRROUTENEXTHOP, ASN_IPADDRESS, RONLY, var_ipCidrRouteTable, 3,
     {4, 1, 4}},
#define IPCIDRROUTEIFINDEX      5
    {IPCIDRROUTEIFINDEX, ASN_INTEGER, RWRITE, var_ipCidrRouteTable, 3,
     {4, 1, 5}},
#define IPCIDRROUTETYPE     6
    {IPCIDRROUTETYPE, ASN_INTEGER, RWRITE, var_ipCidrRouteTable, 3,
     {4, 1, 6}},
#define IPCIDRROUTEPROTO        7
    {IPCIDRROUTEPROTO, ASN_INTEGER, RONLY, var_ipCidrRouteTable, 3,
     {4, 1, 7}},
#define IPCIDRROUTEAGE      8
    {IPCIDRROUTEAGE, ASN_INTEGER, RONLY, var_ipCidrRouteTable, 3,
     {4, 1, 8}},
#define IPCIDRROUTEINFO     9
    {IPCIDRROUTEINFO, ASN_OBJECT_ID, RWRITE, var_ipCidrRouteTable, 3,
     {4, 1, 9}},
#define IPCIDRROUTENEXTHOPAS        10
    {IPCIDRROUTENEXTHOPAS, ASN_INTEGER, RWRITE, var_ipCidrRouteTable, 3,
     {4, 1, 10}},
#define IPCIDRROUTEMETRIC1      11
    {IPCIDRROUTEMETRIC1, ASN_INTEGER, RWRITE, var_ipCidrRouteTable, 3,
     {4, 1, 11}},
#define IPCIDRROUTEMETRIC2      12
    {IPCIDRROUTEMETRIC2, ASN_INTEGER, RWRITE, var_ipCidrRouteTable, 3,
     {4, 1, 12}},
#define IPCIDRROUTEMETRIC3      13
    {IPCIDRROUTEMETRIC3, ASN_INTEGER, RWRITE, var_ipCidrRouteTable, 3,
     {4, 1, 13}},
#define IPCIDRROUTEMETRIC4      14
    {IPCIDRROUTEMETRIC4, ASN_INTEGER, RWRITE, var_ipCidrRouteTable, 3,
     {4, 1, 14}},
#define IPCIDRROUTEMETRIC5      15
    {IPCIDRROUTEMETRIC5, ASN_INTEGER, RWRITE, var_ipCidrRouteTable, 3,
     {4, 1, 15}},
#define IPCIDRROUTESTATUS       16
    {IPCIDRROUTESTATUS, ASN_INTEGER, RWRITE, var_ipCidrRouteTable, 3,
     {4, 1, 16}},
};
/*
 * (L = length of the oidsuffix)
 */


/** Initializes the ipCidrRouteTable module */
void
init_ipCidrRouteTable(void)
{
    static oid      ipForwardStdMIB_module_oid[] =
        { 1, 3, 6, 1, 2, 1, 4, 24 };

    DEBUGMSGTL(("ipCidrRouteTable", "Initializing\n"));

    /*
     * register ourselves with the agent to handle our mib tree
     */
    REGISTER_MIB("ipCidrRouteTable", ipCidrRouteTable_variables, variable3,
                 ipCidrRouteTable_variables_oid);

    /*
     * place any other initialization junk you need here
     */
    REGISTER_SYSOR_ENTRY(ipForwardStdMIB_module_oid,
                         "The MIB module for the display of CIDR multipath IP Routes.");
}

/* 2004/May/24 kelin added. not auto-generated */
static BOOL_T
ipCidrRouteTable_get(int    compc,
                     oid    *compl,
                     NSM_TYPE_IpCidrRouteEntry_T    *data)
{
    UI32_T dest = 0;
    UI32_T mask = 0;
    UI32_T nexthop = 0;

    if (compc != ipCidrRouteEntry_INSTANCE_LEN)
    {
        return FALSE;
    }

    SNMP_MGR_ReadIpFromCompl(compl, 0, &dest);
    SNMP_MGR_ReadIpFromCompl(compl, 4, &mask);
    data->ip_cidr_route_tos = compl[8];
    SNMP_MGR_ReadIpFromCompl(compl, 9, &nexthop);

    IP_LIB_UI32toArray(dest, data->ip_cidr_route_dest);
    IP_LIB_UI32toArray(mask, data->ip_cidr_route_mask);
    IP_LIB_UI32toArray(nexthop, data->ip_cidr_route_next_hop);

    if (NSM_PMGR_SnmpGetRoute(data) != NSM_TYPE_RESULT_OK)
    {
        return FALSE;
    }
    else
    {
        return TRUE;
    } /*End of if */
}

/* 2004/May/24 kelin added. not auto-generated */
static BOOL_T
ipCidrRouteTable_next(int   compc,
                      oid   *compl,
                      NSM_TYPE_IpCidrRouteEntry_T   *data)
{
    oid tmp_compl[ipCidrRouteEntry_INSTANCE_LEN];
    UI32_T dest = 0;
    UI32_T mask = 0;
    UI32_T nexthop = 0;

    /* Generate the instance of each table entry and find the
     * smallest instance that's larger than compc/compl.
     *
     * Step 1: Verify and extract the input key from "compc" and "compl"
     * Note: The number of input key is defined by "compc".
     *       The key for the specified instance is defined in compl.
     */
    memcpy(tmp_compl, compl, sizeof(tmp_compl));
    SNMP_MGR_checkCompl(0, 7, tmp_compl, 255);
    SNMP_MGR_checkCompl(9, 12, tmp_compl, 255);
    SNMP_MGR_ConvertRemainToZero(compc, ipCidrRouteEntry_INSTANCE_LEN, tmp_compl);

    SNMP_MGR_ReadIpFromCompl(compl, 0, &dest);
    SNMP_MGR_ReadIpFromCompl(compl, 4, &mask);
    data->ip_cidr_route_tos = compl[8];
    SNMP_MGR_ReadIpFromCompl(compl, 9, &nexthop);

    IP_LIB_UI32toArray(dest, data->ip_cidr_route_dest);
    IP_LIB_UI32toArray(mask, data->ip_cidr_route_mask);
    IP_LIB_UI32toArray(nexthop, data->ip_cidr_route_next_hop);

    if (NSM_PMGR_SnmpGetNextRoute(data) != NSM_TYPE_RESULT_OK)
        {
            return FALSE;
        }
    return TRUE;
}

/*
 * var_ipCidrRouteTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_ipCidrRouteTable(struct variable *vp,
                     oid * name,
                     size_t * length,
                     int exact,
                     size_t * var_len, WriteMethod ** write_method)
{
    UI32_T compc = 0;
    oid compl[ipCidrRouteEntry_INSTANCE_LEN];
    oid best_inst[ipCidrRouteEntry_INSTANCE_LEN];
    NSM_TYPE_IpCidrRouteEntry_T data;
    UI32_T Index1, Index2, Index3;

    memset(&data, 0, sizeof(NSM_TYPE_IpCidrRouteEntry_T));

    switch (vp->magic)
{
        case IPCIDRROUTEIFINDEX:
            *write_method = write_ipCidrRouteIfIndex;
            break;
        case IPCIDRROUTETYPE:
            *write_method = write_ipCidrRouteType;
            break;
        case IPCIDRROUTEINFO:
            *write_method = write_ipCidrRouteInfo;
            break;
        case IPCIDRROUTENEXTHOPAS:
            *write_method = write_ipCidrRouteNextHopAS;
            break;
        case IPCIDRROUTEMETRIC1:
            *write_method = write_ipCidrRouteMetric1;
            break;
        case IPCIDRROUTEMETRIC2:
            *write_method = write_ipCidrRouteMetric2;
            break;
        case IPCIDRROUTEMETRIC3:
            *write_method = write_ipCidrRouteMetric3;
            break;
        case IPCIDRROUTEMETRIC4:
            *write_method = write_ipCidrRouteMetric4;
            break;
        case IPCIDRROUTEMETRIC5:
            *write_method = write_ipCidrRouteMetric5;
            break;
        case IPCIDRROUTESTATUS:
            *write_method = write_ipCidrRouteStatus;
            break;
        default:
            *write_method = 0;
            break;
    }

    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl, ipCidrRouteEntry_INSTANCE_LEN);

    /*check compc, retrive compl*/
    if (exact)/* get, set */
    {
        if (!ipCidrRouteTable_get(compc, compl, &data))
            return NULL;
    }
    else/* getnext */
    {
        if (!ipCidrRouteTable_next(compc, compl, &data))
        {
            return NULL;
        }
    }

    memcpy(name, vp->name, vp->namelen*sizeof(oid));
    IP_LIB_ArraytoUI32(data.ip_cidr_route_dest, &Index1);
    IP_LIB_ArraytoUI32(data.ip_cidr_route_mask, &Index2);
    IP_LIB_ArraytoUI32(data.ip_cidr_route_next_hop, &Index3);
    SNMP_MGR_BindIpInstance(Index1, 0, best_inst);
    SNMP_MGR_BindIpInstance(Index2, 4, best_inst);
    best_inst[8] = data.ip_cidr_route_tos;
    SNMP_MGR_BindIpInstance(Index3, 9, best_inst);
    memcpy(name + vp->namelen, best_inst, ipCidrRouteEntry_INSTANCE_LEN*sizeof(oid));
    *length = vp->namelen + ipCidrRouteEntry_INSTANCE_LEN;

    *var_len = sizeof(long_return);

   /*Since this table allow for entry that does not exist, (creation). we need to know the write method first*/

    /*
     * * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic)
{
        case IPCIDRROUTEDEST:
            *var_len = sizeof(ipaddr_return);
            IP_LIB_ArraytoUI32(data.ip_cidr_route_dest, &ipaddr_return);
            return (u_char *) &ipaddr_return;
        case IPCIDRROUTEMASK:
            *var_len = sizeof(ipaddr_return);
            IP_LIB_ArraytoUI32(data.ip_cidr_route_mask, &ipaddr_return);
            return (u_char *) &ipaddr_return;
        case IPCIDRROUTETOS:
            long_return = data.ip_cidr_route_tos;
            return (u_char *) &long_return;
        case IPCIDRROUTENEXTHOP:
            *var_len = sizeof(ipaddr_return);
            IP_LIB_ArraytoUI32(data.ip_cidr_route_next_hop, &ipaddr_return);
            return (u_char *) &ipaddr_return;
        case IPCIDRROUTEIFINDEX:
            long_return = data.ip_cidr_route_if_index;
            return (u_char *) &long_return;
        case IPCIDRROUTETYPE:
            long_return = data.ip_cidr_route_type;
            return (u_char *) &long_return;
        case IPCIDRROUTEPROTO:
            long_return = data.ip_cidr_route_proto;
            return (u_char *) &long_return;
        case IPCIDRROUTEAGE:
            long_return = data.ip_cidr_route_age;
            return (u_char *) &long_return;
        case IPCIDRROUTEINFO:
            long_return = 0;
            return (u_char *) &long_return;
        case IPCIDRROUTENEXTHOPAS:
            long_return = data.ip_cidr_route_nextHopAS;
            return (u_char *) &long_return;
        case IPCIDRROUTEMETRIC1:
            long_return = data.ip_cidr_route_metric1;
            return (u_char *) &long_return;
        case IPCIDRROUTEMETRIC2:
            long_return = -1;
            return (u_char *) &long_return;
        case IPCIDRROUTEMETRIC3:
            long_return = -1;
            return (u_char *) &long_return;
        case IPCIDRROUTEMETRIC4:
            long_return = -1;
            return (u_char *) &long_return;
        case IPCIDRROUTEMETRIC5:
            long_return = -1;
            return (u_char *) &long_return;
        case IPCIDRROUTESTATUS:
            long_return = data.ip_cidr_route_status;
            return (u_char *) &long_return;
        default:
            break;
    }
    return NULL;
}


int
write_ipCidrRouteIfIndex(int action,
                         u_char * var_val,
                         u_char var_val_type,
                         size_t var_val_len,
                         u_char * statP, oid * name, size_t name_len)
{
    NSM_TYPE_IpCidrRouteEntry_T data;
    long            value = 0;
    UI16_T   dest_idx_offset = ipCidrRouteEntry_OID_NAME_LEN;             /* 11 */
    UI16_T   mask_idx_offset = ipCidrRouteEntry_OID_NAME_LEN + 4;       /*15 */
    UI16_T   tos_idx_offset = ipCidrRouteEntry_OID_NAME_LEN + 8;         /* 19 */
    UI16_T   nexthop_idx_offset = ipCidrRouteEntry_OID_NAME_LEN + 9;   /* 20 */

    UI32_T tos = (char)name[tos_idx_offset]*1;

    memset(&data, 0, sizeof(NSM_TYPE_IpCidrRouteEntry_T));

     if (tos != 0)
     { /* Do not support tos = 0 */
        return SNMP_ERR_COMMITFAILED;
     }
    switch (action)
{
    case RESERVE1:
        if (name_len != ipCidrRouteEntry_OID_NAME_LEN + ipCidrRouteEntry_INSTANCE_LEN)
        {
            return SNMP_ERR_WRONGLENGTH;
        }

        if (var_val_type != ASN_INTEGER)
        {
            return SNMP_ERR_WRONGTYPE;
        }

        if (var_val_len > sizeof(long))
        {
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        value = *(long *)var_val;
        if (value < 0)
            return SNMP_ERR_WRONGVALUE;
        break;

    case FREE:
        break;

    case ACTION:
        {
            UI32_T dst_ipAddress = 0;
            UI32_T netmask_Address = 0 ;
            UI32_T gateway_Address = 0 ;

            SNMP_MGR_ReadIpFromCompl(name, dest_idx_offset, &dst_ipAddress);
            SNMP_MGR_ReadIpFromCompl(name, mask_idx_offset, &netmask_Address);
            SNMP_MGR_ReadIpFromCompl(name, nexthop_idx_offset, &gateway_Address);

            IP_LIB_UI32toArray(dst_ipAddress, data.ip_cidr_route_dest);
            IP_LIB_UI32toArray(netmask_Address, data.ip_cidr_route_mask);
            IP_LIB_UI32toArray(gateway_Address, data.ip_cidr_route_next_hop);

            data.ip_cidr_route_if_index = *(long *)var_val;
            data.ip_cidr_route_set_mask |= NSM_TYPE_SNMP_SET_IPCIDRTABLE_IFINDEX;

            if (NSM_PMGR_SnmpSetRoute(&data) != NSM_TYPE_RESULT_OK)
            {
                return SNMP_ERR_COMMITFAILED;
            }
        }

    case UNDO:
    case COMMIT:
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_ipCidrRouteType(int action,
                      u_char * var_val,
                      u_char var_val_type,
                      size_t var_val_len,
                      u_char * statP, oid * name, size_t name_len)
{
    NSM_TYPE_IpCidrRouteEntry_T data;
    long            value = 0;
    UI16_T   dest_idx_offset = ipCidrRouteEntry_OID_NAME_LEN;             /* 11 */
    UI16_T   mask_idx_offset = ipCidrRouteEntry_OID_NAME_LEN + 4;       /*15 */
    UI16_T   tos_idx_offset = ipCidrRouteEntry_OID_NAME_LEN + 8;         /* 19 */
    UI16_T   nexthop_idx_offset = ipCidrRouteEntry_OID_NAME_LEN + 9;   /* 20 */

    UI32_T tos = (char)name[tos_idx_offset]*1;

    memset(&data, 0, sizeof(NSM_TYPE_IpCidrRouteEntry_T));

     if (tos != 0)
     { /* Do not support tos = 0 */
        return SNMP_ERR_COMMITFAILED;
     }

    switch (action)
{
    case RESERVE1:
        if (name_len != ipCidrRouteEntry_OID_NAME_LEN + ipCidrRouteEntry_INSTANCE_LEN)
        {
            return SNMP_ERR_WRONGLENGTH;
        }

        if (var_val_type != ASN_INTEGER)
        {
            return SNMP_ERR_WRONGTYPE;
        }

        if (var_val_len > sizeof(long))
        {
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        value = *(long *)var_val;
        if ((value < VAL_ipCidrRouteType_other) ||
            (value > VAL_ipCidrRouteType_remote))
            return SNMP_ERR_WRONGVALUE;
        break;

    case FREE:
        break;

    case ACTION:
        {
            UI32_T dst_ipAddress = 0;
            UI32_T netmask_Address = 0 ;
            UI32_T gateway_Address = 0 ;

            SNMP_MGR_ReadIpFromCompl(name, dest_idx_offset, &dst_ipAddress);
            SNMP_MGR_ReadIpFromCompl(name, mask_idx_offset, &netmask_Address);
            SNMP_MGR_ReadIpFromCompl(name, nexthop_idx_offset, &gateway_Address);

            IP_LIB_UI32toArray(dst_ipAddress, data.ip_cidr_route_dest);
            IP_LIB_UI32toArray(netmask_Address, data.ip_cidr_route_mask);
            IP_LIB_UI32toArray(gateway_Address, data.ip_cidr_route_next_hop);

            data.ip_cidr_route_type = *(long *)var_val;
            data.ip_cidr_route_set_mask |= NSM_TYPE_SNMP_SET_IPCIDRTABLE_ROUTETYPE;

            if (NSM_PMGR_SnmpSetRoute(&data) != NSM_TYPE_RESULT_OK)
            {
                return SNMP_ERR_COMMITFAILED;
            }
        }

    case UNDO:
    case COMMIT:
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_ipCidrRouteInfo(int action,
                      u_char * var_val,
                      u_char var_val_type,
                      size_t var_val_len,
                      u_char * statP, oid * name, size_t name_len)
{
    switch (action)
    {
    case RESERVE1:
        if (name_len != ipCidrRouteEntry_OID_NAME_LEN + ipCidrRouteEntry_INSTANCE_LEN)
        {
            return SNMP_ERR_WRONGLENGTH;
        }
        if (var_val_type != ASN_OBJECT_ID)
        {
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > (sizeof(oid) * 2)) {
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        break;

    case FREE:
        break;

    case ACTION:
    {
         /* Do not support Route Info, no matter get/set */
         /*
         SNMP_TYPE_Oid_T snmpoid;

         memset(&snmpoid, 0x0, sizeof(SNMP_TYPE_Oid_T));
         memcpy(snmpoid.oid, var_val, var_val_len);
         snmpoid.oid_len=var_val_len;
         break;*/

         /* Do not support changing RouteInfo */
         return SNMP_ERR_COMMITFAILED;
    }
    case UNDO:
    case COMMIT:
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_ipCidrRouteNextHopAS(int action,
                           u_char * var_val,
                           u_char var_val_type,
                           size_t var_val_len,
                           u_char * statP, oid * name, size_t name_len)
{
/*
    long            value = 0;
    int             size = 0;
*/

    switch (action)
    {
    case RESERVE1:
        if (name_len != ipCidrRouteEntry_OID_NAME_LEN + ipCidrRouteEntry_INSTANCE_LEN)
        {
            return SNMP_ERR_WRONGLENGTH;
        }

        if (var_val_type != ASN_INTEGER)
        {
            return SNMP_ERR_WRONGTYPE;
        }

        if (var_val_len > sizeof(long))
        {
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
    case FREE:
        break;

    case ACTION:
        /* Do not support changing NextHopAS */
        return SNMP_ERR_COMMITFAILED;

    case UNDO:
    case COMMIT:
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_ipCidrRouteMetric1(int action,
                         u_char * var_val,
                         u_char var_val_type,
                         size_t var_val_len,
                         u_char * statP, oid * name, size_t name_len)
{
    NSM_TYPE_IpCidrRouteEntry_T data;
    long            value = 0;
    UI16_T   dest_idx_offset = ipCidrRouteEntry_OID_NAME_LEN;             /* 11 */
    UI16_T   mask_idx_offset = ipCidrRouteEntry_OID_NAME_LEN + 4;       /*15 */
    UI16_T   tos_idx_offset = ipCidrRouteEntry_OID_NAME_LEN + 8;         /* 19 */
    UI16_T   nexthop_idx_offset = ipCidrRouteEntry_OID_NAME_LEN + 9;   /* 20 */

    UI32_T tos = (char)name[tos_idx_offset]*1;

    memset(&data, 0, sizeof(NSM_TYPE_IpCidrRouteEntry_T));

     if (tos != 0)
     { /* Do not support tos = 0 */
        return SNMP_ERR_COMMITFAILED;
     }

    switch (action)
    {
    case RESERVE1:
        if (name_len != ipCidrRouteEntry_OID_NAME_LEN + ipCidrRouteEntry_INSTANCE_LEN)
        {
            return SNMP_ERR_WRONGLENGTH;
        }

        if (var_val_type != ASN_INTEGER)
        {
            return SNMP_ERR_WRONGTYPE;
        }

        if (var_val_len > sizeof(long))
        {
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        value = *(long *)var_val;
        if (value < VAL_ipCidrRouteMetric_default)
            return SNMP_ERR_WRONGVALUE;
        break;

    case FREE:
        break;

    case ACTION:
        {
            UI32_T dst_ipAddress = 0;
            UI32_T netmask_Address = 0 ;
            UI32_T gateway_Address = 0 ;

            SNMP_MGR_ReadIpFromCompl(name, dest_idx_offset, &dst_ipAddress);
            SNMP_MGR_ReadIpFromCompl(name, mask_idx_offset, &netmask_Address);
            SNMP_MGR_ReadIpFromCompl(name, nexthop_idx_offset, &gateway_Address);

            IP_LIB_UI32toArray(dst_ipAddress, data.ip_cidr_route_dest);
            IP_LIB_UI32toArray(netmask_Address, data.ip_cidr_route_mask);
            IP_LIB_UI32toArray(gateway_Address, data.ip_cidr_route_next_hop);

            data.ip_cidr_route_metric1 = *(long *)var_val;
            data.ip_cidr_route_set_mask |= NSM_TYPE_SNMP_SET_IPCIDRTABLE_METRIC;

            if (NSM_PMGR_SnmpSetRoute(&data) != NSM_TYPE_RESULT_OK)
            {
                return SNMP_ERR_COMMITFAILED;
            }
        }

    case UNDO:
    case COMMIT:
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_ipCidrRouteMetric2(int action,
                         u_char * var_val,
                         u_char var_val_type,
                         size_t var_val_len,
                         u_char * statP, oid * name, size_t name_len)
{
/*
    long            value = 0;
    int             size = 0;
*/

    switch (action)
    {
    case RESERVE1:
        if (name_len != ipCidrRouteEntry_OID_NAME_LEN + ipCidrRouteEntry_INSTANCE_LEN)
        {
            return SNMP_ERR_WRONGLENGTH;
        }

        if (var_val_type != ASN_INTEGER)
        {
            return SNMP_ERR_WRONGTYPE;
        }

        if (var_val_len > sizeof(long))
        {
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
    case FREE:
        break;

    case ACTION:
        /* Do not support changing RouteMetric 2 */
        return SNMP_ERR_COMMITFAILED;

    case UNDO:
    case COMMIT:
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_ipCidrRouteMetric3(int action,
                         u_char * var_val,
                         u_char var_val_type,
                         size_t var_val_len,
                         u_char * statP, oid * name, size_t name_len)
{
/*
    long            value = 0;
    int             size = 0;
*/

    switch (action)
    {
    case RESERVE1:
        if (name_len != ipCidrRouteEntry_OID_NAME_LEN + ipCidrRouteEntry_INSTANCE_LEN)
        {
            return SNMP_ERR_WRONGLENGTH;
        }

        if (var_val_type != ASN_INTEGER)
        {
            return SNMP_ERR_WRONGTYPE;
        }

        if (var_val_len > sizeof(long))
        {
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
    case FREE:
        break;

    case ACTION:
        /* Do not support changing RouteMetric 3 */
        return SNMP_ERR_COMMITFAILED;

    case UNDO:
    case COMMIT:
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_ipCidrRouteMetric4(int action,
                         u_char * var_val,
                         u_char var_val_type,
                         size_t var_val_len,
                         u_char * statP, oid * name, size_t name_len)
{
/*
    long            value = 0;
    int             size = 0;
*/

    switch (action)
    {
    case RESERVE1:
        if (name_len != ipCidrRouteEntry_OID_NAME_LEN + ipCidrRouteEntry_INSTANCE_LEN)
        {
            return SNMP_ERR_WRONGLENGTH;
        }

        if (var_val_type != ASN_INTEGER)
        {
            return SNMP_ERR_WRONGTYPE;
        }

        if (var_val_len > sizeof(long))
        {
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
    case FREE:
        break;

    case ACTION:
        /* Do not support changing RouteMetric 4 */
        return SNMP_ERR_COMMITFAILED;

    case UNDO:
    case COMMIT:
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_ipCidrRouteMetric5(int action,
                         u_char * var_val,
                         u_char var_val_type,
                         size_t var_val_len,
                         u_char * statP, oid * name, size_t name_len)
{
/*
    long            value = 0;
    int             size = 0;
*/

    switch (action)
    {
    case RESERVE1:
        if (name_len != ipCidrRouteEntry_OID_NAME_LEN + ipCidrRouteEntry_INSTANCE_LEN)
        {
            return SNMP_ERR_WRONGLENGTH;
        }

        if (var_val_type != ASN_INTEGER)
        {
            return SNMP_ERR_WRONGTYPE;
        }

        if (var_val_len > sizeof(long))
        {
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
    case FREE:
        break;

    case ACTION:
             /* Do not support changing RouteMetric 5 */
             return SNMP_ERR_COMMITFAILED;

    case UNDO:
    case COMMIT:
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_ipCidrRouteStatus(int action,
                        u_char * var_val,
                        u_char var_val_type,
                        size_t var_val_len,
                        u_char * statP, oid * name, size_t name_len)
{
    NSM_TYPE_IpCidrRouteEntry_T data;
    long            value = 0;
    UI16_T   dest_idx_offset = ipCidrRouteEntry_OID_NAME_LEN;             /* 11 */
    UI16_T   mask_idx_offset = ipCidrRouteEntry_OID_NAME_LEN + 4;       /*15 */
    UI16_T   tos_idx_offset = ipCidrRouteEntry_OID_NAME_LEN + 8;         /* 19 */
    UI16_T   nexthop_idx_offset = ipCidrRouteEntry_OID_NAME_LEN + 9;   /* 20 */

    UI32_T tos = (char)name[tos_idx_offset]*1;

    memset(&data, 0, sizeof(NSM_TYPE_IpCidrRouteEntry_T));

     if (tos != 0)
     { /* Do not support tos = 0 */
        return SNMP_ERR_COMMITFAILED;
     }

    switch (action)
    {
    case RESERVE1:
        if (name_len != ipCidrRouteEntry_OID_NAME_LEN + ipCidrRouteEntry_INSTANCE_LEN)
        {
            return SNMP_ERR_WRONGLENGTH;
        }

        if (var_val_type != ASN_INTEGER)
        {
            return SNMP_ERR_WRONGTYPE;
        }

        if (var_val_len > sizeof(long))
        {
            return SNMP_ERR_WRONGLENGTH;
        }

        break;

    case RESERVE2:
        /* 2004/May/24 kelin added. not auto-generated */
        value = *(long *)var_val;
        switch(value)
        {
            case VAL_ipCidrRouteStatus_active:
            case VAL_ipCidrRouteStatus_notInService:
            case VAL_ipCidrRouteStatus_notReady:
            case VAL_ipCidrRouteStatus_createAndGo:
            case VAL_ipCidrRouteStatus_createAndWait:
            case VAL_ipCidrRouteStatus_destroy:
                break;
            default:
                return SNMP_ERR_WRONGVALUE;
                break;
        }
        break;

    case FREE:
        break;

    case ACTION:
        {
            UI32_T dst_ipAddress = 0;
            UI32_T netmask_Address = 0 ;
            UI32_T gateway_Address = 0 ;

            SNMP_MGR_ReadIpFromCompl(name, dest_idx_offset, &dst_ipAddress);
            SNMP_MGR_ReadIpFromCompl(name, mask_idx_offset, &netmask_Address);
            SNMP_MGR_ReadIpFromCompl(name, nexthop_idx_offset, &gateway_Address);

            value = *(long *)var_val;

            switch(value)
            {
                case VAL_ipCidrRouteStatus_active:
                case VAL_ipCidrRouteStatus_notInService:
                case VAL_ipCidrRouteStatus_notReady:
                case VAL_ipCidrRouteStatus_createAndGo:
                case VAL_ipCidrRouteStatus_createAndWait:
                case VAL_ipCidrRouteStatus_destroy:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }

            IP_LIB_UI32toArray(dst_ipAddress, data.ip_cidr_route_dest);
            IP_LIB_UI32toArray(netmask_Address, data.ip_cidr_route_mask);
            IP_LIB_UI32toArray(gateway_Address, data.ip_cidr_route_next_hop);

            data.ip_cidr_route_status = (UI32_T)value;
            data.ip_cidr_route_set_mask |= NSM_TYPE_SNMP_SET_IPCIDRTABLE_ROWSTATUS;

            if (NSM_PMGR_SnmpSetRoute(&data) != NSM_TYPE_RESULT_OK)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }
    case UNDO:
    case COMMIT:
        break;
    }
    return SNMP_ERR_NOERROR;
}
#endif /* #if (SYS_CPNT_ROUTING == TRUE) */