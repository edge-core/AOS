/* MODULE NAME:  foundry_lag.c
 *
 * PURPOSE: For SNMP to access Brocade's FOUNDRY-LAG-MIB:
 *
 * foundry(1991).products(1).switch(1).snSwitch(3).fdryLinkAggregationGroupMIB(33)
 *
 * NOTES:
 *
 * HISTORY (mm/dd/yyyy)
 *    05/28/2011 - Qiyao Zhong, Created
 *
 * Copyright(C)      Accton Corporation, 2011
 */

/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.scalar.conf,v 1.8 2004/10/14 12:57:34 dts12 Exp $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

/* system
 */
#include "sys_type.h"
#include "sys_adpt.h"
#include "sys_cpnt.h"
#include "l_bitmap.h"
#include "l_cvrt.h"
#include "l_stdlib.h"
#include "leaf_foundry_lag.h"

/* SNMP itself
 */
#include "snmp_mgr.h"
#include "sysORTable.h"
#include "foundry_lib.h"
#include "foundry_lag.h"

/* core (L2)
 */
#if (FOUNDRY_LIB_PLATFORM_STYLE == FOUNDRY_LIB_PLATFORM_STYLE_EDGE_CORE)
#include "swctrl_pom.h"
#endif

#include "trk_pmgr.h"

/* STATIC VARIABLE DEFINITIONS
 */

/* This entry is used for entry which have the ability to row create.
 * This is set upon entering the "var_..." function and does not need to be
 * cleared upon transition mode.
 */
static UI8_T foundry_lag_bitmap_ar[SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK
    * SYS_ADPT_NBR_OF_BYTE_FOR_1BIT_UPORT_LIST] = {0};
static UI32_T foundry_lag_row_status;

/* ------------------------------------------------------------------------
 * TABLE NAME - 1.1.3.33.1.1 fdryLinkAggregationGroupTable
 * ------------------------------------------------------------------------
 */
oid fdryLinkAggregationGroupTable_variables_oid[] = { 1,3,6,1,4,1,1991,1,1,3,33,1 };

/* variable3 fdryLinkAggregationGroupTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */
struct variable3 fdryLinkAggregationGroupTable_variables[] =
{
    /* magic number, variable type, ro/rw, callback fn, L, oidsuffix
     *     (L = length of the oidsuffix)
     */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_fdryLinkAggregationGroupName, ASN_OCTET_STR, RONLY, var_fdryLinkAggregationGroupTable, 3, { 1, 1, 1 }},
#endif  /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

    { LEAF_fdryLinkAggregationGroupType, ASN_INTEGER, RWRITE, var_fdryLinkAggregationGroupTable, 3, { 1, 1, 2 }},

#if 0  /* not implemented */
    { LEAF_fdryLinkAggregationGroupAdminStatus, ASN_INTEGER, RWRITE, var_fdryLinkAggregationGroupTable, 3, { 1, 1, 3 }},
#endif

    { LEAF_fdryLinkAggregationGroupIfList, ASN_OCTET_STR, RWRITE, var_fdryLinkAggregationGroupTable, 3, { 1, 1, 4 }},

#if 0  /* not implemented */
    { LEAF_fdryLinkAggregationGroupPrimaryPort, ASN_INTEGER, RWRITE, var_fdryLinkAggregationGroupTable, 3, { 1, 1, 5 }},
    { LEAF_fdryLinkAggregationGroupTrunkType, ASN_INTEGER, RWRITE, var_fdryLinkAggregationGroupTable, 3, { 1, 1, 6 }},
    { LEAF_fdryLinkAggregationGroupTrunkThreshold, ASN_UNSIGNED, RWRITE, var_fdryLinkAggregationGroupTable, 3, { 1, 1, 7 }},
    { LEAF_fdryLinkAggregationGroupLacpTimeout, ASN_INTEGER, RWRITE, var_fdryLinkAggregationGroupTable, 3, { 1, 1, 8 }},
#endif

    { LEAF_fdryLinkAggregationGroupIfIndex, ASN_INTEGER, RONLY, var_fdryLinkAggregationGroupTable, 3, { 1, 1, 9 }},
    { LEAF_fdryLinkAggregationGroupPortCount, ASN_UNSIGNED, RONLY, var_fdryLinkAggregationGroupTable, 3, { 1, 1, 10 }},
    { LEAF_fdryLinkAggregationGroupRowStatus, ASN_INTEGER, RWRITE, var_fdryLinkAggregationGroupTable, 3, { 1, 1, 11 }},
    { LEAF_fdryLinkAggregationGroupId, ASN_UNSIGNED, RONLY, var_fdryLinkAggregationGroupTable, 3, { 1, 1, 12 }},
};

void init_fdryLinkAggregationGroupTable(void)
{
    /* Register ourselves with the agent to handle our MIB tree
     */
    REGISTER_MIB("fdryLinkAggregationGroupTable", fdryLinkAggregationGroupTable_variables, variable3,
                 fdryLinkAggregationGroupTable_variables_oid);
}

#define FDRYLINKAGGREGATIONGROUPENTRY_INSTANCE_LEN  65

BOOL_T fdryLinkAggregationGroupTable_OidIndexToData(UI32_T exact, UI32_T compc,
    oid *compl, UI8_T *fdryLinkAggregationGroupName, UI32_T *fdryLinkAggregationGroupName_length)
{
    UI32_T i;

    /* get or set
     */
    if (exact)
    {
        /* check the index length
         */
        if ((compc < 2)
            || (compc > FDRYLINKAGGREGATIONGROUPENTRY_INSTANCE_LEN))  /* the dynamic size index */
        {
            return FALSE;
        }
    }

    if ((compl[0] < MINSIZE_fdryLinkAggregationGroupName)
        || (compl[0] > MAXSIZE_fdryLinkAggregationGroupName))
    {
        return FALSE;
    }

    for (i = 0; i < compl[0]; i++)
    {
        fdryLinkAggregationGroupName[i] = compl[1 + i];
    }
    fdryLinkAggregationGroupName[compl[0]] = '\0';
    *fdryLinkAggregationGroupName_length = compl[0];

    return TRUE;
}

/*
 * var_fdryLinkAggregationGroupTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *var_fdryLinkAggregationGroupTable(struct variable *vp,
    oid *name,
    size_t *length,
    int exact,
    size_t *var_len,
    WriteMethod **write_method)
{
    UI32_T compc = 0;
    oid compl[FDRYLINKAGGREGATIONGROUPENTRY_INSTANCE_LEN] = {0};
    oid best_inst[FDRYLINKAGGREGATIONGROUPENTRY_INSTANCE_LEN] = {0};

    /* table-specific variables
     */
    char group_name_sz[MAXSIZE_fdryLinkAggregationGroupName + 1];  /* zero-ended string */
    UI32_T group_name_length = 0, trunk = 0;
    TRK_MGR_TrunkEntry_T trunk_entry;
    UI32_T i;

    /* Give default value for the record first.
     * We use the row_status = 0 to indicate if this set operation is Set by field
     * or set by record (included row creation). If the row_status == 0, this record
     * mean set by field; otherwise, we just think it is a normal set operation.
     */
    memset(foundry_lag_bitmap_ar, 0, sizeof(foundry_lag_bitmap_ar));
    foundry_lag_row_status = 0;

    /* dispatch node to set write method
     */
    switch (vp->magic)
    {
        case LEAF_fdryLinkAggregationGroupType:
            *write_method = write_fdryLinkAggregationGroupType;
            break;

#if 0  /* not implemented */
        case LEAF_fdryLinkAggregationGroupAdminStatus:
            *write_method = write_fdryLinkAggregationGroupAdminStatus;
            break;
#endif

        case LEAF_fdryLinkAggregationGroupIfList:
            *write_method = write_fdryLinkAggregationGroupIfList;
            break;

#if 0  /* not implemented */
        case LEAF_fdryLinkAggregationGroupPrimaryPort:
            *write_method = write_fdryLinkAggregationGroupPrimaryPort;
            break;

        case LEAF_fdryLinkAggregationGroupTrunkType:
            *write_method = write_fdryLinkAggregationGroupTrunkType;
            break;

        case LEAF_fdryLinkAggregationGroupTrunkThreshold:
            *write_method = write_fdryLinkAggregationGroupTrunkThreshold;
            break;

        case LEAF_fdryLinkAggregationGroupLacpTimeout:
            *write_method = write_fdryLinkAggregationGroupLacpTimeout;
            break;
#endif

        case LEAF_fdryLinkAggregationGroupRowStatus:
            *write_method = write_fdryLinkAggregationGroupRowStatus;
            break;

        default:
            *write_method = 0;
            break;
    }

    /* check compc, retrive compl
     */
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl,
        FDRYLINKAGGREGATIONGROUPENTRY_INSTANCE_LEN);

    /* clear structure
     */
    memset(&trunk_entry, 0, sizeof(trunk_entry));

    /* dispatch get-exact versus get-next
     */
    if (exact)  /* get or set */
    {
        /* extract index
         */
        if (! fdryLinkAggregationGroupTable_OidIndexToData(exact, compc, compl,
            (UI8_T *) group_name_sz, &group_name_length))
        {
            return NULL;
        }

        /* convert group name to ID (only supports number in "%02lu" format)
         */
        sscanf(group_name_sz, "%lu", &trunk);

        /* get-exact from core layer
         */
        trunk_entry.trunk_index = trunk;

        if (! TRK_PMGR_GetTrunkEntry(&trunk_entry))
        {
            return NULL;
        }
    }
    else  /* get-next */
    {
        /* extract index
         */
        fdryLinkAggregationGroupTable_OidIndexToData(exact, compc, compl,
            (UI8_T *) group_name_sz, &group_name_length);

#if 0  /* padding for incomplete index not supported;
        * getting-next for "1" will not give us "10", but will give us " 2"
        */

        /* Check the length of inputing index. If compc is less than instance
         * length, we should try get {A.B.C.0.0...}, where A.B.C was
         * obtained from the "..._OidIndexToData" function call, and
         * 0.0... was initialized in the beginning of this function.
         * This instance may exist in the core layer.
         */
        if (compc < FDRYLINKAGGREGATIONGROUPENTRY_INSTANCE_LEN)  /* incomplete index */
        {
            /* get-exact, in case this instance exists
             */

            /* convert group name to ID (only supports number in "%02lu" format)
             */
            sscanf(group_name_sz, "%lu", &trunk);

            /* get-exact from core layer
             */
            trunk_entry.trunk_index = trunk;

            if (! TRK_PMGR_GetTrunkEntry(&trunk_entry))
            {
                /* get-next according to lexicographic order; if none, fail
                 */
                if (! TRK_PMGR_GetNextTrunkEntry(&trunk_entry))
                {
                    return NULL;
                }
            }
        }
        else   /* complete index */
        {
#endif  /* padding for incomplete index not supported */

            /* get-next according to lexicographic order; if none, fail
             */

            /* convert group name to ID (only supports number in "%02lu" format)
             */
            if (group_name_length >= 1)
            {
                sscanf(group_name_sz, "%lu", &trunk);
            }

            /* get-next from core layer
             */
            trunk_entry.trunk_index = trunk;

            if (! TRK_PMGR_GetNextTrunkEntry(&trunk_entry))
            {
                return NULL;
            }

#if 0  /* padding for incomplete index not supported */
        }
#endif
    }

    /* copy base OID (without index) to output
     */
    memcpy(name, vp->name, vp->namelen * sizeof(oid));

    /* generate matched index;
     * use "%02lu" instead of "%2lu" to force lexicographical order and support sscanf
     */
    sprintf(group_name_sz, "%2lu", trunk_entry.trunk_index);
    group_name_length = strlen(group_name_sz);

    /* assign data to the OID index (length-prefixed octet string)
     */
    best_inst[0] = group_name_length;

    for (i = 0; i < best_inst[0]; i++)
    {
        best_inst[1 + i] = group_name_sz[i];
    }

    memcpy(name + vp->namelen, best_inst, (1 + best_inst[0]) * sizeof(oid));
    *length = vp->namelen + 1 + best_inst[0];

    /* dispatch node to read value
     */
    switch (vp->magic)
    {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        /* fdryLinkAggregationGroupName
         */
        case LEAF_fdryLinkAggregationGroupName:
            *var_len = strlen(entry.group_name_sz);
            memcpy(return_buf, entry.fdryLinkAggregationGroupName, *var_len);???
            return (u_char *) return_buf;
#endif  /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

        /* fdryLinkAggregationGroupType
         */
        case LEAF_fdryLinkAggregationGroupType:
            switch (trunk_entry.trunk_creation)
            {
                case VAL_trunkCreation_static:
                    long_return = VAL_fdryLinkAggregationGroupType_static;
                    break;

                case VAL_trunkCreation_lacp:
                    long_return = VAL_fdryLinkAggregationGroupType_dynamic;
                    break;

                default:  /* should not happen */
                    long_return = 0;
                    break;
            }

            *var_len = 4;
            return (u_char *) &long_return;

#if 0  /* not implemented */
        case LEAF_fdryLinkAggregationGroupAdminStatus:
            *var_len = 4;
            long_return = entry.fdryLinkAggregationGroupAdminStatus;???
            return (u_char *) &long_return;
#endif

        case LEAF_fdryLinkAggregationGroupIfList:
        {
            int port, member_index = 0;

            /* for each user port, check whether it is member
             */
            for (port = 1;
                port <= SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK
                    * SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT;
                port++)
            {
                UI32_T network_int;

                /* convert 1 bit to 1 network-order UI32_T;
                 * see MIB object description
                 */
                if (L_BITMAP_PORT_ISSET(trunk_entry.trunk_ports, port))
                {
                    /* convert to network order
                     */
                    network_int = L_STDLIB_Hton32(port);

                    /* at this moment, member_index is a 0-based array index
                     */
                    memcpy(&return_buf[member_index * sizeof(UI32_T)],
                        &network_int,
                        sizeof(UI32_T));

                    /* now, make member_index the actual quantity,
                     * and also the next 0-based index
                     */
                    member_index++;
                }
            }

            /* after leaving the above loop, member_index is the actual quantity
             */

            /* respond to user
             */
            *var_len = member_index * sizeof(UI32_T);
            return (u_char *) return_buf;
        }

#if 0  /* not implemented */
        case LEAF_fdryLinkAggregationGroupPrimaryPort:
            *var_len = 4;
            long_return = entry.fdryLinkAggregationGroupPrimaryPort;???
            return (u_char *) &long_return;

        case LEAF_fdryLinkAggregationGroupTrunkType:
            *var_len = 4;
            long_return = entry.fdryLinkAggregationGroupTrunkType;???
            return (u_char *) &long_return;

        case LEAF_fdryLinkAggregationGroupTrunkThreshold:
            *var_len = 4;
            long_return = entry.fdryLinkAggregationGroupTrunkThreshold;???
            return (u_char *) &long_return;

        case LEAF_fdryLinkAggregationGroupLacpTimeout:
            *var_len = 4;
            long_return = entry.fdryLinkAggregationGroupLacpTimeout;???
            return (u_char *) &long_return;
#endif  /* not implemented */

        /* fdryLinkAggregationGroupIfIndex
         */
        case LEAF_fdryLinkAggregationGroupIfIndex:
            *var_len = 4;
            long_return = SYS_ADPT_TRUNK_1_IF_INDEX_NUMBER - 1
                + trunk_entry.trunk_index;
            return (u_char *) &long_return;

        /* fdryLinkAggregationGroupPortCount
         */
        case LEAF_fdryLinkAggregationGroupPortCount:
        {
            int port, quant = 0;

            /* for all ports, check whether it is member
             */
            for (port = 0;
                port < SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK
                    * SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT;
                port++)
            {
                if (L_BITMAP_PORT_ISSET(trunk_entry.trunk_ports, port))
                {
                    quant++;
                }
            }

            /* respond to user
             */
            *var_len = 4;
            long_return = quant;
            return (u_char *) &long_return;
        }

        /* fdryLinkAggregationGroupRowStatus
         */
        case LEAF_fdryLinkAggregationGroupRowStatus:
            *var_len = 4;
            long_return = VAL_fdryLinkAggregationGroupRowStatus_active;  /* fixed if exists */
            return (u_char *) &long_return;

        /* fdryLinkAggregationGroupId
         */
        case LEAF_fdryLinkAggregationGroupId:
            *var_len = 4;
            long_return = trunk_entry.trunk_index;  /* trunk ID */
            return (u_char *) &long_return;

        /* unrecognised node
         */
        default:
            ERROR_MSG("");
            break;
    }

    /* return failure
     */
    return NULL;
}

int write_fdryLinkAggregationGroupType(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    /* dispatch action
     */
    switch (action)
    {
        case RESERVE1:
            /* check type and length
             */
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            /* check valid values
             */
            switch (*(long *) var_val)
            {
                case VAL_fdryLinkAggregationGroupType_static:
                    break;

                case VAL_fdryLinkAggregationGroupType_dynamic:
                    break;

                case VAL_fdryLinkAggregationGroupType_keepalive:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = 15;
#if 0  /* not supported; ignore */
            I32_T value = 0;
#endif

            /* table-specific variables
             */
            UI8_T fdryLinkAggregationGroupName[MAXSIZE_fdryLinkAggregationGroupName + 1] = {0};
            UI32_T fdryLinkAggregationGroupName_length = 0;

            /* extract index
             */
            if (! fdryLinkAggregationGroupTable_OidIndexToData(TRUE,
                name_len - oid_name_length,
                &(name[oid_name_length]),
                fdryLinkAggregationGroupName, &fdryLinkAggregationGroupName_length))
            {
                return SNMP_ERR_COMMITFAILED;
            }

#if 0  /* not supported; ignore */
            /* get user value
             */
            memcpy(&value, var_val, sizeof(I32_T));

            /* set to core layer
             */
            if (XXX_MGR_SetFdryLinkAggregationGroupType(fdryLinkAggregationGroupName, fdryLinkAggregationGroupName_length, value) != TRUE??? )
            {
                return SNMP_ERR_COMMITFAILED;
            }
#endif

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    /* return success
     */
    return SNMP_ERR_NOERROR;
}

#if 0  /* not implemented */
int write_fdryLinkAggregationGroupAdminStatus(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    /* dispatch action
     */
    switch (action)
    {
        case RESERVE1:
            /* check type and length
             */
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            /* check valid values
             */
            switch (*(long *) var_val)
            {
                case VAL_fdryLinkAggregationGroupAdminStatus_deploy:
                    break;

                case VAL_fdryLinkAggregationGroupAdminStatus_deployPassive:
                    break;

                case VAL_fdryLinkAggregationGroupAdminStatus_undeploy:
                    break;

                case VAL_fdryLinkAggregationGroupAdminStatus_undeployForced:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = 15;
            I32_T value = 0;

            /* table-specific variables
             */
            UI8_T fdryLinkAggregationGroupName[MAXSIZE_fdryLinkAggregationGroupName + 1] = {0};
            UI32_T fdryLinkAggregationGroupName_length = 0;

            /* extract index
             */
            if (! fdryLinkAggregationGroupTable_OidIndexToData(TRUE,
                name_len - oid_name_length,
                &(name[oid_name_length]),
                fdryLinkAggregationGroupName, &fdryLinkAggregationGroupName_length))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            /* get user value
             */
            memcpy(&value, var_val, sizeof(I32_T));

            /* set to core layer
             */
            if (XXX_MGR_SetFdryLinkAggregationGroupAdminStatus(fdryLinkAggregationGroupName, fdryLinkAggregationGroupName_length, value) != TRUE??? )
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    /* return success
     */
    return SNMP_ERR_NOERROR;
}
#endif

int write_fdryLinkAggregationGroupIfList(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    /* dispatch action
     */
    switch (action)
    {
        case RESERVE1:
            /* check type and length
             */
            if (var_val_type != ASN_OCTET_STR)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(UI32_T)
                * SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK
                * SYS_ADPT_NBR_OF_BYTE_FOR_1BIT_UPORT_LIST)
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;

        case RESERVE2:
        {
            UI8_T byte_buffer[sizeof(UI32_T)
                * SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK
                * SYS_ADPT_NBR_OF_BYTE_FOR_1BIT_UPORT_LIST] = {0};

            /* table-specific variables
             */
            UI8_T bitmap_ar[SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK
                * SYS_ADPT_NBR_OF_BYTE_FOR_1BIT_UPORT_LIST] = {0};
            UI32_T member_index;

            /* get user value
             */
            memcpy(byte_buffer, var_val, var_val_len);

            /* Now: convert user value to core-layer bitmap
             */

            /* clear buffer
             */
            memset(bitmap_ar, 0, sizeof(bitmap_ar));

            /* for each member, convert to port in bitmap;
             * in case the input is not a multiple of sizeof(UI32_T) octets,
             * we add "sizeof(UI32_T) - 1" before division
             */
            for (member_index = 0;
                member_index < (var_val_len + sizeof(UI32_T) - 1) / sizeof(UI32_T);
                member_index++)
            {
                UI32_T network_int, ifindex;

#if (FOUNDRY_LIB_PLATFORM_STYLE == FOUNDRY_LIB_PLATFORM_STYLE_EDGE_CORE)
                UI32_T unit, user_port;
#endif

                /* extract one member at 0-based array index to
                 * network-order integer (see MIB object description)
                 */
                memcpy(&network_int,
                    &byte_buffer[member_index * sizeof(UI32_T)],
                    sizeof(UI32_T));

                /* convert to host-order port
                 */
                ifindex = L_STDLIB_Ntoh32(network_int);

                /* if out of range, return "wrong value"
                 */
                if (
#if (FOUNDRY_LIB_PLATFORM_STYLE == FOUNDRY_LIB_PLATFORM_STYLE_SIMBA)
                    /*!!PATCH: There is no "SWCTRL_POM_LogicalPortToUserPort",
                     * which returns "valid" for legal a ifIndex but currently
                     * non-existent port.
                     * This code is copied from "SWCTRL_POM_LogicalPortToUserPort".
                     */
                    (ifindex == 0 || ifindex > SYS_ADPT_TRUNK_1_IF_INDEX_NUMBER)
#endif
#if (FOUNDRY_LIB_PLATFORM_STYLE == FOUNDRY_LIB_PLATFORM_STYLE_EDGE_CORE)
                    (! SWCTRL_POM_IfindexToUport(ifindex, &unit, &user_port))
#endif
                    )
                {
                    return SNMP_ERR_WRONGVALUE;
                }

                /* turn on bit in bitmap
                 */
                L_BITMAP_PORT_SET(bitmap_ar, ifindex);
            }

            /* store to row-create structure
             */
            memcpy(foundry_lag_bitmap_ar, bitmap_ar, sizeof(foundry_lag_bitmap_ar));
            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = 15;

            /* table-specific variables
             */
            UI8_T fdryLinkAggregationGroupName[MAXSIZE_fdryLinkAggregationGroupName + 1] = {0};
            UI32_T fdryLinkAggregationGroupName_length = 0;
            UI32_T trunk;

            /* extract index
             */
            if (! fdryLinkAggregationGroupTable_OidIndexToData(TRUE,
                name_len - oid_name_length,
                &(name[oid_name_length]),
                fdryLinkAggregationGroupName, &fdryLinkAggregationGroupName_length))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            /* extract numeric trunk ID (assume number-formatted text)
             */
            sscanf((char *) fdryLinkAggregationGroupName, "%lu",
                &trunk);

            /* For row creation, if row_status == 0, means that this is a normal
             * operation, we do the normal set operation; otherwise it is a row
             * creation operation, will do nothing here, and the overall entry
             * will perform in the write_xxxRowStatus function.
             */
            if (foundry_lag_row_status == 0)
            {
                /* set to core layer
                 */
                if (! TRK_PMGR_SetTrunkPorts(trunk, foundry_lag_bitmap_ar))
                {
                    return SNMP_ERR_COMMITFAILED;
                }
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    /* return success
     */
    return SNMP_ERR_NOERROR;
}

#if 0  /* not implemented */
int write_fdryLinkAggregationGroupPrimaryPort(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    /* dispatch action
     */
    switch (action)
    {
        case RESERVE1:
            /* check type and length
             */
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            /* check valid values
             */
            if ((*(long *) var_val < MIN_fdryLinkAggregationGroupPrimaryPort)
                || (*(long *) var_val > MAX_fdryLinkAggregationGroupPrimaryPort))
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = 15;
            I32_T value = 0;

            /* table-specific variables
             */
            UI8_T fdryLinkAggregationGroupName[MAXSIZE_fdryLinkAggregationGroupName + 1] = {0};
            UI32_T fdryLinkAggregationGroupName_length = 0;

            /* extract index
             */
            if (! fdryLinkAggregationGroupTable_OidIndexToData(TRUE,
                name_len - oid_name_length,
                &(name[oid_name_length]),
                fdryLinkAggregationGroupName, &fdryLinkAggregationGroupName_length))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            /* get user value
             */
            memcpy(&value, var_val, sizeof(I32_T));

            /* set to core layer
             */
            if (XXX_MGR_SetFdryLinkAggregationGroupPrimaryPort(fdryLinkAggregationGroupName, fdryLinkAggregationGroupName_length, value) != TRUE??? )
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    /* return success
     */
    return SNMP_ERR_NOERROR;
}

int write_fdryLinkAggregationGroupTrunkType(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    /* dispatch action
     */
    switch (action)
    {
        case RESERVE1:
            /* check type and length
             */
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            /* check valid values
             */
            switch (*(long *) var_val)
            {
                case VAL_fdryLinkAggregationGroupTrunkType_hashBased:
                    break;

                case VAL_fdryLinkAggregationGroupTrunkType_perPacket:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = 15;
            I32_T value = 0;

            /* table-specific variables
             */
            UI8_T fdryLinkAggregationGroupName[MAXSIZE_fdryLinkAggregationGroupName + 1] = {0};
            UI32_T fdryLinkAggregationGroupName_length = 0;

            /* extract index
             */
            if (! fdryLinkAggregationGroupTable_OidIndexToData(TRUE,
                name_len - oid_name_length,
                &(name[oid_name_length]),
                fdryLinkAggregationGroupName, &fdryLinkAggregationGroupName_length))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            /* get user value
             */
            memcpy(&value, var_val, sizeof(I32_T));

            /* set to core layer
             */
            if (XXX_MGR_SetFdryLinkAggregationGroupTrunkType(fdryLinkAggregationGroupName, fdryLinkAggregationGroupName_length, value) != TRUE??? )
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    /* return success
     */
    return SNMP_ERR_NOERROR;
}

int write_fdryLinkAggregationGroupTrunkThreshold(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    /* dispatch action
     */
    switch (action)
    {
        case RESERVE1:
            /* check type and length
             */
            if (var_val_type != ASN_UNSIGNED)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            /* check valid values
             */
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = 15;
            UI32_T value = 0;

            /* table-specific variables
             */
            UI8_T fdryLinkAggregationGroupName[MAXSIZE_fdryLinkAggregationGroupName + 1] = {0};
            UI32_T fdryLinkAggregationGroupName_length = 0;

            /* extract index
             */
            if (! fdryLinkAggregationGroupTable_OidIndexToData(TRUE,
                name_len - oid_name_length,
                &(name[oid_name_length]),
                fdryLinkAggregationGroupName, &fdryLinkAggregationGroupName_length))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            /* get user value
             */
            memcpy(&value, var_val, sizeof(UI32_T));

            /* set to core layer
             */
            if (XXX_MGR_SetFdryLinkAggregationGroupTrunkThreshold(fdryLinkAggregationGroupName, fdryLinkAggregationGroupName_length, value) != TRUE??? )
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    /* return success
     */
    return SNMP_ERR_NOERROR;
}

int write_fdryLinkAggregationGroupLacpTimeout(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    /* dispatch action
     */
    switch (action)
    {
        case RESERVE1:
            /* check type and length
             */
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            /* check valid values
             */
            switch (*(long *) var_val)
            {
                case VAL_fdryLinkAggregationGroupLacpTimeout_default:
                    break;

                case VAL_fdryLinkAggregationGroupLacpTimeout_long:
                    break;

                case VAL_fdryLinkAggregationGroupLacpTimeout_short:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = 15;
            I32_T value = 0;

            /* table-specific variables
             */
            UI8_T fdryLinkAggregationGroupName[MAXSIZE_fdryLinkAggregationGroupName + 1] = {0};
            UI32_T fdryLinkAggregationGroupName_length = 0;

            /* extract index
             */
            if (! fdryLinkAggregationGroupTable_OidIndexToData(TRUE,
                name_len - oid_name_length,
                &(name[oid_name_length]),
                fdryLinkAggregationGroupName, &fdryLinkAggregationGroupName_length))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            /* get user value
             */
            memcpy(&value, var_val, sizeof(I32_T));

            /* set to core layer
             */
            if (XXX_MGR_SetFdryLinkAggregationGroupLacpTimeout(fdryLinkAggregationGroupName, fdryLinkAggregationGroupName_length, value) != TRUE??? )
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    /* return success
     */
    return SNMP_ERR_NOERROR;
}
#endif  /* not implemented */

int write_fdryLinkAggregationGroupRowStatus(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    /* dispatch action
     */
    switch (action)
    {
        case RESERVE1:
            /* check type and length
             */
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            /* check valid values
             */
            /* The core layer only has valid (create) and invalid (destroy).
             * So, we have partial support of RowStatus.
             * 1. Writing "notInService(2)" is not supported.
             * 2. Writing "createAndWait(5)" makes it active(1), so that
             * the sequence "createAndWait(5), write field, active(1)",
             * succeeds and results in active(1) in the end, as expected.
             */
            switch (*(long *) var_val)
            {
                case VAL_fdryLinkAggregationGroupRowStatus_active:
                    break;

                case VAL_fdryLinkAggregationGroupRowStatus_notInService:
                case VAL_fdryLinkAggregationGroupRowStatus_notReady:
                    return SNMP_ERR_WRONGVALUE;

                case VAL_fdryLinkAggregationGroupRowStatus_createAndGo:
                case VAL_fdryLinkAggregationGroupRowStatus_createAndWait:
                case VAL_fdryLinkAggregationGroupRowStatus_destroy:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }

            /* In reserve2, we overwrite the set value to the row-create entry
             */
            memcpy(&foundry_lag_row_status, var_val, sizeof(UI32_T));
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = 15;
            I32_T value = 0;

            /* table-specific variables
             */
            UI8_T fdryLinkAggregationGroupName[MAXSIZE_fdryLinkAggregationGroupName + 1] = {0};
            UI32_T fdryLinkAggregationGroupName_length = 0;
            UI32_T trunk;
            TRK_MGR_TrunkEntry_T trunk_entry;

            /* extract index
             */
            if (! fdryLinkAggregationGroupTable_OidIndexToData(TRUE,
                name_len - oid_name_length,
                &(name[oid_name_length]),
                fdryLinkAggregationGroupName, &fdryLinkAggregationGroupName_length))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            /* extract numeric trunk ID (assume number-formatted text)
             */
            sscanf((char *) fdryLinkAggregationGroupName, "%lu",
                &trunk);

            /* get user value
             */
            memcpy(&value, var_val, sizeof(I32_T));

            /* set to core layer
             */
            /* The core layer only has valid (create) and invalid (destroy).
             * So, we have partial support of RowStatus.
             * 1. Writing "notInService(2)" is not supported.
             * 2. Writing "createAndWait(5)" makes it active(1), so that
             * the sequence "createAndWait(5), write field, active(1)",
             * succeeds and results in active(1) in the end, as expected.
             */
            switch (value)
            {
                /* active: accepted only if it already exists
                 */
                case VAL_fdryLinkAggregationGroupRowStatus_active:
                    memset(&trunk_entry, 0, sizeof(trunk_entry));
                    trunk_entry.trunk_index = trunk;

                    if (! TRK_PMGR_GetTrunkEntry(&trunk_entry))
                    {
                        return SNMP_ERR_COMMITFAILED;
                    }
                    break;

                /* not supported: should not come here; already filtered in RESERVE2
                 */
                case VAL_fdryLinkAggregationGroupRowStatus_notInService:
                case VAL_fdryLinkAggregationGroupRowStatus_notReady:
                    return SNMP_ERR_WRONGVALUE;

                /* create: always results in a valid (active) entry
                 *
                 * REFERENCE: PRIVATE-MIB.trunkStatus
                 */
                case VAL_fdryLinkAggregationGroupRowStatus_createAndGo:
                case VAL_fdryLinkAggregationGroupRowStatus_createAndWait:
                    /* the following sequence of calls follows "trunkStatus"
                     * in the Accton private MIB
                     */
                    if ( (! TRK_PMGR_CreateTrunk(trunk))
                        || (! TRK_PMGR_SetTrunkStatus(trunk, VAL_trunkStatus_valid)) )
                    {
                        return SNMP_ERR_COMMITFAILED;
                    }

                    /* set members, if needed by row-creation
                     */
                    if (! TRK_PMGR_SetTrunkPorts(trunk, foundry_lag_bitmap_ar))
                    {
                        return SNMP_ERR_COMMITFAILED;
                    }

                    break;

                /* destroy: even if non-existent, the core layer should return success
                 * (RFC 2579 SNMPv2-TC)
                 */
                case VAL_fdryLinkAggregationGroupRowStatus_destroy:
                    /* the following sequence of calls follows "trunkStatus"
                     * in the Accton private MIB
                     */
                    if ( (! TRK_PMGR_SetTrunkStatus(trunk, VAL_trunkStatus_invalid))
                        || (! TRK_PMGR_DestroyTrunk(trunk)) )
                    {
                        return SNMP_ERR_COMMITFAILED;
                    }
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    /* return success
     */
    return SNMP_ERR_NOERROR;
}

/* ------------------------------------------------------------------------
 * FUNCTION NAME - init_fdryLinkAggregationGroupMIB
 * ------------------------------------------------------------------------
 * PURPOSE  :   This is the entry point into this file for initialisation.
 *
 * INPUT    :   None.
 *
 * OUTPUT   :   None.
 *
 * RETURN   :   None.
 *
 * NOTES    :   None.
 * ------------------------------------------------------------------------
 */
void init_fdryLinkAggregationGroupMIB(void)
{
    oid fdryLinkAggregationGroupMIB_oid[] = { 1,3,6,1,4,1,1991,1,1,3,33 };

    /* register individual tables
     */
    init_fdryLinkAggregationGroupTable();       /* 1 */

    /* register ourselves in the sysORTable
     */
    REGISTER_SYSOR_ENTRY(fdryLinkAggregationGroupMIB_oid,
        "Management Information Base module for link aggregate group "
        "configuration and statistics.");
}
