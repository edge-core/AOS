/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.old-api.conf,v 1.4 2004/07/28 08:04:58 dts12 Exp $
 */
#include "sys_cpnt.h"
#if (SYS_CPNT_EFM_OAM == TRUE)

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "rfc_4878.h"
#include "leaf_4878.h"
#include "sys_type.h"
#include "snmp_mgr.h"
#include "oam_pmgr.h"
#include "oam_pom.h"


oid dot3OamTable_variables_oid[] = { 1,3,6,1,2,1,158,1 };
/*
 * variable3 dot3OamTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */
struct variable3 dot3OamTable_variables[] = {
/*  magic number        ,         variable type , ro/rw , callback fn  , L, oidsuffix */
{DOT3OAMADMINSTATE,          ASN_INTEGER,    RWRITE,  var_dot3OamTable, 3,  { 1, 1, 1 }},
{DOT3OAMOPERSTATUS,          ASN_INTEGER,    RONLY,   var_dot3OamTable, 3,  { 1, 1, 2 }},
{DOT3OAMMODE,                ASN_INTEGER,    RWRITE,  var_dot3OamTable, 3,  { 1, 1, 3 }},
{DOT3OAMMAXOAMPDUSIZE,       ASN_UNSIGNED,   RONLY,   var_dot3OamTable, 3,  { 1, 1, 4 }},
{DOT3OAMCONFIGREVISION,      ASN_UNSIGNED,   RONLY,   var_dot3OamTable, 3,  { 1, 1, 5 }},
{DOT3OAMFUNCTIONSSUPPORTED,  ASN_OCTET_STR,  RONLY,   var_dot3OamTable, 3,  { 1, 1, 6 }},
};

/** Initializes the dot3OamTable module */
void
init_dot3OamTable(void)
{
    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("dot3OamTable", dot3OamTable_variables, variable3,
                 dot3OamTable_variables_oid);
}

#define DOT3OAMENTRY_INSTANCE_LEN  1

BOOL_T dot3OamTable_OidIndexToData(UI32_T exact, UI32_T compc,
            oid * compl,  UI32_T *ifIndex)
{
    /* get or write */
    if (exact)
    {
        /* check the index length */
        if (compc != DOT3OAMENTRY_INSTANCE_LEN) /* the constant size index */
        {
            return FALSE;
        }
    }

    *ifIndex = compl[0];

    return TRUE;
}

/*
 * var_dot3OamTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *
var_dot3OamTable(struct variable *vp,
            oid     *name,
            size_t  *length,
            int     exact,
            size_t  *var_len,
            WriteMethod **write_method)
{

    /* variables we may use later */
    UI32_T compc = 0;
    oid compl[DOT3OAMENTRY_INSTANCE_LEN] = {0};
    oid best_inst[DOT3OAMENTRY_INSTANCE_LEN] = {0};
    EFM_OAM_SNMP_ENTRY_T entry;
    UI32_T  in_lport;

    switch (vp->magic)
    {
        case LEAF_dot3OamAdminState:
            *write_method = write_dot3OamAdminState;
            break;

        case LEAF_dot3OamMode:
            *write_method = write_dot3OamMode;
            break;

        default:
            *write_method = 0;
            break;
    }

    /* check compc, retrive compl */
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,
                           compl, DOT3OAMENTRY_INSTANCE_LEN);

    memset(&entry, 0, sizeof(entry));

    if (exact) /* get,set */
    {
        /* get index */
        if (dot3OamTable_OidIndexToData(exact, compc, compl,  &in_lport) == FALSE)
        {
            return NULL;
        }

        /* get data */
        if (EFM_OAM_POM_GetOAMEntry_SNMP( in_lport, &entry) != TRUE)
        {
            return NULL;
        }
    }
    else /* getnext */
    {
        /* get index */
        dot3OamTable_OidIndexToData(exact, compc, compl,  &in_lport);

        /* check the length of inputing index,if < 1 we should try get
         * {0.0.0.0.0...}
         */
        if (compc < 1)
        {
            /* get data */
            if (EFM_OAM_POM_GetOAMEntry_SNMP( in_lport, &entry) != TRUE)
            {
                /* get next data */
                if (EFM_OAM_POM_GetNextOAMEntry_SNMP( &in_lport, &entry) != TRUE)
                {
                    return NULL;
                }
            }
        }
        else
        {
            /* get next data */
            if (EFM_OAM_POM_GetNextOAMEntry_SNMP( &in_lport, &entry) != TRUE)
            {
                return NULL;
            }
        }
    }

    memcpy(name, vp->name, vp->namelen*sizeof(oid));

    /* assign data to the oid index */
    best_inst[0] = in_lport;
    memcpy(name + vp->namelen, best_inst,
           DOT3OAMENTRY_INSTANCE_LEN * sizeof(oid));
    *length = vp->namelen + DOT3OAMENTRY_INSTANCE_LEN ;

    /* this is where we do the value assignments for the mib results. */
    switch (vp->magic)
    {
        case LEAF_dot3OamAdminState:
            *var_len = sizeof(long_return);
            long_return = entry.admin_state;
            return (u_char *) &long_return;

        case LEAF_dot3OamOperStatus:
            *var_len = sizeof(long_return);
            long_return = entry.oper_status;
            return (u_char *) &long_return;

        case LEAF_dot3OamMode:
            *var_len = sizeof(long_return);
            long_return = entry.oam_mode;
            return (u_char *) &long_return;

        case LEAF_dot3OamMaxOamPduSize:
            *var_len = sizeof(long_return);
            long_return = entry.max_pdu_size;
            return (u_char *) &long_return;

        case LEAF_dot3OamConfigRevision:
            *var_len = sizeof(long_return);
            long_return = entry.config_revision;
            return (u_char *) &long_return;

        case LEAF_dot3OamFunctionsSupported:
            *var_len = sizeof(long_return);
            memcpy(return_buf, &entry.functions_supported, *var_len);
            return (u_char*)return_buf;

        default:
            ERROR_MSG("");
    }


    return NULL;
}

int
write_dot3OamAdminState(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{

    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            switch (*(long *)var_val)
            {
                case VAL_dot3OamAdminState_enabled:
                    break;

                case VAL_dot3OamAdminState_disabled:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = 11;
            I32_T value = 0;
            UI32_T ifIndex = 0;

            if (dot3OamTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]),  &ifIndex) == FALSE)
                return SNMP_ERR_COMMITFAILED;

            value = *(long *)var_val;

            if (value == VAL_dot3OamAdminState_enabled)
            {
                if(EFM_OAM_PMGR_Enable( ifIndex) != TRUE)
                    return SNMP_ERR_COMMITFAILED;
            }
            else if(value == VAL_dot3OamAdminState_disabled)
            {
                if(EFM_OAM_PMGR_Disable( ifIndex) != TRUE)
                    return SNMP_ERR_COMMITFAILED;
            }
            else
                return SNMP_ERR_COMMITFAILED;
        }
            break;

        case UNDO:
          break;

        case COMMIT:
          break;
    }


    return SNMP_ERR_NOERROR;
}

int
write_dot3OamMode(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{

    switch ( action ) {

        case RESERVE1:

          if (var_val_type != ASN_INTEGER)
          {
              return SNMP_ERR_WRONGTYPE;
          }
          break;

        case RESERVE2:
            switch ( *(long *)var_val )
            {
                case VAL_dot3OamMode_passive:
                    break;
                case VAL_dot3OamMode_active:
                    break;
                default:
                    return SNMP_ERR_WRONGVALUE;
            }
          break;

        case FREE:
          break;

        case ACTION:
        {
            UI32_T oid_name_length = 11;
            I32_T value=0;
            UI32_T ifIndex = 0;

            if(dot3OamTable_OidIndexToData(TRUE,name_len - oid_name_length, &(name[oid_name_length]), &ifIndex)==FALSE)
                return SNMP_ERR_COMMITFAILED;
            value = *(long *)var_val;
            if(EFM_OAM_PMGR_SetMode( ifIndex, value) != TRUE )
                return SNMP_ERR_COMMITFAILED;
        }
            break;

        case UNDO:
          break;

        case COMMIT:
          break;
    }


    return SNMP_ERR_NOERROR;
}


oid dot3OamPeerTable_variables_oid[] = { 1,3,6,1,2,1,158,1 };

/*
 * variable3 dot3OamPeerTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */
struct variable3 dot3OamPeerTable_variables[] = {
/*  magic number        ,             variable type , ro/rw , callback fn  , L, oidsuffix */
{DOT3OAMPEERMACADDRESS,          ASN_OCTET_STR,  RONLY,   var_dot3OamPeerTable, 3,  { 2, 1, 1 }},
{DOT3OAMPEERVENDOROUI,           ASN_OCTET_STR,  RONLY,   var_dot3OamPeerTable, 3,  { 2, 1, 2 }},
{DOT3OAMPEERVENDORINFO,          ASN_UNSIGNED,   RONLY,   var_dot3OamPeerTable, 3,  { 2, 1, 3 }},
{DOT3OAMPEERMODE,                ASN_INTEGER,    RONLY,   var_dot3OamPeerTable, 3,  { 2, 1, 4 }},
{DOT3OAMPEERMAXOAMPDUSIZE,       ASN_UNSIGNED,   RONLY,   var_dot3OamPeerTable, 3,  { 2, 1, 5 }},
{DOT3OAMPEERCONFIGREVISION,      ASN_UNSIGNED,   RONLY,   var_dot3OamPeerTable, 3,  { 2, 1, 6 }},
{DOT3OAMPEERFUNCTIONSSUPPORTED,  ASN_OCTET_STR,  RONLY,   var_dot3OamPeerTable, 3,  { 2, 1, 7 }},
};

/** Initializes the dot3OamPeerTable module */
void
init_dot3OamPeerTable(void)
{
    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("dot3OamPeerTable", dot3OamPeerTable_variables, variable3,
                 dot3OamPeerTable_variables_oid);
}

#define DOT3OAMPEERENTRY_INSTANCE_LEN  1

BOOL_T dot3OamPeerTable_OidIndexToData(UI32_T exact, UI32_T compc,
            oid * compl,  UI32_T *ifIndex)
{
    /* get or write */
    if (exact)
    {
        /* check the index length */
        if (compc != DOT3OAMPEERENTRY_INSTANCE_LEN) /* the constant size index */
        {
            return FALSE;
        }
    }

    *ifIndex = compl[0];

    return TRUE;
}

/*
 * var_dot3OamPeerTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *
var_dot3OamPeerTable(struct variable *vp,
            oid     *name,
            size_t  *length,
            int     exact,
            size_t  *var_len,
            WriteMethod **write_method)
{

    /* variables we may use later */
    UI32_T compc = 0;
    oid compl[DOT3OAMPEERENTRY_INSTANCE_LEN] = {0};
    oid best_inst[DOT3OAMPEERENTRY_INSTANCE_LEN] = {0};
    EFM_OAM_PEER_SNMP_ENTRY_T entry;
    UI32_T ifindex = 0;

    switch (vp->magic)
    {
        default:
            *write_method = 0;
            break;
    }

    /* check compc, retrive compl */
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,
                           compl, DOT3OAMPEERENTRY_INSTANCE_LEN);

    memset(&entry, 0, sizeof(entry));

    if (exact) /* get,set */
    {
        /* get index */
        if (dot3OamPeerTable_OidIndexToData(exact, compc, compl,  &ifindex) == FALSE)
        {
            return NULL;
        }

        /* get data */
        if (EFM_OAM_POM_GetPeerOAMEntry_SNMP( ifindex, &entry) != TRUE)
        {
            return NULL;
        }
    }
    else /* getnext */
    {
        /* get index */
        dot3OamPeerTable_OidIndexToData(exact, compc, compl,  &ifindex);

        /* check the length of inputing index,if < 1 we should try get
         * {0.0.0.0.0...}
         */
        if (compc < 1)
        {
            /* get data */
            if (EFM_OAM_POM_GetPeerOAMEntry_SNMP( ifindex, &entry) != TRUE)
            {
                /* get next data */
                if (EFM_OAM_POM_GetNextPeerOAMEntry_SNMP(&ifindex, &entry) != TRUE)
                {
                    return NULL;
                }
            }
        }
        else
        {
            /* get next data */
            if (EFM_OAM_POM_GetNextPeerOAMEntry_SNMP(&ifindex, &entry) != TRUE)
            {
                return NULL;
            }
        }
    }

    memcpy(name, vp->name, vp->namelen*sizeof(oid));

    /* assign data to the oid index */
    best_inst[0] = ifindex;
    memcpy(name + vp->namelen, best_inst,
           DOT3OAMPEERENTRY_INSTANCE_LEN * sizeof(oid));
    *length = vp->namelen + DOT3OAMPEERENTRY_INSTANCE_LEN ;

    /* this is where we do the value assignments for the mib results. */
    switch (vp->magic)
    {
        case LEAF_dot3OamPeerMacAddress:
            *var_len = SYS_ADPT_MAC_ADDR_LEN;
            memcpy(return_buf, entry.mac, *var_len);
            return (u_char*)return_buf;

        case LEAF_dot3OamPeerVendorOui:
            *var_len = SYS_ADPT_OUI_ADDR_LEN;
            memcpy(return_buf, entry.vendor_oui, *var_len);
            return (u_char*)return_buf;

        case LEAF_dot3OamPeerVendorInfo:
            *var_len = sizeof(long_return);
            long_return = entry.vendor_info;
            return (u_char *) &long_return;

        case LEAF_dot3OamPeerMode:
            *var_len = sizeof(long_return);
            long_return = entry.oam_mode;
            return (u_char *) &long_return;

        case LEAF_dot3OamPeerMaxOamPduSize:
            *var_len = sizeof(long_return);
            long_return = entry.max_pdu_size;
            return (u_char *) &long_return;

        case LEAF_dot3OamPeerConfigRevision:
            *var_len = sizeof(long_return);
            long_return = entry.config_revision;
            return (u_char *) &long_return;

        case LEAF_dot3OamPeerFunctionsSupported:
            *var_len = 4;
            memcpy(return_buf, &entry.functions_supported, *var_len);
            return (u_char*)return_buf;

        default:
            ERROR_MSG("");
    }


    return NULL;
}



oid dot3OamLoopbackTable_variables_oid[] = { 1,3,6,1,2,1,158,1 };
/*
 * variable3 dot3OamLoopbackTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */
struct variable3 dot3OamLoopbackTable_variables[] = {
/*  magic number        ,       variable type , ro/rw , callback fn  , L, oidsuffix */
{DOT3OAMLOOPBACKSTATUS,    ASN_INTEGER,  RWRITE,  var_dot3OamLoopbackTable, 3,  { 3, 1, 1 }},
{DOT3OAMLOOPBACKIGNORERX,  ASN_INTEGER,  RWRITE,  var_dot3OamLoopbackTable, 3,  { 3, 1, 2 }},
};

/** Initializes the dot3OamLoopbackTable module */
void
init_dot3OamLoopbackTable(void)
{
    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("dot3OamLoopbackTable", dot3OamLoopbackTable_variables, variable3,
                 dot3OamLoopbackTable_variables_oid);
}

#define DOT3OAMLOOPBACKENTRY_INSTANCE_LEN  1

BOOL_T dot3OamLoopbackTable_OidIndexToData(UI32_T exact, UI32_T compc,
            oid * compl,  UI32_T *ifIndex)
{
    /* get or write */
    if (exact)
    {
        /* check the index length */
        if (compc != DOT3OAMLOOPBACKENTRY_INSTANCE_LEN) /* the constant size index */
        {
            return FALSE;
        }
    }

    *ifIndex = compl[0];

    return TRUE;
}

/*
 * var_dot3OamLoopbackTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *
var_dot3OamLoopbackTable(struct variable *vp,
            oid     *name,
            size_t  *length,
            int     exact,
            size_t  *var_len,
            WriteMethod **write_method)
{

    /* variables we may use later */
    UI32_T compc = 0;
    oid compl[DOT3OAMLOOPBACKENTRY_INSTANCE_LEN] = {0};
    oid best_inst[DOT3OAMLOOPBACKENTRY_INSTANCE_LEN] = {0};
    EFM_OAM_LOOPBACK_ENTRY_T entry;
    UI32_T ifindex;

    switch (vp->magic)
    {
        case LEAF_dot3OamLoopbackStatus:
            *write_method = write_dot3OamLoopbackStatus;
            break;

        case LEAF_dot3OamLoopbackIgnoreRx:
            *write_method = write_dot3OamLoopbackIgnoreRx;
            break;

        default:
            *write_method = 0;
            break;
    }

    /* check compc, retrive compl */
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,
                           compl, DOT3OAMLOOPBACKENTRY_INSTANCE_LEN);

    memset(&entry, 0, sizeof(entry));

    if (exact) /* get,set */
    {
        /* get index */
        if (dot3OamLoopbackTable_OidIndexToData(exact, compc, compl,  &ifindex) == FALSE)
        {
            return NULL;
        }

        /* get data */
        if (EFM_OAM_POM_GetLoopbackEntry( ifindex, &entry) != TRUE)
        {
            return NULL;
        }
    }
    else /* getnext */
    {
        /* get index */
        dot3OamLoopbackTable_OidIndexToData(exact, compc, compl,  &ifindex);

        /* check the length of inputing index,if < 1 we should try get
         * {0.0.0.0.0...}
         */
        if (compc < 1)
        {
            /* get data */
            if (EFM_OAM_POM_GetLoopbackEntry( ifindex, &entry) != TRUE)
            {
                /* get next data */
                if (EFM_OAM_POM_GetNextLoopbackEntry(&ifindex, &entry) != TRUE)
                {
                    return NULL;
                }
            }
        }
        else
        {
            /* get next data */
            if (EFM_OAM_POM_GetNextLoopbackEntry(&ifindex, &entry) != TRUE)
            {
                return NULL;
            }
        }
    }

    memcpy(name, vp->name, vp->namelen*sizeof(oid));

    /* assign data to the oid index */
    best_inst[0] = ifindex;
    memcpy(name + vp->namelen, best_inst,
           DOT3OAMLOOPBACKENTRY_INSTANCE_LEN * sizeof(oid));
    *length = vp->namelen + DOT3OAMLOOPBACKENTRY_INSTANCE_LEN ;

    /* this is where we do the value assignments for the mib results. */
    switch (vp->magic)
    {
        case LEAF_dot3OamLoopbackStatus:
            *var_len = sizeof(long_return);
            long_return = entry.loopback_status;
            return (u_char *) &long_return;

        case LEAF_dot3OamLoopbackIgnoreRx:
            *var_len = sizeof(long_return);
            long_return = entry.ignore_rx;
            return (u_char *) &long_return;

        default:
            ERROR_MSG("");
    }


    return NULL;
}

int
write_dot3OamLoopbackStatus(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{

    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            switch (*(long *)var_val)
            {
                case VAL_dot3OamLoopbackStatus_noLoopback:
                    break;

                case VAL_dot3OamLoopbackStatus_initiatingLoopback:
                    break;

                case VAL_dot3OamLoopbackStatus_remoteLoopback:
                    break;

                case VAL_dot3OamLoopbackStatus_terminatingLoopback:
                    break;

                case VAL_dot3OamLoopbackStatus_localLoopback:
                    break;

                case VAL_dot3OamLoopbackStatus_unknown:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = 11;
            I32_T value = 0;
            UI32_T ifIndex = 0;
            EFM_OAM_LOOPBACK_ENTRY_T  in_loopback_entry;

            if (dot3OamLoopbackTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]),  &ifIndex) == FALSE)
                return SNMP_ERR_COMMITFAILED;

            value = *(long *)var_val;
            in_loopback_entry.loopback_status = value;

            if (EFM_OAM_PMGR_SetLoopbackEntry( ifIndex, &in_loopback_entry) != TRUE)
                return SNMP_ERR_COMMITFAILED;
        }
            break;

        case UNDO:
          break;

        case COMMIT:
          break;
    }


    return SNMP_ERR_NOERROR;
}

int
write_dot3OamLoopbackIgnoreRx(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{

    switch ( action ) {

        case RESERVE1:

          if (var_val_type != ASN_INTEGER)
          {
              return SNMP_ERR_WRONGTYPE;
          }
          break;

        case RESERVE2:
            switch ( *(long *)var_val )
            {
                case VAL_dot3OamLoopbackIgnoreRx_ignore:
                    break;
                case VAL_dot3OamLoopbackIgnoreRx_process:
                    break;
                default:
                    return SNMP_ERR_WRONGVALUE;
            }
          break;

        case FREE:
          break;

        case ACTION:
        {
            UI32_T oid_name_length = 11;
            I32_T value=0;
            UI32_T ifIndex = 0;
            EFM_OAM_LOOPBACK_ENTRY_T  in_loopback_entry;

            if(dot3OamLoopbackTable_OidIndexToData(TRUE,name_len-oid_name_length,&(name[oid_name_length]), &ifIndex)==FALSE)
                return SNMP_ERR_COMMITFAILED;
            value = *(long *)var_val;
            in_loopback_entry.ignore_rx = value;

            if(EFM_OAM_PMGR_SetLoopbackIngoreRx( ifIndex, &in_loopback_entry) != TRUE)
                return SNMP_ERR_COMMITFAILED;
        }
            break;

        case UNDO:
          break;

        case COMMIT:
          break;
    }


    return SNMP_ERR_NOERROR;
}



/*
 * dot3OamStatsTable_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */
oid dot3OamStatsTable_variables_oid[] = { 1,3,6,1,2,1,158,1 };

/*
 * variable3 dot3OamStatsTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */
struct variable3 dot3OamStatsTable_variables[] = {
/*  magic number        ,                 variable type , ro/rw , callback fn  , L, oidsuffix */
{DOT3OAMINFORMATIONTX,                 ASN_COUNTER,  RONLY,   var_dot3OamStatsTable, 3,  { 4, 1, 1 }},
{DOT3OAMINFORMATIONRX,                 ASN_COUNTER,  RONLY,   var_dot3OamStatsTable, 3,  { 4, 1, 2 }},
{DOT3OAMUNIQUEEVENTNOTIFICATIONTX,     ASN_COUNTER,  RONLY,   var_dot3OamStatsTable, 3,  { 4, 1, 3 }},
{DOT3OAMUNIQUEEVENTNOTIFICATIONRX,     ASN_COUNTER,  RONLY,   var_dot3OamStatsTable, 3,  { 4, 1, 4 }},
{DOT3OAMDUPLICATEEVENTNOTIFICATIONTX,  ASN_COUNTER,  RONLY,   var_dot3OamStatsTable, 3,  { 4, 1, 5 }},
{DOT3OAMDUPLICATEEVENTNOTIFICATIONRX,  ASN_COUNTER,  RONLY,   var_dot3OamStatsTable, 3,  { 4, 1, 6 }},
{DOT3OAMLOOPBACKCONTROLTX,             ASN_COUNTER,  RONLY,   var_dot3OamStatsTable, 3,  { 4, 1, 7 }},
{DOT3OAMLOOPBACKCONTROLRX,             ASN_COUNTER,  RONLY,   var_dot3OamStatsTable, 3,  { 4, 1, 8 }},
{DOT3OAMVARIABLEREQUESTTX,             ASN_COUNTER,  RONLY,   var_dot3OamStatsTable, 3,  { 4, 1, 9 }},
{DOT3OAMVARIABLEREQUESTRX,             ASN_COUNTER,  RONLY,   var_dot3OamStatsTable, 3,  { 4, 1, 10 }},
{DOT3OAMVARIABLERESPONSETX,            ASN_COUNTER,  RONLY,   var_dot3OamStatsTable, 3,  { 4, 1, 11 }},
{DOT3OAMVARIABLERESPONSERX,            ASN_COUNTER,  RONLY,   var_dot3OamStatsTable, 3,  { 4, 1, 12 }},
{DOT3OAMORGSPECIFICTX,                 ASN_COUNTER,  RONLY,   var_dot3OamStatsTable, 3,  { 4, 1, 13 }},
{DOT3OAMORGSPECIFICRX,                 ASN_COUNTER,  RONLY,   var_dot3OamStatsTable, 3,  { 4, 1, 14 }},
{DOT3OAMUNSUPPORTEDCODESTX,            ASN_COUNTER,  RONLY,   var_dot3OamStatsTable, 3,  { 4, 1, 15 }},
{DOT3OAMUNSUPPORTEDCODESRX,            ASN_COUNTER,  RONLY,   var_dot3OamStatsTable, 3,  { 4, 1, 16 }},
{DOT3OAMFRAMESLOSTDUETOOAM,            ASN_COUNTER,  RONLY,   var_dot3OamStatsTable, 3,  { 4, 1, 17 }},
};
/*    (L = length of the oidsuffix) */

/** Initializes the dot3OamStatsTable module */
void
init_dot3OamStatsTable(void)
{

    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("dot3OamStatsTable", dot3OamStatsTable_variables, variable3,
                 dot3OamStatsTable_variables_oid);

}

#define DOT3OAMSTATSENTRY_INSTANCE_LEN  1

BOOL_T dot3OamStatsTable_OidIndexToData(UI32_T exact, UI32_T compc,
            oid * compl ,  UI32_T *ifIndex)
{
    /* get or write
     */
    if(exact)
    {

        /* check the index length
         */
        if(compc != DOT3OAMSTATSENTRY_INSTANCE_LEN) /* the constant size index*/
        {
            return FALSE;
        }
    }
    *ifIndex=compl[0];
    return TRUE;
}

/*
 * var_dot3OamStatsTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *
var_dot3OamStatsTable(struct variable *vp,
            oid     *name,
            size_t  *length,
            int     exact,
            size_t  *var_len,
            WriteMethod **write_method)
{

    /* variables we may use later */
    UI32_T compc=0;
    oid compl[DOT3OAMSTATSENTRY_INSTANCE_LEN] = {0};
    oid best_inst[DOT3OAMSTATSENTRY_INSTANCE_LEN] = {0};
    EFM_OAM_STATISTICS_SNMP_T  entry;
    UI32_T ifIndex;

    switch(vp->magic)
    {
    default:
        *write_method = 0;
        break;
    }

    /*check compc, retrive compl*/
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,compl, DOT3OAMSTATSENTRY_INSTANCE_LEN);

    memset(&entry, 0, sizeof(entry));

    if (exact)/*get,set*/
    {

        /* get index */
        if(dot3OamStatsTable_OidIndexToData(exact,compc,compl, &ifIndex)==FALSE)
        {
            return NULL;
        }

        /*get data
         */
        if ( EFM_OAM_POM_GetOAMStatistics_SNMP(ifIndex,&entry)!=TRUE)
        {
            return NULL;
        }
    }
    else/*getnext*/
    {

        /*get index*/
        dot3OamStatsTable_OidIndexToData(exact,compc,compl, &ifIndex);
        /* check the length of inputing index,if <1 we should try get {0.0.0.0.0...}
         */
        if (compc< 1)
        {
            /* get data */
            if ( EFM_OAM_POM_GetOAMStatistics_SNMP(ifIndex,&entry)!=TRUE)
            {

                /*get next data*/
                if ( EFM_OAM_POM_GetNextOAMStatistics_SNMP(&ifIndex,&entry)!=TRUE)
                {
                    return NULL;
                }
            }
        }
        else
        {

            /*get next data*/
            if ( EFM_OAM_POM_GetNextOAMStatistics_SNMP(&ifIndex,&entry)!=TRUE)
            {
                return NULL;
            }
        }
    }

    memcpy(name, vp->name, vp->namelen*sizeof(oid));
    /* assign data to the oid index
     */

    best_inst[0]=ifIndex;
    memcpy(name+vp->namelen,best_inst,DOT3OAMSTATSENTRY_INSTANCE_LEN*sizeof(oid));
    *length = vp->namelen+DOT3OAMSTATSENTRY_INSTANCE_LEN ;

    /* this is where we do the value assignments for the mib results.
     */
    switch(vp->magic) {

    case LEAF_dot3OamInformationTx:
        *var_len = sizeof(long_return);
        long_return = entry.information_tx;
        return (u_char *) &long_return;
    case LEAF_dot3OamInformationRx:
        *var_len = sizeof(long_return);
        long_return = entry.information_rx;
        return (u_char *) &long_return;
    case LEAF_dot3OamUniqueEventNotificationTx:
        *var_len = sizeof(long_return);
        long_return = entry.uni_event_tx;
        return (u_char *) &long_return;
    case LEAF_dot3OamUniqueEventNotificationRx:
        *var_len = sizeof(long_return);
        long_return = entry.uni_event_rx;
        return (u_char *) &long_return;
    case LEAF_dot3OamDuplicateEventNotificationTx:
        *var_len = sizeof(long_return);
        long_return = entry.dup_event_tx;
        return (u_char *) &long_return;
    case LEAF_dot3OamDuplicateEventNotificationRx:
        *var_len = sizeof(long_return);
        long_return = entry.dup_event_rx;
        return (u_char *) &long_return;
    case LEAF_dot3OamLoopbackControlTx:
        *var_len = sizeof(long_return);
        long_return = entry.loopback_tx;
        return (u_char *) &long_return;
    case LEAF_dot3OamLoopbackControlRx:
        *var_len = sizeof(long_return);
        long_return = entry.loopback_rx;
        return (u_char *) &long_return;
    case LEAF_dot3OamVariableRequestTx:
        *var_len = sizeof(long_return);
        long_return = entry.var_request_tx;
        return (u_char *) &long_return;
    case LEAF_dot3OamVariableRequestRx:
        *var_len = sizeof(long_return);
        long_return = entry.var_request_rx;
        return (u_char *) &long_return;
    case LEAF_dot3OamVariableResponseTx:
        *var_len = sizeof(long_return);
        long_return = entry.var_response_tx;
        return (u_char *) &long_return;
    case LEAF_dot3OamVariableResponseRx:
        *var_len = sizeof(long_return);
        long_return = entry.var_response_rx;
        return (u_char *) &long_return;
    case LEAF_dot3OamOrgSpecificTx:
        *var_len = sizeof(long_return);
        long_return = entry.org_spe_tx;
        return (u_char *) &long_return;
    case LEAF_dot3OamOrgSpecificRx:
        *var_len = sizeof(long_return);
        long_return = entry.org_spe_rx;
        return (u_char *) &long_return;
    case LEAF_dot3OamUnsupportedCodesTx:
        *var_len = sizeof(long_return);
        long_return = entry.unsupported_tx;
        return (u_char *) &long_return;
    case LEAF_dot3OamUnsupportedCodesRx:
        *var_len = sizeof(long_return);
        long_return = entry.unsupported_rx;
        return (u_char *) &long_return;
    case LEAF_dot3OamFramesLostDueToOam: /* not supported so far */
        *var_len = sizeof(long_return);
        long_return = entry.frames_lost;
        return (u_char *) &long_return;
    default:
      ERROR_MSG("");
    }


    return NULL;
}






/*
 * dot3OamEventConfigTable_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */
oid dot3OamEventConfigTable_variables_oid[] = { 1,3,6,1,2,1,158,1 };

/*
 * variable3 dot3OamEventConfigTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */
struct variable3 dot3OamEventConfigTable_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
{DOT3OAMERRSYMPERIODWINDOWHI,         ASN_UNSIGNED,  RWRITE,  var_dot3OamEventConfigTable, 3,  { 5, 1, 1 }},
{DOT3OAMERRSYMPERIODWINDOWLO,         ASN_UNSIGNED,  RWRITE,  var_dot3OamEventConfigTable, 3,  { 5, 1, 2 }},
{DOT3OAMERRSYMPERIODTHRESHOLDHI,      ASN_UNSIGNED,  RWRITE,  var_dot3OamEventConfigTable, 3,  { 5, 1, 3 }},
{DOT3OAMERRSYMPERIODTHRESHOLDLO,      ASN_UNSIGNED,  RWRITE,  var_dot3OamEventConfigTable, 3,  { 5, 1, 4 }},
{DOT3OAMERRSYMPERIODEVNOTIFENABLE,    ASN_INTEGER,   RWRITE,  var_dot3OamEventConfigTable, 3,  { 5, 1, 5 }},
{DOT3OAMERRFRAMEPERIODWINDOW,         ASN_UNSIGNED,  RWRITE,  var_dot3OamEventConfigTable, 3,  { 5, 1, 6 }},
{DOT3OAMERRFRAMEPERIODTHRESHOLD,      ASN_UNSIGNED,  RWRITE,  var_dot3OamEventConfigTable, 3,  { 5, 1, 7 }},
{DOT3OAMERRFRAMEPERIODEVNOTIFENABLE,  ASN_INTEGER,   RWRITE,  var_dot3OamEventConfigTable, 3,  { 5, 1, 8 }},
{DOT3OAMERRFRAMEWINDOW,               ASN_UNSIGNED,  RWRITE,  var_dot3OamEventConfigTable, 3,  { 5, 1, 9 }},
{DOT3OAMERRFRAMETHRESHOLD,            ASN_UNSIGNED,  RWRITE,  var_dot3OamEventConfigTable, 3,  { 5, 1, 10 }},
{DOT3OAMERRFRAMEEVNOTIFENABLE,        ASN_INTEGER,   RWRITE,  var_dot3OamEventConfigTable, 3,  { 5, 1, 11 }},
{DOT3OAMERRFRAMESECSSUMMARYWINDOW,    ASN_INTEGER,   RWRITE,  var_dot3OamEventConfigTable, 3,  { 5, 1, 12 }},
{DOT3OAMERRFRAMESECSSUMMARYTHRESHOLD, ASN_INTEGER,   RWRITE,  var_dot3OamEventConfigTable, 3,  { 5, 1, 13 }},
{DOT3OAMERRFRAMESECSEVNOTIFENABLE,    ASN_INTEGER,   RWRITE,  var_dot3OamEventConfigTable, 3,  { 5, 1, 14 }},
{DOT3OAMDYINGGASPENABLE,              ASN_INTEGER,   RWRITE,  var_dot3OamEventConfigTable, 3,  { 5, 1, 15 }},
{DOT3OAMCRITICALEVENTENABLE,          ASN_INTEGER,   RWRITE,  var_dot3OamEventConfigTable, 3,  { 5, 1, 16 }},
};
/*    (L = length of the oidsuffix) */

/** Initializes the dot3OamEventConfigTable module */
void
init_dot3OamEventConfigTable(void)
{

    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("dot3OamEventConfigTable", dot3OamEventConfigTable_variables, variable3,
               dot3OamEventConfigTable_variables_oid);

}

#define DOT3OAMEVENTCONFIGENTRY_INSTANCE_LEN  1

BOOL_T dot3OamEventConfigTable_OidIndexToData(UI32_T exact, UI32_T compc,
            oid * compl ,  UI32_T *ifIndex)
{
    /* get or write
     */
    if(exact)
    {

        /* check the index length
         */
        if(compc != DOT3OAMEVENTCONFIGENTRY_INSTANCE_LEN) /* the constant size index*/
        {
            return FALSE;
        }
    }
    *ifIndex=compl[0];
    return TRUE;
}

/*
 * var_dot3OamEventConfigTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *
var_dot3OamEventConfigTable(struct variable *vp,
            oid     *name,
            size_t  *length,
            int     exact,
            size_t  *var_len,
            WriteMethod **write_method)
{

    /* variables we may use later */
    UI32_T compc=0;
    oid compl[DOT3OAMEVENTCONFIGENTRY_INSTANCE_LEN] = {0};
    oid best_inst[DOT3OAMEVENTCONFIGENTRY_INSTANCE_LEN] = {0};
    EFM_OAM_EVENT_CONF_T  entry;
    UI32_T ifIndex;

    switch(vp->magic)
    {
    case LEAF_dot3OamErrSymPeriodWindowHi:
        *write_method = 0;                 /* Not Supported */
        break;
    case LEAF_dot3OamErrSymPeriodWindowLo:
        *write_method = 0;                 /* Not Supported */
        break;
    case LEAF_dot3OamErrSymPeriodThresholdHi:
        *write_method = 0;                 /* Not Supported */
        break;
    case LEAF_dot3OamErrSymPeriodThresholdLo:
        *write_method = 0;                 /* Not Supported */
        break;
    case LEAF_dot3OamErrSymPeriodEvNotifEnable:
        *write_method = 0;                 /* Not Supported */
        break;
    case LEAF_dot3OamErrFramePeriodWindow:
        *write_method = 0;                 /* Not Supported */
        break;
    case LEAF_dot3OamErrFramePeriodThreshold:
        *write_method = 0;                 /* Not Supported */
        break;
    case LEAF_dot3OamErrFramePeriodEvNotifEnable:
        *write_method = 0;                 /* Not Supported */
        break;
    case LEAF_dot3OamErrFrameWindow:
        *write_method = write_dot3OamErrFrameWindow;
        break;
    case LEAF_dot3OamErrFrameThreshold:
        *write_method = write_dot3OamErrFrameThreshold;
        break;
    case LEAF_dot3OamErrFrameEvNotifEnable:
        *write_method = write_dot3OamErrFrameEvNotifEnable;
        break;
    case LEAF_dot3OamErrFrameSecsSummaryWindow:
        *write_method = 0;                 /* Not Supported */
        break;
    case LEAF_dot3OamErrFrameSecsSummaryThreshold:
        *write_method = 0;                 /* Not Supported */
        break;
    case LEAF_dot3OamErrFrameSecsEvNotifEnable:
        *write_method = 0;                 /* Not Supported */
        break;
    case LEAF_dot3OamDyingGaspEnable:
        *write_method = write_dot3OamDyingGaspEnable;
        break;
    case LEAF_dot3OamCriticalEventEnable:
        *write_method = write_dot3OamCriticalEventEnable;
        break;
    default:
        *write_method = 0;
        break;
    }

    /*check compc, retrive compl*/
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,compl, DOT3OAMEVENTCONFIGENTRY_INSTANCE_LEN);

    memset(&entry, 0, sizeof(entry));

    if (exact)/*get,set*/
    {

        /* get index */
        if(dot3OamEventConfigTable_OidIndexToData(exact,compc,compl, &ifIndex)==FALSE)
        {
            return NULL;
        }

        /*get data
         */
        if (EFM_OAM_POM_GetEventConfig(ifIndex,&entry)!=TRUE)
        {
            return NULL;
        }
    }
    else/*getnext*/
    {

        /*get index*/
        dot3OamEventConfigTable_OidIndexToData(exact,compc,compl, &ifIndex);
        /* check the length of inputing index,if <1 we should try get {0.0.0.0.0...}
         */
        if (compc< 1)
        {
            /* get data */
            if ( EFM_OAM_POM_GetEventConfig(ifIndex,&entry)!=TRUE)
            {

                /*get next data*/
                if ( EFM_OAM_POM_GetNextEventConfig(&ifIndex,&entry)!=TRUE)
                {
                    return NULL;
                }
            }
        }
        else
        {

            /*get next data*/
            if ( EFM_OAM_POM_GetNextEventConfig(&ifIndex,&entry)!=TRUE)
            {
                return NULL;
            }
        }
    }

    memcpy(name, vp->name, vp->namelen*sizeof(oid));
    /* assign data to the oid index
     */

    best_inst[0]=ifIndex;
    memcpy(name+vp->namelen,best_inst,DOT3OAMEVENTCONFIGENTRY_INSTANCE_LEN*sizeof(oid));
    *length = vp->namelen+DOT3OAMEVENTCONFIGENTRY_INSTANCE_LEN ;

    /* this is where we do the value assignments for the mib results.
     */
    switch(vp->magic) {

    case LEAF_dot3OamErrSymPeriodWindowHi:
        *var_len = sizeof(long_return);
        long_return = entry.err_sym_period_window_hi;
        return (u_char *) &long_return;
    case LEAF_dot3OamErrSymPeriodWindowLo:
        *var_len = sizeof(long_return);
        long_return = entry.err_sym_period_window_lo;
        return (u_char *) &long_return;
    case LEAF_dot3OamErrSymPeriodThresholdHi:
        *var_len = sizeof(long_return);
        long_return = entry.err_sym_period_threshold_hi;
        return (u_char *) &long_return;
    case LEAF_dot3OamErrSymPeriodThresholdLo:
        *var_len = sizeof(long_return);
        long_return = entry.err_sym_period_threshold_lo;
        return (u_char *) &long_return;
    case LEAF_dot3OamErrSymPeriodEvNotifEnable:
        *var_len = sizeof(long_return);
        long_return = entry.err_sym_period_enable;
        return (u_char *) &long_return;
    case LEAF_dot3OamErrFramePeriodWindow:
        *var_len = sizeof(long_return);
        long_return = entry.err_frame_period_window;
        return (u_char *) &long_return;
    case LEAF_dot3OamErrFramePeriodThreshold:
        *var_len = sizeof(long_return);
        long_return = entry.err_frame_period_threshold;
        return (u_char *) &long_return;
    case LEAF_dot3OamErrFramePeriodEvNotifEnable:
        *var_len = sizeof(long_return);
        long_return = entry.err_frame_period_enable;
        return (u_char *) &long_return;
    case LEAF_dot3OamErrFrameWindow:
        *var_len = sizeof(long_return);
        long_return = entry.err_frame_window;
        return (u_char *) &long_return;
    case LEAF_dot3OamErrFrameThreshold:
        *var_len = sizeof(long_return);
        long_return = entry.err_frame_threshold;
        return (u_char *) &long_return;
    case LEAF_dot3OamErrFrameEvNotifEnable:
        *var_len = sizeof(long_return);
        long_return = entry.err_frame_enable;
        return (u_char *) &long_return;
    case LEAF_dot3OamErrFrameSecsSummaryWindow:
        *var_len = sizeof(long_return);
        long_return = entry.err_frame_secs_summary_window;
        return (u_char *) &long_return;
    case LEAF_dot3OamErrFrameSecsSummaryThreshold:
        *var_len = sizeof(long_return);
        long_return = entry.err_frame_secs_summary_threshold;
        return (u_char *) &long_return;
    case LEAF_dot3OamErrFrameSecsEvNotifEnable:
        *var_len = sizeof(long_return);
        long_return = entry.err_frame_secs_enable;
        return (u_char *) &long_return;
    case LEAF_dot3OamDyingGaspEnable:
        *var_len = sizeof(long_return);
        long_return = entry.dying_gasp_enable;
        return (u_char *) &long_return;
    case LEAF_dot3OamCriticalEventEnable:
        *var_len = sizeof(long_return);
        long_return = entry.critical_event_enable;
        return (u_char *) &long_return;
    default:
      ERROR_MSG("");
    }


    return NULL;
}



int
write_dot3OamErrFrameWindow(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{

    switch ( action ) {

        case RESERVE1:

          if (var_val_type != ASN_UNSIGNED)
          {
              return SNMP_ERR_WRONGTYPE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
          break;

        case ACTION:
        {
            UI32_T oid_name_length = 11;
            UI32_T value=0;
            UI32_T ifIndex = 0;
            EFM_OAM_EVENT_CONF_T event_config;

            if(dot3OamEventConfigTable_OidIndexToData(TRUE,name_len-oid_name_length,&(name[oid_name_length]), &ifIndex)==FALSE)
                return SNMP_ERR_COMMITFAILED;
            value = *(u_long *)var_val;
            event_config.err_frame_window = value;
            if(EFM_OAM_PMGR_SetEventConfig( ifIndex, &event_config,LINK_EVENT_ERRORED_FRAME ,LINK_EVENT_SET_WINDOW_FLAG ) != TRUE)
                return SNMP_ERR_COMMITFAILED;
        }
            break;

        case UNDO:
          break;

        case COMMIT:
          break;
    }


    return SNMP_ERR_NOERROR;
}

int
write_dot3OamErrFrameThreshold(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{

    switch ( action ) {

        case RESERVE1:

          if (var_val_type != ASN_UNSIGNED)
          {
              return SNMP_ERR_WRONGTYPE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
          break;

        case ACTION:
        {
            UI32_T oid_name_length = 11;
            UI32_T value=0;
            UI32_T ifIndex = 0;
            EFM_OAM_EVENT_CONF_T event_config;

            if(dot3OamEventConfigTable_OidIndexToData(TRUE,name_len-oid_name_length,&(name[oid_name_length]), &ifIndex)==FALSE)
                return SNMP_ERR_COMMITFAILED;
            value = *(u_long *)var_val;
            event_config.err_frame_threshold = value;
            if(EFM_OAM_PMGR_SetEventConfig( ifIndex, &event_config, LINK_EVENT_ERRORED_FRAME, LINK_EVENT_SET_THRESHOLD_FLAG) != TRUE)
                return SNMP_ERR_COMMITFAILED;
        }
            break;

        case UNDO:
          break;

        case COMMIT:
          break;
    }


    return SNMP_ERR_NOERROR;
}

int
write_dot3OamErrFrameEvNotifEnable(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{

    switch ( action ) {

        case RESERVE1:

          if (var_val_type != ASN_INTEGER)
          {
              return SNMP_ERR_WRONGTYPE;
          }
          break;

        case RESERVE2:
            switch ( *(long *)var_val )
            {
                case VAL_dot3OamErrFrameEvNotifEnable_true:
                    break;
                case VAL_dot3OamErrFrameEvNotifEnable_false:
                    break;
                default:
                    return SNMP_ERR_WRONGVALUE;
            }
          break;

        case FREE:
          break;

        case ACTION:
        {
            UI32_T oid_name_length = 11;
            I32_T value=0;
            UI32_T ifIndex = 0;
            EFM_OAM_EVENT_CONF_T event_config;

            if(dot3OamEventConfigTable_OidIndexToData(TRUE,name_len-oid_name_length,&(name[oid_name_length]), &ifIndex)==FALSE)
                return SNMP_ERR_COMMITFAILED;
            value = *(long *)var_val;
            event_config.err_frame_enable = value;
            if(EFM_OAM_PMGR_SetEventConfig( ifIndex, &event_config, LINK_EVENT_ERRORED_FRAME,LINK_EVENT_SET_ENABLE_FLAG ) != TRUE)
                return SNMP_ERR_COMMITFAILED;
        }
            break;

        case UNDO:
          break;

        case COMMIT:
          break;
    }


    return SNMP_ERR_NOERROR;
}


int
write_dot3OamDyingGaspEnable(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{

    switch ( action ) {

        case RESERVE1:

          if (var_val_type != ASN_INTEGER)
          {
              return SNMP_ERR_WRONGTYPE;
          }
          break;

        case RESERVE2:
            switch ( *(long *)var_val )
            {
                case VAL_dot3OamDyingGaspEnable_true:
                    break;
                case VAL_dot3OamDyingGaspEnable_false:
                    break;
                default:
                    return SNMP_ERR_WRONGVALUE;
            }
          break;

        case FREE:
          break;

        case ACTION:
        {
            UI32_T oid_name_length = 11;
            I32_T value=0;
            UI32_T ifIndex = 0;
            EFM_OAM_EVENT_CONF_T event_config;

            if(dot3OamEventConfigTable_OidIndexToData(TRUE,name_len-oid_name_length,&(name[oid_name_length]), &ifIndex)==FALSE)
                return SNMP_ERR_COMMITFAILED;
            value = *(long *)var_val;
            event_config.dying_gasp_enable = value;
            if(EFM_OAM_PMGR_SetEventConfig( ifIndex, &event_config,LINK_EVENT_DYING_GASP ,LINK_EVENT_SET_NONE) != TRUE)
                return SNMP_ERR_COMMITFAILED;
        }
            break;

        case UNDO:
          break;

        case COMMIT:
          break;
    }


    return SNMP_ERR_NOERROR;
}

int
write_dot3OamCriticalEventEnable(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{

    switch ( action ) {

        case RESERVE1:

          if (var_val_type != ASN_INTEGER)
          {
              return SNMP_ERR_WRONGTYPE;
          }
          break;

        case RESERVE2:
            switch ( *(long *)var_val )
            {
                case VAL_dot3OamCriticalEventEnable_true:
                    break;
                case VAL_dot3OamCriticalEventEnable_false:
                    break;
                default:
                    return SNMP_ERR_WRONGVALUE;
            }
          break;

        case FREE:
          break;

        case ACTION:
        {
            UI32_T oid_name_length = 11;
            I32_T value=0;
            UI32_T ifIndex = 0;
            EFM_OAM_EVENT_CONF_T event_config;

            if(dot3OamEventConfigTable_OidIndexToData(TRUE,name_len-oid_name_length,&(name[oid_name_length]), &ifIndex)==FALSE)
                return SNMP_ERR_COMMITFAILED;
            value = *(long *)var_val;
            event_config.critical_event_enable = value;
            if(EFM_OAM_PMGR_SetEventConfig( ifIndex, &event_config,LINK_EVENT_CRITICAL_EVENT, LINK_EVENT_SET_NONE ) != TRUE)
                return SNMP_ERR_COMMITFAILED;
        }
            break;

        case UNDO:
          break;

        case COMMIT:
          break;
    }


    return SNMP_ERR_NOERROR;
}










/*
 * dot3OamEventLogTable_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */
oid dot3OamEventLogTable_variables_oid[] = { 1,3,6,1,2,1,158,1 };

/*
 * variable3 dot3OamEventLogTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */
struct variable3 dot3OamEventLogTable_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
{DOT3OAMEVENTLOGINDEX,         ASN_UNSIGNED,   RONLY,   var_dot3OamEventLogTable, 3,  { 6, 1, 1 }},
#endif

{DOT3OAMEVENTLOGTIMESTAMP,     ASN_TIMETICKS,  RONLY,   var_dot3OamEventLogTable, 3,  { 6, 1, 2 }},
{DOT3OAMEVENTLOGOUI,           ASN_OCTET_STR,  RONLY,   var_dot3OamEventLogTable, 3,  { 6, 1, 3 }},
{DOT3OAMEVENTLOGTYPE,          ASN_INTEGER,    RONLY,   var_dot3OamEventLogTable, 3,  { 6, 1, 4 }},
{DOT3OAMEVENTLOGLOCATION,      ASN_INTEGER,    RONLY,   var_dot3OamEventLogTable, 3,  { 6, 1, 5 }},
{DOT3OAMEVENTLOGWINDOWHI,      ASN_UNSIGNED,   RONLY,   var_dot3OamEventLogTable, 3,  { 6, 1, 6 }},
{DOT3OAMEVENTLOGWINDOWLO,      ASN_UNSIGNED,   RONLY,   var_dot3OamEventLogTable, 3,  { 6, 1, 7 }},
{DOT3OAMEVENTLOGTHRESHOLDHI,   ASN_UNSIGNED,   RONLY,   var_dot3OamEventLogTable, 3,  { 6, 1, 8 }},
{DOT3OAMEVENTLOGTHRESHOLDLO,   ASN_UNSIGNED,   RONLY,   var_dot3OamEventLogTable, 3,  { 6, 1, 9 }},
{DOT3OAMEVENTLOGVALUE,         ASN_COUNTER64,  RONLY,   var_dot3OamEventLogTable, 3,  { 6, 1, 10 }},
{DOT3OAMEVENTLOGRUNNINGTOTAL,  ASN_COUNTER64,  RONLY,   var_dot3OamEventLogTable, 3,  { 6, 1, 11 }},
{DOT3OAMEVENTLOGEVENTTOTAL,    ASN_UNSIGNED,   RONLY,   var_dot3OamEventLogTable, 3,  { 6, 1, 12 }},
};
/*    (L = length of the oidsuffix) */

/** Initializes the dot3OamEventLogTable module */
void
init_dot3OamEventLogTable(void)
{

    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("dot3OamEventLogTable", dot3OamEventLogTable_variables, variable3,
                 dot3OamEventLogTable_variables_oid);

}

#define DOT3OAMEVENTLOGENTRY_INSTANCE_LEN  2

BOOL_T dot3OamEventLogTable_OidIndexToData(UI32_T exact, UI32_T compc,
            oid * compl ,  UI32_T *ifIndex, UI32_T *dot3OamEventLogIndex)
{
    /* get or write
     */
    if(exact)
    {

        /* check the index length
         */
        if(compc != DOT3OAMEVENTLOGENTRY_INSTANCE_LEN) /* the constant size index*/
        {
            return FALSE;
        }
    }
    *ifIndex=compl[0];
    *dot3OamEventLogIndex=compl[1];
    return TRUE;
}

/*
 * var_dot3OamEventLogTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *
var_dot3OamEventLogTable(struct variable *vp,
            oid     *name,
            size_t  *length,
            int     exact,
            size_t  *var_len,
            WriteMethod **write_method)
{

    /* variables we may use later */
    UI32_T compc=0;
    oid compl[DOT3OAMEVENTLOGENTRY_INSTANCE_LEN] = {0};
    oid best_inst[DOT3OAMEVENTLOGENTRY_INSTANCE_LEN] = {0};
    EFM_OAM_EVENT_LOG_ENTRY_T  entry;
    UI32_T ifIndex;
    UI32_T dot3OamEventLogIndex;

    switch(vp->magic)
    {
    default:
        *write_method = 0;
        break;
    }

    /*check compc, retrive compl*/
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,compl, DOT3OAMEVENTLOGENTRY_INSTANCE_LEN);

    memset(&entry, 0, sizeof(entry));

    if (exact)/*get,set*/
    {

        /* get index */
        if(dot3OamEventLogTable_OidIndexToData(exact,compc,compl, &ifIndex, &dot3OamEventLogIndex)==FALSE)
        {
            return NULL;
        }

        /*get data
         */
        if (EFM_OAM_POM_GetLogEntry(ifIndex,dot3OamEventLogIndex,&entry)!=TRUE)
        {
            return NULL;
        }
    }
    else/*getnext*/
    {

        /*get index*/
        dot3OamEventLogTable_OidIndexToData(exact,compc,compl, &ifIndex, &dot3OamEventLogIndex);
        /* check the length of inputing index,if <1 we should try get {0.0.0.0.0...}
         */
        if (compc< 1)
        {
            /* get data */
            if ( EFM_OAM_POM_GetLogEntry(ifIndex,dot3OamEventLogIndex,&entry)!=TRUE)
            {

                /*get next data*/
                if ( EFM_OAM_POM_GetNextLogEntry(&ifIndex,&dot3OamEventLogIndex,&entry)!=TRUE)
                {
                    return NULL;
                }
            }
        }
        else
        {

            /*get next data*/
            if ( EFM_OAM_POM_GetNextLogEntry(&ifIndex,&dot3OamEventLogIndex,&entry)!=TRUE)
            {
                return NULL;
            }
        }
    }

    memcpy(name, vp->name, vp->namelen*sizeof(oid));
    /* assign data to the oid index
     */

    best_inst[0]=ifIndex;
    best_inst[1]=dot3OamEventLogIndex;
    memcpy(name+vp->namelen,best_inst,DOT3OAMEVENTLOGENTRY_INSTANCE_LEN*sizeof(oid));
    *length = vp->namelen+DOT3OAMEVENTLOGENTRY_INSTANCE_LEN ;

    /* this is where we do the value assignments for the mib results.
     */
    switch(vp->magic) {

#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    case LEAF_dot3OamEventLogIndex:
        *var_len = sizeof(long_return);
        long_return = entry.index;
        return (u_char *) &long_return;
#endif
    case LEAF_dot3OamEventLogTimestamp:
        *var_len = sizeof(long_return);
        long_return = entry.timestamp;
        return (u_char *) &long_return;
    case LEAF_dot3OamEventLogOui:
        *var_len = SIZE_dot3OamEventLogOui;
        memcpy(return_buf, entry.oui,*var_len);
        return (u_char*)return_buf;
    case LEAF_dot3OamEventLogType:
        *var_len = sizeof(long_return);
        long_return = entry.log_type;
        return (u_char *) &long_return;
    case LEAF_dot3OamEventLogLocation:
        *var_len = sizeof(long_return);
        long_return = entry.location;
        return (u_char *) &long_return;
    case LEAF_dot3OamEventLogWindowHi:
        *var_len = sizeof(long_return);
        long_return = entry.window_hi;
        return (u_char *) &long_return;
    case LEAF_dot3OamEventLogWindowLo:
        *var_len = sizeof(long_return);
        long_return = entry.window_lo;
        return (u_char *) &long_return;
    case LEAF_dot3OamEventLogThresholdHi:
        *var_len = sizeof(long_return);
        long_return = entry.threshold_hi;
        return (u_char *) &long_return;
    case LEAF_dot3OamEventLogThresholdLo:
        *var_len = sizeof(long_return);
        long_return = entry.threshold_lo;
        return (u_char *) &long_return;
    case LEAF_dot3OamEventLogValue:

        *var_len = sizeof(long64_return);
        long64_return.high = entry.value[0];
        long64_return.low = entry.value[1];
        return (u_char*) &long64_return;

    case LEAF_dot3OamEventLogRunningTotal:
        *var_len = sizeof(long64_return);
        long64_return.high = entry.running_total[0];
        long64_return.low = entry.running_total[1];
        return (u_char*) &long64_return;

    case LEAF_dot3OamEventLogEventTotal:
        *var_len = sizeof(long_return);
        long_return = entry.event_total;
        return (u_char *) &long_return;
    default:
      ERROR_MSG("");
    }


    return NULL;
}

#endif /* end of #if (SYS_CPNT_EFM_OAM == TRUE) */

