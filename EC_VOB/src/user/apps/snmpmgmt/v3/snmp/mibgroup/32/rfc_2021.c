/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.scalar.conf,v 1.5 2002/07/18 14:18:52 dts12 Exp $
 */
#include"sys_cpnt.h"
#if (SYS_CPNT_3COM_CLI == TRUE)
#include "sys_imghdr.h"
#endif
#if (SYS_CPNT_3COM_RMON2_PROBE_CONFIG_MIB == TRUE)
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "rfc_2021.h"
#include "sysORTable.h"
#include "leaf_2021.h"
#include "stktplg_mgr.h"
#include "stkctrl_task.h"
#include "sys_mgr.h"
#include "xfer_mgr.h"
#include "l_inet.h"
#include "snmp_mgr.h"
#include "cli_mgr.h"
#include "sysfun.h"
#include "ip_lib.h"
#include "l_stdlib.h"

/** Initializes the probeConfig module */
void
init_probeConfig(void)
{
    oid             mib_module_oid[] = { SNMP_OID_MIB2, 16, 19 };

    static oid      probeDownloadFile_oid[] =
        { 1, 3, 6, 1, 2, 1, 16, 19, 6, 0 };
    static oid      probeDownloadTFTPServer_oid[] =
        { 1, 3, 6, 1, 2, 1, 16, 19, 7, 0 };
    static oid      probeSoftwareRev_oid[] =
        { 1, 3, 6, 1, 2, 1, 16, 19, 2, 0 };
    static oid      probeDownloadAction_oid[] =
        { 1, 3, 6, 1, 2, 1, 16, 19, 8, 0 };
    static oid      probeResetControl_oid[] =
        { 1, 3, 6, 1, 2, 1, 16, 19, 5, 0 };
    static oid      probeHardwareRev_oid[] =
        { 1, 3, 6, 1, 2, 1, 16, 19, 3, 0 };
  #if 0
    static oid      netDefaultGateway_oid[] =
        { 1, 3, 6, 1, 2, 1, 16, 19, 12, 0 };

    static oid      probeDateTime_oid[] =
        { 1, 3, 6, 1, 2, 1, 16, 19, 4, 0 };
  #endif
    static oid      probeDownloadStatus_oid[] =
        { 1, 3, 6, 1, 2, 1, 16, 19, 9, 0 };

    DEBUGMSGTL(("probeConfig", "Initializing\n"));

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("probeDownloadFile",
                               do_probeDownloadFile,
                               probeDownloadFile_oid,
                               OID_LENGTH(probeDownloadFile_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("probeDownloadTFTPServer",
                               do_probeDownloadTFTPServer,
                               probeDownloadTFTPServer_oid,
                               OID_LENGTH(probeDownloadTFTPServer_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("probeSoftwareRev",
                                         get_probeSoftwareRev,
                                         probeSoftwareRev_oid,
                                         OID_LENGTH(probeSoftwareRev_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("probeDownloadAction",
                               do_probeDownloadAction,
                               probeDownloadAction_oid,
                               OID_LENGTH(probeDownloadAction_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("probeResetControl",
                               do_probeResetControl,
                               probeResetControl_oid,
                               OID_LENGTH(probeResetControl_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("probeHardwareRev",
                                         get_probeHardwareRev,
                                         probeHardwareRev_oid,
                                         OID_LENGTH(probeHardwareRev_oid),
                                         HANDLER_CAN_RONLY));
    #if 0
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("netDefaultGateway",
                               do_netDefaultGateway,
                               netDefaultGateway_oid,
                               OID_LENGTH(netDefaultGateway_oid),
                               HANDLER_CAN_RWRITE));

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("probeDateTime",
                               do_probeDateTime,
                               probeDateTime_oid,
                               OID_LENGTH(probeDateTime_oid),
                               HANDLER_CAN_RWRITE));
   #endif
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("probeDownloadStatus",
                                         get_probeDownloadStatus,
                                         probeDownloadStatus_oid,
                                         OID_LENGTH
                                         (probeDownloadStatus_oid),
                                         HANDLER_CAN_RONLY));
    REGISTER_SYSOR_ENTRY(mib_module_oid,
                         "The RMONII Probe Config MIB.");
}

int
do_probeDownloadFile(netsnmp_mib_handler *handler,
                     netsnmp_handler_registration *reginfo,
                     netsnmp_agent_request_info *reqinfo,
                     netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode)
     {

        case MODE_GET:
        {
            XFER_MGR_FileCopyMgt_T data;
  	    if (XFER_MGR_GetFileCopyMgtEntry(&data)==TRUE)
  	    {
               strcpy( return_buf, data.src_file_name);
               snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, (u_char *) return_buf, strlen(return_buf));
            }
            break;
        }
        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            if ((requests->requestvb->val_len<MINSIZE_probeDownloadFile)  ||    (requests->requestvb->val_len>MAXSIZE_probeDownloadFile))
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_INCONSISTENTVALUE);
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */

            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
               /* XXX: perform the value change here */
           {
               UI8_T  download[MAXSIZE_probeDownloadFile+1];
               #if   (SYS_CPNT_DBSYNC_TXT == TRUE)
    	      /* kinghong add for 3com autosave*/
               if   (!SNMP_MGR_SetTmpDirty(0))
                  SYSFUN_Debug_Printf("autoSave   Fail\n");
               #endif

               memcpy(download, requests->requestvb->val.string, requests->requestvb->val_len);
               download[requests->requestvb->val_len]= '\0';
               if (!L_STDLIB_StrIsAsciiPrintWithCount(download,requests->requestvb->val_len ))
               {
               	netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
               }
               if (XFER_MGR_SetFileCopySrcFileName(download)!=TRUE)
	       {
                  netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
               }
           }
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */

            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */

            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_probeDownloadTFTPServer(netsnmp_mib_handler *handler,
                           netsnmp_handler_registration *reginfo,
                           netsnmp_agent_request_info *reqinfo,
                           netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
        {
  	    XFER_MGR_FileCopyMgt_T data;
	    if (XFER_MGR_GetFileCopyMgtEntry(&data))
  	    {
                long_return = data.tftp_server;
                snmp_set_var_typed_value(requests->requestvb, ASN_IPADDRESS, (u_char *) &long_return, 4);
            }
        }
           break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:

            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */

            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
        {
            UI32_T iIp=0;
            #if   (SYS_CPNT_DBSYNC_TXT == TRUE)
    	    /* kinghong add for 3com autosave*/
            if   (!SNMP_MGR_SetTmpDirty(0))
              SYSFUN_Debug_Printf("autoSave   Fail\n");
            #endif
            iIp= (*requests->requestvb->val.integer);

    	    if (XFER_MGR_SetFileCopyTftpServer(iIp)!=TRUE)
       	    {
               netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
            }
       }
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */

            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */

            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_probeSoftwareRev(netsnmp_mib_handler *handler,
                     netsnmp_handler_registration *reginfo,
                     netsnmp_agent_request_info *reqinfo,
                     netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
        {
  	        STKTPLG_MGR_Switch_Info_T data;
  	        UI8_T buffer[MAXSIZE_probeSoftwareRev+1];
#if (SYS_CPNT_3COM_CLI == TRUE)
            UI32_T version;
            UI32_T version1 = 0, version2 = 0, version3 = 0, version4 = 0;
#endif

          	memset(&data, 0, sizeof(data));
          	/* This variables always  used index = 1 to get*/
            data.sw_unit_index = 1;

          	if(STKTPLG_MGR_GetSwitchInfo(&data))
          	{
          	    strncpy(buffer, data.sw_opcode_ver, MAXSIZE_probeSoftwareRev + 1);
		        buffer[MAXSIZE_probeSoftwareRev] = 0;
#if (SYS_CPNT_3COM_CLI == TRUE)
                sscanf(buffer, "%lu.%lu.%lu.%lu", &version1, &version2, &version3, &version4);

                version = (version1 << 24 | version2 << 16 | version3 << 8 | version4);

                CLI_MGR_GetVersionNumberDisplayString(version, IMGHDR_IMAGE_RUNTIMETYPE, buffer);
#endif  /*end of #if (SYS_CPNT_3COM_CLI == TRUE) */
          	    strcpy(return_buf, buffer);
                snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, (u_char *) return_buf, strlen(return_buf));
            }

            break;
        }

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_probeDownloadAction(netsnmp_mib_handler *handler,
                       netsnmp_handler_registration *reginfo,
                       netsnmp_agent_request_info *reqinfo,
                       netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
        {
            XFER_MGR_FileCopyMgt_T data;
	    if (XFER_MGR_GetFileCopyMgtEntry(&data))
   	    {
   	    	long_return = data.action;
  		switch (long_return)
  		{
  		  case VAL_fileCopyAction_notCopying:
                long_return = VAL_probeDownloadAction_notDownloading;
  		  break;
  		  case VAL_fileCopyAction_copy:
                long_return = VAL_probeDownloadAction_downloadToPROM;
  		  break;

                }
                 snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, 4);
             }
        }
        break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
        {
           UI32_T action;
           action = (*requests->requestvb->val.integer);
           if (action!=VAL_probeDownloadAction_downloadToPROM)
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_INCONSISTENTVALUE);
        }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
        #if(SYS_CPNT_3COM_TWO_OPCODES == TRUE)
    	    #if   (SYS_CPNT_DBSYNC_TXT == TRUE)
    	    /* kinghong add for 3com autosave*/
                if (!SNMP_MGR_SetTmpDirty(0))
                    SYSFUN_Debug_Printf("autoSave   Fail\n");
            #endif
    	    if (!XFER_MGR_SetTftpToStartupOpCodeAction())
       	    {
    		   netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
    	    }
    	#endif
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_probeResetControl(netsnmp_mib_handler *handler,
                     netsnmp_handler_registration *reginfo,
                     netsnmp_agent_request_info *reqinfo,
                     netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
        long_return=VAL_restartControl_running;
         snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, 4);
       break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
          {
           UI32_T control;
           control = (*requests->requestvb->val.integer);
          if ((control!= VAL_probeResetControl_running) && (control!=VAL_probeResetControl_warmBoot) && (control !=VAL_probeResetControl_coldBoot))
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_INCONSISTENTVALUE);
          }

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */

            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */

        {
              UI32_T restartControl;
              restartControl = (*requests->requestvb->val.integer);
              switch ( restartControl)
	      {

	       case VAL_restartControl_running: /* set to running just return ok */
	       break;

	       case VAL_restartControl_warmBoot:  /* Warm Start*/
	       #if   (SYS_CPNT_DBSYNC_TXT == TRUE)
                  /* kinghong add for 3com autosave*/
	           if  (!SNMP_MGR_SetTmpDirty(0))
		       SYSFUN_Debug_Printf("autoSave   Fail\n");
	       #endif
               STKCTRL_TASK_WarmStartSystem();
	       break;

	       case VAL_restartControl_coldBoot:  /* Cold Start*/
	       #if(SYS_CPNT_DBSYNC_TXT == TRUE)
      		/* kinghong add for 3com autosave*/
		   if (!SNMP_MGR_SetTmpDirty(0))
		       SYSFUN_Debug_Printf("autoSave   Fail\n");
	       #endif

	       #if (SYS_CPNT_3COM_CLI == TRUE)
                   if (!CLI_MGR_InitAndKeepIp())
                   {
                        netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
                   }
               #else
               STKCTRL_TASK_ColdStartSystem();
               #endif
      	       break;
	     }

        }
        break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */

            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */

            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_probeHardwareRev(netsnmp_mib_handler *handler,
                     netsnmp_handler_registration *reginfo,
                     netsnmp_agent_request_info *reqinfo,
                     netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
        {
            STKTPLG_MGR_Switch_Info_T data;

  	    memset(&data, 0, sizeof(data));

  	  /* This variables always  used index = 1 to get*/
            data.sw_unit_index = 1;

  	    if (!STKTPLG_MGR_GetSwitchInfo(&data))
  	    {
  	         return SNMP_ERR_GENERR;
  	    }

            strcpy( return_buf, data.sw_hardware_ver);
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, (u_char *) return_buf, strlen(return_buf));
        }
            break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
/* not support*/
#if 0
int
do_netDefaultGateway(netsnmp_mib_handler *handler,
                     netsnmp_handler_registration *reginfo,
                     netsnmp_agent_request_info *reqinfo,
                     netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
           {
           	  UI32_T value;
                    NETCFG_GetRifDefaultGateway( &value);

                   long_return = value;
                  snmp_set_var_typed_value(requests->requestvb, ASN_IPADDRESS, (u_char *) &long_return, 4);
            }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:

            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */

            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
             {
            	UI32_T value;
            	value= (*requests->requestvb->val.integer);
                  if (NETCFG_SetRifDefaultGateway(value) != 0)
                       netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */

            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */

            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_probeDateTime(netsnmp_mib_handler *handler,
                 netsnmp_handler_registration *reginfo,
                 netsnmp_agent_request_info *reqinfo,
                 netsnmp_request_info *requests)
{
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one.
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                 (u_char *)
                                 /* XXX: a pointer to the scalar's data */
                                 ,
                                 /* XXX: the length of the data in bytes */
                                 );
        break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
    case MODE_SET_RESERVE1:
        if ( /* XXX: check incoming data in requests->requestvb->val.XXX for failures, like an incorrect type or an illegal value or ... */ ) {
            netsnmp_set_request_error(reqinfo, requests,
                                      /* XXX: set error code depending on problem (like SNMP_ERR_WRONGTYPE or SNMP_ERR_WRONGVALUE or ... */
                                      );
        }
        break;

    case MODE_SET_RESERVE2:
        /*
         * XXX malloc "undo" storage buffer
         */
        if ( /* XXX if malloc, or whatever, failed: */ ) {
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_RESOURCESUNAVAILABLE);
        }
        break;

    case MODE_SET_FREE:
        /*
         * XXX: free resources allocated in RESERVE1 and/or
         * RESERVE2.  Something failed somewhere, and the states
         * below won't be called.
         */
        break;

    case MODE_SET_ACTION:
        /*
         * XXX: perform the value change here
         */
        if ( /* XXX: error? */ ) {
            netsnmp_set_request_error(reqinfo, requests, /* some error */
                                      );
        }
        break;

    case MODE_SET_COMMIT:
        /*
         * XXX: delete temporary storage
         */
        if ( /* XXX: error? */ ) {
            /*
             * try _really_really_ hard to never get to this point
             */
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_COMMITFAILED);
        }
        break;

    case MODE_SET_UNDO:
        /*
         * XXX: UNDO and return to previous value for the object
         */
        if ( /* XXX: error? */ ) {
            /*
             * try _really_really_ hard to never get to this point
             */
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_UNDOFAILED);
        }
        break;

    default:
        /*
         * we should never get here, so this is a really bad error
         */
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
#endif

int
get_probeDownloadStatus(netsnmp_mib_handler *handler,
                        netsnmp_handler_registration *reginfo,
                        netsnmp_agent_request_info *reqinfo,
                        netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode)
    {
        case MODE_GET:
        {

            XFER_MGR_FileCopyMgt_T data;
      	    /* ericali said that this api never return the following values:
    	    case  VAL_fileCopyStatus_fileCopyTftpCompleted
    	    case  VAL_fileCopyStatus_fileCopyWriteFlashFinish
    	    case  VAL_fileCopyStatus_fileCopyWriteFlashProgramming
    	    case  VAL_fileCopyStatus_fileCopyCompleted
    	    */
            if (XFER_MGR_GetFileCopyMgtEntry(&data))
            {
    	        switch(data.status)
                {
    	            case  VAL_fileCopyStatus_fileCopySuccess:
    		            long_return=VAL_probeDownloadStatus_downloadSuccess;
        		        break;
        		    case  VAL_fileCopyStatus_fileCopyUnknown:
        		        long_return=VAL_probeDownloadStatus_downloadStatusUnknown;
        		        break;
        		    case  VAL_fileCopyStatus_fileCopyTftpUndefError:
           		    case  VAL_fileCopyStatus_fileCopyTftpDiskFull:
        		    case  VAL_fileCopyStatus_fileCopyTftpIllegalOperation:
        		    case  VAL_fileCopyStatus_fileCopyTftpUnkownTransferId:
        		    case  VAL_fileCopyStatus_fileCopyTftpFileExisted:
        		    case  VAL_fileCopyStatus_fileCopyTftpSendError:
        		    case  VAL_fileCopyStatus_fileCopyTftpNoSuchUser:
        		    case  VAL_fileCopyStatus_fileCopyTftpReceiverError:
        		    case  VAL_fileCopyStatus_fileCopyTftpSocketOpenError:
        		    case  VAL_fileCopyStatus_fileCopyTftpSocketBindError:
        		    case  VAL_fileCopyStatus_fileCopyTftpUserCancel:
        		    case  VAL_fileCopyStatus_fileCopyParaError:
        		    case  VAL_fileCopyStatus_fileCopyBusy:
        		    case  VAL_fileCopyStatus_fileCopyReadFileError:
        		    case  VAL_fileCopyStatus_fileCopySetStartupError:
      		        case  VAL_fileCopyStatus_fileCopyFileSizeExceed:
      		        case  VAL_fileCopyStatus_fileCopyMagicWordError:
      		        case  VAL_fileCopyStatus_fileCopyImageTypeError:
      		        case  VAL_fileCopyStatus_fileCopyWriteFlashError:
      		        case  VAL_fileCopyStatus_fileCopyError:
                        long_return=VAL_probeDownloadStatus_downloadGeneralError;
            		    break;
        		    case  VAL_fileCopyStatus_fileCopyTftpTimeout:
        		        long_return=VAL_probeDownloadStatus_downloadNoResponseFromServer;
        		        break;
        		    case  VAL_fileCopyStatus_fileCopyHeaderChecksumError:
      		        case  VAL_fileCopyStatus_fileCopyImageChecksumError:
      		            long_return=VAL_probeDownloadStatus_downloadChecksumError;
      	    	        break;
      		        case  VAL_fileCopyStatus_fileCopyTftpFileNotFound:
      		            long_return=VAL_probeDownloadStatus_downloadTftpFileNotFound;
          		        break;
      		        case  VAL_fileCopyStatus_fileCopyTftpAccessViolation:
      		            long_return=VAL_probeDownloadStatus_downloadTftpAccessViolation;
          		        break;
      		        default:
      		            SYSFUN_Debug_Printf ("\r\nrfc2021.c: XFER_MGR_GetFileCopyMgtEntry gives unrecognised status\r\n");
        		        long_return=VAL_probeDownloadStatus_downloadStatusUnknown;
        		        break;
          	    }
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *)&long_return, 4);
            }
        }
        break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}


/*
 * trapDestTable2_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid             trapDestTable2_variables_oid[] =
    { 1, 3, 6, 1, 2, 1, 16, 19 };

/*
 * variable4 trapDestTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */

struct variable3 trapDestTable2_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */

#define TRAPDESTCOMMUNITY		2
    {TRAPDESTCOMMUNITY, ASN_OCTET_STR, RWRITE, var_trapDestTable2, 3,
     {13, 1, 2}},
#define TRAPDESTPROTOCOL		3
    {TRAPDESTPROTOCOL, ASN_INTEGER, RWRITE, var_trapDestTable2, 3,
     {13, 1, 3}},
#define TRAPDESTADDRESS		4
    {TRAPDESTADDRESS, ASN_OCTET_STR, RWRITE, var_trapDestTable2, 3,
     {13, 1, 4}},
#define TRAPDESTOWNER		5
    {TRAPDESTOWNER, ASN_OCTET_STR, RWRITE, var_trapDestTable2, 3,
     {13, 1, 5}},
#define TRAPDESTSTATUS		6
    {TRAPDESTSTATUS, ASN_INTEGER, RWRITE, var_trapDestTable2, 3,
     {13, 1, 6}},
};
/*
 * (L = length of the oidsuffix)
 */


/** Initializes the trapDestTable module */
void
init_trapDestTable2(void)
{

    DEBUGMSGTL(("trapDestTable2", "Initializing\n"));

    /*
     * register ourselves with the agent to handle our mib tree
     */
    REGISTER_MIB("trapDestTable2", trapDestTable2_variables, variable3,
                 trapDestTable2_variables_oid);

    /*
     * place any other initialization junk you need here
     */
}



static int
header_trapDestTable2(struct variable *vp,
               oid * name,
               size_t * length,
               int exact, size_t * var_len, WriteMethod ** write_method)
{
#define OID_NAME_LENGTH	11
    oid             newname[MAX_OID_LEN];
    UI32_T         interface;
    int             result;
    SNMP_MGR_TrapDestEntry_T  entry;
    UI32_T ifIndex = 0xFFFFFFFF;
    BOOL_T return_val;
    memcpy((char *) newname, (char *) vp->name,
           (int) vp->namelen * sizeof(oid));
    /*
     * find "next" interface
     */

     while (  (return_val= SNMP_MGR_GetNextTrapReceiverByIndex( &ifIndex,&entry))==SNMP_MGR_ERROR_OK)
     {
        newname[OID_NAME_LENGTH] = (oid) ifIndex+1;
        result =
            snmp_oid_compare(name, *length, newname,
                             (int) vp->namelen + 1);
        if ((exact && (result == 0)) || (!exact && (result < 0)))
            break;
    }
    if (return_val!= SNMP_MGR_ERROR_OK ) {
        DEBUGMSGTL(("mibII/interfaces", "... index out of range\n"));
        return MATCH_FAILED;
    }


    memcpy((char *) name, (char *) newname,
           ((int) vp->namelen + 1) * sizeof(oid));
    *length = vp->namelen + 1;
    *write_method = 0;
    *var_len = sizeof(long);    /* default to 'long' results */
    interface = newname[OID_NAME_LENGTH];

    DEBUGMSGTL(("mibII/interfaces", "... get I/F stats "));
    DEBUGMSGOID(("mibII/interfaces", name, *length));
    DEBUGMSG(("mibII/interfaces", "\n"));

    return interface;
}

/* This entry is used for entry which have the ability to row create*/
static SNMP_MGR_TrapDestEntry_T trapDestEntry;



/*
 * var_trapDestTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_trapDestTable2(struct variable *vp,
                  oid * name,
                  size_t * length,
                  int exact, size_t * var_len, WriteMethod ** write_method)
{
    SNMP_MGR_TrapDestEntry_T  entry;
    int             interface;

    /* Give default value for the record first
     * We use the row_status = 0 to indicate if this set operation is Set by field
     * or set by record(included row creation), if the row_status =0, this record
     * mean set by field, otherwise, we just think it is a normal set operation
     */
     if (SNMP_MGR_GetDefaultTrapDestEntry (&trapDestEntry)!= SNMP_MGR_ERROR_OK)
     {
         return NULL;
     }
     trapDestEntry.trap_dest_status = 0;

     switch(vp->magic) {

    case TRAPDESTCOMMUNITY:
       *write_method = write_trapDestCommunity2;
       strcpy( return_buf, entry.trap_dest_community);
       break;
      case TRAPDESTPROTOCOL:
        *write_method = write_trapDestProtocol2;
        break;
      case TRAPDESTADDRESS:
        *write_method = write_trapDestAddress2;
         break;
      case TRAPDESTOWNER:
        *write_method = write_trapDestOwner2;
        break;
      case TRAPDESTSTATUS:
        *write_method = write_trapDestStatus2;
        break;
      default:
       *write_method =0;
      }

   memset( &entry, 0, sizeof(entry));
    interface =
        header_trapDestTable2(vp, name, length, exact, var_len, write_method);
    if (interface == MATCH_FAILED)
        return NULL;



   if (SNMP_MGR_GetTrapReceiverByIndex(interface-1, &entry)!= SNMP_MGR_ERROR_OK)
            return NULL;

    /*
     * * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {


      case TRAPDESTCOMMUNITY:
        *write_method = write_trapDestCommunity2;
       strcpy( return_buf, entry.trap_dest_community);
       *var_len= strlen(return_buf);
        return (u_char*)return_buf;
      case TRAPDESTPROTOCOL:
        *write_method = write_trapDestProtocol2;
        long_return = VAL_trapDestProtocol_ip;
        return (u_char*) &long_return;
      case TRAPDESTADDRESS:
      {
        *write_method = write_trapDestAddress2;

         * (UI32_T*)return_buf = entry.trap_dest_address;
         * (UI16_T*)(return_buf + 4 ) = L_STDLIB_Hton16(entry.trap_dest_port);
        //return_buf[4] = 0;
        //return_buf[5] = 162;
       *var_len= 6;
        return (u_char*)return_buf;
      }
      case TRAPDESTOWNER:
        *write_method = write_trapDestOwner2;
        strcpy( return_buf, entry.trap_dest_owner);
       *var_len= strlen(return_buf);
        return (u_char*)return_buf;
      case TRAPDESTSTATUS:
        *write_method = write_trapDestStatus2;
        long_return = entry.trap_dest_status;
        return (u_char*) &long_return;
    default:
        ERROR_MSG("");
    }
    return NULL;
}


int
write_trapDestCommunity2(int action,
                        u_char * var_val,
                        u_char var_val_type,
                        size_t var_val_len,
                        u_char * statP, oid * name, size_t name_len)
{
    UI32_T oid_name_length = 11;

      /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(char)*SYS_ADPT_MAX_COMM_STR_NAME_LEN) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          /* In reserve2, we overwrite the set value to trapDestEntry*/
          memcpy(trapDestEntry.trap_dest_community, var_val, var_val_len);
          trapDestEntry.trap_dest_community[var_val_len]=0;
          break;
        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
         /* For row creation, if row_status =0, mean that this is a normal
          * operation, we do the normal set operation, otherwise it is a row
          * creation operation, will do nothing here, and the overall entry
          * will perform in the write_xxxRowStatus function.
          */
          if (trapDestEntry.trap_dest_status == 0)
          {
              if (!L_STDLIB_StrIsAsciiPrintWithCount(trapDestEntry.trap_dest_community, var_val_len))
              {
                  return SNMP_ERR_COMMITFAILED;
              }
              if (SNMP_MGR_ERROR_OK!=SNMP_MGR_SetTrapReceiverCommStringNameByIndex (name[11]-1, trapDestEntry.trap_dest_community))
	      {
	          return SNMP_ERR_COMMITFAILED;
	      }
         }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_trapDestProtocol2(int action,
                       u_char * var_val,
                       u_char var_val_type,
                       size_t var_val_len,
                       u_char * statP, oid * name, size_t name_len)
{
    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {

            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        /* In reserve2, we overwrite the set value to trapDestEntry*/
        memcpy(&trapDestEntry.trap_dest_protocol, var_val, var_val_len);
        if (trapDestEntry.trap_dest_protocol != 1)
           return SNMP_ERR_WRONGVALUE;
        break;

    case FREE:
        /*
         * Release any resources that have been allocated
         */
        break;

    case ACTION:
        /* For row creation, if row_status =0, mean that this is a normal
          * operation, we do the normal set operation, otherwise it is a row
          * creation operation, will do nothing here, and the overall entry
          * will perform in the write_xxxRowStatus function.
         */
          if (trapDestEntry.trap_dest_status == 0)
          {
              /* not support set operation*/
          }
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_trapDestAddress2(int action,
                      u_char * var_val,
                      u_char var_val_type,
                      size_t var_val_len,
                      u_char * statP, oid * name, size_t name_len)
{

    UI32_T oid_name_length = 11;

      /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch ( action ) {
        case RESERVE1:
        {

          UI32_T iIp=0;
          if (var_val_type != ASN_OCTET_STR) {
              return SNMP_ERR_WRONGTYPE;
          }

        memcpy(&iIp,var_val, 4);

          if ((var_val_len < sizeof(char)*4)||(var_val_len > sizeof(char)*6))
          {
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( IP_LIB_IsValidForNetworkInterface(iIp)!= TRUE)
          {
              return SNMP_ERR_WRONGVALUE;
          }
        }
          break;

        case RESERVE2:
         /* In reserve2, we overwrite the set value to trapDestEntry*/
         memcpy(&trapDestEntry.trap_dest_address, var_val, 4);
         if (var_val_len <6)
         {
             trapDestEntry.trap_dest_port = 162;
         }
         else
         {
             trapDestEntry.trap_dest_port = ntohs((var_val[4]<<8) + var_val[5]);
         }
          break;
        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
          /* For row creation, if row_status =0, mean that this is a normal
          * operation, we do the normal set operation, otherwise it is a row
          * creation operation, will do nothing here, and the overall entry
          * will perform in the write_xxxRowStatus function.
          */
          if (trapDestEntry.trap_dest_status == 0)
          {
              if (SNMP_MGR_ERROR_OK!=SNMP_MGR_SetTrapDestAddressByIndex (name[11]-1, trapDestEntry.trap_dest_port, trapDestEntry.trap_dest_address) )
	      {
	          return SNMP_ERR_COMMITFAILED;
	      }
         }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_trapDestOwner2(int action,
                    u_char * var_val,
                    u_char var_val_type,
                    size_t var_val_len,
                    u_char * statP, oid * name, size_t name_len)
{
    UI32_T oid_name_length = 11;

      /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(char)*MAXSIZE_trapDestOwner) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
         /* In reserve2, we overwrite the set value to trapDestEntry*/
         memcpy(trapDestEntry.trap_dest_owner, var_val, var_val_len);
         trapDestEntry.trap_dest_owner[var_val_len]=0;
          break;
        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
         /* For row creation, if row_status =0, mean that this is a normal
          * operation, we do the normal set operation, otherwise it is a row
          * creation operation, will do nothing here, and the overall entry
          * will perform in the write_xxxRowStatus function.
          */
          if (trapDestEntry.trap_dest_status == 0)
          {

              if (!L_STDLIB_StrIsAsciiPrintWithCount(trapDestEntry.trap_dest_owner, var_val_len))
              {
                  return SNMP_ERR_COMMITFAILED;
              }
              if (SNMP_MGR_ERROR_OK!=SNMP_MGR_SetTrapDestOwnerByIndex (name[11]-1, trapDestEntry.trap_dest_owner))
	      {
	          return SNMP_ERR_COMMITFAILED;
	      }
           }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_trapDestStatus2(int action,
                     u_char * var_val,
                     u_char var_val_type,
                     size_t var_val_len,
                     u_char * statP, oid * name, size_t name_len)
{

    int size;

    UI32_T value;
    UI32_T oid_name_length = 11;

      /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch (action)
    {
        case RESERVE1:
        {
            size = var_val_len;
            memcpy(&value, var_val, size);

            if ((value < 1) || (value > 6))
                return SNMP_ERR_WRONGVALUE;

            break;
        }

        case RESERVE2:
        {
            /* In reserve2, we overwrite the set value to trapDestEntry*/
            memcpy(&trapDestEntry.trap_dest_status, var_val, 4);
            break;
        }

        case FREE:
            /* Release any resources that have been allocated */
            break;

        case ACTION:
        {
            SNMP_MGR_TrapDestEntry_T entry;
            UI32_T status;

            size = 4;
            memcpy(&status, var_val, size);

            /* give default value for the record first */
            if (SNMP_MGR_ERROR_OK != SNMP_MGR_GetDefaultTrapDestEntry(&entry))
            {
       	        return SNMP_ERR_COMMITFAILED;
            }

             if (status == VAL_trapDestStatus_createAndGo)
             {
                 if (SNMP_MGR_SetTrapDestEntryByIndex(name[11] - 1, &trapDestEntry) != SNMP_MGR_ERROR_OK)
                 {
                     return SNMP_ERR_COMMITFAILED;
	         }
             }

             else if (status == VAL_trapDestStatus_active)
	     {
	         if (SNMP_MGR_ERROR_OK!=SNMP_MGR_GetTrapReceiverByIndex(name[11]-1,&entry))
	         {
                     return SNMP_ERR_COMMITFAILED;
	         }
	     }

	     else if (status == VAL_trapDestStatus_createAndWait)
	     {
                 if (SNMP_MGR_SetTrapDestEntryByIndex(name[11] - 1, &trapDestEntry) != SNMP_MGR_ERROR_OK)
    	         {
		     return SNMP_ERR_COMMITFAILED;
                 }
	     }

	     else if (status == VAL_trapDestStatus_destroy)
 	     {
                SNMP_MGR_TrapDestEntry_T trap_receiver;

                /* Check if the entry(v1 or v2) exists, if not, return failed
                 */
 	        if (SNMP_MGR_GetTrapReceiverByIndex(name[11] - 1, &trap_receiver) != SNMP_MGR_ERROR_OK)
 	            return SNMP_ERR_COMMITFAILED;

	         entry.trap_dest_status = 6;

                 if (SNMP_MGR_SetTrapReceiverStatusByIndex(name[11]-1,entry.trap_dest_status)!=SNMP_MGR_ERROR_OK)
    	         {
		     return SNMP_ERR_COMMITFAILED;
                 }
 	     }

	     else
	     {
	         return SNMP_ERR_COMMITFAILED;
             }

             break;
        }

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }

    return SNMP_ERR_NOERROR;
}
#endif