/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.scalar.conf,v 1.5 2002/07/18 14:18:52 dts12 Exp $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "rfc_2012.h"
#include "sys_type.h"

#include "sysORTable.h"
#include "snmp_mgr.h"

#include "l_prefix.h"

#include "ipal_types.h"
#include "ipal_if.h"

/** Initializes the tcp module */
void
init_tcp(void)
{
    oid             tcp_module_oid[] = { SNMP_OID_MIB2, 6 };

    static oid tcpRtoMin_oid[] = { 1,3,6,1,2,1,6,2, 0 };
    static oid tcpInSegs_oid[] = { 1,3,6,1,2,1,6,10, 0 };
    static oid tcpOutSegs_oid[] = { 1,3,6,1,2,1,6,11, 0 };
    static oid tcpRtoMax_oid[] = { 1,3,6,1,2,1,6,3, 0 };
    static oid tcpCurrEstab_oid[] = { 1,3,6,1,2,1,6,9, 0 };
    static oid tcpRtoAlgorithm_oid[] = { 1,3,6,1,2,1,6,1, 0 };
    static oid tcpAttemptFails_oid[] = { 1,3,6,1,2,1,6,7, 0 };
    static oid tcpPassiveOpens_oid[] = { 1,3,6,1,2,1,6,6, 0 };
    static oid tcpActiveOpens_oid[] = { 1,3,6,1,2,1,6,5, 0 };
    static oid tcpRetransSegs_oid[] = { 1,3,6,1,2,1,6,12, 0 };
    static oid tcpInErrs_oid[] = { 1,3,6,1,2,1,6,14, 0 };
    static oid tcpMaxConn_oid[] = { 1,3,6,1,2,1,6,4, 0 };
    static oid tcpOutRsts_oid[] = { 1,3,6,1,2,1,6,15, 0 };
    static oid tcpEstabResets_oid[] = { 1,3,6,1,2,1,6,8, 0 };

  DEBUGMSGTL(("tcp", "Initializing\n"));

    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("tcpRtoMin",
                                         get_tcpRtoMin,
                                         tcpRtoMin_oid,
                                         OID_LENGTH(tcpRtoMin_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("tcpInSegs",
                                         get_tcpInSegs,
                                         tcpInSegs_oid,
                                         OID_LENGTH(tcpInSegs_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("tcpOutSegs",
                                         get_tcpOutSegs,
                                         tcpOutSegs_oid,
                                         OID_LENGTH(tcpOutSegs_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("tcpRtoMax",
                                         get_tcpRtoMax,
                                         tcpRtoMax_oid,
                                         OID_LENGTH(tcpRtoMax_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("tcpCurrEstab",
                                         get_tcpCurrEstab,
                                         tcpCurrEstab_oid,
                                         OID_LENGTH(tcpCurrEstab_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("tcpRtoAlgorithm",
                                         get_tcpRtoAlgorithm,
                                         tcpRtoAlgorithm_oid,
                                         OID_LENGTH(tcpRtoAlgorithm_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("tcpAttemptFails",
                                         get_tcpAttemptFails,
                                         tcpAttemptFails_oid,
                                         OID_LENGTH(tcpAttemptFails_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("tcpPassiveOpens",
                                         get_tcpPassiveOpens,
                                         tcpPassiveOpens_oid,
                                         OID_LENGTH(tcpPassiveOpens_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("tcpActiveOpens",
                                         get_tcpActiveOpens,
                                         tcpActiveOpens_oid,
                                         OID_LENGTH(tcpActiveOpens_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("tcpRetransSegs",
                                         get_tcpRetransSegs,
                                         tcpRetransSegs_oid,
                                         OID_LENGTH(tcpRetransSegs_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("tcpInErrs",
                                         get_tcpInErrs,
                                         tcpInErrs_oid,
                                         OID_LENGTH(tcpInErrs_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("tcpMaxConn",
                                         get_tcpMaxConn,
                                         tcpMaxConn_oid,
                                         OID_LENGTH(tcpMaxConn_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("tcpOutRsts",
                                         get_tcpOutRsts,
                                         tcpOutRsts_oid,
                                         OID_LENGTH(tcpOutRsts_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("tcpEstabResets",
                                         get_tcpEstabResets,
                                         tcpEstabResets_oid,
                                         OID_LENGTH(tcpEstabResets_oid),
                                         HANDLER_CAN_RONLY));

       REGISTER_SYSOR_ENTRY(tcp_module_oid,
                         "The MIB module to describe  Tcp MIB.");
}

int
get_tcpRtoMin(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    struct tcp_mib tcpstat;

	if (IPAL_IF_GetAllTcpStatistic(&tcpstat)!= IPAL_RESULT_OK)
		 return SNMP_ERR_GENERR;

	long_return = tcpstat.tcpRtoMin;

    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *)&long_return, sizeof(long_return));
            break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_tcpInSegs(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

	struct tcp_mib tcpstat;

	if (IPAL_IF_GetAllTcpStatistic(&tcpstat)!= IPAL_RESULT_OK)
		 return SNMP_ERR_GENERR;

	long_return = tcpstat.tcpInSegs;

    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *)&long_return, sizeof(long_return));
            break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_tcpOutSegs(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
   	struct tcp_mib tcpstat;

	if (IPAL_IF_GetAllTcpStatistic(&tcpstat)!= IPAL_RESULT_OK)
		 return SNMP_ERR_GENERR;

	long_return = tcpstat.tcpOutSegs;

    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *)&long_return, sizeof(long_return));
            break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_tcpRtoMax(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    struct tcp_mib tcpstat;

	if (IPAL_IF_GetAllTcpStatistic(&tcpstat)!= IPAL_RESULT_OK)
		 return SNMP_ERR_GENERR;

	long_return = tcpstat.tcpRtoMax;

    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *)&long_return, sizeof(long_return));
            break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_tcpCurrEstab(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    struct tcp_mib tcpstat;

	if (IPAL_IF_GetAllTcpStatistic(&tcpstat)!= IPAL_RESULT_OK)
		 return SNMP_ERR_GENERR;

	long_return = tcpstat.tcpCurrEstab;

    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_GAUGE, (u_char *)&long_return, sizeof(long_return));
            break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_tcpRtoAlgorithm(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    struct tcp_mib tcpstat;

	if (IPAL_IF_GetAllTcpStatistic(&tcpstat)!= IPAL_RESULT_OK)
		 return SNMP_ERR_GENERR;

	long_return = tcpstat.tcpRtoAlgorithm;

    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *)&long_return, sizeof(long_return));
            break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_tcpAttemptFails(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    struct tcp_mib tcpstat;

	if (IPAL_IF_GetAllTcpStatistic(&tcpstat)!= IPAL_RESULT_OK)
		 return SNMP_ERR_GENERR;

	long_return = tcpstat.tcpAttemptFails;

    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *)&long_return, sizeof(long_return));
            break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_tcpPassiveOpens(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    struct tcp_mib tcpstat;

	if (IPAL_IF_GetAllTcpStatistic(&tcpstat)!= IPAL_RESULT_OK)
		 return SNMP_ERR_GENERR;

	long_return = tcpstat.tcpPassiveOpens;

    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *)&long_return, sizeof(long_return));
            break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_tcpActiveOpens(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    struct tcp_mib tcpstat;

	if (IPAL_IF_GetAllTcpStatistic(&tcpstat)!= IPAL_RESULT_OK)
		 return SNMP_ERR_GENERR;

	long_return = tcpstat.tcpActiveOpens;

    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *)&long_return, sizeof(long_return));
            break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_tcpRetransSegs(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    struct tcp_mib tcpstat;

	if (IPAL_IF_GetAllTcpStatistic(&tcpstat)!= IPAL_RESULT_OK)
		 return SNMP_ERR_GENERR;

	long_return = tcpstat.tcpRetransSegs;

    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *)&long_return, sizeof(long_return));
            break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_tcpInErrs(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    struct tcp_mib tcpstat;

	if (IPAL_IF_GetAllTcpStatistic(&tcpstat)!= IPAL_RESULT_OK)
		 return SNMP_ERR_GENERR;

	long_return = tcpstat.tcpInErrs;

    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *)&long_return, sizeof(long_return));
            break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_tcpMaxConn(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
	struct tcp_mib tcpstat;

	if (IPAL_IF_GetAllTcpStatistic(&tcpstat)!= IPAL_RESULT_OK)
	    return SNMP_ERR_GENERR;

	long_return = tcpstat.tcpMaxConn;

    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *)&long_return, sizeof(long_return));
            break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_tcpOutRsts(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
   	struct tcp_mib tcpstat;

	if (IPAL_IF_GetAllTcpStatistic(&tcpstat)!= IPAL_RESULT_OK)
	    return SNMP_ERR_GENERR;

	long_return = tcpstat.tcpOutRsts;

    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *)&long_return, sizeof(long_return));
            break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
get_tcpEstabResets(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

   struct tcp_mib tcpstat;

   if (IPAL_IF_GetAllTcpStatistic(&tcpstat)!= IPAL_RESULT_OK)
	   return SNMP_ERR_GENERR;

   long_return = tcpstat.tcpEstabResets;

    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *)&long_return, sizeof(long_return));
            break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

/*
 * tcpConnTable_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */
#define tcpConnEntry_INSTANCE_LEN 10
static oid             tcpConnTable_variables_oid[] = { SNMP_OID_MIB2, 6 };


/*
 * variable4 tcpConnTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */

struct variable3 tcpConnTable_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */


{TCPCONNSTATE,  ASN_INTEGER,  RWRITE,  var_tcpConnTable, 3,  { 13, 1, 1 }},
{TCPCONNLOCALADDRESS,  ASN_IPADDRESS,  RONLY,   var_tcpConnTable, 3,  { 13, 1, 2 }},
{TCPCONNLOCALPORT,  ASN_INTEGER,  RONLY,   var_tcpConnTable, 3,  { 13, 1, 3 }},
{TCPCONNREMADDRESS,  ASN_IPADDRESS,  RONLY,   var_tcpConnTable, 3,  { 13, 1, 4 }},
{TCPCONNREMPORT,  ASN_INTEGER,  RONLY,   var_tcpConnTable, 3,  { 13, 1, 5 }},
};
/*    (L = length of the oidsuffix) */






/** Initializes the tcpConnTable module */
void
init_tcpConnTable(void)
{

    DEBUGMSGTL(("tcpConnTable", "Initializing\n"));

    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("tcpConnTable", tcpConnTable_variables, variable3,
               tcpConnTable_variables_oid);

    /* place any other initialization junk you need here */
}

static int
header_tcpConnTable(struct variable *vp,
               oid * name,
               size_t * length,
               int exact, size_t * var_len, WriteMethod ** write_method,
               UI32_T *index1, UI32_T *index2, UI32_T *index3, UI32_T *index4)
{
#define TCPCONNENTRY_NAME_LENGTH	10
    oid             newname[MAX_OID_LEN];
    int             result;
   IPAL_IF_Tcpv4ConnEntry_T entry;
   UI32_T  localIndex1=0, localIndex2=0, localIndex3=0, localIndex4=0;
   BOOL_T return_val;
   oid  next_inst[10];


     memcpy((char *) newname, (char *) vp->name,
           (int) vp->namelen * sizeof(oid));
    /*
     * find "next" interface
     */
    memset(  &entry, 0 , sizeof(entry));

    /*
     * find "next" interface
     */

  while (  (return_val= IPAL_IF_GetNextTcpConnEntry( &entry))==IPAL_RESULT_OK)
     {
       localIndex1 = entry.tcp_conn_local_address;
       localIndex2 =  entry.tcp_conn_local_port;
       localIndex3 =entry.tcp_conn_rem_address;
       localIndex4 =  entry.tcp_conn_rem_port;

       SNMP_MGR_BindIpInstance( localIndex1, 0, next_inst);
       next_inst[4] =localIndex2;
       SNMP_MGR_BindIpInstance( localIndex3, 5, next_inst);
      next_inst[9] =localIndex4;

        memcpy( (char*)&newname[TCPCONNENTRY_NAME_LENGTH], (char*) next_inst,  10*sizeof(oid));
        result =
            snmp_oid_compare(name, *length, newname,
                             (int) vp->namelen +10);
        if ((exact && (result == 0)) || (!exact && (result < 0)))
            break;
    }
    if (!return_val ) {
        DEBUGMSGTL(("mibII/interfaces", "... index out of range\n"));
        return MATCH_FAILED;
    }
    memcpy((char *) name, (char *) newname,
           ((int) vp->namelen + 10) * sizeof(oid));
    *length = vp->namelen + 10;
     *write_method  = 0;
    *var_len = sizeof(long);    /* default to 'long' results */
    *index1 = localIndex1;
    *index2 = next_inst[4];
    *index3 = localIndex3;
    *index4= next_inst[9];
       return TRUE;
}
static BOOL_T tcpConnTable_get(int      compc,
                                oid     *compl,
                                IPAL_IF_Tcpv4ConnEntry_T   *data)
{
    if (compc !=tcpConnEntry_INSTANCE_LEN)
    {
 	    return FALSE;
    }
    SNMP_MGR_ReadIpFromCompl(compl, 0, &data->tcp_conn_local_address);
    data->tcp_conn_local_port=compl[4];
    SNMP_MGR_ReadIpFromCompl(compl, 5, &data->tcp_conn_rem_address);
    data->tcp_conn_rem_port=compl[9];

    if(SNMP_MGR_IsDebugMode())
    {
        printf("tcpConnTable_get:data->tcp_conn_local_address=[%lu]\n", data->tcp_conn_local_address);
        printf("tcpConnTable_get:data->tcp_conn_local_port=[%lu]\n", (UI32_T)data->tcp_conn_local_port);
        printf("tcpConnTable_get:data->tcp_conn_rem_address=[%lu]\n", data->tcp_conn_rem_address);
        printf("tcpConnTable_get:data->tcp_conn_rem_port=[%lu]\n", (UI32_T)data->tcp_conn_rem_port);
    }

	if (IPAL_IF_GetTcpConnEntry(data) != IPAL_RESULT_OK)
	{
	    if(SNMP_MGR_IsDebugMode())
	        printf("tcpConnTable_get:NETCFG_MGR_GetTcpConnEntry return false\n");
		return FALSE;
	}
	else
	{
		return TRUE;
	} /*End of if */
}

static BOOL_T tcpConnTable_next(int      compc,
                                 oid     *compl,
                                 IPAL_IF_Tcpv4ConnEntry_T    *data)
{
  	oid tmp_compl[tcpConnEntry_INSTANCE_LEN];

 	/* Generate the instance of each table entry and find the
	 * smallest instance that's larger than compc/compl.
	 *
	 * Step 1: Verify and extract the input key from "compc" and "compl"
	 * Note: The number of input key is defined by "compc".
	 *       The key for the specified instance is defined in compl.
	 */

	memcpy(tmp_compl, compl, sizeof(tmp_compl));
    SNMP_MGR_checkCompl(0, 3, tmp_compl,255);
    SNMP_MGR_checkCompl(4, 4, tmp_compl,65535);
    SNMP_MGR_checkCompl(5, 8, tmp_compl,255);
    SNMP_MGR_checkCompl(9, 9, tmp_compl,65535);

	SNMP_MGR_ConvertRemainToZero(compc,tcpConnEntry_INSTANCE_LEN, tmp_compl);
	SNMP_MGR_ReadIpFromCompl(tmp_compl, 0, &data->tcp_conn_local_address);
    data->tcp_conn_local_port=tmp_compl[4];
    SNMP_MGR_ReadIpFromCompl(tmp_compl, 5, &data->tcp_conn_rem_address);
    data->tcp_conn_rem_port=tmp_compl[9];


	if(SNMP_MGR_IsDebugMode())
    {
        printf("tcpConnTable_next:data->tcp_conn_local_address=[%lu]\n", data->tcp_conn_local_address);
        printf("tcpConnTable_next:data->tcp_conn_local_port=[%lu]\n", (UI32_T)data->tcp_conn_local_port);
        printf("tcpConnTable_next:data->tcp_conn_rem_address=[%lu]\n", data->tcp_conn_rem_address);
        printf("tcpConnTable_next:data->tcp_conn_rem_port=[%lu]\n", (UI32_T)data->tcp_conn_rem_port);
    }

	if (compc<tcpConnEntry_INSTANCE_LEN)
	{
		if (IPAL_IF_GetTcpConnEntry(data)!=IPAL_RESULT_OK)
        {
            if (IPAL_IF_GetNextTcpConnEntry(data)!=IPAL_RESULT_OK)
   	        {
   	            if(SNMP_MGR_IsDebugMode())
   	                printf("tcpConnTable_next: get & genext return false\n");
   		        return FALSE;
   		    }
        }
	}
	else
	{
		if (IPAL_IF_GetNextTcpConnEntry(data)!=IPAL_RESULT_OK)
		{
		    if(SNMP_MGR_IsDebugMode())
   	            printf("tcpConnTable_next: getnext return false\n");
			return FALSE;
		}
	}
	return TRUE;
}

/*
 * var_tcpConnTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *
var_tcpConnTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{
    UI32_T compc=0;
    oid compl[tcpConnEntry_INSTANCE_LEN];
    oid best_inst[tcpConnEntry_INSTANCE_LEN];
    IPAL_IF_Tcpv4ConnEntry_T data;



    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl, tcpConnEntry_INSTANCE_LEN);

     /*check compc, retrive compl*/
    if (exact)/*get,set*/
    {
        if (!tcpConnTable_get(compc, compl, &data))
            return NULL;
    }
    else/*getnext*/
    {
        if (!tcpConnTable_next(compc, compl, &data))
            return NULL;
    }

    memcpy(name, vp->name, vp->namelen*sizeof(oid));
    SNMP_MGR_BindIpInstance(data.tcp_conn_local_address, 0, best_inst);
    best_inst[4]=data.tcp_conn_local_port;
    SNMP_MGR_BindIpInstance(data.tcp_conn_rem_address, 5, best_inst);
    best_inst[9]=data.tcp_conn_rem_port;

    memcpy(name + vp->namelen, best_inst, tcpConnEntry_INSTANCE_LEN*sizeof(oid));
    *length = vp->namelen +tcpConnEntry_INSTANCE_LEN;

    *var_len = sizeof(long_return);

    /*
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic)
     {
    case TCPCONNSTATE:
        *write_method = write_tcpConnState;
         long_return  = data.tcp_conn_state;
        return (u_char*) &long_return;
    case TCPCONNLOCALADDRESS:
         *var_len = sizeof(ipaddr_return);
         ipaddr_return  = data.tcp_conn_local_address;
        return (u_char*) &ipaddr_return;
    case TCPCONNLOCALPORT:
         long_return  = data.tcp_conn_local_port;
        return (u_char*) &long_return;
    case TCPCONNREMADDRESS:
         *var_len = sizeof(ipaddr_return);
         ipaddr_return  = data.tcp_conn_rem_address;
        return (u_char*) &ipaddr_return;
    case TCPCONNREMPORT:
         long_return  = data.tcp_conn_rem_port;
        return (u_char*) &long_return;
    default:
      ERROR_MSG("");
    }
    return NULL;
}


int
write_tcpConnState(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    UI32_T tcpConnState;
    if (name_len!=  20)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    tcpConnState = *(long *)var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }


            if ((tcpConnState<=1)|| (tcpConnState>=12) )
      {
            //snmp_log(LOG_ERR, "not supported admin state\n");
            return SNMP_ERR_WRONGVALUE;
        }
        break;

        case RESERVE2:
          value = *(long *)var_val;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
        {
#if 0
        	IPAL_IF_Tcpv4ConnEntry_T data;

	        SNMP_MGR_ReadIpFromCompl(name, 10, &data.tcp_conn_local_address);
	        data.tcp_conn_local_port = (UI32_T)name[14];
	        SNMP_MGR_ReadIpFromCompl(name, 15, &data.tcp_conn_rem_address);
	        data.tcp_conn_rem_port = (UI32_T) name[19];

			if(IPAL_IF_GetTcpConnEntry(& data) != IPAL_RESULT_OK)
				return SNMP_ERR_COMMITFAILED;

           if (NETCFG_MGR_SetTcpConnEntry(tcpConnState,
                                         data.tcp_conn_local_address,
                                         data.tcp_conn_local_port,
                                         data.tcp_conn_rem_address,
                                         data.tcp_conn_rem_port) != TRUE)

 #endif
 			return SNMP_ERR_COMMITFAILED;

          }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
