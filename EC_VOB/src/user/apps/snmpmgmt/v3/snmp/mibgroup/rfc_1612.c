/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.scalar.conf,v 1.5 2002/07/18 14:18:52 dts12 Exp $
 */
#include "sys_cpnt.h"

#if (SYS_CPNT_DNS == TRUE)
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "rfc_1612.h"
#include "l_stdlib.h"
#include "leaf_1612.h"
#include "dns_pmgr.h"
#include "dns_pom.h"
#include "sysORTable.h"

/* XXX steven.jiang for removing compilation warnings */
#include "snmp_mgr.h"
int DNS_PMGR_GetDnsResConfigImplementIdent(UI8_T* dnsResConfigImplementIdent_p);
int DNS_PMGR_GetDnsResConfigResetTime(int *config_reset_time_p);
BOOL_T L_STDLIB_StrIsAsciiPrintWithCount ( char *oct_p, int len );

/** Initializes the dnsResConfig module */
void
init_dnsResConfig(void)
{
    oid             dns_resolver_module_oid[] = { SNMP_OID_MIB2, 32, 2 };

    static oid      dnsResConfigImplementIdent_oid[] =
        { 1, 3, 6, 1, 2, 1, 32, 2, 1, 1, 1, 0 };
    static oid      dnsResConfigUpTime_oid[] =
        { 1, 3, 6, 1, 2, 1, 32, 2, 1, 1, 5, 0 };
    static oid      dnsResConfigResetTime_oid[] =
        { 1, 3, 6, 1, 2, 1, 32, 2, 1, 1, 6, 0 };

    static oid      dnsResConfigService_oid[] =
        { 1, 3, 6, 1, 2, 1, 32, 2, 1, 1, 2, 0 };
    static oid      dnsResConfigMaxCnames_oid[] =
        { 1, 3, 6, 1, 2, 1, 32, 2, 1, 1, 3, 0 };
    static oid      dnsResConfigReset_oid[] =
        { 1, 3, 6, 1, 2, 1, 32, 2, 1, 1, 7, 0 };

    DEBUGMSGTL(("dnsResConfig", "Initializing\n"));

    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("dnsResConfigImplementIdent",
                                         get_dnsResConfigImplementIdent,
                                         dnsResConfigImplementIdent_oid,
                                         OID_LENGTH
                                         (dnsResConfigImplementIdent_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("dnsResConfigService",
                                         get_dnsResConfigService,
                                         dnsResConfigService_oid,
                                         OID_LENGTH
                                         (dnsResConfigService_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("dnsResConfigResetTime",
                                         get_dnsResConfigResetTime,
                                         dnsResConfigResetTime_oid,
                                         OID_LENGTH
                                         (dnsResConfigResetTime_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("dnsResConfigMaxCnames",
                               do_dnsResConfigMaxCnames,
                               dnsResConfigMaxCnames_oid,
                               OID_LENGTH(dnsResConfigMaxCnames_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("dnsResConfigReset", do_dnsResConfigReset,
                               dnsResConfigReset_oid,
                               OID_LENGTH(dnsResConfigReset_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("dnsResConfigUpTime",
                                         get_dnsResConfigUpTime,
                                         dnsResConfigUpTime_oid,
                                         OID_LENGTH
                                         (dnsResConfigUpTime_oid),
                                         HANDLER_CAN_RONLY));
    REGISTER_SYSOR_ENTRY(dns_resolver_module_oid,
                         "The Rfc 1612 DNS Resolver MIB.");
}

int
get_dnsResConfigImplementIdent(netsnmp_mib_handler *handler,
                               netsnmp_handler_registration *reginfo,
                               netsnmp_agent_request_info *reqinfo,
                               netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
        {
            UI8_T dnsResConfigImplementIdent[MAXSIZE_dnsResConfigImplementIdent];

            if (DNS_PMGR_GetDnsResConfigImplementIdent(dnsResConfigImplementIdent)!= DNS_OK)
            {
                return SNMP_ERR_GENERR;
            }
            strcpy((char *)return_buf, (char *)dnsResConfigImplementIdent);
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, (u_char *) return_buf, strlen((char *)return_buf));
        }
            break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_dnsResConfigService(netsnmp_mib_handler *handler,
                        netsnmp_handler_registration *reginfo,
                        netsnmp_agent_request_info *reqinfo,
                        netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
           {

            //int dnsResConfigService;

            //if (DNS_PMGR_GetDnsResConfigService(&dnsResConfigService) != DNS_OK)
	        //    return SNMP_ERR_GENERR;

      	    long_return =  1;
                     snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *)&long_return, sizeof(long_return));
            }
            break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_dnsResConfigResetTime(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
           {

                int dnsResConfigResetTime;

	    if (DNS_PMGR_GetDnsResConfigResetTime(&dnsResConfigResetTime) != DNS_OK)
	       return SNMP_ERR_GENERR;

      	  long_return =  dnsResConfigResetTime;
                     snmp_set_var_typed_value(requests->requestvb, ASN_GAUGE, (u_char *)&long_return, sizeof(long_return));
            }
            break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_dnsResConfigMaxCnames(netsnmp_mib_handler *handler,
                         netsnmp_handler_registration *reginfo,
                         netsnmp_agent_request_info *reqinfo,
                         netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode)
     {

        case MODE_GET:
           {
           	int dnsResConfigMaxCnames;

                if ( DNS_PMGR_GetDnsResConfigMaxCnames(&dnsResConfigMaxCnames)!= DNS_OK)
                {
                    return SNMP_ERR_GENERR;
                }

                  long_return = dnsResConfigMaxCnames;
                  snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
            }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
            }
            break;

        case MODE_SET_RESERVE2:

            if (*requests->requestvb->val.integer < MIN_dnsResConfigMaxCnames ||
                *requests->requestvb->val.integer > MAX_dnsResConfigMaxCnames)
            {
               netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
        {
            UI32_T dnsResConfigMaxCnames;

            dnsResConfigMaxCnames = *requests->requestvb->val.integer;


            if (DNS_PMGR_SetDnsResConfigMaxCnames( dnsResConfigMaxCnames)!= DNS_OK)
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);

         }
          break;

        case MODE_SET_COMMIT:

            break;

        case MODE_SET_UNDO:

            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
do_dnsResConfigReset(netsnmp_mib_handler *handler,
                     netsnmp_handler_registration *reginfo,
                     netsnmp_agent_request_info *reqinfo,
                     netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode)
     {

        case MODE_GET:
           {
           	int dnsResConfigReset;

                if ( DNS_PMGR_GetDnsResConfigReset(&dnsResConfigReset)!= DNS_OK)
                {
                    return SNMP_ERR_GENERR;
                }

                  long_return = dnsResConfigReset;
                  snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
            }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
            }
            break;

        case MODE_SET_RESERVE2:
            switch (*requests->requestvb->val.integer)
            {
                case VAL_dnsResConfigReset_other:
                    break;

                case VAL_dnsResConfigReset_reset:
                    break;

                case VAL_dnsResConfigReset_initializing:
                    break;

                case VAL_dnsResConfigReset_running:
                    break;

                default:
                    netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
        {
            int dnsResConfigReset;

            dnsResConfigReset = *requests->requestvb->val.integer;


            if (DNS_PMGR_SetDnsResConfigReset( &dnsResConfigReset)!= DNS_OK)
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);

         }
          break;

        case MODE_SET_COMMIT:

            break;

        case MODE_SET_UNDO:

            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_dnsResConfigUpTime(netsnmp_mib_handler *handler,
                       netsnmp_handler_registration *reginfo,
                       netsnmp_agent_request_info *reqinfo,
                       netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
           {

               int dnsResConfigUpTime;

	       if (DNS_PMGR_GetDnsResConfigUpTime(&dnsResConfigUpTime) != DNS_OK)
	           return SNMP_ERR_GENERR;

      	       long_return =  dnsResConfigUpTime;
               snmp_set_var_typed_value(requests->requestvb, ASN_GAUGE, (u_char *)&long_return, sizeof(long_return));
            }
            break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

/*
 * dnsResConfigSbeltTable_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid             dnsResConfigSbeltTable_variables_oid[] =
    { 1, 3, 6, 1, 2, 1, 32, 2, 1, 1 };

/*
 * variable3 dnsResConfigSbeltTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */

struct variable3 dnsResConfigSbeltTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */

#define DNSRESCONFIGSBELTNAME		2
    {DNSRESCONFIGSBELTNAME, ASN_OCTET_STR, RWRITE,
     var_dnsResConfigSbeltTable, 3, {4, 1, 2}},
#define DNSRESCONFIGSBELTRECURSION		3
    {DNSRESCONFIGSBELTRECURSION, ASN_INTEGER, RWRITE,
     var_dnsResConfigSbeltTable, 3, {4, 1, 3}},
#define DNSRESCONFIGSBELTPREF		4
    {DNSRESCONFIGSBELTPREF, ASN_INTEGER, RWRITE,
     var_dnsResConfigSbeltTable, 3, {4, 1, 4}},
#define DNSRESCONFIGSBELTSTATUS		7
    {DNSRESCONFIGSBELTSTATUS, ASN_INTEGER, RWRITE,
     var_dnsResConfigSbeltTable, 3, {4, 1, 7}},
};
/*
 * (L = length of the oidsuffix)
 */


/** Initializes the dnsResConfigSbeltTable module */
void
init_dnsResConfigSbeltTable(void)
{

    DEBUGMSGTL(("dnsResConfigSbeltTable", "Initializing\n"));

    /*
     * register ourselves with the agent to handle our mib tree
     */
    REGISTER_MIB("dnsResConfigSbeltTable",
                 dnsResConfigSbeltTable_variables, variable3,
                 dnsResConfigSbeltTable_variables_oid);

    /*
     * place any other initialization junk you need here
     */
}

static int
header_dnsResConfigSbeltTable(struct variable *vp,
               oid * name,
               size_t * length,
               int exact, size_t * var_len, WriteMethod ** write_method,
               UI32_T *index1, I8_T *index2, UI32_T *index2_len, int *index3)
{
#if 0/*IPV6*/
#define OID_NAME_LENGTH	13
    oid             newname[MAX_OID_LEN];
    int             result;
   DNS_ResConfigSbeltEntry_T  entry;
   UI32_T dns_index1 = 0;
   I8_T dns_index2[MAXSIZE_dnsResConfigSbeltSubTree+1];
   int dns_index3;
   int return_val;
   oid  next_inst[6+MAXSIZE_dnsResConfigSbeltSubTree];
   int i;


     memcpy((char *) newname, (char *) vp->name,
           (int) vp->namelen * sizeof(oid));
    /*
     * find "next" interface
     */
    memset(  &entry, 0 , sizeof(entry));

    /*
     * find "next" interface
     */

 while (  (return_val= DNS_PMGR_GetNextDnsResConfigSbeltEntry( &entry)) == DNS_OK)
     {
       dns_index1 = entry.dnsResConfigSbeltAddr;
       strcpy((char *)dns_index2, (char *)entry.dnsResConfigSbeltSubTree);
       dns_index3 = entry.dnsResConfigSbeltClass;

       SNMP_MGR_BindIpInstance( dns_index1, 0, (UI32_T *)next_inst);
       next_inst[4] = strlen((char *)dns_index2);
       for ( i = 0; i< strlen((char *)dns_index2); i++)
       {
           next_inst[i+5] = dns_index2[i];
       }
       next_inst[strlen((char *)dns_index2)+5]=dns_index3;

        memcpy( (char*)&newname[OID_NAME_LENGTH], (char*) next_inst,  (6+strlen((char *)dns_index2))*sizeof(oid));
        result =
            snmp_oid_compare(name, *length, newname,
                             (int) vp->namelen + 6+strlen((char *)dns_index2));
        if ((exact && (result == 0)) || (!exact && (result < 0)))
            break;
    }
    if (return_val!= DNS_OK ) {
        DEBUGMSGTL(("mibII/interfaces", "... index out of range\n"));
        return MATCH_FAILED;
    }
    memcpy((char *) name, (char *) newname,
           ((int) vp->namelen + 6+strlen((char *)dns_index2)) * sizeof(oid));
    *length = vp->namelen + 6+strlen((char *)dns_index2);
    *var_len = sizeof(long);    /* default to 'long' results */
    *index1 = dns_index1;
     strcpy((char *)index2, (char *)dns_index2);
     *index3 = dns_index3;
     *index2_len = strlen((char *)index2);
#endif
    return TRUE;

}

/* This entry is used for entry which have the ability to row create*/
static DNS_ResConfigSbeltEntry_T dnsResConfigSbeltEntry;

/*
 * var_dnsResConfigSbeltTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_dnsResConfigSbeltTable(struct variable *vp,
                           oid * name,
                           size_t * length,
                           int exact,
                           size_t * var_len, WriteMethod ** write_method)
{
#if 0/*IPV6*/
    /* variables we may use later */

    UI32_T index1,index2_len, retval;
    I8_T index2[MAXSIZE_dnsResConfigSbeltSubTree+1];
    int index3;

    DNS_ResConfigSbeltEntry_T  entry;


    /* Give default value for the record first.
     * We use the row_status = 0 to indicate if this set operation is Set by field
     * or set by record(included row creation), if the row_status =0, this record
     * mean set by field, otherwise, we just think it is a normal set operation
     */
     if (DNS_PMGR_GetDefaultDnsResConfigSbeltEntry(&dnsResConfigSbeltEntry)!= DNS_OK)
     {
         return NULL;
     }
     dnsResConfigSbeltEntry.dnsResConfigSbeltStatus = 0;

   /*Since this table allow for entry that does not exist, (creation). we need to know the write method first*/
    switch(vp->magic)
     {

      case DNSRESCONFIGSBELTRECURSION:
        *write_method = write_dnsResConfigSbeltRecursion;
        break;
      case DNSRESCONFIGSBELTPREF:
        *write_method = write_dnsResConfigSbeltPref;
        break;
      case DNSRESCONFIGSBELTSTATUS:
        *write_method = write_dnsResConfigSbeltStatus;
         break;
    default:
      ERROR_MSG("");
    }



    memset( &entry, 0, sizeof(entry));

     retval  = header_dnsResConfigSbeltTable(vp, name, length, exact, var_len, write_method,  &index1,index2, &index2_len, &index3);

    if (retval == MATCH_FAILED)
        return NULL;


   entry.dnsResConfigSbeltAddr =index1;
   memcpy(entry.dnsResConfigSbeltSubTree,index2, index2_len);
   entry.dnsResConfigSbeltClass = index3;


    if (DNS_PMGR_GetDnsResConfigSbeltEntry( &entry)!= DNS_OK)
            return NULL;


    /*
     * * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
      case DNSRESCONFIGSBELTNAME:
        strcpy((char *)return_buf,  (char *)entry.dnsResConfigSbeltName);
        *var_len = strlen((char *)return_buf);
        return (u_char*) return_buf;
      case DNSRESCONFIGSBELTRECURSION:
        *write_method = write_dnsResConfigSbeltRecursion;
         long_return =entry.dnsResConfigSbeltRecursion;
        return (u_char*) &long_return;
      case DNSRESCONFIGSBELTPREF:
        *write_method = write_dnsResConfigSbeltPref;
         long_return =entry.dnsResConfigSbeltPref;
        return (u_char*) &long_return;
      case DNSRESCONFIGSBELTSTATUS:
        *write_method = write_dnsResConfigSbeltStatus;
         long_return =entry.dnsResConfigSbeltStatus;
        return (u_char*) &long_return;
    default:
        ERROR_MSG("");
    }
#endif
    return NULL;
}


int
write_dnsResConfigSbeltName(int action,
                            u_char * var_val,
                            u_char var_val_type,
                            size_t var_val_len,
                            u_char * statP, oid * name, size_t name_len)
{
#if 0/*IPV6*/
    DNS_ResConfigSbeltEntry_T entry;
    int i;

    memset(&entry, 0, sizeof(entry));

    if ((char) name[12] != DNSRESCONFIGSBELTNAME)
    {
        return SNMP_ERR_NOTWRITABLE;
    }

     /* check 2: name[16] = the length of the dnsResConfigSbeltSubTree, check if these exceed the max size*/
    if (name[17] > MAXSIZE_dnsResConfigSbeltSubTree)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    /* check 3: check if the input index is exactly match, if not return fail*/
    if (name_len!= name[17]+ 6 + 13)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    SNMP_MGR_ReadIpFromCompl(name, 13, &entry.dnsResConfigSbeltAddr);


    for (i = 0; i< name[17]; i++)
    {
        entry.dnsResConfigSbeltSubTree[i] = name[18+i];
    }
    entry.dnsResConfigSbeltSubTree[name[17]] = '\0';
    entry.dnsResConfigSbeltClass = name[ name[17]+18];
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len >MAXSIZE_dnsResConfigSbeltName) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          /* In reserve2, we overwrite the set value to cHsrpGrpEntry*/
          memcpy(dnsResConfigSbeltEntry.dnsResConfigSbeltName, var_val, var_val_len);
          dnsResConfigSbeltEntry.dnsResConfigSbeltName[var_val_len] = 0;
          if (!L_STDLIB_StrIsAsciiPrintWithCount((char *)dnsResConfigSbeltEntry.dnsResConfigSbeltName,strlen((char *)dnsResConfigSbeltEntry.dnsResConfigSbeltName)))
          {
             return SNMP_ERR_COMMITFAILED;
          }
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
          /* For row creation, if row_status =0, mean that this is a normal
           * operation, we do the normal set operation, otherwise it is a row
           * creation operation, will do nothing here, and the overall entry
           * will perform in the write_xxxRowStatus function.
           */
           if (dnsResConfigSbeltEntry.dnsResConfigSbeltStatus == 0)
           {
               strcpy((char *)entry.dnsResConfigSbeltName, (char *)dnsResConfigSbeltEntry.dnsResConfigSbeltName);
         if (DNS_PMGR_SetDnsResConfigSbeltName (&entry) != DNS_OK)
         {
             return SNMP_ERR_COMMITFAILED;
          }
           }
          break;
        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
#endif
    return SNMP_ERR_NOERROR;
}

int
write_dnsResConfigSbeltRecursion(int action,
                                 u_char * var_val,
                                 u_char var_val_type,
                                 size_t var_val_len,
                                 u_char * statP,
                                 oid * name, size_t name_len)
{
#if 0/*IPV6*/
    int i;
    DNS_ResConfigSbeltEntry_T entry;

    memset(&entry, 0, sizeof(entry));

    if ((char) name[12] != DNSRESCONFIGSBELTRECURSION)
    {
        return SNMP_ERR_NOTWRITABLE;
    }

     /* check 2: name[16] = the length of the dnsResConfigSbeltSubTree, check if these exceed the max size*/
    if (name[17] > MAXSIZE_dnsResConfigSbeltSubTree)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    /* check 3: check if the input index is exactly match, if not return fail*/
    if (name_len!= name[17]+ 6 + 13)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    SNMP_MGR_ReadIpFromCompl(name, 13, &entry.dnsResConfigSbeltAddr);

    for (i = 0; i< name[17]; i++)
    {
        entry.dnsResConfigSbeltSubTree[i] = name[18+i];
    }
    entry.dnsResConfigSbeltSubTree[name[17]] = '\0';
    entry.dnsResConfigSbeltClass = name[ name[17]+18];
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len != sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
         /* In reserve2, we overwrite the set value to cHsrpGrpEntry*/
          dnsResConfigSbeltEntry.dnsResConfigSbeltRecursion = *(long *)var_val;
          break;
        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
          /* For row creation, if row_status =0, mean that this is a normal
           * operation, we do the normal set operation, otherwise it is a row
           * creation operation, will do nothing here, and the overall entry
           * will perform in the write_xxxRowStatus function.
           */
           if (dnsResConfigSbeltEntry.dnsResConfigSbeltStatus == 0)
           {
               entry.dnsResConfigSbeltRecursion = dnsResConfigSbeltEntry.dnsResConfigSbeltRecursion;

         if (DNS_PMGR_SetDnsResConfigSbeltRecursion (&entry) != DNS_OK)
         {
             return SNMP_ERR_COMMITFAILED;
         }
           }
         break;
        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
#endif
    return SNMP_ERR_NOERROR;
}

int
write_dnsResConfigSbeltPref(int action,
                            u_char * var_val,
                            u_char var_val_type,
                            size_t var_val_len,
                            u_char * statP, oid * name, size_t name_len)
{
#if 0/*IPV6*/
    int i;
    DNS_ResConfigSbeltEntry_T entry;

    memset(&entry, 0, sizeof(entry));

    if ((char) name[12] != DNSRESCONFIGSBELTPREF)
    {
        return SNMP_ERR_NOTWRITABLE;
    }

     /* check 2: name[16] = the length of the dnsResConfigSbeltSubTree, check if these exceed the max size*/
    if (name[17] > MAXSIZE_dnsResConfigSbeltSubTree)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    /* check 3: check if the input index is exactly match, if not return fail*/
    if (name_len!= name[17]+ 6 + 13)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    SNMP_MGR_ReadIpFromCompl(name, 13, &entry.dnsResConfigSbeltAddr);


    for (i = 0; i< name[17]; i++)
    {
        entry.dnsResConfigSbeltSubTree[i] = name[18+i];
    }
    entry.dnsResConfigSbeltSubTree[name[17]] = '\0';
    entry.dnsResConfigSbeltClass = name[ name[17]+18];
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len != sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          /* In reserve2, we overwrite the set value to cHsrpGrpEntry*/
          dnsResConfigSbeltEntry.dnsResConfigSbeltPref = *(long *)var_val;
          break;
        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
          /* For row creation, if row_status =0, mean that this is a normal
           * operation, we do the normal set operation, otherwise it is a row
           * creation operation, will do nothing here, and the overall entry
           * will perform in the write_xxxRowStatus function.
           */
           if (dnsResConfigSbeltEntry.dnsResConfigSbeltStatus == 0)
           {
                 entry.dnsResConfigSbeltPref = dnsResConfigSbeltEntry.dnsResConfigSbeltPref;

         if (DNS_PMGR_SetDnsResConfigSbeltPref (&entry) != DNS_OK)
         {
             return SNMP_ERR_COMMITFAILED;
         }
           }
         break;
        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
#endif
    return SNMP_ERR_NOERROR;
}

int
write_dnsResConfigSbeltStatus(int action,
                              u_char * var_val,
                              u_char var_val_type,
                              size_t var_val_len,
                              u_char * statP, oid * name, size_t name_len)
{
#if 0 /*IPV6*/
    int i;
    DNS_ResConfigSbeltEntry_T entry;

    memset(&entry, 0, sizeof(entry));

    if ((char) name[12] != DNSRESCONFIGSBELTSTATUS)
    {
        return SNMP_ERR_NOTWRITABLE;
    }


    /* check 2: name[16] = the length of the dnsResConfigSbeltSubTree, check if these exceed the max size*/
    if (name[17] > MAXSIZE_dnsResConfigSbeltSubTree)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    /* check 3: check if the input index is exactly match, if not return fail*/
    if (name_len!= name[17]+ 6 + 13)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    SNMP_MGR_ReadIpFromCompl(name, 13, &entry.dnsResConfigSbeltAddr);

    for (i = 0; i< name[17]; i++)
    {
        entry.dnsResConfigSbeltSubTree[i] = name[18+i];
    }
    entry.dnsResConfigSbeltSubTree[name[17]] = '\0';
    entry.dnsResConfigSbeltClass = name[ name[17]+18];
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len != sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
            /* In reserve2, we overwrite the set value to cHsrpGrpEntry*/
          dnsResConfigSbeltEntry.dnsResConfigSbeltStatus = *(long *)var_val;
          if ((dnsResConfigSbeltEntry.dnsResConfigSbeltStatus <1) || (dnsResConfigSbeltEntry.dnsResConfigSbeltStatus >6))
          return SNMP_ERR_WRONGVALUE;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
          /* We perform the row creation here, if the row status = 4(createAndGo),
           * or 5 (createAndWait), we call the SetByEntry API, otherwise, call the
           * set rowstatus API
           */
          switch (dnsResConfigSbeltEntry.dnsResConfigSbeltStatus)
          {
              case VAL_dnsResConfigSbeltStatus_createAndGo:
              case VAL_dnsResConfigSbeltStatus_createAndWait:
                dnsResConfigSbeltEntry.dnsResConfigSbeltAddr= entry.dnsResConfigSbeltAddr;
                memcpy(dnsResConfigSbeltEntry.dnsResConfigSbeltSubTree, entry.dnsResConfigSbeltSubTree,name[17] );
                dnsResConfigSbeltEntry.dnsResConfigSbeltSubTree[name[17]]=0;
                dnsResConfigSbeltEntry.dnsResConfigSbeltClass = entry.dnsResConfigSbeltClass;
                if (DNS_PMGR_SetDnsResConfigSbeltEntry(&dnsResConfigSbeltEntry) != DNS_OK)
                {
                    return SNMP_ERR_COMMITFAILED;
                }
              break;
              case VAL_dnsResConfigSbeltStatus_active:
              case VAL_dnsResConfigSbeltStatus_notInService:
              case VAL_dnsResConfigSbeltStatus_notReady:
              case VAL_dnsResConfigSbeltStatus_destroy:
                dnsResConfigSbeltEntry.dnsResConfigSbeltAddr= entry.dnsResConfigSbeltAddr;
                memcpy(dnsResConfigSbeltEntry.dnsResConfigSbeltSubTree, entry.dnsResConfigSbeltSubTree,name[17] );
                dnsResConfigSbeltEntry.dnsResConfigSbeltSubTree[name[17]]=0;
                dnsResConfigSbeltEntry.dnsResConfigSbeltClass = entry.dnsResConfigSbeltClass;
                if (DNS_PMGR_SetDnsResConfigSbeltStatus(&dnsResConfigSbeltEntry) != DNS_OK)
                {
                    return SNMP_ERR_COMMITFAILED;
                }
                break;
              default:
            return SNMP_ERR_COMMITFAILED;
          }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
#endif
    return SNMP_ERR_NOERROR;
}

static int
header_dnsResCounterByOpcodeTable(struct variable *vp,
               oid * name,
               size_t * length,
               int exact, size_t * var_len, WriteMethod ** write_method);


/*
 * dnsResCounterByOpcodeTable_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid             dnsResCounterByOpcodeTable_variables_oid[] =
    { 1, 3, 6, 1, 2, 1, 32, 2, 1, 2};

/*
 * variable3 dnsResCounterByOpcodeTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */

struct variable3 dnsResCounterByOpcodeTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */

#define DNSRESCOUNTERBYOPCODEQUERIES		2
    {DNSRESCOUNTERBYOPCODEQUERIES, ASN_COUNTER, RONLY,
     var_dnsResCounterByOpcodeTable, 3, {3, 1, 2}},
#define DNSRESCOUNTERBYOPCODERESPONSES		3
    {DNSRESCOUNTERBYOPCODERESPONSES, ASN_COUNTER, RONLY,
     var_dnsResCounterByOpcodeTable, 3, {3, 1, 3}},
};
/*
 * (L = length of the oidsuffix)
 */


/** Initializes the dnsResCounterByOpcodeTable module */
void
init_dnsResCounterByOpcodeTable(void)
{

    DEBUGMSGTL(("dnsResCounterByOpcodeTable", "Initializing\n"));

    /*
     * register ourselves with the agent to handle our mib tree
     */
    REGISTER_MIB("dnsResCounterByOpcodeTable",
                 dnsResCounterByOpcodeTable_variables, variable3,
                 dnsResCounterByOpcodeTable_variables_oid);

    /*
     * place any other initialization junk you need here
     */
}

static int
header_dnsResCounterByOpcodeTable(struct variable *vp,
               oid * name,
               size_t * length,
               int exact, size_t * var_len, WriteMethod ** write_method)
{
#define ENTRY_NAME_LENGTH	13
    oid             newname[MAX_OID_LEN];
    int    interface;
    DNS_ResCounterByOpcodeEntry_T entry;
    BOOL_T return_val;
   int  result;


    memcpy((char *) newname, (char *) vp->name,
           (int) vp->namelen * sizeof(oid));
    /*
     * find "next" interface
     */

     memset( &entry, 0, sizeof(entry));


     while (  (return_val= DNS_PMGR_GetNextDnsResCounterByOpcodeEntry( &entry)) == DNS_OK)
     {

        newname[ENTRY_NAME_LENGTH] = (oid) entry.dnsResCounterByOpcodeCode - 1;

        result =
            snmp_oid_compare(name, *length, newname,
                             (int) vp->namelen + 1);

        if ((exact && (result == 0)) || (!exact && (result < 0)))
        {

            break;
         }
    }

    if (return_val!= DNS_OK ) {
        return MATCH_FAILED;
    }


    memcpy((char *) name, (char *) newname,
           ((int) vp->namelen + 1) * sizeof(oid));
    *length = vp->namelen + 1;
    *write_method = 0;
    *var_len = sizeof(long);    /* default to 'long' results */
    interface = newname[ENTRY_NAME_LENGTH];

    return interface;
}

/*
 * var_dnsResCounterByOpcodeTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_dnsResCounterByOpcodeTable(struct variable *vp,
                               oid * name,
                               size_t * length,
                               int exact,
                               size_t * var_len,
                               WriteMethod ** write_method)
{

    DNS_ResCounterByOpcodeEntry_T entry;
    int             interface;


    memset( &entry, 0, sizeof(entry));
    interface =
        header_dnsResCounterByOpcodeTable(vp, name, length, exact, var_len, write_method);
    if (interface == MATCH_FAILED)
        return NULL;

    entry.dnsResCounterByOpcodeCode = interface;
    if (DNS_POM_GetDnsResCounterByOpcodeEntry( &entry)!= DNS_OK)
        return NULL;


    /*
     * * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
      case DNSRESCOUNTERBYOPCODEQUERIES:
        long_return = entry.dnsResCounterByOpcodeQueries;
        return (u_char *) & long_return;
      case DNSRESCOUNTERBYOPCODERESPONSES:
        long_return = entry.dnsResCounterByOpcodeResponses;
        return (u_char *) & long_return;
    default:
        ERROR_MSG("");
    }
    return NULL;
}

/*
 * dnsResCounterByRcodeTable_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid             dnsResCounterByRcodeTable_variables_oid[] =
    { 1, 3, 6, 1, 2, 1, 32, 2, 1, 2};

/*
 * variable3 dnsResCounterByRcodeTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */

struct variable3 dnsResCounterByRcodeTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */


#define DNSRESCOUNTERBYRCODERESPONSES		2
    {DNSRESCOUNTERBYRCODERESPONSES, ASN_COUNTER, RONLY,
     var_dnsResCounterByRcodeTable, 3, {4, 1, 2}},
};
/*
 * (L = length of the oidsuffix)
 */


/** Initializes the dnsResCounterByRcodeTable module */
void
init_dnsResCounterByRcodeTable(void)
{

    DEBUGMSGTL(("dnsResCounterByRcodeTable", "Initializing\n"));

    /*
     * register ourselves with the agent to handle our mib tree
     */
    REGISTER_MIB("dnsResCounterByRcodeTable",
                 dnsResCounterByRcodeTable_variables, variable3,
                 dnsResCounterByRcodeTable_variables_oid);

    /*
     * place any other initialization junk you need here
     */
}

static int
header_dnsResCounterByRcodeTable(struct variable *vp,
               oid * name,
               size_t * length,
               int exact, size_t * var_len, WriteMethod ** write_method)
{
#define ENTRY_NAME_LENGTH	13
    oid             newname[MAX_OID_LEN];
    int    interface;
    DNS_ResCounterByRcodeEntry_T entry;
    BOOL_T return_val;
   int  result;


    memcpy((char *) newname, (char *) vp->name,
           (int) vp->namelen * sizeof(oid));
    /*
     * find "next" interface
     */

     memset( &entry, 0, sizeof(entry));


     while (  (return_val= DNS_PMGR_GetNextDnsResCounterByRcodeEntry( &entry)) == DNS_OK)
     {

        newname[ENTRY_NAME_LENGTH] = (oid) entry.dnsResCounterByRcodeCode - 1;

        result =
            snmp_oid_compare(name, *length, newname,
                             (int) vp->namelen + 1);

        if ((exact && (result == 0)) || (!exact && (result < 0)))
        {

            break;
         }
    }

    if (return_val != DNS_OK) {
        return MATCH_FAILED;
    }


    memcpy((char *) name, (char *) newname,
           ((int) vp->namelen + 1) * sizeof(oid));
    *length = vp->namelen + 1;
    *write_method = 0;
    *var_len = sizeof(long);    /* default to 'long' results */
    interface = newname[ENTRY_NAME_LENGTH];

    return interface;
}

/*
 * var_dnsResCounterByRcodeTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_dnsResCounterByRcodeTable(struct variable *vp,
                              oid * name,
                              size_t * length,
                              int exact,
                              size_t * var_len,
                              WriteMethod ** write_method)
{

    DNS_ResCounterByRcodeEntry_T entry;
    int             interface;


    memset( &entry, 0, sizeof(entry));
    interface =
        header_dnsResCounterByRcodeTable(vp, name, length, exact, var_len, write_method);
    if (interface == MATCH_FAILED)
        return NULL;

    entry.dnsResCounterByRcodeCode = interface;
    if (DNS_POM_GetDnsResCounterByRcodeEntry( &entry)!= DNS_OK)
        return NULL;

    /*
     * * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {

      case DNSRESCOUNTERBYRCODERESPONSES:
        long_return = entry.dnsResCounterByRcodeResponses;
        return (u_char *) & long_return;
    default:
        ERROR_MSG("");
    }
    return NULL;
}

/** Initializes the dnsResCounter module */
void
init_dnsResCounter(void)
{
    static oid      dnsResCounterNonAuthNoDataResps_oid[] =
        { 1, 3, 6, 1, 2, 1, 32, 2, 1, 2, 6, 0 };
    static oid      dnsResCounterNonAuthDataResps_oid[] =
        { 1, 3, 6, 1, 2, 1, 32, 2, 1, 2, 5, 0 };
    static oid      dnsResCounterRecdResponses_oid[] =
        { 1, 3, 6, 1, 2, 1, 32, 2, 1, 2, 8, 0 };
    static oid      dnsResCounterFallbacks_oid[] =
        { 1, 3, 6, 1, 2, 1, 32, 2, 1, 2, 10, 0 };
    static oid      dnsResCounterMartians_oid[] =
        { 1, 3, 6, 1, 2, 1, 32, 2, 1, 2, 7, 0 };
    static oid      dnsResCounterUnparseResps_oid[] =
        { 1, 3, 6, 1, 2, 1, 32, 2, 1, 2, 9, 0 };

    DEBUGMSGTL(("dnsResCounter", "Initializing\n"));

    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("dnsResCounterNonAuthNoDataResps",
                                         get_dnsResCounterNonAuthNoDataResps,
                                         dnsResCounterNonAuthNoDataResps_oid,
                                         OID_LENGTH
                                         (dnsResCounterNonAuthNoDataResps_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("dnsResCounterNonAuthDataResps",
                                         get_dnsResCounterNonAuthDataResps,
                                         dnsResCounterNonAuthDataResps_oid,
                                         OID_LENGTH
                                         (dnsResCounterNonAuthDataResps_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("dnsResCounterRecdResponses",
                                         get_dnsResCounterRecdResponses,
                                         dnsResCounterRecdResponses_oid,
                                         OID_LENGTH
                                         (dnsResCounterRecdResponses_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("dnsResCounterFallbacks",
                                         get_dnsResCounterFallbacks,
                                         dnsResCounterFallbacks_oid,
                                         OID_LENGTH
                                         (dnsResCounterFallbacks_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("dnsResCounterMartians",
                                         get_dnsResCounterMartians,
                                         dnsResCounterMartians_oid,
                                         OID_LENGTH
                                         (dnsResCounterMartians_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("dnsResCounterUnparseResps",
                                         get_dnsResCounterUnparseResps,
                                         dnsResCounterUnparseResps_oid,
                                         OID_LENGTH
                                         (dnsResCounterUnparseResps_oid),
                                         HANDLER_CAN_RONLY));
}

int
get_dnsResCounterNonAuthNoDataResps(netsnmp_mib_handler *handler,
                                    netsnmp_handler_registration *reginfo,
                                    netsnmp_agent_request_info *reqinfo,
                                    netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
           {

               int counter_val;

	       if (DNS_POM_GetDnsResCounterNonAuthNoDataResps(&counter_val) != DNS_OK)
	           return SNMP_ERR_GENERR;

               long_return =  counter_val;
               snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *)&long_return, sizeof(long_return));
           }
        break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_dnsResCounterNonAuthDataResps(netsnmp_mib_handler *handler,
                                  netsnmp_handler_registration *reginfo,
                                  netsnmp_agent_request_info *reqinfo,
                                  netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
           {

               int counter_val;

	       if (DNS_POM_GetDnsResCounterNonAuthDataResps(&counter_val) != DNS_OK)
	           return SNMP_ERR_GENERR;

               long_return =  counter_val;
               snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *)&long_return, sizeof(long_return));
           }
        break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_dnsResCounterRecdResponses(netsnmp_mib_handler *handler,
                               netsnmp_handler_registration *reginfo,
                               netsnmp_agent_request_info *reqinfo,
                               netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
           {

               int counter_val;

	       if (DNS_POM_GetDnsResCounterRecdResponses(&counter_val) != DNS_OK)
	           return SNMP_ERR_GENERR;

               long_return =  counter_val;
               snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *)&long_return, sizeof(long_return));
           }
        break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_dnsResCounterFallbacks(netsnmp_mib_handler *handler,
                           netsnmp_handler_registration *reginfo,
                           netsnmp_agent_request_info *reqinfo,
                           netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
           {

               int counter_val;

	       if (DNS_POM_GetDnsResCounterFallbacks(&counter_val) != DNS_OK)
	           return SNMP_ERR_GENERR;

               long_return =  counter_val;
               snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *)&long_return, sizeof(long_return));
           }
        break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_dnsResCounterMartians(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
           {

               int counter_val;

	       if (DNS_POM_GetDnsResCounterMartians(&counter_val) != DNS_OK)
	           return SNMP_ERR_GENERR;

               long_return =  counter_val;
               snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *)&long_return, sizeof(long_return));
           }
        break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_dnsResCounterUnparseResps(netsnmp_mib_handler *handler,
                              netsnmp_handler_registration *reginfo,
                              netsnmp_agent_request_info *reqinfo,
                              netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
           {

               int counter_val;

	       if (DNS_POM_GetDnsResCounterUnparseResps(&counter_val) != DNS_OK)
	           return SNMP_ERR_GENERR;

               long_return =  counter_val;
               snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *)&long_return, sizeof(long_return));
           }
        break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

/** Initializes the dnsResCache module */
void
init_dnsResCache(void)
{
    static oid      dnsResCacheStatus_oid[] =
        { 1, 3, 6, 1, 2, 1, 32, 2, 1, 4, 1, 0 };
    static oid      dnsResCacheMaxTTL_oid[] =
        { 1, 3, 6, 1, 2, 1, 32, 2, 1, 4, 2, 0 };
#if 0
    static oid      dnsResCacheGoodCaches_oid[] =
        { 1, 3, 6, 1, 2, 1, 32, 2, 1, 4, 3, 0 };
    static oid      dnsResCacheBadCaches_oid[] =
        { 1, 3, 6, 1, 2, 1, 32, 2, 1, 4, 4, 0 };
#endif
    DEBUGMSGTL(("dnsResCache", "Initializing\n"));

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("dnsResCacheStatus", do_dnsResCacheStatus,
                               dnsResCacheStatus_oid,
                               OID_LENGTH(dnsResCacheStatus_oid),
                               HANDLER_CAN_RWRITE));

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("dnsResCacheMaxTTL",
                               do_dnsResCacheMaxTTL,
                               dnsResCacheMaxTTL_oid,
                               OID_LENGTH(dnsResCacheMaxTTL_oid),
                               HANDLER_CAN_RWRITE));
#if 0
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("dnsResCacheGoodCaches",
                                         get_dnsResCacheGoodCaches,
                                         dnsResCacheGoodCaches_oid,
                                         OID_LENGTH
                                         (dnsResCacheGoodCaches_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("dnsResCacheBadCaches",
                                         get_dnsResCacheBadCaches,
                                         dnsResCacheBadCaches_oid,
                                         OID_LENGTH
                                         (dnsResCacheBadCaches_oid),
                                         HANDLER_CAN_RONLY));
#endif
}

int
do_dnsResCacheMaxTTL(netsnmp_mib_handler *handler,
                     netsnmp_handler_registration *reginfo,
                     netsnmp_agent_request_info *reqinfo,
                     netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode)
    {
        case MODE_GET:
        {
            UI32_T dnsResCacheMaxTTL;

            if (DNS_PMGR_GetDnsResCacheMaxTTL(&dnsResCacheMaxTTL) != DNS_OK)
            {
            	return SNMP_ERR_GENERR;
            }

            long_return = dnsResCacheMaxTTL;
            snmp_set_var_typed_value(requests->requestvb, ASN_GAUGE, (u_char *) &long_return, sizeof(long_return));
        }
             break;
        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            if (requests->requestvb->type != ASN_GAUGE)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
            }
            break;

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
          {
               int dnsResCacheMaxTTL;
               dnsResCacheMaxTTL = (*requests->requestvb->val.integer);

               if (DNS_PMGR_SetDnsResCacheMaxTTL(&dnsResCacheMaxTTL) != DNS_OK)
               {
                   netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
               }
           }
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */

            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */

            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}


int
get_dnsResCacheGoodCaches(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
           {

                int dnsResCacheGoodCaches;

	    if (DNS_PMGR_GetDnsResCacheGoodCaches(&dnsResCacheGoodCaches) != DNS_OK)
	       return SNMP_ERR_GENERR;

      	  long_return =  dnsResCacheGoodCaches;
                     snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *)&long_return, sizeof(long_return));
            }
            break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}


int
do_dnsResCacheStatus(netsnmp_mib_handler *handler,
                     netsnmp_handler_registration *reginfo,
                     netsnmp_agent_request_info *reqinfo,
                     netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode)
    {
        case MODE_GET:
        {
            int dnsResCacheStatus;

            if (DNS_PMGR_GetDnsResCacheStatus(&dnsResCacheStatus) != DNS_OK)
            {
            	return SNMP_ERR_GENERR;
            }

            long_return = dnsResCacheStatus;
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
        }
             break;
        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
            }
            break;

        case MODE_SET_RESERVE2:
            switch (*requests->requestvb->val.integer)
            {
                case VAL_dnsResCacheStatus_enabled:
                    break;

                case VAL_dnsResCacheStatus_disabled:
                    break;

                case VAL_dnsResCacheStatus_clear:
                    break;

                default:
                    netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
          {
               int dnsResCacheStatus;
               dnsResCacheStatus = (*requests->requestvb->val.integer);

               if (DNS_PMGR_SetDnsResCacheStatus(&dnsResCacheStatus) != DNS_OK)
               {
                   netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
               }
           }
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */

            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */

            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_dnsResCacheBadCaches(netsnmp_mib_handler *handler,
                         netsnmp_handler_registration *reginfo,
                         netsnmp_agent_request_info *reqinfo,
                         netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
           {

                int dnsResCacheBadCaches;

	    if (DNS_PMGR_GetDnsResCacheBadCaches(&dnsResCacheBadCaches) != DNS_OK)
	       return SNMP_ERR_GENERR;

      	  long_return =  dnsResCacheBadCaches;
                     snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *)&long_return, sizeof(long_return));
            }
            break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

/** Initializes the dnsResOptCounter module */
void
init_dnsResOptCounter(void)
{
    static oid      dnsResOptCounterReferals_oid[] =
        { 1, 3, 6, 1, 2, 1, 32, 2, 1, 6, 1, 0 };
    static oid      dnsResOptCounterRetrans_oid[] =
        { 1, 3, 6, 1, 2, 1, 32, 2, 1, 6, 2, 0 };
#if 0
    static oid      dnsResOptCounterRootRetrans_oid[] =
        { 1, 3, 6, 1, 2, 1, 32, 2, 1, 6, 4, 0 };
    static oid      dnsResOptCounterNoResponses_oid[] =
        { 1, 3, 6, 1, 2, 1, 32, 2, 1, 6, 3, 0 };
#endif
    static oid      dnsResOptCounterInternals_oid[] =
        { 1, 3, 6, 1, 2, 1, 32, 2, 1, 6, 5, 0 };
    static oid      dnsResOptCounterInternalTimeOuts_oid[] =
        { 1, 3, 6, 1, 2, 1, 32, 2, 1, 6, 6, 0 };

    DEBUGMSGTL(("dnsResOptCounter", "Initializing\n"));

    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("dnsResOptCounterReferals",
                                         get_dnsResOptCounterReferals,
                                         dnsResOptCounterReferals_oid,
                                         OID_LENGTH
                                         (dnsResOptCounterReferals_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("dnsResOptCounterRetrans",
                                         get_dnsResOptCounterRetrans,
                                         dnsResOptCounterRetrans_oid,
                                         OID_LENGTH
                                         (dnsResOptCounterRetrans_oid),
                                         HANDLER_CAN_RONLY));
#if 0
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("dnsResOptCounterRootRetrans",
                                         get_dnsResOptCounterRootRetrans,
                                         dnsResOptCounterRootRetrans_oid,
                                         OID_LENGTH
                                         (dnsResOptCounterRootRetrans_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("dnsResOptCounterNoResponses",
                                         get_dnsResOptCounterNoResponses,
                                         dnsResOptCounterNoResponses_oid,
                                         OID_LENGTH
                                         (dnsResOptCounterNoResponses_oid),
                                         HANDLER_CAN_RONLY));
#endif
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("dnsResOptCounterInternals",
                                         get_dnsResOptCounterInternals,
                                         dnsResOptCounterInternals_oid,
                                         OID_LENGTH
                                         (dnsResOptCounterInternals_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("dnsResOptCounterInternalTimeOuts",
                                         get_dnsResOptCounterInternalTimeOuts,
                                         dnsResOptCounterInternalTimeOuts_oid,
                                         OID_LENGTH
                                         (dnsResOptCounterInternalTimeOuts_oid),
                                         HANDLER_CAN_RONLY));
}

int
get_dnsResOptCounterReferals(netsnmp_mib_handler *handler,
                             netsnmp_handler_registration *reginfo,
                             netsnmp_agent_request_info *reqinfo,
                             netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
           {

               int counter_val;

	       if (DNS_POM_GetDnsResOptCounterReferals(&counter_val) != DNS_OK)
	           return SNMP_ERR_GENERR;

               long_return =  counter_val;
               snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *)&long_return, sizeof(long_return));
           }
        break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_dnsResOptCounterRetrans(netsnmp_mib_handler *handler,
                            netsnmp_handler_registration *reginfo,
                            netsnmp_agent_request_info *reqinfo,
                            netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
           {

               int counter_val;

	       if (DNS_POM_GetDnsResOptCounterRetrans(&counter_val) != DNS_OK)
	           return SNMP_ERR_GENERR;

               long_return =  counter_val;
               snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *)&long_return, sizeof(long_return));
           }
        break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_dnsResOptCounterRootRetrans(netsnmp_mib_handler *handler,
                                netsnmp_handler_registration *reginfo,
                                netsnmp_agent_request_info *reqinfo,
                                netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
           {

               int counter_val;

	       if (DNS_POM_GetDnsResOptCounterRootRetrans(&counter_val) != DNS_OK)
	           return SNMP_ERR_GENERR;

               long_return =  counter_val;
               snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *)&long_return, sizeof(long_return));
           }
        break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_dnsResOptCounterNoResponses(netsnmp_mib_handler *handler,
                                netsnmp_handler_registration *reginfo,
                                netsnmp_agent_request_info *reqinfo,
                                netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
           {

               int counter_val;

	       if (DNS_POM_GetDnsResOptCounterNoResponses(&counter_val) != DNS_OK)
	           return SNMP_ERR_GENERR;

               long_return =  counter_val;
               snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *)&long_return, sizeof(long_return));
           }
        break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_dnsResOptCounterInternals(netsnmp_mib_handler *handler,
                              netsnmp_handler_registration *reginfo,
                              netsnmp_agent_request_info *reqinfo,
                              netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
           {

               int counter_val;

	       if (DNS_POM_GetDnsResOptCounterInternals(&counter_val) != DNS_OK)
	           return SNMP_ERR_GENERR;

               long_return =  counter_val;
               snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *)&long_return, sizeof(long_return));
           }
        break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_dnsResOptCounterInternalTimeOuts(netsnmp_mib_handler *handler,
                                     netsnmp_handler_registration *reginfo,
                                     netsnmp_agent_request_info *reqinfo,
                                     netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
           {

               int counter_val;

	       if (DNS_POM_GetDnsResOptCounterInternalTimeOuts(&counter_val) != DNS_OK)
	           return SNMP_ERR_GENERR;

               long_return =  counter_val;
               snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *)&long_return, sizeof(long_return));
           }
        break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
#endif
