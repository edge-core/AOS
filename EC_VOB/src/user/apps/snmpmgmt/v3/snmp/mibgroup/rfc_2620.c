/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.scalar.conf,v 1.8 2004/10/14 12:57:34 dts12 Exp $
 */
#include "sys_type.h"
#include "sys_cpnt.h"
#if (SYS_CPNT_RADIUS_ACCOUNTING == TRUE)
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "leaf_2620.h"
#include "rfc_2620.h"
#include "radius_pmgr.h"
#include "radius_pom.h"
#include "snmp_mgr.h"

/** Initializes the radiusAccClient module */
void
init_radiusAccClient(void)
{
    static oid radiusAccClientInvalidServerAddresses_oid[] = { 1,  3, 6, 1, 2, 1, 67, 2, 2, 1, 1, 1, 0 };
    static oid radiusAccClientIdentifier_oid[] = { 1, 3, 6, 1, 2, 1, 67, 2, 2, 1, 1, 2, 0 };

  DEBUGMSGTL(("radiusAccClient", "Initializing\n"));

    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("radiusAccClientInvalidServerAddresses",
                                         get_radiusAccClientInvalidServerAddresses,
                                         radiusAccClientInvalidServerAddresses_oid,
                                         OID_LENGTH(radiusAccClientInvalidServerAddresses_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("radiusAccClientIdentifier",
                                         get_radiusAccClientIdentifier,
                                         radiusAccClientIdentifier_oid,
                                         OID_LENGTH(radiusAccClientIdentifier_oid),
                                         HANDLER_CAN_RONLY));
}

int
get_radiusAccClientInvalidServerAddresses(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{

    switch(reqinfo->mode) {
        case MODE_GET:
        {
            UI32_T value = 0;

            if (RADIUS_POM_GetAccClientInvalidServerAddresses(&value) == TRUE )
            {
                long_return = value;
                snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER , (u_char *)&long_return , sizeof(long_return) );
            }
            else
            {
                return SNMP_ERR_GENERR;
            }
        }
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
get_radiusAccClientIdentifier(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{

    switch(reqinfo->mode) {
        case MODE_GET:
        {
            UI32_T var_len = 0;
            RADACC_AccClientIdentifier_T entry;
            /* The pointer type must be consistent with the Core Layer API */
           if (RADIUS_PMGR_GetAccClientIdentifier(&entry) == TRUE )
           {
                var_len = strlen((char *)entry.identifier);
                snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR , entry.identifier , var_len );
            }
            else
            {
                return SNMP_ERR_GENERR;
            }
        }
            break;


        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

/*
 * radiusAccServerTable_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid radiusAccServerTable_variables_oid[] = { SNMP_OID_MIB2, 67, 2, 2, 1, 1 };
/*
 * variable3 radiusAccServerTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */
struct variable3 radiusAccServerTable_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
{LEAF_radiusAccServerIndex,  ASN_INTEGER,  RONLY,   var_radiusAccServerTable, 3,  { 3, 1, 1 }},
#endif

{LEAF_radiusAccServerAddress,  ASN_IPADDRESS,  RONLY,   var_radiusAccServerTable, 3,  { 3, 1, 2 }},
{LEAF_radiusAccClientServerPortNumber,  ASN_INTEGER,  RONLY,   var_radiusAccServerTable, 3,  { 3, 1, 3 }},
{LEAF_radiusAccClientRoundTripTime,  ASN_TIMETICKS,  RONLY,   var_radiusAccServerTable, 3,  { 3, 1, 4 }},
{LEAF_radiusAccClientRequests,  ASN_COUNTER,  RONLY,   var_radiusAccServerTable, 3,  { 3, 1, 5 }},
{LEAF_radiusAccClientRetransmissions,  ASN_COUNTER,  RONLY,   var_radiusAccServerTable, 3,  { 3, 1, 6 }},
{LEAF_radiusAccClientResponses,  ASN_COUNTER,  RONLY,   var_radiusAccServerTable, 3,  { 3, 1, 7 }},
{LEAF_radiusAccClientMalformedResponses,  ASN_COUNTER,  RONLY,   var_radiusAccServerTable, 3,  { 3, 1, 8 }},
{LEAF_radiusAccClientBadAuthenticators,  ASN_COUNTER,  RONLY,   var_radiusAccServerTable, 3,  { 3, 1, 9 }},
{LEAF_radiusAccClientPendingRequests,  ASN_GAUGE,  RONLY,   var_radiusAccServerTable, 3,  { 3, 1, 10 }},
{LEAF_radiusAccClientTimeouts,  ASN_COUNTER,  RONLY,   var_radiusAccServerTable, 3,  { 3, 1, 11 }},
{LEAF_radiusAccClientUnknownTypes,  ASN_COUNTER,  RONLY,   var_radiusAccServerTable, 3,  { 3, 1, 12 }},
{LEAF_radiusAccClientPacketsDropped,  ASN_COUNTER,  RONLY,   var_radiusAccServerTable, 3,  { 3, 1, 13 }},
};
/*    (L = length of the oidsuffix) */

/** Initializes the radiusAccServerTable module */
void
init_radiusAccServerTable(void)
{

    DEBUGMSGTL(("radiusAccServerTable", "Initializing\n"));

    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("radiusAccServerTable", radiusAccServerTable_variables, variable3,
               radiusAccServerTable_variables_oid);

    /* place any other initialization junk you need here */
}

#define RADIUSACCSERVERENTRY_INSTANCE_LEN  1

BOOL_T radiusAccServerTable_OidIndexToData(UI32_T exact, UI32_T compc,
            oid * compl ,  UI32_T *radiusAccServerIndex)
{
    /* get or write
     */
    if(exact)
    {
        /* check the index length
         */
        if(compc != RADIUSACCSERVERENTRY_INSTANCE_LEN) /* the constant size index*/
        {
            return FALSE;
        }
    }
    *radiusAccServerIndex = compl[0];
    return TRUE;
}

/*
 * var_radiusAccServerTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *
var_radiusAccServerTable(struct variable *vp,
            oid     *name,
            size_t  *length,
            int     exact,
            size_t  *var_len,
            WriteMethod **write_method)
{
    /* variables we may use later */
    UI32_T compc = 0;
    oid compl[RADIUSACCSERVERENTRY_INSTANCE_LEN] = {0};
    oid best_inst[RADIUSACCSERVERENTRY_INSTANCE_LEN] = {0};
    RADIUS_Server_Host_T  server_host;
    switch(vp->magic)
    {
    default:
        *write_method = 0;
        break;
    }

    /*check compc, retrive compl*/
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl, RADIUSACCSERVERENTRY_INSTANCE_LEN);

    memset(&server_host, 0, sizeof(server_host));

    if (exact)/*get,set*/
    {

        /* get index */
        if(radiusAccServerTable_OidIndexToData(exact, compc, compl, &server_host.server_index) == FALSE)
        {
            return NULL;
        }

        /*get data
         */
        if (RADIUS_POM_Get_Server_Host(server_host.server_index, &server_host) != TRUE )
        {
            return NULL;
        }
    }
    else/*getnext*/
    {

        /*get index*/
        radiusAccServerTable_OidIndexToData(exact,compc,compl, &server_host.server_index);
        /* check the length of inputing index,if <1 we should try get {0.0.0.0.0...}
         */
        if (compc< 1)
        {
            /* get data */
            if (RADIUS_POM_Get_Server_Host(server_host.server_index, &server_host) != TRUE )
            {

                /*get next data*/
                if ( RADIUS_POM_GetNext_Server_Host(&server_host.server_index, &server_host) != TRUE )
                {
                    return NULL;
                }
            }
        }
        else
        {
            /*get next data*/
            if ( RADIUS_POM_GetNext_Server_Host(&server_host.server_index, &server_host) != TRUE )
            {
                return NULL;
            }
        }
    }

    memcpy(name, vp->name, vp->namelen*sizeof(oid));
    /* assign data to the oid index
     */

    best_inst[0] = server_host.server_index;
    memcpy(name+vp->namelen, best_inst, RADIUSACCSERVERENTRY_INSTANCE_LEN * sizeof(oid));
    *length = vp->namelen + RADIUSACCSERVERENTRY_INSTANCE_LEN ;

    /* this is where we do the value assignments for the mib results.
     */
    switch(vp->magic) {

#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    case LEAF_radiusAccServerIndex:
        *var_len = sizeof(long_return);
        long_return = server_host.server_index;
        return (u_char *) &long_return;
#endif
    case LEAF_radiusAccServerAddress:
        *var_len = sizeof(ipaddr_return);
        ipaddr_return = server_host.std_acc_cli_mib.radiusAccServerAddress;
        return (u_char *) &ipaddr_return;
    case LEAF_radiusAccClientServerPortNumber:
        *var_len = sizeof(long_return);
        long_return = server_host.std_acc_cli_mib.radiusAccClientServerPortNumber;
        return (u_char *) &long_return;
    case LEAF_radiusAccClientRoundTripTime:
        *var_len = sizeof(long_return);
        long_return = server_host.std_acc_cli_mib.radiusAccClientRoundTripTime;
        return (u_char *) &long_return;
    case LEAF_radiusAccClientRequests:
        *var_len = sizeof(long_return);
        long_return = server_host.std_acc_cli_mib.radiusAccClientRequests;
        return (u_char *) &long_return;
    case LEAF_radiusAccClientRetransmissions:
        *var_len = sizeof(long_return);
        long_return = server_host.std_acc_cli_mib.radiusAccClientRetransmissions;
        return (u_char *) &long_return;
    case LEAF_radiusAccClientResponses:
        *var_len = sizeof(long_return);
        long_return = server_host.std_acc_cli_mib.radiusAccClientResponses;
        return (u_char *) &long_return;
    case LEAF_radiusAccClientMalformedResponses:
        *var_len = sizeof(long_return);
        long_return = server_host.std_acc_cli_mib.radiusAccClientMalformedResponses;
        return (u_char *) &long_return;
    case LEAF_radiusAccClientBadAuthenticators:
        *var_len = sizeof(long_return);
        long_return = server_host.std_acc_cli_mib.radiusAccClientBadAuthenticators;
        return (u_char *) &long_return;
    case LEAF_radiusAccClientPendingRequests:
        *var_len = sizeof(long_return);
        long_return = server_host.std_acc_cli_mib.radiusAccClientPendingRequests;
        return (u_char *) &long_return;
    case LEAF_radiusAccClientTimeouts:
        *var_len = sizeof(long_return);
        long_return = server_host.std_acc_cli_mib.radiusAccClientTimeouts;
        return (u_char *) &long_return;
    case LEAF_radiusAccClientUnknownTypes:
        *var_len = sizeof(long_return);
        long_return = server_host.std_acc_cli_mib.radiusAccClientUnknownTypes;
        return (u_char *) &long_return;
    case LEAF_radiusAccClientPacketsDropped:
        *var_len = sizeof(long_return);
        long_return = server_host.std_acc_cli_mib.radiusAccClientPacketsDropped;
        return (u_char *) &long_return;
    default:
      ERROR_MSG("");
    }
    return NULL;
}

#endif

