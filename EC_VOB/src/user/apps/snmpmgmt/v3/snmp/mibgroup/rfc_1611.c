/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.scalar.conf,v 1.5 2002/07/18 14:18:52 dts12 Exp $
 */
#include "sys_cpnt.h"
#if (SYS_CPNT_DNS == TRUE)
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "rfc_1611.h"
#include "leaf_1611.h"
#include "dns_pmgr.h"
#include "dns_pom.h"
#include "sysORTable.h"

/** Initializes the dnsServConfig module */
void
init_dnsServConfig(void)
{
    oid             dns_serv_module_oid[] = { SNMP_OID_MIB2, 32, 1 };

    static oid      dnsServConfigRecurs_oid[] =
        { 1, 3, 6, 1, 2, 1, 32, 1, 1, 1, 2, 0 };
    static oid      dnsServConfigUpTime_oid[] =
        { 1, 3, 6, 1, 2, 1, 32, 1, 1, 1, 3, 0 };
    static oid      dnsServConfigImplementIdent_oid[] =
        { 1, 3, 6, 1, 2, 1, 32, 1, 1, 1, 1, 0 };
    static oid      dnsServConfigResetTime_oid[] =
        { 1, 3, 6, 1, 2, 1, 32, 1, 1, 1, 4, 0 };
    static oid      dnsServConfigReset_oid[] =
        { 1, 3, 6, 1, 2, 1, 32, 1, 1, 1, 5, 0 };

    DEBUGMSGTL(("dnsServConfig", "Initializing\n"));

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("dnsServConfigRecurs",
                               do_dnsServConfigRecurs,
                               dnsServConfigRecurs_oid,
                               OID_LENGTH(dnsServConfigRecurs_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("dnsServConfigUpTime",
                                         get_dnsServConfigUpTime,
                                         dnsServConfigUpTime_oid,
                                         OID_LENGTH
                                         (dnsServConfigUpTime_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("dnsServConfigImplementIdent",
                                         get_dnsServConfigImplementIdent,
                                         dnsServConfigImplementIdent_oid,
                                         OID_LENGTH
                                         (dnsServConfigImplementIdent_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("dnsServConfigResetTime",
                                         get_dnsServConfigResetTime,
                                         dnsServConfigResetTime_oid,
                                         OID_LENGTH
                                         (dnsServConfigResetTime_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("dnsServConfigReset", do_dnsServConfigReset,
                               dnsServConfigReset_oid,
                               OID_LENGTH(dnsServConfigReset_oid),
                               HANDLER_CAN_RWRITE));

    REGISTER_SYSOR_ENTRY(dns_serv_module_oid,
                         "The Rfc 1611 DNS Server MIB.");
}

int
do_dnsServConfigRecurs(netsnmp_mib_handler *handler,
                       netsnmp_handler_registration *reginfo,
                       netsnmp_agent_request_info *reqinfo,
                       netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode)
    {
        case MODE_GET:
        {
            int dnsServConfigRecurs;

            if (DNS_POM_GetDnsServConfigRecurs(&dnsServConfigRecurs) != DNS_OK)
            {
            	return SNMP_ERR_GENERR;
            }

            long_return = dnsServConfigRecurs;
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
        }
             break;
        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
            }
            break;

        case MODE_SET_RESERVE2:
            switch (*requests->requestvb->val.integer)
            {
                case VAL_dnsServConfigRecurs_available:
                    break;

                case VAL_dnsServConfigRecurs_restricted:
                    break;

                case VAL_dnsServConfigRecurs_unavailable:
                    break;

                default:
                    netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
          {
               int dnsServConfigRecurs;
               dnsServConfigRecurs = (*requests->requestvb->val.integer);

               if (DNS_PMGR_SetDnsServConfigRecurs(&dnsServConfigRecurs) != DNS_OK)
               {
                   netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
               }
           }
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */

            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */

            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_dnsServConfigUpTime(netsnmp_mib_handler *handler,
                        netsnmp_handler_registration *reginfo,
                        netsnmp_agent_request_info *reqinfo,
                        netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
           {

                UI32_T dnsServConfigUpTime;

	    if (DNS_POM_GetDnsServConfigUpTime(&dnsServConfigUpTime) != DNS_OK)
	       return SNMP_ERR_GENERR;

      	  long_return =  dnsServConfigUpTime;
                     snmp_set_var_typed_value(requests->requestvb, ASN_GAUGE, (u_char *)&long_return, sizeof(long_return));
            }
            break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_dnsServConfigImplementIdent(netsnmp_mib_handler *handler,
                                netsnmp_handler_registration *reginfo,
                                netsnmp_agent_request_info *reqinfo,
                                netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
        {
              UI8_T dnsServConfigImplementIdent[MAXSIZE_dnsServConfigImplementIdent+1];




        if (DNS_POM_GetDnsServConfigImplementIdent((I8_T *)dnsServConfigImplementIdent) != DNS_OK)
             return SNMP_ERR_NOERROR;

    	   strncpy((char *)return_buf, (char *)dnsServConfigImplementIdent, MAXSIZE_dnsServConfigImplementIdent+1);
    	    return_buf[MAXSIZE_dnsServConfigImplementIdent+1] = '\0';
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, (u_char *) return_buf, strlen((char *)return_buf));
        }
            break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_dnsServConfigResetTime(netsnmp_mib_handler *handler,
                           netsnmp_handler_registration *reginfo,
                           netsnmp_agent_request_info *reqinfo,
                           netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
           {

            UI32_T dnsServConfigResetTime;


	    if (DNS_POM_GetDnsServConfigResetTime(&dnsServConfigResetTime) != DNS_OK)
	       return SNMP_ERR_GENERR;

      	  long_return =  dnsServConfigResetTime;
                     snmp_set_var_typed_value(requests->requestvb, ASN_GAUGE, (u_char *)&long_return, sizeof(long_return));
            }
            break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_dnsServConfigReset(netsnmp_mib_handler *handler,
                      netsnmp_handler_registration *reginfo,
                      netsnmp_agent_request_info *reqinfo,
                      netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode)
    {
        case MODE_GET:
        {
            int dnsServConfigReset;

            if (DNS_PMGR_GetDnsServConfigReset(&dnsServConfigReset) != DNS_OK)
            {
            	return SNMP_ERR_GENERR;
            }

            long_return = dnsServConfigReset;
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
        }
             break;
        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
            }
            break;

        case MODE_SET_RESERVE2:
            switch (*requests->requestvb->val.integer)
            {
                case VAL_dnsServConfigReset_other:
                    break;

                case VAL_dnsServConfigReset_reset:
                    break;

                case VAL_dnsServConfigReset_initializing:
                    break;

                case VAL_dnsServConfigReset_running:
                    break;

                default:
                    netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
          {
               int dnsServConfigReset;
               dnsServConfigReset = (*requests->requestvb->val.integer);

               if (DNS_PMGR_SetDnsServConfigReset(&dnsServConfigReset) != DNS_OK)
               {
                   netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
               }
           }
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */

            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */

            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

/** Initializes the dnsServCounter module */
void
init_dnsServCounter(void)
{
    static oid      dnsServCounterAuthAns_oid[] =
        { 1, 3, 6, 1, 2, 1, 32, 1, 1, 2, 2, 0 };
    static oid      dnsServCounterAuthNoNames_oid[] =
        { 1, 3, 6, 1, 2, 1, 32, 1, 1, 2, 3, 0 };
    static oid      dnsServCounterReqRefusals_oid[] =
        { 1, 3, 6, 1, 2, 1, 32, 1, 1, 2, 10, 0 };
    static oid      dnsServCounterNonAuthNoDatas_oid[] =
        { 1, 3, 6, 1, 2, 1, 32, 1, 1, 2, 6, 0 };
    static oid      dnsServCounterErrors_oid[] =
        { 1, 3, 6, 1, 2, 1, 32, 1, 1, 2, 8, 0 };
    static oid      dnsServCounterReqUnparses_oid[] =
        { 1, 3, 6, 1, 2, 1, 32, 1, 1, 2, 11, 0 };
    static oid      dnsServCounterRelNames_oid[] =
        { 1, 3, 6, 1, 2, 1, 32, 1, 1, 2, 9, 0 };
    static oid      dnsServCounterAuthNoDataResps_oid[] =
        { 1, 3, 6, 1, 2, 1, 32, 1, 1, 2, 4, 0 };
    static oid      dnsServCounterOtherErrors_oid[] =
        { 1, 3, 6, 1, 2, 1, 32, 1, 1, 2, 12, 0 };
    static oid      dnsServCounterReferrals_oid[] =
        { 1, 3, 6, 1, 2, 1, 32, 1, 1, 2, 7, 0 };
    static oid      dnsServCounterNonAuthDatas_oid[] =
        { 1, 3, 6, 1, 2, 1, 32, 1, 1, 2, 5, 0 };

    DEBUGMSGTL(("dnsServCounter", "Initializing\n"));

    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("dnsServCounterAuthAns",
                                         get_dnsServCounterAuthAns,
                                         dnsServCounterAuthAns_oid,
                                         OID_LENGTH
                                         (dnsServCounterAuthAns_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("dnsServCounterAuthNoNames",
                                         get_dnsServCounterAuthNoNames,
                                         dnsServCounterAuthNoNames_oid,
                                         OID_LENGTH
                                         (dnsServCounterAuthNoNames_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("dnsServCounterReqRefusals",
                                         get_dnsServCounterReqRefusals,
                                         dnsServCounterReqRefusals_oid,
                                         OID_LENGTH
                                         (dnsServCounterReqRefusals_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("dnsServCounterNonAuthNoDatas",
                                         get_dnsServCounterNonAuthNoDatas,
                                         dnsServCounterNonAuthNoDatas_oid,
                                         OID_LENGTH
                                         (dnsServCounterNonAuthNoDatas_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("dnsServCounterErrors",
                                         get_dnsServCounterErrors,
                                         dnsServCounterErrors_oid,
                                         OID_LENGTH
                                         (dnsServCounterErrors_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("dnsServCounterReqUnparses",
                                         get_dnsServCounterReqUnparses,
                                         dnsServCounterReqUnparses_oid,
                                         OID_LENGTH
                                         (dnsServCounterReqUnparses_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("dnsServCounterRelNames",
                                         get_dnsServCounterRelNames,
                                         dnsServCounterRelNames_oid,
                                         OID_LENGTH
                                         (dnsServCounterRelNames_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("dnsServCounterAuthNoDataResps",
                                         get_dnsServCounterAuthNoDataResps,
                                         dnsServCounterAuthNoDataResps_oid,
                                         OID_LENGTH
                                         (dnsServCounterAuthNoDataResps_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("dnsServCounterOtherErrors",
                                         get_dnsServCounterOtherErrors,
                                         dnsServCounterOtherErrors_oid,
                                         OID_LENGTH
                                         (dnsServCounterOtherErrors_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("dnsServCounterReferrals",
                                         get_dnsServCounterReferrals,
                                         dnsServCounterReferrals_oid,
                                         OID_LENGTH
                                         (dnsServCounterReferrals_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("dnsServCounterNonAuthDatas",
                                         get_dnsServCounterNonAuthDatas,
                                         dnsServCounterNonAuthDatas_oid,
                                         OID_LENGTH
                                         (dnsServCounterNonAuthDatas_oid),
                                         HANDLER_CAN_RONLY));
}

int
get_dnsServCounterAuthAns(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
           {

               int dnsServCounterAuthAns;

	       if (DNS_POM_GetDnsServCounterAuthAns(&dnsServCounterAuthAns) != DNS_OK)
	           return SNMP_ERR_GENERR;

               long_return =  dnsServCounterAuthAns;
               snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *)&long_return, sizeof(long_return));
           }
        break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_dnsServCounterAuthNoNames(netsnmp_mib_handler *handler,
                              netsnmp_handler_registration *reginfo,
                              netsnmp_agent_request_info *reqinfo,
                              netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
           {

               int dnsServCounterAuthNoNames;

	       if (DNS_POM_GetDnsServCounterAuthNoNames(&dnsServCounterAuthNoNames) != DNS_OK)
	           return SNMP_ERR_GENERR;

               long_return =  dnsServCounterAuthNoNames;
               snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *)&long_return, sizeof(long_return));
           }
        break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_dnsServCounterReqRefusals(netsnmp_mib_handler *handler,
                              netsnmp_handler_registration *reginfo,
                              netsnmp_agent_request_info *reqinfo,
                              netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
           {

               int counter_val;

	       if (DNS_POM_GetDnsServCounterReqRefusals(&counter_val) != DNS_OK)
	           return SNMP_ERR_GENERR;

               long_return =  counter_val;
               snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *)&long_return, sizeof(long_return));
           }
        break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_dnsServCounterNonAuthNoDatas(netsnmp_mib_handler *handler,
                                 netsnmp_handler_registration *reginfo,
                                 netsnmp_agent_request_info *reqinfo,
                                 netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
           {

               int counter_val;

	       if (DNS_POM_GetDnsServCounterNonAuthNoDatas(&counter_val) != DNS_OK)
	           return SNMP_ERR_GENERR;

               long_return =  counter_val;
               snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *)&long_return, sizeof(long_return));
           }
        break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_dnsServCounterErrors(netsnmp_mib_handler *handler,
                         netsnmp_handler_registration *reginfo,
                         netsnmp_agent_request_info *reqinfo,
                         netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
           {

               int counter_val;

	       if (DNS_POM_GetDnsServCounterErrors(&counter_val) != DNS_OK)
	           return SNMP_ERR_GENERR;

               long_return =  counter_val;
               snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *)&long_return, sizeof(long_return));
           }
        break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_dnsServCounterReqUnparses(netsnmp_mib_handler *handler,
                              netsnmp_handler_registration *reginfo,
                              netsnmp_agent_request_info *reqinfo,
                              netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
           {

               int counter_val;

	       if (DNS_POM_GetDnsServCounterReqUnparses(&counter_val) != DNS_OK)
	           return SNMP_ERR_GENERR;

               long_return =  counter_val;
               snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *)&long_return, sizeof(long_return));
           }
        break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_dnsServCounterRelNames(netsnmp_mib_handler *handler,
                           netsnmp_handler_registration *reginfo,
                           netsnmp_agent_request_info *reqinfo,
                           netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
           {

               int counter_val;

	       if (DNS_POM_GetDnsServCounterRelNames(&counter_val) != DNS_OK)
	           return SNMP_ERR_GENERR;

               long_return =  counter_val;
               snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *)&long_return, sizeof(long_return));
           }
        break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_dnsServCounterAuthNoDataResps(netsnmp_mib_handler *handler,
                                  netsnmp_handler_registration *reginfo,
                                  netsnmp_agent_request_info *reqinfo,
                                  netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
           {

               int counter_val;

	       if (DNS_POM_GetDnsServCounterAuthNoDataResps(&counter_val) != DNS_OK)
	           return SNMP_ERR_GENERR;

               long_return =  counter_val;
               snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *)&long_return, sizeof(long_return));
           }
        break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_dnsServCounterOtherErrors(netsnmp_mib_handler *handler,
                              netsnmp_handler_registration *reginfo,
                              netsnmp_agent_request_info *reqinfo,
                              netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
           {

               int counter_val;

	       if (DNS_POM_GetDnsServCounterOtherErrors(&counter_val) != DNS_OK)
	           return SNMP_ERR_GENERR;

               long_return =  counter_val;
               snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *)&long_return, sizeof(long_return));
           }
        break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_dnsServCounterReferrals(netsnmp_mib_handler *handler,
                            netsnmp_handler_registration *reginfo,
                            netsnmp_agent_request_info *reqinfo,
                            netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
           {

               int counter_val;

	       if (DNS_POM_GetDnsServCounterReferrals(&counter_val) != DNS_OK)
	           return SNMP_ERR_GENERR;

               long_return =  counter_val;
               snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *)&long_return, sizeof(long_return));
           }
        break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_dnsServCounterNonAuthDatas(netsnmp_mib_handler *handler,
                               netsnmp_handler_registration *reginfo,
                               netsnmp_agent_request_info *reqinfo,
                               netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
           {

               int counter_val;

	       if (DNS_POM_GetDnsServCounterNonAuthDatas(&counter_val) != DNS_OK)
	           return SNMP_ERR_GENERR;

               long_return =  counter_val;
               snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *)&long_return, sizeof(long_return));
           }
        break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

static int
header_dnsServCounterTable(struct variable *vp,
               oid * name,
               size_t * length,
               int exact, size_t * var_len, WriteMethod ** write_method,
               UI32_T *index1, UI32_T *index2, UI32_T *index3, UI32_T *index4);

/*
 * dnsServCounterTable_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid             dnsServCounterTable_variables_oid[] =
    { 1, 3, 6, 1, 2, 1, 32, 1, 1, 2};

/*
 * variable3 dnsServCounterTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */

struct variable3 dnsServCounterTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */
#define DNSSERVCOUNTERREQUESTS		5
    {DNSSERVCOUNTERREQUESTS, ASN_COUNTER, RONLY, var_dnsServCounterTable,
     3, {13, 1, 5}},
#define DNSSERVCOUNTERRESPONSES		6
    {DNSSERVCOUNTERRESPONSES, ASN_COUNTER, RONLY, var_dnsServCounterTable,
     3, {13, 1, 6}},
};
/*
 * (L = length of the oidsuffix)
 */


/** Initializes the dnsServCounterTable module */
void
init_dnsServCounterTable(void)
{

    DEBUGMSGTL(("dnsServCounterTable", "Initializing\n"));

    /*
     * register ourselves with the agent to handle our mib tree
     */
    REGISTER_MIB("dnsServCounterTable", dnsServCounterTable_variables,
                 variable3, dnsServCounterTable_variables_oid);

    /*
     * place any other initialization junk you need here
     */
}

static int
header_dnsServCounterTable(struct variable *vp,
               oid * name,
               size_t * length,
               int exact, size_t * var_len, WriteMethod ** write_method,
               UI32_T *index1, UI32_T *index2, UI32_T *index3, UI32_T *index4)
{
#define OID_NAME_LENGTH	13
    oid             newname[MAX_OID_LEN];
    int             result;
   DNS_ServCounterEntry_T  entry;
   int return_val;
   oid  next_inst[4];


     memcpy((char *) newname, (char *) vp->name,
           (int) vp->namelen * sizeof(oid));
    /*
     * find "next" interface
     */
    memset(  &entry, 0 , sizeof(entry));

    /*
     * find "next" interface
     */

     while (  (return_val= DNS_PMGR_GetNextDnsServCounterEntry( &entry)) == DNS_OK)
     {
       next_inst[0] = entry.dnsServCounterOpCode;
       next_inst[1] = entry.dnsServCounterQClass;
       next_inst[2] = entry.dnsServCounterQType;
       next_inst[3] = entry.dnsServCounterTransport;

        memcpy( (char*)&newname[OID_NAME_LENGTH], (char*) next_inst,  4*sizeof(oid));
        result =
            snmp_oid_compare(name, *length, newname,
                             (int) vp->namelen +4);
        if ((exact && (result == 0)) || (!exact && (result < 0)))
            break;
    }
    if (return_val != DNS_OK) {
        DEBUGMSGTL(("DNS Server MIB", "... index out of range\n"));
        return MATCH_FAILED;
    }
    memcpy((char *) name, (char *) newname,
           ((int) vp->namelen + 4) * sizeof(oid));
    *length = vp->namelen + 4;
    *var_len = sizeof(long);    /* default to 'long' results */
    *index1 = next_inst[0];
    *index2 = next_inst[1];
    *index3 = next_inst[2];
    *index4 = next_inst[3];
    return TRUE;

}

/*
 * var_dnsServCounterTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_dnsServCounterTable(struct variable *vp,
                        oid * name,
                        size_t * length,
                        int exact,
                        size_t * var_len, WriteMethod ** write_method)
{
    UI32_T index1, index2, index3, index4,retval;

    DNS_ServCounterEntry_T  entry;

    memset( &entry, 0, sizeof(entry));

    retval  = header_dnsServCounterTable(vp, name, length, exact, var_len, write_method,  &index1,& index2, &index3, &index4);

    if (retval == MATCH_FAILED)
        return NULL;


    entry.dnsServCounterOpCode= index1;
    entry.dnsServCounterQClass = index2;
    entry.dnsServCounterQType= index3;
    entry.dnsServCounterTransport= index4;

    if (DNS_POM_GetDnsServCounterEntry(&entry)!= TRUE)
        return NULL;


    /*
     * * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {

    case DNSSERVCOUNTERREQUESTS:
        long_return = entry.dnsServCounterRequests;
        return (u_char*) &long_return;
    case DNSSERVCOUNTERRESPONSES:
        long_return = entry.dnsServCounterResponses;
        return (u_char*) &long_return;
    default:
        ERROR_MSG("");
    }
    return NULL;
}

/** Initializes the dnsServOptCounter module */
void
init_dnsServOptCounter(void)
{
    static oid      dnsServOptCounterFriendsErrors_oid[] =
        { 1, 3, 6, 1, 2, 1, 32, 1, 1, 3, 18, 0 };
    static oid      dnsServOptCounterSelfErrors_oid[] =
        { 1, 3, 6, 1, 2, 1, 32, 1, 1, 3, 7, 0 };
    static oid      dnsServOptCounterSelfReqRefusals_oid[] =
        { 1, 3, 6, 1, 2, 1, 32, 1, 1, 3, 9, 0 };
    static oid      dnsServOptCounterFriendsReqRefusals_oid[] =
        { 1, 3, 6, 1, 2, 1, 32, 1, 1, 3, 20, 0 };
    static oid      dnsServOptCounterSelfNonAuthDatas_oid[] =
        { 1, 3, 6, 1, 2, 1, 32, 1, 1, 3, 4, 0 };
    static oid      dnsServOptCounterSelfNonAuthNoDatas_oid[] =
        { 1, 3, 6, 1, 2, 1, 32, 1, 1, 3, 5, 0 };
    static oid      dnsServOptCounterSelfAuthNoDataResps_oid[] =
        { 1, 3, 6, 1, 2, 1, 32, 1, 1, 3, 3, 0 };
    static oid      dnsServOptCounterFriendsNonAuthDatas_oid[] =
        { 1, 3, 6, 1, 2, 1, 32, 1, 1, 3, 15, 0 };
    static oid      dnsServOptCounterFriendsRelNames_oid[] =
        { 1, 3, 6, 1, 2, 1, 32, 1, 1, 3, 19, 0 };
    static oid      dnsServOptCounterFriendsReferrals_oid[] =
        { 1, 3, 6, 1, 2, 1, 32, 1, 1, 3, 17, 0 };
    static oid      dnsServOptCounterFriendsNonAuthNoDatas_oid[] =
        { 1, 3, 6, 1, 2, 1, 32, 1, 1, 3, 16, 0 };
    static oid      dnsServOptCounterFriendsAuthNoDataResps_oid[] =
        { 1, 3, 6, 1, 2, 1, 32, 1, 1, 3, 14, 0 };
    static oid      dnsServOptCounterSelfRelNames_oid[] =
        { 1, 3, 6, 1, 2, 1, 32, 1, 1, 3, 8, 0 };
    static oid      dnsServOptCounterSelfReferrals_oid[] =
        { 1, 3, 6, 1, 2, 1, 32, 1, 1, 3, 6, 0 };
    static oid      dnsServOptCounterSelfAuthNoNames_oid[] =
        { 1, 3, 6, 1, 2, 1, 32, 1, 1, 3, 2, 0 };
    static oid      dnsServOptCounterFriendsAuthNoNames_oid[] =
        { 1, 3, 6, 1, 2, 1, 32, 1, 1, 3, 13, 0 };
    static oid      dnsServOptCounterFriendsReqUnparses_oid[] =
        { 1, 3, 6, 1, 2, 1, 32, 1, 1, 3, 21, 0 };
    static oid      dnsServOptCounterSelfReqUnparses_oid[] =
        { 1, 3, 6, 1, 2, 1, 32, 1, 1, 3, 10, 0 };
    static oid      dnsServOptCounterFriendsOtherErrors_oid[] =
        { 1, 3, 6, 1, 2, 1, 32, 1, 1, 3, 22, 0 };
    static oid      dnsServOptCounterSelfOtherErrors_oid[] =
        { 1, 3, 6, 1, 2, 1, 32, 1, 1, 3, 11, 0 };
    static oid      dnsServOptCounterFriendsAuthAns_oid[] =
        { 1, 3, 6, 1, 2, 1, 32, 1, 1, 3, 12, 0 };
    static oid      dnsServOptCounterSelfAuthAns_oid[] =
        { 1, 3, 6, 1, 2, 1, 32, 1, 1, 3, 1, 0 };

    DEBUGMSGTL(("dnsServOptCounter", "Initializing\n"));

    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("dnsServOptCounterFriendsErrors",
                                         get_dnsServOptCounterFriendsErrors,
                                         dnsServOptCounterFriendsErrors_oid,
                                         OID_LENGTH
                                         (dnsServOptCounterFriendsErrors_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("dnsServOptCounterSelfErrors",
                                         get_dnsServOptCounterSelfErrors,
                                         dnsServOptCounterSelfErrors_oid,
                                         OID_LENGTH
                                         (dnsServOptCounterSelfErrors_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("dnsServOptCounterSelfReqRefusals",
                                         get_dnsServOptCounterSelfReqRefusals,
                                         dnsServOptCounterSelfReqRefusals_oid,
                                         OID_LENGTH
                                         (dnsServOptCounterSelfReqRefusals_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("dnsServOptCounterFriendsReqRefusals",
                                         get_dnsServOptCounterFriendsReqRefusals,
                                         dnsServOptCounterFriendsReqRefusals_oid,
                                         OID_LENGTH
                                         (dnsServOptCounterFriendsReqRefusals_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("dnsServOptCounterSelfNonAuthDatas",
                                         get_dnsServOptCounterSelfNonAuthDatas,
                                         dnsServOptCounterSelfNonAuthDatas_oid,
                                         OID_LENGTH
                                         (dnsServOptCounterSelfNonAuthDatas_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("dnsServOptCounterSelfNonAuthNoDatas",
                                         get_dnsServOptCounterSelfNonAuthNoDatas,
                                         dnsServOptCounterSelfNonAuthNoDatas_oid,
                                         OID_LENGTH
                                         (dnsServOptCounterSelfNonAuthNoDatas_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("dnsServOptCounterSelfAuthNoDataResps",
                                         get_dnsServOptCounterSelfAuthNoDataResps,
                                         dnsServOptCounterSelfAuthNoDataResps_oid,
                                         OID_LENGTH
                                         (dnsServOptCounterSelfAuthNoDataResps_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("dnsServOptCounterFriendsNonAuthDatas",
                                         get_dnsServOptCounterFriendsNonAuthDatas,
                                         dnsServOptCounterFriendsNonAuthDatas_oid,
                                         OID_LENGTH
                                         (dnsServOptCounterFriendsNonAuthDatas_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("dnsServOptCounterFriendsRelNames",
                                         get_dnsServOptCounterFriendsRelNames,
                                         dnsServOptCounterFriendsRelNames_oid,
                                         OID_LENGTH
                                         (dnsServOptCounterFriendsRelNames_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("dnsServOptCounterFriendsReferrals",
                                         get_dnsServOptCounterFriendsReferrals,
                                         dnsServOptCounterFriendsReferrals_oid,
                                         OID_LENGTH
                                         (dnsServOptCounterFriendsReferrals_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("dnsServOptCounterFriendsNonAuthNoDatas",
                                         get_dnsServOptCounterFriendsNonAuthNoDatas,
                                         dnsServOptCounterFriendsNonAuthNoDatas_oid,
                                         OID_LENGTH
                                         (dnsServOptCounterFriendsNonAuthNoDatas_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("dnsServOptCounterFriendsAuthNoDataResps",
                                         get_dnsServOptCounterFriendsAuthNoDataResps,
                                         dnsServOptCounterFriendsAuthNoDataResps_oid,
                                         OID_LENGTH
                                         (dnsServOptCounterFriendsAuthNoDataResps_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("dnsServOptCounterSelfRelNames",
                                         get_dnsServOptCounterSelfRelNames,
                                         dnsServOptCounterSelfRelNames_oid,
                                         OID_LENGTH
                                         (dnsServOptCounterSelfRelNames_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("dnsServOptCounterSelfReferrals",
                                         get_dnsServOptCounterSelfReferrals,
                                         dnsServOptCounterSelfReferrals_oid,
                                         OID_LENGTH
                                         (dnsServOptCounterSelfReferrals_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("dnsServOptCounterSelfAuthNoNames",
                                         get_dnsServOptCounterSelfAuthNoNames,
                                         dnsServOptCounterSelfAuthNoNames_oid,
                                         OID_LENGTH
                                         (dnsServOptCounterSelfAuthNoNames_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("dnsServOptCounterFriendsAuthNoNames",
                                         get_dnsServOptCounterFriendsAuthNoNames,
                                         dnsServOptCounterFriendsAuthNoNames_oid,
                                         OID_LENGTH
                                         (dnsServOptCounterFriendsAuthNoNames_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("dnsServOptCounterFriendsReqUnparses",
                                         get_dnsServOptCounterFriendsReqUnparses,
                                         dnsServOptCounterFriendsReqUnparses_oid,
                                         OID_LENGTH
                                         (dnsServOptCounterFriendsReqUnparses_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("dnsServOptCounterSelfReqUnparses",
                                         get_dnsServOptCounterSelfReqUnparses,
                                         dnsServOptCounterSelfReqUnparses_oid,
                                         OID_LENGTH
                                         (dnsServOptCounterSelfReqUnparses_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("dnsServOptCounterFriendsOtherErrors",
                                         get_dnsServOptCounterFriendsOtherErrors,
                                         dnsServOptCounterFriendsOtherErrors_oid,
                                         OID_LENGTH
                                         (dnsServOptCounterFriendsOtherErrors_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("dnsServOptCounterSelfOtherErrors",
                                         get_dnsServOptCounterSelfOtherErrors,
                                         dnsServOptCounterSelfOtherErrors_oid,
                                         OID_LENGTH
                                         (dnsServOptCounterSelfOtherErrors_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("dnsServOptCounterFriendsAuthAns",
                                         get_dnsServOptCounterFriendsAuthAns,
                                         dnsServOptCounterFriendsAuthAns_oid,
                                         OID_LENGTH
                                         (dnsServOptCounterFriendsAuthAns_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("dnsServOptCounterSelfAuthAns",
                                         get_dnsServOptCounterSelfAuthAns,
                                         dnsServOptCounterSelfAuthAns_oid,
                                         OID_LENGTH
                                         (dnsServOptCounterSelfAuthAns_oid),
                                         HANDLER_CAN_RONLY));
}

int
get_dnsServOptCounterFriendsErrors(netsnmp_mib_handler *handler,
                                   netsnmp_handler_registration *reginfo,
                                   netsnmp_agent_request_info *reqinfo,
                                   netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
           {

               UI32_T counter_val;

	       if (DNS_POM_GetDnsServOptCounterFriendsErrors(&counter_val) != DNS_OK)
	           return SNMP_ERR_GENERR;

               long_return =  counter_val;
               snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *)&long_return, sizeof(long_return));
           }
        break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_dnsServOptCounterSelfErrors(netsnmp_mib_handler *handler,
                                netsnmp_handler_registration *reginfo,
                                netsnmp_agent_request_info *reqinfo,
                                netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
           {

               int counter_val;

	       if (DNS_POM_GetDnsServOptCounterSelfErrors(&counter_val) != DNS_OK)
	           return SNMP_ERR_GENERR;

               long_return =  counter_val;
               snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *)&long_return, sizeof(long_return));
           }
        break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_dnsServOptCounterSelfReqRefusals(netsnmp_mib_handler *handler,
                                     netsnmp_handler_registration *reginfo,
                                     netsnmp_agent_request_info *reqinfo,
                                     netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
           {

               int counter_val;

	       if (DNS_POM_GetDnsServOptCounterSelfReqRefusals(&counter_val) != DNS_OK)
	           return SNMP_ERR_GENERR;

               long_return =  counter_val;
               snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *)&long_return, sizeof(long_return));
           }
        break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_dnsServOptCounterFriendsReqRefusals(netsnmp_mib_handler *handler,
                                        netsnmp_handler_registration
                                        *reginfo,
                                        netsnmp_agent_request_info
                                        *reqinfo,
                                        netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
           {

               UI32_T counter_val;

	       if (DNS_POM_GetDnsServOptCounterFriendsReqRefusals(&counter_val) != DNS_OK)
	           return SNMP_ERR_GENERR;

               long_return =  counter_val;
               snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *)&long_return, sizeof(long_return));
           }
        break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_dnsServOptCounterSelfNonAuthDatas(netsnmp_mib_handler *handler,
                                      netsnmp_handler_registration
                                      *reginfo,
                                      netsnmp_agent_request_info *reqinfo,
                                      netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
           {

               int counter_val;

	       if (DNS_POM_GetDnsServOptCounterSelfNonAuthDatas(&counter_val) != DNS_OK)
	           return SNMP_ERR_GENERR;

               long_return =  counter_val;
               snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *)&long_return, sizeof(long_return));
           }
        break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_dnsServOptCounterSelfNonAuthNoDatas(netsnmp_mib_handler *handler,
                                        netsnmp_handler_registration
                                        *reginfo,
                                        netsnmp_agent_request_info
                                        *reqinfo,
                                        netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
           {

               int counter_val;

	       if (DNS_POM_GetDnsServOptCounterSelfNonAuthNoDatas(&counter_val) != DNS_OK)
	           return SNMP_ERR_GENERR;

               long_return =  counter_val;
               snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *)&long_return, sizeof(long_return));
           }
        break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_dnsServOptCounterSelfAuthNoDataResps(netsnmp_mib_handler *handler,
                                         netsnmp_handler_registration
                                         *reginfo,
                                         netsnmp_agent_request_info
                                         *reqinfo,
                                         netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
           {

               int counter_val;

	       if (DNS_POM_GetDnsServOptCounterSelfAuthNoDataResps(&counter_val) != DNS_OK)
	           return SNMP_ERR_GENERR;

               long_return =  counter_val;
               snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *)&long_return, sizeof(long_return));
           }
        break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_dnsServOptCounterFriendsNonAuthDatas(netsnmp_mib_handler *handler,
                                         netsnmp_handler_registration
                                         *reginfo,
                                         netsnmp_agent_request_info
                                         *reqinfo,
                                         netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
           {

               UI32_T counter_val;

	       if (DNS_POM_GetDnsServOptCounterFriendsNonAuthDatas(&counter_val) != DNS_OK)
	           return SNMP_ERR_GENERR;

               long_return =  counter_val;
               snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *)&long_return, sizeof(long_return));
           }
        break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_dnsServOptCounterFriendsRelNames(netsnmp_mib_handler *handler,
                                     netsnmp_handler_registration *reginfo,
                                     netsnmp_agent_request_info *reqinfo,
                                     netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
           {

               UI32_T counter_val;

	       if (DNS_POM_GetDnsServOptCounterFriendsRelNames(&counter_val) != DNS_OK)
	           return SNMP_ERR_GENERR;

               long_return =  counter_val;
               snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *)&long_return, sizeof(long_return));
           }
        break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_dnsServOptCounterFriendsReferrals(netsnmp_mib_handler *handler,
                                      netsnmp_handler_registration
                                      *reginfo,
                                      netsnmp_agent_request_info *reqinfo,
                                      netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
           {

               UI32_T counter_val;

	       if (DNS_POM_GetDnsServOptCounterFriendsReferrals(&counter_val) != DNS_OK)
	           return SNMP_ERR_GENERR;

               long_return =  counter_val;
               snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *)&long_return, sizeof(long_return));
           }
        break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_dnsServOptCounterFriendsNonAuthNoDatas(netsnmp_mib_handler *handler,
                                           netsnmp_handler_registration
                                           *reginfo,
                                           netsnmp_agent_request_info
                                           *reqinfo,
                                           netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
           {

               UI32_T counter_val;

	       if (DNS_POM_GetDnsServOptCounterFriendsNonAuthNoDatas(&counter_val) != DNS_OK)
	           return SNMP_ERR_GENERR;

               long_return =  counter_val;
               snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *)&long_return, sizeof(long_return));
           }
        break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_dnsServOptCounterFriendsAuthNoDataResps(netsnmp_mib_handler *handler,
                                            netsnmp_handler_registration
                                            *reginfo,
                                            netsnmp_agent_request_info
                                            *reqinfo,
                                            netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
           {

               UI32_T counter_val;

	       if (DNS_POM_GetDnsServOptCounterFriendsAuthNoDataResps(&counter_val) != DNS_OK)
	           return SNMP_ERR_GENERR;

               long_return =  counter_val;
               snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *)&long_return, sizeof(long_return));
           }
        break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_dnsServOptCounterSelfRelNames(netsnmp_mib_handler *handler,
                                  netsnmp_handler_registration *reginfo,
                                  netsnmp_agent_request_info *reqinfo,
                                  netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
           {

               int counter_val;

	       if (DNS_POM_GetDnsServOptCounterSelfRelNames(&counter_val) != DNS_OK)
	           return SNMP_ERR_GENERR;

               long_return =  counter_val;
               snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *)&long_return, sizeof(long_return));
           }
        break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_dnsServOptCounterSelfReferrals(netsnmp_mib_handler *handler,
                                   netsnmp_handler_registration *reginfo,
                                   netsnmp_agent_request_info *reqinfo,
                                   netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
           {

               int counter_val;

	       if (DNS_POM_GetDnsServOptCounterSelfReferrals(&counter_val) != DNS_OK)
	           return SNMP_ERR_GENERR;

               long_return =  counter_val;
               snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *)&long_return, sizeof(long_return));
           }
        break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_dnsServOptCounterSelfAuthNoNames(netsnmp_mib_handler *handler,
                                     netsnmp_handler_registration *reginfo,
                                     netsnmp_agent_request_info *reqinfo,
                                     netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
           {

               int counter_val;

	       if (DNS_POM_GetDnsServOptCounterSelfAuthNoNames(&counter_val) != DNS_OK)
	           return SNMP_ERR_GENERR;

               long_return =  counter_val;
               snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *)&long_return, sizeof(long_return));
           }
        break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_dnsServOptCounterFriendsAuthNoNames(netsnmp_mib_handler *handler,
                                        netsnmp_handler_registration
                                        *reginfo,
                                        netsnmp_agent_request_info
                                        *reqinfo,
                                        netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
           {

               int counter_val;

	       if (DNS_POM_GetDnsServOptCounterFriendsAuthNoNames(&counter_val) != DNS_OK)
	           return SNMP_ERR_GENERR;

               long_return =  counter_val;
               snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *)&long_return, sizeof(long_return));
           }
        break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_dnsServOptCounterFriendsReqUnparses(netsnmp_mib_handler *handler,
                                        netsnmp_handler_registration
                                        *reginfo,
                                        netsnmp_agent_request_info
                                        *reqinfo,
                                        netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
           {

               UI32_T counter_val;

	       if (DNS_POM_GetDnsServOptCounterFriendsReqUnparses(&counter_val) != DNS_OK)
	           return SNMP_ERR_GENERR;

               long_return =  counter_val;
               snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *)&long_return, sizeof(long_return));
           }
        break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_dnsServOptCounterSelfReqUnparses(netsnmp_mib_handler *handler,
                                     netsnmp_handler_registration *reginfo,
                                     netsnmp_agent_request_info *reqinfo,
                                     netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
           {

               int counter_val;

	       if (DNS_POM_GetDnsServOptCounterSelfReqUnparses(&counter_val) != DNS_OK)
	           return SNMP_ERR_GENERR;

               long_return =  counter_val;
               snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *)&long_return, sizeof(long_return));
           }
        break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
get_dnsServOptCounterFriendsOtherErrors(netsnmp_mib_handler *handler,
                                        netsnmp_handler_registration
                                        *reginfo,
                                        netsnmp_agent_request_info
                                        *reqinfo,
                                        netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
           {

               UI32_T counter_val;

	       if (DNS_POM_GetDnsServOptCounterFriendsOtherErrors(&counter_val) != DNS_OK)
	           return SNMP_ERR_GENERR;

               long_return =  counter_val;
               snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *)&long_return, sizeof(long_return));
           }
        break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_dnsServOptCounterSelfOtherErrors(netsnmp_mib_handler *handler,
                                     netsnmp_handler_registration *reginfo,
                                     netsnmp_agent_request_info *reqinfo,
                                     netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
           {

               int counter_val;

	       if (DNS_POM_GetDnsServOptCounterSelfOtherErrors(&counter_val) != DNS_OK)
	           return SNMP_ERR_GENERR;

               long_return =  counter_val;
               snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *)&long_return, sizeof(long_return));
           }
        break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_dnsServOptCounterFriendsAuthAns(netsnmp_mib_handler *handler,
                                    netsnmp_handler_registration *reginfo,
                                    netsnmp_agent_request_info *reqinfo,
                                    netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
           {

               int counter_val;

	       if (DNS_POM_GetDnsServOptCounterFriendsAuthAns(&counter_val) != DNS_OK)
	           return SNMP_ERR_GENERR;

               long_return =  counter_val;
               snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *)&long_return, sizeof(long_return));
           }
        break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_dnsServOptCounterSelfAuthAns(netsnmp_mib_handler *handler,
                                 netsnmp_handler_registration *reginfo,
                                 netsnmp_agent_request_info *reqinfo,
                                 netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
           {

               int counter_val;

	       if (DNS_POM_GetDnsServOptCounterSelfAuthAns(&counter_val) != DNS_OK)
	           return SNMP_ERR_GENERR;

               long_return =  counter_val;
               snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *)&long_return, sizeof(long_return));
           }
        break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

#endif
