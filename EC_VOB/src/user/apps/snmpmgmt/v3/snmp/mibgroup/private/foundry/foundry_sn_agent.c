/* MODULE NAME:  foundry_sn_agent.c
 *
 * PURPOSE: For SNMP to access Brocade's FOUNDRY-SN-AGENT-MIB:
 *
 * MODULE-IDENTITY node:
 * foundry(1991).snAgent(4) - nothing inside
 *
 * Variables:
 * foundry(1991).products(1).switch(1).snChassis(1).*
 * foundry(1991).products(1).switch(1).snAgentSys(2).*
 *
 * NOTES:
 *
 * HISTORY (mm/dd/yyyy)
 *    05/30/2011 - Qiyao Zhong, Created
 *
 * Copyright(C)      Accton Corporation, 2011
 */

/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.scalar.conf,v 1.8 2004/10/14 12:57:34 dts12 Exp $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

/* INCLUDE FILE DECLARATIONS
 */
/* system
 */
#include "sys_type.h"
#include "sys_adpt.h"
#include "sys_cpnt.h"
#include "leaf_sys.h"
#include "leaf_4001.h"
#include "leaf_es3626a.h"
#include "leaf_foundry_sn_agent.h"

/* common library
 */
#include "l_bitmap.h"
#include "l_cvrt.h"
#include "l_stdlib.h"
#include "l_inet.h"

/* driver
 */
#include "fs.h"
#include "sys_time.h"

/* core (management)
 */
#include "http_pmgr.h"
#include "stkctrl_pmgr.h"
#include "stktplg_pom.h"
#include "stktplg_mgr.h"
#include "stktplg_pmgr.h"
#include "sys_mgr.h"
#include "sys_pmgr.h"
#include "telnet_pmgr.h"
#include "xfer_mgr.h"
#include "xfer_pmgr.h"

/* core (L2)
 */
#include "vlan_lib.h"
#include "vlan_pom.h"

/* core (L3)
 */
#include "ip_lib.h"
#include "netcfg_type.h"
#include "netcfg_pom_ip.h"
#include "netcfg_pmgr_ip.h"
#include "netcfg_pmgr_route.h"

#if (SYS_CPNT_ROUTING == TRUE)
#include "nsm_type.h"
#include "nsm_pmgr.h"
#endif

/* SNMP itself
 */
#include "snmp_mgr.h"
#include "sysORTable.h"
#include "foundry_lib.h"
#include "foundry_sn_agent.h"

/* NAMING CONSTANT DECLARATIONS
 */

/* MACRO FUNCTION DECLARATIONS
 */

/* DATA TYPE DECLARATIONS
 */

/* LOCAL SUBPROGRAM DECLARATIONS
 */

/* STATIC VARIABLE DEFINITIONS
 */

/*!!PENDING: These temporary variables need to be cleared upon transition mode
 */

/* for snAgentGbl.snAgGblIfIpAddr(13)
 */
static UI32_T foundry_sn_agent_ip_addr = 0;  /* host order */

/* for snAgentGbl.snAgTftpServerAddrType(65)
 */
static UI32_T foundry_sn_agent_remote_server_address_type = 0;

/* ------------------------------------------------------------------------
 * FUNCTION NAME - do_snAgent_ConvertAcctonToFoundryFileCopyStatus_IsNormal
 * ------------------------------------------------------------------------
 * PURPOSE  :   To check whether an Accton fileCopyStatus maps to
 *              Brocade's "normal".
 *
 * INPUT    :   accton_status   -- Accton's fileCopyStatus
 *
 * OUTPUT   :   None.
 *
 * RETURN   :   TRUE    - maps to "normal"
 *              FALSE   - does not map to "normal"
 *
 * NOTES    :   This function is called from do_snAgWriteNVRAM,
 *              do_snAgConfigFromNVRAM, do_snAgImgLoad,
 *              and do_snAgImgLoad.
 * ------------------------------------------------------------------------
 */
static BOOL_T do_snAgent_ConvertAcctonToFoundryFileCopyStatus_IsNormal(UI32_T accton_status)
{
    BOOL_T ret = FALSE;

    /* map status code
     *
     * SPECIFICATION:
     * See MIB object description of Accton's "fileCopyStatus".
     *
     * MAPPING FILE:
     * fileCopyStatus_20111102_NoTracking.xls
     */
    if ( (accton_status == VAL_fileCopyStatus_fileCopyUnknown)
        || (accton_status == VAL_fileCopyStatus_fileCopySuccess)
        || (accton_status == VAL_fileCopyStatus_fileCopySameVersion) )
    {
        ret = TRUE;
    }

    /* return; single exit point
     */
    return ret;
}

/* ------------------------------------------------------------------------
 * FUNCTION NAME - do_snAgent_ConvertAcctonToFoundryFileCopyStatus_IsError
 * ------------------------------------------------------------------------
 * PURPOSE  :   To check whether an Accton fileCopyStatus maps to
 *              Brocade's "error".
 *
 * INPUT    :   accton_status   -- Accton's fileCopyStatus
 *
 * OUTPUT   :   None.
 *
 * RETURN   :   TRUE    - maps to "error"
 *              FALSE   - does not map to "error"
 *
 * NOTES    :   This function is called from do_snAgWriteNVRAM,
 *              do_snAgConfigFromNVRAM,
 *              do_snAgImgLoad_ConvertAcctonToFoundryError,
 *              and do_snAgCfgLoad_ConvertAcctonToFoundryError.
 * ------------------------------------------------------------------------
 */
static BOOL_T do_snAgent_ConvertAcctonToFoundryFileCopyStatus_IsError(UI32_T accton_status)
{
    BOOL_T ret = FALSE;

    /* map status code
     *
     * SPECIFICATION:
     * See MIB object description of Accton's "fileCopyStatus".
     *
     * MAPPING FILE:
     * fileCopyStatus_20111102_NoTracking.xls
     */
    if (
        ((accton_status >= VAL_fileCopyStatus_fileCopyTftpIllegalOperation /*5*/)
            && accton_status <= VAL_fileCopyStatus_fileCopyBusy /*17*/)
        || ((accton_status >= VAL_fileCopyStatus_fileCopyReadFileError /*19*/)
            && (accton_status <= VAL_fileCopyStatus_fileCopyError /*29*/))
        || ((accton_status >= VAL_fileCopyStatus_fileCopyFileNotFound /*41*/)
            && (accton_status <= VAL_fileCopyStatus_fileCopyFileNumExceed /*55*/))
        || ((accton_status >= VAL_fileCopyStatus_fileCopyFileLenZero /*57*/)
            && (accton_status <= VAL_fileCopyStatus_fileCopyCfDiskNotReady /*59*/))
        )
    {
        ret = TRUE;
    }

    /* return; single exit point
     */
    return ret;
}

/* ------------------------------------------------------------------------
 * SCALAR NAME - 1.1.1.1 snChasGen.snChasSerNum(2)
 * SCALAR NAME - 1.1.1.1 snChasGen.snChasFactorySerialNumber(29)
 * ------------------------------------------------------------------------
 */
void init_snChasSerNum(void)
{
    /* Accton has only a "serial number".
     * Hard-code this to register both nodes to the same routine, for now.
     */
    static oid snChasSerNum_oid[] = { 1,3,6,1,4,1,1991,1,1,1,1,2, 0 };
    static oid snChasFactorySerialNumber_oid[] = { 1,3,6,1,4,1,1991,1,1,1,1,29, 0 };

    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("snChasSerNum",
                                         get_snChasSerNum,  /* also used below */
                                         snChasSerNum_oid,
                                         OID_LENGTH(snChasSerNum_oid),
                                         HANDLER_CAN_RONLY));

    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("snChasFactorySerialNumber",
                                         get_snChasSerNum,  /* uses the above above */
                                         snChasFactorySerialNumber_oid,
                                         OID_LENGTH(snChasFactorySerialNumber_oid),
                                         HANDLER_CAN_RONLY));
}

int get_snChasSerNum(netsnmp_mib_handler *handler,
    netsnmp_handler_registration *reginfo,
    netsnmp_agent_request_info *reqinfo,
    netsnmp_request_info *requests)
{
    /* dispatch get vs. set
     */
    switch (reqinfo->mode)
    {
        /* GET REQUEST
         */
        case MODE_GET:
        {
            UI32_T var_len = 0;
            UI32_T my_unit = 0;
            STKTPLG_MGR_Switch_Info_T entry;

            /* this is a per-unit attribute;
             * for stacking, assume master
             */
            STKTPLG_POM_GetMyUnitID(&my_unit);
            entry.sw_unit_index = my_unit;

            /* get from core layer
             */
            if (! STKTPLG_PMGR_GetSwitchInfo(&entry))
            {
                return SNMP_ERR_GENERR;
            }
            else
            {
                memcpy(return_buf, entry.sw_serial_number, SYS_ADPT_SERIAL_NO_STR_LEN + 1);
                var_len = strlen((char *) return_buf);
                snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                    (u_char *) return_buf, var_len);
            }

            break;
        }

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

/* ------------------------------------------------------------------------
 * SCALAR NAME - 1.1.1.1 snChasGen.snChasMainBrdDescription(5)
 * SCALAR NAME - 1.1.1.1 snChasGen.snChasFactoryPartNumber(28)
 * ------------------------------------------------------------------------
 */
void init_snChasMainBrdDescription(void)
{
    /* Accton has only a "serial number".
     * Hard-code this to register both nodes to the same routine, for now.
     */
    static oid snChasMainBrdDescription_oid[] = { 1,3,6,1,4,1,1991,1,1,1,1,5, 0 };
    static oid snChasFactoryPartNumber_oid[] = { 1,3,6,1,4,1,1991,1,1,1,1,28, 0 };

    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("snChasMainBrdDescription",
                                         get_snChasMainBrdDescription,  /* also used below */
                                         snChasMainBrdDescription_oid,
                                         OID_LENGTH(snChasMainBrdDescription_oid),
                                         HANDLER_CAN_RONLY));

    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("snChasFactoryPartNumber",
                                         get_snChasMainBrdDescription,  /* uses the above */
                                         snChasFactoryPartNumber_oid,
                                         OID_LENGTH(snChasFactoryPartNumber_oid),
                                         HANDLER_CAN_RONLY));
}

int get_snChasMainBrdDescription(netsnmp_mib_handler *handler,
    netsnmp_handler_registration *reginfo,
    netsnmp_agent_request_info *reqinfo,
    netsnmp_request_info *requests)
{
    /* dispatch get vs. set
     */
    switch (reqinfo->mode)
    {
        /* GET REQUEST
         */
        case MODE_GET:
        {
            UI32_T var_len = 0;
            UI32_T my_unit = 0;
            STKTPLG_MGR_Switch_Info_T entry;

            /* this is a per-unit attribute;
             * for stacking, assume master
             */
            STKTPLG_POM_GetMyUnitID(&my_unit);
            entry.sw_unit_index = my_unit;

            /* get from core layer
             */
            if (! STKTPLG_PMGR_GetSwitchInfo(&entry))
            {
                return SNMP_ERR_GENERR;
            }
            else
            {
                memcpy(return_buf, entry.sw_model_number, MAXSIZE_swModelNumber + 1);
                var_len = strlen((char *) return_buf);
                snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                    (u_char *) return_buf, var_len);
            }

            break;
        }

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

/* ------------------------------------------------------------------------
 * SCALAR NAME - 1.1.1.1 snChasGen.snChasMainPortTotal(6)
 * ------------------------------------------------------------------------
 */
void init_snChasMainPortTotal(void)
{
    static oid snChasMainPortTotal_oid[] = { 1,3,6,1,4,1,1991,1,1,1,1,6, 0 };

    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("snChasMainPortTotal",
                                         get_snChasMainPortTotal,
                                         snChasMainPortTotal_oid,
                                         OID_LENGTH(snChasMainPortTotal_oid),
                                         HANDLER_CAN_RONLY));
}

int get_snChasMainPortTotal(netsnmp_mib_handler *handler,
    netsnmp_handler_registration *reginfo,
    netsnmp_agent_request_info *reqinfo,
    netsnmp_request_info *requests)
{
    /* dispatch get vs. set
     */
    switch (reqinfo->mode)
    {
        /* GET REQUEST
         */
        case MODE_GET:
        {
            UI32_T var_len = 0;
            STKTPLG_MGR_Switch_Info_T entry;

            /* get from core layer
             */
            long_return = 0;
            memset(&entry, 0, sizeof(entry));

            while (STKTPLG_PMGR_GetNextSwitchInfo(&entry))
            {
                long_return += entry.sw_port_number;
            }

            var_len = sizeof(UI32_T);
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                (u_char *) &long_return, var_len);

            break;
        }

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

#if (SYS_CPNT_THERMAL_DETECT == TRUE)
/* ------------------------------------------------------------------------
 * SCALAR NAME - 1.1.1.1 snChasGen.snChasActualTemperature(18)
 * ------------------------------------------------------------------------
 */
void init_snChasActualTemperature(void)
{
    static oid snChasActualTemperature_oid[] = { 1,3,6,1,4,1,1991,1,1,1,1,18, 0 };

    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("snChasActualTemperature",
                                         get_snChasActualTemperature,
                                         snChasActualTemperature_oid,
                                         OID_LENGTH(snChasActualTemperature_oid),
                                         HANDLER_CAN_RONLY));
}

int get_snChasActualTemperature(netsnmp_mib_handler *handler,
    netsnmp_handler_registration *reginfo,
    netsnmp_agent_request_info *reqinfo,
    netsnmp_request_info *requests)
{
    I32_T   temperature_sum = 0;  /* core layer uses I32_T */
    UI32_T  sensor_count = 0;
    SYS_MGR_SwitchThermalEntry_T entry;

    /* dispatch get vs. set
     */
    switch (reqinfo->mode)
    {
        /* GET REQUEST
         */
        case MODE_GET:
        {
            UI32_T var_len = 0;

            /* initialise buffer
             */
            memset(&entry, 0, sizeof(entry));

            /* get all sensors for all units
             */
            while (
#if (FOUNDRY_LIB_PLATFORM_STYLE == FOUNDRY_LIB_PLATFORM_STYLE_SIMBA)
                SYS_PMGR_GetNextThermalStatus(&entry)
#endif
#if (FOUNDRY_LIB_PLATFORM_STYLE == FOUNDRY_LIB_PLATFORM_STYLE_EDGE_CORE)
                /*!!PATCH: should call "SYS_PMGR_GetNextThermalTemperature",
                 * but there is no such function
                 */
                ( SYS_PMGR_GetNextThermalStatus(&entry)
                    && SYS_PMGR_GetThermalTemperature(&entry) )
#endif
                )
            {
                temperature_sum += entry.switch_thermal_temp_value;
                sensor_count++;
            }

            /* calculate average:
             *
             * MIB object description says that the unit is 0.5 degree Celsius.
             * So, "* 2" before dividing, i.e. for 1 deg C, display 2.
             */
            if (sensor_count != 0)
            {
                long_return = FOUNDRY_LIB_DivideWithSymmetricRounding(temperature_sum * 2, sensor_count);
            }

            /* reply to user
             */
            var_len = sizeof(UI32_T);
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                (u_char *) &long_return, var_len);

            break;
        }

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
#endif  /* (SYS_CPNT_THERMAL_DETECT == TRUE) */

/* ------------------------------------------------------------------------
 * SCALAR NAME - 1.1.1.1 snChasGen.snChasNumSlots(24)
 * ------------------------------------------------------------------------
 */
void init_snChasNumSlots(void)
{
    static oid snChasNumSlots_oid[] = { 1,3,6,1,4,1,1991,1,1,1,1,24, 0 };

    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("snChasNumSlots",
                                         get_snChasNumSlots,
                                         snChasNumSlots_oid,
                                         OID_LENGTH(snChasNumSlots_oid),
                                         HANDLER_CAN_RONLY));
}

int get_snChasNumSlots(netsnmp_mib_handler *handler,
    netsnmp_handler_registration *reginfo,
    netsnmp_agent_request_info *reqinfo,
    netsnmp_request_info *requests)
{
    /* dispatch get vs. set
     */
    switch (reqinfo->mode)
    {
        /* GET REQUEST
         */
        case MODE_GET:
        {
            UI32_T var_len = 0;

            /* get fixed value
             */
            long_return = SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK;
            var_len = sizeof(UI32_T);
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                (u_char *) &long_return, var_len);

            break;
        }

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

/* ------------------------------------------------------------------------
 * TABLE NAME - 1.1.1.2.2 snChasPwrSupply2Table
 * ------------------------------------------------------------------------
 */
oid snChasPwrSupply2Table_variables_oid[] = { 1,3,6,1,4,1,1991,1,1,1,2 };

/* variable3 snChasPwrSupply2Table_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */
struct variable3 snChasPwrSupply2Table_variables[] =
{
    /* magic number, variable type, ro/rw, callback fn, L, oidsuffix
     *     (L = length of the oidsuffix)
     */
    { LEAF_snChasPwrSupply2Unit, ASN_INTEGER, RONLY, var_snChasPwrSupply2Table, 3, { 2, 1, 1 }},
    { LEAF_snChasPwrSupply2Index, ASN_INTEGER, RONLY, var_snChasPwrSupply2Table, 3, { 2, 1, 2 }},
    { LEAF_snChasPwrSupply2Description, ASN_OCTET_STR, RONLY, var_snChasPwrSupply2Table, 3, { 2, 1, 3 }},
    { LEAF_snChasPwrSupply2OperStatus, ASN_INTEGER, RONLY, var_snChasPwrSupply2Table, 3, { 2, 1, 4 }},
};

void init_snChasPwrSupply2Table(void)
{
    /* Register ourselves with the agent to handle our MIB tree
     */
    REGISTER_MIB("snChasPwrSupply2Table", snChasPwrSupply2Table_variables, variable3,
                 snChasPwrSupply2Table_variables_oid);
}

#define SNCHASPWRSUPPLY2ENTRY_INSTANCE_LEN  2

BOOL_T snChasPwrSupply2Table_OidIndexToData(UI32_T exact, UI32_T compc,
    oid *compl, UI32_T *snChasPwrSupply2Unit, UI32_T *snChasPwrSupply2Index)
{
    /* get or set
     */
    if (exact)
    {
        /* check the index length
         */
        if (compc != SNCHASPWRSUPPLY2ENTRY_INSTANCE_LEN)  /* the constant size index */
        {
            return FALSE;
        }
    }

    *snChasPwrSupply2Unit = compl[0];
    *snChasPwrSupply2Index = compl[1];

    return TRUE;
}

/*
 * var_snChasPwrSupply2Table():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *var_snChasPwrSupply2Table(struct variable *vp,
    oid *name,
    size_t *length,
    int exact,
    size_t *var_len,
    WriteMethod **write_method)
{
    UI32_T compc = 0;
    oid compl[SNCHASPWRSUPPLY2ENTRY_INSTANCE_LEN] = {0};
    oid best_inst[SNCHASPWRSUPPLY2ENTRY_INSTANCE_LEN] = {0};

    /* table-specific variables
     */
    SYS_MGR_IndivPower_T entry;

    /* dispatch node to set write method
     */
    switch (vp->magic)
    {
        default:
            *write_method = 0;
            break;
    }

    /* check compc, retrive compl
     */
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl,
        SNCHASPWRSUPPLY2ENTRY_INSTANCE_LEN);

    memset(&entry, 0, sizeof(entry));

    /* dispatch get-exact versus get-next
     */
    if (exact)  /* get or set */
    {
        /* extract index
         */
        if (! snChasPwrSupply2Table_OidIndexToData(exact, compc, compl,
            &entry.sw_indiv_power_unit_index, &entry.sw_indiv_power_index))
        {
            return NULL;
        }

        /* get-exact from core layer
         */
        if (! SYS_PMGR_GetSwitchIndivPower(&entry))
        {
            return NULL;
        }
    }
    else  /* get-next */
    {
        /* extract index
         */
        snChasPwrSupply2Table_OidIndexToData(exact, compc, compl,
            &entry.sw_indiv_power_unit_index, &entry.sw_indiv_power_index);

        /* Check the length of inputing index. If compc is less than instance
         * length, we should try get {A.B.C.0.0...}, where A.B.C was
         * obtained from the "..._OidIndexToData" function call, and
         * 0.0... was initialized in the beginning of this function.
         * This instance may exist in the core layer.
         */
        if (compc < SNCHASPWRSUPPLY2ENTRY_INSTANCE_LEN)  /* incomplete index */
        {
            /* get-exact, in case this instance exists
             */
            if (! SYS_PMGR_GetSwitchIndivPower(&entry))
            {
                /* get-next according to lexicographic order; if none, fail
                 */
                if (! SYS_PMGR_GetNextSwitchIndivPower(&entry))
                {
                    return NULL;
                }
            }
        }
        else   /* complete index */
        {
            /* get-next according to lexicographic order; if none, fail
             */
            if (! SYS_PMGR_GetNextSwitchIndivPower(&entry))
            {
                return NULL;
            }
        }
    }

    /* copy base OID (without index) to output
     */
    memcpy(name, vp->name, vp->namelen * sizeof(oid));

    /* assign data to the OID index
     */
    best_inst[0] = entry.sw_indiv_power_unit_index;
    best_inst[1] = entry.sw_indiv_power_index;
    memcpy(name + vp->namelen, best_inst, SNCHASPWRSUPPLY2ENTRY_INSTANCE_LEN * sizeof(oid));
    *length = vp->namelen + SNCHASPWRSUPPLY2ENTRY_INSTANCE_LEN;

    /* dispatch node to read value
     */
    switch (vp->magic)
    {
        case LEAF_snChasPwrSupply2Unit:
            *var_len = 4;
            long_return = entry.sw_indiv_power_unit_index;
            return (u_char *) &long_return;

        case LEAF_snChasPwrSupply2Index:
            *var_len = 4;
            long_return = entry.sw_indiv_power_index;
            return (u_char *) &long_return;

#if 0  /* not implemented */
        case LEAF_snChasPwrSupply2Description:
            *var_len = strlen(entry.snChasPwrSupply2Description);???
            memcpy(return_buf, entry.snChasPwrSupply2Description, *var_len);???
            return (u_char *) return_buf;
#endif

        case LEAF_snChasPwrSupply2OperStatus:
            switch (entry.sw_indiv_power_status)
            {
                case VAL_swIndivPowerStatus_notPresent:
                    long_return = VAL_snChasPwrSupply2OperStatus_other;
                    break;

                case VAL_swIndivPowerStatus_green:
                    long_return = VAL_snChasPwrSupply2OperStatus_normal;
                    break;

                case VAL_swIndivPowerStatus_red:
                    long_return = VAL_snChasPwrSupply2OperStatus_failure;
                    break;

                default:  /* unrecognised core-layer value; should not happen */
                    long_return = VAL_snChasPwrSupply2OperStatus_other;
                    break;
            }

            *var_len = 4;
            return (u_char *) &long_return;

        default:
            ERROR_MSG("");
            break;
    }

    /* return failure
     */
    return NULL;
}

/* ------------------------------------------------------------------------
 * TABLE NAME - 1.1.1.4.1 snChasUnitTable
 * ------------------------------------------------------------------------
 */
oid snChasUnitTable_variables_oid[] = { 1,3,6,1,4,1,1991,1,1,1,4 };

/* variable3 snChasUnitTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */
struct variable3 snChasUnitTable_variables[] =
{
    /* magic number, variable type, ro/rw, callback fn, L, oidsuffix
     *     (L = length of the oidsuffix)
     */
    { LEAF_snChasUnitIndex, ASN_INTEGER, RONLY, var_snChasUnitTable, 3, { 1, 1, 1 }},
    { LEAF_snChasUnitSerNum, ASN_OCTET_STR, RONLY, var_snChasUnitTable, 3, { 1, 1, 2 }},
    { LEAF_snChasUnitNumSlots, ASN_INTEGER, RONLY, var_snChasUnitTable, 3, { 1, 1, 3 }},

#if (SYS_CPNT_THERMAL_DETECT == TRUE)
    { LEAF_snChasUnitActualTemperature, ASN_INTEGER, RONLY, var_snChasUnitTable, 3, { 1, 1, 4 }},
#endif

#if 0  /* not implemented */
    { LEAF_snChasUnitWarningTemperature, ASN_INTEGER, RONLY, var_snChasUnitTable, 3, { 1, 1, 5 }},
    { LEAF_snChasUnitShutdownTemperature, ASN_INTEGER, RONLY, var_snChasUnitTable, 3, { 1, 1, 6 }},
#endif

    { LEAF_snChasUnitPartNum, ASN_OCTET_STR, RONLY, var_snChasUnitTable, 3, { 1, 1, 7 }},
};

void init_snChasUnitTable(void)
{
    /* Register ourselves with the agent to handle our MIB tree
     */
    REGISTER_MIB("snChasUnitTable", snChasUnitTable_variables, variable3,
                 snChasUnitTable_variables_oid);
}

#define SNCHASUNITENTRY_INSTANCE_LEN  1

BOOL_T snChasUnitTable_OidIndexToData(UI32_T exact, UI32_T compc,
    oid *compl, UI32_T *snChasUnitIndex)
{
    /* get or set
     */
    if (exact)
    {
        /* check the index length
         */
        if (compc != SNCHASUNITENTRY_INSTANCE_LEN)  /* the constant size index */
        {
            return FALSE;
        }
    }

    *snChasUnitIndex = compl[0];

    return TRUE;
}

#if (SYS_CPNT_THERMAL_DETECT == TRUE)
/* ------------------------------------------------------------------------
 * FUNCTION NAME - var_snChasUnitTable_get_snChasUnitActualTemperature
 * ------------------------------------------------------------------------
 * PURPOSE  :   To get "snChasUnitActualTemperature", being an average
 *              temperature for all sensors in this unit.
 *
 * INPUT    :   unit        - stacking unit ID
 *
 * OUTPUT   :   None.
 *
 * RETURN   :   output value (for assigning to long_return; I32_T => long)
 *
 * NOTES    :   This function is called from var_snChasUnitTable.
 * ------------------------------------------------------------------------
 */
I32_T var_snChasUnitTable_get_snChasUnitActualTemperature(UI32_T unit)
{
    I32_T   ret = 0,    /* core layer uses I32_T */
            temperature_sum = 0;
    UI32_T  sensor_count = 0;
    SYS_MGR_SwitchThermalEntry_T entry;

    /* initialise buffer
     */
    memset(&entry, 0, sizeof(entry));
    entry.switch_unit_index = unit;

    /* get all sensors for this unit
     */
    while (
#if (FOUNDRY_LIB_PLATFORM_STYLE == FOUNDRY_LIB_PLATFORM_STYLE_SIMBA)
        SYS_PMGR_GetNextThermalStatus(&entry)
#endif
#if (FOUNDRY_LIB_PLATFORM_STYLE == FOUNDRY_LIB_PLATFORM_STYLE_EDGE_CORE)
        /*!!PATCH: should call "SYS_PMGR_GetNextThermalTemperature",
         * but there is no such function
         */
        ( SYS_PMGR_GetNextThermalStatus(&entry)
            && SYS_PMGR_GetThermalTemperature(&entry) )
#endif
        && (entry.switch_unit_index == unit)
        )
    {
        temperature_sum += entry.switch_thermal_temp_value;
        sensor_count++;
    }

    /* calculate average:
     *
     * MIB object description says that the unit is 0.5 degree Celsius.
     * So, "* 2" before dividing, i.e. for 1 deg C, display 2.
     */
    if (sensor_count != 0)
    {
        ret = FOUNDRY_LIB_DivideWithSymmetricRounding(temperature_sum * 2, sensor_count);
    }

    /* return; single exit point
     */
    return ret;
}
#endif  /* (SYS_CPNT_THERMAL_DETECT == TRUE) */

/*
 * var_snChasUnitTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *var_snChasUnitTable(struct variable *vp,
    oid *name,
    size_t *length,
    int exact,
    size_t *var_len,
    WriteMethod **write_method)
{
    UI32_T compc = 0;
    oid compl[SNCHASUNITENTRY_INSTANCE_LEN] = {0};
    oid best_inst[SNCHASUNITENTRY_INSTANCE_LEN] = {0};

    /* table-specific variables
     */
    STKTPLG_MGR_Switch_Info_T entry;
    UI32_T unit;

    /* dispatch node to set write method
     */
    switch (vp->magic)
    {
        default:
            *write_method = 0;
            break;
    }

    /* check compc, retrive compl
     */
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl,
        SNCHASUNITENTRY_INSTANCE_LEN);

    memset(&entry, 0, sizeof(entry));

    /* dispatch get-exact versus get-next
     */
    if (exact)  /* get or set */
    {
        /* extract index
         */
        if (! snChasUnitTable_OidIndexToData(exact, compc, compl,
            &unit))
        {
            return NULL;
        }

        /* get-exact from core layer
         */
        entry.sw_unit_index = (UI8_T) unit;

        if (! STKTPLG_PMGR_GetSwitchInfo(&entry))
        {
            return NULL;
        }
    }
    else  /* get-next */
    {
        /* extract index
         */
        snChasUnitTable_OidIndexToData(exact, compc, compl,
            &unit);

        /* Check the length of inputing index. If compc is less than instance
         * length, we should try get {A.B.C.0.0...}, where A.B.C was
         * obtained from the "..._OidIndexToData" function call, and
         * 0.0... was initialized in the beginning of this function.
         * This instance may exist in the core layer.
         */
        if (compc < SNCHASUNITENTRY_INSTANCE_LEN)  /* incomplete index */
        {
            /* get-exact, in case this instance exists
             */
            entry.sw_unit_index = (UI8_T) unit;

            if (! STKTPLG_PMGR_GetSwitchInfo(&entry))
            {
                /* get-next according to lexicographic order; if none, fail
                 */
                if (! STKTPLG_PMGR_GetNextSwitchInfo(&entry))
                {
                    return NULL;
                }
            }
        }
        else   /* complete index */
        {
            entry.sw_unit_index = (UI8_T) unit;

            /* get-next according to lexicographic order; if none, fail
             */
            if (! STKTPLG_PMGR_GetNextSwitchInfo(&entry))
            {
                return NULL;
            }
        }
    }

    /* copy base OID (without index) to output
     */
    memcpy(name, vp->name, vp->namelen * sizeof(oid));

    /* assign data to the OID index
     */
    best_inst[0] = entry.sw_unit_index;
    memcpy(name + vp->namelen, best_inst, SNCHASUNITENTRY_INSTANCE_LEN * sizeof(oid));
    *length = vp->namelen + SNCHASUNITENTRY_INSTANCE_LEN;

    /* dispatch node to read value
     */
    switch (vp->magic)
    {
        /* snChasUnitIndex
         */
        case LEAF_snChasUnitIndex:
            *var_len = 4;
            long_return = entry.sw_unit_index;
            return (u_char *) &long_return;

        /* snChasUnitSerNum
         */
        case LEAF_snChasUnitSerNum:
            *var_len = strlen(entry.sw_serial_number);
            memcpy(return_buf, entry.sw_serial_number, *var_len);
            return (u_char *) return_buf;

        /* snChasUnitNumSlots
         */
        case LEAF_snChasUnitNumSlots:
            *var_len = 4;
            long_return = 1;  /* no such concept; assume 1 */
            return (u_char *) &long_return;

#if (SYS_CPNT_THERMAL_DETECT == TRUE)
        case LEAF_snChasUnitActualTemperature:
            *var_len = 4;
            long_return = var_snChasUnitTable_get_snChasUnitActualTemperature(entry.sw_unit_index);
            return (u_char *) &long_return;
#endif

#if 0  /* not implemented */
        case LEAF_snChasUnitWarningTemperature:
            *var_len = 4;
            long_return = entry.snChasUnitWarningTemperature;???
            return (u_char *) &long_return;

        case LEAF_snChasUnitShutdownTemperature:
            *var_len = 4;
            long_return = entry.snChasUnitShutdownTemperature;???
            return (u_char *) &long_return;
#endif
        /* snChasUnitPartNum
         */
        case LEAF_snChasUnitPartNum:
            *var_len = strlen(entry.sw_model_number);
            memcpy(return_buf, entry.sw_model_number, *var_len);
            return (u_char *) return_buf;

        /* unrecognised node
         */
        default:
            ERROR_MSG("");
            break;
    }

    /* return failure
     */
    return NULL;
}

/*--------------------------------------------------------------------------
 * SCALAR NAME - 1.1.2.1 snAgentGbl.snAgReload(1)
 *--------------------------------------------------------------------------
 */
void init_snAgReload(void)
{
    static oid snAgReload_oid[] = { 1,3,6,1,4,1,1991,1,1,2,1,1, 0 };

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("snAgReload",
                               do_snAgReload,
                               snAgReload_oid,
                               OID_LENGTH(snAgReload_oid),
                               HANDLER_CAN_RWRITE));
}

int do_snAgReload(netsnmp_mib_handler *handler,
    netsnmp_handler_registration *reginfo,
    netsnmp_agent_request_info *reqinfo,
    netsnmp_request_info *requests)
{
    /* dispatch get vs. set
     */
    switch (reqinfo->mode)
    {
        /* GET REQUEST
         */
        case MODE_GET:
        {
            UI32_T var_len = 0;

            /* get fixed value
             */
            long_return = VAL_snAgReload_running;
            var_len = sizeof(UI32_T);
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                (u_char *) &long_return, var_len);
            break;
        }

        /* SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            /* check type and length
             */
            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
                return SNMP_ERR_NOERROR;
            }

            break;

        case MODE_SET_RESERVE2:
            switch (*requests->requestvb->val.integer)
            {
                case VAL_snAgReload_other:
                    netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
                    break;

                case VAL_snAgReload_running:  /* ignore write */
                    break;

                case VAL_snAgReload_reset:
                    break;

                case VAL_snAgReload_busy:
                default:
                    netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
                    return SNMP_ERR_NOERROR;
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called.
             */
            break;

        case MODE_SET_ACTION:
        {
            /* set to core layer
             */
            if (*requests->requestvb->val.integer == VAL_snAgReload_reset)
            {
                /* always succeeds
                 */
                STKCTRL_PMGR_WarmStartSystem();
            }

            break;
        }

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

/*--------------------------------------------------------------------------
 * SCALAR NAME - 1.1.2.1 snAgentGbl.snAgEraseNVRAM(2)
 *--------------------------------------------------------------------------
 */
void init_snAgEraseNVRAM(void)
{
    static oid snAgEraseNVRAM_oid[] = { 1,3,6,1,4,1,1991,1,1,2,1,2, 0 };

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("snAgEraseNVRAM",
                               do_snAgEraseNVRAM,
                               snAgEraseNVRAM_oid,
                               OID_LENGTH(snAgEraseNVRAM_oid),
                               HANDLER_CAN_RWRITE));
}

int do_snAgEraseNVRAM(netsnmp_mib_handler *handler,
    netsnmp_handler_registration *reginfo,
    netsnmp_agent_request_info *reqinfo,
    netsnmp_request_info *requests)
{
    /* dispatch get vs. set
     */
    switch (reqinfo->mode)
    {
        /* GET REQUEST
         */
        case MODE_GET:
        {
            UI32_T var_len = 0;

            /* get fixed value
             */
            long_return = VAL_snAgEraseNVRAM_normal;
            var_len = sizeof(UI32_T);
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                (u_char *) &long_return, var_len);

            break;
        }

        /* SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            /* check type and length
             */
            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
                return SNMP_ERR_NOERROR;
            }

            break;

        case MODE_SET_RESERVE2:
            switch (*requests->requestvb->val.integer)
            {
                case VAL_snAgEraseNVRAM_normal:  /* ignore write */
                    break;

                case VAL_snAgEraseNVRAM_error:
                    netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
                    return SNMP_ERR_NOERROR;

                case VAL_snAgEraseNVRAM_erase:
                    break;

                case VAL_snAgEraseNVRAM_erasing:
                case VAL_snAgEraseNVRAM_busy:
                default:
                    netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
                    return SNMP_ERR_NOERROR;
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called.
             */
            break;

        case MODE_SET_ACTION:
        {
            /* set to core layer
             */
            if ( (*requests->requestvb->val.integer == VAL_snAgEraseNVRAM_erase)
                && (! XFER_PMGR_SetStartupFilename(FS_FILE_TYPE_CONFIG,
                    SYS_DFLT_restartConfigFile, 0, 0, 0)) )
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
                return SNMP_ERR_NOERROR;
            }

            break;
        }

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

/*--------------------------------------------------------------------------
 * SCALAR NAME - 1.1.2.1 snAgentGbl.snAgWriteNVRAM(3)
 *--------------------------------------------------------------------------
 */
void init_snAgWriteNVRAM(void)
{
    static oid snAgWriteNVRAM_oid[] = { 1,3,6,1,4,1,1991,1,1,2,1,3, 0 };

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("snAgWriteNVRAM",
                               do_snAgWriteNVRAM,
                               snAgWriteNVRAM_oid,
                               OID_LENGTH(snAgWriteNVRAM_oid),
                               HANDLER_CAN_RWRITE));
}

int do_snAgWriteNVRAM(netsnmp_mib_handler *handler,
    netsnmp_handler_registration *reginfo,
    netsnmp_agent_request_info *reqinfo,
    netsnmp_request_info *requests)
{
    /* dispatch get vs. set
     */
    switch (reqinfo->mode)
    {
        /* GET REQUEST
         */
        case MODE_GET:
        {
            UI32_T var_len = 0;
            XFER_MGR_FileCopyMgt_T entry;

            /* get from core layer
             */
            if (! XFER_PMGR_GetFileCopyMgtEntry(&entry))
            {
                return SNMP_ERR_GENERR;
            }

            /* compose to user value
             */

            /* copying:
             * reply writing(4), not the error response busy(5)
             */
            if (entry.action == VAL_fileCopyAction_copy)
            {
                long_return = VAL_snAgWriteNVRAM_writing;
            }

            /* finished, read success/error:
             * may mean error from operating this variable or another copy
             */
            else
            {
                /* check whether maps to normal
                 */
                if (do_snAgent_ConvertAcctonToFoundryFileCopyStatus_IsNormal(entry.status))
                {
                    long_return = VAL_snAgWriteNVRAM_normal;
                }

                /* check whether maps to error
                 */
                else if (do_snAgent_ConvertAcctonToFoundryFileCopyStatus_IsError(entry.status))
                {
                    long_return = VAL_snAgWriteNVRAM_error;
                }

                /* unrecognised success/error code from core layer
                 *
                 * If this happens, it means:
                 * 1. new status code not recognised by this mapping;
                 * 2. bug is core layer
                 */
                else
                {
                    long_return = 0;
                }
            }

            /* succeeded; reply to user
             */
            var_len = sizeof(UI32_T);
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                (u_char *) &long_return, var_len);

            break;
        }

        /* SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            /* check type and length
             */
            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
                return SNMP_ERR_NOERROR;
            }

            break;

        case MODE_SET_RESERVE2:
            switch (*requests->requestvb->val.integer)
            {
                case VAL_snAgWriteNVRAM_normal:  /* ignore write */
                    break;

                case VAL_snAgWriteNVRAM_error:
                    netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
                    return SNMP_ERR_NOERROR;

                case VAL_snAgWriteNVRAM_write:
                    break;

                case VAL_snAgWriteNVRAM_writing:
                case VAL_snAgWriteNVRAM_busy:
                default:
                    netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
                    return SNMP_ERR_NOERROR;
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called.
             */
            break;

        case MODE_SET_ACTION:
        {
            char current_startup_ar[SYS_ADPT_FILE_SYSTEM_NAME_LEN + 1];
            const char *new_startup_p = "";

            /*!!PATCH: hardcode this enhancement; will port form EDD (ASF4506B-ZZ)
             */
            const char const *startup1_p = SYS_DFLT_CLI_AUTO_GENERATE_START_UP_FILENAME;
            const char const *startup2_p = "startup2.cfg";

            /* get current startup file name
             */
            if (FS_GetStartupFilename(SYS_VAL_LOCAL_UNIT_ID, FS_FILE_TYPE_CONFIG,
                current_startup_ar) != FS_RETURN_OK)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            /* rotate two startup file names (Brocade MIB does not know file name)
             */
            new_startup_p = startup1_p;

            if (strcmp(current_startup_ar, startup1_p) == 0)
            {
                new_startup_p = startup2_p;
            }

            /* set to core layer
             */
            if (*requests->requestvb->val.integer == VAL_snAgWriteNVRAM_write)
            {
                /* action sequence;
                 * can re-write as a sequence of "if (! XFER_PMGR(...)) { fail }" if preferred,
                 * so that you know which one failed
                 */
                if (! (
                    XFER_PMGR_SetFileCopySrcOperType(VAL_fileCopySrcOperType_runningCfg)
                    && XFER_PMGR_SetFileCopyDestOperType(VAL_fileCopyDestOperType_startUpCfg)
                    && XFER_PMGR_SetFileCopyDestFileName(new_startup_p)
                    && XFER_PMGR_SetFileCopyAction(VAL_fileCopyAction_copy, 0, 0, 0)
                    ))
                {
                    netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
                    return SNMP_ERR_NOERROR;
                }
            }

            break;
        }

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

/*--------------------------------------------------------------------------
 * SCALAR NAME - 1.1.2.1 snAgentGbl.snAgConfigFromNVRAM(4)
 *
 * SPECIFICATION:
 * MIB object in MIB file is "not-accessible".
 *
 * IMPLEMENTATION:
 * This is privately updated to "read-write" and implmentated as such.
 *--------------------------------------------------------------------------
 */
void init_snAgConfigFromNVRAM(void)
{
    static oid snAgConfigFromNVRAM_oid[] = { 1,3,6,1,4,1,1991,1,1,2,1,4, 0 };

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("snAgConfigFromNVRAM",
                               do_snAgConfigFromNVRAM,
                               snAgConfigFromNVRAM_oid,
                               OID_LENGTH(snAgConfigFromNVRAM_oid),
                               HANDLER_CAN_RWRITE));
}

int do_snAgConfigFromNVRAM(netsnmp_mib_handler *handler,
    netsnmp_handler_registration *reginfo,
    netsnmp_agent_request_info *reqinfo,
    netsnmp_request_info *requests)
{
    /* dispatch get vs. set
     */
    switch (reqinfo->mode)
    {
        /* GET REQUEST
         */
        case MODE_GET:
        {
            UI32_T var_len = 0;
            XFER_MGR_FileCopyMgt_T entry;

            /* get from core layer
             */
            if (! XFER_PMGR_GetFileCopyMgtEntry(&entry))
            {
                return SNMP_ERR_GENERR;
            }

            /* compose to user value
             */

            /* copying:
             * reply configing(4), not the error response busy(5)
             */
            if (entry.action == VAL_fileCopyAction_copy)
            {
                long_return = VAL_snAgConfigFromNVRAM_configing;
            }

            /* finished, read success/error:
             * may mean error from operating this variable or another copy
             */
            else
            {
                /* check whether maps to normal
                 */
                if (do_snAgent_ConvertAcctonToFoundryFileCopyStatus_IsNormal(entry.status))
                {
                    long_return = VAL_snAgConfigFromNVRAM_normal;
                }

                /* check whether maps to error
                 */
                else if (do_snAgent_ConvertAcctonToFoundryFileCopyStatus_IsError(entry.status))
                {
                    long_return = VAL_snAgConfigFromNVRAM_error;
                }

                /* unrecognised success/error code from core layer
                 *
                 * If this happens, it means:
                 * 1. new status code not recognised by this mapping;
                 * 2. bug is core layer
                 */
                else
                {
                    long_return = 0;
                }
            }

            /* succeeded; reply to user
             */
            var_len = sizeof(UI32_T);
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                (u_char *) &long_return, var_len);

            break;
        }

        /* SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            /* check type and length
             */
            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
                return SNMP_ERR_NOERROR;
            }

            break;

        case MODE_SET_RESERVE2:
            switch (*requests->requestvb->val.integer)
            {
                case VAL_snAgConfigFromNVRAM_normal:
                    break;

                case VAL_snAgConfigFromNVRAM_error:
                    break;

                case VAL_snAgConfigFromNVRAM_config:
                    break;

                case VAL_snAgConfigFromNVRAM_configing:
                    break;

                case VAL_snAgConfigFromNVRAM_busy:
                    break;

                default:
                    netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
                    return SNMP_ERR_NOERROR;
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called.
             */
            break;

        case MODE_SET_ACTION:
        {
            /* set to core layer
             */
            if (*requests->requestvb->val.integer == VAL_snAgWriteNVRAM_write)
            {
                /* action sequence;
                 * can re-write as a sequence of "if (! XFER_PMGR(...)) { fail }" if preferred,
                 * so that you know which one failed
                 */
                if (! (
                    XFER_PMGR_SetFileCopySrcOperType(VAL_fileCopySrcOperType_startUpCfg)
                    && XFER_PMGR_SetFileCopyDestOperType(VAL_fileCopyDestOperType_runningCfg)
                    && XFER_PMGR_SetFileCopyAction(VAL_fileCopyAction_copy, 0, 0, 0)
                    ))
                {
                    netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
                    return SNMP_ERR_NOERROR;
                }
            }

            break;
        }

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

/*--------------------------------------------------------------------------
 * SCALAR NAME - 1.1.2.1 snAgentGbl.snAgImgFname(6)
 * SCALAR NAME - 1.1.2.1 snAgentGbl.snAgCfgFname(8)
 *--------------------------------------------------------------------------
 */
void init_snAgImgFname(void)
{
    /* Accton does not distinguish between img filenames and cfg filenames.
     * Hard-code this to register both nodes to the same routine, for now.
     */
    static oid snAgImgFname_oid[] = { 1,3,6,1,4,1,1991,1,1,2,1,6, 0 };
    static oid snAgCfgFname_oid[] = { 1,3,6,1,4,1,1991,1,1,2,1,8, 0 };

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("snAgImgFname",
                               do_snAgImgFname,  /* also used below */
                               snAgImgFname_oid,
                               OID_LENGTH(snAgImgFname_oid),
                               HANDLER_CAN_RWRITE));

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("snAgCfgFname",
                               do_snAgImgFname,  /* uses the above */
                               snAgCfgFname_oid,
                               OID_LENGTH(snAgCfgFname_oid),
                               HANDLER_CAN_RWRITE));
}

int do_snAgImgFname(netsnmp_mib_handler *handler,
    netsnmp_handler_registration *reginfo,
    netsnmp_agent_request_info *reqinfo,
    netsnmp_request_info *requests)
{
    /* dispatch get vs. set
     */
    switch (reqinfo->mode)
    {
        /* GET REQUEST
         */
        case MODE_GET:
        {
            UI32_T var_len = 0;
            XFER_MGR_FileCopyMgt_T entry;

            /* get from core layer
             */
            if (! XFER_PMGR_GetFileCopyMgtEntry(&entry))
            {
                return SNMP_ERR_GENERR;
            }
            else
            {
                var_len = strlen(entry.src_file_name);

                if (var_len > MAXSIZE_snAgImgFname)  /* assume truncate */
                {
                    var_len = MAXSIZE_snAgImgFname;
                }

                strncpy((char *) return_buf, (char *) entry.src_file_name,
                    var_len);
                ((UI8_T *) return_buf)[var_len] = '\0';

                snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                    (u_char *) return_buf, var_len);
            }

            break;
        }

        /* SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            /* check type and length
             */
            if (requests->requestvb->type != ASN_OCTET_STR)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
                return SNMP_ERR_NOERROR;
            }

            if ((requests->requestvb->val_len < MINSIZE_snAgImgFname)
                || (requests->requestvb->val_len > MAXSIZE_snAgImgFname))
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGLENGTH);
                return SNMP_ERR_NOERROR;
            }

            break;

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called.
             */
            break;

        case MODE_SET_ACTION:
        {
            UI8_T snAgImgFname[MAXSIZE_snAgImgFname + 1];

            /* get user value
             */
            memcpy(snAgImgFname, requests->requestvb->val.string, requests->requestvb->val_len);
            snAgImgFname[requests->requestvb->val_len] = '\0';

            /* set to core layer
             */
            if (! (
                XFER_PMGR_SetFileCopySrcFileName(snAgImgFname)
                && XFER_PMGR_SetFileCopyDestFileName(snAgImgFname)
                ))
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
                return SNMP_ERR_NOERROR;
            }

            break;
        }

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

/*--------------------------------------------------------------------------
 * SCALAR NAME - 1.1.2.1 snAgentGbl.snAgImgLoad(7)
 *--------------------------------------------------------------------------
 */
void init_snAgImgLoad(void)
{
    static oid snAgImgLoad_oid[] = { 1,3,6,1,4,1,1991,1,1,2,1,7, 0 };

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("snAgImgLoad",
                               do_snAgImgLoad,
                               snAgImgLoad_oid,
                               OID_LENGTH(snAgImgLoad_oid),
                               HANDLER_CAN_RWRITE));
}

/* ------------------------------------------------------------------------
 * FUNCTION NAME - do_snAgImgLoad_set_uploadMPPrimary
 * ------------------------------------------------------------------------
 * PURPOSE  :   To set "snAgImgLoad" to "uploadMPPrimary(19)".
 *
 * INPUT    :   None.
 *
 * OUTPUT   :   None.
 *
 * RETURN   :   SNMP_ERR_..., defined in "snmp.h" of Net-SNMP,
 *              used to call "netsnmp_set_request_error".
 *
 * NOTES    :   This function is called from do_snAgImgLoad.
 * ------------------------------------------------------------------------
 */
static int do_snAgImgLoad_set_uploadMPPrimary(void)
{
    int ret = SNMP_ERR_NOERROR;  /* "int" by Net-SNMP, not UI32_T */
    char startup_sz[SYS_ADPT_FILE_SYSTEM_NAME_LEN + 1];

    /* get start-up runtime (on master unit)
     */
    if (FS_GetStartupFilename(SYS_VAL_LOCAL_UNIT_ID, FS_FILE_TYPE_RUNTIME,
        startup_sz) != FS_RETURN_OK)
    {
        ret = SNMP_ERR_COMMITFAILED;
    }

    /* call core layer: copy runtime file to TFTP
     */
    else
    {
        /* action sequence;
         * can re-write as a sequence of "if (! XFER_PMGR(...)) { fail }" if preferred,
         * so that you know which one failed
         */
        if (! (
            XFER_PMGR_SetFileCopySrcOperType(VAL_fileCopySrcOperType_file)
            && XFER_PMGR_SetFileCopySrcFileName(startup_sz)
            && XFER_PMGR_SetFileCopyDestOperType(VAL_fileCopyDestOperType_tftp)
            && XFER_PMGR_SetFileCopyAction(VAL_fileCopyAction_copy, 0, 0, 0)
            ))
        {
            ret = SNMP_ERR_COMMITFAILED;
        }
    }

    /* return
     */
    return ret;
}

/* ------------------------------------------------------------------------
 * FUNCTION NAME - do_snAgImgLoad_set_downloadMPPrimary
 * ------------------------------------------------------------------------
 * PURPOSE  :   To set "snAgImgLoad" to "downloadMPPrimary(20)".
 *
 * INPUT    :   None.
 *
 * OUTPUT   :   None.
 *
 * RETURN   :   SNMP_ERR_..., defined in "snmp.h" of Net-SNMP,
 *              used to call "netsnmp_set_request_error".
 *
 * NOTES    :   This function is called from do_snAgImgLoad.
 * ------------------------------------------------------------------------
 */
static int do_snAgImgLoad_set_downloadMPPrimary(void)
{
    int ret = SNMP_ERR_NOERROR;  /* "int" by Net-SNMP, not UI32_T */

    /*!!PENDING: Because this involves deleting files,
     * and setting the start-up flag,
     * this enhancement will be moved to Xfer,
     * so that old files are deleted after getting the correct new file.
     */

#if (SYS_CPNT_SINGLE_RUNTIME_IMAGE == TRUE)  /* function body */
    /* for one-opcode devices, overwrite with new file name
     */

    /* action sequence;
     * can re-write as a sequence of "if (! XFER_PMGR(...)) { fail }" if preferred,
     * so that you know which one failed
     */
    if (! (
        XFER_PMGR_SetFileCopySrcOperType(VAL_fileCopySrcOperType_tftp)
        && XFER_PMGR_SetFileCopyDestOperType(VAL_fileCopyDestOperType_file)
        && XFER_PMGR_SetFileCopyFileType(VAL_fileCopyFileType_opcode)
        && XFER_PMGR_SetFileCopyAction(VAL_fileCopyAction_copy, 0, 0, 0)
        ))
    {
        ret = SNMP_ERR_COMMITFAILED;
    }

#else  /* #if (SYS_CPNT_SINGLE_RUNTIME_IMAGE == TRUE) ... #else; function body */
    /* for multi-opcode devices, the current platform cannot overwrite
     */
    FS_File_Attr_T entry_str;
    UI32_T my_unit, unit;

    /*!!PATCH: Xfer cannot download a runtime *and-also* mark it as start-up.
     * For now, borrow this "set" to:
     * 1. Not download. <- You need to download secondary, instead.
     * 2. Switch between existing primary and secondary runtimes.
     */

    /* prepare variables
     */
    STKTPLG_POM_GetMyUnitID(&my_unit);
    unit = my_unit;

    memset(&entry_str, 0, sizeof(entry_str));
    entry_str.file_type_mask = FS_FILE_TYPE_MASK(FS_FILE_TYPE_RUNTIME);

    /* switch non-start-up runtime to start-up (on master unit; assume one file)
     */
    while ( (FS_GetNextFileInfo(&unit, &entry_str) == FS_RETURN_OK)
        && (unit == my_unit) )
    {
        /* if this is not start-up
         */
        if (! entry_str.startup_file)
        {
            /* mark this as start-up
             */
            if (! XFER_PMGR_SetStartupFilename(FS_FILE_TYPE_RUNTIME,
                    entry_str.file_name, 0, 0, 0))
            {
                ret = SNMP_ERR_COMMITFAILED;
            }

            /* done with the non-start-up
             */
            break;
        }
    }
#endif  /* #if (SYS_CPNT_SINGLE_RUNTIME_IMAGE == TRUE) ... #else ...; function body */

    /* return
     */
    return ret;
}

/* ------------------------------------------------------------------------
 * FUNCTION NAME - do_snAgImgLoad_set_uploadMPSecondary
 * ------------------------------------------------------------------------
 * PURPOSE  :   To set "snAgImgLoad" to "uploadMPSecondary(21)".
 *
 * INPUT    :   None.
 *
 * OUTPUT   :   None.
 *
 * RETURN   :   SNMP_ERR_..., defined in "snmp.h" of Net-SNMP,
 *              used to call "netsnmp_set_request_error".
 *
 * NOTES    :   This function is called from do_snAgImgLoad.
 * ------------------------------------------------------------------------
 */
static int do_snAgImgLoad_set_uploadMPSecondary(void)
{
    int ret = SNMP_ERR_NOERROR;  /* "int" by Net-SNMP, not UI32_T */

#if (SYS_CPNT_SINGLE_RUNTIME_IMAGE == FALSE)  /* function body */
    FS_File_Attr_T entry_str;
    UI32_T my_unit, unit;
    BOOL_T found = FALSE;

    /* prepare variables
     */
    STKTPLG_POM_GetMyUnitID(&my_unit);
    unit = my_unit;

    memset(&entry_str, 0, sizeof(entry_str));
    entry_str.file_type_mask = FS_FILE_TYPE_MASK(FS_FILE_TYPE_RUNTIME);

    /* find non-start-up runtime (on master unit; assume one file)
     */
    while ( (FS_GetNextFileInfo(&unit, &entry_str) == FS_RETURN_OK)
        && (unit == my_unit) )
    {
        /* if this is not start-up
         */
        if (! entry_str.startup_file)
        {
            found = TRUE;
            break;
        }
    }

    /* if not found, fail
     */
    if (! found)
    {
        ret = SNMP_ERR_COMMITFAILED;
    }

    /* if found, call core layer: copy runtime file to TFTP
     */
    else
    {
        /* action sequence;
         * can re-write as a sequence of "if (! XFER_PMGR(...)) { fail }" if preferred,
         * so that you know which one failed
         */
        if (! (
            XFER_PMGR_SetFileCopySrcOperType(VAL_fileCopySrcOperType_file)
            && XFER_PMGR_SetFileCopySrcFileName(entry_str.file_name)
            && XFER_PMGR_SetFileCopyDestOperType(VAL_fileCopyDestOperType_tftp)
            && XFER_PMGR_SetFileCopyFileType(VAL_fileCopyFileType_opcode)
            && XFER_PMGR_SetFileCopyAction(VAL_fileCopyAction_copy, 0, 0, 0)
            ))
        {
            ret = SNMP_ERR_COMMITFAILED;
        }
    }
#endif  /* (SYS_CPNT_SINGLE_RUNTIME_IMAGE == FALSE); function body */

    /* return
     */
    return ret;
}

/* ------------------------------------------------------------------------
 * FUNCTION NAME - do_snAgImgLoad_set_downloadMPSecondary
 * ------------------------------------------------------------------------
 * PURPOSE  :   To set "snAgImgLoad" to "downloadMPSecondary(22)".
 *
 * INPUT    :   None.
 *
 * OUTPUT   :   None.
 *
 * RETURN   :   SNMP_ERR_..., defined in "snmp.h" of Net-SNMP,
 *              used to call "netsnmp_set_request_error".
 *
 * NOTES    :   This function is called from do_snAgImgLoad.
 * ------------------------------------------------------------------------
 */
static int do_snAgImgLoad_set_downloadMPSecondary(void)
{
    int ret = SNMP_ERR_NOERROR;  /* "int" by Net-SNMP, not UI32_T */

    /*!!PENDING: Because this involves deleting files,
     * this enhancement will be moved to Xfer,
     * so that old files are deleted after getting the correct new file.
     */

#if (SYS_CPNT_SINGLE_RUNTIME_IMAGE == FALSE)  /* function body */
    FS_File_Attr_T entry_str;
    UI32_T unit;

    /* prepare variables
     */
    unit = 0;
    memset(&entry_str, 0, sizeof(entry_str));
    entry_str.file_type_mask = FS_FILE_TYPE_MASK(FS_FILE_TYPE_RUNTIME);

    /* delete all non-start-up runtimes (on all units; assume many files)
     */
    while (FS_GetNextFileInfo(&unit, &entry_str) == FS_RETURN_OK)
    {
        /* if this is not start-up
         */
        if (! entry_str.startup_file)
        {
            /* delete this file (from all units); ignore error code
             */
            FS_DeleteFile(unit, entry_str.file_name);
        }
    }

    /* call core layer: copy runtime file from TFTP
     */

    /* action sequence;
     * can re-write as a sequence of "if (! XFER_PMGR(...)) { fail }" if preferred,
     * so that you know which one failed
     */
    if (! (
        XFER_PMGR_SetFileCopySrcOperType(VAL_fileCopySrcOperType_tftp)
        && XFER_PMGR_SetFileCopyDestOperType(VAL_fileCopyDestOperType_file)
        && XFER_PMGR_SetFileCopyAction(VAL_fileCopyAction_copy, 0, 0, 0)
        ))
    {
        ret = SNMP_ERR_COMMITFAILED;
    }
#endif  /* (SYS_CPNT_SINGLE_RUNTIME_IMAGE == FALSE); function body */

    /* return
     */
    return ret;
}

/* ------------------------------------------------------------------------
 * FUNCTION NAME - do_snAgImgLoad_ConvertAcctonToFoundryError
 * ------------------------------------------------------------------------
 * PURPOSE  :   Maps error from Accton code to Foundray code for snAgImgLoad.
 *
 * INPUT    :   accton_status       -- Accton's fileCopyStatus
 *              foundry_status_p    -- pointer to Foundry status
 *
 * OUTPUT   :   *foundry_status_p   -- Foundry status
 *
 * RETURN   :   TRUE    -- maps to error
 *              FALSE   -- does not map to error
 *
 * NOTES    :   This functions is called from do_snAgImgLoad.
 *              The mapping is not exactly the same as for snAgCfgLoad.
 * ------------------------------------------------------------------------
 */
static BOOL_T do_snAgImgLoad_ConvertAcctonToFoundryError(UI32_T accton_status,
    UI32_T *foundry_status_p)
{
    BOOL_T ret = FALSE;

    /* quick filter: check range first;
     * if in error code range, map error code
     */
    if (do_snAgent_ConvertAcctonToFoundryFileCopyStatus_IsError(accton_status))
    {
        ret = TRUE;

        /* map status code
         *
         * SPECIFICATION:
         * See MIB object description of Accton's "fileCopyStatus"
         * and Brocade's "snAgImgLoad".
         *
         * MAPPING FILE:
         * fileCopyStatus_20111102_NoTracking.xls
         */
        switch (accton_status)
        {
            case VAL_fileCopyStatus_fileCopyTftpIllegalOperation:
                *foundry_status_p = VAL_snAgImgLoad_tftpRemoteBadOperation;
                break;

            case VAL_fileCopyStatus_fileCopyTftpUnkownTransferId:
                *foundry_status_p = VAL_snAgImgLoad_tftpRemoteBadId;
                break;

            case VAL_fileCopyStatus_fileCopyTftpFileExisted:
                *foundry_status_p = VAL_snAgImgLoad_tftpRemoteFileExists;
                break;

            case VAL_fileCopyStatus_fileCopyTftpNoSuchUser:
                *foundry_status_p = VAL_snAgImgLoad_tftpRemoteNoUser;
                break;

            case VAL_fileCopyStatus_fileCopyBusy:
                *foundry_status_p = VAL_snAgImgLoad_tftpBusy;
                break;

            case VAL_fileCopyStatus_fileCopyReadFileError:
                *foundry_status_p = VAL_snAgImgLoad_flashReadError;
                break;

            case VAL_fileCopyStatus_fileCopySetStartupError:
                *foundry_status_p = VAL_snAgImgLoad_flashWriteError;
                break;

            case VAL_fileCopyStatus_fileCopyFileSizeExceed:
                *foundry_status_p = VAL_snAgImgLoad_tftpOutOfBufferSpace;
                break;

            case VAL_fileCopyStatus_fileCopyMagicWordError:
            case VAL_fileCopyStatus_fileCopyImageTypeError:
            case VAL_fileCopyStatus_fileCopyHeaderChecksumError:
            case VAL_fileCopyStatus_fileCopyImageChecksumError:
                *foundry_status_p = VAL_snAgImgLoad_tftpWrongFileType;
                break;

            case VAL_fileCopyStatus_fileCopyWriteFlashError:
                *foundry_status_p = VAL_snAgImgLoad_flashWriteError;
                break;

            case VAL_fileCopyStatus_fileCopyFileNotFound:
                *foundry_status_p = VAL_snAgImgLoad_tftpRemoteNoFile;
                break;

            case VAL_fileCopyStatus_fileCopyServerPermissionDenied:
                *foundry_status_p = VAL_snAgImgLoad_tftpRemoteBadAccess;
                break;

            case VAL_fileCopyStatus_fileCopyStorageFull:
                *foundry_status_p = VAL_snAgImgLoad_tftpRemoteDiskFull;
                break;

            case VAL_fileCopyStatus_fileCopyConnectError:
                *foundry_status_p = VAL_snAgImgLoad_tftpRemoteBadAccess;
                break;

            case VAL_fileCopyStatus_fileCopyFileUnavailable:
                *foundry_status_p = VAL_snAgImgLoad_tftpRemoteNoFile;
                break;

            case VAL_fileCopyStatus_fileCopyTimeout:
                *foundry_status_p = VAL_snAgImgLoad_tftpTimeoutError;
                break;

            case VAL_fileCopyStatus_fileCopyProjectIdError:
                *foundry_status_p = VAL_snAgImgLoad_tftpWrongFileType;  /* 23 */
                break;

            case VAL_fileCopyStatus_fileCopyFileNumExceed:
                *foundry_status_p = VAL_snAgImgLoad_flashWriteError;
                break;

            default:
                *foundry_status_p = VAL_snAgImgLoad_operationError;
        }
    }

    /* return
     */
    return ret;
}

/* ------------------------------------------------------------------------
 * FUNCTION NAME - do_snAgImgLoad
 * ------------------------------------------------------------------------
 * PURPOSE  :   Action routine for get/set of snAgImgLoad.
 *
 * INPUT    :   Code-generated standard input.
 *
 * OUTPUT   :   Code-generated standard output.
 *
 * RETURN   :   Code-generated standard return.
 *
 * NOTES    :   This functions calls subroutines for each "set-value" case.
 * ------------------------------------------------------------------------
 */
int do_snAgImgLoad(netsnmp_mib_handler *handler,
    netsnmp_handler_registration *reginfo,
    netsnmp_agent_request_info *reqinfo,
    netsnmp_request_info *requests)
{
    /* dispatch get vs. set
     */
    switch (reqinfo->mode)
    {
        /* GET REQUEST
         */
        case MODE_GET:
        {
            UI32_T var_len = 0;
            XFER_MGR_FileCopyMgt_T entry;

            /* get from core layer
             */
            if (! XFER_PMGR_GetFileCopyMgtEntry(&entry))
            {
                return SNMP_ERR_GENERR;
            }

            /* compose to user value
             */

            /* copying:
             * reply loading(18), not the error response tftpBusy(8)
             */
            if (entry.action == VAL_fileCopyAction_copy)
            {
                long_return = VAL_snAgImgLoad_loading;
            }

            /* finished, read success/error:
             * may mean error from operating this variable or another copy
             */
            else
            {
                /* check whether maps to normal
                 */
                if (do_snAgent_ConvertAcctonToFoundryFileCopyStatus_IsNormal(entry.status))
                {
                    long_return = VAL_snAgImgLoad_normal;
                }

                /* check whether maps to error
                 */
                else if (do_snAgImgLoad_ConvertAcctonToFoundryError(entry.status,
                    (UI32_T *) &long_return))
                {
                    /* already collected in "long_return";
                     * nothing to do
                     */
                }

                /* unrecognised success/error code from core layer
                 *
                 * If this happens, it means:
                 * 1. new status code not recognised by this mapping;
                 * 2. bug is core layer
                 */
                else
                {
                    long_return = 0;
                }
            }

            /* succeeded; reply to user
             */
            var_len = sizeof(UI32_T);
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                (u_char *) &long_return, var_len);

            break;
        }

        /* SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            /* check type and length
             */
            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
                return SNMP_ERR_NOERROR;
            }

            break;

        case MODE_SET_RESERVE2:
            switch (*requests->requestvb->val.integer)
            {
                case VAL_snAgImgLoad_normal:  /* ignore write */
                    break;

                case VAL_snAgImgLoad_flashPrepareReadFailure:
                case VAL_snAgImgLoad_flashReadError:
                case VAL_snAgImgLoad_flashPrepareWriteFailure:
                case VAL_snAgImgLoad_flashWriteError:
                case VAL_snAgImgLoad_tftpTimeoutError:
                case VAL_snAgImgLoad_tftpOutOfBufferSpace:
                case VAL_snAgImgLoad_tftpBusy:
                case VAL_snAgImgLoad_tftpRemoteOtherErrors:
                case VAL_snAgImgLoad_tftpRemoteNoFile:
                case VAL_snAgImgLoad_tftpRemoteBadAccess:
                case VAL_snAgImgLoad_tftpRemoteDiskFull:
                case VAL_snAgImgLoad_tftpRemoteBadOperation:
                case VAL_snAgImgLoad_tftpRemoteBadId:
                case VAL_snAgImgLoad_tftpRemoteFileExists:
                case VAL_snAgImgLoad_tftpRemoteNoUser:
                case VAL_snAgImgLoad_operationError:
                case VAL_snAgImgLoad_loading:
                    netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
                    return SNMP_ERR_NOERROR;

                case VAL_snAgImgLoad_uploadMPPrimary:
                case VAL_snAgImgLoad_downloadMPPrimary:
                case VAL_snAgImgLoad_uploadMPSecondary:
                case VAL_snAgImgLoad_downloadMPSecondary:
                    break;

                case VAL_snAgImgLoad_tftpWrongFileType:
                case VAL_snAgImgLoad_downloadSPPrimary:
                case VAL_snAgImgLoad_downloadSPSecondary:
                case VAL_snAgImgLoad_uploadMPBootROM:
                case VAL_snAgImgLoad_downloadMPBootROM:
                case VAL_snAgImgLoad_uploadMPBootTFTP:
                case VAL_snAgImgLoad_downloadMPBootTFTP:
                case VAL_snAgImgLoad_uploadMPMonitor:
                case VAL_snAgImgLoad_downloadMPMonitor:
                case VAL_snAgImgLoad_downloadSPBootROM:
                default:
                    netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
                    return SNMP_ERR_NOERROR;
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called.
             */
            break;

        case MODE_SET_ACTION:
        {
            int err = SNMP_ERR_NOERROR;  /* "int" by Net-SNMP, not UI32_T */

            /* dispatch user action
             */
            switch (*requests->requestvb->val.integer)
            {
                case VAL_snAgImgLoad_normal:  /* ignore write */
                    break;

                case VAL_snAgImgLoad_uploadMPPrimary:
                    err = do_snAgImgLoad_set_uploadMPPrimary();
                    break;

                case VAL_snAgImgLoad_downloadMPPrimary:
                    err = do_snAgImgLoad_set_downloadMPPrimary();
                    break;

                case VAL_snAgImgLoad_uploadMPSecondary:
                    err = do_snAgImgLoad_set_uploadMPSecondary();
                    break;

                case VAL_snAgImgLoad_downloadMPSecondary:
                    err = do_snAgImgLoad_set_downloadMPSecondary();
                    break;

                default:
                    netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
                    return SNMP_ERR_NOERROR;
            }

            /* pass error code
             */
            if (err != SNMP_ERR_NOERROR)
            {
                netsnmp_set_request_error(reqinfo, requests, err);
                return SNMP_ERR_NOERROR;
            }

            break;
        }

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

/*--------------------------------------------------------------------------
 * SCALAR NAME - 1.1.2.1 snAgentGbl.snAgCfgLoad(9)
 *--------------------------------------------------------------------------
 */
void init_snAgCfgLoad(void)
{
    static oid snAgCfgLoad_oid[] = { 1,3,6,1,4,1,1991,1,1,2,1,9, 0 };

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("snAgCfgLoad",
                               do_snAgCfgLoad,
                               snAgCfgLoad_oid,
                               OID_LENGTH(snAgCfgLoad_oid),
                               HANDLER_CAN_RWRITE));
}

/* ------------------------------------------------------------------------
 * FUNCTION NAME - do_snAgCfgLoad_set_uploadFromFlashToServer
 * ------------------------------------------------------------------------
 * PURPOSE  :   To set "snAgCfgLoad" to "uploadFromFlashToServer(20)".
 *
 * INPUT    :   None.
 *
 * OUTPUT   :   None.
 *
 * RETURN   :   SNMP_ERR_..., defined in "snmp.h" of Net-SNMP,
 *              used to call "netsnmp_set_request_error".
 *
 * NOTES    :   This function is called from do_snAgImgLoad.
 * ------------------------------------------------------------------------
 */
static int do_snAgCfgLoad_set_uploadFromFlashToServer(void)
{
    int ret = SNMP_ERR_NOERROR;  /* "int" by Net-SNMP, not UI32_T */

    /* action sequence;
     * can re-write as a sequence of "if (! XFER_PMGR(...)) { fail }" if preferred,
     * so that you know which one failed
     */
    if (! (
        XFER_PMGR_SetFileCopySrcOperType(VAL_fileCopySrcOperType_startUpCfg)
        && XFER_PMGR_SetFileCopyDestOperType(VAL_fileCopyDestOperType_tftp)
        && XFER_PMGR_SetFileCopyAction(VAL_fileCopyAction_copy, 0, 0, 0)
        ))
    {
        ret = SNMP_ERR_COMMITFAILED;
    }

    /* return
     */
    return ret;
}

/* ------------------------------------------------------------------------
 * FUNCTION NAME - do_snAgCfgLoad_set_downloadToFlashFromServer
 * ------------------------------------------------------------------------
 * PURPOSE  :   To set "snAgCfgLoad" to "downloadToFlashFromServer(21)".
 *
 * INPUT    :   None.
 *
 * OUTPUT   :   None.
 *
 * RETURN   :   SNMP_ERR_..., defined in "snmp.h" of Net-SNMP,
 *              used to call "netsnmp_set_request_error".
 *
 * NOTES    :   This function is called from do_snAgCfgImgLoad.
 * ------------------------------------------------------------------------
 */
static int do_snAgCfgLoad_set_downloadToFlashFromServer(void)
{
    int ret = SNMP_ERR_NOERROR;  /* "int" by Net-SNMP, not UI32_T */

    char current_startup_ar[SYS_ADPT_FILE_SYSTEM_NAME_LEN + 1];
    const char *new_startup_p = "";

    /*!!PATCH: hardcode this enhancement; will port form EDD (ASF4506B-ZZ)
     */
    const char const *startup1_p = SYS_DFLT_CLI_AUTO_GENERATE_START_UP_FILENAME;
    const char const *startup2_p = "startup2.cfg";

    /* get current startup file name
     */
    if (FS_GetStartupFilename(SYS_VAL_LOCAL_UNIT_ID, FS_FILE_TYPE_CONFIG,
        current_startup_ar) != FS_RETURN_OK)
    {
        ret = SNMP_ERR_COMMITFAILED;
    }

    /* set to core layer
     */
    if (ret == SNMP_ERR_NOERROR)
    {
        /* rotate two startup file names (Brocade MIB does not know file name)
         */
        new_startup_p = startup1_p;

        if (strcmp(current_startup_ar, startup1_p) == 0)
        {
            new_startup_p = startup2_p;
        }

        /* action sequence;
         * can re-write as a sequence of "if (! XFER_PMGR(...)) { fail }" if preferred,
         * so that you know which one failed
         */
        if (! (
            XFER_PMGR_SetFileCopySrcOperType(VAL_fileCopySrcOperType_tftp)
            && XFER_PMGR_SetFileCopyDestOperType(VAL_fileCopyDestOperType_startUpCfg)
            && XFER_PMGR_SetFileCopyDestFileName(new_startup_p)
            && XFER_PMGR_SetFileCopyAction(VAL_fileCopyAction_copy, 0, 0, 0)
            ))
        {
            ret = SNMP_ERR_COMMITFAILED;
        }
    }

    /* return
     */
    return ret;
}

/* ------------------------------------------------------------------------
 * FUNCTION NAME - do_snAgCfgLoad_set_uploadFromDramToServer
 * ------------------------------------------------------------------------
 * PURPOSE  :   To set "snAgCfgLoad" to "uploadFromDramToServer(22)".
 *
 * INPUT    :   None.
 *
 * OUTPUT   :   None.
 *
 * RETURN   :   SNMP_ERR_..., defined in "snmp.h" of Net-SNMP,
 *              used to call "netsnmp_set_request_error".
 *
 * NOTES    :   This function is called from do_snAgCfgImgLoad.
 * ------------------------------------------------------------------------
 */
static int do_snAgCfgLoad_set_uploadFromDramToServer(void)
{
    int ret = SNMP_ERR_NOERROR;  /* "int" by Net-SNMP, not UI32_T */

    /* action sequence;
     * can re-write as a sequence of "if (! XFER_PMGR(...)) { fail }" if preferred,
     * so that you know which one failed
     */
    if (! (
        XFER_PMGR_SetFileCopySrcOperType(VAL_fileCopySrcOperType_runningCfg)
        && XFER_PMGR_SetFileCopyDestOperType(VAL_fileCopyDestOperType_tftp)
        && XFER_PMGR_SetFileCopyAction(VAL_fileCopyAction_copy, 0, 0, 0)
        ))
    {
        ret = SNMP_ERR_COMMITFAILED;
    }

    /* return
     */
    return ret;
}

/* ------------------------------------------------------------------------
 * FUNCTION NAME - do_snAgCfgLoad_set_downloadToDramFromServer
 * ------------------------------------------------------------------------
 * PURPOSE  :   To set "snAgCfgLoad" to "downloadToDramFromServer(23)".
 *
 * INPUT    :   None.
 *
 * OUTPUT   :   None.
 *
 * RETURN   :   SNMP_ERR_..., defined in "snmp.h" of Net-SNMP,
 *              used to call "netsnmp_set_request_error".
 *
 * NOTES    :   This function is called from do_snAgCfgImgLoad.
 * ------------------------------------------------------------------------
 */
static int do_snAgCfgLoad_set_downloadToDramFromServer(void)
{
    int ret = SNMP_ERR_NOERROR;  /* "int" by Net-SNMP, not UI32_T */

    /* action sequence;
     * can re-write as a sequence of "if (! XFER_PMGR(...)) { fail }" if preferred,
     * so that you know which one failed
     */
    if (! (
        XFER_PMGR_SetFileCopySrcOperType(VAL_fileCopySrcOperType_tftp)
        && XFER_PMGR_SetFileCopyDestOperType(VAL_fileCopyDestOperType_runningCfg)
        && XFER_PMGR_SetFileCopyAction(VAL_fileCopyAction_copy, 0, 0, 0)
        ))
    {
        ret = SNMP_ERR_COMMITFAILED;
    }

    /* return
     */
    return ret;
}

/* ------------------------------------------------------------------------
 * FUNCTION NAME - do_snAgCfgLoad_ConvertAcctonToFoundryError
 * ------------------------------------------------------------------------
 * PURPOSE  :   Maps error from Accton code to Foundray code for snAgCfgLoad.
 *
 * INPUT    :   accton_status       -- Accton's fileCopyStatus
 *              foundry_status_p    -- pointer to Foundry status
 *
 * OUTPUT   :   *foundry_status_p   -- Foundry status
 *
 * RETURN   :   TRUE    -- maps to error
 *              FALSE   -- does not map to error
 *
 * NOTES    :   This functions is called from do_snAgCfgLoad.
 *              The mapping is not exactly the same as for snAgImgLoad.
 * ------------------------------------------------------------------------
 */
static BOOL_T do_snAgCfgLoad_ConvertAcctonToFoundryError(UI32_T accton_status,
    UI32_T *foundry_status_p)
{
    BOOL_T ret = FALSE;

    /* quick filter: check range first;
     * if in error code range, map error code
     */
    if (do_snAgent_ConvertAcctonToFoundryFileCopyStatus_IsError(accton_status))
    {
        ret = TRUE;

        /* map status code
         *
         * SPECIFICATION:
         * See MIB object description of Accton's "fileCopyStatus"
         * and Brocade's "snAgCfgLoad".
         *
         * MAPPING FILE:
         * fileCopyStatus_20111102_NoTracking.xls
         */
        switch (accton_status)
        {
            case VAL_fileCopyStatus_fileCopyTftpIllegalOperation:
                *foundry_status_p = VAL_snAgCfgLoad_tftpRemoteBadOperation;
                break;

            case VAL_fileCopyStatus_fileCopyTftpUnkownTransferId:
                *foundry_status_p = VAL_snAgCfgLoad_tftpRemoteBadId;
                break;

            case VAL_fileCopyStatus_fileCopyTftpFileExisted:
                *foundry_status_p = VAL_snAgCfgLoad_tftpRemoteFileExists;
                break;

            case VAL_fileCopyStatus_fileCopyTftpNoSuchUser:
                *foundry_status_p = VAL_snAgCfgLoad_tftpRemoteNoUser;
                break;

            case VAL_fileCopyStatus_fileCopyBusy:
                *foundry_status_p = VAL_snAgCfgLoad_tftpBusy;
                break;

            case VAL_fileCopyStatus_fileCopyReadFileError:
                *foundry_status_p = VAL_snAgCfgLoad_flashReadError;
                break;

            case VAL_fileCopyStatus_fileCopySetStartupError:
                *foundry_status_p = VAL_snAgCfgLoad_flashWriteError;
                break;

            case VAL_fileCopyStatus_fileCopyFileSizeExceed:
                *foundry_status_p = VAL_snAgCfgLoad_tftpOutOfBufferSpace;
                break;

            case VAL_fileCopyStatus_fileCopyMagicWordError:
            case VAL_fileCopyStatus_fileCopyImageTypeError:
            case VAL_fileCopyStatus_fileCopyHeaderChecksumError:
            case VAL_fileCopyStatus_fileCopyImageChecksumError:
                *foundry_status_p = VAL_snAgCfgLoad_tftpWrongFileType;  /* 29 */
                break;

            case VAL_fileCopyStatus_fileCopyWriteFlashError:
                *foundry_status_p = VAL_snAgCfgLoad_flashWriteError;
                break;

            case VAL_fileCopyStatus_fileCopyFileNotFound:
                *foundry_status_p = VAL_snAgCfgLoad_tftpRemoteNoFile;
                break;

            case VAL_fileCopyStatus_fileCopyServerPermissionDenied:
                *foundry_status_p = VAL_snAgCfgLoad_tftpRemoteBadAccess;
                break;

            case VAL_fileCopyStatus_fileCopyStorageFull:
                *foundry_status_p = VAL_snAgCfgLoad_tftpRemoteDiskFull;
                break;

            case VAL_fileCopyStatus_fileCopyConnectError:
                *foundry_status_p = VAL_snAgCfgLoad_tftpRemoteBadAccess;
                break;

            case VAL_fileCopyStatus_fileCopyFileUnavailable:
                *foundry_status_p = VAL_snAgCfgLoad_tftpRemoteNoFile;
                break;

            case VAL_fileCopyStatus_fileCopyTimeout:
                *foundry_status_p = VAL_snAgCfgLoad_tftpTimeoutError;
                break;

            case VAL_fileCopyStatus_fileCopyProjectIdError:
                *foundry_status_p = VAL_snAgCfgLoad_tftpWrongFileType;
                break;

            case VAL_fileCopyStatus_fileCopyFileNumExceed:
                *foundry_status_p = VAL_snAgCfgLoad_flashWriteError;
                break;

            default:
                *foundry_status_p = VAL_snAgCfgLoad_operationError;
        }
    }

    /* return
     */
    return ret;
}

/* ------------------------------------------------------------------------
 * FUNCTION NAME - do_snAgCfgLoad
 * ------------------------------------------------------------------------
 * PURPOSE  :   Action routien for get/set of snAgCfgLoad.
 *
 * INPUT    :   Code-generated standard input.
 *
 * OUTPUT   :   Code-generated standard output.
 *
 * RETURN   :   Code-generated standard return.
 *
 * NOTES    :   This functions calls subroutines for each "set-value" case.
 * ------------------------------------------------------------------------
 */
int do_snAgCfgLoad(netsnmp_mib_handler *handler,
    netsnmp_handler_registration *reginfo,
    netsnmp_agent_request_info *reqinfo,
    netsnmp_request_info *requests)
{
    /* dispatch get vs. set
     */
    switch (reqinfo->mode)
    {
        /* GET REQUEST
         */
        case MODE_GET:
        {
            UI32_T var_len = 0;
            XFER_MGR_FileCopyMgt_T entry;

            /* get from core layer
             */
            if (! XFER_PMGR_GetFileCopyMgtEntry(&entry))
            {
                return SNMP_ERR_GENERR;
            }

            /* compose to user value
             */

            /* copying:
             * reply loading(18), not the error response tftpBusy(8)
             */
            if (entry.action == VAL_fileCopyAction_copy)
            {
                long_return = VAL_snAgCfgLoad_loading;
            }

            /* finished, read success/error:
             * may mean error from operating this variable or another copy
             */
            else
            {
                /* check whether maps to normal
                 */
                if (do_snAgent_ConvertAcctonToFoundryFileCopyStatus_IsNormal(entry.status))
                {
                    long_return = VAL_snAgCfgLoad_normal;
                }

                /* check whether maps to error
                 */
                else if (do_snAgCfgLoad_ConvertAcctonToFoundryError(entry.status,
                    (UI32_T *) &long_return))
                {
                    /* already collected in "long_return";
                     * nothing to do
                     */
                }

                /* unrecognised success/error code from core layer
                 *
                 * If this happens, it means:
                 * 1. new status code not recognised by this mapping;
                 * 2. bug is core layer
                 */
                else
                {
                    long_return = 0;
                }
            }

            /* succeeded; reply to user
             */
            var_len = sizeof(UI32_T);
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                (u_char *) &long_return, var_len);

            break;
        }

        /* SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            /* check type and length
             */
            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
                return SNMP_ERR_NOERROR;
            }

            break;

        case MODE_SET_RESERVE2:
            switch (*requests->requestvb->val.integer)
            {
                case VAL_snAgCfgLoad_normal:  /* ignore write */
                    break;

                case VAL_snAgCfgLoad_flashPrepareReadFailure:
                case VAL_snAgCfgLoad_flashReadError:
                case VAL_snAgCfgLoad_flashPrepareWriteFailure:
                case VAL_snAgCfgLoad_flashWriteError:
                case VAL_snAgCfgLoad_tftpTimeoutError:
                case VAL_snAgCfgLoad_tftpOutOfBufferSpace:
                case VAL_snAgCfgLoad_tftpBusy:
                case VAL_snAgCfgLoad_tftpRemoteOtherErrors:
                case VAL_snAgCfgLoad_tftpRemoteNoFile:
                case VAL_snAgCfgLoad_tftpRemoteBadAccess:
                case VAL_snAgCfgLoad_tftpRemoteDiskFull:
                case VAL_snAgCfgLoad_tftpRemoteBadOperation:
                case VAL_snAgCfgLoad_tftpRemoteBadId:
                case VAL_snAgCfgLoad_tftpRemoteFileExists:
                case VAL_snAgCfgLoad_tftpRemoteNoUser:
                case VAL_snAgCfgLoad_operationError:
                case VAL_snAgCfgLoad_loading:
                    netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
                    return SNMP_ERR_NOERROR;

                case VAL_snAgCfgLoad_uploadFromFlashToServer:
                case VAL_snAgCfgLoad_downloadToFlashFromServer:
                case VAL_snAgCfgLoad_uploadFromDramToServer:
                case VAL_snAgCfgLoad_downloadToDramFromServer:
                    break;

                case VAL_snAgCfgLoad_uploadFromFlashToNMS:
                case VAL_snAgCfgLoad_downloadToFlashFromNMS:
                case VAL_snAgCfgLoad_uploadFromDramToNMS:
                case VAL_snAgCfgLoad_downloadToDramFromNMS:
                case VAL_snAgCfgLoad_operationDoneWithNMS:
                case VAL_snAgCfgLoad_tftpWrongFileType:
                case VAL_snAgCfgLoad_downloadToDramFromServerOverwrite:
                default:
                    netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
                    return SNMP_ERR_NOERROR;
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called.
             */
            break;

        case MODE_SET_ACTION:
        {
            int err = SNMP_ERR_NOERROR;  /* "int" by Net-SNMP, not UI32_T */

            switch (*requests->requestvb->val.integer)
            {
                case VAL_snAgCfgLoad_normal:  /* ignore write */
                    break;

                case VAL_snAgCfgLoad_uploadFromFlashToServer:
                    err = do_snAgCfgLoad_set_uploadFromFlashToServer();
                    break;

                case VAL_snAgCfgLoad_downloadToFlashFromServer:
                    err = do_snAgCfgLoad_set_downloadToFlashFromServer();
                    break;

                case VAL_snAgCfgLoad_uploadFromDramToServer:
                    err = do_snAgCfgLoad_set_uploadFromDramToServer();
                    break;

                case VAL_snAgCfgLoad_downloadToDramFromServer:
                    err = do_snAgCfgLoad_set_downloadToDramFromServer();
                    break;

                default:
                    netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
                    return SNMP_ERR_NOERROR;
            }

            /* pass error code
             */
            if (err != SNMP_ERR_NOERROR)
            {
                netsnmp_set_request_error(reqinfo, requests, err);
                return SNMP_ERR_NOERROR;
            }

            break;
        }

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

/* ------------------------------------------------------------------------
 * SCALAR NAME - 1.1.2.1 snAgentGbl.snAgDefGwayIp(10)
 * ------------------------------------------------------------------------
 */
void init_snAgDefGwayIp(void)
{
    static oid snAgDefGwayIp_oid[] = { 1,3,6,1,4,1,1991,1,1,2,1,10, 0 };

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("snAgDefGwayIp",
                               do_snAgDefGwayIp,
                               snAgDefGwayIp_oid,
                               OID_LENGTH(snAgDefGwayIp_oid),
                               HANDLER_CAN_RWRITE));
}

#if ((SYS_CPNT_ROUTING == TRUE) && (SYS_CPNT_IPV4_ROUTING == TRUE))
/* ------------------------------------------------------------------------
 * FUNCTION NAME - do_snAgDefGwayIp (Layer 3, IPv4 routing)
 * ------------------------------------------------------------------------
 * PURPOSE  :   To do "snAgDefGwayIp" for Layer 3 with IPv4 routing.
 *
 * INPUT    :   standard parameters from code-gen
 *
 * OUTPUT   :   standard output from code-gen
 *
 * RETURN   :   standard return from code-gen
 *
 * NOTES    :   None.
 * ------------------------------------------------------------------------
 */
int do_snAgDefGwayIp(netsnmp_mib_handler *handler,
    netsnmp_handler_registration *reginfo,
    netsnmp_agent_request_info *reqinfo,
    netsnmp_request_info *requests)
{
    /* dispatch get vs. set
     */
    switch (reqinfo->mode)
    {
        /* GET REQUEST
         */
        case MODE_GET:
        {
            /* REFERENCE:
             * SNMP code in IP-FORWARD-MIB.ipCidrRouteTable.(index)ipCidrRouteNextHop
             * at subindexes:
             * ipCidrRouteDest = 0.0.0.0,
             * ipCidrRouteMask = 0.0.0.0,
             * ipCidrRouteTos = 0
             */
            UI32_T var_len = 0;
            NSM_TYPE_IpCidrRouteEntry_T entry_str;
            const UI8_T zero_addr_ar[SYS_TYPE_IPV4_ADDR_LEN] = {0, 0, 0, 0};

            memset(&entry_str, 0, sizeof(NSM_TYPE_IpCidrRouteEntry_T));
            memcpy(entry_str.ip_cidr_route_dest, zero_addr_ar, SYS_TYPE_IPV4_ADDR_LEN);
            memcpy(entry_str.ip_cidr_route_mask, zero_addr_ar, SYS_TYPE_IPV4_ADDR_LEN);
            entry_str.ip_cidr_route_tos = 0;
            memcpy(entry_str.ip_cidr_route_next_hop, zero_addr_ar, SYS_TYPE_IPV4_ADDR_LEN);

            /* get from core layer; must still be at the above-mentioned subindexes
             */
            if (! (
                (NSM_PMGR_SnmpGetNextRoute(&entry_str) == NSM_TYPE_RESULT_OK)
                && (memcmp(entry_str.ip_cidr_route_dest, zero_addr_ar, SYS_TYPE_IPV4_ADDR_LEN) == 0)
                && (memcmp(entry_str.ip_cidr_route_mask, zero_addr_ar, SYS_TYPE_IPV4_ADDR_LEN) == 0)
                && (entry_str.ip_cidr_route_tos == 0)
                ))
            {
                /* none; give zero IP address
                 */
                long_return = 0;
            }
            else
            {
                /* obtained, give to user
                 */
                IP_LIB_ArraytoUI32(entry_str.ip_cidr_route_next_hop, (UI32_T *) &long_return);
            }

            /* reply to user
             */
            var_len = sizeof(UI32_T);
            snmp_set_var_typed_value(requests->requestvb, ASN_IPADDRESS,
                (u_char *) &long_return, var_len);

            break;
        }

        /* SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            /* check type and length
             */
            if (requests->requestvb->type != ASN_IPADDRESS)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
                return SNMP_ERR_NOERROR;
            }

            break;

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called.
             */
            break;

        case MODE_SET_ACTION:
        {
            /* REFERENCE:
             * SNMP code in IP-FORWARD-MIB.ipCidrRouteTable.ipCidrRouteStatus
             * at subindexes:
             * ipCidrRouteDest = 0.0.0.0,
             * ipCidrRouteMask = 0.0.0.0,
             * ipCidrRouteTos = 0, <- not supported in core layer
             * ipCidrRouteNextHop = user value
             */
            NSM_TYPE_IpCidrRouteEntry_T entry_str;
            const UI8_T zero_addr_ar[SYS_TYPE_IPV4_ADDR_LEN] = {0, 0, 0, 0};

            memset(&entry_str, 0, sizeof(NSM_TYPE_IpCidrRouteEntry_T));

            /* prepare indexes
             */
            memcpy(entry_str.ip_cidr_route_dest, zero_addr_ar, SYS_TYPE_IPV4_ADDR_LEN);
            memcpy(entry_str.ip_cidr_route_mask, zero_addr_ar, SYS_TYPE_IPV4_ADDR_LEN);
            IP_LIB_UI32toArray(*requests->requestvb->val.integer, entry_str.ip_cidr_route_next_hop);

            /* prepare value
             */
            entry_str.ip_cidr_route_status = VAL_ipCidrRouteStatus_createAndGo;
            entry_str.ip_cidr_route_set_mask |= NSM_TYPE_SNMP_SET_IPCIDRTABLE_ROWSTATUS;

            /* create in core layer (overwrites existing gateway)
             */
            if (NSM_PMGR_SnmpSetRoute(&entry_str) != NSM_TYPE_RESULT_OK)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
                return SNMP_ERR_NOERROR;
            }

            break;
        }

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

#else  /* #if ((SYS_CPNT_ROUTING == TRUE) && (SYS_CPNT_IPV4_ROUTING == TRUE)) ... #else */
/* ------------------------------------------------------------------------
 * FUNCTION NAME - do_snAgDefGwayIp (not: Layer 3, IPv4 routing)
 * ------------------------------------------------------------------------
 * PURPOSE  :   To do "snAgDefGwayIp" for no "Layer 3 and IPv4 routing".
 *
 * INPUT    :   standard parameters from code-gen
 *
 * OUTPUT   :   standard output from code-gen
 *
 * RETURN   :   standard return from code-gen
 *
 * NOTES    :   None.
 * ------------------------------------------------------------------------
 */
int do_snAgDefGwayIp(netsnmp_mib_handler *handler,
    netsnmp_handler_registration *reginfo,
    netsnmp_agent_request_info *reqinfo,
    netsnmp_request_info *requests)
{
    /* dispatch get vs. set
     */
    switch (reqinfo->mode)
    {
        /* GET REQUEST
         */
        case MODE_GET:
        {
            UI32_T var_len = 0;
            L_INET_AddrIp_T default_gateway;

            /* this variable is for IPv4
             */
            default_gateway.type = L_INET_ADDR_TYPE_IPV4;

            /* get from core layer (Layer 2)
             */
            if (NETCFG_PMGR_ROUTE_GetDefaultGateway(&default_gateway) != NETCFG_TYPE_OK)
            {
                return SNMP_ERR_GENERR;
            }
            else
            {
                /* IPv4: convert array to network order
                 */
                IP_LIB_ArraytoUI32(default_gateway.addr, &long_return);

                var_len = sizeof(UI32_T);
                snmp_set_var_typed_value(requests->requestvb, ASN_IPADDRESS,
                    (u_char *) &long_return, var_len);
            }

            break;
        }

        /* SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            /* check type and length
             */
            if (requests->requestvb->type != ASN_IPADDRESS)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
                return SNMP_ERR_NOERROR;
            }

            break;

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called.
             */
            break;

        case MODE_SET_ACTION:
        {
            L_INET_AddrIp_T default_gateway;

            memset(&default_gateway, 0, sizeof(default_gateway));
            default_gateway.type = L_INET_ADDR_TYPE_IPV4;

            /* IPv4: convert host order to network order
             */
            IP_LIB_UI32toArray(*requests->requestvb->val.integer, default_gateway.addr);

            /* set to core layer (Layer 2)
             */
            if (NETCFG_PMGR_ROUTE_AddDefaultGateway(&default_gateway, SYS_DFLT_DEFAULT_GATEWAY_METRIC)
                != NETCFG_TYPE_OK)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
                return SNMP_ERR_NOERROR;
            }

            break;
        }

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
#endif  /* #if ((SYS_CPNT_ROUTING == TRUE) && (SYS_CPNT_IPV4_ROUTING == TRUE)) ... #else ... */

/* ------------------------------------------------------------------------
 * SCALAR NAME - 1.1.2.1 snAgentGbl.snAgImgVer(11)
 * SCALAR NAME - 1.1.2.1 snAgentGbl.snAgBuildVer(49)
 * ------------------------------------------------------------------------
 */
void init_snAgImgVer(void)
{
    /* Accton has only a "software (firmware) version".
     * Hard-code this to register both nodes to the same routine, for now.
     */
    static oid snAgImgVer_oid[] = { 1,3,6,1,4,1,1991,1,1,2,1,11, 0 };
    static oid snAgBuildVer_oid[] = { 1,3,6,1,4,1,1991,1,1,2,1,49, 0 };

    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("snAgImgVer",
                                         get_snAgImgVer,  /* also used below */
                                         snAgImgVer_oid,
                                         OID_LENGTH(snAgImgVer_oid),
                                         HANDLER_CAN_RONLY));

    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("snAgBuildVer",
                                         get_snAgImgVer,  /* uses the above */
                                         snAgBuildVer_oid,
                                         OID_LENGTH(snAgBuildVer_oid),
                                         HANDLER_CAN_RONLY));
}

int get_snAgImgVer(netsnmp_mib_handler *handler,
    netsnmp_handler_registration *reginfo,
    netsnmp_agent_request_info *reqinfo,
    netsnmp_request_info *requests)
{
    /* dispatch get vs. set
     */
    switch (reqinfo->mode)
    {
        /* GET REQUEST
         */
        case MODE_GET:
        {
            UI32_T var_len = 0;
            UI32_T unit;
            STKTPLG_MGR_Switch_Info_T entry;

            /* this is a per-unit attribute;
             * for stacking, assume master
             */
            STKTPLG_POM_GetMyUnitID(&unit);

            /* get from core layer
             */
            entry.sw_unit_index = unit;

            if (! STKTPLG_PMGR_GetSwitchInfo(&entry))
            {
                return SNMP_ERR_GENERR;
            }
            else
            {
                strncpy((char *) return_buf, (char *) entry.sw_opcode_ver,
                    SYS_ADPT_FW_VER_STR_LEN);
                return_buf[SYS_ADPT_FW_VER_STR_LEN] = '\0';

                var_len = strlen((char *) return_buf);
                snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                    (u_char *) return_buf, var_len);
            }

            break;
        }

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

/* ------------------------------------------------------------------------
 * SCALAR NAME - 1.1.2.1 snAgentGbl.snAgGblIfIpAddr(13)
 * ------------------------------------------------------------------------
 */
void init_snAgGblIfIpAddr(void)
{
    static oid snAgGblIfIpAddr_oid[] = { 1,3,6,1,4,1,1991,1,1,2,1,13, 0 };

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("snAgGblIfIpAddr",
                               do_snAgGblIfIpAddr,
                               snAgGblIfIpAddr_oid,
                               OID_LENGTH(snAgGblIfIpAddr_oid),
                               HANDLER_CAN_RWRITE));
}

#if (SYS_CPNT_CRAFT_PORT == TRUE)
/* ------------------------------------------------------------------------
 * FUNCTION NAME - do_snAgGblIfIpAddr (Craft Port)
 * ------------------------------------------------------------------------
 * PURPOSE  :   To do "snAgGblIfIpAddr" for Craft Port.
 *
 * INPUT    :   standard parameters from code-gen
 *
 * OUTPUT   :   standard output from code-gen
 *
 * RETURN   :   standard return from code-gen
 *
 * NOTES    :   Code follows CLI "(config-if-craft)#ip address".
 * ------------------------------------------------------------------------
 */
int do_snAgGblIfIpAddr(netsnmp_mib_handler *handler,
    netsnmp_handler_registration *reginfo,
    netsnmp_agent_request_info *reqinfo,
    netsnmp_request_info *requests)
{
    /* dispatch get vs. set
     */
    switch (reqinfo->mode)
    {
        /* GET REQUEST
         */
        case MODE_GET:
        {
            UI32_T var_len = 0;
            NETCFG_TYPE_CraftInetAddress_T craft_addr;

            long_return = 0;
            memset(&craft_addr, 0, sizeof(craft_addr));

            /* get from core layer (if fails, give 0 to user)
             */
            if (NETCFG_POM_IP_GetCraftInterfaceInetAddress(&craft_addr)
                == NETCFG_TYPE_OK)
            {
                IP_LIB_ArraytoUI32(craft_addr.addr.addr, (UI32_T *) &long_return);
            }

            /* reply to user
             */
            var_len = sizeof(UI32_T);
            snmp_set_var_typed_value(requests->requestvb, ASN_IPADDRESS,
                (u_char *) &long_return, var_len);

            break;
        }

        /* SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            /* check type and length
             */
            if (requests->requestvb->type != ASN_IPADDRESS)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
                return SNMP_ERR_NOERROR;
            }

            break;

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called.
             */
            break;

        case MODE_SET_ACTION:
        {
            /* store to temporary storage, and wait for mask
             */
            foundry_sn_agent_ip_addr = *requests->requestvb->val.integer;
            break;
        }

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

#else  /* #if (SYS_CPNT_CRAFT_PORT == TRUE) ... #else */
#if (SYS_CPNT_ROUTING == TRUE)
/* ------------------------------------------------------------------------
 * FUNCTION NAME - do_snAgGblIfIpAddr (no Craft Port; Layer 3)
 * ------------------------------------------------------------------------
 * PURPOSE  :   To do "snAgGblIfIpAddr" for "no Craft Port, and is Layer 3".
 *
 * INPUT    :   standard parameters from code-gen
 *
 * OUTPUT   :   standard output from code-gen
 *
 * RETURN   :   standard return from code-gen
 *
 * NOTES    :   Missing the VLAN concept, this is currently not supported.
 * ------------------------------------------------------------------------
 */
int do_snAgGblIfIpAddr(netsnmp_mib_handler *handler,
    netsnmp_handler_registration *reginfo,
    netsnmp_agent_request_info *reqinfo,
    netsnmp_request_info *requests)
{
    /* dispatch get vs. set
     */
    switch (reqinfo->mode)
    {
        /* GET REQUEST
         */
        case MODE_GET:
        {
            UI32_T var_len = 0;

            /* not supported; return 0
             */
            long_return = 0;
            var_len = sizeof(UI32_T);
            snmp_set_var_typed_value(requests->requestvb, ASN_IPADDRESS,
                (u_char *) &long_return, var_len);

            break;
        }

        /* SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            /* check type and length
             */
            if (requests->requestvb->type != ASN_IPADDRESS)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
                return SNMP_ERR_NOERROR;
            }

            break;

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called.
             */
            break;

        case MODE_SET_ACTION:
        {
            /* not supported; ignore
             */
            break;
        }

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

/* still in: #if (SYS_CPNT_CRAFT_PORT == TRUE) ... #else
 */
#else  /* #if (SYS_CPNT_ROUTING == TRUE) ... #else */
/* ------------------------------------------------------------------------
 * FUNCTION NAME - do_snAgGblIfIpAddr (no Craft Port; Layer 2)
 * ------------------------------------------------------------------------
 * PURPOSE  :   To do "snAgGblIfIpAddr" for "no Craft Port, and is Layer 2".
 *
 * INPUT    :   standard parameters from code-gen
 *
 * OUTPUT   :   standard output from code-gen
 *
 * RETURN   :   standard return from code-gen
 *
 * NOTES    :   Code follows CLI "#show ip interface" and
 *              "(config-if-vlan)#ip address" for layer 2.
 * ------------------------------------------------------------------------
 */
int do_snAgGblIfIpAddr(netsnmp_mib_handler *handler,
    netsnmp_handler_registration *reginfo,
    netsnmp_agent_request_info *reqinfo,
    netsnmp_request_info *requests)
{
    /* dispatch get vs. set
     */
    switch (reqinfo->mode)
    {
        /* GET REQUEST
         */
        case MODE_GET:
        {
            UI32_T var_len = 0;
            NETCFG_TYPE_L3_Interface_T ip_interface;
            NETCFG_TYPE_InetRifConfig_T rif_config;
            UI32_T manage_vid = 0;

            long_return = 0;
            memset(&ip_interface, 0, sizeof(NETCFG_TYPE_L3_Interface_T));

            /* get managaement VLAN
             */
            if (! VLAN_POM_GetManagementVlan(&manage_vid))
            {
                return SNMP_ERR_GENERR;
            }

            /* get Layer 3 interface
             */
            VLAN_VID_CONVERTTO_IFINDEX(manage_vid, ip_interface.ifindex);

            if (NETCFG_POM_IP_GetL3Interface(&ip_interface) != NETCFG_TYPE_OK)
            {
                return SNMP_ERR_GENERR;
            }

            /* get IP address from RIF
             */
            memset(&rif_config, 0, sizeof(rif_config));
            memset(rif_config.addr.addr, 0, SYS_TYPE_IPV4_ADDR_LEN);
            rif_config.addr.type = L_INET_ADDR_TYPE_IPV4;
            rif_config.ifindex = ip_interface.ifindex;

            while (NETCFG_POM_IP_GetNextInetRifOfInterface(&rif_config) == NETCFG_TYPE_OK)
            {
                /* not found
                 */
                if ((rif_config.addr.type != L_INET_ADDR_TYPE_IPV4)
                    && (rif_config.addr.type != L_INET_ADDR_TYPE_IPV4Z))
                {
                    break;
                }

                /* found
                 */
                IP_LIB_ArraytoUI32(rif_config.addr.addr, (UI32_T *) &long_return);
                break;
            }

            var_len = sizeof(UI32_T);
            snmp_set_var_typed_value(requests->requestvb, ASN_IPADDRESS,
                (u_char *) &long_return, var_len);

            break;
        }

        /* SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            /* check type and length
             */
            if (requests->requestvb->type != ASN_IPADDRESS)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
                return SNMP_ERR_NOERROR;
            }

            break;

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called.
             */
            break;

        case MODE_SET_ACTION:
        {
            /* store to temporary storage, and wait for mask
             */
            foundry_sn_agent_ip_addr = *requests->requestvb->val.integer;
            break;
        }

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
#endif  /* #if (SYS_CPNT_ROUTING == TRUE) ... #else ... */
#endif  /* #if (SYS_CPNT_CRAFT_PORT == TRUE) ... #else ... */

/* ------------------------------------------------------------------------
 * SCALAR NAME - 1.1.2.1 snAgentGbl.snAgGblIfIpMask(14)
 * ------------------------------------------------------------------------
 */
void init_snAgGblIfIpMask(void)
{
    static oid snAgGblIfIpMask_oid[] = { 1,3,6,1,4,1,1991,1,1,2,1,14, 0 };

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("snAgGblIfIpMask",
                               do_snAgGblIfIpMask,
                               snAgGblIfIpMask_oid,
                               OID_LENGTH(snAgGblIfIpMask_oid),
                               HANDLER_CAN_RWRITE));
}

#if (SYS_CPNT_CRAFT_PORT == TRUE)
/* ------------------------------------------------------------------------
 * FUNCTION NAME - do_snAgGblIfIpMask (Craft Port)
 * ------------------------------------------------------------------------
 * PURPOSE  :   To do "snAgGblIfIpMask" for Craft Port.
 *
 * INPUT    :   standard parameters from code-gen
 *
 * OUTPUT   :   standard output from code-gen
 *
 * RETURN   :   standard return from code-gen
 *
 * NOTES    :   Code follows CLI "(config-if-craft)#ip address".
 * ------------------------------------------------------------------------
 */
int do_snAgGblIfIpMask(netsnmp_mib_handler *handler,
    netsnmp_handler_registration *reginfo,
    netsnmp_agent_request_info *reqinfo,
    netsnmp_request_info *requests)
{
    /* dispatch get vs. set
     */
    switch (reqinfo->mode)
    {
        /* GET REQUEST
         */
        case MODE_GET:
        {
            /* REFERENCE:
             * CLI code in "ip address" in craft interface mode.
             */
            UI32_T var_len = 0;
            NETCFG_TYPE_CraftInetAddress_T craft_addr;
            UI8_T mask_ar[SYS_TYPE_IPV4_ADDR_LEN];

            long_return = 0;
            memset(&craft_addr, 0, sizeof(craft_addr));

            /* get from core layer (if fails, give 0 to user)
             */
            if (NETCFG_POM_IP_GetCraftInterfaceInetAddress(&craft_addr)
                == NETCFG_TYPE_OK)
            {
                IP_LIB_CidrToMask(craft_addr.addr.preflen, mask_ar);
                IP_LIB_ArraytoUI32(mask_ar, (UI32_T *) &long_return);
            }

            /* reply to user
             */
            var_len = sizeof(UI32_T);
            snmp_set_var_typed_value(requests->requestvb, ASN_IPADDRESS,
                (u_char *) &long_return, var_len);

            break;
        }

        /* SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            /* check type and length
             */
            if (requests->requestvb->type != ASN_IPADDRESS)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
                return SNMP_ERR_NOERROR;
            }

            break;

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called.
             */
            break;

        case MODE_SET_ACTION:
        {
            /* REFERENCE:
             * CLI code in "ip address" in craft interface mode.
             */
            UI8_T addr_ar[SYS_TYPE_IPV4_ADDR_LEN],
                  mask_ar[SYS_TYPE_IPV4_ADDR_LEN],
                  bcast_addr_ar[SYS_TYPE_IPV4_ADDR_LEN],
                  network_id_ar[SYS_TYPE_IPV4_ADDR_LEN];
            NETCFG_TYPE_CraftInetAddress_T craft_addr;

            /* collect user variables
             */
            IP_LIB_UI32toArray(foundry_sn_agent_ip_addr, addr_ar);
            IP_LIB_UI32toArray(*requests->requestvb->val.integer, mask_ar);

            /* prepare IPv4 address and mask, etc.
             */
            craft_addr.addr.type = L_INET_ADDR_TYPE_IPV4;
            memcpy(craft_addr.addr.addr, addr_ar, SYS_TYPE_IPV4_ADDR_LEN);
            craft_addr.addr.preflen = IP_LIB_MaskToCidr(mask_ar);

            /*!!SIMBA: In the future, when porting to Simba on latest branch,
             * use CLI "(config-if)#ip address" as a model, and change
             * all these checks to call IP_LIB_IsValidForCIDRNetworkInterface.
             */
            if (! IP_LIB_IsValidForNetworkInterface(craft_addr.addr.addr))
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
                return SNMP_ERR_NOERROR;
            }

            /* check ip_address, ip_mask,
            * 1. must be either class A, class B, or class C
            * 2. can't be network b'cast ip or network id
            * 3. can't be loop back ip
            * 4. can't be b'cast ip
            * 5. can't be m'cast ip
            */
            if ((IP_LIB_IsIpInClassD(craft_addr.addr.addr) == TRUE)
                || (IP_LIB_IsIpInClassE(craft_addr.addr.addr) == TRUE)
                || (IP_LIB_IsLoopBackIp(craft_addr.addr.addr) == TRUE)
                || (IP_LIB_IsBroadcastIp(craft_addr.addr.addr) == TRUE)
                || (IP_LIB_IsMulticastIp(craft_addr.addr.addr) == TRUE)
                || (IP_LIB_IsTestingIp(craft_addr.addr.addr) == TRUE)
                || (IP_LIB_IsZeroNetwork(craft_addr.addr.addr) == TRUE)
              )
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
                return SNMP_ERR_NOERROR;
            }

            if (IP_LIB_GetSubnetBroadcastIp(craft_addr.addr.addr, mask_ar, bcast_addr_ar)
                == IP_LIB_OK)
            {
                if (memcmp(bcast_addr_ar, craft_addr.addr.addr, SYS_TYPE_IPV4_ADDR_LEN) == 0)
                {
                    netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
                    return SNMP_ERR_NOERROR;
                }
            }

            /* network ID
             */
            IP_LIB_GetNetworkID(craft_addr.addr.addr, mask_ar, network_id_ar);

            if (memcmp(network_id_ar, craft_addr.addr.addr, SYS_TYPE_IPV4_ADDR_LEN) == 0)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
                return SNMP_ERR_NOERROR;
            }

            /* set to core layer (assume user mode address)
             */
            craft_addr.ifindex = SYS_ADPT_CRAFT_INTERFACE_IFINDEX;
            craft_addr.row_status = VAL_netConfigStatus_2_createAndGo;

            if (NETCFG_PMGR_IP_SetCraftInterfaceInetAddress(&craft_addr)
                != NETCFG_TYPE_OK)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
                return SNMP_ERR_NOERROR;
            }

            break;
        }

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

#else  /* #if (SYS_CPNT_CRAFT_PORT == TRUE) ... #else */
#if (SYS_CPNT_ROUTING == TRUE)
/* ------------------------------------------------------------------------
 * FUNCTION NAME - do_snAgGblIfIpMask (no Craft Port; Layer 3)
 * ------------------------------------------------------------------------
 * PURPOSE  :   To do "snAgGblIfIpMask" for "no Craft Port, and is Layer 3".
 *
 * INPUT    :   standard parameters from code-gen
 *
 * OUTPUT   :   standard output from code-gen
 *
 * RETURN   :   standard return from code-gen
 *
 * NOTES    :   Missing the VLAN concept, this is currently not supported.
 * ------------------------------------------------------------------------
 */
int do_snAgGblIfIpMask(netsnmp_mib_handler *handler,
    netsnmp_handler_registration *reginfo,
    netsnmp_agent_request_info *reqinfo,
    netsnmp_request_info *requests)
{
    /* dispatch get vs. set
     */
    switch (reqinfo->mode)
    {
        /* GET REQUEST
         */
        case MODE_GET:
        {
            UI32_T var_len = 0;

            /* not supported; return 0
             */
            long_return = 0;
            var_len = sizeof(UI32_T);
            snmp_set_var_typed_value(requests->requestvb, ASN_IPADDRESS,
                (u_char *) &long_return, var_len);

            break;
        }

        /* SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            /* check type and length
             */
            if (requests->requestvb->type != ASN_IPADDRESS)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
                return SNMP_ERR_NOERROR;
            }

            break;

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called.
             */
            break;

        case MODE_SET_ACTION:
        {
            /* not supported; ignore
             */
            break;
        }

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

/* still in: #if (SYS_CPNT_CRAFT_PORT == TRUE) ... #else
 */
#else  /* #if (SYS_CPNT_ROUTING == TRUE) ... #else */
/* ------------------------------------------------------------------------
 * FUNCTION NAME - do_snAgGblIfIpMask_Rollback_Rif (no Craft Port; Layer 2)
 * ------------------------------------------------------------------------
 * PURPOSE  :   To rollback IP address settings, in case user setting fails.
 *
 * INPUT    :   rif_p           - pointer to RIF structure
 *              address_mode    - adress mode
 *
 * OUTPUT   :   None.
 *
 * RETURN   :   None.
 *
 * NOTES    :   This is called from do_snAgGblIfIpMask if IP setting fails.
 *              Code is copied from CLI_API_Rollback_Rif.
 * ------------------------------------------------------------------------
 */
static void do_snAgGblIfIpMask_Rollback_Rif(NETCFG_TYPE_InetRifConfig_T *rif_p, NETCFG_TYPE_IP_ADDRESS_MODE_T address_mode)
{
    UI32_T vid;
    NETCFG_TYPE_InetRifConfig_T rif_rollback;
    if(rif_p == NULL || rif_p->ifindex ==0)
        return ;
    rif_rollback=*rif_p;
    VLAN_IFINDEX_CONVERTTO_VID(rif_rollback.ifindex,vid);
    if(NETCFG_TYPE_OK!=NETCFG_PMGR_IP_CreateL3If(vid))
        return;
    if(NETCFG_TYPE_OK != NETCFG_PMGR_IP_SetIpAddressMode(rif_rollback.ifindex, address_mode))
        return;
    if(address_mode == NETCFG_TYPE_IP_ADDRESS_MODE_USER_DEFINE)
    {
        switch(rif_rollback.row_status)
        {
            case VAL_netConfigStatus_2_active:
            case VAL_netConfigStatus_2_notInService:
                rif_rollback.row_status = VAL_netConfigStatus_2_createAndGo;
                break;
            case VAL_netConfigStatus_2_notReady:
                rif_rollback.row_status = VAL_netConfigStatus_2_createAndWait;
                break;
            case VAL_netConfigStatus_2_createAndGo:
            case VAL_netConfigStatus_2_createAndWait:
            case VAL_netConfigStatus_2_destroy:
            default:
                return ;
        }
        NETCFG_PMGR_IP_SetInetRif(&rif_rollback, NETCFG_TYPE_IP_CONFIGURATION_TYPE_CLI_WEB);
    }
}

/* ------------------------------------------------------------------------
 * FUNCTION NAME - do_snAgGblIfIpMask (no Craft Port; Layer 2)
 * ------------------------------------------------------------------------
 * PURPOSE  :   To do "snAgGblIfIpMask" for "no Craft Port, and is Layer 2".
 *
 * INPUT    :   standard parameters from code-gen
 *
 * OUTPUT   :   standard output from code-gen
 *
 * RETURN   :   standard return from code-gen
 *
 * NOTES    :   Code follows CLI "#show ip interface" and
 *              "(config-if-vlan)#ip address" for layer 2,
 *              and private MIB "ipCfgMgt" for layer 2.
 * ------------------------------------------------------------------------
 */
int do_snAgGblIfIpMask(netsnmp_mib_handler *handler,
    netsnmp_handler_registration *reginfo,
    netsnmp_agent_request_info *reqinfo,
    netsnmp_request_info *requests)
{
    /* dispatch get vs. set
     */
    switch (reqinfo->mode)
    {
        /* GET REQUEST
         */
        case MODE_GET:
        {
            UI32_T var_len = 0;
            NETCFG_TYPE_L3_Interface_T ip_interface;
            NETCFG_TYPE_InetRifConfig_T rif_config;
            UI32_T manage_vid = 0;
            UI8_T mask_ar[SYS_TYPE_IPV4_ADDR_LEN];

            long_return = 0;
            memset(&ip_interface, 0, sizeof(NETCFG_TYPE_L3_Interface_T));

            /* get management VLAN
             */
            if (! VLAN_POM_GetManagementVlan(&manage_vid))
            {
                return SNMP_ERR_GENERR;
            }

            /* get Layer 3 interface
             */
            VLAN_VID_CONVERTTO_IFINDEX(manage_vid, ip_interface.ifindex);

            if (NETCFG_POM_IP_GetL3Interface(&ip_interface) != NETCFG_TYPE_OK)
            {
                return SNMP_ERR_GENERR;
            }

            /* get IP address from RIF
             */
            memset(&rif_config, 0, sizeof(rif_config));
            memset(rif_config.addr.addr, 0, SYS_TYPE_IPV4_ADDR_LEN);
            rif_config.addr.type = L_INET_ADDR_TYPE_IPV4;
            rif_config.ifindex = ip_interface.ifindex;

            while (NETCFG_POM_IP_GetNextInetRifOfInterface(&rif_config) == NETCFG_TYPE_OK)
            {
                /* not found
                 */
                if ((rif_config.addr.type != L_INET_ADDR_TYPE_IPV4)
                    && (rif_config.addr.type != L_INET_ADDR_TYPE_IPV4Z))
                {
                    break;
                }

                /* found
                 */
                IP_LIB_CidrToMask(rif_config.addr.preflen, mask_ar);
                IP_LIB_ArraytoUI32(mask_ar, (UI32_T *) &long_return);
                break;
            }

            var_len = sizeof(UI32_T);
            snmp_set_var_typed_value(requests->requestvb, ASN_IPADDRESS,
                (u_char *) &long_return, var_len);

            break;
        }

        /* SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            /* check type and length
             */
            if (requests->requestvb->type != ASN_IPADDRESS)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
                return SNMP_ERR_NOERROR;
            }

            break;

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called.
             */
            break;

        case MODE_SET_ACTION:
        {
            UI32_T vid;
            UI8_T addr_ar[SYS_TYPE_IPV4_ADDR_LEN],
                  mask_ar[SYS_TYPE_IPV4_ADDR_LEN];
            NETCFG_TYPE_InetRifConfig_T rif_config;
            NETCFG_TYPE_InetRifConfig_T rif_rollback;
            UI32_T addrmode_rollback = 0;
            UI32_T netcfg_ret;

            /* collect user variables
             */
            IP_LIB_UI32toArray(foundry_sn_agent_ip_addr, addr_ar);
            IP_LIB_UI32toArray(*requests->requestvb->val.integer, mask_ar);

            /* get management VLAN
             */
            memset(&rif_rollback, 0, sizeof(rif_rollback));

            if (VLAN_POM_GetManagementVlan(&vid))
            {
                VLAN_VID_CONVERTTO_IFINDEX(vid, rif_rollback.ifindex);
                NETCFG_POM_IP_GetPrimaryRifFromInterface(&rif_rollback);
                NETCFG_POM_IP_GetIpAddressMode(rif_rollback.ifindex, &addrmode_rollback);
            }
            else
            {
                vid = 1;  /* assume */
            }

            /* prepare IP address and mask, etc.
             */
            memset(&rif_config, 0, sizeof(rif_config));
            VLAN_VID_CONVERTTO_IFINDEX(vid, rif_config.ifindex);
            rif_config.ipv4_role = NETCFG_TYPE_MODE_PRIMARY;  /* default */
            rif_config.row_status = VAL_netConfigStatus_2_createAndGo;

            rif_config.addr.type = L_INET_ADDR_TYPE_IPV4;
            rif_config.addr.addrlen = SYS_TYPE_IPV4_ADDR_LEN;
            memcpy(rif_config.addr.addr, addr_ar, SYS_TYPE_IPV4_ADDR_LEN);

            if (! IP_LIB_IsValidNetworkMask(mask_ar))
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
                return SNMP_ERR_NOERROR;
            }

            rif_config.addr.preflen = IP_LIB_MaskToCidr(mask_ar);

            /*!!SIMBA: In the future, when porting to Simba on latest branch,
             * use CLI "(config-if)#ip address" as a model, and change
             * all these checks to call IP_LIB_IsValidForCIDRNetworkInterface.
             */
            if (! IP_LIB_IsValidForNetworkInterface(rif_config.addr.addr))
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
                return SNMP_ERR_NOERROR;
            }

            /* set to core layer (assume user mode address)
             */
            if (NETCFG_PMGR_IP_SetIpAddressMode(rif_config.ifindex,
                NETCFG_TYPE_IP_ADDRESS_MODE_USER_DEFINE) != NETCFG_TYPE_OK)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
                return SNMP_ERR_NOERROR;
            }
            else
            {
                /* is SNMP; assume CLI/Web
                 */
                netcfg_ret = NETCFG_PMGR_IP_SetInetRif(&rif_config, NETCFG_TYPE_IP_CONFIGURATION_TYPE_CLI_WEB);

                if (netcfg_ret != NETCFG_TYPE_OK)
                {
                    /* Rollback RIF, follows CLI_API_Rollback_Rif
                     */
                    do_snAgGblIfIpMask_Rollback_Rif(&rif_rollback, addrmode_rollback);

                    /* reply error
                     */
                    netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
                    return SNMP_ERR_NOERROR;
                }
            }

            break;
        }

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
#endif  /* #if (SYS_CPNT_ROUTING == TRUE) ... #else ... */
#endif  /* #if (SYS_CPNT_CRAFT_PORT == TRUE) ... #else ... */

#if (SYS_CPNT_SNMP_CONTIGUOUS_TRAP_DEST_TABLE == TRUE)
/* ------------------------------------------------------------------------
 * SCALAR NAME - 1.1.2.1 snAgentGbl.snAgTrpRcvrCurEntry(16)
 * ------------------------------------------------------------------------
 */
void init_snAgTrpRcvrCurEntry(void)
{
    static oid snAgTrpRcvrCurEntry_oid[] = { 1,3,6,1,4,1,1991,1,1,2,1,16, 0 };

    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("snAgTrpRcvrCurEntry",
                                         get_snAgTrpRcvrCurEntry,
                                         snAgTrpRcvrCurEntry_oid,
                                         OID_LENGTH(snAgTrpRcvrCurEntry_oid),
                                         HANDLER_CAN_RONLY));
}

int get_snAgTrpRcvrCurEntry(netsnmp_mib_handler *handler,
    netsnmp_handler_registration *reginfo,
    netsnmp_agent_request_info *reqinfo,
    netsnmp_request_info *requests)
{
    /* dispatch get vs. set
     */
    switch (reqinfo->mode)
    {
        /* GET REQUEST
         */
        case MODE_GET:
        {
            UI32_T var_len = 0;

            /* get from core layer
             */
            if (SNMP_MGR_GetTotalTrapReceiverByIndex((UI32_T *) &long_return)
                != SNMP_MGR_ERROR_OK)
            {
                return SNMP_ERR_GENERR;
            }
            else
            {
                var_len = sizeof(UI32_T);
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                    (u_char *) &long_return, var_len);
            }

            break;
        }

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
#endif  /* (SYS_CPNT_SNMP_CONTIGUOUS_TRAP_DEST_TABLE == TRUE) */

#if (SYS_CPNT_TELNET == TRUE)
/* ------------------------------------------------------------------------
 * SCALAR NAME - 1.1.2.1 snAgentGbl.snAgGblTelnetTimeout(37)
 * ------------------------------------------------------------------------
 */
void init_snAgGblTelnetTimeout(void)
{
    static oid snAgGblTelnetTimeout_oid[] = { 1,3,6,1,4,1,1991,1,1,2,1,37, 0 };

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("snAgGblTelnetTimeout",
                               do_snAgGblTelnetTimeout,
                               snAgGblTelnetTimeout_oid,
                               OID_LENGTH(snAgGblTelnetTimeout_oid),
                               HANDLER_CAN_RWRITE));
}

int do_snAgGblTelnetTimeout(netsnmp_mib_handler *handler,
    netsnmp_handler_registration *reginfo,
    netsnmp_agent_request_info *reqinfo,
    netsnmp_request_info *requests)
{
    /* dispatch get vs. set
     */
    switch (reqinfo->mode)
    {
        /* GET REQUEST
         */
        case MODE_GET:
        {
            UI32_T var_len = 0;
            SYS_MGR_Telnet_T entry;

            /* get from core layer (seconds or 0)
             */
            if (! SYS_PMGR_GetTelnetCfg(&entry))
            {
                 return SNMP_ERR_GENERR;
            }
            else
            {
                /* convert core-layer value (seconds or 0) to user value (minutes or 0),
                 * ignoring loss in precision;
                 *
                 * round up to avoid "30 seconds" being displayed as "0 minute"
                 */
                long_return = (entry.inactive_timeout + 59) / 60;

                var_len = sizeof(UI32_T);
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                    (u_char *) &long_return, var_len);
            }

            break;
        }

        /* SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            /* check type and length
             */
            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
                return SNMP_ERR_NOERROR;
            }

            break;

        case MODE_SET_RESERVE2:
            /* user value: minutes or 0; core-layer value: seconds or 0
             *
             * maximum value (if not multiple of 60 seconds), maps to Accton maximum
             * (if not multiple of 60 seconds)
             */
            if ((*requests->requestvb->val.integer * 60 < SYS_ADPT_TELNET_INACTIVE_TIMEOUT_MIN)
                || (*requests->requestvb->val.integer * 60 > SYS_ADPT_TELNET_INACTIVE_TIMEOUT_MAX + 59))
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
                return SNMP_ERR_NOERROR;
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called.
             */
            break;

        case MODE_SET_ACTION:
        {
            UI32_T core_val = 0;

            /* convert user value (minutes or 0) to core-layer value (seconds or 0)
             *
             * maximum value (if not multiple of 60 seconds), maps to Accton maximum
             * (if not multiple of 60 seconds)
             */
            core_val = *requests->requestvb->val.integer * 60;

            if (core_val > SYS_ADPT_TELNET_INACTIVE_TIMEOUT_MAX)
            {
                core_val = SYS_ADPT_TELNET_INACTIVE_TIMEOUT_MAX;
            }

            /* set to core layer
             */
            if (! SYS_PMGR_SetTelnetInactiveTimeOut(core_val))
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
                return SNMP_ERR_NOERROR;
            }

            break;
        }

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
#endif  /* (SYS_CPNT_TELNET == TRUE) */

#if (SYS_CPNT_HTTP == TRUE)
/* ------------------------------------------------------------------------
 * SCALAR NAME - 1.1.2.1 snAgentGbl.snAgGblEnableWebMgmt(38)
 * ------------------------------------------------------------------------
 */
void init_snAgGblEnableWebMgmt(void)
{
    static oid snAgGblEnableWebMgmt_oid[] = { 1,3,6,1,4,1,1991,1,1,2,1,38, 0 };

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("snAgGblEnableWebMgmt",
                               do_snAgGblEnableWebMgmt,
                               snAgGblEnableWebMgmt_oid,
                               OID_LENGTH(snAgGblEnableWebMgmt_oid),
                               HANDLER_CAN_RWRITE));
}

int do_snAgGblEnableWebMgmt(netsnmp_mib_handler *handler,
    netsnmp_handler_registration *reginfo,
    netsnmp_agent_request_info *reqinfo,
    netsnmp_request_info *requests)
{
    /* dispatch get vs. set
     */
    switch (reqinfo->mode)
    {
        /* GET REQUEST
         */
        case MODE_GET:
        {
            UI32_T var_len = 0;

            /* get from core layer
             */
            long_return = FOUNDRY_LIB_ConvertAcctonToFoundryEnabledStatus
                (HTTP_PMGR_Get_Http_Status());

            var_len = sizeof(UI32_T);
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                (u_char *) &long_return, var_len);

            break;
        }

        /* SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            /* check type and length
             */
            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
                return SNMP_ERR_NOERROR;
            }

            break;

        case MODE_SET_RESERVE2:
            switch (*requests->requestvb->val.integer)
            {
                case VAL_snAgGblEnableWebMgmt_disabled:
                    break;

                case VAL_snAgGblEnableWebMgmt_enabled:
                    break;

                default:
                    netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
                    return SNMP_ERR_NOERROR;
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called.
             */
            break;

        case MODE_SET_ACTION:
        {
            /* set to core layer
             */
            if (! HTTP_PMGR_Set_Http_Status
                (FOUNDRY_LIB_ConvertFoundryToAcctonEnabledStatus
                    (*requests->requestvb->val.integer) ))
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
                return SNMP_ERR_NOERROR;
            }

            break;
        }

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
#endif  /* (SYS_CPNT_HTTP == TRUE) */

/* ------------------------------------------------------------------------
 * SCALAR NAME - 1.1.2.1 snAgentGbl.snAgSoftwareFeature(41)
 * ------------------------------------------------------------------------
 */
void init_snAgSoftwareFeature(void)
{
    static oid snAgSoftwareFeature_oid[] = { 1,3,6,1,4,1,1991,1,1,2,1,41, 0 };

    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("snAgSoftwareFeature",
                                         get_snAgSoftwareFeature,
                                         snAgSoftwareFeature_oid,
                                         OID_LENGTH(snAgSoftwareFeature_oid),
                                         HANDLER_CAN_RONLY));
}

int get_snAgSoftwareFeature(netsnmp_mib_handler *handler,
    netsnmp_handler_registration *reginfo,
    netsnmp_agent_request_info *reqinfo,
    netsnmp_request_info *requests)
{
    /* dispatch get vs. set
     */
    switch (reqinfo->mode)
    {
        /* GET REQUEST
         */
        case MODE_GET:
        {
            UI32_T var_len = 7;  /* hard-coded; must match the array size (below) */

            /* SPECIFICATION:
             * This object contains "var_len" bytes, with 8 bits each.
             * Octets are counted from position 0, being the earliest octet.
             * Bits are counted from position 0, being the lowest bit.
             * Feature names inside comments are copied from MIB object description.
             *
             * IMPLEMENTATION:
             * Compose "return_buf", based on our understanding of feature names.
             * C-language Booleans evaluate to 0 or 1, and can be used in formulas.
             *
             * If you prefer, you can rewrite this as a pre-initialised
             * byte array (56 bytes) or bitmap (56 bits),
             * and then convert or copy this into "return_buf".
             *
             * MAPPING FILE:
             * sys_cpnt_20110812_NoTracking.xls
             *
             * FUTURE MAINTAINANCE:
             * 1. Follow the appearance of new SYS_CPNT constants in Brocade projects.
             * 2. Sync SYS_CPNT from other projects to Brocade projects, as FALSE.
             * 3. Remember to update the tracking file (above).
             */
            return_buf[0] =
                (((((SYS_CPNT_SNMP_VERSION == 1) || (SYS_CPNT_SNMP_VERSION == 2)) && SYS_CPNT_RMON) || (SYS_CPNT_SNMP_VERSION == 3)) << 0)  /* RMON */
                | (FALSE << 1)  /* ipx switching */
                | (FALSE << 2)  /* server load balancing */
                | (FALSE << 3)  /* layer 3 filter in switch */
                | (FALSE << 4)  /* ipx routing */
                | (FALSE << 5)  /* appletalk routing */

#if (SYS_CPNT_ROUTING == TRUE)  /* SYS_CPNT_SUPPORTING_MULTICAST_ROUTING is defined inside SYS_CPNT_ROUTING */
                | (FALSE << 6)  /* ip multicast routing */
#endif

                | (TRUE << 7);  /* local access control */

            return_buf[1] =

#if (SYS_CPNT_ROUTING == TRUE)  /* SYS_CPNT_BGP is defined inside SYS_CPNT_ROUTING */
                (SYS_CPNT_BGP << 0)  /* BGP routing */
#else
                (FALSE << 0)
#endif

                | (TRUE << 1)  /* loopback interface */
                | (FALSE << 2)  /* BigIron multi-management module */
                | (FALSE << 3)  /* BigIron SYSIF II */
                | (FALSE <<4)  /* BigIron POS support */
                | (FALSE << 5)  /* appletalk cable vlan */

#if (SYS_CPNT_IPV6 == TRUE)  /* SYS_CPNT_IPV6_ROUTING is defined inside SYS_CPNT_IPV6 */
                | (SYS_CPNT_IPV6_ROUTING << 6)  /* 64 subnet */
#endif

                | (TRUE << 7);  /* multi-slot trunk */

            return_buf[2] =
                (SYS_CPNT_TACACS << 0)  /* TACACS */
                | (TRUE << 1)  /* Gigabit Ethernet port auto-negotiation mode */
                | (FALSE << 2)  /* FSRP */
                | (FALSE << 3)  /* Exodus requested OSPF enhancement */
                | (FALSE << 4)  /* OSPF NSSA */
                | (FALSE << 5)  /* POS */
                | (SYS_CPNT_QOS_V2 << 6)  /* QOS */
                | (TRUE << 7);  /* Single Span */

            return_buf[3] =
                (((SYS_CPNT_STP == SYS_CPNT_STP_TYPE_RSTP) || (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_MSTP)) << 0)  /* Fast Span */
                | (SYS_CPNT_ROUTING << 1)  /* Base L3 */
                | (SYS_CPNT_SYSLOG << 2)  /* static log buffer */
                | (FALSE << 3)  /* L2 POS */
                | (FALSE << 4)  /* BI15K */
                | (FALSE << 5)  /* L2 ATM */
                | (FALSE << 6)  /* ATM */
                | (FALSE << 7);  /* NETFLOW */

            return_buf[4] =
                (SYS_CPNT_SFLOW << 0)  /* SFLOW */
                | (SYS_CPNT_LACP << 3)  /* dynamic trunk */
                | (FALSE << 4)  /* IGC 8G */
                | ((SYS_CPNT_INGRESS_RATE_LIMIT || SYS_CPNT_EGRESS_RATE_LIMIT) << 5)  /* rate limit */
                | (FALSE << 6)  /* IPC rate limit */
                | (FALSE << 7);  /* MPLS */

            return_buf[5] =
                (FALSE << 0)  /* ISIS */
                | (TRUE << 1)  /* link aggregation */
                | (TRUE << 2)  /* port dual mode */
                | (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION << 3)  /* private vlan */
                | (FALSE << 4)  /* MBGP */
                | (FALSE << 5)  /* ipv6 protocol vlan */
                | (FALSE << 6)  /* X10G */
                | (FALSE << 7);  /* fastiron edge switch/router (gridiron) */

            return_buf[6] =
                (FALSE << 0)  /* FDP */
                | (FALSE << 1)  /* port tag type */
                | (FALSE << 2)  /* wireless capable */
                | (FALSE << 3)  /* snSwPortVlanId object has changed from read-only to read-write */
                | (SYS_CPNT_LLDP << 4);  /* LLDP */

            /* Future: If more items are added here, remember to update the
             * hard-coded "var_len" (above).
             */

            /* reply to user
             */
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                (u_char *) return_buf, var_len);

            break;
        }

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

/* ------------------------------------------------------------------------
 * SCALAR NAME - 1.1.2.1 snAgentGbl.snAgGblTrapMessage(44)
 * ------------------------------------------------------------------------
 */
void init_snAgGblTrapMessage(void)
{
    static oid snAgGblTrapMessage_oid[] = { 1,3,6,1,4,1,1991,1,1,2,1,44, 0 };

    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("snAgGblTrapMessage",
                                         get_snAgGblTrapMessage,
                                         snAgGblTrapMessage_oid,
                                         OID_LENGTH(snAgGblTrapMessage_oid),
                                         HANDLER_CAN_RONLY));
}

int get_snAgGblTrapMessage(netsnmp_mib_handler *handler,
    netsnmp_handler_registration *reginfo,
    netsnmp_agent_request_info *reqinfo,
    netsnmp_request_info *requests)
{
    /* dispatch get vs. set
     */
    switch (reqinfo->mode)
    {
        /* GET REQUEST
         */
        case MODE_GET:
        {
            UI32_T var_len = 0;

            /* get empty value;
             * return_buf does not need to be filled;
             *
             * SPECIFICATION:
             * This variable is in the MIB file as read-only,
             * but this is used in trap var-binds like a trapVar.
             *
             * IMPLEMENTATION:
             * Brocade (Foundry) lets us to return an empty string.
             */
            var_len = 0;
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                (u_char *) return_buf, var_len);

            break;
        }

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

#if (SYS_CPNT_TELNET == TRUE)
/* ------------------------------------------------------------------------
 * SCALAR NAME - 1.1.2.1 snAgentGbl.snAgGblEnableTelnetServer(45)
 * ------------------------------------------------------------------------
 */
void init_snAgGblEnableTelnetServer(void)
{
    static oid snAgGblEnableTelnetServer_oid[] = { 1,3,6,1,4,1,1991,1,1,2,1,45, 0 };

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("snAgGblEnableTelnetServer",
                               do_snAgGblEnableTelnetServer,
                               snAgGblEnableTelnetServer_oid,
                               OID_LENGTH(snAgGblEnableTelnetServer_oid),
                               HANDLER_CAN_RWRITE));
}

int do_snAgGblEnableTelnetServer(netsnmp_mib_handler *handler,
    netsnmp_handler_registration *reginfo,
    netsnmp_agent_request_info *reqinfo,
    netsnmp_request_info *requests)
{
    /* dispatch get vs. set
     */
    switch (reqinfo->mode)
    {
        /* GET REQUEST
         */
        case MODE_GET:
        {
            UI32_T var_len = 0;
            TELNET_State_T telnetStatus;

            /* get from core layer
             */
            if (! TELNET_PMGR_GetTnpdStatus(&telnetStatus))
            {
                 return SNMP_ERR_GENERR;
            }

            long_return = FOUNDRY_LIB_ConvertAcctonToFoundryEnabledStatus
                ((UI32_T) telnetStatus);

            var_len = sizeof(UI32_T);
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                (u_char *) &long_return, var_len);

            break;
        }

        /* SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            /* check type and length
             */
            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
                return SNMP_ERR_NOERROR;
            }

            break;

        case MODE_SET_RESERVE2:
            switch (*requests->requestvb->val.integer)
            {
                case VAL_snAgGblEnableTelnetServer_disabled:
                    break;

                case VAL_snAgGblEnableTelnetServer_enabled:
                    break;

                default:
                    netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
                    return SNMP_ERR_NOERROR;
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called.
             */
            break;

        case MODE_SET_ACTION:
        {
            /* set to core layer
             */
            if (! TELNET_PMGR_SetTnpdStatus
                (FOUNDRY_LIB_ConvertFoundryToAcctonEnabledStatus
                    (*requests->requestvb->val.integer) ))
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
                return SNMP_ERR_NOERROR;
            }

            break;
        }

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
#endif  /* (SYS_CPNT_TELNET == TRUE) */

/* ------------------------------------------------------------------------
 * SCALAR NAME - 1.1.2.1 snAgentGbl.snAgBuildDate(47)
 * ------------------------------------------------------------------------
 */
void init_snAgBuildDate(void)
{
    static oid snAgBuildDate_oid[] = { 1,3,6,1,4,1,1991,1,1,2,1,47, 0 };

    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("snAgBuildDate",
                                         get_snAgBuildDate,
                                         snAgBuildDate_oid,
                                         OID_LENGTH(snAgBuildDate_oid),
                                         HANDLER_CAN_RONLY));
}

int get_snAgBuildDate(netsnmp_mib_handler *handler,
    netsnmp_handler_registration *reginfo,
    netsnmp_agent_request_info *reqinfo,
    netsnmp_request_info *requests)
{
    /* dispatch get vs. set
     */
    switch (reqinfo->mode)
    {
        /* GET REQUEST
         */
        case MODE_GET:
        {
            UI32_T var_len = 0;
            UI32_T unit;
            STKTPLG_MGR_Switch_Info_T entry;

            /* this is a per-unit attribute;
             * for stacking, assume master
             */
            STKTPLG_POM_GetMyUnitID(&unit);

            /* get from core layer
             */
            entry.sw_unit_index = unit;

            if (! STKTPLG_PMGR_GetSwitchInfo(&entry))
            {
                return SNMP_ERR_GENERR;
            }
            else
            {
                const UI32_T month_day_len = sizeof("Jan  3") - 1;  /* excludes '\0' */
                const UI32_T year_offset = sizeof("Jan  3 15:14:13 ") - 1;
                const UI32_T year_len = sizeof("1988") - 1;

                char time_sz[SIZE_sysCurrentTime + 1];

                /* get fixed-length format: "Jan  3 15:14:13 1988"
                 *
                 * Date-time string :      J|a|n| | |3| |1|5|:| 1| 4| :| 1| 3|  | 1| 9| 8| 8|\0|
                 * Character Position :    0|1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|16|17|18|19|20|
                 */
                SYS_TIME_ConvertTime(entry.sw_software_build_time, time_sz);

                /* convert core-layer value to user value
                 */
                memcpy(return_buf, time_sz, month_day_len);
                return_buf[month_day_len] = ' ';  /* insert space */
                memcpy(return_buf + month_day_len + 1, time_sz + year_offset, year_len);
                return_buf[month_day_len + 1 + year_len] = '\0';  /* end */
                var_len = strlen((char *) return_buf);
                snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                    (u_char *) return_buf, var_len);
            }

            break;
        }

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

/* ------------------------------------------------------------------------
 * SCALAR NAME - 1.1.2.1 snAgentGbl.snAgBuildtime(48)
 * ------------------------------------------------------------------------
 */
void init_snAgBuildtime(void)
{
    static oid snAgBuildtime_oid[] = { 1,3,6,1,4,1,1991,1,1,2,1,48, 0 };

    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("snAgBuildtime",
                                         get_snAgBuildtime,
                                         snAgBuildtime_oid,
                                         OID_LENGTH(snAgBuildtime_oid),
                                         HANDLER_CAN_RONLY));
}

int get_snAgBuildtime(netsnmp_mib_handler *handler,
    netsnmp_handler_registration *reginfo,
    netsnmp_agent_request_info *reqinfo,
    netsnmp_request_info *requests)
{
    /* dispatch get vs. set
     */
    switch (reqinfo->mode)
    {
        /* GET REQUEST
         */
        case MODE_GET:
        {
            UI32_T var_len = 0;
            UI32_T unit;
            STKTPLG_MGR_Switch_Info_T entry;

            /* this is a per-unit attribute;
             * for stacking, assume master
             */
            STKTPLG_POM_GetMyUnitID(&unit);

            /* get from core layer
             */
            entry.sw_unit_index = unit;

            if (! STKTPLG_PMGR_GetSwitchInfo(&entry))
            {
                return SNMP_ERR_GENERR;
            }
            else
            {
                const UI32_T time_of_day_offset = sizeof("Jan  3 ") - 1;  /* excludes '\0' */
                const UI32_T time_of_day_len = sizeof("15:14:13") - 1;

                char time_sz[SIZE_sysCurrentTime + 1];

                /* get fixed-length format: "Jan  3 15:14:13 1988"
                 *
                 * Date-time string :      J|a|n| | |3| |1|5|:| 1| 4| :| 1| 3|  | 1| 9| 8| 8|\0|
                 * Character Position :    0|1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|16|17|18|19|20|
                 */
                SYS_TIME_ConvertTime(entry.sw_software_build_time, time_sz);

                /* convert core-layer value to user value
                 */
                memcpy(return_buf, time_sz + time_of_day_offset, time_of_day_len);
                return_buf[time_of_day_len] = '\0';  /* end */
                var_len = strlen((char *) return_buf);
                snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                    (u_char *) return_buf, var_len);
            }

            break;
        }

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

#if (SYS_CPNT_SYSMGMT_RESMIB == TRUE)
/* ------------------------------------------------------------------------
 * SCALAR NAME - 1.1.2.1 snAgentGbl.snAgGblCpuUtilData(35)
 * SCALAR NAME - 1.1.2.1 snAgentGbl.snAgGblCpuUtil5SecAvg(51)
 * ------------------------------------------------------------------------
 */
void init_snAgGblCpuUtil5SecAvg(void)
{
    /* These two variables are registered to the same routine for
     * snAgGblCpuUtil5SecAvg(51).
     */
    static oid snAgGblCpuUtilData_oid[] = { 1,3,6,1,4,1,1991,1,1,2,1,35, 0 };
    static oid snAgGblCpuUtil5SecAvg_oid[] = { 1,3,6,1,4,1,1991,1,1,2,1,51, 0 };

    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("snAgGblCpuUtilData",
                                         get_snAgGblCpuUtil5SecAvg,  /* uses the below */
                                         snAgGblCpuUtilData_oid,
                                         OID_LENGTH(snAgGblCpuUtilData_oid),
                                         HANDLER_CAN_RONLY));

    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("snAgGblCpuUtil5SecAvg",
                                         get_snAgGblCpuUtil5SecAvg,  /* also used above */
                                         snAgGblCpuUtil5SecAvg_oid,
                                         OID_LENGTH(snAgGblCpuUtil5SecAvg_oid),
                                         HANDLER_CAN_RONLY));
}

int get_snAgGblCpuUtil5SecAvg(netsnmp_mib_handler *handler,
    netsnmp_handler_registration *reginfo,
    netsnmp_agent_request_info *reqinfo,
    netsnmp_request_info *requests)
{
    /* dispatch get vs. set
     */
    switch (reqinfo->mode)
    {
        /* GET REQUEST
         */
        case MODE_GET:
        {
            UI32_T var_len = 0;
            UI32_T usage_flag;

            /* get from core layer
             */
            if (! SYS_PMGR_GetCpuUsagePercentage((UI32_T *) &long_return, &usage_flag))
            {
                return SNMP_ERR_GENERR;
            }
            else
            {
                var_len = sizeof(UI32_T);
                snmp_set_var_typed_value(requests->requestvb, ASN_GAUGE,
                    (u_char *) &long_return, var_len);
            }

            break;
        }

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

/* ------------------------------------------------------------------------
 * SCALAR NAME - 1.1.2.1 snAgentGbl.snAgGblCpuUtil1MinAvg(52)
 * ------------------------------------------------------------------------
 */
void init_snAgGblCpuUtil1MinAvg(void)
{
    static oid snAgGblCpuUtil1MinAvg_oid[] = { 1,3,6,1,4,1,1991,1,1,2,1,52, 0 };

    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("snAgGblCpuUtil1MinAvg",
                                         get_snAgGblCpuUtil1MinAvg,
                                         snAgGblCpuUtil1MinAvg_oid,
                                         OID_LENGTH(snAgGblCpuUtil1MinAvg_oid),
                                         HANDLER_CAN_RONLY));
}

int get_snAgGblCpuUtil1MinAvg(netsnmp_mib_handler *handler,
    netsnmp_handler_registration *reginfo,
    netsnmp_agent_request_info *reqinfo,
    netsnmp_request_info *requests)
{
    /* dispatch get vs. set
     */
    switch (reqinfo->mode)
    {
        /* GET REQUEST
         */
        case MODE_GET:
        {
            UI32_T var_len = 0;

            /* get from core layer
             */
            if (! SYS_PMGR_GetCpuUsageAverage((UI32_T *) &long_return))
            {
                return SNMP_ERR_GENERR;
            }
            else
            {
                var_len = sizeof(UI32_T);
                snmp_set_var_typed_value(requests->requestvb, ASN_GAUGE,
                    (u_char *) &long_return, var_len);
            }

            break;
        }

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
#endif  /* (SYS_CPNT_SYSMGMT_RESMIB == TRUE) */

#if (SYS_CPNT_TELNET == TRUE)
/* ------------------------------------------------------------------------
 * SCALAR NAME - 1.1.2.1 snAgentGbl.snAgGblTelnetLoginTimeout(60)
 * ------------------------------------------------------------------------
 */
void init_snAgGblTelnetLoginTimeout(void)
{
    static oid snAgGblTelnetLoginTimeout_oid[] = { 1,3,6,1,4,1,1991,1,1,2,1,60, 0 };

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("snAgGblTelnetLoginTimeout",
                               do_snAgGblTelnetLoginTimeout,
                               snAgGblTelnetLoginTimeout_oid,
                               OID_LENGTH(snAgGblTelnetLoginTimeout_oid),
                               HANDLER_CAN_RWRITE));
}

int do_snAgGblTelnetLoginTimeout(netsnmp_mib_handler *handler,
    netsnmp_handler_registration *reginfo,
    netsnmp_agent_request_info *reqinfo,
    netsnmp_request_info *requests)
{
    /* dispatch get vs. set
     */
    switch (reqinfo->mode)
    {
        /* GET REQUEST
         */
        case MODE_GET:
        {
            UI32_T var_len = 0;
            SYS_MGR_Telnet_T entry;

            /* get from core layer (seconds or 0)
             */
            if (! SYS_PMGR_GetTelnetCfg(&entry))
            {
                 return SNMP_ERR_GENERR;
            }
            else
            {
                /* convert core-layer value (seconds or 0) to user value (minutes or 0),
                 * ignoring loss in precision;
                 *
                 * round up to avoid "30 seconds" being displayed as "0 minute"
                 */
                long_return = (entry.login_timeout + 59) / 60;

                var_len = sizeof(UI32_T);
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                    (u_char *) &long_return, var_len);
            }

            break;
        }

        /* SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            /* check type and length
             */
            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
                return SNMP_ERR_NOERROR;
            }

            break;

        case MODE_SET_RESERVE2:
            /* user value: minutes or 0; core-layer value: seconds or 0
             *
             * maximum value (if not multiple of 60 seconds), maps to Accton maximum
             * (if not multiple of 60 seconds)
             */
            if ((*requests->requestvb->val.integer * 60 < SYS_ADPT_MIN_TELNET_LOGIN_TIMEOUT)
                || (*requests->requestvb->val.integer * 60 > SYS_ADPT_MAX_TELNET_LOGIN_TIMEOUT + 59))
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
                return SNMP_ERR_NOERROR;
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called.
             */
            break;

        case MODE_SET_ACTION:
        {
            UI32_T core_val = 0;

            /* convert user value (minutes or 0) to core-layer value (seconds or 0)
             *
             * maximum value (if not multiple of 60 seconds), maps to Accton maximum
             * (if not multiple of 60 seconds)
             */
            core_val = *requests->requestvb->val.integer * 60;

            if (core_val > SYS_ADPT_MAX_TELNET_LOGIN_TIMEOUT)
            {
                core_val = SYS_ADPT_MAX_TELNET_LOGIN_TIMEOUT;
            }

            /* set to core layer
             */
            if (! SYS_PMGR_SetTelnetLoginTimeOut(core_val))
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
                return SNMP_ERR_NOERROR;
            }

            break;
        }

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
#endif

#if (SYS_CPNT_HTTP == TRUE)
/* ------------------------------------------------------------------------
 * SCALAR NAME - 1.1.2.1 snAgentGbl.snAgWebMgmtServerTcpPort(64)
 * ------------------------------------------------------------------------
 */
void init_snAgWebMgmtServerTcpPort(void)
{
    static oid snAgWebMgmtServerTcpPort_oid[] = { 1,3,6,1,4,1,1991,1,1,2,1,64, 0 };

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("snAgWebMgmtServerTcpPort",
                               do_snAgWebMgmtServerTcpPort,
                               snAgWebMgmtServerTcpPort_oid,
                               OID_LENGTH(snAgWebMgmtServerTcpPort_oid),
                               HANDLER_CAN_RWRITE));
}

int do_snAgWebMgmtServerTcpPort(netsnmp_mib_handler *handler,
    netsnmp_handler_registration *reginfo,
    netsnmp_agent_request_info *reqinfo,
    netsnmp_request_info *requests)
{
    /* dispatch get vs. set
     */
    switch (reqinfo->mode)
    {
        /* GET REQUEST
         */
        case MODE_GET:
        {
            UI32_T var_len = 0;

            /* get from core layer
             */
            long_return = HTTP_PMGR_Get_Http_Port();

            var_len = sizeof(UI32_T);
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                (u_char *) &long_return, var_len);

            break;
        }

        /* SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            /* check type and length
             */
            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
                return SNMP_ERR_NOERROR;
            }

            break;

        case MODE_SET_RESERVE2:
            if ((*requests->requestvb->val.integer < MIN_snAgWebMgmtServerTcpPort)
                || (*requests->requestvb->val.integer > MAX_snAgWebMgmtServerTcpPort))
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
                return SNMP_ERR_NOERROR;
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called.
             */
            break;

        case MODE_SET_ACTION:
        {
            /* set to core layer
             */
            if (! HTTP_PMGR_Set_Http_Port(*requests->requestvb->val.integer))
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
                return SNMP_ERR_NOERROR;
            }

            break;
        }

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
#endif

/* ------------------------------------------------------------------------
 * SCALAR NAME - 1.1.2.1 snAgentGbl.snAgTftpServerAddrType(65)
 * ------------------------------------------------------------------------
 */
void init_snAgTftpServerAddrType(void)
{
    static oid snAgTftpServerAddrType_oid[] = { 1,3,6,1,4,1,1991,1,1,2,1,65, 0 };

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("snAgTftpServerAddrType",
                               do_snAgTftpServerAddrType,
                               snAgTftpServerAddrType_oid,
                               OID_LENGTH(snAgTftpServerAddrType_oid),
                               HANDLER_CAN_RWRITE));
}

int do_snAgTftpServerAddrType(netsnmp_mib_handler *handler,
    netsnmp_handler_registration *reginfo,
    netsnmp_agent_request_info *reqinfo,
    netsnmp_request_info *requests)
{
    /* dispatch get vs. set
     */
    switch (reqinfo->mode)
    {
        /* GET REQUEST
         */
        case MODE_GET:
        {
            UI32_T var_len = 0;
            XFER_MGR_FileCopyMgt_T entry;

            /* get from core layer
             */
            if (FALSE == XFER_PMGR_GetFileCopyMgtEntry(&entry))
            {
                return SNMP_ERR_GENERR;
            }
            else
            {
                long_return = entry.server_address.type;
                var_len = sizeof(UI32_T);
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                    (u_char *) &long_return, var_len);
            }

            break;
        }

        /* SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            /* check type and length
             */
            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
                return SNMP_ERR_NOERROR;
            }

            break;

        case MODE_SET_RESERVE2:
            switch (*requests->requestvb->val.integer)
            {
                case VAL_fileCopyServerInetAddressType_ipv4:
                case VAL_fileCopyServerInetAddressType_ipv6:
                case VAL_fileCopyServerInetAddressType_ipv4z:
                case VAL_fileCopyServerInetAddressType_ipv6z:
                    break;

                case VAL_fileCopyServerInetAddressType_unknown:
                case VAL_fileCopyServerInetAddressType_dns:
                default:
                    netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
                    return SNMP_ERR_NOERROR;
            }

            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called.
             */
            break;

        case MODE_SET_ACTION:
        {
            /* store to temporary storage and wait for the address
             */
            foundry_sn_agent_remote_server_address_type
                = *requests->requestvb->val.integer;

            break;
        }

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

/* ------------------------------------------------------------------------
 * SCALAR NAME - 1.1.2.1 snAgentGbl.init_snAgTftpServerAddr(66)
 * ------------------------------------------------------------------------
 */
void init_snAgTftpServerAddr(void)
{
    static oid snAgTftpServerAddr_oid[] = { 1,3,6,1,4,1,1991,1,1,2,1,66, 0 };

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("snAgTftpServerAddr",
                               do_snAgTftpServerAddr,
                               snAgTftpServerAddr_oid,
                               OID_LENGTH(snAgTftpServerAddr_oid),
                               HANDLER_CAN_RWRITE));
}

int do_snAgTftpServerAddr(netsnmp_mib_handler *handler,
    netsnmp_handler_registration *reginfo,
    netsnmp_agent_request_info *reqinfo,
    netsnmp_request_info *requests)
{
    /* dispatch get vs. set
     */
    switch (reqinfo->mode)
    {
        /* GET REQUEST
         */
        case MODE_GET:
        {
            UI32_T var_len = 0;
            XFER_MGR_FileCopyMgt_T entry;
            UI32_T type, preflen;

            /* get from core layer
             */
            if (FALSE == XFER_PMGR_GetFileCopyMgtEntry(&entry))
            {
                return SNMP_ERR_GENERR;
            }
            else
            {
                /* convert to SNMP value
                 */
                if (! SNMP_MGR_ConvertLInetAddrToInetAddrAndType(
                    (L_INET_Addr_T *) &entry.server_address,
                    &type, &var_len, return_buf, &preflen))
                {
                    /* conversion failed
                     */
                    var_len = 0;
                }

                snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                    (u_char *) return_buf, var_len);
            }

            break;
        }

        /* SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            /* check type and length
             */
            if (requests->requestvb->type != ASN_OCTET_STR)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
                return SNMP_ERR_NOERROR;
            }

            if ((requests->requestvb->val_len < MINSIZE_snAgTftpServerAddr)
                || (requests->requestvb->val_len > MAXSIZE_snAgTftpServerAddr))
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGLENGTH);
                return SNMP_ERR_NOERROR;
            }

            break;

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called.
             */
            break;

        case MODE_SET_ACTION:
        {
            L_INET_AddrIp_T server_address;

            /* NOTE: InetAddressType and InetAddress
             *
             * The following checks use the corresponding InetAddressType.
             * If corresponding InetAddressType and InetAddress are in the
             * same packet, this check must be done in the sequence of
             * RESERVE1->RESERVE2->ACTION after InetAddressType is stored.
             */

            /* check address length based on address type
             */
            if (SNMP_MGR_IsInetAddrLengthValid(
				foundry_sn_agent_remote_server_address_type,
                requests->requestvb->val_len) == FALSE)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGLENGTH);
                return SNMP_ERR_NOERROR;
            }

            /* check address value based on address type
             */
            if (! SNMP_MGR_IsInetAddrValueValid(
                foundry_sn_agent_remote_server_address_type,
                requests->requestvb->val.string))
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_INCONSISTENTVALUE);
                return SNMP_ERR_NOERROR;
            }

            /* compose address structure
             */
            if (! SNMP_MGR_ConvertInetAddrAndTypeToLInetAddr(foundry_sn_agent_remote_server_address_type,
                requests->requestvb->val_len, requests->requestvb->val.string, 0,
                (L_INET_Addr_T *) &server_address))
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
                return SNMP_ERR_NOERROR;
            }

            /* set to core layer
             */
            if (! XFER_PMGR_SetFileCopyServerInetAddress(&server_address))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

/* ------------------------------------------------------------------------
 * SCALAR NAME - 1.1.2.12 snAgentHw.snAgSystemDRAM(1).snAgSystemDRAMUtil(1)
 * ------------------------------------------------------------------------
 */
void init_snAgSystemDRAMUtil(void)
{
    static oid snAgSystemDRAMUtil_oid[] = { 1,3,6,1,4,1,1991,1,1,2,12,4,1, 0 };

    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("snAgSystemDRAMUtil",
                                         get_snAgSystemDRAMUtil,
                                         snAgSystemDRAMUtil_oid,
                                         OID_LENGTH(snAgSystemDRAMUtil_oid),
                                         HANDLER_CAN_RONLY));
}

int get_snAgSystemDRAMUtil(netsnmp_mib_handler *handler,
    netsnmp_handler_registration *reginfo,
    netsnmp_agent_request_info *reqinfo,
    netsnmp_request_info *requests)
{
    /* dispatch get vs. set
     */
    switch (reqinfo->mode)
    {
        /* GET REQUEST
         */
        case MODE_GET:
        {
            UI32_T var_len = 0;
            UI32_T free_percentage = 0;

            /* get from core layer
             */
            if (! SYS_PMGR_GetMemoryUtilFreePercentage(&free_percentage))
            {
                return SNMP_ERR_GENERR;
            }
            else
            {
                long_return = 100 - free_percentage;
                var_len = sizeof(UI32_T);
                snmp_set_var_typed_value(requests->requestvb, ASN_GAUGE,
                    (u_char *) &long_return, var_len);
            }

            break;
        }

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

/* ------------------------------------------------------------------------
 * SCALAR NAME - 1.1.2.12 snAgentHw.snAgSystemDRAM(1).snAgSystemDRAMTotal(2)
 * ------------------------------------------------------------------------
 */
void init_snAgSystemDRAMTotal(void)
{
    static oid snAgSystemDRAMTotal_oid[] = { 1,3,6,1,4,1,1991,1,1,2,12,4,2, 0 };

    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("snAgSystemDRAMTotal",
                                         get_snAgSystemDRAMTotal,
                                         snAgSystemDRAMTotal_oid,
                                         OID_LENGTH(snAgSystemDRAMTotal_oid),
                                         HANDLER_CAN_RONLY));
}

int get_snAgSystemDRAMTotal(netsnmp_mib_handler *handler,
    netsnmp_handler_registration *reginfo,
    netsnmp_agent_request_info *reqinfo,
    netsnmp_request_info *requests)
{
    /* dispatch get vs. set
     */
    switch (reqinfo->mode)
    {
        /* GET REQUEST
         */
        case MODE_GET:
        {
            UI32_T var_len = 0;

            /* get from core layer
             */
            if (! SYS_PMGR_GetMemoryUtilTotalMemory((UI32_T *) &long_return))
            {
                return SNMP_ERR_GENERR;
            }
            else
            {
                var_len = sizeof(UI32_T);
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                    (u_char *) &long_return, var_len);
            }

            break;
        }

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

/* ------------------------------------------------------------------------
 * SCALAR NAME - 1.1.2.12 snAgentHw.snAgSystemDRAM(1).snAgSystemDRAMFree(3)
 * ------------------------------------------------------------------------
 */
void init_snAgSystemDRAMFree(void)
{
    static oid snAgSystemDRAMFree_oid[] = { 1,3,6,1,4,1,1991,1,1,2,12,4,3, 0 };

    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("snAgSystemDRAMFree",
                                         get_snAgSystemDRAMFree,
                                         snAgSystemDRAMFree_oid,
                                         OID_LENGTH(snAgSystemDRAMFree_oid),
                                         HANDLER_CAN_RONLY));
}

int get_snAgSystemDRAMFree(netsnmp_mib_handler *handler,
    netsnmp_handler_registration *reginfo,
    netsnmp_agent_request_info *reqinfo,
    netsnmp_request_info *requests)
{
    /* dispatch get vs. set
     */
    switch (reqinfo->mode)
    {
        /* GET REQUEST
         */
        case MODE_GET:
        {
            UI32_T var_len = 0;
            SYS_MGR_MemoryUtilBrief_T entry;

            /* get from core layer
             */
            if (! SYS_PMGR_GetMemoryUtilizationBrief(&entry))
            {
                return SNMP_ERR_GENERR;
            }
            else
            {
                long_return = entry.free_bytes;
                var_len = sizeof(UI32_T);
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                    (u_char *) &long_return, var_len);
            }

            break;
        }

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

#if (SYS_CPNT_THERMAL_DETECT == TRUE)  /* this table */
/* ------------------------------------------------------------------------
 * TABLE NAME - 1.1.2.13 snAgentTemp.snAgentTemp2Table(3)
 * ------------------------------------------------------------------------
 */
oid snAgentTemp2Table_variables_oid[] = { 1,3,6,1,4,1,1991,1,1,2,13 };

/* variable3 snAgentTemp2Table_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */
struct variable3 snAgentTemp2Table_variables[] =
{
    /* magic number, variable type, ro/rw, callback fn, L, oidsuffix
     *     (L = length of the oidsuffix)
     */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_snAgentTemp2UnitNum, ASN_INTEGER, RONLY, var_snAgentTemp2Table, 3, { 3, 1, 1 }},
#endif  /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_snAgentTemp2SlotNum, ASN_INTEGER, RONLY, var_snAgentTemp2Table, 3, { 3, 1, 2 }},
#endif  /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_snAgentTemp2SensorId, ASN_INTEGER, RONLY, var_snAgentTemp2Table, 3, { 3, 1, 3 }},
#endif  /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

#if 0  /* not implemented */
    { LEAF_snAgentTemp2SensorDescr, ASN_OCTET_STR, RONLY, var_snAgentTemp2Table, 3, { 3, 1, 4 }},
#endif

    { LEAF_snAgentTemp2Value, ASN_INTEGER, RONLY, var_snAgentTemp2Table, 3, { 3, 1, 5 }},
};

void init_snAgentTemp2Table(void)
{
    /* Register ourselves with the agent to handle our MIB tree
     */
    REGISTER_MIB("snAgentTemp2Table", snAgentTemp2Table_variables, variable3,
                 snAgentTemp2Table_variables_oid);
}

#define SNAGENTTEMP2ENTRY_INSTANCE_LEN  3

BOOL_T snAgentTemp2Table_OidIndexToData(UI32_T exact, UI32_T compc,
    oid *compl, UI32_T *snAgentTemp2UnitNum, UI32_T *snAgentTemp2SlotNum, UI32_T *snAgentTemp2SensorId)
{
    /* get or set
     */
    if (exact)
    {
        /* check the index length
         */
        if (compc != SNAGENTTEMP2ENTRY_INSTANCE_LEN)  /* the constant size index */
        {
            return FALSE;
        }
    }

    *snAgentTemp2UnitNum = compl[0];
    *snAgentTemp2SlotNum = compl[1];
    *snAgentTemp2SensorId = compl[2];

    return TRUE;
}

/*
 * var_snAgentTemp2Table():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *var_snAgentTemp2Table(struct variable *vp,
    oid *name,
    size_t *length,
    int exact,
    size_t *var_len,
    WriteMethod **write_method)
{
    UI32_T compc = 0;
    oid compl[SNAGENTTEMP2ENTRY_INSTANCE_LEN] = {0};
    oid best_inst[SNAGENTTEMP2ENTRY_INSTANCE_LEN] = {0};

    /* table-specific variables
     */
    SYS_MGR_SwitchThermalEntry_T entry;
    UI32_T slot;  /* dummy, not much use; only "1" exists */

    /* dispatch node to set write method
     */
    switch (vp->magic)
    {
        default:
            *write_method = 0;
            break;
    }

    /* check compc, retrive compl
     */
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl,
        SNAGENTTEMP2ENTRY_INSTANCE_LEN);

    memset(&entry, 0, sizeof(entry));

    /* dispatch get-exact versus get-next
     */
    if (exact)  /* get or set */
    {
        /* extract index
         */
        if (! snAgentTemp2Table_OidIndexToData(exact, compc, compl,
            &entry.switch_unit_index, &slot, &entry.switch_thermal_index))
        {
            return NULL;
        }

        /* slot: only "1" exists
         */
        if (slot != 1L)
        {
            return NULL;
        }

        /* get-exact from core layer
         */
        if (! (
#if (FOUNDRY_LIB_PLATFORM_STYLE == FOUNDRY_LIB_PLATFORM_STYLE_SIMBA)
            SYS_PMGR_GetThermalStatus(&entry)
#endif
#if (FOUNDRY_LIB_PLATFORM_STYLE == FOUNDRY_LIB_PLATFORM_STYLE_EDGE_CORE)
            SYS_PMGR_GetThermalTemperature(&entry)
#endif
            ))
        {
            return NULL;
        }
    }
    else  /* get-next */
    {
        /* extract index
         */
        snAgentTemp2Table_OidIndexToData(exact, compc, compl,
            &entry.switch_unit_index, &slot, &entry.switch_thermal_index);

        /* Check the length of inputing index.  If compc is less than the
         * instance length, we should try get {A.B.C.0.0...}, where A.B.C was
         * obtained from the "..._OidIndexToData" function call, and
         * 0.0... was initialized in the beginning of this function.
         * This instance may exist in the core layer.
         */
        if (compc < SNAGENTTEMP2ENTRY_INSTANCE_LEN)  /* incomplete index */
        {
            /* get-exact, in case this instance exists
             */
            if (! ( (slot == 1)  /* only "1" exists */
                && (
#if (FOUNDRY_LIB_PLATFORM_STYLE == FOUNDRY_LIB_PLATFORM_STYLE_SIMBA)
                SYS_PMGR_GetThermalStatus(&entry)
#endif
#if (FOUNDRY_LIB_PLATFORM_STYLE == FOUNDRY_LIB_PLATFORM_STYLE_EDGE_CORE)
                SYS_PMGR_GetThermalTemperature(&entry)
#endif
                ) ))
            {
                /* slot: only "1" exists;
                 * wrap the GetNext action for "slot" here
                 */
                if (slot < 1)
                {
                    slot = 1;
                    entry.switch_thermal_index = 0;
                }
                else if (slot > 1)
                {
                    entry.switch_unit_index++;
                    slot = 1;
                    entry.switch_thermal_index = 0;
                }

                /* get-next according to lexicographic order; if none, fail
                 */
                if (! (
#if (FOUNDRY_LIB_PLATFORM_STYLE == FOUNDRY_LIB_PLATFORM_STYLE_SIMBA)
                    SYS_PMGR_GetNextThermalStatus(&entry)
#endif
#if (FOUNDRY_LIB_PLATFORM_STYLE == FOUNDRY_LIB_PLATFORM_STYLE_EDGE_CORE)
                    /*!!PATCH: should call "SYS_PMGR_GetNextThermalTemperature",
                     * but there is no such function
                     */
                    (SYS_PMGR_GetNextThermalStatus(&entry)
                        && SYS_PMGR_GetThermalTemperature(&entry))
#endif
                    ))
                {
                    return NULL;
                }
            }
        }
        else   /* complete index */
        {
            /* slot: only "1" exists;
             * wrap the GetNext action for "slot" here
             */
            if (slot < 1)
            {
                slot = 1;
                entry.switch_thermal_index = 0;
            }
            else if (slot > 1)
            {
                entry.switch_unit_index++;
                slot = 1;
                entry.switch_thermal_index = 0;
            }

            /* get-next according to lexicographic order; if none, fail
             */
            if (! (
#if (FOUNDRY_LIB_PLATFORM_STYLE == FOUNDRY_LIB_PLATFORM_STYLE_SIMBA)
                SYS_PMGR_GetNextThermalStatus(&entry)
#endif
#if (FOUNDRY_LIB_PLATFORM_STYLE == FOUNDRY_LIB_PLATFORM_STYLE_EDGE_CORE)
                /*!!PATCH: should call "SYS_PMGR_GetNextThermalTemperature",
                 * but there is no such function
                 */
                (SYS_PMGR_GetNextThermalStatus(&entry)
                    && SYS_PMGR_GetThermalTemperature(&entry))
#endif
                ))
            {
                return NULL;
            }
        }
    }

    /* copy base OID (without index) to output
     */
    memcpy(name, vp->name, vp->namelen * sizeof(oid));

    /* assign data to the OID index
     */
    best_inst[0] = entry.switch_unit_index;
    best_inst[1] = 1;
    best_inst[2] = entry.switch_thermal_index;
    memcpy(name + vp->namelen, best_inst, SNAGENTTEMP2ENTRY_INSTANCE_LEN * sizeof(oid));
    *length = vp->namelen + SNAGENTTEMP2ENTRY_INSTANCE_LEN;

    /* dispatch node to read value
     */
    switch (vp->magic)
    {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case LEAF_snAgentTemp2UnitNum:
            *var_len = 4;
            long_return = (long) entry.switch_unit_index;
            return (u_char *) &long_return;
#endif  /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case LEAF_snAgentTemp2SlotNum:
            *var_len = 4;
            long_return = 1L;  /* only "1" exists */
            return (u_char *) &long_return;
#endif  /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case LEAF_snAgentTemp2SensorId:
            *var_len = 4;
            long_return = entry.switch_thermal_index;
            return (u_char *) &long_return;
#endif  /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

#if 0  /* not implemented */
        case LEAF_snAgentTemp2SensorDescr:
            *var_len = 0;  /* not supported; return empty string */
            return (u_char *) return_buf;
#endif

        case LEAF_snAgentTemp2Value:
            /* MIB object description says that the unit is 0.5 degree Celsius.
             * So, "* 2", i.e. for 1 deg C, display 2.
             */
            *var_len = 4;
            long_return = (long) entry.switch_thermal_temp_value * 2;  /* I32_T */
            return (u_char *) &long_return;

        default:
            ERROR_MSG("");
            break;
    }

    /* return failure
     */
    return NULL;
}
#endif  /* (SYS_CPNT_THERMAL_DETECT == TRUE); this table */

/* ------------------------------------------------------------------------
 * FUNCTION NAME - init_snChassis
 * ------------------------------------------------------------------------
 * PURPOSE  :   This is responsible for initialising snAgent.snChassis(1).
 *
 * INPUT    :   None.
 *
 * OUTPUT   :   None.
 *
 * RETURN   :   None.
 *
 * NOTES    :   None.
 * ------------------------------------------------------------------------
 */
void init_snChassis(void)
{
    /* register individual tables - under 1.1.1 snChassis.snChasGen(1)
     */
    init_snChasSerNum();                /* 2; also used by snChasFactoryPartNumber(28) */
    init_snChasMainBrdDescription();    /* 5; also used by snChasFactorySerialNumber(29) */
    init_snChasMainPortTotal();         /* 6 */

#if (SYS_CPNT_THERMAL_DETECT == TRUE)
    init_snChasActualTemperature();     /* 18 */
#endif

    init_snChasNumSlots();              /* 24 */

    /* snChasFactoryPartNumber(28): usse snChasSerNum(2) */
    /* snChasFactorySerialNumber(29): uses snChasMainBrdDescription(5) */

    /* register individual tables - under 1.1.1 snChassis.snChasPwr(2)
     */
    init_snChasPwrSupply2Table();   /* 2 */

    /* register individual tables - under 1.1.1 snChassis.snChasUnit(4)
     */
    init_snChasUnitTable();         /* 1 */
}

/* ------------------------------------------------------------------------
 * FUNCTION NAME - init_snAgentSys
 * ------------------------------------------------------------------------
 * PURPOSE  :   This is responsible for initialising snAgent.snAgentSys(2).
 *
 * INPUT    :   None.
 *
 * OUTPUT   :   None.
 *
 * RETURN   :   None.
 *
 * NOTES    :   None.
 * ------------------------------------------------------------------------
 */
void init_snAgentSys(void)
{
    /* register individual scalars - under 1.1.2 snAgentSys.snAgentGbl(1)
     */
    init_snAgReload();          /* 1 */
    init_snAgEraseNVRAM();      /* 2 */
    init_snAgWriteNVRAM();      /* 3 */
    init_snAgConfigFromNVRAM(); /* 4 */
    init_snAgImgFname();        /* 6; also used by snAgCfgFname(8) */
    init_snAgImgLoad();         /* 7 */

    /* snAgCfgFname(8): uses snAgImgFname(6) */

    init_snAgCfgLoad();         /* 9 */
    init_snAgDefGwayIp();       /* 10 */
    init_snAgImgVer();          /* 11; also used by snAgBuildVer(49) */
    init_snAgGblIfIpAddr();     /* 13 */
    init_snAgGblIfIpMask();     /* 14 */

#if (SYS_CPNT_SNMP_CONTIGUOUS_TRAP_DEST_TABLE == TRUE)
    init_snAgTrpRcvrCurEntry(); /* 16 */
#endif

    /* snAgGblCpuUtilData(35): uses snAgGblCpuUtil5SecAvg(51) */

#if (SYS_CPNT_TELNET == TRUE)
    init_snAgGblTelnetTimeout();        /* 37 */
#endif

#if (SYS_CPNT_HTTP == TRUE)
    init_snAgGblEnableWebMgmt();        /* 38 */
#endif

    init_snAgSoftwareFeature();         /* 41 */

    init_snAgGblTrapMessage();          /* 44 */

#if (SYS_CPNT_TELNET == TRUE)
    init_snAgGblEnableTelnetServer();   /* 45 */
#endif

    init_snAgBuildDate();               /* 47 */
    init_snAgBuildtime();               /* 48 */

    /* snAgBuildVer(49): uses snAgImgVer(11) */

#if (SYS_CPNT_SYSMGMT_RESMIB == TRUE)
    init_snAgGblCpuUtil5SecAvg();       /* 51; also used by snAgGblCpuUtilData(35) */
    init_snAgGblCpuUtil1MinAvg();       /* 52 */
#endif

#if (SYS_CPNT_TELNET == TRUE)
    init_snAgGblTelnetLoginTimeout();   /* 60 */
#endif

#if (SYS_CPNT_HTTP == TRUE)
    init_snAgWebMgmtServerTcpPort();    /* 64 */
#endif

    init_snAgTftpServerAddrType();      /* 65 */
    init_snAgTftpServerAddr();          /* 66 */

    /* register individual scalars - under 1.1.2 snAgentSys.snAgentHw(12)
     */
#if (SYS_CPNT_SYSMGMT_RESMIB == TRUE)
    init_snAgSystemDRAMUtil();  /* 1 */
    init_snAgSystemDRAMTotal(); /* 2 */
    init_snAgSystemDRAMFree();  /* 3 */
#endif

#if (SYS_CPNT_THERMAL_DETECT == TRUE)  /* this table */
    /* register tables - under 1.1.2 snAgentSys.snAgentTemp(13)
     */
    init_snAgentTemp2Table();  /* 3 */
#endif
}

/* ------------------------------------------------------------------------
 * FUNCTION NAME - init_snAgent
 * ------------------------------------------------------------------------
 * PURPOSE  :   This is the entry point into this file for initialisation.
 *
 * INPUT    :   None.
 *
 * OUTPUT   :   None.
 *
 * RETURN   :   None.
 *
 * NOTES    :   None.
 * ------------------------------------------------------------------------
 */
void init_snAgent(void)
{
    /* MODULE-IDENTITY node:
     * 4 FOUNDRY-SN-AGENT-MIB.snAgent (nothing inside)
     *
     * variables:
     * 1.1.1 FOUNDRY-SN-AGENT-MIB.snChassis.*
     * 1.1.2 FOUNDRY-SN-AGENT-MIB.snAgentSys.*
     */
    oid snAgent_oid[] = { 1,3,6,1,4,1,1991,4 };

    /* register subtrees
     */
    init_snChassis();   /* 1.1.1 snChassis */
    init_snAgentSys();  /* 1.1.2 snAgentSys */

    /* register ourselves in the sysORTable
     */
    REGISTER_SYSOR_ENTRY(snAgent_oid,
        "MIB module for the agent.");  /* not copied from MIB Description */
}
