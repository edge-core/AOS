/* MODULE NAME:  fdry_trap.c
 *
 * PURPOSE: For SNMP to access Brocade's FDRY-TRAP-MIB:
 *
 * foundry(1991).products(1).switch(1).fdryTrap(10).fdryTrapMIB(1)
 *
 * NOTES:
 *
 * HISTORY (mm/dd/yyyy)
 *    07/19/2011 - Qiyao Zhong, Created
 *
 * Copyright(C)      Accton Corporation, 2011
 */

/* Note: this file originally auto-generated by mib2c using
 *        : mib2c.scalar.conf,v 1.5 2002/07/18 14:18:52 dts12 Exp $
 */
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

#include "sys_type.h"
#include "sys_adpt.h"
#include "sys_cpnt.h"
#include "leaf_fdry_trap.h"

#include "ip_lib.h"
#include "sysfun.h"

#include "snmp_mgr.h"
#include "sysORTable.h"
#include "foundry_lib.h"
#include "fdry_trap.h"

#if (SYS_CPNT_SNMP == TRUE)
#include "snmp_mgr.h"
#endif /* #if (SYS_CPNT_SNMP == TRUE) */

/*!!PENDING: These temporary variables need to be cleared upon
 * entering transition mode.
 */

/* temporary variable to be combined with actual address for "set";
 * Brocade default is ipv4(1)
 */
static UI32_T fdry_trap_addr_type = VAL_fdryTrapReceiverAddrType_ipv4;

/* This entry is used for entry which have the ability to row create.
 * This is initialised upon entering the "var_..." function and does not need to be
 * cleared upon entering transition mode.
 */
static SNMP_MGR_TrapDestEntry_T fdry_trap_trapDestEntry;

#if (SYS_CPNT_SNMP == TRUE)  /* from near-beginning to end of file */
/* ------------------------------------------------------------------------
 * TABLE NAME - fdryTrapReceiverTable
 * ------------------------------------------------------------------------
 */
oid fdryTrapReceiverTable_variables_oid[] = { 1,3,6,1,4,1,1991,1,1,10,1,1 };

/* variable3 fdryTrapReceiverTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */
struct variable3 fdryTrapReceiverTable_variables[] =
{
    /* magic number, variable type, ro/rw, callback fn, L, oidsuffix
     *     (L = length of the oidsuffix)
     */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_fdryTrapReceiverTIndex, ASN_UNSIGNED, RONLY, var_fdryTrapReceiverTable, 3, { 1, 1, 1 }},
#endif  /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

    { LEAF_fdryTrapReceiverAddrType, ASN_INTEGER, RWRITE, var_fdryTrapReceiverTable, 3, { 1, 1, 2 }},
    { LEAF_fdryTrapReceiverAddr, ASN_OCTET_STR, RWRITE, var_fdryTrapReceiverTable, 3, { 1, 1, 3 }},
    { LEAF_fdryTrapReceiverCommunityOrSecurityName, ASN_OCTET_STR, RWRITE, var_fdryTrapReceiverTable, 3, { 1, 1, 4 }},
    { LEAF_fdryTrapReceiverUDPPort, ASN_INTEGER, RWRITE, var_fdryTrapReceiverTable, 3, { 1, 1, 5 }},
    { LEAF_fdryTrapReceiverSecurityModel, ASN_INTEGER, RWRITE, var_fdryTrapReceiverTable, 3, { 1, 1, 6 }},
    { LEAF_fdryTrapReceiverSecurityLevel, ASN_INTEGER, RWRITE, var_fdryTrapReceiverTable, 3, { 1, 1, 7 }},
    { LEAF_fdryTrapReceiverRowStatus, ASN_INTEGER, RWRITE, var_fdryTrapReceiverTable, 3, { 1, 1, 8 }},
};

void init_fdryTrapReceiverTable(void)
{
    oid fdryTrapMIB_oid[] = { 1,3,6,1,4,1,1991,1,1,10,1 };

    /* register ourselves in the sysORTable
     */
    REGISTER_SYSOR_ENTRY(fdryTrapMIB_oid,
        "The Brocade proprietary MIB module for Traps.");

    /* Register ourselves with the agent to handle our MIB tree
     */
    REGISTER_MIB("fdryTrapReceiverTable", fdryTrapReceiverTable_variables, variable3,
                 fdryTrapReceiverTable_variables_oid);
}

#define FDRYTRAPRECEIVERENTRY_INSTANCE_LEN  1

BOOL_T fdryTrapReceiverTable_OidIndexToData(UI32_T exact, UI32_T compc,
    oid *compl, UI32_T *fdryTrapReceiverIndex)
{
    /* get or set
     */
    if (exact)
    {
        /* check the index length
         */
        if (compc != FDRYTRAPRECEIVERENTRY_INSTANCE_LEN)  /* the constant size index */
        {
            return FALSE;
        }
    }

    *fdryTrapReceiverIndex = compl[0];

    return TRUE;
}

/*
 * var_fdryTrapReceiverTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *var_fdryTrapReceiverTable(struct variable *vp,
    oid *name,
    size_t *length,
    int exact,
    size_t *var_len,
    WriteMethod **write_method)
{
    UI32_T compc = 0;
    oid compl[FDRYTRAPRECEIVERENTRY_INSTANCE_LEN] = {0};
    oid best_inst[FDRYTRAPRECEIVERENTRY_INSTANCE_LEN] = {0};

    /* table-specific variables
     */
    SNMP_MGR_TrapDestEntry_T entry;
    UI32_T index = 0;

    /* Give default value for the record first
     * We use the row_status = 0 to indicate if this set operation is Set by field
     * or set by record (included row creation), if the row_status =0, this record
     * mean set by field; otherwise, we just think it is a normal set operation
     */
    if (SNMP_MGR_GetDefaultTrapDestEntry(&fdry_trap_trapDestEntry)
        != SNMP_MGR_ERROR_OK)
    {
        return NULL;
    }

    fdry_trap_trapDestEntry.trap_dest_status = 0;

    /* dispatch node to set write method
     */
    switch (vp->magic)
    {
        case LEAF_fdryTrapReceiverAddrType:
            *write_method = write_fdryTrapReceiverAddrType;
            break;

        case LEAF_fdryTrapReceiverAddr:
            *write_method = write_fdryTrapReceiverAddr;
            break;

        case LEAF_fdryTrapReceiverCommunityOrSecurityName:
            *write_method = write_fdryTrapReceiverCommunityOrSecurityName;
            break;

        case LEAF_fdryTrapReceiverUDPPort:
            *write_method = write_fdryTrapReceiverUDPPort;
            break;

        case LEAF_fdryTrapReceiverSecurityModel:
            *write_method = write_fdryTrapReceiverSecurityModel;
            break;

        case LEAF_fdryTrapReceiverSecurityLevel:
            *write_method = write_fdryTrapReceiverSecurityLevel;
            break;

        case LEAF_fdryTrapReceiverRowStatus:
            *write_method = write_fdryTrapReceiverRowStatus;
            break;

        default:
            *write_method = 0;
            break;
    }

    /* check compc, retrive compl
     */
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl,
        FDRYTRAPRECEIVERENTRY_INSTANCE_LEN);

    memset(&entry, 0, sizeof(entry));

    /* dispatch get-exact versus get-next
     */
    if (exact)  /* get or set */
    {
        /* extract index
         */
        if (! fdryTrapReceiverTable_OidIndexToData(exact, compc, compl,
            &index))
        {
            return NULL;
        }

        /* get-exact from core layer
         */
        if (SNMP_MGR_GetTrapReceiverByIndex(index, &entry)
            != SNMP_MGR_ERROR_OK)
        {
            return NULL;
        }
    }
    else  /* get-next */
    {
        /* extract index
         */
        fdryTrapReceiverTable_OidIndexToData(exact, compc, compl,
            &index);

        /* Check the length of inputing index.  If compc is less than the
         * instance length, we should try get {A.B.C.0.0...}, where A.B.C was
         * obtained from the "..._OidIndexToData" function call, and
         * 0.0... was initialized in the beginning of this function.
         * This instance may exist in the core layer.
         */
        if (compc < FDRYTRAPRECEIVERENTRY_INSTANCE_LEN)  /* incomplete index */
        {
            /* get-exact, in case this instance exists
             */
            if (SNMP_MGR_GetTrapReceiverByIndex(index, &entry)
                != SNMP_MGR_ERROR_OK)
            {
                /* get-next according to lexicographic order; if none, fail
                 */
                if (SNMP_MGR_GetNextTrapReceiverByIndex(&index, &entry)
                    != SNMP_MGR_ERROR_OK)
                {
                    return NULL;
                }
            }
        }
        else   /* complete index */
        {
            /* get-next according to lexicographic order; if none, fail
             */
            if (SNMP_MGR_GetNextTrapReceiverByIndex(&index, &entry)
                != SNMP_MGR_ERROR_OK)
            {
                return NULL;
            }
        }
    }

    /* copy base OID (without index) to output
     */
    memcpy(name, vp->name, vp->namelen * sizeof(oid));

    /* assign data to the OID index
     */
    best_inst[0] = index;
    memcpy(name + vp->namelen, best_inst, FDRYTRAPRECEIVERENTRY_INSTANCE_LEN * sizeof(oid));
    *length = vp->namelen + FDRYTRAPRECEIVERENTRY_INSTANCE_LEN;

    /* dispatch node to read value
     */
    switch (vp->magic)
    {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case LEAF_fdryTrapReceiverIndex:
            *var_len = 4;
            long_return = index;
            return (u_char *) &long_return;
#endif  /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

        case LEAF_fdryTrapReceiverAddrType:
            *var_len = 4;
            long_return = L_INET_ADDR_TYPE_IPV4;  /* fixed */
            return (u_char *) &long_return;

        case LEAF_fdryTrapReceiverAddr:
            {
                UI32_T type, addr_len, preflen;

                if (! SNMP_MGR_ConvertLInetAddrToInetAddrAndType(
                    (L_INET_Addr_T *) &entry.trap_dest_address,
                    &type, &addr_len, return_buf, &preflen))
                {
                    /* conversion failed
                     */
                    *var_len = 0;
                }
                else
                {
                    *var_len = (size_t) addr_len;
                }
                return (u_char *) return_buf;
            }

        case LEAF_fdryTrapReceiverCommunityOrSecurityName:
            *var_len = strlen(entry.trap_dest_community);
            memcpy(return_buf, entry.trap_dest_community, *var_len);
            return (u_char *) return_buf;

        case LEAF_fdryTrapReceiverUDPPort:
            *var_len = 4;
            long_return = entry.trap_dest_port;
            return (u_char *) &long_return;

        case LEAF_fdryTrapReceiverSecurityModel:
            *var_len = 4;
            long_return = entry.trap_dest_version;
            return (u_char *) &long_return;

        case LEAF_fdryTrapReceiverSecurityLevel:
            *var_len = 4;
            long_return = entry.trap_dest_security_level;
            return (u_char *) &long_return;

        case LEAF_fdryTrapReceiverRowStatus:
            *var_len = 4;
            long_return = entry.trap_dest_status;
            return (u_char *) &long_return;

        default:
            ERROR_MSG("");
            break;
    }

    /* return failure
     */
    return NULL;
}

int write_fdryTrapReceiverAddrType(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    /* dispatch action
     */
    switch (action)
    {
        case RESERVE1:
            /* check type and length
             */
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            /* check valid values
             */
            switch (*(long *) var_val)
            {
                case VAL_fdryTrapReceiverAddrType_unknown:
                    return SNMP_ERR_WRONGVALUE;

                /* we support only IPv4
                 */
                case VAL_fdryTrapReceiverAddrType_ipv4:
                    break;

                case VAL_fdryTrapReceiverAddrType_ipv6:
                case VAL_fdryTrapReceiverAddrType_ipv4z:
                case VAL_fdryTrapReceiverAddrType_ipv6z:
                case VAL_fdryTrapReceiverAddrType_dns:
                default:
                    return SNMP_ERR_WRONGVALUE;
            }

            /* Cache IP type in SNMP before setting IP.
             * When set IP address, it will be set to core layer together.
             * It is ported from Galaxy.
             */
            fdry_trap_addr_type = *(long *) var_val;
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = 15;

            /* table-specific variables
             */
            UI32_T fdryTrapReceiverIndex = 0;
            SNMP_MGR_TrapDestEntry_T entry;

            /* extract index
             */
            if (! fdryTrapReceiverTable_OidIndexToData(TRUE,
                name_len - oid_name_length,
                &(name[oid_name_length]),
                &fdryTrapReceiverIndex))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            /* For row creation, if row_status == 0, mean that this is a normal
             * operation, we do the normal set operation; otherwise it is a row
             * creation operation, will do nothing here, and the overall entry
             * will be performed in the write_xxxRowStatus function.
             */
            if (fdry_trap_trapDestEntry.trap_dest_status == 0)
            {
#if (SYS_CPNT_SNMP_CONTIGUOUS_TRAP_DEST_TABLE == TRUE)
                /* MIB object description says that if entry is active,
                 * modification is not allowed.
                 * To protect from re-ordering during modification,
                 * we don't allow modification if contiguousness is desired.
                 */
                if ( (SNMP_MGR_GetTrapReceiverByIndex(fdryTrapReceiverIndex,
                        &entry) == SNMP_MGR_ERROR_OK)
                    && (entry.trap_dest_status == SNMP_MGR_SNMPV3_ROWSTATUS_TYPE_ACTIVE) )
                {
                    if (fdry_trap_addr_type != VAL_fdryTrapReceiverAddrType_ipv4)
                    {
                        return SNMP_ERR_INCONSISTENTVALUE;
                    }
                    else
                    {
                        return SNMP_ERR_NOERROR;
                    }
                }
#endif

                /* nothing to store
                 */
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    /* return success
     */
    return SNMP_ERR_NOERROR;
}

int write_fdryTrapReceiverAddr(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    /* dispatch action
     */
    switch (action)
    {
        case RESERVE1:
            /* check type and length
             */
            if (var_val_type != ASN_OCTET_STR)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if ((var_val_len < MINSIZE_fdryTrapReceiverAddr)
                || (var_val_len > MAXSIZE_fdryTrapReceiverAddr))
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;

        case RESERVE2:
            /* NOTE: InetAddressType and InetAddress
             *
             * The following checks use the corresponding InetAddressType.
             * If corresponding InetAddressType and InetAddress are in the
             * same packet, this check must be done in the sequence of
             * RESERVE1->RESERVE2->ACTION after InetAddressType is stored.
             */

            /* check address length based on address type
             */
            if (! SNMP_MGR_IsInetAddrLengthValid(
                fdry_trap_addr_type,
                (UI32_T) var_val_len))
            {
                return SNMP_ERR_INCONSISTENTVALUE;
            }

            /* check address value based on address type
             */
            if (! SNMP_MGR_IsInetAddrValueValid(
                fdry_trap_addr_type,
                var_val))
            {
                return SNMP_ERR_INCONSISTENTVALUE;
            }

            /* store to row-create structure
             */
            if (! SNMP_MGR_ConvertInetAddrAndTypeToLInetAddr(fdry_trap_addr_type,
                var_val_len, var_val, 0,
                (L_INET_Addr_T *) &fdry_trap_trapDestEntry.trap_dest_address))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            /* clear InetAddressType to wait for next write;
             * the Brocade default is ipv4(1)
             */
            fdry_trap_addr_type = VAL_fdryTrapReceiverAddrType_ipv4;

            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = 15;

            /* table-specific variables
             */
            UI32_T fdryTrapReceiverIndex = 0;
            SNMP_MGR_TrapDestEntry_T entry;

            /* extract index
             */
            if (! fdryTrapReceiverTable_OidIndexToData(TRUE,
                name_len - oid_name_length,
                &(name[oid_name_length]),
                &fdryTrapReceiverIndex))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            /* set to core layer
             */

            /* For row creation, if row_status == 0, mean that this is a normal
             * operation, we do the normal set operation; otherwise it is a row
             * creation operation, will do nothing here, and the overall entry
             * will be performed in the write_xxxRowStatus function.
             */
            if (fdry_trap_trapDestEntry.trap_dest_status == 0)
            {
                /* get current structure
                 */
                if (SNMP_MGR_GetTrapReceiverByIndex(fdryTrapReceiverIndex, &entry)
                    != SNMP_MGR_ERROR_OK)
                {
                    return SNMP_ERR_COMMITFAILED;
                }

#if (SYS_CPNT_SNMP_CONTIGUOUS_TRAP_DEST_TABLE == TRUE)
                /* MIB object description says that if entry is active,
                 * modification is not allowed.
                 * To protect from re-ordering during modification,
                 * we don't allow modification if contiguousness is desired.
                 */
                if (entry.trap_dest_status == SNMP_MGR_SNMPV3_ROWSTATUS_TYPE_ACTIVE)
                {
                    if (fdry_trap_trapDestEntry.trap_dest_address != entry.trap_dest_address)
                    {
                        return SNMP_ERR_INCONSISTENTVALUE;
                    }
                    else
                    {
                        return SNMP_ERR_NOERROR;
                    }
                }
#endif

                /* combine with new address
                 */
                if (SNMP_MGR_SetTrapDestAddressByIndex(fdryTrapReceiverIndex,
                        entry.trap_dest_port,
                        &fdry_trap_trapDestEntry.trap_dest_address)
                    != SNMP_MGR_ERROR_OK)
                {
                    return SNMP_ERR_COMMITFAILED;
                }
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    /* return success
     */
    return SNMP_ERR_NOERROR;
}

int write_fdryTrapReceiverCommunityOrSecurityName(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    /* dispatch action
     */
    switch (action)
    {
        case RESERVE1:
            /* check type and length
             */
            if (var_val_type != ASN_OCTET_STR)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if ((var_val_len < MINSIZE_fdryTrapReceiverCommunityOrSecurityName)
                || (var_val_len > MAXSIZE_fdryTrapReceiverCommunityOrSecurityName))
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;

        case RESERVE2:
            /* check value
             */
            if (! L_STDLIB_StrIsAsciiPrintWithCount((char *) var_val, var_val_len))
            {
                return SNMP_ERR_WRONGVALUE;
            }

            /* store to row-create structure
             */
            memcpy(fdry_trap_trapDestEntry.trap_dest_community, var_val, var_val_len);
            fdry_trap_trapDestEntry.trap_dest_community[var_val_len] = 0;
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = 15;
#if 0  /* code-gen'd but un-used */
            UI8_T byte_buffer[MAXSIZE_fdryTrapReceiverCommunityOrSecurityName + 1] = {0};
#endif

            /* table-specific variables
             */
            UI32_T fdryTrapReceiverIndex = 0;

#if (SYS_CPNT_SNMP_CONTIGUOUS_TRAP_DEST_TABLE == TRUE)
            SNMP_MGR_TrapDestEntry_T entry;
#endif

            /* extract index
             */
            if (! fdryTrapReceiverTable_OidIndexToData(TRUE,
                name_len - oid_name_length,
                &(name[oid_name_length]),
                &fdryTrapReceiverIndex))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            /* set to core layer
             */

            /* For row creation, if row_status == 0, mean that this is a normal
             * operation, we do the normal set operation; otherwise it is a row
             * creation operation, will do nothing here, and the overall entry
             * will be performed in the write_xxxRowStatus function.
             */
            if (fdry_trap_trapDestEntry.trap_dest_status == 0)
            {
#if (SYS_CPNT_SNMP_CONTIGUOUS_TRAP_DEST_TABLE == TRUE)
                /* MIB object description says that if entry is active,
                 * modification is not allowed.
                 * To protect from re-ordering during modification,
                 * we don't allow modification if contiguousness is desired.
                 */
                if ( (SNMP_MGR_GetTrapReceiverByIndex(fdryTrapReceiverIndex,
                        &entry) == SNMP_MGR_ERROR_OK)
                    && (entry.trap_dest_status == SNMP_MGR_SNMPV3_ROWSTATUS_TYPE_ACTIVE) )
                {
                    if (strcmp(fdry_trap_trapDestEntry.trap_dest_community,
                        entry.trap_dest_community) != 0)
                    {
                        return SNMP_ERR_INCONSISTENTVALUE;
                    }
                    else
                    {
                        return SNMP_ERR_NOERROR;
                    }
                }
#endif

                /* set new value
                 */
                if (SNMP_MGR_SetTrapReceiverCommStringNameByIndex(fdryTrapReceiverIndex,
                        fdry_trap_trapDestEntry.trap_dest_community)
                    != SNMP_MGR_ERROR_OK)
                {
                    return SNMP_ERR_COMMITFAILED;
                }
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    /* return success
     */
    return SNMP_ERR_NOERROR;
}

int write_fdryTrapReceiverUDPPort(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    /* dispatch action
     */
    switch (action)
    {
        case RESERVE1:
            /* check type and length
             */
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            /* check valid values
             */
            if ((*(long *) var_val < MIN_fdryTrapReceiverUDPPort)
                || (*(long *) var_val > MAX_fdryTrapReceiverUDPPort))
            {
                return SNMP_ERR_WRONGVALUE;
            }

            /* store to row-create structure
             */
            fdry_trap_trapDestEntry.trap_dest_port = (UI32_T) *(long *) var_val;

            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = 15;
#if 0  /* code-gen'd but un-used */
            I32_T value = 0;
#endif

            /* table-specific variables
             */
            UI32_T fdryTrapReceiverIndex = 0;
            SNMP_MGR_TrapDestEntry_T entry;

            /* extract index
             */
            if (! fdryTrapReceiverTable_OidIndexToData(TRUE,
                name_len - oid_name_length,
                &(name[oid_name_length]),
                &fdryTrapReceiverIndex))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            /* set to core layer
             */

            /* For row creation, if row_status == 0, mean that this is a normal
             * operation, we do the normal set operation; otherwise it is a row
             * creation operation, will do nothing here, and the overall entry
             * will be performed in the write_xxxRowStatus function.
             */
            if (fdry_trap_trapDestEntry.trap_dest_status == 0)
            {
                /* get current structure
                 */
                if (SNMP_MGR_GetTrapReceiverByIndex(fdryTrapReceiverIndex, &entry)
                    != SNMP_MGR_ERROR_OK)
                {
                    return SNMP_ERR_COMMITFAILED;
                }

#if (SYS_CPNT_SNMP_CONTIGUOUS_TRAP_DEST_TABLE == TRUE)
                /* MIB object description says that if entry is active,
                 * modification is not allowed.
                 * To protect from re-ordering during modification,
                 * we don't allow modification if contiguousness is desired.
                 */
                if (entry.trap_dest_status == SNMP_MGR_SNMPV3_ROWSTATUS_TYPE_ACTIVE)
                {
                    if (fdry_trap_trapDestEntry.trap_dest_port != entry.trap_dest_port)
                    {
                        return SNMP_ERR_INCONSISTENTVALUE;
                    }
                    else
                    {
                        return SNMP_ERR_NOERROR;
                    }
                }
#endif

                /* combine with new port
                 */
                if (SNMP_MGR_SetTrapDestAddressByIndex(fdryTrapReceiverIndex,
                        fdry_trap_trapDestEntry.trap_dest_port,
                        &entry.trap_dest_address)
                    != SNMP_MGR_ERROR_OK)
                {
                    return SNMP_ERR_COMMITFAILED;
                }
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    /* return success
     */
    return SNMP_ERR_NOERROR;
}

int write_fdryTrapReceiverSecurityModel(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    /* dispatch action
     */
    switch (action)
    {
        case RESERVE1:
            /* check type and length
             */
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            /* check valid values
             */
            switch (*(long *) var_val)
            {
                case VAL_fdryTrapReceiverSecurityModel_v1:
                    break;

                case VAL_fdryTrapReceiverSecurityModel_v2c:
                    break;

                case VAL_fdryTrapReceiverSecurityModel_usm:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }

            /* store to row-create structure (parallel enums, skip conversion)
             */
            fdry_trap_trapDestEntry.trap_dest_version = (UI32_T) *(long *) var_val;
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = 15;
#if 0  /* code-gen'd but un-used */
            I32_T value = 0;
#endif

            /* table-specific variables
             */
            UI32_T fdryTrapReceiverIndex = 0;

#if (SYS_CPNT_SNMP_CONTIGUOUS_TRAP_DEST_TABLE == TRUE)
            SNMP_MGR_TrapDestEntry_T entry;
#endif

            /* extract index
             */
            if (! fdryTrapReceiverTable_OidIndexToData(TRUE,
                name_len - oid_name_length,
                &(name[oid_name_length]),
                &fdryTrapReceiverIndex))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            /* set to core layer
             */

            /* For row creation, if row_status == 0, mean that this is a normal
             * operation, we do the normal set operation; otherwise it is a row
             * creation operation, will do nothing here, and the overall entry
             * will be performed in the write_xxxRowStatus function.
             */
            if (fdry_trap_trapDestEntry.trap_dest_status == 0)
            {
#if (SYS_CPNT_SNMP_CONTIGUOUS_TRAP_DEST_TABLE == TRUE)
                /* MIB object description says that if entry is active,
                 * modification is not allowed.
                 * To protect from re-ordering during modification,
                 * we don't allow modification if contiguousness is desired.
                 */
                if ( (SNMP_MGR_GetTrapReceiverByIndex(fdryTrapReceiverIndex,
                        &entry) == SNMP_MGR_ERROR_OK)
                    && (entry.trap_dest_status == SNMP_MGR_SNMPV3_ROWSTATUS_TYPE_ACTIVE) )
                {
                    if (fdry_trap_trapDestEntry.trap_dest_version != entry.trap_dest_version)
                    {
                        return SNMP_ERR_INCONSISTENTVALUE;
                    }
                    else
                    {
                        return SNMP_ERR_NOERROR;
                    }
                }
#endif

                /* set new value
                 */
                if (SNMP_MGR_SetTrapReceiverVersionByIndex(fdryTrapReceiverIndex,
                        fdry_trap_trapDestEntry.trap_dest_version)
                    != SNMP_MGR_ERROR_OK)
                {
                    return SNMP_ERR_COMMITFAILED;
                }
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    /* return success
     */
    return SNMP_ERR_NOERROR;
}

int write_fdryTrapReceiverSecurityLevel(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    /* dispatch action
     */
    switch (action)
    {
        case RESERVE1:
            /* check type and length
             */
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            /* check valid values
             */
            switch (*(long *) var_val)
            {
                case VAL_fdryTrapReceiverSecurityLevel_noAuth:
                    break;

                case VAL_fdryTrapReceiverSecurityLevel_auth:
                    break;

                case VAL_fdryTrapReceiverSecurityLevel_authPriv:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }

            /* store to row-create structure
             */
            fdry_trap_trapDestEntry.trap_dest_security_level = (UI32_T) *(long *) var_val;
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = 15;
#if 0  /* code-gen'd but un-used */
            I32_T value = 0;
#endif

            /* table-specific variables
             */
            UI32_T fdryTrapReceiverIndex = 0;

#if (SYS_CPNT_SNMP_CONTIGUOUS_TRAP_DEST_TABLE == TRUE)
            SNMP_MGR_TrapDestEntry_T entry;
#endif

            /* extract index
             */
            if (! fdryTrapReceiverTable_OidIndexToData(TRUE,
                name_len - oid_name_length,
                &(name[oid_name_length]),
                &fdryTrapReceiverIndex))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            /* set to core layer
             */

            /* For row creation, if row_status == 0, mean that this is a normal
             * operation, we do the normal set operation; otherwise it is a row
             * creation operation, will do nothing here, and the overall entry
             * will be performed in the write_xxxRowStatus function.
             */
            if (fdry_trap_trapDestEntry.trap_dest_status == 0)
            {
#if (SYS_CPNT_SNMP_CONTIGUOUS_TRAP_DEST_TABLE == TRUE)
                /* MIB object description says that if entry is active,
                 * modification is not allowed.
                 * To protect from re-ordering during modification,
                 * we don't allow modification if contiguousness is desired.
                 */
                if ( (SNMP_MGR_GetTrapReceiverByIndex(fdryTrapReceiverIndex,
                        &entry) == SNMP_MGR_ERROR_OK)
                    && (entry.trap_dest_status == SNMP_MGR_SNMPV3_ROWSTATUS_TYPE_ACTIVE) )
                {
                    if (fdry_trap_trapDestEntry.trap_dest_security_level != entry.trap_dest_security_level)
                    {
                        return SNMP_ERR_INCONSISTENTVALUE;
                    }
                    else
                    {
                        return SNMP_ERR_NOERROR;
                    }
                }
#endif

                /* set new value
                 */
                if (SNMP_MGR_SetTrapReceiverSecLevelByIndex(fdryTrapReceiverIndex,
                        fdry_trap_trapDestEntry.trap_dest_security_level)
                    != SNMP_MGR_ERROR_OK)
                {
                    return SNMP_ERR_COMMITFAILED;
                }
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    /* return success
     */
    return SNMP_ERR_NOERROR;
}

int write_fdryTrapReceiverRowStatus(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    /* dispatch action
     */
    switch (action)
    {
        case RESERVE1:
            /* check type and length
             */
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            /* check valid values
             */

            /* The core layer only has valid (create) and invalid (destroy).
             * So, we have partial support of RowStatus.
             * 1. Writing "notInService(2)" is not supported.
             * 2. Writing "createAndWait(5)" makes it active(1), so that
             * the sequence "createAndWait(5), write field, active(1)",
             * succeeds and results in active(1) in the end, as expected.
             */
            switch (*(long *) var_val)
            {
                case VAL_fdryTrapReceiverRowStatus_active:
                    break;

                case VAL_fdryTrapReceiverRowStatus_notInService:
                case VAL_fdryTrapReceiverRowStatus_notReady:
                    return SNMP_ERR_WRONGVALUE;

                case VAL_fdryTrapReceiverRowStatus_createAndGo:
                case VAL_fdryTrapReceiverRowStatus_createAndWait:
                case VAL_fdryTrapReceiverRowStatus_destroy:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }

            /* In reserve2, we overwrite the set value to trapDestEntry
             */
            memcpy(&fdry_trap_trapDestEntry.trap_dest_status, var_val, sizeof(UI32_T));
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = 15;

            /* table-specific variables
             */
            UI32_T fdryTrapReceiverIndex = 0;
            SNMP_MGR_TrapDestEntry_T entry;

            /* extract index
             */
            if (! fdryTrapReceiverTable_OidIndexToData(TRUE,
                name_len - oid_name_length,
                &(name[oid_name_length]),
                &fdryTrapReceiverIndex))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            /* set to core layer
             */

            /* The core layer only has valid (create) and invalid (destroy).
             * So, we have partial support of RowStatus.
             * 1. Writing "notInService(2)" is not supported.
             * 2. Writing "createAndWait(5)" makes it active(1), so that
             * the sequence "createAndWait(5), write field, active(1)",
             * succeeds and results in active(1) in the end, as expected.
             */
            switch (fdry_trap_trapDestEntry.trap_dest_status)
            {
                /* active: accepted only if it already exists
                 */
                case VAL_fdryTrapReceiverRowStatus_active:
                    if (SNMP_MGR_GetTrapReceiverByIndex(fdryTrapReceiverIndex,
                            &entry)
                        != SNMP_MGR_ERROR_OK)
                    {
                        return SNMP_ERR_COMMITFAILED;
                    }
                    break;

                /* not supported: should not come here; already filtered in RESERVE2
                 */
                case VAL_fdryTrapReceiverRowStatus_notInService:
                case VAL_fdryTrapReceiverRowStatus_notReady:
                    return SNMP_ERR_WRONGVALUE;

                /* create: always results in a valid (active) entry
                 */
                case VAL_fdryTrapReceiverRowStatus_createAndGo:
                case VAL_fdryTrapReceiverRowStatus_createAndWait:
                    if (SNMP_MGR_SetTrapDestEntryByIndex(fdryTrapReceiverIndex,
                            &fdry_trap_trapDestEntry)
                        != SNMP_MGR_ERROR_OK)
                    {
                        return SNMP_ERR_COMMITFAILED;
                    }

                    break;

                /* destroy: even if non-existent, the core layer should return success
                 * (RFC 2579 SNMPv2-TC)
                 */
                case VAL_fdryTrapReceiverRowStatus_destroy:
                    if (SNMP_MGR_SetTrapReceiverStatusByIndex(fdryTrapReceiverIndex,
                            VAL_fdryTrapReceiverRowStatus_destroy)
                        != SNMP_MGR_ERROR_OK)
                    {
                        return SNMP_ERR_COMMITFAILED;
                    }
                    break;

                /* default: should not come here; already filtered in RESERVE2
                 */
                default:
                    return SNMP_ERR_WRONGVALUE;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    /* return success
     */
    return SNMP_ERR_NOERROR;
}
#endif  /* (SYS_CPNT_SNMP == TRUE); from near-beginning to end of file */
