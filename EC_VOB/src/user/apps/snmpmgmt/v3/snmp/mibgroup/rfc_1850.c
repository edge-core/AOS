/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.scalar.conf,v 1.5 2002/07/18 14:18:52 dts12 Exp $
 */
#include "sys_cpnt.h"

#if (SYS_CPNT_OSPF == TRUE)
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

#include "leaf_1850.h"
#include "rfc_1850.h"
#include "snmp_mgr.h"
#include "sysortable.h"
#include "ip_lib.h"
#include "sysfun.h"

#include "netcfg_type.h"
#include "netcfg_pom_ip.h"
#include "ospf_pmgr.h"
#include "vlan_lib.h"
#define CHECK_FLAG(V,F)      ((V) & (F))
#define SET_FLAG(V,F)        (V) = (V) | (F)
#define UNSET_FLAG(V,F)      (V) = (V) & ~(F)

#define ospfAreaEntry_INSTANCE_LEN 4
#define ospfStubAreaEntry_INSTANCE_LEN 5
#define ospfIfEntry_INSTANCE_LEN 5
#define ospfIfMetricEntry_INSTANCE_LEN 6
#define ospfVirtIfEntry_INSTANCE_LEN 8
#define ospfNbrEntry_INSTANCE_LEN 5
#define ospfAreaAggregateEntry_INSTANCE_LEN 13
#define ospfHostEntry_INSTANCE_LEN 5
#define ospfVirtNbrEntry_INSTANCE_LEN 8
#define ospfExtLsdbEntry_INSTANCE_LEN 9
#define ospfLsdbEntry_INSTANCE_LEN 13

/** Initializes the ospfGeneralGroup module */
void
init_ospfGeneralGroup(void)
{
    static oid      ospf_module_oid[] = { SNMP_OID_MIB2, 14 };

    static oid      ospfExternLsaCount_oid[] =
        { 1, 3, 6, 1, 2, 1, 14, 1, 6, 0 };
    static oid      ospfExtLsdbLimit_oid[] =
        { 1, 3, 6, 1, 2, 1, 14, 1, 11, 0 };
    static oid      ospfASBdrRtrStatus_oid[] =
        { 1, 3, 6, 1, 2, 1, 14, 1, 5, 0 };
    static oid      ospfVersionNumber_oid[] =
        { 1, 3, 6, 1, 2, 1, 14, 1, 3, 0 };
    static oid      ospfAreaBdrRtrStatus_oid[] =
        { 1, 3, 6, 1, 2, 1, 14, 1, 4, 0 };
    static oid      ospfTOSSupport_oid[] =
        { 1, 3, 6, 1, 2, 1, 14, 1, 8, 0 };
    static oid      ospfAdminStat_oid[] =
        { 1, 3, 6, 1, 2, 1, 14, 1, 2, 0 };
    static oid      ospfExitOverflowInterval_oid[] =
        { 1, 3, 6, 1, 2, 1, 14, 1, 13, 0 };
    static oid      ospfMulticastExtensions_oid[] =
        { 1, 3, 6, 1, 2, 1, 14, 1, 12, 0 };
    static oid      ospfRouterId_oid[] = { 1, 3, 6, 1, 2, 1, 14, 1, 1, 0 };
    static oid      ospfDemandExtensions_oid[] =
        { 1, 3, 6, 1, 2, 1, 14, 1, 14, 0 };
    static oid      ospfRxNewLsas_oid[] =
        { 1, 3, 6, 1, 2, 1, 14, 1, 10, 0 };
    static oid      ospfOriginateNewLsas_oid[] =
        { 1, 3, 6, 1, 2, 1, 14, 1, 9, 0 };
    static oid      ospfExternLsaCksumSum_oid[] =
        { 1, 3, 6, 1, 2, 1, 14, 1, 7, 0 };


    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("ospfExternLsaCount",
                                         get_ospfExternLsaCount,
                                         ospfExternLsaCount_oid,
                                         OID_LENGTH
                                         (ospfExternLsaCount_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("ospfExtLsdbLimit", do_ospfExtLsdbLimit,
                               ospfExtLsdbLimit_oid,
                               OID_LENGTH(ospfExtLsdbLimit_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("ospfASBdrRtrStatus", do_ospfASBdrRtrStatus,
                               ospfASBdrRtrStatus_oid,
                               OID_LENGTH(ospfASBdrRtrStatus_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("ospfVersionNumber",
                                         get_ospfVersionNumber,
                                         ospfVersionNumber_oid,
                                         OID_LENGTH(ospfVersionNumber_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("ospfAreaBdrRtrStatus",
                                         get_ospfAreaBdrRtrStatus,
                                         ospfAreaBdrRtrStatus_oid,
                                         OID_LENGTH
                                         (ospfAreaBdrRtrStatus_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("ospfTOSSupport", do_ospfTOSSupport,
                               ospfTOSSupport_oid,
                               OID_LENGTH(ospfTOSSupport_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("ospfAdminStat", do_ospfAdminStat,
                               ospfAdminStat_oid,
                               OID_LENGTH(ospfAdminStat_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("ospfExitOverflowInterval",
                               do_ospfExitOverflowInterval,
                               ospfExitOverflowInterval_oid,
                               OID_LENGTH(ospfExitOverflowInterval_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("ospfMulticastExtensions",
                               do_ospfMulticastExtensions,
                               ospfMulticastExtensions_oid,
                               OID_LENGTH(ospfMulticastExtensions_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("ospfRouterId", do_ospfRouterId,
                               ospfRouterId_oid,
                               OID_LENGTH(ospfRouterId_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("ospfDemandExtensions",
                               do_ospfDemandExtensions,
                               ospfDemandExtensions_oid,
                               OID_LENGTH(ospfDemandExtensions_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("ospfRxNewLsas",
                                         get_ospfRxNewLsas,
                                         ospfRxNewLsas_oid,
                                         OID_LENGTH(ospfRxNewLsas_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("ospfOriginateNewLsas",
                                         get_ospfOriginateNewLsas,
                                         ospfOriginateNewLsas_oid,
                                         OID_LENGTH
                                         (ospfOriginateNewLsas_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("ospfExternLsaCksumSum",
                                         get_ospfExternLsaCksumSum,
                                         ospfExternLsaCksumSum_oid,
                                         OID_LENGTH
                                         (ospfExternLsaCksumSum_oid),
                                         HANDLER_CAN_RONLY));


    REGISTER_SYSOR_ENTRY(ospf_module_oid,
                         "The MIB module to describe the OSPF Version 2 Protocol.");
}

int
get_ospfExternLsaCount(netsnmp_mib_handler *handler,
                       netsnmp_handler_registration *reginfo,
                       netsnmp_agent_request_info *reqinfo,
                       netsnmp_request_info *requests)
{
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one.
     */

    switch(reqinfo->mode)
    {

        case MODE_GET:
        {
            UI32_T value;
            if (OSPF_PMGR_GetExternLsaCount(0, 1, &value)==OSPF_TYPE_RESULT_SUCCESS)
            {
                long_return=value;
                snmp_set_var_typed_value(requests->requestvb, ASN_GAUGE, (u_char *)&long_return, sizeof(long_return));
            }
            else
            {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}

int
do_ospfExtLsdbLimit(netsnmp_mib_handler *handler,
                    netsnmp_handler_registration *reginfo,
                    netsnmp_agent_request_info *reqinfo,
                    netsnmp_request_info *requests)
{
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one.
     */
    switch(reqinfo->mode) {

        case MODE_GET:
        {

            UI32_T value;
            if (OSPF_PMGR_GetExtLsdbLimit(0, 1, &value)==OSPF_TYPE_RESULT_SUCCESS)
            {
                long_return=value;
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *)&long_return, sizeof(long_return));
            }
            else
            {
                return SNMP_ERR_GENERR;
            }
            break;
         }

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
        {
          I32_T value;
          value = *requests->requestvb->val.integer;
          if ((value< MIN_ospfExtLsdbLimit) || (value >MAX_ospfExtLsdbLimit))
          {
              netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
          }
        }
        break;

        case MODE_SET_RESERVE2:
            break;
        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;
        case MODE_SET_ACTION:
        {
           UI32_T value;
           value = *requests->requestvb->val.integer;

           if (OSPF_PMGR_SetExtLsdbLimit(0, 1, value)!= OSPF_TYPE_RESULT_SUCCESS)
           {
               netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
           }
         }
         break;
        case MODE_SET_COMMIT:
            break;
        case MODE_SET_UNDO:
            break;
        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}

int
do_ospfASBdrRtrStatus(netsnmp_mib_handler *handler,
                      netsnmp_handler_registration *reginfo,
                      netsnmp_agent_request_info *reqinfo,
                      netsnmp_request_info *requests)
{
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one.
     */
    switch(reqinfo->mode) {

        case MODE_GET:
        {

            UI32_T value;
            if (OSPF_PMGR_GetASBdrRtrStatus(0, 1, &value)==OSPF_TYPE_RESULT_SUCCESS)
            {
                long_return = value;
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *)&long_return, sizeof(long_return));
            }
            else
            {
                return SNMP_ERR_GENERR;
            }
            break;
         }

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
        {
          UI32_T value;
          value = *requests->requestvb->val.integer;

          if ((value!= VAL_ospfASBdrRtrStatus_true) && (value !=VAL_ospfASBdrRtrStatus_false))
              netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
        }
        break;

        case MODE_SET_RESERVE2:
            break;
        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;
        case MODE_SET_ACTION:
        {
            UI32_T value;
            value = *requests->requestvb->val.integer;
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *)&long_return, sizeof(long_return));

           if (OSPF_PMGR_SetASBdrRtrStatus(0, 1, value)!= OSPF_TYPE_RESULT_SUCCESS)
           {
               netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
           }
         }
         break;
        case MODE_SET_COMMIT:
            break;
        case MODE_SET_UNDO:
            break;
        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}

int
get_ospfVersionNumber(netsnmp_mib_handler *handler,
                      netsnmp_handler_registration *reginfo,
                      netsnmp_agent_request_info *reqinfo,
                      netsnmp_request_info *requests)
{
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one.
     */

    switch(reqinfo->mode)
    {

        case MODE_GET:
        {
            UI32_T value;

            if (OSPF_PMGR_GetVersionNumber(0, 1, &value)==OSPF_TYPE_RESULT_SUCCESS)
            {
                long_return = value;
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *)&long_return, sizeof(long_return));
            }
            else
            {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}

int
get_ospfAreaBdrRtrStatus(netsnmp_mib_handler *handler,
                         netsnmp_handler_registration *reginfo,
                         netsnmp_agent_request_info *reqinfo,
                         netsnmp_request_info *requests)
{
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one.
     */

    switch(reqinfo->mode)
    {

        case MODE_GET:
        {
            UI32_T value;
            if (OSPF_PMGR_GetAreaBdrRtrStatus(0, 1, &value)==OSPF_TYPE_RESULT_SUCCESS)
            {
                long_return = value;
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *)&long_return, sizeof(long_return));
            }
            else
            {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}

int
do_ospfTOSSupport(netsnmp_mib_handler *handler,
                  netsnmp_handler_registration *reginfo,
                  netsnmp_agent_request_info *reqinfo,
                  netsnmp_request_info *requests)
{
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one.
     */
    switch(reqinfo->mode) {

        case MODE_GET:
        {

            UI32_T value;
            if (OSPF_PMGR_GetTOSSupport(0, 1, &value)==OSPF_TYPE_RESULT_SUCCESS)
            {
                long_return=value;
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *)&long_return, sizeof(long_return));
            }
            else
            {
                return SNMP_ERR_GENERR;
            }
            break;
         }

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
        {
          UI32_T value;
          value = *requests->requestvb->val.integer;

          if ((value!= VAL_ospfTOSSupport_true) && (value !=VAL_ospfTOSSupport_false))
              netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
        }
        break;

        case MODE_SET_RESERVE2:
            break;
        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;
        case MODE_SET_ACTION:
        {
           UI32_T value;
           value = *requests->requestvb->val.integer;

           if (OSPF_PMGR_SetTOSSupport(0, 1, value)!= OSPF_TYPE_RESULT_SUCCESS)
           {
               netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
           }
         }
         break;
        case MODE_SET_COMMIT:
            break;
        case MODE_SET_UNDO:
            break;
        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}

int
do_ospfAdminStat(netsnmp_mib_handler *handler,
                 netsnmp_handler_registration *reginfo,
                 netsnmp_agent_request_info *reqinfo,
                 netsnmp_request_info *requests)
{
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one.
     */
    switch(reqinfo->mode) {

        case MODE_GET:
        {

            UI32_T value;
            if (OSPF_PMGR_GetAdminStat(0, 1, &value)==OSPF_TYPE_RESULT_SUCCESS)
            {
                long_return=value;
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *)&long_return, sizeof(long_return));
            }
            else
            {
                return SNMP_ERR_GENERR;
            }
            break;
         }

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
        {
          UI32_T value;
          value = *requests->requestvb->val.integer;

          if ((value!= VAL_ospfAdminStat_enabled) && (value !=VAL_ospfAdminStat_disabled))
              netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
        }
        break;

        case MODE_SET_RESERVE2:
            break;
        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;
        case MODE_SET_ACTION:
        {
           UI32_T value;
           value = *requests->requestvb->val.integer;

           if (OSPF_PMGR_SetAdminStat(0, 1, value)!= OSPF_TYPE_RESULT_SUCCESS)
           {
               netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
           }
         }
         break;
        case MODE_SET_COMMIT:
            break;
        case MODE_SET_UNDO:
            break;
        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}

int
do_ospfExitOverflowInterval(netsnmp_mib_handler *handler,
                            netsnmp_handler_registration *reginfo,
                            netsnmp_agent_request_info *reqinfo,
                            netsnmp_request_info *requests)
{
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one.
     */
    switch(reqinfo->mode) {

        case MODE_GET:
        {

            UI32_T value;
            if (OSPF_PMGR_GetExitOverflowInterval(0, 1, &value)==OSPF_TYPE_RESULT_SUCCESS)
            {
                long_return=value;
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *)&long_return, sizeof(long_return));
            }
            else
            {
                return SNMP_ERR_GENERR;
            }
            break;
         }

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
        {
          UI32_T value;
          value = *requests->requestvb->val.integer;

          if ((value < MIN_ospfExitOverflowInterval) || (value >MAX_ospfExitOverflowInterval))
              netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
        }
        break;

        case MODE_SET_RESERVE2:
            break;
        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;
        case MODE_SET_ACTION:
        {
           UI32_T value;
           value = *requests->requestvb->val.integer;

           if (OSPF_PMGR_SetExitOverflowInterval(0, 1, value)!= OSPF_TYPE_RESULT_SUCCESS)
           {
               netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
           }
         }
         break;
        case MODE_SET_COMMIT:
            break;
        case MODE_SET_UNDO:
            break;
        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}

int
do_ospfMulticastExtensions(netsnmp_mib_handler *handler,
                           netsnmp_handler_registration *reginfo,
                           netsnmp_agent_request_info *reqinfo,
                           netsnmp_request_info *requests)
{
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one.
     */
    switch(reqinfo->mode) {

        case MODE_GET:
        {

            UI32_T value;
            if (OSPF_PMGR_GetMulticastExtensions(0, 1, &value)==OSPF_TYPE_RESULT_SUCCESS)
            {
                long_return=value;
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *)&long_return, sizeof(long_return));
            }
            else
            {
                return SNMP_ERR_GENERR;
            }
            break;
         }

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
        {
          UI32_T value;
          value = *requests->requestvb->val.integer;

          if ((value < MIN_ospfExitOverflowInterval) || (value >MAX_ospfExitOverflowInterval))
              netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
        }
        break;

        case MODE_SET_RESERVE2:
            break;
        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;
        case MODE_SET_ACTION:
        {
           UI32_T value;
           value = *requests->requestvb->val.integer;

           if (OSPF_PMGR_SetMulticastExtensions(0, 1, value)!= OSPF_TYPE_RESULT_SUCCESS)
           {
               netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
           }
         }
         break;
        case MODE_SET_COMMIT:
            break;
        case MODE_SET_UNDO:
            break;
        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}

int
do_ospfRouterId(netsnmp_mib_handler *handler,
                netsnmp_handler_registration *reginfo,
                netsnmp_agent_request_info *reqinfo,
                netsnmp_request_info *requests)
{
    UI32_T value;

    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one.
     */
    switch(reqinfo->mode) {

        case MODE_GET:
        {
            UI32_T value;
            if (OSPF_PMGR_GetRouterId(0, 1, &value)==OSPF_TYPE_RESULT_SUCCESS)
            {
                ipaddr_return = value;
                snmp_set_var_typed_value(requests->requestvb, ASN_IPADDRESS, (u_char *)&ipaddr_return, sizeof(ipaddr_return));
            }
            else
            {
                return SNMP_ERR_GENERR;
            }
            break;
         }

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
        {
        }
        break;

        case MODE_SET_RESERVE2:
            break;
        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;
        case MODE_SET_ACTION:
        {
           //UI32_T value;
//           struct pal_in4_addr addr;
//           addr.s_addr = value;
           value = *requests->requestvb->val.integer;

           if (OSPF_PMGR_RouterIdSet(0, 1, value)!= OSPF_TYPE_RESULT_SUCCESS)
           {
               netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
           }
         }
         break;
        case MODE_SET_COMMIT:
            break;
        case MODE_SET_UNDO:
            break;
        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}

int
do_ospfDemandExtensions(netsnmp_mib_handler *handler,
                        netsnmp_handler_registration *reginfo,
                        netsnmp_agent_request_info *reqinfo,
                        netsnmp_request_info *requests)
{
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one.
     */
    switch(reqinfo->mode) {

        case MODE_GET:
        {

            UI32_T value;
            if (OSPF_PMGR_GetDemandExtensions(0, 1, &value)==OSPF_TYPE_RESULT_SUCCESS)
            {
                long_return=value;
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *)&long_return, sizeof(long_return));
            }
            else
            {
                return SNMP_ERR_GENERR;
            }
            break;
         }

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
        {
          UI32_T value;
          value = *requests->requestvb->val.integer;

          if ((value!= VAL_ospfDemandExtensions_true)&& (value != VAL_ospfDemandExtensions_false))
              netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
        }
        break;

        case MODE_SET_RESERVE2:
            break;
        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;
        case MODE_SET_ACTION:
        {
           UI32_T value;
           value = *requests->requestvb->val.integer;

           if (OSPF_PMGR_SetDemandExtensions(0, 1, value)!= OSPF_TYPE_RESULT_SUCCESS)
           {
               netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
           }
         }
         break;
        case MODE_SET_COMMIT:
            break;
        case MODE_SET_UNDO:
            break;
        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}

int
get_ospfRxNewLsas(netsnmp_mib_handler *handler,
                  netsnmp_handler_registration *reginfo,
                  netsnmp_agent_request_info *reqinfo,
                  netsnmp_request_info *requests)
{
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one.
     */

    switch(reqinfo->mode)
    {

        case MODE_GET:
        {
            UI32_T value;
            if (OSPF_PMGR_GetRxNewLsas(0, 1, &value)==OSPF_TYPE_RESULT_SUCCESS)
            {
                long_return=value;
                snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *)&long_return, sizeof(long_return));
            }
            else
            {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}

int
get_ospfOriginateNewLsas(netsnmp_mib_handler *handler,
                         netsnmp_handler_registration *reginfo,
                         netsnmp_agent_request_info *reqinfo,
                         netsnmp_request_info *requests)
{
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one.
     */

    switch(reqinfo->mode)
    {

        case MODE_GET:
        {
            UI32_T value;
            if (OSPF_PMGR_GetOriginateNewLsas(0, 1, &value)==OSPF_TYPE_RESULT_SUCCESS)
            {
                long_return=value;
                snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *)&long_return, sizeof(long_return));
            }
            else
            {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}

int
get_ospfExternLsaCksumSum(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one.
     */

    switch(reqinfo->mode)
    {

        case MODE_GET:
        {
            UI32_T value;
            if (OSPF_PMGR_GetExternLsaCksumSum(0, 1, &value)==OSPF_TYPE_RESULT_SUCCESS)
            {
                long_return=value;
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *)&long_return, sizeof(long_return));
            }
            else
            {
                return SNMP_ERR_GENERR;
            }
            break;
        }
        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}




/*
 * ospfAreaTable_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

static oid ospfAreaTable_variables_oid[] =
    { 1, 3, 6, 1, 2, 1, 14 };

/*
 * variable3 ospfAreaTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */

struct variable3 ospfAreaTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */
#define OSPFAREAID          1
    {OSPFAREAID, ASN_INTEGER, RONLY, var_ospfAreaTable, 3, {2, 1, 1}},
#define OSPFAUTHTYPE        2
    {OSPFAUTHTYPE, ASN_INTEGER, RWRITE, var_ospfAreaTable, 3, {2, 1, 2}},
#define OSPFIMPORTASEXTERN      3
    {OSPFIMPORTASEXTERN, ASN_INTEGER, RWRITE, var_ospfAreaTable, 3,
     {2, 1, 3}},
#define OSPFSPFRUNS     4
    {OSPFSPFRUNS, ASN_COUNTER, RONLY, var_ospfAreaTable, 3, {2, 1, 4}},
#define OSPFAREABDRRTRCOUNT     5
    {OSPFAREABDRRTRCOUNT, ASN_GAUGE, RONLY, var_ospfAreaTable, 3,
     {2, 1, 5}},
#define OSPFASBDRRTRCOUNT       6
    {OSPFASBDRRTRCOUNT, ASN_GAUGE, RONLY, var_ospfAreaTable, 3, {2, 1, 6}},
#define OSPFAREALSACOUNT        7
    {OSPFAREALSACOUNT, ASN_GAUGE, RONLY, var_ospfAreaTable, 3, {2, 1, 7}},
#define OSPFAREALSACKSUMSUM     8
    {OSPFAREALSACKSUMSUM, ASN_INTEGER, RONLY, var_ospfAreaTable, 3,
     {2, 1, 8}},
#define OSPFAREASUMMARY     9
    {OSPFAREASUMMARY, ASN_INTEGER, RWRITE, var_ospfAreaTable, 3,
     {2, 1, 9}},
#define OSPFAREASTATUS      10
    {OSPFAREASTATUS, ASN_INTEGER, RWRITE, var_ospfAreaTable, 3,
     {2, 1, 10}},
};
/*
 * (L = length of the oidsuffix)
 */


/** Initializes the ospfAreaTable module */
void
init_ospfAreaTable(void)
{
    /*
     * register ourselves with the agent to handle our mib tree
     */
    REGISTER_MIB("ospfAreaTable", ospfAreaTable_variables, variable3,
                 ospfAreaTable_variables_oid);

    /*
     * place any other initialization junk you need here
     */
}

static BOOL_T ospfAreaTable_get(int      compc,
                                oid     *compl,
                                OSPF_TYPE_Area_T   *data)
{
    if (compc !=ospfAreaEntry_INSTANCE_LEN)
    {
        return FALSE;
    }
    SNMP_MGR_ReadIpFromCompl(compl,0, &data->area_id);
    if (OSPF_PMGR_GetAreaTable(data)!=OSPF_TYPE_RESULT_SUCCESS)
    {
        return FALSE;
    }
    else
    {
        return TRUE;

    } /*End of if */
}

static BOOL_T ospfAreaTable_next(int      compc,
                                 oid     *compl,
                                 OSPF_TYPE_Area_T    *data)
{
    oid tmp_compl[ospfAreaEntry_INSTANCE_LEN];

    /* Generate the instance of each table entry and find the
     * smallest instance that's larger than compc/compl.
     *
     * Step 1: Verify and extract the input key from "compc" and "compl"
     * Note: The number of input key is defined by "compc".
     *       The key for the specified instance is defined in compl.
     */
    memcpy(tmp_compl, compl, sizeof(tmp_compl));
    SNMP_MGR_checkCompl(0, 3, tmp_compl,255);
    SNMP_MGR_ConvertRemainToZero(compc,ospfAreaEntry_INSTANCE_LEN, tmp_compl);

    SNMP_MGR_ReadIpFromCompl(tmp_compl,0,&data->area_id);
    if (compc == 0)
    {
        /* get first, set indexlen 0 */
        data->indexlen = 0;

        if (OSPF_PMGR_GetNextAreaTable(data)!= OSPF_TYPE_RESULT_SUCCESS)
        {
            return FALSE;
        }
    }
    else if (compc<ospfAreaEntry_INSTANCE_LEN)
    {
        /* get next area, set indexlen 4 */
        data->indexlen = 4;
        if (OSPF_PMGR_GetAreaTable(data)!=OSPF_TYPE_RESULT_SUCCESS)
        {
            if (OSPF_PMGR_GetNextAreaTable(data)!=OSPF_TYPE_RESULT_SUCCESS)
            {
                return FALSE;
            }
        }
    }
    else
    {
        /* get next area, set indexlen 4 */
        data->indexlen = 4;
        if (OSPF_PMGR_GetNextAreaTable(data)!=OSPF_TYPE_RESULT_SUCCESS)
        {
            return FALSE;
        }
    }
    return TRUE;
}

/* This entry is used for entry which have the ability to row create*/
static OSPF_TYPE_Area_T ospfAreaEntry;

/*
 * var_ospfAreaTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_ospfAreaTable(struct variable *vp,
                  oid * name,
                  size_t * length,
                  int exact, size_t * var_len, WriteMethod ** write_method)
{
    UI32_T compc=0;
    oid compl[ospfAreaEntry_INSTANCE_LEN];
    oid best_inst[ospfAreaEntry_INSTANCE_LEN];
    OSPF_TYPE_Area_T data;

     /* Give default value for the record first.
     * We use the row_status = 0 to indicate if this set operation is Set by field
     * or set by record(included row creation), if the row_status =0, this record
     * mean set by field, otherwise, we just think it is a normal set operation
     */
    memset(&ospfAreaEntry, 0, sizeof(ospfAreaEntry));
    ospfAreaEntry.vr_id = 0;
    ospfAreaEntry.proc_id = 1;


   /*Since this table allow for entry that does not exist, (creation). we need to know the write method first*/
    switch (vp->magic)
    {
      case OSPFAUTHTYPE:
        *write_method = write_ospfAuthType;
      break;
      case OSPFIMPORTASEXTERN:
        *write_method = write_ospfImportAsExtern;
        break;
      case OSPFAREASUMMARY:
        *write_method = write_ospfAreaSummary;
        break;
      case OSPFAREASTATUS:
        *write_method = write_ospfAreaStatus;
        break;
      default:
         *write_method =0;
         break;
    }

    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,compl, ospfAreaEntry_INSTANCE_LEN);

    memset(&data, 0, sizeof(data));
    /* set default vr_id, proc_id */
    data.vr_id = 0;
    data.proc_id = 1;
    data.indexlen = 0;
     /*check compc, retrive compl*/
    if (exact)/*get,set*/
    {
        if (!ospfAreaTable_get(compc, compl, &data))
            return NULL;
    }
    else/*getnext*/
    {
        if (!ospfAreaTable_next(compc, compl, &data))
        {
            return NULL;
        }
    }
    memcpy(name, vp->name, vp->namelen*sizeof(oid));
    SNMP_MGR_BindIpInstance(data.area_id,0,best_inst);

    memcpy(name + vp->namelen, best_inst, ospfAreaEntry_INSTANCE_LEN*sizeof(oid));
    *length = vp->namelen +ospfAreaEntry_INSTANCE_LEN;

    *var_len = sizeof(long_return);

    /*
     * * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
      case OSPFAREAID:
        long_return = data.area_id;
        return (u_char*) &long_return;
      case OSPFAUTHTYPE:
        long_return = data.auth_type;
        return (u_char*) &long_return;
      case OSPFIMPORTASEXTERN:
        if(data.external_routing == OSPF_AREA_DEFAULT)
        {
            long_return =  VAL_ospfImportAsExtern_importExternal;
        }
        else if(data.external_routing == OSPF_AREA_STUB)
        {
            long_return =  VAL_ospfImportAsExtern_importNoExternal;
        }
        else if(data.external_routing == OSPF_AREA_NSSA)
        {
            long_return =  VAL_ospfImportAsExtern_importNssa;
        }
        return (u_char*) &long_return;
        case OSPFSPFRUNS:
        long_return = data.spf_calc_count;
        return (u_char*) &long_return;
      case OSPFAREABDRRTRCOUNT:
        if(CHECK_FLAG (data.top_flags, OSPF_ROUTER_ABR))
        {
            long_return = data.abr_count + 1;
        }
        else
        {
            long_return = data.abr_count;
        }
        return (u_char *) &long_return;
      case OSPFASBDRRTRCOUNT:
            if(CHECK_FLAG (data.top_flags, OSPF_ROUTER_ASBR))
            {
                long_return = data.asbr_count + 1;
            }
            else
            {
                long_return = data.asbr_count;
            }
            return (u_char *) &long_return;
      case OSPFAREALSACOUNT:
        long_return = data.lsa_count;
        return (u_char*) &long_return;
      case OSPFAREALSACKSUMSUM:
            long_return =  data.lsa_checksum;
        return (u_char*) &long_return;
      case OSPFAREASUMMARY:
        if(CHECK_FLAG (data.config, OSPF_AREA_CONF_NO_SUMMARY))
        {
            long_return = VAL_ospfAreaSummary_noAreaSummary;
        }
        else
        {
            long_return = VAL_ospfAreaSummary_sendAreaSummary;
        }
        return (u_char *) &long_return;
      case OSPFAREASTATUS:
        long_return = data.status;
        return (u_char*) &long_return;
    default:
        break;
    }
    return NULL;
}


int
write_ospfAuthType(int action,
                   u_char * var_val,
                   u_char var_val_type,
                   size_t var_val_len,
                   u_char * statP, oid * name, size_t name_len)
{
    UI32_T oid_name_length = 10;
    UI32_T value;

    /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  ospfAreaEntry_INSTANCE_LEN + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    SNMP_MGR_ReadIpFromCompl(name, oid_name_length, &ospfAreaEntry.area_id);
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;

        case RESERVE2:
            /* In reserve2, we overwrite the set value to ospfAreaEntry*/
            value = *(long *)var_val;
            if ((value < SYS_ADPT_OSPF_AUTH_TYPE_NONE) || (value > SYS_ADPT_OSPF_AUTH_TYPE_MD5))
                return SNMP_ERR_WRONGVALUE;
            ospfAreaEntry.auth_type = value;
            break;

        case FREE:
            /* Release any resources that have been allocated */
            break;

        case ACTION:
            if (ospfAreaEntry.status == 0)
            {
                if (OSPF_TYPE_RESULT_SUCCESS != OSPF_PMGR_AreaAuthenticationTypeSet(0, 1, ospfAreaEntry.area_id, ospfAreaEntry.auth_type))
                    return SNMP_ERR_COMMITFAILED;

            }
            break;

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_ospfImportAsExtern(int action,
                         u_char * var_val,
                         u_char var_val_type,
                         size_t var_val_len,
                         u_char * statP, oid * name, size_t name_len)
{
    UI32_T oid_name_length = 10;
    UI32_T value;
    OSPF_TYPE_Area_T old_area;

   /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  ospfAreaEntry_INSTANCE_LEN + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    SNMP_MGR_ReadIpFromCompl(name, oid_name_length,  &ospfAreaEntry.area_id);
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
            /* In reserve2, we overwrite the set value to ospfAreaEntry*/
            value = *(long *)var_val;
            if ((value <VAL_ospfImportAsExtern_importExternal) || (value >VAL_ospfImportAsExtern_importNssa))
                return SNMP_ERR_WRONGVALUE;

            switch(value)
            {
                case VAL_ospfImportAsExtern_importExternal:
                    ospfAreaEntry.external_routing = OSPF_AREA_DEFAULT;
                    break;
                case VAL_ospfImportAsExtern_importNoExternal:
                    ospfAreaEntry.external_routing = OSPF_AREA_STUB;
                    break;
                case VAL_ospfImportAsExtern_importNssa:
                    ospfAreaEntry.external_routing = OSPF_AREA_NSSA;
                    break;
                default:
                    break;
            }

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
           /* For row creation, if row_status =0, mean that this is a normal
            * operation, we do the normal set operation, otherwise it is a row
            * creation operation, will do nothing here, and the overall entry
            * will perform in the write_xxxRowStatus function.
            */
            if (ospfAreaEntry.status == 0)
            {
                UI32_T rc = OSPF_TYPE_RESULT_FAIL;
                memset(&old_area, 0, sizeof(old_area));
                old_area.vr_id = 0;
                old_area.proc_id = 1;
                old_area.area_id = ospfAreaEntry.area_id;
                /* get the old area type */
                if(OSPF_TYPE_RESULT_SUCCESS == OSPF_PMGR_GetAreaTable(&old_area))
                {
                    switch(old_area.external_routing)
                    {
                        case OSPF_AREA_DEFAULT:
                        {
                            OSPF_TYPE_Area_Nssa_Para_T nssa_para;
                            memset(&nssa_para, 0, sizeof(nssa_para));

                            if(OSPF_AREA_STUB == ospfAreaEntry.external_routing)
                                //rc = OSPF_PMGR_AreaStubUnset(0, 1, ospfAreaEntry.area_id, 0);
                                rc = OSPF_PMGR_AreaStubSet(0, 1, ospfAreaEntry.area_id, 1);
                            else if (OSPF_AREA_NSSA == ospfAreaEntry.external_routing)
                                //rc = OSPF_PMGR_AreaNssaUnset(0, 1, ospfAreaEntry.area_id, 0, 0);
                                rc = OSPF_PMGR_AreaNssaSet(0, 1, ospfAreaEntry.area_id, 1, &nssa_para);
                            else
                                rc = OSPF_TYPE_RESULT_SUCCESS;
                            break;
                        }
                        case OSPF_AREA_STUB:
                            if (OSPF_AREA_DEFAULT == ospfAreaEntry.external_routing)
                                //rc = OSPF_PMGR_AreaStubSet(0, 1, ospfAreaEntry.area_id, 1);
                                rc = OSPF_PMGR_AreaStubUnset(0, 1, ospfAreaEntry.area_id, 1);
                            else if (OSPF_AREA_NSSA == ospfAreaEntry.external_routing)
                                rc = OSPF_TYPE_RESULT_FAIL; /* stub -> nssa is not allowed. */
                            else
                                rc = OSPF_TYPE_RESULT_SUCCESS;
                            break;
                        case OSPF_AREA_NSSA:
                     //   {
                     //       OSPF_TYPE_Area_Nssa_Para_T nssa_para;
                     //       memset(&nssa_para, 0, sizeof(nssa_para));

                            if (OSPF_AREA_DEFAULT == ospfAreaEntry.external_routing)
                                //rc = OSPF_PMGR_AreaNssaSet(0, 1, ospfAreaEntry.area_id, 1, &nssa_para);
                                rc = OSPF_PMGR_AreaNssaUnset(0, 1, ospfAreaEntry.area_id, 1, 0);
                            else if (OSPF_AREA_STUB == ospfAreaEntry.external_routing)
                                rc = OSPF_TYPE_RESULT_FAIL; /* nssa -> stub is not allowed. */
                            else
                                rc = OSPF_TYPE_RESULT_SUCCESS;
                            break;
                      //  }
                        default:
                            break;

                    }
                } // if
                if(OSPF_TYPE_RESULT_SUCCESS != rc)
                    return SNMP_ERR_COMMITFAILED;
            }
            break;
        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_ospfAreaSummary(int action,
                      u_char * var_val,
                      u_char var_val_type,
                      size_t var_val_len,
                      u_char * statP, oid * name, size_t name_len)
{
    UI32_T oid_name_length = 10;
    UI32_T value;

   /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  ospfAreaEntry_INSTANCE_LEN + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    SNMP_MGR_ReadIpFromCompl(name, oid_name_length, &ospfAreaEntry.area_id);
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          /* In reserve2, we overwrite the set value to ospfAreaEntry*/
          value = *(long *)var_val;
          if ((value <VAL_ospfAreaSummary_noAreaSummary) || (value >VAL_ospfAreaSummary_sendAreaSummary))
             return SNMP_ERR_WRONGVALUE;

            if(value == VAL_ospfAreaSummary_noAreaSummary)
                SET_FLAG(ospfAreaEntry.config, OSPF_AREA_CONF_NO_SUMMARY);
            else if (value == VAL_ospfAreaSummary_sendAreaSummary)
                UNSET_FLAG(ospfAreaEntry.config, OSPF_AREA_CONF_NO_SUMMARY);

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
           /* For row creation, if row_status =0, mean that this is a normal
            * operation, we do the normal set operation, otherwise it is a row
            * creation operation, will do nothing here, and the overall entry
            * will perform in the write_xxxRowStatus function.
            */
            if (ospfAreaEntry.status == 0)
            {
                UI32_T rc = OSPF_TYPE_RESULT_FAIL;

                if(CHECK_FLAG(ospfAreaEntry.config, OSPF_AREA_CONF_NO_SUMMARY))
                    rc = OSPF_PMGR_AreaStubNoSummarySet(0, 1, ospfAreaEntry.area_id, 1);
                else
                    rc = OSPF_PMGR_AreaStubNoSummaryUnset(0, 1, ospfAreaEntry.area_id, 1);

                if(OSPF_TYPE_RESULT_SUCCESS != rc)
                    return SNMP_ERR_COMMITFAILED;


#if 0
            if (OSPF_PMGR_SetArea(&ospfAreaEntry)!= OSPF_TYPE_RESULT_SUCCESS)
            {
                   return SNMP_ERR_COMMITFAILED;
            }
#endif
           } /* if */
        break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_ospfAreaStatus(int action,
                     u_char * var_val,
                     u_char var_val_type,
                     size_t var_val_len,
                     u_char * statP, oid * name, size_t name_len)
{
    UI32_T oid_name_length = 10;
 //   UI32_T ip_address;
    UI32_T value;

   /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  ospfAreaEntry_INSTANCE_LEN + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    SNMP_MGR_ReadIpFromCompl(name, oid_name_length,  &ospfAreaEntry.area_id);
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
         /* In reserve2, we overwrite the set value to ospfAreaEntry*/
          value = *(long *)var_val;
          if ((value <VAL_ospfAreaStatus_active) || (value >VAL_ospfAreaStatus_destroy))
             return SNMP_ERR_WRONGVALUE;
          ospfAreaEntry.status = value;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
          /* We perform the row creation here, if the row status = 4(createAndGo),
           * or 5 (createAndWait), we call the SetByEntry API, otherwise, call the
           * set rowstatus API
           */
          switch (ospfAreaEntry.status)
          {
               case VAL_ospfAreaStatus_createAndGo:
               case VAL_ospfAreaStatus_createAndWait:
               case VAL_ospfAreaStatus_active:
               case VAL_ospfAreaStatus_notInService:
               case VAL_ospfAreaStatus_notReady:
               case VAL_ospfAreaStatus_destroy:
                if (OSPF_PMGR_SetAreaStatus(&ospfAreaEntry) != OSPF_TYPE_RESULT_SUCCESS)
                {
                    return SNMP_ERR_COMMITFAILED;
                }
                break;
              default:
                return SNMP_ERR_COMMITFAILED;
          }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


/*
 * ospfStubAreaTable_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

static oid    ospfStubAreaTable_variables_oid[] =
    { 1, 3, 6, 1, 2, 1, 14 };

/*
 * variable3 ospfStubAreaTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */

struct variable3 ospfStubAreaTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */

#define OSPFSTUBAREAID      1
    {OSPFSTUBAREAID, ASN_IPADDRESS, RONLY, var_ospfStubAreaTable, 3,
     {3, 1, 1}},
#define OSPFSTUBTOS     2
    {OSPFSTUBTOS, ASN_INTEGER, RONLY, var_ospfStubAreaTable, 3, {3, 1, 2}},
#define OSPFSTUBMETRIC      3
    {OSPFSTUBMETRIC, ASN_INTEGER, RWRITE, var_ospfStubAreaTable, 3,
     {3, 1, 3}},
#define OSPFSTUBSTATUS      4
    {OSPFSTUBSTATUS, ASN_INTEGER, RWRITE, var_ospfStubAreaTable, 3,
     {3, 1, 4}},
#define OSPFSTUBMETRICTYPE      5
    {OSPFSTUBMETRICTYPE, ASN_INTEGER, RWRITE, var_ospfStubAreaTable, 3,
     {3, 1, 5}},
};
/*
 * (L = length of the oidsuffix)
 */


/** Initializes the ospfStubAreaTable module */
void
init_ospfStubAreaTable(void)
{

    /*
     * register ourselves with the agent to handle our mib tree
     */
    REGISTER_MIB("ospfStubAreaTable", ospfStubAreaTable_variables,
                 variable3, ospfStubAreaTable_variables_oid);

    /*
     * place any other initialization junk you need here
     */
}

static BOOL_T ospfStubAreaTable_get(int      compc,
                                oid     *compl,
                                OSPF_TYPE_Stub_Area_T   *data)
{
    if (compc !=ospfStubAreaEntry_INSTANCE_LEN)
    {
        return FALSE;
    }
    SNMP_MGR_ReadIpFromCompl(compl,0, &data->area_id);
    data->stub_tos = compl[4];

    if (OSPF_PMGR_GetStubAreaTable(data)!=OSPF_TYPE_RESULT_SUCCESS)
    {
        return FALSE;
    }
    else
    {
        return TRUE;

    } /*End of if */
}

static BOOL_T ospfStubAreaTable_next(int      compc,
                                 oid     *compl,
                                 OSPF_TYPE_Stub_Area_T    *data)
{
    oid tmp_compl[ospfStubAreaEntry_INSTANCE_LEN];

    /* Generate the instance of each table entry and find the
     * smallest instance that's larger than compc/compl.
     *
     * Step 1: Verify and extract the input key from "compc" and "compl"
     * Note: The number of input key is defined by "compc".
     *       The key for the specified instance is defined in compl.
     */
    memcpy(tmp_compl, compl, sizeof(tmp_compl));
    SNMP_MGR_checkCompl(0, 3, tmp_compl,255);
    SNMP_MGR_ConvertRemainToZero(compc,ospfStubAreaEntry_INSTANCE_LEN, tmp_compl);

    SNMP_MGR_ReadIpFromCompl(tmp_compl,0,&data->area_id);
    data->stub_tos = tmp_compl[4];

    if (compc<ospfStubAreaEntry_INSTANCE_LEN)
    {
        data->indexlen = 0;
        if (OSPF_PMGR_GetStubAreaTable(data)!=OSPF_TYPE_RESULT_SUCCESS)
        {
            if (OSPF_PMGR_GetNextStubAreaTable(data)!=OSPF_TYPE_RESULT_SUCCESS)
            {
                return FALSE;
            }
        }
    }
    else
    {
        data->indexlen = 5;

        if (OSPF_PMGR_GetNextStubAreaTable(data)!=OSPF_TYPE_RESULT_SUCCESS)
        {
            return FALSE;
        }
    }
    return TRUE;
}


/* This entry is used for entry which have the ability to row create*/
static OSPF_TYPE_Stub_Area_T ospfStubAreaEntry;

/*
 * var_ospfStubAreaTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_ospfStubAreaTable(struct variable *vp,
                      oid * name,
                      size_t * length,
                      int exact,
                      size_t * var_len, WriteMethod ** write_method)
{
    UI32_T compc=0;
    oid compl[ospfStubAreaEntry_INSTANCE_LEN];
    oid best_inst[ospfStubAreaEntry_INSTANCE_LEN];
    OSPF_TYPE_Stub_Area_T data;


    /* Give default value for the record first.
     * We use the row_status = 0 to indicate if this set operation is Set by field
     * or set by record(included row creation), if the row_status =0, this record
     * mean set by field, otherwise, we just think it is a normal set operation
     */
    memset(&ospfStubAreaEntry, 0, sizeof(ospfStubAreaEntry));
    ospfStubAreaEntry.vr_id = 0;
    ospfStubAreaEntry.proc_id = 1;


   /*Since this table allow for entry that does not exist, (creation). we need to know the write method first*/
    switch (vp->magic)
    {
      case OSPFSTUBMETRIC:
        *write_method = write_ospfStubMetric;
        break;
      case OSPFSTUBSTATUS:
        *write_method = write_ospfStubStatus;
        break;
      case OSPFSTUBMETRICTYPE:
        *write_method = write_ospfStubMetricType;
        break;
      default:
         *write_method =0;
         break;
    }

    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,compl, ospfStubAreaEntry_INSTANCE_LEN);

    memset(&data, 0, sizeof(data));
    /* set default vr_id, proc_id */
    data.vr_id = 0;
    data.proc_id = 1;
    data.indexlen = 0;

     /*check compc, retrive compl*/
    if (exact)/*get,set*/
    {
        if (!ospfStubAreaTable_get(compc, compl, &data))
            return NULL;
    }
    else/*getnext*/
    {
        if (!ospfStubAreaTable_next(compc, compl, &data))
        {
            return NULL;
        }
    }
    memcpy(name, vp->name, vp->namelen*sizeof(oid));
    SNMP_MGR_BindIpInstance(data.area_id,0,best_inst);
    best_inst[4]= data.stub_tos;

    memcpy(name + vp->namelen, best_inst, ospfStubAreaEntry_INSTANCE_LEN*sizeof(oid));
    *length = vp->namelen +ospfStubAreaEntry_INSTANCE_LEN;

    *var_len = sizeof(long_return);

    /*
     * * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
      case OSPFSTUBAREAID:
        *var_len = sizeof(ipaddr_return);
        ipaddr_return = data.area_id;
        return (u_char*) &ipaddr_return;
      case OSPFSTUBTOS:
         long_return = data.stub_tos;
        return (u_char*) &long_return;
      case OSPFSTUBMETRIC:
        long_return = data.default_cost;
        return (u_char*) &long_return;
      case OSPFSTUBSTATUS:
         long_return = data.status;
        return (u_char*) &long_return;
      case OSPFSTUBMETRICTYPE:
         long_return = data.metric_type;
        return (u_char*) &long_return;
    default:
        break;
    }
    return NULL;
}


int
write_ospfStubMetric(int action,
                     u_char * var_val,
                     u_char var_val_type,
                     size_t var_val_len,
                     u_char * statP, oid * name, size_t name_len)
{
    UI32_T oid_name_length = 10;
//    UI32_T ip_address;
    UI32_T data;

   /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  ospfStubAreaEntry_INSTANCE_LEN + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    SNMP_MGR_ReadIpFromCompl(name, oid_name_length,  &ospfStubAreaEntry.area_id);
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          /* In reserve2, we overwrite the set value to cHsrpExtIfTrackedEntry*/
          data = *(long *)var_val;
          if ((data <MIN_ospfStubMetric) || (data >MAX_ospfStubMetric))
             return SNMP_ERR_WRONGVALUE;
          ospfStubAreaEntry.default_cost = data;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
           /* For row creation, if row_status =0, mean that this is a normal
            * operation, we do the normal set operation, otherwise it is a row
            * creation operation, will do nothing here, and the overall entry
            * will perform in the write_xxxRowStatus function.
            */
            if (ospfStubAreaEntry.status == 0)
            {
                int tos = 0;
                if (OSPF_PMGR_StubAreaMetricSet(0, 1, ospfStubAreaEntry.area_id, tos, ospfStubAreaEntry.default_cost)!= OSPF_TYPE_RESULT_SUCCESS)
                {
                    return SNMP_ERR_COMMITFAILED;
                }
            }
            break;
        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_ospfStubStatus(int action,
                     u_char * var_val,
                     u_char var_val_type,
                     size_t var_val_len,
                     u_char * statP, oid * name, size_t name_len)
{

    UI32_T oid_name_length = 10;
    //UI32_T ip_address;
    UI32_T data;

   /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  ospfStubAreaEntry_INSTANCE_LEN + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    SNMP_MGR_ReadIpFromCompl(name, oid_name_length,  &ospfStubAreaEntry.area_id);
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
           /* In reserve2, we overwrite the set value to cHsrpExtIfTrackedEntry*/
          data = *(long *)var_val;
          if ((data <VAL_ospfStubStatus_active) || (data >VAL_ospfStubStatus_destroy))
             return SNMP_ERR_WRONGVALUE;
            ospfStubAreaEntry.status = data;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
           /* We perform the row creation here, if the row status = 4(createAndGo),
           * or 5 (createAndWait), we call the SetByEntry API, otherwise, call the
           * set rowstatus API
           */

            switch (ospfStubAreaEntry.status)
            {

                case VAL_ospfStubStatus_createAndGo:
                case VAL_ospfStubStatus_createAndWait:
                case VAL_ospfStubStatus_active:
                case VAL_ospfStubStatus_notInService:
                case VAL_ospfStubStatus_notReady:
                case VAL_ospfStubStatus_destroy:
                    ospfStubAreaEntry.stub_tos=name[14];
                    if (OSPF_PMGR_StubAreaStatusSet(0, 1, ospfStubAreaEntry.area_id, ospfStubAreaEntry.stub_tos, ospfStubAreaEntry.status)!= OSPF_TYPE_RESULT_SUCCESS)
                    {
                    return SNMP_ERR_COMMITFAILED;
                    }
                    break;
                default:
                    return SNMP_ERR_COMMITFAILED;
          }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_ospfStubMetricType(int action,
                         u_char * var_val,
                         u_char var_val_type,
                         size_t var_val_len,
                         u_char * statP, oid * name, size_t name_len)
{
    UI32_T oid_name_length = 10;
    UI32_T data=0;


   /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  ospfStubAreaEntry_INSTANCE_LEN + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    SNMP_MGR_ReadIpFromCompl(name, oid_name_length,  &ospfStubAreaEntry.area_id);
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
           /* In reserve2, we overwrite the set value to cHsrpExtIfTrackedEntry*/
          data = *(long *)var_val;
          if ((data <VAL_ospfStubMetricType_ospfMetric) || (data >VAL_ospfStubMetricType_nonComparable))
             return SNMP_ERR_WRONGVALUE;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
           /* For row creation, if row_status =0, mean that this is a normal
            * operation, we do the normal set operation, otherwise it is a row
            * creation operation, will do nothing here, and the overall entry
            * will perform in the write_xxxRowStatus function.
            */
           if (ospfStubAreaEntry.status == 0)
           {
            int tos = name[14];
             if (OSPF_PMGR_StubAreaMetricTypeSet(0, 1, ospfStubAreaEntry.area_id, tos, data)!= OSPF_TYPE_RESULT_SUCCESS)
             {
                return SNMP_ERR_COMMITFAILED;
             }
           }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


/*
 * ospfLsdbTable_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid             ospfLsdbTable_variables_oid[] =
    { 1, 3, 6, 1, 2, 1, 14 };

/*
 * variable4 ospfLsdbTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */

struct variable3 ospfLsdbTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */

#define OSPFLSDBAREAID      1
    {OSPFLSDBAREAID, ASN_IPADDRESS, RONLY, var_ospfLsdbTable, 3,
     {4, 1, 1}},
#define OSPFLSDBTYPE        2
    {OSPFLSDBTYPE, ASN_INTEGER, RONLY, var_ospfLsdbTable, 3, {4, 1, 2}},
#define OSPFLSDBLSID        3
    {OSPFLSDBLSID, ASN_IPADDRESS, RONLY, var_ospfLsdbTable, 3, {4, 1, 3}},
#define OSPFLSDBROUTERID        4
    {OSPFLSDBROUTERID, ASN_IPADDRESS, RONLY, var_ospfLsdbTable, 3,
     {4, 1, 4}},
#define OSPFLSDBSEQUENCE        5
    {OSPFLSDBSEQUENCE, ASN_INTEGER, RONLY, var_ospfLsdbTable, 3,
     {4, 1, 5}},
#define OSPFLSDBAGE     6
    {OSPFLSDBAGE, ASN_INTEGER, RONLY, var_ospfLsdbTable, 3, {4, 1, 6}},
#define OSPFLSDBCHECKSUM        7
    {OSPFLSDBCHECKSUM, ASN_INTEGER, RONLY, var_ospfLsdbTable, 3,
     {4, 1, 7}},
#define OSPFLSDBADVERTISEMENT       8
    {OSPFLSDBADVERTISEMENT, ASN_OCTET_STR, RONLY, var_ospfLsdbTable, 3,
     {4, 1, 8}},
};
/*
 * (L = length of the oidsuffix)
 */


/** Initializes the ospfLsdbTable module */
void
init_ospfLsdbTable(void)
{


    /*
     * register ourselves with the agent to handle our mib tree
     */
    REGISTER_MIB("ospfLsdbTable", ospfLsdbTable_variables, variable3,
                 ospfLsdbTable_variables_oid);

    /*
     * place any other initialization junk you need here
     */
}

static BOOL_T ospfLsdbTable_get(int      compc,
                                oid     *compl,
                                OSPF_TYPE_MultiProcessLsdb_T   *data)
{
    if (compc !=ospfLsdbEntry_INSTANCE_LEN)
    {
        return FALSE;
    }
    SNMP_MGR_ReadIpFromCompl(compl,0, (UI32_T *)&data->LsdbArea_id.s_addr);
    data->LsdbType = compl[4];
    SNMP_MGR_ReadIpFromCompl(compl,5, (UI32_T *)&data->LsdbLsid.s_addr);
    SNMP_MGR_ReadIpFromCompl(compl,9, (UI32_T *)&data->LsdbRouter_id.s_addr);

    if (OSPF_PMGR_GetMultiProcessLsdbEntry(0, data)!=OSPF_TYPE_RESULT_SUCCESS)
    {
        return FALSE;
    }
    else
    {
        return TRUE;

    } /*End of if */
}

static BOOL_T ospfLsdbTable_next(int      compc,
                                 oid     *compl,
                                 OSPF_TYPE_MultiProcessLsdb_T    *data)
{
    oid tmp_compl[ospfLsdbEntry_INSTANCE_LEN];

    /* Generate the instance of each table entry and find the
     * smallest instance that's larger than compc/compl.
     *
     * Step 1: Verify and extract the input key from "compc" and "compl"
     * Note: The number of input key is defined by "compc".
     *       The key for the specified instance is defined in compl.
     */
    memcpy(tmp_compl, compl, sizeof(tmp_compl));
    SNMP_MGR_checkCompl(0, 3, tmp_compl,255);
    SNMP_MGR_checkCompl(5, 8, tmp_compl,255);
    SNMP_MGR_checkCompl(9, 12, tmp_compl,255);
    SNMP_MGR_ConvertRemainToZero(compc,ospfLsdbEntry_INSTANCE_LEN, tmp_compl);

    SNMP_MGR_ReadIpFromCompl(tmp_compl,0,(UI32_T *) &data->LsdbArea_id.s_addr);
    data->LsdbType = tmp_compl[4];
    SNMP_MGR_ReadIpFromCompl(tmp_compl,5,(UI32_T *)&data->LsdbLsid.s_addr);
    SNMP_MGR_ReadIpFromCompl(tmp_compl,9,(UI32_T *)&data->LsdbRouter_id.s_addr);

    if (compc<ospfLsdbEntry_INSTANCE_LEN)
    {
        if (OSPF_PMGR_GetMultiProcessLsdbEntry(0, data)!=OSPF_TYPE_RESULT_SUCCESS)
        {
            if (OSPF_PMGR_GetNextMultiProcessLsdbEntry(0, compc, data)!=OSPF_TYPE_RESULT_SUCCESS)
            {
                return FALSE;
            }
        }
    }
    else
    {
        if (OSPF_PMGR_GetNextMultiProcessLsdbEntry(0, compc, data)!=OSPF_TYPE_RESULT_SUCCESS)
        {
            return FALSE;
        }
    }
    return TRUE;
}


/*
 * var_ospfLsdbTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_ospfLsdbTable(struct variable *vp,
                  oid * name,
                  size_t * length,
                  int exact, size_t * var_len, WriteMethod ** write_method)
{
    UI32_T compc=0;
    oid compl[ospfLsdbEntry_INSTANCE_LEN];
    oid best_inst[ospfLsdbEntry_INSTANCE_LEN];
    OSPF_TYPE_MultiProcessLsdb_T data;

    memset(&data, 0, sizeof(data));
    /* set default vr_id, proc_id */
    data.proc_id = 1;
//    data.indexlen = 0;
     /*check compc, retrive compl*/

    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,compl, ospfLsdbEntry_INSTANCE_LEN);

     /*check compc, retrive compl*/
    if (exact)/*get,set*/
    {
        if (!ospfLsdbTable_get(compc, compl, &data))
            return NULL;
    }
    else/*getnext*/
    {
        if (!ospfLsdbTable_next(compc, compl, &data))
        {
            return NULL;
        }
    }
    memcpy(name, vp->name, vp->namelen*sizeof(oid));
    SNMP_MGR_BindIpInstance(data.LsdbArea_id.s_addr,0,best_inst);
    best_inst[4]= data.LsdbType;
    SNMP_MGR_BindIpInstance(data.LsdbLsid.s_addr,5,best_inst);
    SNMP_MGR_BindIpInstance(data.LsdbRouter_id.s_addr,9,best_inst);


    memcpy(name + vp->namelen, best_inst, ospfLsdbEntry_INSTANCE_LEN*sizeof(oid));
    *length = vp->namelen +ospfLsdbEntry_INSTANCE_LEN;

    *var_len = sizeof(long_return);
    *write_method = 0;

    /*
     * * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
      case OSPFLSDBAREAID:
        *var_len = sizeof(ipaddr_return);
        ipaddr_return = data.LsdbArea_id.s_addr;
        return (u_char*) &ipaddr_return;
      case OSPFLSDBTYPE:
       long_return = data.LsdbType;
        return (u_char*) &long_return;
      case OSPFLSDBLSID:
        *var_len = sizeof(ipaddr_return);
        ipaddr_return = data.LsdbLsid.s_addr;
        return (u_char*) &ipaddr_return;
      case OSPFLSDBROUTERID:
        *var_len = sizeof(ipaddr_return);
        ipaddr_return = data.LsdbRouter_id.s_addr;
        return (u_char*) &ipaddr_return;
      case OSPFLSDBSEQUENCE:
        long_return = data.LsdbSeqence;
        return (u_char*) &long_return;
      case OSPFLSDBAGE:
        long_return = data.LsdbAge;
        return (u_char*) &long_return;
      case OSPFLSDBCHECKSUM:
        long_return = data.LsdbChecksum;
        return (u_char*) &long_return;
      case OSPFLSDBADVERTISEMENT:
        memcpy(return_buf, data.LsdbAdvertise, data.LsdbAdvertise_size);
        *var_len = data.LsdbAdvertise_size;
        return (u_char*) return_buf;
    default:
        break;
    }
    return NULL;
}

/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.old-api.conf,v 1.3 2002/10/17 09:40:46 dts12 Exp $
 */

/*
 * ospfHostTable_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid             ospfHostTable_variables_oid[] =
    { 1, 3, 6, 1, 2, 1, 14};

/*
 * variable4 ospfHostTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */

struct variable3 ospfHostTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */

#define OSPFHOSTIPADDRESS       1
    {OSPFHOSTIPADDRESS, ASN_IPADDRESS, RONLY, var_ospfHostTable, 3,
     {6, 1, 1}},
#define OSPFHOSTTOS     2
    {OSPFHOSTTOS, ASN_INTEGER, RONLY, var_ospfHostTable, 3, {6, 1, 2}},
#define OSPFHOSTMETRIC      3
    {OSPFHOSTMETRIC, ASN_INTEGER, RWRITE, var_ospfHostTable, 3, {6, 1, 3}},
#define OSPFHOSTSTATUS      4
    {OSPFHOSTSTATUS, ASN_INTEGER, RWRITE, var_ospfHostTable, 3, {6, 1, 4}},
#define OSPFHOSTAREAID      5
    {OSPFHOSTAREAID, ASN_IPADDRESS, RONLY, var_ospfHostTable, 3,
     {6, 1, 5}},
};
/*
 * (L = length of the oidsuffix)
 */


/** Initializes the ospfHostTable module */
void
init_ospfHostTable(void)
{

    /*
     * register ourselves with the agent to handle our mib tree
     */
    REGISTER_MIB("ospfHostTable", ospfHostTable_variables, variable3,
                 ospfHostTable_variables_oid);

    /*
     * place any other initialization junk you need here
     */
}

static BOOL_T ospfHostTable_get(int      compc,
                                oid     *compl,
                                OSPF_TYPE_HostEntry_T   *data)
{
    if (compc !=ospfHostEntry_INSTANCE_LEN)
    {
        return FALSE;
    }
    SNMP_MGR_ReadIpFromCompl(compl,0, &data->ip_address);
    data->tos = compl[4];

    if (OSPF_PMGR_GetHostEntry(data)!=OSPF_TYPE_RESULT_SUCCESS)
    {
        return FALSE;
    }
    else
    {
        return TRUE;

    } /*End of if */
}

static BOOL_T ospfHostTable_next(int      compc,
                                 oid     *compl,
                                 OSPF_TYPE_HostEntry_T    *data)
{
    oid tmp_compl[ospfHostEntry_INSTANCE_LEN];

    /* Generate the instance of each table entry and find the
     * smallest instance that's larger than compc/compl.
     *
     * Step 1: Verify and extract the input key from "compc" and "compl"
     * Note: The number of input key is defined by "compc".
     *       The key for the specified instance is defined in compl.
     */
    memcpy(tmp_compl, compl, sizeof(tmp_compl));
    SNMP_MGR_checkCompl(0, 3, tmp_compl,255);
    SNMP_MGR_ConvertRemainToZero(compc,ospfHostEntry_INSTANCE_LEN, tmp_compl);

    SNMP_MGR_ReadIpFromCompl(tmp_compl,0,&data->ip_address);
    data->tos = tmp_compl[4];

    if (compc<ospfHostEntry_INSTANCE_LEN)
    {
        if (OSPF_PMGR_GetHostEntry(data)!=OSPF_TYPE_RESULT_SUCCESS)
        {
            if (OSPF_PMGR_GetNextHostEntry(data)!=OSPF_TYPE_RESULT_SUCCESS)
            {
                return FALSE;
            }
        }
    }
    else
    {
        if (OSPF_PMGR_GetNextHostEntry(data)!=OSPF_TYPE_RESULT_SUCCESS)
        {
            return FALSE;
        }
    }
    return TRUE;
}


/*
//!!!!!!!!!!!!!!!!!!!!!!
//hyliao said that this table is not support get whole entry and get default api now,
//!!!!!!!!!!!!!!!!!!!!!!!
*/

/*
 * var_ospfHostTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_ospfHostTable(struct variable *vp,
                  oid * name,
                  size_t * length,
                  int exact, size_t * var_len, WriteMethod ** write_method)
{
    UI32_T compc=0;
    oid compl[ospfHostEntry_INSTANCE_LEN];
    oid best_inst[ospfHostEntry_INSTANCE_LEN];
    OSPF_TYPE_HostEntry_T data;


   /*Since this table allow for entry that does not exist, (creation). we need to know the write method first*/
    switch (vp->magic)
    {
      case OSPFHOSTMETRIC:
        *write_method = write_ospfHostMetric;
        break;
      case OSPFHOSTSTATUS:
        *write_method = write_ospfHostStatus;
        break;
      default:
        *write_method =0;
         break;
    }

    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,compl, ospfHostEntry_INSTANCE_LEN);

    memset(&data, 0, sizeof(data));
    /* set default vr_id, proc_id */
    data.vr_id = 0;
    data.proc_id = 1;


     /*check compc, retrive compl*/
    if (exact)/*get,set*/
    {
        if (!ospfHostTable_get(compc, compl, &data))
            return NULL;
    }
    else/*getnext*/
    {
        if (!ospfHostTable_next(compc, compl, &data))
        {
            return NULL;
        }
    }
    memcpy(name, vp->name, vp->namelen*sizeof(oid));
    SNMP_MGR_BindIpInstance(data.ip_address,0,best_inst);
    best_inst[4]= data.tos;

    memcpy(name + vp->namelen, best_inst, ospfHostEntry_INSTANCE_LEN*sizeof(oid));
    *length = vp->namelen +ospfHostEntry_INSTANCE_LEN;

    *var_len = sizeof(long_return);

    /*
     * * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
      case OSPFHOSTIPADDRESS:
        *var_len = sizeof(ipaddr_return);
        ipaddr_return = data.ip_address;
        return (u_char*) &ipaddr_return;
      case OSPFHOSTTOS:
        long_return = data.tos;
        return (u_char*) &long_return;
      case OSPFHOSTMETRIC:
        long_return = data.metric;
        return (u_char*) &long_return;
      case OSPFHOSTSTATUS:
        long_return = data.status;
        return (u_char*) &long_return;
      case OSPFHOSTAREAID:
        *var_len = sizeof(ipaddr_return);
        ipaddr_return = data.area_id;
        return (u_char*) &ipaddr_return;
    default:
        ERROR_MSG("");
    }
    return NULL;
}


int
write_ospfHostMetric(int action,
                     u_char * var_val,
                     u_char var_val_type,
                     size_t var_val_len,
                     u_char * statP, oid * name, size_t name_len)
{
    long value;
    UI32_T oid_name_length = 10;
    UI32_T ip_address;


   /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  ospfHostEntry_INSTANCE_LEN + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    SNMP_MGR_ReadIpFromCompl(name, oid_name_length,  &ip_address);
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          value = *(long *)var_val;
          if ((value <MIN_ospfHostMetric) || (value >MAX_ospfHostMetric))
             return SNMP_ERR_WRONGVALUE;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             value = *(long *)var_val;
             if (OSPF_PMGR_SetHostMetric(0, 1, ip_address, name[14], value)!= OSPF_TYPE_RESULT_SUCCESS)
             {
                return SNMP_ERR_COMMITFAILED;
             }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_ospfHostStatus(int action,
                     u_char * var_val,
                     u_char var_val_type,
                     size_t var_val_len,
                     u_char * statP, oid * name, size_t name_len)
{
    long value;
    UI32_T oid_name_length = 10;
    UI32_T ip_address;


   /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  ospfHostEntry_INSTANCE_LEN + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    SNMP_MGR_ReadIpFromCompl(name, oid_name_length,  &ip_address);
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          value = *(long *)var_val;
          if ((value <VAL_ospfHostStatus_active) || (value >VAL_ospfHostStatus_destroy))
             return SNMP_ERR_WRONGVALUE;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             value = *(long *)var_val;
             if (OSPF_PMGR_SetHostStatus(0, 1, ip_address, name[14], value)!= OSPF_TYPE_RESULT_SUCCESS)
             {
                return SNMP_ERR_COMMITFAILED;
             }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.old-api.conf,v 1.3 2002/10/17 09:40:46 dts12 Exp $
 */

/*
 * ospfIfTable_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid             ospfIfTable_variables_oid[] = { 1, 3, 6, 1, 2, 1, 14 };

/*
 * variable4 ospfIfTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */

struct variable3 ospfIfTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */

#define OSPFIFIPADDRESS     1
    {OSPFIFIPADDRESS, ASN_IPADDRESS, RONLY, var_ospfIfTable, 3, {7, 1, 1}},
#define OSPFADDRESSLESSIF       2
    {OSPFADDRESSLESSIF, ASN_INTEGER, RONLY, var_ospfIfTable, 3, {7, 1, 2}},
#define OSPFIFAREAID        3
    {OSPFIFAREAID, ASN_IPADDRESS, RWRITE, var_ospfIfTable, 3, {7, 1, 3}},
#define OSPFIFTYPE      4
    {OSPFIFTYPE, ASN_INTEGER, RWRITE, var_ospfIfTable, 3, {7, 1, 4}},
#define OSPFIFADMINSTAT     5
    {OSPFIFADMINSTAT, ASN_INTEGER, RWRITE, var_ospfIfTable, 3, {7, 1, 5}},
#define OSPFIFRTRPRIORITY       6
    {OSPFIFRTRPRIORITY, ASN_INTEGER, RWRITE, var_ospfIfTable, 3,
     {7, 1, 6}},
#define OSPFIFTRANSITDELAY      7
    {OSPFIFTRANSITDELAY, ASN_INTEGER, RWRITE, var_ospfIfTable, 3,
     {7, 1, 7}},
#define OSPFIFRETRANSINTERVAL       8
    {OSPFIFRETRANSINTERVAL, ASN_INTEGER, RWRITE, var_ospfIfTable, 3,
     {7, 1, 8}},
#define OSPFIFHELLOINTERVAL     9
    {OSPFIFHELLOINTERVAL, ASN_INTEGER, RWRITE, var_ospfIfTable, 3,
     {7, 1, 9}},
#define OSPFIFRTRDEADINTERVAL       10
    {OSPFIFRTRDEADINTERVAL, ASN_INTEGER, RWRITE, var_ospfIfTable, 3,
     {7, 1, 10}},
#define OSPFIFPOLLINTERVAL      11
    {OSPFIFPOLLINTERVAL, ASN_INTEGER, RWRITE, var_ospfIfTable, 3,
     {7, 1, 11}},
#define OSPFIFSTATE     12
    {OSPFIFSTATE, ASN_INTEGER, RONLY, var_ospfIfTable, 3, {7, 1, 12}},
#define OSPFIFDESIGNATEDROUTER      13
    {OSPFIFDESIGNATEDROUTER, ASN_IPADDRESS, RONLY, var_ospfIfTable, 3,
     {7, 1, 13}},
#define OSPFIFBACKUPDESIGNATEDROUTER        14
    {OSPFIFBACKUPDESIGNATEDROUTER, ASN_IPADDRESS, RONLY, var_ospfIfTable,
     3, {7, 1, 14}},
#define OSPFIFEVENTS        15
    {OSPFIFEVENTS, ASN_COUNTER, RONLY, var_ospfIfTable, 3, {7, 1, 15}},
#define OSPFIFAUTHKEY       16
    {OSPFIFAUTHKEY, ASN_OCTET_STR, RWRITE, var_ospfIfTable, 3, {7, 1, 16}},
#define OSPFIFSTATUS        17
    {OSPFIFSTATUS, ASN_INTEGER, RWRITE, var_ospfIfTable, 3, {7, 1, 17}},
#define OSPFIFMULTICASTFORWARDING       18
    {OSPFIFMULTICASTFORWARDING, ASN_INTEGER, RWRITE, var_ospfIfTable, 3,
     {7, 1, 18}},
#define OSPFIFDEMAND        19
    {OSPFIFDEMAND, ASN_INTEGER, RWRITE, var_ospfIfTable, 3, {7, 1, 19}},
#define OSPFIFAUTHTYPE      20
    {OSPFIFAUTHTYPE, ASN_INTEGER, RWRITE, var_ospfIfTable, 3, {7, 1, 20}},
};
/*
 * (L = length of the oidsuffix)
 */


/** Initializes the ospfIfTable module */
void
init_ospfIfTable(void)
{
    /*
     * register ourselves with the agent to handle our mib tree
     */
    REGISTER_MIB("ospfIfTable", ospfIfTable_variables, variable3,
                 ospfIfTable_variables_oid);

}

static BOOL_T ospfIfTable_get(int      compc,
                                oid     *compl,
                                OSPF_TYPE_Msg_OspfInterfac_T   *data)
{
    if (compc !=ospfIfEntry_INSTANCE_LEN)
    {
        return FALSE;
    }
    SNMP_MGR_ReadIpFromCompl(compl,0, (UI32_T *)&data->if_addr.s_addr);
    data->addressless_if = compl[4];

    if (OSPF_PMGR_GetMultiProcIfEntry(0, 0, data)!=OSPF_TYPE_RESULT_SUCCESS)
    {
        return FALSE;
    }
    else
    {
        return TRUE;

    } /*End of if */
}

static BOOL_T ospfIfTable_next(int      compc,
                                 oid     *compl,
                                 OSPF_TYPE_Msg_OspfInterfac_T    *data)
{
    oid tmp_compl[ospfIfEntry_INSTANCE_LEN];

    /* Generate the instance of each table entry and find the
     * smallest instance that's larger than compc/compl.
     *
     * Step 1: Verify and extract the input key from "compc" and "compl"
     * Note: The number of input key is defined by "compc".
     *       The key for the specified instance is defined in compl.
     */
    memcpy(tmp_compl, compl, sizeof(tmp_compl));
    SNMP_MGR_checkCompl(0, 3, tmp_compl,255);
    SNMP_MGR_ConvertRemainToZero(compc,ospfIfEntry_INSTANCE_LEN, tmp_compl);

    SNMP_MGR_ReadIpFromCompl(tmp_compl,0,(UI32_T *)&data->if_addr.s_addr);
    data->addressless_if = tmp_compl[4];

    if (compc<ospfIfEntry_INSTANCE_LEN)
    {
        if (OSPF_PMGR_GetMultiProcIfEntry(0, 0, data)!=OSPF_TYPE_RESULT_SUCCESS)
        {
            if (OSPF_PMGR_GetNextMultiProcIfEntry(0, 0, data)!=OSPF_TYPE_RESULT_SUCCESS)
            {
                return FALSE;
            }
        }
    }
    else
    {
        if (OSPF_PMGR_GetNextMultiProcIfEntry(0, 0, data)!=OSPF_TYPE_RESULT_SUCCESS)
        {
            return FALSE;
        }
    }
    return TRUE;
}

/* This entry is used for entry which have the ability to row create*/
static OSPF_TYPE_Msg_OspfInterfac_T ospfIfEntry;

/*
 * var_ospfIfTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_ospfIfTable(struct variable *vp,
                oid * name,
                size_t * length,
                int exact, size_t * var_len, WriteMethod ** write_method)
{
    UI32_T compc=0;
    oid compl[ospfIfEntry_INSTANCE_LEN];
    oid best_inst[ospfIfEntry_INSTANCE_LEN];
    OSPF_TYPE_Msg_OspfInterfac_T data;

    /* Give default value for the record first.
     * We use the row_status = 0 to indicate if this set operation is Set by field
     * or set by record(included row creation), if the row_status =0, this record
     * mean set by field, otherwise, we just think it is a normal set operation
     */


    memset(&ospfIfEntry, 0, sizeof(ospfIfEntry));
    memset(&data, 0, sizeof(data));

   /*Since this table allow for entry that does not exist, (creation). we need to know the write method first*/
    switch (vp->magic)
    {
      case OSPFIFAREAID:
        *write_method = write_ospfIfAreaId;
        break;
      case OSPFIFTYPE:
        *write_method = write_ospfIfType;
        break;
      case OSPFIFADMINSTAT:
        *write_method = write_ospfIfAdminStat;
        break;
      case OSPFIFRTRPRIORITY:
        *write_method = write_ospfIfRtrPriority;
        break;
      case OSPFIFTRANSITDELAY:
        *write_method = write_ospfIfTransitDelay;
        break;
      case OSPFIFRETRANSINTERVAL:
        *write_method = write_ospfIfRetransInterval;
        break;
      case OSPFIFHELLOINTERVAL:
        *write_method = write_ospfIfHelloInterval;
        break;
      case OSPFIFRTRDEADINTERVAL:
        *write_method = write_ospfIfRtrDeadInterval;
        break;
      case OSPFIFPOLLINTERVAL:
        *write_method = write_ospfIfPollInterval;
        break;
      case OSPFIFAUTHKEY:
        *write_method = write_ospfIfAuthKey;
        break;
      case OSPFIFSTATUS:
        *write_method = write_ospfIfStatus;
        break;
      case OSPFIFMULTICASTFORWARDING:
        *write_method = write_ospfIfMulticastForwarding;
        break;
      case OSPFIFDEMAND:
        *write_method = write_ospfIfDemand;
        break;
      case OSPFIFAUTHTYPE:
        *write_method = write_ospfIfAuthType;
        break;
      default:
        *write_method =0;
         break;
    }

    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,compl, ospfIfEntry_INSTANCE_LEN);

     /*check compc, retrive compl*/
    if (exact)/*get,set*/
    {
        if (!ospfIfTable_get(compc, compl, &data))
            return NULL;
    }
    else/*getnext*/
    {
        if (!ospfIfTable_next(compc, compl, &data))
        {
            return NULL;
        }
    }
    memcpy(name, vp->name, vp->namelen*sizeof(oid));
    SNMP_MGR_BindIpInstance(data.if_addr.s_addr,0,best_inst);
    best_inst[4]= data.addressless_if;

    memcpy(name + vp->namelen, best_inst, ospfIfEntry_INSTANCE_LEN*sizeof(oid));
    *length = vp->namelen +ospfIfEntry_INSTANCE_LEN;

    *var_len = sizeof(long_return);

    /*
     * * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
      case OSPFIFIPADDRESS:
        *var_len = sizeof(ipaddr_return);
        ipaddr_return = data.if_addr.s_addr;
        return (u_char*) &ipaddr_return;
      case OSPFADDRESSLESSIF:
        long_return = data.addressless_if;
        return (u_char*) &long_return;
      case OSPFIFAREAID:
        *var_len = sizeof(ipaddr_return);
        ipaddr_return = data.area_id.s_addr;
        return (u_char*) &ipaddr_return;
      case OSPFIFTYPE:
        long_return = data.type;
        return (u_char*) &long_return;
      case OSPFIFADMINSTAT:
        long_return = data.admin_status;
        return (u_char*) &long_return;
      case OSPFIFRTRPRIORITY:
        long_return = data.priority;
        return (u_char*) &long_return;
      case OSPFIFTRANSITDELAY:
        long_return = data.transmit_delay;
        return (u_char*) &long_return;
      case OSPFIFRETRANSINTERVAL:
        long_return = data.retransmit_interval;
        return (u_char*) &long_return;
      case OSPFIFHELLOINTERVAL:
        long_return = data.hello_interval;
        return (u_char*) &long_return;
      case OSPFIFRTRDEADINTERVAL:
        long_return = data.dead_interval;
        return (u_char*) &long_return;
      case OSPFIFPOLLINTERVAL:
        long_return = data.poll_interval;
        return (u_char*) &long_return;
      case OSPFIFSTATE:
        long_return = data.state;
        return (u_char*) &long_return;
      case OSPFIFDESIGNATEDROUTER:
        *var_len = sizeof(ipaddr_return);
        ipaddr_return = data.dr_addr.s_addr;
        return (u_char*) &ipaddr_return;
      case OSPFIFBACKUPDESIGNATEDROUTER:
        *var_len = sizeof(ipaddr_return);
        ipaddr_return = data.bdr_addr.s_addr;
        return (u_char*) &ipaddr_return;
      case OSPFIFEVENTS:
        long_return = data.events;
        return (u_char*) &long_return;
      case OSPFIFAUTHKEY:
        memcpy(return_buf, data.auth_key, 8);
        *var_len = 8;
        return (u_char*) return_buf;
      case OSPFIFSTATUS:
        long_return = data.status;
        return (u_char*) &long_return;
      case OSPFIFMULTICASTFORWARDING:
        long_return = data.multicast_forwarding;
        return (u_char*) &long_return;
      case OSPFIFDEMAND:
        long_return = data.demand;
        return (u_char*) &long_return;
      case OSPFIFAUTHTYPE:
        long_return = data.auth_type;
        return (u_char*) &long_return;
    default:
        ERROR_MSG("");
    }
    return NULL;
}


int
write_ospfIfAreaId(int action,
                   u_char * var_val,
                   u_char var_val_type,
                   size_t var_val_len,
                   u_char * statP, oid * name, size_t name_len)
{

    UI32_T oid_name_length = 10;
    UI32_T ip_address;


   /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  ospfIfEntry_INSTANCE_LEN + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    SNMP_MGR_ReadIpFromCompl(name, oid_name_length,  &ip_address);
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_IPADDRESS) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len != SYS_TYPE_IPV4_ADDR_LEN) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          /* In reserve2, we overwrite the set value to ospfIfEntry*/
          memcpy(&ospfIfEntry.area_id.s_addr, var_val, var_val_len);
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
           /* For row creation, if row_status =0, mean that this is a normal
            * operation, we do the normal set operation, otherwise it is a row
            * creation operation, will do nothing here, and the overall entry
            * will perform in the write_xxxRowStatus function.
            */

            if(ospfIfEntry.status == 0)
            {
                /* not support */
                return SNMP_ERR_COMMITFAILED;
            }
           break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_ospfIfType(int action,
                 u_char * var_val,
                 u_char var_val_type,
                 size_t var_val_len,
                 u_char * statP, oid * name, size_t name_len)
{

    UI32_T oid_name_length = 10;
    UI32_T ip_address;


   /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  ospfIfEntry_INSTANCE_LEN + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    SNMP_MGR_ReadIpFromCompl(name, oid_name_length,  &ip_address);
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
         /* In reserve2, we overwrite the set value to ospfIfEntry*/
          ospfIfEntry.type = *(long *)var_val;
          if ((ospfIfEntry.type <VAL_ospfIfType_broadcast) || (ospfIfEntry.type >VAL_ospfIfType_pointToMultipoint))
             return SNMP_ERR_WRONGVALUE;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:

           /* For row creation, if row_status =0, mean that this is a normal
            * operation, we do the normal set operation, otherwise it is a row
            * creation operation, will do nothing here, and the overall entry
            * will perform in the write_xxxRowStatus function.
            */
           if (ospfIfEntry.status == 0)
           {
             if (OSPF_PMGR_SetIfType(ip_address,ospfIfEntry.type)!= OSPF_TYPE_RESULT_SUCCESS)
             {
                return SNMP_ERR_COMMITFAILED;
             }
           }
           break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_ospfIfAdminStat(int action,
                      u_char * var_val,
                      u_char var_val_type,
                      size_t var_val_len,
                      u_char * statP, oid * name, size_t name_len)
{

    UI32_T oid_name_length = 10;
    UI32_T ip_address;


   /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  ospfIfEntry_INSTANCE_LEN + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    SNMP_MGR_ReadIpFromCompl(name, oid_name_length,  &ip_address);
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
        {
        /* In reserve2, we overwrite the set value to ospfIfEntry*/
          UI32_T admin_status;
          admin_status = *(long *)var_val;
          if ((admin_status <VAL_ospfIfAdminStat_enabled) || (admin_status >VAL_ospfIfAdminStat_disabled))
             return SNMP_ERR_WRONGVALUE;
          ospfIfEntry.admin_status = admin_status;

          break;
        }
        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
           /* For row creation, if row_status =0, mean that this is a normal
            * operation, we do the normal set operation, otherwise it is a row
            * creation operation, will do nothing here, and the overall entry
            * will perform in the write_xxxRowStatus function.
            */
           if (ospfIfEntry.status == 0)
           {
             if (OSPF_PMGR_SetIfAdminStat(ip_address, ospfIfEntry.admin_status)!= OSPF_TYPE_RESULT_SUCCESS)
             {
                return SNMP_ERR_COMMITFAILED;
             }
           }
          break;
        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_ospfIfRtrPriority(int action,
                        u_char * var_val,
                        u_char var_val_type,
                        size_t var_val_len,
                        u_char * statP, oid * name, size_t name_len)
{

    UI32_T oid_name_length = 10;
    UI32_T ip_address;


   /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  ospfIfEntry_INSTANCE_LEN + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    SNMP_MGR_ReadIpFromCompl(name, oid_name_length,  &ip_address);
    ospfIfEntry.if_addr.s_addr = ip_address;
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          /* In reserve2, we overwrite the set value to ospfIfEntry*/
          ospfIfEntry.priority = *(long *)var_val;
          if ((ospfIfEntry.priority <MIN_ospfIfRtrPriority) || (ospfIfEntry.priority >MAX_ospfIfRtrPriority))
             return SNMP_ERR_WRONGVALUE;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
           /* For row creation, if row_status =0, mean that this is a normal
            * operation, we do the normal set operation, otherwise it is a row
            * creation operation, will do nothing here, and the overall entry
            * will perform in the write_xxxRowStatus function.
            */
           if (ospfIfEntry.status == 0)
           {
                /* find out ifindex */
                NETCFG_TYPE_InetRifConfig_T rif_config;
                UI32_T ifindex = 0;

                memset(&rif_config, 0, sizeof(rif_config));
                rif_config.addr.type = L_INET_ADDR_TYPE_IPV4;

                /* convert UI32 IP to array */
                if(IP_LIB_UI32toArray(ip_address, rif_config.addr.addr)!=IP_LIB_OK)
                {
                    return SNMP_ERR_COMMITFAILED;
                }

                if (NETCFG_POM_IP_GetRifFromExactIp(&rif_config)!= NETCFG_TYPE_OK)
                {
                    return SNMP_ERR_COMMITFAILED;
                }
                ifindex = rif_config.ifindex;
                /* ifindex is must */
                if (OSPF_PMGR_IfPrioritySet(0, ifindex, ospfIfEntry.priority, TRUE, ospfIfEntry.if_addr)!= OSPF_TYPE_RESULT_SUCCESS)
                {
                    return SNMP_ERR_COMMITFAILED;
                }
           }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_ospfIfTransitDelay(int action,
                         u_char * var_val,
                         u_char var_val_type,
                         size_t var_val_len,
                         u_char * statP, oid * name, size_t name_len)
{

    UI32_T oid_name_length = 10;
    UI32_T ip_address;


   /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  ospfIfEntry_INSTANCE_LEN + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    SNMP_MGR_ReadIpFromCompl(name, oid_name_length,  &ip_address);
    ospfIfEntry.if_addr.s_addr = ip_address;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          /* In reserve2, we overwrite the set value to ospfIfEntry*/
          ospfIfEntry.transmit_delay = *(long *)var_val;
          if ((ospfIfEntry.transmit_delay <MIN_ospfIfTransitDelay) || (ospfIfEntry.transmit_delay >MAX_ospfIfTransitDelay))
             return SNMP_ERR_WRONGVALUE;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
           /* For row creation, if row_status =0, mean that this is a normal
            * operation, we do the normal set operation, otherwise it is a row
            * creation operation, will do nothing here, and the overall entry
            * will perform in the write_xxxRowStatus function.
            */
           if (ospfIfEntry.status == 0)
           {
                /* find out ifindex */
                NETCFG_TYPE_InetRifConfig_T rif_config;
                UI32_T ifindex = 0;

                memset(&rif_config, 0, sizeof(rif_config));
                rif_config.addr.type = L_INET_ADDR_TYPE_IPV4;

                /* convert UI32 IP to array */
                if(IP_LIB_UI32toArray(ip_address, rif_config.addr.addr)!=IP_LIB_OK)
                {
                    return SNMP_ERR_COMMITFAILED;
                }

                if (NETCFG_POM_IP_GetRifFromExactIp(&rif_config)!= NETCFG_TYPE_OK)
                {
                    return SNMP_ERR_COMMITFAILED;
                }
                ifindex = rif_config.ifindex;
                /* ifindex is must */
                if (OSPF_PMGR_IfTransmitDelaySet(0, ifindex, ospfIfEntry.transmit_delay, TRUE, ospfIfEntry.if_addr)!= OSPF_TYPE_RESULT_SUCCESS)
                {
                    return SNMP_ERR_COMMITFAILED;
                }
            }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_ospfIfRetransInterval(int action,
                            u_char * var_val,
                            u_char var_val_type,
                            size_t var_val_len,
                            u_char * statP, oid * name, size_t name_len)
{
    UI32_T oid_name_length = 10;
    UI32_T ip_address;
    struct pal_in4_addr addr;


   /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  ospfIfEntry_INSTANCE_LEN + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    SNMP_MGR_ReadIpFromCompl(name, oid_name_length,  &ip_address);
    addr.s_addr = ip_address;
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
         /* In reserve2, we overwrite the set value to ospfIfEntry*/
          ospfIfEntry.retransmit_interval = *(long *)var_val;
          if ((ospfIfEntry.retransmit_interval <MIN_ospfIfRetransInterval) || (ospfIfEntry.retransmit_interval >MAX_ospfIfRetransInterval))
             return SNMP_ERR_WRONGVALUE;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
           /* For row creation, if row_status =0, mean that this is a normal
            * operation, we do the normal set operation, otherwise it is a row
            * creation operation, will do nothing here, and the overall entry
            * will perform in the write_xxxRowStatus function.
            */
            if (ospfIfEntry.status == 0)
            {
                /* find out ifindex */
                NETCFG_TYPE_InetRifConfig_T rif_config;
                UI32_T ifindex = 0;

                memset(&rif_config, 0, sizeof(rif_config));
                rif_config.addr.type = L_INET_ADDR_TYPE_IPV4;

                /* convert UI32 IP to array */
                if(IP_LIB_UI32toArray(ip_address, rif_config.addr.addr)!=IP_LIB_OK)
                {
                    return SNMP_ERR_COMMITFAILED;
                }

                if (NETCFG_POM_IP_GetRifFromExactIp(&rif_config)!= NETCFG_TYPE_OK)
                {
                    return SNMP_ERR_COMMITFAILED;
                }
                ifindex = rif_config.ifindex;
                /* ifindex is must */
                if (OSPF_PMGR_IfRetransmitIntervalSet(0, ifindex, ospfIfEntry.retransmit_interval, TRUE, addr)!= OSPF_TYPE_RESULT_SUCCESS)
                {
                    return SNMP_ERR_COMMITFAILED;
                }
           }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_ospfIfHelloInterval(int action,
                          u_char * var_val,
                          u_char var_val_type,
                          size_t var_val_len,
                          u_char * statP, oid * name, size_t name_len)
{
    UI32_T oid_name_length = 10;
    UI32_T ip_address;
    struct pal_in4_addr addr;

   /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  ospfIfEntry_INSTANCE_LEN + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    SNMP_MGR_ReadIpFromCompl(name, oid_name_length,  &ip_address);
    addr.s_addr = ip_address;
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
         /* In reserve2, we overwrite the set value to ospfIfEntry*/
          ospfIfEntry.hello_interval = *(long *)var_val;
          if ((ospfIfEntry.hello_interval <MIN_ospfIfHelloInterval) || (ospfIfEntry.hello_interval >MAX_ospfIfHelloInterval))
             return SNMP_ERR_WRONGVALUE;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
           /* For row creation, if row_status =0, mean that this is a normal
            * operation, we do the normal set operation, otherwise it is a row
            * creation operation, will do nothing here, and the overall entry
            * will perform in the write_xxxRowStatus function.
            */
            if (ospfIfEntry.status == 0)
            {
                /* find out ifindex */
                NETCFG_TYPE_InetRifConfig_T rif_config;
                UI32_T ifindex = 0;

                memset(&rif_config, 0, sizeof(rif_config));
                rif_config.addr.type = L_INET_ADDR_TYPE_IPV4;

                /* convert UI32 IP to array */
                if(IP_LIB_UI32toArray(ip_address, rif_config.addr.addr)!=IP_LIB_OK)
                {
                    return SNMP_ERR_COMMITFAILED;
                }

                if (NETCFG_POM_IP_GetRifFromExactIp(&rif_config)!= NETCFG_TYPE_OK)
                {
                    return SNMP_ERR_COMMITFAILED;
                }
                ifindex = rif_config.ifindex;
                /* ifindex is must */
                if (OSPF_PMGR_IfHelloIntervalSet(0, ifindex, ospfIfEntry.hello_interval, FALSE, addr)!= OSPF_TYPE_RESULT_SUCCESS)
                {
                    return SNMP_ERR_COMMITFAILED;
                }
            }
            break;
        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_ospfIfRtrDeadInterval(int action,
                            u_char * var_val,
                            u_char var_val_type,
                            size_t var_val_len,
                            u_char * statP, oid * name, size_t name_len)
{

    UI32_T oid_name_length = 10;
    UI32_T ip_address;
    struct pal_in4_addr addr;


   /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  ospfIfEntry_INSTANCE_LEN + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    SNMP_MGR_ReadIpFromCompl(name, oid_name_length,  &ip_address);
    addr.s_addr = ip_address;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          /* In reserve2, we overwrite the set value to ospfIfEntry*/
          ospfIfEntry.dead_interval = *(long *)var_val;
          if ((ospfIfEntry.dead_interval <MIN_ospfIfRtrDeadInterval) || (ospfIfEntry.dead_interval >MAX_ospfIfRtrDeadInterval))
             return SNMP_ERR_WRONGVALUE;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
           /* For row creation, if row_status =0, mean that this is a normal
            * operation, we do the normal set operation, otherwise it is a row
            * creation operation, will do nothing here, and the overall entry
            * will perform in the write_xxxRowStatus function.
            */
           if (ospfIfEntry.status == 0)
           {
                /* find out ifindex */
                NETCFG_TYPE_InetRifConfig_T rif_config;
                UI32_T ifindex = 0;

                memset(&rif_config, 0, sizeof(rif_config));
                rif_config.addr.type = L_INET_ADDR_TYPE_IPV4;

                /* convert UI32 IP to array */
                if(IP_LIB_UI32toArray(ip_address, rif_config.addr.addr)!=IP_LIB_OK)
                {
                    return SNMP_ERR_COMMITFAILED;
                }

                if (NETCFG_POM_IP_GetRifFromExactIp(&rif_config)!= NETCFG_TYPE_OK)
                {
                    return SNMP_ERR_COMMITFAILED;
                }
                ifindex = rif_config.ifindex;
                /* ifindex is must */
                if (OSPF_PMGR_IfDeadIntervalSet(0, ifindex, ospfIfEntry.dead_interval, TRUE, addr)!= OSPF_TYPE_RESULT_SUCCESS)
                {
                    return SNMP_ERR_COMMITFAILED;
                }
           }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_ospfIfPollInterval(int action,
                         u_char * var_val,
                         u_char var_val_type,
                         size_t var_val_len,
                         u_char * statP, oid * name, size_t name_len)
{

    UI32_T oid_name_length = 10;
    UI32_T ip_address;


   /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  ospfIfEntry_INSTANCE_LEN + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    SNMP_MGR_ReadIpFromCompl(name, oid_name_length,  &ip_address);
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
         /* In reserve2, we overwrite the set value to ospfIfEntry*/
          ospfIfEntry.poll_interval = *(long *)var_val;
          if ((ospfIfEntry.poll_interval <MIN_ospfIfPollInterval) || (ospfIfEntry.poll_interval >MAX_ospfIfPollInterval))
             return SNMP_ERR_WRONGVALUE;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
        /* For row creation, if row_status =0, mean that this is a normal
            * operation, we do the normal set operation, otherwise it is a row
            * creation operation, will do nothing here, and the overall entry
            * will perform in the write_xxxRowStatus function.
            */
           if (ospfIfEntry.status == 0)
           {
                /* find out ifindex */
                NETCFG_TYPE_InetRifConfig_T rif_config;
                UI32_T ifindex = 0;

                memset(&rif_config, 0, sizeof(rif_config));
                rif_config.addr.type = L_INET_ADDR_TYPE_IPV4;

                /* convert UI32 IP to array */
                if(IP_LIB_UI32toArray(ip_address, rif_config.addr.addr)!=IP_LIB_OK)
                {
                    return SNMP_ERR_COMMITFAILED;
                }

                if (NETCFG_POM_IP_GetRifFromExactIp(&rif_config)!= NETCFG_TYPE_OK)
                {
                    return SNMP_ERR_COMMITFAILED;
                }
                ifindex = rif_config.ifindex;
                /* ifindex is must */
                if (OSPF_PMGR_SetIfPollInterval(ip_address, ospfIfEntry.poll_interval)!= OSPF_TYPE_RESULT_SUCCESS)
                {
                    return SNMP_ERR_COMMITFAILED;
                }
           }
          break;
        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_ospfIfAuthKey(int action,
                    u_char * var_val,
                    u_char var_val_type,
                    size_t var_val_len,
                    u_char * statP, oid * name, size_t name_len)
{
    UI32_T oid_name_length = 10;
    UI32_T ip_address;


   /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  ospfIfEntry_INSTANCE_LEN + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    SNMP_MGR_ReadIpFromCompl(name, oid_name_length,  &ip_address);
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              return SNMP_ERR_WRONGTYPE;
          }
          if ((var_val_len > (SYS_ADPT_MAXSIZE_OSPF_IF_AUTH_KEY)*sizeof(char)) ||
              (var_val_len < (SYS_ADPT_MINSIZE_OSPF_IF_AUTH_KEY)*sizeof(char)))
          {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
           /* In reserve2, we overwrite the set value to ospfIfEntry*/
          memcpy(&ospfIfEntry.auth_key, var_val, var_val_len);
          ospfIfEntry.auth_key[var_val_len]=0;
          break;
        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
           /* For row creation, if row_status =0, mean that this is a normal
            * operation, we do the normal set operation, otherwise it is a row
            * creation operation, will do nothing here, and the overall entry
            * will perform in the write_xxxRowStatus function.
            */
           if (ospfIfEntry.status == 0)
           {
             if (OSPF_PMGR_SetIfAuthKey(ip_address, ospfIfEntry.auth_key)!= OSPF_TYPE_RESULT_SUCCESS)
             {
                return SNMP_ERR_COMMITFAILED;
             }
           }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_ospfIfStatus(int action,
                   u_char * var_val,
                   u_char var_val_type,
                   size_t var_val_len,
                   u_char * statP, oid * name, size_t name_len)
{

    UI32_T oid_name_length = 10;
    UI32_T ip_address;


   /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  ospfIfEntry_INSTANCE_LEN + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    SNMP_MGR_ReadIpFromCompl(name, oid_name_length,  &ip_address);
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
        {
          UI32_T status;
          /* In reserve2, we overwrite the set value to ospfIfEntry*/
          status = *(long *)var_val;
          if ((status <VAL_ospfIfStatus_active) || (status >VAL_ospfIfStatus_destroy))
             return SNMP_ERR_WRONGVALUE;
          ospfIfEntry.status = status;
          break;
        }
        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
          /* We perform the row creation here, if the row status = 4(createAndGo),
           * or 5 (createAndWait), we call the SetByEntry API, otherwise, call the
           * set rowstatus API
           */
            ospfIfEntry.addressless_if = name[14];
            ospfIfEntry.area_id.s_addr = 0; // default is backbone area.
            switch (ospfIfEntry.status)
            {
                case VAL_ospfIfStatus_active:
                case VAL_ospfIfStatus_notInService:
                case VAL_ospfIfStatus_notReady:
                case VAL_ospfIfStatus_createAndGo:
                case VAL_ospfIfStatus_createAndWait:
                case VAL_ospfIfStatus_destroy:
                default:
                    /* peter, not support */
                    return SNMP_ERR_COMMITFAILED;
            }
            break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_ospfIfMulticastForwarding(int action,
                                u_char * var_val,
                                u_char var_val_type,
                                size_t var_val_len,
                                u_char * statP,
                                oid * name, size_t name_len)
{

    UI32_T oid_name_length = 10;
    UI32_T ip_address;


   /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  ospfIfEntry_INSTANCE_LEN + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    SNMP_MGR_ReadIpFromCompl(name, oid_name_length,  &ip_address);
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
           /* In reserve2, we overwrite the set value to ospfIfEntry*/
          ospfIfEntry.multicast_forwarding = *(long *)var_val;
          if ((ospfIfEntry.multicast_forwarding <VAL_ospfIfMulticastForwarding_blocked) || (ospfIfEntry.multicast_forwarding >VAL_ospfIfMulticastForwarding_unicast))
             return SNMP_ERR_WRONGVALUE;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
           /* For row creation, if row_status =0, mean that this is a normal
            * operation, we do the normal set operation, otherwise it is a row
            * creation operation, will do nothing here, and the overall entry
            * will perform in the write_xxxRowStatus function.
            */
           if (ospfIfEntry.status == 0)
           {
             /* not support now*/
             return SNMP_ERR_COMMITFAILED;
           }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_ospfIfDemand(int action,
                   u_char * var_val,
                   u_char var_val_type,
                   size_t var_val_len,
                   u_char * statP, oid * name, size_t name_len)
{

    UI32_T oid_name_length = 10;
    UI32_T ip_address;


   /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  ospfIfEntry_INSTANCE_LEN + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    SNMP_MGR_ReadIpFromCompl(name, oid_name_length,  &ip_address);
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          /* In reserve2, we overwrite the set value to ospfIfEntry*/
          ospfIfEntry.demand = *(long *)var_val;
          if ((ospfIfEntry.demand <VAL_ospfIfDemand_true) || (ospfIfEntry.demand >VAL_ospfIfDemand_false))
             return SNMP_ERR_WRONGVALUE;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
           /* For row creation, if row_status =0, mean that this is a normal
            * operation, we do the normal set operation, otherwise it is a row
            * creation operation, will do nothing here, and the overall entry
            * will perform in the write_xxxRowStatus function.
            */
           if (ospfIfEntry.status == 0)
           {
             /* not support now*/
             return SNMP_ERR_COMMITFAILED;
           }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_ospfIfAuthType(int action,
                     u_char * var_val,
                     u_char var_val_type,
                     size_t var_val_len,
                     u_char * statP, oid * name, size_t name_len)
{
    UI32_T oid_name_length = 10;
    UI32_T ip_address;


   /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  ospfIfEntry_INSTANCE_LEN + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    SNMP_MGR_ReadIpFromCompl(name, oid_name_length,  &ip_address);
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          /* In reserve2, we overwrite the set value to ospfIfEntry*/
          ospfIfEntry.auth_type = *(long *)var_val;
          if ((ospfIfEntry.auth_type <MIN_ospfIfAuthType) || (ospfIfEntry.auth_type >MAX_ospfIfAuthType))
             return SNMP_ERR_WRONGVALUE;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
            /* For row creation, if row_status =0, mean that this is a normal
            * operation, we do the normal set operation, otherwise it is a row
            * creation operation, will do nothing here, and the overall entry
            * will perform in the write_xxxRowStatus function.
            */
           if (ospfIfEntry.status == 0)
           {
                /* find out ifindex */
                NETCFG_TYPE_InetRifConfig_T rif_config;
                UI32_T ifindex = 0;

                memset(&rif_config, 0, sizeof(rif_config));
                rif_config.addr.type = L_INET_ADDR_TYPE_IPV4;

                /* convert UI32 IP to array */
                if(IP_LIB_UI32toArray(ip_address, rif_config.addr.addr)!=IP_LIB_OK)
                {
                    return SNMP_ERR_COMMITFAILED;
                }

                if (NETCFG_POM_IP_GetRifFromExactIp(&rif_config)!= NETCFG_TYPE_OK)
                {
                    return SNMP_ERR_COMMITFAILED;
                }
                ifindex = rif_config.ifindex;
                /* ifindex is must */
                if(OSPF_PMGR_IfAuthenticationTypeSet(0, ifindex, ospfIfEntry.auth_type , TRUE,
                                        ospfIfEntry.if_addr) != OSPF_TYPE_RESULT_SUCCESS)
                {
                    return SNMP_ERR_COMMITFAILED;
                }
           }

          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.old-api.conf,v 1.3 2002/10/17 09:40:46 dts12 Exp $
 */


/*
 * ospfIfMetricTable_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid             ospfIfMetricTable_variables_oid[] =
    { 1, 3, 6, 1, 2, 1, 14 };

/*
 * variable4 ospfIfMetricTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */

struct variable3 ospfIfMetricTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */

#define OSPFIFMETRICIPADDRESS       1
    {OSPFIFMETRICIPADDRESS, ASN_IPADDRESS, RONLY, var_ospfIfMetricTable, 3,
     {8, 1, 1}},
#define OSPFIFMETRICADDRESSLESSIF       2
    {OSPFIFMETRICADDRESSLESSIF, ASN_INTEGER, RONLY, var_ospfIfMetricTable,
     3, {8, 1, 2}},
#define OSPFIFMETRICTOS     3
    {OSPFIFMETRICTOS, ASN_INTEGER, RONLY, var_ospfIfMetricTable, 3,
     {8, 1, 3}},
#define OSPFIFMETRICVALUE       4
    {OSPFIFMETRICVALUE, ASN_INTEGER, RWRITE, var_ospfIfMetricTable, 3,
     {8, 1, 4}},
#define OSPFIFMETRICSTATUS      5
    {OSPFIFMETRICSTATUS, ASN_INTEGER, RWRITE, var_ospfIfMetricTable, 3,
     {8, 1, 5}},
};
/*
 * (L = length of the oidsuffix)
 */


/** Initializes the ospfIfMetricTable module */
void
init_ospfIfMetricTable(void)
{

    /*
     * register ourselves with the agent to handle our mib tree
     */
    REGISTER_MIB("ospfIfMetricTable", ospfIfMetricTable_variables,
                 variable3, ospfIfMetricTable_variables_oid);

}

static BOOL_T ospfIfMetricTable_get(int      compc,
                                oid     *compl,
                                OSPF_TYPE_IfMetricEntry_T   *data)
{
    if (compc !=ospfIfMetricEntry_INSTANCE_LEN)
    {
        return FALSE;
    }
    SNMP_MGR_ReadIpFromCompl(compl,0, &data->ip_address);
    data->addressless_if = compl[4];
    data->tos = compl[5];

    if (OSPF_PMGR_GetIfMetricEntry(data)!=OSPF_TYPE_RESULT_SUCCESS)
    {
        return FALSE;
    }
    else
    {
        return TRUE;

    } /*End of if */
}

static BOOL_T ospfIfMetricTable_next(int      compc,
                                 oid     *compl,
                                 OSPF_TYPE_IfMetricEntry_T    *data)
{
    oid tmp_compl[ospfIfMetricEntry_INSTANCE_LEN];

    /* Generate the instance of each table entry and find the
     * smallest instance that's larger than compc/compl.
     *
     * Step 1: Verify and extract the input key from "compc" and "compl"
     * Note: The number of input key is defined by "compc".
     *       The key for the specified instance is defined in compl.
     */
    memcpy(tmp_compl, compl, sizeof(tmp_compl));
    SNMP_MGR_checkCompl(0, 3, tmp_compl,255);
    SNMP_MGR_ConvertRemainToZero(compc,ospfIfMetricEntry_INSTANCE_LEN, tmp_compl);

    SNMP_MGR_ReadIpFromCompl(tmp_compl,0,&data->ip_address);
    data->addressless_if = tmp_compl[4];
    data->tos = tmp_compl[5];


    if (compc<ospfIfMetricEntry_INSTANCE_LEN)
    {
        if (OSPF_PMGR_GetIfMetricEntry(data)!=OSPF_TYPE_RESULT_SUCCESS)
        {
            if (OSPF_PMGR_GetNextIfMetricEntry(data)!=OSPF_TYPE_RESULT_SUCCESS)
            {
                return FALSE;
            }
        }
    }
    else
    {
        if (OSPF_PMGR_GetNextIfMetricEntry(data)!=OSPF_TYPE_RESULT_SUCCESS)
        {
            return FALSE;
        }
    }
    return TRUE;
}

/* This entry is used for entry which have the ability to row create*/
static OSPF_TYPE_IfMetricEntry_T ospfIfMetricEntry;

/*
 * var_ospfIfMetricTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_ospfIfMetricTable(struct variable *vp,
                      oid * name,
                      size_t * length,
                      int exact,
                      size_t * var_len, WriteMethod ** write_method)
{
    UI32_T compc=0;
    oid compl[ospfIfMetricEntry_INSTANCE_LEN];
    oid best_inst[ospfIfMetricEntry_INSTANCE_LEN];
    OSPF_TYPE_IfMetricEntry_T data;


    memset(&ospfIfMetricEntry, 0, sizeof(ospfIfMetricEntry));
    ospfIfMetricEntry.vr_id = 0;
    ospfIfMetricEntry.proc_id = 1;

    /* Give default value for the record first
     * We use the row_status = 0 to indicate if this set operation is Set by field
     * or set by record(included row creation), if the row_status =0, this record
     * mean set by field, otherwise, we just think it is a normal set operation
     */

   /*Since this table allow for entry that does not exist, (creation). we need to know the write method first*/
    switch (vp->magic)
    {
      case OSPFIFMETRICVALUE:
        *write_method = write_ospfIfMetricValue;
        break;
      case OSPFIFMETRICSTATUS:
        *write_method = write_ospfIfMetricStatus;
        break;
      default:
        *write_method =0;
         break;
    }

    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,compl, ospfIfMetricEntry_INSTANCE_LEN);

    memset(&data, 0, sizeof(data));
    /* set default vr_id, proc_id */
    data.vr_id = 0;
    data.proc_id = 1;

     /*check compc, retrive compl*/
    if (exact)/*get,set*/
    {
        if (!ospfIfMetricTable_get(compc, compl, &data))
            return NULL;
    }
    else/*getnext*/
    {
        if (!ospfIfMetricTable_next(compc, compl, &data))
        {
            return NULL;
        }
    }
    memcpy(name, vp->name, vp->namelen*sizeof(oid));
    SNMP_MGR_BindIpInstance(data.ip_address,0,best_inst);
    best_inst[4]= data.addressless_if;
    best_inst[5]= data.tos;

    memcpy(name + vp->namelen, best_inst, ospfIfMetricEntry_INSTANCE_LEN*sizeof(oid));
    *length = vp->namelen +ospfIfMetricEntry_INSTANCE_LEN;

    *var_len = sizeof(long_return);

    /*
     * * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
      case OSPFIFMETRICIPADDRESS:
        *var_len = sizeof(ipaddr_return);
        ipaddr_return = data.ip_address;
        return (u_char*) &ipaddr_return;
      case OSPFIFMETRICADDRESSLESSIF:
        long_return = data.addressless_if;
        return (u_char*) &long_return;
      case OSPFIFMETRICTOS:
        long_return = data.tos;
        return (u_char*) &long_return;
      case OSPFIFMETRICVALUE:
        long_return = data.value;
        return (u_char*) &long_return;
      case OSPFIFMETRICSTATUS:
        long_return = data.status;
        return (u_char*) &long_return;
    default:
        ERROR_MSG("");
    }
    return NULL;
}


int
write_ospfIfMetricValue(int action,
                        u_char * var_val,
                        u_char var_val_type,
                        size_t var_val_len,
                        u_char * statP, oid * name, size_t name_len)
{

    UI32_T oid_name_length = 10;
    UI32_T ip_address;


   /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  ospfIfMetricEntry_INSTANCE_LEN + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    SNMP_MGR_ReadIpFromCompl(name, oid_name_length,  &ip_address);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
           /* In reserve2, we overwrite the set value to ospfIfMetricEntry*/
           ospfIfMetricEntry.value = *(long *)var_val;
          if ((ospfIfMetricEntry.value <MIN_ospfIfMetricValue) || (ospfIfMetricEntry.value >MAX_ospfIfMetricValue))
             return SNMP_ERR_WRONGVALUE;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
         /* For row creation, if row_status =0, mean that this is a normal
          * operation, we do the normal set operation, otherwise it is a row
          * creation operation, will do nothing here, and the overall entry
          * will perform in the write_xxxRowStatus function.
          */
        if(ospfIfMetricEntry.status == 0)
        {
            ospfIfMetricEntry.ip_address = ip_address;
            ospfIfMetricEntry.addressless_if = name[14];
            ospfIfMetricEntry.tos = name[15];
            if (OSPF_PMGR_SetIfMetricEntry(&ospfIfMetricEntry)!= OSPF_TYPE_RESULT_SUCCESS)
            {
            return SNMP_ERR_COMMITFAILED;
            }
        }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_ospfIfMetricStatus(int action,
                         u_char * var_val,
                         u_char var_val_type,
                         size_t var_val_len,
                         u_char * statP, oid * name, size_t name_len)
{

    UI32_T oid_name_length = 10;
    UI32_T ip_address;


   /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  ospfIfMetricEntry_INSTANCE_LEN + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    SNMP_MGR_ReadIpFromCompl(name, oid_name_length,  &ip_address);
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
           /* In reserve2, we overwrite the set value to ospfIfMetricEntry*/
           ospfIfMetricEntry.status = *(long *)var_val;
          if ((ospfIfMetricEntry.status <VAL_ospfIfMetricStatus_active) || (ospfIfMetricEntry.status >VAL_ospfIfMetricStatus_destroy))
             return SNMP_ERR_WRONGVALUE;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
               /* We perform the row creation here, if the row status = 4(createAndGo),
           * or 5 (createAndWait), we call the SetByEntry API, otherwise, call the
           * set rowstatus API
           */
          switch (ospfIfMetricEntry.status)
          {
              case VAL_ospfIfMetricStatus_createAndGo:
              case VAL_ospfIfMetricStatus_createAndWait:
              case VAL_ospfIfMetricStatus_active:
              case VAL_ospfIfMetricStatus_notInService:
              case VAL_ospfIfMetricStatus_notReady:
              case VAL_ospfIfMetricStatus_destroy:
                ospfIfMetricEntry.ip_address = ip_address;
                ospfIfMetricEntry.addressless_if = name[14];
                ospfIfMetricEntry.tos = name[15];
                if (OSPF_PMGR_SetIfMetricEntry(&ospfIfMetricEntry) != OSPF_TYPE_RESULT_SUCCESS)
                {
                    return SNMP_ERR_COMMITFAILED;
                }
                break;
              default:
                return SNMP_ERR_COMMITFAILED;
          }
          break;
        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.old-api.conf,v 1.3 2002/10/17 09:40:46 dts12 Exp $
 */

/*
 * ospfVirtIfTable_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid             ospfVirtIfTable_variables_oid[] =
    { 1, 3, 6, 1, 2, 1, 14};

/*
 * variable4 ospfVirtIfTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */

struct variable3 ospfVirtIfTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */

#define OSPFVIRTIFAREAID        1
    {OSPFVIRTIFAREAID, ASN_IPADDRESS, RONLY, var_ospfVirtIfTable, 3,
     {9, 1, 1}},
#define OSPFVIRTIFNEIGHBOR      2
    {OSPFVIRTIFNEIGHBOR, ASN_IPADDRESS, RONLY, var_ospfVirtIfTable, 3,
     {9, 1, 2}},
#define OSPFVIRTIFTRANSITDELAY      3
    {OSPFVIRTIFTRANSITDELAY, ASN_INTEGER, RWRITE, var_ospfVirtIfTable, 3,
     {9, 1, 3}},
#define OSPFVIRTIFRETRANSINTERVAL       4
    {OSPFVIRTIFRETRANSINTERVAL, ASN_INTEGER, RWRITE, var_ospfVirtIfTable,
     3, {9, 1, 4}},
#define OSPFVIRTIFHELLOINTERVAL     5
    {OSPFVIRTIFHELLOINTERVAL, ASN_INTEGER, RWRITE, var_ospfVirtIfTable, 3,
     {9, 1, 5}},
#define OSPFVIRTIFRTRDEADINTERVAL       6
    {OSPFVIRTIFRTRDEADINTERVAL, ASN_INTEGER, RWRITE, var_ospfVirtIfTable,
     3, {9, 1, 6}},
#define OSPFVIRTIFSTATE     7
    {OSPFVIRTIFSTATE, ASN_INTEGER, RONLY, var_ospfVirtIfTable, 3,
     {9, 1, 7}},
#define OSPFVIRTIFEVENTS        8
    {OSPFVIRTIFEVENTS, ASN_COUNTER, RONLY, var_ospfVirtIfTable, 3,
     {9, 1, 8}},
#define OSPFVIRTIFAUTHKEY       9
    {OSPFVIRTIFAUTHKEY, ASN_OCTET_STR, RWRITE, var_ospfVirtIfTable, 3,
     {9, 1, 9}},
#define OSPFVIRTIFSTATUS        10
    {OSPFVIRTIFSTATUS, ASN_INTEGER, RWRITE, var_ospfVirtIfTable, 3,
     {9, 1, 10}},
#define OSPFVIRTIFAUTHTYPE      11
    {OSPFVIRTIFAUTHTYPE, ASN_INTEGER, RWRITE, var_ospfVirtIfTable, 3,
     {9, 1, 11}},
};
/*
 * (L = length of the oidsuffix)
 */


/** Initializes the ospfVirtIfTable module */
void
init_ospfVirtIfTable(void)
{


    /*
     * register ourselves with the agent to handle our mib tree
     */
    REGISTER_MIB("ospfVirtIfTable", ospfVirtIfTable_variables, variable3,
                 ospfVirtIfTable_variables_oid);

}

static BOOL_T ospfVirtIfTable_get(int      compc,
                                oid     *compl,
                                OSPF_TYPE_Vlink_T   *data)
{
    if (compc !=ospfVirtIfEntry_INSTANCE_LEN)
    {
        return FALSE;
    }
    SNMP_MGR_ReadIpFromCompl(compl,0, (UI32_T *)&data->area_id.s_addr);
    SNMP_MGR_ReadIpFromCompl(compl,4, (UI32_T *)&data->peer_id.s_addr);


    if (OSPF_PMGR_GetMultiProcVirtualLinkEntry(data)!=OSPF_TYPE_RESULT_SUCCESS)
    {
        return FALSE;
    }
    else
    {
        return TRUE;

    } /*End of if */
}

static BOOL_T ospfVirtIfTable_next(int      compc,
                                 oid     *compl,
                                 OSPF_TYPE_Vlink_T    *data)
{
    oid tmp_compl[ospfVirtIfEntry_INSTANCE_LEN];

    /* Generate the instance of each table entry and find the
     * smallest instance that's larger than compc/compl.
     *
     * Step 1: Verify and extract the input key from "compc" and "compl"
     * Note: The number of input key is defined by "compc".
     *       The key for the specified instance is defined in compl.
     */
    memcpy(tmp_compl, compl, sizeof(tmp_compl));
    SNMP_MGR_checkCompl(0, 3, tmp_compl,255);
    SNMP_MGR_checkCompl(4, 7, tmp_compl,255);
    SNMP_MGR_ConvertRemainToZero(compc,ospfVirtIfEntry_INSTANCE_LEN, tmp_compl);

    SNMP_MGR_ReadIpFromCompl(tmp_compl,0,(UI32_T *)&data->area_id.s_addr);
    SNMP_MGR_ReadIpFromCompl(tmp_compl,4,(UI32_T *)&data->peer_id.s_addr);


    if (compc<ospfVirtIfEntry_INSTANCE_LEN)
    {
        if (OSPF_PMGR_GetMultiProcVirtualLinkEntry(data)!=OSPF_TYPE_RESULT_SUCCESS)
        {
            if (OSPF_PMGR_GetNextMultiProcVirtualLinkEntry(data)!=OSPF_TYPE_RESULT_SUCCESS)
            {
                return FALSE;
            }
        }
    }
    else
    {
        if (OSPF_PMGR_GetNextMultiProcVirtualLinkEntry(data)!=OSPF_TYPE_RESULT_SUCCESS)
        {
            return FALSE;
        }
    }
    return TRUE;
}

/* This entry is used for entry which have the ability to row create*/
//static OSPF_TYPE_Vlink_T ospfVirtIfEntry;
static OSPF_TYPE_Area_Virtual_Link_Para_T vlink_param;


/*
 * var_ospfVirtIfTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_ospfVirtIfTable(struct variable *vp,
                    oid * name,
                    size_t * length,
                    int exact,
                    size_t * var_len, WriteMethod ** write_method)
{
    UI32_T compc=0;
    oid compl[ospfVirtIfEntry_INSTANCE_LEN];
    oid best_inst[ospfVirtIfEntry_INSTANCE_LEN];
    OSPF_TYPE_Vlink_T data;

    /* Give default value for the record first.
     * We use the row_status = 0 to indicate if this set operation is Set by field
     * or set by record(included row creation), if the row_status =0, this record
     * mean set by field, otherwise, we just think it is a normal set operation
     */

    memset(&vlink_param, 0, sizeof(vlink_param));

    memset(&data, 0, sizeof(data));
    data.vr_id = 0;
    data.proc_id = 1;

   /*Since this table allow for entry that does not exist, (creation). we need to know the write method first*/
    switch (vp->magic)
    {
      case OSPFVIRTIFTRANSITDELAY:
        *write_method = write_ospfVirtIfTransitDelay;
        break;
      case OSPFVIRTIFRETRANSINTERVAL:
        *write_method = write_ospfVirtIfRetransInterval;
        break;
      case OSPFVIRTIFHELLOINTERVAL:
        *write_method = write_ospfVirtIfHelloInterval;
        break;
      case OSPFVIRTIFRTRDEADINTERVAL:
        *write_method = write_ospfVirtIfRtrDeadInterval;
        break;
      case OSPFVIRTIFAUTHKEY:
        *write_method = write_ospfVirtIfAuthKey;
        break;
      case OSPFVIRTIFSTATUS:
        *write_method = write_ospfVirtIfStatus;
        break;
      case OSPFVIRTIFAUTHTYPE:
        *write_method = write_ospfVirtIfAuthType;
        break;
      default:
        *write_method =0;
         break;
    }

    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,compl, ospfVirtIfEntry_INSTANCE_LEN);

     /*check compc, retrive compl*/
    if (exact)/*get,set*/
    {
        if (!ospfVirtIfTable_get(compc, compl, &data))
            return NULL;
    }
    else/*getnext*/
    {
        if (!ospfVirtIfTable_next(compc, compl, &data))
        {
            return NULL;
        }
    }
    memcpy(name, vp->name, vp->namelen*sizeof(oid));
    SNMP_MGR_BindIpInstance(data.area_id.s_addr,0,best_inst);
    SNMP_MGR_BindIpInstance(data.peer_id.s_addr,4,best_inst);


    memcpy(name + vp->namelen, best_inst, ospfVirtIfEntry_INSTANCE_LEN*sizeof(oid));
    *length = vp->namelen +ospfVirtIfEntry_INSTANCE_LEN;

    *var_len = sizeof(long_return);

    /*
     * * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
      case OSPFVIRTIFAREAID:
        *var_len = sizeof(ipaddr_return);
        ipaddr_return = data.area_id.s_addr;
        return (u_char*) &ipaddr_return;
      case OSPFVIRTIFNEIGHBOR:
        *var_len = sizeof(ipaddr_return);
        ipaddr_return = data.peer_id.s_addr;
        return (u_char*) &ipaddr_return;
      case OSPFVIRTIFTRANSITDELAY:
        long_return = data.transmit_delay;
        return (u_char*) &long_return;
      case OSPFVIRTIFRETRANSINTERVAL:
        long_return = data.retransmit_interval;
        return (u_char*) &long_return;
      case OSPFVIRTIFHELLOINTERVAL:
        long_return = data.hello_interval;
        return (u_char*) &long_return;
      case OSPFVIRTIFRTRDEADINTERVAL:
        long_return = data.dead_interval;
        return (u_char*) &long_return;
      case OSPFVIRTIFSTATE:
        long_return = data.oi_state;
        return (u_char*) &long_return;
      case OSPFVIRTIFEVENTS:
        long_return = data.events;
        return (u_char*) &long_return;
      case OSPFVIRTIFAUTHKEY:
        /*reading the auth key will always return zero */
        *var_len=0;
        strcpy((char *)return_buf,"");
        return (u_char*) return_buf;
      case OSPFVIRTIFSTATUS:
        long_return = data.status;
        return (u_char*) &long_return;
      case OSPFVIRTIFAUTHTYPE:
        long_return = data.auth_type;
        return (u_char*) &long_return;
    default:
        ERROR_MSG("");
    }
    return NULL;
}


int
write_ospfVirtIfTransitDelay(int action,
                             u_char * var_val,
                             u_char var_val_type,
                             size_t var_val_len,
                             u_char * statP, oid * name, size_t name_len)
{
    UI32_T oid_name_length = 10;
    UI32_T ip_address;
//    OSPF_TYPE_Area_Virtual_Link_Para_T vlink_param;

//    memset(&vlink_param,0,sizeof(vlink_param));

   /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  ospfVirtIfEntry_INSTANCE_LEN + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    SNMP_MGR_ReadIpFromCompl(name, oid_name_length,  &ip_address);
    SNMP_MGR_ReadIpFromCompl(name, oid_name_length+4,  &vlink_param.vlink_addr);
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
         /* In reserve2, we overwrite the set value to OSPF_TYPE_Area_Virtual_Link_Para_T*/

          vlink_param.transmit_delay = *(long *)var_val;
          if ((vlink_param.transmit_delay <MIN_ospfVirtIfTransitDelay) || (vlink_param.transmit_delay >MAX_ospfVirtIfTransitDelay))
             return SNMP_ERR_WRONGVALUE;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
         /* For row creation, if row_status =0, mean that this is a normal
          * operation, we do the normal set operation, otherwise it is a row
          * creation operation, will do nothing here, and the overall entry
          * will perform in the write_xxxRowStatus function.
          */

                SET_FLAG(vlink_param.config, OSPF_TYPE_AREA_VLINK_TRANSMIT_DELAY);
                if(OSPF_PMGR_AreaVirtualLinkSet(0, 1, ip_address, 1, &vlink_param)!= NETCFG_TYPE_OK)/* OSPF_AREA_ID_FORMAT_ADDRESS: 1 */
                {
                    return SNMP_ERR_COMMITFAILED;
                }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_ospfVirtIfRetransInterval(int action,
                                u_char * var_val,
                                u_char var_val_type,
                                size_t var_val_len,
                                u_char * statP,
                                oid * name, size_t name_len)
{
    UI32_T oid_name_length = 10;
    UI32_T ip_address;
//    OSPF_TYPE_Area_Virtual_Link_Para_T vlink_param;

//    memset(&vlink_param,0,sizeof(vlink_param));

   /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  ospfVirtIfEntry_INSTANCE_LEN + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    SNMP_MGR_ReadIpFromCompl(name, oid_name_length,  &ip_address);
    SNMP_MGR_ReadIpFromCompl(name, oid_name_length+4,  &vlink_param.vlink_addr);
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          /* In reserve2, we overwrite the set value to vlink_param*/
          vlink_param.retransmit_interval = *(long *)var_val;
          if ((vlink_param.retransmit_interval <MIN_ospfVirtIfRetransInterval) || (vlink_param.retransmit_interval >MAX_ospfVirtIfRetransInterval))
             return SNMP_ERR_WRONGVALUE;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
         /* For row creation, if row_status =0, mean that this is a normal
          * operation, we do the normal set operation, otherwise it is a row
          * creation operation, will do nothing here, and the overall entry
          * will perform in the write_xxxRowStatus function.
          */
         //if ( ospfVirtIfEntry.status == 0)
         //{
                SET_FLAG(vlink_param.config, OSPF_TYPE_AREA_VLINK_RETRANSMIT_INTERVAL);
                if(OSPF_PMGR_AreaVirtualLinkSet(0,1, ip_address, 1, &vlink_param)!= NETCFG_TYPE_OK) /* OSPF_AREA_ID_FORMAT_ADDRESS: 1 */
                {
                    return SNMP_ERR_COMMITFAILED;
                }

         //}
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_ospfVirtIfHelloInterval(int action,
                              u_char * var_val,
                              u_char var_val_type,
                              size_t var_val_len,
                              u_char * statP, oid * name, size_t name_len)
{
    UI32_T oid_name_length = 10;
    UI32_T ip_address;
//    OSPF_TYPE_Area_Virtual_Link_Para_T vlink_param;

//    memset(&vlink_param,0,sizeof(vlink_param));


   /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  ospfVirtIfEntry_INSTANCE_LEN + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    SNMP_MGR_ReadIpFromCompl(name, oid_name_length,  &ip_address);
    SNMP_MGR_ReadIpFromCompl(name, oid_name_length+4,  &vlink_param.vlink_addr);
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          /* In reserve2, we overwrite the set value to vlink_param*/
          vlink_param.hello_interval = *(long *)var_val;
          if ((vlink_param.hello_interval <MIN_ospfVirtIfHelloInterval) || (vlink_param.hello_interval >MAX_ospfVirtIfHelloInterval))
             return SNMP_ERR_WRONGVALUE;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
         /* For row creation, if row_status =0, mean that this is a normal
          * operation, we do the normal set operation, otherwise it is a row
          * creation operation, will do nothing here, and the overall entry
          * will perform in the write_xxxRowStatus function.
          */
         //if ( ospfVirtIfEntry.status == 0)
         //{
                SET_FLAG(vlink_param.config, OSPF_TYPE_AREA_VLINK_HELLO_INTERVAL);
                if(OSPF_PMGR_AreaVirtualLinkSet(0,1, ip_address, 1, &vlink_param)!= NETCFG_TYPE_OK) /* OSPF_AREA_ID_FORMAT_ADDRESS: 1 */
                {
                    return SNMP_ERR_COMMITFAILED;
                }
         //}
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_ospfVirtIfRtrDeadInterval(int action,
                                u_char * var_val,
                                u_char var_val_type,
                                size_t var_val_len,
                                u_char * statP,
                                oid * name, size_t name_len)
{
    UI32_T oid_name_length = 10;
    UI32_T ip_address;
//    OSPF_TYPE_Area_Virtual_Link_Para_T vlink_param;

//    memset(&vlink_param,0,sizeof(vlink_param));



   /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  ospfVirtIfEntry_INSTANCE_LEN + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    SNMP_MGR_ReadIpFromCompl(name, oid_name_length,  &ip_address);
    SNMP_MGR_ReadIpFromCompl(name, oid_name_length+4,  &vlink_param.vlink_addr);
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          /* In reserve2, we overwrite the set value to vlink_param*/
          vlink_param.dead_interval = *(long *)var_val;
          if ((vlink_param.dead_interval <MIN_ospfVirtIfRtrDeadInterval) || (vlink_param.dead_interval >MAX_ospfVirtIfRtrDeadInterval))
             return SNMP_ERR_WRONGVALUE;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
         /* For row creation, if row_status =0, mean that this is a normal
          * operation, we do the normal set operation, otherwise it is a row
          * creation operation, will do nothing here, and the overall entry
          * will perform in the write_xxxRowStatus function.
          */
         //if (ospfVirtIfEntry.status == 0)
         //{
                SET_FLAG(vlink_param.config, OSPF_TYPE_AREA_VLINK_DEAD_INTERVAL);
                if(OSPF_PMGR_AreaVirtualLinkSet(0,1, ip_address, 1, &vlink_param)!= NETCFG_TYPE_OK) /* OSPF_AREA_ID_FORMAT_ADDRESS: 1 */
                {
                    return SNMP_ERR_COMMITFAILED;
                }
         //}
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_ospfVirtIfAuthKey(int action,
                        u_char * var_val,
                        u_char var_val_type,
                        size_t var_val_len,
                        u_char * statP, oid * name, size_t name_len)
{
    UI32_T oid_name_length = 10;
    UI32_T ip_address;
//    OSPF_TYPE_Area_Virtual_Link_Para_T vlink_param;

//    memset(&vlink_param,0,sizeof(vlink_param));

   /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  ospfVirtIfEntry_INSTANCE_LEN + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    SNMP_MGR_ReadIpFromCompl(name, oid_name_length,  &ip_address);
    SNMP_MGR_ReadIpFromCompl(name, oid_name_length+4,  &vlink_param.vlink_addr);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > (MAXSIZE_ospfVirtIfAuthKey)*sizeof(char)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
           /* In reserve2, we overwrite the set value to vlink_param*/
           memcpy(vlink_param.auth_key, var_val, var_val_len);
           vlink_param.auth_key[var_val_len]=0;
           break;
        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
         /* For row creation, if row_status =0, mean that this is a normal
          * operation, we do the normal set operation, otherwise it is a row
          * creation operation, will do nothing here, and the overall entry
          * will perform in the write_xxxRowStatus function.
          */
         //if ( ospfVirtIfEntry.status == 0)
         //{

            if(var_val_len)
            {
                strncpy(vlink_param.auth_key, (char *)var_val, var_val_len);
            }
            SET_FLAG(vlink_param.config, OSPF_TYPE_AREA_VLINK_AUTHENTICATIONKEY);
            if(var_val_len)
            {
                if(OSPF_PMGR_AreaVirtualLinkSet(0,1, ip_address,1, &vlink_param)!= NETCFG_TYPE_OK) /* OSPF_AREA_ID_FORMAT_ADDRESS: 1 */
                {
                    return SNMP_ERR_COMMITFAILED;
                }
            }
            else
            {
                if(OSPF_PMGR_AreaVirtualLinkUnset(0,1, ip_address,1 , &vlink_param)!= NETCFG_TYPE_OK) /* OSPF_AREA_ID_FORMAT_ADDRESS: 1 */
                {
                    return SNMP_ERR_COMMITFAILED;
                }
            }

            SET_FLAG(vlink_param.config, OSPF_TYPE_AREA_VLINK_AUTHENTICATIONKEY);
            if(var_val_len)
            {
                if(OSPF_PMGR_AreaVirtualLinkSet(0, 1, ip_address, 1, &vlink_param)!= NETCFG_TYPE_OK)
                {
                    return SNMP_ERR_COMMITFAILED;
                }
            }
            else
            {
                if(OSPF_PMGR_AreaVirtualLinkUnset(0, 1, ip_address, 1, &vlink_param)!= NETCFG_TYPE_OK)
                {
                    return SNMP_ERR_COMMITFAILED;
                }
            }
         //}/*end of if ( ospfVirtIfEntry.status == 0)*/
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_ospfVirtIfStatus(int action,
                       u_char * var_val,
                       u_char var_val_type,
                       size_t var_val_len,
                       u_char * statP, oid * name, size_t name_len)
{
    UI32_T oid_name_length = 10;
    UI32_T ip_address;
    UI32_T status=0;
//    OSPF_TYPE_Area_Virtual_Link_Para_T vlink_param;

//    memset(&vlink_param,0,sizeof(vlink_param));

   /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  ospfVirtIfEntry_INSTANCE_LEN + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    SNMP_MGR_ReadIpFromCompl(name, oid_name_length,  &ip_address);
    SNMP_MGR_ReadIpFromCompl(name, oid_name_length+4,  &vlink_param.vlink_addr);
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
           /* In reserve2, we overwrite the set value to */
          status = *(long *)var_val;
          if ((status <VAL_ospfVirtIfStatus_active) || (status >VAL_ospfVirtIfStatus_destroy))
             return SNMP_ERR_WRONGVALUE;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
          /* We perform the row creation here, if the row status = 4(createAndGo),
           * or 5 (createAndWait), we call the SetByEntry API, otherwise, call the
           * set rowstatus API
           */
          switch (status)
          {
               case VAL_ospfVirtIfStatus_createAndGo:
               case VAL_ospfVirtIfStatus_createAndWait:

                    if(OSPF_PMGR_AreaVirtualLinkSet(0,1, ip_address, 1, &vlink_param)!= NETCFG_TYPE_OK)  /* OSPF_AREA_ID_FORMAT_ADDRESS: 1 */
                    {
                        return SNMP_ERR_COMMITFAILED;
                    }

                break;
              case VAL_ospfVirtIfStatus_destroy:
                    if(OSPF_PMGR_AreaVirtualLinkUnset(0,1, ip_address, 1, &vlink_param)!= NETCFG_TYPE_OK)  /* OSPF_AREA_ID_FORMAT_ADDRESS: 1 */
                    {
                        return SNMP_ERR_COMMITFAILED;
                    }


                break;
              case VAL_ospfVirtIfStatus_active:
              case VAL_ospfVirtIfStatus_notInService:
              case VAL_ospfVirtIfStatus_notReady:
              default:
            return SNMP_ERR_COMMITFAILED;
          }
          break;
        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_ospfVirtIfAuthType(int action,
                         u_char * var_val,
                         u_char var_val_type,
                         size_t var_val_len,
                         u_char * statP, oid * name, size_t name_len)
{
    UI32_T oid_name_length = 10;
    UI32_T ip_address;

//    OSPF_TYPE_Area_Virtual_Link_Para_T vlink_param;

//    memset(&vlink_param,0,sizeof(vlink_param));



   /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  ospfVirtIfEntry_INSTANCE_LEN + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    SNMP_MGR_ReadIpFromCompl(name, oid_name_length,  &ip_address);
    SNMP_MGR_ReadIpFromCompl(name, oid_name_length+4,  &vlink_param.vlink_addr);
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
         /* In reserve2, we overwrite the set value to vlink_param*/
          vlink_param.auth_type = *(long *)var_val;
          if ((vlink_param.auth_type <MIN_ospfVirtIfAuthType) || (vlink_param.auth_type >MAX_ospfVirtIfAuthType))
             return SNMP_ERR_WRONGVALUE;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
         /* For row creation, if row_status =0, mean that this is a normal
          * operation, we do the normal set operation, otherwise it is a row
          * creation operation, will do nothing here, and the overall entry
          * will perform in the write_xxxRowStatus function.
          */
            switch(vlink_param.auth_type)
            {
                case OSPF_TYPE_AUTH_CRYPTOGRAPHIC:
                case OSPF_TYPE_AUTH_SIMPLE:
                {
                    UI32_T area_id = ip_address;
                    SET_FLAG(vlink_param.config, OSPF_TYPE_AREA_VLINK_AUTHENTICATION);
                    if(OSPF_PMGR_AreaVirtualLinkSet(0,1, area_id, 1, &vlink_param)!= NETCFG_TYPE_OK)
                    {
                        return SNMP_ERR_COMMITFAILED;
                    }
                    break;
                }
                default:
                    if(SNMP_MGR_IsDebugMode())
                        SYSFUN_Debug_Printf("write_ospfVirtIfAuthKey:unknow type=%lu\n", vlink_param.auth_type);
                    return SNMP_ERR_COMMITFAILED;
                    break;

             } /* switch */
         break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.old-api.conf,v 1.3 2002/10/17 09:40:46 dts12 Exp $
 */

/*
 * ospfVirtNbrTable_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid             ospfVirtNbrTable_variables_oid[] =
    { 1, 3, 6, 1, 2, 1, 14 };

/*
 * variable4 ospfVirtNbrTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */

struct variable3 ospfVirtNbrTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */

#define OSPFVIRTNBRAREA     1
    {OSPFVIRTNBRAREA, ASN_IPADDRESS, RONLY, var_ospfVirtNbrTable, 3,
     {11, 1, 1}},
#define OSPFVIRTNBRRTRID        2
    {OSPFVIRTNBRRTRID, ASN_IPADDRESS, RONLY, var_ospfVirtNbrTable, 3,
     {11, 1, 2}},
#define OSPFVIRTNBRIPADDR       3
    {OSPFVIRTNBRIPADDR, ASN_IPADDRESS, RONLY, var_ospfVirtNbrTable, 3,
     {11, 1, 3}},
#define OSPFVIRTNBROPTIONS      4
    {OSPFVIRTNBROPTIONS, ASN_INTEGER, RONLY, var_ospfVirtNbrTable, 3,
     {11, 1, 4}},
#define OSPFVIRTNBRSTATE        5
    {OSPFVIRTNBRSTATE, ASN_INTEGER, RONLY, var_ospfVirtNbrTable, 3,
     {11, 1, 5}},
#define OSPFVIRTNBREVENTS       6
    {OSPFVIRTNBREVENTS, ASN_COUNTER, RONLY, var_ospfVirtNbrTable, 3,
     {11, 1, 6}},
#define OSPFVIRTNBRLSRETRANSQLEN        7
    {OSPFVIRTNBRLSRETRANSQLEN, ASN_GAUGE, RONLY, var_ospfVirtNbrTable, 3,
     {11, 1, 7}},
#define OSPFVIRTNBRHELLOSUPPRESSED      8
    {OSPFVIRTNBRHELLOSUPPRESSED, ASN_INTEGER, RONLY, var_ospfVirtNbrTable,
     3, {11, 1, 8}},
};
/*
 * (L = length of the oidsuffix)
 */


/** Initializes the ospfVirtNbrTable module */
void
init_ospfVirtNbrTable(void)
{

    /*
     * register ourselves with the agent to handle our mib tree
     */
    REGISTER_MIB("ospfVirtNbrTable", ospfVirtNbrTable_variables, variable3,
                 ospfVirtNbrTable_variables_oid);

}

static BOOL_T ospfVirtNbrTable_get(int      compc,
                                oid     *compl,
                                OSPF_TYPE_MultiProcessVirtNbr_T   *data)
{
    if (compc !=ospfVirtNbrEntry_INSTANCE_LEN)
    {
        return FALSE;
    }
    SNMP_MGR_ReadIpFromCompl(compl,0, (UI32_T *) &data->area_id.s_addr);
    SNMP_MGR_ReadIpFromCompl(compl,4, (UI32_T *) &data->router_id.s_addr);


    if (OSPF_PMGR_GetMultiProcVirtNbrEntry(data)!=OSPF_TYPE_RESULT_SUCCESS)
    {
        return FALSE;
    }
    else
    {
        return TRUE;

    } /*End of if */
}

static BOOL_T ospfVirtNbrTable_next(int      compc,
                                 oid     *compl,
                                 OSPF_TYPE_MultiProcessVirtNbr_T    *data)
{
    oid tmp_compl[ospfVirtNbrEntry_INSTANCE_LEN];

    /* Generate the instance of each table entry and find the
     * smallest instance that's larger than compc/compl.
     *
     * Step 1: Verify and extract the input key from "compc" and "compl"
     * Note: The number of input key is defined by "compc".
     *       The key for the specified instance is defined in compl.
     */
    memcpy(tmp_compl, compl, sizeof(tmp_compl));
    SNMP_MGR_checkCompl(0, 7, tmp_compl,255);
    SNMP_MGR_ConvertRemainToZero(compc,ospfVirtNbrEntry_INSTANCE_LEN, tmp_compl);

    SNMP_MGR_ReadIpFromCompl(tmp_compl,0,(UI32_T *) &data->area_id.s_addr);
    SNMP_MGR_ReadIpFromCompl(tmp_compl,4,(UI32_T *) &data->router_id.s_addr);


    if (compc<ospfVirtNbrEntry_INSTANCE_LEN)
    {
        if (OSPF_PMGR_GetMultiProcVirtNbrEntry(data)!=OSPF_TYPE_RESULT_SUCCESS)
        {
            if (OSPF_PMGR_GetNextMultiProcVirtNbrEntry(data)!=OSPF_TYPE_RESULT_SUCCESS)
            {
                return FALSE;
            }
        }
    }
    else
    {
        if (OSPF_PMGR_GetNextMultiProcVirtNbrEntry(data)!=OSPF_TYPE_RESULT_SUCCESS)
        {
            return FALSE;
        }
    }
    return TRUE;
}


/*
 * var_ospfVirtNbrTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_ospfVirtNbrTable(struct variable *vp,
                     oid * name,
                     size_t * length,
                     int exact,
                     size_t * var_len, WriteMethod ** write_method)
{
    UI32_T compc=0;
    oid compl[ospfVirtNbrEntry_INSTANCE_LEN];
    oid best_inst[ospfVirtNbrEntry_INSTANCE_LEN];
    OSPF_TYPE_MultiProcessVirtNbr_T data;

    /* init */
    memset(&data, 0, sizeof(data));
    data.vr_id = 0;
    data.proc_id = 1;

    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,compl, ospfVirtNbrEntry_INSTANCE_LEN);

     /*check compc, retrive compl*/
    if (exact)/*get,set*/
    {
        if (!ospfVirtNbrTable_get(compc, compl, &data))
            return NULL;
    }
    else/*getnext*/
    {
        if (!ospfVirtNbrTable_next(compc, compl, &data))
        {
            return NULL;
        }
    }
    memcpy(name, vp->name, vp->namelen*sizeof(oid));
    SNMP_MGR_BindIpInstance(data.area_id.s_addr,0,best_inst);
    SNMP_MGR_BindIpInstance(data.router_id.s_addr,4,best_inst);


    memcpy(name + vp->namelen, best_inst, ospfVirtNbrEntry_INSTANCE_LEN*sizeof(oid));
    *length = vp->namelen +ospfVirtNbrEntry_INSTANCE_LEN;

    *var_len = sizeof(long_return);

    /*
     * * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
      case OSPFVIRTNBRAREA:
        *var_len = sizeof(ipaddr_return);
        ipaddr_return = data.area_id.s_addr;
        return (u_char*) &ipaddr_return;
      case OSPFVIRTNBRRTRID:
        *var_len = sizeof(ipaddr_return);
        ipaddr_return = data.router_id.s_addr;
        return (u_char*) &ipaddr_return;
      case OSPFVIRTNBRIPADDR:
        *var_len = sizeof(ipaddr_return);
        ipaddr_return = data.ipaddr.s_addr;
        return (u_char*) &ipaddr_return;
      case OSPFVIRTNBROPTIONS:
        long_return = data.options;
        return (u_char*) &long_return;
      case OSPFVIRTNBRSTATE:
        long_return = data.state;
        return (u_char*) &long_return;
      case OSPFVIRTNBREVENTS:
        long_return = data.event;
        return (u_char*) &long_return;
      case OSPFVIRTNBRLSRETRANSQLEN:
        long_return = data.lsretransqlen;
        return (u_char*) &long_return;
      case OSPFVIRTNBRHELLOSUPPRESSED:
        long_return = VAL_ospfVirtNbrHelloSuppressed_false; /* not support */
        return (u_char*) &long_return;
    default:
        ERROR_MSG("");
    }
    return NULL;
}


/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.old-api.conf,v 1.3 2002/10/17 09:40:46 dts12 Exp $
 */

/*
 * ospfNbrTable_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid             ospfNbrTable_variables_oid[] =
    { 1, 3, 6, 1, 2, 1, 14};

/*
 * variable4 ospfNbrTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */

struct variable3 ospfNbrTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */

#define OSPFNBRIPADDR       1
    {OSPFNBRIPADDR, ASN_IPADDRESS, RONLY, var_ospfNbrTable, 3, {10, 1, 1}},
#define OSPFNBRADDRESSLESSINDEX     2
    {OSPFNBRADDRESSLESSINDEX, ASN_INTEGER, RONLY, var_ospfNbrTable, 3,
     {10, 1, 2}},
#define OSPFNBRRTRID        3
    {OSPFNBRRTRID, ASN_IPADDRESS, RONLY, var_ospfNbrTable, 3, {10, 1, 3}},
#define OSPFNBROPTIONS      4
    {OSPFNBROPTIONS, ASN_INTEGER, RONLY, var_ospfNbrTable, 3, {10, 1, 4}},
#define OSPFNBRPRIORITY     5
    {OSPFNBRPRIORITY, ASN_INTEGER, RWRITE, var_ospfNbrTable, 3,
     {10, 1, 5}},
#define OSPFNBRSTATE        6
    {OSPFNBRSTATE, ASN_INTEGER, RONLY, var_ospfNbrTable, 3, {10, 1, 6}},
#define OSPFNBREVENTS       7
    {OSPFNBREVENTS, ASN_COUNTER, RONLY, var_ospfNbrTable, 3, {10, 1, 7}},
#define OSPFNBRLSRETRANSQLEN        8
    {OSPFNBRLSRETRANSQLEN, ASN_GAUGE, RONLY, var_ospfNbrTable, 3,
     {10, 1, 8}},
#define OSPFNBMANBRSTATUS       9
    {OSPFNBMANBRSTATUS, ASN_INTEGER, RWRITE, var_ospfNbrTable, 3,
     {10, 1, 9}},
#define OSPFNBMANBRPERMANENCE       10
    {OSPFNBMANBRPERMANENCE, ASN_INTEGER, RONLY, var_ospfNbrTable, 3,
     {10, 1, 10}},
#define OSPFNBRHELLOSUPPRESSED      11
    {OSPFNBRHELLOSUPPRESSED, ASN_INTEGER, RONLY, var_ospfNbrTable, 3,
     {10, 1, 11}},
};
/*
 * (L = length of the oidsuffix)
 */


/** Initializes the ospfNbrTable module */
void
init_ospfNbrTable(void)
{

    /*
     * register ourselves with the agent to handle our mib tree
     */
    REGISTER_MIB("ospfNbrTable", ospfNbrTable_variables, variable3,
                 ospfNbrTable_variables_oid);
}

static BOOL_T ospfNbrTable_get(int      compc,
                                oid     *compl,
                                OSPF_TYPE_MultiProcessNbr_T   *data)
{
    if (compc !=ospfNbrEntry_INSTANCE_LEN)
    {
        return FALSE;
    }
    SNMP_MGR_ReadIpFromCompl(compl,0, (UI32_T *) &data->NbrIpAddr.s_addr);

    if (OSPF_PMGR_GetMultiProcessNbrEntry(0, data)!=OSPF_TYPE_RESULT_SUCCESS)
    {
        return FALSE;
    }
    else
    {
        return TRUE;

    } /*End of if */
}

static BOOL_T ospfNbrTable_next(int      compc,
                                 oid     *compl,
                                 OSPF_TYPE_MultiProcessNbr_T    *data)
{
    oid tmp_compl[ospfNbrEntry_INSTANCE_LEN];

    /* Generate the instance of each table entry and find the
     * smallest instance that's larger than compc/compl.
     *
     * Step 1: Verify and extract the input key from "compc" and "compl"
     * Note: The number of input key is defined by "compc".
     *       The key for the specified instance is defined in compl.
     */
    memcpy(tmp_compl, compl, sizeof(tmp_compl));
    SNMP_MGR_checkCompl(0, 3, tmp_compl,255);
    SNMP_MGR_ConvertRemainToZero(compc,ospfNbrEntry_INSTANCE_LEN, tmp_compl);

    SNMP_MGR_ReadIpFromCompl(tmp_compl,0, (UI32_T *) &data->NbrIpAddr.s_addr);

    if (compc<ospfNbrEntry_INSTANCE_LEN)
    {
        if (OSPF_PMGR_GetMultiProcessNbrEntry(0, data)!=OSPF_TYPE_RESULT_SUCCESS)
        {
            if (OSPF_PMGR_GetNextMultiProcessNbrEntry(0, 0, data)!=OSPF_TYPE_RESULT_SUCCESS) //peter_yu, index_len?
            {
                return FALSE;
            }
        }
    }
    else
    {
        if (OSPF_PMGR_GetNextMultiProcessNbrEntry(0, ospfNbrEntry_INSTANCE_LEN, data)!=OSPF_TYPE_RESULT_SUCCESS)// peter_yu, index_len?
        {
            return FALSE;
        }
    }
    return TRUE;
}
/*
//!!!!!!!!!!!!!!!!!!!!!!
//hyliao said that this table is not support get whole entry and get default api now,
//!!!!!!!!!!!!!!!!!!!!!!!
 */
/*
 * var_ospfNbrTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_ospfNbrTable(struct variable *vp,
                 oid * name,
                 size_t * length,
                 int exact, size_t * var_len, WriteMethod ** write_method)
{
    UI32_T compc=0;
    oid compl[ospfNbrEntry_INSTANCE_LEN];
    oid best_inst[ospfNbrEntry_INSTANCE_LEN];
    OSPF_TYPE_MultiProcessNbr_T data;

   /*Since this table allow for entry that does not exist, (creation). we need to know the write method first*/
    switch (vp->magic)
    {
      case OSPFNBRPRIORITY:
        *write_method = write_ospfNbrPriority;
        break;
      case OSPFNBMANBRSTATUS:
        *write_method = write_ospfNbmaNbrStatus;
        break;
      default:
        *write_method =0;
         break;
    }

    /* init */
    memset(&data, 0, sizeof(data));
    data.proc_id = 1;

    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,compl, ospfNbrEntry_INSTANCE_LEN);

     /*check compc, retrive compl*/
    if (exact)/*get,set*/
    {
        if (!ospfNbrTable_get(compc, compl, &data))
            return NULL;
    }
    else/*getnext*/
    {
        if (!ospfNbrTable_next(compc, compl, &data))
        {
            return NULL;
        }
    }
    memcpy(name, vp->name, vp->namelen*sizeof(oid));
    SNMP_MGR_BindIpInstance(data.NbrIpAddr.s_addr,0,best_inst);
    best_inst[4] = 0; //data.ospf_nbr_address_less_index;

    memcpy(name + vp->namelen, best_inst, ospfNbrEntry_INSTANCE_LEN*sizeof(oid));
    *length = vp->namelen +ospfNbrEntry_INSTANCE_LEN;

    *var_len = sizeof(long_return);

    /*
     * * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
      case OSPFNBRIPADDR:
        *var_len = sizeof(ipaddr_return);
        ipaddr_return = data.NbrIpAddr.s_addr;
        return (u_char*) &ipaddr_return;
    case OSPFNBRADDRESSLESSINDEX:
        long_return = 0;
        return (u_char*) &long_return;
      case OSPFNBRRTRID:
        *var_len = sizeof(ipaddr_return);
        ipaddr_return = data.router_id.s_addr;
        return (u_char*) &ipaddr_return;
      case OSPFNBROPTIONS:
        long_return = data.NbrOptions;
        return (u_char*) &long_return;
      case OSPFNBRPRIORITY:
        long_return = data.NbrPriority;
        return (u_char*) &long_return;
      case OSPFNBRSTATE:
        long_return = data.NbrState;
        return (u_char*) &long_return;
      case OSPFNBREVENTS:
        long_return = data.NbrEvent;
        return (u_char*) &long_return;
      case OSPFNBRLSRETRANSQLEN:
        long_return = data.NbrLsRetransQlen;
        return (u_char*) &long_return;
      case OSPFNBMANBRSTATUS:
        long_return = data.NbmaNbrStatus;
        return (u_char*) &long_return;
      case OSPFNBMANBRPERMANENCE:
        long_return = VAL_ospfNbmaNbrPermanence_permanent;
        return (u_char*) &long_return;
      case OSPFNBRHELLOSUPPRESSED:
        long_return = VAL_ospfNbrHelloSuppressed_false;
        return (u_char*) &long_return;
    default:
        ERROR_MSG("");
    }
    return NULL;
}


int
write_ospfNbrPriority(int action,
                      u_char * var_val,
                      u_char var_val_type,
                      size_t var_val_len,
                      u_char * statP, oid * name, size_t name_len)
{
    long value;
    UI32_T oid_name_length = 10;
    UI32_T ip_address;


   /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  ospfVirtIfEntry_INSTANCE_LEN + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    SNMP_MGR_ReadIpFromCompl(name, oid_name_length,  &ip_address);
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          value = *(long *)var_val;
          if ((value <MIN_ospfNbrPriority) || (value >MAX_ospfNbrPriority))
             return SNMP_ERR_WRONGVALUE;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            value = *(long *)var_val;
            // peter, not support yet
            return SNMP_ERR_COMMITFAILED;

          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_ospfNbmaNbrStatus(int action,
                        u_char * var_val,
                        u_char var_val_type,
                        size_t var_val_len,
                        u_char * statP, oid * name, size_t name_len)
{
    long value;
    UI32_T oid_name_length = 10;
    UI32_T ip_address;


   /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  ospfVirtIfEntry_INSTANCE_LEN + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    SNMP_MGR_ReadIpFromCompl(name, oid_name_length,  &ip_address);
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          value = *(long *)var_val;
          if ((value <VAL_ospfNbmaNbrStatus_active) || (value >VAL_ospfNbmaNbrStatus_destroy))
             return SNMP_ERR_WRONGVALUE;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             value = *(long *)var_val;
             #if 0
             if (OSPF_PMGR_SetOspfVirtIfAuthType(ip_address, name[14], value)!= OSPF_TYPE_RESULT_SUCCESS)
             {
                return SNMP_ERR_COMMITFAILED;
             }
             #endif
             /*not support?*/
             return SNMP_ERR_COMMITFAILED;
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.old-api.conf,v 1.3 2002/10/17 09:40:46 dts12 Exp $
 */

/*
 * ospfExtLsdbTable_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid             ospfExtLsdbTable_variables_oid[] =
    { 1, 3, 6, 1, 2, 1, 14};

/*
 * variable4 ospfExtLsdbTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */

struct variable3 ospfExtLsdbTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */

#define OSPFEXTLSDBTYPE     1
    {OSPFEXTLSDBTYPE, ASN_INTEGER, RONLY, var_ospfExtLsdbTable, 3,
     {12, 1, 1}},
#define OSPFEXTLSDBLSID     2
    {OSPFEXTLSDBLSID, ASN_IPADDRESS, RONLY, var_ospfExtLsdbTable, 3,
     {12, 1, 2}},
#define OSPFEXTLSDBROUTERID     3
    {OSPFEXTLSDBROUTERID, ASN_IPADDRESS, RONLY, var_ospfExtLsdbTable, 3,
     {12, 1, 3}},
#define OSPFEXTLSDBSEQUENCE     4
    {OSPFEXTLSDBSEQUENCE, ASN_INTEGER, RONLY, var_ospfExtLsdbTable, 3,
     {12, 1, 4}},
#define OSPFEXTLSDBAGE      5
    {OSPFEXTLSDBAGE, ASN_INTEGER, RONLY, var_ospfExtLsdbTable, 3,
     {12, 1, 5}},
#define OSPFEXTLSDBCHECKSUM     6
    {OSPFEXTLSDBCHECKSUM, ASN_INTEGER, RONLY, var_ospfExtLsdbTable, 3,
     {12, 1, 6}},
#define OSPFEXTLSDBADVERTISEMENT        7
    {OSPFEXTLSDBADVERTISEMENT, ASN_OCTET_STR, RONLY, var_ospfExtLsdbTable,
     3, {12, 1, 7}},
};
/*
 * (L = length of the oidsuffix)
 */


/** Initializes the ospfExtLsdbTable module */
void
init_ospfExtLsdbTable(void)
{

    /*
     * register ourselves with the agent to handle our mib tree
     */
    REGISTER_MIB("ospfExtLsdbTable", ospfExtLsdbTable_variables, variable3,
                 ospfExtLsdbTable_variables_oid);


}

static BOOL_T ospfExtLsdbTable_get(int      compc,
                                oid     *compl,
                                OSPF_TYPE_MultiProcessExtLsdb_T   *data)
{
    if (compc !=ospfExtLsdbEntry_INSTANCE_LEN)
    {
        return FALSE;
    }
    data->ExtLsdbType = compl[0];
    SNMP_MGR_ReadIpFromCompl(compl,1, (UI32_T *) &data->ExtLsdbLsid.s_addr);
    SNMP_MGR_ReadIpFromCompl(compl,5, (UI32_T *) &data->ExtLsdbRouter_id.s_addr);

    if (OSPF_PMGR_GetMultiProcessExtLsdbEntry(0, data)!=OSPF_TYPE_RESULT_SUCCESS)
    {
        return FALSE;
    }
    else
    {
        return TRUE;

    } /*End of if */
}

static BOOL_T ospfExtLsdbTable_next(int      compc,
                                 oid     *compl,
                                 OSPF_TYPE_MultiProcessExtLsdb_T    *data)
{
    oid tmp_compl[ospfExtLsdbEntry_INSTANCE_LEN];

    /* Generate the instance of each table entry and find the
     * smallest instance that's larger than compc/compl.
     *
     * Step 1: Verify and extract the input key from "compc" and "compl"
     * Note: The number of input key is defined by "compc".
     *       The key for the specified instance is defined in compl.
     */
    memcpy(tmp_compl, compl, sizeof(tmp_compl));
    SNMP_MGR_checkCompl(1, 8, tmp_compl,255);
    SNMP_MGR_ConvertRemainToZero(compc,ospfExtLsdbEntry_INSTANCE_LEN, tmp_compl);
    data->ExtLsdbType = tmp_compl[0];
    SNMP_MGR_ReadIpFromCompl(tmp_compl,1, (UI32_T *) &data->ExtLsdbLsid.s_addr);
    SNMP_MGR_ReadIpFromCompl(tmp_compl,5, (UI32_T *) &data->ExtLsdbRouter_id.s_addr);

    if (compc<ospfExtLsdbEntry_INSTANCE_LEN)
    {
        if (OSPF_PMGR_GetMultiProcessExtLsdbEntry(0, data)!=OSPF_TYPE_RESULT_SUCCESS)
        {
            if (OSPF_PMGR_GetNextMultiProcessExtLsdbEntry(0, compc, data)!=OSPF_TYPE_RESULT_SUCCESS)
            {
                return FALSE;
            }
        }
    }
    else
    {
        if (OSPF_PMGR_GetNextMultiProcessExtLsdbEntry(0, compc, data)!=OSPF_TYPE_RESULT_SUCCESS)
        {
            return FALSE;
        }
    }
    return TRUE;
}


/*
 * var_ospfExtLsdbTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_ospfExtLsdbTable(struct variable *vp,
                     oid * name,
                     size_t * length,
                     int exact,
                     size_t * var_len, WriteMethod ** write_method)
{
    UI32_T compc=0;
    oid compl[ospfExtLsdbEntry_INSTANCE_LEN];
    oid best_inst[ospfExtLsdbEntry_INSTANCE_LEN];
    OSPF_TYPE_MultiProcessExtLsdb_T data;

    /* init */
    memset(&data, 0, sizeof(data));
    data.proc_id = 1;

    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,compl, ospfExtLsdbEntry_INSTANCE_LEN);

     /*check compc, retrive compl*/
    if (exact)/*get,set*/
    {
        if (!ospfExtLsdbTable_get(compc, compl, &data))
            return NULL;
    }
    else/*getnext*/
    {
        if (!ospfExtLsdbTable_next(compc, compl, &data))
        {
            return NULL;
        }
    }
    memcpy(name, vp->name, vp->namelen*sizeof(oid));
    best_inst[0] = data.ExtLsdbType;
    SNMP_MGR_BindIpInstance(data.ExtLsdbLsid.s_addr,1,best_inst);
    SNMP_MGR_BindIpInstance(data.ExtLsdbRouter_id.s_addr,5,best_inst);

    memcpy(name + vp->namelen, best_inst, ospfExtLsdbEntry_INSTANCE_LEN*sizeof(oid));
    *length = vp->namelen +ospfExtLsdbEntry_INSTANCE_LEN;

    *var_len = sizeof(long_return);

    /*
     * * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
      case OSPFEXTLSDBTYPE:
        long_return = data.ExtLsdbType;
/*         if (data.ospf_ext_lsdb_advertisement)
        {
            L_MEM_Free(data.ospf_ext_lsdb_advertisement);
            data.ospf_ext_lsdb_advertisement = NULL;
        }
 */        return (u_char*) &long_return;
      case OSPFEXTLSDBLSID:
        *var_len = sizeof(ipaddr_return);
        ipaddr_return = data.ExtLsdbLsid.s_addr;
/*         if (data.ospf_ext_lsdb_advertisement)
        {
            L_MEM_Free(data.ospf_ext_lsdb_advertisement);
            data.ospf_ext_lsdb_advertisement = NULL;
        }
 */        return (u_char*) &ipaddr_return;
      case OSPFEXTLSDBROUTERID:
        *var_len = sizeof(ipaddr_return);
        ipaddr_return = data.ExtLsdbRouter_id.s_addr;
/*         if (data.ospf_ext_lsdb_advertisement)
        {
            L_MEM_Free(data.ospf_ext_lsdb_advertisement);
            data.ospf_ext_lsdb_advertisement = NULL;
        }
 */        return (u_char*) &ipaddr_return;
      case OSPFEXTLSDBSEQUENCE:
        long_return = data.ExtLsdbSeqence;
/*         if (data.ospf_ext_lsdb_advertisement)
        {
            L_MEM_Free(data.ospf_ext_lsdb_advertisement);
            data.ospf_ext_lsdb_advertisement = NULL;
        }
 */        return (u_char*) &long_return;
      case OSPFEXTLSDBAGE:
        long_return = data.ExtLsdbAge;
/*         if (data.ospf_ext_lsdb_advertisement)
        {
            L_MEM_Free(data.ospf_ext_lsdb_advertisement);
            data.ospf_ext_lsdb_advertisement = NULL;
        }
 */        return (u_char*) &long_return;
      case OSPFEXTLSDBCHECKSUM:
        long_return = data.ExtLsdbChecksum;
/*         if (data.ospf_ext_lsdb_advertisement)
        {
            L_MEM_Free(data.ospf_ext_lsdb_advertisement);
            data.ospf_ext_lsdb_advertisement = NULL;
        }
 */        return (u_char*) &long_return;
      case OSPFEXTLSDBADVERTISEMENT:
        memcpy(return_buf, data.ExtLsdbAdvertise,data.ExtLsdbAdvertise_size);
        *var_len = data.ExtLsdbAdvertise_size;
/*         if (data.ospf_ext_lsdb_advertisement)
        {
            L_MEM_Free(data.ospf_ext_lsdb_advertisement);
            data.ospf_ext_lsdb_advertisement = NULL;
        }
 */        return (u_char*) return_buf;
    default:
        ERROR_MSG("");
    }

/*     if (data.ospf_ext_lsdb_advertisement)
    {
        L_MEM_Free(data.ospf_ext_lsdb_advertisement);
        data.ospf_ext_lsdb_advertisement = NULL;
    }
 */    return NULL;
}



/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.old-api.conf,v 1.3 2002/10/17 09:40:46 dts12 Exp $
 */


/*
 * ospfAreaAggregateTable_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid             ospfAreaAggregateTable_variables_oid[] =
    { 1, 3, 6, 1, 2, 1, 14 };

/*
 * variable4 ospfAreaAggregateTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */

struct variable3 ospfAreaAggregateTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */

#define OSPFAREAAGGREGATEAREAID     1
    {OSPFAREAAGGREGATEAREAID, ASN_IPADDRESS, RONLY,
     var_ospfAreaAggregateTable, 3, {14, 1, 1}},
#define OSPFAREAAGGREGATELSDBTYPE       2
    {OSPFAREAAGGREGATELSDBTYPE, ASN_INTEGER, RONLY,
     var_ospfAreaAggregateTable, 3, {14, 1, 2}},
#define OSPFAREAAGGREGATENET        3
    {OSPFAREAAGGREGATENET, ASN_IPADDRESS, RONLY,
     var_ospfAreaAggregateTable, 3, {14, 1, 3}},
#define OSPFAREAAGGREGATEMASK       4
    {OSPFAREAAGGREGATEMASK, ASN_IPADDRESS, RONLY,
     var_ospfAreaAggregateTable, 3, {14, 1, 4}},
#define OSPFAREAAGGREGATESTATUS     5
    {OSPFAREAAGGREGATESTATUS, ASN_INTEGER, RWRITE,
     var_ospfAreaAggregateTable, 3, {14, 1, 5}},
#define OSPFAREAAGGREGATEEFFECT     6
    {OSPFAREAAGGREGATEEFFECT, ASN_INTEGER, RWRITE,
     var_ospfAreaAggregateTable, 3, {14, 1, 6}},
};
/*
 * (L = length of the oidsuffix)
 */


/** Initializes the ospfAreaAggregateTable module */
void
init_ospfAreaAggregateTable(void)
{


    /*
     * register ourselves with the agent to handle our mib tree
     */
    REGISTER_MIB("ospfAreaAggregateTable",
                 ospfAreaAggregateTable_variables, variable3,
                 ospfAreaAggregateTable_variables_oid);

    /*
     * place any other initialization junk you need here
     */
}

static BOOL_T ospfAreaAggregateTable_get(int      compc,
                                oid     *compl,
                                OSPF_TYPE_Area_Range_T   *data)
{
    if (compc !=ospfAreaAggregateEntry_INSTANCE_LEN)
    {
        return FALSE;
    }

    SNMP_MGR_ReadIpFromCompl(compl,0, &data->area_id);
    data->type = compl[4];
    SNMP_MGR_ReadIpFromCompl(compl,5, &data->range_addr);
    SNMP_MGR_ReadIpFromCompl(compl,9, &data->range_mask);

    if (OSPF_PMGR_GetAreaRangeTable(data)!=OSPF_TYPE_RESULT_SUCCESS)
    {
        return FALSE;
    }
    else
    {
        return TRUE;

    } /*End of if */
}

static BOOL_T ospfAreaAggregateTable_next(int      compc,
                                 oid     *compl,
                                 OSPF_TYPE_Area_Range_T    *data)
{
    oid tmp_compl[ospfAreaAggregateEntry_INSTANCE_LEN];

    /* Generate the instance of each table entry and find the
     * smallest instance that's larger than compc/compl.
     *
     * Step 1: Verify and extract the input key from "compc" and "compl"
     * Note: The number of input key is defined by "compc".
     *       The key for the specified instance is defined in compl.
     */
    memcpy(tmp_compl, compl, sizeof(tmp_compl));
    SNMP_MGR_checkCompl(0, 3, tmp_compl,255);
    SNMP_MGR_checkCompl(5, 12, tmp_compl,255);
    SNMP_MGR_ConvertRemainToZero(compc,ospfAreaAggregateEntry_INSTANCE_LEN, tmp_compl);
    SNMP_MGR_ReadIpFromCompl(tmp_compl,0,&data->area_id);
    data->type = tmp_compl[4];
    SNMP_MGR_ReadIpFromCompl(tmp_compl,5,&data->range_addr);
    SNMP_MGR_ReadIpFromCompl(tmp_compl,9,&data->range_mask);

    if (compc<ospfAreaAggregateEntry_INSTANCE_LEN)
    {
        if (OSPF_PMGR_GetAreaRangeTable(data)!=OSPF_TYPE_RESULT_SUCCESS)
        {
            data->indexlen = 0;
            if (OSPF_PMGR_GetNextAreaRangeTable(data)!=OSPF_TYPE_RESULT_SUCCESS)
            {
                return FALSE;
            }
        }
    }
    else
    {
        data->indexlen = ospfAreaAggregateEntry_INSTANCE_LEN;

        if (OSPF_PMGR_GetNextAreaRangeTable(data)!=OSPF_TYPE_RESULT_SUCCESS)
        {
            return FALSE;
        }
    }
    return TRUE;
}

/* This entry is used for entry which have the ability to row create*/
static OSPF_TYPE_Area_Range_T ospfAreaAggregateEntry;


/*
 * var_ospfAreaAggregateTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_ospfAreaAggregateTable(struct variable *vp,
                           oid * name,
                           size_t * length,
                           int exact,
                           size_t * var_len, WriteMethod ** write_method)
{
    UI32_T compc=0;
    oid compl[ospfAreaAggregateEntry_INSTANCE_LEN];
    oid best_inst[ospfAreaAggregateEntry_INSTANCE_LEN];
    OSPF_TYPE_Area_Range_T data;

    /* Give default value for the record first.
     * We use the row_status = 0 to indicate if this set operation is Set by field
     * or set by record(included row creation), if the row_status =0, this record
     * mean set by field, otherwise, we just think it is a normal set operation
     */

    /* init */
    memset(&ospfAreaAggregateEntry, 0, sizeof(ospfAreaAggregateEntry));
    ospfAreaAggregateEntry.vr_id = 0;
    ospfAreaAggregateEntry.proc_id = 1;

   /*Since this table allow for entry that does not exist, (creation). we need to know the write method first*/
    switch (vp->magic)
    {
       case OSPFAREAAGGREGATESTATUS:
        *write_method = write_ospfAreaAggregateStatus;
        break;
      case OSPFAREAAGGREGATEEFFECT:
        *write_method = write_ospfAreaAggregateEffect;
        break;
      default:
        *write_method =0;
         break;
    }

    /* init */
    memset(&data, 0, sizeof(data));
    data.vr_id = 0;
    data.proc_id = 1;

    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,compl, ospfAreaAggregateEntry_INSTANCE_LEN);

     /*check compc, retrive compl*/
    if (exact)/*get,set*/
    {
        if (!ospfAreaAggregateTable_get(compc, compl, &data))
            return NULL;
    }
    else/*getnext*/
    {
        if (!ospfAreaAggregateTable_next(compc, compl, &data))
        {
            return NULL;
        }
    }
    memcpy(name, vp->name, vp->namelen*sizeof(oid));
    SNMP_MGR_BindIpInstance(data.area_id,0,best_inst);
    best_inst[4] = data.type;
    SNMP_MGR_BindIpInstance(data.range_addr,5,best_inst);
    SNMP_MGR_BindIpInstance(data.range_mask,9,best_inst);


    memcpy(name + vp->namelen, best_inst, ospfAreaAggregateEntry_INSTANCE_LEN*sizeof(oid));
    *length = vp->namelen +ospfAreaAggregateEntry_INSTANCE_LEN;

    *var_len = sizeof(long_return);

    /*
     * * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
      case OSPFAREAAGGREGATEAREAID:
        *var_len = sizeof(ipaddr_return);
        ipaddr_return = data.area_id;
        return (u_char*) &ipaddr_return;
      case OSPFAREAAGGREGATELSDBTYPE:
        long_return = data.type;
        return (u_char*) &long_return;
      case OSPFAREAAGGREGATENET:
        *var_len = sizeof(ipaddr_return);
        ipaddr_return = data.range_addr;
        return (u_char*) &ipaddr_return;
      case OSPFAREAAGGREGATEMASK:
        *var_len = sizeof(ipaddr_return);
        ipaddr_return = data.range_mask;
        return (u_char*) &ipaddr_return;
      case OSPFAREAAGGREGATESTATUS:
        long_return = data.status;
        return (u_char*) &long_return;
      case OSPFAREAAGGREGATEEFFECT:
            if (CHECK_FLAG (data.flags, OSPF_AREA_RANGE_ADVERTISE))
            {
                long_return = VAL_ospfAreaRangeEffect_advertiseMatching;
            }
            else
            {
                long_return = VAL_ospfAreaRangeEffect_doNotAdvertiseMatching;
            }
            return (u_char*) &long_return;
            break;
    default:
        ERROR_MSG("");
    }
    return NULL;
}


int
write_ospfAreaAggregateStatus(int action,
                              u_char * var_val,
                              u_char var_val_type,
                              size_t var_val_len,
                              u_char * statP, oid * name, size_t name_len)
{
    UI32_T oid_name_length = 10;
    UI32_T ip_address,ip_address2, ip_address3;


   /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  ospfAreaAggregateEntry_INSTANCE_LEN + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    SNMP_MGR_ReadIpFromCompl(name, oid_name_length,    &ip_address);
    SNMP_MGR_ReadIpFromCompl(name, oid_name_length+5,  &ip_address2);
    SNMP_MGR_ReadIpFromCompl(name, oid_name_length+9,  &ip_address3);
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
         /* In reserve2, we overwrite the set value to ospfAreaAggregateEntry*/
          ospfAreaAggregateEntry.status = *(long *)var_val;
          if ((ospfAreaAggregateEntry.status <VAL_ospfAreaAggregateStatus_active) || (ospfAreaAggregateEntry.status >VAL_ospfAreaAggregateStatus_destroy))
             return SNMP_ERR_WRONGVALUE;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
          /* We perform the row creation here, if the row status = 4(createAndGo),
           * or 5 (createAndWait), we call the SetByEntry API, otherwise, call the
           * set rowstatus API
           */
          switch (ospfAreaAggregateEntry.status)
          {
              case VAL_ospfAreaAggregateStatus_createAndGo:
              case VAL_ospfAreaAggregateStatus_createAndWait:
              case VAL_ospfAreaAggregateStatus_active:
              case VAL_ospfAreaAggregateStatus_notInService:
              case VAL_ospfAreaAggregateStatus_notReady:
              case VAL_ospfAreaAggregateStatus_destroy:
                {
                    UI32_T area_id = ip_address;
                    UI32_T type=name[14];
                    UI32_T range_addr=ip_address2;
                    UI32_T range_mask=ip_address3;
                    UI32_T val = *(int *) var_val;
                    UI32_T ret;
                    ret = OSPF_PMGR_AreaAggregateStatusSet(0,1 ,area_id,type,range_addr,range_mask,val);

                    if(ret == OSPF_TYPE_RESULT_SUCCESS)
                        return SNMP_ERR_NOERROR;
                    else if (ret == OSPF_TYPE_RESULT_INCONSISTENT_VALUE)
                        return SNMP_ERR_INCONSISTENTVALUE;
                    else
                        return SNMP_ERR_COMMITFAILED;

                }
                break;
              default:
            return SNMP_ERR_COMMITFAILED;
          }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_ospfAreaAggregateEffect(int action,
                              u_char * var_val,
                              u_char var_val_type,
                              size_t var_val_len,
                              u_char * statP, oid * name, size_t name_len)
{

    UI32_T oid_name_length = 10;
    UI32_T ip_address,ip_address2, ip_address3;
    UI32_T value=0;

   /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  ospfAreaAggregateEntry_INSTANCE_LEN + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    SNMP_MGR_ReadIpFromCompl(name, oid_name_length,  &ip_address);
    SNMP_MGR_ReadIpFromCompl(name, oid_name_length+5,  &ip_address2);
    SNMP_MGR_ReadIpFromCompl(name, oid_name_length+9,  &ip_address3);
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          /* In reserve2, we overwrite the set value to ospfAreaAggregateEntry*/
          value = *(long *)var_val;
          if ((value <VAL_ospfAreaAggregateEffect_advertiseMatching) || (value >VAL_ospfAreaAggregateEffect_doNotAdvertiseMatching))
             return SNMP_ERR_WRONGVALUE;

            if(VAL_ospfAreaAggregateEffect_advertiseMatching == value)
                SET_FLAG(ospfAreaAggregateEntry.flags, OSPF_AREA_RANGE_ADVERTISE);
            else
                UNSET_FLAG(ospfAreaAggregateEntry.flags, OSPF_AREA_RANGE_ADVERTISE);

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
         /* For row creation, if row_status =0, mean that this is a normal
          * operation, we do the normal set operation, otherwise it is a row
          * creation operation, will do nothing here, and the overall entry
          * will perform in the write_xxxRowStatus function.
          */
        if ( ospfAreaAggregateEntry.status == 0)
        {
                  UI32_T area_id = ip_address;
                  UI32_T type=name[14];
                  UI32_T range_addr=ip_address2;
                  UI32_T range_mask=ip_address3;
                if(OSPF_PMGR_AreaAggregateEffectSet(0,1,area_id,type,range_addr,range_mask,value)!= OSPF_TYPE_RESULT_SUCCESS)
                {
                    return SNMP_ERR_COMMITFAILED;
                }
         }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
#endif
