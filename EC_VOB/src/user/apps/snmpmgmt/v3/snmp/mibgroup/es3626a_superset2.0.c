/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.scalar.conf,v 1.5 2002/07/18 14:18:52 dts12 Exp $
 */

#include <stdio.h>
#include <stdint.h>
#include <arpa/inet.h>

/* SNMP third-party
 */
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

/* system
 */
#include "sys_type.h"
#include "sys_adpt.h"
#include "sys_cpnt.h"
#include "sys_dflt.h"
#include "leaf_sys.h"

#if (SYS_CPNT_3COM_CLI == TRUE)
#include "sys_imghdr.h"
#endif

/* common library
 */
#include "sysfun.h"
#include "l_stdlib.h"
#include "l_snmp.h"
#include "l_charset.h"
#include "l_md5.h"
#include "l_bitmap.h"
#include "l_inet.h"

/* driver
 */
/* Currently, the following bypasses the core layer and calls the driver.
 * If, in the future, UI will be detached from the driver, then
 * this will be removed.
 */
#if (SYS_CPNT_SYSDRV_FAN_FAIL_DETECT == TRUE)
#include "sysdrv.h"
#endif
#if (SYS_CPNT_ALARM_INPUT_DETECT == TRUE)
#include "sysdrv.h"
#endif

#include "fs.h"
#include "fs_type.h"
#include "sys_time.h"

#if (SYS_CPNT_CRAFT_PORT == TRUE) && (SYS_CPNT_CRAFT_PORT_MODE == SYS_CPNT_CRAFT_PORT_MODE_FRONT_PORT_CRAFT_PORT)
#include "swdrv_om.h"
#endif
/* core: layer 2
 */
#include "vlan_lib.h"
#include "vlan_mgr.h"
#include "vlan_pmgr.h"
#include "vlan_pom.h"
#include "amtr_pmgr.h"
#include "amtr_om.h"
#include "nmtr_pmgr.h"
#include "swctrl_pom.h"
#include "swctrl_pmgr.h"
#include "swctrl.h"
#include "trk_pmgr.h"
#include "lacp_pmgr.h"
#include "lacp_pom.h"
#if (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_RSTP) || (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_MSTP)
  #include "xstp_pmgr.h"
  #include "xstp_pom.h"
#else
  #include "sta_mgr.h"
#endif

#if (SYS_CPNT_EFM_OAM == TRUE)
    #include "oam_type.h"
    #include "oam_pom.h"
    #include "oam_pmgr.h"
#endif  /* end of #if (SYS_CPNT_EFM_OAM == TRUE) */

#if (SYS_CPNT_MLDSNP == TRUE)
    #include "mldsnp_type.h"
    #include "mldsnp_pom.h"
    #include "mldsnp_pmgr.h"
#endif  /* end of #if (SYS_CPNT_MLDSNP == TRUE) */

#if (SYS_CPNT_RSPAN == TRUE)
#include "rspan_pmgr.h"
#endif  /* #if (SYS_CPNT_RSPAN == TRUE) */

#if (SYS_CPNT_PPPOE_IA == TRUE)
#include "pppoe_ia_pmgr.h"
#include "pppoe_ia_type.h"
#endif  /* #if (SYS_CPNT_PPPOE_IA == TRUE) */

#if (SYS_CPNT_CN == TRUE)
#include "cn_pmgr.h"
#include "cn_pom.h"
#include "cn_type.h"
#endif

#if (SYS_CPNT_DCBX == TRUE)
#include "dcbx_pmgr.h"
#include "dcbx_type.h"
#endif

/* core: layer 3
 */
#include "netcfg_type.h"
#include "netcfg_pom_ip.h"
#include "netcfg_pmgr_ip.h"
#include "netcfg_pmgr_route.h"
#include "netcfg_pmgr_nd.h"
#include "ip_lib.h"
#include "ping_pom.h"
#include "ping_pmgr.h"

#if 0  /* was: (SYS_CPNT_HSRP == TRUE) */
#include "Hsrp_mgr.h"       /* naming problem */
#include "hsrp_sys_adpt.h"  /* naming problem */
#endif

#if (SYS_CPNT_IP_TUNNEL == TRUE)
#include "netcfg_pmgr_nd.h"
#include "netcfg_pom_nd.h"
#include "netcfg_pmgr_ip.h"
#include "netcfg_pom_ip.h"
#endif  /* #if (SYS_CPNT_IP_TUNNEL == TRUE) */

#if (SYS_CPNT_VXLAN == TRUE)
#include "vxlan_pmgr.h"
#include "vxlan_pom.h"
#include "vxlan_type.h"
#endif  /* #if (SYS_CPNT_VXLAN == TRUE) */

/* core: QoS
 */
#if (SYS_CPNT_COS == TRUE)
  #include "l4_pmgr.h"
  #include "cos_vm.h"
#endif

#if (SYS_CPNT_QOS == SYS_CPNT_QOS_MARKER)
  #include "l4_marker_mgr.h"
#endif

#if (SYS_CPNT_PFU == TRUE)
 #include "pfu_mgr.h"
 #include "pfu_type.h"
#endif

#if (SYS_CPNT_ACL == TRUE)
 #if(SYS_CPNT_QOS_V2 == TRUE)
  #include "l4_pmgr.h"
 #else
  #include "l4_acl_mgr.h"
 #endif
#endif

#if ((SYS_CPNT_QOS == SYS_CPNT_QOS_DIFFSERV) && (SYS_CPNT_QOS_V2 != TRUE))
#include "l4_ds_mgr.h"
#endif

#if (SYS_CPNT_QOS_V2 == TRUE)
#include "l4_pmgr.h"
#include "rule_type.h"
#include "pri_mgr.h"
#include "pri_pmgr.h"
#endif

#if (SYS_CPNT_ROUTING == TRUE)
#include "nsm_pmgr.h"
#endif /* SYS_CPNT_ROUTING */

/* core: security
 */
#if (SYS_CPNT_DOT1X == TRUE)
  #include "1x_pmgr.h"
  #include "1x_pom.h"
#endif

#if (SYS_CPNT_PORT_SECURITY == TRUE)
#include "psec_pmgr.h"
#endif

#if (SYS_CPNT_RADIUS == TRUE)
 #include "radius_pmgr.h"
 #include "radius_pom.h"
#endif /* #if (SYS_CPNT_RADIUS == TRUE) */

#if (SYS_CPNT_TACACS == TRUE)
 #include "tacacs_pmgr.h"
 #include "tacacs_pom.h"
#endif /* #if (SYS_CPNT_TACACS == TRUE) */

#if (SYS_CPNT_ACCOUNTING == TRUE)
 #include "aaa_pmgr.h"
 #include "aaa_pom.h"
#endif

#if (SYS_CPNT_SSHD == TRUE || SYS_CPNT_SSH2 == TRUE)
 #include "sshd_pmgr.h"
 #include "cli_task.h"

#if (SYS_CPNT_SSH2 == TRUE)
 #include "keygen_pmgr.h"
#endif
#endif

#if (SYS_CPNT_MGMT_IP_FLT == TRUE)
#include "mgmt_ip_flt.h"
#endif

#if (SYS_CPNT_NETACCESS == TRUE)
#include "netaccess_pmgr.h"
#include "netaccess_type.h"
#endif

#include "userauth.h"
#include "userauth_pmgr.h"

#if (SYS_CPNT_WEBAUTH == TRUE)
#include "webauth_pmgr.h"
#include "webauth_type.h"
#endif  /* #if (SYS_CPNT_WEBAUTH == TRUE) */

#if (SYS_CPNT_DOS == TRUE)
#include "dos_pmgr.h"
#endif

/* core: management
 */
#include "stktplg_pmgr.h"
#include "stktplg_pom.h"
#include "stkctrl_task.h"
#include "stkctrl_pmgr.h"
#include "sys_mgr.h"
#include "sys_pmgr.h"
#include "telnet_pmgr.h"
#include "telnet_pom.h"

#if (SYS_CPNT_DBSYNC_TXT == TRUE)
        #include "dbsync_txt_mgr.h"
#endif

#include  "xfer_pmgr.h"

#if (SYS_CPNT_HTTPS == TRUE)
 #include "http_type.h"
#endif

#include "http_mgr.h"
#include "http_pmgr.h"

#if (SYS_CPNT_DHCP == TRUE)
#include "dhcp_pmgr.h"
#include "dhcp_type.h"
#endif

#if (SYS_CPNT_SMTP == TRUE)
#include "smtp_pmgr.h"
#endif

#if (SYS_CPNT_SYSLOG == TRUE)
 #include "syslog_pmgr.h"
 #include "syslog_pom.h"
 #include "syslog_type.h"
 #include "syslog_mgr.h"
#endif

#if (SYS_CPNT_SNTP == TRUE)
 #include "sntp_pmgr.h"
#endif

#if (SYS_CPNT_NTP == TRUE)
 #include "ntp_pmgr.h"
#endif

#if (SYS_CPNT_DNS == TRUE)
#include "dns_pmgr.h"
#include "dns_pom.h"
#include "l_inet.h"
#endif

#if (SYS_CPNT_POE == TRUE)
#include "poe_pmgr.h"
#endif

#if (SYS_CPNT_CLUSTER == TRUE)
#include "cluster_pmgr.h"
#include "cluster_pom.h"
#endif

#if (SYS_CPNT_DHCPSNP == TRUE)
    #include "dhcpsnp_pmgr.h"
    #include "dhcpsnp_type.h"
#endif

#if (SYS_CPNT_IP_SOURCE_GUARD == TRUE)
#include "ipsg_pmgr.h"
#include "ipsg_pom.h"
#endif

#if (SYS_CPNT_ADD == TRUE)
    #include "add_pmgr.h"
#endif

#if (SYS_CPNT_DAI == TRUE)
#include "dai_pmgr.h"
#endif  /*#if (SYS_CPNT_DAI == TRUE)*/

#if (SYS_CPNT_TIME_RANGE == TRUE)
#include "time_range_pmgr.h"
#endif  /* #if (SYS_CPNT_TIME_RANGE == TRUE) */

#if (SYS_CPNT_POE == TRUE)
#include "poe_pmgr.h"
#include "poe_pom.h"
#endif  /*#if (SYS_CPNT_POE == TRUE) */

#if (SYS_CPNT_DHCPV6SNP == TRUE)
#include "dhcpv6snp_pom.h"
#include "dhcpv6snp_pmgr.h"
#endif

#if (SYS_CPNT_DHCP_RELAY_OPTION82 == TRUE)
#include "dhcp_pom.h"
#include "dhcp_om.h"
#include "dhcp_pmgr.h"
#endif

#if (SYS_CPNT_UDP_HELPER == TRUE)
#include "udphelper_pmgr.h"
#endif

#if (SYS_CPNT_IPV6_SOURCE_GUARD == TRUE)
#include "ip6sg_pmgr.h"
#include "ip6sg_pom.h"
#endif

#if (SYS_CPNT_APP_FILTER == TRUE)
#include "af_type.h"
#include "af_pmgr.h"
#endif /* #if (SYS_CPNT_APP_FILTER == TRUE) */

/* App
 */
#include "cli_pmgr.h"

/* SNMP itself
 */
#include "snmp_type.h"
#include "snmp_mgr.h"
#include "es3626a_superset.h"
#include "rfc_2674q.h"

#if (SYS_CPNT_MGMT_IP_FLT == TRUE)
/* used for ipFilterAllClientCtl
 */
static UI32_T ip_filter_all_client_ctl_type = 0;
static MGMT_IP_FLT_IpFilter_T ip_filter_all_client_ctl_entry;
#endif

#if (SYS_CPNT_SNTP == TRUE)
/* used for sntpServerTable
 */
static UI32_T sntp_server_inet_address_type = 0;
#endif

static char   *invalid_char_in_desc ="\"?!";
static char   *invalid_char_in_name ="\"?! ";

#ifndef _countof
#define _countof(_Ary)  (sizeof(_Ary) / sizeof(*_Ary))
#endif

/********************************************
 *********   init_switchMgt******************
 ********************************************
 */
int
do_switchManagementVlan(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode)
     {



        case MODE_GET:
           {
                UI32_T switchManagementVlan;
                UI32_T vid;

                VLAN_POM_GetManagementVlan(&switchManagementVlan);
                VLAN_IFINDEX_CONVERTTO_VID(switchManagementVlan, vid);
                long_return = vid;
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
            }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:

            break;

        case MODE_SET_RESERVE2:

            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
       {
            UI32_T switchManagementVlan;
            UI32_T vid;
            vid = *requests->requestvb->val.integer;

             VLAN_VID_CONVERTTO_IFINDEX(vid, switchManagementVlan);
             if (VLAN_PMGR_SetManagementVlan( switchManagementVlan)!= TRUE)
                 netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);

         }
          break;

        case MODE_SET_COMMIT:

            break;

        case MODE_SET_UNDO:

            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
get_swProdName(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
            if (SYS_PMGR_GetProductName(SYS_VAL_LOCAL_UNIT_ID, return_buf)!=TRUE)
            {
                return SNMP_ERR_GENERR;
            }
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, (u_char *) return_buf, strlen((char *)return_buf));
            break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
get_swProdUrl(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
        {
            UI8_T  buffer[MAXSIZE_swProdVersion+1];
            UI8_T ip[4] ={0};
            NETCFG_TYPE_InetRifConfig_T  data;
            #define HTTP "Http://%d.%d.%d.%d"

            memset(&data, 0 , sizeof(data));
            if (NETCFG_POM_IP_GetNextRifConfig(&data) == -1)
            {
                memset(data.addr.addr, 0, SYS_ADPT_IPV4_ADDR_LEN); /* memcpy(data.ip_addr, 0, 4); */ /* if get ip address fail, default ip= 0.0.0.0*/
            }
            memcpy(ip, data.addr.addr, 4);
            sprintf((char *)buffer, HTTP, ip[0], ip[1], ip[2], ip[3]);

            strcpy((char *)return_buf, (char *)buffer);

            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, (u_char *)return_buf, strlen((char *)return_buf));
        }
            break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
get_swProdDescription(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
            if (SYS_PMGR_GetProductDescription((char *)return_buf) == TRUE)
            {
                snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, (u_char *) return_buf, strlen((char *)return_buf));
                break;
            }


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
get_swProdVersion(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
        {

        STKTPLG_MGR_Switch_Info_T data;
        UI8_T buffer[SYS_ADPT_FW_VER_STR_LEN+1];
#if (SYS_CPNT_3COM_CLI == TRUE)
        UI32_T version;
        UI32_T version1=0,version2=0,version3=0,version4=0;
#endif

        memset(&data, 0, sizeof(data));
        data.sw_unit_index =1;
        STKTPLG_PMGR_GetSwitchInfo(&data);

        strncpy((char *)buffer, (char *)data.sw_opcode_ver, SYS_ADPT_FW_VER_STR_LEN+1);
        buffer[SYS_ADPT_FW_VER_STR_LEN]=0;

        /*using 3COM cli sys_cpnt to seperate 3com style opcode ver*/
#if (SYS_CPNT_3COM_CLI == TRUE)
        sscanf(buffer,"%lu.%lu.%lu.%lu",&version1,&version2,&version3,&version4);

        version = (version1 << 24 | version2 << 16 | version3 << 8 | version4);

        CLI_MGR_GetVersionNumberDisplayString(version, IMGHDR_IMAGE_RUNTIMETYPE, buffer);
#endif /*end of #if (SYS_CPNT_3COM_CLI == TRUE)*/


        /* 06-03-2002 check with Qyiao, swProdVersion is identical to sw_opcode_ver*/
        strcpy((char *)return_buf, (char *)buffer);
        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, (u_char *) return_buf, strlen((char *)return_buf));
         }
            break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_amtrMacAddrAgingStatus(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode)
     {

        case MODE_GET:
           {
               UI32_T amtrMacAddrAgingStatus;

                if (AMTR_PMGR_GetAgingStatus(&amtrMacAddrAgingStatus)!= TRUE)
                {
                    return SNMP_ERR_GENERR;
                }
                   long_return = amtrMacAddrAgingStatus;
                  snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
            }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
            }
            break;

        case MODE_SET_RESERVE2:
            switch (*requests->requestvb->val.integer)
            {
                case VAL_amtrMacAddrAgingStatus_enabled:
                    break;

                case VAL_amtrMacAddrAgingStatus_disabled:
                    break;

                default:
                    netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
       {
            UI32_T amtrMacAddrAgingStatus;

            amtrMacAddrAgingStatus = *requests->requestvb->val.integer;


         if (AMTR_PMGR_SetAgingStatus( amtrMacAddrAgingStatus)!= TRUE)
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);

         }
          break;

        case MODE_SET_COMMIT:

            break;

        case MODE_SET_UNDO:

            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_swChassisServiceTag(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
        {
              STKTPLG_MGR_Switch_Info_T data;


        memset(&data, 0 , sizeof(data));
        data.sw_unit_index = 1;
        if (STKTPLG_PMGR_GetSwitchInfo(&data) != TRUE)
             return SNMP_ERR_NOERROR;

        strncpy((char *)return_buf, (char *)data.sw_chassis_service_tag, SYS_ADPT_SERIAL_NO_STR_LEN+1);
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, (u_char *) return_buf, strlen((char *)return_buf));
        }
            break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_switchOperState(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
           {

                UI8_T switchOperState;
        /* Values:
         *  other(1)          = VAL_switchOperState_other
         *  unknown(2)        = VAL_switchOperState_unknown
         *  ok(3)             = VAL_switchOperState_ok
         *  noncritical(4)    = VAL_switchOperState_noncritical
         *  critical(5)       = VAL_switchOperState_critical
         *  nonrecoverable(6) = VAL_switchOperState_nonrecoverable
         */

        if (STKTPLG_POM_GetSwitchOperState(&switchOperState) != TRUE)
           return SNMP_ERR_GENERR;

            long_return = switchOperState;
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *)&long_return, sizeof(long_return));
            }
            break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

#if 0
int
do_amtrMacAddrRisingThreshold(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) /* XXX: a pointer to the scalar's data */, /* XXX: the length of the data in bytes */);
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            if (/* XXX: check incoming data in requests->requestvb->val.XXX for failures, like an incorrect type or an illegal value or ... */) {
                netsnmp_set_request_error(reqinfo, requests, /* XXX: set error code depending on problem (like SNMP_ERR_WRONGTYPE or SNMP_ERR_WRONGVALUE or ... */);
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            if (/* XXX if malloc, or whatever, failed: */) {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCESUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
            if (/* XXX: error? */) {
                netsnmp_set_request_error(reqinfo, requests, /* some error */);
            }
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            if (/* XXX: error? */) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            if (/* XXX: error? */) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
do_amtrMacAddrFallingThreshold(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) /* XXX: a pointer to the scalar's data */, /* XXX: the length of the data in bytes */);
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            if (/* XXX: check incoming data in requests->requestvb->val.XXX for failures, like an incorrect type or an illegal value or ... */) {
                netsnmp_set_request_error(reqinfo, requests, /* XXX: set error code depending on problem (like SNMP_ERR_WRONGTYPE or SNMP_ERR_WRONGVALUE or ... */);
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            if (/* XXX if malloc, or whatever, failed: */) {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCESUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
            if (/* XXX: error? */) {
                netsnmp_set_request_error(reqinfo, requests, /* some error */);
            }
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            if (/* XXX: error? */) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            if (/* XXX: error? */) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

#endif


int
get_switchNumber(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
        {
              UI32_T switchNumber;
             if (STKTPLG_POM_GetNumberOfUnit(&switchNumber)!= TRUE)
                 return SNMP_ERR_GENERR;

             long_return = switchNumber;
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *)&long_return, sizeof(long_return));
          }
            break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
get_swProdManufacturer(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:

            if (SYS_PMGR_GetProductManufacturer((char *)return_buf) == TRUE)
            {
                snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, (u_char *) return_buf, strlen((char *)return_buf));
                break;
            }


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}



int
get_swIdentifier(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
        {
          STKTPLG_MGR_Switch_Info_T  data;

          memset(&data, 0 , sizeof(data));
           data.sw_unit_index = 1;

       if (STKTPLG_PMGR_GetSwitchInfo(&data) != TRUE)
          return SNMP_ERR_GENERR;

       long_return=data.sw_identifier;
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *)&long_return, sizeof(long_return));
         }
            break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

#if (SYS_CPNT_JUMBO_FRAMES == TRUE)
int
do_switchJumboFrameStatus(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
        {
            UI32_T switchJumboFrameStatus;

            /* Values:
             *  enabled(1)  = VAL_switchJumboFrameStatus_enabled
             *  disabled(2) = VAL_switchJumboFrameStatus_disabled
             */
            if (SWCTRL_POM_GetJumboFrameStatus(&switchJumboFrameStatus) != TRUE)
                return SNMP_ERR_GENERR;
            switch(switchJumboFrameStatus)
            {
            case SWCTRL_JUMBO_FRAME_DISABLE:
                long_return= VAL_switchJumboFrameStatus_disabled;
                break;
            case SWCTRL_JUMBO_FRAME_ENABLE:
                long_return = VAL_switchJumboFrameStatus_enabled;
                break;
            }
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *)&long_return, sizeof(long_return));
        }
        break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
            }
            break;

        case MODE_SET_RESERVE2:
            switch (*requests->requestvb->val.integer)
            {
                case VAL_switchJumboFrameStatus_enabled:
                    break;

                case VAL_switchJumboFrameStatus_disabled:
                    break;

                default:
                    netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
        {
            UI32_T switchJumboFrameStatus;
            switchJumboFrameStatus = *requests->requestvb->val.integer;

            switch(switchJumboFrameStatus)
            {
            case VAL_switchJumboFrameStatus_enabled:
                switchJumboFrameStatus = SWCTRL_JUMBO_FRAME_ENABLE;
                break;
            case VAL_switchJumboFrameStatus_disabled:
                switchJumboFrameStatus = SWCTRL_JUMBO_FRAME_DISABLE;
                break;
            }

            if (SWCTRL_PMGR_SetJumboFrameStatus(switchJumboFrameStatus)!= TRUE)
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);

       }
            break;

        case MODE_SET_COMMIT:

            break;

        case MODE_SET_UNDO:

            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
#endif

#if (SYS_CPNT_3COM_LOOPBACK_TEST == TRUE)
int
get_switchLoopbackTestFailurePorts(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
        {
            UI32_T buffer_size;
            UI8_T buffer[SYS_ADPT_NBR_OF_BYTE_FOR_1BIT_UPORT_LIST * SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK];

            buffer_size =SYS_ADPT_NBR_OF_BYTE_FOR_1BIT_UPORT_LIST * SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK;
            if (buffer_size > 255)
            {
                return SNMP_ERR_GENERR;
            }
            if (SWCTRL_POM_GetSwitchLoopbackTestFailurePorts(buffer)!=TRUE)
            {
                return SNMP_ERR_GENERR;
            }
            memcpy( return_buf, buffer, SYS_ADPT_NBR_OF_BYTE_FOR_1BIT_UPORT_LIST * SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK);

            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, (u_char *) return_buf, buffer_size);
         }
            break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
#endif /* end of #if (SYS_CPNT_3COM_LOOPBACK_TEST == TRUE)  */


/********************************************
 *********   switchInfoTable****************
 ********************************************
 */
/*
 * header_switchInfoTable(...
 * Arguments:
 * vp     IN      - pointer to variable entry that points here
 * name    IN/OUT  - IN/name requested, OUT/name found
 * length  IN/OUT  - length of IN/OUT oid's
 * exact   IN      - TRUE if an exact match was requested
 * var_len OUT     - length of variable or 0 if function returned
 * write_method
 *
 */

static int
header_switchInfoTable(struct variable *vp,
               oid * name,
               size_t * length,
               int exact, size_t * var_len, WriteMethod ** write_method)
{
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
    oid             newname[MAX_OID_LEN];
    int    interface;
    int             result;
   STKTPLG_MGR_Switch_Info_T  entry;
   int ifIndex = 0;
   BOOL_T return_val;


    memcpy((char *) newname, (char *) vp->name,
           (int) vp->namelen * sizeof(oid));
    /*
     * find "next" interface
     */

       entry.sw_unit_index = ifIndex;
     while (  (return_val= STKTPLG_PMGR_GetNextSwitchInfo( &entry))==TRUE)
     {

        ifIndex = entry.sw_unit_index;
        newname[oid_name_length] = (oid) ifIndex;
        result =
            snmp_oid_compare(name, *length, newname,
                             (int) vp->namelen + 1);
        if ((exact && (result == 0)) || (!exact && (result < 0)))
            break;
    }
    if (!return_val ) {

        return MATCH_FAILED;
    }


    memcpy((char *) name, (char *) newname,
           ((int) vp->namelen + 1) * sizeof(oid));
    *length = vp->namelen + 1;
    *write_method = 0;
    *var_len = sizeof(long);    /* default to 'long' results */
    interface = newname[oid_name_length];



    return interface;
}


/*
 * var_switchInfoTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *
var_switchInfoTable(struct variable *vp,
            oid     *name,
            size_t  *length,
            int     exact,
            size_t  *var_len,
            WriteMethod **write_method)
{
   STKTPLG_MGR_Switch_Info_T  entry;
    int             interface;



   memset( &entry, 0, sizeof(entry));
    interface =
        header_switchInfoTable(vp, name, length, exact, var_len, write_method);
    if (interface == MATCH_FAILED)
        return NULL;


  entry.sw_unit_index =interface;

   if (STKTPLG_PMGR_GetSwitchInfo( &entry)!= TRUE)
            return NULL;

    /*
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic)
     {
    case SWUNITINDEX:
       long_return = entry.sw_unit_index;
        return (u_char*) &long_return;
    case SWHARDWAREVER:
         strcpy((char *)return_buf, (char *)entry.sw_hardware_ver);
       *var_len = strlen((char *)return_buf);
        return (u_char*) return_buf;
    case SWMICROCODEVER:
          strcpy((char *)return_buf, (char *)entry.sw_microcode_ver);
       *var_len = strlen((char *)return_buf);
        return (u_char*) return_buf;
   case SWLOADERVER:
    {
#if (SYS_CPNT_3COM_CLI == TRUE)
        UI32_T version = 0;
        UI32_T version1 = 0, version2 = 0, version3 = 0, version4 = 0;
#endif
        UI8_T buffer[SYS_ADPT_FW_VER_STR_LEN + 1];

        strncpy((char *)buffer, (char *)entry.sw_loader_ver, SYS_ADPT_FW_VER_STR_LEN + 1);
        buffer[SYS_ADPT_FW_VER_STR_LEN] = 0;

#if (SYS_CPNT_3COM_CLI == TRUE)
        sscanf((char *)buffer, "%lu.%lu.%lu.%lu", &version1, &version2, &version3, &version4);
        version = (version1 << 24 | version2 << 16 | version3 << 8 | version4);
        CLI_MGR_GetVersionNumberDisplayString(version, IMGHDR_IMAGE_LOADERTYPE, buffer);
#endif /*end of #if (SYS_CPNT_3COM_CLI == TRUE)*/
        strcpy((char *)return_buf, (char *)buffer);
       *var_len = strlen((char *)return_buf);
        return (u_char*) return_buf;
    }

    case SWBOOTROMVER:
    {
#if (SYS_CPNT_3COM_CLI == TRUE)
        UI32_T version = 0;
        UI32_T version1 = 0, version2 = 0, version3 = 0, version4 = 0;
#endif
        UI8_T buffer[SYS_ADPT_FW_VER_STR_LEN+1];

        strncpy((char *)buffer, (char *)entry.sw_boot_rom_ver, SYS_ADPT_FW_VER_STR_LEN + 1);
        buffer[SYS_ADPT_FW_VER_STR_LEN] = 0;

#if (SYS_CPNT_3COM_CLI == TRUE)
        sscanf((char *)buffer, "%lu.%lu.%lu.%lu", &version1, &version2, &version3, &version4);
        version = (version1 << 24 | version2 << 16 | version3 << 8 | version4);
        CLI_MGR_GetVersionNumberDisplayString(version, IMGHDR_IMAGE_DIAGNOSTICTYPE, buffer);
#endif /*end of #if (SYS_CPNT_3COM_CLI == TRUE)*/
        strcpy((char *)return_buf, (char *)buffer);
       *var_len = strlen((char *)return_buf);
        return (u_char*) return_buf;
    }

    case SWOPCODEVER:
    {
#if (SYS_CPNT_3COM_CLI == TRUE)
        UI32_T version = 0;
        UI32_T version1=0,version2=0,version3=0,version4=0;
#endif
        UI8_T buffer[SYS_ADPT_FW_VER_STR_LEN+1];

        strncpy((char *)buffer, (char *)entry.sw_opcode_ver, SYS_ADPT_FW_VER_STR_LEN+1);
        buffer[SYS_ADPT_FW_VER_STR_LEN] = 0;

#if (SYS_CPNT_3COM_CLI == TRUE)
        sscanf((char *)buffer,"%lu.%lu.%lu.%lu",&version1,&version2,&version3,&version4);

        version = (version1 << 24 | version2 << 16 | version3 << 8 | version4);

        CLI_MGR_GetVersionNumberDisplayString(version, IMGHDR_IMAGE_RUNTIMETYPE, buffer);

#endif /*end of #if (SYS_CPNT_3COM_CLI == TRUE)*/
        strcpy((char *)return_buf, (char *)buffer);
       *var_len = strlen((char *)return_buf);
        return (u_char*) return_buf;
    }
    case SWPORTNUMBER:
         long_return = entry.sw_port_number;
        return (u_char*) &long_return;
    case SWPOWERSTATUS:
    {
         SYS_MGR_PowerStatus_T powerData;
         powerData.sw_unit_index=entry.sw_unit_index;
         if (!SYS_PMGR_GetPowerStatus(&powerData))
         {
             long_return = 0;
         }
         else
         {
             long_return = powerData.sw_power_status;
         }
         return (u_char*) &long_return;
    }
    case SWROLEINSYSTEM:
       long_return = entry.sw_role_in_system;
        return (u_char*) &long_return;
    case SWSERIALNUMBER:
        memcpy(return_buf, entry.sw_serial_number, SYS_ADPT_SERIAL_NO_STR_LEN+1);
        *var_len = strlen((char *)return_buf);
        return (u_char*) return_buf;
    case SWEXPANSIONSLOT1:
         long_return = entry.sw_expansion_slot1;
        return (u_char*) &long_return;
    case SWEXPANSIONSLOT2:
         long_return = entry.sw_expansion_slot2;
        return (u_char*) &long_return;
    case SWSERVICETAG:
          memcpy( return_buf, entry.sw_service_tag, SYS_ADPT_SERIAL_NO_STR_LEN+1);
       *var_len = strlen((char *)return_buf);
        return (u_char*) return_buf;
    case SWMODELNUMBER:
       memcpy( return_buf, entry.sw_model_number, MAXSIZE_swModelNumber+1);
       *var_len = strlen((char *)return_buf);
        return (u_char*) return_buf;
    case SWEPLDVER:
        strcpy((char *)return_buf, (char *)entry.sw_epld_ver);
       *var_len = strlen((char *)entry.sw_epld_ver);
        return (u_char*) return_buf;

#if (SYS_CPNT_MODULE_WITH_CPU == TRUE)
    case SWEXPECTEDMODULEOPCODEVER:
    {
        UI32_T version = 0;
#if (SYS_CPNT_3COM_CLI == TRUE)
        UI32_T version1=0,version2=0,version3=0,version4=0;
#endif
        UI8_T buffer[SYS_ADPT_FW_VER_STR_LEN+1];

        strncpy( buffer, entry.sw_module_expected_opcode_ver, SYS_ADPT_FW_VER_STR_LEN+1);
        buffer[SYS_ADPT_FW_VER_STR_LEN] = 0;

#if (SYS_CPNT_3COM_CLI == TRUE)
        sscanf(buffer,"%lu.%lu.%lu.%lu",&version1,&version2,&version3,&version4);

        version = (version1 << 24 | version2 << 16 | version3 << 8 | version4);

        CLI_MGR_GetVersionNumberDisplayString(version, IMGHDR_IMAGE_RUNTIMETYPE, buffer);

#endif /*end of #if (SYS_CPNT_3COM_CLI == TRUE)*/
        strcpy( return_buf, buffer);
       *var_len = strlen(return_buf);
        return (u_char*) return_buf;
    }
#endif
    default:
      ERROR_MSG("");
    }
    return NULL;
}

/********************************************
 ********* switchIndivPowerTable********
 ********************************************
     */
static int
header_switchIndivPowerTable(struct variable *vp,
               oid * name,
               size_t * length,
               int exact, size_t * var_len, WriteMethod ** write_method,
               UI32_T *index1, UI32_T *index2)
{
    UI32_T          oid_name_len;
    oid             newname[MAX_OID_LEN];
    int             result;
   SYS_MGR_IndivPower_T  entry;
   BOOL_T return_val;
   oid  next_inst[2];

     oid_name_len = SNMP_MGR_Get_PrivateMibRootLen() + 5;

     memcpy((char *) newname, (char *) vp->name,
           (int) vp->namelen * sizeof(oid));
    /*
     * find "next" interface
     */
    memset(  &entry, 0 , sizeof(entry));

    /*
     * find "next" interface
     */

  while (  (return_val= SYS_PMGR_GetNextSwitchIndivPower( &entry))==TRUE)
     {
       next_inst[0] =entry.sw_indiv_power_unit_index;
       next_inst[1] = entry.sw_indiv_power_index;


        memcpy( (char*)&newname[oid_name_len], (char*) next_inst,  2*sizeof(oid));
        result =
            snmp_oid_compare(name, *length, newname,
                             (int) vp->namelen +2);
        if ((exact && (result == 0)) || (!exact && (result < 0)))
            break;
    }
    if (!return_val ) {
        return MATCH_FAILED;
    }
    memcpy((char *) name, (char *) newname,
           ((int) vp->namelen + 2) * sizeof(oid));
    *length = vp->namelen + 2;
    *var_len = sizeof(long);    /* default to 'long' results */
    *index1 = next_inst[0];
    *index2 = next_inst[1];
    return TRUE;

}

/*
 * var_switchIndivPowerTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_switchIndivPowerTable(struct variable *vp,
                          oid * name,
                          size_t * length,
                          int exact,
                          size_t * var_len, WriteMethod ** write_method)
{
    /* variables we may use later */

    UI32_T index1 = 0, index2 = 0, retval;

    SYS_MGR_IndivPower_T   entry;

    memset( &entry, 0, sizeof(entry));

     retval  = header_switchIndivPowerTable(vp, name, length, exact, var_len, write_method,  &index1,& index2);

    if (retval == MATCH_FAILED)
        return NULL;

    entry.sw_indiv_power_unit_index= index1;
    entry.sw_indiv_power_index = index2;

   if (SYS_PMGR_GetSwitchIndivPower(&entry)!= TRUE)
            return NULL;

    /*
     * * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
     #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
      case SWINDIVPOWERUNITINDEX:
        long_return=entry.sw_indiv_power_unit_index;
        return (u_char*) &long_return;
      case SWINDIVPOWERINDEX:
       long_return=entry.sw_indiv_power_index;
        return (u_char*) &long_return;
     #endif
      case SWINDIVPOWERSTATUS:
        long_return=entry.sw_indiv_power_status;
        return (u_char*) &long_return;
    default:
        ERROR_MSG("");
    }
    return NULL;
}

#if (SYS_CPNT_STKTPLG_FAN_DETECT == TRUE)
/********************************************
 ***********switchFanTable*******************
 ********************************************
 */
static int
header_switchFanTable(struct variable *vp,
               oid * name,
               size_t * length,
               int exact, size_t * var_len, WriteMethod ** write_method,
               UI32_T *index1, UI32_T *index2)
{
    UI32_T          oid_name_len;
    oid             newname[MAX_OID_LEN];
    int             result;
   SYS_MGR_SwitchFanEntry_T  entry;
   BOOL_T return_val;
   oid  next_inst[2];

     oid_name_len = SNMP_MGR_Get_PrivateMibRootLen() + 5;

     memcpy((char *) newname, (char *) vp->name,
           (int) vp->namelen * sizeof(oid));
    /*
     * find "next" interface
     */
    memset(  &entry, 0 , sizeof(entry));

    /*
     * find "next" interface
     */

  while (  (return_val= SYS_PMGR_GetNextFanStatus( &entry))==TRUE)
     {
       next_inst[0] =entry.switch_unit_index;
       next_inst[1] = entry.switch_fan_index;


        memcpy( (char*)&newname[oid_name_len], (char*) next_inst,  2*sizeof(oid));
        result =
            snmp_oid_compare(name, *length, newname,
                             (int) vp->namelen +2);
        if ((exact && (result == 0)) || (!exact && (result < 0)))
            break;
    }
    if (!return_val ) {
        return MATCH_FAILED;
    }
    memcpy((char *) name, (char *) newname,
           ((int) vp->namelen + 2) * sizeof(oid));
    *length = vp->namelen + 2;
    *var_len = sizeof(long);    /* default to 'long' results */
    *index1 = next_inst[0];
    *index2 = next_inst[1];
    return TRUE;

}



/*
 * var_switchFanTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_switchFanTable(struct variable *vp,
                   oid * name,
                   size_t * length,
                   int exact,
                   size_t * var_len, WriteMethod ** write_method)
{
    /* variables we may use later */

    UI32_T index1=0, index2=0, retval;

    SYS_MGR_SwitchFanEntry_T   entry;

    memset( &entry, 0, sizeof(entry));

     retval  = header_switchFanTable(vp, name, length, exact, var_len, write_method,  &index1,& index2);

    if (retval == MATCH_FAILED)
        return NULL;

    entry.switch_unit_index= index1;
    entry.switch_fan_index = index2;

   if (SYS_PMGR_GetFanStatus(&entry)!= TRUE)
            return NULL;

    /*
     * * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
   #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
      case SWITCHUNITINDEX:
        long_return=index1;
        return (u_char*) &long_return;
      case SWITCHFANINDEX:
       long_return=index2;
        return (u_char*) &long_return;
   #endif
      case SWITCHFANSTATUS:
        long_return=entry.switch_fan_status;
        return (u_char*) &long_return;

#if 0 /* not allow user to set and failure count is not support now */
      case SWITCHFANADMINSPEED:
        *write_method = write_switchFanAdminSpeed;
        long_return=entry.switch_fan_speed;
        return (u_char*) &long_return;
      case SWITCHFANFAILURECOUNT:
        long_return=entry.switch_fan_fail_counter;
        return (u_char*) &long_return;
#endif /* #if 0 */

      case SWITCHFANOPERSPEED:
        long_return=entry.switch_fan_oper_speed;
        return (u_char*) &long_return;
    default:
        ERROR_MSG("");
    }
    return NULL;
}

#if 0 /* not allow user to set and failure count is not support now */
int
write_switchFanAdminSpeed(int action,
                     u_char * var_val,
                     u_char var_val_type,
                     size_t var_val_len,
                     u_char * statP, oid * name, size_t name_len)
{
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
   /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  2 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
        {
             SYS_MGR_SwitchFanEntry_T entry;
             long value;

             value = * (long *) var_val;
             entry.switch_unit_index=name[oid_name_length];
             entry.switch_fan_index=name[oid_name_length+1];
             entry.switch_fan_speed = value;


             if (SYS_PMGR_SetFanSpeed(&entry)!= TRUE)
             {
              return SNMP_ERR_COMMITFAILED;
             }
        }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
#endif /* #if 0 */
#endif


#if (SYS_CPNT_THERMAL_DETECT == TRUE)

/********************************************
 ***********switchThermalTempTable***********
 ********************************************
 */
static int
header_switchThermalTempTable(struct variable *vp,
               oid * name,
               size_t * length,
               int exact, size_t * var_len, WriteMethod ** write_method,
               UI32_T *index1, UI32_T *index2)
{
    UI32_T          oid_name_len;
    oid             newname[MAX_OID_LEN];
    int             result;
   SYS_MGR_SwitchThermalEntry_T  entry;
   BOOL_T return_val;
   oid  next_inst[2];

     oid_name_len = SNMP_MGR_Get_PrivateMibRootLen() + 5;

     memcpy((char *) newname, (char *) vp->name,
           (int) vp->namelen * sizeof(oid));
    /*
     * find "next" interface
     */
    memset(  &entry, 0 , sizeof(entry));

    /*
     * find "next" interface
     */

  while (  (return_val= SYS_PMGR_GetNextThermalStatus( &entry))==TRUE)
     {
       next_inst[0] =entry.switch_unit_index;
       next_inst[1] = entry.switch_thermal_index;


        memcpy( (char*)&newname[oid_name_len], (char*) next_inst,  2*sizeof(oid));
        result =
            snmp_oid_compare(name, *length, newname,
                             (int) vp->namelen +2);
        if ((exact && (result == 0)) || (!exact && (result < 0)))
            break;
    }
    if (!return_val ) {
        return MATCH_FAILED;
    }
    memcpy((char *) name, (char *) newname,
           ((int) vp->namelen + 2) * sizeof(oid));
    *length = vp->namelen + 2;
    *var_len = sizeof(long);    /* default to 'long' results */
    *index1 = next_inst[0];
    *index2 = next_inst[1];
    return TRUE;

}


/*
 * var_switchThermalTempTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_switchThermalTempTable(struct variable *vp,
                           oid * name,
                           size_t * length,
                           int exact,
                           size_t * var_len, WriteMethod ** write_method)
{
    /* variables we may use later */

    UI32_T index1=0, index2=0, retval;

    SYS_MGR_SwitchThermalEntry_T   entry;

    memset( &entry, 0, sizeof(entry));

     retval  = header_switchThermalTempTable(vp, name, length, exact, var_len, write_method,  &index1,& index2);

    if (retval == MATCH_FAILED)
        return NULL;

    entry.switch_unit_index= index1;
    entry.switch_thermal_index = index2;

   if (SYS_PMGR_GetThermalStatus(&entry)!= TRUE)
            return NULL;

    /*
     * * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
      #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
      case SWITCHTHERMALTEMPUNITINDEX:
        long_return=index1;
        return (u_char*) &long_return;
      case SWITCHTHERMALTEMPTHERMALINDEX:
         long_return=index2;
        return (u_char*) &long_return;
      #endif
      case SWITCHTHERMALTEMPVALUE:
        long_return=entry.switch_thermal_temp_value;
        return (u_char*) &long_return;
    default:
        ERROR_MSG("");
    }
    return NULL;
}

/********************************************
 *********   switchThermalActionTable****************
 ********************************************
 */

/* This entry is used for entry which have the ability to row create*/
#define switchThermalActionEntry_INSTANCE_LEN 3

SYS_MGR_SwitchThermalActionEntry_T switchThermalActionEntry;

static UI32_T getSwitchThermalActionTableOidNameLen(void)
{
    return SNMP_MGR_Get_PrivateMibRootLen() + 5;
}

static BOOL_T switchThermalActionTable_get(int      compc,
                                oid     *compl,
                                SYS_MGR_SwitchThermalActionEntry_T   *data)
{
    if (compc !=switchThermalActionEntry_INSTANCE_LEN)
    {
        return FALSE;
    }
    data->unit_index=compl[0];
    data->thermal_index=compl[1];
    data->action_index=compl[2];

    if (!SYS_PMGR_GetSwitchThermalActionEntry(data))
    {
        if(SNMP_MGR_IsDebugMode())
            SYSFUN_Debug_Printf("switchThermalActionTable_get:SYS_MGR_GetSwitchThermalActionEntry return false\n");
        return FALSE;
    }
    else
    {
        return TRUE;
    } /*End of if */
}

static BOOL_T switchThermalActionTable_next(int      compc,
                                 oid     *compl,
                                 SYS_MGR_SwitchThermalActionEntry_T    *data)
{
    oid tmp_compl[switchThermalActionEntry_INSTANCE_LEN];

    /* Generate the instance of each table entry and find the
     * smallest instance that's larger than compc/compl.
     *
     * Step 1: Verify and extract the input key from "compc" and "compl"
     * Note: The number of input key is defined by "compc".
     *       The key for the specified instance is defined in compl.
     */

    memcpy(tmp_compl, compl, sizeof(tmp_compl));
    SNMP_MGR_ConvertRemainToZero(compc,switchThermalActionEntry_INSTANCE_LEN, tmp_compl);
    data->unit_index=tmp_compl[0];
    data->thermal_index=tmp_compl[1];
    data->action_index=tmp_compl[2];


    if(SNMP_MGR_IsDebugMode())
        SYSFUN_Debug_Printf("switchThermalActionTable_next:data->unit_index=[%lu], data->thermal_index=[%lu],data->action_index=[%lu]\n", data->unit_index, data->thermal_index, data->action_index);

    if (compc<switchThermalActionEntry_INSTANCE_LEN)
    {
        if (!SYS_PMGR_GetSwitchThermalActionEntry(data))
        {
            if (!SYS_PMGR_GetNextSwitchThermalActionEntry(data))
            {
                if(SNMP_MGR_IsDebugMode())
                    SYSFUN_Debug_Printf("switchThermalActionTable_next: get & genext return false\n");
                return FALSE;
            }
        }
    }
    else
    {
        if (!SYS_PMGR_GetNextSwitchThermalActionEntry(data))
        {
            if(SNMP_MGR_IsDebugMode())
                SYSFUN_Debug_Printf("switchThermalActionTable_next: get return false\n");
            return FALSE;
        }
    }
    return TRUE;
}





/*
 * var_switchThermalActionTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_switchThermalActionTable(struct variable *vp,
                             oid * name,
                             size_t * length,
                             int exact,
                             size_t * var_len, WriteMethod ** write_method)
{
    UI32_T compc=0;
    oid compl[switchThermalActionEntry_INSTANCE_LEN];
    oid best_inst[switchThermalActionEntry_INSTANCE_LEN];
    SYS_MGR_SwitchThermalActionEntry_T data;

    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl, switchThermalActionEntry_INSTANCE_LEN);

    data.unit_index=compl[0];
    data.thermal_index=compl[1];
    data.action_index=compl[2];

    /* Give default value for the record first.
     * We use the row_status = 0 to indicate if this set operation is Set by field
     * or set by record(included row creation), if the row_status =0, this record
     * mean set by field, otherwise, we just think it is a normal set operation
     */
    if (exact)/*do this only for "get" or "set": this getdefault api need to specify thermal_index, do this only for "get" and "set",
                get next don't call this api, since it will encountered "index 0"(getfirst) return false issue */
    {
        switchThermalActionEntry.thermal_index=compl[1];
    if (!SYS_PMGR_GetDefaultSwitchThermalActionEntry(&switchThermalActionEntry))
    {
        if(SNMP_MGR_IsDebugMode())
            SYSFUN_Debug_Printf("var_switchThermalActionTable:SYS_MGR_GetDefaultSwitchThermalActionEntry return false\n");
        return NULL;
    }
    }
    switchThermalActionEntry.status=0;

   /*Since this table allow for entry that does not exist, (creation). we need to know the write method first*/
    switch (vp->magic)
    {
      case SWITCHTHERMALACTIONRISINGTHRESHOLD:
        *write_method = write_switchThermalActionRisingThreshold;
        break;
      case SWITCHTHERMALACTIONFALLINGTHRESHOLD:
        *write_method = write_switchThermalActionFallingThreshold;
        break;
      case SWITCHTHERMALACTIONACTION:
        *write_method = write_switchThermalActionAction;
        break;
      case SWITCHTHERMALACTIONSTATUS:
        *write_method = write_switchThermalActionStatus;
        break;
      default:
        *write_method =0;
         break;
    }

     /*check compc, retrive compl*/
    if (exact)/*get,set*/
    {
        if (!switchThermalActionTable_get(compc, compl, &data))
            return NULL;
    }
    else/*getnext*/
    {
        if (!switchThermalActionTable_next(compc, compl, &data))
            return NULL;
    }
    memcpy(name, vp->name, vp->namelen*sizeof(oid));
    best_inst[0]=data.unit_index;
    best_inst[1]=data.thermal_index;
    best_inst[2]=data.action_index;

    memcpy(name + vp->namelen, best_inst, switchThermalActionEntry_INSTANCE_LEN*sizeof(oid));
    *length = vp->namelen +switchThermalActionEntry_INSTANCE_LEN;

    *var_len = sizeof(long_return);

    /*
     * * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
      case SWITCHTHERMALACTIONUNITINDEX:
        long_return = data.unit_index;
        return (u_char*) &long_return;
      case SWITCHTHERMALACTIONTHERMALINDEX:
        long_return = data.thermal_index;
        return (u_char*) &long_return;
      case SWITCHTHERMALACTIONINDEX:
        long_return = data.action_index;
        return (u_char*) &long_return;
#endif
      case SWITCHTHERMALACTIONRISINGTHRESHOLD:
        long_return = data.rising_threshold;
        return (u_char*) &long_return;
      case SWITCHTHERMALACTIONFALLINGTHRESHOLD:
        long_return = data.falling_threshold;
        return (u_char*) &long_return;
      case SWITCHTHERMALACTIONACTION:
        long_return =(long) L_STDLIB_Hton32(data.action);
        return (u_char*) &long_return;
      case SWITCHTHERMALACTIONSTATUS:
        long_return = data.status;
        return (u_char*) &long_return;
    default:
        ERROR_MSG("");
    }
    return NULL;
}


int
write_switchThermalActionRisingThreshold(int action,
                                         u_char * var_val,
                                         u_char var_val_type,
                                         size_t var_val_len,
                                         u_char * statP,
                                         oid * name, size_t name_len)
{
    switch (action) {
    case RESERVE1:
        /* check 1: check if the input index is exactly match, if not return fail*/
        if (name_len!=  getSwitchThermalActionTableOidNameLen() + switchThermalActionEntry_INSTANCE_LEN )
        {
            return SNMP_ERR_WRONGLENGTH;
        }
        if (var_val_type != ASN_INTEGER) {

            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        switchThermalActionEntry.unit_index=name[getSwitchThermalActionTableOidNameLen()];
        switchThermalActionEntry.thermal_index=name[getSwitchThermalActionTableOidNameLen()+1];
        switchThermalActionEntry.action_index=name[getSwitchThermalActionTableOidNameLen()+2];
        switchThermalActionEntry.rising_threshold=*(long *)var_val;
        break;
    case FREE:
        /*
         * Release any resources that have been allocated
         */
        break;

    case ACTION:
    {
        /* For row creation, if row_status =0, mean that this is a normal
            * operation, we do the normal set operation, otherwise it is a row
            * creation operation, will do nothing here, and the overall entry
            * will perform in the write_xxxRowStatus function.
              */
        if (switchThermalActionEntry.status == 0)
        {
            if(SNMP_MGR_IsDebugMode())
                 SYSFUN_Debug_Printf("write_switchThermalActionRisingThreshold:unit_index=[%lu], thermal_index=[%lu], index=[%lu], value=[%lu]\n", switchThermalActionEntry.unit_index, switchThermalActionEntry.thermal_index, switchThermalActionEntry.action_index, switchThermalActionEntry.rising_threshold);

            if (!SYS_PMGR_SetSwitchThermalActionRisingThreshold(switchThermalActionEntry.unit_index, switchThermalActionEntry.thermal_index, switchThermalActionEntry.action_index, switchThermalActionEntry.rising_threshold))
            {
                if(SNMP_MGR_IsDebugMode())
                    SYSFUN_Debug_Printf("write_switchThermalActionRisingThreshold:SYS_MGR_SetSwitchThermalActionRisingThreshold return false\n");
                return SNMP_ERR_COMMITFAILED;
            }
        }
        break;
    }
    case UNDO:
        /*
         * Back out any changes made in the ACTION case
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_switchThermalActionFallingThreshold(int action,
                                          u_char * var_val,
                                          u_char var_val_type,
                                          size_t var_val_len,
                                          u_char * statP,
                                          oid * name, size_t name_len)
{
    switch (action) {
    case RESERVE1:
        /* check 1: check if the input index is exactly match, if not return fail*/
        if (name_len!=  getSwitchThermalActionTableOidNameLen() + switchThermalActionEntry_INSTANCE_LEN )
        {
            return SNMP_ERR_WRONGLENGTH;
        }
        if (var_val_type != ASN_INTEGER) {
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {

            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        switchThermalActionEntry.unit_index=name[getSwitchThermalActionTableOidNameLen()];
        switchThermalActionEntry.thermal_index=name[getSwitchThermalActionTableOidNameLen()+1];
        switchThermalActionEntry.action_index=name[getSwitchThermalActionTableOidNameLen()+2];
        switchThermalActionEntry.falling_threshold=*(long *)var_val;
        break;
    case FREE:
        /*
         * Release any resources that have been allocated
         */
        break;

    case ACTION:
    {
        /* For row creation, if row_status =0, mean that this is a normal
            * operation, we do the normal set operation, otherwise it is a row
            * creation operation, will do nothing here, and the overall entry
            * will perform in the write_xxxRowStatus function.
              */
        if (switchThermalActionEntry.status == 0)
        {
            if(SNMP_MGR_IsDebugMode())
                 SYSFUN_Debug_Printf("write_switchThermalActionRisingThreshold:unit_index=[%lu], thermal_index=[%lu], index=[%lu], value=[%lu]\n", switchThermalActionEntry.unit_index, switchThermalActionEntry.thermal_index, switchThermalActionEntry.action_index, switchThermalActionEntry.falling_threshold);

            if (!SYS_PMGR_SetSwitchThermalActionFallingThreshold(switchThermalActionEntry.unit_index, switchThermalActionEntry.thermal_index, switchThermalActionEntry.action_index, switchThermalActionEntry.falling_threshold))
            {
                if(SNMP_MGR_IsDebugMode())
                    SYSFUN_Debug_Printf("write_switchThermalActionRisingThreshold:SYS_MGR_SetSwitchThermalActionFallingThreshold return false\n");
                return SNMP_ERR_COMMITFAILED;
            }
        }
        break;
    }
    case UNDO:
        /*
         * Back out any changes made in the ACTION case
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_switchThermalActionAction(int action,
                                u_char * var_val,
                                u_char var_val_type,
                                size_t var_val_len,
                                u_char * statP,
                                oid * name, size_t name_len)
{

    switch (action) {
    case RESERVE1:
        /* check 1: check if the input index is exactly match, if not return fail*/
        if (name_len!=  getSwitchThermalActionTableOidNameLen() + switchThermalActionEntry_INSTANCE_LEN )
        {
            return SNMP_ERR_WRONGLENGTH;
        }
        if (var_val_type !=ASN_OCTET_STR) {
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(UI32_T)) {
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        switchThermalActionEntry.unit_index=name[getSwitchThermalActionTableOidNameLen()];
        switchThermalActionEntry.thermal_index=name[getSwitchThermalActionTableOidNameLen()+1];
        switchThermalActionEntry.action_index=name[getSwitchThermalActionTableOidNameLen()+2];
        memcpy(&switchThermalActionEntry.action, var_val, var_val_len);
        break;
    case FREE:
        /*
         * Release any resources that have been allocated
         */
        break;

    case ACTION:
    {
        /* For row creation, if row_status =0, mean that this is a normal
            * operation, we do the normal set operation, otherwise it is a row
            * creation operation, will do nothing here, and the overall entry
            * will perform in the write_xxxRowStatus function.
              */
        if (switchThermalActionEntry.status == 0)
        {
            if(SNMP_MGR_IsDebugMode())
                 SYSFUN_Debug_Printf("write_switchThermalActionRisingThreshold:unit_index=[%lu], thermal_index=[%lu], action_index=[%lu], value=[%lu]\n", switchThermalActionEntry.unit_index, switchThermalActionEntry.thermal_index, switchThermalActionEntry.action_index, switchThermalActionEntry.action);

            switchThermalActionEntry.action = L_STDLIB_Ntoh32(switchThermalActionEntry.action);
            if (!SYS_PMGR_SetSwitchThermalActionAction(switchThermalActionEntry.unit_index, switchThermalActionEntry.thermal_index, switchThermalActionEntry.action_index, switchThermalActionEntry.action))
            {
                if(SNMP_MGR_IsDebugMode())
                    SYSFUN_Debug_Printf("write_switchThermalActionRisingThreshold:SYS_MGR_SetSwitchThermalActionAction return false\n");
                return SNMP_ERR_COMMITFAILED;
            }
        }
        break;
    }
    case UNDO:
        /*
         * Back out any changes made in the ACTION case
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_switchThermalActionStatus(int action,
                                u_char * var_val,
                                u_char var_val_type,
                                size_t var_val_len,
                                u_char * statP,
                                oid * name, size_t name_len)
{
    switch (action) {
    case RESERVE1:
        /* check 1: check if the input index is exactly match, if not return fail*/
        if (name_len!=  getSwitchThermalActionTableOidNameLen() + switchThermalActionEntry_INSTANCE_LEN )
        {
            return SNMP_ERR_WRONGLENGTH;
        }
        if (var_val_type != ASN_INTEGER) {
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {

            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        switchThermalActionEntry.unit_index=name[getSwitchThermalActionTableOidNameLen()];
        switchThermalActionEntry.thermal_index=name[getSwitchThermalActionTableOidNameLen()+1];
        switchThermalActionEntry.action_index=name[getSwitchThermalActionTableOidNameLen()+2];
        switchThermalActionEntry.status=*(long *)var_val;

        switch(switchThermalActionEntry.status)
        {
          case VAL_switchThermalActionStatus_valid:
          case VAL_switchThermalActionStatus_invalid:
            break;
          default:
            return SNMP_ERR_WRONGVALUE;
        }
        break;
    case FREE:
        /*
         * Release any resources that have been allocated
         */
        break;

    case ACTION:
    {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        switch(switchThermalActionEntry.status)
        {
            case VAL_switchThermalActionStatus_valid:
            {
                if(SNMP_MGR_IsDebugMode())
                    SYSFUN_Debug_Printf("write_switchThermalActionRisingThreshold:unit_index=[%lu], thermal_index=[%lu], action_index=[%lu], rising_threshold=[%lu], falling_threshold=[%lu], action=[%lu], status=[%lu]\n", switchThermalActionEntry.unit_index, switchThermalActionEntry.thermal_index, switchThermalActionEntry.action_index, switchThermalActionEntry.rising_threshold, switchThermalActionEntry.falling_threshold, switchThermalActionEntry.action, switchThermalActionEntry.status);

                if (!SYS_PMGR_SetSwitchThermalActionEntry(&switchThermalActionEntry))
                {
                    if(SNMP_MGR_IsDebugMode())
                        SYSFUN_Debug_Printf("write_switchThermalActionRisingThreshold:SYS_MGR_SetSwitchThermalActionEntry return false\n");
                    return SNMP_ERR_COMMITFAILED;
                }
                break;
            }
            case VAL_switchThermalActionStatus_invalid:
            {
                if(SNMP_MGR_IsDebugMode())
                    SYSFUN_Debug_Printf("write_switchThermalActionRisingThreshold:unit_index=[%lu], thermal_index=[%lu], action_index=[%lu], status=[%lu]\n", switchThermalActionEntry.unit_index, switchThermalActionEntry.thermal_index, switchThermalActionEntry.action_index, switchThermalActionEntry.status);

                if (!SYS_PMGR_SetSwitchThermalActionStatus(switchThermalActionEntry.unit_index, switchThermalActionEntry.thermal_index, switchThermalActionEntry.action_index, switchThermalActionEntry.status))
                {
                    if(SNMP_MGR_IsDebugMode())
                        SYSFUN_Debug_Printf("write_switchThermalActionRisingThreshold:SYS_MGR_SetSwitchThermalActionStatus return false\n");
                    return SNMP_ERR_COMMITFAILED;
                }
                break;
           }
        }




    }
    case UNDO:
        /*
         * Back out any changes made in the ACTION case
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}


#endif


#if (SYS_CPNT_MODULE_WITH_CPU == TRUE)
/********************************************
 ******************switchModuleInfoTable*****************
 ********************************************
 */
#define switchModuleInfoEntry_INSTANCE_LEN 2

static BOOL_T switchModuleInfoTable_get(int      compc,
                                oid     *compl,
                                STKTPLG_MGR_switchModuleInfoEntry_T   *data)
{
    if (compc !=switchModuleInfoEntry_INSTANCE_LEN)
    {
        return FALSE;
    }
    data->unit_index=compl[0];
    data->module_index=compl[1];

    if(SNMP_MGR_IsDebugMode())
        SYSFUN_Debug_Printf("switchModuleInfoTable_get:data->unit_index=[%lu], data->module_index=[%lu]\n", data->unit_index, data->module_index);

    if (!STKTPLG_PMGR_GetSwitchModuleInfoEntry(data))
    {
        if(SNMP_MGR_IsDebugMode())
            SYSFUN_Debug_Printf("switchModuleInfoTable_get:STKTPLG_MGR_GetSwitchModuleInfoEntry return false\n");
        return FALSE;
    }
    else
    {
        return TRUE;
    } /*End of if */
}

static BOOL_T switchModuleInfoTable_next(int      compc,
                                 oid     *compl,
                                 STKTPLG_MGR_switchModuleInfoEntry_T    *data)
{
    oid tmp_compl[switchModuleInfoEntry_INSTANCE_LEN];

    /* Generate the instance of each table entry and find the
     * smallest instance that's larger than compc/compl.
     *
     * Step 1: Verify and extract the input key from "compc" and "compl"
     * Note: The number of input key is defined by "compc".
     *       The key for the specified instance is defined in compl.
     */

    memcpy(tmp_compl, compl, sizeof(tmp_compl));
    SNMP_MGR_ConvertRemainToZero(compc,switchModuleInfoEntry_INSTANCE_LEN, tmp_compl);
    data->unit_index=tmp_compl[0];
    data->module_index=tmp_compl[1];

    if(SNMP_MGR_IsDebugMode())
        SYSFUN_Debug_Printf("switchModuleInfoTable_next:data->unit_index=[%lu], data->module_index=[%lu]\n", data->unit_index, data->module_index);

    if (compc<switchModuleInfoEntry_INSTANCE_LEN)
    {
        if (!STKTPLG_PMGR_GetSwitchModuleInfoEntry(data))
        {
            if (!STKTPLG_PMGR_GetNextSwitchModuleInfoEntry(data))
            {
                if(SNMP_MGR_IsDebugMode())
                    SYSFUN_Debug_Printf("switchModuleInfoTable_next: get & genext return false\n");
                return FALSE;
            }
        }
    }
    else
    {
        if (!STKTPLG_PMGR_GetNextSwitchModuleInfoEntry(data))
        {
            if(SNMP_MGR_IsDebugMode())
                SYSFUN_Debug_Printf("switchModuleInfoTable_next: get return false\n");
            return FALSE;
        }
    }
    return TRUE;
}

/*
 * var_switchModuleInfoTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_switchModuleInfoTable(struct variable *vp,
                          oid * name,
                          size_t * length,
                          int exact,
                          size_t * var_len, WriteMethod ** write_method)
{
    UI32_T compc = 0;
    oid compl[switchModuleInfoEntry_INSTANCE_LEN];
    oid best_inst[switchModuleInfoEntry_INSTANCE_LEN];
    STKTPLG_MGR_switchModuleInfoEntry_T data;

    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl, switchModuleInfoEntry_INSTANCE_LEN);

     /*check compc, retrive compl*/
    if(exact)/*get,set*/
    {
        if(!switchModuleInfoTable_get(compc, compl, &data))
            return NULL;
    }

    else/*getnext*/
    {
        if(!switchModuleInfoTable_next(compc, compl, &data))
            return NULL;
    }

    memcpy(name, vp->name, vp->namelen*sizeof(oid));
    best_inst[0] = data.unit_index;
    best_inst[1] = data.module_index;

    memcpy(name + vp->namelen, best_inst, switchModuleInfoEntry_INSTANCE_LEN*sizeof(oid));
    *length = vp->namelen + switchModuleInfoEntry_INSTANCE_LEN;

    *var_len = sizeof(long_return);

    /*
     * * this is where we do the value assignments for the mib results.
     */
    switch(vp->magic)
    {
#if(SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case SWMODULEUNITINDEX:
            long_return = data.unit_index;
            return (u_char*) &long_return;
        case SWMODULEMODULEINDEX:
            long_return = data.module_index;
            return (u_char*) &long_return;
#endif
        case SWMODULEHARDWAREVER:
            memcpy(return_buf, data.hardware_ver, SYS_ADPT_HW_VER_STR_LEN);
            *var_len=MAXSIZE_swModuleHardwareVer;
            return (u_char*) return_buf;
        case SWMODULEMICROCODEVER:
            memcpy(return_buf, data.microcode_ver, SYS_ADPT_HW_VER_STR_LEN);
            *var_len=MAXSIZE_swModuleMicrocodeVer;
            return (u_char*) return_buf;
        case SWMODULELOADERVER:
        {
            UI32_T version = 0;
#if (SYS_CPNT_3COM_CLI == TRUE)
            UI32_T version1 = 0, version2 = 0, version3 = 0, version4 = 0;
#endif
            UI8_T buffer[SYS_ADPT_FW_VER_STR_LEN + 1];

            strncpy(buffer, data.loader_ver, SYS_ADPT_FW_VER_STR_LEN + 1);
            buffer[SYS_ADPT_FW_VER_STR_LEN] = 0;

#if (SYS_CPNT_3COM_CLI == TRUE)
            sscanf(buffer, "%lu.%lu.%lu.%lu", &version1, &version2, &version3, &version4);

            version = (version1 << 24 | version2 << 16 | version3 << 8 | version4);

            CLI_MGR_GetVersionNumberDisplayString(version, IMGHDR_IMAGE_LOADERTYPE, buffer);

#endif /*end of #if (SYS_CPNT_3COM_CLI == TRUE)*/
            strcpy(return_buf, buffer);
            *var_len = strlen(return_buf);
            return (u_char*) return_buf;
        }

        case SWMODULEBOOTROMVER:
        {
            UI32_T version = 0;
#if (SYS_CPNT_3COM_CLI == TRUE)
            UI32_T version1 = 0, version2 = 0, version3 = 0, version4 = 0;
#endif
            UI8_T buffer[SYS_ADPT_FW_VER_STR_LEN + 1];

            strncpy(buffer, data.boot_rom_ver, SYS_ADPT_FW_VER_STR_LEN + 1);
            buffer[SYS_ADPT_FW_VER_STR_LEN] = 0;

#if (SYS_CPNT_3COM_CLI == TRUE)
            sscanf(buffer, "%lu.%lu.%lu.%lu", &version1, &version2, &version3, &version4);

            version = (version1 << 24 | version2 << 16 | version3 << 8 | version4);

            CLI_MGR_GetVersionNumberDisplayString(version, IMGHDR_IMAGE_DIAGNOSTICTYPE, buffer);

#endif /*end of #if (SYS_CPNT_3COM_CLI == TRUE)*/
            strcpy(return_buf, buffer);
            *var_len = strlen(return_buf);
            return (u_char*) return_buf;
        }

        case SWMODULEOPCODEVER:
        {
            UI32_T version = 0;
#if (SYS_CPNT_3COM_CLI == TRUE)
            UI32_T version1 = 0, version2 = 0, version3 = 0, version4 = 0;
#endif
            UI8_T buffer[SYS_ADPT_FW_VER_STR_LEN+1];

            strncpy(buffer, data.op_code_ver, SYS_ADPT_FW_VER_STR_LEN+1);
            buffer[SYS_ADPT_FW_VER_STR_LEN] = 0;

#if (SYS_CPNT_3COM_CLI == TRUE)
            sscanf(buffer,"%lu.%lu.%lu.%lu",&version1,&version2,&version3,&version4);

            version = (version1 << 24 | version2 << 16 | version3 << 8 | version4);

            CLI_MGR_GetVersionNumberDisplayString(version, IMGHDR_IMAGE_RUNTIMETYPE, buffer);

#endif /*end of #if (SYS_CPNT_3COM_CLI == TRUE)*/
            strcpy(return_buf, buffer);
            *var_len = strlen(return_buf);
            return (u_char*) return_buf;
        }
        case SWMODULEPORTNUMBER:
            long_return = data.port_number;
            return (u_char*) &long_return;
        case SWMODULESERIALNUMBER:
            memcpy(return_buf, data.serial_number, SYS_ADPT_SERIAL_NO_STR_LEN);
            *var_len=MAXSIZE_swModuleSerialNumber;
            return (u_char*) return_buf;
        case SWMODULETYPE:
            long_return = data.module_type;
            return (u_char*) &long_return;
        case SWMODULEMODELNUMBER:
            memcpy(return_buf, data.model_number, SYS_ADPT_MODEL_NUMBER_LEN);
            *var_len=MAXSIZE_swModuleModelNumber;
            return (u_char*) return_buf;
        case SWMODULEEPLDVER:
            memcpy(return_buf, data.epld_ver, SYS_ADPT_EPLD_VER_STR_LEN);
            *var_len=MAXSIZE_swModuleEpldVer;
            return (u_char*) return_buf;
        case SWMODULEDESCR:
            memcpy(return_buf, data.desc, SYS_ADPT_MODULE_DESC_STR_LEN);
            *var_len=MAXSIZE_swModuleDescr;
            return (u_char*) return_buf;
        case SWMODULEXENPAKTYPE:
            long_return = data.xenpak_status;
            return (u_char*) &long_return;
        default:
            ERROR_MSG("");
    }

    return NULL;
}
#endif/*end of #if (SYS_CPNT_MODULE_WITH_CPU == TRUE)*/

int
do_switchRenumberUnitID(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode)
    {
        case MODE_GET:
             long_return=VAL_switchRenumberUnitID_noRenumber;
             snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
             break;

        case MODE_SET_RESERVE1:
            if (requests->requestvb->type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }

            switch (*requests->requestvb->val.integer)
            {
                case VAL_switchRenumberUnitID_renumber:
                case VAL_switchRenumberUnitID_noRenumber:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case MODE_SET_RESERVE2:
             break;

        case MODE_SET_FREE:
             break;

        case MODE_SET_ACTION:
        {
             UI32_T renumber;

             renumber = (*requests->requestvb->val.integer);

             switch( renumber)
         {
           case VAL_switchRenumberUnitID_renumber:
                     STKTPLG_PMGR_UnitIDReNumbering();
                break;

               case VAL_switchRenumberUnitID_noRenumber:
               default:
                    break;
         }
            break;
        }

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */

            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */

            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

#if (SYS_CPNT_DBSYNC_TXT == TRUE)
int
do_switchConfigAutosaveEnableStatus(netsnmp_mib_handler *handler,
                                    netsnmp_handler_registration *reginfo,
                                    netsnmp_agent_request_info *reqinfo,
                                    netsnmp_request_info *requests)
{
    switch (reqinfo->mode)
    {
        case MODE_GET:
        {
                  UI32_T switchConfigAutosaveEnableStatus;

             if(DBSYNC_TXT_MGR_GetSwitchConfigAutosaveEnableStatus (&switchConfigAutosaveEnableStatus) == TRUE)
             {
                        long_return = switchConfigAutosaveEnableStatus;
                        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
             }

             else
             {
                        return SNMP_ERR_GENERR;
             }
        }
        break;


         case MODE_SET_RESERVE1:
         {
            UI32_T value;

            value = (*requests->requestvb->val.integer);

            if((value != VAL_switchConfigAutosaveEnableStatus_enabled) && (value != VAL_switchConfigAutosaveEnableStatus_disabled))
            {
                        netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            }

            break;
         }

         case MODE_SET_RESERVE2:
                                break;

         case MODE_SET_FREE:
              break;

         case MODE_SET_ACTION:
         {
             UI32_T value;

             value = (*requests->requestvb->val.integer);

             if(DBSYNC_TXT_MGR_SetSwitchConfigAutosaveEnableStatus (value) != TRUE)
             {
                                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
             }

             break;
        }

        case MODE_SET_COMMIT:
                         break;

        case MODE_SET_UNDO:
             break;

        default:
             return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
#endif

#if (SYS_CPNT_DBSYNC_TXT == TRUE)
int
get_switchConfigAutosaveBusyStatus(netsnmp_mib_handler *handler,
                                   netsnmp_handler_registration *reginfo,
                                   netsnmp_agent_request_info *reqinfo,
                                   netsnmp_request_info *requests)
{
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one.
     */

    switch (reqinfo->mode) {

    case MODE_GET:
    {
        UI32_T switchConfigAutosaveBusyStatus;

        if(DBSYNC_TXT_MGR_GetSwitchConfigAutosaveBusyStatus (&switchConfigAutosaveBusyStatus) == TRUE)
        {
            long_return = switchConfigAutosaveBusyStatus;
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
        }

        else
        {
            return SNMP_ERR_GENERR;
        }
    }

    break;

    default:
        /*
         * we should never get here, so this is a really bad error
         */
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
#endif

#if (SYS_CPNT_SWCTRL_MTU_CONFIG_MODE == SYS_CPNT_SWCTRL_MTU_PER_SYSTEM)
int do_switchSystemJumboMtu(netsnmp_mib_handler            *handler,
                           netsnmp_handler_registration    *reginfo,
                           netsnmp_agent_request_info      *reqinfo,
                           netsnmp_request_info            *requests)
{
    switch(reqinfo->mode)
    {
        case MODE_GET:
        {
            UI32_T systemJumboMtu;
            UI32_T systemMtu;

            if(!SWCTRL_PMGR_GetSystemMTU(&systemJumboMtu, &systemMtu))
            {
                return SNMP_ERR_GENERR;
            }

            long_return = systemJumboMtu;
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *)&long_return, sizeof(long_return));

            break;
        }

        case MODE_SET_RESERVE1:
        {
            UI32_T value;
            value = (*requests->requestvb->val.integer);

            /*Check the type.    amy  2007.7.8*/
            if (requests->requestvb->type != ASN_INTEGER)
                     {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
                         return SNMP_ERR_WRONGTYPE;
                }

            if((value < SYS_ADPT_IF_MTU) || (value > SYS_ADPT_MAX_JUMBO_MTU))
            {
                         netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_WRONGVALUE);
                         return SNMP_ERR_WRONGVALUE;
            }

            break;
        }

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            break;

        case MODE_SET_ACTION:
        {
            UI32_T value;

            value = (*requests->requestvb->val.integer);

            if(!SWCTRL_PMGR_SetSystemMTU(TRUE, value))
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            }

            break;
        }

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
#endif /* #if (SYS_CPNT_SWCTRL_MTU_CONFIG_MODE == SYS_CPNT_SWCTRL_MTU_PER_SYSTEM) */

#define SWITCHALARMINPUTENTRY_INSTANCE_LEN  2

BOOL_T switchAlarmInputTable_OidIndexToData(UI32_T exact, UI32_T compc,
    oid *compl, UI32_T *swUnitIndex, UI32_T *swAlarmInputType)
{
    /* get or set
     */
    if (exact)
    {
        /* check the index length
         */
        if (compc != SWITCHALARMINPUTENTRY_INSTANCE_LEN)  /* the constant size index */
        {
            return FALSE;
        }
    }

    *swUnitIndex = compl[0];
    *swAlarmInputType = compl[1];
    return TRUE;
}
#if (SYS_CPNT_ALARM_INPUT_DETECT == TRUE)
/*
 * var_switchAlarmInputTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *var_switchAlarmInputTable(struct variable *vp,
    oid *name,
    size_t *length,
    int exact,
    size_t *var_len,
    WriteMethod **write_method)
{
    UI32_T compc = 0;
    oid compl[SWITCHALARMINPUTENTRY_INSTANCE_LEN] = {0};
    oid best_inst[SWITCHALARMINPUTENTRY_INSTANCE_LEN] = {0};

    /* table-specific variables
     */
    SYS_MGR_SwAlarmEntry_T entry;

    /* dispatch node to set write method
     */
    switch (vp->magic)
    {
        case LEAF_swAlarmInputName:
            *write_method = write_switchAlarmInputName;
            break;
        default:
            *write_method = 0;
            break;
    }

    /* check compc, retrive compl
     */
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl,
        SWITCHALARMINPUTENTRY_INSTANCE_LEN);

    memset(&entry, 0, sizeof(entry));

    /* dispatch get-exact versus get-next
     */
    if (exact)  /* get or set */
    {
        /* extract index
         */
        if (! switchAlarmInputTable_OidIndexToData(exact, compc, compl,
            &entry.sw_alarm_unit_index, &entry.sw_alarm_input_index))
        {
            return NULL;
        }

        /* get-exact from core layer
         */
        if (! SYS_PMGR_GetSwAlarmInput(&entry))
        {
            return NULL;
        }
    }
    else  /* get-next */
    {
        /* extract index
         */
        switchAlarmInputTable_OidIndexToData(exact, compc, compl,
            &entry.sw_alarm_unit_index, &entry.sw_alarm_input_index);

        /* Check the length of inputing index.  If compc is less than the
         * instance length, we should try get {A.B.C.0.0...}, where A.B.C was
         * obtained from the "..._OidIndexToData" function call, and
         * 0.0... was initialized in the beginning of this function.
         * This instance may exist in the core layer.
         */
        if (compc < SWITCHALARMINPUTENTRY_INSTANCE_LEN)  /* incomplete index */
        {
            /* get-exact, in case this instance exists
             */
            if (! SYS_PMGR_GetSwAlarmInput(&entry))
            {
                /* get-next according to lexicographic order; if none, fail
                 */
                if (! SYS_PMGR_GetNextSwAlarmInput(&entry))
                {
                    return NULL;
                }
            }
        }
        else   /* complete index */
        {
            /* get-next according to lexicographic order; if none, fail
             */
            if (! SYS_PMGR_GetNextSwAlarmInput(&entry))
            {
                return NULL;
            }
        }
    }

    /* copy base OID (without index) to output
     */
    memcpy(name, vp->name, vp->namelen * sizeof(oid));

    /* assign data to the OID index
     */
    best_inst[0] = entry.sw_alarm_unit_index;
    best_inst[1] = entry.sw_alarm_input_index;
    memcpy(name + vp->namelen, best_inst, SWITCHALARMINPUTENTRY_INSTANCE_LEN * sizeof(oid));
    *length = vp->namelen + SWITCHALARMINPUTENTRY_INSTANCE_LEN;

    /* dispatch node to read value
     */
    switch (vp->magic)
    {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case LEAF_swAlarmUnitIndex:
            *var_len = sizeof(long_return);
            long_return = entry.sw_alarm_unit_index
            return (u_char *) &long_return;
#endif  /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case LEAF_swAlarmInputType:
            *var_len = sizeof(long_return);
            long_return = entry.sw_alarm_input_index;
            return (u_char *) &long_return;
#endif  /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

        case LEAF_swAlarmInputStatus:
        {
            BOOL_T alarm_input_asserted = FALSE;
            *var_len = sizeof(long_return);
            switch(entry.sw_alarm_input_index)
            {
                case 1:
                    alarm_input_asserted = SYSDRV_ALARM_INPUT_IS_ASSERTED(entry.sw_alarm_status, SYS_HWCFG_SYSTEM_ALARM_INPUT_1_MASK);
                    break;
                case 2:
                    alarm_input_asserted = SYSDRV_ALARM_INPUT_IS_ASSERTED(entry.sw_alarm_status, SYS_HWCFG_SYSTEM_ALARM_INPUT_2_MASK);
                    break;
                case 3:
                    alarm_input_asserted = SYSDRV_ALARM_INPUT_IS_ASSERTED(entry.sw_alarm_status, SYS_HWCFG_SYSTEM_ALARM_INPUT_3_MASK);
                    break;
                case 4:
                    alarm_input_asserted = SYSDRV_ALARM_INPUT_IS_ASSERTED(entry.sw_alarm_status, SYS_HWCFG_SYSTEM_ALARM_INPUT_4_MASK);
                    break;
                default:
                    break;
            }
            if(alarm_input_asserted)
                long_return = VAL_swAlarmInputStatus_alarmInputAsserted;
            else
                long_return = VAL_swAlarmInputStatus_alarmInputNotAsserted;
            return (u_char *) &long_return;
        }

        case LEAF_swAlarmInputName:
            *var_len = strlen((char *)entry.sw_alarm_input_name);
            memcpy(return_buf, entry.sw_alarm_input_name, *var_len);
            return (u_char *) return_buf;

        default:
            ERROR_MSG("");
            break;
    }

    /* return failure
     */
    return NULL;
}
int write_switchAlarmInputName(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_OCTET_STR)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if ((MINSIZE_swAlarmInputName > var_val_len) || (var_val_len > MAXSIZE_swAlarmInputName))
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;

        case RESERVE2:
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            SYS_MGR_SwAlarmEntry_T entry;
            UI32_T i;

            memset(&entry, 0, sizeof(entry));
            if (switchAlarmInputTable_OidIndexToData(TRUE, name_len - oid_name_length,
&(name[oid_name_length]), &entry.sw_alarm_unit_index, &entry.sw_alarm_input_index) == FALSE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            memcpy(entry.sw_alarm_input_name, var_val, var_val_len);

            entry.sw_alarm_input_name[var_val_len] = '\0';

            for (i=0 ; i<var_val_len;i++)
            {
                if (entry.sw_alarm_input_name[i]=='?' ||
                    entry.sw_alarm_input_name[i]==' ' ||
                    entry.sw_alarm_input_name[i]==':')
                    return SNMP_ERR_WRONGVALUE;
            }

            if (SYS_PMGR_SetSwAlarmInputName(&entry) != TRUE)
            {
                return SNMP_ERR_COMMITFAILED;
            }
        }
            break;

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}
#endif/* #if (SYS_CPNT_ALARM_INPUT_DETECT == TRUE) */

#if (SYS_CPNT_ALARM_DETECT == TRUE)
#define SWITCHALARMOUTPUTENTRY_INSTANCE_LEN  1

BOOL_T switchAlarmOutputTable_OidIndexToData(UI32_T exact, UI32_T compc,
    oid *compl, UI32_T *swAlarmUnitIndex)
{
    /* get or set
     */
    if (exact)
    {
        /* check the index length
         */
        if (compc != SWITCHALARMOUTPUTENTRY_INSTANCE_LEN)  /* the constant size index */
        {
            return FALSE;
        }
    }

    *swAlarmUnitIndex = compl[0];

    return TRUE;
}

/*
 * var_switchAlarmOutputTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *var_switchAlarmOutputTable(struct variable *vp,
    oid *name,
    size_t *length,
    int exact,
    size_t *var_len,
    WriteMethod **write_method)
{
    UI32_T compc = 0;
    oid compl[SWITCHALARMOUTPUTENTRY_INSTANCE_LEN] = {0};
    oid best_inst[SWITCHALARMOUTPUTENTRY_INSTANCE_LEN] = {0};

    /* table-specific variables
     */
    SYS_MGR_SwAlarmEntry_T entry;

    /* dispatch node to set write method
     */
    switch (vp->magic)
    {
        default:
            *write_method = 0;
            break;
    }

    /* check compc, retrive compl
     */
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl,
        SWITCHALARMOUTPUTENTRY_INSTANCE_LEN);

    memset(&entry, 0, sizeof(entry));

    /* dispatch get-exact versus get-next
     */
    if (exact)  /* get or set */
    {
        /* extract index
         */
        if (! switchAlarmOutputTable_OidIndexToData(exact, compc, compl,
            &entry.sw_alarm_unit_index))
        {
            return NULL;
        }

        /* get-exact from core layer
         */
        if (! SYS_PMGR_GetAlarmOutputCurrentStatus(&entry))
        {
            return NULL;
        }
    }
    else  /* get-next */
    {
        /* extract index
         */
        switchAlarmOutputTable_OidIndexToData(exact, compc, compl,
            &entry.sw_alarm_unit_index);

        /* Check the length of inputing index.  If compc is less than the
         * instance length, we should try get {A.B.C.0.0...}, where A.B.C was
         * obtained from the "..._OidIndexToData" function call, and
         * 0.0... was initialized in the beginning of this function.
         * This instance may exist in the core layer.
         */
        if (compc < SWITCHALARMOUTPUTENTRY_INSTANCE_LEN)  /* incomplete index */
        {
            /* get-exact, in case this instance exists
             */
            if (! SYS_PMGR_GetAlarmOutputCurrentStatus(&entry))
            {
                /* get-next according to lexicographic order; if none, fail
                 */
                if (! SYS_PMGR_GetNextAlarmOutputCurrentStatus(&entry))
                {
                    return NULL;
                }
            }
        }
        else   /* complete index */
        {
            /* get-next according to lexicographic order; if none, fail
             */
            if (! SYS_PMGR_GetNextAlarmOutputCurrentStatus(&entry))
            {
                return NULL;
            }
        }
    }

    /* copy base OID (without index) to output
     */
    memcpy(name, vp->name, vp->namelen * sizeof(oid));

    /* assign data to the OID index
     */
    best_inst[0] = entry.sw_alarm_unit_index;
    memcpy(name + vp->namelen, best_inst, SWITCHALARMOUTPUTENTRY_INSTANCE_LEN * sizeof(oid));
    *length = vp->namelen + SWITCHALARMOUTPUTENTRY_INSTANCE_LEN;

    /* dispatch node to read value
     */
    switch (vp->magic)
    {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case LEAF_swAlarmOutputUnitIndex:
            *var_len = sizeof(long_return);
            long_return = entry.sw_alarm_unit_index;
            return (u_char *) &long_return;
#endif  /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

        case LEAF_swAlarmMajorStatus:
            *var_len = sizeof(long_return);
            long_return = entry.sw_alarm_status;
            return (u_char *) &long_return;

        case LEAF_swAlarmMinorStatus:
            *var_len = sizeof(long_return);
            long_return = entry.sw_alarm_status_2;
            return (u_char *) &long_return;

        default:
            ERROR_MSG("");
            break;
    }

    /* return failure
     */
    return NULL;
}
#endif/* #if (SYS_CPNT_ALARM_DETECT == TRUE) */

#if (SYS_CPNT_CRAFT_PORT == TRUE) && (SYS_CPNT_CRAFT_PORT_MODE == SYS_CPNT_CRAFT_PORT_MODE_FRONT_PORT_CRAFT_PORT)
int get_switchCraftLinkStatus(netsnmp_mib_handler *handler,
    netsnmp_handler_registration *reginfo,
    netsnmp_agent_request_info *reqinfo,
    netsnmp_request_info *requests)
{
    /* dispatch get vs. set
     */
    switch (reqinfo->mode)
    {
        /* GET REQUEST
         */
        case MODE_GET:
        {
            SWDRV_CraftPort_Info_T swdrv_craftport_info;

            /* get from om
             */
            memset(&swdrv_craftport_info, 0, sizeof(SWDRV_CraftPort_Info_T));

            if(!SWDRV_OM_GetCraftPortInfo(&swdrv_craftport_info))
            {
                return SNMP_ERR_GENERR;
            }
            else
            {
                if(swdrv_craftport_info.link_status == TRUE)
                   long_return = VAL_switchCraftLinkStatus_up;
                else
                   long_return = VAL_switchCraftLinkStatus_down;

                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                    (u_char *) &long_return, sizeof(long_return));
            }

            break;
        }

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
#endif

#if ((SYS_HWCFG_SUPPORT_PD==TRUE) && (SYS_CPNT_SWDRV_ONLY_ALLOW_PD_PORT_LINKUP_WITH_PSE_PORT==TRUE))
int do_switchPDPowerSourceCheck(netsnmp_mib_handler *handler,
    netsnmp_handler_registration *reginfo,
    netsnmp_agent_request_info *reqinfo,
    netsnmp_request_info *requests)
{
    /* dispatch get vs. set
     */
    switch (reqinfo->mode)
    {
        /* GET REQUEST
         */
        case MODE_GET:
        {
            BOOL_T pse_check_status = FALSE;

            /* get from core layer
             */
            if (! SWCTRL_PMGR_GetPSECheckStatus(&pse_check_status))
            {
                return SNMP_ERR_GENERR;
            }
            else
            {
                if(pse_check_status == TRUE)
                    long_return = VAL_switchPDPowerSourceCheck_true;
                else
                    long_return = VAL_switchPDPowerSourceCheck_false;

                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                    (u_char *) &long_return, sizeof(long_return));
            }

            break;
        }

        /* SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            /* check type and length
             */
            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
                return SNMP_ERR_NOERROR;
            }

            break;

        case MODE_SET_RESERVE2:
            switch (*requests->requestvb->val.integer)
            {
                case VAL_switchPDPowerSourceCheck_true:
                    break;

                case VAL_switchPDPowerSourceCheck_false:
                    break;

                default:
                    netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
                    return SNMP_ERR_NOERROR;
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called.
             */
            break;

        case MODE_SET_ACTION:
        {
            /* set to core layer
             */
            BOOL_T pse_check_status = FALSE;

            if(*requests->requestvb->val.integer == VAL_switchPDPowerSourceCheck_true)
                pse_check_status = TRUE;
            else
                pse_check_status = FALSE;

            if (!SWCTRL_PMGR_SetPSECheckStatus(pse_check_status))
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
                return SNMP_ERR_NOERROR;
            }

            break;
        }

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
#endif
/********************************************
 ******************portTable*****************
 ********************************************
 */
#define PORTENTRY_INSTANCE_LEN  1

BOOL_T portTable_OidIndexToData(UI32_T exact, UI32_T compc,
    oid *compl, UI32_T *index_p)
{
    /* get or set
     */
    if (exact)
    {
        /* check the index length
         */
        if (compc != PORTENTRY_INSTANCE_LEN) /* the constant size index */
        {
            return FALSE;
        }
    }

    *index_p = compl[0];

    return TRUE;
}

/*
 * var_portTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *var_portTable(struct variable *vp,
    oid *name,
    size_t *length,
    int exact,
    size_t *var_len,
    WriteMethod **write_method)
{
    UI32_T compc = 0;
    oid compl[PORTENTRY_INSTANCE_LEN] = {0};
    oid best_inst[PORTENTRY_INSTANCE_LEN] = {0};
    SWCTRL_PortEntry_T entry;

    switch (vp->magic)
    {
        case LEAF_portName:
            *write_method = write_portName;
            break;

        case LEAF_portSpeedDpxCfg:
            *write_method = write_portSpeedDpxCfg;
            break;

        case LEAF_portFlowCtrlCfg:
            *write_method = write_portFlowCtrlCfg;
            break;

        case LEAF_portCapabilities:
            *write_method = write_portCapabilities;
            break;

        case LEAF_portAutonegotiation:
            *write_method = write_portAutonegotiation;
            break;

#if (SYS_CPNT_COMBO_PORT_FORCE_MODE == TRUE)
        case LEAF_portComboForcedMode:
            *write_method = write_portComboForcedMode;
            break;
#endif /* #if (SYS_CPNT_COMBO_PORT_FORCE_MODE == TRUE) */

#if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION == TRUE)
#if (SYS_DFLT_TRAFFIC_SEG_METHOD == SYS_DFLT_TRAFFIC_SEG_METHOD_PORT_PRIVATE_MODE)
        case LEAF_portPrivateMode:
            *write_method = write_portPrivateMode;
            break;
#endif /* #if (SYS_DFLT_TRAFFIC_SEG_METHOD == SYS_DFLT_TRAFFIC_SEG_METHOD_PORT_PRIVATE_MODE) */
#endif /* #if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION == TRUE) */

#if (SYS_CPNT_SWCTRL_MDIX_CONFIG == TRUE)
        case LEAF_portMdixMode:
            *write_method = write_portMdixMode;
            break;
#endif /* #if (SYS_CPNT_SWCTRL_MDIX_CONFIG == TRUE) */

#if (SYS_CPNT_SWCTRL_MTU_CONFIG_MODE == SYS_CPNT_SWCTRL_MTU_PER_PORT)
        case LEAF_portMtu:
            *write_method = write_portMtu;
            break;
#endif /* #if (SYS_CPNT_SWCTRL_MTU_CONFIG_MODE == SYS_CPNT_SWCTRL_MTU_PER_PORT) */

#if (SYS_CPNT_AMTR_PORT_MAC_LEARNING == TRUE)
        case LEAF_portMacAddrLearningStatus:
            *write_method = write_portMacAddrLearningStatus;
            break;
#endif /* #if (SYS_CPNT_AMTR_PORT_MAC_LEARNING == TRUE) */

#if (SYS_CPNT_SWCTRL_SWITCH_MODE_CONFIGURABLE == TRUE)
        case LEAF_portSwitchingMode:
            *write_method = write_portSwitchingMode;
            break;
#endif /* #if (SYS_CPNT_SWCTRL_SWITCH_MODE_CONFIGURABLE == TRUE) */

        default:
            *write_method = 0;
            break;
    }

    /* check compc, retrive compl
     */
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl, PORTENTRY_INSTANCE_LEN);

    memset(&entry, 0, sizeof(entry));

    if (exact) /* get or set */
    {
        if (portTable_OidIndexToData(exact, compc, compl, &entry.port_index) == FALSE)
        {
            return NULL;
        }

        if (SWCTRL_POM_GetPortEntry(&entry) != TRUE)
        {
            return NULL;
        }
    }
    else /* getnext */
    {
        portTable_OidIndexToData(exact, compc, compl, &entry.port_index);

        /* check the length of inputing index,if < 1 we should try get
         * {0.0.0.0.0...}
         */
        if (compc < 1)
        {
            if (SWCTRL_POM_GetPortEntry(&entry) != TRUE)
            {
                if (SWCTRL_POM_GetNextPortEntry(&entry) != TRUE)
                {
                    return NULL;
                }
            }
        }
        else
        {
            if (SWCTRL_POM_GetNextPortEntry(&entry) != TRUE)
            {
                return NULL;
            }
        }
    }

    memcpy(name, vp->name, vp->namelen * sizeof(oid));

    /* assign data to the oid index
     */
    best_inst[0] = entry.port_index;
    memcpy(name + vp->namelen, best_inst, PORTENTRY_INSTANCE_LEN * sizeof(oid));
    *length = vp->namelen + PORTENTRY_INSTANCE_LEN;

    switch (vp->magic)
    {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case LEAF_portIndex:
            *var_len = sizeof(long_return);
            long_return = entry.port_index;
            return (u_char *) &long_return;
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

        case LEAF_portName:
            *var_len = strlen((char *)entry.port_name);
            memcpy(return_buf, entry.port_name, *var_len);
            return (u_char *) return_buf;

        case LEAF_portType:
            *var_len = sizeof(long_return);
            long_return = entry.port_type;
            return (u_char *) &long_return;

        case LEAF_portSpeedDpxCfg:
            *var_len = sizeof(long_return);
            long_return = entry.port_speed_dpx_cfg;
            return (u_char *) &long_return;

        case LEAF_portFlowCtrlCfg:
            *var_len = sizeof(long_return);
            long_return = entry.port_flow_ctrl_cfg;
            return (u_char *) &long_return;

        case LEAF_portCapabilities:
            *var_len = SIZE_portCapabilities;
            long_return = L_STDLIB_Hton32(entry.port_capabilities);
            return (u_char *) &long_return;

        case LEAF_portAutonegotiation:
            *var_len = sizeof(long_return);
            long_return = entry.port_autonegotiation;
            return (u_char *) &long_return;

        case LEAF_portSpeedDpxStatus:
            *var_len = sizeof(long_return);
            long_return = entry.port_speed_dpx_status;
            return (u_char *) &long_return;

        case LEAF_portFlowCtrlStatus:
            *var_len = sizeof(long_return);
            long_return = entry.port_flow_ctrl_status;
            return (u_char *) &long_return;

        case LEAF_portTrunkIndex:
            *var_len = sizeof(long_return);
            long_return = entry.port_trunk_index;
            return (u_char *) &long_return;

#ifdef VS2512A
        case LEAF_portEthernetType:
            *var_len = sizeof(long_return);
            long_return = entry.ethertype;
            return (u_char*) &long_return;
#endif /* #ifdef VS2512A */

#if (SYS_CPNT_COMBO_PORT_FORCE_MODE == TRUE)
        case LEAF_portComboForcedMode:
            *var_len = sizeof(long_return);
            long_return = entry.port_forced_mode;
            return (u_char *) &long_return;
#endif /* #if (SYS_CPNT_COMBO_PORT_FORCE_MODE == TRUE) */

#if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION == TRUE)
#if (SYS_DFLT_TRAFFIC_SEG_METHOD == SYS_DFLT_TRAFFIC_SEG_METHOD_PORT_PRIVATE_MODE)
        case LEAF_portPrivateMode:
            *var_len = sizeof(long_return);
            long_return = entry.port_private_mode;
            return (u_char*) &long_return;
#endif /* #if (SYS_DFLT_TRAFFIC_SEG_METHOD == SYS_DFLT_TRAFFIC_SEG_METHOD_PORT_PRIVATE_MODE) */
#endif /* #if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION == TRUE) */

#if (SYS_CPNT_SWCTRL_MDIX_CONFIG == TRUE)
        case LEAF_portMdixMode:
            *var_len = sizeof(long_return);
            long_return = entry.port_MDIX_mode;
            return (u_char *) &long_return;
#endif /* #if (SYS_CPNT_SWCTRL_MDIX_CONFIG == TRUE) */

#if (SYS_CPNT_SWCTRL_MTU_CONFIG_MODE == SYS_CPNT_SWCTRL_MTU_PER_PORT)
        case LEAF_portMtu:
            *var_len = sizeof(long_return);
            long_return = entry.port_mtu;
            return (u_char *) &long_return;
#endif /* #if (SYS_CPNT_SWCTRL_MTU_CONFIG_MODE == SYS_CPNT_SWCTRL_MTU_PER_PORT) */

#if (SYS_CPNT_AMTR == TRUE)
#if (SYS_CPNT_AMTR_PORT_MAC_LEARNING == TRUE)
        case LEAF_portMacAddrLearningStatus:
            *var_len = sizeof(long_return);
            long_return = (entry.port_macaddr_learning == FALSE) ? VAL_staPortMacAddrLearning_false : VAL_staPortMacAddrLearning_true;
            return (u_char *) &long_return;
#endif

        case LEAF_portMacAddrLearningCount:
            *var_len = sizeof(long_return);
            long_return = AMTR_OM_GetDynCounterByPort(entry.port_index);
            return (u_char *) &long_return;
#endif /* #if (SYS_CPNT_AMTR == TRUE) */

        case LEAF_portUpTime:
            *var_len = sizeof(long_return);
            long_return = entry.uptime;
            return (u_char *) &long_return;

#if (SYS_CPNT_SWCTRL_SWITCH_MODE_CONFIGURABLE == TRUE)
        case LEAF_portSwitchingMode:
            *var_len = sizeof(long_return);
            long_return = entry.switch_mode;
            return (u_char *) &long_return;
#endif

        default:
            ERROR_MSG("");
    }

    return NULL;
}

int write_portName(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_OCTET_STR)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if ((MINSIZE_portName > var_val_len) || (var_val_len > MAXSIZE_portName))
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;

        case RESERVE2:
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            UI8_T byte_buffer[MAXSIZE_portName + 1] = {0};
            UI32_T portIndex = 0;
            UI32_T i;

            if (portTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &portIndex) == FALSE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            memcpy(byte_buffer, var_val, var_val_len);

            byte_buffer[var_val_len] = '\0';

            for (i=0 ; i<var_val_len;i++)
            {
                if (byte_buffer[i]=='?'||byte_buffer[i]==' '||byte_buffer[i]==':')
                    return SNMP_ERR_WRONGVALUE;
            }

            if (SWCTRL_PMGR_SetPortName(portIndex, byte_buffer) != TRUE)
            {
                return SNMP_ERR_COMMITFAILED;
            }
        }
            break;

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

int write_portSpeedDpxCfg(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            switch (*(long *)var_val)
            {
                case VAL_portSpeedDpxCfg_reserved:
                    break;

                case VAL_portSpeedDpxCfg_halfDuplex10:
                    break;

                case VAL_portSpeedDpxCfg_fullDuplex10:
                    break;

                case VAL_portSpeedDpxCfg_halfDuplex100:
                    break;

                case VAL_portSpeedDpxCfg_fullDuplex100:
                    break;

                case VAL_portSpeedDpxCfg_halfDuplex1000:
                    break;

                case VAL_portSpeedDpxCfg_fullDuplex1000:
                    break;

                case VAL_portSpeedDpxCfg_halfDuplex10g:
                    break;

                case VAL_portSpeedDpxCfg_fullDuplex10g:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            I32_T value = 0;
            UI32_T portIndex = 0;

            if (portTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &portIndex) == FALSE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            value = *(long *)var_val;

            if (SWCTRL_PMGR_SetPortSpeedDpxCfg(portIndex, value) != TRUE)
            {
                return SNMP_ERR_COMMITFAILED;
            }
        }
            break;

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

int write_portFlowCtrlCfg(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            switch (*(long *)var_val)
            {
                case VAL_portFlowCtrlCfg_enabled:
                    break;

                case VAL_portFlowCtrlCfg_disabled:
                    break;

                case VAL_portFlowCtrlCfg_tx:
                    break;

                case VAL_portFlowCtrlCfg_rx:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            I32_T value = 0;
            UI32_T portIndex = 0;

            if (portTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &portIndex) == FALSE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            value = *(long *)var_val;

            if (SWCTRL_PMGR_SetPortFlowCtrlCfg(portIndex, value) != TRUE)
            {
                return SNMP_ERR_COMMITFAILED;
            }
        }
            break;

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

int write_portCapabilities(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_OCTET_STR)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > SIZE_portCapabilities)
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;

        case RESERVE2:
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            UI32_T portIndex = 0;
            UI32_T value = 0;

            if (portTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &portIndex) == FALSE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            var_val_len = (var_val_len < SIZE_portCapabilities) ? var_val_len : SIZE_portCapabilities;
            memcpy(&value, var_val, var_val_len);
            value = L_STDLIB_Ntoh32(value);

            if (SWCTRL_PMGR_SetPortCapabilities(portIndex, value) != TRUE)
            {
                return SNMP_ERR_COMMITFAILED;
            }
        }
            break;

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

int write_portAutonegotiation(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            switch (*(long *)var_val)
            {
                case VAL_portAutonegotiation_enabled:
                    break;

                case VAL_portAutonegotiation_disabled:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            I32_T value = 0;
            UI32_T portIndex = 0;

            if (portTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &portIndex) == FALSE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            value = *(long *)var_val;

            if (SWCTRL_PMGR_SetPortAutonegotiation(portIndex, value) != TRUE)
            {
                return SNMP_ERR_COMMITFAILED;
            }
        }
            break;

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

#if (SYS_CPNT_COMBO_PORT_FORCE_MODE == TRUE)
int write_portComboForcedMode(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            switch (*(long *)var_val)
            {
                case VAL_portComboForcedMode_none:
                    break;

                case VAL_portComboForcedMode_copperForced:
                    break;

                case VAL_portComboForcedMode_copperPreferredAuto:
                    break;

                case VAL_portComboForcedMode_sfpForced:
                    break;

                case VAL_portComboForcedMode_sfpPreferredAuto:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            I32_T value = 0;
            UI32_T portIndex = 0;

            if (portTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &portIndex) == FALSE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            value = *(long *)var_val;

#if (SYS_CPNT_COMBO_PORT_FORCED_MODE_SFP_SPEED == TRUE)
            if (SWCTRL_PMGR_SetPortComboForcedMode(portIndex, value, VAL_portType_other) != TRUE)
#else
            if (SWCTRL_PMGR_SetPortComboForcedMode(portIndex, value) != TRUE)
#endif
            {
                return SNMP_ERR_COMMITFAILED;
            }
        }
            break;

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}
#endif /* #if (SYS_CPNT_COMBO_PORT_FORCE_MODE == TRUE) */

#if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION == TRUE)
#if (SYS_DFLT_TRAFFIC_SEG_METHOD == SYS_DFLT_TRAFFIC_SEG_METHOD_PORT_PRIVATE_MODE)
int write_portPrivateMode(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            switch (*(long *)var_val)
            {
                case VAL_portPrivateMode_enabled:
                    break;

                case VAL_portPrivateMode_disabled:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            I32_T value = 0;
            UI32_T portIndex = 0;

            if (portTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &portIndex) == FALSE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            value = *(long *)var_val;

            if (SWCTRL_PMGR_SetPortPrivateMode(portIndex, value) != TRUE)
            {
                return SNMP_ERR_COMMITFAILED;
            }
        }
            break;

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}
#endif /* #if (SYS_DFLT_TRAFFIC_SEG_METHOD == SYS_DFLT_TRAFFIC_SEG_METHOD_PORT_PRIVATE_MODE) */
#endif /* #if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION == TRUE) */

#if (SYS_CPNT_SWCTRL_MDIX_CONFIG == TRUE)
int write_portMdixMode(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            switch (*(long *)var_val)
            {
                case VAL_portMdixMode_auto:
                    break;

                case VAL_portMdixMode_straight:
                    break;

                case VAL_portMdixMode_crossover:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            I32_T value = 0;
            UI32_T portIndex = 0;

            if (portTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &portIndex) == FALSE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            value = *(long *)var_val;

            if (SWCTRL_PMGR_SetMDIXMode(portIndex, value) != TRUE)
            {
                return SNMP_ERR_COMMITFAILED;
            }
        }
            break;

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}
#endif /* #if (SYS_CPNT_SWCTRL_MDIX_CONFIG == TRUE) */

#if (SYS_CPNT_SWCTRL_MTU_CONFIG_MODE == SYS_CPNT_SWCTRL_MTU_PER_PORT)
int write_portMtu(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_UNSIGNED)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            if (SYS_ADPT_IF_MTU > *(u_long *)var_val || *(u_long *)var_val > SYS_ADPT_MAX_JUMBO_MTU)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            UI32_T value = 0;
            UI32_T portIndex = 0;

            if (portTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &portIndex) == FALSE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            value = *(u_long *)var_val;

            if (SWCTRL_PMGR_SetPortMTU(portIndex, value) != TRUE)
            {
                return SNMP_ERR_COMMITFAILED;
            }
        }
            break;

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}
#endif /* #if (SYS_CPNT_SWCTRL_MTU_CONFIG_MODE == SYS_CPNT_SWCTRL_MTU_PER_PORT) */

#if (SYS_CPNT_AMTR_PORT_MAC_LEARNING == TRUE)
int write_portMacAddrLearningStatus(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            switch (*(long *)var_val)
            {
                case VAL_portMacAddrLearningStatus_enabled:
                    break;

                case VAL_portMacAddrLearningStatus_disabled:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            I32_T value = 0;
            UI32_T portIndex = 0;

            if (portTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &portIndex) == FALSE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            value = *(long *)var_val;
            value = (value == VAL_staPortMacAddrLearning_true) ? TRUE : FALSE;

            if (SWCTRL_PMGR_SetPortMACLearningStatus(portIndex, value) != TRUE)
            {
                return SNMP_ERR_COMMITFAILED;
            }
        }
            break;

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}
#endif /* #if (SYS_CPNT_AMTR == TRUE) */

#if (SYS_CPNT_SWCTRL_SWITCH_MODE_CONFIGURABLE == TRUE)
int write_portSwitchingMode(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            switch (*(long *)var_val)
            {
                case VAL_swctrlSwitchModeSF:
                    break;

                case VAL_swctrlSwitchModeCT:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            I32_T value = 0;
            UI32_T portIndex = 0;

            if (portTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &portIndex) == FALSE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            value = *(long *)var_val;

            if (SWCTRL_PMGR_SetSwitchingMode(portIndex, value) != TRUE)
            {
                return SNMP_ERR_COMMITFAILED;
            }
        }
            break;

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}
#endif /*#if (SYS_CPNT_SWCTRL_SWITCH_MODE_CONFIGURABLE == TRUE)*/

/* Cable Diagnostics */
#if (SYS_CPNT_SWCTRL_CABLE_DIAG == TRUE)
int
do_cableDiagCtlAction(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{

    switch(reqinfo->mode) {
        case MODE_GET:
        {
            long_return = 0;
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
        }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:

            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
            }

            break;
        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
        {
            SWCTRL_Cable_Info_T result;
            memset(&result, 0, sizeof(SWCTRL_Cable_Info_T));

            if (SWCTRL_PMGR_ExecuteCableDiag(*requests->requestvb->val.integer, &result)!=TRUE)
            {
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
            }
        }
            break;

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

#define CABLEDIAGRESULTENTRY_INSTANCE_LEN  1

static UI32_T cableDiagResultConvert(UI32_T core_status)
{
    switch(core_status)
    {
#if (SYS_CPNT_SWCTRL_CABLE_DIAG_CHIP == SYS_CPNT_SWCTRL_CABLE_DIAG_BROADCOM)
        case CABLE_NOT_TESTED_YET:
            return VAL_cableDiagResultStatus_notTestedYet;
#endif /* #if (SYS_CPNT_SWCTRL_CABLE_DIAG_CHIP == SYS_CPNT_SWCTRL_CABLE_DIAG_BROADCOM) */

#if (SYS_CPNT_SWCTRL_CABLE_DIAG_CHIP == SYS_CPNT_SWCTRL_CABLE_DIAG_MARVELL)
        case CABLE_NOT_TEST_BEFORE:
            return VAL_cableDiagResultStatus_notTestedYet;
#endif /* #if (SYS_CPNT_SWCTRL_CABLE_DIAG_CHIP == SYS_CPNT_SWCTRL_CABLE_DIAG_MARVELL) */

        case CABLE_NORMAL_CABLE:
            return VAL_cableDiagResultStatus_ok;

        case CABLE_OPEN_CABLE:
            return VAL_cableDiagResultStatus_open;

        case CABLE_SHORT_CABLE:
            return VAL_cableDiagResultStatus_short;

#if (SYS_CPNT_SWCTRL_CABLE_DIAG_CHIP == SYS_CPNT_SWCTRL_CABLE_DIAG_BROADCOM)
        case CABLE_OPEN_SHORT_CABLE:
            return VAL_cableDiagResultStatus_openShort;

        case CABLE_CROSSTALK_CABLE:
            return VAL_cableDiagResultStatus_crosstalk;

        case CABLE_UNKNOWN_CABLE:
            return VAL_cableDiagResultStatus_unknown;
#endif /* #if (SYS_CPNT_SWCTRL_CABLE_DIAG_CHIP == SYS_CPNT_SWCTRL_CABLE_DIAG_BROADCOM) */

#if (SYS_CPNT_SWCTRL_CABLE_DIAG_CHIP == SYS_CPNT_SWCTRL_CABLE_DIAG_MARVELL)
        case CABLE_IMPEDANCE_MISMATCH:
            return VAL_cableDiagResultStatus_impedanceMismatch;

        case CABLE_TEST_FAIL:
            return VAL_cableDiagResultStatus_fail;

        case CABLE_DIAG_NOT_SUPPORTED:
            return VAL_cableDiagResultStatus_notSupport;

        case CABLE_NO_CABLE:
            return VAL_cableDiagResultStatus_noCable;
#endif /* #if (SYS_CPNT_SWCTRL_CABLE_DIAG_CHIP == SYS_CPNT_SWCTRL_CABLE_DIAG_MARVELL) */

        default:
            return VAL_cableDiagResultStatus_unknown;
    }
}

BOOL_T cableDiagResultTable_OidIndexToData(UI32_T exact, UI32_T compc,
            oid * compl,  UI32_T *cableDiagResultIfIndex)
{
    /* get or write */
    if (exact)
    {
        /* check the index length */
        if (compc != CABLEDIAGRESULTENTRY_INSTANCE_LEN) /* the constant size index */
        {
            return FALSE;
        }
    }
    *cableDiagResultIfIndex = compl[0];
    return TRUE;
}

/*
 * var_cableDiagResultTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *
var_cableDiagResultTable(struct variable *vp,
            oid     *name,
            size_t  *length,
            int     exact,
            size_t  *var_len,
            WriteMethod **write_method)
{
    /* variables we may use later */
    UI32_T compc = 0;
    oid compl[CABLEDIAGRESULTENTRY_INSTANCE_LEN] = {0};
    oid best_inst[CABLEDIAGRESULTENTRY_INSTANCE_LEN] = {0};
    SWCTRL_Cable_Info_T  result;
    UI32_T  ifIndex;

    switch (vp->magic)
    {
        default:
            *write_method = 0;
            break;
    }

    /* check compc, retrive compl */
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,
                           compl, CABLEDIAGRESULTENTRY_INSTANCE_LEN);

    memset(&result, 0, sizeof(SWCTRL_Cable_Info_T));

    if (exact) /* get,set */
    {
        /* get index */
        if (cableDiagResultTable_OidIndexToData(exact, compc, compl,  &ifIndex) == FALSE)
        {
            return NULL;
        }

        /* get data */
        if (SWCTRL_POM_GetCableDiagResult(ifIndex, &result) != TRUE)
        {
            return NULL;
        }
    }
    else /* getnext */
    {
        /* get index */
        cableDiagResultTable_OidIndexToData(exact, compc, compl,  &ifIndex);

        /* check the length of inputing index,if < 1 we should try get
         * {0.0.0.0.0...}
         */
        if (compc < 1)
        {
            /* get data */
            if (SWCTRL_POM_GetCableDiagResult(ifIndex, &result) != TRUE)
            {
                /* get next data */
                if (SWCTRL_POM_GetNextCableDiagResult(&ifIndex, &result) != TRUE)
                {
                    return NULL;
                }
            }
        }
        else
        {
            /* get next data */
            if (SWCTRL_POM_GetNextCableDiagResult(&ifIndex, &result) != TRUE)
            {
                return NULL;
            }
        }
    }

    memcpy(name, vp->name, vp->namelen*sizeof(oid));

    /* assign data to the oid index */
    best_inst[0] = ifIndex;
    memcpy(name + vp->namelen, best_inst,
           CABLEDIAGRESULTENTRY_INSTANCE_LEN * sizeof(oid));
    *length = vp->namelen + CABLEDIAGRESULTENTRY_INSTANCE_LEN ;

    /* this is where we do the value assignments for the mib results. */
    switch (vp->magic)
    {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case LEAF_cableDiagResultIfIndex:
            *var_len = sizeof(long_return);
            long_return = ifIndex;
            return (u_char *) &long_return;
#endif

        case LEAF_cableDiagResultStatusPairA:
            *var_len = sizeof(long_return);
            long_return = 0;

#if (SYS_CPNT_SWCTRL_CABLE_DIAG_CHIP == SYS_CPNT_SWCTRL_CABLE_DIAG_BROADCOM)
            long_return = cableDiagResultConvert(result.pair_state[0]);
#elif (SYS_CPNT_SWCTRL_CABLE_DIAG_CHIP == SYS_CPNT_SWCTRL_CABLE_DIAG_MARVELL)
            long_return = cableDiagResultConvert(result.pair1Status);
#endif /* #if (SYS_CPNT_SWCTRL_CABLE_DIAG_CHIP == SYS_CPNT_SWCTRL_CABLE_DIAG_BROADCOM) */

            return (u_char *) &long_return;

        case LEAF_cableDiagResultStatusPairB:
            *var_len = sizeof(long_return);
            long_return = 0;

#if (SYS_CPNT_SWCTRL_CABLE_DIAG_CHIP == SYS_CPNT_SWCTRL_CABLE_DIAG_BROADCOM)
            long_return = cableDiagResultConvert(result.pair_state[1]);
#elif (SYS_CPNT_SWCTRL_CABLE_DIAG_CHIP == SYS_CPNT_SWCTRL_CABLE_DIAG_MARVELL)
            long_return = cableDiagResultConvert(result.pair2Status);
#endif /* #if (SYS_CPNT_SWCTRL_CABLE_DIAG_CHIP == SYS_CPNT_SWCTRL_CABLE_DIAG_BROADCOM) */
            return (u_char *) &long_return;

#if (SYS_CPNT_SWCTRL_CABLE_DIAG_CHIP == SYS_CPNT_SWCTRL_CABLE_DIAG_BROADCOM)
        case LEAF_cableDiagResultStatusPairC:
            *var_len = sizeof(long_return);
            long_return = cableDiagResultConvert( result.pair_state[2]);
            return (u_char *) &long_return;

        case LEAF_cableDiagResultStatusPairD:
            *var_len = sizeof(long_return);
            long_return = cableDiagResultConvert( result.pair_state[3]);
            return (u_char *) &long_return;
#endif /* #if (SYS_CPNT_SWCTRL_CABLE_DIAG_CHIP == SYS_CPNT_SWCTRL_CABLE_DIAG_BROADCOM) */

        case LEAF_cableDiagResultDistancePairA:
            *var_len = sizeof(long_return);
            long_return = 0;

#if (SYS_CPNT_SWCTRL_CABLE_DIAG_CHIP == SYS_CPNT_SWCTRL_CABLE_DIAG_BROADCOM)
            long_return = result.pair_len[0];
#elif (SYS_CPNT_SWCTRL_CABLE_DIAG_CHIP == SYS_CPNT_SWCTRL_CABLE_DIAG_MARVELL)
            long_return = result.pair1FaultLen;
#endif /* #if (SYS_CPNT_SWCTRL_CABLE_DIAG_CHIP == SYS_CPNT_SWCTRL_CABLE_DIAG_BROADCOM) */
            return (u_char *) &long_return;

        case LEAF_cableDiagResultDistancePairB:
            *var_len = sizeof(long_return);
            long_return = 0;

#if (SYS_CPNT_SWCTRL_CABLE_DIAG_CHIP == SYS_CPNT_SWCTRL_CABLE_DIAG_BROADCOM)
            long_return = result.pair_len[1];
#elif (SYS_CPNT_SWCTRL_CABLE_DIAG_CHIP == SYS_CPNT_SWCTRL_CABLE_DIAG_MARVELL)
            long_return = result.pair2FaultLen;
#endif /* #if (SYS_CPNT_SWCTRL_CABLE_DIAG_CHIP == SYS_CPNT_SWCTRL_CABLE_DIAG_BROADCOM) */
            return (u_char *) &long_return;

#if (SYS_CPNT_SWCTRL_CABLE_DIAG_CHIP == SYS_CPNT_SWCTRL_CABLE_DIAG_BROADCOM)
        case LEAF_cableDiagResultDistancePairC:
            *var_len = sizeof(long_return);
            long_return = result.pair_len[2];
            return (u_char *) &long_return;

        case LEAF_cableDiagResultDistancePairD:
            *var_len = sizeof(long_return);
            long_return = result.pair_len[3];
            return (u_char *) &long_return;

        case LEAF_cableDiagResultDistanceAccuracy:
            *var_len = sizeof(long_return);
            long_return = result.fuzz_len;
            return (u_char *) &long_return;
#endif /* #if (SYS_CPNT_SWCTRL_CABLE_DIAG_CHIP == SYS_CPNT_SWCTRL_CABLE_DIAG_BROADCOM) */

        case LEAF_cableDiagResultTime:
            {
                char buffer[SIZE_sysCurrentTime+1];

                if (!SYS_TIME_ConvertTime(result.last_test_time, buffer))
                {
                       return NULL; // SNMP_ERR_GENERR;
                }
                            /* shumin.wang modified for ES4827G-FLF-ZZ-00192 */
                            *var_len = strlen(buffer);
                strcpy((char *)return_buf, buffer);
            }
            return (u_char*)return_buf;

        default:
            ERROR_MSG("");
    }

    return NULL;
}

#endif /* #if (SYS_CPNT_SWCTRL_CABLE_DIAG == TRUE) */

#if (SYS_CPNT_INTERNAL_LOOPBACK_TEST == TRUE)
int
do_loopInternalCtlAction(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{

    switch(reqinfo->mode) {
        case MODE_GET:
        {
            long_return = 0;
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
        }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:

            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
            }

            break;
        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
        {
            SWCTRL_PMGR_ExecuteInternalLoopBackTest(*requests->requestvb->val.integer);
/*
            if (SWCTRL_PMGR_ExecuteInternalLoopBackTest(*requests->requestvb->val.integer)!=TRUE)
            {
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
            }
*/        }
            break;

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

#define LOOPINTERNALRESULTENTRY_INSTANCE_LEN  1

BOOL_T loopInternalResultTable_OidIndexToData(UI32_T exact, UI32_T compc,
            oid * compl,  UI32_T *loopInternalResultIfIndex)
{
    /* get or write */
    if (exact)
    {
        /* check the index length */
        if (compc != LOOPINTERNALRESULTENTRY_INSTANCE_LEN) /* the constant size index */
        {
            return FALSE;
        }
    }

    *loopInternalResultIfIndex = compl[0];

    return TRUE;
}

/*
 * var_loopInternalResultTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *
var_loopInternalResultTable(struct variable *vp,
            oid     *name,
            size_t  *length,
            int     exact,
            size_t  *var_len,
            WriteMethod **write_method)
{
    /* variables we may use later */
    UI32_T compc = 0;
    oid compl[LOOPINTERNALRESULTENTRY_INSTANCE_LEN] = {0};
    oid best_inst[LOOPINTERNALRESULTENTRY_INSTANCE_LEN] = {0};
    UI32_T lport;
    UI32_T result;
    UI32_T result_time;

    switch (vp->magic)
    {
        default:
            *write_method = 0;
            break;
    }

    /* check compc, retrive compl */
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,
                           compl, LOOPINTERNALRESULTENTRY_INSTANCE_LEN);

    if (exact) /* get,set */
    {
        /* get index */
        if (loopInternalResultTable_OidIndexToData(exact, compc, compl, &lport) == FALSE)
        {
            return NULL;
        }

        /* get data */
        if (SWCTRL_POM_GetInternalLoopbackTestResult( lport, &result, &result_time)!= TRUE)
        {
            return NULL;
        }
    }
    else /* getnext */
    {
        /* get index */
        loopInternalResultTable_OidIndexToData(exact, compc, compl, &lport);

        /* check the length of inputing index,if < 1 we should try get
         * {0.0.0.0.0...}
         */
        if (compc < 1)
        {
            /* get data */
            if (SWCTRL_POM_GetInternalLoopbackTestResult( lport, &result, &result_time)!= TRUE)
            {
                /* get next data */
                if (SWCTRL_POM_GetNextInternalLoopbackTestResult( &lport, &result, &result_time)!= TRUE)
                {
                    return NULL;
                }
            }
        }
        else
        {
            /* get next data */
            if (SWCTRL_POM_GetNextInternalLoopbackTestResult( &lport, &result, &result_time)!= TRUE)
            {
                return NULL;
            }
        }
    }

    memcpy(name, vp->name, vp->namelen*sizeof(oid));

    /* assign data to the oid index */
    best_inst[0] = lport;
    memcpy(name + vp->namelen, best_inst,
           LOOPINTERNALRESULTENTRY_INSTANCE_LEN * sizeof(oid));
    *length = vp->namelen + LOOPINTERNALRESULTENTRY_INSTANCE_LEN ;

    /* this is where we do the value assignments for the mib results. */
    switch (vp->magic)
    {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case LEAF_loopInternalResultIfIndex:
            *var_len = sizeof(long_return);
            long_return = lport;
            return (u_char *) &long_return;

#endif
        case LEAF_loopInternalResultStatus:
            *var_len = sizeof(long_return);
            long_return = result;
            return (u_char *) &long_return;

        case LEAF_loopInternalResultTime:
            {
                char buffer[SIZE_sysCurrentTime+1];

                if (!SYS_TIME_ConvertTime(result_time, buffer))
                {
                       return NULL; // SNMP_ERR_GENERR;
                }
                /* shumin.wang modified for ES4827G-FLF-ZZ-00192 */
                *var_len = strlen(buffer);
                strcpy((char *)return_buf, buffer);
            }
            return (u_char*)return_buf;

        default:
            ERROR_MSG("");
    }

    return NULL;
}
#endif /* end of #if (SYS_CPNT_INTERNAL_LOOPBACK_TEST == TRUE) */

/*portUtilTable*/
#define PORTUTILENTRY_INSTANCE_LEN  1

BOOL_T portUtilTable_OidIndexToData(UI32_T exact, UI32_T compc,
            oid * compl,  UI32_T *portUtilIfIndex)
{
    /* get or write */
    if (exact)
    {
        /* check the index length */
        if (compc != PORTUTILENTRY_INSTANCE_LEN) /* the constant size index */
        {
            return FALSE;
        }
    }

    *portUtilIfIndex = compl[0];

    return TRUE;
}

/*
 * var_portUtilTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *
var_portUtilTable(struct variable *vp,
            oid     *name,
            size_t  *length,
            int     exact,
            size_t  *var_len,
            WriteMethod **write_method)
{
    /* variables we may use later */
    UI32_T compc = 0,portUtilIfIndex;
    UI64_T temp=0;
    oid compl[PORTUTILENTRY_INSTANCE_LEN] = {0};
    oid best_inst[PORTUTILENTRY_INSTANCE_LEN] = {0};
    NMTR_MGR_Utilization_300_SECS_T entry;

    switch (vp->magic)
    {
        default:
            *write_method = 0;
            break;
    }

    /* check compc, retrive compl */
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,
                           compl, PORTUTILENTRY_INSTANCE_LEN);

    memset(&entry, 0, sizeof(entry));

    if (exact) /* get,set */
    {
        /* get index */
        if (portUtilTable_OidIndexToData(exact, compc, compl,  &portUtilIfIndex) == FALSE)
        {
            return NULL;
        }

        /* get data */
        if (NMTR_PMGR_GetPortUtilization300secs(portUtilIfIndex,&entry) != TRUE)
        {
            return NULL;
        }
    }
    else /* getnext */
    {
        /* get index */
        portUtilTable_OidIndexToData(exact, compc, compl,  &portUtilIfIndex);

        /* check the length of inputing index,if < 1 we should try get
         * {0.0.0.0.0...}
         */
        if (compc < 1)
        {
            /* get data */
            if (NMTR_PMGR_GetPortUtilization300secs(portUtilIfIndex,&entry) != TRUE)
            {
                /* get next data */
                if (NMTR_PMGR_GetNextPortUtilization300secs(&portUtilIfIndex,&entry) != TRUE)
                {
                    return NULL;
                }
            }
        }
        else
        {
            /* get next data */
            if (NMTR_PMGR_GetNextPortUtilization300secs(&portUtilIfIndex,&entry) != TRUE)
            {
                return NULL;
            }
        }
    }

    memcpy(name, vp->name, vp->namelen*sizeof(oid));

    /* assign data to the oid index */
    best_inst[0] = portUtilIfIndex;
    memcpy(name + vp->namelen, best_inst,
           PORTUTILENTRY_INSTANCE_LEN * sizeof(oid));
    *length = vp->namelen + PORTUTILENTRY_INSTANCE_LEN ;

    /* this is where we do the value assignments for the mib results. */
    switch (vp->magic)
    {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case LEAF_portUtilIfIndex:
            *var_len = sizeof(long_return);
            long_return = portUtilIfIndex;
            return (u_char *) &long_return;

#endif
        case LEAF_portInOctetRate:
            temp= entry.ifInOctets / (1000 / 8);
            SNMP_MGR_UI64_T_TO_COUNTER64(long64_return, temp);
            *var_len = sizeof(long64_return);
            return (u_char*) &long64_return;

        case LEAF_portInPacketRate:
            SNMP_MGR_UI64_T_TO_COUNTER64(long64_return, entry.ifInPackets);
            *var_len = sizeof(long64_return);
            return (u_char*) &long64_return;

        case LEAF_portInUtil:
            *var_len = sizeof(long_return);
            long_return = entry.ifInOctets_utilization;
            return (u_char *) &long_return;

        case LEAF_portOutOctetRate:
            temp= entry.ifOutOctets / (1000 / 8);
            SNMP_MGR_UI64_T_TO_COUNTER64(long64_return, temp);
            *var_len = sizeof(long64_return);
            return (u_char*) &long64_return;

        case LEAF_portOutPacketRate:
            SNMP_MGR_UI64_T_TO_COUNTER64(long64_return, entry.ifOutPackets);
            *var_len = sizeof(long64_return);
            return (u_char*) &long64_return;

        case LEAF_portOutUtil:
            *var_len = sizeof(long_return);
            long_return = entry.ifOutOctets_utilization;
            return (u_char *) &long_return;

        default:
            ERROR_MSG("");
    }

    return NULL;
}

#if (SYS_CPNT_NMTR_HISTORY == TRUE)
/***** portHistControlTable *****/
#define PORTHISTCONTROLENTRY_INSTANCE_LEN  1

BOOL_T portHistControlTable_OidIndexToData(UI32_T exact, UI32_T compc,
                                            oid* compl, UI32_T *portHistControlIndex)
{
    /* get or write */
    if (exact)
    {
        /* check the index length */
        if (compc != PORTHISTCONTROLENTRY_INSTANCE_LEN) /* the constant size index */
        {
            return FALSE;
        }
    }

    *portHistControlIndex = compl[0];

    return TRUE;
}

/*
 * var_portHistControlTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char*
var_portHistControlTable(struct variable *vp,
                          oid     *name,
                          size_t  *length,
                          int exact,
                          size_t  *var_len,
                          WriteMethod **write_method)
{
    /* variables we may use later */
    UI32_T compc = 0;
    oid compl[PORTHISTCONTROLENTRY_INSTANCE_LEN] = {0};
    oid best_inst[PORTHISTCONTROLENTRY_INSTANCE_LEN] = {0};
    NMTR_TYPE_HistCtrlInfo_T entry;

    switch (vp->magic)
    {
        case LEAF_portHistControlName:
            *write_method = write_portHistControlName;
            break;

        case LEAF_portHistControlDataSource:
            *write_method = write_portHistControlDataSource;
            break;

        case LEAF_portHistControlInterval:
            *write_method = write_portHistControlInterval;
            break;

        case LEAF_portHistControlBucketsRequested:
            *write_method = write_portHistControlBucketsRequested;
            break;

        case LEAF_portHistControlStatus:
            *write_method = write_portHistControlStatus;
            break;

        default:
            *write_method = 0;
            break;
    }

    /* check compc, retrive compl */
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,
                           compl, PORTHISTCONTROLENTRY_INSTANCE_LEN);

    memset(&entry, 0, sizeof(entry));
    if (exact) /* get,set */
    {
        /* get index */
        if (portHistControlTable_OidIndexToData(exact, compc, compl, &entry.ctrl_idx) == FALSE)
        {
            return NULL;
        }
        /* get data */
        if (!NMTR_PMGR_GetHistoryCtrlEntry(&entry, FALSE))
        {
            return NULL;
        }
    }
    else /* getnext */
    {
        /* get index */
        portHistControlTable_OidIndexToData(exact, compc, compl, &entry.ctrl_idx);
        /* check the length of inputing index,if < 1 we should try get
         * {0.0.0.0.0...}
         */
        if (compc < 1)
        {
            /* get data */
            if (!NMTR_PMGR_GetHistoryCtrlEntry(&entry, FALSE))
            {
                /* get next data */
                if (!NMTR_PMGR_GetHistoryCtrlEntry(&entry, TRUE))
                {
                    return NULL;
                }
            }
        }
        else
        {
            /* get next data */
            if (!NMTR_PMGR_GetHistoryCtrlEntry(&entry, TRUE))
            {
                return NULL;
            }
        }
    }

    memcpy(name, vp->name, vp->namelen * sizeof(oid));

    /* assign data to the oid index */
    best_inst[0] = entry.ctrl_idx;
    memcpy(name + vp->namelen, best_inst, PORTHISTCONTROLENTRY_INSTANCE_LEN * sizeof(oid));
    *length = vp->namelen + PORTHISTCONTROLENTRY_INSTANCE_LEN ;

    /* this is where we do the value assignments for the mib results. */
    switch (vp->magic)
    {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case LEAF_portHistControlIndex:
            *var_len = sizeof(long_return);
            long_return = entry.ctrl_idx;
            return (u_char*) &long_return;
#endif

        case LEAF_portHistControlName:
            *var_len = strlen((char *)entry.name);
            memcpy(return_buf, entry.name, *var_len);
            return (u_char *) return_buf;

        case LEAF_portHistControlDataSource:
            *var_len = sizeof(long_return);
            long_return = entry.data_source;
            return (u_char*) &long_return;

        case LEAF_portHistControlInterval:
            *var_len = sizeof(long_return);
            long_return = entry.interval;
            return (u_char*) &long_return;

        case LEAF_portHistControlBucketsRequested:
            *var_len = sizeof(long_return);
            long_return = entry.buckets_requested;
            return (u_char*) &long_return;

        case LEAF_portHistControlBucketsGranted:
            *var_len = sizeof(long_return);
            long_return = entry.buckets_granted;
            return (u_char*) &long_return;

        case LEAF_portHistControlStatus:
            *var_len = sizeof(long_return);
            long_return = entry.status;
            return (u_char*) &long_return;

        default :
            ERROR_MSG("");
    }

    return NULL;
}

int
write_portHistControlName(int action,
                             u_char   *var_val,
                             u_char var_val_type,
                             size_t var_val_len,
                             u_char   *statP,
                             oid      *name,
                             size_t name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_OCTET_STR)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len < sizeof(char)*NMTR_TYPE_HIST_CTRL_NAME_LEN_MIN ||
                var_val_len > sizeof(char)*NMTR_TYPE_HIST_CTRL_NAME_LEN_MAX)
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;

        case RESERVE2:
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
            UI32_T ctrl_idx = 0;
            char ctrl_name[NMTR_TYPE_HIST_CTRL_NAME_LEN_MAX+1];

            if (portHistControlTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &ctrl_idx) == FALSE)
                return SNMP_ERR_COMMITFAILED;

            memcpy(ctrl_name, var_val, var_val_len);
            ctrl_name[var_val_len] = 0;
            if (!NMTR_PMGR_SetHistoryCtrlEntryField(ctrl_idx, NMTR_TYPE_HIST_CTRL_FIELD_NAME, ctrl_name))
                return SNMP_ERR_COMMITFAILED;

            break;
        }

        case UNDO :
            break;

        case COMMIT :
            break;
    }

    return SNMP_ERR_NOERROR;
}

int
write_portHistControlDataSource(int action,
                             u_char   *var_val,
                             u_char var_val_type,
                             size_t var_val_len,
                             u_char   *statP,
                             oid      *name,
                             size_t name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            if ((*(long *)var_val < NMTR_TYPE_HIST_CTRL_DATA_SOURCE_MIN) ||
                (*(long *)var_val > NMTR_TYPE_HIST_CTRL_DATA_SOURCE_MAX))
               return SNMP_ERR_WRONGVALUE;
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
            I32_T value = 0;
            UI32_T ctrl_idx = 0;

            if (portHistControlTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &ctrl_idx) == FALSE)
                return SNMP_ERR_COMMITFAILED;

            value = *(long *)var_val;
            if (!NMTR_PMGR_SetHistoryCtrlEntryField(ctrl_idx, NMTR_TYPE_HIST_CTRL_FIELD_DATA_SOURCE, (void *)(uintptr_t)value))
                return SNMP_ERR_COMMITFAILED;

            break;
        }

        case UNDO :
            break;

        case COMMIT :
            break;
    }

    return SNMP_ERR_NOERROR;
}

int
write_portHistControlInterval(int action,
                             u_char   *var_val,
                             u_char var_val_type,
                             size_t var_val_len,
                             u_char   *statP,
                             oid      *name,
                             size_t name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            if ((*(long *)var_val < NMTR_TYPE_HIST_CTRL_INTERVAL_MIN) ||
                (*(long *)var_val > NMTR_TYPE_HIST_CTRL_INTERVAL_MAX))
               return SNMP_ERR_WRONGVALUE;
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
            I32_T value = 0;
            UI32_T ctrl_idx = 0;

            if (portHistControlTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &ctrl_idx) == FALSE)
                return SNMP_ERR_COMMITFAILED;

            value = *(long *)var_val;
            if (!NMTR_PMGR_SetHistoryCtrlEntryField(ctrl_idx, NMTR_TYPE_HIST_CTRL_FIELD_INTERVAL, (void *)(uintptr_t)value))
                return SNMP_ERR_COMMITFAILED;

            break;
        }

        case UNDO :
            break;

        case COMMIT :
            break;
    }

    return SNMP_ERR_NOERROR;
}

int
write_portHistControlBucketsRequested(int action,
                             u_char   *var_val,
                             u_char var_val_type,
                             size_t var_val_len,
                             u_char   *statP,
                             oid      *name,
                             size_t name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            if ((*(long *)var_val < NMTR_TYPE_HIST_CTRL_BUCKETS_MIN) ||
                (*(long *)var_val > NMTR_TYPE_HIST_CTRL_BUCKETS_MAX))
               return SNMP_ERR_WRONGVALUE;
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
            I32_T value = 0;
            UI32_T ctrl_idx = 0;

            if (portHistControlTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &ctrl_idx) == FALSE)
                return SNMP_ERR_COMMITFAILED;

            value = *(long *)var_val;
            if (!NMTR_PMGR_SetHistoryCtrlEntryField(ctrl_idx, NMTR_TYPE_HIST_CTRL_FIELD_BUCKETS_REQUESTED, (void *)(uintptr_t)value))
                return SNMP_ERR_COMMITFAILED;

            break;
        }

        case UNDO :
            break;

        case COMMIT :
            break;
    }

    return SNMP_ERR_NOERROR;
}

int
write_portHistControlStatus(int action,
                             u_char   *var_val,
                             u_char var_val_type,
                             size_t var_val_len,
                             u_char   *statP,
                             oid      *name,
                             size_t name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            switch (*(long *)var_val)
            {
                case VAL_portHistControlStatus_active:
                    break;

                case VAL_portHistControlStatus_notInService:
                    break;

                case VAL_portHistControlStatus_notReady:
                    break;

                case VAL_portHistControlStatus_createAndGo:
                    break;

                case VAL_portHistControlStatus_createAndWait:
                    break;

                case VAL_portHistControlStatus_destroy:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
            I32_T value = 0;
            UI32_T ctrl_idx = 0;

            if (portHistControlTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &ctrl_idx) == FALSE)
                return SNMP_ERR_COMMITFAILED;

            value = *(long *)var_val;
            if (!NMTR_PMGR_SetHistoryCtrlEntryField(ctrl_idx, NMTR_TYPE_HIST_CTRL_FIELD_STATUS, (void *)(uintptr_t)value))
                return SNMP_ERR_COMMITFAILED;

            break;
        }

        case UNDO :
            break;

        case COMMIT :
            break;
    }

    return SNMP_ERR_NOERROR;
}

/***** portHistCurrentTable *****/
#define PORTHISTCURRENTENTRY_INSTANCE_LEN  1

BOOL_T portHistCurrentTable_OidIndexToData(UI32_T exact, UI32_T compc,
                                            oid* compl, UI32_T *portHistCurrentIndex)
{
    /* get or write */
    if (exact)
    {
        /* check the index length */
        if (compc != PORTHISTCURRENTENTRY_INSTANCE_LEN) /* the constant size index */
        {
            return FALSE;
        }
    }

    *portHistCurrentIndex = compl[0];

    return TRUE;
}

/*
 * var_portHistCurrentTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char*
var_portHistCurrentTable(struct variable *vp,
                          oid     *name,
                          size_t  *length,
                          int exact,
                          size_t  *var_len,
                          WriteMethod **write_method)
{
    /* variables we may use later */
    UI32_T compc = 0;
    oid compl[PORTHISTCURRENTENTRY_INSTANCE_LEN] = {0};
    oid best_inst[PORTHISTCURRENTENTRY_INSTANCE_LEN] = {0};
    NMTR_TYPE_HistSampleEntry_T entry;

    switch (vp->magic)
    {
        default:
            *write_method = 0;
            break;
    }

    /* check compc, retrive compl */
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,
                           compl, PORTHISTCURRENTENTRY_INSTANCE_LEN);

    memset(&entry, 0, sizeof(entry));
    if (exact) /* get,set */
    {
        /* get index */
        if (portHistCurrentTable_OidIndexToData(exact, compc, compl, &entry.ctrl_idx) == FALSE)
        {
            return NULL;
        }
        /* get data */
        if (!NMTR_PMGR_GetHistoryCurrentEntry(&entry, FALSE))
        {
            return NULL;
        }
    }
    else /* getnext */
    {
        /* get index */
        portHistCurrentTable_OidIndexToData(exact, compc, compl, &entry.ctrl_idx);
        /* check the length of inputing index,if < 1 we should try get
         * {0.0.0.0.0...}
         */
        if (compc < 1)
        {
            /* get data */
            if (!NMTR_PMGR_GetHistoryCurrentEntry(&entry, FALSE))
            {
                /* get next data */
                if (!NMTR_PMGR_GetHistoryCurrentEntry(&entry, TRUE))
                {
                    return NULL;
                }
            }
        }
        else
        {
            /* get next data */
            if (!NMTR_PMGR_GetHistoryCurrentEntry(&entry, TRUE))
            {
                return NULL;
            }
        }
    }

    memcpy(name, vp->name, vp->namelen * sizeof(oid));

    /* assign data to the oid index */
    best_inst[0] = entry.ctrl_idx;
    memcpy(name + vp->namelen, best_inst, PORTHISTCURRENTENTRY_INSTANCE_LEN * sizeof(oid));
    *length = vp->namelen + PORTHISTCURRENTENTRY_INSTANCE_LEN ;

    /* this is where we do the value assignments for the mib results. */
    switch (vp->magic)
    {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case LEAF_portHistCurrentIndex:
            *var_len = sizeof(long_return);
            long_return = entry.ctrl_idx;
            return (u_char*) &long_return;
#endif

        case LEAF_portHistCurrentSampleIndex:
            *var_len = sizeof(long_return);
            long_return = entry.sample_idx;
            return (u_char*) &long_return;

        case LEAF_portHistCurrentIntervalStart:
            *var_len = sizeof(long_return);
            long_return = entry.counter.start_time;
            return (u_char*) &long_return;

        case LEAF_portHistCurrentInOctets:
            SNMP_MGR_UI64_T_TO_COUNTER64(long64_return, entry.counter.ifInOctets);
            *var_len = sizeof(long64_return);
            return (u_char*) &long64_return;

        case LEAF_portHistCurrentInUcastPkts:
            SNMP_MGR_UI64_T_TO_COUNTER64(long64_return, entry.counter.ifInUcastPkts);
            *var_len = sizeof(long64_return);
            return (u_char*) &long64_return;

        case LEAF_portHistCurrentInMulticastPkts:
            SNMP_MGR_UI64_T_TO_COUNTER64(long64_return, entry.counter.ifInMulticastPkts);
            *var_len = sizeof(long64_return);
            return (u_char*) &long64_return;

        case LEAF_portHistCurrentInBroadcastPkts:
            SNMP_MGR_UI64_T_TO_COUNTER64(long64_return, entry.counter.ifInBroadcastPkts);
            *var_len = sizeof(long64_return);
            return (u_char*) &long64_return;

        case LEAF_portHistCurrentInDiscards:
            SNMP_MGR_UI64_T_TO_COUNTER64(long64_return, entry.counter.ifInDiscards);
            *var_len = sizeof(long64_return);
            return (u_char*) &long64_return;

        case LEAF_portHistCurrentInErrors:
            SNMP_MGR_UI64_T_TO_COUNTER64(long64_return, entry.counter.ifInErrors);
            *var_len = sizeof(long64_return);
            return (u_char*) &long64_return;

        case LEAF_portHistCurrentInUnknownProtos:
            SNMP_MGR_UI64_T_TO_COUNTER64(long64_return, entry.counter.ifInUnknownProtos);
            *var_len = sizeof(long64_return);
            return (u_char*) &long64_return;

        case LEAF_portHistCurrentOutOctets:
            SNMP_MGR_UI64_T_TO_COUNTER64(long64_return, entry.counter.ifOutOctets);
            *var_len = sizeof(long64_return);
            return (u_char*) &long64_return;

        case LEAF_portHistCurrentOutUcastPkts:
            SNMP_MGR_UI64_T_TO_COUNTER64(long64_return, entry.counter.ifOutUcastPkts);
            *var_len = sizeof(long64_return);
            return (u_char*) &long64_return;

        case LEAF_portHistCurrentOutMulticastPkts:
            SNMP_MGR_UI64_T_TO_COUNTER64(long64_return, entry.counter.ifOutMulticastPkts);
            *var_len = sizeof(long64_return);
            return (u_char*) &long64_return;

        case LEAF_portHistCurrentOutBroadcastPkts:
            SNMP_MGR_UI64_T_TO_COUNTER64(long64_return, entry.counter.ifOutBroadcastPkts);
            *var_len = sizeof(long64_return);
            return (u_char*) &long64_return;

        case LEAF_portHistCurrentOutDiscards:
            SNMP_MGR_UI64_T_TO_COUNTER64(long64_return, entry.counter.ifOutDiscards);
            *var_len = sizeof(long64_return);
            return (u_char*) &long64_return;

        case LEAF_portHistCurrentOutErrors:
            SNMP_MGR_UI64_T_TO_COUNTER64(long64_return, entry.counter.ifOutErrors);
            *var_len = sizeof(long64_return);
            return (u_char*) &long64_return;

        case LEAF_portHistCurrentInUtilization:
            *var_len = sizeof(long_return);
            long_return = entry.counter.ifInUtilization.basis_point;
            return (u_char*) &long_return;

        case LEAF_portHistCurrentOutUtilization:
            *var_len = sizeof(long_return);
            long_return = entry.counter.ifOutUtilization.basis_point;
            return (u_char*) &long_return;

        default :
            ERROR_MSG("");
    }

    return NULL;
}

/***** portHistPreviousTable *****/
#define PORTHISTPREVIOUSENTRY_INSTANCE_LEN  2

BOOL_T portHistPreviousTable_OidIndexToData(UI32_T exact, UI32_T compc,
                                            oid* compl, UI32_T *portHistPreviousIndex, UI32_T *portHistPreviousSampleIndex)
{
    /* get or write */
    if (exact)
    {
        /* check the index length */
        if (compc != PORTHISTPREVIOUSENTRY_INSTANCE_LEN) /* the constant size index */
        {
            return FALSE;
        }
    }

    *portHistPreviousIndex = compl[0];
    *portHistPreviousSampleIndex = compl[1];

    return TRUE;
}

/*
 * var_portHistPreviousTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char*
var_portHistPreviousTable(struct variable *vp,
                          oid     *name,
                          size_t  *length,
                          int exact,
                          size_t  *var_len,
                          WriteMethod **write_method)
{
    /* variables we may use later */
    UI32_T compc = 0;
    oid compl[PORTHISTPREVIOUSENTRY_INSTANCE_LEN] = {0};
    oid best_inst[PORTHISTPREVIOUSENTRY_INSTANCE_LEN] = {0};
    NMTR_TYPE_HistSampleEntry_T entry;

    switch (vp->magic)
    {
        default:
            *write_method = 0;
            break;
    }

    /* check compc, retrive compl */
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,
                           compl, PORTHISTPREVIOUSENTRY_INSTANCE_LEN);

    memset(&entry, 0, sizeof(entry));
    if (exact) /* get,set */
    {
        /* get index */
        if (portHistPreviousTable_OidIndexToData(exact, compc, compl, &entry.ctrl_idx, &entry.sample_idx) == FALSE)
        {
            return NULL;
        }
        /* get data */
        if (!NMTR_PMGR_GetHistoryPreviousEntry(&entry, FALSE))
        {
            return NULL;
        }
    }
    else /* getnext */
    {
        /* get index */
        portHistPreviousTable_OidIndexToData(exact, compc, compl, &entry.ctrl_idx, &entry.sample_idx);
        /* check the length of inputing index,if < 1 we should try get
         * {0.0.0.0.0...}
         */
        if (compc < 1)
        {
            /* get data */
            if (!NMTR_PMGR_GetHistoryPreviousEntry(&entry, FALSE))
            {
                /* get next data */
                if (!NMTR_PMGR_GetHistoryPreviousEntry(&entry, TRUE))
                {
                    return NULL;
                }
            }
        }
        else
        {
            /* get next data */
            if (!NMTR_PMGR_GetHistoryPreviousEntry(&entry, TRUE))
            {
                return NULL;
            }
        }
    }

    memcpy(name, vp->name, vp->namelen * sizeof(oid));

    /* assign data to the oid index */
    best_inst[0] = entry.ctrl_idx;
    best_inst[1] = entry.sample_idx;
    memcpy(name + vp->namelen, best_inst, PORTHISTPREVIOUSENTRY_INSTANCE_LEN * sizeof(oid));
    *length = vp->namelen + PORTHISTPREVIOUSENTRY_INSTANCE_LEN ;

    /* this is where we do the value assignments for the mib results. */
    switch (vp->magic)
    {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case LEAF_portHistPreviousIndex:
            *var_len = sizeof(long_return);
            long_return = entry.ctrl_idx;
            return (u_char*) &long_return;

        case LEAF_portHistPreviousSampleIndex:
            *var_len = sizeof(long_return);
            long_return = entry.sample_idx;
            return (u_char*) &long_return;
#endif

        case LEAF_portHistPreviousIntervalStart:
            *var_len = sizeof(long_return);
            long_return = entry.counter.start_time;
            return (u_char*) &long_return;

        case LEAF_portHistPreviousInOctets:
            SNMP_MGR_UI64_T_TO_COUNTER64(long64_return, entry.counter.ifInOctets);
            *var_len = sizeof(long64_return);
            return (u_char*) &long64_return;

        case LEAF_portHistPreviousInUcastPkts:
            SNMP_MGR_UI64_T_TO_COUNTER64(long64_return, entry.counter.ifInUcastPkts);
            *var_len = sizeof(long64_return);
            return (u_char*) &long64_return;

        case LEAF_portHistPreviousInMulticastPkts:
            SNMP_MGR_UI64_T_TO_COUNTER64(long64_return, entry.counter.ifInMulticastPkts);
            *var_len = sizeof(long64_return);
            return (u_char*) &long64_return;

        case LEAF_portHistPreviousInBroadcastPkts:
            SNMP_MGR_UI64_T_TO_COUNTER64(long64_return, entry.counter.ifInBroadcastPkts);
            *var_len = sizeof(long64_return);
            return (u_char*) &long64_return;

        case LEAF_portHistPreviousInDiscards:
            SNMP_MGR_UI64_T_TO_COUNTER64(long64_return, entry.counter.ifInDiscards);
            *var_len = sizeof(long64_return);
            return (u_char*) &long64_return;

        case LEAF_portHistPreviousInErrors:
            SNMP_MGR_UI64_T_TO_COUNTER64(long64_return, entry.counter.ifInErrors);
            *var_len = sizeof(long64_return);
            return (u_char*) &long64_return;

        case LEAF_portHistPreviousInUnknownProtos:
            SNMP_MGR_UI64_T_TO_COUNTER64(long64_return, entry.counter.ifInUnknownProtos);
            *var_len = sizeof(long64_return);
            return (u_char*) &long64_return;

        case LEAF_portHistPreviousOutOctets:
            SNMP_MGR_UI64_T_TO_COUNTER64(long64_return, entry.counter.ifOutOctets);
            *var_len = sizeof(long64_return);
            return (u_char*) &long64_return;

        case LEAF_portHistPreviousOutUcastPkts:
            SNMP_MGR_UI64_T_TO_COUNTER64(long64_return, entry.counter.ifOutUcastPkts);
            *var_len = sizeof(long64_return);
            return (u_char*) &long64_return;

        case LEAF_portHistPreviousOutMulticastPkts:
            SNMP_MGR_UI64_T_TO_COUNTER64(long64_return, entry.counter.ifOutMulticastPkts);
            *var_len = sizeof(long64_return);
            return (u_char*) &long64_return;

        case LEAF_portHistPreviousOutBroadcastPkts:
            SNMP_MGR_UI64_T_TO_COUNTER64(long64_return, entry.counter.ifOutBroadcastPkts);
            *var_len = sizeof(long64_return);
            return (u_char*) &long64_return;

        case LEAF_portHistPreviousOutDiscards:
            SNMP_MGR_UI64_T_TO_COUNTER64(long64_return, entry.counter.ifOutDiscards);
            *var_len = sizeof(long64_return);
            return (u_char*) &long64_return;

        case LEAF_portHistPreviousOutErrors:
            SNMP_MGR_UI64_T_TO_COUNTER64(long64_return, entry.counter.ifOutErrors);
            *var_len = sizeof(long64_return);
            return (u_char*) &long64_return;

        case LEAF_portHistPreviousInUtilization:
            *var_len = sizeof(long_return);
            long_return = entry.counter.ifInUtilization.basis_point;
            return (u_char*) &long_return;

        case LEAF_portHistPreviousOutUtilization:
            *var_len = sizeof(long_return);
            long_return = entry.counter.ifOutUtilization.basis_point;
            return (u_char*) &long_return;

        default :
            ERROR_MSG("");
    }

    return NULL;
}
#endif /* (SYS_CPNT_NMTR_HISTORY == TRUE) */

#if (SYS_CPNT_SWDRV_MONITOR_SFP_DDM == TRUE)
/***** portMediaInfoTable *****/
#define PORTMEDIAINFOENTRY_INSTANCE_LEN  1

BOOL_T portMediaInfoTable_OidIndexToData(UI32_T exact, UI32_T compc,
    oid *compl, UI32_T *portMediaInfoIfIndex)
{
    /* get or set
     */
    if (exact)
    {
        /* check the index length
         */
        if (compc != PORTMEDIAINFOENTRY_INSTANCE_LEN)  /* the constant size index */
        {
            return FALSE;
        }
    }

    *portMediaInfoIfIndex = compl[0];

    return TRUE;
}
#endif /* #if (SYS_CPNT_SWDRV_MONITOR_SFP_DDM == TRUE) */

/*
 * var_portMediaInfoTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *var_portMediaInfoTable(struct variable *vp,
    oid *name,
    size_t *length,
    int exact,
    size_t *var_len,
    WriteMethod **write_method)
{
#if (SYS_CPNT_SWDRV_MONITOR_SFP_DDM == TRUE)
    UI32_T compc = 0;
    oid compl[PORTMEDIAINFOENTRY_INSTANCE_LEN] = {0};
    oid best_inst[PORTMEDIAINFOENTRY_INSTANCE_LEN] = {0};
    SWCTRL_OM_SfpEntry_T entry;

    /* dispatch node to set write method
     */
    switch (vp->magic)
    {
        default:
            *write_method = 0;
            break;
    }

    /* check compc, retrive compl
     */
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl,
        PORTMEDIAINFOENTRY_INSTANCE_LEN);

    memset(&entry, 0, sizeof(entry));

    /* dispatch get-exact versus get-next
     */
    if (exact)  /* get or set */
    {
        /* extract index
         */
        if (FALSE == portMediaInfoTable_OidIndexToData(exact, compc, compl, &entry.ifindex))
        {
            return NULL;
        }

        /* get-exact from core layer
         */
        if (FALSE == SWCTRL_POM_GetPortSfpEntry(entry.ifindex, &entry))
        {
            return NULL;
        }
    }
    else  /* get-next */
    {
        /* extract index
         */
        portMediaInfoTable_OidIndexToData(exact, compc, compl, &entry.ifindex);

        /* Check the length of inputing index.  If compc is less than the
         * instance length, we should try get {A.B.C.0.0...}, where A.B.C was
         * obtained from the "..._OidIndexToData" function call, and
         * 0.0... was initialized in the beginning of this function.
         * This instance may exist in the core layer.
         */
        if (compc < PORTMEDIAINFOENTRY_INSTANCE_LEN)  /* incomplete index */
        {
            /* get-exact, in case this instance exists
             */
            if (FALSE == SWCTRL_POM_GetPortSfpEntry(entry.ifindex, &entry))
            {
                /* get-next according to lexicographic order; if none, fail
                 */
                if (FALSE == SWCTRL_POM_GetNextPortSfpEntry(&entry.ifindex, &entry))
                {
                    return NULL;
                }
            }
        }
        else   /* complete index */
        {
            /* get-next according to lexicographic order; if none, fail
             */
            if (FALSE == SWCTRL_POM_GetNextPortSfpEntry(&entry.ifindex, &entry))
            {
                return NULL;
            }
        }
    }

    /* copy base OID (without index) to output
     */
    memcpy(name, vp->name, vp->namelen * sizeof(oid));

    /* assign data to the OID index
     */
    best_inst[0] = entry.ifindex;
    memcpy(name + vp->namelen, best_inst, PORTMEDIAINFOENTRY_INSTANCE_LEN * sizeof(oid));
    *length = vp->namelen + PORTMEDIAINFOENTRY_INSTANCE_LEN;

    /* dispatch node to read value
     */
    switch (vp->magic)
    {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case LEAF_portMediaInfoIfIndex:
            *var_len = sizeof(long_return);
            long_return = entry.ifindex;
            return (u_char *) &long_return;
#endif  /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

        case LEAF_portMediaInfoConnectorType:
            *var_len = strlen((char *)entry.connector_type);
            memcpy(return_buf, entry.connector_type, *var_len);
            return (u_char *) return_buf;

        case LEAF_portMediaInfoFiberType:
            *var_len = strlen((char *)entry.fiber_type);
            memcpy(return_buf, entry.fiber_type, *var_len);
            return (u_char *) return_buf;

        case LEAF_portMediaInfoEthComplianceCodes:
            *var_len = strlen((char *)entry.eth_comp_code);
            memcpy(return_buf, entry.eth_comp_code, *var_len);
            return (u_char *) return_buf;

        case LEAF_portMediaInfoBaudRate:
            *var_len = strlen((char *)entry.baud_rate);
            memcpy(return_buf, entry.baud_rate, *var_len);
            return (u_char *) return_buf;

        case LEAF_portMediaInfoVendorOUI:
            *var_len = strlen((char *)entry.vendor_oui);
            memcpy(return_buf, entry.vendor_oui, *var_len);
            return (u_char *) return_buf;

        case LEAF_portMediaInfoVendorName:
            *var_len = strlen((char *)entry.vendor_name);
            memcpy(return_buf, entry.vendor_name, *var_len);
            return (u_char *) return_buf;

        case LEAF_portMediaInfoPartNumber:
            *var_len = strlen((char *)entry.vendor_pn);
            memcpy(return_buf, entry.vendor_pn, *var_len);
            return (u_char *) return_buf;

        case LEAF_portMediaInfoRevision:
            *var_len = strlen((char *)entry.vendor_rev);
            memcpy(return_buf, entry.vendor_rev, *var_len);
            return (u_char *) return_buf;

        case LEAF_portMediaInfoSerialNumber:
            *var_len = strlen((char *)entry.vendor_sn);
            memcpy(return_buf, entry.vendor_sn, *var_len);
            return (u_char *) return_buf;

        case LEAF_portMediaInfoDateCode:
            *var_len = strlen((char *)entry.date_code);
            memcpy(return_buf, entry.date_code, *var_len);
            return (u_char *) return_buf;

        case LEAF_portMediaInfoErrorMessage:
            *var_len = strlen((char *)entry.error_msg);
            memcpy(return_buf, entry.error_msg, *var_len);
            return (u_char *) return_buf;

        default:
            ERROR_MSG("");
            break;
    }
#endif /* #if (SYS_CPNT_SWDRV_MONITOR_SFP_DDM == TRUE) */
    /* return failure
     */
    return NULL;
}

#if (SYS_CPNT_SWDRV_MONITOR_SFP_DDM == TRUE)
/***** portOpticalMonitoringInfoTable *****/
#define PORTOPTICALMONITORINGINFOENTRY_INSTANCE_LEN  1

BOOL_T portOpticalMonitoringInfoTable_OidIndexToData(UI32_T exact, UI32_T compc,
    oid *compl, UI32_T *portOpticalMonitoringInfoIfIndex)
{
    /* get or set
     */
    if (exact)
    {
        /* check the index length
         */
        if (compc != PORTOPTICALMONITORINGINFOENTRY_INSTANCE_LEN)  /* the constant size index */
        {
            return FALSE;
        }
    }

    *portOpticalMonitoringInfoIfIndex = compl[0];

    return TRUE;
}
#endif/* #if (SYS_CPNT_SWDRV_MONITOR_SFP_DDM == TRUE) */

/*
 * var_portOpticalMonitoringInfoTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *var_portOpticalMonitoringInfoTable(struct variable *vp,
    oid *name,
    size_t *length,
    int exact,
    size_t *var_len,
    WriteMethod **write_method)
{
#if (SYS_CPNT_SWDRV_MONITOR_SFP_DDM == TRUE)
    UI32_T compc = 0;
    oid compl[PORTOPTICALMONITORINGINFOENTRY_INSTANCE_LEN] = {0};
    oid best_inst[PORTOPTICALMONITORINGINFOENTRY_INSTANCE_LEN] = {0};
    SWCTRL_OM_SfpDdmEntry_T entry;

    /* dispatch node to set write method
     */
    switch (vp->magic)
    {
        default:
            *write_method = 0;
            break;
    }

    /* check compc, retrive compl
     */
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl,
        PORTOPTICALMONITORINGINFOENTRY_INSTANCE_LEN);

    memset(&entry, 0, sizeof(entry));

    /* dispatch get-exact versus get-next
     */
    if (exact)  /* get or set */
    {
        /* extract index
         */
        if (FALSE == portMediaInfoTable_OidIndexToData(exact, compc, compl, &entry.ifindex))
        {
            return NULL;
        }

        /* get-exact from core layer
         */
        if (FALSE == SWCTRL_POM_GetPortSfpDdmEntry(entry.ifindex, &entry))
        {
            return NULL;
        }
    }
    else  /* get-next */
    {
        /* extract index
         */
        portOpticalMonitoringInfoTable_OidIndexToData(exact, compc, compl, &entry.ifindex);

        /* Check the length of inputing index.  If compc is less than the
         * instance length, we should try get {A.B.C.0.0...}, where A.B.C was
         * obtained from the "..._OidIndexToData" function call, and
         * 0.0... was initialized in the beginning of this function.
         * This instance may exist in the core layer.
         */
        if (compc < PORTOPTICALMONITORINGINFOENTRY_INSTANCE_LEN)  /* incomplete index */
        {
            /* get-exact, in case this instance exists
             */
            if (FALSE == SWCTRL_POM_GetPortSfpDdmEntry(entry.ifindex, &entry))
            {
                /* get-next according to lexicographic order; if none, fail
                 */
                if (FALSE == SWCTRL_POM_GetNextPortSfpDdmEntry(&entry.ifindex, &entry))
                {
                    return NULL;
                }
            }
        }
        else   /* complete index */
        {
            /* get-next according to lexicographic order; if none, fail
             */
            if (FALSE == SWCTRL_POM_GetNextPortSfpDdmEntry(&entry.ifindex, &entry))
            {
                return NULL;
            }
        }
    }

    /* copy base OID (without index) to output
     */
    memcpy(name, vp->name, vp->namelen * sizeof(oid));

    /* assign data to the OID index
     */
    best_inst[0] = entry.ifindex;
    memcpy(name + vp->namelen, best_inst, PORTOPTICALMONITORINGINFOENTRY_INSTANCE_LEN * sizeof(oid));
    *length = vp->namelen + PORTOPTICALMONITORINGINFOENTRY_INSTANCE_LEN;

    /* dispatch node to read value
     */
    switch (vp->magic)
    {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case LEAF_portOpticalMonitoringInfoIfIndex:
            *var_len = sizeof(long_return);
            long_return = entry.ifindex;
            return (u_char *) &long_return;
#endif  /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

        case LEAF_portOpticalMonitoringInfoTemperature:
            *var_len = strlen((char *)entry.temperature);
            memcpy(return_buf, entry.temperature, *var_len);
            return (u_char *) return_buf;

        case LEAF_portOpticalMonitoringInfoVcc:
            *var_len = strlen((char *)entry.voltage);
            memcpy(return_buf, entry.voltage, *var_len);
            return (u_char *) return_buf;

        case LEAF_portOpticalMonitoringInfoTxBiasCurrent:
            *var_len = strlen((char *)entry.bias_current);
            memcpy(return_buf, entry.bias_current, *var_len);
            return (u_char *) return_buf;

        case LEAF_portOpticalMonitoringInfoTxPower:
            *var_len = strlen((char *)entry.tx_power);
            memcpy(return_buf, entry.tx_power, *var_len);
            return (u_char *) return_buf;

        case LEAF_portOpticalMonitoringInfoRxPower:
            *var_len = strlen((char *)entry.rx_power);
            memcpy(return_buf, entry.rx_power, *var_len);
            return (u_char *) return_buf;

        default:
            ERROR_MSG("");
            break;
    }

#endif /* #if (SYS_CPNT_SWDRV_MONITOR_SFP_DDM == TRUE) */
    /* return failure
     */
    return NULL;
}

#if (SYS_CPNT_SFP_DDM_ALARMWARN_TRAP == TRUE)
#define PORTTRANSCEIVERTHRESHOLDINFOENTRY_INSTANCE_LEN  1

BOOL_T portTransceiverThresholdInfoTable_OidIndexToData(UI32_T exact, UI32_T compc,
    oid *compl, UI32_T *portTransceiverThresholdInfoIfIndex)
{
    /* get or set
     */
    if (exact)
    {
        /* check the index length
         */
        if (compc != PORTTRANSCEIVERTHRESHOLDINFOENTRY_INSTANCE_LEN)  /* the constant size index */
        {
            return FALSE;
        }
    }

    *portTransceiverThresholdInfoIfIndex = compl[0];

    return TRUE;
}
#endif /* #if (SYS_CPNT_SWDRV_MONITOR_SFP_DDM == TRUE) */

/*
 * var_portTransceiverThresholdInfoTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *var_portTransceiverThresholdInfoTable(struct variable *vp,
    oid *name,
    size_t *length,
    int exact,
    size_t *var_len,
    WriteMethod **write_method)
{
#if (SYS_CPNT_SWDRV_MONITOR_SFP_DDM == TRUE)
    UI32_T compc = 0;
    oid compl[PORTTRANSCEIVERTHRESHOLDINFOENTRY_INSTANCE_LEN] = {0};
    oid best_inst[PORTTRANSCEIVERTHRESHOLDINFOENTRY_INSTANCE_LEN] = {0};

    /* table-specific variables
     */
    SWCTRL_OM_SfpDdmThresholdEntry_T entry;

    /* dispatch node to set write method
     */
    switch (vp->magic)
    {
        case LEAF_portTransceiverThresholdInfoTemperatureLowAlarm:
            *write_method = write_portTransceiverThresholdInfoTemperatureLowAlarm;
            break;

        case LEAF_portTransceiverThresholdInfoTemperatureLowWarn:
            *write_method = write_portTransceiverThresholdInfoTemperatureLowWarn;
            break;

        case LEAF_portTransceiverThresholdInfoTemperatureHighWarn:
            *write_method = write_portTransceiverThresholdInfoTemperatureHighWarn;
            break;

        case LEAF_portTransceiverThresholdInfoTemperatureHighAlarm:
            *write_method = write_portTransceiverThresholdInfoTemperatureHighAlarm;
            break;

        case LEAF_portTransceiverThresholdInfoVccLowAlarm:
            *write_method = write_portTransceiverThresholdInfoVccLowAlarm;
            break;

        case LEAF_portTransceiverThresholdInfoVccLowWarn:
            *write_method = write_portTransceiverThresholdInfoVccLowWarn;
            break;

        case LEAF_portTransceiverThresholdInfoVccHighWarn:
            *write_method = write_portTransceiverThresholdInfoVccHighWarn;
            break;

        case LEAF_portTransceiverThresholdInfoVccHighAlarm:
            *write_method = write_portTransceiverThresholdInfoVccHighAlarm;
            break;

        case LEAF_portTransceiverThresholdInfoTxBiasCurrentLowAlarm:
            *write_method = write_portTransceiverThresholdInfoTxBiasCurrentLowAlarm;
            break;

        case LEAF_portTransceiverThresholdInfoTxBiasCurrentLowWarn:
            *write_method = write_portTransceiverThresholdInfoTxBiasCurrentLowWarn;
            break;

        case LEAF_portTransceiverThresholdInfoTxBiasCurrentHighWarn:
            *write_method = write_portTransceiverThresholdInfoTxBiasCurrentHighWarn;
            break;

        case LEAF_portTransceiverThresholdInfoTxBiasCurrentHighAlarm:
            *write_method = write_portTransceiverThresholdInfoTxBiasCurrentHighAlarm;
            break;

        case LEAF_portTransceiverThresholdInfoTxPowerLowAlarm:
            *write_method = write_portTransceiverThresholdInfoTxPowerLowAlarm;
            break;

        case LEAF_portTransceiverThresholdInfoTxPowerLowWarn:
            *write_method = write_portTransceiverThresholdInfoTxPowerLowWarn;
            break;

        case LEAF_portTransceiverThresholdInfoTxPowerHighWarn:
            *write_method = write_portTransceiverThresholdInfoTxPowerHighWarn;
            break;

        case LEAF_portTransceiverThresholdInfoTxPowerHighAlarm:
            *write_method = write_portTransceiverThresholdInfoTxPowerHighAlarm;
            break;

        case LEAF_portTransceiverThresholdInfoRxPowerLowAlarm:
            *write_method = write_portTransceiverThresholdInfoRxPowerLowAlarm;
            break;

        case LEAF_portTransceiverThresholdInfoRxPowerLowWarn:
            *write_method = write_portTransceiverThresholdInfoRxPowerLowWarn;
            break;

        case LEAF_portTransceiverThresholdInfoRxPowerHighWarn:
            *write_method = write_portTransceiverThresholdInfoRxPowerHighWarn;
            break;

        case LEAF_portTransceiverThresholdInfoRxPowerHighAlarm:
            *write_method = write_portTransceiverThresholdInfoRxPowerHighAlarm;
            break;

        case LEAF_portTransceiverThresholdAutoMode:
            *write_method = write_portTransceiverThresholdAutoMode;
            break;

        default:
            *write_method = 0;
            break;
    }

    /* check compc, retrive compl
     */
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl,
        PORTTRANSCEIVERTHRESHOLDINFOENTRY_INSTANCE_LEN);

    memset(&entry, 0, sizeof(entry));

    /* dispatch get-exact versus get-next
     */
    if (exact)  /* get or set */
    {
        /* extract index
         */
        if (! portTransceiverThresholdInfoTable_OidIndexToData(exact, compc, compl,
            &entry.ifindex))
        {
            return NULL;
        }
        /* get-exact from core layer
         */
        if (! SWCTRL_POM_GetPortSfpDdmThresholdEntry(entry.ifindex, &entry))
        {
            return NULL;
        }
    }
    else  /* get-next */
    {
        /* extract index
         */
        portTransceiverThresholdInfoTable_OidIndexToData(exact, compc, compl, &entry.ifindex);

        /* Check the length of inputing index.  If compc is less than the
         * instance length, we should try get {A.B.C.0.0...}, where A.B.C was
         * obtained from the "..._OidIndexToData" function call, and
         * 0.0... was initialized in the beginning of this function.
         * This instance may exist in the core layer.
         */
        if (compc < PORTTRANSCEIVERTHRESHOLDINFOENTRY_INSTANCE_LEN)  /* incomplete index */
        {
            /* get-exact, in case this instance exists
             */
            if (! SWCTRL_POM_GetPortSfpDdmThresholdEntry(entry.ifindex, &entry))
            {
                /* get-next according to lexicographic order; if none, fail
                 */
                if (!  SWCTRL_POM_GetNextPortSfpDdmThresholdEntry(&entry.ifindex, &entry))
                {
                    return NULL;
                }
            }
        }
        else   /* complete index */
        {
            /* get-next according to lexicographic order; if none, fail
             */
            if (! SWCTRL_POM_GetNextPortSfpDdmThresholdEntry(&entry.ifindex, &entry))
            {
                return NULL;
            }
        }
    }

    /* copy base OID (without index) to output
     */
    memcpy(name, vp->name, vp->namelen * sizeof(oid));

    /* assign data to the OID index
     */
    best_inst[0] = entry.ifindex;
    memcpy(name + vp->namelen, best_inst, PORTTRANSCEIVERTHRESHOLDINFOENTRY_INSTANCE_LEN * sizeof(oid));
    *length = vp->namelen + PORTTRANSCEIVERTHRESHOLDINFOENTRY_INSTANCE_LEN;

    /* dispatch node to read value
     */
    switch (vp->magic)
    {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case LEAF_portTransceiverThresholdInfoIfIndex:
            *var_len = sizeof(long_return);
            long_return = entry.ifindex;
            return (u_char *) &long_return;
#endif  /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

        case LEAF_portTransceiverThresholdInfoTemperatureLowAlarm:
            *var_len = sizeof(long_return);
            long_return = entry.threshold_int.temp_low_alarm;
            return (u_char *) &long_return;

        case LEAF_portTransceiverThresholdInfoTemperatureLowWarn:
            *var_len = sizeof(long_return);
            long_return = entry.threshold_int.temp_low_warning;
            return (u_char *) &long_return;

        case LEAF_portTransceiverThresholdInfoTemperatureHighWarn:
            *var_len = sizeof(long_return);
            long_return = entry.threshold_int.temp_high_warning;
            return (u_char *) &long_return;

        case LEAF_portTransceiverThresholdInfoTemperatureHighAlarm:
            *var_len = sizeof(long_return);
            long_return = entry.threshold_int.temp_high_alarm;
            return (u_char *) &long_return;

        case LEAF_portTransceiverThresholdInfoVccLowAlarm:
            *var_len = sizeof(long_return);
            long_return = entry.threshold_int.voltage_low_alarm;
            return (u_char *) &long_return;

        case LEAF_portTransceiverThresholdInfoVccLowWarn:
            *var_len = sizeof(long_return);
            long_return = entry.threshold_int.voltage_low_warning;
            return (u_char *) &long_return;

        case LEAF_portTransceiverThresholdInfoVccHighWarn:
            *var_len = sizeof(long_return);
            long_return = entry.threshold_int.voltage_high_warning;
            return (u_char *) &long_return;

        case LEAF_portTransceiverThresholdInfoVccHighAlarm:
            *var_len = sizeof(long_return);
            long_return = entry.threshold_int.voltage_high_alarm;
            return (u_char *) &long_return;

        case LEAF_portTransceiverThresholdInfoTxBiasCurrentLowAlarm:
            *var_len = sizeof(long_return);
            long_return = entry.threshold_int.bias_low_alarm;
            return (u_char *) &long_return;

        case LEAF_portTransceiverThresholdInfoTxBiasCurrentLowWarn:
            *var_len = sizeof(long_return);
            long_return = entry.threshold_int.bias_low_warning;
            return (u_char *) &long_return;

        case LEAF_portTransceiverThresholdInfoTxBiasCurrentHighWarn:
            *var_len = sizeof(long_return);
            long_return = entry.threshold_int.bias_high_warning;
            return (u_char *) &long_return;

        case LEAF_portTransceiverThresholdInfoTxBiasCurrentHighAlarm:
            *var_len = sizeof(long_return);
            long_return = entry.threshold_int.bias_high_alarm;
            return (u_char *) &long_return;

        case LEAF_portTransceiverThresholdInfoTxPowerLowAlarm:
            *var_len = sizeof(long_return);
            long_return = entry.threshold_int.tx_power_low_alarm;
            return (u_char *) &long_return;

        case LEAF_portTransceiverThresholdInfoTxPowerLowWarn:
            *var_len = sizeof(long_return);
            long_return = entry.threshold_int.tx_power_low_warning;
            return (u_char *) &long_return;

        case LEAF_portTransceiverThresholdInfoTxPowerHighWarn:
            *var_len = sizeof(long_return);
            long_return = entry.threshold_int.tx_power_high_warning;
            return (u_char *) &long_return;

        case LEAF_portTransceiverThresholdInfoTxPowerHighAlarm:
            *var_len = sizeof(long_return);
            long_return = entry.threshold_int.tx_power_high_alarm;
            return (u_char *) &long_return;

        case LEAF_portTransceiverThresholdInfoRxPowerLowAlarm:
            *var_len = sizeof(long_return);
            long_return = entry.threshold_int.rx_power_low_alarm;
            return (u_char *) &long_return;

        case LEAF_portTransceiverThresholdInfoRxPowerLowWarn:
            *var_len = sizeof(long_return);
            long_return = entry.threshold_int.rx_power_low_warning;
            return (u_char *) &long_return;

        case LEAF_portTransceiverThresholdInfoRxPowerHighWarn:
            *var_len = sizeof(long_return);
            long_return = entry.threshold_int.rx_power_high_warning;
            return (u_char *) &long_return;

        case LEAF_portTransceiverThresholdInfoRxPowerHighAlarm:
            *var_len = sizeof(long_return);
            long_return = entry.threshold_int.rx_power_high_alarm;
            return (u_char *) &long_return;

        case LEAF_portTransceiverThresholdAutoMode:
            *var_len = sizeof(long_return);
            if(entry.auto_mode == TRUE)
                long_return = VAL_portTransceiverThresholdAutoMode_true;
            else
                long_return = VAL_portTransceiverThresholdAutoMode_false;

            return (u_char *) &long_return;

        default:
            ERROR_MSG("");
            break;
    }
#endif /* #if (SYS_CPNT_SWDRV_MONITOR_SFP_DDM == TRUE) */
    /* return failure
     */
    return NULL;
}

#if (SYS_CPNT_SWDRV_MONITOR_SFP_DDM == TRUE)
int write_portTransceiverThresholdInfoTemperatureLowAlarm(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    /* dispatch action
     */
    switch (action)
    {
        case RESERVE1:
            /* check type and length
             */
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            /* check valid values
             */
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            I32_T value = 0;

            /* table-specific variables
             */
            UI32_T portTransceiverThresholdInfoIfIndex = 0;

            /* extract index
             */
            if (! portTransceiverThresholdInfoTable_OidIndexToData(TRUE,
                name_len - oid_name_length,
                &(name[oid_name_length]),
                &portTransceiverThresholdInfoIfIndex))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            /* get user value
             */
            value = *(long *)var_val;

            /* set to core layer
             */
            if(value > SWCTRL_GBIC_DDM_TEMPERATURE_MAX ||
               value < SWCTRL_GBIC_DDM_TEMPERATURE_MIN)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            if (! SWCTRL_PMGR_SetPortSfpDdmThreshold(portTransceiverThresholdInfoIfIndex, VAL_trapSfpThresholdAlarmWarnType_temperatureLowAlarm, value, TRUE) )
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    /* return success
     */
    return SNMP_ERR_NOERROR;
}

int write_portTransceiverThresholdInfoTemperatureLowWarn(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    /* dispatch action
     */
    switch (action)
    {
        case RESERVE1:
            /* check type and length
             */
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            /* check valid values
             */
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            I32_T value = 0;

            /* table-specific variables
             */
            UI32_T portTransceiverThresholdInfoIfIndex = 0;

            /* extract index
             */
            if (! portTransceiverThresholdInfoTable_OidIndexToData(TRUE,
                name_len - oid_name_length,
                &(name[oid_name_length]),
                &portTransceiverThresholdInfoIfIndex))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            /* get user value
             */
            value = *(long *)var_val;


            /* set to core layer
             */
            if(value > SWCTRL_GBIC_DDM_TEMPERATURE_MAX ||
               value < SWCTRL_GBIC_DDM_TEMPERATURE_MIN)
            {
                return SNMP_ERR_WRONGVALUE;
            }

            if (! SWCTRL_PMGR_SetPortSfpDdmThreshold(portTransceiverThresholdInfoIfIndex, VAL_trapSfpThresholdAlarmWarnType_temperatureLowWarning, value, TRUE) )
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    /* return success
     */
    return SNMP_ERR_NOERROR;
}
int write_portTransceiverThresholdInfoTemperatureHighWarn(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    /* dispatch action
     */
    switch (action)
    {
        case RESERVE1:
            /* check type and length
             */
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            /* check valid values
             */
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            I32_T value = 0;

            /* table-specific variables
             */
            UI32_T portTransceiverThresholdInfoIfIndex = 0;

            /* extract index
             */
            if (! portTransceiverThresholdInfoTable_OidIndexToData(TRUE,
                name_len - oid_name_length,
                &(name[oid_name_length]),
                &portTransceiverThresholdInfoIfIndex))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            /* get user value
             */
            value = *(long *)var_val;

            /* set to core layer
             */
            if(value > SWCTRL_GBIC_DDM_TEMPERATURE_MAX ||
               value < SWCTRL_GBIC_DDM_TEMPERATURE_MIN)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            if (! SWCTRL_PMGR_SetPortSfpDdmThreshold(portTransceiverThresholdInfoIfIndex, VAL_trapSfpThresholdAlarmWarnType_temperatureHighWarning, value, TRUE) )
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    /* return success
     */
    return SNMP_ERR_NOERROR;
}
int write_portTransceiverThresholdInfoTemperatureHighAlarm(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    /* dispatch action
     */
    switch (action)
    {
        case RESERVE1:
            /* check type and length
             */
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            /* check valid values
             */
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            I32_T value = 0;

            /* table-specific variables
             */
            UI32_T portTransceiverThresholdInfoIfIndex = 0;

            /* extract index
             */
            if (! portTransceiverThresholdInfoTable_OidIndexToData(TRUE,
                name_len - oid_name_length,
                &(name[oid_name_length]),
                &portTransceiverThresholdInfoIfIndex))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            /* get user value
             */
            value = *(long *)var_val;

            /* set to core layer
             */
            if(value < SWCTRL_GBIC_DDM_TEMPERATURE_MIN ||
               value > SWCTRL_GBIC_DDM_TEMPERATURE_MAX)
            {
                return SNMP_ERR_WRONGVALUE;
            }

            if (! SWCTRL_PMGR_SetPortSfpDdmThreshold(portTransceiverThresholdInfoIfIndex, VAL_trapSfpThresholdAlarmWarnType_temperatureHighAlarm, value, TRUE) )
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    /* return success
     */
    return SNMP_ERR_NOERROR;
}

int write_portTransceiverThresholdInfoVccLowAlarm(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    /* dispatch action
     */
    switch (action)
    {
        case RESERVE1:
            /* check type and length
             */
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            /* check valid values
             */
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            I32_T value = 0;

            /* table-specific variables
             */
            UI32_T portTransceiverThresholdInfoIfIndex = 0;

            /* extract index
             */
            if (! portTransceiverThresholdInfoTable_OidIndexToData(TRUE,
                name_len - oid_name_length,
                &(name[oid_name_length]),
                &portTransceiverThresholdInfoIfIndex))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            /* get user value
             */
            value = *(long *)var_val;

            /* set to core layer
             */
            if(value > SWCTRL_GBIC_DDM_VOLTAGE_MAX ||
               value < SWCTRL_GBIC_DDM_VOLTAGE_MIN)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            if (! SWCTRL_PMGR_SetPortSfpDdmThreshold(portTransceiverThresholdInfoIfIndex, VAL_trapSfpThresholdAlarmWarnType_voltageLowAlarm, value, TRUE) )
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    /* return success
     */
    return SNMP_ERR_NOERROR;
}

int write_portTransceiverThresholdInfoVccLowWarn(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    /* dispatch action
     */
    switch (action)
    {
        case RESERVE1:
            /* check type and length
             */
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            /* check valid values
             */
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            I32_T value = 0;

            /* table-specific variables
             */
            UI32_T portTransceiverThresholdInfoIfIndex = 0;

            /* extract index
             */
            if (! portTransceiverThresholdInfoTable_OidIndexToData(TRUE,
                name_len - oid_name_length,
                &(name[oid_name_length]),
                &portTransceiverThresholdInfoIfIndex))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            /* get user value
             */
            value = *(long *)var_val;

            /* set to core layer
             */
            if(value > SWCTRL_GBIC_DDM_VOLTAGE_MAX ||
               value < SWCTRL_GBIC_DDM_VOLTAGE_MIN)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            if (! SWCTRL_PMGR_SetPortSfpDdmThreshold(portTransceiverThresholdInfoIfIndex, VAL_trapSfpThresholdAlarmWarnType_voltageLowWarning, value, TRUE) )
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    /* return success
     */
    return SNMP_ERR_NOERROR;
}

int write_portTransceiverThresholdInfoVccHighWarn(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    /* dispatch action
     */
    switch (action)
    {
        case RESERVE1:
            /* check type and length
             */
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            /* check valid values
             */
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            I32_T value = 0;

            /* table-specific variables
             */
            UI32_T portTransceiverThresholdInfoIfIndex = 0;

            /* extract index
             */
            if (! portTransceiverThresholdInfoTable_OidIndexToData(TRUE,
                name_len - oid_name_length,
                &(name[oid_name_length]),
                &portTransceiverThresholdInfoIfIndex))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            /* get user value
             */
            value = *(long *)var_val;

            /* set to core layer
             */
            if(value > SWCTRL_GBIC_DDM_VOLTAGE_MAX ||
               value < SWCTRL_GBIC_DDM_VOLTAGE_MIN)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            if (! SWCTRL_PMGR_SetPortSfpDdmThreshold(portTransceiverThresholdInfoIfIndex, VAL_trapSfpThresholdAlarmWarnType_voltageHighWarning, value, TRUE) )
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    /* return success
     */
    return SNMP_ERR_NOERROR;
}

int write_portTransceiverThresholdInfoVccHighAlarm(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    /* dispatch action
     */
    switch (action)
    {
        case RESERVE1:
            /* check type and length
             */
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            /* check valid values
             */
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            I32_T value = 0;

            /* table-specific variables
             */
            UI32_T portTransceiverThresholdInfoIfIndex = 0;

            /* extract index
             */
            if (! portTransceiverThresholdInfoTable_OidIndexToData(TRUE,
                name_len - oid_name_length,
                &(name[oid_name_length]),
                &portTransceiverThresholdInfoIfIndex))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            /* get user value
             */
            value = *(long *)var_val;

            /* set to core layer
             */
            if(value > SWCTRL_GBIC_DDM_VOLTAGE_MAX ||
               value < SWCTRL_GBIC_DDM_VOLTAGE_MIN)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            if (! SWCTRL_PMGR_SetPortSfpDdmThreshold(portTransceiverThresholdInfoIfIndex, VAL_trapSfpThresholdAlarmWarnType_voltageHighAlarm, value, TRUE) )
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    /* return success
     */
    return SNMP_ERR_NOERROR;
}

int write_portTransceiverThresholdInfoTxBiasCurrentLowAlarm(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    /* dispatch action
     */
    switch (action)
    {
        case RESERVE1:
            /* check type and length
             */
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            /* check valid values
             */
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            I32_T value = 0;

            /* table-specific variables
             */
            UI32_T portTransceiverThresholdInfoIfIndex = 0;

            /* extract index
             */
            if (! portTransceiverThresholdInfoTable_OidIndexToData(TRUE,
                name_len - oid_name_length,
                &(name[oid_name_length]),
                &portTransceiverThresholdInfoIfIndex))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            /* get user value
             */
            value = *(long *)var_val;

            /* set to core layer
             */
            if(value > SWCTRL_GBIC_DDM_CURRENT_MAX ||
               value < SWCTRL_GBIC_DDM_CURRENT_MIN)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            if (! SWCTRL_PMGR_SetPortSfpDdmThreshold(portTransceiverThresholdInfoIfIndex, VAL_trapSfpThresholdAlarmWarnType_currentLowAlarm, value, TRUE) )
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    /* return success
     */
    return SNMP_ERR_NOERROR;
}

int write_portTransceiverThresholdInfoTxBiasCurrentLowWarn(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    /* dispatch action
     */
    switch (action)
    {
        case RESERVE1:
            /* check type and length
             */
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            /* check valid values
             */
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            I32_T value = 0;

            /* table-specific variables
             */
            UI32_T portTransceiverThresholdInfoIfIndex = 0;

            /* extract index
             */
            if (! portTransceiverThresholdInfoTable_OidIndexToData(TRUE,
                name_len - oid_name_length,
                &(name[oid_name_length]),
                &portTransceiverThresholdInfoIfIndex))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            /* get user value
             */
            value = *(long *)var_val;

            /* set to core layer
             */
            if(value > SWCTRL_GBIC_DDM_CURRENT_MAX ||
               value < SWCTRL_GBIC_DDM_CURRENT_MIN)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            if (! SWCTRL_PMGR_SetPortSfpDdmThreshold(portTransceiverThresholdInfoIfIndex, VAL_trapSfpThresholdAlarmWarnType_currentLowWarning, value, TRUE) )
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    /* return success
     */
    return SNMP_ERR_NOERROR;
}

int write_portTransceiverThresholdInfoTxBiasCurrentHighWarn(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    /* dispatch action
     */
    switch (action)
    {
        case RESERVE1:
            /* check type and length
             */
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            /* check valid values
             */
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            I32_T value = 0;

            /* table-specific variables
             */
            UI32_T portTransceiverThresholdInfoIfIndex = 0;

            /* extract index
             */
            if (! portTransceiverThresholdInfoTable_OidIndexToData(TRUE,
                name_len - oid_name_length,
                &(name[oid_name_length]),
                &portTransceiverThresholdInfoIfIndex))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            /* get user value
             */
            value = *(long *)var_val;

            /* set to core layer
             */
            if(value > SWCTRL_GBIC_DDM_CURRENT_MAX ||
               value < SWCTRL_GBIC_DDM_CURRENT_MIN)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            if (! SWCTRL_PMGR_SetPortSfpDdmThreshold(portTransceiverThresholdInfoIfIndex, VAL_trapSfpThresholdAlarmWarnType_currentHighWarning, value, TRUE) )
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    /* return success
     */
    return SNMP_ERR_NOERROR;
}

int write_portTransceiverThresholdInfoTxBiasCurrentHighAlarm(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    /* dispatch action
     */
    switch (action)
    {
        case RESERVE1:
            /* check type and length
             */
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            /* check valid values
             */
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            I32_T value = 0;

            /* table-specific variables
             */
            UI32_T portTransceiverThresholdInfoIfIndex = 0;

            /* extract index
             */
            if (! portTransceiverThresholdInfoTable_OidIndexToData(TRUE,
                name_len - oid_name_length,
                &(name[oid_name_length]),
                &portTransceiverThresholdInfoIfIndex))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            /* get user value
             */
            value = *(long *)var_val;

            /* set to core layer
             */
            if(value > SWCTRL_GBIC_DDM_CURRENT_MAX ||
               value < SWCTRL_GBIC_DDM_CURRENT_MIN)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            if (! SWCTRL_PMGR_SetPortSfpDdmThreshold(portTransceiverThresholdInfoIfIndex, VAL_trapSfpThresholdAlarmWarnType_currentHighAlarm, value, TRUE) )
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    /* return success
     */
    return SNMP_ERR_NOERROR;
}

int write_portTransceiverThresholdInfoTxPowerLowAlarm(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    /* dispatch action
     */
    switch (action)
    {
        case RESERVE1:
            /* check type and length
             */
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            /* check valid values
             */
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            I32_T value = 0;

            /* table-specific variables
             */
            UI32_T portTransceiverThresholdInfoIfIndex = 0;

            /* extract index
             */
            if (! portTransceiverThresholdInfoTable_OidIndexToData(TRUE,
                name_len - oid_name_length,
                &(name[oid_name_length]),
                &portTransceiverThresholdInfoIfIndex))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            /* get user value
             */
            value = *(long *)var_val;

            /* set to core layer
             */
            if(value > SWCTRL_GBIC_DDM_TX_POWER_MAX ||
               value < SWCTRL_GBIC_DDM_TX_POWER_MIN)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            if (! SWCTRL_PMGR_SetPortSfpDdmThreshold(portTransceiverThresholdInfoIfIndex, VAL_trapSfpThresholdAlarmWarnType_txPowerLowAlarm, value, TRUE) )
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    /* return success
     */
    return SNMP_ERR_NOERROR;
}

int write_portTransceiverThresholdInfoTxPowerLowWarn(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    /* dispatch action
     */
    switch (action)
    {
        case RESERVE1:
            /* check type and length
             */
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            /* check valid values
             */
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            I32_T value = 0;

            /* table-specific variables
             */
            UI32_T portTransceiverThresholdInfoIfIndex = 0;

            /* extract index
             */
            if (! portTransceiverThresholdInfoTable_OidIndexToData(TRUE,
                name_len - oid_name_length,
                &(name[oid_name_length]),
                &portTransceiverThresholdInfoIfIndex))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            /* get user value
             */
            value = *(long *)var_val;

            /* set to core layer
             */
            if(value > SWCTRL_GBIC_DDM_TX_POWER_MAX ||
               value < SWCTRL_GBIC_DDM_TX_POWER_MIN)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            if (! SWCTRL_PMGR_SetPortSfpDdmThreshold(portTransceiverThresholdInfoIfIndex, VAL_trapSfpThresholdAlarmWarnType_txPowerLowWarning, value, TRUE) )
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    /* return success
     */
    return SNMP_ERR_NOERROR;
}

int write_portTransceiverThresholdInfoTxPowerHighWarn(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    /* dispatch action
     */
    switch (action)
    {
        case RESERVE1:
            /* check type and length
             */
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            /* check valid values
             */
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            I32_T value = 0;

            /* table-specific variables
             */
            UI32_T portTransceiverThresholdInfoIfIndex = 0;

            /* extract index
             */
            if (! portTransceiverThresholdInfoTable_OidIndexToData(TRUE,
                name_len - oid_name_length,
                &(name[oid_name_length]),
                &portTransceiverThresholdInfoIfIndex))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            /* get user value
             */
            value = *(long *)var_val;

            /* set to core layer
             */
            if(value > SWCTRL_GBIC_DDM_TX_POWER_MAX ||
               value < SWCTRL_GBIC_DDM_TX_POWER_MIN)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            if (! SWCTRL_PMGR_SetPortSfpDdmThreshold(portTransceiverThresholdInfoIfIndex, VAL_trapSfpThresholdAlarmWarnType_txPowerHighWarning, value, TRUE) )
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    /* return success
     */
    return SNMP_ERR_NOERROR;
}

int write_portTransceiverThresholdInfoTxPowerHighAlarm(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    /* dispatch action
     */
    switch (action)
    {
        case RESERVE1:
            /* check type and length
             */
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            /* check valid values
             */
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            I32_T value = 0;

            /* table-specific variables
             */
            UI32_T portTransceiverThresholdInfoIfIndex = 0;

            /* extract index
             */
            if (! portTransceiverThresholdInfoTable_OidIndexToData(TRUE,
                name_len - oid_name_length,
                &(name[oid_name_length]),
                &portTransceiverThresholdInfoIfIndex))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            /* get user value
             */
            value = *(long *)var_val;

            /* set to core layer
             */
            if(value > SWCTRL_GBIC_DDM_TX_POWER_MAX ||
               value < SWCTRL_GBIC_DDM_TX_POWER_MIN)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            if (! SWCTRL_PMGR_SetPortSfpDdmThreshold(portTransceiverThresholdInfoIfIndex, VAL_trapSfpThresholdAlarmWarnType_txPowerHighAlarm, value, TRUE) )
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    /* return success
     */
    return SNMP_ERR_NOERROR;
}

int write_portTransceiverThresholdInfoRxPowerLowAlarm(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    /* dispatch action
     */
    switch (action)
    {
        case RESERVE1:
            /* check type and length
             */
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            /* check valid values
             */
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            I32_T value = 0;

            /* table-specific variables
             */
            UI32_T portTransceiverThresholdInfoIfIndex = 0;

            /* extract index
             */
            if (! portTransceiverThresholdInfoTable_OidIndexToData(TRUE,
                name_len - oid_name_length,
                &(name[oid_name_length]),
                &portTransceiverThresholdInfoIfIndex))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            /* get user value
             */
            value = *(long *)var_val;

            /* set to core layer
             */
            if(value > SWCTRL_GBIC_DDM_RX_POWER_MAX ||
               value < SWCTRL_GBIC_DDM_RX_POWER_MIN)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            if (! SWCTRL_PMGR_SetPortSfpDdmThreshold(portTransceiverThresholdInfoIfIndex, VAL_trapSfpThresholdAlarmWarnType_rxPowerLowAlarm, value, TRUE) )
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    /* return success
     */
    return SNMP_ERR_NOERROR;
}

int write_portTransceiverThresholdInfoRxPowerLowWarn(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    /* dispatch action
     */
    switch (action)
    {
        case RESERVE1:
            /* check type and length
             */
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            /* check valid values
             */
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            I32_T value = 0;

            /* table-specific variables
             */
            UI32_T portTransceiverThresholdInfoIfIndex = 0;

            /* extract index
             */
            if (! portTransceiverThresholdInfoTable_OidIndexToData(TRUE,
                name_len - oid_name_length,
                &(name[oid_name_length]),
                &portTransceiverThresholdInfoIfIndex))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            /* get user value
             */
            value = *(long *)var_val;

            /* set to core layer
             */
            if(value > SWCTRL_GBIC_DDM_RX_POWER_MAX ||
               value < SWCTRL_GBIC_DDM_RX_POWER_MIN)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            if (! SWCTRL_PMGR_SetPortSfpDdmThreshold(portTransceiverThresholdInfoIfIndex, VAL_trapSfpThresholdAlarmWarnType_rxPowerLowWarning, value, TRUE) )
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    /* return success
     */
    return SNMP_ERR_NOERROR;
}

int write_portTransceiverThresholdInfoRxPowerHighWarn(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    /* dispatch action
     */
    switch (action)
    {
        case RESERVE1:
            /* check type and length
             */
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            /* check valid values
             */
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            I32_T value = 0;

            /* table-specific variables
             */
            UI32_T portTransceiverThresholdInfoIfIndex = 0;

            /* extract index
             */
            if (! portTransceiverThresholdInfoTable_OidIndexToData(TRUE,
                name_len - oid_name_length,
                &(name[oid_name_length]),
                &portTransceiverThresholdInfoIfIndex))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            /* get user value
             */
            value = *(long *)var_val;

            /* set to core layer
             */
            if(value > SWCTRL_GBIC_DDM_RX_POWER_MAX ||
               value < SWCTRL_GBIC_DDM_RX_POWER_MIN)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            if (! SWCTRL_PMGR_SetPortSfpDdmThreshold(portTransceiverThresholdInfoIfIndex, VAL_trapSfpThresholdAlarmWarnType_rxPowerHighWarning, value, TRUE) )
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    /* return success
     */
    return SNMP_ERR_NOERROR;
}

int write_portTransceiverThresholdInfoRxPowerHighAlarm(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    /* dispatch action
     */
    switch (action)
    {
        case RESERVE1:
            /* check type and length
             */
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            /* check valid values
             */
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            I32_T value = 0;

            /* table-specific variables
             */
            UI32_T portTransceiverThresholdInfoIfIndex = 0;

            /* extract index
             */
            if (! portTransceiverThresholdInfoTable_OidIndexToData(TRUE,
                name_len - oid_name_length,
                &(name[oid_name_length]),
                &portTransceiverThresholdInfoIfIndex))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            /* get user value
             */
            value = *(long *)var_val;

            /* set to core layer
             */
            if(value > SWCTRL_GBIC_DDM_RX_POWER_MAX ||
               value < SWCTRL_GBIC_DDM_RX_POWER_MIN)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            if (! SWCTRL_PMGR_SetPortSfpDdmThreshold(portTransceiverThresholdInfoIfIndex, VAL_trapSfpThresholdAlarmWarnType_rxPowerHighAlarm, value, TRUE) )
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    /* return success
     */
    return SNMP_ERR_NOERROR;
}

int write_portTransceiverThresholdAutoMode(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    /* dispatch action
     */
    switch (action)
    {
        case RESERVE1:
            /* check type and length
             */
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            /* check valid values
             */
            switch (*(long *) var_val)
            {
                case VAL_portTransceiverThresholdAutoMode_true:
                    break;

                case VAL_portTransceiverThresholdAutoMode_false:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            I32_T value = 0;
            BOOL_T enable = FALSE;

            /* table-specific variables
             */
            UI32_T portTransceiverThresholdInfoIfIndex = 0;

            /* extract index
             */
            if (! portTransceiverThresholdInfoTable_OidIndexToData(TRUE,
                name_len - oid_name_length,
                &(name[oid_name_length]),
                &portTransceiverThresholdInfoIfIndex))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            /* get user value
             */
            value = *(long *)var_val;
            if(value == VAL_portTransceiverThresholdAutoMode_true)
                enable = TRUE;
            else
                enable = FALSE;
            /* set to core layer
             */
            if (!SWCTRL_PMGR_SetPortSfpDdmThresholdAutoMode(portTransceiverThresholdInfoIfIndex, enable))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    /* return success
     */
    return SNMP_ERR_NOERROR;
}
#endif /* #if (SYS_CPNT_SFP_DDM_ALARMWARN_TRAP == TRUE) */

#if (SYS_HWCFG_SUPPORT_PD == TRUE)
#define PORTPDENTRY_INSTANCE_LEN  1

BOOL_T portPDTable_OidIndexToData(UI32_T exact, UI32_T compc,
    oid *compl, UI32_T *portPDIfIndex)
{
    /* get or set
     */
    if (exact)
    {
        /* check the index length
         */
        if (compc != PORTPDENTRY_INSTANCE_LEN)  /* the constant size index */
        {
            return FALSE;
        }
    }

    *portPDIfIndex = compl[0];

    return TRUE;
}

/*
 * var_portPDTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *var_portPDTable(struct variable *vp,
    oid *name,
    size_t *length,
    int exact,
    size_t *var_len,
    WriteMethod **write_method)
{
    UI32_T compc = 0;
    oid compl[PORTPDENTRY_INSTANCE_LEN] = {0};
    oid best_inst[PORTPDENTRY_INSTANCE_LEN] = {0};

    /* table-specific variables
     */
    SWCTRL_PortPD_T entry;

    /* dispatch node to set write method
     */
    switch (vp->magic)
    {
        default:
            *write_method = 0;
            break;
    }

    /* check compc, retrive compl
     */
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl,
        PORTPDENTRY_INSTANCE_LEN);

    memset(&entry, 0, sizeof(entry));

    /* dispatch get-exact versus get-next
     */
    if (exact)  /* get or set */
    {
        /* extract index
         */
        if (! portPDTable_OidIndexToData(exact, compc, compl, &entry.port_pd_ifindex))
        {
            return NULL;
        }

        /* get-exact from core layer
         */
        if (! SWCTRL_PMGR_GetPDPortStatus(&entry))
        {
            return NULL;
        }
    }
    else  /* get-next */
    {
        /* extract index
         */
        portPDTable_OidIndexToData(exact, compc, compl, &entry.port_pd_ifindex);

        /* Check the length of inputing index.  If compc is less than the
         * instance length, we should try get {A.B.C.0.0...}, where A.B.C was
         * obtained from the "..._OidIndexToData" function call, and
         * 0.0... was initialized in the beginning of this function.
         * This instance may exist in the core layer.
         */
        if (compc < PORTPDENTRY_INSTANCE_LEN)  /* incomplete index */
        {
            /* get-exact, in case this instance exists
             */
            if (! SWCTRL_PMGR_GetPDPortStatus(&entry))
            {
                /* get-next according to lexicographic order; if none, fail
                 */
                if (! SWCTRL_PMGR_GetNextPDPortStatus(&entry))
                {
                    return NULL;
                }
            }
        }
        else   /* complete index */
        {
            /* get-next according to lexicographic order; if none, fail
             */
            if (! SWCTRL_PMGR_GetNextPDPortStatus(&entry))
            {
                return NULL;
            }
        }
    }

    /* copy base OID (without index) to output
     */
    memcpy(name, vp->name, vp->namelen * sizeof(oid));

    /* assign data to the OID index
     */
    best_inst[0] = entry.port_pd_ifindex;
    memcpy(name + vp->namelen, best_inst, PORTPDENTRY_INSTANCE_LEN * sizeof(oid));
    *length = vp->namelen + PORTPDENTRY_INSTANCE_LEN;

    /* dispatch node to read value
     */
    switch (vp->magic)
    {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case LEAF_portPDIfIndex:
            *var_len = sizeof(long_return);
            long_return = entry.port_pd_ifindex;
            return (u_char *) &long_return;
#endif  /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

        case LEAF_portPDStatus:
            *var_len = sizeof(long_return);
            long_return = entry.port_pd_status;
            return (u_char *) &long_return;

#if (SYS_HWCFG_SUPPORT_PD_MODE_DETECT == TRUE)
        case LEAF_portPDMode:
            *var_len = sizeof(long_return);
            long_return = entry.port_pd_mode;
            return (u_char *) &long_return;
#endif

        default:
            ERROR_MSG("");
            break;
    }

    /* return failure
     */
    return NULL;
}

#endif /* End of #if (SYS_HWCFG_SUPPORT_PD == TRUE) */

#if (SYS_CPNT_SWCTRL_FEC == TRUE)
/***** portFecTable *****/
#define PORTFECENTRY_INSTANCE_LEN  1

BOOL_T portFecTable_OidIndexToData(UI32_T exact, UI32_T compc,
    oid *compl, UI32_T *portFecIfIndex)
{
    /* get or set
     */
    if (exact)
    {
        /* check the index length
         */
        if (compc != PORTFECENTRY_INSTANCE_LEN)  /* the constant size index */
        {
            return FALSE;
        }
    }

    *portFecIfIndex = compl[0];

    return TRUE;
}

int
write_portFecMode(int action,
                             u_char   *var_val,
                             u_char var_val_type,
                             size_t var_val_len,
                             u_char   *statP,
                             oid      *name,
                             size_t name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            /* check valid values
             */
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            I32_T value = 0;
            UI32_T ifindex = 0;

            if (portFecTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &ifindex) == FALSE)
                return SNMP_ERR_COMMITFAILED;

            value = *(long *)var_val;
            if (!SWCTRL_PMGR_SetPortFec(ifindex, value))
                return SNMP_ERR_COMMITFAILED;

            break;
        }

        case UNDO :
            break;

        case COMMIT :
            break;
    }

    return SNMP_ERR_NOERROR;
}

/*
 * var_portFecTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *var_portFecTable(struct variable *vp,
    oid *name,
    size_t *length,
    int exact,
    size_t *var_len,
    WriteMethod **write_method)
{
    UI32_T compc = 0;
    oid compl[PORTFECENTRY_INSTANCE_LEN] = {0};
    oid best_inst[PORTFECENTRY_INSTANCE_LEN] = {0};
    Port_Info_T port_info;
    UI32_T ifindex;

    /* dispatch node to set write method
     */
    switch (vp->magic)
    {
        case LEAF_portFecMode:
            *write_method = write_portFecMode;
            break;

        default:
            *write_method = 0;
            break;
    }

    /* check compc, retrive compl
     */
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl,
        PORTFECENTRY_INSTANCE_LEN);

    ifindex = 0;

    /* dispatch get-exact versus get-next
     */
    if (exact)  /* get or set */
    {
        /* extract index
         */
        if (FALSE == portFecTable_OidIndexToData(exact, compc, compl, &ifindex))
        {
            return NULL;
        }

        /* get-exact from core layer
         */
        if (!SWCTRL_POM_GetPortInfo(ifindex, &port_info))
        {
            return NULL;
        }
    }
    else  /* get-next */
    {
        /* extract index
         */
        portFecTable_OidIndexToData(exact, compc, compl, &ifindex);

        /* Check the length of inputing index.  If compc is less than the
         * instance length, we should try get {A.B.C.0.0...}, where A.B.C was
         * obtained from the "..._OidIndexToData" function call, and
         * 0.0... was initialized in the beginning of this function.
         * This instance may exist in the core layer.
         */
        if (compc < PORTFECENTRY_INSTANCE_LEN)  /* incomplete index */
        {
            /* get-exact, in case this instance exists
             */
            if (!SWCTRL_POM_GetPortInfo(ifindex, &port_info))
            {
                /* get-next according to lexicographic order; if none, fail
                 */
                if (!SWCTRL_POM_GetNextPortInfo(&ifindex, &port_info))
                {
                    return NULL;
                }
            }
        }
        else   /* complete index */
        {
            /* get-next according to lexicographic order; if none, fail
             */
            if (!SWCTRL_POM_GetNextPortInfo(&ifindex, &port_info))
            {
                return NULL;
            }
        }
    }

    /* copy base OID (without index) to output
     */
    memcpy(name, vp->name, vp->namelen * sizeof(oid));

    /* assign data to the OID index
     */
    best_inst[0] = ifindex;
    memcpy(name + vp->namelen, best_inst, PORTFECENTRY_INSTANCE_LEN * sizeof(oid));
    *length = vp->namelen + PORTFECENTRY_INSTANCE_LEN;

    /* dispatch node to read value
     */
    switch (vp->magic)
    {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case LEAF_portFecIfIndex:
            *var_len = sizeof(long_return);
            long_return = ifindex;
            return (u_char *) &long_return;
#endif  /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

        case LEAF_portFecMode:
            *var_len = sizeof(long_return);
            long_return = port_info.port_fec_mode;
            return (u_char *) &long_return;

        case LEAF_portFecStatus:
            *var_len = sizeof(long_return);
            long_return = port_info.port_fec_status;
            return (u_char *) &long_return;

        default:
            ERROR_MSG("");
            break;
    }

    /* return failure
     */
    return NULL;
}
#endif /* (SYS_CPNT_SWCTRL_FEC == TRUE) */

/********************************************
 ******************trunkMgt******************
 ********************************************
 */
int
get_trunkValidNumber(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
             {
            UI32_T trunkValidNum;



    if (!TRK_PMGR_GetTrunkValidNumber(&trunkValidNum))
         return SNMP_ERR_NOERROR;


                   long_return = trunkValidNum;
                  snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
            }
            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
get_trunkMaxId(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
            {
            UI32_T  trunkMaxId;



    if (!TRK_PMGR_GetTrunkMaxId(&trunkMaxId))
         return SNMP_ERR_NOERROR;


                   long_return = trunkMaxId;
                  snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
            }
            break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_trunkBalanceMode(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    switch(reqinfo->mode) {

        case MODE_GET:
        {
            UI32_T balance_mode;

            if (!SWCTRL_POM_GetTrunkBalanceMode(&balance_mode))
            {
                return  SNMP_ERR_GENERR;
            }

            long_return = balance_mode;

            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
        }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
            }
            break;

        case MODE_SET_RESERVE2:
            switch (*requests->requestvb->val.integer)
            {
                case VAL_trunkBalanceMode_macSrc:
                case VAL_trunkBalanceMode_macDst:
                case VAL_trunkBalanceMode_macSrcDst:
                case VAL_trunkBalanceMode_ipSrc:
                case VAL_trunkBalanceMode_ipDst:
                case VAL_trunkBalanceMode_ipSrcDst:
                    break;

                default:
                    netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
        {
            UI32_T balance_mode;
            balance_mode = (*requests->requestvb->val.integer);

            if (!SWCTRL_PMGR_SetTrunkBalanceMode(balance_mode))
            {
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
            }
        }
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */

            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

/********************************************
 ******************trunkTable****************
 ********************************************
 */
#if 0
static int
header_trunkTable(struct variable *vp,
               oid * name,
               size_t * length,
               int exact, size_t * var_len, WriteMethod ** write_method)
{
    oid             newname[MAX_OID_LEN];
    int    interface;
    int             result;
   TRK_MGR_TrunkEntry_T  entry;
   int ifIndex = 0;
   BOOL_T return_val;

   UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;

    memcpy((char *) newname, (char *) vp->name,
           (int) vp->namelen * sizeof(oid));
    /*
     * find "next" interface
     */

       entry.trunk_index = ifIndex;
     while (  (return_val= TRK_PMGR_GetNextTrunkEntry( &entry))==TRUE)
     {

        ifIndex = entry.trunk_index;
        newname[oid_name_length] = (oid) ifIndex;
        result =
            snmp_oid_compare(name, *length, newname,
                             (int) vp->namelen + 1);
        if ((exact && (result == 0)) || (!exact && (result < 0)))
            break;
    }
    if (!return_val ) {

        return MATCH_FAILED;
    }


    memcpy((char *) name, (char *) newname,
           ((int) vp->namelen + 1) * sizeof(oid));
    *length = vp->namelen + 1;
    *var_len = sizeof(long);    /* default to 'long' results */
    interface = newname[oid_name_length];



    return interface;
}
#else
static int
header_trunkTable(struct variable *vp,
               oid * name,
               size_t * length,
               int exact, size_t * var_len,
               TRK_MGR_TrunkEntry_T  *entry)
{
  unsigned int  ifIndex = 0;

     if(!entry || l_snmp_index_get(vp,name,length,&ifIndex,exact) < 0 )
        return MATCH_FAILED;
    /*
     * find "next" interface
     */
     entry->trunk_index = ifIndex;
    if(!exact){

     if  (TRK_PMGR_GetNextTrunkEntry(entry)!=TRUE)
       return MATCH_FAILED;

     l_snmp_index_set(vp,name,length,entry->trunk_index);
   }
   else
   {
       if(TRK_PMGR_GetTrunkEntry(entry)!=TRUE)
           return MATCH_FAILED;

   }

    *var_len = sizeof(long);    /* default to 'long' results */

    return TRUE;
}

#endif

/*
 * var_trunkTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *
var_trunkTable(struct variable *vp,
            oid     *name,
            size_t  *length,
            int     exact,
            size_t  *var_len,
            WriteMethod **write_method)
{
   TRK_MGR_TrunkEntry_T  entry;


     switch(vp->magic)
     {
    case TRUNKPORTS:
        *write_method = write_trunkPorts;
      break;
    case TRUNKCREATION:
        *write_method= 0;
        break;
    case TRUNKSTATUS:
        *write_method = write_trunkStatus;
      break;
#if defined(ACD)
        case TRUNKGROUP:
        *write_method = write_trunkGroup;
         break;
  #endif
      }

   memset( &entry, 0, sizeof(entry));
    if(MATCH_FAILED ==header_trunkTable(vp, name, length, exact, var_len, &entry))
     return NULL;
    /*
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
   #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    case TRUNKINDEX:
        long_return = entry.trunk_index;
        return (u_char*) &long_return;
    #endif
    case TRUNKPORTS:
        *var_len = SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK * SYS_ADPT_NBR_OF_BYTE_FOR_1BIT_UPORT_LIST;
        memcpy( return_buf, entry.trunk_ports, SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK * SYS_ADPT_NBR_OF_BYTE_FOR_1BIT_UPORT_LIST);
        return (u_char*) return_buf;
    case TRUNKCREATION:
        long_return = entry.trunk_creation;
        return (u_char*) &long_return;
    case TRUNKSTATUS:
         long_return = entry.trunk_status;
        return (u_char*) &long_return;
#if defined(ACD)
    case TRUNKGROUP:
        long_return = entry.trunk_group;
        return (u_char*) &long_return;
 #endif
    default:
      ERROR_MSG("");
    }
    return NULL;
}


int
write_trunkPorts(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    int size,i;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
    UI8_T buffer[SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK * SYS_ADPT_NBR_OF_BYTE_FOR_1BIT_UPORT_LIST];


      if ((char) name[oid_name_length-1] != TRUNKPORTS)
     {
        return SNMP_ERR_NOTWRITABLE;
    }

      /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK * SYS_ADPT_NBR_OF_BYTE_FOR_1BIT_UPORT_LIST * sizeof(char)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          size  = var_val_len;


          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             size  = var_val_len;
         memcpy(buffer, var_val, size);

             for (i =size; i< SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK * SYS_ADPT_NBR_OF_BYTE_FOR_1BIT_UPORT_LIST ; i ++)
                      buffer[i] = 0;

         if (TRK_PMGR_SetTrunkPorts (name[oid_name_length], buffer) != TRUE)

             return SNMP_ERR_COMMITFAILED;
           break;


        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_trunkStatus(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;

      /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          value = *(long *)var_val;
          if ((value <1) || (value >2))
             return SNMP_ERR_WRONGVALUE;



          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */

          value = * (long *) var_val;

          switch(value)
          {
          case VAL_trunkStatus_valid:
               if (TRK_PMGR_CreateTrunk(name[oid_name_length]) != TRUE)
                 return SNMP_ERR_COMMITFAILED;
              if (TRK_PMGR_SetTrunkStatus(name[oid_name_length], VAL_trunkStatus_valid ) != TRUE)
                    return SNMP_ERR_COMMITFAILED;
              break;
           case VAL_trunkStatus_invalid:
                if (TRK_PMGR_SetTrunkStatus(name[oid_name_length], VAL_trunkStatus_invalid ) != TRUE)
                  return SNMP_ERR_COMMITFAILED;
              if (TRK_PMGR_DestroyTrunk(name[oid_name_length]) != TRUE)
                    return SNMP_ERR_COMMITFAILED;
                break;
           }
           break;
        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

#if defined (ACD)
int
write_trunkGroup(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;

      /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          value = *(long *)var_val;
          if ((value <MIN_trunkGroup) || (value >MAX_trunkGroup))
             return SNMP_ERR_WRONGVALUE;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             value = * (long *) var_val;

             switch(value)
          {
          case 0:
               if (TRK_PMGR_DeleteTrunkGroup(name[oid_name_length],1, 0) != TRUE)
                 return SNMP_ERR_COMMITFAILED;

              break;
            default:
                if (TRK_PMGR_AddTrunkGroup(name[oid_name_length], 1, value ) != TRUE)
                  return SNMP_ERR_COMMITFAILED;
                break;
           }
           break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
#endif

/********************************************
 ******************lacpPortTable*************
 ********************************************
 */
static int
header_lacpPortTable(struct variable *vp,
               oid * name,
               size_t * length,
               int exact, size_t * var_len, WriteMethod ** write_method,
               LACP_MGR_Dot3adLacpPortEntry_T  *entry)
{

  unsigned int ifIndex = 0;


    if(!entry || l_snmp_index_get(vp,name,length,&ifIndex,exact) < 0 )
        return MATCH_FAILED;

    /*
     * find "next" interface
     */
       entry->dot3ad_lacp_port_index = ifIndex;
     if(!exact){
        if( LACP_PMGR_GetNextDot3adLacpPortEntry( entry)!=TRUE)
          return MATCH_FAILED;

         l_snmp_index_set(vp,name,length,entry->dot3ad_lacp_port_index);
    }
    else
    {
      if(LACP_PMGR_GetDot3adLacpPortEntry(entry)!=TRUE)
            return MATCH_FAILED;
    }


    *write_method = 0;
    *var_len = sizeof(long);    /* default to 'long' results */


    return entry->dot3ad_lacp_port_index;
}


/*
 * var_lacpPortTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *
var_lacpPortTable(struct variable *vp,
            oid     *name,
            size_t  *length,
            int     exact,
            size_t  *var_len,
            WriteMethod **write_method)
{
   LACP_MGR_Dot3adLacpPortEntry_T  entry;

   memset( &entry, 0, sizeof(entry));
   if(MATCH_FAILED ==header_lacpPortTable(vp, name, length, exact, var_len, write_method,&entry))
      return NULL;
    /*
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
  #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE==1)
    case LACPPORTINDEX:
        long_return = entry.dot3ad_lacp_port_index;
        return (u_char*) &long_return;
  #endif
   case LACPPORTSTATUS:
        *write_method = write_lacpPortStatus;
       long_return = entry.dot3ad_lacp_port_status;
        return (u_char*) &long_return;
    default:
      ERROR_MSG("");
    }
    return NULL;
}


int
write_lacpPortStatus(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
   /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          value = *(long *)var_val;
          if ((value <1) || (value >2))
             return SNMP_ERR_WRONGVALUE;


          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
                value = * (long *) var_val;
               if (LACP_PMGR_SetDot3adLacpPortEnabled(name[oid_name_length], value) != LACP_RETURN_SUCCESS)
                 return SNMP_ERR_COMMITFAILED;
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

/********************************************
 *****************staMgt*********************
 ********************************************
 */
int
do_staSystemStatus(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:

                 #if (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_RSTP) || (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_MSTP)
                   {
                    UI32_T status;
                 if (XSTP_POM_GetSystemSpanningTreeStatus(&status) != TRUE)
                       return SNMP_ERR_GENERR;
                  long_return = status;
                     snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
                     }

                #else
                {
                 STA_MGR_StaEntry_T data;
                 if (STA_MGR_GetStaEntry(&data) != TRUE)
         return SNMP_ERR_NOERROR;
                   long_return = data.sta_system_status;
                  snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
            }

                 #endif
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
            }
            break;

        case MODE_SET_RESERVE2:
            switch (*requests->requestvb->val.integer)
            {
                case VAL_staSystemStatus_enabled:
                    break;

                case VAL_staSystemStatus_disabled:
                    break;

                default:
                    netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:

            {
                UI32_T staSystemStatus;
                staSystemStatus = (*requests->requestvb->val.integer);

           #if (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_RSTP) || (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_MSTP)
                 if (XSTP_PMGR_SetSystemSpanningTreeStatus(staSystemStatus) != XSTP_TYPE_RETURN_OK)
           #else
                 if (STA_MGR_SetStaSystemStatus(staSystemStatus) != STA_RETURN_OK)
            #endif
                 netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_COMMIT:

            break;

        case MODE_SET_UNDO:

            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

#if (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_RSTP) || (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_MSTP)


int
do_staProtocolType(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:


        {

            UI32_T  version;
            if (XSTP_POM_GetSystemSpanningTreeVersion(&version) != TRUE)
                return  SNMP_ERR_GENERR;

            switch( version)
            {
                case XSTP_TYPE_STP_PROTOCOL_VERSION_ID:
                    long_return = VAL_staProtocolType_stp;
                    break;
                case XSTP_TYPE_RSTP_PROTOCOL_VERSION_ID:
                    long_return = VAL_staProtocolType_rstp;
                    break;
                case XSTP_TYPE_MSTP_PROTOCOL_VERSION_ID:
                    long_return = VAL_staProtocolType_mstp;
                    break;
            }

            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
        }

            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
            }
            break;

        case MODE_SET_RESERVE2:
            switch (*requests->requestvb->val.integer)
            {
                case VAL_staProtocolType_stp:
                    break;

                case VAL_staProtocolType_rstp:
                    break;

                case VAL_staProtocolType_mstp:
                    break;

                default:
                    netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
        {
            UI32_T staProtocolType;
            staProtocolType = (*requests->requestvb->val.integer);
            switch (staProtocolType)
            {
                case VAL_staProtocolType_stp:
                    staProtocolType = XSTP_TYPE_STP_PROTOCOL_VERSION_ID;
                    break;
                case VAL_staProtocolType_rstp:
                    staProtocolType = XSTP_TYPE_RSTP_PROTOCOL_VERSION_ID;
                    break;
                case VAL_staProtocolType_mstp:
                    staProtocolType = XSTP_TYPE_MSTP_PROTOCOL_VERSION_ID;
                    break;
            }
            if (XSTP_PMGR_SetSystemSpanningTreeVersion( staProtocolType)!= XSTP_TYPE_RETURN_OK)
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
        }
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */

            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}


int
do_staTxHoldCount(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
              {

                UI32_T staTxHoldCount;
        if (XSTP_POM_GetTransmissionLimit( &staTxHoldCount) != TRUE)
                   return  SNMP_ERR_GENERR;

                   long_return = staTxHoldCount;
                  snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
            }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
            }
            break;

        case MODE_SET_RESERVE2:

            if (*requests->requestvb->val.integer < MIN_staTxHoldCount ||
                *requests->requestvb->val.integer > MAX_staTxHoldCount)
            {
               netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
           {
               UI32_T staTxHoldCount;
               staTxHoldCount = (*requests->requestvb->val.integer);

                if (XSTP_PMGR_SetTransmissionLimit(staTxHoldCount) != XSTP_TYPE_RETURN_OK)
                  netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */

            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */

            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}


int
do_staPathCostMethod(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:

             {

                UI32_T staPathCostMethod;
                if (XSTP_POM_GetPathCostMethod_Ex(&staPathCostMethod) != TRUE)
                   return  SNMP_ERR_GENERR;

                   long_return = staPathCostMethod;
                  snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
            }

            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
            }
            break;

        case MODE_SET_RESERVE2:
            switch (*requests->requestvb->val.integer)
            {
                case VAL_staPathCostMethod_short:
                    break;

                case VAL_staPathCostMethod_long:
                    break;

                default:
                    netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
            {
               UI32_T staPathCostMethod;
               staPathCostMethod = (*requests->requestvb->val.integer);

                  if (XSTP_PMGR_SetPathCostMethod(staPathCostMethod) !=XSTP_TYPE_RETURN_OK)
                  netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */

            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */

            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

#if(SYS_CPNT_XSTP_TC_PROP_GROUP == TRUE)
#define STATCPROPGROUPENTRY_INSTANCE_LEN  1

BOOL_T staTcPropGroupTable_OidIndexToData(UI32_T exact, UI32_T compc,
    oid *compl, UI32_T *staTcPropGroupIndex)
{
    /* get or set
     */
    if (exact)
    {
        /* check the index length
         */
        if (compc != STATCPROPGROUPENTRY_INSTANCE_LEN) /* the constant size index */
        {
            return FALSE;
        }
    }

    *staTcPropGroupIndex = compl[0];

    return TRUE;
}

/*
 * var_staTcPropGroupTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *var_staTcPropGroupTable(struct variable *vp,
    oid *name,
    size_t *length,
    int exact,
    size_t *var_len,
    WriteMethod **write_method)
{
    UI32_T compc = 0;
    oid compl[STATCPROPGROUPENTRY_INSTANCE_LEN] = {0};
    oid best_inst[STATCPROPGROUPENTRY_INSTANCE_LEN] = {0};
    UI32_T group_id=0;
    BOOL_T have_port = FALSE;
    UI8_T portbitmap[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST] = {0};

    switch (vp->magic)
    {
        case LEAF_staTcPropGroupPorts:
            *write_method = write_staTcPropGroupPorts;
            break;

        default:
            *write_method = 0;
            break;
    }

    /* check compc, retrive compl
     */
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl, STATCPROPGROUPENTRY_INSTANCE_LEN);

    memset(portbitmap, 0, sizeof(portbitmap));

    if (exact) /* get or set */
    {
        if (staTcPropGroupTable_OidIndexToData(exact, compc, compl, &group_id) == FALSE)
        {
            return NULL;
        }

        if (XSTP_POM_GetTcPropGroupPortbitmap(group_id, portbitmap, &have_port) != TRUE)
        {
            return NULL;
        }
    }
    else /* getnext */
    {
        staTcPropGroupTable_OidIndexToData(exact, compc, compl, &group_id);

        /* check the length of inputing index,if < 1 we should try get
         * {0.0.0.0.0...}
         */
        if (compc < 1)
        {
            group_id =1;

            if (XSTP_POM_GetTcPropGroupPortbitmap(group_id, portbitmap, &have_port) != TRUE)
            {
                if (XSTP_POM_GetTcPropNextGroupPortbitmap(&group_id, portbitmap, &have_port) != TRUE)
                {
                    return NULL;
                }
            }
        }
        else
        {
            if ((group_id < XSTP_TYPE_TC_PROP_MIN_GROUP_ID) || (group_id > XSTP_TYPE_TC_PROP_MAX_GROUP_ID))
                return NULL;

            if (XSTP_POM_GetTcPropNextGroupPortbitmap(&group_id, portbitmap, &have_port) != TRUE)
            {
                return NULL;
            }
        }
    }

    memcpy(name, vp->name, vp->namelen * sizeof(oid));

    /* assign data to the oid index
     */
    best_inst[0] = group_id;
    memcpy(name + vp->namelen, best_inst, STATCPROPGROUPENTRY_INSTANCE_LEN * sizeof(oid));
    *length = vp->namelen + STATCPROPGROUPENTRY_INSTANCE_LEN;

    switch (vp->magic)
    {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case LEAF_staTcPropGroupIndex:
            *var_len = sizeof(long_return);
            long_return = group_id;
            return (u_char *) &long_return;
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

        case LEAF_staTcPropGroupPorts:
            *var_len = SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST;
            memcpy(return_buf, portbitmap, *var_len);
            return (u_char *) return_buf;

        default:
            ERROR_MSG("");
    }

    return NULL;
}

int write_staTcPropGroupPorts(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_OCTET_STR)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST)
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;

        case RESERVE2:
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            UI32_T staTcPropGroupIndex = 0;
            UI32_T i = 0;
            BOOL_T is_add=FALSE;
            BOOL_T have_member = FALSE;
            UI8_T  byte_buffer[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST] = {0};

            if (staTcPropGroupTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &staTcPropGroupIndex) == FALSE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            memcpy(byte_buffer, var_val, var_val_len);

            for (i=0; i<SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST; i++)
            {
                if (byte_buffer[i] != 0)
                {
                    is_add = TRUE;
                    break;
                }
            }

            if (is_add == FALSE)
            {
                if (!XSTP_POM_GetTcPropGroupPortbitmap(staTcPropGroupIndex, byte_buffer, &have_member))
                {
                    return SNMP_ERR_COMMITFAILED;
                }

            }

            if (XSTP_PMGR_SetTcPropGroupPortList(is_add, staTcPropGroupIndex, byte_buffer) != XSTP_TYPE_RETURN_OK)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}
#endif /*#if(SYS_CPNT_XSTP_TC_PROP_GROUP == TRUE)*/

#endif

/********************************************
 ****************staPortTable****************
 ********************************************
 */

#define STAPORTENTRY_INSTANCE_LEN  1

BOOL_T staPortTable_OidIndexToData(UI32_T exact, UI32_T compc,
    oid *compl, UI32_T *index_p)
{
    /* get or set
     */
    if (exact)
    {
        /* check the index length
         */
        if (compc != STAPORTENTRY_INSTANCE_LEN) /* the constant size index */
        {
            return FALSE;
        }
    }

    *index_p = compl[0];

    return TRUE;
}

static BOOL_T sta_get_entry(UI32_T lport, void *entry_p)
{
#if (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_RSTP) || (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_MSTP)
    return XSTP_POM_GetDot1dMstExtPortEntry(0, lport, entry_p);
#else
    ((STA_MGR_StaPortEntry_T *)entry_p)->sta_port_index = lport;
    return STA_MGR_GetStaPortEntry(entry_p);
#endif /* #if (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_RSTP) || (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_MSTP) */
}

static BOOL_T sta_getnext_entry(UI32_T *lport_p, void *entry_p)
{
#if (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_RSTP) || (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_MSTP)
    return XSTP_POM_GetNextDot1dMstExtPortEntry(0, lport_p, entry_p);
#else
    ((STA_MGR_StaPortEntry_T *)entry_p)->sta_port_index = lport;
    return STA_MGR_GetNextStaPortEntry(entry_p);
#endif /* #if (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_RSTP) || (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_MSTP) */
}

/*
 * var_staPortTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *var_staPortTable(struct variable *vp,
    oid *name,
    size_t *length,
    int exact,
    size_t *var_len,
    WriteMethod **write_method)
{
    UI32_T compc = 0;
    UI32_T lport;
    oid compl[STAPORTENTRY_INSTANCE_LEN] = {0};
    oid best_inst[STAPORTENTRY_INSTANCE_LEN] = {0};

#if (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_RSTP) || (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_MSTP)
    XSTP_MGR_Dot1dStpExtPortEntry_T entry;
#else
    STA_MGR_StaPortEntry_T entry;
#endif /* #if (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_RSTP) || (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_MSTP) */

    switch (vp->magic)
    {
#if (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_STA)
        case LEAF_staPortFastForward:
            *write_method = write_staPortFastForward;
            break;
#endif

#if (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_RSTP) || (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_MSTP)
        case LEAF_staPortProtocolMigration:
            *write_method = write_staPortProtocolMigration;
            break;

#if (SYS_CPNT_STP_AUTO_EDGE_PORT != TRUE)
        case LEAF_staPortAdminEdgePort:
            *write_method = write_staPortAdminEdgePort;
            break;
#endif /* #if (SYS_CPNT_STP_AUTO_EDGE_PORT != TRUE) */

        case LEAF_staPortAdminPointToPoint:
            *write_method = write_staPortAdminPointToPoint;
            break;

        case LEAF_staPortSystemStatus:
            *write_method = write_staPortSystemStatus;
            break;

        case LEAF_staPortLongAdminPathCost:
            *write_method = write_staPortLongAdminPathCost;
            break;
#if (SYS_CPNT_STP_BPDU_GUARD == TRUE)
        case LEAF_staPortBpduGuard:
            *write_method = write_staPortBpduGuard;
            break;
#endif /* #if (SYS_CPNT_STP_BPDU_GUARD == TRUE) */

#if (SYS_CPNT_STP_AUTO_EDGE_PORT == TRUE)
        case LEAF_staPortAdminEdgePortWithAuto:
            *write_method = write_staPortAdminEdgePortWithAuto;
            break;
#endif /* #if (SYS_CPNT_STP_AUTO_EDGE_PORT == TRUE) */

#if (SYS_CPNT_STP_BPDU_FILTER == TRUE)
        case LEAF_staPortBpduFilter:
            *write_method = write_staPortBpduFilter;
            break;
#endif /* #if (SYS_CPNT_STP_BPDU_FILTER == TRUE) */

#if (SYS_CPNT_STP_ROOT_GUARD == TRUE)
        case LEAF_staPortRootGuardStatus:
            *write_method = write_staPortRootGuardStatus;
            break;
#endif /* #if (SYS_CPNT_STP_ROOT_GUARD == TRUE) */

#if (SYS_CPNT_STP_BPDU_GUARD == TRUE)
        case LEAF_staPortBpduGuardAutoRecovery:
            *write_method = write_staPortBpduGuardAutoRecovery;
            break;
        case LEAF_staPortBpduGuardAutoRecoveryInterval:
            *write_method = write_staPortBpduGuardAutoRecoveryInterval;
            break;
#endif
#if(SYS_CPNT_XSTP_TC_PROP_STOP == TRUE)
        case LEAF_staPortTcPropStop:
            *write_method = write_staPortTcPropStop;
            break;
#endif
#endif /* #if (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_RSTP) || (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_MSTP) */

        default:
            *write_method = 0;
            break;
    }

    /* check compc, retrive compl
     */
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl, STAPORTENTRY_INSTANCE_LEN);

    memset(&entry, 0, sizeof(entry));

    if (exact) /* get or set */
    {
        if (staPortTable_OidIndexToData(exact, compc, compl, &lport) == FALSE)
        {
            return NULL;
        }

        if (sta_get_entry(lport, &entry) != TRUE)
        {
            return NULL;
        }
    }
    else /* getnext */
    {
        staPortTable_OidIndexToData(exact, compc, compl, &lport);

        /* check the length of inputing index,if < 1 we should try get
         * {0.0.0.0.0...}
         */
        if (compc < 1)
        {
            if (sta_get_entry(lport, &entry) != TRUE)
            {
                if (sta_getnext_entry(&lport, &entry) != TRUE)
                {
                    return NULL;
                }
            }
        }
        else
        {
            if (sta_getnext_entry(&lport, &entry) != TRUE)
            {
                return NULL;
            }
        }
    }

    memcpy(name, vp->name, vp->namelen * sizeof(oid));

    /* assign data to the oid index
     */
    best_inst[0] = lport;
    memcpy(name + vp->namelen, best_inst, STAPORTENTRY_INSTANCE_LEN * sizeof(oid));
    *length = vp->namelen + STAPORTENTRY_INSTANCE_LEN;

    switch (vp->magic)
    {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case LEAF_staPortIndex:
            *var_len = sizeof(long_return);
            long_return = lport;
            return (u_char *) &long_return;
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

#if (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_STA)
        case LEAF_staPortFastForward:
            *var_len = sizeof(long_return);
            long_return = entry.sta_port_mgt_fast_forward;
            return (u_char *) &long_return;
#endif /* #if (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_STA) */

#if (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_RSTP) || (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_MSTP)
        case LEAF_staPortProtocolMigration:
            *var_len = sizeof(long_return);
            long_return = entry.dot1d_stp_port_protocol_migration;
            return (u_char *) &long_return;

#if (SYS_CPNT_STP_AUTO_EDGE_PORT != TRUE)
        case LEAF_staPortAdminEdgePort:
            *var_len = sizeof(long_return);
            long_return = entry.dot1d_stp_port_admin_edge_port;
            return (u_char *) &long_return;
#endif /* #if (SYS_CPNT_STP_AUTO_EDGE_PORT != TRUE) */

        case LEAF_staPortOperEdgePort:
            *var_len = sizeof(long_return);
            long_return = entry.dot1d_stp_port_oper_edge_port;
            return (u_char *) &long_return;

        case LEAF_staPortAdminPointToPoint:
            *var_len = sizeof(long_return);
            long_return = entry.dot1d_stp_port_admin_point_to_point;
            return (u_char *) &long_return;

        case LEAF_staPortOperPointToPoint:
            *var_len = sizeof(long_return);
            long_return = entry.dot1d_stp_port_oper_point_to_point;
            return (u_char *) &long_return;

        case LEAF_staPortSystemStatus:
            *var_len = sizeof(long_return);
            long_return = entry.dot1d_stp_port_spanning_tree_status;
            return (u_char *) &long_return;

        case LEAF_staPortLongAdminPathCost:
            *var_len = sizeof(long_return);
            long_return = entry.port_admin_long_path_cost;
            return (u_char *) &long_return;

        case LEAF_staPortLongOperPathCost:
            *var_len = sizeof(long_return);
            long_return = entry.port_oper_long_path_cost;
            return (u_char *) &long_return;
#if (SYS_CPNT_STP_BPDU_GUARD == TRUE)
        case LEAF_staPortBpduGuard:
            *var_len = sizeof(long_return);
            long_return = entry.port_bpdu_guard_status;
            return (u_char *) &long_return;
#endif /* #if (SYS_CPNT_STP_BPDU_GUARD == TRUE) */

#if (SYS_CPNT_STP_AUTO_EDGE_PORT == TRUE)
        case LEAF_staPortAdminEdgePortWithAuto:
            *var_len = sizeof(long_return);
            long_return = entry.dot1d_stp_port_admin_edge_port;
            return (u_char *) &long_return;
#endif /* #if (SYS_CPNT_STP_AUTO_EDGE_PORT == TRUE) */

#if (SYS_CPNT_STP_BPDU_FILTER == TRUE)
        case LEAF_staPortBpduFilter:
            *var_len = sizeof(long_return);
            long_return = entry.port_bpdu_filter_status;
            return (u_char *) &long_return;
#endif /* #if (SYS_CPNT_STP_BPDU_FILTER == TRUE) */

#if (SYS_CPNT_STP_ROOT_GUARD == TRUE)
        case LEAF_staPortRootGuardStatus:
            *var_len = sizeof(long_return);
            long_return = entry.port_root_guard_status;
            return (u_char *) &long_return;
#endif /* #if (SYS_CPNT_STP_ROOT_GUARD == TRUE) */

#if (SYS_CPNT_STP_BPDU_GUARD == TRUE)
        case LEAF_staPortBpduGuardAutoRecovery:
            *var_len = sizeof(long_return);
            long_return = entry.port_bpdu_guard_auto_recovery;
            return (u_char*) &long_return;

        case LEAF_staPortBpduGuardAutoRecoveryInterval:
            *var_len = sizeof(long_return);
            long_return = entry.port_bpdu_guard_auto_recovery_interval;
            return (u_char*) &long_return;
#endif
#if(SYS_CPNT_XSTP_TC_PROP_STOP == TRUE)
        case LEAF_staPortTcPropStop:
            *var_len = sizeof(long_return);
            long_return = entry.tc_prop_stop?VAL_staPortTcPropStop_true:VAL_staPortTcPropStop_false;
            return (u_char *) &long_return;
#endif
#endif /* #if (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_RSTP) || (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_MSTP) */

        default:
            ERROR_MSG("");
    }

    return NULL;
}

#if (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_STA)
int write_staPortFastForward(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            switch (*(long *)var_val)
            {
                case VAL_staPortFastForward_enabled:
                    break;

                case VAL_staPortFastForward_disabled:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            I32_T value = 0;
            UI32_T index = 0;

            if (staPortTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &index) == FALSE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            value = *(long *)var_val;

#if (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_RSTP) || (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_MSTP)
            if (XSTP_PMGR_SetPortAdminEdgePort(index, value) != XSTP_TYPE_RETURN_OK)
#else
            if (STA_MGR_SetStaPortMgtFastForward(index, value) != STA_RETURN_OK)
#endif /* #if (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_RSTP) || (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_MSTP) */
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}
#endif /* #if (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_STA) */

#if (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_RSTP) || (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_MSTP)
int write_staPortProtocolMigration(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            switch (*(long *)var_val)
            {
                case VAL_staPortProtocolMigration_true:
                    break;

                case VAL_staPortProtocolMigration_false:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            I32_T value = 0;
            UI32_T index = 0;

            if (staPortTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &index) == FALSE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            value = *(long *)var_val;

            if (XSTP_PMGR_SetPortProtocolMigration(index, value) != XSTP_TYPE_RETURN_OK)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

#if (SYS_CPNT_STP_AUTO_EDGE_PORT != TRUE)
int write_staPortAdminEdgePort(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            switch (*(long *)var_val)
            {
                case VAL_staPortAdminEdgePort_true:
                    break;

                case VAL_staPortAdminEdgePort_false:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            I32_T value = 0;
            UI32_T index = 0;

            if (staPortTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &index) == FALSE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            value = *(long *)var_val;

            if (XSTP_PMGR_SetPortAdminEdgePort(index, value) != XSTP_TYPE_RETURN_OK)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}
#endif /* #if (SYS_CPNT_STP_AUTO_EDGE_PORT != TRUE) */

int write_staPortAdminPointToPoint(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            switch (*(long *)var_val)
            {
                case VAL_staPortAdminPointToPoint_forceTrue:
                    break;

                case VAL_staPortAdminPointToPoint_forceFalse:
                    break;

                case VAL_staPortAdminPointToPoint_auto:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            I32_T value = 0;
            UI32_T index = 0;

            if (staPortTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &index) == FALSE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            value = *(long *)var_val;

            if (XSTP_PMGR_SetPortLinkTypeMode(index, value) != XSTP_TYPE_RETURN_OK)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

int write_staPortSystemStatus(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            switch (*(long *)var_val)
            {
                case VAL_staPortSystemStatus_enabled:
                    break;

                case VAL_staPortSystemStatus_disabled:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            I32_T value = 0;
            UI32_T index = 0;

            if (staPortTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &index) == FALSE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            value = *(long *)var_val;

            if (XSTP_PMGR_SetPortSpanningTreeStatus(index, value) != XSTP_TYPE_RETURN_OK)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

int write_staPortLongAdminPathCost(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            if (MIN_staPortLongAdminPathCost > *(long *)var_val || *(long *)var_val > MAX_staPortLongAdminPathCost)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            I32_T value = 0;
            UI32_T index = 0;

            if (staPortTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &index) == FALSE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            value = *(long *)var_val;

            if (XSTP_PMGR_SetPortAdminPathCostAgent(index, value) != XSTP_TYPE_RETURN_OK)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

#if (SYS_CPNT_STP_BPDU_GUARD == TRUE)
int write_staPortBpduGuard(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            switch (*(long *)var_val)
            {
                case VAL_staPortBpduGuard_enabled:
                    break;

                case VAL_staPortBpduGuard_disabled:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            I32_T value = 0;
            UI32_T index = 0;

            if (staPortTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &index) == FALSE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            value = *(long *)var_val;

            value = (VAL_staPortBpduGuard_enabled == value) ? XSTP_TYPE_PORT_BPDU_GUARD_ENABLED : XSTP_TYPE_PORT_BPDU_GUARD_DISABLED;

            if (XSTP_PMGR_SetPortBpduGuardStatus(index, value) != XSTP_TYPE_RETURN_OK)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}
#endif /* #if (SYS_CPNT_STP_BPDU_GUARD == TRUE) */

#if (SYS_CPNT_STP_AUTO_EDGE_PORT == TRUE)
int write_staPortAdminEdgePortWithAuto(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            switch (*(long *)var_val)
            {
                case VAL_staPortAdminEdgePortWithAuto_true:
                    break;

                case VAL_staPortAdminEdgePortWithAuto_false:
                    break;

                case VAL_staPortAdminEdgePortWithAuto_auto:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            I32_T value = 0;
            UI32_T index = 0;

            if (staPortTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &index) == FALSE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            value = *(long *)var_val;

            if (XSTP_PMGR_SetPortAdminEdgePort(index, value) != XSTP_TYPE_RETURN_OK)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}
#endif /* #if (SYS_CPNT_STP_AUTO_EDGE_PORT == TRUE) */

#if (SYS_CPNT_STP_BPDU_FILTER == TRUE)
int write_staPortBpduFilter(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            switch (*(long *)var_val)
            {
                case VAL_staPortBpduFilter_enabled:
                    break;

                case VAL_staPortBpduFilter_disabled:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            I32_T value = 0;
            UI32_T index = 0;

            if (staPortTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &index) == FALSE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            value = *(long *)var_val;

            value = (VAL_staPortBpduFilter_enabled == value) ? XSTP_TYPE_PORT_BPDU_FILTER_ENABLED : XSTP_TYPE_PORT_BPDU_FILTER_DISABLED;

            if (XSTP_PMGR_SetPortBpduFilterStatus(index, value) != XSTP_TYPE_RETURN_OK)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}
#endif /* #if (SYS_CPNT_STP_BPDU_FILTER == TRUE) */

#if (SYS_CPNT_STP_ROOT_GUARD == TRUE)
int write_staPortRootGuardStatus(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            switch (*(long *)var_val)
            {
                case VAL_staPortRootGuardStatus_enabled:
                    break;

                case VAL_staPortRootGuardStatus_disabled:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            I32_T value = 0;
            UI32_T index = 0;

            if (staPortTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &index) == FALSE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            value = *(long *)var_val;

            if (XSTP_PMGR_SetPortRootGuardStatus(index, value) != XSTP_TYPE_RETURN_OK)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}
#endif /* #if (SYS_CPNT_STP_ROOT_GUARD == TRUE) */

#if (SYS_CPNT_STP_BPDU_GUARD == TRUE)
int
write_staPortBpduGuardAutoRecovery(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    switch ( action )
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;

        case RESERVE2:
            switch (*(long *)var_val)
            {
                case VAL_staPortBpduGuardAutoRecovery_enabled:
                case VAL_staPortBpduGuardAutoRecovery_disabled:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            I32_T value = 0;
            UI32_T index = 0;

            if (staPortTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &index) == FALSE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            value = * (long *) var_val;
            if (XSTP_PMGR_SetPortBPDUGuardAutoRecovery(index, value) != XSTP_TYPE_RETURN_OK)
            {
                return SNMP_ERR_COMMITFAILED;
            }
            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}
int
write_staPortBpduGuardAutoRecoveryInterval(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    switch ( action )
    {
        case RESERVE1:
            if (var_val_type != ASN_UNSIGNED)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(u_long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;

        case RESERVE2:
            if ((MIN_staPortBpduGuardAutoRecoveryInterval > *(u_long *)var_val) || (*(u_long *)var_val > MAX_staPortBpduGuardAutoRecoveryInterval))
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            I32_T value = 0;
            UI32_T index = 0;

            if (staPortTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &index) == FALSE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            value = * (u_long *) var_val;
            if (XSTP_PMGR_SetPortBPDUGuardAutoRecoveryInterval(index, value) != XSTP_TYPE_RETURN_OK)
            {
                return SNMP_ERR_COMMITFAILED;
            }
            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}
#endif  /* #if (SYS_CPNT_STP_BPDU_GUARD == TRUE) */

#if(SYS_CPNT_XSTP_TC_PROP_STOP == TRUE)
int write_staPortTcPropStop(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    /* dispatch action
     */
    switch (action)
    {
        case RESERVE1:
            /* check type and length
             */
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            /* check valid values
             */
            switch (*(long *) var_val)
            {
                case VAL_staPortTcPropStop_true:
                    break;

                case VAL_staPortTcPropStop_false:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            I32_T value = 0;

            /* table-specific variables
             */
            UI32_T dot1dStpPort = 0;

            /* extract index
             */
            if (! staPortTable_OidIndexToData(TRUE,
                name_len - oid_name_length,
                &(name[oid_name_length]),
                &dot1dStpPort))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            /* get user value
             */
            value = *(long *)var_val;

            /* set to core layer
             */
            if (XSTP_TYPE_RETURN_OK != XSTP_PMGR_SetPortTcPropStop(dot1dStpPort, value == VAL_staPortTcPropStop_true?TRUE:FALSE))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    /* return success
     */
    return SNMP_ERR_NOERROR;
}
#endif



#endif /* #if (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_RSTP) || (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_MSTP) */

#if (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_RSTP) || (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_MSTP)

/********************************************
 ****************xstMgt**********************
 ********************************************
 */
int
do_mstRevision(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
            {

                XSTP_MGR_MstpEntry_T entry;
                 if (XSTP_POM_GetMstpConfigurationEntry(&entry) != TRUE)
                   return  SNMP_ERR_GENERR;
                   long_return = entry.mstp_region_revision;
                  snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
            }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
            }
            break;

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
             {
               UI32_T mstRevision;
               mstRevision = (*requests->requestvb->val.integer);
               if (XSTP_PMGR_SetMstpRevisionLevel( mstRevision) !=XSTP_TYPE_RETURN_OK)
                  netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_COMMIT:


            break;

        case MODE_SET_UNDO:

            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
do_mstMaxHops(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
         {

                XSTP_MGR_MstpEntry_T entry;

                  if (XSTP_POM_GetMstpConfigurationEntry(&entry) != TRUE)
                   return  SNMP_ERR_GENERR;

                   long_return = entry.mstp_max_hop_count;
                  snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
            }
           break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
            }
            break;

        case MODE_SET_RESERVE2:

            if (*requests->requestvb->val.integer < MIN_mstMaxHops ||
                *requests->requestvb->val.integer > MAX_mstMaxHops)
            {
               netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
          {
               UI32_T mstMaxHops;
               mstMaxHops = (*requests->requestvb->val.integer);

               if (XSTP_PMGR_SetMstpMaxHop( mstMaxHops) != XSTP_TYPE_RETURN_OK)
                  netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
do_mstName(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    char  mstName[XSTP_TYPE_REGION_NAME_MAX_LENGTH+1];
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
           {

            XSTP_MGR_MstpEntry_T entry;

              if (XSTP_POM_GetMstpConfigurationEntry(&entry) != TRUE)
                return SNMP_ERR_GENERR;
                 strcpy((char *)return_buf, (char *)entry.mstp_region_name);
               snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, (u_char *) return_buf, strlen((char *)return_buf));
           }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            if (requests->requestvb->type != ASN_OCTET_STR)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
            }

            if (requests->requestvb->val_len < MINSIZE_mstName || requests->requestvb->val_len > MAXSIZE_mstName)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGLENGTH);
            }
            break;

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
            memcpy( mstName, requests->requestvb->val.string, requests->requestvb->val_len);
            mstName[requests->requestvb->val_len]= '\0';

            if (!L_CHARSET_IsValidGenericString(mstName))
            {
                return SNMP_ERR_BADVALUE;
            }

            if (XSTP_PMGR_SetMstpConfigurationName((UI8_T *)mstName) != XSTP_TYPE_RETURN_OK)
            {
                return SNMP_ERR_COMMITFAILED;
            }
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */

            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */

            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}


/********************************************
 **************xstInstanceCfgTable***********
 ********************************************
 */
static int
header_xstInstanceCfgTable(struct variable *vp,
               oid * name,
               size_t * length,
               int exact, size_t * var_len, WriteMethod ** write_method,
               XSTP_MGR_Dot1dStpEntry_T  *entry)
{

   unsigned int  ifIndex = XSTP_MSTP_GET_FIRST_INSTANCE_FOR_SNMP;

   if(!entry || l_snmp_index_get(vp,name,length,&ifIndex,exact) < 0 )
       return MATCH_FAILED;
    /*
     * find "next" interface
     */

    if(!exact){
      if(XSTP_PMGR_GetNextDot1dMstEntry( (UI32_T *)(&ifIndex),entry)!=TRUE)
       return MATCH_FAILED;

      l_snmp_index_set(vp,name,length,ifIndex);

    }
    else
    {
        if(XSTP_PMGR_GetDot1dMstEntry(ifIndex,entry)!=TRUE)
            return MATCH_FAILED;

    }

    *write_method = 0;
    *var_len = sizeof(long);    /* default to 'long' results */


    return ifIndex;
}


/*
 * var_xstInstanceCfgTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *
var_xstInstanceCfgTable(struct variable *vp,
            oid     *name,
            size_t  *length,
            int     exact,
            size_t  *var_len,
            WriteMethod **write_method)
{
   XSTP_MGR_Dot1dStpEntry_T  entry;
    int             interface;



   memset( &entry, 0, sizeof(entry));
    interface =
        header_xstInstanceCfgTable(vp, name, length, exact, var_len, write_method,&entry);
    if (interface == MATCH_FAILED)
      return NULL;
    /*
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
   #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    case XSTINSTANCECFGINDEX:
       long_return = interface;
        return (u_char*) &long_return;
   #endif
    case XSTINSTANCECFGPRIORITY:
        *write_method = write_xstInstanceCfgPriority;
           long_return = entry.dot1d_stp_priority;
        return (u_char*) &long_return;
    case XSTINSTANCECFGTIMESINCETOPOLOGYCHANGE:
        long_return = entry.dot1d_stp_time_since_topology_change;
        return (u_char*) &long_return;
    case XSTINSTANCECFGTOPCHANGES:
         long_return = entry.dot1d_stp_top_changes;
        return (u_char*) &long_return;
    case XSTINSTANCECFGDESIGNATEDROOT:
         memcpy(return_buf,& entry.dot1d_stp_designated_root, 8);
        *var_len = 8;
        return (u_char*) return_buf;
    case XSTINSTANCECFGROOTCOST:
        long_return = entry.dot1d_stp_root_cost;
        return (u_char*) &long_return;
    case XSTINSTANCECFGROOTPORT:
        long_return = entry.dot1d_stp_root_port;
        return (u_char*) &long_return;
    case XSTINSTANCECFGMAXAGE:
        long_return = entry.dot1d_stp_max_age;
        return (u_char*) &long_return;
    case XSTINSTANCECFGHELLOTIME:
        long_return = entry.dot1d_stp_hello_time;
        return (u_char*) &long_return;
    case XSTINSTANCECFGHOLDTIME:
        long_return = entry.dot1d_stp_hold_time;
        return (u_char*) &long_return;
    case XSTINSTANCECFGFORWARDDELAY:
       long_return = entry.dot1d_stp_forward_delay;
        return (u_char*) &long_return;
    case XSTINSTANCECFGBRIDGEMAXAGE:
       long_return = entry.dot1d_stp_bridge_max_age;
        return (u_char*) &long_return;
    case XSTINSTANCECFGBRIDGEHELLOTIME:
        long_return = entry.dot1d_stp_bridge_hello_time;
        return (u_char*) &long_return;
    case XSTINSTANCECFGBRIDGEFORWARDDELAY:
        long_return = entry.dot1d_stp_bridge_forward_delay;
        return (u_char*) &long_return;
    case XSTINSTANCECFGTXHOLDCOUNT:
        long_return = entry.dot1d_stp_tx_hold_count;
        return (u_char*) &long_return;
    case XSTINSTANCECFGPATHCOSTMETHOD:
        long_return = entry.dot1d_stp_path_cost_default;
        return (u_char*) &long_return;
    default:
      ERROR_MSG("");
    }
    return NULL;
}


int
write_xstInstanceCfgPriority(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

     /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          value = *(long *)var_val;
          if ((value <MIN_xstInstanceCfgPriority) || (value >MAX_xstInstanceCfgPriority))
             return SNMP_ERR_WRONGVALUE;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
                 value = * (long *) var_val;
              if (XSTP_PMGR_SetMstPriority( name[oid_name_length], value)!= XSTP_TYPE_RETURN_OK)
                 return SNMP_ERR_COMMITFAILED;
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

/********************************************
 ***********xstInstancePortTable*************
 ********************************************
 */
#define xstInstancePortEntry_INSTANCE_LEN 2

static UI32_T getXstInstancePortOidNameLen(void)
{
    return SNMP_MGR_Get_PrivateMibRootLen() + 6;
}

static int
header_xstInstancePortTable(struct variable *vp,
               oid * name,
               size_t * length,
               int exact, size_t * var_len, WriteMethod ** write_method,
               UI32_T *index1, UI32_T *index2)
{
    UI32_T oid_name_length = getXstInstancePortOidNameLen();
    oid             newname[MAX_OID_LEN];
    int             result;
   XSTP_MGR_Dot1dStpPortEntry_T  entry;
   BOOL_T return_val;
   oid  next_inst[xstInstancePortEntry_INSTANCE_LEN];
   UI32_T  msid=XSTP_TYPE_CISTID;

     memcpy((char *) newname, (char *) vp->name,
           (int) vp->namelen * sizeof(oid));
    /*
     * find "next" interface
     */
    memset(  &entry, 0 , sizeof(entry));

    /*
     * find "next" interface
     */

  while (  (return_val= XSTP_POM_GetNextDot1dMstPortEntry( &msid,  &entry))==TRUE)
     {
       next_inst[0] =msid;
       next_inst[1] = entry.dot1d_stp_port;


        memcpy( (char*)&newname[oid_name_length], (char*) next_inst,  2*sizeof(oid));
        result =
            snmp_oid_compare(name, *length, newname,
                             (int) vp->namelen +2);
        if ((exact && (result == 0)) || (!exact && (result < 0)))
            break;
    }
    if (!return_val ) {
        return MATCH_FAILED;
    }
    memcpy((char *) name, (char *) newname,
           ((int) vp->namelen + 2) * sizeof(oid));
    *length = vp->namelen + 2;
    *var_len = sizeof(long);    /* default to 'long' results */
    *index1 = next_inst[0];
    *index2 = next_inst[1];
    *write_method = 0;
    return TRUE;

}


/*
 * var_xstInstancePortTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *
var_xstInstancePortTable(struct variable *vp,
            oid     *name,
            size_t  *length,
            int     exact,
            size_t  *var_len,
            WriteMethod **write_method)
{
    /* variables we may use later */

    UI32_T index1 = 0, index2 = 0, retval;

    XSTP_MGR_Dot1dStpPortEntry_T  entry;




    memset( &entry, 0, sizeof(entry));

     retval  = header_xstInstancePortTable(vp, name, length, exact, var_len, write_method,  &index1,& index2);

    if (retval == MATCH_FAILED)
        return NULL;

  entry.dot1d_stp_port = index2;

   if (XSTP_POM_GetDot1dMstPortEntry(index1,&entry)!= TRUE)
            return NULL;
    /*
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
    #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    case  XSTINSTANCEPORTINSTANCE:
        long_return = index1;
        return (u_char*) &long_return;
    case XSTINSTANCEPORTPORT:
        long_return = index2;
        return (u_char*) &long_return;
     #endif
    case  XSTINSTANCEPORTPRIORITY:
        *write_method = write_xstInstancePortPriority;
        long_return = entry.dot1d_stp_port_priority;
        return (u_char*) &long_return;
    case XSTINSTANCEPORTSTATE:
        long_return = entry.dot1d_stp_port_state;
         switch (long_return)
    {
        case VAL_dot1dStpPortState_learning:
          long_return = VAL_xstInstancePortState_learning;
          break;
        case VAL_dot1dStpPortState_forwarding:
          long_return = VAL_xstInstancePortState_forwarding;
          break;
        default:
          long_return = VAL_xstInstancePortState_discarding;
          break;
   }
        return (u_char*) &long_return;
    case  XSTINSTANCEPORTENABLE:
        long_return = entry.dot1d_stp_port_enable;
        return (u_char*) &long_return;
    case XSTINSTANCEPORTPATHCOST:
        *write_method = write_xstInstancePortPathCost;
       long_return = entry.mstp_internal_port_path_cost;
        return (u_char*) &long_return;
    case XSTINSTANCEPORTDESIGNATEDROOT:
        memcpy(return_buf,  &entry.dot1d_stp_port_designated_root,8);
        *var_len  =   8;
        return (u_char*)return_buf;
    case XSTINSTANCEPORTDESIGNATEDCOST:
        long_return = entry.dot1d_stp_port_designated_cost;
        return (u_char*) &long_return;
    case XSTINSTANCEPORTDESIGNATEDBRIDGE:
       memcpy(return_buf,  &entry.dot1d_stp_port_designated_bridge,8);
        *var_len  =   8;
        return (u_char*)return_buf;
    case XSTINSTANCEPORTDESIGNATEDPORT:

         memcpy(return_buf,  &entry.dot1d_stp_port_designated_port,2);
        *var_len  =   2;
        return (u_char*)return_buf;
    case XSTINSTANCEPORTFORWARDTRANSITIONS:
        long_return = entry.dot1d_stp_port_forward_transitions;
        return (u_char*) &long_return;
    case XSTINSTANCEPORTPORTROLE:
        long_return = entry.port_role;
        return (u_char*) &long_return;
    case XSTINSTANCEPORTADMINPATHCOST:
        *write_method = write_xstInstancePortAdminPathCost;
        long_return = entry.admin_path_cost;
        return (u_char*) &long_return;
    case XSTINSTANCEPORTOPERPATHCOST:
        long_return = entry.oper_path_cost;
        return (u_char*) &long_return;
    default:
      ERROR_MSG("");
    }
    return NULL;
}


int
write_xstInstancePortPriority(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    UI32_T oid_name_length = getXstInstancePortOidNameLen();

     /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  xstInstancePortEntry_INSTANCE_LEN + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          value = *(long *)var_val;
          if ((value <MIN_xstInstancePortPriority) || (value >MAX_xstInstancePortPriority))
             return SNMP_ERR_WRONGVALUE;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
                  value = * (long *) var_val;
               if (XSTP_PMGR_SetMstPortPriority(name[oid_name_length+1],name[oid_name_length], value) != XSTP_TYPE_RETURN_OK)
                 return SNMP_ERR_COMMITFAILED;
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_xstInstancePortPathCost(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    UI32_T oid_name_length = getXstInstancePortOidNameLen();

     /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  xstInstancePortEntry_INSTANCE_LEN + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          value = *(long *)var_val;
          if ((value <MIN_xstInstancePortPathCost) || (value >MAX_xstInstancePortPathCost))
             return SNMP_ERR_WRONGVALUE;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
                     value = * (long *) var_val;
               if (XSTP_PMGR_SetMstPortPathCost(name[oid_name_length+1],name[oid_name_length], value) != XSTP_TYPE_RETURN_OK)
                 return SNMP_ERR_COMMITFAILED;
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_xstInstancePortAdminPathCost(int action,
                                   u_char * var_val,
                                   u_char var_val_type,
                                   size_t var_val_len,
                                   u_char * statP,
                                   oid * name, size_t name_len)
{
    long value;
    UI32_T oid_name_length = getXstInstancePortOidNameLen();

     /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  xstInstancePortEntry_INSTANCE_LEN + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
          value = *(long *)var_val;
          /*0 means auto path cost---DanXie*/
          if ((value < 0 ) || (value >MAX_xstInstancePortAdminPathCost))
             return SNMP_ERR_WRONGVALUE;
        break;
    case FREE:
        /*
         * Release any resources that have been allocated
         */
        break;
    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        value = * (long *) var_val;
        if (XSTP_PMGR_SetMstPortAdminPathCostAgent(name[oid_name_length+1],name[oid_name_length], value) != XSTP_TYPE_RETURN_OK)
        {
            if(SNMP_MGR_IsDebugMode())
                SYSFUN_Debug_Printf("write_xstInstancePortAdminPathCost:XSTP_MGR_SetMstPortAdminPathCostAgent return false, lport=%lu, mstid=%lu, pathcost=%lu\\n", name[oid_name_length+1], name[oid_name_length], value);
            return SNMP_ERR_COMMITFAILED;
        }
        break;
    case UNDO:
        /*
         * Back out any changes made in the ACTION case
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}


/********************************************
 ************mstInstanceEditTable************
 ********************************************
 */
static int
header_mstInstanceEditTable(struct variable *vp,
                            oid * name,
                            size_t * length,
                            int exact, size_t * var_len, WriteMethod ** write_method)
{
    oid    newname[MAX_OID_LEN];
    int    interface = 0;
    int    result = 0;
    BOOL_T return_val;
    UI32_T oid_name_length = 0;
    UI32_T ifIndex = XSTP_MSTP_GET_FIRST_INSTANCE_FOR_SNMP;
    XSTP_MGR_MstpInstanceEntry_T  entry;

    memset(newname, 0, MAX_OID_LEN * sizeof(oid));
    memset(&entry,  0, sizeof(XSTP_MGR_MstpInstanceEntry_T));

    oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    memcpy((char *) newname, (char *) vp->name, (int) vp->namelen * sizeof(oid));

    /* find "next" interface  */
    while ((return_val= XSTP_POM_GetNextMstpInstanceVlanConfigurationForMSB( &ifIndex, &entry))==TRUE)
    {
        newname[oid_name_length] = (oid) ifIndex;
        result = snmp_oid_compare(name, *length, newname, (int) vp->namelen + 1);

        if ((exact && (result == 0)) || (!exact && (result < 0)))
            break;
    }
    if (!return_val )
    {
        return MATCH_FAILED;
    }

    memcpy((char *) name, (char *) newname, ((int) vp->namelen + 1) * sizeof(oid));
    *length = vp->namelen + 1;
    *var_len = sizeof(long);    /* default to 'long' results */
    interface = newname[oid_name_length];

    return interface;
}


/*
 * var_mstInstanceEditTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_mstInstanceEditTable(struct variable *vp,
                         oid * name,
                         size_t * length,
                         int exact,
                         size_t * var_len, WriteMethod ** write_method)
{
   XSTP_MGR_MstpInstanceEntry_T  entry;
   int   interface;

#if (SYS_CPNT_MSTP_SUPPORT_PVST != 1)
   switch (vp->magic)
    {
      case MSTINSTANCEEDITVLANSMAP:
           *write_method = write_mstInstanceEditVlansMap;
           break;
      case MSTINSTANCEEDITVLANSMAP2K:
           *write_method = write_mstInstanceEditVlansMap2k;
           break;
      case MSTINSTANCEEDITVLANSMAP3K:
           *write_method = write_mstInstanceEditVlansMap3k;
           break;
      case MSTINSTANCEEDITVLANSMAP4K:
           *write_method = write_mstInstanceEditVlansMap4k;
           break;
      default:
           *write_method = 0;
     }
#endif

    memset( &entry, 0, sizeof(entry));
    interface = header_mstInstanceEditTable(vp, name, length, exact, var_len, write_method);

    if (interface == MATCH_FAILED)
        return NULL;

    if (XSTP_POM_GetMstpInstanceVlanConfigurationForMSB( interface, &entry)!= TRUE)
        return NULL;

    /*
     * * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic)
    {
     #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
      case MSTINSTANCEEDITINDEX:
           long_return = interface;
           return (u_char*) &long_return;
     #endif
      case MSTINSTANCEEDITVLANSMAP:
           memcpy(return_buf, entry.mstp_instance_vlans_mapped,128);
           *var_len = 128;
           return (u_char*)return_buf;
      case MSTINSTANCEEDITVLANSMAP2K:
           memcpy(return_buf, entry.mstp_instance_vlans_mapped2k,128);
           *var_len = 128;
           return (u_char*)return_buf;
      case MSTINSTANCEEDITVLANSMAP3K:
           memcpy(return_buf, entry.mstp_instance_vlans_mapped3k,128);
           *var_len = 128;
           return (u_char*)return_buf;
      case MSTINSTANCEEDITVLANSMAP4K:
           memcpy(return_buf, entry.mstp_instance_vlans_mapped4k,128);
           *var_len = 128;
           return (u_char*)return_buf;
      case MSTINSTANCEEDITREMAININGHOPS:
           long_return = entry.mstp_instance_remaining_hop_count;
           *var_len = sizeof(long_return);
           return (u_char*) &long_return;
      default:
           ERROR_MSG("");
    }
    return NULL;
}


int
write_mstInstanceEditVlansMap(int action,
                              u_char * var_val,
                              u_char var_val_type,
                              size_t var_val_len,
                              u_char * statP, oid * name, size_t name_len)
{
    int size;
    UI32_T oid_name_length;


    oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    if (name_len!=  1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              return SNMP_ERR_WRONGTYPE;
          }
          if ((var_val_len < MINSIZE_mstInstanceEditVlansMap) ||
              (var_val_len > MAXSIZE_mstInstanceEditVlansMap))
          {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:


          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
          {
                UI8_T buffer[128];
                int i;
                 size  = var_val_len;
                 memcpy(buffer, var_val, size);

             for (i =size; i<128 ; i ++)
                      buffer[i] = 0;
         if (XSTP_PMGR_AttachVlanListToMstConfigTable(name[oid_name_length],XSTP_MSTP_SET_INSTANCE_VLANS_MAPPED_1K, buffer) != XSTP_TYPE_RETURN_OK)
             return SNMP_ERR_COMMITFAILED;
        }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_mstInstanceEditVlansMap2k(int action,
                                u_char * var_val,
                                u_char var_val_type,
                                size_t var_val_len,
                                u_char * statP,
                                oid * name, size_t name_len)
{
    int size;
    UI32_T oid_name_length;


    oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    if (name_len!=  1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              return SNMP_ERR_WRONGTYPE;
          }
          if ((var_val_len < MINSIZE_mstInstanceEditVlansMap) ||
              (var_val_len > MAXSIZE_mstInstanceEditVlansMap))
          {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:


          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
          {
                UI8_T buffer[128];
                int i;
                 size  = var_val_len;
                 memcpy(buffer, var_val, size);

             for (i =size; i<128 ; i ++)
                      buffer[i] = 0;
         if (XSTP_PMGR_AttachVlanListToMstConfigTable(name[oid_name_length],XSTP_MSTP_SET_INSTANCE_VLANS_MAPPED_2K, buffer) != XSTP_TYPE_RETURN_OK)
             return SNMP_ERR_COMMITFAILED;
        }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_mstInstanceEditVlansMap3k(int action,
                                u_char * var_val,
                                u_char var_val_type,
                                size_t var_val_len,
                                u_char * statP,
                                oid * name, size_t name_len)
{
    int size;
    UI32_T oid_name_length;


    oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    if (name_len!=  1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              return SNMP_ERR_WRONGTYPE;
          }
          if ((var_val_len < MINSIZE_mstInstanceEditVlansMap) ||
              (var_val_len > MAXSIZE_mstInstanceEditVlansMap))
          {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:


          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
          {
                UI8_T buffer[128];
                int i;
                 size  = var_val_len;
                 memcpy(buffer, var_val, size);

             for (i =size; i<128 ; i ++)
                      buffer[i] = 0;
         if (XSTP_PMGR_AttachVlanListToMstConfigTable(name[oid_name_length],XSTP_MSTP_SET_INSTANCE_VLANS_MAPPED_3K, buffer) != XSTP_TYPE_RETURN_OK)
             return SNMP_ERR_COMMITFAILED;
        }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_mstInstanceEditVlansMap4k(int action,
                                u_char * var_val,
                                u_char var_val_type,
                                size_t var_val_len,
                                u_char * statP,
                                oid * name, size_t name_len)
{
    int size;
    UI32_T oid_name_length;


    oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    if (name_len!=  1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              return SNMP_ERR_WRONGTYPE;
          }
          if ((var_val_len < MINSIZE_mstInstanceEditVlansMap*sizeof(char)) ||
              (var_val_len > MAXSIZE_mstInstanceEditVlansMap*sizeof(char)))
          {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:


          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
          {
                UI8_T buffer[128];
                int i;
                 size  = var_val_len;
                 memcpy(buffer, var_val, size);

             for (i =size; i<128 ; i ++)
                      buffer[i] = 0;
         if (XSTP_PMGR_AttachVlanListToMstConfigTable(name[oid_name_length],XSTP_MSTP_SET_INSTANCE_VLANS_MAPPED_4K, buffer) != XSTP_TYPE_RETURN_OK)
             return SNMP_ERR_COMMITFAILED;
        }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

/********************************************
 ************mstInstanceOperTable************
 ********************************************
 */
#define mstInstanceOperEntry_INSTANCE_LEN 1

static BOOL_T mstInstanceOperTable_get(int      compc,
                                oid     *compl,
                                UI32_T  *msid,
                                XSTP_MGR_MstpInstanceEntry_T   *data)
{
    if (compc !=mstInstanceOperEntry_INSTANCE_LEN)
    {
        return FALSE;
    }
    *msid=compl[0];

    if (!XSTP_POM_GetMstpInstanceVlanMappedForMSB(*msid, data))
    {
        return FALSE;
    }
    else
    {
        return TRUE;
    } /*End of if */
}

static BOOL_T mstInstanceOperTable_next(int      compc,
                                 oid     *compl,
                                 UI32_T  *msid,
                                 XSTP_MGR_MstpInstanceEntry_T    *data)
{
    oid tmp_compl[mstInstanceOperEntry_INSTANCE_LEN];

    /* Generate the instance of each table entry and find the
     * smallest instance that's larger than compc/compl.
     *
     * Step 1: Verify and extract the input key from "compc" and "compl"
     * Note: The number of input key is defined by "compc".
     *       The key for the specified instance is defined in compl.
     */
    memcpy(tmp_compl, compl, sizeof(tmp_compl));
    SNMP_MGR_checkCompl(0, 0, tmp_compl,MAX_mstInstanceEditIndex);
    SNMP_MGR_ConvertRemainToZero(compc,mstInstanceOperEntry_INSTANCE_LEN, tmp_compl);

    *msid=tmp_compl[0];

    if (compc<mstInstanceOperEntry_INSTANCE_LEN)
    {
        if (!XSTP_POM_GetMstpInstanceVlanMappedForMSB(*msid, data))
        {
            if (!XSTP_POM_GetNextMstpInstanceVlanMappedForMSB(msid, data))
            {
                return FALSE;
            }
        }
    }
    else
    {
        if (!XSTP_POM_GetNextMstpInstanceVlanMappedForMSB(msid, data))
        {
            return FALSE;
        }
    }
    return TRUE;
}


/*
 * var_mstInstanceOperTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_mstInstanceOperTable(struct variable *vp,
                         oid * name,
                         size_t * length,
                         int exact,
                         size_t * var_len, WriteMethod ** write_method)
{
    UI32_T compc=0;
    oid compl[mstInstanceOperEntry_INSTANCE_LEN];
    oid best_inst[mstInstanceOperEntry_INSTANCE_LEN];
    UI32_T  msid;
    XSTP_MGR_MstpInstanceEntry_T data;

    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl, mstInstanceOperEntry_INSTANCE_LEN);

     /*check compc, retrive compl*/
    if (exact)/*get,set*/
    {
        if (!mstInstanceOperTable_get(compc, compl, &msid, &data))
            return NULL;
    }
    else/*getnext*/
    {
        if (!mstInstanceOperTable_next(compc, compl, &msid, &data))
        {
            return NULL;
        }
    }
    memcpy(name, vp->name, vp->namelen*sizeof(oid));
    best_inst[0]=msid;
    memcpy(name + vp->namelen, best_inst, mstInstanceOperEntry_INSTANCE_LEN*sizeof(oid));
    *length = vp->namelen +mstInstanceOperEntry_INSTANCE_LEN;

    /*
     * * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
      case MSTINSTANCEOPERINDEX:
        long_return = msid;
        *var_len = sizeof(msid);
        return (u_char*) &long_return;
#endif
      case MSTINSTANCEOPERVLANSMAP:
         memcpy(return_buf, data.mstp_instance_vlans_mapped,MAXSIZE_mstInstanceOperVlansMap);
        *var_len = MAXSIZE_mstInstanceOperVlansMap;
        return (u_char*)return_buf;
      case MSTINSTANCEOPERVLANSMAP2K:
         memcpy(return_buf, data.mstp_instance_vlans_mapped2k,MAXSIZE_mstInstanceOperVlansMap2k);
        *var_len = MAXSIZE_mstInstanceOperVlansMap2k;
        return (u_char*)return_buf;
      case MSTINSTANCEOPERVLANSMAP3K:
        memcpy(return_buf, data.mstp_instance_vlans_mapped3k,MAXSIZE_mstInstanceOperVlansMap3k);
        *var_len = MAXSIZE_mstInstanceOperVlansMap3k;
        return (u_char*)return_buf;
      case MSTINSTANCEOPERVLANSMAP4K:
        memcpy(return_buf, data.mstp_instance_vlans_mapped4k,MAXSIZE_mstInstanceOperVlansMap4k);
        *var_len = MAXSIZE_mstInstanceOperVlansMap4k;
        return (u_char*)return_buf;
    default:
        break;
    }
    return NULL;
}


#endif//end of #if (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_RSTP) || (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_MSTP)


/********************************************
 ************tftpMgt*************************
 ********************************************
 */
int
do_tftpFileType(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
           {
              XFER_MGR_TftpMgtEntry_T entry;

              if (XFER_PMGR_GetTftpMgtEntry(&entry)== FALSE)
                       return SNMP_ERR_GENERR;
                  long_return = entry.tftpFileType;
               switch (long_return)
        {
            case FS_TYPE_OPCODE_FILE_TYPE:
                 long_return = VAL_tftpFileType_opcode;
            break;
            case FS_FILE_TYPE_CONFIG:
                 long_return = VAL_tftpFileType_config;
            break;
            default:
                long_return = VAL_tftpFileType_config;
            break;
        }
                     snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
             }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
           {
           UI32_T fileType;
           fileType = (*requests->requestvb->val.integer);
          if ((fileType!= 1) && (fileType!=2))
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_INCONSISTENTVALUE);
          }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */

            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
            {
                UI32_T fileType;
                fileType = (*requests->requestvb->val.integer);
                 if (XFER_PMGR_SetTftpFileType(fileType) != TRUE)
                       netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */

            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */

            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
get_tftpStatus(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
       {
              XFER_MGR_TftpMgtEntry_T entry;

              if (XFER_PMGR_GetTftpMgtEntry(&entry)== FALSE)
                       return SNMP_ERR_GENERR;
                  long_return = entry.tftpStatus;
                switch (long_return)
        {
            case XFER_MGR_TFTPSTATUSUNKNOWN:
            case XFER_MGR_BUSY:
            case XFER_MGR_WRITE_FLASH_FINISH:
                 long_return = VAL_tftpStatus_tftpStatusUnknown;
              break;
            case XFER_MGR_SUCCESS:
            case XFER_MGR_TFTP_COMPLETED:
            case XFER_MGR_COMPLETED:
                 long_return = VAL_tftpStatus_tftpSuccess;
              break;
            case XFER_MGR_ERROR:
            case XFER_MGR_NO_IP_ADDR:
            case XFER_MGR_PARA_ERR:
            case XFER_MGR_OPEN_ERROR:
            case XFER_MGR_FILENAME_LEN_EXCEED:
            case XFER_MGR_UPLOAD_ERROR:
            case XFER_MGR_DOWNLOAD_ERROR:
            case XFER_MGR_GEN_ERROR:
            case XFER_MGR_WRITE_FLASH_ERR:
            case XFER_MGR_WRITE_FLASH_PROGRAMMING:
            case XFER_MGR_READ_FILE_ERR:
                 long_return = VAL_tftpStatus_tftpGeneralError;
              break;
            case XFER_MGR_HEADER_CHECKSUM_ERROR:
            case XFER_MGR_IMAGE_CHECKSUM_ERROR:
                 long_return = VAL_tftpStatus_tftpDownloadChecksumError;
              break;
            case XFER_MGR_IMAGE_TYPE_ERROR:
                 long_return = VAL_tftpStatus_tftpDownloadIncompatibleImage;
              break;
            default:
                 long_return = VAL_tftpStatus_tftpStatusUnknown;
              break;
            }
                     snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
             }
            break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

/*------------------------------------------------------------------------
 * ROUTINE NAME - fileCopyUserInfo_get
 *------------------------------------------------------------------------
 * FUNCTION: Get file copry user information
 * INPUT   : reqinfo      -- request information
 *           user_info_p  -- user information entry
 * OUTPUT  : None
 * RETURN  : TRUE/FALSE
 * NOTE    : None
 *------------------------------------------------------------------------
 */
static BOOL_T
fileCopyUserInfo_get(
    netsnmp_agent_request_info *reqinfo,
    XFER_MGR_UserInfo_T *user_info_p)
{
    L_INET_AddrIp_T      rem_ip_addr;
    L_INET_AddrIp_T      nexthop_addr;
    struct sockaddr *sock_addr_in = (struct sockaddr *)reqinfo->asp->pdu->transport_data;

    user_info_p->session_type = VAL_trapVarSessionType_snmp;

    /* get user name
     */
    switch (reqinfo->asp->pdu->securityModel)
    {
        case SNMP_SEC_MODEL_SNMPv1:
        case SNMP_SEC_MODEL_SNMPv2c:
            strncpy(user_info_p->user_name, (char *)reqinfo->asp->pdu->community,
                sizeof(user_info_p->user_name)-1);
            break;

        case SNMP_SEC_MODEL_USM:
            strncpy(user_info_p->user_name, reqinfo->asp->pdu->securityName,
                sizeof(user_info_p->user_name)-1);
            break;

        default:
            return FALSE;
    }

    user_info_p->user_name[sizeof(user_info_p->user_name)-1] = '\0';

    /* get user ip
     */
    if (FALSE == L_INET_SockaddrToInaddr(sock_addr_in, &rem_ip_addr))
    {
        return FALSE;
    }

    memcpy(&user_info_p->user_ip, &rem_ip_addr, sizeof(user_info_p->user_ip));

    /* get user mac
     */
    if (NETCFG_TYPE_FAIL == NETCFG_PMGR_ROUTE_GetReversePathIpMac(&rem_ip_addr,
        &nexthop_addr, user_info_p->user_mac))
    {
        return FALSE;
    }

    return TRUE;
}/* End of fileCopyUserInfo_get */

int
do_tftpAction(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
        {
              XFER_MGR_TftpMgtEntry_T entry;

              if (XFER_PMGR_GetTftpMgtEntry(&entry)== FALSE)
                       return SNMP_ERR_GENERR;
                  long_return = entry.tftpAction;

                     snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
             }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            {
           UI32_T action;
           action = (*requests->requestvb->val.integer);
          if ((action<1)  ||    (action>4))
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_INCONSISTENTVALUE);
          }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
             {
                XFER_MGR_UserInfo_T  user_info;
                UI32_T action;

                action = (*requests->requestvb->val.integer);

                memset(&user_info, 0, sizeof(user_info));
                fileCopyUserInfo_get(reqinfo, &user_info);

                if (XFER_PMGR_SetTftpActive(&user_info, action) != TRUE)
                       netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
                     SYSFUN_Sleep(200);
            }
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_tftpServer(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
        {
            XFER_MGR_TftpMgtEntry_T entry;
            char ip_ar[SYS_ADPT_IPV4_ADDR_LEN]={0};

            if (XFER_PMGR_GetTftpMgtEntry(&entry)== FALSE)
                return SNMP_ERR_GENERR;

            strncpy(ip_ar, (char *)entry.tftpServer.addr, SYS_ADPT_IPV4_ADDR_LEN);
            IP_LIB_ArraytoUI32((UI8_T *)ip_ar, &ipaddr_return);

            snmp_set_var_typed_value(requests->requestvb, ASN_IPADDRESS, (u_char *) &ipaddr_return, sizeof(ipaddr_return));
        }
        break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:

            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */

            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
             {
                UI32_T tftpServer;
                L_INET_AddrIp_T entry;
                memset(&entry, 0, sizeof(entry));
                entry.addrlen = SYS_ADPT_IPV4_ADDR_LEN;
                entry.type = VAL_ipFilterSnmpInetAddressType_ipv4;  /* temp assign */
                tftpServer = (*requests->requestvb->val.integer);
                IP_LIB_UI32toArray(tftpServer, entry.addr);

                if (XFER_PMGR_SetTftpServer(&entry)!= TRUE)
                       netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */

            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */

            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_tftpSrcFile(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
            {

             XFER_MGR_TftpMgtEntry_T entry;

              if (XFER_PMGR_GetTftpMgtEntry(&entry)== FALSE)
                       return SNMP_ERR_GENERR;
                 strcpy((char *)return_buf, (char *)entry.tftpSrcFile);
               snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, (u_char *) return_buf, strlen((char *)return_buf));
           }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
              if ((requests->requestvb->val_len<MINSIZE_tftpSrcFile)  ||    (requests->requestvb->val_len>MAXSIZE_tftpSrcFile))
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_INCONSISTENTVALUE);
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */

            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
           {
               UI8_T  tftpSrcFile[MAXSIZE_tftpSrcFile+1];
               memcpy(tftpSrcFile, requests->requestvb->val.string, requests->requestvb->val_len);
               tftpSrcFile[requests->requestvb->val_len]= '\0';
                  if (XFER_PMGR_SetTftpSrcFile(tftpSrcFile)!= TRUE)
                  netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */

            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */

            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
do_tftpDestFile(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
              {

             XFER_MGR_TftpMgtEntry_T entry;

              if (XFER_PMGR_GetTftpMgtEntry(&entry)== FALSE)
                       return SNMP_ERR_GENERR;
                 strcpy((char *)return_buf, (char *)entry.tftpDestFile);
               snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, (u_char *) return_buf, strlen((char *)return_buf));
           }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
          if ((requests->requestvb->val_len<MINSIZE_tftpDestFile)  ||    (requests->requestvb->val_len>MAXSIZE_tftpDestFile))
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_INCONSISTENTVALUE);
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */

            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
               {
               UI8_T  tftpDestFile[MAXSIZE_tftpDestFile+1];

               memcpy  (   tftpDestFile, requests->requestvb->val.string, requests->requestvb->val_len);
               tftpDestFile[requests->requestvb->val_len]= '\0';
                  if (XFER_PMGR_SetTftpDestFile(tftpDestFile)!= TRUE)
                  netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */

            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */

            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}


/********************************************
 ***********restartMgt***********************
 ********************************************
 */
int
do_restartOpCodeFile(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode)
    {

        case MODE_GET:
        {
             UI8_T buffer[MAXSIZE_restartOpCodeFile+1];

             /* Get startup of local unit, not unit 1.
              * Zhong Qiyao, 2004.07.21
              */

             if (FS_GetStartupFilename(SYS_VAL_LOCAL_UNIT_ID, FS_TYPE_OPCODE_FILE_TYPE, buffer)
                     != FS_RETURN_OK)
             {
                    return SNMP_ERR_GENERR;
             }
             strcpy((char *)return_buf, (char *)buffer);
             snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, (u_char *) return_buf, strlen((char *)return_buf));
             break;
        }

        case MODE_SET_RESERVE1:
            if (requests->requestvb->type != ASN_OCTET_STR)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
            }

            if (requests->requestvb->val_len < MINSIZE_restartOpCodeFile || requests->requestvb->val_len > MAXSIZE_restartOpCodeFile)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGLENGTH);
            }
            break;

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
             break;

        case MODE_SET_ACTION:
        {
             UI8_T  restartOpcode[MAXSIZE_restartOpCodeFile+1];
             UI32_T my_unit_id = 0;

             memcpy(restartOpcode, requests->requestvb->val.string, requests->requestvb->val_len);
             restartOpcode[requests->requestvb->val_len]= '\0';

             STKTPLG_POM_GetMyUnitID(&my_unit_id);

            if (XFER_PMGR_SetStartupFilename( FS_TYPE_OPCODE_FILE_TYPE, restartOpcode,0,0,0)!= TRUE)
             {
                 netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
             }

             #if 0
             if (XFER_MGR_AutoDownLoad("",
                 restartOpcode,
                 restartOpcode,
                 FS_TYPE_OPCODE_FILE_TYPE,
                 TRUE,
                 0,
                 0) == FALSE)
                 {
                    netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
                 }
             #endif
             break;
        }
        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */

            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */

            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_restartConfigFile(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
            {
                UI8_T buffer[MAXSIZE_restartConfigFile+1];

                /* Get startup of local unit, not unit 1.
                 * Zhong Qiyao, 2004.07.21
                 */
                memset(buffer, 0, MAXSIZE_restartConfigFile+1);

                if (FS_GetStartupFilename(SYS_VAL_LOCAL_UNIT_ID, FS_FILE_TYPE_CONFIG, buffer)
                        != FS_RETURN_OK)
                {
                    return SNMP_ERR_GENERR;
                }

                strcpy((char *)return_buf, (char *)buffer);
                snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, (u_char *) return_buf, strlen((char *)return_buf));
            }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            if (requests->requestvb->type != ASN_OCTET_STR)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
            }

            if (requests->requestvb->val_len < MINSIZE_restartConfigFile || requests->requestvb->val_len > MAXSIZE_restartConfigFile)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGLENGTH);
            }
            break;

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
            {
                UI8_T  restartConfig[MAXSIZE_restartConfigFile+1];
                UI32_T my_unit_id = 0;

                memcpy  (restartConfig, requests->requestvb->val.string, requests->requestvb->val_len);
                restartConfig[requests->requestvb->val_len]= '\0';

                #if   (SYS_CPNT_DBSYNC_TXT == TRUE)
                if(!SNMP_MGR_SetTmpDirty(0))
                {
                    SYSFUN_Debug_Printf("autoSave   Fail\n");
                }
                #endif

                STKTPLG_POM_GetMyUnitID(&my_unit_id);

                if (XFER_PMGR_SetStartupFilename( FS_FILE_TYPE_CONFIG, restartConfig,0,0,0)!= TRUE)
                {
                     netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
                }

                #if 0
                if (XFER_MGR_AutoDownLoad("",
                    restartConfig,
                    restartConfig,
                    FS_FILE_TYPE_CONFIG,
                    TRUE,
                    (UI32_T)0,
                    NULL) == FALSE)
                    {
                       netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
                    }
                #endif
            }
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */

            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */

            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_restartControl(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
        long_return=VAL_restartControl_running;
         snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
       break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
            }
            break;

        case MODE_SET_RESERVE2:
            switch (*requests->requestvb->val.integer)
            {
                case VAL_restartControl_running:
                    break;

                case VAL_restartControl_warmBoot:
                    break;

                case VAL_restartControl_coldBoot:
                    break;

                default:
                    netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
        {
            /* XXX: perform the value change here */
            UI32_T restartControl;

            restartControl = (*requests->requestvb->val.integer);

            switch (restartControl)
            {
                case VAL_restartControl_running: /* set to running just return ok */
                    break;

                case VAL_restartControl_warmBoot:  /* Warm Start*/
#if (SYS_CPNT_DBSYNC_TXT == TRUE)
                    /* kinghong add for 3com autosave*/
                    if (!SNMP_MGR_SetTmpDirty(0))
                    {
                        SYSFUN_Debug_Printf("autoSave   Fail\n");
                    }
#endif /* #if (SYS_CPNT_DBSYNC_TXT == TRUE) */
                    STKCTRL_PMGR_WarmStartSystem();
                    break;

                case VAL_restartControl_coldBoot:  /* Cold Start*/
#if (SYS_CPNT_DBSYNC_TXT == TRUE)
                    /* kinghong add for 3com autosave*/
                    if (!SNMP_MGR_SetTmpDirty(0))
                    {
                        SYSFUN_Debug_Printf("autoSave   Fail\n");
                    }
#endif /* #if (SYS_CPNT_DBSYNC_TXT == TRUE) */
                    STKCTRL_PMGR_ColdStartSystem();
                    break;
            }
            break;
        }

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */

            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */

            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

/********************************************
 ***********mirrorTable**********************
 ********************************************
 */
static int
header_mirrorTable(struct variable *vp,
               oid * name,
               size_t * length,
               int exact, size_t * var_len, WriteMethod ** write_method,
               SWCTRL_MirrorEntry_T *entry)
{
#if 0 /* DanXie, Thursday, February 26, 2009 9:53:28 */
UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
    oid             newname[MAX_OID_LEN];
    int             result;
   SWCTRL_MirrorEntry_T  entry;
   BOOL_T return_val;
   oid  next_inst[2];


     memcpy((char *) newname, (char *) vp->name,
           (int) vp->namelen * sizeof(oid));
    /*
     * find "next" interface
     */
    memset(  &entry, 0 , sizeof(entry));

    /*
     * find "next" interface
     */

  while (  (return_val= SWCTRL_POM_GetNextMirrorEntry( &entry))==TRUE)
     {
       next_inst[0] =entry.mirror_destination_port;
       next_inst[1] = entry.mirror_source_port;


        memcpy( (char*)&newname[oid_name_length], (char*) next_inst,  2*sizeof(oid));
        result =
            snmp_oid_compare(name, *length, newname,
                             (int) vp->namelen +2);
        if ((exact && (result == 0)) || (!exact && (result < 0)))
            break;
    }
    if (!return_val ) {
        return MATCH_FAILED;
    }
    memcpy((char *) name, (char *) newname,
           ((int) vp->namelen + 2) * sizeof(oid));
    *length = vp->namelen + 2;
    *var_len = sizeof(long);    /* default to 'long' results */
    *index1 = next_inst[0];
    *index2 = next_inst[1];
    return TRUE;
#else
    unsigned int index1 = 0,index2 = 0;

    if(!entry || l_snmp_2_index_get(vp,name,length,&index1,&index2,exact) < 0 )
        return MATCH_FAILED;

    /*
    * find "next" interface
    */
    entry->mirror_destination_port = index1;
    entry->mirror_source_port      = index2;
    if(!exact)
    {

        if ( SWCTRL_POM_GetNextMirrorEntry( entry)!=TRUE)
            return MATCH_FAILED;

        l_snmp_2_index_set(vp,name,length,entry->mirror_destination_port,entry->mirror_source_port);

    }
    else
    {
        if(SWCTRL_POM_GetMirrorEntry(entry)!=TRUE)
            return MATCH_FAILED;
    }

    *var_len = sizeof(long);    /* default to 'long' results */

     return TRUE;

#endif /* #if 0 */

}


/*
 * var_mirrorTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *
var_mirrorTable(struct variable *vp,
            oid     *name,
            size_t  *length,
            int     exact,
            size_t  *var_len,
            WriteMethod **write_method)
{
    /* variables we may use later */

    UI32_T retval;

    SWCTRL_MirrorEntry_T   entry;



    /*Since this table allow for entry that does not exist, (creation). we need to know the write method first*/
    switch(vp->magic)
     {
   case MIRRORTYPE:
        *write_method = write_mirrorType;
        break;
    case MIRRORSTATUS:
        *write_method = write_mirrorStatus;
        break;
     default:
          *write_method =0;
     break;
    }
    memset( &entry, 0, sizeof(entry));

     retval  = header_mirrorTable(vp, name, length, exact, var_len, write_method,&entry);

    if (retval == MATCH_FAILED)
        return NULL;

#if 0 /* DanXie, Thursday, February 26, 2009 10:01:08 */
  entry.mirror_destination_port= index1;
  entry.mirror_source_port = index2;

   if (SWCTRL_POM_GetMirrorEntry(&entry)!= TRUE)
            return NULL;
#endif /* #if 0 */

    /*
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic)
    {
   #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    case MIRRORDESTINATIONPORT:
        long_return=entry.mirror_destination_port;

        return (u_char*) &long_return;
    case MIRRORSOURCEPORT:
         long_return=entry.mirror_source_port;

        return (u_char*) &long_return;
    #endif
    case MIRRORTYPE:
         long_return=entry.mirror_type;
        return (u_char*) &long_return;
    case MIRRORSTATUS:

         long_return=entry.mirror_status;
        return (u_char*) &long_return;
    default:
      ERROR_MSG("");
    }
    return NULL;
}


int
write_mirrorType(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
     UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
   /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  2 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          value = *(long *)var_val;
          if ((value <1) || (value >3))
             return SNMP_ERR_WRONGVALUE;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
          value = * (long *) var_val;
             if (SWCTRL_PMGR_SetMirrorType(name[oid_name_length+1],name[oid_name_length],value)!= TRUE)
             {
                return SNMP_ERR_COMMITFAILED;
             }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_mirrorStatus(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
   /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  2 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          value = *(long *)var_val;
          if ((value <1) || (value >2))
             return SNMP_ERR_WRONGVALUE;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             value = * (long *) var_val;

             /*
              EPR:       ES4827G-FLF-ZZ-00440
              Problem:   Portmirror: the configuration in MIB UI can not take effect
              rootcasue: if only config the mirror status by mib and without config mirror type, the port mirror will not take
                         effect. It is not the same as CLI. Config the mirror status in CLI and without define the mirror type,
                         system will also set the mirror type as 'both' to chip automatically.
              sloution:  Modify the mirror status operation of mib as CLI behavior.
              File:      es3626a_superset2.0.c
             */

             if (value == VAL_mirrorStatus_valid)
             {
                 if (SWCTRL_PMGR_SetMirrorStatus(name[oid_name_length+1],name[oid_name_length],value) != TRUE)
                 {
                     return SNMP_ERR_COMMITFAILED;
                 }

                 if (SWCTRL_PMGR_SetMirrorType(name[oid_name_length+1],name[oid_name_length],VAL_mirrorType_both)!= TRUE)
                 {
                     /* if set mirror type failed, role back */
                     SWCTRL_PMGR_SetMirrorStatus(name[oid_name_length+1],name[oid_name_length],VAL_mirrorStatus_invalid);
                     return SNMP_ERR_COMMITFAILED;
                 }
             }
             else if (value == VAL_mirrorStatus_invalid)
             {
                 if (SWCTRL_PMGR_SetMirrorStatus(name[oid_name_length+1],name[oid_name_length],value) != TRUE)
                 {
                     return SNMP_ERR_COMMITFAILED;
                 }
             }

             break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

#if (SYS_CPNT_VLAN_MIRROR == TRUE)
#define VLANMIRRORENTRY_INSTANCE_LEN 2

BOOL_T vlanMirrorTable_OidIndexToData(UI32_T exact, UI32_T compc,
            oid * compl,  UI32_T *vlanMirrorDestinationPort, UI32_T *vlanMirrorSourceVlan)
{
    /* get or write */
    if (exact)
    {
        /* check the index length */
        if (compc != VLANMIRRORENTRY_INSTANCE_LEN) /* the constant size index */
        {
            return FALSE;
        }
    }

    *vlanMirrorDestinationPort = compl[0];
    *vlanMirrorSourceVlan = compl[1];

    return TRUE;
}

/*
 * var_vlanMirrorTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *
var_vlanMirrorTable(struct variable *vp,
            oid     *name,
            size_t  *length,
            int     exact,
            size_t  *var_len,
            WriteMethod **write_method)
{
    /* variables we may use later */
    UI32_T compc = 0;
    oid compl[VLANMIRRORENTRY_INSTANCE_LEN] = {0};
    oid best_inst[VLANMIRRORENTRY_INSTANCE_LEN] = {0};
    SWCTRL_VlanMirrorEntry_T entry;

    switch (vp->magic)
    {
        case LEAF_vlanMirrorStatus:
            *write_method = write_vlanMirrorStatus;
            break;

        default:
            *write_method = 0;
            break;
    }

    /* check compc, retrive compl */
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,
                           compl, VLANMIRRORENTRY_INSTANCE_LEN);

    memset(&entry, 0, sizeof(entry));

    if (exact) /* get,set */
    {
        /* get index */
        if (vlanMirrorTable_OidIndexToData(exact, compc, compl, &entry.mirror_dest_port, &entry.mirror_source_vlan) == FALSE)
        {
            return NULL;
        }

        /* get data */
        if (SWCTRL_PMGR_GetVlanMirrorEntry(&entry) != TRUE)
        {
            return NULL;
        }
    }
    else /* getnext */
    {
        /* get index */
        vlanMirrorTable_OidIndexToData(exact, compc, compl, &entry.mirror_dest_port, &entry.mirror_source_vlan);

        /* check the length of inputing index,if < 1 we should try get
         * {0.0.0.0.0...}
         */
        if (compc < 1)
        {
            /* get data */
            if (SWCTRL_PMGR_GetVlanMirrorEntry(&entry) != TRUE)
            {
                /* get next data */
                if (SWCTRL_PMGR_GetNextVlanMirrorEntry(&entry) != TRUE)
                {
                    return NULL;
                }
            }
        }
        else
        {
            /* get next data */
            if (SWCTRL_PMGR_GetNextVlanMirrorEntry(&entry) != TRUE)
            {
                return NULL;
            }
        }
    }

    memcpy(name, vp->name, vp->namelen*sizeof(oid));

    /* assign data to the oid index */
    best_inst[0] = entry.mirror_dest_port;
    best_inst[1] = entry.mirror_source_vlan;
    memcpy(name + vp->namelen, best_inst,
           VLANMIRRORENTRY_INSTANCE_LEN * sizeof(oid));
    *length = vp->namelen + VLANMIRRORENTRY_INSTANCE_LEN ;

    /* this is where we do the value assignments for the mib results. */
    switch (vp->magic)
    {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case LEAF_vlanMirrorDestinationPort:
            *var_len = sizeof(long_return);
            long_return = entry.mirror_dest_port;
            return (u_char *) &long_return;

        case LEAF_vlanMirrorSourceVlan:
            *var_len = sizeof(long_return);
            long_return = entry.mirror_source_vlan;
            return (u_char *) &long_return;
#endif /* end of #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

        case LEAF_vlanMirrorStatus:
            *var_len = sizeof(long_return);
            long_return = entry.mirror_vlan_status;
            return (u_char *) &long_return;

        default:
            ERROR_MSG("");
    }

    return NULL;
}

int
write_vlanMirrorStatus(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            switch (*(long *)var_val)
            {
                case VAL_vlanMirrorStatus_valid:
                    break;

                case VAL_vlanMirrorStatus_invalid:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            UI32_T vlanMirrorDestinationPort = 0;
            UI32_T vlanMirrorSourceVlan = 0;
            I32_T value = 0;

            if (vlanMirrorTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &vlanMirrorDestinationPort, &vlanMirrorSourceVlan) == FALSE)
                return SNMP_ERR_COMMITFAILED;

            value = *(long *)var_val;

            /* add an entry */
            if (value == VAL_vlanMirrorStatus_valid && SWCTRL_PMGR_AddVlanMirror(vlanMirrorSourceVlan, vlanMirrorDestinationPort) != TRUE)
                return SNMP_ERR_COMMITFAILED;

            /* delete an entry */
            if (value == VAL_vlanMirrorStatus_invalid && SWCTRL_PMGR_DeleteVlanMirror(vlanMirrorSourceVlan, vlanMirrorDestinationPort) != TRUE)
                return SNMP_ERR_COMMITFAILED;
        }
            break;

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}
#endif /* end of #if (SYS_CPNT_VLAN_MIRROR == TRUE) */

#if (SYS_CPNT_MAC_BASED_MIRROR == TRUE)

#define MACMIRRORENTRY_INSTANCE_LEN  7

BOOL_T macMirrorTable_OidIndexToData(UI32_T exact, UI32_T compc,
            oid * compl,  UI32_T *macMirrorDestinationPort, UI8_T *macMirrorSourceMacAddr)
{
    int i;

    if (exact)
    {
        if (compc != MACMIRRORENTRY_INSTANCE_LEN)
        {
            return FALSE;
        }
    }

    *macMirrorDestinationPort = compl[0];

    for (i=0; i < SIZE_macMirrorSourceMacAddr; i++)
    {
        macMirrorSourceMacAddr[i] = compl[1 + i];
    }

    return TRUE;
}

/*
 * var_macMirrorTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *
var_macMirrorTable(struct variable *vp,
            oid     *name,
            size_t  *length,
            int     exact,
            size_t  *var_len,
            WriteMethod **write_method)
{
    UI32_T compc = 0;
    oid compl[MACMIRRORENTRY_INSTANCE_LEN] = {0};
    oid best_inst[MACMIRRORENTRY_INSTANCE_LEN] = {0};
    UI8_T mac_addr[SIZE_macMirrorSourceMacAddr]={0};
    UI32_T ifindex = 0;
    int i;

    switch (vp->magic)
    {
        case LEAF_macMirrorStatus:
            *write_method = write_macMirrorStatus;
            break;

        default:
            *write_method = 0;
            break;
    }

    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,
                           compl, MACMIRRORENTRY_INSTANCE_LEN);

    if (exact)
    {
        if (macMirrorTable_OidIndexToData(exact, compc, compl, &ifindex, mac_addr) == FALSE)
        {
            return NULL;
        }

        if (SWCTRL_POM_IsExistedMacAddrMirrorEntry(mac_addr, ifindex) != TRUE)
        {
            return NULL;
        }
    }
    else
    {
        macMirrorTable_OidIndexToData(exact, compc, compl, &ifindex, mac_addr);

        if (compc < 1)
        {
            if (SWCTRL_POM_IsExistedMacAddrMirrorEntry(mac_addr, ifindex) != TRUE)
            {
                if (SWCTRL_POM_GetNextMacAddrMirrorEntryForSnmp(mac_addr, &ifindex) != TRUE)
                {
                    return NULL;
                }
            }
        }
        else
        {
            if (SWCTRL_POM_GetNextMacAddrMirrorEntryForSnmp(mac_addr, &ifindex) != TRUE)
            {
                return NULL;
            }
        }
    }

    memcpy(name, vp->name, vp->namelen*sizeof(oid));

    best_inst[0] = ifindex;
    for (i = 0; i < SIZE_macMirrorSourceMacAddr; i++)
    {
        best_inst[1 + i] = mac_addr[i];
    }
    memcpy(name + vp->namelen, best_inst,
           MACMIRRORENTRY_INSTANCE_LEN * sizeof(oid));
    *length = vp->namelen + MACMIRRORENTRY_INSTANCE_LEN ;

    switch (vp->magic)
    {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case LEAF_macMirrorDestinationPort:
            SWCTRL_POM_GetVlanAndMacMirrorDestPort
            *var_len = sizeof(long_return);
            long_return = ifindex;
            return (u_char *) &long_return;

#endif
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case LEAF_macMirrorSourceMacAddr:
            *var_len = SIZE_macMirrorSourceMacAddr;
            memcpy(return_buf, mac_addr, *var_len);
            return (u_char*)return_buf;

#endif
        case LEAF_macMirrorStatus:
            *var_len = sizeof(long_return);
            long_return = VAL_macMirrorStatus_valid;
            return (u_char *) &long_return;

        default:
            ERROR_MSG("");
    }

    return NULL;
}

int
write_macMirrorStatus(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            switch (*(long *)var_val)
            {
                case VAL_macMirrorStatus_valid:
                    break;

                case VAL_macMirrorStatus_invalid:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            I32_T  value = 0;
            UI32_T ifindex = 0;
            UI8_T  mac_addr[SIZE_macMirrorSourceMacAddr] = {0};

            if (macMirrorTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &ifindex, mac_addr) == FALSE)
                return SNMP_ERR_COMMITFAILED;

            value = *(long *)var_val;

            if (value == VAL_macMirrorStatus_valid)
            {
                if(TRUE != SWCTRL_PMGR_SetMacMirrorEntry(ifindex, mac_addr))
                {
                    return SNMP_ERR_COMMITFAILED;
                }
            }
            else
            {
                if (TRUE != SWCTRL_PMGR_DeleteMacMirrorEntry(ifindex, mac_addr))
                {
                    return SNMP_ERR_COMMITFAILED;
                }
            }
        }
            break;

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

#endif  /* #if (SYS_CPNT_MAC_BASED_MIRROR == TRUE) */

#if (SYS_CPNT_RSPAN == TRUE)

#define VLANSTATICEXTENTRY_INSTANCE_LEN  1

BOOL_T vlanStaticExtTable_OidIndexToData(UI32_T exact, UI32_T compc,
            oid * compl, UI32_T *vlanStaticExtVlanId)
{
    /* get or write */
    if (exact)
    {
        /* check the index length */
        if (compc != VLANSTATICEXTENTRY_INSTANCE_LEN) /* the constant size index */
        {
            return FALSE;
        }
    }

    *vlanStaticExtVlanId = compl[0];

    return TRUE;
}

/*
 * var_vlanStaticExtTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *
var_vlanStaticExtTable(struct variable *vp,
            oid     *name,
            size_t  *length,
            int     exact,
            size_t  *var_len,
            WriteMethod **write_method)
{
    /* variables we may use later */
    UI32_T compc = 0;
    oid compl[VLANSTATICEXTENTRY_INSTANCE_LEN] = {0};
    oid best_inst[VLANSTATICEXTENTRY_INSTANCE_LEN] = {0};
    RSPAN_MGR_RspanVlan_T entry;

    switch (vp->magic)
    {
        case LEAF_vlanStaticExtRspanStatus:
            *write_method = write_vlanStaticExtRspanStatus;
            break;

        default:
            *write_method = 0;
            break;
    }

    /* check compc, retrive compl */
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl,
                           VLANSTATICEXTENTRY_INSTANCE_LEN);

    memset(&entry, 0, sizeof(entry));

    if (exact) /* get,set */
    {
        /* get index */
        if (vlanStaticExtTable_OidIndexToData(exact, compc, compl,
                                         &entry.rspanVlanId) == FALSE)
        {
            return NULL;
        }

        /*get data */
        if (RSPAN_PMGR_GetRspanVlanEntry(&entry) != TRUE)
        {
            return NULL;
        }
    }
    else /* getnext */
    {
        /* get index */
        vlanStaticExtTable_OidIndexToData(exact, compc, compl,
                                     &entry.rspanVlanId);

        /* check the length of inputing index,if < 1 we should try get
         * {0.0.0.0.0...}
         */
        if (compc < 1)
        {
            /* get data */
            if (RSPAN_PMGR_GetRspanVlanEntry(&entry) != TRUE)
            {
                /* get next data */
                if (RSPAN_PMGR_GetNextRspanVlanEntry(&entry) != TRUE)
                {
                    return NULL;
                }
            }
        }
        else
        {
            /* get next data */
            if (RSPAN_PMGR_GetNextRspanVlanEntry(&entry) != TRUE)
            {
                return NULL;
            }
        }
    }

    memcpy(name, vp->name, vp->namelen*sizeof(oid));

    /* assign data to the oid index */
    best_inst[0] = entry.rspanVlanId;
    memcpy(name + vp->namelen, best_inst,
           VLANSTATICEXTENTRY_INSTANCE_LEN * sizeof(oid));
    *length = vp->namelen + VLANSTATICEXTENTRY_INSTANCE_LEN;

    /* this is where we do the value assignments for the mib results. */
    switch (vp->magic)
    {
        case LEAF_vlanStaticExtRspanStatus:
            *var_len = sizeof(long_return);
            long_return = entry.rspanVlanStatus;
            return (u_char *) &long_return;

        default:
            ERROR_MSG("");
    }

    return NULL;
}

int
write_vlanStaticExtRspanStatus(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            switch (*(long *)var_val)
            {
                case VAL_vlanStaticExtRspanStatus_destroy:
                case VAL_vlanStaticExtRspanStatus_vlan:
                case VAL_vlanStaticExtRspanStatus_rspanVlan:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            I32_T value = 0;
            UI32_T vlanStaticExtVlanId;

            if (vlanStaticExtTable_OidIndexToData(TRUE, name_len - oid_name_length,
                                                  &(name[oid_name_length]),
                                                  &vlanStaticExtVlanId) == FALSE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            value = *(long *)var_val;

            if (value == VAL_vlanStaticExtRspanStatus_vlan ||
                RSPAN_PMGR_SetRspanVlanStatus(vlanStaticExtVlanId,
                                              value) != TRUE)
            {
                return SNMP_ERR_COMMITFAILED;
            }
        }
            break;

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

/********************************************
 **********rspanTable************************
 ********************************************
 */
#define RSPANENTRY_INSTANCE_LEN  1

BOOL_T rspanTable_OidIndexToData(UI32_T exact, UI32_T compc,
            oid * compl,  UI8_T *rspanSessionId)
{
    /* get or write */
    if (exact)
    {
        /* check the index length */
        if (compc != RSPANENTRY_INSTANCE_LEN) /* the constant size index */
        {
            return FALSE;
        }
    }

    *rspanSessionId = compl[0];

    return TRUE;
}

/*
 * var_rspanTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *
var_rspanTable(struct variable *vp,
            oid     *name,
            size_t  *length,
            int     exact,
            size_t  *var_len,
            WriteMethod **write_method)
{
    /* variables we may use later */
    UI32_T compc = 0;
    UI8_T session_id;
    oid compl[RSPANENTRY_INSTANCE_LEN] = {0};
    oid best_inst[RSPANENTRY_INSTANCE_LEN] = {0};
    RSPAN_OM_SessionEntry_T entry;

    switch (vp->magic)
    {
        case LEAF_rspanSrcTxPorts:
            *write_method = write_rspanSrcTxPorts;
            break;

        case LEAF_rspanSrcRxPorts:
            *write_method = write_rspanSrcRxPorts;
            break;

        case LEAF_rspanDstPort:
            *write_method = write_rspanDstPort;
            break;

        case LEAF_rspanDstPortTag:
            *write_method = write_rspanDstPortTag;
            break;

        case LEAF_rspanSwitchRole:
            *write_method = write_rspanSwitchRole;
            break;

        case LEAF_rspanRemotePorts:
            *write_method = write_rspanRemotePorts;
            break;

        case LEAF_rspanRemoteVlanId:
            *write_method = write_rspanRemoteVlanId;
            break;

        case LEAF_rspanStatus:
            *write_method = write_rspanStatus;
            break;

        default:
            *write_method = 0;
            break;
    }

    /* check compc, retrive compl */
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,
                           compl, RSPANENTRY_INSTANCE_LEN);

    memset(&entry, 0, sizeof(entry));

    if (exact) /* get,set */
    {
        /* get index */
        if (rspanTable_OidIndexToData(exact, compc, compl, &session_id) == FALSE)
        {
            return NULL;
        }

        /* get data */
        if (RSPAN_PMGR_GetRspanSessionEntry(session_id, &entry) != TRUE)
        {
            return NULL;
        }
    }
    else /* getnext */
    {
        /* get index */
        rspanTable_OidIndexToData(exact, compc, compl, &session_id);

        /* check the length of inputing index,if < 1 we should try get
         * {0.0.0.0.0...}
         */
        if (compc < 1)
        {
            /* get data */
            if (RSPAN_PMGR_GetRspanSessionEntry(session_id, &entry) != TRUE)
            {
                /* get next data */
                if (RSPAN_PMGR_GetNextRspanSessionEntry(&session_id, &entry) != TRUE)
                {
                    return NULL;
                }
            }
        }
        else
        {
            /* get next data */
            if (RSPAN_PMGR_GetNextRspanSessionEntry(&session_id, &entry) != TRUE)
            {
                return NULL;
            }
        }
    }

    memcpy(name, vp->name, vp->namelen*sizeof(oid));

    /* assign data to the oid index */
    best_inst[0] = entry.session_id;
    memcpy(name + vp->namelen, best_inst,
           RSPANENTRY_INSTANCE_LEN * sizeof(oid));
    *length = vp->namelen + RSPANENTRY_INSTANCE_LEN ;

    /* this is where we do the value assignments for the mib results. */
    switch (vp->magic)
    {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case LEAF_rspanSessionId:
            *var_len = sizeof(long_return);
            long_return = entry.session_id;
            return (u_char *) &long_return;
#endif

        case LEAF_rspanSrcTxPorts:
            *var_len = SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST;
            memcpy(return_buf, entry.src_tx, *var_len);
            return (u_char*)return_buf;

        case LEAF_rspanSrcRxPorts:
            *var_len = SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST;
            memcpy(return_buf, entry.src_rx, *var_len);
            return (u_char*)return_buf;

        case LEAF_rspanDstPort:
            *var_len = sizeof(long_return);
            long_return = entry.dst;
            return (u_char *) &long_return;

        case LEAF_rspanDstPortTag:
            *var_len = sizeof(long_return);
            /* Tag value: none=1, untagged=2 and tagged=3 for SNMP.
             * none=0, untagged=2 and tagged=3 for Core layer.
             * 2008.1.10. by Tien.
             */
            if (entry.is_tagged == 0)
                long_return = VAL_rspanDstPortTag_none;
            else
                long_return = entry.is_tagged;
            return (u_char *) &long_return;

        case LEAF_rspanSwitchRole:
            *var_len = sizeof(long_return);
            /* Role value: none=1, src=2, intermediate=3 and dst=4 for SNMP.
             * none=0, src=2, intermediate=3 and dst=4 for Core layer.
             * 2008.1.10. by Tien.
             */
            if (entry.switch_role == 0)
                long_return = VAL_rspanSwitchRole_none;
            else
                long_return = entry.switch_role;
            return (u_char *) &long_return;

        case LEAF_rspanRemotePorts:
            *var_len = SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST;
            memcpy(return_buf, entry.uplink, *var_len);
            return (u_char*)return_buf;

        case LEAF_rspanRemoteVlanId:
            *var_len = sizeof(long_return);
            long_return = entry.remote_vid;
            return (u_char *) &long_return;

        case LEAF_rspanOperStatus:
            *var_len = sizeof(long_return);
            if (RSPAN_PMGR_IsSessionEntryCompleted(entry.session_id))
                long_return = VAL_rspanOperStatus_up;
            else
                long_return = VAL_rspanOperStatus_down;
            return (u_char *) &long_return;

        case LEAF_rspanStatus:
            *var_len = sizeof(long_return);
            long_return = entry.snmpEntryStatus;
            return (u_char *) &long_return;

        default:
            ERROR_MSG("");
    }

    return NULL;
}

int
write_rspanSrcTxPorts(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_OCTET_STR)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len < 1 || var_val_len > SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST)
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;

        case RESERVE2:
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            RSPAN_OM_SessionEntry_T entry;

            memset(&entry, 0, sizeof(RSPAN_OM_SessionEntry_T));

            if (rspanTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &entry.session_id) == FALSE)
                return SNMP_ERR_COMMITFAILED;

            memcpy(entry.src_tx, var_val, var_val_len);

            if (RSPAN_PMGR_SetRspanEntryStatus(&entry, LEAF_rspanSrcTxPorts) != TRUE)
                return SNMP_ERR_COMMITFAILED;
        }
            break;

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

int
write_rspanSrcRxPorts(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_OCTET_STR)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len < 1 || var_val_len > SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST)
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;

        case RESERVE2:
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            RSPAN_OM_SessionEntry_T entry;

            memset(&entry, 0, sizeof(RSPAN_OM_SessionEntry_T));

            if (rspanTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &entry.session_id) == FALSE)
                return SNMP_ERR_COMMITFAILED;

            memcpy(entry.src_rx, var_val, var_val_len);

            if (RSPAN_PMGR_SetRspanEntryStatus(&entry, LEAF_rspanSrcRxPorts) != TRUE)
                return SNMP_ERR_COMMITFAILED;
        }
            break;

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

int
write_rspanDstPort(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            I32_T value;
            RSPAN_OM_SessionEntry_T entry;

            memset(&entry, 0, sizeof(RSPAN_OM_SessionEntry_T));

            if (rspanTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &entry.session_id) == FALSE)
                return SNMP_ERR_COMMITFAILED;

            value = *(long *)var_val;
            entry.dst = value;

            if (RSPAN_PMGR_SetRspanEntryStatus(&entry, LEAF_rspanDstPort) != TRUE)
                return SNMP_ERR_COMMITFAILED;
        }
            break;

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

int
write_rspanDstPortTag(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            switch (*(long *)var_val)
            {
                case VAL_rspanDstPortTag_none:
                    break;

                case VAL_rspanDstPortTag_untagged:
                    break;

                case VAL_rspanDstPortTag_tagged:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            I32_T value;
            RSPAN_OM_SessionEntry_T entry;

            memset(&entry, 0, sizeof(RSPAN_OM_SessionEntry_T));

            if (rspanTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &entry.session_id) == FALSE)
                return SNMP_ERR_COMMITFAILED;

            value = *(long *)var_val;

            entry.is_tagged = value;

            if (RSPAN_PMGR_SetRspanEntryStatus(&entry, LEAF_rspanDstPortTag) != TRUE)
                return SNMP_ERR_COMMITFAILED;
        }
            break;

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

int
write_rspanSwitchRole(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            switch (*(long *)var_val)
            {
                case VAL_rspanSwitchRole_none:
                    break;

                case VAL_rspanSwitchRole_source:
                    break;

                case VAL_rspanSwitchRole_intermediate:
                    break;

                case VAL_rspanSwitchRole_destination:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            I32_T value;
            RSPAN_OM_SessionEntry_T entry;

            memset(&entry, 0, sizeof(RSPAN_OM_SessionEntry_T));

            if (rspanTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &entry.session_id) == FALSE)
                return SNMP_ERR_COMMITFAILED;

            value = *(long *)var_val;
            entry.switch_role = value;

            if (RSPAN_PMGR_SetRspanEntryStatus(&entry, LEAF_rspanSwitchRole) != TRUE)
                return SNMP_ERR_COMMITFAILED;
        }
            break;

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

int
write_rspanRemotePorts(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_OCTET_STR)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len < 1 || var_val_len > SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST)
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;

        case RESERVE2:
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            RSPAN_OM_SessionEntry_T entry;

            memset(&entry, 0, sizeof(RSPAN_OM_SessionEntry_T));

            if (rspanTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &entry.session_id) == FALSE)
                return SNMP_ERR_COMMITFAILED;

            memcpy(entry.uplink, var_val, var_val_len);

            if (RSPAN_PMGR_SetRspanEntryStatus(&entry, LEAF_rspanRemotePorts) != TRUE)
                return SNMP_ERR_COMMITFAILED;
        }
            break;

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

int
write_rspanRemoteVlanId(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:

            if (*(long *)var_val < MIN_rspanRemoteVlanId ||
                *(long *)var_val > MAX_rspanRemoteVlanId)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            I32_T value;
            RSPAN_OM_SessionEntry_T entry;

            memset(&entry, 0, sizeof(RSPAN_OM_SessionEntry_T));

            if (rspanTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &entry.session_id) == FALSE)
                return SNMP_ERR_COMMITFAILED;

            value = *(long *)var_val;
            entry.remote_vid = value;

            if (RSPAN_PMGR_SetRspanEntryStatus(&entry, LEAF_rspanRemoteVlanId) != TRUE)
                return SNMP_ERR_COMMITFAILED;
        }
            break;

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

int
write_rspanStatus(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            switch (*(long *)var_val)
            {
                case VAL_rspanStatus_valid:
                    break;

                case VAL_rspanStatus_invalid:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            I32_T value;
            RSPAN_OM_SessionEntry_T entry;

            memset(&entry, 0, sizeof(RSPAN_OM_SessionEntry_T)); //tien

            if (rspanTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &entry.session_id) == FALSE)
                return SNMP_ERR_COMMITFAILED;

            value = *(long *)var_val;
            entry.snmpEntryStatus = value;

            if (RSPAN_PMGR_SetRspanEntryStatus(&entry, LEAF_rspanStatus) != TRUE)
                return SNMP_ERR_COMMITFAILED;
        }
            break;

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}
#endif /* end of #if (SYS_CPNT_RSPAN == TRUE) */

#if (SYS_CPNT_ACL_MIRROR == TRUE)

#define ACLMIRRORENTRY_INSTANCE_LEN  3

BOOL_T aclMirrorTable_OidIndexToData(UI32_T exact, UI32_T compc, oid * compl,
                                   UI32_T *dstPort, UI32_T *accessList, UI32_T *type)
{
    int i;

    if (exact)
    {
        if (compc != ACLMIRRORENTRY_INSTANCE_LEN)
        {
            return FALSE;
        }
    }

    *dstPort = compl[0];
    *accessList = compl[1];
    *type = compl[2];

    return TRUE;
}

/*
 * var_aclMirrorTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *
var_aclMirrorTable(struct variable *vp,
            oid     *name,
            size_t  *length,
            int     exact,
            size_t  *var_len,
            WriteMethod **write_method)
{
    UI32_T compc = 0;
    oid compl[ACLMIRRORENTRY_INSTANCE_LEN] = {0};
    oid best_inst[ACLMIRRORENTRY_INSTANCE_LEN] = {0};
    UI32_T ifindex = 0;
    UI32_T acl_index = 0;
    UI32_T mirror_type;

    switch (vp->magic)
    {
        case LEAF_aclMirrorStatus:
            *write_method = write_aclMirrorStatus;
            break;

        default:
            *write_method = 0;
            break;
    }

    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,
                           compl, ACLMIRRORENTRY_INSTANCE_LEN);

    if (exact)
    {
        UI32_T tmp_dst_port, tmp_acl_index, tmp_mirror_type;
        RULE_TYPE_UI_AclEntry_T tmp_acl_entry;
        BOOL_T mirror_status = VAL_aclMirrorStatus_invalid;

        if (aclMirrorTable_OidIndexToData(exact, compc, compl, &ifindex, &acl_index, &mirror_type) == FALSE)
        {
            return NULL;
        }

        tmp_acl_index = (acl_index!=0)? acl_index-1: 0;
        tmp_dst_port=ifindex;
        while (RULE_TYPE_OK == L4_PMGR_ACL_GetNextAclMirrorEntry( &tmp_dst_port, &tmp_acl_index,
                  &tmp_mirror_type, &tmp_acl_entry))
        {
            if (tmp_dst_port == ifindex && tmp_acl_index == acl_index && tmp_mirror_type == mirror_type)
            {
                mirror_status = VAL_aclMirrorStatus_valid;
                break;
            }
            if (tmp_dst_port != ifindex)
            {
                break;
            }
        }
        if (mirror_status == VAL_aclMirrorStatus_invalid)
        {
            return NULL;
        }
    }
    else
    {
        RULE_TYPE_UI_AclEntry_T tmp_acl_entry;

        aclMirrorTable_OidIndexToData(exact, compc, compl, &ifindex, &acl_index, &mirror_type);

        if (compc < 1)
        {
            ifindex = 0;
            if (RULE_TYPE_OK != L4_PMGR_ACL_GetNextAclMirrorEntry( &ifindex, &acl_index,
                      &mirror_type, &tmp_acl_entry))
            {
                return NULL;
            }
        }
        else
        {
            if (RULE_TYPE_OK != L4_PMGR_ACL_GetNextAclMirrorEntry( &ifindex, &acl_index,
                      &mirror_type, &tmp_acl_entry))
            {
                return NULL;
            }
        }
    }

    memcpy(name, vp->name, vp->namelen*sizeof(oid));

    best_inst[0] = ifindex;
    best_inst[1] = acl_index;
    best_inst[2] = mirror_type;

    memcpy(name + vp->namelen, best_inst,
           ACLMIRRORENTRY_INSTANCE_LEN * sizeof(oid));
    *length = vp->namelen + ACLMIRRORENTRY_INSTANCE_LEN ;

    switch (vp->magic)
    {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case LEAF_aclMirrorDestinationPort:
            *var_len = sizeof(long_return);
            long_return = ifindex;
            return (u_char *) &long_return;

        case LEAF_aclMirrorAccessList:
            *var_len = sizeof(long_return);
            long_return = acl_index
            return (u_char*) &long_return;

        case LEAF_aclMirrorType:
            *var_len = sizeof(long_return);
            long_return = mirror_type;
            return (u_char *) &long_return;
#endif

        case LEAF_aclMirrorStatus:
            *var_len = sizeof(long_return);
            long_return = VAL_aclMirrorStatus_valid;
            return (u_char *) &long_return;

        default:
            ERROR_MSG("");
    }

    return NULL;
}

int
write_aclMirrorStatus(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
    /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  ACLMIRRORENTRY_INSTANCE_LEN + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            switch (*(long *)var_val)
            {
                case VAL_aclMirrorStatus_valid:
                case VAL_aclMirrorStatus_invalid:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T ifindex = 0;
            UI32_T acl_index = 0;
            UI32_T mirror_type = 0;

            if (aclMirrorTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]),
                                     &ifindex, &acl_index, &mirror_type) == FALSE)
                return SNMP_ERR_COMMITFAILED;

            if (RULE_TYPE_OK != L4_PMGR_ACL_SetAclMirrorEntryForMib(ifindex, acl_index,
                                       mirror_type, *(long *)var_val))
            {
                return SNMP_ERR_COMMITFAILED;
            }
        }
            break;

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}
#endif /*#if (SYS_CPNT_ACL_MIRROR == TRUE)*/

 #if(SYS_CPNT_ROUTING==TRUE)
/********************************************
 ******iPAddrTable************************
 ********************************************
 */
#define iPAddrEntry_INSTANCE_LEN 9
static int
header_iPAddrTable(struct variable *vp,
               oid * name,
               size_t * length,
               int exact, size_t * var_len, WriteMethod ** write_method,
               UI32_T *index1, UI32_T *index2, UI32_T *index3)
{
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
    oid             newname[MAX_OID_LEN];
    int             result;
    NETCFG_TYPE_InetRifConfig_T  entry;
    UI32_T  localIndex1=0, localIndex2=0, localIndex3=0;
    UI32_T  return_val=0;
    oid  next_inst[9];

    memcpy((char *) newname, (char *) vp->name, (int) vp->namelen * sizeof(oid));
    /*
     * find "next" interface
     */
    memset(  &entry, 0 , sizeof(entry));
    entry.addr.type = L_INET_ADDR_TYPE_IPV4;
    /*
     * find "next" interface
     */

    while (  return_val==0 )
    {
        return_val = NETCFG_POM_IP_GetNextRifFromInterface( &entry);
        localIndex1 = entry.ifindex;
        IP_LIB_ArraytoUI32(entry.addr.addr, &localIndex2);
        IP_LIB_CidrToMask(entry.addr.preflen, (UI8_T*)&localIndex3);

        next_inst[0] = localIndex1;
        SNMP_MGR_BindIpInstance( localIndex2, 1, next_inst);
        SNMP_MGR_BindIpInstance( localIndex3, 5, next_inst);

        memcpy( (char*)&newname[oid_name_length], (char*) next_inst,  9*sizeof(oid));
        result =
            snmp_oid_compare(name, *length, newname, (int) vp->namelen +9);
        if ((exact && (result == 0)) || (!exact && (result < 0)))
            break;
    }
    if (return_val != NETCFG_TYPE_OK) {
        return MATCH_FAILED;
    }
    memcpy((char *) name, (char *) newname, ((int) vp->namelen + 9) * sizeof(oid));
    *length = vp->namelen + 9;
    *var_len = sizeof(long);    /* default to 'long' results */
    *index1 = next_inst[0];
    *index2 = localIndex2;
    *index3 = localIndex3;
    return TRUE;
}


/*
 * var_iPAddrTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *
var_iPAddrTable(struct variable *vp,
            oid     *name,
            size_t  *length,
            int     exact,
            size_t  *var_len,
            WriteMethod **write_method)
{
    /* variables we may use later */

    UI32_T index1 = 0, index2 = 0, index3 = 0, retval;
    NETCFG_TYPE_InetRifConfig_T entry;
    //UI8_T outIp_ar[SYS_ADPT_IPV4_ADDR_LEN]={0};
    //UI8_T outMask_ar[SYS_ADPT_IPV4_ADDR_LEN]={0};

    memset( &entry, 0, sizeof(entry));
    switch(vp->magic)
    {
        case  IPADDRPRIMARYINTERFACE:
            *write_method = write_iPAddrPrimaryInterface;
            break;
        case IPADDRSTATUS:
            *write_method = write_iPAddrStatus;
            break;
        default:
            *write_method =0;
            break;
    }

    retval  = header_iPAddrTable(vp, name, length, exact, var_len, write_method,  &index1,& index2, &index3);
    if (retval == MATCH_FAILED)
        return NULL;

    entry.ifindex =index1;
    entry.addr.type = L_INET_ADDR_TYPE_IPV4;
    entry.addr.addrlen = SYS_ADPT_IPV4_ADDR_LEN;


    /* convert UI32 IP to array */
    if(IP_LIB_UI32toArray(index2, entry.addr.addr)!=IP_LIB_OK)
    {
        return NULL; //SNMP_ERR_COMMITFAILED;
    }
    entry.addr.preflen = IP_LIB_MaskToCidr((UI8_T*)&index3);

    if (NETCFG_POM_IP_GetRifConfig( &entry)!= NETCFG_TYPE_OK)
        return NULL;

    switch(vp->magic) {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    case  IPADDRIFINDEX:
        long_return = index1;
        return (u_char*) &long_return;
    case IPADDRIPADDRESS:
       *var_len = sizeof(ipaddr_return);
       ipaddr_return = index2;
        return (u_char*) &ipaddr_return;
    case IPADDRSUBNETMASK:
        *var_len = sizeof(ipaddr_return);
        ipaddr_return = index3;
        return (u_char*) &ipaddr_return;
#endif
    case  IPADDRPRIMARYINTERFACE:
        long_return = entry.ipv4_role;
        return (u_char*) &long_return;
   case  IPADDRUNNUMBERED:
        /*eli,2005.01.04,we always return VAL_iPAddrUnnumbered_notUnnumbered*/
         long_return = VAL_iPAddrUnnumbered_notUnnumbered;
        return (u_char*) &long_return;
    case IPADDRSTATUS:
         long_return = entry.row_status;
        return (u_char*) &long_return;
    default:
      ERROR_MSG("");
    }
    return NULL;
}

int
write_iPAddrPrimaryInterface(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
    /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  iPAddrEntry_INSTANCE_LEN + oid_name_length)
    {
    return SNMP_ERR_WRONGLENGTH;
    }
    switch ( action ) {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER) {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;

        case RESERVE2:
            value = *(long *)var_val;
            if ((value <VAL_iPAddrPrimaryInterface_UnknownType) || (value >VAL_iPAddrPrimaryInterface_secondary))
                return SNMP_ERR_WRONGVALUE;

            break;

        case FREE:
            /* Release any resources that have been allocated */
            break;

        case ACTION:
        {
            UI32_T ipaddr;
            UI32_T ipmask;
            UI32_T ifindex;
            UI32_T mode;
            NETCFG_TYPE_InetRifConfig_T rif_entry;

            value = *(long *)var_val;
            ifindex = name[oid_name_length];
            SNMP_MGR_ReadIpFromCompl(name, oid_name_length + 1, &ipaddr);
            SNMP_MGR_ReadIpFromCompl(name, oid_name_length + 5, &ipmask);
            memset(&rif_entry, 0, sizeof(NETCFG_TYPE_InetRifConfig_T));

            rif_entry.ifindex = ifindex;
            memcpy(rif_entry.addr.addr, &ipaddr, SYS_ADPT_IPV4_ADDR_LEN);
            rif_entry.addr.preflen = IP_LIB_MaskToCidr((UI8_T*)&ipmask);
            rif_entry.addr.type = L_INET_ADDR_TYPE_IPV4;

            if(NETCFG_POM_IP_GetRifConfig(&rif_entry)== NETCFG_TYPE_OK)
            {
                /* The role (primary/secondary) of RIF can only be changed when it is not active
                 */
                if((rif_entry.row_status == VAL_iPAddrStatus_2_notReady) || (rif_entry.row_status == VAL_iPAddrStatus_2_notInService))
                {
                    if(NETCFG_POM_IP_GetIpAddressMode(rif_entry.ifindex, &mode) != NETCFG_TYPE_OK)
                    {
                        return SNMP_ERR_COMMITFAILED;
                    }

                    rif_entry.ipv4_role = value;

                    if(NETCFG_PMGR_IP_SetInetRif(&rif_entry, NETCFG_TYPE_IP_CONFIGURATION_TYPE_SNMP) != NETCFG_TYPE_OK)
                    {
                        return SNMP_ERR_COMMITFAILED;
                    }
                }
                else
                {
                    return SNMP_ERR_COMMITFAILED;
                }
            }
            break;
        }
        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_iPAddrStatus(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;

    /* check 1: check if the input index is exactly match, if not return fail*/
    if(name_len != iPAddrEntry_INSTANCE_LEN + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch(action)
    {
        case RESERVE1:
        {
            if(var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }

            if(var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }

            break;
        }

        case RESERVE2:
        {
            value = *(long *)var_val;

            if((value < VAL_iPAddrStatus_2_active) || (value > VAL_iPAddrStatus_2_destroy))
                return SNMP_ERR_WRONGVALUE;

            break;
        }

        case FREE:
             /* Release any resources that have been allocated */
            break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
        {
            UI32_T ipaddr;
            UI32_T ipmask;
            UI32_T mode;
            UI32_T ifindex;
            NETCFG_TYPE_InetRifConfig_T rif_entry;

            value = *(long *)var_val;
            ifindex = name[oid_name_length];
            SNMP_MGR_ReadIpFromCompl(name, oid_name_length + 1, &ipaddr);
            SNMP_MGR_ReadIpFromCompl(name, oid_name_length + 5, &ipmask);
            memset(&rif_entry, 0, sizeof(NETCFG_TYPE_InetRifConfig_T));

            rif_entry.ifindex = ifindex;
            memcpy(rif_entry.addr.addr, &ipaddr, SYS_ADPT_IPV4_ADDR_LEN);
            rif_entry.addr.preflen = IP_LIB_MaskToCidr((UI8_T*)&ipmask);
            rif_entry.addr.type = L_INET_ADDR_TYPE_IPV4;

            switch(value)
            {
                case VAL_netConfigStatus_2_active:
                    {
                        if(NETCFG_POM_IP_GetRifConfig(&rif_entry)== NETCFG_TYPE_OK)
                        {
                            if(rif_entry.row_status == VAL_netConfigStatus_2_notReady)
                                return SNMP_ERR_COMMITFAILED;
                            else if(rif_entry.row_status == VAL_netConfigStatus_2_active)
                                return NETCFG_TYPE_OK;
                        }
                        else
                        {
                            return SNMP_ERR_COMMITFAILED;
                        }
                    }
                    break;

                case VAL_netConfigStatus_2_notInService:
                    {
                        if(NETCFG_POM_IP_GetRifConfig(&rif_entry)== NETCFG_TYPE_OK)
                        {
                            if(rif_entry.row_status == VAL_netConfigStatus_2_notReady)
                                return SNMP_ERR_COMMITFAILED;
                            else if(rif_entry.row_status == VAL_netConfigStatus_2_notInService)
                                return NETCFG_TYPE_OK;
                        }
                        else
                        {
                            return SNMP_ERR_COMMITFAILED;
                        }
                    }
                    break;

                case VAL_netConfigStatus_2_notReady:
                    return SNMP_ERR_COMMITFAILED;
                    break;

                case VAL_netConfigStatus_2_createAndGo:
                    return SNMP_ERR_COMMITFAILED;
                    break;

                case VAL_netConfigStatus_2_createAndWait:
                    if (NETCFG_POM_IP_GetRifConfig(&rif_entry)== NETCFG_TYPE_OK)
                        return SNMP_ERR_COMMITFAILED;
                    if (NETCFG_PMGR_IP_SetIpAddressMode (ifindex, NETCFG_TYPE_IP_ADDRESS_MODE_USER_DEFINE) != NETCFG_TYPE_OK)
                        return SNMP_ERR_COMMITFAILED;
                    rif_entry.ipv4_role = VAL_iPAddrPrimaryInterface_UnknownType;
                    break;

                case VAL_netConfigStatus_2_destroy:
                    {
                        if (NETCFG_POM_IP_GetRifConfig(&rif_entry)!= NETCFG_TYPE_OK)
                            return SNMP_ERR_COMMITFAILED;
                    }
                    break;

                default:
                    return SNMP_ERR_COMMITFAILED;
            }

            if(NETCFG_POM_IP_GetIpAddressMode(ifindex, &mode)!= NETCFG_TYPE_OK)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            rif_entry.row_status = value;
            if(NETCFG_PMGR_IP_SetInetRif(&rif_entry, NETCFG_TYPE_IP_CONFIGURATION_TYPE_SNMP) != NETCFG_TYPE_OK)
            {
                return SNMP_ERR_COMMITFAILED;
            }
            break;
        }

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }

    return SNMP_ERR_NOERROR;
}
#else
/********************************************
 ******netConfigTable************************
 ********************************************
 */
static int
header_netConfigTable(struct variable *vp,
               oid * name,
               size_t * length,
               int exact, size_t * var_len, WriteMethod ** write_method,
               UI32_T *index1, UI32_T *index2, UI32_T *index3)
{
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
    oid             newname[MAX_OID_LEN];
    int             result;
    NETCFG_TYPE_InetRifConfig_T entry;
    UI32_T localIndex1=0, localIndex2=0, localIndex3=0;
    UI32_T rc = NETCFG_TYPE_FAIL;
    oid next_inst[9];
    UI8_T mask[4] = {};

    memcpy((char *) newname, (char *) vp->name, (int) vp->namelen * sizeof(oid));
    /*
     * find "next" interface
     */
    memset(&entry, 0, sizeof(entry));
    entry.addr.type = L_INET_ADDR_TYPE_IPV4;

    while ((rc = NETCFG_POM_IP_GetNextRifFromInterface(&entry)) == NETCFG_TYPE_OK)
    {
        localIndex1 = entry.ifindex;
        IP_LIB_ArraytoUI32(entry.addr.addr, &localIndex2);
        IP_LIB_CidrToMask(entry.addr.preflen, mask);
        IP_LIB_ArraytoUI32(mask, &localIndex3);
        rc = NETCFG_TYPE_OK;
        next_inst[0] = localIndex1;
        SNMP_MGR_BindIpInstance(localIndex2, 1, next_inst);
        SNMP_MGR_BindIpInstance(localIndex3, 5, next_inst);

        memcpy((char*)&newname[oid_name_length], (char*) next_inst,  9*sizeof(oid));
        result =
            snmp_oid_compare(name, *length, newname, (int) vp->namelen +9);
        if ((exact && (result == 0)) || (!exact && (result < 0)))
            break;
    }

#if (SYS_CPNT_CRAFT_PORT == TRUE)
    if(rc != NETCFG_TYPE_OK)
    {
        NETCFG_TYPE_CraftInetAddress_T craft_addr;
        memset(&craft_addr, 0, sizeof(craft_addr));
        craft_addr.addr.type = L_INET_ADDR_TYPE_IPV4;

        if(NETCFG_POM_IP_GetCraftInterfaceInetAddress(&craft_addr) == NETCFG_TYPE_OK)
        {
            localIndex1 = craft_addr.ifindex;
            IP_LIB_ArraytoUI32(craft_addr.addr.addr, &localIndex2);
            IP_LIB_CidrToMask(craft_addr.addr.preflen, mask);
            IP_LIB_ArraytoUI32(mask, &localIndex3);

            next_inst[0] = localIndex1;
            SNMP_MGR_BindIpInstance(localIndex2, 1, next_inst);
            SNMP_MGR_BindIpInstance(localIndex3, 5, next_inst);

            memcpy((char*)&newname[oid_name_length], (char*) next_inst,  9*sizeof(oid));
            result =
                snmp_oid_compare(name, *length, newname, (int) vp->namelen +9);
            if ((exact && (result == 0)) || (!exact && (result < 0)))
            {
                rc = NETCFG_TYPE_OK;
            }
        }

    }
#endif
    if (rc != NETCFG_TYPE_OK)
        return MATCH_FAILED;

    memcpy((char *) name, (char *) newname, ((int) vp->namelen + 9) * sizeof(oid));
    *length = vp->namelen + 9;
    *var_len = sizeof(long);    /* default to 'long' results */
    *index1 = next_inst[0];
    *index2 = localIndex2;
    *index3 = localIndex3;
    return TRUE;
}

/*
 * var_netConfigTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *
var_netConfigTable(struct variable *vp,
            oid     *name,
            size_t  *length,
            int     exact,
            size_t  *var_len,
            WriteMethod **write_method)
{
    /* variables we may use later */
    UI32_T index1=0, index2=0,index3=0, retval;

    NETCFG_TYPE_InetRifConfig_T  entry;
    UI8_T mask[4] = {};
    UI32_T ifindex = 0, ipv4_role = 0, row_status = 0;
    memset(&entry, 0, sizeof(entry));

    switch(vp->magic)
    {
        case  NETCONFIGPRIMARYINTERFACE:
            *write_method = write_netConfigPrimaryInterface;
            break;
        case  NETCONFIGUNNUMBERED:
            *write_method = write_netConfigUnnumbered;
            break;
        case NETCONFIGSTATUS:
            *write_method = write_netConfigStatus;
            break;
        default:
            *write_method =0;
            break;
    }

    retval  = header_netConfigTable(vp, name, length, exact, var_len, write_method,  &index1,& index2, &index3);

    if (retval == MATCH_FAILED)
        return NULL;

    entry.addr.type = L_INET_ADDR_TYPE_IPV4;
    entry.addr.addrlen = SYS_ADPT_IPV4_ADDR_LEN;
    entry.ifindex = index1;
    /* convert UI32 IP to array */
    if(IP_LIB_UI32toArray(index2, entry.addr.addr)!=IP_LIB_OK)
    {
        return NULL;
    }

    /* convert to byte array format */
    IP_LIB_UI32toArray(index3, mask);
    entry.addr.preflen = IP_LIB_MaskToCidr(mask);
    /* DEBUG */
    //printf("%s, %d, index1: %lu, index2: %lx, index3: %lx\r\n", __FUNCTION__, __LINE__, index1, index2, index3);
    if (NETCFG_POM_IP_GetRifConfig(&entry)== NETCFG_TYPE_OK)
    {
        ifindex = entry.ifindex;
        ipv4_role = entry.ipv4_role;
        row_status = entry.row_status;
    }
#if (SYS_CPNT_CRAFT_PORT == TRUE)
    else if(SYS_ADPT_CRAFT_INTERFACE_IFINDEX == index1)
    {
        NETCFG_TYPE_CraftInetAddress_T craft_addr;
        memset(&craft_addr, 0, sizeof(craft_addr));
        craft_addr.addr.type = L_INET_ADDR_TYPE_IPV4;
        if(NETCFG_POM_IP_GetCraftInterfaceInetAddress(&craft_addr) == NETCFG_TYPE_OK)
        {
            UI8_T byte_index2[SYS_ADPT_IPV4_ADDR_LEN] = {};
            UI8_T byte_index3[SYS_ADPT_IPV4_ADDR_LEN] = {};
            UI8_T preflen_index3 = 0;
            IP_LIB_UI32toArray(index2, byte_index2);
            /* convert to byte array format */
            IP_LIB_UI32toArray(index3, byte_index3);
            preflen_index3 = IP_LIB_MaskToCidr(byte_index3);
            /* DEBUG */
            //printf("addr: %x%x%x%x\r\n", craft_addr.addr.addr[0], craft_addr.addr.addr[1], craft_addr.addr.addr[2], craft_addr.addr.addr[3]);
            //printf("index2: %x%x%x%x\r\n", byte_index2[0], byte_index2[1], byte_index2[2], byte_index2[3]);

            //printf("ip eq ? : %d\r\n", !memcmp(craft_addr.addr.addr, byte_index2, SYS_ADPT_IPV4_ADDR_LEN));
            //printf("preflen eq ?: %d, %d, %d\r\n", craft_addr.addr.preflen, preflen_index3, craft_addr.addr.preflen == preflen_index3);

            if(!memcmp(craft_addr.addr.addr, byte_index2, SYS_ADPT_IPV4_ADDR_LEN) && craft_addr.addr.preflen == preflen_index3)
            {
                ifindex = craft_addr.ifindex;
                ipv4_role = VAL_netConfigPrimaryInterface_primary; /* always */
                row_status = craft_addr.row_status;
            }
            else
                return NULL;
        }
        else
            return NULL;
    }
#else
    else
        return NULL;
#endif

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch(vp->magic) {
 #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case NETCONFIGIFINDEX:
            long_return = ifindex;
            return (u_char*) &long_return;
        case NETCONFIGIPADDRESS:
            *var_len = sizeof(ipaddr_return);
            ipaddr_return = index2;
            return (u_char*) &ipaddr_return;
        case NETCONFIGSUBNETMASK:
            *var_len = sizeof(ipaddr_return);
            ipaddr_return = index3;
            return (u_char*) &ipaddr_return;
#endif
        case  NETCONFIGPRIMARYINTERFACE:
            long_return = ipv4_role;
            return (u_char*) &long_return;
        case  NETCONFIGUNNUMBERED:
            long_return = VAL_iPAddrUnnumbered_notUnnumbered;
            return (u_char*) &long_return;
        case NETCONFIGSTATUS:
            long_return = row_status;
            return (u_char*) &long_return;
        default:
            ERROR_MSG("");
    }
    return NULL;
}


int
write_netConfigPrimaryInterface(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
    /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  9 + oid_name_length)
    {
    return SNMP_ERR_WRONGLENGTH;
    }
    switch ( action ) {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER) {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;

        case RESERVE2:
            value = *(long *)var_val;
            if ((value <VAL_netConfigPrimaryInterface_primary) || (value >VAL_netConfigPrimaryInterface_secondary))
                return SNMP_ERR_WRONGVALUE;

            break;

        case FREE:
            /* Release any resources that have been allocated */
            break;

        case ACTION:
            /*
             * The variable has been stored in 'value' for you to use,
             * and you have just been asked to do something with it.
             * Note that anything done here must be reversable in the UNDO case
             */

            /* Since we can only set one ip, Check with william_chiang, we do not support
             * set operation of this 2 variables in this stage 2002/3/22, kinghong
             */

            return SNMP_ERR_COMMITFAILED;
            break;

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_netConfigUnnumbered(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
    /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  9 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch ( action ) {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER) {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;

        case RESERVE2:
            value = *(long *)var_val;
            if ((value <VAL_netConfigUnnumbered_unnumbered) || (value >VAL_netConfigUnnumbered_notUnnumbered))
                return SNMP_ERR_WRONGVALUE;

            break;

        case FREE:
            /* Release any resources that have been allocated */
            break;

        case ACTION:
            /*
             * The variable has been stored in 'value' for you to use,
             * and you have just been asked to do something with it.
             * Note that anything done here must be reversable in the UNDO case
             */
            return SNMP_ERR_COMMITFAILED;
            break;

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_netConfigStatus(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;

    /* check 1: check if the input index is exactly match, if not return fail*/
    if(name_len != 9 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch(action)
    {
        case RESERVE1:
        {
            if(var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }

            if(var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }

            break;
        }

        case RESERVE2:
        {
            value = *(long *)var_val;

            if((value < VAL_netConfigStatus_2_active) || (value > VAL_netConfigStatus_2_destroy))
                return SNMP_ERR_WRONGVALUE;

            break;
        }

        case FREE:
             /* Release any resources that have been allocated */
            break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            {
                UI32_T vidifIndex;
                UI32_T ipAddress;
                UI32_T ipMask;
                UI8_T  byte_mask[SYS_ADPT_IPV4_ADDR_LEN] = {};
                NETCFG_TYPE_InetRifConfig_T rif_config;
#if (SYS_CPNT_CRAFT_PORT == TRUE)
                UI32_T rc = NETCFG_TYPE_FAIL;
#endif
                value = *(long *)var_val;
                vidifIndex = name[oid_name_length];
                SNMP_MGR_ReadIpFromCompl(name, oid_name_length + 1, &ipAddress);
                SNMP_MGR_ReadIpFromCompl(name, oid_name_length + 5, &ipMask);


                memset(&rif_config,0,sizeof(rif_config));
                rif_config.ifindex = vidifIndex;
                rif_config.addr.type = L_INET_ADDR_TYPE_IPV4;
                rif_config.addr.addrlen = SYS_ADPT_IPV4_ADDR_LEN;

                /* convert UI32 IP to array */
                if(IP_LIB_UI32toArray(ipAddress, rif_config.addr.addr)!=IP_LIB_OK)
                {
                    return SNMP_ERR_COMMITFAILED;
                }
                /* convert to byte array format */
                IP_LIB_UI32toArray(ipMask, byte_mask);

                if(!IP_LIB_IsValidNetworkMask(byte_mask))
                {
                    return SNMP_ERR_WRONGVALUE;
                }

                rif_config.addr.preflen = IP_LIB_MaskToCidr(byte_mask);
#if (SYS_CPNT_CRAFT_PORT == TRUE)
                if(vidifIndex == SYS_ADPT_CRAFT_INTERFACE_IFINDEX)
                {
                    NETCFG_TYPE_CraftInetAddress_T craft_addr;

                    memset(&craft_addr, 0, sizeof craft_addr);
                    craft_addr.ifindex = vidifIndex;
                    craft_addr.addr = rif_config.addr;
                    craft_addr.row_status = value;
                    /* DEBUG */
                    //printf("%s, %d, ifindex:%ld, type:%d, preflen:%d\r\n", __FUNCTION__, __LINE__, craft_addr.ifindex, craft_addr.addr.type, craft_addr.addr.preflen);

                    rc = NETCFG_PMGR_IP_SetCraftInterfaceInetAddress(&craft_addr);
                    if(NETCFG_TYPE_OK != rc)
                        return SNMP_ERR_COMMITFAILED;

                    break;
                }
#endif
                if (NETCFG_POM_IP_GetRifConfig(&rif_config)== NETCFG_TYPE_OK)
                {
                    /*We only set destroy to the ip of the interface when it is
                     * exist.
                     */
                    if(value!=VAL_netConfigStatus_2_destroy)
                    {
                        return SNMP_ERR_COMMITFAILED;
                    }
                }
                else
                {
                    /*We only set createAndGo to the ip of the interface when it
                     * is not exist.
                     */
                    if(value!=VAL_netConfigStatus_2_createAndGo)
                    {
                        return SNMP_ERR_COMMITFAILED;
                    }
                }
                /* re-assign row_status */
                rif_config.row_status  = value;

               /* DEBUG */
                //DUMP_RIF_ENTRY(&rif_config);

                if(NETCFG_PMGR_IP_SetInetRif(&rif_config, NETCFG_TYPE_IP_CONFIGURATION_TYPE_SNMP) != NETCFG_TYPE_OK)
                {
                    return SNMP_ERR_COMMITFAILED;
                }

                break;
            }

        case UNDO:
             /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
            break;
    }

    return SNMP_ERR_NOERROR;
}
#endif

/********************************************
 ***************ipMgt************************
 ********************************************
 */
#if (SYS_CPNT_HTTPS == TRUE)
int
do_ipHttpsPort(netsnmp_mib_handler *handler,
               netsnmp_handler_registration *reginfo,
               netsnmp_agent_request_info *reqinfo,
               netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch (reqinfo->mode)
    {
        case MODE_GET:
        {
            UI32_T ipHttpsPort;
            if (HTTP_PMGR_Get_Secure_Port(&ipHttpsPort) != TRUE)
                return SNMP_ERR_GENERR;

            long_return = ipHttpsPort;
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
        }
        break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
        {
            UI32_T ipHttpsPort;
            ipHttpsPort = (*requests->requestvb->val.integer);
            if ((ipHttpsPort < MIN_ipHttpsPort) || (ipHttpsPort > MAX_ipHttpsPort))
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_INCONSISTENTVALUE);
        }
        break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
        {
            UI32_T ipHttpsPort;
            ipHttpsPort = (*requests->requestvb->val.integer);
            if (HTTP_PMGR_Set_Secure_Port(ipHttpsPort) != TRUE)
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
        }
        break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_ipHttpsState(netsnmp_mib_handler *handler,
                netsnmp_handler_registration *reginfo,
                netsnmp_agent_request_info *reqinfo,
                netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch (reqinfo->mode)
    {
        case MODE_GET:
        {
            SECURE_HTTP_STATE_T ipHttpsState;
            /* Values:
             *  enabled(1)  = VAL_ipHttpsState_enabled
             *  disabled(2) = VAL_ipHttpsState_disabled
             */
            ipHttpsState = HTTP_PMGR_Get_Secure_Http_Status();
            long_return = ipHttpsState;
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
        }
        break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
        {
            UI32_T value;
            value = (*requests->requestvb->val.integer);
            if ((value < VAL_ipHttpsState_enabled) || (value > VAL_ipHttpsState_disabled))
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_INCONSISTENTVALUE);
        }
        break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
        {
            UI32_T value;
            value = (*requests->requestvb->val.integer);
            if (HTTP_PMGR_Set_Secure_Http_Status(value) != TRUE)
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
        }
        break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
#endif

#if (SYS_CPNT_HTTP == TRUE) /*fuzhimin,20090512*/
int
do_ipHttpState(netsnmp_mib_handler *handler,
               netsnmp_handler_registration *reginfo,
               netsnmp_agent_request_info *reqinfo,
               netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch (reqinfo->mode)
    {
        case MODE_GET:
        {
            HTTP_STATE_T ipHttpState;

            ipHttpState = HTTP_PMGR_Get_Http_Status();
            long_return = ipHttpState;
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
        }
        break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
        {
            UI32_T value;
            value = (*requests->requestvb->val.integer);
            if ((value < VAL_ipHttpState_enabled) || (value > VAL_ipHttpState_disabled))
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_INCONSISTENTVALUE);
        }
        break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
        {
            HTTP_STATE_T value;
            value = (*requests->requestvb->val.integer);
            if (HTTP_PMGR_Set_Http_Status(value) != TRUE)
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
        }
        break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_ipHttpPort(netsnmp_mib_handler *handler,
              netsnmp_handler_registration *reginfo,
              netsnmp_agent_request_info *reqinfo,
              netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch (reqinfo->mode)
    {
        case MODE_GET:
        {
            UI32_T ipHttpPort;
            ipHttpPort = HTTP_PMGR_Get_Http_Port();
            long_return = ipHttpPort;
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
        }
        break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
        {
            UI32_T value;
            value = (*requests->requestvb->val.integer);
            if ((value < MIN_ipHttpPort) || (value > MAX_ipHttpPort))
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_INCONSISTENTVALUE);
        }
        break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
        {
            UI32_T value;
            value = (*requests->requestvb->val.integer);
            if (HTTP_PMGR_Set_Http_Port(value) != TRUE)
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
        }
        break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
#endif

int
do_ipDhcpRestart(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:

    /* When get always return noRestart, James*/
                   long_return = VAL_ipDhcpRestart_noRestart;
                  snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));

            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
              {
               UI32_T value;
               UI8_T  type;

               type = requests->requestvb->type;

               if(type != ASN_INTEGER)
                   return SNMP_ERR_WRONGTYPE;

               value = (*requests->requestvb->val.integer);
                if ((value<VAL_ipDhcpRestart_restart) || (value>VAL_ipDhcpRestart_noRestart))
                    return SNMP_ERR_WRONGVALUE;
           }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */

            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
        /* XXX: perform the value change here */
        {
            UI32_T value;
            value= (*requests->requestvb->val.integer);
            switch (value)
            {
                case VAL_ipDhcpRestart_restart:
                    DHCP_PMGR_Restart();
                break;
            }
        }

            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */

            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */

            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_netDefaultGateway(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
        {
            L_INET_AddrIp_T  inet_addr;

            memset(&inet_addr, 0, sizeof(inet_addr));
            inet_addr.addrlen = SYS_ADPT_IPV4_ADDR_LEN;
            inet_addr.type = L_INET_ADDR_TYPE_IPV4;

            if(NETCFG_PMGR_ROUTE_GetDefaultGateway(&inet_addr)==NETCFG_TYPE_OK)
            {
                IP_LIB_ArraytoUI32(inet_addr.addr, &ipaddr_return);
                snmp_set_var_typed_value(requests->requestvb, ASN_IPADDRESS, (u_char *) &ipaddr_return, sizeof(ipaddr_return));
            }
            else
            {
                ipaddr_return = 0;
                snmp_set_var_typed_value(requests->requestvb, ASN_IPADDRESS, (u_char *) &ipaddr_return, sizeof(ipaddr_return));
            }
            //NETCFG_GetRifDefaultGateway( &value);

        }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            if (requests->requestvb->type != ASN_IPADDRESS)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */

            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
        /* XXX: perform the value change here */
        {
            UI32_T value;
            UI32_T default_gateway_ip;
            UI32_T ret;
            L_INET_AddrIp_T  inet_addr;

            memset(&inet_addr, 0, sizeof(inet_addr));
            inet_addr.addrlen = SYS_ADPT_IPV4_ADDR_LEN;
            inet_addr.type = L_INET_ADDR_TYPE_IPV4;

            value= (*requests->requestvb->val.integer);

            /* writing 0.0.0.0 needs special treatment: deletion
             * Zhong Qiyao, 2004.07.22
             */
            if (value == 0)
            {
                /* read original gateway
                 */
                if(NETCFG_PMGR_ROUTE_GetDefaultGateway(&inet_addr)==NETCFG_TYPE_OK)
                {
                    IP_LIB_ArraytoUI32(inet_addr.addr, &default_gateway_ip);
                }

                /* delete it
                 */
                if (L_STDLIB_Ntoh32(default_gateway_ip) != 0)
                {
                    ret = NETCFG_PMGR_ROUTE_DeleteDefaultGateway(&inet_addr);

                    if (ret != NETCFG_TYPE_OK)
                    {
                        netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
                    }
                }
            }

            /* writing non-zero, just set it in
             */
            else
            {
                IP_LIB_UI32toArray(value, inet_addr.addr);

                if(NETCFG_PMGR_ROUTE_AddDefaultGateway(&inet_addr, SYS_DFLT_DEFAULT_GATEWAY_METRIC)!=NETCFG_TYPE_OK)
                {
                    netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
                }
            }
        }
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */

            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */

            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

#if (SYS_CPNT_DHCP_CLIENT == TRUE)
/********************************************
 **************dhcpcInterfaceTable***********
 ********************************************
 */
static int
header_dhcpcInterfaceTable(struct variable *vp,
                                      oid             *name,
                                      size_t          *length,
               int exact, size_t * var_len, WriteMethod ** write_method)
{
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 8;
    oid newname[MAX_OID_LEN];
    int interface;
    int result;
    DHCP_MGR_ClientId_T entry;
    UI32_T ifIndex = 0;
    int return_val = DHCP_MGR_OK;


    memcpy((char *) newname, (char *) vp->name,
           (int) vp->namelen * sizeof(oid));
    /*
     * find "next" interface
     */

    while(return_val == DHCP_MGR_OK)
    {
        return_val = DHCP_PMGR_C_GetNextClientId(&ifIndex, &entry);
        newname[oid_name_length] = (oid)ifIndex;
        result =
            snmp_oid_compare(name, *length, newname,
                             (int) vp->namelen + 1);
        if((exact && (result == 0)) || (!exact && (result < 0)))
            break;
    }
    if (return_val!=DHCP_MGR_OK ) {

        return MATCH_FAILED;
    }


    memcpy((char *) name, (char *) newname,
           ((int) vp->namelen + 1) * sizeof(oid));
    *length = vp->namelen + 1;
    interface = newname[oid_name_length];

    return interface;
}


/*
 * var_dhcpcInterfaceTable():
 * Handle this table separately from the scalar value case.
 * The workings of this are basically the same as for var_ above.
 */
unsigned char *
var_dhcpcInterfaceTable(struct variable *vp,
                                       oid             *name,
                                       size_t          *length,
                                       int             exact,
                                       size_t          *var_len,
                                       WriteMethod     **write_method)
{
    DHCP_MGR_ClientId_T entry;
    DHCP_MGR_Vendor_T class_id;
    int interface;

    switch(vp->magic)
    {
        case LEAF_dhcpcIfClientIdMode:
            *write_method = write_dhcpcIfClientIdMode;
            break;

        case LEAF_dhcpcIfClientId:
            *write_method = write_dhcpcIfClientId;
            break;

        case LEAF_dhcpcIfVendorClassIdMode:
            *write_method = write_dhcpcIfVendorClassIdMode;
            break;

        case LEAF_dhcpcIfVendorClassId:
            *write_method = write_dhcpcIfVendorClassId;
            break;

        default:
            *write_method = 0;
            break;
    }

    memset(&entry, 0, sizeof(entry));
    memset(&class_id, 0, sizeof(class_id));
    interface = header_dhcpcInterfaceTable(vp, name, length, exact, var_len, write_method);

    if(interface == MATCH_FAILED)
        return NULL;

    if(DHCP_PMGR_C_GetClientId(interface, &entry) != DHCP_MGR_OK)
        return NULL;

    if(DHCP_PMGR_C_GetVendorClassId( interface, &class_id)!=DHCP_MGR_OK)
        return NULL;

    *var_len = sizeof(long_return);

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch(vp->magic)
    {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case LEAF_dhcpcIfIndex:
            long_return = interface;
            return (u_char*)&long_return;
#endif
        case LEAF_dhcpcIfClientIdMode:
            long_return = entry.id_mode;
            return (u_char*)&long_return;

        case LEAF_dhcpcIfClientId:
            memcpy(return_buf, entry.id_buf, entry.id_len);
            *var_len = entry.id_len;
            return (u_char*)return_buf;

        case LEAF_dhcpcIfVendorClassIdMode:
            *var_len = sizeof(long_return);
            long_return = class_id.vendor_mode;
            return (u_char *) &long_return;

        case LEAF_dhcpcIfVendorClassId:
            *var_len  =   strlen((char *)class_id.vendor_buf);
            memcpy(return_buf, class_id.vendor_buf, *var_len);
            return (u_char*)return_buf;

        default:
            ERROR_MSG("");
    }

    return NULL;
}


int
write_dhcpcIfClientIdMode(int      action,
                              u_char    *var_val,
                              u_char    var_val_type,
                              size_t    var_val_len,
                              u_char    *statP,
                              oid       *name,
                              size_t    name_len)
{
    long value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 8;

    /* check 1: check if the input index is exactly match, if not return fail */
    if(name_len != 1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
                return SNMP_ERR_WRONGTYPE;
            }
          if (var_val_len > sizeof(long)) {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;

        case RESERVE2:
            value = *(long *)var_val;
            if((value < VAL_dhcpcIfClientIdMode_text) || (value > VAL_dhcpcIfClientIdMode_hex))
                return SNMP_ERR_WRONGVALUE;

            break;

        case FREE:
             /* Release any resources that have been allocated */
            break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
        {
            DHCP_MGR_ClientId_T data;
            UI32_T dhcpcIfClientIdMode;

            dhcpcIfClientIdMode = * (long *)var_val;

            if(DHCP_PMGR_C_GetClientId(name[oid_name_length], &data) != DHCP_MGR_OK)
                return SNMP_ERR_COMMITFAILED;

            if(DHCP_PMGR_C_SetClientId(name[oid_name_length], dhcpcIfClientIdMode, data.id_len, data.id_buf) != DHCP_MGR_OK)
                return SNMP_ERR_COMMITFAILED;

            break;
        }

        case UNDO:
             /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
            break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_dhcpcIfClientId(int      action,
                          u_char   *var_val,
                          u_char   var_val_type,
                          size_t   var_val_len,
                          u_char   *statP,
                          oid      *name,
                          size_t   name_len)
{
    int size;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 8;

    /* check 1: check if the input index is exactly match, if not return fail*/
    if(name_len != 1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
                return SNMP_ERR_WRONGTYPE;
            }
          if (var_val_len >MAXSIZE_dhcpcIfClientId* sizeof(char)) {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;

        case RESERVE2:

            break;

        case FREE:
             /* Release any resources that have been allocated */
            break;

        case ACTION:
        {
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */

            DHCP_MGR_ClientId_T data;
            char buffer[DHCP_MGR_CID_BUF_MAX_SIZE + 1];

            size = var_val_len;
            memcpy(buffer, var_val, size);
            buffer[size]='\0';

            if (!L_CHARSET_IsValidGenericString(buffer))
            {
                return SNMP_ERR_WRONGVALUE;
            }

            if(DHCP_PMGR_C_GetClientId(name[oid_name_length], &data) != DHCP_MGR_OK)
                return SNMP_ERR_COMMITFAILED;

            if(DHCP_PMGR_C_SetClientId(name[oid_name_length], data.id_mode, size, buffer) != DHCP_MGR_OK)
                return SNMP_ERR_COMMITFAILED;
        }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
            break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dhcpcIfVendorClassIdMode(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            switch (*(long *)var_val)
            {
                case VAL_dhcpcIfVendorClassIdMode_notSpecify:
                    break;

                case VAL_dhcpcIfVendorClassIdMode_text:
                    break;

                case VAL_dhcpcIfVendorClassIdMode_hex:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            DHCP_MGR_Vendor_T class_id;
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 8;
            //UI32_T dhcpcIfIndex = 0;
            UI32_T value = 0;

            value = *(long *)var_val;
            memset(&class_id, 0, sizeof(class_id));

            if(DHCP_PMGR_C_GetVendorClassId( name[oid_name_length], &class_id)!= DHCP_MGR_OK)
                return SNMP_ERR_COMMITFAILED;

            if(DHCP_PMGR_C_SetVendorClassId( name[oid_name_length], value, class_id.vendor_len, class_id.vendor_buf)!=DHCP_MGR_OK)
                return SNMP_ERR_COMMITFAILED;
        }
            break;

        case UNDO:
          break;

        case COMMIT:
          break;
    }

    return SNMP_ERR_NOERROR;
}

int
write_dhcpcIfVendorClassId(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_OCTET_STR)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len < MINSIZE_dhcpcIfVendorClassId ||
                var_val_len > MAXSIZE_dhcpcIfVendorClassId)
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;

        case RESERVE2:
            break;

        case FREE:
            break;

        case ACTION:
        {
            DHCP_MGR_Vendor_T  class_id;
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 8;
            char byte_buffer[DHCP_MGR_CLASSID_BUF_MAX_SIZE + 1] = {0};
            //UI32_T dhcpcIfIndex = 0;

            memcpy(byte_buffer, var_val, var_val_len);
            byte_buffer[var_val_len] = '\0';
            memset(&class_id, 0, sizeof(class_id));

            if(DHCP_PMGR_C_GetVendorClassId( name[oid_name_length], &class_id)!= DHCP_MGR_OK)
                return SNMP_ERR_COMMITFAILED;

            if(DHCP_PMGR_C_SetVendorClassId( name[oid_name_length], class_id.vendor_mode, var_val_len, byte_buffer)!=DHCP_MGR_OK)
                return SNMP_ERR_COMMITFAILED;
        }
            break;

        case UNDO:
          break;

        case COMMIT:
          break;
    }

    return SNMP_ERR_NOERROR;
}


#endif


/********************************************
 **********************dhcpRelay*************
 ********************************************
 */

#if (SYS_CPNT_DHCP_RELAY == TRUE)
int
do_dhcpRelayRestart(netsnmp_mib_handler *handler,
                        netsnmp_handler_registration *reginfo,
                        netsnmp_agent_request_info   *reqinfo,
                        netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
        {
            long_return = VAL_dhcpRelayRestart_noRestart;
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
        }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
        {
            UI32_T value;
            UI8_T  type;

            type = requests->requestvb->type;

            if(type != ASN_INTEGER)
                return SNMP_ERR_WRONGTYPE;

            value = (*requests->requestvb->val.integer);
            if((value < VAL_dhcpRelayRestart_restart) || (value > VAL_dhcpRelayRestart_noRestart))
                 return SNMP_ERR_WRONGVALUE;
        }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */

            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
        {
            UI32_T value;
            value = (*requests->requestvb->val.integer);

            if(value == VAL_dhcpRelayRestart_restart);
            {
                DHCP_PMGR_Restart3(DHCP_MGR_RESTART_RELAY);
            }

        }
        break;


        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */

            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */

            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
#if 0
/* dhcpRelayServerAddrTable */
#define dhcpRelayServerAddrEntry_INSTANCE_LEN 2
static BOOL_T dhcpRelayServerAddrTable_get(int      compc,
                                           oid      *compl,
                                           UI32_T   *idx1,
                                           UI32_T   *idx2,
                                           UI32_T   *value)
{

    if(compc != dhcpRelayServerAddrEntry_INSTANCE_LEN)
    {
        return FALSE;
    }
    *idx1 = compl[0];
    *idx2 = compl[1];

    if(DHCP_PMGR_GetDhcpRelayServerAddrTable(*idx1, *idx2, value) != DHCP_MGR_OK)
    {
        return FALSE;
    }
    else
    {
    return TRUE;

    } /*End of if */
}

static BOOL_T dhcpRelayServerAddrTable_next(int       compc,
                                            oid       *compl,
                                            UI32_T    *index1,
                                            UI32_T    *index2,
                                            UI32_T    *value)
{
    oid tmp_compl[dhcpRelayServerAddrEntry_INSTANCE_LEN];

    /* Generate the instance of each table entry and find the
     * smallest instance that's larger than compc/compl.
     *
     * Step 1: Verify and extract the input key from "compc" and "compl"
     * Note: The number of input key is defined by "compc".
     *       The key for the specified instance is defined in compl.
     */
    memcpy(tmp_compl, compl, sizeof(tmp_compl));
    SNMP_MGR_ConvertRemainToZero(compc, dhcpRelayServerAddrEntry_INSTANCE_LEN, tmp_compl);

    *index1 = tmp_compl[0];
    *index2 = tmp_compl[1];

    if(compc < dhcpRelayServerAddrEntry_INSTANCE_LEN)
    {
        if(DHCP_PMGR_GetDhcpRelayServerAddrTable(*index1, *index2,value) != DHCP_MGR_OK)
        {
            if(DHCP_PMGR_GetNextDhcpRelayServerAddrTable(index1, index2, value) != DHCP_MGR_OK)
            {
                return FALSE;
            }
        }
    }
    else
    {
        if(DHCP_PMGR_GetNextDhcpRelayServerAddrTable(index1, index2, value) != DHCP_MGR_OK)
        {
            return FALSE;
        }
    }
    return TRUE;
}


/*
 * var_dhcpRelayServerAddrTable():
 * Handle this table separately from the scalar value case.
 * The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_dhcpRelayServerAddrTable(struct variable *vp,
                                            oid             *name,
                                            size_t          *length,
                                            int             exact,
                             size_t * var_len, WriteMethod ** write_method)
{
    UI32_T compc = 0;
    oid compl[dhcpRelayServerAddrEntry_INSTANCE_LEN];
    oid best_inst[dhcpRelayServerAddrEntry_INSTANCE_LEN];
    UI32_T index1, index2;
    UI32_T value;

    switch(vp->magic)
    {
        case DHCPRELAYSERVERADDRSERVERIP:
            *write_method = write_dhcpRelayServerAddrServerIp;
            break;
        default:
            *write_method = 0;
            break;
    }

    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,compl, dhcpRelayServerAddrEntry_INSTANCE_LEN);

    /* check compc, retrive compl */
    if(exact)  /* get, set */
    {
        if(!dhcpRelayServerAddrTable_get(compc, compl, &index1, &index2, &value))
            return NULL;
    }
    else  /* getnext */
    {
        if(!dhcpRelayServerAddrTable_next(compc, compl, &index1, &index2, &value))
        {
            return NULL;
        }
    }
    memcpy(name, vp->name, vp->namelen * sizeof(oid));
    best_inst[0] = index1;
    best_inst[1] = index2;
    memcpy(name + vp->namelen, best_inst, dhcpRelayServerAddrEntry_INSTANCE_LEN * sizeof(oid));
    *length = vp->namelen + dhcpRelayServerAddrEntry_INSTANCE_LEN;

    *var_len = sizeof(long_return);

    /*
     * * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case DHCPRELAYSERVERADDRIFINDEX:
            long_return = index1;
            return (u_char*)&long_return;
        case DHCPRELAYSERVERADDRINDEX:
            long_return = index2;
            return (u_char*)&long_return;
#endif
        case DHCPRELAYSERVERADDRSERVERIP:
        *write_method = write_dhcpRelayServerAddrServerIp;
            *var_len = sizeof(ipaddr_return);
            ipaddr_return = value;
            return (u_char*)&ipaddr_return;
        default:
            ERROR_MSG("");
    }
    return NULL;
}


int
write_dhcpRelayServerAddrServerIp(int action,
                                      u_char    *var_val,
                                      u_char    var_val_type,
                                      size_t    var_val_len,
                                      u_char    *statP,
                                  oid * name, size_t name_len)
{
    UI32_T value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 7;

    /* check 1: check if the input index is exactly match, if not return fail*/
    if(name_len != 2 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_IPADDRESS) {
                return SNMP_ERR_WRONGTYPE;
            }
          if (var_val_len !=  SYS_ADPT_IPV4_ADDR_LEN) {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;

        case RESERVE2:
            memcpy(&value, var_val, var_val_len);
            if(!IP_LIB_IsValidForNetworkInterface((UI8_T *)&value))
                return SNMP_ERR_WRONGVALUE;
            break;

        case FREE:
             /* Release any resources that have been allocated */
            break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */

        {
            UI32_T value;

            memcpy(&value, var_val, var_val_len);

            if(DHCP_PMGR_SetDhcpRelayServerAddrServerIp(name[oid_name_length], name[oid_name_length + 1], value) != DHCP_MGR_OK)
                return SNMP_ERR_COMMITFAILED;
        }
            break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
            break;
    }
    return SNMP_ERR_NOERROR;
}
#endif

/* dhcpRelayServerInetAddrTable*/
#define dhcpRelayServerAddrEntry_INSTANCE_LEN 2
static BOOL_T dhcpRelayServerAddrTable_get(int      compc,
                                oid     *compl,
                                UI32_T   *idx1,
                                UI32_T   *idx2,
                                UI32_T   *value)
{

    if (compc !=dhcpRelayServerAddrEntry_INSTANCE_LEN)
    {
        return FALSE;
    }
    *idx1= compl[0];
    *idx2= compl[1];

    if (DHCP_PMGR_GetDhcpRelayServerAddrTable(*idx1, *idx2, value)!=DHCP_MGR_OK)
        return FALSE;

    return TRUE;


}

static BOOL_T dhcpRelayServerAddrTable_next(int   compc,
                                 oid     *compl,
                                 UI32_T  *index1,
                                 UI32_T  *index2,
                                 UI32_T  *value)
{
    oid tmp_compl[dhcpRelayServerAddrEntry_INSTANCE_LEN];

    /* Generate the instance of each table entry and find the
     * smallest instance that's larger than compc/compl.
     *
     * Step 1: Verify and extract the input key from "compc" and "compl"
     * Note: The number of input key is defined by "compc".
     *       The key for the specified instance is defined in compl.
     */
    memcpy(tmp_compl, compl, sizeof(tmp_compl));
    SNMP_MGR_ConvertRemainToZero(compc, dhcpRelayServerAddrEntry_INSTANCE_LEN, tmp_compl);

    *index1 = tmp_compl[0];
    *index2 = tmp_compl[1];

    if(compc < dhcpRelayServerAddrEntry_INSTANCE_LEN)
    {
        if(DHCP_PMGR_GetDhcpRelayServerAddrTable(*index1, *index2,value) != DHCP_MGR_OK)
        {
            if(DHCP_PMGR_GetNextDhcpRelayServerAddrTable(index1, index2, value) != DHCP_MGR_OK)
            {
                return FALSE;
            }
        }
    }
    else
    {
        if(DHCP_PMGR_GetNextDhcpRelayServerAddrTable(index1, index2, value) != DHCP_MGR_OK)
        {
            return FALSE;
        }
    }
    return TRUE;
}

/*
 * var_dhcpRelayServerAddrTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_dhcpRelayServerAddrTable(struct variable *vp,
                             oid * name,
                             size_t * length,
                             int exact,
                             size_t * var_len, WriteMethod ** write_method)
{
    UI32_T compc = 0;
    oid compl[dhcpRelayServerAddrEntry_INSTANCE_LEN];
    oid best_inst[dhcpRelayServerAddrEntry_INSTANCE_LEN];
    UI32_T index1, index2;
    UI32_T value;

    switch(vp->magic)
    {
        case DHCPRELAYSERVERINETADDRTYPE:
        *write_method = write_dhcpRelayServerInetAddrType;
        case DHCPRELAYSERVERINETADDR:
            *write_method = write_dhcpRelayServerInetAddr;
            break;
        default:
            *write_method = 0;
            break;
    }

    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,compl, dhcpRelayServerAddrEntry_INSTANCE_LEN);

    /* check compc, retrive compl */
    if(exact)  /* get, set */
    {
        if(!dhcpRelayServerAddrTable_get(compc, compl, &index1, &index2, &value))
            return NULL;
    }
    else  /* getnext */
    {
        if(!dhcpRelayServerAddrTable_next(compc, compl, &index1, &index2, &value))
        {
            return NULL;
        }
    }
    memcpy(name, vp->name, vp->namelen * sizeof(oid));
    best_inst[0] = index1;
    best_inst[1] = index2;
    memcpy(name + vp->namelen, best_inst, dhcpRelayServerAddrEntry_INSTANCE_LEN * sizeof(oid));
    *length = vp->namelen + dhcpRelayServerAddrEntry_INSTANCE_LEN;

    *var_len = sizeof(long_return);

    /*
     * * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case DHCPRELAYSERVERINETADDRIFINDEX:
            long_return = index1;
            return (u_char*)&long_return;
        case DHCPRELAYSERVERINETADDRINDEX:
            long_return = index2;
            return (u_char*)&long_return;
#endif
        case DHCPRELAYSERVERINETADDRTYPE:
        *write_method = write_dhcpRelayServerInetAddrType;
        long_return = 1;
        return (u_char*) &long_return;
        case DHCPRELAYSERVERINETADDR:
        *write_method = write_dhcpRelayServerInetAddr;
            long_return = value;
            return (u_char*)&long_return;
        default:
            ERROR_MSG("");
    }
    return NULL;
}

int
write_dhcpRelayServerInetAddrType(int action,
                                  u_char * var_val,
                                  u_char var_val_type,
                                  size_t var_val_len,
                                  u_char * statP,
                                  oid * name, size_t name_len)
{
    UI32_T dhcpRelayServerIpType = 0;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER)
        {
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len != sizeof(long))
        {
            return SNMP_ERR_WRONGLENGTH;
        }
        break;
    case RESERVE2:
        dhcpRelayServerIpType = *(long *)var_val;
        if(dhcpRelayServerIpType != 1)
            return SNMP_ERR_WRONGVALUE;
        break;
    case FREE:

            /*
             * Release any resources that have been allocated
             */
            break;
    case ACTION:
        {
            /*
             *
             * * The variable has been stored in 'value' for you to use,
             * * and you have just been asked to do something with it.
             * * Note that anything done here must be reversable in the UNDO case
             */

        }
            break;
    case UNDO:

            /*
             * Back out any changes made in the ACTION case
             */
            break;
    case COMMIT:

            /*
             *
             * * Things are working well, so it's now safe to make the change
             * * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dhcpRelayServerInetAddr(int action,
                                  u_char * var_val,
                                  u_char var_val_type,
                                  size_t var_val_len,
                                  u_char * statP,
                                  oid * name, size_t name_len)
{

    UI32_T value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 7;

    /* check 1: check if the input index is exactly match, if not return fail*/
    if(name_len != 2 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
                return SNMP_ERR_WRONGTYPE;
            }
          if (var_val_len != SYS_TYPE_IPV4_ADDR_LEN) {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;

        case RESERVE2:
            memcpy(&value, var_val, var_val_len);
            if(!IP_LIB_IsValidForNetworkInterface((UI8_T *)&value) && value != 0)
                return SNMP_ERR_WRONGVALUE;
            break;

        case FREE:
             /* Release any resources that have been allocated */
            break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */

        {
            UI32_T value;

            memcpy(&value, var_val, var_val_len);

            if(DHCP_PMGR_SetDhcpRelayServerAddrServerIp(name[oid_name_length], name[oid_name_length + 1], value) != DHCP_MGR_OK)
                return SNMP_ERR_COMMITFAILED;

            DHCP_PMGR_Restart3(DHCP_TYPE_RESTART_RELAY);
        }
            break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
            break;
    }
    return SNMP_ERR_NOERROR;

}

#endif /* end of #if (SYS_CPNT_DHCP_RELAY == TRUE)*/

#if 0 /* shumin.wang added for inet address, 2008-12-30 */
/********************************************
 **************dhcpServerMgt*****************
 ********************************************
 */
int
do_dhcpServerServiceStatus(netsnmp_mib_handler *handler,
                               netsnmp_handler_registration *reginfo,
                               netsnmp_agent_request_info   *reqinfo,
                               netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
        {
            if(DHCP_PMGR_GetDhcpServerServiceStatus())
            {
                long_return = VAL_dhcpServerServiceStatus_enabled;
            }
            else
            {
                long_return = VAL_dhcpServerServiceStatus_disabled;
            }
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *)&long_return, sizeof(long_return));
        }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
        {
            UI32_T value;
            value = (*requests->requestvb->val.integer);
            if((value < VAL_dhcpServerServiceStatus_enabled) || (value > VAL_dhcpServerServiceStatus_disabled))
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_INCONSISTENTVALUE);
        }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */

            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
        {
            UI32_T value;
            value = (*requests->requestvb->val.integer);

            if(value == VAL_dhcpServerServiceStatus_enabled)
            {
                DHCP_PMGR_Restart3(DHCP_MGR_RESTART_SERVER);
            }
            else if(value == VAL_dhcpServerServiceStatus_disabled)
            {
                if(DHCP_PMGR_RemoveSystemRole(DHCP_MGR_BIND_SERVER) == DHCP_MGR_OK)
                {
                    DHCP_PMGR_Restart3(DHCP_MGR_RESTART_CLIENT);
                }
                else
                {
                    return SNMP_ERR_GENERR;
                }
            }

        }
        break;


        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */

            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */

            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

/********************************************
 **************dhcpPoolTable*****************
 ********************************************
 */
/* dhcpPoolTable*/
#define dhcpPoolEntry_INSTANCE_LEN 9
static BOOL_T dhcpPoolTable_get(int                        compc,
                                oid                        *compl,
                                UI8_T                      *buffer,
                                DHCP_TYPE_PoolConfigEntry_T *data)
{

    if((compc <= 0) || (compc > dhcpPoolEntry_INSTANCE_LEN) || (compc != compl[0] + 1))
    {
        if(SNMP_MGR_IsDebugMode())
            SYSFUN_Debug_Printf("dhcpPoolTable_get:compc err, compc=[%d], compl[0]=[%lu]\n",compc, compl[0]);
        return FALSE;
    }

    SNMP_MGR_ReadStrFromCompl(compl, 1, compl[0], buffer);
    if(SNMP_MGR_IsDebugMode())
        SYSFUN_Debug_Printf("dhcpPoolTable_get: buffer=[%s]\n", buffer);

    if(DHCP_PMGR_GetDhcpPoolTable((char *)buffer, data) != DHCP_MGR_OK)
    {
        if(SNMP_MGR_IsDebugMode())
            SYSFUN_Debug_Printf("dhcpPoolTable_get:DHCP_MGR_GetDhcpPoolTable return !=DHCP_MGR_OK\n");
        return FALSE;
    }
    else
    {
    return TRUE;

    } /*End of if */
}

static BOOL_T dhcpPoolTable_next(int                        compc,
                                 oid                        *compl,
                                 UI8_T                      *buffer,
                                 DHCP_TYPE_PoolConfigEntry_T *data)
{

    /* Generate the instance of each table entry and find the
     * smallest instance that's larger than compc/compl.
     *
     * Step 1: Verify and extract the input key from "compc" and "compl"
     * Note: The number of input key is defined by "compc".
     *       The key for the specified instance is defined in compl.
     */

    if(compc > dhcpPoolEntry_INSTANCE_LEN)
    {
        if(SNMP_MGR_IsDebugMode())
            SYSFUN_Debug_Printf("dhcpPoolTable_next:compc err, compc = [%d]\n", compc);
        return FALSE;
    }
    else if(compc == 0)
    {
        /* If input key is not given, assign a default vaule to the input key.
        * Note: 1. The default value for an input key for "get next" shall be a value
        *          less than the first/smallest vaule defined by the input key type.
        *       2. Since compl is a byte array, for a given key, it may use multiple
        *          bytes to represent its key value! Byte/half-word swap may be required
        *          for Little-Endian type CPU.
        */
        buffer[0] = 0;
    }
    else if(compc == (compl[0] + 1))
    {
        /* The key for the specified instance is defined in compl.
        * Since compl is a byte array, for a givn key, it may use multiple bytes to represent its key value!
        * It shall be carefully when extract the key value from the compl. Byte/half-word swap may be required
        * for Little-Endian type CPU
        */
        SNMP_MGR_ReadStrFromCompl(compl, 1, compl[0], buffer);
    }
    else
    {
        return FALSE;
    }
    if(SNMP_MGR_IsDebugMode())
        SYSFUN_Debug_Printf("dhcpPoolTable_next:buffer=[%s]\n", buffer);

    if(DHCP_PMGR_GetNextDhcpPoolTable((char*)buffer, data) != DHCP_MGR_OK)
    {
        return FALSE;
    }
    else
    {
        if(SNMP_MGR_IsDebugMode())
            SYSFUN_Debug_Printf("dhcpPoolTable_next:DHCP_MGR_GetNextDhcpPoolTable return != DHCP_MGR_OK\n");
        return TRUE;
    }

}


/*
 * var_dhcpPoolTable():
 * Handle this table separately from the scalar value case.
 * The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_dhcpPoolTable(struct variable *vp,
                                 oid             *name,
                                 size_t          *length,
                  int exact, size_t * var_len, WriteMethod ** write_method)
{
    UI32_T compc = 0;
    oid compl[dhcpPoolEntry_INSTANCE_LEN];
    oid best_inst[dhcpPoolEntry_INSTANCE_LEN];
    DHCP_TYPE_PoolConfigEntry_T data;
    char buffer[MAXSIZE_dhcpPoolPoolName + 1];

    /*Since this table allow for entry that does not exist, (creation). we need to know the write method first*/
    switch(vp->magic)
    {
        case DHCPPOOLPOOLTYPE:
            *write_method = write_dhcpPoolPoolType;
            break;
        case DHCPPOOLPOOLADDRESS:
            *write_method = write_dhcpPoolPoolAddress;
            break;
        case DHCPPOOLSUBNETMASK:
            *write_method = write_dhcpPoolSubnetMask;
            break;
        case DHCPPOOLHARDWARETYPE:
            *write_method = write_dhcpPoolHardwareType;
            break;
        case DHCPPOOLMACADDRESS:
            *write_method = write_dhcpPoolMacAddress;
            break;
        case DHCPPOOLSTATUS:
            *write_method = write_dhcpPoolstatus;
            break;
        default:
            *write_method = 0;
            break;
    }


    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,compl, dhcpPoolEntry_INSTANCE_LEN);

     /*check compc, retrive compl*/
    if(exact)  /* get, set */
    {
        if(!dhcpPoolTable_get(compc, compl, (UI8_T *)buffer, &data))
            return NULL;
    }
    else  /* getnext */
    {
        if(!dhcpPoolTable_next(compc, compl, (UI8_T *)buffer, &data))
        {
            return NULL;
        }
    }
    if(SNMP_MGR_IsDebugMode())
        SYSFUN_Debug_Printf("var_dhcpPoolTable:buffer=[%s]\n", buffer);

    memcpy(name, vp->name, vp->namelen * sizeof(oid));
    best_inst[0] = strlen(buffer);
    SNMP_MGR_BindStrInstance(buffer, 1, best_inst);
    memcpy(name + vp->namelen, best_inst, (best_inst[0] + 1) * sizeof(oid));
    *length = vp->namelen + best_inst[0] + 1;

    *var_len = sizeof(long_return);

    /*
     * * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case DHCPPOOLPOOLNAME:
            strcpy(return_buf, buffer);
            *var_len = strlen(return_buf);
            return (u_char*)return_buf;
#endif
        case DHCPPOOLPOOLTYPE:
            long_return = data.pool_type;
            return (u_char*) &long_return;
        case DHCPPOOLPOOLADDRESS:
            if(data.pool_type == VAL_dhcpPoolPoolType_netWork)
            {
                ipaddr_return = data.network_address;
            }
            else if(data.pool_type == VAL_dhcpPoolPoolType_host)
            {
                ipaddr_return = data.host_address;
            }
            else
            {
                ipaddr_return = 0;
            }
            *var_len = sizeof(ipaddr_return);
            return (u_char*) &ipaddr_return;
        case DHCPPOOLSUBNETMASK:
            *var_len = sizeof(ipaddr_return);
            ipaddr_return = data.sub_netmask;
            return (u_char*) &ipaddr_return;
        case DHCPPOOLHARDWARETYPE:
            switch(data.hardware_address.htype)
            {
                case DHCP_MGR_HTYPE_NONE:
                    long_return = VAL_dhcpPoolHardwareType_notSpecify;
                    break;
                case DHCP_MGR_HTYPE_ETHER:
                    long_return = VAL_dhcpPoolHardwareType_ethernet;
                    break;
                case DHCP_MGR_HTYPE_IEEE802:
                    long_return = VAL_dhcpPoolHardwareType_ieee802;
                    break;
                case DHCP_MGR_HTYPE_FDDI:
                    long_return = VAL_dhcpPoolHardwareType_fddi;
                    break;
            }
            return (u_char*)&long_return;
        case DHCPPOOLMACADDRESS:
            memcpy(return_buf, data.hardware_address.haddr, SIZE_dhcpPoolMacAddress);
            *var_len = SIZE_dhcpPoolMacAddress;
            return (u_char*) return_buf;
        case DHCPPOOLSTATUS:
            long_return = VAL_dhcpPoolstatus_valid;
            return (u_char*) &long_return;
        default:
            ERROR_MSG("");
    }
    return NULL;
}


int
write_dhcpPoolPoolType(int action,
                           u_char    *var_val,
                           u_char    var_val_type,
                           size_t    var_val_len,
                       u_char * statP, oid * name, size_t name_len)
{
    long value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 7;
    char  buffer_index[MAXSIZE_dhcpPoolPoolName + 1];

   /* check 2: name[oid_name_length] = the length of the name, check if these exceed the max size*/
    if(name[oid_name_length] > MAXSIZE_dhcpPoolPoolName)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    /* check 3: check if the input index is exactly match, if not return fail*/
    if(name_len != name[oid_name_length] + 1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    SNMP_MGR_ReadStrFromCompl(name, oid_name_length + 1, name_len - 1, (UI8_T *)buffer_index);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
                return SNMP_ERR_WRONGTYPE;
            }
          if (var_val_len > sizeof(long)) {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;

        case RESERVE2:
            value = *(long *)var_val;
            if((value < VAL_dhcpPoolPoolType_notSpecify) || (value > VAL_dhcpPoolPoolType_host))
                return SNMP_ERR_WRONGVALUE;
            break;

        case FREE:
             /* Release any resources that have been allocated */
            break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */

        {
            UI32_T value;

            value = * (long *) var_val;

            if(DHCP_PMGR_SetDhcpPoolPoolType(buffer_index, value) != DHCP_MGR_OK)
                return SNMP_ERR_COMMITFAILED;
        }
            break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
            break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dhcpPoolPoolAddress(int action,
                              u_char    *var_val,
                              u_char    var_val_type,
                              size_t    var_val_len,
                          u_char * statP, oid * name, size_t name_len)
{
    UI32_T value;
    int size;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 7;
    UI8_T buffer_index[MAXSIZE_dhcpPoolPoolName + 1];

   /* check 2: name[oid_name_length] = the length of the name, check if these exceed the max size*/
    if(name[oid_name_length] > MAXSIZE_dhcpPoolPoolName)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    /* check 3: check if the input index is exactly match, if not return fail*/
    if(name_len != name[oid_name_length] + 1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    SNMP_MGR_ReadStrFromCompl(name, oid_name_length + 1, name_len - 1, buffer_index);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_IPADDRESS) {
                return SNMP_ERR_WRONGTYPE;
            }
          if (var_val_len !=  SYS_ADPT_IPV4_ADDR_LEN) {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;

        case RESERVE2:
            size = var_val_len;
            memcpy(&value, var_val, var_val_len);
            if(!IP_LIB_IsValidForNetworkInterface((UI8_T *)&value))
                return SNMP_ERR_WRONGVALUE;
            break;

        case FREE:
             /* Release any resources that have been allocated */
            break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
        {
            UI32_T value;

            memcpy(&value, var_val, var_val_len);

            if(DHCP_PMGR_SetDhcpPoolPoolAddress((char *)buffer_index, value) != DHCP_MGR_OK)
                return SNMP_ERR_COMMITFAILED;
        }
            break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
            break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dhcpPoolSubnetMask(int action,
                             u_char    *var_val,
                             u_char    var_val_type,
                             size_t    var_val_len,
                         u_char * statP, oid * name, size_t name_len)
{
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 7;
    UI8_T buffer_index[MAXSIZE_dhcpPoolPoolName + 1];

   /* check 2: name[oid_name_length] = the length of the name, check if these exceed the max size*/
    if(name[oid_name_length] > MAXSIZE_dhcpPoolPoolName)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    /* check 3: check if the input index is exactly match, if not return fail*/
    if(name_len != name[oid_name_length] + 1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    SNMP_MGR_ReadStrFromCompl(name, oid_name_length + 1, name_len - 1, buffer_index);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_IPADDRESS) {
                return SNMP_ERR_WRONGTYPE;
            }
          if (var_val_len !=  SYS_ADPT_IPV4_ADDR_LEN) {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;

        case RESERVE2:
            break;
        case FREE:
             /* Release any resources that have been allocated */
            break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */

        {
            UI32_T value;

            memcpy(&value, var_val, var_val_len);

            if(DHCP_PMGR_SetDhcpPoolSubnetMask((char *)buffer_index, value) != DHCP_MGR_OK)
                return SNMP_ERR_COMMITFAILED;
        }
            break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
            break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dhcpPoolHardwareType(int action,
                               u_char    *var_val,
                               u_char    var_val_type,
                               size_t    var_val_len,
                           u_char * statP, oid * name, size_t name_len)
{
    long value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 7;
    UI8_T buffer_index[MAXSIZE_dhcpPoolPoolName + 1];

   /* check 2: name[oid_name_length] = the length of the name, check if these exceed the max size*/
    if(name[oid_name_length] > MAXSIZE_dhcpPoolPoolName)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    /* check 3: check if the input index is exactly match, if not return fail*/
    if(name_len != name[oid_name_length] + 1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    SNMP_MGR_ReadStrFromCompl(name, oid_name_length + 1, name_len - 1, buffer_index);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
                return SNMP_ERR_WRONGTYPE;
            }
          if (var_val_len > sizeof(long)) {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;

        case RESERVE2:
            value = *(long *)var_val;
            if((value < VAL_dhcpPoolHardwareType_notSpecify) || (value > VAL_dhcpPoolHardwareType_fddi))
                return SNMP_ERR_WRONGVALUE;
            break;

        case FREE:
             /* Release any resources that have been allocated */
            break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */

        {
            UI32_T value;

            value = *(long *)var_val;
            switch(value)
            {
                case VAL_dhcpPoolHardwareType_notSpecify:
                    value = DHCP_MGR_HTYPE_NONE;
                    break;
                case VAL_dhcpPoolHardwareType_ethernet:
                    value = DHCP_MGR_HTYPE_ETHER;
                    break;
                case VAL_dhcpPoolHardwareType_ieee802:
                    value = DHCP_MGR_HTYPE_IEEE802;
                    break;
                case VAL_dhcpPoolHardwareType_fddi:
                    value = DHCP_MGR_HTYPE_FDDI;
                    break;
                default:
                    break;
            }
            if(DHCP_PMGR_SetMacTypeToPoolConfigEntry((char *)buffer_index, value) != DHCP_MGR_OK)
                return SNMP_ERR_COMMITFAILED;
        }
            break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
            break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dhcpPoolMacAddress(int action,
                             u_char    *var_val,
                             u_char    var_val_type,
                             size_t    var_val_len,
                         u_char * statP, oid * name, size_t name_len)
{

    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 7;
    UI8_T buffer_index[MAXSIZE_dhcpPoolPoolName + 1];

   /* check 2: name[oid_name_length] = the length of the name, check if these exceed the max size*/
    if(name[oid_name_length] > MAXSIZE_dhcpPoolPoolName)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    /* check 3: check if the input index is exactly match, if not return fail*/
    if(name_len != name[oid_name_length] + 1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    SNMP_MGR_ReadStrFromCompl(name, oid_name_length + 1, name_len - 1, buffer_index);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
                return SNMP_ERR_WRONGTYPE;
            }
          if (var_val_len > SIZE_dhcpPoolMacAddress*sizeof(UI8_T)) {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;

        case RESERVE2:

            break;

        case FREE:
             /* Release any resources that have been allocated */
            break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */

        {
            UI8_T buffer[SIZE_dhcpPoolMacAddress];

            memcpy(buffer, var_val, var_val_len);
            if(DHCP_PMGR_SetMacToPoolConfigEntry((char *)buffer_index, buffer) != DHCP_MGR_OK)
                return SNMP_ERR_COMMITFAILED;
        }
            break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
            break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dhcpPoolstatus(int action,
                         u_char    *var_val,
                         u_char    var_val_type,
                         size_t    var_val_len,
                     u_char * statP, oid * name, size_t name_len)
{
    long value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 7;
    UI8_T buffer_index[MAXSIZE_dhcpPoolPoolName + 1];

   /* check 2: name[oid_name_length] = the length of the name, check if these exceed the max size*/
    if(name[oid_name_length] > MAXSIZE_dhcpPoolPoolName)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    /* check 3: check if the input index is exactly match, if not return fail*/
    if(name_len != name[oid_name_length] + 1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    SNMP_MGR_ReadStrFromCompl(name, oid_name_length + 1, name_len - 1, buffer_index);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
                return SNMP_ERR_WRONGTYPE;
            }
          if (var_val_len > sizeof(long)) {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;

        case RESERVE2:
            value = *(long *)var_val;
            if((value < VAL_dhcpPoolstatus_valid) || (value > VAL_dhcpPoolstatus_invalid))
                return SNMP_ERR_WRONGVALUE;
            break;

        case FREE:
             /* Release any resources that have been allocated */
            break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */

        {
            UI32_T  value;

            value = *(long *)var_val;

            if(DHCP_PMGR_SetDhcpPoolStatus((char *)buffer_index, value) != DHCP_MGR_OK)
                return SNMP_ERR_COMMITFAILED;
        }
            break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
            break;
    }
    return SNMP_ERR_NOERROR;
}

/********************************************
 ***********dhcpPoolOptionTable**************
 ********************************************
 */
/* dhcpPoolOptionTable*/
#define dhcpPoolOptionEntry_INSTANCE_LEN 9
static BOOL_T dhcpPoolOptionTable_get(int                      compc,
                                      oid                      *compl,
                                      UI8_T                    *buffer,
                                      DHCP_TYPE_ServerOptions_T *data)
{

    if((compc <= 0) || (compc > dhcpPoolOptionEntry_INSTANCE_LEN) || (compc != compl[0] + 1))
    {
        return FALSE;
    }

    SNMP_MGR_ReadStrFromCompl(compl, 1, compl[0], buffer);


    if(DHCP_PMGR_GetDhcpPoolOptionTable((char *)buffer, data) != DHCP_MGR_OK)
    {
        return FALSE;
    }
    else
    {
    return TRUE;

    } /*End of if */
}

static BOOL_T dhcpPoolOptionTable_next(int                      compc,
                                       oid                      *compl,
                                       UI8_T                    *buffer,
                                       DHCP_TYPE_ServerOptions_T *data)
{
    oid tmp_compl[dhcpPoolOptionEntry_INSTANCE_LEN];

    /* Generate the instance of each table entry and find the
     * smallest instance that's larger than compc/compl.
     *
     * Step 1: Verify and extract the input key from "compc" and "compl"
     * Note: The number of input key is defined by "compc".
     *       The key for the specified instance is defined in compl.
     */
    memcpy(tmp_compl, compl, sizeof(tmp_compl));

    if(compc > dhcpPoolOptionEntry_INSTANCE_LEN)
    {
        return FALSE;
    }
    else if(compc == 0)
    {
        /* If input key is not given, assign a default vaule to the input key.
        * Note: 1. The default value for an input key for "get next" shall be a value
        *          less than the first/smallest vaule defined by the input key type.
        *       2. Since compl is a byte array, for a given key, it may use multiple
        *          bytes to represent its key value! Byte/half-word swap may be required
        *          for Little-Endian type CPU.
        */
        buffer[0] = 0;
    }
    else if(compc == (compl[0] + 1))
    {
        /* The key for the specified instance is defined in compl.
        * Since compl is a byte array, for a givn key, it may use multiple bytes to represent its key value!
        * It shall be carefully when extract the key value from the compl. Byte/half-word swap may be required
        * for Little-Endian type CPU
        */
        SNMP_MGR_ReadStrFromCompl(compl,1,compl[0],buffer);
    }
    else
    {
        return FALSE;
    }

    if(DHCP_PMGR_GetNextDhcpPoolOptionTable((char *)buffer, data) != DHCP_MGR_OK)
    {
        return FALSE;
    }
    else
    {
        return TRUE;
    }

}


/*
 * var_dhcpPoolOptionTable():
 * Handle this table separately from the scalar value case.
 * The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_dhcpPoolOptionTable(struct variable *vp,
                                       oid             *name,
                                       size_t          *length,
                                       int             exact,
                        size_t * var_len, WriteMethod ** write_method)
{
    UI32_T compc = 0;
    oid compl[dhcpPoolOptionEntry_INSTANCE_LEN];
    oid best_inst[dhcpPoolOptionEntry_INSTANCE_LEN];
    DHCP_TYPE_ServerOptions_T data;
    char  buffer[MAXSIZE_dhcpPoolOptionPoolName + 1];

    /* Since this table allow for entry that does not exist, (creation). we need to know the write method first */
    switch(vp->magic)
    {
        case DHCPPOOLOPTIONNEXTSERVER:
            *write_method = write_dhcpPoolOptionNextServer;
            break;
        case DHCPPOOLOPTIONNETBIOSNODETYPE:
            *write_method = write_dhcpPoolOptionNetbiosNodeType;
            break;
        case DHCPPOOLOPTIONDOMAINNAME:
            *write_method = write_dhcpPoolOptionDomainName;
            break;
        case DHCPPOOLOPTIONBOOTFILE:
            *write_method = write_dhcpPoolOptionBootFile;
            break;
        case DHCPPOOLOPTIONLEASETIME:
            *write_method = write_dhcpPoolOptionLeaseTime;
            break;
        case DHCPPOOLOPTIONCIDMODE:
            *write_method = write_dhcpPoolOptionCidMode;
            break;
        case DHCPPOOLOPTIONCIDBUFFER:
            *write_method = write_dhcpPoolOptionCidBuffer;
            break;
        default:
            *write_method = 0;
            break;
    }


    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl, dhcpPoolOptionEntry_INSTANCE_LEN);

     /*check compc, retrive compl*/
    if(exact)  /* get, set */
    {
        if(!dhcpPoolOptionTable_get(compc, compl, (UI8_T *)buffer, &data))
            return NULL;
    }
    else  /* getnext */
    {
        if(!dhcpPoolOptionTable_next(compc, compl, (UI8_T *)buffer, &data))
        {
            return NULL;
        }
    }
    memcpy(name, vp->name, vp->namelen * sizeof(oid));
    best_inst[0] = strlen(buffer);
    SNMP_MGR_BindStrInstance(buffer, 1, best_inst);
    memcpy(name + vp->namelen, best_inst, (best_inst[0] + 1) * sizeof(oid));
    *length = vp->namelen + best_inst[0] + 1;

    *var_len = sizeof(long_return);

    /*
     * * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case DHCPPOOLOPTIONPOOLNAME:
            strcpy(return_buf, buffer);
            *var_len = strlen(return_buf);
            return (u_char*) return_buf;
#endif
        case DHCPPOOLOPTIONNEXTSERVER:
            *var_len = sizeof(ipaddr_return);
            ipaddr_return = data.next_server;
            return (u_char*) &ipaddr_return;
        case DHCPPOOLOPTIONNETBIOSNODETYPE:
            switch(data.netbios_node_type)
            {
                case DHCP_MGR_NETBIOS_NODE_TYPE_NONE:
                    long_return = VAL_dhcpPoolOptionNetbiosNodeType_none;
                    break;
                case DHCP_MGR_NETBIOS_NODE_TYPE_B_NODE:
                    long_return = VAL_dhcpPoolOptionNetbiosNodeType_b_node;
                    break;
                case DHCP_MGR_NETBIOS_NODE_TYPE_P_NODE:
                    long_return = VAL_dhcpPoolOptionNetbiosNodeType_p_node;
                    break;
                case DHCP_MGR_NETBIOS_NODE_TYPE_M_NODE:
                    long_return = VAL_dhcpPoolOptionNetbiosNodeType_m_node;
                    break;
                case DHCP_MGR_NETBIOS_NODE_TYPE_H_NODE:
                    long_return = VAL_dhcpPoolOptionNetbiosNodeType_h_node;
                    break;
                default:
                    break;
            }
            return (u_char*)&long_return;
        case DHCPPOOLOPTIONDOMAINNAME:
            strcpy((char *)return_buf, data.domain_name);
            *var_len = strlen((char *)return_buf);
            return (u_char*) return_buf;
        case DHCPPOOLOPTIONBOOTFILE:
            strcpy((char *)return_buf, data.bootfile);
            *var_len = strlen((char *)return_buf);
            return (u_char*) return_buf;
        case DHCPPOOLOPTIONLEASETIME:
            long_return = data.lease_time;
            return (u_char*) &long_return;
        case DHCPPOOLOPTIONCIDMODE:
            long_return = data.cid.id_mode;
            return (u_char*) &long_return;
        case DHCPPOOLOPTIONCIDBUFFER:
            memcpy(return_buf, data.cid.id_buf, data.cid.id_len);
            *var_len = data.cid.id_len;
            return (u_char*) return_buf;
        default:
            ERROR_MSG("");
    }
    return NULL;
}


int
write_dhcpPoolOptionNextServer(int action,
                                   u_char    *var_val,
                                   u_char    var_val_type,
                                   size_t    var_val_len,
                               u_char * statP, oid * name, size_t name_len)
{
    UI32_T value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 7;
    UI8_T buffer_index[MAXSIZE_dhcpPoolPoolName + 1];

   /* check 2: name[oid_name_length] = the length of the name, check if these exceed the max size*/
    if(name[oid_name_length] > MAXSIZE_dhcpPoolPoolName)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    /* check 3: check if the input index is exactly match, if not return fail*/
    if(name_len != name[oid_name_length] + 1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    SNMP_MGR_ReadStrFromCompl(name, oid_name_length + 1, name_len - 1, buffer_index);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_IPADDRESS) {
                return SNMP_ERR_WRONGTYPE;
            }
          if (var_val_len !=  SYS_ADPT_IPV4_ADDR_LEN) {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;

        case RESERVE2:
            memcpy(&value, var_val, var_val_len);
            if(!IP_LIB_IsValidForNetworkInterface((UI8_T *)&value))
                return SNMP_ERR_WRONGVALUE;
            break;

        case FREE:
             /* Release any resources that have been allocated */
            break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */

        {
            UI32_T value;

            memcpy(&value, var_val, var_val_len);

            if(DHCP_PMGR_SetNextServerToPoolConfigEntry((char *)buffer_index, value) != DHCP_MGR_OK)
                return SNMP_ERR_COMMITFAILED;
        }
            break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
            break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dhcpPoolOptionNetbiosNodeType(int action,
                                        u_char    *var_val,
                                        u_char    var_val_type,
                                        size_t    var_val_len,
                                        u_char    *statP,
                                    oid * name, size_t name_len)
{
    long value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 7;
    UI8_T buffer_index[MAXSIZE_dhcpPoolPoolName + 1];

   /* check 2: name[oid_name_length] = the length of the name, check if these exceed the max size*/
    if(name[oid_name_length] > MAXSIZE_dhcpPoolPoolName)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    /* check 3: check if the input index is exactly match, if not return fail*/
    if(name_len != name[oid_name_length] + 1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    SNMP_MGR_ReadStrFromCompl(name, oid_name_length + 1, name_len - 1, buffer_index);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
                return SNMP_ERR_WRONGTYPE;
            }
          if (var_val_len > sizeof(long)) {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;

        case RESERVE2:
            value = *(long *)var_val;
            if((value < VAL_dhcpPoolOptionNetbiosNodeType_none) || (value > VAL_dhcpPoolOptionNetbiosNodeType_h_node))
                return SNMP_ERR_WRONGVALUE;
            break;

        case FREE:
             /* Release any resources that have been allocated */
            break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */

        {
            UI32_T value;

            value = *(long *)var_val;

            if(DHCP_PMGR_SetNetbiosNodeTypeToPoolConfigEntry((char *)buffer_index, value) != DHCP_MGR_OK)
                return SNMP_ERR_COMMITFAILED;
        }
            break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
            break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dhcpPoolOptionDomainName(int action,
                                   u_char    *var_val,
                                   u_char    var_val_type,
                                   size_t    var_val_len,
                               u_char * statP, oid * name, size_t name_len)
{

    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 7;
    UI8_T buffer_index[MAXSIZE_dhcpPoolPoolName + 1];

   /* check 2: name[oid_name_length] = the length of the name, check if these exceed the max size*/
    if(name[oid_name_length] > MAXSIZE_dhcpPoolPoolName)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    /* check 3: check if the input index is exactly match, if not return fail*/
    if(name_len != name[oid_name_length] + 1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    SNMP_MGR_ReadStrFromCompl(name, oid_name_length + 1, name_len - 1, buffer_index);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
                return SNMP_ERR_WRONGTYPE;
            }
          if (var_val_len >MAXSIZE_dhcpPoolOptionDomainName) {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;

        case RESERVE2:

            break;

        case FREE:
             /* Release any resources that have been allocated */
            break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */

        {
            char buffer[MAXSIZE_dhcpPoolOptionDomainName + 1];

            memcpy(buffer, var_val, var_val_len);
            buffer[var_val_len] = '\0';
            if(!L_STDLIB_StrIsAsciiPrintWithCount(buffer, var_val_len))
            {
                return SNMP_ERR_COMMITFAILED;
            }
            if(DHCP_PMGR_SetDomainNameToPoolConfigEntry((char *)buffer_index, buffer) != DHCP_MGR_OK)
                return SNMP_ERR_COMMITFAILED;
        }
            break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
            break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dhcpPoolOptionBootFile(int action,
                                 u_char    *var_val,
                                 u_char    var_val_type,
                                 size_t    var_val_len,
                             u_char * statP, oid * name, size_t name_len)
{

    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 7;
    UI8_T buffer_index[MAXSIZE_dhcpPoolPoolName + 1];

   /* check 2: name[oid_name_length] = the length of the name, check if these exceed the max size*/
    if(name[oid_name_length] > MAXSIZE_dhcpPoolPoolName)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    /* check 3: check if the input index is exactly match, if not return fail*/
    if(name_len != name[oid_name_length] + 1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    SNMP_MGR_ReadStrFromCompl(name, oid_name_length + 1, name_len - 1, buffer_index);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
                return SNMP_ERR_WRONGTYPE;
            }
          if (var_val_len >MAXSIZE_dhcpPoolOptionBootFile) {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;

        case RESERVE2:

            break;

        case FREE:
             /* Release any resources that have been allocated */
            break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */

        {
            char buffer[MAXSIZE_dhcpPoolOptionBootFile + 1];

            memcpy(buffer, var_val, var_val_len);
            buffer[var_val_len] = '\0';
            if(!L_STDLIB_StrIsAsciiPrintWithCount(buffer, var_val_len))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            if(DHCP_PMGR_SetBootfileToPoolConfigEntry((char *)buffer_index, buffer) != DHCP_MGR_OK)
                return SNMP_ERR_COMMITFAILED;
        }
            break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
            break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dhcpPoolOptionLeaseTime(int action,
                                  u_char    *var_val,
                                  u_char    var_val_type,
                                  size_t    var_val_len,
                              u_char * statP, oid * name, size_t name_len)
{

    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 7;
    UI8_T buffer_index[MAXSIZE_dhcpPoolPoolName + 1];

   /* check 2: name[oid_name_length] = the length of the name, check if these exceed the max size */
    if(name[oid_name_length] > MAXSIZE_dhcpPoolPoolName)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    /* check 3: check if the input index is exactly match, if not return fail*/
    if(name_len != name[oid_name_length] + 1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    SNMP_MGR_ReadStrFromCompl(name, oid_name_length + 1, name_len - 1, buffer_index);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
                return SNMP_ERR_WRONGTYPE;
            }
          if (var_val_len >sizeof(long)) {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;

        case RESERVE2:

            break;

        case FREE:
             /* Release any resources that have been allocated */
            break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */

        {
            UI32_T value;

            value = *(long *)var_val;

            if(DHCP_PMGR_SetLeaseTimeToPoolConfigEntry((char *)buffer_index, value, 0) != DHCP_MGR_OK)
                return SNMP_ERR_COMMITFAILED;
        }
            break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
            break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dhcpPoolOptionCidMode(int action,
                            u_char * var_val,
                            u_char var_val_type,
                            size_t var_val_len,
                            u_char * statP, oid * name, size_t name_len)
{
    long value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 7;
    UI8_T buffer_index[MAXSIZE_dhcpPoolPoolName+1];

   /* check 2: name[oid_name_length] = the length of the name, check if these exceed the max size*/
    if (name[oid_name_length] > MAXSIZE_dhcpPoolPoolName)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    /* check 3: check if the input index is exactly match, if not return fail*/
    if (name_len!= name[oid_name_length]+ 1+ oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    SNMP_MGR_ReadStrFromCompl(name,oid_name_length+1, name_len - 1,buffer_index);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len >sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          value = *(long *)var_val;
          if ((value <VAL_dhcpPoolOptionCidMode_text) || (value >VAL_dhcpPoolOptionCidMode_hex))
             return SNMP_ERR_WRONGVALUE;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */

           {
              UI32_T value;

               value = *(long *)var_val;

               if (DHCP_PMGR_SetDhcpPoolOptionCidMode( (char *)buffer_index,  value) != DHCP_MGR_OK)
                 return SNMP_ERR_COMMITFAILED;
           }
            break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dhcpPoolOptionCidBuffer(int action,
                              u_char * var_val,
                              u_char var_val_type,
                              size_t var_val_len,
                              u_char * statP, oid * name, size_t name_len)
{
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 7;
    UI8_T buffer_index[MAXSIZE_dhcpPoolPoolName+1];

   /* check 2: name[oid_name_length] = the length of the name, check if these exceed the max size*/
    if (name[oid_name_length] > MAXSIZE_dhcpPoolOptionCidBuffer)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    /* check 3: check if the input index is exactly match, if not return fail*/
    if (name_len!= name[oid_name_length]+ 1+ oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    SNMP_MGR_ReadStrFromCompl(name,oid_name_length+1, name_len - 1,buffer_index);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len >MAXSIZE_dhcpPoolOptionCidBuffer) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */

           {
              char  buffer[MAXSIZE_dhcpPoolOptionCidBuffer+1];

               memcpy(buffer, var_val,var_val_len);
               buffer[var_val_len]='\0';
               if (!L_STDLIB_StrIsAsciiPrintWithCount(buffer, var_val_len))
               {
                    return SNMP_ERR_COMMITFAILED;
               }
               if (DHCP_PMGR_SetDhcpPoolOptionCidBuffer((char *) buffer_index,  buffer) != DHCP_MGR_OK)
                 return SNMP_ERR_COMMITFAILED;
           }
            break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

/********************************************
 ***********dhcpPoolOptionDnsSerTable********
 ********************************************
 */
/* dhcpPoolOptionDnsSerTable*/
#define dhcpPoolOptionDnsSerEntry_INSTANCE_LEN 10
static BOOL_T dhcpPoolOptionDnsSerTable_get(int      compc,
                                oid     *compl,
                                UI8_T   *buffer,
                                UI32_T  *idx1,
                                UI32_T   *value)
{

    if ((compc <= 0)||(compc > dhcpPoolOptionDnsSerEntry_INSTANCE_LEN) || (compc != compl[0] + 2 ))
    {
        return FALSE;
    }

    SNMP_MGR_ReadStrFromCompl(compl,1,compl[0],buffer);
    *idx1=compl[compl[0]+1];

    if (DHCP_PMGR_GetDhcpPoolOptionDnsSerTable((char *)buffer, *idx1, value)!=DHCP_MGR_OK)
    {
        return FALSE;
    }
    else
    {
        return TRUE;

    } /*End of if */
}

static BOOL_T dhcpPoolOptionDnsSerTable_next(int   compc,
                                 oid     *compl,
                                 UI8_T   *buffer,
                                 UI32_T  *index1,
                                 UI32_T  *value)
{
    oid tmp_compl[dhcpPoolOptionDnsSerEntry_INSTANCE_LEN];

    /* Generate the instance of each table entry and find the
     * smallest instance that's larger than compc/compl.
     *
     * Step 1: Verify and extract the input key from "compc" and "compl"
     * Note: The number of input key is defined by "compc".
     *       The key for the specified instance is defined in compl.
     */
    memcpy(tmp_compl, compl, sizeof(tmp_compl));

    if (compc > dhcpPoolOptionDnsSerEntry_INSTANCE_LEN)
    {
        return FALSE;
    }
    else if(compc==0)
    {
        /* If input key is not given, assign a default vaule to the input key.
        * Note: 1. The default value for an input key for "get next" shall be a value
        *          less than the first/smallest vaule defined by the input key type.
        *       2. Since compl is a byte array, for a given key, it may use multiple
        *          bytes to represent its key value! Byte/half-word swap may be required
        *          for Little-Endian type CPU.
        */
        buffer[0]=0;
        *index1 = 0;
    }
    else if(compc==(compl[0] + 2))
    {
        /* The key for the specified instance is defined in compl.
        * Since compl is a byte array, for a givn key, it may use multiple bytes to represent its key value!
        * It shall be carefully when extract the key value from the compl. Byte/half-word swap may be required
        * for Little-Endian type CPU
        */
        SNMP_MGR_ReadStrFromCompl(compl,1,compl[0],buffer);
        *index1=compl[compl[0]+1];
    }
    else
    {
        return FALSE;
    }

    if (DHCP_PMGR_GetNextDhcpPoolOptionDnsSerTable((char *)buffer, index1, value)!=DHCP_MGR_OK)
    {
        return FALSE;
    }
    else
    {
        return TRUE;
    }

}


/*
 * var_dhcpPoolOptionDnsSerTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_dhcpPoolOptionDnsSerTable(struct variable *vp,
                              oid * name,
                              size_t * length,
                              int exact,
                              size_t * var_len,
                              WriteMethod ** write_method)
{
    UI32_T compc=0;
    oid compl[dhcpPoolOptionDnsSerEntry_INSTANCE_LEN];
    oid best_inst[dhcpPoolOptionDnsSerEntry_INSTANCE_LEN];
    UI32_T  index1;
    UI32_T value;
    char  buffer[MAXSIZE_dhcpPoolOptionDnsSerPoolName+1];

    switch (vp->magic)
    {
        case DHCPPOOLOPTIONDNSSERIPADDRESS:
            *write_method = write_dhcpPoolOptionDnsSerIpAddress;
            break;
        default:
            *write_method = 0;
            break;
    }

    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,compl, dhcpPoolOptionDnsSerEntry_INSTANCE_LEN);

     /*check compc, retrive compl*/
    if (exact)/*get,set*/
    {
        if (!dhcpPoolOptionDnsSerTable_get(compc, compl, (UI8_T  *)buffer, &index1, &value))
            return NULL;
    }
    else/*getnext*/
    {
        if (!dhcpPoolOptionDnsSerTable_next(compc, compl, (UI8_T *)buffer, &index1, &value))
        {
            return NULL;
        }
    }
    memcpy(name, vp->name, vp->namelen*sizeof(oid));
    best_inst[0] = strlen(buffer);
    SNMP_MGR_BindStrInstance(buffer,1,best_inst);
    best_inst[strlen(buffer)+1]=index1;
    memcpy(name + vp->namelen, best_inst, (best_inst[0]+2)*sizeof(oid));
    *length = vp->namelen +best_inst[0]+2;

    *var_len = sizeof(long_return);

    /*
     * * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
      case DHCPPOOLOPTIONDNSSERPOOLNAME:
        strcpy( return_buf, buffer);
        *var_len = strlen(return_buf);
        return (u_char*) return_buf;
      case DHCPPOOLOPTIONDNSSERINDEX:
        long_return  = index1;
        return (u_char*) &long_return;
    #endif
      case DHCPPOOLOPTIONDNSSERIPADDRESS:
        *var_len = sizeof(ipaddr_return);
        ipaddr_return  = value;
        return (u_char*) &ipaddr_return;
    default:
        ERROR_MSG("");
    }
    return NULL;
}


int
write_dhcpPoolOptionDnsSerIpAddress(int action,
                                    u_char * var_val,
                                    u_char var_val_type,
                                    size_t var_val_len,
                                    u_char * statP,
                                    oid * name, size_t name_len)
{
    UI32_T value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 7;
    UI8_T buffer_index[MAXSIZE_dhcpPoolOptionDnsSerPoolName+1];
    UI32_T index1;

   /* check 2: name[oid_name_length] = the length of the name, check if these exceed the max size*/
    if (name[oid_name_length] > MAXSIZE_dhcpPoolOptionDnsSerPoolName)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    /* check 3: check if the input index is exactly match, if not return fail*/
    if (name_len!= name[oid_name_length]+ 2+ oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    SNMP_MGR_ReadStrFromCompl(name,oid_name_length+1, name_len - 2,buffer_index);
    index1 = name[oid_name_length+name[oid_name_length]+1];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_IPADDRESS) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len !=  SYS_ADPT_IPV4_ADDR_LEN) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          memcpy(&value, var_val, var_val_len);
          if (!IP_LIB_IsValidForNetworkInterface((UI8_T *)&value))
             return SNMP_ERR_WRONGVALUE;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */

           {
              UI32_T  value;

               memcpy(&value, var_val, var_val_len);

               if (DHCP_PMGR_SetDhcpPoolOptionDnsSerIpAddress( (char *)buffer_index, index1, value) != DHCP_MGR_OK)
                 return SNMP_ERR_COMMITFAILED;
           }
            break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

/* dhcpPoolOptDefaultRouterTable*/
#define dhcpPoolOptDefaultRouterEntry_INSTANCE_LEN 10
static BOOL_T dhcpPoolOptDefaultRouterTable_get(int      compc,
                                oid     *compl,
                                UI8_T   *buffer,
                                UI32_T   *idx1,
                                UI32_T   *value)
{

    if ((compc <= 0)||(compc > dhcpPoolOptDefaultRouterEntry_INSTANCE_LEN) || (compc != compl[0] + 2 ))
    {
        return FALSE;
    }

    SNMP_MGR_ReadStrFromCompl(compl,1,compl[0],buffer);
    *idx1=compl[compl[0]+1];

    if (DHCP_PMGR_GetDhcpPoolOptDefaultRouterTable((char *)buffer, *idx1, value)!=DHCP_MGR_OK)
    {
        return FALSE;
    }
    else
    {
        return TRUE;

    } /*End of if */
}

static BOOL_T dhcpPoolOptDefaultRouterTable_next(int   compc,
                                 oid     *compl,
                                 UI8_T   *buffer,
                                 UI32_T  *index1,
                                 UI32_T  *value)
{
    oid tmp_compl[dhcpPoolOptDefaultRouterEntry_INSTANCE_LEN];

    /* Generate the instance of each table entry and find the
     * smallest instance that's larger than compc/compl.
     *
     * Step 1: Verify and extract the input key from "compc" and "compl"
     * Note: The number of input key is defined by "compc".
     *       The key for the specified instance is defined in compl.
     */
    memcpy(tmp_compl, compl, sizeof(tmp_compl));

    if (compc > dhcpPoolOptDefaultRouterEntry_INSTANCE_LEN)
    {
        return FALSE;
    }
    else if(compc==0)
    {
        /* If input key is not given, assign a default vaule to the input key.
        * Note: 1. The default value for an input key for "get next" shall be a value
        *          less than the first/smallest vaule defined by the input key type.
        *       2. Since compl is a byte array, for a given key, it may use multiple
        *          bytes to represent its key value! Byte/half-word swap may be required
        *          for Little-Endian type CPU.
        */
        buffer[0]=0;
        *index1 = 0;
    }
    else if(compc==(compl[0] + 2))
    {
        /* The key for the specified instance is defined in compl.
        * Since compl is a byte array, for a givn key, it may use multiple bytes to represent its key value!
        * It shall be carefully when extract the key value from the compl. Byte/half-word swap may be required
        * for Little-Endian type CPU
        */
        SNMP_MGR_ReadStrFromCompl(compl,1,compl[0],buffer);
        *index1=compl[compl[0]+1];
    }
    else
    {
        return FALSE;
    }

    if (DHCP_PMGR_GetNextDhcpPoolOptDefaultRouterTable((char *)buffer, index1, value)!=DHCP_MGR_OK)
    {
        return FALSE;
    }
    else
    {
        return TRUE;
    }

}

/*
 * var_dhcpPoolOptDefaultRouterTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_dhcpPoolOptDefaultRouterTable(struct variable *vp,
                                  oid * name,
                                  size_t * length,
                                  int exact,
                                  size_t * var_len,
                                  WriteMethod ** write_method)
{
    UI32_T compc=0;
    oid compl[dhcpPoolOptDefaultRouterEntry_INSTANCE_LEN];
    oid best_inst[dhcpPoolOptDefaultRouterEntry_INSTANCE_LEN];
    UI32_T  index1;
    UI32_T value;
    char buffer[MAXSIZE_dhcpPoolOptDefaultRouterPoolName+1];

    switch (vp->magic)
    {
        case DHCPPOOLOPTDEFAULTROUTERIPADDRESS:
            *write_method = write_dhcpPoolOptDefaultRouterIpAddress;
            break;
        default:
            *write_method = 0;
            break;
    }

    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,compl, dhcpPoolOptDefaultRouterEntry_INSTANCE_LEN);

     /*check compc, retrive compl*/
    if (exact)/*get,set*/
    {
        if (!dhcpPoolOptDefaultRouterTable_get(compc, compl, (UI8_T *)buffer, &index1, &value))
            return NULL;
    }
    else/*getnext*/
    {
        if (!dhcpPoolOptDefaultRouterTable_next(compc, compl, (UI8_T *)buffer, &index1, &value))
        {
            return NULL;
        }
    }
    memcpy(name, vp->name, vp->namelen*sizeof(oid));
    best_inst[0] = strlen(buffer);
    SNMP_MGR_BindStrInstance(buffer,1,best_inst);
    best_inst[strlen(buffer)+1]=index1;
    memcpy(name + vp->namelen, best_inst, (best_inst[0]+2)*sizeof(oid));
    *length = vp->namelen +best_inst[0]+2;

    *var_len = sizeof(long_return);

    /*
     * * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
      case DHCPPOOLOPTDEFAULTROUTERPOOLNAME:
        strcpy( return_buf, buffer);
        *var_len = strlen(return_buf);
        return (u_char*) return_buf;
      case DHCPPOOLOPTDEFAULTROUTERINDEX:
        long_return  = index1;
        return (u_char*) &long_return;
    #endif
      case DHCPPOOLOPTDEFAULTROUTERIPADDRESS:
        *var_len = sizeof(ipaddr_return);
        ipaddr_return  = value;
        return (u_char*) &ipaddr_return;
    default:
        ERROR_MSG("");
    }
    return NULL;
}


int
write_dhcpPoolOptDefaultRouterIpAddress(int action,
                                        u_char * var_val,
                                        u_char var_val_type,
                                        size_t var_val_len,
                                        u_char * statP,
                                        oid * name, size_t name_len)
{
    UI32_T value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 7;
    UI8_T buffer_index[MAXSIZE_dhcpPoolOptDefaultRouterPoolName];
    UI32_T index1;

   /* check 2: name[oid_name_length] = the length of the name, check if these exceed the max size*/
    if (name[oid_name_length] > MAXSIZE_dhcpPoolOptDefaultRouterPoolName)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    /* check 3: check if the input index is exactly match, if not return fail*/
    if (name_len!= name[oid_name_length]+ 2+ oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    SNMP_MGR_ReadStrFromCompl(name,oid_name_length+1, name_len - 2,buffer_index);
    index1 = name[oid_name_length+name[oid_name_length]+1];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_IPADDRESS) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len !=  SYS_ADPT_IPV4_ADDR_LEN) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          memcpy(&value, var_val, var_val_len);
          if (!IP_LIB_IsValidForNetworkInterface((UI8_T *)&value))
             return SNMP_ERR_WRONGVALUE;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */

           {
              UI32_T  value;

               memcpy(&value, var_val, var_val_len);

               if (DHCP_PMGR_SetDhcpPoolOptDefaultRouterIpAddress( (char *)buffer_index, index1, value) != DHCP_MGR_OK)
                 return SNMP_ERR_COMMITFAILED;
           }
            break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

/********************************************
 ***********dhcpPoolOptNetbiosServerTable****
 ********************************************
 */
/* dhcpPoolOptDefaultRouterTable*/
#define dhcpPoolOptNetbiosServerEntry_INSTANCE_LEN 10
static BOOL_T dhcpPoolOptNetbiosServerTable_get(int      compc,
                                oid     *compl,
                                UI8_T    *buffer,
                                UI32_T    *idx1,
                                UI32_T   *value)
{

    if ((compc <= 0)||(compc > dhcpPoolOptNetbiosServerEntry_INSTANCE_LEN) || (compc != compl[0] + 2 ))
    {
        return FALSE;
    }

    SNMP_MGR_ReadStrFromCompl(compl,1,compl[0],buffer);
    *idx1=compl[compl[0]+1];

    if (DHCP_PMGR_GetDhcpPoolOptNetbiosServerTable((char *)buffer, *idx1, value)!=DHCP_MGR_OK)
    {
        return FALSE;
    }
    else
    {
        return TRUE;

    } /*End of if */
}

static BOOL_T dhcpPoolOptNetbiosServerTable_next(int   compc,
                                 oid     *compl,
                                 UI8_T   *buffer,
                                 UI32_T  *index1,
                                 UI32_T  *value)
{
    oid tmp_compl[dhcpPoolOptNetbiosServerEntry_INSTANCE_LEN];

    /* Generate the instance of each table entry and find the
     * smallest instance that's larger than compc/compl.
     *
     * Step 1: Verify and extract the input key from "compc" and "compl"
     * Note: The number of input key is defined by "compc".
     *       The key for the specified instance is defined in compl.
     */
    memcpy(tmp_compl, compl, sizeof(tmp_compl));

    if (compc > dhcpPoolOptNetbiosServerEntry_INSTANCE_LEN)
    {
        return FALSE;
    }
    else if(compc==0)
    {
        /* If input key is not given, assign a default vaule to the input key.
        * Note: 1. The default value for an input key for "get next" shall be a value
        *          less than the first/smallest vaule defined by the input key type.
        *       2. Since compl is a byte array, for a given key, it may use multiple
        *          bytes to represent its key value! Byte/half-word swap may be required
        *          for Little-Endian type CPU.
        */
        buffer[0]=0;
        *index1 = 0;
    }
    else if(compc==(compl[0] + 2))
    {
        /* The key for the specified instance is defined in compl.
        * Since compl is a byte array, for a givn key, it may use multiple bytes to represent its key value!
        * It shall be carefully when extract the key value from the compl. Byte/half-word swap may be required
        * for Little-Endian type CPU
        */
        SNMP_MGR_ReadStrFromCompl(compl,1,compl[0],buffer);
        *index1=compl[compl[0]+1];
    }
    else
    {
        return FALSE;
    }

    if (DHCP_PMGR_GetNextDhcpPoolOptNetbiosServerTable((char *)buffer, index1, value)!=DHCP_MGR_OK)
    {
        return FALSE;
    }
    else
    {
        return TRUE;
    }

}


/*
 * var_dhcpPoolOptNetbiosServerTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_dhcpPoolOptNetbiosServerTable(struct variable *vp,
                                  oid * name,
                                  size_t * length,
                                  int exact,
                                  size_t * var_len,
                                  WriteMethod ** write_method)
{
    UI32_T compc=0;
    oid compl[dhcpPoolOptNetbiosServerEntry_INSTANCE_LEN];
    oid best_inst[dhcpPoolOptNetbiosServerEntry_INSTANCE_LEN];
    UI32_T  index1;
    UI32_T value;
    char buffer[MAXSIZE_dhcpPoolOptNetbiosServerPoolName+1];

    switch (vp->magic)
    {
        case DHCPPOOLOPTNETBIOSSERVERIPADDRESS:
            *write_method = write_dhcpPoolOptNetbiosServerIpAddress;
            break;
        default:
            *write_method = 0;
            break;
    }

    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,compl, dhcpPoolOptNetbiosServerEntry_INSTANCE_LEN);

     /*check compc, retrive compl*/
    if (exact)/*get,set*/
    {
        if (!dhcpPoolOptNetbiosServerTable_get(compc, compl, (UI8_T *)buffer, &index1, &value))
            return NULL;
    }
    else/*getnext*/
    {
        if (!dhcpPoolOptNetbiosServerTable_next(compc, compl, (UI8_T *)buffer, &index1, &value))
        {
            return NULL;
        }
    }
    memcpy(name, vp->name, vp->namelen*sizeof(oid));
    best_inst[0] = strlen(buffer);
    SNMP_MGR_BindStrInstance(buffer,1,best_inst);
    best_inst[strlen(buffer)+1]=index1;
    memcpy(name + vp->namelen, best_inst, (best_inst[0]+2)*sizeof(oid));
    *length = vp->namelen +best_inst[0]+2;

    *var_len = sizeof(long_return);

    /*
     * * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
      case DHCPPOOLOPTNETBIOSSERVERPOOLNAME:
        strcpy( return_buf, buffer);
        *var_len = strlen(return_buf);
        return (u_char*) return_buf;
      case DHCPPOOLOPTNETBIOSSERVERINDEX:
        long_return  = index1;
        return (u_char*) &long_return;
    #endif
      case DHCPPOOLOPTNETBIOSSERVERIPADDRESS:
        *var_len = sizeof(ipaddr_return);
        ipaddr_return  = value;
        return (u_char*) &ipaddr_return;
    default:
        ERROR_MSG("");
    }
    return NULL;
}


int
write_dhcpPoolOptNetbiosServerIpAddress(int action,
                                        u_char * var_val,
                                        u_char var_val_type,
                                        size_t var_val_len,
                                        u_char * statP,
                                        oid * name, size_t name_len)
{
    UI32_T value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 7;
    UI8_T buffer_index[MAXSIZE_dhcpPoolOptNetbiosServerPoolName];
    UI32_T index1;

   /* check 2: name[oid_name_length] = the length of the name, check if these exceed the max size*/
    if (name[oid_name_length] > MAXSIZE_dhcpPoolOptDefaultRouterPoolName)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    /* check 3: check if the input index is exactly match, if not return fail*/
    if (name_len!= name[oid_name_length]+ 2+ oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    SNMP_MGR_ReadStrFromCompl(name,oid_name_length+1, name_len - 2,buffer_index);
    index1 = name[oid_name_length+name[oid_name_length]+1];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_IPADDRESS) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len !=  SYS_ADPT_IPV4_ADDR_LEN) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          memcpy(&value, var_val, var_val_len);
          if (!IP_LIB_IsValidForNetworkInterface((UI8_T *)&value))
             return SNMP_ERR_WRONGVALUE;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */

           {
              UI32_T  value;

               memcpy(&value, var_val, var_val_len);

               if (DHCP_PMGR_SetDhcpPoolOptNetbiosServerIpAddress((char *) buffer_index, index1, value) != DHCP_MGR_OK)
                 return SNMP_ERR_COMMITFAILED;
           }
            break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


/********************************************
 ***********dhcpServerExcludedIpAddrTable****
 ********************************************
 */
/* dhcpServerExcludedIpAddrTable*/
#define dhcpServerExcludedIpAddrEntry_INSTANCE_LEN 8
static BOOL_T dhcpServerExcludedIpAddrTable_get(int      compc,
                                oid     *compl,
                                UI32_T *idx1,
                                UI32_T  *idx2)
{

    if (compc !=dhcpServerExcludedIpAddrEntry_INSTANCE_LEN)
    {
        return FALSE;
    }

    SNMP_MGR_ReadIpFromCompl(compl,0, idx1);
    SNMP_MGR_ReadIpFromCompl(compl,4, idx2);

    if (DHCP_PMGR_GetDhcpServerExcludedIpAddrTable(idx1, idx2)!=DHCP_MGR_OK)
    {
        return FALSE;
    }
    else
    {
        return TRUE;

    } /*End of if */
}

static BOOL_T dhcpServerExcludedIpAddrTable_next(int   compc,
                                 oid     *compl,
                                 UI32_T  *idx1,
                                 UI32_T  *idx2)
{
    oid tmp_compl[dhcpServerExcludedIpAddrEntry_INSTANCE_LEN];

    /* Generate the instance of each table entry and find the
     * smallest instance that's larger than compc/compl.
     *
     * Step 1: Verify and extract the input key from "compc" and "compl"
     * Note: The number of input key is defined by "compc".
     *       The key for the specified instance is defined in compl.
     */
    memcpy(tmp_compl, compl, sizeof(tmp_compl));
    SNMP_MGR_checkCompl(0, 7, tmp_compl,255);
    SNMP_MGR_ConvertRemainToZero(compc,dhcpServerExcludedIpAddrEntry_INSTANCE_LEN, tmp_compl);

    SNMP_MGR_ReadIpFromCompl(tmp_compl,0,idx1);
    SNMP_MGR_ReadIpFromCompl(tmp_compl,4,idx2);

    if (compc<dhcpServerExcludedIpAddrEntry_INSTANCE_LEN)
    {
        if (DHCP_PMGR_GetDhcpServerExcludedIpAddrTable(idx1, idx2)!=DHCP_MGR_OK)
        {
            if (DHCP_PMGR_GetNextExcludedIp(idx1,idx2)!=DHCP_MGR_OK)
            {
                return FALSE;
            }
        }
    }
    else
    {
        if (DHCP_PMGR_GetNextExcludedIp(idx1, idx2)!=DHCP_MGR_OK)
        {
            return FALSE;
        }
    }
    return TRUE;
}


/*
 * var_dhcpServerExcludedIpAddrTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_dhcpServerExcludedIpAddrTable(struct variable *vp,
                                  oid * name,
                                  size_t * length,
                                  int exact,
                                  size_t * var_len,
                                  WriteMethod ** write_method)
{
    UI32_T compc=0;
    oid compl[dhcpServerExcludedIpAddrEntry_INSTANCE_LEN];
    oid best_inst[dhcpServerExcludedIpAddrEntry_INSTANCE_LEN];
    UI32_T  idx1, idx2;

    switch (vp->magic)
    {
        case DHCPSERVEREXCLUDEDIPADDRSTATUS:
            *write_method = write_dhcpServerExcludedIpAddrStatus;
            break;
        default:
            *write_method =0;
            break;
    }

    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,compl, dhcpServerExcludedIpAddrEntry_INSTANCE_LEN);

     /*check compc, retrive compl*/
    if (exact)/*get,set*/
    {
        if (!dhcpServerExcludedIpAddrTable_get(compc, compl, &idx1, &idx2))
            return NULL;
    }
    else/*getnext*/
    {
        if (!dhcpServerExcludedIpAddrTable_next(compc, compl,&idx1, &idx2))
        {
            return NULL;
        }
    }
    memcpy(name, vp->name, vp->namelen*sizeof(oid));
    SNMP_MGR_BindIpInstance(idx1,0,best_inst);
    SNMP_MGR_BindIpInstance(idx2,4,best_inst);
    memcpy(name + vp->namelen, best_inst, dhcpServerExcludedIpAddrEntry_INSTANCE_LEN*sizeof(oid));
    *length = vp->namelen +dhcpServerExcludedIpAddrEntry_INSTANCE_LEN;

    *var_len = sizeof(long_return);

    /*
     * * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
      case DHCPSERVEREXCLUDEDIPADDRLOWIP:
        *var_len = sizeof(ipaddr_return);
        ipaddr_return  = idx1;
        return (u_char*) &ipaddr_return;
      case DHCPSERVEREXCLUDEDIPADDRHIIP:
        *var_len = sizeof(ipaddr_return);
        ipaddr_return  = idx2;
        return (u_char*) &ipaddr_return;
    #endif
      case DHCPSERVEREXCLUDEDIPADDRSTATUS:
        long_return  = VAL_dhcpServerExcludedIpAddrStatus_valid;
        return (u_char*) &long_return;
    default:
        ERROR_MSG("");
    }
    return NULL;
}


int
write_dhcpServerExcludedIpAddrStatus(int action,
                                     u_char * var_val,
                                     u_char var_val_type,
                                     size_t var_val_len,
                                     u_char * statP,
                                     oid * name, size_t name_len)
{
    long value;
    UI32_T index,index2;

    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 7;

      /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  8 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    SNMP_MGR_ReadIpFromCompl(name, oid_name_length,  &index);
    SNMP_MGR_ReadIpFromCompl(name, oid_name_length+4,  &index2);
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          value = *(long *)var_val;
          if ((value <VAL_dhcpServerExcludedIpAddrStatus_valid) || (value >VAL_dhcpServerExcludedIpAddrStatus_invalid))
             return SNMP_ERR_WRONGVALUE;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
        {
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */

              value = * (long *) var_val;
              if (value == VAL_dhcpServerExcludedIpAddrStatus_valid)
              {
                  if (DHCP_PMGR_SetExcludedIp(index, index2) !=DHCP_MGR_OK)
                  {
                     return SNMP_ERR_COMMITFAILED;
                  }
              }
              else if (value == VAL_dhcpServerExcludedIpAddrStatus_invalid)
              {
                  if (DHCP_PMGR_DelExcludedIp(index, index2) !=DHCP_MGR_OK)
                  {
                     return SNMP_ERR_COMMITFAILED;
                  }
              }
              else
              {
                  return SNMP_ERR_COMMITFAILED;
              }

         }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

/********************************************
 ***********dhcpServerLeaseBindingTable******
 ********************************************
 */
/* dhcpServerLeaseBindingTable*/
#define dhcpServerLeaseBindingEntry_INSTANCE_LEN 4
static BOOL_T dhcpServerLeaseBindingTable_get(int      compc,
                                oid     *compl,
                                UI32_T  *idx1,
                                DHCP_MGR_Server_Lease_Config_T *data)
{

    if (compc !=dhcpServerLeaseBindingEntry_INSTANCE_LEN)
    {
        return FALSE;
    }

    SNMP_MGR_ReadIpFromCompl(compl,0, idx1);

    if (DHCP_PMGR_GetIpBinding(*idx1, data)!=DHCP_MGR_OK)
    {
        return FALSE;
    }
    else
    {
        return TRUE;

    } /*End of if */
}

static BOOL_T dhcpServerLeaseBindingTable_next(int   compc,
                                 oid     *compl,
                                 UI32_T  *idx1,
                                 DHCP_MGR_Server_Lease_Config_T  *data)
{
    oid tmp_compl[dhcpServerLeaseBindingEntry_INSTANCE_LEN];

    /* Generate the instance of each table entry and find the
     * smallest instance that's larger than compc/compl.
     *
     * Step 1: Verify and extract the input key from "compc" and "compl"
     * Note: The number of input key is defined by "compc".
     *       The key for the specified instance is defined in compl.
     */
    memcpy(tmp_compl, compl, sizeof(tmp_compl));
    SNMP_MGR_checkCompl(0, 3, tmp_compl,255);
    SNMP_MGR_ConvertRemainToZero(compc,dhcpServerLeaseBindingEntry_INSTANCE_LEN, tmp_compl);

    SNMP_MGR_ReadIpFromCompl(tmp_compl,0,idx1);

    if (compc<dhcpServerLeaseBindingEntry_INSTANCE_LEN)
    {
        if (DHCP_PMGR_GetIpBinding(*idx1, data)!=DHCP_MGR_OK)
        {
            if (DHCP_PMGR_GetNextIpBinding(*idx1,data)!=DHCP_MGR_OK)
            {
                return FALSE;
            }
        }
    }
    else
    {
        if (DHCP_PMGR_GetNextIpBinding(*idx1, data)!=DHCP_MGR_OK)
        {
            return FALSE;
        }
    }
    return TRUE;
}


/*
 * var_dhcpServerLeaseBindingTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_dhcpServerLeaseBindingTable(struct variable *vp,
                                oid * name,
                                size_t * length,
                                int exact,
                                size_t * var_len,
                                WriteMethod ** write_method)
{
    UI32_T compc=0;
    oid compl[dhcpServerLeaseBindingEntry_INSTANCE_LEN];
    oid best_inst[dhcpServerLeaseBindingEntry_INSTANCE_LEN];
    UI32_T  index1;
    DHCP_MGR_Server_Lease_Config_T data;

    switch(vp->magic) {
    case DHCPSERVERLEASEBINDINGSTATUS:
        *write_method = write_dhcpServerLeaseBindingStatus;
        break;
    default:
        *write_method = 0;
        break;
    }

    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,compl, dhcpServerLeaseBindingEntry_INSTANCE_LEN);

     /*check compc, retrive compl*/
    if (exact)/*get,set*/
    {
        if (!dhcpServerLeaseBindingTable_get(compc, compl, &index1, &data))
            return NULL;
    }
    else/*getnext*/
    {
        if (!dhcpServerLeaseBindingTable_next(compc, compl,&index1, &data))
        {
            return NULL;
        }
    }
    memcpy(name, vp->name, vp->namelen*sizeof(oid));
    SNMP_MGR_BindIpInstance(data.lease_ip,0,best_inst);
    memcpy(name + vp->namelen, best_inst, dhcpServerLeaseBindingEntry_INSTANCE_LEN*sizeof(oid));
    *length = vp->namelen +dhcpServerLeaseBindingEntry_INSTANCE_LEN;

    *var_len = sizeof(long_return);

    /*
     * * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
      case DHCPSERVERLEASEBINDINGIP:
        *var_len = sizeof(ipaddr_return);
        ipaddr_return  = idx1;
        return (u_char*) &ipaddr_return;
    #endif
      case DHCPSERVERLEASEBINDINGMAC:
        memcpy(return_buf, data.hardware_address, SIZE_dhcpServerLeaseBindingMac);
        *var_len = SIZE_dhcpServerLeaseBindingMac;
        return (u_char*) return_buf;
      case DHCPSERVERLEASEBINDINGLEASETIME:
        long_return = data.lease_time;
        return (u_char *) & long_return;
      case DHCPSERVERLEASEBINDINGSTARTTIME:
        SYS_TIME_ConvertTime(data.start_time, return_buf);
        *var_len = strlen((char *)return_buf);
        return (u_char *) return_buf;
      case DHCPSERVERLEASEBINDINGSTATUS:
        long_return = VAL_dhcpServerLeaseBindingStatus_valid;
        return (u_char *) & long_return;
    default:
        ERROR_MSG("");
    }
    return NULL;
}


int
write_dhcpServerLeaseBindingStatus(int action,
                                   u_char * var_val,
                                   u_char var_val_type,
                                   size_t var_val_len,
                                   u_char * statP,
                                   oid * name, size_t name_len)
{
    long value;
    UI32_T index;

    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 7;

      /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  4 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    SNMP_MGR_ReadIpFromCompl(name, oid_name_length,  &index);
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          value = *(long *)var_val;
          /* only can perform delete operation*/
          if ((value <VAL_dhcpServerLeaseBindingStatus_valid) || (value >VAL_dhcpServerLeaseBindingStatus_invalid))
             return SNMP_ERR_WRONGVALUE;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
        {
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */

              value = * (long *) var_val;
              if (value == VAL_dhcpServerExcludedIpAddrStatus_valid)
              {
                    /* valid can not perform*/
                     return SNMP_ERR_COMMITFAILED;

              }
              else if (value == VAL_dhcpServerLeaseBindingStatus_invalid)
              {
                  if (DHCP_PMGR_ClearIpBinding(index)!=DHCP_MGR_OK)
                  {
                     return SNMP_ERR_COMMITFAILED;
                  }
              }
              else
              {
                  return SNMP_ERR_COMMITFAILED;
              }

         }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
#else

#if (SYS_CPNT_DHCP_SERVER == TRUE)
/********************************************
 **************dhcpServerMgt*****************
 ********************************************
 */
int
do_dhcpServerServiceStatus(netsnmp_mib_handler *handler,
                               netsnmp_handler_registration *reginfo,
                               netsnmp_agent_request_info   *reqinfo,
                               netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
        {
            if(DHCP_PMGR_GetDhcpServerServiceStatus())
            {
                long_return = VAL_dhcpServerServiceStatus_enabled;
            }
            else
            {
                long_return = VAL_dhcpServerServiceStatus_disabled;
            }
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *)&long_return, sizeof(long_return));
        }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
        {
            UI32_T value;

            UI8_T  type;
            type = requests->requestvb->type;

            if(type != ASN_INTEGER)
                return SNMP_ERR_WRONGTYPE;

            value = (*requests->requestvb->val.integer);
            if((value < VAL_dhcpServerServiceStatus_enabled) || (value > VAL_dhcpServerServiceStatus_disabled))
                return SNMP_ERR_WRONGVALUE;
        }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */

            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
        {
            UI32_T value;
            value = (*requests->requestvb->val.integer);

            if(value == VAL_dhcpServerServiceStatus_enabled)
            {
                if(DHCP_PMGR_CheckRestartObj(DHCP_MGR_RESTART_SERVER) != DHCP_MGR_OK)
                    return SNMP_ERR_GENERR;

                DHCP_PMGR_Restart3(DHCP_MGR_RESTART_SERVER);
            }
            else if(value == VAL_dhcpServerServiceStatus_disabled)
            {
                if(DHCP_PMGR_RemoveSystemRole(DHCP_MGR_BIND_SERVER) == DHCP_MGR_OK)
                {
                    DHCP_PMGR_Restart3(DHCP_MGR_RESTART_CLIENT);
                }
                else
                {
                    return SNMP_ERR_GENERR;
                }
            }

        }
        break;


        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */

            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */

            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

/********************************************
 **************dhcpPoolTable*****************
 ********************************************
 */
/* dhcpPoolTable*/
#define dhcpPoolEntry_INSTANCE_LEN 9
static BOOL_T dhcpPoolTable_get(int                        compc,
                                oid                        *compl,
                                UI8_T                      *buffer,
                                DHCP_TYPE_PoolConfigEntry_T *data)
{

    if((compc <= 0) || (compc > dhcpPoolEntry_INSTANCE_LEN) || (compc != compl[0] + 1))
    {
        if(SNMP_MGR_IsDebugMode())
            SYSFUN_Debug_Printf("dhcpPoolTable_get:compc err, compc=[%d], compl[0]=[%lu]\n",compc, compl[0]);
        return FALSE;
    }

    SNMP_MGR_ReadStrFromCompl(compl, 1, compl[0], buffer);
    if(SNMP_MGR_IsDebugMode())
        SYSFUN_Debug_Printf("dhcpPoolTable_get: buffer=[%s]\n", buffer);

    if(DHCP_PMGR_GetDhcpPoolTable((char *)buffer, data) != DHCP_MGR_OK)
    {
        if(SNMP_MGR_IsDebugMode())
            SYSFUN_Debug_Printf("dhcpPoolTable_get:DHCP_MGR_GetDhcpPoolTable return !=DHCP_MGR_OK\n");
        return FALSE;
    }
    else
    {
    return TRUE;

    } /*End of if */
}

static BOOL_T dhcpPoolTable_next(int                        compc,
                                 oid                        *compl,
                                 UI8_T                      *buffer,
                                 DHCP_TYPE_PoolConfigEntry_T *data)
{

    /* Generate the instance of each table entry and find the
     * smallest instance that's larger than compc/compl.
     *
     * Step 1: Verify and extract the input key from "compc" and "compl"
     * Note: The number of input key is defined by "compc".
     *       The key for the specified instance is defined in compl.
     */

    if(compc > dhcpPoolEntry_INSTANCE_LEN)
    {
        if(SNMP_MGR_IsDebugMode())
            SYSFUN_Debug_Printf("dhcpPoolTable_next:compc err, compc = [%d]\n", compc);
        return FALSE;
    }
    else if(compc == 0)
    {
        /* If input key is not given, assign a default vaule to the input key.
        * Note: 1. The default value for an input key for "get next" shall be a value
        *          less than the first/smallest vaule defined by the input key type.
        *       2. Since compl is a byte array, for a given key, it may use multiple
        *          bytes to represent its key value! Byte/half-word swap may be required
        *          for Little-Endian type CPU.
        */
        buffer[0] = 0;
    }
    else if(compc == (compl[0] + 1))
    {
        /* The key for the specified instance is defined in compl.
        * Since compl is a byte array, for a givn key, it may use multiple bytes to represent its key value!
        * It shall be carefully when extract the key value from the compl. Byte/half-word swap may be required
        * for Little-Endian type CPU
        */
        SNMP_MGR_ReadStrFromCompl(compl, 1, compl[0], buffer);
    }
    else
    {
        return FALSE;
    }
    if(SNMP_MGR_IsDebugMode())
        SYSFUN_Debug_Printf("dhcpPoolTable_next:buffer=[%s]\n", buffer);

    if(DHCP_PMGR_GetNextDhcpPoolTable((char*)buffer, data) != DHCP_MGR_OK)
    {
        return FALSE;
    }
    else
    {
        if(SNMP_MGR_IsDebugMode())
            SYSFUN_Debug_Printf("dhcpPoolTable_next:DHCP_MGR_GetNextDhcpPoolTable return != DHCP_MGR_OK\n");
        return TRUE;
    }

}


/*
 * var_dhcpPoolInetTable():
 * Handle this table separately from the scalar value case.
 * The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_dhcpPoolInetTable(struct variable *vp,
                                 oid             *name,
                                 size_t          *length,
                  int exact, size_t * var_len, WriteMethod ** write_method)
{
    UI32_T compc = 0;
    oid compl[dhcpPoolEntry_INSTANCE_LEN];
    oid best_inst[dhcpPoolEntry_INSTANCE_LEN];
    DHCP_TYPE_PoolConfigEntry_T data;
    char buffer[SYS_ADPT_DHCP_MAX_POOL_NAME_LEN + 1];

    /*Since this table allow for entry that does not exist, (creation). we need to know the write method first*/
    switch(vp->magic)
    {
        case DHCPPOOLINETPOOLTYPE:
            *write_method = write_dhcpPoolInetPoolType;
            break;
        case DHCPPOOLINETADDRESSTYPE:
            *write_method = write_dhcpPoolInetAddressType;
            break;
        case DHCPPOOLINETADDRESS:
            *write_method = write_dhcpPoolInetAddress;
            break;
        case DHCPPOOLINETSUBNETMASKTYPE:
            *write_method = write_dhcpPoolInetSubnetMaskType;
            break;
        case DHCPPOOLINETSUBNETMASK:
            *write_method = write_dhcpPoolInetSubnetMask;
            break;
        case DHCPPOOLINETHARDWARETYPE:
            *write_method = write_dhcpPoolInetHardwareType;
            break;
        case DHCPPOOLINETMACADDRESS:
            *write_method = write_dhcpPoolInetMacAddress;
            break;
        case DHCPPOOLINETSTATUS:
            *write_method = write_dhcpPoolInetstatus;
            break;
        default:
            *write_method = 0;
            break;
    }


    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,compl, dhcpPoolEntry_INSTANCE_LEN);

     /*check compc, retrive compl*/
    if(exact)  /* get, set */
    {
        if(!dhcpPoolTable_get(compc, compl, (UI8_T *)buffer, &data))
            return NULL;
    }
    else  /* getnext */
    {
        if(!dhcpPoolTable_next(compc, compl, (UI8_T *)buffer, &data))
        {
            return NULL;
        }
    }
    if(SNMP_MGR_IsDebugMode())
        SYSFUN_Debug_Printf("var_dhcpPoolInetTable:buffer=[%s]\n", buffer);

    memcpy(name, vp->name, vp->namelen * sizeof(oid));
    best_inst[0] = strlen(buffer);
    SNMP_MGR_BindStrInstance(buffer, 1, best_inst);
    memcpy(name + vp->namelen, best_inst, (best_inst[0] + 1) * sizeof(oid));
    *length = vp->namelen + best_inst[0] + 1;

    *var_len = sizeof(long_return);

    /*
     * * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case DHCPPOOLINETPOOLNAME:
            strcpy(return_buf, buffer);
            *var_len = strlen(return_buf);
            return (u_char*)return_buf;
#endif
        case DHCPPOOLINETPOOLTYPE:
            long_return = data.pool_type;
            return (u_char*) &long_return;
        case DHCPPOOLINETADDRESSTYPE:
            long_return = 1;
            return (u_char*) &long_return;
        case DHCPPOOLINETADDRESS:
            if(data.pool_type == VAL_dhcpPoolPoolType_netWork)
            {
                long_return = data.network_address;
            }
            else if(data.pool_type == VAL_dhcpPoolPoolType_host)
            {
                long_return = data.host_address;
            }
            else
            {
                long_return = 0;
            }
            return (u_char*) &long_return;
        case DHCPPOOLINETSUBNETMASKTYPE:
            long_return = 1;
            return (u_char*) &long_return;
        case DHCPPOOLINETSUBNETMASK:
            long_return = data.sub_netmask;
            return (u_char*) &long_return;
        case DHCPPOOLINETHARDWARETYPE:
            switch(data.hardware_address.htype)
            {
                case DHCP_MGR_HTYPE_NONE:
                    long_return = VAL_dhcpPoolHardwareType_notSpecify;
                    break;
                case DHCP_MGR_HTYPE_ETHER:
                    long_return = VAL_dhcpPoolHardwareType_ethernet;
                    break;
                case DHCP_MGR_HTYPE_IEEE802:
                    long_return = VAL_dhcpPoolHardwareType_ieee802;
                    break;
                case DHCP_MGR_HTYPE_FDDI:
                    long_return = VAL_dhcpPoolHardwareType_fddi;
                    break;
            }
            return (u_char*)&long_return;
        case DHCPPOOLINETMACADDRESS:
            memcpy(return_buf, data.hardware_address.haddr, SIZE_dhcpPoolMacAddress);
            *var_len = SIZE_dhcpPoolMacAddress;
            return (u_char*) return_buf;
        case DHCPPOOLINETSTATUS:
            long_return = VAL_dhcpPoolstatus_valid;
            return (u_char*) &long_return;
        default:
            ERROR_MSG("");
    }
    return NULL;
}


int
write_dhcpPoolInetPoolType(int action,
                           u_char    *var_val,
                           u_char    var_val_type,
                           size_t    var_val_len,
                       u_char * statP, oid * name, size_t name_len)
{
    long value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 7;
    char  buffer_index[SYS_ADPT_DHCP_MAX_POOL_NAME_LEN + 1];

   /* check 2: name[oid_name_length] = the length of the name, check if these exceed the max size*/
    if(name[oid_name_length] > SYS_ADPT_DHCP_MAX_POOL_NAME_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    /* check 3: check if the input index is exactly match, if not return fail*/
    if(name_len != name[oid_name_length] + 1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    SNMP_MGR_ReadStrFromCompl(name, oid_name_length + 1, name_len - 1, (UI8_T *)buffer_index);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
                return SNMP_ERR_WRONGTYPE;
            }
          if (var_val_len > sizeof(long)) {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;

        case RESERVE2:
            value = *(long *)var_val;
            if((value < VAL_dhcpPoolPoolType_notSpecify) || (value > VAL_dhcpPoolPoolType_host))
                return SNMP_ERR_WRONGVALUE;
            break;

        case FREE:
             /* Release any resources that have been allocated */
            break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */

        {
            UI32_T value;

            value = * (long *) var_val;

            if(DHCP_PMGR_SetDhcpPoolPoolType(buffer_index, value) != DHCP_MGR_OK)
                return SNMP_ERR_COMMITFAILED;
        }
            break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
            break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_dhcpPoolInetAddressType(int      action,
                            u_char   *var_val,
                            u_char   var_val_type,
                            size_t   var_val_len,
                            u_char   *statP,
                            oid      *name,
                            size_t   name_len)
{
     long value;
     UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 7;
     char  buffer_index[SYS_ADPT_DHCP_MAX_POOL_NAME_LEN + 1];

    /* check 2: name[oid_name_length] = the length of the name, check if these exceed the max size*/
     if(name[oid_name_length] > SYS_ADPT_DHCP_MAX_POOL_NAME_LEN)
     {
         return SNMP_ERR_WRONGLENGTH;
     }

     /* check 3: check if the input index is exactly match, if not return fail*/
     if(name_len != name[oid_name_length] + 1 + oid_name_length)
     {
         return SNMP_ERR_WRONGLENGTH;
     }

     SNMP_MGR_ReadStrFromCompl(name, oid_name_length + 1, name_len - 1, (UI8_T *)buffer_index);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          value = *(long *)var_val;
          if(value != 1)
            return SNMP_ERR_WRONGVALUE;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dhcpPoolInetAddress(int action,
                              u_char    *var_val,
                              u_char    var_val_type,
                              size_t    var_val_len,
                          u_char * statP, oid * name, size_t name_len)
{
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 7;
    UI8_T buffer_index[SYS_ADPT_DHCP_MAX_POOL_NAME_LEN + 1];

   /* check 2: name[oid_name_length] = the length of the name, check if these exceed the max size*/
    if(name[oid_name_length] > SYS_ADPT_DHCP_MAX_POOL_NAME_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    /* check 3: check if the input index is exactly match, if not return fail*/
    if(name_len != name[oid_name_length] + 1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    SNMP_MGR_ReadStrFromCompl(name, oid_name_length + 1, name_len - 1, buffer_index);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR)
          {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len != SYS_TYPE_IPV4_ADDR_LEN)
          {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
            break;

        case FREE:
             /* Release any resources that have been allocated */
            break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
        {
            UI32_T value;

            memcpy(&value, var_val, var_val_len);

            if(DHCP_PMGR_SetDhcpPoolPoolAddress((char *)buffer_index, value) != DHCP_MGR_OK)
                return SNMP_ERR_COMMITFAILED;
        }
            break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
            break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dhcpPoolInetSubnetMaskType(int      action,
                                u_char   *var_val,
                                u_char   var_val_type,
                                size_t   var_val_len,
                                u_char   *statP,
                                oid      *name,
                                size_t   name_len)
{
     long value;
     UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 7;
     char  buffer_index[SYS_ADPT_DHCP_MAX_POOL_NAME_LEN + 1];

    /* check 2: name[oid_name_length] = the length of the name, check if these exceed the max size*/
     if(name[oid_name_length] > SYS_ADPT_DHCP_MAX_POOL_NAME_LEN)
     {
         return SNMP_ERR_WRONGLENGTH;
     }

     /* check 3: check if the input index is exactly match, if not return fail*/
     if(name_len != name[oid_name_length] + 1 + oid_name_length)
     {
         return SNMP_ERR_WRONGLENGTH;
     }

     SNMP_MGR_ReadStrFromCompl(name, oid_name_length + 1, name_len - 1, (UI8_T *)buffer_index);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          value = *(long *)var_val;
          if(value != 1)
            return SNMP_ERR_WRONGVALUE;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dhcpPoolInetSubnetMask(int action,
                             u_char    *var_val,
                             u_char    var_val_type,
                             size_t    var_val_len,
                         u_char * statP, oid * name, size_t name_len)
{
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 7;
    UI8_T buffer_index[SYS_ADPT_DHCP_MAX_POOL_NAME_LEN + 1];

   /* check 2: name[oid_name_length] = the length of the name, check if these exceed the max size*/
    if(name[oid_name_length] > SYS_ADPT_DHCP_MAX_POOL_NAME_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    /* check 3: check if the input index is exactly match, if not return fail*/
    if(name_len != name[oid_name_length] + 1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    SNMP_MGR_ReadStrFromCompl(name, oid_name_length + 1, name_len - 1, buffer_index);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR)
          {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len != SYS_TYPE_IPV4_ADDR_LEN)
          {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
            break;
        case FREE:
             /* Release any resources that have been allocated */
            break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */

        {
            UI32_T value;

            memcpy(&value, var_val, var_val_len);

            if(DHCP_PMGR_SetDhcpPoolSubnetMask((char *)buffer_index, value) != DHCP_MGR_OK)
                return SNMP_ERR_COMMITFAILED;
        }
            break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
            break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dhcpPoolInetHardwareType(int action,
                               u_char    *var_val,
                               u_char    var_val_type,
                               size_t    var_val_len,
                           u_char * statP, oid * name, size_t name_len)
{
    long value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 7;
    UI8_T buffer_index[SYS_ADPT_DHCP_MAX_POOL_NAME_LEN + 1];

   /* check 2: name[oid_name_length] = the length of the name, check if these exceed the max size*/
    if(name[oid_name_length] > SYS_ADPT_DHCP_MAX_POOL_NAME_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    /* check 3: check if the input index is exactly match, if not return fail*/
    if(name_len != name[oid_name_length] + 1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    SNMP_MGR_ReadStrFromCompl(name, oid_name_length + 1, name_len - 1, buffer_index);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
                return SNMP_ERR_WRONGTYPE;
            }
          if (var_val_len > sizeof(long)) {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;

        case RESERVE2:
            value = *(long *)var_val;
            if((value < VAL_dhcpPoolHardwareType_notSpecify) || (value > VAL_dhcpPoolHardwareType_fddi))
                return SNMP_ERR_WRONGVALUE;
            break;

        case FREE:
             /* Release any resources that have been allocated */
            break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */

        {
            UI32_T value;

            value = *(long *)var_val;
            switch(value)
            {
                case VAL_dhcpPoolHardwareType_notSpecify:
                    value = DHCP_MGR_HTYPE_NONE;
                    break;
                case VAL_dhcpPoolHardwareType_ethernet:
                    value = DHCP_MGR_HTYPE_ETHER;
                    break;
                case VAL_dhcpPoolHardwareType_ieee802:
                    value = DHCP_MGR_HTYPE_IEEE802;
                    break;
                case VAL_dhcpPoolHardwareType_fddi:
                    value = DHCP_MGR_HTYPE_FDDI;
                    break;
                default:
                    break;
            }
            if(DHCP_PMGR_SetMacTypeToPoolConfigEntry((char *)buffer_index, value) != DHCP_MGR_OK)
                return SNMP_ERR_COMMITFAILED;
        }
            break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
            break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dhcpPoolInetMacAddress(int action,
                             u_char    *var_val,
                             u_char    var_val_type,
                             size_t    var_val_len,
                         u_char * statP, oid * name, size_t name_len)
{

    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 7;
    UI8_T buffer_index[SYS_ADPT_DHCP_MAX_POOL_NAME_LEN + 1];

   /* check 2: name[oid_name_length] = the length of the name, check if these exceed the max size*/
    if(name[oid_name_length] > SYS_ADPT_DHCP_MAX_POOL_NAME_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    /* check 3: check if the input index is exactly match, if not return fail*/
    if(name_len != name[oid_name_length] + 1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    SNMP_MGR_ReadStrFromCompl(name, oid_name_length + 1, name_len - 1, buffer_index);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
                return SNMP_ERR_WRONGTYPE;
            }
          if (var_val_len > SIZE_dhcpPoolMacAddress*sizeof(UI8_T)) {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;

        case RESERVE2:

            break;

        case FREE:
             /* Release any resources that have been allocated */
            break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */

        {
            UI8_T buffer[SIZE_dhcpPoolMacAddress];

            memcpy(buffer, var_val, var_val_len);
            if(DHCP_PMGR_SetMacToPoolConfigEntry((char *)buffer_index, buffer) != DHCP_MGR_OK)
                return SNMP_ERR_COMMITFAILED;
        }
            break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
            break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dhcpPoolInetstatus(int action,
                         u_char    *var_val,
                         u_char    var_val_type,
                         size_t    var_val_len,
                     u_char * statP, oid * name, size_t name_len)
{
    long value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 7;
    UI8_T buffer_index[SYS_ADPT_DHCP_MAX_POOL_NAME_LEN + 1];

   /* check 2: name[oid_name_length] = the length of the name, check if these exceed the max size*/
    if(name[oid_name_length] > SYS_ADPT_DHCP_MAX_POOL_NAME_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    /* check 3: check if the input index is exactly match, if not return fail*/
    if(name_len != name[oid_name_length] + 1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    SNMP_MGR_ReadStrFromCompl(name, oid_name_length + 1, name_len - 1, buffer_index);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
                return SNMP_ERR_WRONGTYPE;
            }
          if (var_val_len > sizeof(long)) {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;

        case RESERVE2:
            value = *(long *)var_val;
            if((value < VAL_dhcpPoolstatus_valid) || (value > VAL_dhcpPoolstatus_invalid))
                return SNMP_ERR_WRONGVALUE;
            break;

        case FREE:
             /* Release any resources that have been allocated */
            break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */

        {
            UI32_T  value;

            value = *(long *)var_val;

            if(DHCP_PMGR_SetDhcpPoolStatus((char *)buffer_index, value) != DHCP_MGR_OK)
                return SNMP_ERR_COMMITFAILED;
        }
            break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
            break;
    }
    return SNMP_ERR_NOERROR;
}

/********************************************
 ***********dhcpPoolOptionTable**************
 ********************************************
 */
/* dhcpPoolOptionTable*/
#define dhcpPoolOptionEntry_INSTANCE_LEN 9
static BOOL_T dhcpPoolOptionTable_get(int                      compc,
                                      oid                      *compl,
                                      UI8_T                    *buffer,
                                      DHCP_TYPE_ServerOptions_T *data)
{

    if((compc <= 0) || (compc > dhcpPoolOptionEntry_INSTANCE_LEN) || (compc != compl[0] + 1))
    {
        return FALSE;
    }

    SNMP_MGR_ReadStrFromCompl(compl, 1, compl[0], buffer);


    if(DHCP_PMGR_GetDhcpPoolOptionTable((char *)buffer, data) != DHCP_MGR_OK)
    {
        return FALSE;
    }
    else
    {
    return TRUE;

    } /*End of if */
}

static BOOL_T dhcpPoolOptionTable_next(int                      compc,
                                       oid                      *compl,
                                       UI8_T                    *buffer,
                                       DHCP_TYPE_ServerOptions_T *data)
{
    oid tmp_compl[dhcpPoolOptionEntry_INSTANCE_LEN];

    /* Generate the instance of each table entry and find the
     * smallest instance that's larger than compc/compl.
     *
     * Step 1: Verify and extract the input key from "compc" and "compl"
     * Note: The number of input key is defined by "compc".
     *       The key for the specified instance is defined in compl.
     */
    memcpy(tmp_compl, compl, sizeof(tmp_compl));

    if(compc > dhcpPoolOptionEntry_INSTANCE_LEN)
    {
        return FALSE;
    }
    else if(compc == 0)
    {
        /* If input key is not given, assign a default vaule to the input key.
        * Note: 1. The default value for an input key for "get next" shall be a value
        *          less than the first/smallest vaule defined by the input key type.
        *       2. Since compl is a byte array, for a given key, it may use multiple
        *          bytes to represent its key value! Byte/half-word swap may be required
        *          for Little-Endian type CPU.
        */
        buffer[0] = 0;
    }
    else if(compc == (compl[0] + 1))
    {
        /* The key for the specified instance is defined in compl.
        * Since compl is a byte array, for a givn key, it may use multiple bytes to represent its key value!
        * It shall be carefully when extract the key value from the compl. Byte/half-word swap may be required
        * for Little-Endian type CPU
        */
        SNMP_MGR_ReadStrFromCompl(compl,1,compl[0],buffer);
    }
    else
    {
        return FALSE;
    }

    if(DHCP_PMGR_GetNextDhcpPoolOptionTable((char *)buffer, data) != DHCP_MGR_OK)
    {
        return FALSE;
    }
    else
    {
        return TRUE;
    }

}


/*
 * var_dhcpPoolInetOptionTable():
 * Handle this table separately from the scalar value case.
 * The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_dhcpPoolInetOptionTable(struct variable *vp,
                                       oid             *name,
                                       size_t          *length,
                                       int             exact,
                        size_t * var_len, WriteMethod ** write_method)
{
    UI32_T compc = 0;
    oid compl[dhcpPoolOptionEntry_INSTANCE_LEN];
    oid best_inst[dhcpPoolOptionEntry_INSTANCE_LEN];
    DHCP_TYPE_ServerOptions_T data;
    char  buffer[SYS_ADPT_DHCP_MAX_POOL_NAME_LEN + 1];

    /* Since this table allow for entry that does not exist, (creation). we need to know the write method first */
    switch(vp->magic)
    {
        case DHCPPOOLINETOPTIONNEXTSERVERTYPE:
            *write_method = write_dhcpPoolInetOptionNextServerType;
            break;
        case DHCPPOOLINETOPTIONNEXTSERVER:
            *write_method = write_dhcpPoolInetOptionNextServer;
            break;
        case DHCPPOOLINETOPTIONNETBIOSNODETYPE:
            *write_method = write_dhcpPoolInetOptionNetbiosNodeType;
            break;
        case DHCPPOOLINETOPTIONDOMAINNAME:
            *write_method = write_dhcpPoolInetOptionDomainName;
            break;
        case DHCPPOOLINETOPTIONBOOTFILE:
            *write_method = write_dhcpPoolInetOptionBootFile;
            break;
        case DHCPPOOLINETOPTIONLEASETIME:
            *write_method = write_dhcpPoolInetOptionLeaseTime;
            break;
        case DHCPPOOLINETOPTIONCIDMODE:
            *write_method = write_dhcpPoolInetOptionCidMode;
            break;
        case DHCPPOOLINETOPTIONCIDBUFFER:
            *write_method = write_dhcpPoolInetOptionCidBuffer;
            break;
        default:
            *write_method = 0;
            break;
    }


    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl, dhcpPoolOptionEntry_INSTANCE_LEN);

     /*check compc, retrive compl*/
    if(exact)  /* get, set */
    {
        if(!dhcpPoolOptionTable_get(compc, compl, (UI8_T *)buffer, &data))
            return NULL;
    }
    else  /* getnext */
    {
        if(!dhcpPoolOptionTable_next(compc, compl, (UI8_T *)buffer, &data))
        {
            return NULL;
        }
    }
    memcpy(name, vp->name, vp->namelen * sizeof(oid));
    best_inst[0] = strlen(buffer);
    SNMP_MGR_BindStrInstance(buffer, 1, best_inst);
    memcpy(name + vp->namelen, best_inst, (best_inst[0] + 1) * sizeof(oid));
    *length = vp->namelen + best_inst[0] + 1;

    *var_len = sizeof(long_return);

    /*
     * * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case DHCPPOOLINETOPTIONPOOLNAME:
            strcpy(return_buf, buffer);
            *var_len = strlen(return_buf);
            return (u_char*) return_buf;
#endif
        case DHCPPOOLINETOPTIONNEXTSERVERTYPE:
            long_return = 1;
            return (u_char*) &long_return;
        case DHCPPOOLINETOPTIONNEXTSERVER:
            long_return = data.next_server;
            return (u_char*) &long_return;
        case DHCPPOOLINETOPTIONNETBIOSNODETYPE:
            switch(data.netbios_node_type)
            {
                case DHCP_MGR_NETBIOS_NODE_TYPE_NONE:
                    long_return = VAL_dhcpPoolOptionNetbiosNodeType_none;
                    break;
                case DHCP_MGR_NETBIOS_NODE_TYPE_B_NODE:
                    long_return = VAL_dhcpPoolOptionNetbiosNodeType_b_node;
                    break;
                case DHCP_MGR_NETBIOS_NODE_TYPE_P_NODE:
                    long_return = VAL_dhcpPoolOptionNetbiosNodeType_p_node;
                    break;
                case DHCP_MGR_NETBIOS_NODE_TYPE_M_NODE:
                    long_return = VAL_dhcpPoolOptionNetbiosNodeType_m_node;
                    break;
                case DHCP_MGR_NETBIOS_NODE_TYPE_H_NODE:
                    long_return = VAL_dhcpPoolOptionNetbiosNodeType_h_node;
                    break;
                default:
                    break;
            }
            return (u_char*)&long_return;
        case DHCPPOOLINETOPTIONDOMAINNAME:
            strcpy((char *)return_buf, data.domain_name);
            *var_len = strlen((char *)return_buf);
            return (u_char*) return_buf;
        case DHCPPOOLINETOPTIONBOOTFILE:
            strcpy((char *)return_buf, data.bootfile);
            *var_len = strlen((char *)return_buf);
            return (u_char*) return_buf;
        case DHCPPOOLINETOPTIONLEASETIME:
            long_return = data.lease_time;
            return (u_char*) &long_return;
        case DHCPPOOLINETOPTIONCIDMODE:
            long_return = data.cid.id_mode;
            return (u_char*) &long_return;
        case DHCPPOOLINETOPTIONCIDBUFFER:
            memcpy(return_buf, data.cid.id_buf, data.cid.id_len);
            *var_len = data.cid.id_len;
            return (u_char*) return_buf;
        default:
            ERROR_MSG("");
    }
    return NULL;
}

int
write_dhcpPoolInetOptionNextServerType(int      action,
                            u_char   *var_val,
                            u_char   var_val_type,
                            size_t   var_val_len,
                            u_char   *statP,
                            oid      *name,
                            size_t   name_len)
{
     long value;
     UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 7;
     UI8_T buffer_index[SYS_ADPT_DHCP_MAX_POOL_NAME_LEN + 1];

    /* check 2: name[oid_name_length] = the length of the name, check if these exceed the max size*/
     if(name[oid_name_length] > SYS_ADPT_DHCP_MAX_POOL_NAME_LEN)
     {
         return SNMP_ERR_WRONGLENGTH;
     }

     /* check 3: check if the input index is exactly match, if not return fail*/
     if(name_len != name[oid_name_length] + 1 + oid_name_length)
     {
         return SNMP_ERR_WRONGLENGTH;
     }

     SNMP_MGR_ReadStrFromCompl(name, oid_name_length + 1, name_len - 1, buffer_index);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          value = *(long *)var_val;
          if(value != 1)
              return SNMP_ERR_WRONGVALUE;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dhcpPoolInetOptionNextServer(int action,
                                   u_char    *var_val,
                                   u_char    var_val_type,
                                   size_t    var_val_len,
                               u_char * statP, oid * name, size_t name_len)
{
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 7;
    UI8_T buffer_index[SYS_ADPT_DHCP_MAX_POOL_NAME_LEN + 1];

   /* check 2: name[oid_name_length] = the length of the name, check if these exceed the max size*/
    if(name[oid_name_length] > SYS_ADPT_DHCP_MAX_POOL_NAME_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    /* check 3: check if the input index is exactly match, if not return fail*/
    if(name_len != name[oid_name_length] + 1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    SNMP_MGR_ReadStrFromCompl(name, oid_name_length + 1, name_len - 1, buffer_index);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR)
          {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len != SYS_TYPE_IPV4_ADDR_LEN)
          {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
            break;

        case FREE:
             /* Release any resources that have been allocated */
            break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */

        {
            UI32_T value;

            memcpy(&value, var_val, var_val_len);

            if(DHCP_PMGR_SetNextServerToPoolConfigEntry((char *)buffer_index, value) != DHCP_MGR_OK)
                return SNMP_ERR_COMMITFAILED;
        }
            break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
            break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dhcpPoolInetOptionNetbiosNodeType(int action,
                                        u_char    *var_val,
                                        u_char    var_val_type,
                                        size_t    var_val_len,
                                        u_char    *statP,
                                    oid * name, size_t name_len)
{
    long value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 7;
    UI8_T buffer_index[SYS_ADPT_DHCP_MAX_POOL_NAME_LEN + 1];

   /* check 2: name[oid_name_length] = the length of the name, check if these exceed the max size*/
    if(name[oid_name_length] > SYS_ADPT_DHCP_MAX_POOL_NAME_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    /* check 3: check if the input index is exactly match, if not return fail*/
    if(name_len != name[oid_name_length] + 1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    SNMP_MGR_ReadStrFromCompl(name, oid_name_length + 1, name_len - 1, buffer_index);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
                return SNMP_ERR_WRONGTYPE;
            }
          if (var_val_len > sizeof(long)) {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;

        case RESERVE2:
            value = *(long *)var_val;
            if((value < VAL_dhcpPoolOptionNetbiosNodeType_none) || (value > VAL_dhcpPoolOptionNetbiosNodeType_h_node))
                return SNMP_ERR_WRONGVALUE;
            break;

        case FREE:
             /* Release any resources that have been allocated */
            break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */

        {
            UI32_T value;

            value = *(long *)var_val;

            if(DHCP_PMGR_SetNetbiosNodeTypeToPoolConfigEntry((char *)buffer_index, value) != DHCP_MGR_OK)
                return SNMP_ERR_COMMITFAILED;
        }
            break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
            break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dhcpPoolInetOptionDomainName(int action,
                                   u_char    *var_val,
                                   u_char    var_val_type,
                                   size_t    var_val_len,
                               u_char * statP, oid * name, size_t name_len)
{

    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 7;
    UI8_T buffer_index[SYS_ADPT_DHCP_MAX_POOL_NAME_LEN + 1];

   /* check 2: name[oid_name_length] = the length of the name, check if these exceed the max size*/
    if(name[oid_name_length] > SYS_ADPT_DHCP_MAX_POOL_NAME_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    /* check 3: check if the input index is exactly match, if not return fail*/
    if(name_len != name[oid_name_length] + 1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    SNMP_MGR_ReadStrFromCompl(name, oid_name_length + 1, name_len - 1, buffer_index);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
                return SNMP_ERR_WRONGTYPE;
            }
          if (var_val_len >MAXSIZE_dhcpPoolOptionDomainName) {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;

        case RESERVE2:

            break;

        case FREE:
             /* Release any resources that have been allocated */
            break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */

        {
            char buffer[MAXSIZE_dhcpPoolOptionDomainName + 1];

            memcpy(buffer, var_val, var_val_len);
            buffer[var_val_len] = '\0';
            if(!L_STDLIB_StrIsAsciiPrintWithCount(buffer, var_val_len))
            {
                return SNMP_ERR_COMMITFAILED;
            }
            if(DHCP_PMGR_SetDomainNameToPoolConfigEntry((char *)buffer_index, buffer) != DHCP_MGR_OK)
                return SNMP_ERR_COMMITFAILED;
        }
            break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
            break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dhcpPoolInetOptionBootFile(int action,
                                 u_char    *var_val,
                                 u_char    var_val_type,
                                 size_t    var_val_len,
                             u_char * statP, oid * name, size_t name_len)
{

    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 7;
    UI8_T buffer_index[SYS_ADPT_DHCP_MAX_POOL_NAME_LEN + 1];

   /* check 2: name[oid_name_length] = the length of the name, check if these exceed the max size*/
    if(name[oid_name_length] > SYS_ADPT_DHCP_MAX_POOL_NAME_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    /* check 3: check if the input index is exactly match, if not return fail*/
    if(name_len != name[oid_name_length] + 1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    SNMP_MGR_ReadStrFromCompl(name, oid_name_length + 1, name_len - 1, buffer_index);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
                return SNMP_ERR_WRONGTYPE;
            }
          if (var_val_len >MAXSIZE_dhcpPoolOptionBootFile) {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;

        case RESERVE2:

            break;

        case FREE:
             /* Release any resources that have been allocated */
            break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */

        {
            char buffer[MAXSIZE_dhcpPoolOptionBootFile + 1];

            memcpy(buffer, var_val, var_val_len);
            buffer[var_val_len] = '\0';
            if(!L_STDLIB_StrIsAsciiPrintWithCount(buffer, var_val_len))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            if(DHCP_PMGR_SetBootfileToPoolConfigEntry((char *)buffer_index, buffer) != DHCP_MGR_OK)
                return SNMP_ERR_COMMITFAILED;
        }
            break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
            break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dhcpPoolInetOptionLeaseTime(int action,
                                  u_char    *var_val,
                                  u_char    var_val_type,
                                  size_t    var_val_len,
                              u_char * statP, oid * name, size_t name_len)
{

    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 7;
    UI8_T buffer_index[SYS_ADPT_DHCP_MAX_POOL_NAME_LEN + 1];

   /* check 2: name[oid_name_length] = the length of the name, check if these exceed the max size */
    if(name[oid_name_length] > SYS_ADPT_DHCP_MAX_POOL_NAME_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    /* check 3: check if the input index is exactly match, if not return fail*/
    if(name_len != name[oid_name_length] + 1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    SNMP_MGR_ReadStrFromCompl(name, oid_name_length + 1, name_len - 1, buffer_index);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
                return SNMP_ERR_WRONGTYPE;
            }
          if (var_val_len >sizeof(long)) {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;

        case RESERVE2:

            break;

        case FREE:
             /* Release any resources that have been allocated */
            break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */

        {
            UI32_T value;

            value = *(long *)var_val;

            if(DHCP_PMGR_SetLeaseTimeToPoolConfigEntry((char *)buffer_index, value, 0) != DHCP_MGR_OK)
                return SNMP_ERR_COMMITFAILED;
        }
            break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
            break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dhcpPoolInetOptionCidMode(int action,
                            u_char * var_val,
                            u_char var_val_type,
                            size_t var_val_len,
                            u_char * statP, oid * name, size_t name_len)
{
    long value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 7;
    UI8_T buffer_index[SYS_ADPT_DHCP_MAX_POOL_NAME_LEN+1];

   /* check 2: name[oid_name_length] = the length of the name, check if these exceed the max size*/
    if (name[oid_name_length] > SYS_ADPT_DHCP_MAX_POOL_NAME_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    /* check 3: check if the input index is exactly match, if not return fail*/
    if (name_len!= name[oid_name_length]+ 1+ oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    SNMP_MGR_ReadStrFromCompl(name,oid_name_length+1, name_len - 1,buffer_index);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len >sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          value = *(long *)var_val;
          if ((value <VAL_dhcpPoolOptionCidMode_text) || (value >VAL_dhcpPoolOptionCidMode_hex))
             return SNMP_ERR_WRONGVALUE;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */

           {
              UI32_T value;

               value = *(long *)var_val;

               if (DHCP_PMGR_SetDhcpPoolOptionCidMode( (char *)buffer_index,  value) != DHCP_MGR_OK)
                 return SNMP_ERR_COMMITFAILED;
           }
            break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dhcpPoolInetOptionCidBuffer(int action,
                              u_char * var_val,
                              u_char var_val_type,
                              size_t var_val_len,
                              u_char * statP, oid * name, size_t name_len)
{
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 7;
    UI8_T buffer_index[SYS_ADPT_DHCP_MAX_POOL_NAME_LEN+1];

   /* check 2: name[oid_name_length] = the length of the name, check if these exceed the max size*/
    if (name[oid_name_length] > MAXSIZE_dhcpPoolOptionCidBuffer)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    /* check 3: check if the input index is exactly match, if not return fail*/
    if (name_len!= name[oid_name_length]+ 1+ oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    SNMP_MGR_ReadStrFromCompl(name,oid_name_length+1, name_len - 1,buffer_index);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len >MAXSIZE_dhcpPoolOptionCidBuffer) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */

           {
              char  buffer[MAXSIZE_dhcpPoolOptionCidBuffer+1];

               memcpy(buffer, var_val,var_val_len);
               buffer[var_val_len]='\0';
               if (!L_STDLIB_StrIsAsciiPrintWithCount(buffer, var_val_len))
               {
                    return SNMP_ERR_COMMITFAILED;
               }
               if (DHCP_PMGR_SetDhcpPoolOptionCidBuffer((char *) buffer_index,  buffer) != DHCP_MGR_OK)
                 return SNMP_ERR_COMMITFAILED;
           }
            break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

/********************************************
 ***********dhcpPoolOptionDnsSerTable********
 ********************************************
 */
/* dhcpPoolOptionDnsSerTable*/
#define dhcpPoolOptionDnsSerEntry_INSTANCE_LEN 10
static BOOL_T dhcpPoolOptionDnsSerTable_get(int      compc,
                                oid     *compl,
                                UI8_T   *buffer,
                                UI32_T  *idx1,
                                UI32_T   *value)
{

    if ((compc <= 0)||(compc > dhcpPoolOptionDnsSerEntry_INSTANCE_LEN) || (compc != compl[0] + 2 ))
    {
        return FALSE;
    }

    SNMP_MGR_ReadStrFromCompl(compl,1,compl[0],buffer);
    *idx1=compl[compl[0]+1];

    if (DHCP_PMGR_GetDhcpPoolOptionDnsSerTable((char *)buffer, *idx1, value)!=DHCP_MGR_OK)
    {
        return FALSE;
    }
    else
    {
        return TRUE;

    } /*End of if */
}

static BOOL_T dhcpPoolOptionDnsSerTable_next(int   compc,
                                 oid     *compl,
                                 UI8_T   *buffer,
                                 UI32_T  *index1,
                                 UI32_T  *value)
{
    oid tmp_compl[dhcpPoolOptionDnsSerEntry_INSTANCE_LEN];

    /* Generate the instance of each table entry and find the
     * smallest instance that's larger than compc/compl.
     *
     * Step 1: Verify and extract the input key from "compc" and "compl"
     * Note: The number of input key is defined by "compc".
     *       The key for the specified instance is defined in compl.
     */
    memcpy(tmp_compl, compl, sizeof(tmp_compl));

    if (compc > dhcpPoolOptionDnsSerEntry_INSTANCE_LEN)
    {
        return FALSE;
    }
    else if(compc==0)
    {
        /* If input key is not given, assign a default vaule to the input key.
        * Note: 1. The default value for an input key for "get next" shall be a value
        *          less than the first/smallest vaule defined by the input key type.
        *       2. Since compl is a byte array, for a given key, it may use multiple
        *          bytes to represent its key value! Byte/half-word swap may be required
        *          for Little-Endian type CPU.
        */
        buffer[0]=0;
        *index1 = 0;
    }
    else if(compc==(compl[0] + 2))
    {
        /* The key for the specified instance is defined in compl.
        * Since compl is a byte array, for a givn key, it may use multiple bytes to represent its key value!
        * It shall be carefully when extract the key value from the compl. Byte/half-word swap may be required
        * for Little-Endian type CPU
        */
        SNMP_MGR_ReadStrFromCompl(compl,1,compl[0],buffer);
        *index1=compl[compl[0]+1];
    }
    else
    {
        return FALSE;
    }

    if (DHCP_PMGR_GetNextDhcpPoolOptionDnsSerTable((char *)buffer, index1, value)!=DHCP_MGR_OK)
    {
        return FALSE;
    }
    else
    {
        return TRUE;
    }

}


/*
 * var_dhcpPoolInetOptionDnsSerTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_dhcpPoolInetOptionDnsSerTable(struct variable *vp,
                              oid * name,
                              size_t * length,
                              int exact,
                              size_t * var_len,
                              WriteMethod ** write_method)
{
    UI32_T compc=0;
    oid compl[dhcpPoolOptionDnsSerEntry_INSTANCE_LEN];
    oid best_inst[dhcpPoolOptionDnsSerEntry_INSTANCE_LEN];
    UI32_T  index1;
    UI32_T value;
    char  buffer[SYS_ADPT_DHCP_MAX_POOL_NAME_LEN+1];

    switch (vp->magic)
    {
        case DHCPPOOLINETOPTIONDNSSERIPADDRESSTYPE:
            *write_method = write_dhcpPoolOptionDnsSerIpAddressType;
            break;
        case DHCPPOOLINETOPTIONDNSSERIPADDRESS:
            *write_method = write_dhcpPoolInetOptionDnsSerIpAddress;
            break;
        default:
            *write_method = 0;
            break;
    }

    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,compl, dhcpPoolOptionDnsSerEntry_INSTANCE_LEN);

     /*check compc, retrive compl*/
    if (exact)/*get,set*/
    {
        if (!dhcpPoolOptionDnsSerTable_get(compc, compl, (UI8_T  *)buffer, &index1, &value))
            return NULL;
    }
    else/*getnext*/
    {
        if (!dhcpPoolOptionDnsSerTable_next(compc, compl, (UI8_T *)buffer, &index1, &value))
        {
            return NULL;
        }
    }
    memcpy(name, vp->name, vp->namelen*sizeof(oid));
    best_inst[0] = strlen(buffer);
    SNMP_MGR_BindStrInstance(buffer,1,best_inst);
    best_inst[strlen(buffer)+1]=index1;
    memcpy(name + vp->namelen, best_inst, (best_inst[0]+2)*sizeof(oid));
    *length = vp->namelen +best_inst[0]+2;

    *var_len = sizeof(long_return);

    /*
     * * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
      case DHCPPOOLINETOPTIONDNSSERPOOLNAME:
        strcpy( return_buf, buffer);
        *var_len = strlen(return_buf);
        return (u_char*) return_buf;
      case DHCPPOOLINETOPTIONDNSSERINDEX:
        long_return  = index1;
        return (u_char*) &long_return;
    #endif
    case DHCPPOOLINETOPTIONDNSSERIPADDRESSTYPE:
      long_return  = 1;
      return (u_char*) &long_return;
      case DHCPPOOLINETOPTIONDNSSERIPADDRESS:
        long_return  = value;
        return (u_char*) &long_return;
    default:
        ERROR_MSG("");
    }
    return NULL;
}

int
write_dhcpPoolOptionDnsSerIpAddressType(int      action,
                            u_char   *var_val,
                            u_char   var_val_type,
                            size_t   var_val_len,
                            u_char   *statP,
                            oid      *name,
                            size_t   name_len)
{
     long value;
     UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 7;
     UI8_T buffer_index[SYS_ADPT_DHCP_MAX_POOL_NAME_LEN+1];
     UI32_T index1;

    /* check 2: name[oid_name_length] = the length of the name, check if these exceed the max size*/
     if (name[oid_name_length] > SYS_ADPT_DHCP_MAX_POOL_NAME_LEN)
     {
         return SNMP_ERR_WRONGLENGTH;
     }

     /* check 3: check if the input index is exactly match, if not return fail*/
     if (name_len!= name[oid_name_length]+ 2+ oid_name_length)
     {
         return SNMP_ERR_WRONGLENGTH;
     }

     SNMP_MGR_ReadStrFromCompl(name,oid_name_length+1, name_len - 2,buffer_index);
     index1 = name[oid_name_length+name[oid_name_length]+1];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          value = *(long *)var_val;
          if(value != 1)
              return SNMP_ERR_WRONGVALUE;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dhcpPoolInetOptionDnsSerIpAddress(int action,
                                    u_char * var_val,
                                    u_char var_val_type,
                                    size_t var_val_len,
                                    u_char * statP,
                                    oid * name, size_t name_len)
{
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 7;
    UI8_T buffer_index[SYS_ADPT_DHCP_MAX_POOL_NAME_LEN+1];
    UI32_T index1;

   /* check 2: name[oid_name_length] = the length of the name, check if these exceed the max size*/
    if (name[oid_name_length] > SYS_ADPT_DHCP_MAX_POOL_NAME_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    /* check 3: check if the input index is exactly match, if not return fail*/
    if (name_len!= name[oid_name_length]+ 2+ oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    SNMP_MGR_ReadStrFromCompl(name,oid_name_length+1, name_len - 2,buffer_index);
    index1 = name[oid_name_length+name[oid_name_length]+1];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR)
          {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len != SYS_TYPE_IPV4_ADDR_LEN)
          {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */

           {
              UI32_T  value;

              memcpy(&value, var_val, var_val_len);

               if (DHCP_PMGR_SetDhcpPoolOptionDnsSerIpAddress( (char *)buffer_index, index1, value) != DHCP_MGR_OK)
                 return SNMP_ERR_COMMITFAILED;
           }
            break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

/* dhcpPoolOptDefaultRouterTable*/
#define dhcpPoolOptDefaultRouterEntry_INSTANCE_LEN 10
static BOOL_T dhcpPoolOptDefaultRouterTable_get(int      compc,
                                oid     *compl,
                                UI8_T   *buffer,
                                UI32_T   *idx1,
                                UI32_T   *value)
{

    if ((compc <= 0)||(compc > dhcpPoolOptDefaultRouterEntry_INSTANCE_LEN) || (compc != compl[0] + 2 ))
    {
        return FALSE;
    }

    SNMP_MGR_ReadStrFromCompl(compl,1,compl[0],buffer);
    *idx1=compl[compl[0]+1];

    if (DHCP_PMGR_GetDhcpPoolOptDefaultRouterTable((char *)buffer, *idx1, value)!=DHCP_MGR_OK)
    {
        return FALSE;
    }
    else
    {
        return TRUE;

    } /*End of if */
}

static BOOL_T dhcpPoolOptDefaultRouterTable_next(int   compc,
                                 oid     *compl,
                                 UI8_T   *buffer,
                                 UI32_T  *index1,
                                 UI32_T  *value)
{
    oid tmp_compl[dhcpPoolOptDefaultRouterEntry_INSTANCE_LEN];

    /* Generate the instance of each table entry and find the
     * smallest instance that's larger than compc/compl.
     *
     * Step 1: Verify and extract the input key from "compc" and "compl"
     * Note: The number of input key is defined by "compc".
     *       The key for the specified instance is defined in compl.
     */
    memcpy(tmp_compl, compl, sizeof(tmp_compl));

    if (compc > dhcpPoolOptDefaultRouterEntry_INSTANCE_LEN)
    {
        return FALSE;
    }
    else if(compc==0)
    {
        /* If input key is not given, assign a default vaule to the input key.
        * Note: 1. The default value for an input key for "get next" shall be a value
        *          less than the first/smallest vaule defined by the input key type.
        *       2. Since compl is a byte array, for a given key, it may use multiple
        *          bytes to represent its key value! Byte/half-word swap may be required
        *          for Little-Endian type CPU.
        */
        buffer[0]=0;
        *index1 = 0;
    }
    else if(compc==(compl[0] + 2))
    {
        /* The key for the specified instance is defined in compl.
        * Since compl is a byte array, for a givn key, it may use multiple bytes to represent its key value!
        * It shall be carefully when extract the key value from the compl. Byte/half-word swap may be required
        * for Little-Endian type CPU
        */
        SNMP_MGR_ReadStrFromCompl(compl,1,compl[0],buffer);
        *index1=compl[compl[0]+1];
    }
    else
    {
        return FALSE;
    }

    if (DHCP_PMGR_GetNextDhcpPoolOptDefaultRouterTable((char *)buffer, index1, value)!=DHCP_MGR_OK)
    {
        return FALSE;
    }
    else
    {
        return TRUE;
    }

}

/*
 * var_dhcpPoolOptInetDefaultRouterTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_dhcpPoolOptInetDefaultRouterTable(struct variable *vp,
                                  oid * name,
                                  size_t * length,
                                  int exact,
                                  size_t * var_len,
                                  WriteMethod ** write_method)
{
    UI32_T compc=0;
    oid compl[dhcpPoolOptDefaultRouterEntry_INSTANCE_LEN];
    oid best_inst[dhcpPoolOptDefaultRouterEntry_INSTANCE_LEN];
    UI32_T  index1;
    UI32_T value;
    char buffer[SYS_ADPT_DHCP_MAX_POOL_NAME_LEN+1];

    switch (vp->magic)
    {
        case DHCPPOOLOPTINETDEFAULTROUTERIPADDRESSTYPE:
            *write_method = write_dhcpPoolOptInetDefaultRouterIpAddressType;
            break;
        case DHCPPOOLOPTINETDEFAULTROUTERIPADDRESS:
            *write_method = write_dhcpPoolOptInetDefaultRouterIpAddress;
            break;
        default:
            *write_method = 0;
            break;
    }

    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,compl, dhcpPoolOptDefaultRouterEntry_INSTANCE_LEN);

     /*check compc, retrive compl*/
    if (exact)/*get,set*/
    {
        if (!dhcpPoolOptDefaultRouterTable_get(compc, compl, (UI8_T *)buffer, &index1, &value))
            return NULL;
    }
    else/*getnext*/
    {
        if (!dhcpPoolOptDefaultRouterTable_next(compc, compl, (UI8_T *)buffer, &index1, &value))
        {
            return NULL;
        }
    }
    memcpy(name, vp->name, vp->namelen*sizeof(oid));
    best_inst[0] = strlen(buffer);
    SNMP_MGR_BindStrInstance(buffer,1,best_inst);
    best_inst[strlen(buffer)+1]=index1;
    memcpy(name + vp->namelen, best_inst, (best_inst[0]+2)*sizeof(oid));
    *length = vp->namelen +best_inst[0]+2;

    *var_len = sizeof(long_return);

    /*
     * * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
      case DHCPPOOLOPTINETDEFAULTROUTERPOOLNAME:
        strcpy( return_buf, buffer);
        *var_len = strlen(return_buf);
        return (u_char*) return_buf;
      case DHCPPOOLOPTINETDEFAULTROUTERINDEX:
        long_return  = index1;
        return (u_char*) &long_return;
    #endif
      case DHCPPOOLOPTINETDEFAULTROUTERIPADDRESSTYPE:
        long_return  = 1;
        return (u_char*) &long_return;
      case DHCPPOOLOPTINETDEFAULTROUTERIPADDRESS:
        long_return  = value;
        return (u_char*) &long_return;
    default:
        ERROR_MSG("");
    }
    return NULL;
}

int
write_dhcpPoolOptInetDefaultRouterIpAddressType(int      action,
                                                                u_char   *var_val,
                                                                u_char   var_val_type,
                                                                size_t   var_val_len,
                                                                u_char   *statP,
                                                                oid      *name,
                                                                size_t   name_len)
{
    long value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 7;
    UI8_T buffer_index[SYS_ADPT_DHCP_MAX_POOL_NAME_LEN];
    UI32_T index1;

   /* check 2: name[oid_name_length] = the length of the name, check if these exceed the max size*/
    if (name[oid_name_length] > SYS_ADPT_DHCP_MAX_POOL_NAME_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    /* check 3: check if the input index is exactly match, if not return fail*/
    if (name_len!= name[oid_name_length]+ 2+ oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    SNMP_MGR_ReadStrFromCompl(name,oid_name_length+1, name_len - 2,buffer_index);
    index1 = name[oid_name_length+name[oid_name_length]+1];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          value = *(long *)var_val;
          if(value != 1)
            return SNMP_ERR_WRONGVALUE;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dhcpPoolOptInetDefaultRouterIpAddress(int action,
                                        u_char * var_val,
                                        u_char var_val_type,
                                        size_t var_val_len,
                                        u_char * statP,
                                        oid * name, size_t name_len)
{
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 7;
    UI8_T buffer_index[SYS_ADPT_DHCP_MAX_POOL_NAME_LEN];
    UI32_T index1;

   /* check 2: name[oid_name_length] = the length of the name, check if these exceed the max size*/
    if (name[oid_name_length] > SYS_ADPT_DHCP_MAX_POOL_NAME_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    /* check 3: check if the input index is exactly match, if not return fail*/
    if (name_len!= name[oid_name_length]+ 2+ oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    SNMP_MGR_ReadStrFromCompl(name,oid_name_length+1, name_len - 2,buffer_index);
    index1 = name[oid_name_length+name[oid_name_length]+1];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR)
          {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len  != SYS_TYPE_IPV4_ADDR_LEN)
          {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */

           {
              UI32_T  value;

               memcpy(&value, var_val, var_val_len);

               if (DHCP_PMGR_SetDhcpPoolOptDefaultRouterIpAddress( (char *)buffer_index, index1, value) != DHCP_MGR_OK)
                 return SNMP_ERR_COMMITFAILED;
           }
            break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

/********************************************
 ***********dhcpPoolOptNetbiosServerTable****
 ********************************************
 */
/* dhcpPoolOptDefaultRouterTable*/
#define dhcpPoolOptNetbiosServerEntry_INSTANCE_LEN 10
static BOOL_T dhcpPoolOptNetbiosServerTable_get(int      compc,
                                oid     *compl,
                                UI8_T    *buffer,
                                UI32_T    *idx1,
                                UI32_T   *value)
{

    if ((compc <= 0)||(compc > dhcpPoolOptNetbiosServerEntry_INSTANCE_LEN) || (compc != compl[0] + 2 ))
    {
        return FALSE;
    }

    SNMP_MGR_ReadStrFromCompl(compl,1,compl[0],buffer);
    *idx1=compl[compl[0]+1];

    if (DHCP_PMGR_GetDhcpPoolOptNetbiosServerTable((char *)buffer, *idx1, value)!=DHCP_MGR_OK)
    {
        return FALSE;
    }
    else
    {
        return TRUE;

    } /*End of if */
}

static BOOL_T dhcpPoolOptNetbiosServerTable_next(int   compc,
                                 oid     *compl,
                                 UI8_T   *buffer,
                                 UI32_T  *index1,
                                 UI32_T  *value)
{
    oid tmp_compl[dhcpPoolOptNetbiosServerEntry_INSTANCE_LEN];

    /* Generate the instance of each table entry and find the
     * smallest instance that's larger than compc/compl.
     *
     * Step 1: Verify and extract the input key from "compc" and "compl"
     * Note: The number of input key is defined by "compc".
     *       The key for the specified instance is defined in compl.
     */
    memcpy(tmp_compl, compl, sizeof(tmp_compl));

    if (compc > dhcpPoolOptNetbiosServerEntry_INSTANCE_LEN)
    {
        return FALSE;
    }
    else if(compc==0)
    {
        /* If input key is not given, assign a default vaule to the input key.
        * Note: 1. The default value for an input key for "get next" shall be a value
        *          less than the first/smallest vaule defined by the input key type.
        *       2. Since compl is a byte array, for a given key, it may use multiple
        *          bytes to represent its key value! Byte/half-word swap may be required
        *          for Little-Endian type CPU.
        */
        buffer[0]=0;
        *index1 = 0;
    }
    else if(compc==(compl[0] + 2))
    {
        /* The key for the specified instance is defined in compl.
        * Since compl is a byte array, for a givn key, it may use multiple bytes to represent its key value!
        * It shall be carefully when extract the key value from the compl. Byte/half-word swap may be required
        * for Little-Endian type CPU
        */
        SNMP_MGR_ReadStrFromCompl(compl,1,compl[0],buffer);
        *index1=compl[compl[0]+1];
    }
    else
    {
        return FALSE;
    }

    if (DHCP_PMGR_GetNextDhcpPoolOptNetbiosServerTable((char *)buffer, index1, value)!=DHCP_MGR_OK)
    {
        return FALSE;
    }
    else
    {
        return TRUE;
    }

}


/*
 * var_dhcpPoolOptInetNetbiosServerTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_dhcpPoolOptInetNetbiosServerTable(struct variable *vp,
                                  oid * name,
                                  size_t * length,
                                  int exact,
                                  size_t * var_len,
                                  WriteMethod ** write_method)
{
    UI32_T compc=0;
    oid compl[dhcpPoolOptNetbiosServerEntry_INSTANCE_LEN];
    oid best_inst[dhcpPoolOptNetbiosServerEntry_INSTANCE_LEN];
    UI32_T  index1;
    UI32_T value;
    char buffer[SYS_ADPT_DHCP_MAX_POOL_NAME_LEN+1];

    switch (vp->magic)
    {
        case DHCPPOOLOPTINETNETBIOSSERVERIPADDRESSTYPE:
            *write_method = write_dhcpPoolOptInetNetbiosServerIpAddressType;
            break;
        case DHCPPOOLOPTINETNETBIOSSERVERIPADDRESS:
            *write_method = write_dhcpPoolOptInetNetbiosServerIpAddress;
            break;
        default:
            *write_method = 0;
            break;
    }

    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,compl, dhcpPoolOptNetbiosServerEntry_INSTANCE_LEN);

     /*check compc, retrive compl*/
    if (exact)/*get,set*/
    {
        if (!dhcpPoolOptNetbiosServerTable_get(compc, compl, (UI8_T *)buffer, &index1, &value))
            return NULL;
    }
    else/*getnext*/
    {
        if (!dhcpPoolOptNetbiosServerTable_next(compc, compl, (UI8_T *)buffer, &index1, &value))
        {
            return NULL;
        }
    }
    memcpy(name, vp->name, vp->namelen*sizeof(oid));
    best_inst[0] = strlen(buffer);
    SNMP_MGR_BindStrInstance(buffer,1,best_inst);
    best_inst[strlen(buffer)+1]=index1;
    memcpy(name + vp->namelen, best_inst, (best_inst[0]+2)*sizeof(oid));
    *length = vp->namelen +best_inst[0]+2;

    *var_len = sizeof(long_return);

    /*
     * * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
      case DHCPPOOLOPTINETNETBIOSSERVERPOOLNAME:
        strcpy( return_buf, buffer);
        *var_len = strlen(return_buf);
        return (u_char*) return_buf;
      case DHCPPOOLOPTINETNETBIOSSERVERINDEX:
        long_return  = index1;
        return (u_char*) &long_return;
    #endif
      case DHCPPOOLOPTINETNETBIOSSERVERIPADDRESSTYPE:
        long_return  = 1;
        return (u_char*) &long_return;
      case DHCPPOOLOPTINETNETBIOSSERVERIPADDRESS:
        long_return  = value;
        return (u_char*) &long_return;
    default:
        ERROR_MSG("");
    }
    return NULL;
}

int
write_dhcpPoolOptInetNetbiosServerIpAddressType(int      action,
                                                            u_char   *var_val,
                                                            u_char   var_val_type,
                                                            size_t   var_val_len,
                                                            u_char   *statP,
                                                            oid      *name,
                                                            size_t   name_len)
{
    long value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 7;
    UI8_T buffer_index[SYS_ADPT_DHCP_MAX_POOL_NAME_LEN];
    UI32_T index1;

   /* check 2: name[oid_name_length] = the length of the name, check if these exceed the max size*/
    if (name[oid_name_length] > SYS_ADPT_DHCP_MAX_POOL_NAME_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    /* check 3: check if the input index is exactly match, if not return fail*/
    if (name_len!= name[oid_name_length]+ 2+ oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    SNMP_MGR_ReadStrFromCompl(name,oid_name_length+1, name_len - 2,buffer_index);
    index1 = name[oid_name_length+name[oid_name_length]+1];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          value = *(long *)var_val;
          if(value != 1)
            return SNMP_ERR_WRONGVALUE;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dhcpPoolOptInetNetbiosServerIpAddress(int action,
                                        u_char * var_val,
                                        u_char var_val_type,
                                        size_t var_val_len,
                                        u_char * statP,
                                        oid * name, size_t name_len)
{
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 7;
    UI8_T buffer_index[SYS_ADPT_DHCP_MAX_POOL_NAME_LEN];
    UI32_T index1;

   /* check 2: name[oid_name_length] = the length of the name, check if these exceed the max size*/
    if (name[oid_name_length] > SYS_ADPT_DHCP_MAX_POOL_NAME_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    /* check 3: check if the input index is exactly match, if not return fail*/
    if (name_len!= name[oid_name_length]+ 2+ oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    SNMP_MGR_ReadStrFromCompl(name,oid_name_length+1, name_len - 2,buffer_index);
    index1 = name[oid_name_length+name[oid_name_length]+1];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR)
          {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len  != SYS_TYPE_IPV4_ADDR_LEN)
          {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */

           {
              UI32_T  value;

               memcpy(&value, var_val, var_val_len);

               if (DHCP_PMGR_SetDhcpPoolOptNetbiosServerIpAddress((char *) buffer_index, index1, value) != DHCP_MGR_OK)
                 return SNMP_ERR_COMMITFAILED;
           }
            break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


/********************************************
 ***********dhcpServerExcludedIpAddrTable****
 ********************************************
 */
/* dhcpServerExcludedIpAddrTable*/
#define dhcpServerExcludedIpAddrEntry_INSTANCE_LEN 12
static BOOL_T dhcpServerExcludedIpAddrTable_get(int      compc,
                                oid     *compl,
                                UI32_T *idx1,
                                UI32_T  *idx2)
{

    if (compc !=dhcpServerExcludedIpAddrEntry_INSTANCE_LEN)
    {
        return FALSE;
    }

    SNMP_MGR_ReadIpFromCompl(compl,2, idx1);
    SNMP_MGR_ReadIpFromCompl(compl,2+4+2, idx2);

    if (DHCP_PMGR_GetDhcpServerExcludedIpAddrTable(idx1, idx2)!=DHCP_MGR_OK)
    {
        return FALSE;
    }
    else
    {
        return TRUE;

    } /*End of if */
}

static BOOL_T dhcpServerExcludedIpAddrTable_next(int   compc,
                                 oid     *compl,
                                 UI32_T  *idx1,
                                 UI32_T  *idx2)
{
    oid tmp_compl[dhcpServerExcludedIpAddrEntry_INSTANCE_LEN];

    /* Generate the instance of each table entry and find the
     * smallest instance that's larger than compc/compl.
     *
     * Step 1: Verify and extract the input key from "compc" and "compl"
     * Note: The number of input key is defined by "compc".
     *       The key for the specified instance is defined in compl.
     */
    memcpy(tmp_compl, compl, sizeof(tmp_compl));
    SNMP_MGR_checkCompl(0, 11, tmp_compl,255);
    SNMP_MGR_ConvertRemainToZero(compc,dhcpServerExcludedIpAddrEntry_INSTANCE_LEN, tmp_compl);

    SNMP_MGR_ReadIpFromCompl(tmp_compl,2,idx1);
    SNMP_MGR_ReadIpFromCompl(tmp_compl,2+4+2,idx2);

    if (compc<dhcpServerExcludedIpAddrEntry_INSTANCE_LEN)
    {
        if (DHCP_PMGR_GetDhcpServerExcludedIpAddrTable(idx1, idx2)!=DHCP_MGR_OK)
        {
            if (DHCP_PMGR_GetNextExcludedIp(idx1,idx2)!=DHCP_MGR_OK)
            {
                return FALSE;
            }
        }
    }
    else
    {
        if (DHCP_PMGR_GetNextExcludedIp(idx1, idx2)!=DHCP_MGR_OK)
        {
            return FALSE;
        }
    }
    return TRUE;
}


/*
 * var_dhcpServerExcludedInetAddrTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_dhcpServerExcludedInetAddrTable(struct variable *vp,
                                  oid * name,
                                  size_t * length,
                                  int exact,
                                  size_t * var_len,
                                  WriteMethod ** write_method)
{
    UI32_T compc = 0;
    oid compl[dhcpServerExcludedIpAddrEntry_INSTANCE_LEN];
    oid best_inst[dhcpServerExcludedIpAddrEntry_INSTANCE_LEN];
    UI32_T idx2, idx4;

    /*Since this table allow for entry that does not exist, (creation). we need to know the write method first*/
    switch (vp->magic)
    {
      case DHCPSERVEREXCLUDEDINETADDRSTATUS:
        *write_method = write_dhcpServerExcludedInetAddrStatus;
        break;
      default:
         *write_method =0;
         break;
    }

    if(*length  > ( (vp->namelen) + dhcpServerExcludedIpAddrEntry_INSTANCE_LEN))
        return NULL;

    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,compl, dhcpServerExcludedIpAddrEntry_INSTANCE_LEN);

     /*check compc, retrive compl*/
    if (exact)/*get,set*/
    {
        if (!dhcpServerExcludedIpAddrTable_get(compc, compl, &idx2, &idx4))
            return NULL;
    }
    else/*getnext*/
    {
        if (!dhcpServerExcludedIpAddrTable_next(compc, compl,&idx2, &idx4))
        {
            return NULL;
        }
    }
    memcpy(name, vp->name, vp->namelen*sizeof(oid));
    best_inst[0] = 1;

    best_inst[1] = 4;
    SNMP_MGR_BindIpInstance(idx2,2,best_inst);
    best_inst[6] = 1;

    best_inst[7] = 4;
    SNMP_MGR_BindIpInstance(idx4,8,best_inst);
    memcpy(name + vp->namelen, best_inst, 12*sizeof(oid));
//    *length = vp->namelen + 2 + name[vp->namelen + 1] + 2 + name[vp->namelen + 2 + name[vp->namelen + 1] + 1];
    *length = vp->namelen + 12;

    *var_len = sizeof(long_return);

    /*
     * * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
      case DHCPSERVEREXCLUDEDINETADDRLOWADDRTYPE:
        long_return = 1;
        return (u_char*) &long_return;
      case DHCPSERVEREXCLUDEDINETADDRLOWADDR:
        memcpy(return_buf, &idx2, 4);
        return (u_char*) return_buf;
      case DHCPSERVEREXCLUDEDINETADDRHIGHADDRTYPE:
        long_return = 1;
        return (u_char*) &long_return;
      case DHCPSERVEREXCLUDEDINETADDRHIGHADDR:
        memcpy(return_buf, &idx4, 4);
        return (u_char*) return_buf;
    #endif
      case DHCPSERVEREXCLUDEDINETADDRSTATUS:
        long_return  = VAL_dhcpServerExcludedIpAddrStatus_valid;
        return (u_char*) &long_return;
    default:
        ERROR_MSG("");
    }
    return NULL;
}

int
write_dhcpServerExcludedInetAddrStatus(int action,
                                     u_char * var_val,
                                     u_char var_val_type,
                                     size_t var_val_len,
                                     u_char * statP,
                                     oid * name, size_t name_len)
{
    long value;
    UI32_T index,index2;

    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 7;

    /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  2 + 4 + 2 + 4 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    SNMP_MGR_ReadIpFromCompl(name, oid_name_length+2,  &index);
    SNMP_MGR_ReadIpFromCompl(name, oid_name_length+8,  &index2);
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          value = *(long *)var_val;
          if ((value <VAL_dhcpServerExcludedIpAddrStatus_valid) || (value >VAL_dhcpServerExcludedIpAddrStatus_invalid))
             return SNMP_ERR_WRONGVALUE;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
        {
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */

              value = * (long *) var_val;
              if (value == VAL_dhcpServerExcludedIpAddrStatus_valid)
              {
                  if (DHCP_PMGR_SetExcludedIp(index, index2) !=DHCP_MGR_OK)
                  {
                     return SNMP_ERR_COMMITFAILED;
                  }
              }
              else if (value == VAL_dhcpServerExcludedIpAddrStatus_invalid)
              {
                  if (DHCP_PMGR_DelExcludedIp(index, index2) !=DHCP_MGR_OK)
                  {
                     return SNMP_ERR_COMMITFAILED;
                  }
              }
              else
              {
                  return SNMP_ERR_COMMITFAILED;
              }

         }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

/********************************************
 ***********dhcpServerLeaseBindingTable******
 ********************************************
 */
/* dhcpServerLeaseBindingTable*/
#define dhcpServerLeaseBindingEntry_INSTANCE_LEN 6
static BOOL_T dhcpServerLeaseBindingTable_get(int      compc,
                                oid     *compl,
                                UI32_T  *idx1,
                                DHCP_MGR_Server_Lease_Config_T *data)
{

    if (compc !=dhcpServerLeaseBindingEntry_INSTANCE_LEN)
    {
        return FALSE;
    }

    SNMP_MGR_ReadIpFromCompl(compl,2, idx1);

    if (DHCP_PMGR_GetIpBinding(*idx1, data)!=DHCP_MGR_OK)
    {
        return FALSE;
    }
    else
    {
        return TRUE;

    } /*End of if */
}

static BOOL_T dhcpServerLeaseBindingTable_next(int   compc,
                                 oid     *compl,
                                 UI32_T  *idx1,
                                 DHCP_MGR_Server_Lease_Config_T  *data)
{
    oid tmp_compl[dhcpServerLeaseBindingEntry_INSTANCE_LEN];

    /* Generate the instance of each table entry and find the
     * smallest instance that's larger than compc/compl.
     *
     * Step 1: Verify and extract the input key from "compc" and "compl"
     * Note: The number of input key is defined by "compc".
     *       The key for the specified instance is defined in compl.
     */
    memcpy(tmp_compl, compl, sizeof(tmp_compl));
    SNMP_MGR_checkCompl(0, 5, tmp_compl,255);
    SNMP_MGR_ConvertRemainToZero(compc,dhcpServerLeaseBindingEntry_INSTANCE_LEN, tmp_compl);

    SNMP_MGR_ReadIpFromCompl(tmp_compl,2,idx1);

    if (compc<dhcpServerLeaseBindingEntry_INSTANCE_LEN)
    {
        if (DHCP_PMGR_GetIpBinding(*idx1, data)!=DHCP_MGR_OK)
        {
            if (DHCP_PMGR_GetNextIpBinding(*idx1,data)!=DHCP_MGR_OK)
            {
                return FALSE;
            }
        }
    }
    else
    {
        if (DHCP_PMGR_GetNextIpBinding(*idx1, data)!=DHCP_MGR_OK)
        {
            return FALSE;
        }
    }
    return TRUE;
}


/*
 * var_dhcpServerInetLeaseBindingTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_dhcpServerInetLeaseBindingTable(struct variable *vp,
                                oid * name,
                                size_t * length,
                                int exact,
                                size_t * var_len,
                                WriteMethod ** write_method)
{
    UI32_T compc=0;
    oid compl[dhcpServerLeaseBindingEntry_INSTANCE_LEN];
    oid best_inst[dhcpServerLeaseBindingEntry_INSTANCE_LEN];
    UI32_T  index2;
    DHCP_MGR_Server_Lease_Config_T data;

    switch(vp->magic) {
    case DHCPSERVERINETLEASEBINDINGSTATUS:
        *write_method = write_dhcpServerInetLeaseBindingStatus;
        break;
    default:
        *write_method = 0;
        break;
    }
    if(*length  > ( (vp->namelen) + dhcpServerLeaseBindingEntry_INSTANCE_LEN))
        return NULL;
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,compl, dhcpServerLeaseBindingEntry_INSTANCE_LEN);

     /*check compc, retrive compl*/
    if (exact)/*get,set*/
    {
        if (!dhcpServerLeaseBindingTable_get(compc, compl, &index2, &data))
            return NULL;
    }
    else/*getnext*/
    {
        if (!dhcpServerLeaseBindingTable_next(compc, compl,&index2, &data))
        {
            return NULL;
        }
    }
    memcpy(name, vp->name, vp->namelen*sizeof(oid));
    best_inst[0] = 1;
    best_inst[1] = 4;
    SNMP_MGR_BindIpInstance(data.lease_ip,2,best_inst);
    memcpy(name + vp->namelen, best_inst, dhcpServerLeaseBindingEntry_INSTANCE_LEN*sizeof(oid));
    *length = vp->namelen +dhcpServerLeaseBindingEntry_INSTANCE_LEN;

    *var_len = sizeof(long_return);

    /*
     * * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
      case DHCPSERVERINETLEASEBINDINGADDRTYPE:
        long_return = 1;
        return (u_char*) &long_return;
      case DHCPSERVERINETLEASEBINDINGADDR:
        memcpy(return_buf, &index2, 4);
        return (u_char*) return_buf;
    #endif
      case DHCPSERVERINETLEASEBINDINGMAC:
        memcpy(return_buf, data.hardware_address, SIZE_dhcpServerLeaseBindingMac);
        *var_len = SIZE_dhcpServerLeaseBindingMac;
        return (u_char*) return_buf;
      case DHCPSERVERINETLEASEBINDINGLEASETIME:
        long_return = data.lease_time;
        return (u_char *) & long_return;
      case DHCPSERVERINETLEASEBINDINGSTARTTIME:
        SYS_TIME_ConvertTime(data.start_time, (char *)return_buf);
        *var_len = strlen((char *)return_buf);
        return (u_char *) return_buf;
      case DHCPSERVERINETLEASEBINDINGSTATUS:
        long_return = VAL_dhcpServerLeaseBindingStatus_valid;
        return (u_char *) & long_return;
    default:
        ERROR_MSG("");
    }
    return NULL;
}


int
write_dhcpServerInetLeaseBindingStatus(int action,
                                   u_char * var_val,
                                   u_char var_val_type,
                                   size_t var_val_len,
                                   u_char * statP,
                                   oid * name, size_t name_len)
{
    long value;
    UI32_T index;

    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 7;

      /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  2 + name[oid_name_length + 1]  + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    SNMP_MGR_ReadIpFromCompl(name, oid_name_length+2,  &index);
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          value = *(long *)var_val;
          /* only can perform delete operation*/
          if ((value <VAL_dhcpServerLeaseBindingStatus_valid) || (value >VAL_dhcpServerLeaseBindingStatus_invalid))
             return SNMP_ERR_WRONGVALUE;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
        {
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */

              value = * (long *) var_val;
              if (value == VAL_dhcpServerExcludedIpAddrStatus_valid)
              {
                    /* valid can not perform*/
                     return SNMP_ERR_COMMITFAILED;

              }
              else if (value == VAL_dhcpServerLeaseBindingStatus_invalid)
              {
                  if (DHCP_PMGR_ClearIpBinding(index)!=DHCP_MGR_OK)
                  {
                     return SNMP_ERR_COMMITFAILED;
                  }
              }
              else
              {
                  return SNMP_ERR_COMMITFAILED;
              }

         }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

#endif /* end of #if (SYS_CPNT_DHCP_SERVER == TRUE)*/
#endif


/********************************************
 ***************dhcpRelayOption82************
 ********************************************
 */
#if (SYS_CPNT_DHCP_RELAY_OPTION82 == TRUE)
int
do_dhcpOption82Status(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
           {
               UI32_T dhcpStatus;

               if (DHCP_OM_OK != DHCP_POM_GetDhcpRelayOption82Status(&dhcpStatus))
               {
                    return SNMP_ERR_GENERR;
               }

                long_return = dhcpStatus;

                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
            }

        break;
        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
             {
                UI32_T dhcpStatus;
                dhcpStatus = (*requests->requestvb->val.integer);
                if ((dhcpStatus < VAL_dhcp_Option82_enabled) || (dhcpStatus > VAL_dhcp_Option82_disabled))
                    netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_INCONSISTENTVALUE);
              }

        break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */

            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
        {
            UI32_T dhcpStatus;

            dhcpStatus = *requests->requestvb->val.integer;


            if (DHCP_MGR_OK != DHCP_PMGR_SetOption82Status(dhcpStatus))
               netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
        }

            /* XXX: perform the value change here*/
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */

            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */

            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}

int
do_dhcpOption82Policy(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
   /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
           {
               UI32_T dhcpPolicy;

               if (DHCP_OM_OK != DHCP_POM_GetDhcpRelayOption82Policy(&dhcpPolicy))
               {
                    return SNMP_ERR_GENERR;
               }

                long_return = dhcpPolicy;
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
            }

        break;
        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            {
                UI32_T dhcpPolicy;
                dhcpPolicy = *requests->requestvb->val.integer;
                switch(dhcpPolicy)
                {
                    case VAL_dhcp_Option82_Policy_drop:
                    case VAL_dhcp_Option82_Policy_replace:
                    case VAL_dhcp_Option82_Policy_keep:
                        break;

                    default:
                        return SNMP_ERR_WRONGVALUE;
                }
            }
          break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */

            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            {
                UI32_T dhcpPolicy;
                dhcpPolicy = *requests->requestvb->val.integer;

                if (DHCP_MGR_OK != DHCP_PMGR_SetOption82Policy(dhcpPolicy))
                    netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            }

            /* XXX: perform the value change here*/
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */

            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */

            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}

int do_dhcpOption82RemoteIDMode(netsnmp_mib_handler *handler,
    netsnmp_handler_registration *reginfo,
    netsnmp_agent_request_info *reqinfo,
    netsnmp_request_info *requests)
{
    switch (reqinfo->mode)
    {
        case MODE_GET:
        {
            UI32_T rid_mode = 0;
            if (DHCP_OM_OK != DHCP_POM_GetDhcpRelayOption82RidMode(&rid_mode))
            {
                return SNMP_ERR_GENERR;

            }

            long_return = rid_mode;
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *)&long_return, sizeof(long_return));

            break;
        }

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            if (requests->requestvb->type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case MODE_SET_RESERVE2:
            switch (*requests->requestvb->val.integer)
            {
                case VAL_dhcpOption82RemoteIDMode_mac_address_in_hex:
                case VAL_dhcpOption82RemoteIDMode_mac_address_in_ascii:
                case VAL_dhcpOption82RemoteIDMode_ip_address_in_hex:
                case VAL_dhcpOption82RemoteIDMode_ip_address_in_ascii:
                case VAL_dhcpOption82RemoteIDMode_configured_string:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called.
             */
            break;

        case MODE_SET_ACTION:
        {
            UI32_T  rid_mode;
            rid_mode = *requests->requestvb->val.integer;
            if (DHCP_MGR_OK != DHCP_PMGR_SetOption82RidMode(rid_mode))
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);

            break;
        }

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int do_dhcpOption82RemoteIDString(netsnmp_mib_handler *handler,
    netsnmp_handler_registration *reginfo,
    netsnmp_agent_request_info *reqinfo,
    netsnmp_request_info *requests)
{
    switch (reqinfo->mode)
    {
        case MODE_GET:
        {
            UI32_T var_len = 0;
            UI8_T rid_value[MAXSIZE_dhcpOption82RemoteIDString + 1] = {0};
            if (DHCP_OM_OK != DHCP_POM_GetDhcpRelayOption82RidValue(rid_value))
            {
                return SNMP_ERR_GENERR;
            }

            memcpy(return_buf, rid_value, MAXSIZE_dhcpOption82RemoteIDString + 1);
            var_len = strlen((char *)return_buf);
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, (u_char *)return_buf, var_len);

            break;
        }

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            if (requests->requestvb->type != ASN_OCTET_STR)
            {
                return SNMP_ERR_WRONGTYPE;
            }

            if ((requests->requestvb->val_len < MINSIZE_dhcpOption82RemoteIDString) || (requests->requestvb->val_len > MAXSIZE_dhcpOption82RemoteIDString))
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called.
             */
            break;

        case MODE_SET_ACTION:
        {
            UI8_T dhcpOption82RemoteIDString[MAXSIZE_dhcpOption82RemoteIDString + 1];

            memcpy(dhcpOption82RemoteIDString, requests->requestvb->val.string, requests->requestvb->val_len);
            dhcpOption82RemoteIDString[requests->requestvb->val_len] = '\0';

            if (DHCP_MGR_OK != DHCP_PMGR_SetOption82RidValue(dhcpOption82RemoteIDString))
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            break;
        }

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int do_dhcpOption82EncodeFormat(netsnmp_mib_handler *handler,
    netsnmp_handler_registration *reginfo,
    netsnmp_agent_request_info *reqinfo,
    netsnmp_request_info *requests)
{
    switch (reqinfo->mode)
    {
        case MODE_GET:
        {
            BOOL_T subtype_format=TRUE;

            if (DHCP_OM_OK == DHCP_POM_GetDhcpRelayOption82Format(&subtype_format))
            {
                if(subtype_format)
                    long_return = VAL_dhcpOption82EncodeFormat_extra_subtype_included;
                else
                    long_return = VAL_dhcpOption82EncodeFormat_no_extra_subtype_included;
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *)&long_return, sizeof(long_return));
            }
            else
            {
                return SNMP_ERR_GENERR;
            }

            break;
        }

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            if (requests->requestvb->type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case MODE_SET_RESERVE2:
            switch (*requests->requestvb->val.integer)
            {
                case VAL_dhcpOption82EncodeFormat_extra_subtype_included:
                    break;

                case VAL_dhcpOption82EncodeFormat_no_extra_subtype_included:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called.
             */
            break;

        case MODE_SET_ACTION:
        {
            switch (*requests->requestvb->val.integer)
            {
                case VAL_dhcpOption82EncodeFormat_extra_subtype_included:
                {
                    if(DHCP_MGR_OK != DHCP_PMGR_SetOption82Format(TRUE))
                        return SNMP_ERR_COMMITFAILED;
                }
                break;
                case VAL_dhcpOption82EncodeFormat_no_extra_subtype_included:
                {
                    if(DHCP_MGR_OK != DHCP_PMGR_SetOption82Format(FALSE))
                        return SNMP_ERR_COMMITFAILED;
                }
                break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }

            break;
        }

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}


#define DHCPOPTION82RELAYSERVERADDRENTRY_INSTANCE_LEN  1

BOOL_T dhcpOption82RelayServerAddrTable_OidIndexToData(UI32_T exact, UI32_T compc,
    oid *compl, UI32_T *dhcpOption82RelayServerAddrIndex)
{
    /* get or set
     */
    if (exact)
    {
        /* check the index length
         */
        if (compc != DHCPOPTION82RELAYSERVERADDRENTRY_INSTANCE_LEN)  /* the constant size index */
        {
            return FALSE;
        }
    }

    *dhcpOption82RelayServerAddrIndex = compl[0];

    return TRUE;
}

/*
 * var_dhcpOption82RelayServerAddrTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *var_dhcpOption82RelayServerAddrTable(struct variable *vp,
    oid *name,
    size_t *length,
    int exact,
    size_t *var_len,
    WriteMethod **write_method)
{
    UI32_T compc = 0;
    oid compl[DHCPOPTION82RELAYSERVERADDRENTRY_INSTANCE_LEN] = {0};
    oid best_inst[DHCPOPTION82RELAYSERVERADDRENTRY_INSTANCE_LEN] = {0};

    /* table-specific variables
     */
    UI32_T index=0;
    UI32_T server_ip=0;

    /* dispatch node to set write method
     */
    switch (vp->magic)
    {
        case LEAF_dhcpOption82RelayServerAddrServerIp:
            *write_method = write_dhcpOption82RelayServerAddrServerIp;
            break;

        default:
            *write_method = 0;
            break;
    }

    /* check compc, retrive compl
     */
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl,
        DHCPOPTION82RELAYSERVERADDRENTRY_INSTANCE_LEN);

    /* dispatch get-exact versus get-next
     */
    if (exact)  /* get or set */
    {
        /* extract index
         */
        if (! dhcpOption82RelayServerAddrTable_OidIndexToData(exact, compc, compl,&index))
        {
            return NULL;
        }

        /* get-exact from core layer
         */
        if (DHCP_MGR_OK != DHCP_PMGR_GetRelayServerAddressFromSnmp(index,&server_ip))
        {
            return NULL;
        }
    }
    else  /* get-next */
    {
        /* extract index
         */
        dhcpOption82RelayServerAddrTable_OidIndexToData(exact, compc, compl,&index);

        /* Check the length of inputing index.  If compc is less than the
         * instance length, we should try get {A.B.C.0.0...}, where A.B.C was
         * obtained from the "..._OidIndexToData" function call, and
         * 0.0... was initialized in the beginning of this function.
         * This instance may exist in the core layer.
         */
        if (compc < DHCPOPTION82RELAYSERVERADDRENTRY_INSTANCE_LEN)  /* incomplete index */
        {
            /* get-exact, in case this instance exists
             */

            if (DHCP_MGR_OK != DHCP_PMGR_GetRelayServerAddressFromSnmp(index, &server_ip))
            {
                index++;
                /* get-next according to lexicographic order; if none, fail
                 */

                if (DHCP_MGR_OK != DHCP_PMGR_GetRelayServerAddressFromSnmp(index, &server_ip))
                {
                    return NULL;
                }
            }
        }
        else   /* complete index */
        {
            index++;
            /* get-next according to lexicographic order; if none, fail
             */

            if (DHCP_MGR_OK != DHCP_PMGR_GetRelayServerAddressFromSnmp(index, &server_ip))
            {
                return NULL;
            }
        }
    }

    /* copy base OID (without index) to output
     */
    memcpy(name, vp->name, vp->namelen * sizeof(oid));

    /* assign data to the OID index
     */
    best_inst[0] = index;
    memcpy(name + vp->namelen, best_inst, DHCPOPTION82RELAYSERVERADDRENTRY_INSTANCE_LEN * sizeof(oid));
    *length = vp->namelen + DHCPOPTION82RELAYSERVERADDRENTRY_INSTANCE_LEN;

    /* dispatch node to read value
     */
    switch (vp->magic)
    {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case LEAF_dhcpOption82RelayServerAddrIndex:
            *var_len = sizeof(long_return);
            long_return = index;
            return (u_char *) &long_return;
#endif  /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

        case LEAF_dhcpOption82RelayServerAddrServerIp:
            *var_len = sizeof(long_return);
            long_return = server_ip;
            return (u_char *) &long_return;

        default:
            ERROR_MSG("");
            break;
    }

    /* return failure
     */
    return NULL;
}

int write_dhcpOption82RelayServerAddrServerIp(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    /* dispatch action
     */
    switch (action)
    {
        case RESERVE1:
            /* check type and length
             */
            if (var_val_type != ASN_IPADDRESS)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len !=  SYS_ADPT_IPV4_ADDR_LEN) {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;

        case RESERVE2:
            /* check valid values
             */
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 7;
            UI32_T value = 0;

            /* table-specific variables
             */
            UI32_T dhcpOption82RelayServerAddrIndex = 0;

            /* extract index
             */
            if (! dhcpOption82RelayServerAddrTable_OidIndexToData(TRUE,
                name_len - oid_name_length,
                &(name[oid_name_length]),
                &dhcpOption82RelayServerAddrIndex))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            /* get user value
             */
            memcpy(&value, var_val, var_val_len);

            /* set to core layer
             */

            if (DHCP_MGR_OK != DHCP_PMGR_SetRelayServerAddressFromSnmp(dhcpOption82RelayServerAddrIndex, value))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    /* return success
     */
    return SNMP_ERR_NOERROR;
}

#endif /* end of SYS_CPNT_DHCP_RELAY_OPTION82 */

/*****************************************************
 **************ATC  Storm Control Table***************
 *****************************************************
 */
#if (SYS_CPNT_ATC_STORM == TRUE)

#if (SYS_CPNT_ATC_BSTORM == TRUE)
int
do_atcBcastStormTcApplyTime(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{

    switch(reqinfo->mode) {
        case MODE_GET:
        {
            UI32_T value = 0;

            if (SWCTRL_PMGR_GetATCBroadcastStormTrafficControlOnTimer(&value)==TRUE )
            {
                long_return = value;
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER , (u_char *)&long_return , sizeof(long_return) );
            }
            else
            {
                return SNMP_ERR_GENERR;
            }
        }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:

            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
            }

            break;
        case MODE_SET_RESERVE2:

            if ((*requests->requestvb->val.integer < MIN_atcBcastStormTcApplyTime) || (*requests->requestvb->val.integer > MAX_atcBcastStormTcApplyTime))
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
        {
                        if (SWCTRL_PMGR_SetATCBroadcastStormTrafficControlOnTimer(*requests->requestvb->val.integer)!=TRUE )
            {
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
            }
        }
            break;

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
do_atcBcastStormTcReleaseTime(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{

    switch(reqinfo->mode) {
        case MODE_GET:
        {
            UI32_T value = 0;

            if (SWCTRL_PMGR_GetATCBroadcastStormTrafficControlReleaseTimer(&value)==TRUE )
            {
                long_return = value;
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER , (u_char *)&long_return , sizeof(long_return) );
            }
            else
            {
                return SNMP_ERR_GENERR;
            }
        }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:

            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
            }

            break;
        case MODE_SET_RESERVE2:

            if ((*requests->requestvb->val.integer < MIN_atcBcastStormTcReleaseTime) || (*requests->requestvb->val.integer > MAX_atcBcastStormTcReleaseTime))
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
        {
            if (SWCTRL_PMGR_SetATCBroadcastStormTrafficControlReleaseTimer(*requests->requestvb->val.integer)!=TRUE )
            {
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
            }
        }
            break;

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}


#define ATCBCASTSTORMENTRY_INSTANCE_LEN  1

BOOL_T atcBcastStormTable_OidIndexToData(UI32_T exact, UI32_T compc,
            oid * compl ,  UI32_T *atcBcastStormIfIndex)
{
    /* get or write
     */
    if(exact)
    {

        /* check the index length
         */
        if(compc != ATCBCASTSTORMENTRY_INSTANCE_LEN) /* the constant size index*/
        {
            return FALSE;
        }
    }
    *atcBcastStormIfIndex=compl[0];
    return TRUE;
}

/*
 * var_atcBcastStormTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *
var_atcBcastStormTable(struct variable *vp,
            oid     *name,
            size_t  *length,
            int     exact,
            size_t  *var_len,
            WriteMethod **write_method)
{
    /* variables we may use later */
    UI32_T compc=0;
    oid compl[ATCBCASTSTORMENTRY_INSTANCE_LEN] = {0};
    oid best_inst[ATCBCASTSTORMENTRY_INSTANCE_LEN] = {0};
    SWCTRL_ATCBroadcastStormEntry_T  entry;
    switch(vp->magic)
    {
    case LEAF_atcBcastStormEnable:
        *write_method = write_atcBcastStormEnable;
        break;
    case LEAF_atcBcastStormAutoRelease:
        *write_method = write_atcBcastStormAutoRelease;
        break;
    case LEAF_atcBcastStormControlRelease:
        *write_method = write_atcBcastStormControlRelease;
        break;
    case LEAF_atcBcastStormSampleType:
        *write_method = write_atcBcastStormSampleType;
        break;
    case LEAF_atcBcastStormAlarmFireThreshold:
        *write_method = write_atcBcastStormAlarmFireThreshold;
        break;
    case LEAF_atcBcastStormAlarmClearThreshold:
        *write_method = write_atcBcastStormAlarmClearThreshold;
        break;
    case LEAF_atcBcastStormTcAction:
        *write_method = write_atcBcastStormTcAction;
        break;
    case LEAF_atcBcastStormAlarmFireTrapStatus:
        *write_method = write_atcBcastStormAlarmFireTrapStatus;
        break;
    case LEAF_atcBcastStormAlarmClearTrapStatus:
        *write_method = write_atcBcastStormAlarmClearTrapStatus;
        break;
    case LEAF_atcBcastStormTcApplyTrapStatus:
        *write_method = write_atcBcastStormTcApplyTrapStatus;
        break;
    case LEAF_atcBcastStormTcReleaseTrapStatus:
        *write_method = write_atcBcastStormTcReleaseTrapStatus;
        break;
    default:
        *write_method = 0;
        break;
    }

    /*check compc, retrive compl*/
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,compl, ATCBCASTSTORMENTRY_INSTANCE_LEN);

    memset(&entry, 0, sizeof(entry));

    if (exact)/*get,set*/
    {

        /* get index */
        if(atcBcastStormTable_OidIndexToData(exact,compc,compl, &entry.atc_broadcast_storm_ifindex)==FALSE)
        {
            return NULL;
        }

        /*get data
         */
        if (SWCTRL_PMGR_GetATCBroadcastStormEntry(&entry)!=TRUE)
        {
            return NULL;
        }
    }
    else/*getnext*/
    {

        /*get index*/
        atcBcastStormTable_OidIndexToData(exact,compc,compl, &entry.atc_broadcast_storm_ifindex);
        /* check the length of inputing index,if <1 we should try get {0.0.0.0.0...}
         */
        if (compc< 1)
        {
            /* get data */
            if ( SWCTRL_PMGR_GetATCBroadcastStormEntry(&entry)!=TRUE )
            {

                /*get next data*/
                if ( SWCTRL_PMGR_GetNextATCBroadcastStormEntry(&entry)!=TRUE )
                {
                    return NULL;
                }
            }
        }
        else
        {

            /*get next data*/
            if ( SWCTRL_PMGR_GetNextATCBroadcastStormEntry(&entry)!=TRUE )
            {
                return NULL;
            }
        }
    }

    memcpy(name, vp->name, vp->namelen*sizeof(oid));
    /* assign data to the oid index
     */

    best_inst[0]=entry.atc_broadcast_storm_ifindex;
    memcpy(name+vp->namelen,best_inst,ATCBCASTSTORMENTRY_INSTANCE_LEN*sizeof(oid));
    *length = vp->namelen+ATCBCASTSTORMENTRY_INSTANCE_LEN ;

    /* this is where we do the value assignments for the mib results.
     */
    switch(vp->magic) {

    case LEAF_atcBcastStormIfIndex:
        *var_len = sizeof(long_return);
        long_return = entry.atc_broadcast_storm_ifindex;
        return (u_char *) &long_return;
    case LEAF_atcBcastStormEnable:
        *var_len = sizeof(long_return);
        long_return = entry.atc_broadcast_storm_auto_traffic_control_on;
        return (u_char *) &long_return;
    case LEAF_atcBcastStormAutoRelease:
        *var_len = sizeof(long_return);
        long_return = entry.atc_broadcast_storm_auto_traffic_control_release;
        return (u_char *) &long_return;
    case LEAF_atcBcastStormControlRelease:
        *var_len = sizeof(long_return);
        long_return = entry.atc_broadcast_storm_traffic_control_release;
        return (u_char *) &long_return;
    case LEAF_atcBcastStormSampleType:
        *var_len = sizeof(long_return);
        long_return = entry.atc_broadcast_storm_sample_type;
        return (u_char *) &long_return;
    case LEAF_atcBcastStormCurrentTrafficRate:
        *var_len = sizeof(long_return);
        long_return = entry.atc_broadcast_storm_current_traffic_rate;
        return (u_char *) &long_return;
    case LEAF_atcBcastStormAlarmFireThreshold:
        *var_len = sizeof(long_return);
        long_return = entry.atc_broadcast_storm_storm_alarm_threshold;
        return (u_char *) &long_return;
    case LEAF_atcBcastStormAlarmClearThreshold:
        *var_len = sizeof(long_return);
        long_return = entry.atc_broadcast_storm_storm_clear_threshold;
        return (u_char *) &long_return;
    case LEAF_atcBcastStormTcAction:
        *var_len = sizeof(long_return);
        long_return = entry.atc_broadcast_storm_action;
        return (u_char *) &long_return;
    case LEAF_atcBcastStormAlarmFireTrapStatus:
        *var_len = sizeof(long_return);
        long_return = entry.atc_broadcast_storm_trap_storm_alarm;
        return (u_char *) &long_return;
    case LEAF_atcBcastStormAlarmClearTrapStatus:
        *var_len = sizeof(long_return);
        long_return = entry.atc_broadcast_storm_trap_storm_clear;
        return (u_char *) &long_return;
    case LEAF_atcBcastStormTcApplyTrapStatus:
        *var_len = sizeof(long_return);
        long_return = entry.atc_broadcast_storm_trap_traffic_control_on;
        return (u_char *) &long_return;
    case LEAF_atcBcastStormTcReleaseTrapStatus:
        *var_len = sizeof(long_return);
        long_return = entry.atc_broadcast_storm_trap_traffic_control_release;
        return (u_char *) &long_return;
    default:
      ERROR_MSG("");
    }
    return NULL;
}

int
write_atcBcastStormEnable(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{

    switch ( action ) {

        case RESERVE1:

          if (var_val_type != ASN_INTEGER)
          {
              return SNMP_ERR_WRONGTYPE;
          }
          break;

        case RESERVE2:
            switch ( *(long *)var_val )
            {
                case VAL_atcBcastStormEnable_enabled:
                    break;
                case VAL_atcBcastStormEnable_disabled:
                    break;
                default:
                    return SNMP_ERR_WRONGVALUE;
            }
          break;

        case FREE:
          break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
            I32_T value=0;
            UI32_T atcBcastStormIfIndex = 0;

            if(atcBcastStormTable_OidIndexToData(TRUE,name_len-oid_name_length,&(name[oid_name_length]), &atcBcastStormIfIndex)==FALSE)
                return SNMP_ERR_COMMITFAILED;
            value = *(long *)var_val;
            if(SWCTRL_PMGR_SetATCBroadcastStormAutoTrafficControlOnStatus( atcBcastStormIfIndex, value) != TRUE )
                return SNMP_ERR_COMMITFAILED;
        }
            break;

        case UNDO:
          break;

        case COMMIT:
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_atcBcastStormAutoRelease(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{

    switch ( action ) {

        case RESERVE1:

          if (var_val_type != ASN_INTEGER)
          {
              return SNMP_ERR_WRONGTYPE;
          }
          break;

        case RESERVE2:
            switch ( *(long *)var_val )
            {
                case VAL_atcBcastStormAutoRelease_enabled:
                    break;
                case VAL_atcBcastStormAutoRelease_disabled:
                    break;
                default:
                    return SNMP_ERR_WRONGVALUE;
            }
          break;

        case FREE:
          break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
            I32_T value=0;
            UI32_T atcBcastStormIfIndex = 0;

            if(atcBcastStormTable_OidIndexToData(TRUE,name_len-oid_name_length,&(name[oid_name_length]), &atcBcastStormIfIndex)==FALSE)
                return SNMP_ERR_COMMITFAILED;
            value = *(long *)var_val;
            if(SWCTRL_PMGR_SetATCBroadcastStormAutoTrafficControlReleaseStatus( atcBcastStormIfIndex, value) != TRUE )
                return SNMP_ERR_COMMITFAILED;
        }
            break;

        case UNDO:
          break;

        case COMMIT:
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_atcBcastStormControlRelease(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{

    switch ( action ) {

        case RESERVE1:

          if (var_val_type != ASN_INTEGER)
          {
              return SNMP_ERR_WRONGTYPE;
          }
          break;

        case RESERVE2:
            switch ( *(long *)var_val )
            {
                case VAL_atcBcastStormControlRelease_enabled:
                    break;
                case VAL_atcBcastStormControlRelease_disabled:
                    break;
                default:
                    return SNMP_ERR_WRONGVALUE;
            }
          break;

        case FREE:
          break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
            I32_T value=0;
            UI32_T atcBcastStormIfIndex = 0;

            if(atcBcastStormTable_OidIndexToData(TRUE,name_len-oid_name_length,&(name[oid_name_length]), &atcBcastStormIfIndex)==FALSE)
                return SNMP_ERR_COMMITFAILED;
            value = *(long *)var_val;
            if(SWCTRL_PMGR_SetATCBroadcastStormTrafficControlReleaseStatus( atcBcastStormIfIndex, value) != TRUE )
                return SNMP_ERR_COMMITFAILED;
        }
            break;

        case UNDO:
          break;

        case COMMIT:
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_atcBcastStormSampleType(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{

    switch ( action ) {

        case RESERVE1:

          if (var_val_type != ASN_INTEGER)
          {
              return SNMP_ERR_WRONGTYPE;
          }
          break;

        case RESERVE2:
            switch ( *(long *)var_val )
            {
#if (SYS_CPNT_STORM_SAMPLE_TYPE_PACKET == TRUE)
                case VAL_atcBcastStormSampleType_packet_rate:
                    break;
#endif

#if (SYS_CPNT_STORM_SAMPLE_TYPE_OCTET == TRUE)
                case VAL_atcBcastStormSampleType_octet_rate:
                    break;
#endif

#if (SYS_CPNT_STORM_SAMPLE_TYPE_PERCENT == TRUE)
                case VAL_atcBcastStormSampleType_percent:
                    break;
#endif

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
          break;

        case FREE:
          break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
            I32_T value=0;
            UI32_T atcBcastStormIfIndex = 0;

            if(atcBcastStormTable_OidIndexToData(TRUE,name_len-oid_name_length,&(name[oid_name_length]), &atcBcastStormIfIndex)==FALSE)
                return SNMP_ERR_COMMITFAILED;
            value = *(long *)var_val;
            if(SWCTRL_PMGR_SetATCBroadcastStormSampleType( atcBcastStormIfIndex, value) != TRUE )
                return SNMP_ERR_COMMITFAILED;
        }
            break;

        case UNDO:
          break;

        case COMMIT:
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_atcBcastStormAlarmFireThreshold(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{

    switch ( action )
    {

        case RESERVE1:

          if (var_val_type != ASN_INTEGER)
          {
              return SNMP_ERR_WRONGTYPE;
          }
          break;

        case RESERVE2:
        {
            long value;

            value = * (long *) var_val;

            if ((value < MIN_atcBcastStormAlarmFireThreshold) || (value > MAX_atcBcastStormAlarmFireThreshold))
                return SNMP_ERR_WRONGVALUE;
            break;
        }

        case FREE:
          break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
            I32_T value=0;
            UI32_T atcBcastStormIfIndex = 0;

            if(atcBcastStormTable_OidIndexToData(TRUE,name_len-oid_name_length,&(name[oid_name_length]), &atcBcastStormIfIndex)==FALSE)
                return SNMP_ERR_COMMITFAILED;
            value = *(long *)var_val;
            if(SWCTRL_PMGR_SetATCBroadcastStormStormAlarmThreshold( atcBcastStormIfIndex, value) != TRUE )
                return SNMP_ERR_COMMITFAILED;
        }
            break;

        case UNDO:
          break;

        case COMMIT:
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_atcBcastStormAlarmClearThreshold(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{

    switch ( action ) {

        case RESERVE1:

          if (var_val_type != ASN_INTEGER)
          {
              return SNMP_ERR_WRONGTYPE;
          }
          break;

        case RESERVE2:
        {
            long value;

            value = * (long *) var_val;

            if ((value < MIN_atcBcastStormAlarmClearThreshold) || (value > MAX_atcBcastStormAlarmClearThreshold))
                return SNMP_ERR_WRONGVALUE;
            break;
        }

        case FREE:
          break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
            I32_T value=0;
            UI32_T atcBcastStormIfIndex = 0;

            if(atcBcastStormTable_OidIndexToData(TRUE,name_len-oid_name_length,&(name[oid_name_length]), &atcBcastStormIfIndex)==FALSE)
                return SNMP_ERR_COMMITFAILED;
            value = *(long *)var_val;
            if(SWCTRL_PMGR_SetATCBroadcastStormStormClearThreshold( atcBcastStormIfIndex, value) != TRUE )
                return SNMP_ERR_COMMITFAILED;
        }
            break;

        case UNDO:
          break;

        case COMMIT:
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_atcBcastStormTcAction(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{

    switch ( action ) {

        case RESERVE1:

          if (var_val_type != ASN_INTEGER)
          {
              return SNMP_ERR_WRONGTYPE;
          }
          break;

        case RESERVE2:
            switch ( *(long *)var_val )
            {
                case VAL_atcBcastStormTcAction_rate_control:
                    break;
                case VAL_atcBcastStormTcAction_shutdown:
                    break;
                default:
                    return SNMP_ERR_WRONGVALUE;
            }
          break;

        case FREE:
          break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
            I32_T value=0;
            UI32_T atcBcastStormIfIndex = 0;

            if(atcBcastStormTable_OidIndexToData(TRUE,name_len-oid_name_length,&(name[oid_name_length]), &atcBcastStormIfIndex)==FALSE)
                return SNMP_ERR_COMMITFAILED;
            value = *(long *)var_val;
            if(SWCTRL_PMGR_SetATCBroadcastStormAction( atcBcastStormIfIndex, value) != TRUE )
                return SNMP_ERR_COMMITFAILED;
        }
            break;

        case UNDO:
          break;

        case COMMIT:
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_atcBcastStormAlarmFireTrapStatus(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{

    switch ( action ) {

        case RESERVE1:

          if (var_val_type != ASN_INTEGER)
          {
              return SNMP_ERR_WRONGTYPE;
          }
          break;

        case RESERVE2:
            switch ( *(long *)var_val )
            {
                case VAL_atcBcastStormAlarmFireTrapStatus_enabled:
                    break;
                case VAL_atcBcastStormAlarmFireTrapStatus_disabled:
                    break;
                default:
                    return SNMP_ERR_WRONGVALUE;
            }
          break;

        case FREE:
          break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
            I32_T value=0;
            UI32_T atcBcastStormIfIndex = 0;

            if(atcBcastStormTable_OidIndexToData(TRUE,name_len-oid_name_length,&(name[oid_name_length]), &atcBcastStormIfIndex)==FALSE)
                return SNMP_ERR_COMMITFAILED;
            value = *(long *)var_val;
            if(SWCTRL_PMGR_SetATCBroadcastStormTrapStormAlarmStatus( atcBcastStormIfIndex, value) != TRUE )
                return SNMP_ERR_COMMITFAILED;
        }
            break;

        case UNDO:
          break;

        case COMMIT:
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_atcBcastStormAlarmClearTrapStatus(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{

    switch ( action ) {

        case RESERVE1:

          if (var_val_type != ASN_INTEGER)
          {
              return SNMP_ERR_WRONGTYPE;
          }
          break;

        case RESERVE2:
            switch ( *(long *)var_val )
            {
                case VAL_atcBcastStormAlarmClearTrapStatus_enabled:
                    break;
                case VAL_atcBcastStormAlarmClearTrapStatus_disabled:
                    break;
                default:
                    return SNMP_ERR_WRONGVALUE;
            }
          break;

        case FREE:
          break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
            I32_T value=0;
            UI32_T atcBcastStormIfIndex = 0;

            if(atcBcastStormTable_OidIndexToData(TRUE,name_len-oid_name_length,&(name[oid_name_length]), &atcBcastStormIfIndex)==FALSE)
                return SNMP_ERR_COMMITFAILED;
            value = *(long *)var_val;
            if(SWCTRL_PMGR_SetATCBroadcastStormTrapStormClearStatus( atcBcastStormIfIndex, value) != TRUE )
                return SNMP_ERR_COMMITFAILED;
        }
            break;

        case UNDO:
          break;

        case COMMIT:
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_atcBcastStormTcApplyTrapStatus(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{

    switch ( action ) {

        case RESERVE1:

          if (var_val_type != ASN_INTEGER)
          {
              return SNMP_ERR_WRONGTYPE;
          }
          break;

        case RESERVE2:
            switch ( *(long *)var_val )
            {
                case VAL_atcBcastStormTcApplyTrapStatus_enabled:
                    break;
                case VAL_atcBcastStormTcApplyTrapStatus_disabled:
                    break;
                default:
                    return SNMP_ERR_WRONGVALUE;
            }
          break;

        case FREE:
          break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
            I32_T value=0;
            UI32_T atcBcastStormIfIndex = 0;

            if(atcBcastStormTable_OidIndexToData(TRUE,name_len-oid_name_length,&(name[oid_name_length]), &atcBcastStormIfIndex)==FALSE)
                return SNMP_ERR_COMMITFAILED;
            value = *(long *)var_val;
            if(SWCTRL_PMGR_SetATCBroadcastStormTrapTrafficControlOnStatus( atcBcastStormIfIndex, value) != TRUE )
                return SNMP_ERR_COMMITFAILED;
        }
            break;

        case UNDO:
          break;

        case COMMIT:
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_atcBcastStormTcReleaseTrapStatus(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{

    switch ( action ) {

        case RESERVE1:

          if (var_val_type != ASN_INTEGER)
          {
              return SNMP_ERR_WRONGTYPE;
          }
          break;

        case RESERVE2:
            switch ( *(long *)var_val )
            {
                case VAL_atcBcastStormTcReleaseTrapStatus_enabled:
                    break;
                case VAL_atcBcastStormTcReleaseTrapStatus_disabled:
                    break;
                default:
                    return SNMP_ERR_WRONGVALUE;
            }
          break;

        case FREE:
          break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
            I32_T value=0;
            UI32_T atcBcastStormIfIndex = 0;

            if(atcBcastStormTable_OidIndexToData(TRUE,name_len-oid_name_length,&(name[oid_name_length]), &atcBcastStormIfIndex)==FALSE)
                return SNMP_ERR_COMMITFAILED;
            value = *(long *)var_val;
            if(SWCTRL_PMGR_SetATCBroadcastStormTrapTrafficControlReleaseStatus( atcBcastStormIfIndex, value) != TRUE )
                return SNMP_ERR_COMMITFAILED;
        }
            break;

        case UNDO:
          break;

        case COMMIT:
          break;
    }
    return SNMP_ERR_NOERROR;
}
#endif /* #if (SYS_CPNT_ATC_BSTORM == TRUE) */

#if (SYS_CPNT_ATC_MSTORM == TRUE)
int
do_atcMcastStormTcApplyTime(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    switch(reqinfo->mode) {
        case MODE_GET:
        {
            UI32_T value = 0;
            if (SWCTRL_PMGR_GetATCMulticastStormTrafficControlOnTimer(&value)==TRUE )
            {
                long_return = value;
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER , (u_char *)&long_return , sizeof(long_return) );
            }
            else
            {
                return SNMP_ERR_GENERR;
            }
        }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
            }

            break;
        case MODE_SET_RESERVE2:
            if ((*requests->requestvb->val.integer < MIN_atcMcastStormTcApplyTime) || (*requests->requestvb->val.integer > MAX_atcMcastStormTcApplyTime))
            {
                 return SNMP_ERR_WRONGVALUE;
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
        {
            if (SWCTRL_PMGR_SetATCMulticastStormTrafficControlOnTimer(*requests->requestvb->val.integer)!=TRUE )
            {
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
            }
        }
            break;

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
do_atcMcastStormTcReleaseTime(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{

    switch(reqinfo->mode) {
        case MODE_GET:
        {
            UI32_T value = 0;

            if (SWCTRL_PMGR_GetATCMulticastStormTrafficControlReleaseTimer(&value)==TRUE )
            {
                long_return = value;
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER , (u_char *)&long_return , sizeof(long_return) );
            }
            else
            {
                return SNMP_ERR_GENERR;
            }
        }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:

            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
            }

            break;
        case MODE_SET_RESERVE2:

            if ((*requests->requestvb->val.integer < MIN_atcMcastStormTcReleaseTime) || (*requests->requestvb->val.integer > MAX_atcMcastStormTcReleaseTime))
            {
                 return SNMP_ERR_WRONGVALUE;
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
        {
            if (SWCTRL_PMGR_SetATCMulticastStormTrafficControlReleaseTimer(*requests->requestvb->val.integer)!=TRUE )
            {
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
            }
        }
            break;

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

#define ATCMCASTSTORMENTRY_INSTANCE_LEN  1

BOOL_T atcMcastStormTable_OidIndexToData(UI32_T exact, UI32_T compc,
            oid * compl ,  UI32_T *atcMcastStormIfIndex)
{
    /* get or write
     */
    if(exact)
    {

        /* check the index length
         */
        if(compc != ATCMCASTSTORMENTRY_INSTANCE_LEN) /* the constant size index*/
        {
            return FALSE;
        }
    }
    *atcMcastStormIfIndex=compl[0];
    return TRUE;
}

/*
 * var_atcMcastStormTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *
var_atcMcastStormTable(struct variable *vp,
            oid     *name,
            size_t  *length,
            int     exact,
            size_t  *var_len,
            WriteMethod **write_method)
{
    /* variables we may use later */
    UI32_T compc=0;
    oid compl[ATCMCASTSTORMENTRY_INSTANCE_LEN] = {0};
    oid best_inst[ATCMCASTSTORMENTRY_INSTANCE_LEN] = {0};
    SWCTRL_ATCMulticastStormEntry_T  entry;

    switch(vp->magic)
    {
    case LEAF_atcMcastStormEnable:
        *write_method = write_atcMcastStormEnable;
        break;
    case LEAF_atcMcastStormAutoRelease:
        *write_method = write_atcMcastStormAutoRelease;
        break;
    case LEAF_atcMcastStormControlRelease:
        *write_method = write_atcMcastStormControlRelease;
        break;
    case LEAF_atcMcastStormSampleType:
        *write_method = write_atcMcastStormSampleType;
        break;
    case LEAF_atcMcastStormAlarmFireThreshold:
        *write_method = write_atcMcastStormAlarmFireThreshold;
        break;
    case LEAF_atcMcastStormAlarmClearThreshold:
        *write_method = write_atcMcastStormAlarmClearThreshold;
        break;
    case LEAF_atcMcastStormTcAction:
        *write_method = write_atcMcastStormTcAction;
        break;
    case LEAF_atcMcastStormAlarmFireTrapStatus:
        *write_method = write_atcMcastStormAlarmFireTrapStatus;
        break;
    case LEAF_atcMcastStormAlarmClearTrapStatus:
        *write_method = write_atcMcastStormAlarmClearTrapStatus;
        break;
    case LEAF_atcMcastStormTcApplyTrapStatus:
        *write_method = write_atcMcastStormTcApplyTrapStatus;
        break;
    case LEAF_atcMcastStormTcReleaseTrapStatus:
        *write_method = write_atcMcastStormTcReleaseTrapStatus;
        break;
    default:
        *write_method = 0;
        break;
    }

    /*check compc, retrive compl*/
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,compl, ATCMCASTSTORMENTRY_INSTANCE_LEN);
    memset(&entry, 0, sizeof(entry));
    if (exact)/*get,set*/
    {
        /* get index */
        if(atcMcastStormTable_OidIndexToData(exact,compc,compl, &entry.atc_multicast_storm_ifindex)==FALSE)
        {
            return NULL;
        }

        /*get data
         */
        if (SWCTRL_PMGR_GetATCMulticastStormEntry(&entry)!=TRUE )
        {
            return NULL;
        }
    }
    else/*getnext*/
    {
        /*get index*/
        atcMcastStormTable_OidIndexToData(exact,compc,compl, &entry.atc_multicast_storm_ifindex);
        /* check the length of inputing index,if <1 we should try get {0.0.0.0.0...}
         */
        if (compc< 1)
        {
            /* get data */
            if ( SWCTRL_PMGR_GetATCMulticastStormEntry(&entry)!=TRUE )
            {

                /*get next data*/
                if ( SWCTRL_PMGR_GetNextATCMulticastStormEntry(&entry)!=TRUE )
                {
                    return NULL;
                }
            }
        }
        else
        {
            /*get next data*/
            if ( SWCTRL_PMGR_GetNextATCMulticastStormEntry(&entry)!=TRUE )
            {
                return NULL;
            }
        }
    }

    memcpy(name, vp->name, vp->namelen*sizeof(oid));
    /* assign data to the oid index
     */

    best_inst[0]=entry.atc_multicast_storm_ifindex;
    memcpy(name+vp->namelen,best_inst,ATCMCASTSTORMENTRY_INSTANCE_LEN*sizeof(oid));
    *length = vp->namelen+ATCMCASTSTORMENTRY_INSTANCE_LEN ;

    /* this is where we do the value assignments for the mib results.
     */
    switch(vp->magic) {

    case LEAF_atcMcastStormIfIndex:
        *var_len = sizeof(long_return);
        long_return = entry.atc_multicast_storm_ifindex;
        return (u_char *) &long_return;
    case LEAF_atcMcastStormEnable:
        *var_len = sizeof(long_return);
        long_return = entry.atc_multicast_storm_auto_traffic_control_on;
        return (u_char *) &long_return;
    case LEAF_atcMcastStormAutoRelease:
        *var_len = sizeof(long_return);
        long_return = entry.atc_multicast_storm_auto_traffic_control_release;
        return (u_char *) &long_return;

    case LEAF_atcMcastStormControlRelease:
        *var_len = sizeof(long_return);
        long_return = entry.atc_multicast_storm_traffic_control_release;
        return (u_char *) &long_return;

        case LEAF_atcMcastStormSampleType:
        *var_len = sizeof(long_return);
        long_return = entry.atc_multicast_storm_sample_type;
        return (u_char *) &long_return;
    case LEAF_atcMcastStormCurrentTrafficRate:
        *var_len = sizeof(long_return);
        long_return = entry.atc_multicast_storm_current_traffic_rate;
        return (u_char *) &long_return;
    case LEAF_atcMcastStormAlarmFireThreshold:
        *var_len = sizeof(long_return);
        long_return = entry.atc_multicast_storm_storm_alarm_threshold;
        return (u_char *) &long_return;
    case LEAF_atcMcastStormAlarmClearThreshold:
        *var_len = sizeof(long_return);
        long_return = entry.atc_multicast_storm_storm_clear_threshold;
        return (u_char *) &long_return;
    case LEAF_atcMcastStormTcAction:
        *var_len = sizeof(long_return);
        long_return = entry.atc_multicast_storm_action;
        return (u_char *) &long_return;
    case LEAF_atcMcastStormAlarmFireTrapStatus:
        *var_len = sizeof(long_return);
        long_return = entry.atc_multicast_storm_trap_storm_alarm;
        return (u_char *) &long_return;
    case LEAF_atcMcastStormAlarmClearTrapStatus:
        *var_len = sizeof(long_return);
        long_return = entry.atc_multicast_storm_trap_storm_clear;
        return (u_char *) &long_return;
    case LEAF_atcMcastStormTcApplyTrapStatus:
        *var_len = sizeof(long_return);
        long_return = entry.atc_multicast_storm_trap_traffic_control_on;
        return (u_char *) &long_return;
    case LEAF_atcMcastStormTcReleaseTrapStatus:
        *var_len = sizeof(long_return);
        long_return = entry.atc_multicast_storm_trap_traffic_control_release;
        return (u_char *) &long_return;
    default:
      ERROR_MSG("");
    }
    return NULL;
}

int
write_atcMcastStormEnable(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    switch ( action ) {

        case RESERVE1:

          if (var_val_type != ASN_INTEGER)
          {
              return SNMP_ERR_WRONGTYPE;
          }
          break;

        case RESERVE2:
            switch ( *(long *)var_val )
            {
                case VAL_atcMcastStormEnable_enabled:
                    break;
                case VAL_atcMcastStormEnable_disabled:
                    break;
                default:
                    return SNMP_ERR_WRONGVALUE;
            }
          break;

        case FREE:
          break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
            I32_T value=0;
            UI32_T atcMcastStormIfIndex = 0;

            if(atcMcastStormTable_OidIndexToData(TRUE,name_len-oid_name_length,&(name[oid_name_length]), &atcMcastStormIfIndex)==FALSE)
                return SNMP_ERR_COMMITFAILED;
            value = *(long *)var_val;
            if(SWCTRL_PMGR_SetATCMulticastStormAutoTrafficControlOnStatus( atcMcastStormIfIndex, value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
        }
            break;

        case UNDO:
          break;

        case COMMIT:
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_atcMcastStormAutoRelease(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    switch ( action ) {

        case RESERVE1:

          if (var_val_type != ASN_INTEGER)
          {
              return SNMP_ERR_WRONGTYPE;
          }
          break;

        case RESERVE2:
            switch ( *(long *)var_val )
            {
                case VAL_atcMcastStormAutoRelease_enabled:
                    break;
                case VAL_atcMcastStormAutoRelease_disabled:
                    break;
                default:
                    return SNMP_ERR_WRONGVALUE;
            }
          break;

        case FREE:
          break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
            I32_T value=0;
            UI32_T atcMcastStormIfIndex = 0;

            if(atcMcastStormTable_OidIndexToData(TRUE,name_len-oid_name_length,&(name[oid_name_length]), &atcMcastStormIfIndex)==FALSE)
                return SNMP_ERR_COMMITFAILED;
            value = *(long *)var_val;
            if(SWCTRL_PMGR_SetATCMulticastStormAutoTrafficControlReleaseStatus( atcMcastStormIfIndex, value) != TRUE )
                return SNMP_ERR_COMMITFAILED;
        }
            break;

        case UNDO:
          break;

        case COMMIT:
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_atcMcastStormControlRelease(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    switch ( action ) {

        case RESERVE1:

          if (var_val_type != ASN_INTEGER)
          {
              return SNMP_ERR_WRONGTYPE;
          }
          break;

        case RESERVE2:
            switch ( *(long *)var_val )
            {
                case VAL_atcMcastStormControlRelease_enabled:
                    break;
                case VAL_atcMcastStormControlRelease_disabled:
                    break;
                default:
                    return SNMP_ERR_WRONGVALUE;
            }
          break;

        case FREE:
          break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
            I32_T value=0;
            UI32_T atcMcastStormIfIndex = 0;

            if(atcMcastStormTable_OidIndexToData(TRUE,name_len-oid_name_length,&(name[oid_name_length]), &atcMcastStormIfIndex)==FALSE)
                return SNMP_ERR_COMMITFAILED;
            value = *(long *)var_val;
            if(SWCTRL_PMGR_SetATCMulticastStormTrafficControlReleaseStatus( atcMcastStormIfIndex, value) != TRUE )
                return SNMP_ERR_COMMITFAILED;
        }
            break;

        case UNDO:
          break;

        case COMMIT:
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_atcMcastStormSampleType(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{

    switch ( action ) {

        case RESERVE1:

          if (var_val_type != ASN_INTEGER)
          {
              return SNMP_ERR_WRONGTYPE;
          }
          break;

        case RESERVE2:
            switch ( *(long *)var_val )
            {
#if (SYS_CPNT_STORM_SAMPLE_TYPE_PACKET == TRUE)
                case VAL_atcMcastStormSampleType_packet_rate:
                    break;
#endif

#if (SYS_CPNT_STORM_SAMPLE_TYPE_OCTET == TRUE)
                case VAL_atcMcastStormSampleType_octet_rate:
                    break;
#endif

#if (SYS_CPNT_STORM_SAMPLE_TYPE_PERCENT == TRUE)
                case VAL_atcMcastStormSampleType_percent:
                    break;
#endif

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
          break;

        case FREE:
          break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
            I32_T value=0;
            UI32_T atcMcastStormIfIndex = 0;

            if(atcMcastStormTable_OidIndexToData(TRUE,name_len-oid_name_length,&(name[oid_name_length]), &atcMcastStormIfIndex)==FALSE)
                return SNMP_ERR_COMMITFAILED;
            value = *(long *)var_val;
            if(SWCTRL_PMGR_SetATCMulticastStormSampleType( atcMcastStormIfIndex, value) != TRUE )
                return SNMP_ERR_COMMITFAILED;
        }
            break;

        case UNDO:
          break;

        case COMMIT:
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_atcMcastStormAlarmFireThreshold(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    switch ( action )
    {

        case RESERVE1:

          if (var_val_type != ASN_INTEGER)
          {
              return SNMP_ERR_WRONGTYPE;
          }
          break;

        case RESERVE2:
        {
            long value;

            value = * (long *) var_val;

            if ((value < MIN_atcMcastStormAlarmFireThreshold) || (value > MAX_atcMcastStormAlarmFireThreshold))
                 return SNMP_ERR_WRONGVALUE;
            break;
        }

        case FREE:
          break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
            I32_T value=0;
            UI32_T atcMcastStormIfIndex = 0;

            if(atcMcastStormTable_OidIndexToData(TRUE,name_len-oid_name_length,&(name[oid_name_length]), &atcMcastStormIfIndex)==FALSE)
                return SNMP_ERR_COMMITFAILED;
            value = *(long *)var_val;


            if(SWCTRL_PMGR_SetATCMulticastStormStormAlarmThreshold( atcMcastStormIfIndex, value) != TRUE )
                return SNMP_ERR_COMMITFAILED;
        }
            break;

        case UNDO:
          break;

        case COMMIT:
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_atcMcastStormAlarmClearThreshold(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    switch ( action )
    {

        case RESERVE1:

          if (var_val_type != ASN_INTEGER)
          {
              return SNMP_ERR_WRONGTYPE;
          }
          break;

        case RESERVE2:
        {
            long value;

            value = * (long *) var_val;

            if ((value < MIN_atcMcastStormAlarmClearThreshold) || (value > MAX_atcMcastStormAlarmClearThreshold))
                  return SNMP_ERR_WRONGVALUE;
            break;
        }

        case FREE:
          break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
            I32_T value=0;
            UI32_T atcMcastStormIfIndex = 0;

            if(atcMcastStormTable_OidIndexToData(TRUE,name_len-oid_name_length,&(name[oid_name_length]), &atcMcastStormIfIndex)==FALSE)
                return SNMP_ERR_COMMITFAILED;
            value = *(long *)var_val;
            if(SWCTRL_PMGR_SetATCMulticastStormStormClearThreshold( atcMcastStormIfIndex, value) != TRUE )
                return SNMP_ERR_COMMITFAILED;
        }
            break;

        case UNDO:
          break;

        case COMMIT:
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_atcMcastStormTcAction(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{

    switch ( action ) {

        case RESERVE1:

          if (var_val_type != ASN_INTEGER)
          {
              return SNMP_ERR_WRONGTYPE;
          }
          break;

        case RESERVE2:
            switch ( *(long *)var_val )
            {
                case VAL_atcMcastStormTcAction_rate_control:
                    break;
                case VAL_atcMcastStormTcAction_shutdown:
                    break;
                default:
                    return SNMP_ERR_WRONGVALUE;
            }
          break;

        case FREE:
          break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
            I32_T value=0;
            UI32_T atcMcastStormIfIndex = 0;

            if(atcMcastStormTable_OidIndexToData(TRUE,name_len-oid_name_length,&(name[oid_name_length]), &atcMcastStormIfIndex)==FALSE)
                return SNMP_ERR_COMMITFAILED;
            value = *(long *)var_val;
            if(SWCTRL_PMGR_SetATCMulticastStormAction( atcMcastStormIfIndex, value) != TRUE )
                return SNMP_ERR_COMMITFAILED;
        }
            break;

        case UNDO:
          break;

        case COMMIT:
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_atcMcastStormAlarmFireTrapStatus(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{

    switch ( action ) {

        case RESERVE1:

          if (var_val_type != ASN_INTEGER)
          {
              return SNMP_ERR_WRONGTYPE;
          }
          break;

        case RESERVE2:
            switch ( *(long *)var_val )
            {
                case VAL_atcMcastStormAlarmFireTrapStatus_enabled:
                    break;
                case VAL_atcMcastStormAlarmFireTrapStatus_disabled:
                    break;
                default:
                    return SNMP_ERR_WRONGVALUE;
            }
          break;

        case FREE:
          break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
            I32_T value=0;
            UI32_T atcMcastStormIfIndex = 0;

            if(atcMcastStormTable_OidIndexToData(TRUE,name_len-oid_name_length,&(name[oid_name_length]), &atcMcastStormIfIndex)==FALSE)
                return SNMP_ERR_COMMITFAILED;
            value = *(long *)var_val;
            if(SWCTRL_PMGR_SetATCMulticastStormTrapStormAlarmStatus( atcMcastStormIfIndex, value) != TRUE )
                return SNMP_ERR_COMMITFAILED;
        }
            break;

        case UNDO:
          break;

        case COMMIT:
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_atcMcastStormAlarmClearTrapStatus(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{

    switch ( action ) {

        case RESERVE1:

          if (var_val_type != ASN_INTEGER)
          {
              return SNMP_ERR_WRONGTYPE;
          }
          break;

        case RESERVE2:
            switch ( *(long *)var_val )
            {
                case VAL_atcMcastStormAlarmClearTrapStatus_enabled:
                    break;
                case VAL_atcMcastStormAlarmClearTrapStatus_disabled:
                    break;
                default:
                    return SNMP_ERR_WRONGVALUE;
            }
          break;

        case FREE:
          break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
            I32_T value=0;
            UI32_T atcMcastStormIfIndex = 0;

            if(atcMcastStormTable_OidIndexToData(TRUE,name_len-oid_name_length,&(name[oid_name_length]), &atcMcastStormIfIndex)==FALSE)
                return SNMP_ERR_COMMITFAILED;
            value = *(long *)var_val;
            if(SWCTRL_PMGR_SetATCMulticastStormTrapStormClearStatus( atcMcastStormIfIndex, value) != TRUE )
                return SNMP_ERR_COMMITFAILED;
        }
            break;

        case UNDO:
          break;

        case COMMIT:
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_atcMcastStormTcApplyTrapStatus(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{

    switch ( action ) {

        case RESERVE1:

          if (var_val_type != ASN_INTEGER)
          {
              return SNMP_ERR_WRONGTYPE;
          }
          break;

        case RESERVE2:
            switch ( *(long *)var_val )
            {
                case VAL_atcMcastStormTcApplyTrapStatus_enabled:
                    break;
                case VAL_atcMcastStormTcApplyTrapStatus_disabled:
                    break;
                default:
                    return SNMP_ERR_WRONGVALUE;
            }
          break;

        case FREE:
          break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
            I32_T value=0;
            UI32_T atcMcastStormIfIndex = 0;

            if(atcMcastStormTable_OidIndexToData(TRUE,name_len-oid_name_length,&(name[oid_name_length]), &atcMcastStormIfIndex)==FALSE)
                return SNMP_ERR_COMMITFAILED;
            value = *(long *)var_val;
            if(SWCTRL_PMGR_SetATCMulticastStormTrapTrafficControlOnStatus( atcMcastStormIfIndex, value) != TRUE )
                return SNMP_ERR_COMMITFAILED;
        }
            break;

        case UNDO:
          break;

        case COMMIT:
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_atcMcastStormTcReleaseTrapStatus(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{

    switch ( action ) {

        case RESERVE1:

          if (var_val_type != ASN_INTEGER)
          {
              return SNMP_ERR_WRONGTYPE;
          }
          break;

        case RESERVE2:
            switch ( *(long *)var_val )
            {
                case VAL_atcMcastStormTcReleaseTrapStatus_enabled:
                    break;
                case VAL_atcMcastStormTcReleaseTrapStatus_disabled:
                    break;
                default:
                    return SNMP_ERR_WRONGVALUE;
            }
          break;

        case FREE:
          break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
            I32_T value=0;
            UI32_T atcMcastStormIfIndex = 0;

            if(atcMcastStormTable_OidIndexToData(TRUE,name_len-oid_name_length,&(name[oid_name_length]), &atcMcastStormIfIndex)==FALSE)
                return SNMP_ERR_COMMITFAILED;
            value = *(long *)var_val;
            if(SWCTRL_PMGR_SetATCMulticastStormTrapTrafficControlReleaseStatus( atcMcastStormIfIndex, value) != TRUE )
                return SNMP_ERR_COMMITFAILED;
        }
            break;

        case UNDO:
          break;

        case COMMIT:
          break;
    }
    return SNMP_ERR_NOERROR;
}
#endif /* #if (SYS_CPNT_ATC_MSTORM == TRUE) */

#endif /* #if (SYS_CPNT_ATC_STORM == TRUE) */

#if (SYS_CPNT_RATE_BASED_STORM_CONTROL != TRUE)

#if (SYS_CPNT_STORM_MODE & SYS_CPNT_STORM_BSTORM)
/********************************************
 **************bcastStormTable***************
 ********************************************
 */
#define BCASTSTORMENTRY_INSTANCE_LEN  1

BOOL_T bcastStormTable_OidIndexToData(UI32_T exact, UI32_T compc,
    oid *compl, UI32_T *index_p)
{
    /* get or set
     */
    if (exact)
    {
        /* check the index length
         */
        if (compc != BCASTSTORMENTRY_INSTANCE_LEN) /* the constant size index */
        {
            return FALSE;
        }
    }

    *index_p = compl[0];

    return TRUE;
}

/*
 * var_bcastStormTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *var_bcastStormTable(struct variable *vp,
    oid *name,
    size_t *length,
    int exact,
    size_t *var_len,
    WriteMethod **write_method)
{
    UI32_T compc = 0;
    oid compl[BCASTSTORMENTRY_INSTANCE_LEN] = {0};
    oid best_inst[BCASTSTORMENTRY_INSTANCE_LEN] = {0};
    SWCTRL_BcastStormEntry_T entry;

    switch (vp->magic)
    {
        case LEAF_bcastStormStatus:
            *write_method = write_bcastStormStatus;
            break;

        case LEAF_bcastStormSampleType:
            *write_method = write_bcastStormSampleType;
            break;

        case LEAF_bcastStormPktRate:
            *write_method = write_bcastStormPktRate;
            break;

        case LEAF_bcastStormOctetRate:
            *write_method = write_bcastStormOctetRate;
            break;

        case LEAF_bcastStormPercent:
            *write_method = write_bcastStormPercent;
            break;

        case LEAF_bcastStormBitRateInKilo:
            *write_method = write_bcastStormBitRateInKilo;
            break;

        default:
            *write_method = 0;
            break;
    }

    /* check compc, retrive compl
     */
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl, BCASTSTORMENTRY_INSTANCE_LEN);

    memset(&entry, 0, sizeof(entry));

    if (exact) /* get or set */
    {
        if (bcastStormTable_OidIndexToData(exact, compc, compl, &entry.bcast_storm_ifindex) == FALSE)
        {
            return NULL;
        }

        if (SWCTRL_POM_GetBcastStormEntry(&entry) != TRUE)
        {
            return NULL;
        }
    }
    else /* getnext */
    {
        bcastStormTable_OidIndexToData(exact, compc, compl, &entry.bcast_storm_ifindex);

        /* check the length of inputing index,if < 1 we should try get
         * {0.0.0.0.0...}
         */
        if (compc < 1)
        {
            if (SWCTRL_POM_GetBcastStormEntry(&entry) != TRUE)
            {
                if (SWCTRL_POM_GetNextBcastStormEntry(&entry) != TRUE)
                {
                    return NULL;
                }
            }
        }
        else
        {
            if (SWCTRL_POM_GetNextBcastStormEntry(&entry) != TRUE)
            {
                return NULL;
            }
        }
    }

    memcpy(name, vp->name, vp->namelen * sizeof(oid));

    /* assign data to the oid index
     */
    best_inst[0] = entry.bcast_storm_ifindex;
    memcpy(name + vp->namelen, best_inst, BCASTSTORMENTRY_INSTANCE_LEN * sizeof(oid));
    *length = vp->namelen + BCASTSTORMENTRY_INSTANCE_LEN;

    switch (vp->magic)
    {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case LEAF_bcastStormIfIndex:
            *var_len = sizeof(long_return);
            long_return = entry.bcast_storm_ifindex;
            return (u_char *) &long_return;
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

        case LEAF_bcastStormStatus:
            *var_len = sizeof(long_return);
            long_return = entry.bcast_storm_status;
            return (u_char *) &long_return;

        case LEAF_bcastStormSampleType:
            *var_len = sizeof(long_return);
            long_return = entry.bcast_storm_sample_type;
            return (u_char *) &long_return;

        case LEAF_bcastStormPktRate:
            *var_len = sizeof(long_return);
            long_return = entry.bcast_storm_pkt_rate;
            return (u_char *) &long_return;

        case LEAF_bcastStormOctetRate:
            *var_len = sizeof(long_return);
            long_return = entry.bcast_storm_octet_rate;
            return (u_char *) &long_return;

        case LEAF_bcastStormPercent:
            *var_len = sizeof(long_return);
            long_return = entry.bcast_storm_percent;
            return (u_char *) &long_return;

        case LEAF_bcastStormBitRateInKilo:
            *var_len = sizeof(long_return);
            long_return = entry.bcast_storm_octet_rate;
            return (u_char *) &long_return;

        default:
            ERROR_MSG("");
    }

    return NULL;
}

int write_bcastStormStatus(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            switch (*(long *)var_val)
            {
                case VAL_bcastStormStatus_enabled:
                    break;

                case VAL_bcastStormStatus_disabled:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
            I32_T value = 0;
            UI32_T index = 0;

            if (bcastStormTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &index) == FALSE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            value = *(long *)var_val;

            if (SWCTRL_PMGR_SetBroadcastStormStatus(index, value) != TRUE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

int write_bcastStormSampleType(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            switch (*(long *)var_val)
            {
                case VAL_bcastStormSampleType_pkt_rate:
                    break;

                case VAL_bcastStormSampleType_octet_rate:
                    break;

                case VAL_bcastStormSampleType_percent:
                    break;

                case VAL_bcastStormSampleType_bitRateInKilo:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
            I32_T value = 0;
            UI32_T index = 0;

            if (bcastStormTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &index) == FALSE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            value = *(long *)var_val;

            if (SWCTRL_PMGR_SetBcastStormSampleType(index, value) != TRUE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

int write_bcastStormPktRate(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
            I32_T value = 0;
            UI32_T index = 0;

            if (bcastStormTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &index) == FALSE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            value = *(long *)var_val;

            if (SWCTRL_PMGR_SetBStormControlRateLimit(index, SYS_DFLT_BSTORM_TYPE, value) != TRUE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

int write_bcastStormOctetRate(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
            I32_T value = 0;
            UI32_T index = 0;

            if (bcastStormTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &index) == FALSE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            value = *(long *)var_val;

            if (SWCTRL_PMGR_SetBcastStormOctetRate(index, value) != TRUE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

int write_bcastStormPercent(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            if (MIN_bcastStormPercent > *(long *)var_val || *(long *)var_val > MAX_bcastStormPercent)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
            I32_T value = 0;
            UI32_T index = 0;

            if (bcastStormTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &index) == FALSE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            value = *(long *)var_val;

            if (SWCTRL_PMGR_SetBcastStormPercent(index, value) != TRUE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

int write_bcastStormBitRateInKilo(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
            I32_T value = 0;
            UI32_T index = 0;

            if (bcastStormTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &index) == FALSE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            value = *(long *)var_val;

            if (SWCTRL_PMGR_SetBcastStormOctetRate(index, value) != TRUE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}
#endif /* #if (SYS_CPNT_STORM_MODE & SYS_CPNT_STORM_BSTORM) */

#if (SYS_CPNT_STORM_MODE & SYS_CPNT_STORM_MSTORM)
/********************************************
 **************mcastStormTable***************
 ********************************************
 */
static int
header_mcastStormTable(struct variable *vp,
               oid * name,
               size_t * length,
               int exact, size_t * var_len, WriteMethod ** write_method)
{
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    oid    newname[MAX_OID_LEN];
    int    interface;
    int    result;
    SWCTRL_McastStormEntry_T  entry;
    int ifIndex = 0;
    BOOL_T return_val;


    memcpy((char *) newname, (char *) vp->name,
           (int) vp->namelen * sizeof(oid));
    /*
     * find "next" interface
     */
    entry.mcast_storm_ifindex = ifIndex;

    while (  (return_val= SWCTRL_POM_GetNextMcastStormEntry( &entry))==TRUE)
    {
        ifIndex = entry.mcast_storm_ifindex;
        newname[oid_name_length] = (oid) ifIndex;
        result =
            snmp_oid_compare(name, *length, newname,
                         (int) vp->namelen + 1);
        if ((exact && (result == 0)) || (!exact && (result < 0)))
            break;
    }
    if (!return_val ) {

        return MATCH_FAILED;
    }


    memcpy((char *) name, (char *) newname,
    ((int) vp->namelen + 1) * sizeof(oid));
    *length = vp->namelen + 1;
    *write_method = 0;
    *var_len = sizeof(long);    /* default to 'long' results */
    interface = newname[oid_name_length];

    return interface;
}


/*
 * var_mcastStormTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *
var_mcastStormTable(struct variable *vp,
            oid     *name,
            size_t  *length,
            int     exact,
            size_t  *var_len,
            WriteMethod **write_method)
{
    SWCTRL_McastStormEntry_T  entry;
    int   interface;

    memset( &entry, 0, sizeof(entry));
    interface =
    header_mcastStormTable(vp, name, length, exact, var_len, write_method);
    if (interface == MATCH_FAILED)
        return NULL;

    entry.mcast_storm_ifindex =interface;

    if (SWCTRL_POM_GetMcastStormEntry( &entry)!= TRUE)
        return NULL;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch(vp->magic) {
   #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    case MCASTSTORMIFINDEX:
        long_return = entry.mcast_storm_ifindex;
        return (u_char*) &long_return;
   #endif

    case MCASTSTORMSTATUS:
        *write_method = write_mcastStormStatus;
        long_return = entry.mcast_storm_status;
        return (u_char*) &long_return;

    case MCASTSTORMSAMPLETYPE:
        *write_method = write_mcastStormSampleType;
        long_return = entry.mcast_storm_sample_type;
        return (u_char*) &long_return;

    case MCASTSTORMPKTRATE:
        *write_method = write_mcastStormPktRate;
         long_return = entry.mcast_storm_pkt_rate;
        return (u_char*) &long_return;

    case MCASTSTORMOCTETRATE:
        *write_method = write_mcastStormOctetRate;
        long_return = entry.mcast_storm_octet_rate;
        return (u_char*) &long_return;

    case MCASTSTORMPERCENT:
        *write_method = write_mcastStormPercent;
         long_return = entry.mcast_storm_percent;
        return (u_char*) &long_return;

    default:
      ERROR_MSG("");
    }
    return NULL;
}


int
write_mcastStormStatus(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch ( action ) {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER) {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;

        case RESERVE2:
            value = *(long *)var_val;
            if ((value <VAL_mcastStormStatus_enabled) || (value >VAL_mcastStormStatus_disabled))
                return SNMP_ERR_WRONGVALUE;

            break;

        case FREE:
            /* Release any resources that have been allocated */
            break;

        case ACTION:
            /*
             * The variable has been stored in 'value' for you to use,
             * and you have just been asked to do something with it.
             * Note that anything done here must be reversable in the UNDO case
             */
            value = * (long *) var_val;
            if (SWCTRL_PMGR_SetMulticastStormStatus(name[oid_name_length],value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
            break;

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_mcastStormSampleType(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch ( action ) {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER) {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;

        case RESERVE2:
            value = *(long *)var_val;
            if ((value <VAL_mcastStormSampleType_pkt_rate) || (value >VAL_mcastStormSampleType_percent))
                return SNMP_ERR_WRONGVALUE;

            break;

        case FREE:
            /* Release any resources that have been allocated */
            break;

        case ACTION:
            /*
             * The variable has been stored in 'value' for you to use,
             * and you have just been asked to do something with it.
             * Note that anything done here must be reversable in the UNDO case
             */
            value = * (long *) var_val;
            if (SWCTRL_PMGR_SetMcastStormSampleType(name[oid_name_length],value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
            break;

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_mcastStormPktRate(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch ( action ) {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER) {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;

        case RESERVE2:

            break;

        case FREE:
            /* Release any resources that have been allocated */
            break;

        case ACTION:
            /*
             * The variable has been stored in 'value' for you to use,
             * and you have just been asked to do something with it.
             * Note that anything done here must be reversable in the UNDO case
             */
            value = * (long *) var_val;
            if (SWCTRL_PMGR_SetMStormControlRateLimit(name[oid_name_length], SYS_DFLT_MSTORM_TYPE, value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
            break;

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_mcastStormOctetRate(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch ( action ) {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER) {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;

        case RESERVE2:

            break;

        case FREE:
            /* Release any resources that have been allocated */
            break;

        case ACTION:
            /*
             * The variable has been stored in 'value' for you to use,
             * and you have just been asked to do something with it.
             * Note that anything done here must be reversable in the UNDO case
             */
            value = * (long *) var_val;
            if (SWCTRL_PMGR_SetMcastStormOctetRate(name[oid_name_length],value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
            break;

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_mcastStormPercent(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch ( action ) {
            case RESERVE1:
            if (var_val_type != ASN_INTEGER) {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long)) {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;

        case RESERVE2:
            value = *(long *)var_val;
            if ((value <0) || (value >100))
                return SNMP_ERR_WRONGVALUE;

            break;

        case FREE:
            /* Release any resources that have been allocated */
            break;

        case ACTION:
            /*
             * The variable has been stored in 'value' for you to use,
             * and you have just been asked to do something with it.
             * Note that anything done here must be reversable in the UNDO case
             */
            value = * (long *) var_val;
            if (SWCTRL_PMGR_SetMcastStormPercent(name[oid_name_length ],value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
            break;

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }
    return SNMP_ERR_NOERROR;
}
#endif /* #if (SYS_CPNT_STORM_MODE & SYS_CPNT_STORM_MSTORM) */

#if (SYS_CPNT_STORM_MODE & SYS_CPNT_STORM_UNKNOWN_USTORM)

#define UNKNOWNUCASTSTORMENTRY_INSTANCE_LEN  1

BOOL_T unknownUcastStormTable_OidIndexToData(UI32_T exact, UI32_T compc,
            oid * compl ,  UI32_T *unknownUcastStormIfIndex)
{
    /* get or write
     */
    if(exact)
    {
        /* check the index length
         */
        if(compc != UNKNOWNUCASTSTORMENTRY_INSTANCE_LEN) /* the constant size index*/
        {
            return FALSE;
        }
    }
    *unknownUcastStormIfIndex=compl[0];
    return TRUE;
}

/*
 * var_unknownUcastStormTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *
var_unknownUcastStormTable(struct variable *vp,
            oid     *name,
            size_t  *length,
            int     exact,
            size_t  *var_len,
            WriteMethod **write_method)
{
    /* variables we may use later */
    UI32_T compc=0;
    oid compl[UNKNOWNUCASTSTORMENTRY_INSTANCE_LEN] = {0};
    oid best_inst[UNKNOWNUCASTSTORMENTRY_INSTANCE_LEN] = {0};
    SWCTRL_UnknownUcastStormEntry_T  entry;
    switch(vp->magic)
    {
    case LEAF_unknownUcastStormStatus:
        *write_method = write_unknownUcastStormStatus;
        break;
    case LEAF_unknownUcastStormSampleType:
        *write_method = write_unknownUcastStormSampleType;
        break;
    case LEAF_unknownUcastStormPktRate:
        *write_method = write_unknownUcastStormPktRate;
        break;
    case LEAF_unknownUcastStormOctetRate:
        *write_method = write_unknownUcastStormOctetRate;
        break;
    case LEAF_unknownUcastStormPercent:
        *write_method = write_unknownUcastStormPercent;
        break;
    default:
        *write_method = 0;
        break;
    }

    /*check compc, retrive compl*/
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,compl, UNKNOWNUCASTSTORMENTRY_INSTANCE_LEN);

    memset(&entry, 0, sizeof(entry));

    if (exact)/*get,set*/
    {

        /* get index */
        if(unknownUcastStormTable_OidIndexToData(exact,compc,compl, &entry.unknown_ucast_storm_ifindex)==FALSE)
        {
            return NULL;
        }

        /*get data
         */
        if (SWCTRL_POM_GetUnkucastStormEntry(&entry)!=TRUE)
        {
            return NULL;
        }
    }
    else/*getnext*/
    {

        /*get index*/
        unknownUcastStormTable_OidIndexToData(exact,compc,compl, &entry.unknown_ucast_storm_ifindex);
        /* check the length of inputing index,if <1 we should try get {0.0.0.0.0...}
         */
        if (compc< 1)
        {
            /* get data */
            if ( SWCTRL_POM_GetUnkucastStormEntry(&entry)!=TRUE)
            {

                /*get next data*/
                if ( SWCTRL_POM_GetNextUnkucastStormEntry(&entry)!=TRUE)
                {
                    return NULL;
                }
            }
        }
        else
        {

            /*get next data*/
            if ( SWCTRL_POM_GetNextUnkucastStormEntry(&entry)!=TRUE)
            {
                return NULL;
            }
        }
    }

    memcpy(name, vp->name, vp->namelen*sizeof(oid));
    /* assign data to the oid index
     */

    best_inst[0]=entry.unknown_ucast_storm_ifindex;
    memcpy(name+vp->namelen,best_inst,UNKNOWNUCASTSTORMENTRY_INSTANCE_LEN*sizeof(oid));
    *length = vp->namelen+UNKNOWNUCASTSTORMENTRY_INSTANCE_LEN ;

    /* this is where we do the value assignments for the mib results.
     */
    switch(vp->magic) {

#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    case LEAF_unknownUcastStormIfIndex:
        *var_len = sizeof(long_return);
        long_return = entry.unknown_ucast_storm_ifindex;
        return (u_char *) &long_return;
#endif
    case LEAF_unknownUcastStormStatus:
        *var_len = sizeof(long_return);
        long_return = entry.unknown_ucast_storm_status;
        return (u_char *) &long_return;
    case LEAF_unknownUcastStormSampleType:
        *var_len = sizeof(long_return);
        long_return = entry.unknown_ucast_storm_sample_type;
        return (u_char *) &long_return;
    case LEAF_unknownUcastStormPktRate:
        *var_len = sizeof(long_return);
        long_return = entry.unknown_ucast_storm_pkt_rate;
        return (u_char *) &long_return;
    case LEAF_unknownUcastStormOctetRate:
        *var_len = sizeof(long_return);
        long_return = entry.unknown_ucast_storm_octet_rate;
        return (u_char *) &long_return;
    case LEAF_unknownUcastStormPercent:
        *var_len = sizeof(long_return);
        long_return = entry.unknown_ucast_storm_percent;
        return (u_char *) &long_return;
    default:
      ERROR_MSG("");
    }
    return NULL;
}

int
write_unknownUcastStormStatus(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{

    switch ( action ) {

        case RESERVE1:

            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            switch ( *(long *)var_val )
            {
                case VAL_unknownUcastStormStatus_enabled:
                    break;
                case VAL_unknownUcastStormStatus_disabled:
                    break;
                default:
                    return SNMP_ERR_WRONGVALUE;
            }
          break;

        case FREE:
          break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
            I32_T value=0;
            UI32_T unknownUcastStormIfIndex = 0;

            if(unknownUcastStormTable_OidIndexToData(TRUE,name_len-oid_name_length,&(name[oid_name_length]), &unknownUcastStormIfIndex)==FALSE)
                return SNMP_ERR_COMMITFAILED;
            value = *(long *)var_val;
            if(SWCTRL_PMGR_SetUnknownUnicastStormStatus( unknownUcastStormIfIndex, value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
        }
            break;

        case UNDO:
          break;

        case COMMIT:
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_unknownUcastStormSampleType(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{

    switch ( action ) {

        case RESERVE1:

            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            switch ( *(long *)var_val )
            {
#if (SYS_CPNT_STORM_SAMPLE_TYPE_PACKET == TRUE)
                case VAL_unknownUcastStormSampleType_packet_rate:
                    break;
#endif

#if (SYS_CPNT_STORM_SAMPLE_TYPE_OCTET == TRUE)
                case VAL_unknownUcastStormSampleType_octet_rate:
                    break;
#endif

#if (SYS_CPNT_STORM_SAMPLE_TYPE_PERCENT == TRUE)
                case VAL_unknownUcastStormSampleType_percent:
                    break;
#endif
                default:
                    return SNMP_ERR_WRONGVALUE;
            }
          break;

        case FREE:
          break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
            I32_T value=0;
            UI32_T unknownUcastStormIfIndex = 0;

            if(unknownUcastStormTable_OidIndexToData(TRUE,name_len-oid_name_length,&(name[oid_name_length]), &unknownUcastStormIfIndex)==FALSE)
                return SNMP_ERR_COMMITFAILED;
            value = *(long *)var_val;
            if(SWCTRL_PMGR_SetUnknownUnicastStormStatus( unknownUcastStormIfIndex, value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
        }
            break;

        case UNDO:
          break;

        case COMMIT:
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_unknownUcastStormPktRate(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{

    switch ( action ) {

        case RESERVE1:

            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
            I32_T value=0;
            UI32_T unknownUcastStormIfIndex = 0;

            if(unknownUcastStormTable_OidIndexToData(TRUE,name_len-oid_name_length,&(name[oid_name_length]), &unknownUcastStormIfIndex)==FALSE)
                return SNMP_ERR_COMMITFAILED;
            value = *(long *)var_val;
            if(SWCTRL_PMGR_SetUnknownUStormControlRateLimit(unknownUcastStormIfIndex, SYS_DFLT_UNKUSTORM_TYPE, value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
        }
            break;

        case UNDO:
          break;

        case COMMIT:
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_unknownUcastStormOctetRate(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{

    switch ( action ) {

        case RESERVE1:

            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
            I32_T value=0;
            UI32_T unknownUcastStormIfIndex = 0;

            if(unknownUcastStormTable_OidIndexToData(TRUE,name_len-oid_name_length,&(name[oid_name_length]), &unknownUcastStormIfIndex)==FALSE)
                return SNMP_ERR_COMMITFAILED;
            value = *(long *)var_val;
            if(SWCTRL_PMGR_SetUnkucastStormOctetRate( unknownUcastStormIfIndex, value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
        }
            break;

        case UNDO:
          break;

        case COMMIT:
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_unknownUcastStormPercent(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{

    switch ( action ) {

        case RESERVE1:

            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            if (   (*(long *)var_val < 0)
                || (*(long *)var_val > 100))
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
            I32_T value=0;
            UI32_T unknownUcastStormIfIndex = 0;

            if(unknownUcastStormTable_OidIndexToData(TRUE,name_len-oid_name_length,&(name[oid_name_length]), &unknownUcastStormIfIndex)==FALSE)
                return SNMP_ERR_COMMITFAILED;
            value = *(long *)var_val;
            if(SWCTRL_PMGR_SetUnkucastStormPercent( unknownUcastStormIfIndex, value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
        }
            break;

        case UNDO:
          break;

        case COMMIT:
          break;
    }
    return SNMP_ERR_NOERROR;
}
#endif /* #if (SYS_CPNT_STORM_MODE & SYS_CPNT_STORM_UNKNOWN_USTORM) */

#else /* else #if (SYS_CPNT_RATE_BASED_STORM_CONTROL != TRUE) */

/********************************************
 *********rateBasedStormTable****************
 ********************************************
 */
#define RATEBASEDSTORMENTRY_INSTANCE_LEN  1

BOOL_T rateBasedStormTable_OidIndexToData(UI32_T exact, UI32_T compc,
            oid * compl,  UI32_T *rateBasedStormIfIndex)
{
    /* get or write */
    if (exact)
    {
        /* check the index length */
        if (compc != RATEBASEDSTORMENTRY_INSTANCE_LEN) /* the constant size index */
        {
            return FALSE;
        }
    }
    *rateBasedStormIfIndex = compl[0];
    return TRUE;
}

/*
 * var_rateBasedStormTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *
var_rateBasedStormTable(struct variable *vp,
            oid     *name,
            size_t  *length,
            int     exact,
            size_t  *var_len,
            WriteMethod **write_method)
{
    /* variables we may use later */
    UI32_T compc = 0;
    oid compl[RATEBASEDSTORMENTRY_INSTANCE_LEN] = {0};
    oid best_inst[RATEBASEDSTORMENTRY_INSTANCE_LEN] = {0};
    UI32_T ifindex;
    UI32_T rate;
    UI32_T mode;

    switch (vp->magic)
    {
        case LEAF_rateBasedStormRate:
            *write_method = write_rateBasedStormRate;
            break;

        case LEAF_rateBasedStormMode:
            *write_method = write_rateBasedStormMode;
            break;

        default:
            *write_method = 0;
            break;
    }

    /* check compc, retrive compl */
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,
                           compl, RATEBASEDSTORMENTRY_INSTANCE_LEN);

    if (exact) /* get,set */
    {
        /* get index */
        if (rateBasedStormTable_OidIndexToData(exact, compc, compl,  &ifindex) == FALSE)
        {
            return NULL;
        }

        /* get data */
        if (SWCTRL_POM_GetRateBasedStormControl( ifindex, &rate, &mode) != TRUE)
        {
            return NULL;
        }
    }
    else /* getnext */
    {
        /* get index */
        if(rateBasedStormTable_OidIndexToData(exact, compc, compl,  &ifindex)==FALSE)
        {
            ;
        }

        /* check the length of inputing index,if < 1 we should try get
         * {0.0.0.0.0...}
         */
        if (compc < 1)
        {
            /* get data */
            ifindex=1;/*first time ,we initialize ifindex as 1 */
            if (SWCTRL_POM_GetRateBasedStormControl( ifindex, &rate, &mode) != TRUE)
            {
                /* get next data */
                if (SWCTRL_POM_GetNextRateBasedStormControl( &ifindex, &rate, &mode) != TRUE)
                {
                    return NULL;
                }
            }
        }
        else
        {
            /* get next data */
            if (SWCTRL_POM_GetNextRateBasedStormControl( &ifindex, &rate, &mode) != TRUE)
            {
                return NULL;
            }
        }
    }

    memcpy(name, vp->name, vp->namelen*sizeof(oid));

    /* assign data to the oid index */
    best_inst[0] = ifindex;
    memcpy(name + vp->namelen, best_inst,
           RATEBASEDSTORMENTRY_INSTANCE_LEN * sizeof(oid));
    *length = vp->namelen + RATEBASEDSTORMENTRY_INSTANCE_LEN ;

    /* this is where we do the value assignments for the mib results. */
    switch (vp->magic)
    {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case LEAF_rateBasedStormIfIndex:
            *var_len = sizeof(long_return);
            long_return = ifindex;
            return (u_char *) &long_return;

#endif
        case LEAF_rateBasedStormRate:
            *var_len = sizeof(long_return);
            long_return = rate;
            return (u_char *) &long_return;

        case LEAF_rateBasedStormMode:
            *var_len = SIZE_rateBasedStormMode;
            memcpy(return_buf, &mode, *var_len);
            return (u_char*)return_buf;

        default:
            ERROR_MSG("");
    }

    return NULL;
}

int
write_rateBasedStormRate(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
            I32_T value = 0;
            UI32_T ifindex = 0;

            if (rateBasedStormTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]),  &ifindex) == FALSE)
                return SNMP_ERR_COMMITFAILED;

            value = *(long *)var_val;

            if(SWCTRL_PMGR_SetRateBasedStormControlRate( ifindex, value)!=TRUE)
                return SNMP_ERR_COMMITFAILED;
        }
            break;

        case UNDO:
          break;

        case COMMIT:
          break;
    }

    return SNMP_ERR_NOERROR;
}

int
write_rateBasedStormMode(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_OCTET_STR)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len != SIZE_rateBasedStormMode)
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;

        case RESERVE2:
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
            UI8_T byte_buffer[SIZE_rateBasedStormMode] = {0};
            UI32_T ifindex = 0;

            if (rateBasedStormTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]),  &ifindex) == FALSE)
                return SNMP_ERR_COMMITFAILED;

            memcpy(byte_buffer, var_val, var_val_len);

            if(SWCTRL_PMGR_SetRateBasedStormControlMode( ifindex, byte_buffer)!=TRUE)
                return SNMP_ERR_COMMITFAILED;
        }
            break;

        case UNDO:
          break;

        case COMMIT:
          break;
    }

    return SNMP_ERR_NOERROR;
}
#endif /* #if (SYS_CPNT_RATE_BASED_STORM_CONTROL != TRUE) */

/********************************************
 **************vlanTable*********************
 ********************************************
 */


#define Vlan_Entry_INSTANCE_LEN 1

/* donny.li  EPR:ES3628BT-FLF-ZZ-00505*/
extern UI32_T NETCFG_POM_IP_GetNextIpAddressMode(UI32_T *ifindex_p, UI32_T *mode_p);

static BOOL_T vlanAddressMethod_get(int      compc,
                                oid     *compl,
                                UI32_T *vlanAddressMethod)
{
    UI32_T vidifindex = 0;
    UI32_T vid;

    vid = compl[0];
    VLAN_VID_CONVERTTO_IFINDEX(vid, vidifindex);
    if(NETCFG_POM_IP_GetIpAddressMode(vidifindex, vlanAddressMethod)!= NETCFG_TYPE_OK)
    {
        return FALSE;
    }
    return TRUE;

}
static BOOL_T vlanAddressMethod_next(int   compc,
                                 oid     *compl,
                                 UI32_T *vlanAddressMethod)
{
    UI32_T vidifindex = 0;
    UI32_T vid;

    vid = compl[0];
    VLAN_VID_CONVERTTO_IFINDEX(vid, vidifindex);
    if(NETCFG_POM_IP_GetNextIpAddressMode(&vidifindex, vlanAddressMethod)!= NETCFG_TYPE_OK)
    {
        return FALSE;
    }
    VLAN_IFINDEX_CONVERTTO_VID(vidifindex,vid);
    compl[0] = vid;
    return TRUE;

}

/*
 * var_vlanTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *
var_vlanTable(struct variable *vp,
            oid     *name,
            size_t  *length,
            int     exact,
            size_t  *var_len,
            WriteMethod **write_method)
{
    UI32_T vidifindex = 0;
    UI32_T vlanAddressMethod = 0;
    UI32_T compc = 0;
    oid compl[Vlan_Entry_INSTANCE_LEN] = {0};

    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,compl, Vlan_Entry_INSTANCE_LEN);

    switch(vp->magic)
    {
        case VLANADDRESSMETHOD:
            *write_method = write_vlanAddressMethod;
            break;
        default:
            *write_method = 0;
            break;
    }

    if (exact)/*get*/
    {
        if (!vlanAddressMethod_get(compc, compl, &vlanAddressMethod))
            return NULL;
    }
    else/*getnext*/
    {
        if (!vlanAddressMethod_next(compc, compl, &vlanAddressMethod))
            return NULL;
    }

    vidifindex = compl[0];
    memcpy(name, vp->name, vp->namelen*sizeof(oid));
    name[vp->namelen] = vidifindex;
    *length = vp->namelen +Vlan_Entry_INSTANCE_LEN;

    *var_len = sizeof(long_return);

    switch(vp->magic) {
  #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    case VLANINDEX:
        long_return = vidifindex;
        return (u_char*) &long_return;
  #endif
    case VLANADDRESSMETHOD:
        long_return = vlanAddressMethod;
        return (u_char*) &long_return;
    default:
      ERROR_MSG("");
    }
    return NULL;
}


int
write_vlanAddressMethod(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;

     /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          value = *(long *)var_val;
          if ((value <VAL_vlanAddressMethod_user) || (value >VAL_vlanAddressMethod_dhcp))
             return SNMP_ERR_WRONGVALUE;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
              {

                UI32_T vlanAddressMethod;
                UI32_T vidifindex;
                vlanAddressMethod= * (long *) var_val;

                VLAN_VID_CONVERTTO_IFINDEX(name[oid_name_length], vidifindex);

                if (NETCFG_PMGR_IP_SetIpAddressMode(vidifindex,vlanAddressMethod) != NETCFG_TYPE_OK)
                    return SNMP_ERR_COMMITFAILED;
             }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

/********************************************
 *************vlanPortTable******************
 ********************************************
 */
#if 0
static int
header_vlanPortTable(struct variable *vp,
               oid * name,
               size_t * length,
               int exact, size_t * var_len, WriteMethod ** write_method)
{
    oid             newname[MAX_OID_LEN];
    int    interface;
    int             result;
   VLAN_OM_VlanPortEntry_T  entry;
   UI32_T ifIndex = 0;
   BOOL_T return_val;
   UI32_T oid_name_length;

    oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
    memcpy((char *) newname, (char *) vp->name,
           (int) vp->namelen * sizeof(oid));
    /*
     * find "next" interface
     */

     while (  (return_val= VLAN_PMGR_GetNextVlanPortEntry( &ifIndex, &entry))==TRUE)
     {

        newname[oid_name_length] = (oid) ifIndex;
        result =
            snmp_oid_compare(name, *length, newname,
                             (int) vp->namelen + 1);
        if ((exact && (result == 0)) || (!exact && (result < 0)))
            break;
    }
    if (!return_val ) {

        return MATCH_FAILED;
    }


    memcpy((char *) name, (char *) newname,
           ((int) vp->namelen + 1) * sizeof(oid));
    *length = vp->namelen + 1;
    *write_method = 0;
    *var_len = sizeof(long);    /* default to 'long' results */
    interface = newname[oid_name_length];



    return interface;
}
#else
static int
header_vlanPortTable(struct variable *vp,
               oid * name,
               size_t * length,
               int exact, size_t * var_len, WriteMethod ** write_method,
               VLAN_OM_VlanPortEntry_T  *entry)
{

   unsigned int ifIndex = 0;


    if(!entry || l_snmp_index_get(vp,name,length,&ifIndex,exact) < 0 )
        return MATCH_FAILED;

    /*
     * find "next" interface
     */
    if(!exact){

     if(  VLAN_PMGR_GetNextVlanPortEntry( (UI32_T *)(&ifIndex), entry)!=TRUE)
        return MATCH_FAILED;

     l_snmp_index_set(vp,name,length,ifIndex);

    }
    else
    {
        if(VLAN_PMGR_GetVlanPortEntry(ifIndex,entry)!=TRUE)
            return MATCH_FAILED;

    }

    *write_method = 0;
    *var_len = sizeof(long);    /* default to 'long' results */

    return TRUE;
}

#endif

/*
 * var_vlanPortTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *
var_vlanPortTable(struct variable *vp,
            oid     *name,
            size_t  *length,
            int     exact,
            size_t  *var_len,
            WriteMethod **write_method)
{
   VLAN_OM_VlanPortEntry_T  entry;
    int             interface;
   memset( &entry, 0, sizeof(entry));
   interface = header_vlanPortTable(vp, name, length, exact, var_len, write_method,&entry);
   if(MATCH_FAILED == interface)
        return NULL;

    /*
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    case VLANPORTINDEX:
        long_return = interface;
        return (u_char*) &long_return;
#endif
    case VLANPORTMODE:
        *write_method = write_vlanPortMode;
          long_return = entry.vlan_port_mode;
        return (u_char*) &long_return;
    default:
      ERROR_MSG("");
    }
    return NULL;
}


int
write_vlanPortMode(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    UI32_T oid_name_length;

    oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;

     /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          value = *(long *)var_val;
          #ifdef ACD
          if ((value !=VAL_vlanPortMode_dot1qTrunk) &&(value !=VAL_vlanPortMode_access))
             return SNMP_ERR_WRONGVALUE;
          #else
          if ((value !=VAL_vlanPortMode_dot1qTrunk)&& (value !=VAL_vlanPortMode_hybrid)
#if (SYS_CPNT_VLAN_ACCESS == TRUE)
              &&(value !=VAL_vlanPortMode_access)
#endif
              )
             return SNMP_ERR_WRONGVALUE;
          #endif
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
               value = * (long *) var_val;
                  if (VLAN_PMGR_SetVlanPortMode(name[oid_name_length],value) != TRUE)
                    return SNMP_ERR_COMMITFAILED;

          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

#if (SYS_CPNT_ADD == TRUE)
/********************************************
 ***************voiceVlanMgt*****************
 ********************************************
 */
int
do_voiceVlanEnabledId(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{

    switch(reqinfo->mode) {
        case MODE_GET:
        {
            I32_T  voice_vlan_id = 0;
            if (ADD_PMGR_GetVoiceVlanId(&voice_vlan_id)==TRUE)
            {
                long_return = voice_vlan_id;
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER , (u_char *)&long_return , sizeof(long_return) );
            }
            else
            {
                return SNMP_ERR_GENERR;
            }
        }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:

            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
            }

            break;
        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
        {
            if (ADD_PMGR_SetVoiceVlanEnabledId(*requests->requestvb->val.integer)!=TRUE)
            {
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
            }
        }
            break;

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_voiceVlanAgingTime(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{

    switch(reqinfo->mode) {
        case MODE_GET:
        {
            UI32_T value = 0;

            if (ADD_PMGR_GetVoiceVlanAgingTime(&value)==TRUE)
            {
                long_return = value;
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER , (u_char *)&long_return , sizeof(long_return) );
            }
            else
            {
                return SNMP_ERR_GENERR;
            }
        }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:

            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
            }

            break;
        case MODE_SET_RESERVE2:

            if (*requests->requestvb->val.integer< MIN_voiceVlanAgingTime ||*requests->requestvb->val.integer > MAX_voiceVlanAgingTime)
            {
               netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
        {
            if (ADD_PMGR_SetVoiceVlanAgingTime(*requests->requestvb->val.integer)!=TRUE)
            {
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
            }
        }
            break;

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

#define VOICEVLANOUIENTRY_INSTANCE_LEN  6

BOOL_T voiceVlanOuiTable_OidIndexToData(UI32_T exact, UI32_T compc,
            oid * compl ,  UI8_T *voiceVlanOuiAddress)
{
    int i;
    /* get or write
     */
    if(exact)
    {

        /* check the index length
         */
        if(compc != VOICEVLANOUIENTRY_INSTANCE_LEN) /* the constant size index*/
        {
            return FALSE;
        }
    }
    for( i=0;i< SIZE_voiceVlanOuiAddress ;i++)
    {
        voiceVlanOuiAddress[i]=compl[0+i];
    }

    return TRUE;
}

/*
 * var_voiceVlanOuiTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *
var_voiceVlanOuiTable(struct variable *vp,
            oid     *name,
            size_t  *length,
            int     exact,
            size_t  *var_len,
            WriteMethod **write_method)
{
    /* variables we may use later */
    UI32_T compc=0;
    oid compl[VOICEVLANOUIENTRY_INSTANCE_LEN] = {0};
    oid best_inst[VOICEVLANOUIENTRY_INSTANCE_LEN] = {0};
    int i;
    ADD_MGR_VoiceVlanOui_T  entry;
    switch(vp->magic)
    {
    case LEAF_voiceVlanOuiMask:
        *write_method = write_voiceVlanOuiMask;
        break;
    case LEAF_voiceVlanOuiDescription:
        *write_method = write_voiceVlanOuiDescription;
        break;
    case LEAF_voiceVlanOuiStatus:
        *write_method = write_voiceVlanOuiStatus;
        break;
    default:
        *write_method = 0;
        break;
    }

    /*check compc, retrive compl*/
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,compl, VOICEVLANOUIENTRY_INSTANCE_LEN);

    memset(&entry, 0, sizeof(entry));

    if (exact)/*get,set*/
    {

        /* get index */
        if(voiceVlanOuiTable_OidIndexToData(exact,compc,compl, entry.oui)==FALSE)
        {
            return NULL;
        }

        /*get data
         */
        if (ADD_PMGR_GetOuiEntry(&entry)!=TRUE)
        {
            return NULL;
        }
    }
    else/*getnext*/
    {

        /*get index*/
        voiceVlanOuiTable_OidIndexToData(exact,compc,compl, entry.oui);
        /* check the length of inputing index,if <1 we should try get {0.0.0.0.0...}
         */
        if (compc< 1)
        {
            /* get data */
            if ( ADD_PMGR_GetOuiEntry(&entry)!=TRUE)
            {
                memset(entry.oui, 255, 6);

                /*get next data*/
                if ( ADD_PMGR_GetNextOuiEntry(&entry)!=TRUE)
                {
                    return NULL;
                }
            }
        }
        else
        {
            /*get next data*/
            if ( ADD_PMGR_GetNextOuiEntry(&entry)!=TRUE)
            {
                return NULL;
            }
        }
    }

    memcpy(name, vp->name, vp->namelen*sizeof(oid));
    /* assign data to the oid index
     */

    for( i=0;i< SIZE_voiceVlanOuiAddress ;i++)
    {
        best_inst[0+i]=entry.oui[i];
    }
    memcpy(name+vp->namelen,best_inst,VOICEVLANOUIENTRY_INSTANCE_LEN*sizeof(oid));
    *length = vp->namelen+VOICEVLANOUIENTRY_INSTANCE_LEN ;

    /* this is where we do the value assignments for the mib results.
     */
    switch(vp->magic) {

    case LEAF_voiceVlanOuiAddress:
        *var_len = SIZE_voiceVlanOuiAddress;
        memcpy(return_buf, entry.oui,*var_len);
        return (u_char*)return_buf;
    case LEAF_voiceVlanOuiMask:
        *var_len = SIZE_voiceVlanOuiMask;
        memcpy(return_buf, entry.mask,*var_len);
        return (u_char*)return_buf;
    case LEAF_voiceVlanOuiDescription:
        *var_len  =   strlen(entry.description);
        memcpy(return_buf, entry.description,*var_len);
        return (u_char*)return_buf;
    case LEAF_voiceVlanOuiStatus:
        *var_len = sizeof(long_return);
        long_return = 1;
        return (u_char *) &long_return;
    default:
      ERROR_MSG("");
    }
    return NULL;
}

int
write_voiceVlanOuiMask(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{

    switch ( action ) {

        case RESERVE1:

          if (var_val_type != ASN_OCTET_STR)
          {
              return SNMP_ERR_WRONGTYPE;
          }
              if (var_val_len != SIZE_voiceVlanOuiMask)
              {
                  return SNMP_ERR_WRONGLENGTH;
              }
          break;

        case RESERVE2:
          break;

        case FREE:
          break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
            UI8_T byte_buffer[SIZE_voiceVlanOuiMask]={0};
            UI8_T voiceVlanOuiAddress[SIZE_voiceVlanOuiAddress] = {0};

            if(voiceVlanOuiTable_OidIndexToData(TRUE,name_len-oid_name_length,&(name[oid_name_length]), voiceVlanOuiAddress)==FALSE)
                return SNMP_ERR_COMMITFAILED;
            memcpy(byte_buffer,var_val,var_val_len);
            if(ADD_PMGR_SetOuiMaskAddress( voiceVlanOuiAddress, byte_buffer) != TRUE)
                return SNMP_ERR_COMMITFAILED;
        }
            break;

        case UNDO:
          break;

        case COMMIT:
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_voiceVlanOuiDescription(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{

    switch ( action ) {

        case RESERVE1:

          if (var_val_type != ASN_OCTET_STR)
          {
              return SNMP_ERR_WRONGTYPE;
          }
              if (var_val_len< MINSIZE_voiceVlanOuiDescription ||var_val_len > MAXSIZE_voiceVlanOuiDescription)
              {
                  return SNMP_ERR_WRONGLENGTH;
              }
          break;

        case RESERVE2:
          break;

        case FREE:
          break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
            UI8_T byte_buffer[MAXSIZE_voiceVlanOuiDescription+1]={0};
            UI8_T voiceVlanOuiAddress[SIZE_voiceVlanOuiAddress] = {0};

            if(voiceVlanOuiTable_OidIndexToData(TRUE,name_len-oid_name_length,&(name[oid_name_length]), voiceVlanOuiAddress)==FALSE)
                return SNMP_ERR_COMMITFAILED;
            memcpy(byte_buffer,var_val,var_val_len);
            byte_buffer[var_val_len]='\0';
            if(ADD_PMGR_SetOuiDescription( voiceVlanOuiAddress, byte_buffer) != TRUE)
                return SNMP_ERR_COMMITFAILED;
        }
            break;

        case UNDO:
          break;

        case COMMIT:
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_voiceVlanOuiStatus(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{

    switch ( action ) {

        case RESERVE1:

          if (var_val_type != ASN_INTEGER)
          {
              return SNMP_ERR_WRONGTYPE;
          }
          break;

        case RESERVE2:
            switch ( *(long *)var_val )
            {
                case VAL_voiceVlanOuiStatus_valid:
                    break;
                case VAL_voiceVlanOuiStatus_invalid:
                    break;
                default:
                    return SNMP_ERR_WRONGVALUE;
            }
          break;

        case FREE:
          break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
            I32_T value=0;
            UI8_T voiceVlanOuiAddress[SIZE_voiceVlanOuiAddress] = {0};

            if(voiceVlanOuiTable_OidIndexToData(TRUE,name_len-oid_name_length,&(name[oid_name_length]), voiceVlanOuiAddress)==FALSE)
                return SNMP_ERR_COMMITFAILED;
            value = *(long *)var_val;
            if(ADD_PMGR_SetOuiState( voiceVlanOuiAddress, value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
        }
            break;

        case UNDO:
          break;

        case COMMIT:
          break;
    }
    return SNMP_ERR_NOERROR;
}

#define VOICEVLANPORTENTRY_INSTANCE_LEN  1

BOOL_T voiceVlanPortTable_OidIndexToData(UI32_T exact, UI32_T compc,
            oid * compl ,  UI32_T *voiceVlanPortIfIndex)
{
    /* get or write
     */
    if(exact)
    {

        /* check the index length
         */
        if(compc != VOICEVLANPORTENTRY_INSTANCE_LEN) /* the constant size index*/
        {
            return FALSE;
        }
    }
    *voiceVlanPortIfIndex=compl[0];
    return TRUE;
}

/*
 * var_voiceVlanPortTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *
var_voiceVlanPortTable(struct variable *vp,
            oid     *name,
            size_t  *length,
            int     exact,
            size_t  *var_len,
            WriteMethod **write_method)
{
    /* variables we may use later */
    UI32_T compc=0;
    oid compl[VOICEVLANPORTENTRY_INSTANCE_LEN] = {0};
    oid best_inst[VOICEVLANPORTENTRY_INSTANCE_LEN] = {0};
    UI32_T lport = 0, lldp_state = 0, mode = 0, oui_stat = 0, security_stat = 0;
    I32_T remain_age = 0;
    UI8_T priority = 0;
    char  arRemain[16] = {0};
    switch(vp->magic)
    {
    case LEAF_voiceVlanPortMode:
        *write_method = write_voiceVlanPortMode;
        break;
    case LEAF_voiceVlanPortSecurity:
        *write_method = write_voiceVlanPortSecurity;
        break;

#if (SYS_CPNT_ADD_CONFIGURABLE_PRIORTIY == TRUE)
    case LEAF_voiceVlanPortPriority:
        *write_method = write_voiceVlanPortPriority;
        break;
#endif /*#if (SYS_CPNT_ADD_CONFIGURABLE_PRIORTIY == TRUE)*/

#if (SYS_CPNT_ADD_SUPPORT_LLDP == TRUE)
    case LEAF_voiceVlanPortRuleOui:
        *write_method = write_voiceVlanPortRuleOui;
        break;
    case LEAF_voiceVlanPortRuleLldp:
        *write_method = write_voiceVlanPortRuleLldp;
        break;
#endif /*#if (SYS_CPNT_ADD_SUPPORT_LLDP == TRUE)*/

    default:
        *write_method = 0;
        break;
    }

    /*check compc, retrive compl*/
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,compl, VOICEVLANPORTENTRY_INSTANCE_LEN);


    if (exact)/*get,set*/
    {

        /* get index */
        if(voiceVlanPortTable_OidIndexToData(exact,compc,compl, &lport)==FALSE)
        {
            return NULL;
        }

        /*get data
         */
        if (SWCTRL_POM_LogicalPortExisting(lport)!=TRUE)
        {
            return NULL;
        }
    }
    else/*getnext*/
    {

        /*get index*/
        voiceVlanPortTable_OidIndexToData(exact,compc,compl, &lport);
        /* check the length of inputing index,if <1 we should try get {0.0.0.0.0...}
         */
        if (compc< 1)
        {
            /* get data */
            if ( SWCTRL_POM_LogicalPortExisting(lport)!=TRUE)
            {

                /*get next data*/
                if ( SWCTRL_LPORT_UNKNOWN_PORT == SWCTRL_POM_GetNextLogicalPort(&lport))
                {
                    return NULL;
                }
            }
        }
        else
        {

            /*get next data*/
            if ( SWCTRL_LPORT_UNKNOWN_PORT == SWCTRL_POM_GetNextLogicalPort(&lport))
            {
                return NULL;
            }
        }
    }

    memcpy(name, vp->name, vp->namelen*sizeof(oid));
    /* assign data to the oid index
     */

    best_inst[0]=lport;
    memcpy(name+vp->namelen,best_inst,VOICEVLANPORTENTRY_INSTANCE_LEN*sizeof(oid));
    *length = vp->namelen+VOICEVLANPORTENTRY_INSTANCE_LEN ;

    /* this is where we do the value assignments for the mib results.
     */
    switch(vp->magic) {

#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    case LEAF_voiceVlanPortIfIndex:
        *var_len = sizeof(long_return);
        long_return = lport;
        return (u_char *) &long_return;
#endif
    case LEAF_voiceVlanPortMode:
        ADD_PMGR_GetVoiceVlanPortMode(lport, &mode);
        *var_len = sizeof(long_return);
        long_return = mode;
        return (u_char *) &long_return;
    case LEAF_voiceVlanPortSecurity:
        ADD_PMGR_GetVoiceVlanPortSecurityState(lport, &security_stat);
        *var_len = sizeof(long_return);
        long_return = security_stat;
        return (u_char *) &long_return;

#if (SYS_CPNT_ADD_CONFIGURABLE_PRIORTIY == TRUE)
    case LEAF_voiceVlanPortPriority:
        ADD_PMGR_GetVoiceVlanPortPriority(lport, &priority);
        *var_len = sizeof(long_return);
        long_return = (UI32_T)priority;
        return (u_char *) &long_return;
#endif /*#if (SYS_CPNT_ADD_CONFIGURABLE_PRIORTIY == TRUE)*/

#if (SYS_CPNT_ADD_SUPPORT_LLDP == TRUE)
    case LEAF_voiceVlanPortRuleOui:
        ADD_PMGR_GetVoiceVlanPortOuiRuleState(lport, &oui_stat);
        *var_len = sizeof(long_return);
        long_return = oui_stat;
        return (u_char *) &long_return;
    case LEAF_voiceVlanPortRuleLldp:
        ADD_PMGR_GetVoiceVlanPortLldpRuleState(lport, &lldp_state);
        *var_len = sizeof(long_return);
        long_return = lldp_state;
        return (u_char *) &long_return;
#endif /*#if (SYS_CPNT_ADD_SUPPORT_LLDP == TRUE)*/

    case LEAF_voiceVlanPortRemainAge:
        ADD_PMGR_GetVoiceVlanPortRemainAge(lport, &remain_age);
        if (remain_age < 0)
        {
            sprintf(arRemain, "%s",
                    (remain_age == ADD_TYPE_VOICE_VLAN_ERROR_NA) ? "NA" :
                    (remain_age == ADD_TYPE_VOICE_VLAN_ERROR_NO_START) ? "Not Start" : "??");
        }
        else if (remain_age == 0)
        {
            sprintf(arRemain, "%s", "< 1");
        }
        else
        {
            sprintf(arRemain, "%ld", remain_age);
        }
        *var_len = strlen(arRemain);
        memcpy(return_buf, arRemain, *var_len);
        return (u_char*)return_buf;

    default:
      ERROR_MSG("");
    }
    return NULL;
}

int
write_voiceVlanPortMode(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{

    switch ( action ) {

        case RESERVE1:

          if (var_val_type != ASN_INTEGER)
          {
              return SNMP_ERR_WRONGTYPE;
          }
          break;

        case RESERVE2:
            switch ( *(long *)var_val )
            {
                case VAL_voiceVlanPortMode_auto:
                    break;
                case VAL_voiceVlanPortMode_manual:
                    break;
                case VAL_voiceVlanPortMode_none:
                    break;
                default:
                    return SNMP_ERR_WRONGVALUE;
            }
          break;

        case FREE:
          break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
            I32_T value=0;
            UI32_T voiceVlanPortIfIndex = 0;

            if(voiceVlanPortTable_OidIndexToData(TRUE,name_len-oid_name_length,&(name[oid_name_length]), &voiceVlanPortIfIndex)==FALSE)
                return SNMP_ERR_COMMITFAILED;
            value = *(long *)var_val;
            if(ADD_PMGR_SetVoiceVlanPortMode( voiceVlanPortIfIndex, value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
        }
            break;

        case UNDO:
          break;

        case COMMIT:
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_voiceVlanPortSecurity(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{

    switch ( action ) {

        case RESERVE1:

          if (var_val_type != ASN_INTEGER)
          {
              return SNMP_ERR_WRONGTYPE;
          }
          break;

        case RESERVE2:
            switch ( *(long *)var_val )
            {
                case VAL_voiceVlanPortSecurity_enabled:
                    break;
                case VAL_voiceVlanPortSecurity_disabled:
                    break;
                default:
                    return SNMP_ERR_WRONGVALUE;
            }
          break;

        case FREE:
          break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
            I32_T value=0;
            UI32_T voiceVlanPortIfIndex = 0;

            if(voiceVlanPortTable_OidIndexToData(TRUE,name_len-oid_name_length,&(name[oid_name_length]), &voiceVlanPortIfIndex)==FALSE)
                return SNMP_ERR_COMMITFAILED;
            value = *(long *)var_val;
            if(ADD_PMGR_SetVoiceVlanPortSecurityState( voiceVlanPortIfIndex, value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
        }
            break;

        case UNDO:
          break;

        case COMMIT:
          break;
    }
    return SNMP_ERR_NOERROR;
}

#if (SYS_CPNT_ADD_CONFIGURABLE_PRIORTIY == TRUE)
int
write_voiceVlanPortPriority(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{

    switch ( action ) {

        case RESERVE1:

          if (var_val_type != ASN_INTEGER)
          {
              return SNMP_ERR_WRONGTYPE;
          }
          break;

        case RESERVE2:

            if (*(long *)var_val< MIN_voiceVlanPortPriority ||*(long *)var_val > MAX_voiceVlanPortPriority)
            {
                return SNMP_ERR_WRONGVALUE;
            }
          break;

        case FREE:
          break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
            I32_T value=0;
            UI32_T voiceVlanPortIfIndex = 0;

            if(voiceVlanPortTable_OidIndexToData(TRUE,name_len-oid_name_length,&(name[oid_name_length]), &voiceVlanPortIfIndex)==FALSE)
                return SNMP_ERR_COMMITFAILED;
            value = *(long *)var_val;
            if(ADD_PMGR_SetVoiceVlanPortPriority( voiceVlanPortIfIndex, value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
        }
            break;

        case UNDO:
          break;

        case COMMIT:
          break;
    }
    return SNMP_ERR_NOERROR;
}
#endif /*#if (SYS_CPNT_ADD_CONFIGURABLE_PRIORTIY == TRUE)*/

#if (SYS_CPNT_ADD_SUPPORT_LLDP == TRUE)
int
write_voiceVlanPortRuleOui(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{

    switch ( action ) {

        case RESERVE1:

          if (var_val_type != ASN_INTEGER)
          {
              return SNMP_ERR_WRONGTYPE;
          }
          break;

        case RESERVE2:
            switch ( *(long *)var_val )
            {
                case VAL_voiceVlanPortRuleOui_enabled:
                    break;
                case VAL_voiceVlanPortRuleOui_disabled:
                    break;
                default:
                    return SNMP_ERR_WRONGVALUE;
            }
          break;

        case FREE:
          break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
            I32_T value=0;
            UI32_T voiceVlanPortIfIndex = 0;

            if(voiceVlanPortTable_OidIndexToData(TRUE,name_len-oid_name_length,&(name[oid_name_length]), &voiceVlanPortIfIndex)==FALSE)
                return SNMP_ERR_COMMITFAILED;
            value = *(long *)var_val;
            if(ADD_PMGR_SetVoiceVlanPortOuiRuleState( voiceVlanPortIfIndex, value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
        }
            break;

        case UNDO:
          break;

        case COMMIT:
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_voiceVlanPortRuleLldp(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{

    switch ( action ) {

        case RESERVE1:

          if (var_val_type != ASN_INTEGER)
          {
              return SNMP_ERR_WRONGTYPE;
          }
          break;

        case RESERVE2:
            switch ( *(long *)var_val )
            {
                case VAL_voiceVlanPortRuleLldp_enabled:
                    break;
                case VAL_voiceVlanPortRuleLldp_disabled:
                    break;
                default:
                    return SNMP_ERR_WRONGVALUE;
            }
          break;

        case FREE:
          break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
            I32_T value=0;
            UI32_T voiceVlanPortIfIndex = 0;

            if(voiceVlanPortTable_OidIndexToData(TRUE,name_len-oid_name_length,&(name[oid_name_length]), &voiceVlanPortIfIndex)==FALSE)
                return SNMP_ERR_COMMITFAILED;
            value = *(long *)var_val;
            if(ADD_PMGR_SetVoiceVlanPortLldpRuleState( voiceVlanPortIfIndex, value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
        }
            break;

        case UNDO:
          break;

        case COMMIT:
          break;
    }
    return SNMP_ERR_NOERROR;
}
#endif /*#if (SYS_CPNT_ADD_SUPPORT_LLDP == TRUE)*/
#endif

#define VLANSTATICENTRY_INSTANCE_LEN  1

BOOL_T vlanStaticTable_OidIndexToData(UI32_T exact, UI32_T compc,
    oid *compl, UI32_T *index_p)
{
    /* get or set
     */
    if (exact)
    {
        /* check the index length
         */
        if (compc != VLANSTATICENTRY_INSTANCE_LEN) /* the constant size index */
        {
            return FALSE;
        }
    }

    *index_p = compl[0];

    return TRUE;
}

/*
 * var_vlanStaticTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *var_vlanStaticTable(struct variable *vp,
    oid *name,
    size_t *length,
    int exact,
    size_t *var_len,
    WriteMethod **write_method)
{
    UI32_T compc = 0;
    UI32_T vid;
    oid compl[VLANSTATICENTRY_INSTANCE_LEN] = {0};
    oid best_inst[VLANSTATICENTRY_INSTANCE_LEN] = {0};
    VLAN_OM_Dot1qVlanCurrentEntry_T entry;

    switch (vp->magic)
    {
        case LEAF_vlanStaticInterfaceType:
            *write_method = write_vlanStaticInterfaceType;
            break;

        default:
            *write_method = 0;
            break;
    }

    /* check compc, retrive compl
     */
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl, VLANSTATICENTRY_INSTANCE_LEN);

    memset(&entry, 0, sizeof(entry));

    if (exact) /* get or set */
    {
        if (vlanStaticTable_OidIndexToData(exact, compc, compl, &vid) == FALSE)
        {
            return NULL;
        }

        if (VLAN_POM_GetDot1qVlanCurrentEntry(0, vid, &entry) != TRUE)
        {
            return NULL;
        }
    }
    else /* getnext */
    {
        vlanStaticTable_OidIndexToData(exact, compc, compl, &vid);

        /* check the length of inputing index,if < 1 we should try get
         * {0.0.0.0.0...}
         */
        if (compc < 1)
        {
            if (VLAN_POM_GetDot1qVlanCurrentEntry(0, vid, &entry) != TRUE)
            {
                if (VLAN_POM_GetNextDot1qVlanCurrentEntry(0, &vid, &entry) != TRUE)
                {
                    return NULL;
                }
            }
        }
        else
        {
            if (VLAN_POM_GetNextDot1qVlanCurrentEntry(0, &vid, &entry) != TRUE)
            {
                return NULL;
            }
        }
    }

    memcpy(name, vp->name, vp->namelen * sizeof(oid));

    /* assign data to the oid index
     */
    best_inst[0] = vid;
    memcpy(name + vp->namelen, best_inst, VLANSTATICENTRY_INSTANCE_LEN * sizeof(oid));
    *length = vp->namelen + VLANSTATICENTRY_INSTANCE_LEN;

    switch (vp->magic)
    {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case LEAF_vlanStaticIndex:
            *var_len = sizeof(long_return);
            long_return = vid;
            return (u_char *) &long_return;
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

        case LEAF_vlanStaticInterfaceType:
            *var_len = sizeof(long_return);

            switch (entry.if_entry.ifType)
            {
                case VLAN_L2_IFTYPE:
                    long_return = VAL_vlanStaticInterfaceType_l2vlan;
                    break;

                case VLAN_L3_IP_IFTYPE:
                    long_return = VAL_vlanStaticInterfaceType_l3ipvlan;
                    break;

            default:
                return NULL;
            }
            return (u_char *) &long_return;

        default:
            ERROR_MSG("");
    }

    return NULL;
}

int write_vlanStaticInterfaceType(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            switch (*(long *)var_val)
            {
                case VAL_vlanStaticInterfaceType_l2vlan:
                    break;

                case VAL_vlanStaticInterfaceType_l3ipvlan:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            I32_T value = 0;
            UI32_T vid = 0;

            if (vlanStaticTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &vid) == FALSE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            value = *(long *)var_val;

            switch (value)
            {
                case VAL_vlanStaticInterfaceType_l3ipvlan:
                    if (NETCFG_PMGR_IP_CreateL3If(vid) != NETCFG_TYPE_OK)
                    {
                        return SNMP_ERR_COMMITFAILED;
                    }
                    break;

                case VAL_vlanStaticInterfaceType_l2vlan:
                    if (NETCFG_PMGR_IP_DeleteL3If(vid) != NETCFG_TYPE_OK)
                    {
                        return SNMP_ERR_COMMITFAILED;
                    }
                    break;
                default:
                    return SNMP_ERR_COMMITFAILED;
            }
        }
            break;

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

#if (SYS_CPNT_PING == TRUE)
/********************************************
 ******************pingMgt*******************
 ********************************************
 */

int
do_pingIpAddress(netsnmp_mib_handler *handler,
              netsnmp_handler_registration *reginfo,
              netsnmp_agent_request_info *reqinfo,
              netsnmp_request_info *requests)
{
    UI32_T value;
    PING_TYPE_PingCtlEntry_T     data;

    memset(&data, 0, sizeof(PING_TYPE_PingCtlEntry_T));

    data.ping_ctl_owner_index_len = SYS_DFLT_PING_PRIVATE_MIB_ID_LEN;
    memcpy(data.ping_ctl_owner_index, SYS_DFLT_PING_PRIVATE_MIB_ID, SYS_DFLT_PING_PRIVATE_MIB_ID_LEN); /* KEY 1 */
    data.ping_ctl_test_name_len = SYS_DFLT_PING_PRIVATE_MIB_ID_LEN;
    memcpy(data.ping_ctl_test_name, SYS_DFLT_PING_PRIVATE_MIB_ID, SYS_DFLT_PING_PRIVATE_MIB_ID_LEN); /* KEY 2 */

    switch (reqinfo->mode)
    {
        case MODE_GET:
        {
            if ( PING_POM_GetCtlEntry(&data)!= PING_TYPE_OK)
            {
                return SNMP_ERR_GENERR;
            }

            IP_LIB_ArraytoUI32(data.ping_ctl_target_address.addr, &ipaddr_return);
            snmp_set_var_typed_value(requests->requestvb, ASN_IPADDRESS, (u_char *) &ipaddr_return, sizeof(ipaddr_return));

            break;
        }

        case MODE_SET_RESERVE1:
        {
            if (requests->requestvb->type != ASN_IPADDRESS)
            {
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_WRONGTYPE);
                break;
            }
        }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer
             */
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called.
             */
            break;

        case MODE_SET_ACTION:
        {
            L_INET_AddrIp_T inet_addr;

            memset(&inet_addr, 0, sizeof(inet_addr));
            value= *requests->requestvb->val.integer;
            IP_LIB_UI32toArray(value, inet_addr.addr);
            inet_addr.addrlen = SYS_ADPT_IPV4_ADDR_LEN;
            inet_addr.type = L_INET_ADDR_TYPE_IPV4;

            if (PING_PMGR_SetCtlTargetAddress(&data, &inet_addr) != PING_TYPE_OK)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            }
            break;
        }
        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage
             */
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object
             */
            break;

        default:
            /*
             * we should never get here, so this is a really bad error
             */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_pingPacketSize(netsnmp_mib_handler *handler,
              netsnmp_handler_registration *reginfo,
              netsnmp_agent_request_info *reqinfo,
              netsnmp_request_info *requests)
{
    UI32_T packet_size;

    PING_TYPE_PingCtlEntry_T     data;

    memset(&data, 0, sizeof(PING_TYPE_PingCtlEntry_T));

    data.ping_ctl_owner_index_len = SYS_DFLT_PING_PRIVATE_MIB_ID_LEN;
    memcpy(data.ping_ctl_owner_index, SYS_DFLT_PING_PRIVATE_MIB_ID, SYS_DFLT_PING_PRIVATE_MIB_ID_LEN); /* KEY 1 */
    data.ping_ctl_test_name_len = SYS_DFLT_PING_PRIVATE_MIB_ID_LEN;
    memcpy(data.ping_ctl_test_name, SYS_DFLT_PING_PRIVATE_MIB_ID, SYS_DFLT_PING_PRIVATE_MIB_ID_LEN); /* KEY 2 */

    switch (reqinfo->mode)
    {
        case MODE_GET:
        {
            if (PING_POM_GetCtlEntry(&data)!= PING_TYPE_OK)
            {
                return SNMP_ERR_GENERR;
            }

            long_return = data.ping_ctl_data_size;
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));

           break;
        }

       case MODE_SET_RESERVE1:
       {
            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_WRONGTYPE);
                break;
            }
            packet_size=(*requests->requestvb->val.integer);
            if((packet_size<MINSIZE_pingPacketSize)||(packet_size>MAXSIZE_pingPacketSize))
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_WRONGVALUE);

          break;
       }
       case MODE_SET_RESERVE2:
           /*
            * XXX malloc "undo" storage buffer
            */
           break;

       case MODE_SET_FREE:
           /*
            * XXX: free resources allocated in RESERVE1 and/or
            * RESERVE2.  Something failed somewhere, and the states
            * below won't be called.
            */
           break;

       case MODE_SET_ACTION:
       {
           packet_size = *requests->requestvb->val.integer;

           if (PING_PMGR_SetCtlDataSize(&data, packet_size)!= PING_TYPE_OK)
               netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
           break;
       }
       case MODE_SET_COMMIT:
           /*
            * XXX: delete temporary storage
            */
           break;

       case MODE_SET_UNDO:
           /*
            * XXX: UNDO and return to previous value for the object
            */
           break;

       default:
           /*
            * we should never get here, so this is a really bad error
            */
           return SNMP_ERR_GENERR;
       }

       return SNMP_ERR_NOERROR;
}

#define VAL_pingCtlAdminStatus_enabled  1L
#define VAL_pingCtlAdminStatus_disabled 2L

int
get_pingCompleted(netsnmp_mib_handler *handler,
                   netsnmp_handler_registration *reginfo,
                   netsnmp_agent_request_info *reqinfo,
                   netsnmp_request_info *requests)
{
    PING_TYPE_PingCtlEntry_T     data;

    memset(&data, 0, sizeof(PING_TYPE_PingCtlEntry_T));

    data.ping_ctl_owner_index_len = SYS_DFLT_PING_PRIVATE_MIB_ID_LEN;
    memcpy(data.ping_ctl_owner_index, SYS_DFLT_PING_PRIVATE_MIB_ID, SYS_DFLT_PING_PRIVATE_MIB_ID_LEN); /* KEY 1 */
    data.ping_ctl_test_name_len = SYS_DFLT_PING_PRIVATE_MIB_ID_LEN;
    memcpy(data.ping_ctl_test_name, SYS_DFLT_PING_PRIVATE_MIB_ID, SYS_DFLT_PING_PRIVATE_MIB_ID_LEN); /* KEY 2 */

    switch(reqinfo->mode)
    {

        case MODE_GET:
        {
            if ( PING_POM_GetCtlEntry( &data)!= PING_TYPE_OK)
                return SNMP_ERR_GENERR;

            switch(data.ping_ctl_admin_status)
            {
                case VAL_pingCtlAdminStatus_enabled:
                    long_return = 2; /* 2: false */
                    break;
                case VAL_pingCtlAdminStatus_disabled:
                    long_return = 1; /* 1: true */
                    break;
                default:
                    long_return = 1; /* 1: true */
            }

            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
        }
            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_pingAction(netsnmp_mib_handler *handler,
              netsnmp_handler_registration *reginfo,
              netsnmp_agent_request_info *reqinfo,
              netsnmp_request_info *requests)
{
    UI32_T value = 0;

    PING_TYPE_PingCtlEntry_T     data;

    memset(&data, 0, sizeof(PING_TYPE_PingCtlEntry_T));

    data.ping_ctl_owner_index_len = SYS_DFLT_PING_PRIVATE_MIB_ID_LEN;
    memcpy(data.ping_ctl_owner_index, SYS_DFLT_PING_PRIVATE_MIB_ID, SYS_DFLT_PING_PRIVATE_MIB_ID_LEN); /* KEY 1 */
    data.ping_ctl_test_name_len = SYS_DFLT_PING_PRIVATE_MIB_ID_LEN;
    memcpy(data.ping_ctl_test_name, SYS_DFLT_PING_PRIVATE_MIB_ID, SYS_DFLT_PING_PRIVATE_MIB_ID_LEN); /* KEY 2 */

    switch (reqinfo->mode)
    {
        case MODE_GET:
        {
            long_return = VAL_pingAction_noAction;
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));

            break;
        }
        case MODE_SET_RESERVE1:
        {
            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_WRONGTYPE);
                break;
            }
            value=(*requests->requestvb->val.integer);
            if((value!=VAL_pingAction_noAction)&&(value!=VAL_pingAction_pingStart))
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_WRONGVALUE);

          break;
       }
       case MODE_SET_RESERVE2:
           /*
            * XXX malloc "undo" storage buffer
            */
           break;

       case MODE_SET_FREE:
           /*
            * XXX: free resources allocated in RESERVE1 and/or
            * RESERVE2.  Something failed somewhere, and the states
            * below won't be called.
            */
           break;

       case MODE_SET_ACTION:
       {
           switch ( *requests->requestvb->val.integer )
           {
               case VAL_pingAction_noAction:
                   value = VAL_pingCtlAdminStatus_disabled;
                   break;
               case VAL_pingAction_pingStart:
                   value = VAL_pingCtlAdminStatus_enabled;
                   break;
               default:
                   netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
           }

           if (PING_PMGR_SetCtlAdminStatus(&data, value) != PING_TYPE_OK)
               netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);

           break;
       }
       case MODE_SET_COMMIT:
           /*
            * XXX: delete temporary storage
            */
           break;

       case MODE_SET_UNDO:
           /*
            * XXX: UNDO and return to previous value for the object
            */
           break;

       default:
           /*
            * we should never get here, so this is a really bad error
            */
           return SNMP_ERR_GENERR;
       }

       return SNMP_ERR_NOERROR;

}

int
do_pingProbeCount(netsnmp_mib_handler *handler,
              netsnmp_handler_registration *reginfo,
              netsnmp_agent_request_info *reqinfo,
              netsnmp_request_info *requests)
{
    UI32_T value;

    PING_TYPE_PingCtlEntry_T     data;

    memset(&data, 0, sizeof(PING_TYPE_PingCtlEntry_T));

    data.ping_ctl_owner_index_len = SYS_DFLT_PING_PRIVATE_MIB_ID_LEN;
    memcpy(data.ping_ctl_owner_index, SYS_DFLT_PING_PRIVATE_MIB_ID, SYS_DFLT_PING_PRIVATE_MIB_ID_LEN); /* KEY 1 */
    data.ping_ctl_test_name_len = SYS_DFLT_PING_PRIVATE_MIB_ID_LEN;
    memcpy(data.ping_ctl_test_name, SYS_DFLT_PING_PRIVATE_MIB_ID, SYS_DFLT_PING_PRIVATE_MIB_ID_LEN); /* KEY 2 */

    switch (reqinfo->mode)
    {
        case MODE_GET:
        {
            if (PING_POM_GetCtlEntry(&data)!= PING_TYPE_OK)
            {
                return SNMP_ERR_GENERR;
            }

            long_return = data.ping_ctl_probe_count;
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));

           break;
        }

       case MODE_SET_RESERVE1:
       {
            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_WRONGTYPE);
                break;
            }
           value=(*requests->requestvb->val.integer);
           if((value<MIN_pingProbeCount)||(value>MAX_pingProbeCount))
               netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_WRONGVALUE);

           break;
       }
       case MODE_SET_RESERVE2:
           /*
            * XXX malloc "undo" storage buffer
            */
           break;

       case MODE_SET_FREE:
           /*
            * XXX: free resources allocated in RESERVE1 and/or
            * RESERVE2.  Something failed somewhere, and the states
            * below won't be called.
            */
           break;

       case MODE_SET_ACTION:
       {
           value = *requests->requestvb->val.integer;

           if (PING_PMGR_SetCtlProbeCount(&data, value) != PING_TYPE_OK)
               netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);

           break;
       }
       case MODE_SET_COMMIT:
           /*
            * XXX: delete temporary storage
            */
           break;

       case MODE_SET_UNDO:
           /*
            * XXX: UNDO and return to previous value for the object
            */
           break;

       default:
           /*
            * we should never get here, so this is a really bad error
            */
           return SNMP_ERR_GENERR;
       }

       return SNMP_ERR_NOERROR;
}

int
get_pingSentPackets(netsnmp_mib_handler *handler,
                   netsnmp_handler_registration *reginfo,
                   netsnmp_agent_request_info *reqinfo,
                   netsnmp_request_info *requests)
{
    PING_TYPE_PingResultsEntry_T data;

    memset(&data, 0, sizeof(PING_TYPE_PingResultsEntry_T));

    data.ping_ctl_owner_index_len = SYS_DFLT_PING_PRIVATE_MIB_ID_LEN;
    memcpy(data.ping_ctl_owner_index, SYS_DFLT_PING_PRIVATE_MIB_ID, SYS_DFLT_PING_PRIVATE_MIB_ID_LEN); /* KEY 1 */
    data.ping_ctl_test_name_len = SYS_DFLT_PING_PRIVATE_MIB_ID_LEN;
    memcpy(data.ping_ctl_test_name, SYS_DFLT_PING_PRIVATE_MIB_ID, SYS_DFLT_PING_PRIVATE_MIB_ID_LEN); /* KEY 2 */

    switch(reqinfo->mode)
    {

        case MODE_GET:
        {
            if ( PING_POM_GetResultsEntry(&data)!= PING_TYPE_OK)
            {
                long_return = 0;
            }
            else
            {
                long_return = data.ping_results_sent_probes;
            }
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
        }
            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_pingReceivedPackets(netsnmp_mib_handler *handler,
                   netsnmp_handler_registration *reginfo,
                   netsnmp_agent_request_info *reqinfo,
                   netsnmp_request_info *requests)
{
    PING_TYPE_PingResultsEntry_T     data;

    memset(&data, 0, sizeof(PING_TYPE_PingResultsEntry_T));

    data.ping_ctl_owner_index_len = SYS_DFLT_PING_PRIVATE_MIB_ID_LEN;
    memcpy(data.ping_ctl_owner_index, SYS_DFLT_PING_PRIVATE_MIB_ID, SYS_DFLT_PING_PRIVATE_MIB_ID_LEN); /* KEY 1 */
    data.ping_ctl_test_name_len = SYS_DFLT_PING_PRIVATE_MIB_ID_LEN;
    memcpy(data.ping_ctl_test_name, SYS_DFLT_PING_PRIVATE_MIB_ID, SYS_DFLT_PING_PRIVATE_MIB_ID_LEN); /* KEY 2 */

    switch(reqinfo->mode)
    {
        case MODE_GET:
        {
            if ( PING_POM_GetResultsEntry( &data)!= PING_TYPE_OK)
            {
                long_return = 0;
            }
            else
            {
                long_return = data.ping_results_probe_responses;
            }
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
        }
            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_pingLossRate(netsnmp_mib_handler *handler,
                   netsnmp_handler_registration *reginfo,
                   netsnmp_agent_request_info *reqinfo,
                   netsnmp_request_info *requests)
{
    //UI32_T value;
    PING_TYPE_PingResultsEntry_T     data;

    memset(&data, 0, sizeof(PING_TYPE_PingResultsEntry_T));

    data.ping_ctl_owner_index_len = SYS_DFLT_PING_PRIVATE_MIB_ID_LEN;
    memcpy(data.ping_ctl_owner_index, SYS_DFLT_PING_PRIVATE_MIB_ID, SYS_DFLT_PING_PRIVATE_MIB_ID_LEN); /* KEY 1 */
    data.ping_ctl_test_name_len = SYS_DFLT_PING_PRIVATE_MIB_ID_LEN;
    memcpy(data.ping_ctl_test_name, SYS_DFLT_PING_PRIVATE_MIB_ID, SYS_DFLT_PING_PRIVATE_MIB_ID_LEN); /* KEY 2 */

    switch(reqinfo->mode)
    {
        case MODE_GET:
        {
            //UI8_T buffer[4]={0};

            if ( PING_POM_GetResultsEntry( &data)!= PING_TYPE_OK)
            {
                long_return = 100;
            }
            else
            {
                if (0 == data.ping_results_sent_probes)
                {
                    long_return = 0;
                }
                else
                {
                long_return = ((data.ping_results_sent_probes - data.ping_results_probe_responses)*100)/data.ping_results_sent_probes;
            }
            }
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
        }
            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

#define PINGHISTORYENTRY_INSTANCE_LEN  1

BOOL_T pingHistoryTable_OidIndexToData(UI32_T exact, UI32_T compc,
            oid * compl,  UI32_T *pingHistoryIndex)
{
    /* get or write */
    if (exact)
    {
        /* check the index length */
        if (compc != PINGHISTORYENTRY_INSTANCE_LEN) /* the constant size index */
        {
            return FALSE;
        }
    }
    *pingHistoryIndex = compl[0];

    return TRUE;
}

/*
 * var_pingHistoryTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *
var_pingHistoryTable(struct variable *vp,
            oid     *name,
            size_t  *length,
            int     exact,
            size_t  *var_len,
            WriteMethod **write_method)
{
    /* variables we may use later */
    UI32_T compc = 0;
    oid compl[PINGHISTORYENTRY_INSTANCE_LEN] = {0};
    oid best_inst[PINGHISTORYENTRY_INSTANCE_LEN] = {0};
    PING_TYPE_PingProbeHistoryEntry_T entry;

    memset(&entry, 0, sizeof(entry));

    entry.ping_ctl_owner_index_len = SYS_DFLT_PING_PRIVATE_MIB_ID_LEN;
    memcpy(entry.ping_ctl_owner_index, SYS_DFLT_PING_PRIVATE_MIB_ID, SYS_DFLT_PING_PRIVATE_MIB_ID_LEN); /* KEY 1 */
    entry.ping_ctl_test_name_len = SYS_DFLT_PING_PRIVATE_MIB_ID_LEN;
    memcpy(entry.ping_ctl_test_name, SYS_DFLT_PING_PRIVATE_MIB_ID, SYS_DFLT_PING_PRIVATE_MIB_ID_LEN); /* KEY 2 */

    switch (vp->magic)
    {
        default:
            *write_method = 0;
            break;
    }

    /* check compc, retrive compl */
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,
                           compl, PINGHISTORYENTRY_INSTANCE_LEN);

    if (exact) /* get,set */
    {
        /* get index */
        if (pingHistoryTable_OidIndexToData(exact, compc, compl, &entry.ping_probe_history_index) == FALSE)
        {
            return NULL;
        }

        /* get data */
        if (PING_POM_GetProbeHistoryEntry(&entry) != PING_TYPE_OK)
        {
            return NULL;
        }
    }
    else /* getnext */
    {
        /* get index */
        pingHistoryTable_OidIndexToData(exact, compc, compl, &entry.ping_probe_history_index);

        /* check the length of inputing index,if < 1 we should try get
         * {0.0.0.0.0...}
         */
        if (compc < 1)
        {
            /* get data */
            if (PING_POM_GetProbeHistoryEntry(&entry) != PING_TYPE_OK)
            {
                /* get next data */
                if (PING_POM_GetNextProbeHistoryEntry(&entry) != PING_TYPE_OK)
                {
                    return NULL;
                }
            }
        }
        else
        {
            /* get next data */
            if (PING_POM_GetNextProbeHistoryEntry(&entry) != PING_TYPE_OK)
            {
                return NULL;
            }
        }
    }

    memcpy(name, vp->name, vp->namelen*sizeof(oid));

    /* assign data to the oid index */
    best_inst[0] = entry.ping_probe_history_index;
    memcpy(name + vp->namelen, best_inst,
           PINGHISTORYENTRY_INSTANCE_LEN * sizeof(oid));
    *length = vp->namelen + PINGHISTORYENTRY_INSTANCE_LEN ;

    /* this is where we do the value assignments for the mib results. */
    switch (vp->magic)
    {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case PINGHISTORYINDEX:
            *var_len = sizeof(long_return);
            long_return = entry.ping_probe_history_index;
            return (u_char *) &long_return;

#endif
        case PINGHISTORYRESPONSE:
            *var_len = sizeof(long_return);
            long_return = entry.ping_probe_history_response;
            return (u_char *) &long_return;

        default:
            ERROR_MSG("");
    }

    return NULL;
}

#endif/* #if (SYS_CPNT_PING == TRUE) */

/********************************************
 ***************priorityMgt******************
 ********************************************
 */
#if 1
int
do_prioIpPrecRestoreDefault(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
           /* Acoording to the Mib definition, it always return 0 when read */
                    long_return = 0;
                    snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));

            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
            }
            break;

        case MODE_SET_RESERVE2:
            if (*requests->requestvb->val.integer > SYS_ADPT_TOTAL_NBR_OF_LPORT)
            {
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_INCONSISTENTVALUE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */

             {
                UI32_T value;
                value = (*requests->requestvb->val.integer);
                 if (L4_PMGR_COS_DelIpPrecedenceLportAllEntry(value) != TRUE)
                       netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */

            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */

            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_prioIpDscpRestoreDefault(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
               /* Acoording to the Mib definition, it always return 0 when read */
                    long_return = 0;
                    snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
                    break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
            }
            break;

        case MODE_SET_RESERVE2:
            if (*requests->requestvb->val.integer > SYS_ADPT_TOTAL_NBR_OF_LPORT)
            {
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_INCONSISTENTVALUE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
              {
                UI32_T value;
                value = (*requests->requestvb->val.integer);
                 if (L4_PMGR_COS_DelDscpLportAllEntry(value) != TRUE)
                       netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */

            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */

            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}


int
do_prioIpPrecDscpStatus(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
           {
              COS_VM_MAPPING_FLAG_T prioIpPrecDscpStatus;
        /* Values:
         *  disabled(1)    = VAL_prioIpPrecDscpStatus_disabled
         *  precedence(2) = VAL_prioIpPrecDscpStatus_precedence
         *  dscp(3)       = VAL_prioIpPrecDscpStatus_dscp
         */
              if (L4_PMGR_COS_GetIpPrecedenceDscpMappingStatus(&prioIpPrecDscpStatus)!= TRUE)
                      return SNMP_ERR_GENERR;

              if (prioIpPrecDscpStatus == 0)
                   prioIpPrecDscpStatus = VAL_prioIpPrecDscpStatus_disabled;
                  long_return =prioIpPrecDscpStatus;
                     snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
             }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
            }
            break;

        case MODE_SET_RESERVE2:
            switch (*requests->requestvb->val.integer)
            {
                case VAL_prioIpPrecDscpStatus_disabled:
                    break;

                case VAL_prioIpPrecDscpStatus_precedence:
                    break;

                case VAL_prioIpPrecDscpStatus_dscp:
                    break;

                default:
                    netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
             {
                UI32_T value;
                value = (*requests->requestvb->val.integer);
                     if (L4_PMGR_COS_SetIpPrecedenceDscpMappingStatus(  value) != TRUE)
                       netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */

            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */

            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}


int
do_prioCopyIpPrec(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
              {

               memset(return_buf, 0, 1);
               snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, (u_char *) return_buf, 0);
           }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            if (requests->requestvb->type != ASN_OCTET_STR)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
            }

            if ((5 > requests->requestvb->val_len) || (requests->requestvb->val_len > SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST + 4))
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_INCONSISTENTVALUE);
            }
            break;

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
               {
                   UI32_T src_port;
                   int i;
                   UI8_T port_list[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST];

                 /* copy the first 4 byte for the src_port */
                   src_port = ( (UI32_T)requests->requestvb->val.string[0] << 24) |
                              ( (UI32_T)requests->requestvb->val.string[1] << 16) |
                              ( (UI32_T)requests->requestvb->val.string[2] << 8 ) |
                              ( (UI32_T)requests->requestvb->val.string[3]);
                   memcpy( port_list,
                          &requests->requestvb->val.string[4],
                           requests->requestvb->val_len-4);
                   for (i = requests->requestvb->val_len; i<SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST+4 ; i ++)
                       port_list[i-4] = 0;

                  if (L4_PMGR_COS_PortCopy(COS_VM_IPPRECEDENCE_MAP_TABLE, src_port, port_list)!= TRUE)
                  {
                      netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
                  }
            }
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */

            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */

            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}


int
do_prioCopyIpDscp(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
              {

               memset(return_buf, 0, 1);
               snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, (u_char *) return_buf, 0);
           }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            if (requests->requestvb->type != ASN_OCTET_STR)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
            }

            if ((5 > requests->requestvb->val_len) || (requests->requestvb->val_len > SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST + 4))
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_INCONSISTENTVALUE);
            }
            break;

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
               {
                   int i;
                   UI32_T src_port;
                   UI8_T port_list[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST];

                 /* copy the first 4 byte for the src_port */
                   src_port = ( (UI32_T)requests->requestvb->val.string[0] << 24) |
                              ( (UI32_T)requests->requestvb->val.string[1] << 16) |
                              ( (UI32_T)requests->requestvb->val.string[2] << 8 ) |
                              ( (UI32_T)requests->requestvb->val.string[3]);
                   memcpy( port_list,
                          &requests->requestvb->val.string[4],
                           requests->requestvb->val_len-4);
                   for (i = requests->requestvb->val_len; i<SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST+4 ; i ++)
                       port_list[i-4] = 0;

                  if (L4_PMGR_COS_PortCopy(COS_VM_DSCP_MAP_TABLE, src_port, port_list)!= TRUE)
                  {
                      netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
                  }
            }
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */

            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */

            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_prioIpPortEnableStatus(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
           {
              UI32_T  prioIpPortEnableStatus; /* COS_VM_TCPPORT_MAPPING_FLAG_T prioIpPortEnableStatus; */
        /* Values:
             *  enabled(1)  = VAL_prioIpPortEnableStatus_enabled
             *  disabled(2) = VAL_prioIpPortEnableStatus_disabled
             */
              if (L4_PMGR_COS_GetTcpPortMappingStatus(&prioIpPortEnableStatus)!= TRUE)
                      return SNMP_ERR_GENERR;

              if (prioIpPortEnableStatus == 0)
                   prioIpPortEnableStatus = VAL_prioIpPortEnableStatus_disabled;
                  long_return =prioIpPortEnableStatus;
                     snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
             }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
            }
            break;

        case MODE_SET_RESERVE2:
            switch (*requests->requestvb->val.integer)
            {
                case VAL_prioIpPortEnableStatus_enabled:
                    break;

                case VAL_prioIpPortEnableStatus_disabled:
                    break;

                default:
                    netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
             {
                UI32_T value;
                value = (*requests->requestvb->val.integer);
                     if (L4_PMGR_COS_SetTcpPortMappingStatus(  value) != TRUE)
                       netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */

            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */

            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
do_prioCopyIpPort(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
              {

               memset(return_buf, 0, 1);
               snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, (u_char *) return_buf, 0);
           }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            if (requests->requestvb->type != ASN_OCTET_STR)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
            }

            if ((5 > requests->requestvb->val_len) || (requests->requestvb->val_len > SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST + 4))
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_INCONSISTENTVALUE);
            }
            break;

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
               {
                   UI32_T src_port;
                   UI8_T port_list[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST];
                   int i;

                 /* copy the first 4 byte for the src_port */
                   src_port = ( (UI32_T)requests->requestvb->val.string[0] << 24) |
                              ( (UI32_T)requests->requestvb->val.string[1] << 16) |
                              ( (UI32_T)requests->requestvb->val.string[2] << 8 ) |
                              ( (UI32_T)requests->requestvb->val.string[3]);
                   memcpy( port_list,
                          &requests->requestvb->val.string[4],
                           requests->requestvb->val_len-4);
                   for (i = requests->requestvb->val_len; i<SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST+4 ; i ++)
                       port_list[i-4] = 0;

                  if (L4_PMGR_COS_PortCopy(COS_VM_TCP_PORT_MAP_TABLE, src_port, port_list)!= TRUE)
                  {
                      netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
                  }
            }
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */

            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */

            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
#endif
#if (SYS_CPNT_WRR_Q_MODE_PER_PORT_CTRL == FALSE)
int
do_prioQueueMode(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode)
    {
        case MODE_GET:
        {
            UI32_T mode;

            if (TRUE != L4_PMGR_QOS_GetPriorityEgressQueueMode(COS_TYPE_PRIORITY_USER,
                                                               &mode))
            {
                return SNMP_ERR_GENERR;
            }

            long_return = mode;
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
            break;
        }

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
        {
            UI32_T value;

            value = (*requests->requestvb->val.integer);

            if ((value != VAL_prioQueueMode_wrr) &&
                (value != VAL_prioQueueMode_strict) &&
#if (SYS_CPNT_SWCTRL_Q_MODE_DRR == TRUE)
                (value != VAL_prioQueueMode_drr) &&
                (value != VAL_prioQueueMode_sp_drr) &&
#endif
                (value != VAL_prioQueueMode_sp_wrr))
            {
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_WRONGVALUE);
            }
            break;
        }

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */

            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
             {
                 UI32_T mode;

                     mode = (*requests->requestvb->val.integer);

                     if (TRUE != L4_PMGR_QOS_SetPriorityEgressQueueMode(COS_TYPE_PRIORITY_USER,
                                                                        mode))
                     {
                         netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
                     }
            }
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */

            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */

            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
#endif
#if 1
/********************************************
 *************prioIpPrecTable****************
 ********************************************
 */
static int
header_prioIpPrecTable(struct variable *vp,
               oid * name,
               size_t * length,
               int exact, size_t * var_len, WriteMethod ** write_method,
               UI32_T *index1, UI32_T *index2)
{
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
    oid             newname[MAX_OID_LEN];
    int             result;
   UI32_T   cosvalue;
   UI32_T i1;
   UI8_T i2;
   BOOL_T return_val;
   oid  next_inst[2];


     memcpy((char *) newname, (char *) vp->name,
           (int) vp->namelen * sizeof(oid));

   i1=0;
   i2=0;

    /*
     * find "next" interface
     */

  while (  (return_val= L4_PMGR_COS_GetNextIpPrecedenceToCos(&i1, &i2, &cosvalue))==TRUE)
     {
       next_inst[0] =i1;
       next_inst[1] =i2;

        memcpy( (char*)&newname[oid_name_length], (char*) next_inst,  2*sizeof(oid));
        result =
            snmp_oid_compare(name, *length, newname,
                             (int) vp->namelen +2);
        if ((exact && (result == 0)) || (!exact && (result < 0)))
            break;
    }
    if (!return_val ) {
        return MATCH_FAILED;
    }
    memcpy((char *) name, (char *) newname,
           ((int) vp->namelen + 2) * sizeof(oid));
    *length = vp->namelen + 2;
    *var_len = sizeof(long);    /* default to 'long' results */
    *index1 = next_inst[0];
    *index2 = next_inst[1];
    return TRUE;

}

/*
 * var_prioIpPrecTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *
var_prioIpPrecTable(struct variable *vp,
            oid     *name,
            size_t  *length,
            int     exact,
            size_t  *var_len,
            WriteMethod **write_method)
{
    /* variables we may use later */

    UI32_T index1 = 0, index2 = 0, retval;

    UI32_T   cosvalue;



    /*Since this table allow for entry that does not exist, (creation). we need to know the write method first*/
    switch(vp->magic)
     {
   case PRIOIPPRECCOS:
        *write_method = write_prioIpPrecCos;
        break;
     default:
          *write_method =0;
     break;
    }

     retval  = header_prioIpPrecTable(vp, name, length, exact, var_len, write_method,  &index1,& index2);

    if (retval == MATCH_FAILED)
        return NULL;


   if (L4_PMGR_COS_GetIpPrecedenceToCos(index1, index2, &cosvalue)!= TRUE)
            return NULL;


    /*
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
 #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)

    case PRIOIPPRECPORT:
        long_return = index1;
        return (u_char*) &long_return;
    case PRIOIPPRECVALUE:
        long_return = index1;
        return (u_char*) &long_return;
  #endif
    case PRIOIPPRECCOS:
        *write_method = write_prioIpPrecCos;
         long_return = cosvalue;
        return (u_char*) &long_return;
    default:
      ERROR_MSG("");
    }
    return NULL;
}


int
write_prioIpPrecCos(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
   /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  2 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          value = *(long *)var_val;
          if ((value <0) || (value >7))
             return SNMP_ERR_WRONGVALUE;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
                  value = * (long *) var_val;
                if (L4_PMGR_COS_SetIpPrecedenceToCos(name[oid_name_length], (UI8_T) name[oid_name_length+1], value) != TRUE)
                         return SNMP_ERR_COMMITFAILED;
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

/********************************************
 *************prioIpDscpTable****************
 ********************************************
 */
#define PRIOIPDSCPENTRY_INSTANCE_LEN  2

BOOL_T prioIpDscpTable_OidIndexToData(UI32_T exact, UI32_T compc,
            oid * compl ,  UI32_T *prioIpDscpPort, UI8_T *prioIpDscpValue)
{

    /* get or write
     */
    if(exact)
    {

        /* check the index length
         */

        if(compc != PRIOIPDSCPENTRY_INSTANCE_LEN) /* the constant size index*/
        {
            return FALSE;
        }
    }

    *prioIpDscpPort=compl[0];

    if(compl[1]>MAX_prioIpDscpValue)
    {
        if(exact)
        {
            return FALSE;
        }
        else
        {
            *prioIpDscpValue=(UI8_T)MAX_prioIpDscpValue;
        }
        }
    else
    {
        *prioIpDscpValue = (UI8_T)compl[1];
    }
    return TRUE;
}

/*
 * var_prioIpDscpTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *
var_prioIpDscpTable(struct variable *vp,
            oid     *name,
            size_t  *length,
            int     exact,
            size_t  *var_len,
            WriteMethod **write_method)
{
    /* variables we may use later */
    UI32_T compc=0;
    oid compl[PRIOIPDSCPENTRY_INSTANCE_LEN];
    oid best_inst[PRIOIPDSCPENTRY_INSTANCE_LEN];
    UI32_T  cosvalue;
    UI32_T index1 = 0;
    UI8_T index2 = 0;

    /*Since this table allow for entry that does not exist, (creation). we need to know the write method first*/
    switch(vp->magic)
     {
   case PRIOIPDSCPCOS:
        *write_method = write_prioIpDscpCos;
        break;
   case PRIOIPDSCPSTATUS:
        *write_method = write_prioIpDscpStatus;
        break;
     default:
          *write_method =0;
     break;
    }
   /*check compc, retrive compl*/
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,compl, PRIOIPDSCPENTRY_INSTANCE_LEN);

    memset(&cosvalue, 0, sizeof(cosvalue));

    if (exact)/*get,set*/
    {
        if(prioIpDscpTable_OidIndexToData(exact,compc,compl, &index1, &index2)==FALSE)
        {
            return NULL;
        }

        /*get data
         */
        if (L4_PMGR_COS_GetDSCPToCos( index1, index2, &cosvalue)!=TRUE)
        {
            return NULL;
        }
    }
    else/*getnext*/
    {

        prioIpDscpTable_OidIndexToData(exact,compc,compl, &index1, &index2);
        /* check the length of inputing index,if <1 we should try get {0.0.0.0.0...}
         */

        /*get next data*/
        if ( L4_PMGR_COS_GetNextDSCPToCos( &index1, &index2, &cosvalue)!=TRUE)
        {
            return NULL;
        }
    }

    memcpy(name, vp->name, vp->namelen*sizeof(oid));
    /* assign data to the oid index
     */

    best_inst[0]=index1;
    best_inst[1]=index2;
    memcpy(name+vp->namelen,best_inst,PRIOIPDSCPENTRY_INSTANCE_LEN*sizeof(oid));
    *length = vp->namelen+PRIOIPDSCPENTRY_INSTANCE_LEN;
    *var_len = sizeof(long_return);

    /*
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic)
     {
    #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
   case  PRIOIPDSCPPORT:
        long_return = index1;
        return (u_char*) &long_return;
   case  PRIOIPDSCPVALUE:
         long_return = (UI32_T)index2;
        return (u_char*) &long_return;
    #endif
    case PRIOIPDSCPCOS:
        *write_method = write_prioIpDscpCos;
        long_return = cosvalue;
        return (u_char*) &long_return;
    case PRIOIPDSCPSTATUS:
    {
         BOOL_T status;

         if (L4_PMGR_COS_GetDSCPToCosStatus(index1, index2, &status)!= TRUE)
         {
            return NULL;
         }
         if (status == TRUE)
         {
             long_return = VAL_prioIpDscpStatus_enabled;
         }
         else if (status == FALSE)
         {
             long_return = VAL_prioIpDscpStatus_disabled;
         }
     }
    return (u_char*) &long_return;
    default:
      ERROR_MSG("");
    }
    return NULL;
}


int
write_prioIpDscpCos(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    UI32_T oid_name_length;

    oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;

     /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  2 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          value = *(long *)var_val;
          if ((value <0) || (value >7))
             return SNMP_ERR_WRONGVALUE;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
                    value = * (long *) var_val;
                if (L4_PMGR_COS_SetDSCPToCos(name[oid_name_length], (UI8_T) name[oid_name_length+1], value) != TRUE)
                         return SNMP_ERR_COMMITFAILED;
          break;
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_prioIpDscpStatus(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    UI32_T oid_name_length;

    oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;

     /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  2 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          value = *(long *)var_val;
          if ((value <VAL_prioIpDscpStatus_enabled) || (value >VAL_prioIpDscpStatus_disabled))
             return SNMP_ERR_WRONGVALUE;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
                    value = * (long *) var_val;

                if (value == VAL_prioIpDscpStatus_enabled)
                {
                    value = TRUE;
                }
                else if (value == VAL_prioIpDscpStatus_disabled)
                {
                    value = FALSE;
                }
                if (L4_PMGR_COS_SetDSCPToCosStatus(name[oid_name_length], (UI8_T) name[oid_name_length+1], (UI8_T)value) != TRUE)
                         return SNMP_ERR_COMMITFAILED;
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

/********************************************
 *************prioIpPortTable****************
 ********************************************
 */
static int
header_prioIpPortTable(struct variable *vp,
               oid * name,
               size_t * length,
               int exact, size_t * var_len, WriteMethod ** write_method,
               UI32_T *index1, UI16_T *index2)
{
    oid             newname[MAX_OID_LEN];
    int             result;
    UI32_T   cosvalue;
    UI32_T i1;
    UI32_T i2;
    BOOL_T return_val;
    oid  next_inst[2];
    UI32_T oid_name_length;

    oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;

     memcpy((char *) newname, (char *) vp->name,
           (int) vp->namelen * sizeof(oid));

   i1=0;
   i2=0;

    /*
     * find "next" interface
     */

  while (  (return_val= L4_PMGR_COS_GetNextPortToCos(&i1, (I32_T *)&i2, &cosvalue))==TRUE)
     {
       next_inst[0] =i1;
       next_inst[1] =(oid)i2;

        memcpy( (char*)&newname[oid_name_length], (char*) next_inst,  2*sizeof(oid));
        result =
            snmp_oid_compare(name, *length, newname,
                             (int) vp->namelen +2);
        if ((exact && (result == 0)) || (!exact && (result < 0)))
            break;
    }
    if (!return_val ) {
        return MATCH_FAILED;
    }
    memcpy((char *) name, (char *) newname,
           ((int) vp->namelen + 2) * sizeof(oid));
    *length = vp->namelen + 2;
    *var_len = sizeof(long);    /* default to 'long' results */
    *index1 = next_inst[0];
    *index2 = (UI16_T)next_inst[1];
    return TRUE;

}

/*
 * var_prioIpPortTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_prioIpPortTable(struct variable *vp,
                    oid * name,
                    size_t * length,
                    int exact,
                    size_t * var_len, WriteMethod ** write_method)
{
    /* variables we may use later */

    UI32_T index1 = 0, retval;
    UI16_T index2 = 0;
    UI32_T   cosvalue;



    /*Since this table allow for entry that does not exist, (creation). we need to know the write method first*/
    switch(vp->magic)
     {
     case PRIOIPPORTCOS:
        *write_method = write_prioIpPortCos;
        break;
     case PRIOIPPORTSTATUS:
        *write_method = write_prioIpPortStatus;
        break;
     default:
          *write_method =0;
     break;
    }

     retval  = header_prioIpPortTable(vp, name, length, exact, var_len, write_method,  &index1,& index2);

    if (retval == MATCH_FAILED)
        return NULL;


   if (L4_PMGR_COS_GetPortToCos(index1, index2, &cosvalue)!= TRUE)
            return NULL;

    /*
     * * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
     #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
      case PRIOIPPORTPHYSPORT:
        long_return = index1;
        return (u_char*) &long_return;
      case PRIOIPPORTVALUE:
        long_return = index2;
        return (u_char*) &long_return;
    #endif
      case PRIOIPPORTCOS:
        *write_method = write_prioIpPortCos;
         long_return = cosvalue;
        return (u_char*) &long_return;
      case PRIOIPPORTSTATUS:
        *write_method = write_prioIpPortStatus;
         long_return = VAL_prioIpPortStatus_valid;
        return (u_char*) &long_return;
    default:
        ERROR_MSG("");
    }
    return NULL;
}


int
write_prioIpPortCos(int action,
                    u_char * var_val,
                    u_char var_val_type,
                    size_t var_val_len,
                    u_char * statP, oid * name, size_t name_len)
{
    long value;
    UI32_T oid_name_length;

    oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;

     /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  2 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          value = *(long *)var_val;
          if ((value <MIN_prioIpPortCos) || (value >MAX_prioIpPortCos))
             return SNMP_ERR_WRONGVALUE;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
                    value = * (long *) var_val;
                if (L4_PMGR_COS_SetPortToCos(name[oid_name_length], (UI16_T) name[oid_name_length+1], value) != TRUE)
                         return SNMP_ERR_COMMITFAILED;
          break;
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_prioIpPortStatus(int action,
                       u_char * var_val,
                       u_char var_val_type,
                       size_t var_val_len,
                       u_char * statP, oid * name, size_t name_len)
{
    long value;
    UI32_T oid_name_length;

    oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;

     /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  2 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          value = *(long *)var_val;
          if ((value <VAL_prioIpPortStatus_valid) || (value >VAL_prioIpPortStatus_invalid))
             return SNMP_ERR_WRONGVALUE;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
                    value = * (long *) var_val;
                    if (value == VAL_prioIpPortStatus_valid)
                    {
                        if (L4_PMGR_COS_SetPortToCos(name[oid_name_length], (UI16_T) name[oid_name_length+1], 0) != TRUE)
                            return SNMP_ERR_COMMITFAILED;
                    }
                    else
                    if (value == VAL_prioIpPortStatus_invalid)
                    {
                        if (L4_PMGR_COS_DelPortToCos(name[oid_name_length], (UI16_T) name[oid_name_length+1]) != TRUE)
                            return SNMP_ERR_COMMITFAILED;
                    }
                    else
                        return SNMP_ERR_COMMITFAILED;
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
#endif
#if (SYS_CPNT_WRR_Q_WEIGHT_PER_PORT_CTRL == FALSE)
/********************************************
 *************prioWrrTable*******************
 ********************************************
 */
#define PRIO_WRR_ENTRY_INSTANCE_LEN  1

static BOOL_T
prioWrrTable_OidIndexToData(
    UI32_T compc,
    oid *  compl,
    UI32_T *queue_p)
{
    *queue_p = COS_TYPE_UNKNOWN_QUEUE;

    if (compc)
    {
        if (1 < compc)
        {
            return FALSE;
        }

        *queue_p = compl[0];
    }

    return TRUE;
}

/*
 * var_prioWrrTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *
var_prioWrrTable(
    struct variable *vp,
    oid     *name,
    size_t  *length,
    int     exact,
    size_t  *var_len,
    WriteMethod **write_method)
{
    UI32_T prioWrrWeight;
    UI32_T queue;
    UI32_T compc = 0;
    oid    compl[PRIO_WRR_ENTRY_INSTANCE_LEN] = {0};
    oid    next_inst[PRIO_WRR_ENTRY_INSTANCE_LEN];
    COS_VM_QUEUE_STRICT_STATUS_T strict_status;

    *write_method = 0;

    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,
                           compl, PRIO_WRR_ENTRY_INSTANCE_LEN);

    if (FALSE == prioWrrTable_OidIndexToData(compc, compl, &queue))
    {
        return NULL;
    }

    if (exact)
    {
        if (TRUE != L4_PMGR_QOS_GetPriorityEgressWrrQueueWeight(
                         COS_TYPE_PRIORITY_USER, queue, &prioWrrWeight))
        {
            return NULL;
        }
    }
    else
    {
        if (TRUE != L4_PMGR_QOS_GetNextEgressQueueWeight(&queue, &prioWrrWeight))
        {
            return NULL;
        }
    }

    if (TRUE != L4_PMGR_QOS_GetPriorityEgressQueueStrictStatus(
                    COS_TYPE_PRIORITY_USER, queue, &strict_status))
    {
        return NULL;
    }

    /*
     * this is where we do the value assignments for the mib results.
     */
    memcpy(name, vp->name, vp->namelen*sizeof(oid));
    next_inst[0] = queue;
    memcpy(name + vp->namelen, next_inst, PRIO_WRR_ENTRY_INSTANCE_LEN * sizeof(oid));
    *length = vp->namelen + PRIO_WRR_ENTRY_INSTANCE_LEN;
    *var_len = sizeof(long);

    switch(vp->magic)
    {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case PRIOWRRTRAFFICCLASS:
            long_return = queue;
            return (u_char*) &long_return;
#endif
        case PRIOWRRWEIGHT:
            *write_method = write_prioWrrWeight;
            long_return = prioWrrWeight;
            return (u_char*) &long_return;
        case PRIOWRRSTRICTSTATUS:
            *write_method = write_prioWrrStrictStatus;
            long_return = strict_status;
            return  (u_char*) &long_return;
        default:
          ERROR_MSG("");
    }

    return NULL;
}

int
write_prioWrrWeight(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

     UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;

    /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {

              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {

              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          value = *(long *)var_val;
          if ((value <MIN_prioWrrWeight) || (value >MAX_prioWrrWeight))
             return SNMP_ERR_WRONGVALUE;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
               value = * (long *) var_val;
               if (TRUE != L4_PMGR_QOS_SetPriorityEgressWrrQueueWeight(
                               COS_TYPE_PRIORITY_USER, name[oid_name_length], value))
               {
                   return SNMP_ERR_COMMITFAILED;
               }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_prioWrrStrictStatus(
    int      action,
    u_char   *var_val,
    u_char   var_val_type,
    size_t   var_val_len,
    u_char   *statP,
    oid      *name,
    size_t   name_len)
{
    long value;

     UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;

    /* check 1: check if the input index is exactly match, if not return fail
     */
    if (name_len !=  PRIO_WRR_ENTRY_INSTANCE_LEN + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }

            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;

        case RESERVE2:
            value = *(long *)var_val;
            if ((value < VAL_prioWrrStrictStatus_enabled) ||
                (VAL_prioWrrStrictStatus_disabled < value))
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
            /*
             * The variable has been stored in 'value' for you to use,
             * and you have just been asked to do something with it.
             * Note that anything done here must be reversable in the UNDO case
             */
            value = * (long *) var_val;
            {
                UI32_T queue;

                queue = name[oid_name_length];
                if (TRUE != L4_PMGR_QOS_SetPriorityEgressQueueStrictStatus(
                                COS_TYPE_PRIORITY_USER, queue, value))
                {
                    return SNMP_ERR_COMMITFAILED;
                }
            }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

#endif /* (SYS_CPNT_WRR_Q_WEIGHT_PER_PORT_CTRL == FALSE) */

#if (SYS_CPNT_WRR_Q_MODE_PER_PORT_CTRL == TRUE)
/********************************************
 *************prioPortTable******************
 ********************************************
 */
#define PRIO_PORT_ENTRY_INSTANCE_LEN  1

static BOOL_T
prioPortTable_OidIndexToData(
    UI32_T compc,
    oid *  compl,
    UI32_T *ifindex_p)
{
    *ifindex_p = 0;

    if (compc)
    {
        if (1 < compc)
        {
            return FALSE;
        }

        *ifindex_p = compl[0];
    }

    return TRUE;
}

/*
 * var_prioPortTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_prioPortTable(
    struct variable *vp,
    oid * name,
    size_t * length,
    int exact,
    size_t * var_len,
    WriteMethod ** write_method)
{
    UI32_T mode;
    UI32_T ifindex;

    UI32_T compc = 0;
    oid    compl[PRIO_PORT_ENTRY_INSTANCE_LEN] = {0};
    oid    next_inst[PRIO_PORT_ENTRY_INSTANCE_LEN];

    *write_method = 0;

    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,
                           compl, PRIO_PORT_ENTRY_INSTANCE_LEN);

    if (TRUE != prioPortTable_OidIndexToData(compc, compl, &ifindex))
    {
        return NULL;
    }

    if (exact)
    {
        if (TRUE != L4_PMGR_QOS_GetPortPriorityEgressQueueMode(ifindex,
                                                               COS_TYPE_PRIORITY_USER,
                                                               &mode))
        {
            return NULL;
        }
    }
    else
    {
        if (TRUE != L4_PMGR_QOS_GetNextPortEgressQueueMode(&ifindex, &mode))
        {
            return NULL;
        }
    }

    /*
     * this is where we do the value assignments for the mib results.
     */
    memcpy(name, vp->name, vp->namelen*sizeof(oid));
    next_inst[0] = ifindex;
    memcpy(name + vp->namelen, next_inst, PRIO_PORT_ENTRY_INSTANCE_LEN * sizeof(oid));
    *length = vp->namelen + PRIO_PORT_ENTRY_INSTANCE_LEN;
    *var_len = sizeof(long);

    switch (vp->magic)
    {
 #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case PRIOPORTIFINDEX:
            long_return = ifindex;
            return (u_char*) &long_return;
 #endif
        case PRIOPORTQUEUEMODE:
            *write_method = write_prioPortQueueMode;
            long_return = mode;
            return (u_char*) &long_return;
        default:
            ERROR_MSG("");
    }
    return NULL;
}


int
write_prioPortQueueMode(int action,
                        u_char * var_val,
                        u_char var_val_type,
                        size_t var_val_len,
                        u_char * statP, oid * name, size_t name_len)
{
    long value;
    UI32_T oid_name_length;

    oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;

     /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          value = *(long *)var_val;

        /* 2008-06-04, Jinfeng.Chen : Add three mode */
           if ( (value != VAL_prioPortQueueMode_wrr) &&
                (value != VAL_prioPortQueueMode_strict) &&
                (value != VAL_prioPortQueueMode_drr) &&
                (value != VAL_prioPortQueueMode_sp_drr) &&
                (value != VAL_prioPortQueueMode_sp_wrr)
              )
             return SNMP_ERR_WRONGVALUE;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             value = * (long *) var_val;
             if (TRUE != L4_PMGR_QOS_SetPortEgressQueueMode(
                             name[oid_name_length], value))
             {
                 return SNMP_ERR_COMMITFAILED;
             }

          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
#endif

#if (SYS_CPNT_WRR_Q_WEIGHT_PER_PORT_CTRL == TRUE)
/********************************************
 *************prioWrrPortTable***************
 ********************************************
 */
#define PRIO_WRR_PORT_ENTRY_INSTANCE_LEN  2

static BOOL_T
prioWrrPortTable_OidIndexToData(
    UI32_T compc,
    oid *  compl,
    UI32_T *ifindex_p,
    UI32_T *queue_p)
{
    *ifindex_p = 0;
    *queue_p = COS_TYPE_UNKNOWN_QUEUE;

    if (compc)
    {
        *ifindex_p = compl[0];
        if (2 < compc)
        {
            return FALSE;
        }

        if (2 == compc)
        {
            *queue_p = compl[1];
        }
    }

    return TRUE;
}

/*
 * var_prioWrrPortTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_prioWrrPortTable(
    struct variable *vp,
    oid * name,
    size_t * length,
    int exact,
    size_t * var_len,
    WriteMethod ** write_method)
{
    UI32_T ifindex, queue, weight;
    UI32_T compc = 0;
    oid    compl[PRIO_WRR_PORT_ENTRY_INSTANCE_LEN] = {0};
    oid    next_inst[PRIO_WRR_PORT_ENTRY_INSTANCE_LEN];
    COS_VM_QUEUE_STRICT_STATUS_T strict_status;

    *write_method = 0;

    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,
                           compl, PRIO_WRR_PORT_ENTRY_INSTANCE_LEN);

    if (TRUE != prioWrrPortTable_OidIndexToData(compc, compl, &ifindex, &queue))
    {
        return NULL;
    }

    if (exact)
    {
        if (TRUE != L4_PMGR_QOS_GetPortPriorityEgressWrrQueueWeight(
                        ifindex, COS_TYPE_PRIORITY_USER, queue, &weight))
        {
            return NULL;
        }
    }
    else
    {
        if (TRUE != L4_PMGR_QOS_GetNextPortEgressQueueWeight(
                        &ifindex, &queue, &weight))
        {
            return NULL;
        }
    }

    if (TRUE != L4_PMGR_QOS_GetPortPriorityEgressQueueStrictStatus(
                    ifindex, COS_TYPE_PRIORITY_USER, queue, &strict_status))
    {
        return NULL;
    }

    /*
     * this is where we do the value assignments for the mib results.
     */
    memcpy(name, vp->name, vp->namelen*sizeof(oid));
    next_inst[0] = ifindex;
    next_inst[1] = queue;
    memcpy(name + vp->namelen, next_inst, PRIO_WRR_PORT_ENTRY_INSTANCE_LEN * sizeof(oid));
    *length = vp->namelen + PRIO_WRR_PORT_ENTRY_INSTANCE_LEN;
    *var_len = sizeof(long);

    switch (vp->magic)
    {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case PRIOWRRPORTIFINDEX:
            long_return = ifindex;
            return (u_char*) &long_return;

        case PRIOWRRPORTTRAFFICCLASS:
            long_return = queue;
            return (u_char*) &long_return;
#endif
        case PRIOWRRPORTWEIGHT:
            *write_method = write_prioWrrPortWeight;
            long_return = weight;
            return (u_char*) &long_return;

        case PRIOWRRPORTSTRICTSTATUS:
            *write_method = write_prioWrrPortStrictStatus;
            long_return = strict_status;
            return (u_char*) &long_return;

        default:
            ERROR_MSG("");
    }

    return NULL;
}

int
write_prioWrrPortWeight(int action,
                        u_char * var_val,
                        u_char var_val_type,
                        size_t var_val_len,
                        u_char * statP, oid * name, size_t name_len)
{
    long value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
   /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len !=  PRIO_WRR_PORT_ENTRY_INSTANCE_LEN + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          value = *(long *)var_val;
          /*2008-06-06, Jinfeng.Chen: Now it support drr mode, the range is from 1 to 255.
                for the wrr mode, the error will be given at the ACTION case.
          if ((value <SYS_ADPT_MIN_RATIO_OF_WRR) || (value >SYS_ADPT_MAX_RATIO_OF_WRR))
          */
          if((value < SYS_ADPT_MIN_RATIO_OF_DRR) || value > (SYS_ADPT_MAX_RATIO_OF_DRR))
             return SNMP_ERR_WRONGVALUE;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             value = * (long *) var_val;
             if (TRUE != L4_PMGR_QOS_SetPortEgressWrrQueueWeight(
                             name[oid_name_length], name[oid_name_length+1], value))
             {
              return SNMP_ERR_COMMITFAILED;
             }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_prioWrrPortStrictStatus(
    int      action,
    u_char   *var_val,
    u_char   var_val_type,
    size_t   var_val_len,
    u_char   *statP,
    oid      *name,
    size_t   name_len)
{
    long value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;

    if (name_len !=  PRIO_WRR_PORT_ENTRY_INSTANCE_LEN + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
              return SNMP_ERR_WRONGTYPE;
            }

            if (var_val_len > sizeof(long))
            {
              return SNMP_ERR_WRONGLENGTH;
            }
            break;

        case RESERVE2:
            value = *(long *)var_val;
            if (    value != VAL_prioWrrPortStrictStatus_enabled
                 && value != VAL_prioWrrPortStrictStatus_disabled)
            {
                return SNMP_ERR_WRONGVALUE;
            }

            break;

        case FREE:
             /* Release any resources that have been allocated */
            break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            value = *(long *) var_val;
            {
                UI32_T ifindex, queue;

                ifindex = name[oid_name_length];
                queue = name[oid_name_length + 1];

                if (TRUE != L4_PMGR_QOS_SetPortPriorityEgressQueueStrictStatus(
                                ifindex,  COS_TYPE_PRIORITY_USER, queue, value))
                {
                    return SNMP_ERR_COMMITFAILED;
                }
            }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

#endif

#if (SYS_CPNT_WRR_Q_MODE_PER_PORT_CTRL == TRUE)
/********************************************
 *************prioSchedModePortTable******************
 ********************************************
 */
#define PRIO_SCHED_MODE_PORT_ENTRY_INSTANCE_LEN  1

static BOOL_T
prioSchedModePortTable_OidIndexToData(
    UI32_T compc,
    oid *  compl,
    UI32_T *ifindex_p)
{
    *ifindex_p = 0;

    if (compc)
    {
        if (1 < compc)
        {
            return FALSE;
        }

        *ifindex_p = compl[0];
    }

    return TRUE;
}

/*
 *   var_prioSchedModePortTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_prioSchedModePortTable(
    struct variable *vp,
    oid * name,
    size_t * length,
    int exact,
    size_t * var_len,
    WriteMethod ** write_method)
{
    UI32_T mode;
    UI32_T ifindex;

    UI32_T compc = 0;
    oid    compl[PRIO_SCHED_MODE_PORT_ENTRY_INSTANCE_LEN] = {0};
    oid    next_inst[PRIO_SCHED_MODE_PORT_ENTRY_INSTANCE_LEN];

    *write_method = 0;

    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,
                           compl, PRIO_SCHED_MODE_PORT_ENTRY_INSTANCE_LEN);

    if (TRUE != prioSchedModePortTable_OidIndexToData(compc, compl, &ifindex))
    {
        return NULL;
    }

    if (exact)
    {
        if (TRUE != L4_PMGR_QOS_GetPortPriorityEgressQueueMode(ifindex,
                                                               COS_TYPE_PRIORITY_USER,
                                                               &mode))
        {
            return NULL;
        }
    }
    else
    {

        if (TRUE != L4_PMGR_QOS_GetNextPortEgressQueueMode(&ifindex, &mode))
        {
            return NULL;
        }
    }

    /*
     * this is where we do the value assignments for the mib results.
     */
    memcpy(name, vp->name, vp->namelen*sizeof(oid));
    next_inst[0] = ifindex;
    memcpy(name + vp->namelen, next_inst, PRIO_SCHED_MODE_PORT_ENTRY_INSTANCE_LEN * sizeof(oid));
    *length = vp->namelen + PRIO_SCHED_MODE_PORT_ENTRY_INSTANCE_LEN;
    *var_len = sizeof(long);

    switch (vp->magic)
    {
 #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case PRIOSCHEDMODEPORTINDEX:
            long_return = ifindex;
            return (u_char*) &long_return;
 #endif
        case PRIOSCHEDMODEPORT:
            *write_method = write_prioSchedModePort;
            long_return = mode;
            return (u_char*) &long_return;
        default:
            ERROR_MSG("");
    }

    return NULL;
}

int
write_prioSchedModePort(int action,
                        u_char * var_val,
                        u_char var_val_type,
                        size_t var_val_len,
                        u_char * statP, oid * name, size_t name_len)
{
    long value;
    UI32_T oid_name_length;

    oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;

     /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          value = *(long *)var_val;

        /* 2008-06-04, Jinfeng.Chen : Add three mode */
           if ( (value != VAL_prioPortQueueMode_wrr) &&
                (value != VAL_prioPortQueueMode_strict) &&
#if (SYS_CPNT_SWCTRL_Q_MODE_DRR == TRUE)
                (value != VAL_prioPortQueueMode_drr) &&
                (value != VAL_prioPortQueueMode_sp_drr) &&
#endif
                (value != VAL_prioPortQueueMode_sp_wrr)
              )
             return SNMP_ERR_WRONGVALUE;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             value = * (long *) var_val;

             if (TRUE != L4_PMGR_QOS_SetPortEgressQueueMode(
                             name[oid_name_length], value))
             {
                 return SNMP_ERR_COMMITFAILED;
             }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
#endif

/* use standard MIB
 */
#if 0
/********************************************
 *************trapDestTable******************
 ********************************************
 */
static int
header_trapDestTable(struct variable *vp,
               oid * name,
               size_t * length,
               int exact, size_t * var_len, WriteMethod ** write_method)
{
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
    oid             newname[MAX_OID_LEN];
    UI32_T    interface;
    int             result;
    SNMP_MGR_TrapDestEntry_T  entry;
    UI32_T ifIndex = 0;
    BOOL_T return_val;
    oid  next_inst[4];


     memcpy((char *) newname, (char *) vp->name,
           (int) vp->namelen * sizeof(oid));
    /*
     * find "next" interface
     */
    memset(  &entry, 0 , sizeof(entry));

    /*
     * find "next" interface
     */

    while ((return_val= SNMP_MGR_GetNextTrapReceiverForV1V2(&entry)) == SNMP_MGR_ERROR_OK)
    {
        ifIndex = entry.trap_dest_address;
        SNMP_MGR_BindIpInstance( ifIndex, 0, next_inst);

        memcpy((char*)&newname[oid_name_length], (char*) next_inst,  4*sizeof(oid));
        result =
            snmp_oid_compare(name, *length, newname,
                             (int) vp->namelen + 4);
        if ((exact && (result == 0)) || (!exact && (result < 0)))
            break;
    }
    if (return_val!= SNMP_MGR_ERROR_OK ) {
        DEBUGMSGTL(("mibII/interfaces", "... index out of range\n"));
        return MATCH_FAILED;
    }
    memcpy((char *) name, (char *) newname,
           ((int) vp->namelen + 4) * sizeof(oid));
    *length = vp->namelen + 4;
    *var_len = sizeof(long);    /* default to 'long' results */
    interface = ifIndex;
    return interface;
}


/*
 * var_trapDestTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *
var_trapDestTable(struct variable *vp,
            oid     *name,
            size_t  *length,
            int     exact,
            size_t  *var_len,
            WriteMethod **write_method)
{
    /* variables we may use later */

    UI32_T index;
    SNMP_MGR_TrapDestEntry_T  entry;



    switch(vp->magic) {
    case TRAPDESTCOMMUNITY:
        *write_method = write_trapDestCommunity;
        break;
    case TRAPDESTSTATUS:
        *write_method = write_trapDestStatus;
        break;
    case TRAPDESTVERSION:
        *write_method = write_trapDestVersion;
        break;

    case TRAPDESTUDPPORT:
        *write_method = write_trapDestUdpPort;
        break;

    default:
       *write_method =0;
     }

    memset( &entry, 0, sizeof(entry));
    index =
        header_trapDestTable(vp, name, length, exact, var_len, write_method);
    if (index == MATCH_FAILED)
        return NULL;


  entry.trap_dest_address=index;

   if (SNMP_MGR_GetTrapReceiver( &entry)!= SNMP_MGR_ERROR_OK)
            return NULL;

    /*
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
 #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    case TRAPDESTADDRESS:
        *var_len = sizeof(ipaddr_return);
       ipaddr_return = entry.snmp_mgr_trap_dest_address;
        return (u_char*) &ipaddr_return;
#endif
    case TRAPDESTCOMMUNITY:
        strcpy((char *)return_buf, (char *)entry.trap_dest_community);
        *var_len = strlen((char *)return_buf);
        return (u_char*) return_buf;
    case TRAPDESTSTATUS:
         long_return = entry.trap_dest_status;
        return (u_char*) &long_return;
    case TRAPDESTVERSION:
         long_return = entry.trap_dest_version;
        return (u_char*) &long_return;

    case TRAPDESTUDPPORT:
         long_return = entry.trap_dest_port;
        return (u_char*) &long_return;

    default:
      ERROR_MSG("");
    }
    return NULL;
}

int
write_trapDestCommunity(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{

    int size;
    UI32_T ipAddress;

    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;

      /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  4 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    SNMP_MGR_ReadIpFromCompl(name, oid_name_length, &ipAddress);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(char)*SYS_ADPT_MAX_COMM_STR_NAME_LEN) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
        {
            /*
             * The variable has been stored in 'value' for you to use,
             * and you have just been asked to do something with it.
             * Note that anything done here must be reversable in the UNDO case
             */
            char  buffer[SYS_ADPT_MAX_COMM_STR_NAME_LEN+1];
            size  = var_val_len;
            strncpy((char *)buffer, (char *)var_val, size);
            buffer[size]= '\0';

            if (!L_CHARSET_IsValidGenericString(buffer))
            {
                return SNMP_ERR_WRONGVALUE;
            }

            if (SNMP_MGR_SetTrapReceiverCommunity (ipAddress, (UI8_T *)buffer) != SNMP_MGR_ERROR_OK)
            return SNMP_ERR_COMMITFAILED;
        }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_trapDestStatus(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    UI32_T ipAddress;

    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;

      /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  4 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    SNMP_MGR_ReadIpFromCompl(name, oid_name_length, &ipAddress);
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          value = *(long *)var_val;
          if ((value <1) || (value >2))
             return SNMP_ERR_WRONGVALUE;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
               value = * (long *) var_val;
               switch(value)
               {
                 case VAL_trapDestStatus_2_valid:
                 {
                   SNMP_MGR_TrapDestEntry_T entry;

                   memset(&entry, 0, sizeof(entry));
                   entry.trap_dest_address = ipAddress;
                   entry.trap_dest_type = SNMP_MGR_SNMPV3_NOTIFY_TRAP;
                   entry.trap_dest_port = 162;
                   entry.trap_dest_version = VAL_trapDestVersion_version1;
                   if (SNMP_MGR_SetTrapReceiver(&entry) != SNMP_MGR_ERROR_OK)
                   {
                      return SNMP_ERR_COMMITFAILED;
                    }
                 }
                 break;

                    case VAL_trapDestStatus_2_invalid:
                    {
                    SNMP_MGR_TrapDestEntry_T trap_receiver;

                    memset(&trap_receiver, 0, sizeof(SNMP_MGR_TrapDestEntry_T));
                    trap_receiver.trap_dest_address = ipAddress;

                    SNMP_MGR_GetTrapReceiver(&trap_receiver);

                    /* if the version != v1 or v2, return failed
                     */
                    if ((trap_receiver.trap_dest_version != VAL_trapDestVersion_version1) &&
                        (trap_receiver.trap_dest_version != VAL_trapDestVersion_version2))
                    {
                        return SNMP_ERR_COMMITFAILED;
                    }

                        if ( SNMP_MGR_DeleteTrapReceiver(ipAddress)!= SNMP_MGR_ERROR_OK)
                        {
                           return SNMP_ERR_COMMITFAILED;
                        }
                        break;
                    }
                }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_trapDestVersion(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    UI32_T ipAddress;

    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;

      /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  4 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    SNMP_MGR_ReadIpFromCompl(name, oid_name_length, &ipAddress);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          value = *(long *)var_val;
          if ((value <1) || (value >2))
             return SNMP_ERR_WRONGVALUE;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
                       value = * (long *) var_val;
               if (SNMP_MGR_SetTrapReceiverVersion(ipAddress, value) != SNMP_MGR_ERROR_OK)
                 return SNMP_ERR_COMMITFAILED;
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_trapDestUdpPort(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    UI32_T ipAddress;

    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;

      /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  4 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    SNMP_MGR_ReadIpFromCompl(name, oid_name_length, &ipAddress);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          value = *(long *)var_val;
          if ((value <1) || (value >65535))
             return SNMP_ERR_WRONGVALUE;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
                       value = * (long *) var_val;
               if (SNMP_MGR_SetTrapReceiverPort(ipAddress, value) != SNMP_MGR_ERROR_OK)
               {
                  return SNMP_ERR_COMMITFAILED;
               }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
#endif /* #if 0 */

/********************************************
 *************rateLimitMgt*******************
 ********************************************
 */
#if (SYS_CPNT_INGRESS_RATE_LIMIT == TRUE)
int
do_rateLimitStatus(netsnmp_mib_handler *handler,
                   netsnmp_handler_registration *reginfo,
                   netsnmp_agent_request_info *reqinfo,
                   netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
           {
               UI32_T  rateLimitStatus;
               UI32_T  i;

               for (i = 1; i<= SYS_ADPT_TOTAL_NBR_OF_LPORT; i++)
               {
                   if (SWCTRL_POM_LogicalPortExisting(i))
                   break;
               }
               if (SWCTRL_POM_GetRunningPortIngressRateLimitStatus(i, &rateLimitStatus)==SYS_TYPE_GET_RUNNING_CFG_FAIL)
               {
                       return SNMP_ERR_GENERR;
               }
               long_return = rateLimitStatus;
               snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
            }
             break;
        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
             {
           UI32_T status;
           status = (*requests->requestvb->val.integer);
          if ((status!= VAL_rateLimitStatus_enabled) && (status!=VAL_rateLimitStatus_disabled))
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_INCONSISTENTVALUE);
          }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */

            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
          {
               UI32_T status;
               status = (*requests->requestvb->val.integer);

               switch(status)
               {
                   case VAL_rateLimitStatus_enabled :
                        if (SWCTRL_PMGR_EnablePortIngressRateLimit(status) != TRUE)
                           netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
                        break;
                   case VAL_rateLimitStatus_disabled:
                        if (SWCTRL_PMGR_DisablePortIngressRateLimit(status) != TRUE)
                           netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
                        break;
               }

          }
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */

            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */

            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
#endif

/********************************************
 *************rateLimitPortTable*************
 ********************************************
 */
static int
header_rateLimitPortTable(struct variable *vp,
               oid * name,
               size_t * length,
               int exact, size_t * var_len, WriteMethod ** write_method)
{
    oid             newname[MAX_OID_LEN];
    int    interface;
    int             result;
   Port_Info_T  entry;
   UI32_T ifIndex = 0;
   BOOL_T return_val;
   UI32_T oid_name_length;

    oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    memcpy((char *) newname, (char *) vp->name,
           (int) vp->namelen * sizeof(oid));
    /*
     * find "next" interface
     */

     while (  (return_val= SWCTRL_POM_GetNextPortInfo( &ifIndex, &entry))==TRUE)
     {

        newname[oid_name_length] = (oid) ifIndex;
        result =
            snmp_oid_compare(name, *length, newname,
                             (int) vp->namelen + 1);
        if ((exact && (result == 0)) || (!exact && (result < 0)))
            break;
    }
    if (!return_val ) {

        return MATCH_FAILED;
    }


    memcpy((char *) name, (char *) newname,
           ((int) vp->namelen + 1) * sizeof(oid));
    *length = vp->namelen + 1;
    *write_method = 0;
    *var_len = sizeof(long);    /* default to 'long' results */
    interface = newname[oid_name_length];



    return interface;
}


/*
 * var_rateLimitPortTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_rateLimitPortTable(struct variable *vp,
                       oid * name,
                       size_t * length,
                       int exact,
                       size_t * var_len, WriteMethod ** write_method)
{
   Port_Info_T  entry;
    int             interface;



   memset( &entry, 0, sizeof(entry));
    interface =
        header_rateLimitPortTable(vp, name, length, exact, var_len, write_method);
    if (interface == MATCH_FAILED)
        return NULL;



   if (SWCTRL_POM_GetPortInfo( interface, &entry)!= TRUE)
            return NULL;
    /*
     * * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
      case RLPORTINDEX:
        long_return = interface;
        return (u_char*) &long_return;
    #endif
    #if (SYS_CPNT_INGRESS_RATE_LIMIT == TRUE)
      case RLPORTINPUTLIMIT:
        *write_method = write_rlPortInputLimit;
        long_return = entry.ingress_rate_limit/1000;
        return (u_char*) &long_return;
    #endif
    #if (SYS_CPNT_EGRESS_RATE_LIMIT == TRUE)
      case RLPORTOUTPUTLIMIT:
        *write_method = write_rlPortOutputLimit;
       long_return = entry.egress_rate_limit/1000;
        return (u_char*) &long_return;
    #endif
     #if (SYS_CPNT_INGRESS_RATE_LIMIT == TRUE)
      case RLPORTINPUTSTATUS:
        *write_method = write_rlPortInputStatus;
        long_return = entry.ingress_rate_limit_status;
        return (u_char*) &long_return;
    #endif
    #if (SYS_CPNT_EGRESS_RATE_LIMIT == TRUE)
      case RLPORTOUTPUTSTATUS:
        *write_method = write_rlPortOutputStatus;
        long_return = entry.egress_rate_limit_status;
        return (u_char*) &long_return;
    #endif

    #if (SYS_CPNT_INGRESS_RATE_LIMIT == TRUE)
        case LEAF_rlPortInputLimitInKilo:
            *write_method = write_rlPortInputLimitInKilo;
            long_return = entry.ingress_rate_limit;
            return (u_char*) &long_return;
    #endif /* #if (SYS_CPNT_INGRESS_RATE_LIMIT == TRUE) */

    #if (SYS_CPNT_EGRESS_RATE_LIMIT == TRUE)
        case LEAF_rlPortOutputLimitInKilo:
            *write_method = write_rlPortOutputLimitInKilo;
            long_return = entry.egress_rate_limit;
            return (u_char*) &long_return;
    #endif /* #if (SYS_CPNT_EGRESS_RATE_LIMIT == TRUE) */

    default:
        ERROR_MSG("");
    }
    return NULL;
}

#if (SYS_CPNT_INGRESS_RATE_LIMIT == TRUE)
int
write_rlPortInputLimit(int action,
                       u_char * var_val,
                       u_char var_val_type,
                       size_t var_val_len,
                       u_char * statP, oid * name, size_t name_len)
{
    long value;
    UI32_T oid_name_length;

    oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    if (name_len!=  1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             value = * (long *) var_val;
             value *= 1000;
             if (SWCTRL_PMGR_SetPortIngressRateLimit(name[oid_name_length],value) != TRUE)
                 return SNMP_ERR_COMMITFAILED;

          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
#endif

#if (SYS_CPNT_EGRESS_RATE_LIMIT == TRUE)
int
write_rlPortOutputLimit(int action,
                        u_char * var_val,
                        u_char var_val_type,
                        size_t var_val_len,
                        u_char * statP, oid * name, size_t name_len)
{
    long value;
    UI32_T oid_name_length;

    oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    if (name_len!=  1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             value = * (long *) var_val;
             value *= 1000;
             if (SWCTRL_PMGR_SetPortEgressRateLimit(name[oid_name_length],value) != TRUE)
                 return SNMP_ERR_COMMITFAILED;

          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
#endif
#if (SYS_CPNT_INGRESS_RATE_LIMIT == TRUE)
int
write_rlPortInputStatus(int action,
                        u_char * var_val,
                        u_char var_val_type,
                        size_t var_val_len,
                        u_char * statP, oid * name, size_t name_len)
{
    long value;
    UI32_T oid_name_length;

    oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    if (name_len!=  1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          value = *(long *)var_val;
          if ((value <VAL_rlPortInputStatus_enabled) ||(value >VAL_rlPortInputStatus_disabled))
             return SNMP_ERR_WRONGVALUE;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
               value = * (long *) var_val;
               if (value == VAL_rlPortInputStatus_enabled)
               {
                  if (SWCTRL_PMGR_EnablePortIngressRateLimit(name[oid_name_length]) != TRUE)
                  {
                    return SNMP_ERR_COMMITFAILED;
                  }
               }
               else if (value == VAL_rlPortInputStatus_disabled)
               {
                   if (SWCTRL_PMGR_DisablePortIngressRateLimit(name[oid_name_length]) != TRUE)
                  {
                    return SNMP_ERR_COMMITFAILED;
                  }
               }
               else
                   return SNMP_ERR_COMMITFAILED;
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
#endif
#if (SYS_CPNT_EGRESS_RATE_LIMIT == TRUE)
int
write_rlPortOutputStatus(int action,
                         u_char * var_val,
                         u_char var_val_type,
                         size_t var_val_len,
                         u_char * statP, oid * name, size_t name_len)
{
    long value;
    UI32_T oid_name_length;

    oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    if (name_len!=  1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          value = *(long *)var_val;
          if ((value <VAL_rlPortOutputStatus_enabled) ||(value >VAL_rlPortOutputStatus_disabled))
             return SNMP_ERR_WRONGVALUE;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
               value = * (long *) var_val;
               if (value == VAL_rlPortOutputStatus_enabled)
               {
                  if (SWCTRL_PMGR_EnablePortEgressRateLimit(name[oid_name_length]) != TRUE)
                  {
                    return SNMP_ERR_COMMITFAILED;
                  }
               }
               else if (value == VAL_rlPortOutputStatus_disabled)
               {
                   if (SWCTRL_PMGR_DisablePortEgressRateLimit(name[oid_name_length]) != TRUE)
                  {
                    return SNMP_ERR_COMMITFAILED;
                  }
               }
               else
                   return SNMP_ERR_COMMITFAILED;
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
#endif

#if (SYS_CPNT_INGRESS_RATE_LIMIT == TRUE)
int
write_rlPortInputLimitInKilo(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    UI32_T oid_name_length;

    oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    if (name_len!=  1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            break;

        case FREE:
            break;

        case ACTION:
        {
            value = * (long *) var_val;

            if (SWCTRL_PMGR_SetPortIngressRateLimit(name[oid_name_length], value) != TRUE)
            {
                return SNMP_ERR_COMMITFAILED;
            }
        }
            break;

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}
#endif /* #if (SYS_CPNT_INGRESS_RATE_LIMIT == TRUE) */

#if (SYS_CPNT_EGRESS_RATE_LIMIT == TRUE)
int
write_rlPortOutputLimitInKilo(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    UI32_T oid_name_length;

    oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    if (name_len!=  1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            break;

        case FREE:
            break;

        case ACTION:
        {
            value = * (long *) var_val;

            if (SWCTRL_PMGR_SetPortEgressRateLimit(name[oid_name_length], value) != TRUE)
            {
                return SNMP_ERR_COMMITFAILED;
            }
        }
            break;

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}
#endif /* #if (SYS_CPNT_EGRESS_RATE_LIMIT == TRUE) */

#if (SYS_CPNT_QOS == SYS_CPNT_QOS_MARKER)
/********************************************
 *************markerTable********************
 ********************************************
     */
/* This entry is used for entry which have the ability to row create*/
static MARKER_TYPE_MarkerEntry_T markerEntry;

static int
header_markerTable(struct variable *vp,
               oid * name,
               size_t * length,
               int exact, size_t * var_len, WriteMethod ** write_method,
               UI32_T *index1, I8_T *index2, UI32_T *index2_len)
{

    oid    newname[MAX_OID_LEN];
    UI32_T    ifIndex=0;
    int    result;
   MARKER_TYPE_MarkerEntry_T  entry;
   I8_T marker_index2[SYS_ADPT_ACL_MAX_NAME_LEN+1];
   int return_val;
   oid  next_inst[2+SYS_ADPT_ACL_MAX_NAME_LEN];
   int i;
   UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

     memcpy((char *) newname, (char *) vp->name,
           (int) vp->namelen * sizeof(oid));
    /*
     * find "next" interface
     */
    memset(  &entry, 0 , sizeof(entry));

    /*
     * find "next" interface
     */

 while (  (return_val= L4_MARKER_MGR_SNMPGetNextMarkerEntry( &ifIndex, &entry)) == TRUE)
     {
       strcpy(marker_index2,entry.acl_name);

       next_inst[0] =ifIndex;
       next_inst[1] = strlen( marker_index2);
       for ( i = 0; i< strlen(marker_index2); i++)
       {
           next_inst[i+2] = marker_index2[i];
       }

        memcpy( (char*)&newname[oid_name_length], (char*) next_inst,  (2+strlen(marker_index2))*sizeof(oid));
        result =
            snmp_oid_compare(name, *length, newname,
                             (int) vp->namelen + 2+strlen(marker_index2));
        if ((exact && (result == 0)) || (!exact && (result < 0)))
            break;
    }
    if (return_val!= TRUE ) {
        DEBUGMSGTL(("mibII/interfaces", "... index out of range\n"));
        return MATCH_FAILED;
    }
    memcpy((char *) name, (char *) newname,
           ((int) vp->namelen + 2+strlen(marker_index2)) * sizeof(oid));
    *length = vp->namelen + 2+strlen(marker_index2);
    *var_len = sizeof(long);    /* default to 'long' results */
    *index1 = ifIndex;
     strcpy( index2, marker_index2);
     *index2_len = strlen(index2);
    return TRUE;

}

/*
 * var_markerTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_markerTable(struct variable *vp,
                oid * name,
                size_t * length,
                int exact, size_t * var_len, WriteMethod ** write_method)
{
    /* variables we may use later */

    UI32_T index1,index2_len, retval;
    I8_T index2[SYS_ADPT_ACL_MAX_NAME_LEN+1];


    MARKER_TYPE_MarkerEntry_T  entry;

    /* Give default value for the record first
     * We use the row_status = 0 to indicate if this set operation is Set by field
     * or set by record(included row creation), if the row_status =0, this record
     * mean set by field, otherwise, we just think it is a normal set operation
     */
    if (!L4_MARKER_MGR_GetDefaultMarkerEntry(&markerEntry))
    {
        if(SNMP_MGR_IsDebugMode())
        {
            SYSFUN_Debug_Printf("markerEntry_set:L4_MARKER_MGR_GetDefaultmarkerEntry return false\n");
        }
        return NULL;
    }
    markerEntry.row_status = 0;


   /*Since this table allow for entry that does not exist, (creation). we need to know the write method first*/
    switch(vp->magic)
     {

       case MARKERACTIONBITLIST:
        *write_method = write_markerActionBitList;
        break;
      case MARKERDSCP:
        *write_method = write_markerDscp;
         break;
      case MARKERPRECEDENCE:
        *write_method = write_markerPrecedence;
         break;
      case MARKERPRIORITY:
        *write_method = write_markerPriority;
         break;
      case MARKERSTATUS:
        *write_method = write_markerStatus;
         break;
    default:
      ERROR_MSG("");
    }



    memset( &entry, 0, sizeof(entry));

     retval  = header_markerTable(vp, name, length, exact, var_len, write_method,  &index1,index2, &index2_len);

    if (retval == MATCH_FAILED)
        return NULL;


   memcpy(entry.acl_name,index2, index2_len);



    if (L4_MARKER_MGR_GetMarkerEntry(index1, &entry)!= TRUE)
            return NULL;


    /*
     * * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
   #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
      case MARKERIFINDEX:
        long_return =index1;
        return (u_char *) &long_return;
      case MARKERACLNAME:
        strcpy(return_buf, index2);
        *var_len = strlen(return_buf);
        return (u_char *)return_buf;
   #endif
      case MARKERACTIONBITLIST:
        *write_method = write_markerActionBitList;
        long_return = L_STDLIB_Hton32(entry.action);
        *var_len = sizeof(long_return) ;
        return( u_char *) &long_return;
      case MARKERDSCP:
        *write_method = write_markerDscp;
        long_return =entry.dscp;
        return (u_char *) &long_return;
      case MARKERPRECEDENCE:
        *write_method = write_markerPrecedence;
        long_return =entry.precedence;
        return (u_char *) &long_return;
      case MARKERPRIORITY:
        *write_method = write_markerPriority;
        long_return =entry.dot1p;
        return (u_char *) &long_return;
      case MARKERSTATUS:
        *write_method = write_markerStatus;
         long_return =entry.row_status;
        return (u_char *) &long_return;
    default:
        ERROR_MSG("");
    }
    return NULL;
}


int
write_markerActionBitList(int action,
                          u_char * var_val,
                          u_char var_val_type,
                          size_t var_val_len,
                          u_char * statP, oid * name, size_t name_len)
{
    int i;
    I8_T buffer[SYS_ADPT_ACL_MAX_NAME_LEN+1];
     UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    if ((char) name[oid_name_length-1] != MARKERACTIONBITLIST)
    {
        return SNMP_ERR_NOTWRITABLE;
    }

     /* check 2: name[oid_name_length] = the length of the aclname, check if these exceed the max size*/
    if (name[oid_name_length+1] > SYS_ADPT_ACL_MAX_NAME_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    /* check 3: check if the input index is exactly match, if not return fail*/
    if (name_len!= name[oid_name_length+1]+ 2+ oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }


    for (i = 0; i< name[oid_name_length+1]; i++)
    {
        buffer[i] = name[oid_name_length+2+i];
    }
    buffer[name[oid_name_length+1]] = '\0';

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len >4) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
        /* In reserve2, we overwrite the set value to markerEntry*/
          {
              UI32_T CapaIntegerType=0;

              memcpy(&CapaIntegerType, var_val, var_val_len);
              CapaIntegerType = L_STDLIB_Ntoh32(CapaIntegerType);
              /* The following is for SNMPc 5.1 implentation, since we will get Octet type*/
              switch (var_val_len)
              {
                  case 1:
                    markerEntry.action = (CapaIntegerType & 0xFF000000) >>24;
                  break;
                  case 2:
                    markerEntry.action = (CapaIntegerType & 0xFFFF0000) >>16;
                  break;
                  case 3:
                    markerEntry.action = (CapaIntegerType & 0xFFFFFF00) >> 8;
                  break;
                  case 4:
                    markerEntry.action = (CapaIntegerType & 0xFFFFFFFF) >> 0;
                  break;
              }
          }
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
         /* For row creation, if row_status =0, mean that this is a normal
          * operation, we do the normal set operation, otherwise it is a row
          * creation operation, will do nothing here, and the overall entry
          * will perform in the write_xxxRowStatus function.
          */
          if (markerEntry.row_status == 0)
          {
              if (L4_MARKER_MGR_SetMarkerEntry_Action (name[oid_name_length], buffer, markerEntry.action) != TRUE)
         {
             return SNMP_ERR_COMMITFAILED;
          }
          }
          break;
        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_markerDscp(int action,
                 u_char * var_val,
                 u_char var_val_type,
                 size_t var_val_len,
                 u_char * statP, oid * name, size_t name_len)
{
    int i;
    I8_T buffer[SYS_ADPT_ACL_MAX_NAME_LEN+1];
     UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;



    if ((char) name[oid_name_length-1] != MARKERDSCP)
    {
        return SNMP_ERR_NOTWRITABLE;
    }

     /* check 2: name[oid_name_length] = the length of the aclname, check if these exceed the max size*/
    if (name[oid_name_length+1] > SYS_ADPT_ACL_MAX_NAME_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    /* check 3: check if the input index is exactly match, if not return fail*/
    if (name_len!= name[oid_name_length+1]+ 2+ oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }


    for (i = 0; i< name[oid_name_length+1]; i++)
    {
        buffer[i] = name[oid_name_length+2+i];
    }
    buffer[name[oid_name_length+1]] = '\0';

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
         /* In reserve2, we overwrite the set value to markerEntry*/
          markerEntry.dscp = *(long *)var_val;
          if ((markerEntry.dscp < MIN_markerDscp) || (markerEntry.dscp > MAX_markerDscp))
              return SNMP_ERR_WRONGVALUE;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
          /* For row creation, if row_status =0, mean that this is a normal
          * operation, we do the normal set operation, otherwise it is a row
          * creation operation, will do nothing here, and the overall entry
          * will perform in the write_xxxRowStatus function.
          */
          if (markerEntry.row_status == 0)
          {
              if (L4_MARKER_MGR_SetMarkerEntry_Dscp (name[oid_name_length], buffer, markerEntry.dscp) != TRUE)
         {
             return SNMP_ERR_COMMITFAILED;
          }
          }
          break;
        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_markerPrecedence(int action,
                       u_char * var_val,
                       u_char var_val_type,
                       size_t var_val_len,
                       u_char * statP, oid * name, size_t name_len)
{
    int i;
    I8_T buffer[SYS_ADPT_ACL_MAX_NAME_LEN+1];
     UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;



    if ((char) name[oid_name_length-1] != MARKERPRECEDENCE)
    {
        return SNMP_ERR_NOTWRITABLE;
    }

     /* check 2: name[oid_name_length] = the length of the aclname, check if these exceed the max size*/
    if (name[oid_name_length+1] > SYS_ADPT_ACL_MAX_NAME_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    /* check 3: check if the input index is exactly match, if not return fail*/
    if (name_len!= name[oid_name_length+1]+ 2+ oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }


    for (i = 0; i< name[oid_name_length+1]; i++)
    {
        buffer[i] = name[oid_name_length+2+i];
    }
    buffer[name[oid_name_length+1]] = '\0';

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
         /* In reserve2, we overwrite the set value to markerEntry*/
          markerEntry.precedence = *(long *)var_val;
          if ((markerEntry.precedence < MIN_markerPrecedence) || (markerEntry.precedence > MAX_markerPrecedence))
              return SNMP_ERR_WRONGVALUE;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
         /* For row creation, if row_status =0, mean that this is a normal
          * operation, we do the normal set operation, otherwise it is a row
          * creation operation, will do nothing here, and the overall entry
          * will perform in the write_xxxRowStatus function.
          */
          if (markerEntry.row_status == 0)
          {
              if (L4_MARKER_MGR_SetMarkerEntry_Precedence (name[oid_name_length], buffer, markerEntry.precedence) != TRUE)
         {
             return SNMP_ERR_COMMITFAILED;
          }
          }
          break;
        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_markerPriority(int action,
                     u_char * var_val,
                     u_char var_val_type,
                     size_t var_val_len,
                     u_char * statP, oid * name, size_t name_len)
{
    int i;
    I8_T buffer[SYS_ADPT_ACL_MAX_NAME_LEN+1];
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;



    if ((char) name[oid_name_length-1] != MARKERPRIORITY)
    {
        return SNMP_ERR_NOTWRITABLE;
    }

     /* check 2: name[oid_name_length] = the length of the aclname, check if these exceed the max size*/
    if (name[oid_name_length+1] > SYS_ADPT_ACL_MAX_NAME_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    /* check 3: check if the input index is exactly match, if not return fail*/
    if (name_len!= name[oid_name_length+1]+ 2+ oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }


    for (i = 0; i< name[oid_name_length+1]; i++)
    {
        buffer[i] = name[oid_name_length+2+i];
    }
    buffer[name[oid_name_length+1]] = '\0';

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

         /* In reserve2, we overwrite the set value to markerEntry*/
          markerEntry.dot1p = *(long *)var_val;
          if ((markerEntry.dot1p < MIN_markerPriority) || (markerEntry.dot1p > MAX_markerPriority))
              return SNMP_ERR_WRONGVALUE;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
         /* For row creation, if row_status =0, mean that this is a normal
          * operation, we do the normal set operation, otherwise it is a row
          * creation operation, will do nothing here, and the overall entry
          * will perform in the write_xxxRowStatus function.
          */
          if (markerEntry.row_status == 0)
          {
              if (L4_MARKER_MGR_SetMarkerEntry_Priority (name[oid_name_length], buffer, markerEntry.dot1p) != TRUE)
         {
             return SNMP_ERR_COMMITFAILED;
          }
          }
          break;
        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_markerStatus(int action,
                   u_char * var_val,
                   u_char var_val_type,
                   size_t var_val_len,
                   u_char * statP, oid * name, size_t name_len)
{
    int i;
    I8_T buffer[SYS_ADPT_ACL_MAX_NAME_LEN+1];
     UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;



    if ((char) name[oid_name_length-1] != MARKERSTATUS)
    {
        return SNMP_ERR_NOTWRITABLE;
    }

    /* check 2: name[oid_name_length] = the length of the aclname, check if these exceed the max size*/
    if (name[oid_name_length+1] > SYS_ADPT_ACL_MAX_NAME_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    /* check 3: check if the input index is exactly match, if not return fail*/
    if (name_len!= name[oid_name_length+1]+ 2+ oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    for (i = 0; i< name[oid_name_length+1]; i++)
    {
        buffer[i] = name[oid_name_length+2+i];
    }
    buffer[name[oid_name_length+1]] = '\0';

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len != sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          /* In reserve2, we overwrite the set value to markerEntry*/
          markerEntry.row_status = *(long *)var_val;
          if ((markerEntry.row_status < VAL_markerStatus_active) || (markerEntry.row_status > VAL_markerStatus_destroy))
              return SNMP_ERR_WRONGVALUE;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
         /* We perform the row creation here, if the row status = 4(createAndGo),
           * or 5 (createAndWait), we call the SetByEntry API, otherwise, call the
           * set rowstatus API
           */
           strcpy(markerEntry.acl_name, buffer);
           if (L4_MARKER_MGR_SetMarkerEntryRowStatus(name[oid_name_length], &markerEntry) != TRUE)
         {
             return SNMP_ERR_COMMITFAILED;
          }
          break;
        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
#endif

#if (SYS_CPNT_COS == TRUE)
/********************************************
 *************prioAclToCosMappingTable*******
 ********************************************
 */
static int
header_prioAclToCosMappingTable(struct variable *vp,
               oid * name,
               size_t * length,
               int exact, size_t * var_len, WriteMethod ** write_method,
               UI32_T *index1, I8_T *index2, UI32_T *index2_len)
{

    oid    newname[MAX_OID_LEN];
    UI32_T    ifIndex=0;
    int    result;
   COS_TYPE_AclCosEntry_T  entry;
   I8_T marker_index2[SYS_ADPT_ACL_MAX_NAME_LEN+1];
   int return_val;
   oid  next_inst[2+SYS_ADPT_ACL_MAX_NAME_LEN];
   int i;
   UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

     memcpy((char *) newname, (char *) vp->name,
           (int) vp->namelen * sizeof(oid));
    /*
     * find "next" interface
     */
    memset(  &entry, 0 , sizeof(entry));

    /*
     * find "next" interface
     */

 while (  (return_val= L4_PMGR_COS_SNMPGetNextCosEntry( &ifIndex, &entry)) == TRUE)
     {
       strcpy((char *)marker_index2, (char *)entry.acl_name);

       next_inst[0] =ifIndex;
       next_inst[1] = strlen((char *)marker_index2);
       for ( i = 0; i< strlen((char *)marker_index2); i++)
       {
           next_inst[i+2] = marker_index2[i];
       }

        memcpy( (char*)&newname[oid_name_length], (char*) next_inst,  (2+strlen((char *)marker_index2))*sizeof(oid));
        result =
            snmp_oid_compare(name, *length, newname,
                             (int) vp->namelen + 2+strlen((char *)marker_index2));
        if ((exact && (result == 0)) || (!exact && (result < 0)))
            break;
    }
    if (return_val!= TRUE ) {
        DEBUGMSGTL(("mibII/interfaces", "... index out of range\n"));
        return MATCH_FAILED;
    }
    memcpy((char *) name, (char *) newname,
           ((int) vp->namelen + 2+strlen((char *)marker_index2)) * sizeof(oid));
    *length = vp->namelen + 2+strlen((char *)marker_index2);
    *var_len = sizeof(long);    /* default to 'long' results */
    *index1 = ifIndex;
     strcpy((char *)index2, (char *)marker_index2);
     *index2_len = strlen((char *)index2);
    return TRUE;

}
static int
header_PrioIfClassificationModeTable(struct variable *vp,
                                            oid * name,
                                            size_t * length,
                                            int exact,
                                            size_t * var_len,
                                            WriteMethod ** write_method)
{
    oid         newname[MAX_OID_LEN];
    int         interface;
    int         result;
    I32_T       ifindex = 0;
    BOOL_T  return_val = FALSE;
    UI32_T      oid_name_length = 16;
    UI32_T  mode;

    memcpy((char *) newname, (char *) vp->name,
           (int) vp->namelen * sizeof(oid));
    /*
     * find "next"
     */
    for (ifindex = 1; ifindex < SYS_ADPT_TRUNK_1_IF_INDEX_NUMBER; ifindex ++, return_val=FALSE)
    {
        if ( (return_val = L4_PMGR_QOS_GetQosIfMappingMode(ifindex, &mode)) == TRUE)
        {
            newname[oid_name_length] = (oid)ifindex;
            result = snmp_oid_compare(name, *length, newname, (int) vp->namelen + 1);
            if ((exact && (result == 0)) || (!exact && (result < 0)))
            {
                break;
            }
        }
    }
    if (return_val != TRUE)
    {
        return -1;
    }
    memcpy((char *) name, (char *) newname, ((int) vp->namelen + 1)*sizeof(oid));
    *length = vp->namelen + 1;
    *var_len = sizeof(long);    /* default to 'long' results */
    interface = newname[oid_name_length];
    return interface;
}

static int
header_PrioDscpToCosTable(struct variable *vp,
                                         oid * name,
                                         size_t * length,
                                         int exact,
                                         size_t * var_len,
                                         WriteMethod ** write_method,UI32_T *cos,UI32_T *cfi)
{
    UI32_T  ifindex = 0,phb = 0,color = 0;

    if(l_snmp_3_index_get(vp,name,length,&ifindex,&phb,&color,exact) < 0 )
        return MATCH_FAILED;
    /*
     * find "next" interface
     */
    if(!exact){
      if(ifindex == 0 && phb == 0 && color ==0)
      {
          ifindex = 1;
          phb = 0;
          color = 0;
          if(L4_PMGR_QOS_GetIngressDscp2Cos(ifindex,phb,color,cos,cfi)!=TRUE)
              return MATCH_FAILED;
      }
      else
      {
          if(L4_PMGR_QOS_GetNextIngressDscp2Cos(&ifindex,&phb,&color,cos,cfi)!=TRUE)
              return MATCH_FAILED;
      }
      l_snmp_3_index_set(vp,name,length,ifindex,phb,color);
    }
    else
    {
      if(L4_PMGR_QOS_GetIngressDscp2Cos(ifindex,phb,color,cos,cfi)!=TRUE)
          return MATCH_FAILED;
    }

    *write_method = 0;
    *var_len = sizeof(long);    /* default to 'long' results */

    return MATCH_SUCCEEDED;
}
static int
header_prioPrioToDropPrecTable(struct variable *vp,
                                         oid * name,
                                         size_t * length,
                                         int exact,
                                         size_t * var_len,
                                         WriteMethod ** write_method,UI32_T *ifindex,UI32_T *phb)
{
    oid         newname[MAX_OID_LEN];
    int         result;
    //UI32_T        cos,cfi,phb1,color1;
    BOOL_T  return_val=FALSE;
    UI32_T      oid_name_length = 16,ifindex1,match = 0,pre_color[MAX_phb_val + 1],prec1;

    memcpy((char *) newname, (char *) vp->name,(int) vp->namelen * sizeof(oid));
    /*
    * find "next"
    */
    for (ifindex1 = 1; ifindex1 < SYS_ADPT_TRUNK_1_IF_INDEX_NUMBER; ifindex1 ++, return_val=FALSE)
    {
        if (( return_val =  L4_PMGR_QOS_GetIngressDscp2Color(ifindex1,(UI8_T *)pre_color)) == TRUE)
        {
            for (prec1 = 0;prec1 <= MAX_phb_val;prec1 ++)
            {
                newname[oid_name_length] = (oid)ifindex1;
                newname[oid_name_length + 1] = (oid)prec1;
                result = snmp_oid_compare(name, *length, newname, (int) vp->namelen + 2);
                if ((exact && (result == 0)) || (!exact && (result < 0)))
                {
                    match = 1;
                    break;
                }
            }
        }
        if (match == 1)
            break;
    }
    if (return_val != TRUE)
    return -1;

    memcpy((char *) name, (char *) newname, ((int) vp->namelen + 2)*sizeof(oid));
    *length = vp->namelen + 2;
    *var_len = sizeof(long);    /* default to 'long' results */
    *ifindex = newname[oid_name_length];
    *phb = newname[oid_name_length + 1];
    return 0;
}
static int
header_PrioDscpToQueueTable(
    struct variable *vp,
    oid * name,
    size_t * length,
    int exact,
    size_t * var_len,
    WriteMethod ** write_method,
    UI32_T *ifindex,
    UI32_T *phb)
{
    oid newname[MAX_OID_LEN];
    int result;
    BOOL_T return_val=FALSE;
    UI32_T oid_name_length = 16,ifindex1,match = 0;
    UI8_T  queue[MAX_phb_val + 1],prec1;

    memcpy((char *) newname, (char *) vp->name,(int) vp->namelen * sizeof(oid));
    /*
    * find the index (ifindex, phb)
    */
    for (ifindex1 = 1; ifindex1 < SYS_ADPT_TRUNK_1_IF_INDEX_NUMBER; ifindex1 ++, return_val=FALSE)
    {
#if (SYS_CPNT_COS_ING_INTER_DSCP_TO_QUEUE_PER_PORT == TRUE)
        if (( return_val =  L4_PMGR_QOS_GetPortIngressDscp2Queue(ifindex1, queue)) == TRUE)
#else
        if (( return_val =  L4_PMGR_QOS_GetIngressDscp2Queue(queue)) == TRUE)
#endif /* #if (SYS_CPNT_COS_ING_INTER_DSCP_TO_QUEUE_PER_PORT == TRUE) */
        {
            for (prec1 = 0;prec1 <= MAX_phb_val;prec1 ++)
            {
                newname[oid_name_length] = (oid)ifindex1;
                newname[oid_name_length + 1] = (oid)prec1;
                result = snmp_oid_compare(name, *length, newname, (int) vp->namelen + 2);
                if ((exact && (result == 0)) || (!exact && (result < 0)))
                {
                    match = 1;
                    break;
                }
            }
       }
       if (match == 1)
            break;
    }
    if (return_val != TRUE)
    return -1;

    memcpy((char *) name, (char *) newname, ((int) vp->namelen + 2)*sizeof(oid));
    *length = vp->namelen + 2;
    *var_len = sizeof(long);    /* default to 'long' results */
    *ifindex = newname[oid_name_length];
    *phb = newname[oid_name_length + 1];
    return 0;
}
#define  prioDefaultPrioEntry_INSTANCE_LEN  1
static int
header_PrioDefaultPriorityTable(struct variable *vp,
                                          oid * name,
                                          size_t * length,
                                          int exact,
                                          size_t * var_len,
                                          WriteMethod ** write_method,UI32_T *ifindex)
{
    UI32_T      compc=0,ifindex1;
    oid         compl[prioDefaultPrioEntry_INSTANCE_LEN];
    int         i;
    PRI_MGR_Dot1dPortPriorityEntry_T entry;
    memset(&entry, 0, sizeof(entry));
    /*check compc, retrive compl*/
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,compl, prioDefaultPrioEntry_INSTANCE_LEN);

    if (exact)/*get,set*/
    {
        if(compl[0]>0 && compl[0]<SYS_ADPT_TRUNK_1_IF_INDEX_NUMBER )
        {
            *ifindex = compl[0];
            return 0;
        }
        return -1;
    }
    else/*getnext*/
    {
        if(compc == 0)
        {
            ifindex1 = 1;
        }
        else if(compl[0]>0 && compl[0]<SYS_ADPT_TRUNK_1_IF_INDEX_NUMBER-1 )
        {
            ifindex1 = compl[0]+1;
        }
        else
            return -1;

        for (i = ifindex1;i < SYS_ADPT_TRUNK_1_IF_INDEX_NUMBER;i ++)
        {
            if (TRUE == PRI_PMGR_GetDot1dPortPriorityEntry(i,&entry))
            {
                *ifindex = i;
                return 0;
            }
        }
        return -1;
    }
}

/* This entry is used for entry which have the ability to row create*/
static COS_TYPE_AclCosEntry_T prioAclToCosMappingEntry;

/*
 * var_prioAclToCosMappingTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_prioAclToCosMappingTable(struct variable *vp,
                             oid * name,
                             size_t * length,
                             int exact,
                             size_t * var_len, WriteMethod ** write_method)
{
    /* variables we may use later */

    UI32_T index1 = 0,index2_len = 0, retval;
    I8_T index2[SYS_ADPT_ACL_MAX_NAME_LEN+1];


    COS_TYPE_AclCosEntry_T  entry;

   /* Give default value for the record first
    * We use the row_status = 0 to indicate if this set operation is Set by field
    * or set by record(included row creation), if the row_status =0, this record
    * mean set by field, otherwise, we just think it is a normal set operation
    */
    prioAclToCosMappingEntry.cos=COS_TYPE_DEFAULT_COS;
    prioAclToCosMappingEntry.row_status = 0;


   /*Since this table allow for entry that does not exist, (creation). we need to know the write method first*/
    switch(vp->magic)
     {
      case PRIOACLTOCOSMAPPINGCOSVALUE:
        *write_method = write_prioAclToCosMappingCosValue;
       break;
      case PRIOACLTOCOSMAPPINGSTATUS:
        *write_method = write_prioAclToCosMappingStatus;
      break;
    default:
      ERROR_MSG("");
    }



    memset( &entry, 0, sizeof(entry));

     retval  = header_prioAclToCosMappingTable(vp, name, length, exact, var_len, write_method,  &index1,index2, &index2_len);

    if (retval == MATCH_FAILED)
        return NULL;


   memcpy(entry.acl_name,index2, index2_len);



    if (L4_PMGR_COS_GetCosEntry(index1, &entry)!= TRUE)
            return NULL;

    /*
     * * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
      case PRIOACLTOCOSMAPPINGIFINDEX:
        long_return =index1;
        return (u_char *) &long_return;
      case PRIOACLTOCOSMAPPINGACLNAME:
         strcpy(return_buf, index2);
        *var_len = strlen(return_buf);
        return (u_char *)return_buf;
    #endif
      case PRIOACLTOCOSMAPPINGCOSVALUE:
        *write_method = write_prioAclToCosMappingCosValue;
         long_return =entry.cos;
        return (u_char *) &long_return;
      case PRIOACLTOCOSMAPPINGSTATUS:
        *write_method = write_prioAclToCosMappingStatus;
         long_return =entry.row_status;
        return (u_char *) &long_return;
    default:
        ERROR_MSG("");
    }
    return NULL;
}


int
write_prioAclToCosMappingCosValue(int action,
                                  u_char * var_val,
                                  u_char var_val_type,
                                  size_t var_val_len,
                                  u_char * statP,
                                  oid * name, size_t name_len)
{
    int i;
    I8_T buffer[SYS_ADPT_ACL_MAX_NAME_LEN+1];
     UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;



    if ((char) name[oid_name_length-1] != PRIOACLTOCOSMAPPINGCOSVALUE)
    {
        return SNMP_ERR_NOTWRITABLE;
    }

    /* check 2: name[oid_name_length] = the length of the aclname, check if these exceed the max size*/
    if (name[oid_name_length+1] > SYS_ADPT_ACL_MAX_NAME_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    /* check 3: check if the input index is exactly match, if not return fail*/
    if (name_len!= name[oid_name_length+1]+ 2+ oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }


    for (i = 0; i< name[oid_name_length+1]; i++)
    {
        buffer[i] = name[oid_name_length+2+i];
    }
    buffer[name[oid_name_length+1]] = '\0';

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len != sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          /* In reserve2, we overwrite the set value to prioAclToCosMappingEntry*/
          prioAclToCosMappingEntry.cos = *(long *)var_val;
          if ((prioAclToCosMappingEntry.cos < MIN_prioAclToCosMappingCosValue) || (prioAclToCosMappingEntry.cos > MAX_prioAclToCosMappingCosValue))
              return SNMP_ERR_WRONGVALUE;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
         /* For row creation, if row_status =0, mean that this is a normal
          * operation, we do the normal set operation, otherwise it is a row
          * creation operation, will do nothing here, and the overall entry
          * will perform in the write_xxxRowStatus function.
          */
         if (prioAclToCosMappingEntry.row_status == 0)
        {
             strcpy((char *)prioAclToCosMappingEntry.acl_name, (char *)buffer);

             if (L4_PMGR_COS_SetCosEntry (name[oid_name_length], &prioAclToCosMappingEntry) != TRUE)
         {
             return SNMP_ERR_COMMITFAILED;
          }
         }
          break;
        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_prioAclToCosMappingStatus(int action,
                                u_char * var_val,
                                u_char var_val_type,
                                size_t var_val_len,
                                u_char * statP,
                                oid * name, size_t name_len)
{
    int i;
    I8_T buffer[SYS_ADPT_ACL_MAX_NAME_LEN+1];
     UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;



    if ((char) name[oid_name_length-1] != PRIOACLTOCOSMAPPINGSTATUS)
    {
        return SNMP_ERR_NOTWRITABLE;
    }

    /* check 2: name[oid_name_length] = the length of the aclname, check if these exceed the max size*/
    if (name[oid_name_length+1] > SYS_ADPT_ACL_MAX_NAME_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    /* check 3: check if the input index is exactly match, if not return fail*/
    if (name_len!= name[oid_name_length+1]+ 2+ oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }


    for (i = 0; i< name[oid_name_length+1]; i++)
    {
        buffer[i] = name[oid_name_length+2+i];
    }
    buffer[name[oid_name_length+1]] = '\0';

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len != sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          /* In reserve2, we overwrite the set value to aclIngressIpMaskEntry*/
          prioAclToCosMappingEntry.row_status = *(long *)var_val;
          if ((prioAclToCosMappingEntry.row_status < VAL_prioAclToCosMappingStatus_active) || (prioAclToCosMappingEntry.row_status > VAL_prioAclToCosMappingStatus_destroy))
              return SNMP_ERR_WRONGVALUE;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
            prioAclToCosMappingEntry.row_status = prioAclToCosMappingEntry.row_status;
            strcpy((char *)prioAclToCosMappingEntry.acl_name, (char *)buffer);
            if (L4_PMGR_COS_SetCosEntryRowStatus (name[oid_name_length], &prioAclToCosMappingEntry) != TRUE)
         {
             return SNMP_ERR_COMMITFAILED;
          }
          break;
        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_prioIfClassificationModeStatus(int action,
                                u_char * var_val,
                                u_char var_val_type,
                                size_t var_val_len,
                                u_char * statP,
                                oid * name, size_t name_len)
{
    int mode;
    //I8_T buffer[SYS_ADPT_ACL_MAX_NAME_LEN+1];
     UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len != sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          /* In reserve2, we overwrite the set value to aclIngressIpMaskEntry*/
          mode = *(long *)var_val;
          if ((mode <0) || (mode >2))
             return SNMP_ERR_WRONGVALUE;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
          mode = * (long *) var_val;
           if (!L4_PMGR_QOS_SetQosIfMappingMode(name[oid_name_length], mode))
          {
             return SNMP_ERR_COMMITFAILED;
          }
          break;
        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
unsigned char  *
var_prioIfClassificationModeTable(struct variable *vp,
                             oid * name,
                             size_t * length,
                             int exact,
                             size_t * var_len, WriteMethod ** write_method)
{
    /* variables we may use later */

    UI32_T interface,mode;
    //I8_T index2[SYS_ADPT_ACL_MAX_NAME_LEN+1];



   /*Since this table allow for entry that does not exist, (creation). we need to know the write method first*/
    switch(vp->magic)
     {
      case PRIOIFCLASSIFICATIONMODESTATUS:
        *write_method = write_prioIfClassificationModeStatus;
      break;
    default:
      ERROR_MSG("");
    }
    interface =
        header_PrioIfClassificationModeTable(vp, name, length, exact, var_len, write_method);
    if (interface == -1)
    {
        return NULL;
    }
    if (!L4_PMGR_QOS_GetQosIfMappingMode(interface, &mode))
    {
        return NULL;
    }
    /*
     * * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
      case PRIOIFCLASSIFICATIONMODESTATUS:
         long_return = mode;
        return (u_char *) &long_return;
    default:
        ERROR_MSG("");
    }
    return NULL;
}

#if (SYS_CPNT_COS_ING_COS_TO_INTER_DSCP == TRUE)
#if (SYS_CPNT_COS_ING_COS_TO_INTER_DSCP_PER_PORT == TRUE)

#define PRIOCOSTODSCPENTRY_INSTANCE_LEN  3

BOOL_T
prioCosToDscpTable_OidIndexToData(
    UI32_T exact,
    UI32_T compc,
    oid *compl,
    UI32_T *ifindex_p,
    UI32_T *cos_p,
    UI32_T *cfi_p)
{
    *ifindex_p = 0;
    *cos_p = COS_TYPE_UNKNOWN_COS;
    *cfi_p = COS_TYPE_UNKNOWN_CFI;

    if (exact)
    {
        if (PRIOCOSTODSCPENTRY_INSTANCE_LEN != compc)
        {
            return FALSE;
        }
    }

    if (0 < compc)
    {
        *ifindex_p = compl[0];
        if (1 < compc)
        {
            *cos_p = compl[1];
            if (2 < compc)
            {
               *cfi_p = compl[2];
            }
        }
    }

    return TRUE;
}

/*
 * var_prioCosToDscpTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *var_prioCosToDscpTable(
    struct variable *vp,
    oid *name,
    size_t *length,
    int exact,
    size_t *var_len,
    WriteMethod **write_method)
{
    UI32_T compc = 0;
    oid compl[PRIOCOSTODSCPENTRY_INSTANCE_LEN] = {0};
    oid best_inst[PRIOCOSTODSCPENTRY_INSTANCE_LEN] = {0};
    UI32_T ifindex, cos, cfi, phb, color;

    switch (vp->magic)
    {
        case PRIOCOSTODSCPDSCPVALUE:
            *write_method = write_prioCosToDscpDscpValue;
            break;

        case PRIOCOSTODSCPPHBVALUE:
            *write_method = write_prioCosToDscpPhbValue;
            break;

        case PRIOCOSTODSCPCOLORVALUE:
            *write_method = write_prioCosToDscpColorValue;
            break;

        default:
            *write_method = 0;
            break;
    }

    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl, PRIOCOSTODSCPENTRY_INSTANCE_LEN);

    if (prioCosToDscpTable_OidIndexToData(exact, compc, compl, &ifindex, &cos, &cfi) == FALSE)
    {
        return NULL;
    }


    if (exact)
    {
        if (COS_TYPE_E_NONE !=
            L4_PMGR_QOS_GetPortCos2InternalDscp(ifindex, COS_TYPE_PRIORITY_USER, cos, cfi, &phb, &color))
        {
            return NULL;
        }
    }
    else /* getnext */
    {
        if (COS_TYPE_E_NONE !=
            L4_PMGR_QOS_GetNextPortCos2InternalDscp(&ifindex, COS_TYPE_PRIORITY_USER, &cos, &cfi, &phb, &color))
        {
            return NULL;
        }
    }

    memcpy(name, vp->name, vp->namelen * sizeof(oid));

    /* assign data to the oid index
     */
    best_inst[0] = ifindex;
    best_inst[1] = cos;
    best_inst[2] = cfi;
    memcpy(name + vp->namelen, best_inst, PRIOCOSTODSCPENTRY_INSTANCE_LEN * sizeof(oid));
    *length = vp->namelen + PRIOCOSTODSCPENTRY_INSTANCE_LEN;
    *var_len = sizeof(long_return);

    switch (vp->magic)
    {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case PRIOCOSTODSCPIFVALUE:
            long_return = ifindex;
            return (u_char *) &long_return;

        case PRIOCOSTODSCPCOSVALUE:
            long_return = cos
            return (u_char *) &long_return;

        case PRIOCOSTODSCPCFIVALUE:
            long_return = cfi;
            return (u_char *) &long_return;
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

        case PRIOCOSTODSCPDSCPVALUE:
            long_return = ((phb<<2) + color);
            return (u_char *) &long_return;

        case PRIOCOSTODSCPPHBVALUE:
            long_return = phb;
            return (u_char *) &long_return;

        case PRIOCOSTODSCPCOLORVALUE:
            long_return = color;
            return (u_char *) &long_return;

        default:
            ERROR_MSG("");
    }

    return NULL;
}

int write_prioCosToDscpDscpValue(
    int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    UI32_T dscp, phb, color;

    dscp = *(long *)var_val;
    phb = dscp>>2;
    color = dscp&0x3;

    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            if ( MAX_phb_val < phb || MAX_color_val < color || color == 2)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
            UI32_T ifindex, cos, cfi, dscp;

            if (TRUE != prioCosToDscpTable_OidIndexToData(TRUE, name_len - oid_name_length,
                            &(name[oid_name_length]), &ifindex, &cos, &cfi))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            if (COS_TYPE_E_NONE != L4_PMGR_QOS_SetPortCos2InternalDscp(ifindex,
                                       COS_TYPE_PRIORITY_USER, cos, cfi, phb, color))
            {
                return SNMP_ERR_COMMITFAILED;
            }
            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

int write_prioCosToDscpPhbValue(
    int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    UI32_T phb;

    phb = *(long *)var_val;

    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            if (phb < MIN_phb_val || MAX_phb_val < phb)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
            UI32_T ifindex, cos, cfi;
            UI32_T old_phb, old_color;

            if (TRUE != prioCosToDscpTable_OidIndexToData(TRUE, name_len - oid_name_length,
                            &(name[oid_name_length]), &ifindex, &cos, &cfi))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            if (COS_TYPE_E_NONE != L4_PMGR_QOS_GetPortCos2InternalDscp(ifindex,
                                       COS_TYPE_PRIORITY_USER, cos, cfi, &old_phb, &old_color))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            if (COS_TYPE_E_NONE != L4_PMGR_QOS_SetPortCos2InternalDscp(ifindex,
                                       COS_TYPE_PRIORITY_USER, cos, cfi, phb, old_color))
            {
                return SNMP_ERR_COMMITFAILED;
            }
            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

int write_prioCosToDscpColorValue(
    int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    UI32_T color;

    color = *(long *)var_val;

    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            if (color < MIN_color_val || MAX_color_val < color || color == 2)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
            I32_T value = 0;
            UI32_T ifindex, cos, cfi;
            UI32_T old_phb, old_color;

            if (TRUE != prioCosToDscpTable_OidIndexToData(TRUE, name_len - oid_name_length,
                            &(name[oid_name_length]), &ifindex, &cos, &cfi))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            if (COS_TYPE_E_NONE != L4_PMGR_QOS_GetPortCos2InternalDscp(ifindex,
                                       COS_TYPE_PRIORITY_USER, cos, cfi, &old_phb, &old_color))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            if (COS_TYPE_E_NONE != L4_PMGR_QOS_SetPortCos2InternalDscp(ifindex,
                                       COS_TYPE_PRIORITY_USER, cos, cfi, old_phb, color))
            {
                return SNMP_ERR_COMMITFAILED;
            }
            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

#endif /* SYS_CPNT_COS_ING_COS_TO_INTER_DSCP_PER_PORT */
#endif /* SYS_CPNT_COS_ING_COS_TO_INTER_DSCP*/

#if (SYS_CPNT_COS_ING_IP_PRECEDENCE_TO_INTER_DSCP == TRUE)
#if (SYS_CPNT_COS_ING_IP_PRECEDENCE_TO_INTER_DSCP_PER_PORT == TRUE)

#define PRIOPRECTODSCPENTRY_INSTANCE_LEN  2

BOOL_T
prioPrecToDscpTable_OidIndexToData(
    UI32_T exact,
    UI32_T compc,
    oid *compl,
    UI32_T *ifindex_p,
    UI32_T *precedence_p)
{
    *ifindex_p = 0;
    *precedence_p = COS_TYPE_UNKNOWN_PRE;

    if (exact)
    {
        if (PRIOPRECTODSCPENTRY_INSTANCE_LEN != compc)
        {
            return FALSE;
        }
    }

    if (0 < compc)
    {
        *ifindex_p = compl[0];
        if (1 < compc)
        {
            *precedence_p = compl[1];
        }
    }

    return TRUE;
}

/*
 * var_prioPrecToDscpTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *var_prioPrecToDscpTable(
    struct variable *vp,
    oid *name,
    size_t *length,
    int exact,
    size_t *var_len,
    WriteMethod **write_method)
{
    UI32_T compc = 0;
    oid compl[PRIOPRECTODSCPENTRY_INSTANCE_LEN] = {0};
    oid best_inst[PRIOPRECTODSCPENTRY_INSTANCE_LEN] = {0};
    UI32_T ifindex, precedence, phb, color;

    switch (vp->magic)
    {
        case PRIOPRECTODSCPDSCPVALUE:
            *write_method = write_prioPrecToDscpDscpValue;
            break;

        case PRIOPRECTODSCPPHBVALUE:
            *write_method = write_prioPrecToDscpPhbValue;
            break;

        case PRIOPRECTODSCPCOLORVALUE:
            *write_method = write_prioPrecToDscpColorValue;
            break;

        default:
            *write_method = 0;
            break;
    }

    /* check compc, retrive compl
     */
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl, PRIOPRECTODSCPENTRY_INSTANCE_LEN);

    if (FALSE == prioPrecToDscpTable_OidIndexToData(exact, compc, compl, &ifindex, &precedence))
    {
        return NULL;
    }

    if (exact)
    {
        if (COS_TYPE_E_NONE != L4_PMGR_QOS_GetPortPre2InternalDscp(ifindex,
                                   COS_TYPE_PRIORITY_USER, precedence, &phb, &color))
        {
            return NULL;
        }
    }
    else
    {
        if (COS_TYPE_E_NONE != L4_PMGR_QOS_GetNextPortPre2InternalDscp(&ifindex,
                                   COS_TYPE_PRIORITY_USER, &precedence, &phb, &color))
        {
            return NULL;
        }
    }

    memcpy(name, vp->name, vp->namelen * sizeof(oid));

    /* assign data to the oid index
     */
    best_inst[0] = ifindex;
    best_inst[1] = precedence;
    memcpy(name + vp->namelen, best_inst, PRIOPRECTODSCPENTRY_INSTANCE_LEN * sizeof(oid));
    *length = vp->namelen + PRIOPRECTODSCPENTRY_INSTANCE_LEN;
    *var_len = sizeof(long_return);

    switch (vp->magic)
    {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case PRIOPRECTODSCPIFVALUE:
            long_return = ifindex;
            return (u_char *) &long_return;

        case PRIOPRECTODSCPPRECVALUE:
            long_return = precedence;
            return (u_char *) &long_return;
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

        case PRIOPRECTODSCPDSCPVALUE:
            long_return = ((phb<<2) + color);
            return (u_char *) &long_return;

        case PRIOPRECTODSCPPHBVALUE:
            long_return = phb;
            return (u_char *) &long_return;

        case PRIOPRECTODSCPCOLORVALUE:
            *var_len = sizeof(long_return);
            long_return = color;
            return (u_char *) &long_return;

        default:
            ERROR_MSG("");
    }

    return NULL;
}

int write_prioPrecToDscpDscpValue(
    int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    UI32_T dscp, phb, color;

    dscp = *(long *)var_val;
    phb = dscp >> 2;
    color = dscp & 0x3;

    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            if (phb < MIN_phb_val || MAX_phb_val < phb ||
                color < MIN_color_val || MAX_color_val < color || color == 2)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
            UI32_T ifindex, precedence;

            if (FALSE == prioPrecToDscpTable_OidIndexToData(TRUE, name_len - oid_name_length,
                             &(name[oid_name_length]), &ifindex, &precedence))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            if (COS_TYPE_E_NONE != L4_PMGR_QOS_SetPortPre2InternalDscp(ifindex,
                                       COS_TYPE_PRIORITY_USER, precedence, phb, color))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

int write_prioPrecToDscpPhbValue(
    int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    UI32_T phb;
    phb = *(long *)var_val;

    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            if (phb < MIN_phb_val || MAX_phb_val < phb)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
            UI32_T ifindex, precedence;
            UI32_T old_phb, old_color;

            if (FALSE == prioPrecToDscpTable_OidIndexToData(TRUE, name_len - oid_name_length,
                             &(name[oid_name_length]), &ifindex, &precedence))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            if (COS_TYPE_E_NONE != L4_PMGR_QOS_GetPortPre2InternalDscp(ifindex,
                                      COS_TYPE_PRIORITY_USER, precedence, &old_phb, &old_color))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            if (COS_TYPE_E_NONE != L4_PMGR_QOS_SetPortPre2InternalDscp(ifindex,
                                       COS_TYPE_PRIORITY_USER, precedence, phb, old_color))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

int write_prioPrecToDscpColorValue(
    int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    UI32_T color;
    color = *(long *)var_val;

    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            if (color < MIN_color_val || MAX_color_val < color || color == 2)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
            UI32_T ifindex, precedence;
            UI32_T old_phb, old_color;

            if (FALSE == prioPrecToDscpTable_OidIndexToData(TRUE, name_len - oid_name_length,
                             &(name[oid_name_length]), &ifindex, &precedence))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            if (COS_TYPE_E_NONE != L4_PMGR_QOS_GetPortPre2InternalDscp(ifindex,
                                      COS_TYPE_PRIORITY_USER, precedence, &old_phb, &old_color))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            if (COS_TYPE_E_NONE != L4_PMGR_QOS_SetPortPre2InternalDscp(ifindex,
                                       COS_TYPE_PRIORITY_USER, precedence, old_phb, color))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}
#endif /* SYS_CPNT_COS_ING_IP_PRECEDENCE_TO_INTER_DSCP_PER_PORT */
#endif /* SYS_CPNT_COS_ING_IP_PRECEDENCE_TO_INTER_DSCP */

#if (SYS_CPNT_COS_ING_DSCP_TO_INTER_DSCP == TRUE)
#if (SYS_CPNT_COS_ING_DSCP_TO_INTER_DSCP_PER_PORT == TRUE)

#define PRIODSCPTODSCPENTRY_INSTANCE_LEN  2

BOOL_T
prioDscpToDscpTable_OidIndexToData(
    UI32_T exact,
    UI32_T compc,
    oid *compl,
    UI32_T *ifindex_p,
    UI32_T *dscp_p)
{
    *ifindex_p = 0;
    *dscp_p = COS_TYPE_UNKNOWN_DSCP;

    if (exact)
    {
        if (PRIODSCPTODSCPENTRY_INSTANCE_LEN != compc)
        {
            return FALSE;
        }
    }

    if (0 < compc)
    {
        *ifindex_p = compl[0];
        if (1 < compc)
        {
            *dscp_p = compl[1];
        }
    }

    return TRUE;
}

/*
 * var_prioDscpToDscpTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *var_prioDscpToDscpTable(
    struct variable *vp,
    oid *name,
    size_t *length,
    int exact,
    size_t *var_len,
    WriteMethod **write_method)
{
    UI32_T compc = 0;
    oid compl[PRIODSCPTODSCPENTRY_INSTANCE_LEN] = {0};
    oid best_inst[PRIODSCPTODSCPENTRY_INSTANCE_LEN] = {0};
    UI32_T ifindex, dscp, phb, color;

    switch (vp->magic)
    {
        case PRIODSCPTODSCPDSCPVALUE:
            *write_method = write_prioDscpToDscpDscpValue;
            break;

        case PRIODSCPTODSCPPHBVALUE:
            *write_method = write_prioDscpToDscpPhbValue;
            break;

        case PRIODSCPTODSCPCOLORVALUE:
            *write_method = write_prioDscpToDscpColorValue;
            break;

        default:
            *write_method = 0;
            break;
    }


    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl, PRIODSCPTODSCPENTRY_INSTANCE_LEN);

    if (FALSE == prioDscpToDscpTable_OidIndexToData(exact, compc, compl, &ifindex, &dscp))
    {
        return NULL;
    }

    if (exact) /* get or set */
    {
        if (COS_TYPE_E_NONE != L4_PMGR_QOS_GetPortDscp2InternalDscp(ifindex,
                                   COS_TYPE_PRIORITY_USER, dscp, &phb, &color))
        {
            return NULL;
        }
    }
    else /* getnext */
    {
        if (COS_TYPE_E_NONE != L4_PMGR_QOS_GetNextPortDscp2InternalDscp(&ifindex,
                                   COS_TYPE_PRIORITY_USER, &dscp, &phb, &color))
        {
            return NULL;
        }
    }

    memcpy(name, vp->name, vp->namelen * sizeof(oid));

    /* assign data to the oid index
     */
    best_inst[0] = ifindex;
    best_inst[1] = dscp;
    memcpy(name + vp->namelen, best_inst, PRIODSCPTODSCPENTRY_INSTANCE_LEN * sizeof(oid));
    *length = vp->namelen + PRIODSCPTODSCPENTRY_INSTANCE_LEN;
    *var_len = sizeof(long_return);

    switch (vp->magic)
    {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case PRIODSCPTODSCPIFVALUE:
            long_return = ifindex;
            return (u_char *) &long_return;

        case PRIODSCPTODSCPINGRESSDSCPVALUE:
            long_return = dscp;
            return (u_char *) &long_return;
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

        case PRIODSCPTODSCPDSCPVALUE:
            long_return = ((phb<<2) + color);
            return (u_char *) &long_return;

        case PRIODSCPTODSCPPHBVALUE:
            long_return = phb;
            return (u_char *) &long_return;

        case PRIODSCPTODSCPCOLORVALUE:
            long_return = color;
            return (u_char *) &long_return;

        default:
            ERROR_MSG("");
    }

    return NULL;
}

int write_prioDscpToDscpDscpValue(
    int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    UI32_T dscp, phb, color;

    dscp = *(long *)var_val;
    phb = dscp >> 2;
    color = dscp & 0x3;

    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            if (phb < MIN_phb_val || MAX_phb_val < phb ||
                color < MIN_color_val || MAX_color_val < color || color == 2)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
            I32_T value = 0;
            UI32_T ifindex, dscp;

            if (FALSE == prioDscpToDscpTable_OidIndexToData(TRUE, name_len - oid_name_length,
                             &(name[oid_name_length]), &ifindex, &dscp))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            if (COS_TYPE_E_NONE != L4_PMGR_QOS_SetPortDscp2InternalDscp(ifindex,
                                       COS_TYPE_PRIORITY_USER, dscp, phb, color))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

int write_prioDscpToDscpPhbValue(
    int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    UI32_T phb;
    phb = *(long *)var_val;

    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            if (phb < MIN_phb_val || MAX_phb_val < phb)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
            UI32_T ifindex, dscp;
            UI32_T old_phb, old_color;

            if (FALSE == prioDscpToDscpTable_OidIndexToData(TRUE, name_len - oid_name_length,
                             &(name[oid_name_length]), &ifindex, &dscp))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            if (COS_TYPE_E_NONE != L4_PMGR_QOS_GetPortDscp2InternalDscp(ifindex,
                                      COS_TYPE_PRIORITY_USER, dscp, &old_phb, &old_color))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            if (COS_TYPE_E_NONE != L4_PMGR_QOS_SetPortDscp2InternalDscp(ifindex,
                                       COS_TYPE_PRIORITY_USER, dscp, phb, old_color))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

int write_prioDscpToDscpColorValue(
    int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    UI32_T color;
    color = *(long *)var_val;

    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            if (color < MIN_color_val || MAX_color_val < color || color == 2)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
            UI32_T ifindex, dscp;
            UI32_T old_phb, old_color;

            if (FALSE == prioDscpToDscpTable_OidIndexToData(TRUE, name_len - oid_name_length,
                             &(name[oid_name_length]), &ifindex, &dscp))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            if (COS_TYPE_E_NONE != L4_PMGR_QOS_GetPortDscp2InternalDscp(ifindex,
                                      COS_TYPE_PRIORITY_USER, dscp, &old_phb, &old_color))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            if (COS_TYPE_E_NONE != L4_PMGR_QOS_SetPortDscp2InternalDscp(ifindex,
                                       COS_TYPE_PRIORITY_USER, dscp, old_phb, color))
            {
                return SNMP_ERR_COMMITFAILED;
            }


            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}
#endif /* SYS_CPNT_COS_ING_DSCP_TO_INTER_DSCP_PER_PORT */
#endif /* SYS_CPNT_COS_ING_DSCP_TO_INTER_DSCP */

#if (SYS_CPNT_COS_ING_IP_PORT_TO_INTER_DSCP == TRUE)
#if (SYS_CPNT_COS_ING_IP_PORT_TO_INTER_DSCP_PER_PORT == TRUE)

#define PRIODSTPORTTODSCPENTRY_INSTANCE_LEN  3

BOOL_T
prioDstPortToDscpTable_OidIndexToData(
    UI32_T exact,
    UI32_T compc,
    oid *compl,
    UI32_T *ifindex_p,
    UI32_T *protocol_p,
    UI32_T *dst_port_p)
{
    *ifindex_p = 0;
    *protocol_p = 0;
    *dst_port_p = 0;

    if (exact)
    {
        if (compc != PRIODSTPORTTODSCPENTRY_INSTANCE_LEN)
        {
            return FALSE;
        }
    }

    if (compc == PRIODSTPORTTODSCPENTRY_INSTANCE_LEN)
    {
        *ifindex_p = compl[0];
        *protocol_p = compl[1];
        *dst_port_p = compl[2];
    }

    return TRUE;
}

/*
 * var_prioDstPortToDscpTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *var_prioDstPortToDscpTable(
    struct variable *vp,
    oid *name,
    size_t *length,
    int exact,
    size_t *var_len,
    WriteMethod **write_method)
{
    UI32_T compc = 0;
    oid compl[PRIODSTPORTTODSCPENTRY_INSTANCE_LEN] = {0};
    oid best_inst[PRIODSTPORTTODSCPENTRY_INSTANCE_LEN] = {0};
    UI32_T ifindex, protocol, dst_port, phb, color;

    switch (vp->magic)
    {
        case PRIODSTPORTTODSCPDSCPVALUE:
            *write_method = write_prioDstPortToDscpDscpValue;
            break;

        case PRIODSTPORTTODSCPPHBVALUE:
            *write_method = write_prioDstPortToDscpPhbValue;
            break;

        case PRIODSTPORTTODSCPCOLORVALUE:
            *write_method = write_prioDstPortToDscpColorValue;
            break;

        default:
            *write_method = 0;
            break;
    }

    /* check compc, retrive compl
     */
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl, PRIODSTPORTTODSCPENTRY_INSTANCE_LEN);

    if (FALSE == prioDstPortToDscpTable_OidIndexToData(exact, compc, compl,
                     &ifindex, &protocol, &dst_port))
    {
        return NULL;
    }

    if (exact)
    {
        if (FALSE == L4_PMGR_QOS_GetTCPUDP2Dscp(ifindex, protocol, dst_port, &phb, &color))
        {
            return NULL;
        }
    }
    else /* getnext */
    {
        if(FALSE == L4_PMGR_QOS_GetNextTCPUDP2Dscp(&ifindex, &protocol, &dst_port, &phb, &color))
        {
            return NULL;
        }
    }

    memcpy(name, vp->name, vp->namelen * sizeof(oid));

    /* assign data to the oid index
     */
    best_inst[0] = ifindex;
    best_inst[1] = protocol;
    best_inst[2] = dst_port;
    memcpy(name + vp->namelen, best_inst, PRIODSTPORTTODSCPENTRY_INSTANCE_LEN * sizeof(oid));
    *length = vp->namelen + PRIODSTPORTTODSCPENTRY_INSTANCE_LEN;
    *var_len = sizeof(long_return);

    switch (vp->magic)
    {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case PRIODSTPORTTODSCPIFVALUE:
            long_return = ifindex;
            return (u_char *) &long_return;

        case PRIODSTPORTTODSCPPROTOCOLVALUE:
            long_return = protocol;
            return (u_char *) &long_return;

        case PRIODSTPORTTODSCPDSTPORTVALUE:
            long_return = dst_port;
            return (u_char *) &long_return;
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

        case PRIODSTPORTTODSCPDSCPVALUE:
            long_return = ((phb<<2) + color);
            return (u_char *) &long_return;

        case PRIODSTPORTTODSCPPHBVALUE:
            long_return = phb;
            return (u_char *) &long_return;

        case PRIODSTPORTTODSCPCOLORVALUE:
            long_return = color;
            return (u_char *) &long_return;

        default:
            ERROR_MSG("");
    }

    return NULL;
}

int write_prioDstPortToDscpDscpValue(
    int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    UI32_T dscp, phb, color;
    dscp = *(long *)var_val;
    phb = dscp >> 2;
    color = dscp & 0x3;

    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            if ( phb > MAX_phb_val  || color > MAX_color_val || color == 2)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
            UI32_T ifindex, protocol, dst_port;

            if (FALSE == prioDstPortToDscpTable_OidIndexToData(TRUE, name_len - oid_name_length,
                             &(name[oid_name_length]), &ifindex, &protocol, &dst_port))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            if (FALSE == L4_PMGR_QOS_SetTcpUdp2Dscp(ifindex, protocol, dst_port, phb, color ,FALSE))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

int write_prioDstPortToDscpPhbValue(
    int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    UI32_T phb;
    phb = *(long *)var_val;

    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
            UI32_T ifindex, protocol, dst_port;
            UI32_T old_phb, old_color;
            BOOL_T is_reset;

            if (FALSE == prioDstPortToDscpTable_OidIndexToData(TRUE, name_len - oid_name_length,
                             &(name[oid_name_length]), &ifindex, &protocol, &dst_port))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            if (FALSE == L4_PMGR_QOS_GetTCPUDP2Dscp(ifindex, protocol, dst_port, &old_phb, &old_color))
            {
                old_color = DFLT_color_val;
                if (phb < MIN_phb_val || MAX_phb_val < phb)
                {
                    // no entry to reset
                    return SNMP_ERR_COMMITFAILED;
                }
            }

            is_reset = FALSE;
            if (phb < MIN_phb_val || MAX_phb_val < phb)
            {
                is_reset = TRUE;
                phb = old_phb;
            }

            if (FALSE == L4_PMGR_QOS_SetTcpUdp2Dscp(ifindex, protocol, dst_port, phb, old_color, is_reset))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

int write_prioDstPortToDscpColorValue(
    int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    UI32_T color;
    color = *(long *)var_val;

    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
            UI32_T ifindex, protocol, dst_port;
            UI32_T old_phb, old_color;
            BOOL_T is_reset;

            if (FALSE == prioDstPortToDscpTable_OidIndexToData(TRUE, name_len - oid_name_length,
                             &(name[oid_name_length]), &ifindex, &protocol, &dst_port))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            if (FALSE == L4_PMGR_QOS_GetTCPUDP2Dscp(ifindex, protocol, dst_port, &old_phb, &old_color))
            {
                old_phb = DFLT_phb_val;

                if (color < MIN_color_val || MAX_color_val < color || color == 2)
                {
                    // no entry to reset
                    return SNMP_ERR_COMMITFAILED;
                }
            }

            is_reset = FALSE;
            if (color < MIN_color_val || MAX_color_val < color || color == 2)
            {
                is_reset = TRUE;
                color = old_color;
            }

            if (FALSE == L4_PMGR_QOS_SetTcpUdp2Dscp(ifindex, protocol, dst_port, old_phb, color, is_reset))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}
#endif /* SYS_CPNT_COS_ING_IP_PORT_TO_INTER_DSCP_PER_PORT */
#endif /* SYS_CPNT_COS_ING_IP_PORT_TO_INTER_DSCP */

int
write_prioDscpToCosCFICosValue(int action,
                                u_char * var_val,
                                u_char var_val_type,
                                size_t var_val_len,
                                u_char * statP,
                                oid * name, size_t name_len)
{
    UI32_T value,cos_cfi,cfi,cos;
    //I8_T buffer[SYS_ADPT_ACL_MAX_NAME_LEN+1];
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;


    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len != sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          /* In reserve2, we overwrite the set value to aclIngressIpMaskEntry*/
          value = *(long *)var_val;
          cos_cfi = value;
          cfi = (cos_cfi>>3);
          cos = cos_cfi&0x7;
          if (cfi > MAX_cfi_val || cos > MAX_cos_val)
                  return SNMP_ERR_WRONGVALUE;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
          value = * (long *) var_val;
          cos_cfi = value;
          cfi = (cos_cfi>>3);
          cos = cos_cfi&0x7;
          if (L4_PMGR_QOS_SetIngressDscp2Cos((UI32_T)name[oid_name_length], (UI32_T)name[oid_name_length + 1],(UI32_T)name[oid_name_length + 2], cos, cfi )!= TRUE)
          {
             return SNMP_ERR_COMMITFAILED;
          }
          break;
        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
unsigned char  *
var_prioDscpToCosTable(struct variable *vp,
                             oid * name,
                             size_t * length,
                             int exact,
                             size_t * var_len, WriteMethod ** write_method)
{
    /* variables we may use later */

    UI32_T  cos = 0,cfi = 0,cos_cfi;
    if(MATCH_FAILED ==header_PrioDscpToCosTable(vp, name, length, exact, var_len, write_method,&cos,&cfi))
        return NULL;
    /*
     * * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
      case PRIODSCPTOCOSCFICOSVALUE:
        *write_method = write_prioDscpToCosCFICosValue;
        cos_cfi = (cfi<<3) + cos;
        long_return = cos_cfi;
        return (u_char *) &long_return;
    default:
        ERROR_MSG("");
    }
    return NULL;
}
int
write_prioPrioToDropPrecPrecValue(int action,
                                u_char * var_val,
                                u_char var_val_type,
                                size_t var_val_len,
                                u_char * statP,
                                oid * name, size_t name_len)
{
    UI32_T color,value;
    //I8_T buffer[SYS_ADPT_ACL_MAX_NAME_LEN+1];
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len != sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          /* In reserve2, we overwrite the set value to aclIngressIpMaskEntry*/
          value = *(long *)var_val;
          color = value;
          if (color > MAX_color_val ||color == 2)
                  return SNMP_ERR_WRONGVALUE;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
          value = * (long *) var_val;
          color = value;
           if (L4_PMGR_QOS_SetIngressDscp2Color((UI32_T)name[oid_name_length], (UI32_T)name[oid_name_length + 1], color )!= TRUE)
          {
             return SNMP_ERR_COMMITFAILED;
          }
          break;
        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
unsigned char  *
var_prioPrioToDropPrecTable(struct variable *vp,
                             oid * name,
                             size_t * length,
                             int exact,
                             size_t * var_len, WriteMethod ** write_method)
{
    /* variables we may use later */

    UI32_T interface,phb,color = 0;
    //I8_T index2[SYS_ADPT_ACL_MAX_NAME_LEN+1];
    UI8_T  pre_color[MAX_pre_val + 1]={0},pre;

   /*Since this table allow for entry that does not exist, (creation). we need to know the write method first*/
    switch(vp->magic)
     {
      case PRIOPRIOTODROPPRECPRECVALUE:
        *write_method = write_prioPrioToDropPrecPrecValue;
      break;
    default:
      ERROR_MSG("");
    }

    if (header_prioPrioToDropPrecTable(vp, name, length, exact, var_len, write_method,&interface,&phb) == -1)
        return NULL;

    if (L4_PMGR_QOS_GetIngressDscp2Color(interface,pre_color) != TRUE)
        return NULL;

    for (pre = 0;pre <= MAX_pre_val;pre ++)
    {
        if(pre == phb)
        {
            color = pre_color[pre];
            break;
        }
    }
    /*
     * * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
      case PRIOPRIOTODROPPRECPRECVALUE:
        long_return = (long)color;
        return (u_char *) &long_return;
    default:
        ERROR_MSG("");
    }
    return NULL;
}
int
write_prioDscpToQueueQueueValue(int action,
                                u_char * var_val,
                                u_char var_val_type,
                                size_t var_val_len,
                                u_char * statP,
                                oid * name, size_t name_len)
{
    UI32_T queue,value;
    //I8_T buffer[SYS_ADPT_ACL_MAX_NAME_LEN+1];
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len != sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          /* In reserve2, we overwrite the set value to aclIngressIpMaskEntry*/
          value = *(long *)var_val;
          queue = value;
          if (queue > MAX_queue_val )
            return SNMP_ERR_WRONGVALUE;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
            value = * (long *) var_val;
            queue = value;

            if (COS_TYPE_E_NONE != L4_PMGR_QOS_SetPortIngressPhb2Queue(
                                       (UI32_T)name[oid_name_length],
                                       COS_TYPE_PRIORITY_USER,
                                       (UI32_T)name[oid_name_length + 1],
                                       queue))
            {
                return SNMP_ERR_COMMITFAILED;
            }
            break;
        case UNDO:
             /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
            break;
    }
    return SNMP_ERR_NOERROR;
}

unsigned char  *
var_prioDscpToQueueTable(
    struct variable *vp,
    oid * name,
    size_t * length,
    int exact,
    size_t * var_len,
    WriteMethod ** write_method)
{
    /* variables we may use later */
    UI32_T ifindex, phb, queue;

    /*Since this table allow for entry that does not exist, (creation). we need to know the write method first*/
    switch(vp->magic)
    {
        case PRIODSCPTOQUEUEQUEUEVALUE:
            *write_method = write_prioDscpToQueueQueueValue;
        break;

        default:
            ERROR_MSG("");
    }

    if (header_PrioDscpToQueueTable(vp, name, length, exact, var_len, write_method, &ifindex, &phb) == -1)
        return NULL;

    if (COS_TYPE_E_NONE != L4_PMGR_QOS_GetPortIngressPhb2Queue(
                               ifindex, COS_TYPE_PRIORITY_USER, phb, &queue))
    {
        return NULL;
    }

    /*
     * * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic)
    {
        case PRIODSCPTOQUEUEQUEUEVALUE:
            long_return = queue;
            return (u_char *) &long_return;

        default:
            ERROR_MSG("");
    }

    return NULL;
}

int
write_prioDefaultPrioValue(int action,
                                u_char * var_val,
                                u_char var_val_type,
                                size_t var_val_len,
                                u_char * statP,
                                oid * name, size_t name_len)
{
    UI32_T prio,value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len != sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          /* In reserve2, we overwrite the set value to aclIngressIpMaskEntry*/
          value = *(long *)var_val;
          prio = value;
          if (prio > MAX_queue_val || prio < MIN_queue_val)
            return SNMP_ERR_WRONGVALUE;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
          value = * (long *) var_val;
          prio= value;
          if (PRI_PMGR_SetDot1dPortDefaultUserPriority((UI32_T)name[oid_name_length], prio)!= TRUE)
          {
             return SNMP_ERR_COMMITFAILED;
          }
          break;
        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
unsigned char  *
var_prioDefaultPrioTable(struct variable *vp,
                             oid * name,
                             size_t * length,
                             int exact,
                             size_t * var_len, WriteMethod ** write_method)
{
    /* variables we may use later */
    UI32_T interface = 0;
    PRI_MGR_Dot1dPortPriorityEntry_T  entry;
    oid best_inst[prioDefaultPrioEntry_INSTANCE_LEN];

    memset(&entry, 0, sizeof(entry));
   /*Since this table allow for entry that does not exist, (creation). we need to know the write method first*/
    switch(vp->magic)
     {
      case PRIODEFAULTPRIORITYVALUE:
        *write_method = write_prioDefaultPrioValue;
      break;
    default:
      ERROR_MSG("");
    }
    if (header_PrioDefaultPriorityTable(vp, name, length, exact, var_len, write_method,&interface) == -1)
        return NULL;

    if (PRI_PMGR_GetDot1dPortPriorityEntry(interface, &entry) != TRUE)
        return NULL;

    memcpy(name, vp->name, vp->namelen*sizeof(oid));
    best_inst[0] = interface;
    memcpy(name + vp->namelen, best_inst, prioDefaultPrioEntry_INSTANCE_LEN*sizeof(oid));
    *length = vp->namelen + prioDefaultPrioEntry_INSTANCE_LEN;
    *var_len = sizeof(long);    /* default to 'long' results */
    /*
     * * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
      case PRIODEFAULTPRIORITYVALUE:
        long_return = (UI8_T)entry.dot1d_port_default_user_priority;
        return (u_char *) &long_return;
    default:
        ERROR_MSG("");
    }
    return NULL;
}

/********************************************
 *************cosGlobalMgt*******************
 ********************************************
 */

#if (SYS_CPNT_COS_ING_COS_TO_INTER_DSCP == TRUE)
#if (SYS_CPNT_COS_ING_COS_TO_INTER_DSCP_PER_PORT == FALSE)

#define PRIOGLOBALCOSTODSCPENTRY_INSTANCE_LEN  2

BOOL_T
prioGlobalCosToDscpTable_OidIndexToData(
    UI32_T exact,
    UI32_T compc,
    oid *compl,
    UI32_T *cos_p,
    UI32_T *cfi_p)
{
    *cos_p = COS_TYPE_UNKNOWN_COS;
    *cfi_p = COS_TYPE_UNKNOWN_CFI;

    if (exact)
    {
        if (PRIOGLOBALCOSTODSCPENTRY_INSTANCE_LEN != compc)
        {
            return FALSE;
        }
    }

    if (0 < compc)
    {
        *cos_p = compl[0];
        if (1 < compc)
        {
            *cfi_p = compl[1];
        }
    }

    return TRUE;
}

/*
 * var_prioGlobalCosToDscpTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *var_prioGlobalCosToDscpTable(
    struct variable *vp,
    oid *name,
    size_t *length,
    int exact,
    size_t *var_len,
    WriteMethod **write_method)
{
    UI32_T compc = 0;
    oid compl[PRIOGLOBALCOSTODSCPENTRY_INSTANCE_LEN] = {0};
    oid best_inst[PRIOGLOBALCOSTODSCPENTRY_INSTANCE_LEN] = {0};
    UI32_T cos, cfi, phb, color;

    switch (vp->magic)
    {
        case PRIOGLOBALCOSTODSCPDSCPVALUE:
            *write_method = write_prioGlobalCosToDscpDscpValue;
            break;

        case PRIOGLOBALCOSTODSCPPHBVALUE:
            *write_method = write_prioGlobalCosToDscpPhbValue;
            break;

        case PRIOGLOBALCOSTODSCPCOLORVALUE:
            *write_method = write_prioGlobalCosToDscpColorValue;
            break;

        default:
            *write_method = 0;
            break;
    }

    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl, PRIOGLOBALCOSTODSCPENTRY_INSTANCE_LEN);

    if (prioGlobalCosToDscpTable_OidIndexToData(exact, compc, compl, &cos, &cfi) == FALSE)
    {
        return NULL;
    }


    if (exact)
    {
        if (COS_TYPE_E_NONE !=
            L4_PMGR_QOS_GetCos2InternalDscp(COS_TYPE_PRIORITY_USER, cos, cfi, &phb, &color))
        {
            return NULL;
        }
    }
    else /* getnext */
    {
        if (COS_TYPE_E_NONE !=
            L4_PMGR_QOS_GetNextCos2InternalDscp(COS_TYPE_PRIORITY_USER, &cos, &cfi, &phb, &color))
        {
            return NULL;
        }
    }

    memcpy(name, vp->name, vp->namelen * sizeof(oid));

    /* assign data to the oid index
     */
    best_inst[0] = cos;
    best_inst[1] = cfi;
    memcpy(name + vp->namelen, best_inst, PRIOGLOBALCOSTODSCPENTRY_INSTANCE_LEN * sizeof(oid));
    *length = vp->namelen + PRIOGLOBALCOSTODSCPENTRY_INSTANCE_LEN;
    *var_len = sizeof(long_return);

    switch (vp->magic)
    {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case PRIOGLOBALCOSTODSCPCOSVALUE:
            long_return = cos
            return (u_char *) &long_return;

        case PRIOGLOBALCOSTODSCPCFIVALUE:
            long_return = cfi;
            return (u_char *) &long_return;
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

        case PRIOGLOBALCOSTODSCPDSCPVALUE:
            long_return = ((phb<<2) + color);
            return (u_char *) &long_return;

        case PRIOGLOBALCOSTODSCPPHBVALUE:
            long_return = phb;
            return (u_char *) &long_return;

        case PRIOGLOBALCOSTODSCPCOLORVALUE:
            long_return = color;
            return (u_char *) &long_return;

        default:
            ERROR_MSG("");
    }

    return NULL;
}

int write_prioGlobalCosToDscpDscpValue(
    int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    UI32_T dscp, phb, color;

    dscp = *(long *)var_val;
    phb = dscp>>2;
    color = dscp&0x3;

    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            if ( MAX_phb_val < phb || MAX_color_val < color || color == 2)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
            UI32_T cos, cfi, dscp;

            if (TRUE != prioGlobalCosToDscpTable_OidIndexToData(TRUE, name_len - oid_name_length,
                            &(name[oid_name_length]), &cos, &cfi))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            if (COS_TYPE_E_NONE != L4_PMGR_QOS_SetCos2InternalDscp(
                                       COS_TYPE_PRIORITY_USER, cos, cfi, phb, color))
            {
                return SNMP_ERR_COMMITFAILED;
            }
            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

int write_prioGlobalCosToDscpPhbValue(
    int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    UI32_T phb;

    phb = *(long *)var_val;

    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            if (phb < MIN_phb_val || MAX_phb_val < phb)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
            UI32_T cos, cfi;
            UI32_T old_phb, old_color;

            if (TRUE != prioGlobalCosToDscpTable_OidIndexToData(TRUE, name_len - oid_name_length,
                            &(name[oid_name_length]), &cos, &cfi))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            if (COS_TYPE_E_NONE != L4_PMGR_QOS_GetCos2InternalDscp(
                                       COS_TYPE_PRIORITY_USER, cos, cfi, &old_phb, &old_color))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            if (COS_TYPE_E_NONE != L4_PMGR_QOS_SetCos2InternalDscp(
                                       COS_TYPE_PRIORITY_USER, cos, cfi, phb, old_color))
            {
                return SNMP_ERR_COMMITFAILED;
            }
            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

int write_prioGlobalCosToDscpColorValue(
    int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    UI32_T color;

    color = *(long *)var_val;

    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            if (color < MIN_color_val || MAX_color_val < color || color == 2)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
            I32_T value = 0;
            UI32_T cos, cfi;
            UI32_T old_phb, old_color;

            if (TRUE != prioGlobalCosToDscpTable_OidIndexToData(TRUE, name_len - oid_name_length,
                            &(name[oid_name_length]), &cos, &cfi))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            if (COS_TYPE_E_NONE != L4_PMGR_QOS_GetCos2InternalDscp(
                                       COS_TYPE_PRIORITY_USER, cos, cfi, &old_phb, &old_color))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            if (COS_TYPE_E_NONE != L4_PMGR_QOS_SetCos2InternalDscp(
                                       COS_TYPE_PRIORITY_USER, cos, cfi, old_phb, color))
            {
                return SNMP_ERR_COMMITFAILED;
            }
            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

#endif /* (SYS_CPNT_COS_ING_COS_TO_INTER_DSCP_PER_PORT == FALSE) */
#endif /* SYS_CPNT_COS_ING_COS_TO_INTER_DSCP*/

#if (SYS_CPNT_COS_ING_DSCP_TO_INTER_DSCP == TRUE)
#if (SYS_CPNT_COS_ING_DSCP_TO_INTER_DSCP_PER_PORT == FALSE)

#define PRIOGLOBALDSCPTODSCPENTRY_INSTANCE_LEN  1

BOOL_T
prioGlobalDscpToDscpTable_OidIndexToData(
    UI32_T exact,
    UI32_T compc,
    oid *compl,
    UI32_T *dscp_p)
{
    *dscp_p = COS_TYPE_UNKNOWN_DSCP;

    if (exact)
    {
        if (PRIOGLOBALDSCPTODSCPENTRY_INSTANCE_LEN != compc)
        {
            return FALSE;
        }
    }

    if (PRIOGLOBALDSCPTODSCPENTRY_INSTANCE_LEN == compc)
    {
        *dscp_p = compl[0];
    }

    return TRUE;
}

/*
 * var_prioGlobalDscpToDscpTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *var_prioGlobalDscpToDscpTable(
    struct variable *vp,
    oid *name,
    size_t *length,
    int exact,
    size_t *var_len,
    WriteMethod **write_method)
{
    UI32_T compc = 0;
    oid compl[PRIOGLOBALDSCPTODSCPENTRY_INSTANCE_LEN] = {0};
    oid best_inst[PRIOGLOBALDSCPTODSCPENTRY_INSTANCE_LEN] = {0};
    UI32_T dscp, phb, color;

    switch (vp->magic)
    {
        case PRIOGLOBALDSCPTODSCPPHBVALUE:
            *write_method = write_prioGlobalDscpToDscpPhbValue;
            break;

        case PRIOGLOBALDSCPTODSCPCOLORVALUE:
            *write_method = write_prioGlobalDscpToDscpColorValue;
            break;

        default:
            *write_method = 0;
            break;
    }

    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl, PRIOGLOBALDSCPTODSCPENTRY_INSTANCE_LEN);

    if (FALSE == prioGlobalDscpToDscpTable_OidIndexToData(exact, compc, compl, &dscp))
    {
        return NULL;
    }

    if (exact)
    {
        if (COS_TYPE_E_NONE != L4_PMGR_QOS_GetDscp2InternalDscp(
                                   COS_TYPE_PRIORITY_USER, dscp, &phb, &color))
        {
            return NULL;
        }
    }
    else
    {
        if (COS_TYPE_E_NONE != L4_PMGR_QOS_GetNextDscp2InternalDscp(
                                   COS_TYPE_PRIORITY_USER, &dscp, &phb, &color))
        {
            return NULL;
        }
    }

    memcpy(name, vp->name, vp->namelen * sizeof(oid));

    /* assign data to the oid index
     */
    best_inst[0] = dscp;
    memcpy(name + vp->namelen, best_inst, PRIOGLOBALDSCPTODSCPENTRY_INSTANCE_LEN * sizeof(oid));
    *length = vp->namelen + PRIOGLOBALDSCPTODSCPENTRY_INSTANCE_LEN;
    *var_len = sizeof(long_return);

    switch (vp->magic)
    {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case LEAF_prioGLOBALDscpToDscpIngressDscpValue:
            long_return = dscp;
            return (u_char *) &long_return;
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

        case PRIOGLOBALDSCPTODSCPPHBVALUE:
            long_return = phb;
            return (u_char *) &long_return;

        case PRIOGLOBALDSCPTODSCPCOLORVALUE:
            long_return = color;
            return (u_char *) &long_return;

        default:
            ERROR_MSG("");
    }

    return NULL;
}

int write_prioGlobalDscpToDscpPhbValue(
    int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    UI32_T phb;

    phb = *(long *)var_val;

    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            if (phb < MIN_phb_val || MAX_phb_val < phb)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
            UI32_T dscp;
            UI32_T old_phb, old_color;

            if (FALSE == prioGlobalDscpToDscpTable_OidIndexToData(TRUE, name_len - oid_name_length,
                             &(name[oid_name_length]), &dscp))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            if (COS_TYPE_E_NONE != L4_PMGR_QOS_GetDscp2InternalDscp(
                                      COS_TYPE_PRIORITY_USER, dscp, &old_phb, &old_color))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            if (COS_TYPE_E_NONE != L4_PMGR_QOS_SetDscp2InternalDscp(
                                       COS_TYPE_PRIORITY_USER, dscp, phb, old_color))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

int write_prioGlobalDscpToDscpColorValue(
    int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    UI32_T color;

    color = *(long *)var_val;

    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            if (color < MIN_color_val || MAX_color_val < color || color == 2)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
            UI32_T dscp;
            UI32_T old_phb, old_color;

            if (FALSE == prioGlobalDscpToDscpTable_OidIndexToData(TRUE, name_len - oid_name_length,
                             &(name[oid_name_length]), &dscp))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            if (COS_TYPE_E_NONE != L4_PMGR_QOS_GetDscp2InternalDscp(
                                      COS_TYPE_PRIORITY_USER, dscp, &old_phb, &old_color))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            if (COS_TYPE_E_NONE != L4_PMGR_QOS_SetDscp2InternalDscp(
                                       COS_TYPE_PRIORITY_USER, dscp, old_phb, color))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}
#endif /* (SYS_CPNT_COS_ING_DSCP_TO_INTER_DSCP_PER_PORT == FALSE) */
#endif /* SYS_CPNT_COS_ING_DSCP_TO_INTER_DSCP */

#if (SYS_CPNT_COS_ING_INTER_DSCP_TO_QUEUE == TRUE)
#if (SYS_CPNT_COS_ING_INTER_DSCP_TO_QUEUE_PER_PORT == FALSE)
#define PRIOGLOBALDSCPTOQUEUEENTRY_INSTANCE_LEN  1

static BOOL_T
prioGlobalDscpToQueueTable_get(
    int compc,
    oid *compl,
    UI32_T *phb,
    UI32_T *queue)
{
    if (compc < PRIOGLOBALDSCPTOQUEUEENTRY_INSTANCE_LEN)
    {
        return FALSE;
    }

    *phb = (UI32_T)compl[0];

    if (*phb < MIN_phb_val || *phb > MAX_phb_val)
    {
        return FALSE;
    }

    if (COS_TYPE_E_NONE != L4_PMGR_QOS_GetIngressPhb2Queue(
                               COS_TYPE_PRIORITY_USER, *phb, queue))
    {
        return FALSE;
    }

    return TRUE;
}

static BOOL_T
prioGlobalDscpToQueueTable_next(
    int compc,
    oid *compl,
    UI32_T *phb,
    UI32_T *queue)
{
    if (compc < PRIOGLOBALDSCPTOQUEUEENTRY_INSTANCE_LEN)
    {
        *phb = MIN_phb_val;
    }
    else
    {
        *phb = (UI32_T)compl[0];

        if (*phb < MAX_phb_val)
        {
            *phb += 1;
        }
        else
        {
            return FALSE;
        }
    }

    if (COS_TYPE_E_NONE != L4_PMGR_QOS_GetIngressPhb2Queue(
                               COS_TYPE_PRIORITY_USER, *phb, queue))
    {
        return FALSE;
    }

    return TRUE;
}

int
write_prioGlobalDscpToQueueQueueValue(
    int     action,
    u_char  *var_val,
    u_char  var_val_type,
    size_t  var_val_len,
    u_char  *statP,
    oid     *name,
    size_t  name_len)
{
    UI32_T queue, value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    switch ( action )
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }

            if (var_val_len != sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;

        case RESERVE2:
            value = *(long *)var_val;
            queue = value;
            if (queue > MAX_queue_val )
            {
                if(SNMP_MGR_IsDebugMode())
                {
                    SYSFUN_Debug_Printf("queue[%lu] > MAX_queue_val[%lu]\r\n",
                        queue, MAX_queue_val);
                }
                return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            /* Release any resources that have been allocated */
            break;

        case ACTION:
            value = * (long *) var_val;
            queue = value;

            if (COS_TYPE_E_NONE != L4_PMGR_QOS_SetIngressPhb2Queue(
                                       COS_TYPE_PRIORITY_USER,
                                       (UI32_T)name[oid_name_length],
                                       queue))
            {
                if(SNMP_MGR_IsDebugMode())
                {
                    SYSFUN_Debug_Printf("L4_PMGR_QOS_SetIngressPhb2Queue Fail:");
                    SYSFUN_Debug_Printf("PHB=[%lu], Queue=[%s]\r\n",
                        (UI32_T)name[oid_name_length], queue);
                }
                return SNMP_ERR_COMMITFAILED;
            }
            break;
        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }
    return SNMP_ERR_NOERROR;
}

unsigned char  *
var_prioGlobalDscpToQueueTable(
    struct variable *vp,
    oid * name,
    size_t * length,
    int exact,
    size_t * var_len,
    WriteMethod ** write_method)
{
    UI32_T phb, queue;
    UI32_T compc = 0;
    oid compl[PRIOGLOBALDSCPTOQUEUEENTRY_INSTANCE_LEN];
    oid next_inst[PRIOGLOBALDSCPTOQUEUEENTRY_INSTANCE_LEN];

   /* Since this table allow for entry that does not exist, (creation).
    * we need to know the write method first
    */
    switch(vp->magic)
    {
        case PRIOGLOBALDSCPTOQUEUEQUEUEVALUE:
            *write_method = write_prioGlobalDscpToQueueQueueValue;
            break;
        default:
            ERROR_MSG("");
            break;
    }

    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl,
        PRIOGLOBALDSCPTOQUEUEENTRY_INSTANCE_LEN);

    if (exact)/*get,set*/
    {
        if (!prioGlobalDscpToQueueTable_get(compc, compl, &phb, &queue))
        {
            return NULL;
        }
    }
    else/*getnext*/
    {
      if (!prioGlobalDscpToQueueTable_next(compc, compl, &phb, &queue))
      {
          return NULL;
      }
    }


    memcpy(name, vp->name, vp->namelen*sizeof(oid));
    next_inst[0] = phb;

    memcpy(name + vp->namelen, next_inst, PRIOGLOBALDSCPTOQUEUEENTRY_INSTANCE_LEN * sizeof(oid));
    *length = vp->namelen + PRIOGLOBALDSCPTOQUEUEENTRY_INSTANCE_LEN;
    *var_len = sizeof(long_return);

    /*
     * This is where we do the value assignments for the mib results.
     */
    switch (vp->magic)
    {
        case PRIOGLOBALDSCPTOQUEUEQUEUEVALUE:
            long_return = queue;
            return (u_char *) &long_return;
        default:
            ERROR_MSG("");
    }

    return NULL;
}
#endif /* #if (SYS_CPNT_COS_ING_INTER_DSCP_TO_QUEUE_PER_PORT == FALSE) */
#endif /* SYS_CPNT_COS_ING_INTER_DSCP_TO_QUEUE */

#endif /* end of #if(SYS_CPNT_COS == TRUE)*/


#if ((SYS_CPNT_QOS == SYS_CPNT_QOS_DIFFSERV) && (SYS_CPNT_QOS_V2 != TRUE))

/********************************************
 *************diffServMgt********************
 ********************************************
 */
int
get_diffServClassMapNextFree(netsnmp_mib_handler *handler,
                             netsnmp_handler_registration *reginfo,
                             netsnmp_agent_request_info *reqinfo,
                             netsnmp_request_info *requests)
{
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one.
     */

    switch (reqinfo->mode)
    {

    case MODE_GET:
    {
            UI32_T value;
            if (L4_DS_MGR_GetDiffServClassMapNextFree(&value)==TRUE)
            {
                long_return=value;
                snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, (u_char *)&long_return, sizeof(long_return));
            }
            else
            {
                 if(SNMP_MGR_IsDebugMode())
                 {
                     SYSFUN_Debug_Printf("get_diffServClassMapNextFree:L4_DS_MGR_GetDiffServClassMapNextFree return false\n");
                 }
                 return SNMP_ERR_GENERR;
            }
            break;
     }
     default:
        /*
         * we should never get here, so this is a really bad error
         */
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_diffServClassMapElementNextFree(netsnmp_mib_handler *handler,
                                    netsnmp_handler_registration *reginfo,
                                    netsnmp_agent_request_info *reqinfo,
                                    netsnmp_request_info *requests)
{
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one.
     */

    switch (reqinfo->mode) {

    case MODE_GET:
    {
            UI32_T value;
            if (L4_DS_MGR_GetDiffServClassMapElementNextFree(&value)==TRUE)
            {
                long_return=value;
                snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, (u_char *)&long_return, sizeof(long_return));
            }
            else
            {
                if(SNMP_MGR_IsDebugMode())
                 {
                     SYSFUN_Debug_Printf("get_diffServClassMapElementNextFree:L4_DS_MGR_GetDiffServClassMapElementNextFree return false\n");
                 }
                return SNMP_ERR_GENERR;
            }
            break;
     }
    default:
        /*
         * we should never get here, so this is a really bad error
         */
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}


/********************************************
 *************diffServClfrExtTable***********
 ********************************************
 */
#define diffServClfrExtEntry_INSTANCE_LEN 1

static BOOL_T diffServClfrExtTable_get(int      compc,
                                oid     *compl,
                                L4_TYPE_diffServClfrEntry_T   *data)
{
    if (compc !=diffServClfrExtEntry_INSTANCE_LEN)
    {
        return FALSE;
    }
    data->id=compl[0];

    if(SNMP_MGR_IsDebugMode())
        SYSFUN_Debug_Printf("diffServClfrExtTable_get:data->id=[%lu]\n", data->id);

    if (!L4_DS_MGR_GetClfr(data->id, data))
    {
        if(SNMP_MGR_IsDebugMode())
            SYSFUN_Debug_Printf("diffServClfrExtTable_get:L4_DS_MGR_GetClfr return false\n");
        return FALSE;
    }
    else
    {
        return TRUE;
    } /*End of if */
}

static BOOL_T diffServClfrExtTable_next(int      compc,
                                 oid     *compl,
                                 L4_TYPE_diffServClfrEntry_T    *data)
{
    oid tmp_compl[diffServClfrExtEntry_INSTANCE_LEN];

    /* Generate the instance of each table entry and find the
     * smallest instance that's larger than compc/compl.
     *
     * Step 1: Verify and extract the input key from "compc" and "compl"
     * Note: The number of input key is defined by "compc".
     *       The key for the specified instance is defined in compl.
     */
    memcpy(tmp_compl, compl, sizeof(tmp_compl));
    SNMP_MGR_ConvertRemainToZero(compc,diffServClfrExtEntry_INSTANCE_LEN, tmp_compl);

    data->id=tmp_compl[0];

    if(SNMP_MGR_IsDebugMode())
    {
        SYSFUN_Debug_Printf("diffServClfrExtTable_next:data->id=[%lu]\n", data->id);
    }

    if (compc<diffServClfrExtEntry_INSTANCE_LEN)
    {
        if (!L4_DS_MGR_GetClfr(data->id, data))
        {
            if (!L4_DS_MGR_GetNextClfr( &data->id, data))
            {
                if(SNMP_MGR_IsDebugMode())
                    SYSFUN_Debug_Printf("diffServClfrExtTable_next: get & genext return false\n");
                return FALSE;
            }
        }
    }
    else
    {
        if (!L4_DS_MGR_GetNextClfr( &data->id, data))
        {
            if(SNMP_MGR_IsDebugMode())
                SYSFUN_Debug_Printf("diffServClfrExtTable_next: get & genext return false\n");
            return FALSE;
        }
    }
    return TRUE;
}


/*
 * var_diffServClfrExtTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_diffServClfrExtTable(struct variable *vp,
                         oid * name,
                         size_t * length,
                         int exact,
                         size_t * var_len, WriteMethod ** write_method)
{
    UI32_T compc=0;
    oid compl[diffServClfrExtEntry_INSTANCE_LEN];
    oid best_inst[diffServClfrExtEntry_INSTANCE_LEN];
    L4_TYPE_diffServClfrEntry_T data;


    /*Since this table allow for entry that does not exist, (creation). we need to know the write method first*/
    switch (vp->magic)
    {
      case DIFFSERVCLFREXTNAME:
        *write_method = write_diffServClfrExtName;
        break;
      case DIFFSERVCLFREXTDESC:
        *write_method = write_diffServClfrExtDesc;
        break;
      default:
        *write_method =0;
         break;
    }

    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl, diffServClfrExtEntry_INSTANCE_LEN);

     /*check compc, retrive compl*/
    if (exact)/*get,set*/
    {
        if (!diffServClfrExtTable_get(compc, compl, &data))
            return NULL;
    }
    else/*getnext*/
    {
        if (!diffServClfrExtTable_next(compc, compl, &data))
        {
            return NULL;
        }
    }
    memcpy(name, vp->name, vp->namelen*sizeof(oid));
    best_inst[0]=data.id;
    memcpy(name + vp->namelen, best_inst, diffServClfrExtEntry_INSTANCE_LEN*sizeof(oid));
    *length = vp->namelen +diffServClfrExtEntry_INSTANCE_LEN;
    *var_len = sizeof(long_return);

    /*
     * * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
      case DIFFSERVCLFREXTNAME:
        strcpy(return_buf, data.name);
        *var_len = strlen(return_buf);
        return (u_char *) return_buf;
      case DIFFSERVCLFREXTDESC:
        strcpy(return_buf, data.desc);
        *var_len = strlen(return_buf);
        return (u_char *) return_buf;
    default:
        ERROR_MSG("");
    }
    return NULL;
}


int
write_diffServClfrExtName(int action,
                          u_char * var_val,
                          u_char var_val_type,
                          size_t var_val_len,
                          u_char * statP, oid * name, size_t name_len)
{

    UI32_T idx;

    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

      /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    idx = name[oid_name_length];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              return SNMP_ERR_WRONGTYPE;
          }
          /*maggie for bug es3552g-poe-38-00154,sync with cli/web*/
          if (var_val_len > sizeof(char)*MAXSIZE_diffServClfrExtName || var_val_len <  sizeof(char)*MINSIZE_diffServClfrExtName) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
          {
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
               UI8_T buffer[MAXSIZE_diffServClfrExtName+1];
               strncpy(buffer, var_val, var_val_len);
               buffer[var_val_len]= '\0';

              if(SNMP_MGR_IsDebugMode())
              {
                  SYSFUN_Debug_Printf("write_diffServClfrExtName:idx=[%lu], buffer=[%s]\n", idx, buffer);
              }
              if (L4_DS_MGR_SetDiffServClfrExtName (idx, buffer) != TRUE) /* Jason Yang fix ES3628C-38-00052 */
              {
                  if(SNMP_MGR_IsDebugMode())
                  {
                      SYSFUN_Debug_Printf("write_diffServClfrExtName:L4_DS_MGR_SetDiffServClfrExtName return false\n");
                  }
                  return SNMP_ERR_COMMITFAILED;
              }
         }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_diffServClfrExtDesc(int action,
                          u_char * var_val,
                          u_char var_val_type,
                          size_t var_val_len,
                          u_char * statP, oid * name, size_t name_len)
{

    UI32_T idx;

    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

      /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    idx = name[oid_name_length];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(char)*MAXSIZE_diffServClfrExtDesc) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
          {
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
               UI8_T buffer[MAXSIZE_diffServClfrExtDesc+1];
               strncpy(buffer, var_val, var_val_len);
               buffer[var_val_len]= '\0';

              if(SNMP_MGR_IsDebugMode())
              {
                  SYSFUN_Debug_Printf("write_diffServClfrExtDesc:idx=[%lu], buffer=[%s]\n", idx, buffer);
              }
              if (L4_DS_MGR_SetDiffServClfrExtDesc (idx, buffer) != TRUE) /* Jason Yang fix ES3628C-38-00052 */
              {

                  if(SNMP_MGR_IsDebugMode())
                  {
                      SYSFUN_Debug_Printf("write_diffServClfrExtDesc:L4_DS_MGR_SetDiffServClfrExtDesc return false\n");
                  }
                  return SNMP_ERR_COMMITFAILED;
              }
         }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


/********************************************
 *************diffServClassMapTable**********
 ********************************************
 */
#define diffServClassMapEntry_INSTANCE_LEN 1

static BOOL_T diffServClassMapTable_get(int      compc,
                                oid     *compl,
                                L4_TYPE_ClassMapEntry_T   *data)
{
    if (compc !=diffServClassMapEntry_INSTANCE_LEN)
    {
        return FALSE;
    }
    data->id=compl[0];

    if(SNMP_MGR_IsDebugMode())
    {
        SYSFUN_Debug_Printf("diffServClassMapTable_get:data->id=[%lu]\n", data->id);
    }
    if (!L4_DS_MGR_GetClassMap(data->id, data))
    {
        if(SNMP_MGR_IsDebugMode())
        {
            SYSFUN_Debug_Printf("diffServClassMapTable_get:L4_DS_MGR_GetClassMap return false\n");
        }
        return FALSE;
    }
    else
    {
        return TRUE;
    } /*End of if */
}

static BOOL_T diffServClassMapTable_next(int      compc,
                                 oid     *compl,
                                 L4_TYPE_ClassMapEntry_T    *data)
{
    oid tmp_compl[diffServClassMapEntry_INSTANCE_LEN];

    /* Generate the instance of each table entry and find the
     * smallest instance that's larger than compc/compl.
     *
     * Step 1: Verify and extract the input key from "compc" and "compl"
     * Note: The number of input key is defined by "compc".
     *       The key for the specified instance is defined in compl.
     */
    memcpy(tmp_compl, compl, sizeof(tmp_compl));
    SNMP_MGR_ConvertRemainToZero(compc,diffServClassMapEntry_INSTANCE_LEN, tmp_compl);

    data->id=tmp_compl[0];

    if(SNMP_MGR_IsDebugMode())
    {
        SYSFUN_Debug_Printf("diffServClassMapTable_next:data->id=[%lu]\n", data->id);
    }
    if (compc<diffServClassMapEntry_INSTANCE_LEN)
    {
        if (!L4_DS_MGR_GetClassMap(data->id, data))
        {
            if (!L4_DS_MGR_GetNextClassMap( &data->id, data))
            {
                if(SNMP_MGR_IsDebugMode())
                {
                    SYSFUN_Debug_Printf("diffServClassMapTable_next:L4_DS_MGR_GetNextClassMap return false\n");
                }
                return FALSE;
            }
        }
    }
    else
    {
        if (!L4_DS_MGR_GetNextClassMap( &data->id, data))
        {
            if(SNMP_MGR_IsDebugMode())
            {
                    SYSFUN_Debug_Printf("diffServClassMapTable_next:L4_DS_MGR_GetNextClassMap return false\n");
            }
            return FALSE;
        }
    }
    return TRUE;
}


/*
 * var_diffServClassMapTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_diffServClassMapTable(struct variable *vp,
                          oid * name,
                          size_t * length,
                          int exact,
                          size_t * var_len, WriteMethod ** write_method)
{
    UI32_T compc=0;
    oid compl[diffServClassMapEntry_INSTANCE_LEN];
    oid best_inst[diffServClassMapEntry_INSTANCE_LEN];
    L4_TYPE_ClassMapEntry_T data;


    /*Since this table allow for entry that does not exist, (creation). we need to know the write method first*/
    switch (vp->magic)
    {
      case DIFFSERVCLASSMAPNAME:
        *write_method = write_diffServClassMapName;
       break;
      case DIFFSERVCLASSMAPDESC:
        *write_method = write_diffServClassMapDesc;
        break;
      case DIFFSERVCLASSMAPTYPE:
        *write_method = write_diffServClassMapType;
        break;
      case DIFFSERVCALSSMAPSTATUS:
        *write_method = write_diffServCalssMapStatus;
        break;
      default:
        *write_method =0;
         break;
    }

    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl, diffServClassMapEntry_INSTANCE_LEN);

     /*check compc, retrive compl*/
    if (exact)/*get,set*/
    {
        if (!diffServClassMapTable_get(compc, compl, &data))
            return NULL;
    }
    else/*getnext*/
    {
        if (!diffServClassMapTable_next(compc, compl, &data))
        {
            return NULL;
        }
    }
    memcpy(name, vp->name, vp->namelen*sizeof(oid));
    best_inst[0]=data.id;
    memcpy(name + vp->namelen, best_inst, diffServClassMapEntry_INSTANCE_LEN*sizeof(oid));
    *length = vp->namelen +diffServClassMapEntry_INSTANCE_LEN;
    *var_len = sizeof(long_return);

    /*
     * * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
      case DIFFSERVCLASSMAPID:
        long_return =data.id;
        return (u_char *) &long_return;
    #endif
      case DIFFSERVCLASSMAPNAME:
        strcpy(return_buf, data.name);
        *var_len = strlen(return_buf);
        return (u_char *) return_buf;
      case DIFFSERVCLASSMAPDESC:
        strcpy(return_buf, data.desc);
        *var_len = strlen(return_buf);
        return (u_char *) return_buf;
      case DIFFSERVCLASSMAPTYPE:
        long_return =data.type;
        return (u_char *) &long_return;
      case DIFFSERVCALSSMAPSTATUS:
        long_return =data.status;
        return (u_char *) &long_return;
    default:
        ERROR_MSG("");
    }
    return NULL;
}


int
write_diffServClassMapName(int action,
                           u_char * var_val,
                           u_char var_val_type,
                           size_t var_val_len,
                           u_char * statP, oid * name, size_t name_len)
{

    UI32_T idx;

    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

      /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    idx = name[oid_name_length];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(char)*SYS_ADPT_DIFFSERV_MAX_NAME_LENGTH) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
          {
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
               UI8_T buffer[SYS_ADPT_DIFFSERV_MAX_NAME_LENGTH+1];
               strncpy(buffer, var_val, var_val_len);
               buffer[var_val_len]= '\0';

              if(SNMP_MGR_IsDebugMode())
              {
                      SYSFUN_Debug_Printf("write_diffServClassMapName:idx=[%lu], buffer=[%s]\n", idx, buffer);
              }
              if (L4_DS_MGR_SetDiffServClassMapName (idx, buffer) != TRUE) /* Jason Yang fix ES3628C-38-00052 */
              {
                  if(SNMP_MGR_IsDebugMode())
                  {
                      SYSFUN_Debug_Printf("write_diffServClassMapName:L4_DS_MGR_SetDiffServClassMapName return false\n");

                  }
                  return SNMP_ERR_COMMITFAILED;
              }
         }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_diffServClassMapDesc(int action,
                           u_char * var_val,
                           u_char var_val_type,
                           size_t var_val_len,
                           u_char * statP, oid * name, size_t name_len)
{

    UI32_T idx;

    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

      /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    idx = name[oid_name_length];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(char)*MAXSIZE_diffServClassMapDesc) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
          {
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
               UI8_T buffer[MAXSIZE_diffServClassMapDesc+1];
               strncpy(buffer, var_val, var_val_len);
               buffer[var_val_len]= '\0';

              if(SNMP_MGR_IsDebugMode())
              {
                  SYSFUN_Debug_Printf("write_diffServClassMapDesc:idx=[%lu], buffer=[%s]\n", idx, buffer);
              }
              if (L4_DS_MGR_SetDiffServClassMapDesc (idx, buffer) != TRUE) /* Jason Yang fix ES3628C-38-00052 */
              {
                  if(SNMP_MGR_IsDebugMode())
                  {
                      SYSFUN_Debug_Printf("write_diffServClassMapDesc:L4_DS_MGR_SetDiffServClassMapDesc return false\n");
                  }
                  return SNMP_ERR_COMMITFAILED;
              }
         }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_diffServClassMapType(int action,
                           u_char * var_val,
                           u_char var_val_type,
                           size_t var_val_len,
                           u_char * statP, oid * name, size_t name_len)
{

    UI32_T idx;
    UI32_T value;

    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

      /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    idx = name[oid_name_length];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          value = *(long *)var_val;
          if ((value < VAL_diffServClassMapType_matchAll) || (value > VAL_diffServClassMapType_matchAny))
              return SNMP_ERR_WRONGVALUE;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
          {
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
              value = *(long *)var_val;

              if(SNMP_MGR_IsDebugMode())
              {
                  SYSFUN_Debug_Printf("write_diffServClassMapType:idx=[%lu], value=[%lu]\n", idx, value);
              }
              if (L4_DS_MGR_SetDiffServClassMapType (idx, value) != TRUE) /* Jason Yang fix ES3628C-38-00052 */
              {
                  if(SNMP_MGR_IsDebugMode())
                  {
                      SYSFUN_Debug_Printf("write_diffServClassMapType:L4_DS_MGR_SetDiffServClassMapType return false\n");
                  }
                  return SNMP_ERR_COMMITFAILED;
              }
         }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_diffServCalssMapStatus(int action,
                             u_char * var_val,
                             u_char var_val_type,
                             size_t var_val_len,
                             u_char * statP, oid * name, size_t name_len)
{

    UI32_T idx;
    UI32_T value;

    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

      /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    idx = name[oid_name_length];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          value = *(long *)var_val;
          if ((value < VAL_diffServCalssMapStatus_active) || (value > VAL_diffServCalssMapStatus_destroy))
              return SNMP_ERR_WRONGVALUE;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
          {
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
              value = *(long *)var_val;

              if(SNMP_MGR_IsDebugMode())
              {
                  SYSFUN_Debug_Printf("write_diffServCalssMapStatus:idx=[%lu], value=[%ld]\n", idx, value);
              }
              if (L4_DS_MGR_SetDiffServClassMapStatus (idx, value) != TRUE) /* Jason Yang fix ES3628C-38-00052 */
              {
                  if(SNMP_MGR_IsDebugMode())
                  {
                      SYSFUN_Debug_Printf("write_diffServCalssMapStatus:L4_DS_MGR_SetDiffServClassMapType return false\n");
                  }
                  return SNMP_ERR_COMMITFAILED;
              }
         }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


/********************************************
 ******diffServClassMapElementTable**********
 ********************************************
 */
#define diffServClassMapElementEntry_INSTANCE_LEN 2

static BOOL_T diffServClassMapElementTable_get(int      compc,
                                oid     *compl,
                                L4_TYPE_ClassMapElementEntry_T   *data)
{
    if (compc !=diffServClassMapElementEntry_INSTANCE_LEN)
    {
        return FALSE;
    }
    data->id=compl[0];
    data->cmap_id = compl[1];

    if(SNMP_MGR_IsDebugMode())
    {
        SYSFUN_Debug_Printf("diffServClassMapElementTable_get:data->id=[%lu], data->cmap_id =[%lu]\n", data->id,data->cmap_id);
    }
    if (!L4_DS_MGR_GetClassMapElement(data->id, data))
    {
        if(SNMP_MGR_IsDebugMode())
        {
            SYSFUN_Debug_Printf("diffServClassMapElementTable_get:L4_DS_MGR_GetClassMapElement return false\n");
        }
        return FALSE;
    }
    else
    {
        return TRUE;
    } /*End of if */
}

static BOOL_T diffServClassMapElementTable_next(int      compc,
                                 oid     *compl,
                                 L4_TYPE_ClassMapElementEntry_T    *data)
{
    oid tmp_compl[diffServClassMapElementEntry_INSTANCE_LEN];

    /* Generate the instance of each table entry and find the
     * smallest instance that's larger than compc/compl.
     *
     * Step 1: Verify and extract the input key from "compc" and "compl"
     * Note: The number of input key is defined by "compc".
     *       The key for the specified instance is defined in compl.
     */
    memcpy(tmp_compl, compl, sizeof(tmp_compl));
    SNMP_MGR_ConvertRemainToZero(compc,diffServClassMapElementEntry_INSTANCE_LEN, tmp_compl);

    data->id=tmp_compl[0];
    data->cmap_id = tmp_compl[1];

    if(SNMP_MGR_IsDebugMode())
    {
        SYSFUN_Debug_Printf("diffServClassMapElementTable_next:data->id=[%lu], data->cmap_id=[%lu]\n", data->id,data->cmap_id);
    }
    if (compc<diffServClassMapElementEntry_INSTANCE_LEN)
    {
        if (!L4_DS_MGR_GetClassMapElement(data->id, data))
        {
            if (!L4_DS_MGR_GetNextClassMapElementByIndex( &data->id, data))
            {
                if(SNMP_MGR_IsDebugMode())
                {
                    SYSFUN_Debug_Printf("diffServClassMapElementTable_next:data->id=[%lu], data->cmap_id=[%lu]\n", data->id,data->cmap_id);
                }
                return FALSE;
            }
        }
    }
    else
    {
        if (!L4_DS_MGR_GetNextClassMapElementByIndex( &data->id, data))
        {
            if(SNMP_MGR_IsDebugMode())
            {
                    SYSFUN_Debug_Printf("diffServClassMapElementTable_next:data->id=[%lu], data->cmap_id=[%lu]\n", data->id,data->cmap_id);
            }
            return FALSE;
        }
    }
    return TRUE;
}


/*
 * var_diffServClassMapElementTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_diffServClassMapElementTable(struct variable *vp,
                                 oid * name,
                                 size_t * length,
                                 int exact,
                                 size_t * var_len,
                                 WriteMethod ** write_method)
{
    UI32_T compc=0;
    oid compl[diffServClassMapElementEntry_INSTANCE_LEN];
    oid best_inst[diffServClassMapElementEntry_INSTANCE_LEN];
    L4_TYPE_ClassMapElementEntry_T data;


    /*Since this table allow for entry that does not exist, (creation). we need to know the write method first*/
    switch (vp->magic)
    {
      case DIFFSERVCLASSMAPELEMENTSPECIFIC:
        *write_method = write_diffServClassMapElementSpecific;
        break;
      case DIFFSERVCLASSMAPELEMENTSTATUS:
        *write_method = write_diffServClassMapElementStatus;
        break;
      default:
        *write_method =0;
         break;
    }

    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl, diffServClassMapElementEntry_INSTANCE_LEN);

     /*check compc, retrive compl*/
    if (exact)/*get,set*/
    {
        if (!diffServClassMapElementTable_get(compc, compl, &data))
            return NULL;
    }
    else/*getnext*/
    {
        if (!diffServClassMapElementTable_next(compc, compl, &data))
        {
            return NULL;
        }
    }
    memcpy(name, vp->name, vp->namelen*sizeof(oid));
    best_inst[0]=data.id;
    best_inst[1]=data.cmap_id;
    memcpy(name + vp->namelen, best_inst, diffServClassMapElementEntry_INSTANCE_LEN*sizeof(oid));
    *length = vp->namelen +diffServClassMapElementEntry_INSTANCE_LEN;
    *var_len = sizeof(long_return);

    /*
     * * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
      case DIFFSERVCLASSMAPELEMENTID:
        long_return =data.cmap_id;
        return (u_char *) &long_return;
#endif
      case DIFFSERVCLASSMAPELEMENTSPECIFIC:
       {
        SNMP_TYPE_Oid_T snmpoid;
        if(SNMP_MGR_IsDebugMode())
        {
            print_dsoid(&data.specific);
        }
        if (L4_DS_MGR_DiffServRowPointerToOid(&data.specific, &snmpoid))
        {
            *var_len = snmpoid.oid_len * sizeof(oid);
            memcpy(oid_return, snmpoid.oid, *var_len);
            return (u_char *) oid_return;
        }
        else
        {
            if(SNMP_MGR_IsDebugMode())
                SYSFUN_Debug_Printf("var_diffServClassMapElementTable:L4_DS_MGR_DiffServRowPointerToOid return false\n");
            return NULL;
        }
      }
      case DIFFSERVCLASSMAPELEMENTSTATUS:
        long_return = data.status;
        return (u_char*) &long_return;
    default:
        ERROR_MSG("");
    }
    return NULL;
}


int
write_diffServClassMapElementSpecific(int action,
                                      u_char * var_val,
                                      u_char var_val_type,
                                      size_t var_val_len,
                                      u_char * statP,
                                      oid * name, size_t name_len)
{
    UI32_T idx1, idx2;

    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

      /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  2 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    idx1 = name[oid_name_length];
    idx2 = name[oid_name_length+1];

    switch (action) {
    case RESERVE1:

        if (var_val_type != ASN_OBJECT_ID) {

            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(oid)*SYS_ADPT_MAX_OID_COUNT) {

            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        break;
    case FREE:
        /*
         * Release any resources that have been allocated
         */
        break;
    case ACTION:
    {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
         SNMP_TYPE_Oid_T snmpoid;
         L4_DS_TYPE_Oid_T dsoid;
         memcpy(snmpoid.oid, var_val, var_val_len);
         snmpoid.oid_len=var_val_len;
         if (L4_DS_MGR_OidToDiffServRowPointer(&snmpoid, &dsoid))
         {
             if(SNMP_MGR_IsDebugMode())
             {
                 SYSFUN_Debug_Printf("write_diffServClassMapElementSpecific:idx1=[%lu], idx2=[%lu]\n", idx1, idx2);
                 print_dsoid(&dsoid);
             }
             if (!L4_DS_MGR_SetDiffServClassMapElementSpecific(idx1, idx2, &dsoid))
             {
                if(SNMP_MGR_IsDebugMode())
                    SYSFUN_Debug_Printf("write_diffServClassMapElementSpecific:L4_DS_MGR_SetDiffServClassMapElementSpecific return false\n");
                return SNMP_ERR_COMMITFAILED;
             }
         }
         else
         {
            if(SNMP_MGR_IsDebugMode())
                SYSFUN_Debug_Printf("write_diffServClassMapElementSpecific:L4_DS_MGR_OidToDiffServRowPointer return false\n");
         }
         break;
    }
    case UNDO:
        /*
         * Back out any changes made in the ACTION case
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_diffServClassMapElementStatus(int action,
                                    u_char * var_val,
                                    u_char var_val_type,
                                    size_t var_val_len,
                                    u_char * statP,
                                    oid * name, size_t name_len)
{

    UI32_T idx,idx2;
    UI32_T value;

    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

      /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  2 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    idx = name[oid_name_length];
    idx2= name[oid_name_length+1];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          value = *(long *)var_val;
          if ((value < VAL_diffServClassMapElementStatus_active) || (value > VAL_diffServClassMapElementStatus_destroy))
              return SNMP_ERR_WRONGVALUE;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
          {
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
              value = *(long *)var_val;

              if(SNMP_MGR_IsDebugMode())
              {
                  SYSFUN_Debug_Printf("write_diffServClassMapElementStatus:idx=[%lu], idx2=[%lu], value=[%ld]\n", idx, idx2, value);
              }
              if (L4_DS_MGR_SetDiffServClassMapElementStatus(idx, idx2, value) != TRUE) /* Jason Yang fix ES3628C-38-00052 */
              {
                  if(SNMP_MGR_IsDebugMode())
                  {
                      SYSFUN_Debug_Printf("write_diffServClassMapElementStatus:L4_DS_MGR_SetDiffServClassMapElementStatus return false\n");
                  }
                  return SNMP_ERR_COMMITFAILED;
              }
         }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}



/********************************************
 ****diffServMultiFieldClfrExtTable**********
 ********************************************
 */
/*
 * var_diffServMultiFieldClfrExtTable():
 *   This function is called every time the agent gets a request for
 *   a scalar variable that might be found within your mib section
 *   registered above.  It is up to you to do the right thing and
 *   return the correct value.
 *     You should also correct the value of "var_len" if necessary.
 *
 *   Please see the documentation for more information about writing
 *   module extensions, and check out the examples in the examples
 *   and mibII directories.
 */
#define diffServMultiFieldClfrExtEntry_INSTANCE_LEN 1

static BOOL_T diffServMultiFieldClfrExtTable_get(int      compc,
                                oid     *compl,
                                L4_TYPE_diffServMultiFieldClfrEntry_T   *data)
{
    if (compc !=diffServMultiFieldClfrExtEntry_INSTANCE_LEN)
    {
        return FALSE;
    }
    data->id=compl[0];

    if(SNMP_MGR_IsDebugMode())
    {
        SYSFUN_Debug_Printf("diffServMultiFieldClfrExtTable_get:data->id=[%lu]\n", data->id);
    }
    if (!L4_DS_MGR_GetMultiFieldClfr(data->id, data))
    {
        if(SNMP_MGR_IsDebugMode())
        {
            SYSFUN_Debug_Printf("diffServMultiFieldClfrExtTable_get:L4_DS_MGR_GetMultiFieldClfr return false\n");
        }
        return FALSE;
    }
    else
    {
        return TRUE;
    } /*End of if */
}

static BOOL_T diffServMultiFieldClfrExtTable_next(int      compc,
                                 oid     *compl,
                                 L4_TYPE_diffServMultiFieldClfrEntry_T    *data)
{
    oid tmp_compl[diffServMultiFieldClfrExtEntry_INSTANCE_LEN];

    /* Generate the instance of each table entry and find the
     * smallest instance that's larger than compc/compl.
     *
     * Step 1: Verify and extract the input key from "compc" and "compl"
     * Note: The number of input key is defined by "compc".
     *       The key for the specified instance is defined in compl.
     */
    memcpy(tmp_compl, compl, sizeof(tmp_compl));
    SNMP_MGR_ConvertRemainToZero(compc,diffServMultiFieldClfrExtEntry_INSTANCE_LEN, tmp_compl);

    data->id=tmp_compl[0];

    if(SNMP_MGR_IsDebugMode())
    {
        SYSFUN_Debug_Printf("diffServMultiFieldClfrExtTable_next:data->id=[%lu]\n", data->id);
    }
    if (compc<diffServMultiFieldClfrExtEntry_INSTANCE_LEN)
    {
        if (!L4_DS_MGR_GetMultiFieldClfr(data->id, data))
        {
            if (!L4_DS_MGR_GetNextMultiFieldClfr( &data->id, data))
            {
                if(SNMP_MGR_IsDebugMode())
                {
                    SYSFUN_Debug_Printf("diffServMultiFieldClfrExtTable_next:data->id=[%lu]\n", data->id);
                }
                return FALSE;
            }
        }
    }
    else
    {
        if (!L4_DS_MGR_GetNextMultiFieldClfr( &data->id, data))
        {
            if(SNMP_MGR_IsDebugMode())
            {
                SYSFUN_Debug_Printf("diffServMultiFieldClfrExtTable_next:data->id=[%lu]\n", data->id);
            }
            return FALSE;
        }
    }
    return TRUE;
}


/*
 * var_diffServMultiFieldClfrExtTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_diffServMultiFieldClfrExtTable(struct variable *vp,
                                   oid * name,
                                   size_t * length,
                                   int exact,
                                   size_t * var_len,
                                   WriteMethod ** write_method)
{
    UI32_T compc=0;
    oid compl[diffServMultiFieldClfrExtEntry_INSTANCE_LEN];
    oid best_inst[diffServMultiFieldClfrExtEntry_INSTANCE_LEN];
    L4_TYPE_diffServMultiFieldClfrEntry_T data;


    /*Since this table allow for entry that does not exist, (creation). we need to know the write method first*/
    switch (vp->magic)
    {
      case DIFFSERVMULTIFIELDCLFREXTTYPE:
        *write_method = write_diffServMultiFieldClfrExtType;
        break;
      case DIFFSERVMULTIFIELDCLFREXTVID:
        *write_method = write_diffServMultiFieldClfrExtVid;
        break;
      case DIFFSERVMULTIFIELDCLFREXTIPPRECEDENCE:
        *write_method = write_diffServMultiFieldClfrExtIpPrecedence;
        break;
      case DIFFSERVMULTIFIELDCLFREXTCLASSTYPE:
        *write_method = write_diffServMultiFieldClfrExtClassType;
        break;
      case DIFFSERVMULTIFIELDCLFREXTETHERTYPE:
        *write_method = write_diffServMultiFieldClfrExtEtherType;
        break;
      default:
        *write_method =0;
         break;
    }

    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl, diffServMultiFieldClfrExtEntry_INSTANCE_LEN);

     /*check compc, retrive compl*/
    if (exact)/*get,set*/
    {
        if (!diffServMultiFieldClfrExtTable_get(compc, compl, &data))
            return NULL;
    }
    else/*getnext*/
    {
        if (!diffServMultiFieldClfrExtTable_next(compc, compl, &data))
        {
            return NULL;
        }
    }
    memcpy(name, vp->name, vp->namelen*sizeof(oid));
    best_inst[0]=data.id;
    memcpy(name + vp->namelen, best_inst, diffServMultiFieldClfrExtEntry_INSTANCE_LEN*sizeof(oid));
    *length = vp->namelen +diffServMultiFieldClfrExtEntry_INSTANCE_LEN;
    *var_len = sizeof(long_return);

    /*
     * * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
      case DIFFSERVMULTIFIELDCLFREXTTYPE:
        long_return = L_STDLIB_Hton32(data.valid_zero);
        return (u_char*) &long_return;
      case DIFFSERVMULTIFIELDCLFREXTVID:
        long_return = data.vlan_id;
        return (u_char*) &long_return;
      case DIFFSERVMULTIFIELDCLFREXTIPPRECEDENCE:
        long_return = data.ip_precedence;
        return (u_char*) &long_return;
      case DIFFSERVMULTIFIELDCLFREXTCLASSTYPE:
        long_return = data.class_type;
        return (u_char*) &long_return;
      case DIFFSERVMULTIFIELDCLFREXTETHERTYPE:
        long_return = data.ethertype;
        return (u_char*) &long_return;
    default:
        ERROR_MSG("");
    }
    return NULL;
}


int
write_diffServMultiFieldClfrExtType(int action,
                                    u_char * var_val,
                                    u_char var_val_type,
                                    size_t var_val_len,
                                    u_char * statP,
                                    oid * name, size_t name_len)
{

    UI32_T idx;

    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;

      /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    idx = name[oid_name_length];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(UI32_T)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
          {
           UI32_T CapaIntegerType=0;
           UI32_T CapaInteger = 0;

           memcpy(&CapaIntegerType, var_val, var_val_len);
           CapaIntegerType = L_STDLIB_Ntoh32(CapaIntegerType);
           /* The following is for SNMPc 5.1 implentation, since we will get Octet type*/
           switch (var_val_len)
           {
            case 1:
               CapaInteger = (CapaIntegerType & 0xFF000000) >>24;
            break;
            case 2:
               CapaInteger = (CapaIntegerType & 0xFFFF0000) >>16;
            break;
            case 3:
               CapaInteger = (CapaIntegerType & 0xFFFFFF00) >> 8;
            break;
            case 4:
               CapaInteger = (CapaIntegerType & 0xFFFFFFFF) >> 0;
            break;
           }
           if(SNMP_MGR_IsDebugMode())
           {
             SYSFUN_Debug_Printf("write_diffServMultiFieldClfrExtType:idx=[%lu], CapaInteger=[%lu]\n", idx, CapaInteger);
           }
           if (L4_DS_MGR_SetDiffServMultiFieldClfrExtType(idx, CapaInteger )!= TRUE)
           {
                if(SNMP_MGR_IsDebugMode())
                {
                    SYSFUN_Debug_Printf("write_diffServMultiFieldClfrExtType:L4_DS_MGR_SetDiffServMultiFieldClfrExtType return false\n");
                }
                return SNMP_ERR_COMMITFAILED;
           }

           }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_diffServMultiFieldClfrExtVid(int action,
                                   u_char * var_val,
                                   u_char var_val_type,
                                   size_t var_val_len,
                                   u_char * statP,
                                   oid * name, size_t name_len)
{

    UI32_T idx;
    UI32_T value;

    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;

      /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    idx = name[oid_name_length];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_UNSIGNED) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(u_long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
          {
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
              value = *(u_long *)var_val;

              if(SNMP_MGR_IsDebugMode())
              {
                  SYSFUN_Debug_Printf("write_diffServMultiFieldClfrExtVid:idx=[%lu], value=[%ld]\n", idx, value);
              }
              if (L4_DS_MGR_SetDiffServMultiFieldClfrExtVid(idx, value) != TRUE) /* Jason Yang fix ES3628C-38-00052 */
              {
                  if(SNMP_MGR_IsDebugMode())
                  {
                      SYSFUN_Debug_Printf("write_diffServMultiFieldClfrExtVid:L4_DS_MGR_SetDiffServMultiFieldClfrExtVid return false\n");
                  }
                  return SNMP_ERR_COMMITFAILED;
              }
         }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_diffServMultiFieldClfrExtIpPrecedence(int action,
                                            u_char * var_val,
                                            u_char var_val_type,
                                            size_t var_val_len,
                                            u_char * statP,
                                            oid * name, size_t name_len)
{

    UI32_T idx;
    UI32_T value;

    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;

      /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    idx = name[oid_name_length];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          value = *(long *)var_val;
          if ((value < MIN_diffServMultiFieldClfrExtIpPrecedence) || (value > MAX_diffServMultiFieldClfrExtIpPrecedence))
              return SNMP_ERR_WRONGVALUE;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
          {
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
              value = *(long *)var_val;

              if(SNMP_MGR_IsDebugMode())
              {
                  SYSFUN_Debug_Printf("write_diffServMultiFieldClfrExtIpPrecedence:idx=[%lu], value=[%ld]\n", idx, value);
              }
              if (L4_DS_MGR_SetDiffServMultiFieldClfrExtIpPrecedence(idx, value) != TRUE) /* Jason Yang fix ES3628C-38-00052 */
              {
                  if(SNMP_MGR_IsDebugMode())
                  {
                      SYSFUN_Debug_Printf("write_diffServMultiFieldClfrExtIpPrecedence:L4_DS_MGR_SetDiffServMultiFieldClfrExtIpPrecedence return false\n");
                  }
                  return SNMP_ERR_COMMITFAILED;
              }
         }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_diffServMultiFieldClfrExtClassType(int action,
                                         u_char * var_val,
                                         u_char var_val_type,
                                         size_t var_val_len,
                                         u_char * statP,
                                         oid * name, size_t name_len)
{
    UI32_T          idx;
    UI32_T          value;

    UI32_T          oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;

    idx = name[oid_name_length];

    switch (action) {
    case RESERVE1:
        if (name_len != oid_name_length + diffServMultiFieldClfrExtEntry_INSTANCE_LEN)
        {
            return SNMP_ERR_WRONGLENGTH;
        }
        if (var_val_type != ASN_INTEGER) {
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:

        break;

    case FREE:
        /*
         * Release any resources that have been allocated
         */
        break;

    case ACTION:
        {
            /*
             * The variable has been stored in 'value' for you to use,
             * and you have just been asked to do something with it.
             * Note that anything done here must be reversable in the UNDO case
             */
            value = *(long *)var_val;

            if(SNMP_MGR_IsDebugMode())
            {
                SYSFUN_Debug_Printf("write_diffServMultiFieldClfrExtClassType:idx=[%lu], value=[%ld]\n", idx, value);
            }
            if (L4_DS_MGR_SetDiffServMultiFieldClfrExtClassType(idx, value) != TRUE)
            {
                if(SNMP_MGR_IsDebugMode())
                {
                    SYSFUN_Debug_Printf("write_diffServMultiFieldClfrExtClassType:L4_DS_MGR_SetDiffServMultiFieldClfrExtClassType return false\n");
                }
                return SNMP_ERR_COMMITFAILED;
            }
        }
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_diffServMultiFieldClfrExtEtherType(int action,
                                         u_char * var_val,
                                         u_char var_val_type,
                                         size_t var_val_len,
                                         u_char * statP,
                                         oid * name, size_t name_len)
{
    UI32_T          value;
    UI32_T          idx;

    UI32_T          oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;

    idx = name[oid_name_length];

    switch (action) {
    case RESERVE1:
        if (name_len != oid_name_length + diffServMultiFieldClfrExtEntry_INSTANCE_LEN)
        {
            return SNMP_ERR_WRONGLENGTH;
        }
        if (var_val_type != ASN_INTEGER) {
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        value = *(long *)var_val;
        if ((value < MIN_diffServMultiFieldClfrExtEtherType) ||
            (value > MAX_diffServMultiFieldClfrExtEtherType))
        {
            return SNMP_ERR_WRONGVALUE;
        }
        break;

    case FREE:
        /*
         * Release any resources that have been allocated
         */
        break;

    case ACTION:
        {
            /*
             * The variable has been stored in 'value' for you to use,
             * and you have just been asked to do something with it.
             * Note that anything done here must be reversable in the UNDO case
             */
            value = *(long *)var_val;

            if(SNMP_MGR_IsDebugMode())
            {
                SYSFUN_Debug_Printf("write_diffServMultiFieldClfrExtEtherType:idx=[%lu], value=[%ld]\n", idx, value);
            }
            if (L4_DS_MGR_SetDiffServMultiFieldClfrExtEtherType(idx, value) != TRUE)
            {
                if(SNMP_MGR_IsDebugMode())
                {
                    SYSFUN_Debug_Printf("write_diffServMultiFieldClfrExtEtherType:L4_DS_MGR_SetDiffServMultiFieldClfrExtEtherType return false\n");
                }
                return SNMP_ERR_COMMITFAILED;
            }
        }
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}


/********************************************
 ************diffServToSMarkActTable*********
 ********************************************
 */
#define diffServToSMarkActEntry_INSTANCE_LEN 1

static BOOL_T diffServToSMarkActTable_get(int      compc,
                                oid     *compl,
                                UI32_T   *value)
{
    if (compc !=diffServToSMarkActEntry_INSTANCE_LEN)
    {
        return FALSE;
    }

    *value = compl[0];

    if(SNMP_MGR_IsDebugMode())
    {
        SYSFUN_Debug_Printf("diffServToSMarkActTable_get:value=[%lu]\n", *value);
    }
    if (!L4_DS_MGR_GetDiffServDscpMarkActToS(value))
    {
        if(SNMP_MGR_IsDebugMode())
        {
            SYSFUN_Debug_Printf("diffServToSMarkActTable_get:L4_DS_MGR_GetDiffServDscpMarkActToS return false\n");
        }
        return FALSE;
    }
    else
    {
        return TRUE;
    } /*End of if */
}

static BOOL_T diffServToSMarkActTable_next(int      compc,
                                 oid     *compl,
                                 UI32_T    *value)
{
    oid tmp_compl[diffServToSMarkActEntry_INSTANCE_LEN];

    /* Generate the instance of each table entry and find the
     * smallest instance that's larger than compc/compl.
     *
     * Step 1: Verify and extract the input key from "compc" and "compl"
     * Note: The number of input key is defined by "compc".
     *       The key for the specified instance is defined in compl.
     */
    memcpy(tmp_compl, compl, sizeof(tmp_compl));
    SNMP_MGR_ConvertRemainToZero(compc,diffServToSMarkActEntry_INSTANCE_LEN, tmp_compl);

    *value=tmp_compl[0];

    if(SNMP_MGR_IsDebugMode())
    {
        SYSFUN_Debug_Printf("diffServToSMarkActTable_next:value=[%lu]\n", *value);
    }
    if (compc<diffServToSMarkActEntry_INSTANCE_LEN)
    {
        if (!L4_DS_MGR_GetDiffServDscpMarkActToS(value))
        {
            if (!L4_DS_MGR_GetNextDiffServDscpMarkActToS( value))
            {
                if(SNMP_MGR_IsDebugMode())
                {
                     SYSFUN_Debug_Printf("L4_DS_MGR_GetNextDiffServDscpMarkActToS:L4_DS_MGR_GetNextMultiFieldClfr return false");
                }
                return FALSE;
            }
        }
    }
    else
    {
        if (!L4_DS_MGR_GetNextDiffServDscpMarkActToS( value))
        {
            if(SNMP_MGR_IsDebugMode())
            {
                SYSFUN_Debug_Printf("L4_DS_MGR_GetNextDiffServDscpMarkActToS:L4_DS_MGR_GetNextMultiFieldClfr return false");
            }
            return FALSE;
        }
    }
    return TRUE;
}


/*
 * var_diffServToSMarkActTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_diffServToSMarkActTable(struct variable *vp,
                            oid * name,
                            size_t * length,
                            int exact,
                            size_t * var_len, WriteMethod ** write_method)
{
    UI32_T compc=0;
    oid compl[diffServToSMarkActEntry_INSTANCE_LEN];
    oid best_inst[diffServToSMarkActEntry_INSTANCE_LEN];
    UI32_T value;

    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl, diffServToSMarkActEntry_INSTANCE_LEN);

     /*check compc, retrive compl*/
    if (exact)/*get,set*/
    {
        if (!diffServToSMarkActTable_get(compc, compl, &value))
            return NULL;
    }
    else/*getnext*/
    {
        if (!diffServToSMarkActTable_next(compc, compl, &value))
        {
            return NULL;
        }
    }
    memcpy(name, vp->name, vp->namelen*sizeof(oid));
    best_inst[0]=value;
    memcpy(name + vp->namelen, best_inst, diffServToSMarkActEntry_INSTANCE_LEN*sizeof(oid));
    *length = vp->namelen +diffServToSMarkActEntry_INSTANCE_LEN;
    *var_len = sizeof(long_return);

    /*
     * * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
      case DIFFSERVTOSMARKACTTOS:
        long_return = value;
        return (u_char*) &long_return;
    default:
        ERROR_MSG("");
    }
    return NULL;
}


/********************************************
 ************diffServDot1pMarkActTable*******
 ********************************************
 */
#define diffServDot1pMarkActEntry_INSTANCE_LEN 1

static BOOL_T diffServDot1pMarkActTable_get(int      compc,
                                oid     *compl,
                                UI32_T   *value)
{
    if (compc !=diffServDot1pMarkActEntry_INSTANCE_LEN)
    {
        return FALSE;
    }

    *value = compl[0];

    if(SNMP_MGR_IsDebugMode())
    {
        SYSFUN_Debug_Printf("diffServDot1pMarkActTable_get:value=[%lu]\n", *value);
    }
    if (!L4_DS_MGR_GetDiffServDscpMarkActDot1p(value))
    {
        if(SNMP_MGR_IsDebugMode())
        {
            SYSFUN_Debug_Printf("diffServDot1pMarkActTable_get:L4_DS_MGR_GetDiffServDscpMarkActToS return false\n");
        }
        return FALSE;
    }
    else
    {
        return TRUE;
    } /*End of if */
}

static BOOL_T diffServDot1pMarkActTable_next(int      compc,
                                 oid     *compl,
                                 UI32_T    *value)
{
    oid tmp_compl[diffServDot1pMarkActEntry_INSTANCE_LEN];

    /* Generate the instance of each table entry and find the
     * smallest instance that's larger than compc/compl.
     *
     * Step 1: Verify and extract the input key from "compc" and "compl"
     * Note: The number of input key is defined by "compc".
     *       The key for the specified instance is defined in compl.
     */
    memcpy(tmp_compl, compl, sizeof(tmp_compl));
    SNMP_MGR_ConvertRemainToZero(compc,diffServDot1pMarkActEntry_INSTANCE_LEN, tmp_compl);

    *value=tmp_compl[0];

    if(SNMP_MGR_IsDebugMode())
    {
        SYSFUN_Debug_Printf("diffServDot1pMarkActTable_next:value=[%lu]\n", *value);
    }
    if (compc<diffServDot1pMarkActEntry_INSTANCE_LEN)
    {
        if (!L4_DS_MGR_GetDiffServDscpMarkActDot1p(value))
        {
            if (!L4_DS_MGR_GetNextDiffServDscpMarkActDot1p( value))
            {
                if(SNMP_MGR_IsDebugMode())
                {
                     SYSFUN_Debug_Printf("diffServDot1pMarkActTable_next:L4_DS_MGR_GetNextDiffServDscpMarkActDot1p return false");
                }
                return FALSE;
            }
        }
    }
    else
    {
        if (!L4_DS_MGR_GetNextDiffServDscpMarkActDot1p( value))
        {
            if(SNMP_MGR_IsDebugMode())
            {
                SYSFUN_Debug_Printf("diffServDot1pMarkActTable_next:L4_DS_MGR_GetNextDiffServDscpMarkActDot1p return false");
            }
            return FALSE;
        }
    }
    return TRUE;
}


/*
 * var_diffServDot1pMarkActTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_diffServDot1pMarkActTable(struct variable *vp,
                              oid * name,
                              size_t * length,
                              int exact,
                              size_t * var_len,
                              WriteMethod ** write_method)
{
    UI32_T compc=0;
    oid compl[diffServDot1pMarkActEntry_INSTANCE_LEN];
    oid best_inst[diffServDot1pMarkActEntry_INSTANCE_LEN];
    UI32_T value;

    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl, diffServDot1pMarkActEntry_INSTANCE_LEN);

     /*check compc, retrive compl*/
    if (exact)/*get,set*/
    {
        if (!diffServDot1pMarkActTable_get(compc, compl, &value))
            return NULL;
    }
    else/*getnext*/
    {
        if (!diffServDot1pMarkActTable_next(compc, compl, &value))
        {
            return NULL;
        }
    }
    memcpy(name, vp->name, vp->namelen*sizeof(oid));
    best_inst[0]=value;
    memcpy(name + vp->namelen, best_inst, diffServDot1pMarkActEntry_INSTANCE_LEN*sizeof(oid));
    *length = vp->namelen +diffServToSMarkActEntry_INSTANCE_LEN;
    *var_len = sizeof(long_return);

    /*
     * * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
      case DIFFSERVDOT1PMARKACTDOT1P:
        long_return = value;
        return (u_char*) &long_return;
    default:
        ERROR_MSG("");
    }
    return NULL;
}

#endif /* end of #if (SYS_CPNT_QOS == SYS_CPNT_QOS_DIFFSERV)*/


#if (SYS_CPNT_QOS_V2 == TRUE)


#define diffServPortEntry_INSTANCE_LEN 1

BOOL_T
diffServPortTable_OidIndexToData(
    UI32_T compc,
    oid *  compl,
    UI32_T *ifindex_p)
{
    *ifindex_p = 0;

    if (0 < compc)
    {
        if (compc != diffServPortEntry_INSTANCE_LEN)
        {
            return FALSE;
        }

        *ifindex_p = compl[0];
    }

    return TRUE;
}

unsigned char  *
var_diffServPortTable(struct variable *vp,
                    oid * name,
                    size_t * length,
                    int exact,
                    size_t * var_len, WriteMethod ** write_method)
{
    /*
     * variables we may use later
     */
    UI32_T compc=0;
    UI32_T index=0;
    oid compl[diffServPortEntry_INSTANCE_LEN];
    oid best_inst[diffServPortEntry_INSTANCE_LEN];
    RULE_TYPE_UI_PortEntry_T  entry;

    switch (vp->magic) {
      case DIFFSERVPORTPOLICYMAPINDEX:
        *write_method = write_diffServPortPolicyMapIndex;
        break;
      case DIFFSERVPORTINGRESSIPACLINDEX:
        *write_method = write_diffServPortIngressIpAclIndex;
        break;
      case DIFFSERVPORTINGRESSMACACLINDEX:
        *write_method = write_diffServPortIngressMacAclIndex;
        break;

#if (SYS_CPNT_ACL_IPV6 == TRUE)
      case DIFFSERVPORTINGRESSIPV6ACLINDEX:
        *write_method = write_diffServPortIngressIpv6AclIndex;
        break;
#endif
      default:
        *write_method = 0;
        break;
    }

    /*check compc, retrive compl*/
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,compl, diffServPortEntry_INSTANCE_LEN);

    if (FALSE == diffServPortTable_OidIndexToData(compc, compl, &index))
    {
        return NULL;
    }

    if (exact)
    {
        if (L4_PMGR_QoS_GetDiffServPortEntry(index, RULE_TYPE_INBOUND, &entry)!= TRUE)
        {
            return NULL;
        }
    }
    else
    {
        RULE_TYPE_InOutDirection_T direction = RULE_TYPE_INBOUND;

        if (L4_PMGR_QoS_GetNextDiffServPortEntry(&index, &direction, &entry)!= TRUE)
        {
            return NULL;
        }

        if (direction == RULE_TYPE_OUTBOUND)
        {
            /* FIXME: skip egress because this MIB node only support ingress
             */
            return NULL;
        }
    }

    memcpy(name, vp->name, vp->namelen*sizeof(oid));
    best_inst[0] = index;
    memcpy(name + vp->namelen, best_inst, diffServPortEntry_INSTANCE_LEN*sizeof(oid));
    *length = vp->namelen + diffServPortEntry_INSTANCE_LEN;

    *var_len = sizeof(long_return);

    switch (vp->magic) {
        #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
      case DIFFSERVPORTIFINDEX:
            long_return = index;
            return (u_char *) &long_return;
        #endif
      case DIFFSERVPORTPOLICYMAPINDEX:
            long_return = entry.policy_map_index;
            return (u_char *) &long_return;
      case DIFFSERVPORTINGRESSIPACLINDEX:
            long_return = entry.ingress_ip_acl_index;
            return (u_char *) &long_return;
      case DIFFSERVPORTINGRESSMACACLINDEX:
            long_return = entry.ingress_mac_acl_index;
            return (u_char *) &long_return;
#if (SYS_CPNT_ACL_IPV6 == TRUE)
      case DIFFSERVPORTINGRESSIPV6ACLINDEX:
            long_return = entry.ingress_ipv6_acl_index;
            return (u_char *) &long_return;
#endif
      default:
          ERROR_MSG("");
    }
    return NULL;
}


int write_diffServPortPolicyMapIndex(int       action,
                                         u_char    *var_val,
                                         u_char    var_val_type,
                                         size_t    var_val_len,
                                         u_char    *statP,
                                         oid       *name,
                                         size_t    name_len)
{
    long value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    /*check max length of the inputing index */
    if(name_len > oid_name_length+diffServPortEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }

        case RESERVE2:
        {
            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            UI32_T  index;
            index = name[oid_name_length];
            value = *(long *)var_val;
            if(L4_PMGR_QoS_SetDiffServPortPolicyMapIndex(index, RULE_TYPE_INBOUND, value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
            break;
        }

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }
    return SNMP_ERR_NOERROR;
}

int write_diffServPortIngressIpAclIndex(int       action,
                                         u_char    *var_val,
                                         u_char    var_val_type,
                                         size_t    var_val_len,
                                         u_char    *statP,
                                         oid       *name,
                                         size_t    name_len)
{
    long value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    /*check max length of the inputing index */
    if(name_len > oid_name_length+diffServPortEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }

        case RESERVE2:
        {
            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            UI32_T  index;
            index = name[oid_name_length];
            value = *(long *)var_val;
            if(L4_PMGR_QoS_SetDiffServPortIngressIpAclIndex(index, value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
            break;
        }

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }
    return SNMP_ERR_NOERROR;
}
int write_diffServPortIngressMacAclIndex(int       action,
                                         u_char    *var_val,
                                         u_char    var_val_type,
                                         size_t    var_val_len,
                                         u_char    *statP,
                                         oid       *name,
                                         size_t    name_len)
{
    long value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    /*check max length of the inputing index */
    if(name_len > oid_name_length+diffServPortEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }

        case RESERVE2:
        {
            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            UI32_T  index;
            index = name[oid_name_length];
            value = *(long *)var_val;
            if(L4_PMGR_QoS_SetDiffServPortIngressMacAclIndex(index, value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
            break;
        }

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }
    return SNMP_ERR_NOERROR;
}

#if (SYS_CPNT_ACL_IPV6 == TRUE)
int write_diffServPortIngressIpv6AclIndex(int       action,
                                         u_char    *var_val,
                                         u_char    var_val_type,
                                         size_t    var_val_len,
                                         u_char    *statP,
                                         oid       *name,
                                         size_t    name_len)
{
    long value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    /*check max length of the inputing index */
    if(name_len > oid_name_length+diffServPortEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }

        case RESERVE2:
        {
            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            UI32_T  index;
            index = name[oid_name_length];
            value = *(long *)var_val;
            if(L4_PMGR_QoS_SetDiffServPortIngressIpv6AclIndex(index, value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
            break;
        }

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }
    return SNMP_ERR_NOERROR;
}
#endif /* end of #if (SYS_CPNT_ACL_IPV6 == TRUE) */

#define diffServPolicyMapEntry_INSTANCE_LEN 1

static BOOL_T diffServPolicyMapTable_get(int      compc,
                                oid     *compl,
                                UI32_T  *index,
                                RULE_TYPE_MIB_PolicyMap_T   *data)
{
    if (compc !=diffServPolicyMapEntry_INSTANCE_LEN)
    {
        return FALSE;
    }
    *index = compl[0];
    memset(data, 0, sizeof(RULE_TYPE_MIB_PolicyMap_T));

    /*get data
     */
    if (L4_PMGR_QoS_GetDiffServPolicyMapEntry(*index,data)!=TRUE)
    {
        return FALSE;
    }
    else
    {
        return TRUE;
    } /*End of if */
}

static BOOL_T diffServPolicyMapTable_next(int      compc,
                                 oid     *compl,
                                 UI32_T  *index,
                                 RULE_TYPE_MIB_PolicyMap_T    *data)
{
    *index = compl[0];
    memset(data, 0, sizeof(RULE_TYPE_MIB_PolicyMap_T));
    /*check  the length of inputing index,if <1 we should try get {0.0.0.0.0...} */
    if (compc<1)
    {
        /*get data*/
        if (L4_PMGR_QoS_GetDiffServPolicyMapEntry(*index,data)!=TRUE)
        {
            /*get data*/
            if (L4_PMGR_QoS_GetNextDiffServPolicyMapEntry(index,data)!=TRUE)
            {
                return FALSE;
            }
        }
    }
    else
    {
        /*get data*/
        if (L4_PMGR_QoS_GetNextDiffServPolicyMapEntry(index,data)!=TRUE)
        {
            return FALSE;
        }
    }
    return TRUE;
}

unsigned char  *
var_diffServPolicyMapTable(struct variable *vp,
                         oid * name,
                         size_t * length,
                         int exact,
                         size_t * var_len, WriteMethod ** write_method)
{
    /*
     * variables we may use later
     */
    UI32_T compc=0;
    UI32_T index=0;
    oid compl[diffServPolicyMapEntry_INSTANCE_LEN];
    oid best_inst[diffServPolicyMapEntry_INSTANCE_LEN];
    RULE_TYPE_MIB_PolicyMap_T  entry;

    switch (vp->magic) {;
      case DIFFSERVPOLICYMAPNAME:
        *write_method = write_diffServPolicyMapName;
        break;
      case DIFFSERVPOLICYMAPDESCRIPTION:
        *write_method = write_diffServPolicyMapDescription;
        break;
      case DIFFSERVPOLICYMAPSTATUS:
        *write_method = write_diffServPolicyMapStatus;
        break;
    default:
        *write_method = 0;
        break;
    }

    /*check compc, retrive compl*/
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,compl, diffServPolicyMapEntry_INSTANCE_LEN);

    if (exact)/*get,set*/
    {
        if (!diffServPolicyMapTable_get(compc, compl,&index, &entry))
            return NULL;
    }
    else/*getnext*/
    {
        if (!diffServPolicyMapTable_next(compc, compl,&index,  &entry))
        {
            return NULL;
        }
    }

    memcpy(name, vp->name, vp->namelen*sizeof(oid));
    best_inst[0] = index;
    memcpy(name + vp->namelen, best_inst, diffServPolicyMapEntry_INSTANCE_LEN*sizeof(oid));
    *length = vp->namelen + diffServPolicyMapEntry_INSTANCE_LEN;

    switch (vp->magic) {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
      case DIFFSERVPOLICYMAPINDEX:
        long_return = index;
        *var_len = sizeof(long_return);
        return (u_char *) &long_return;
 #endif
      case DIFFSERVPOLICYMAPNAME:
        memcpy(return_buf,  entry.name,SYS_ADPT_DIFFSERV_MAX_NAME_LENGTH);
        *var_len  =   strlen((char *)entry.name);
        return (u_char*)return_buf;
      case DIFFSERVPOLICYMAPDESCRIPTION:
        memcpy(return_buf,  entry.desc,MAXSIZE_diffServPolicyMapDescription);
        *var_len  =  strlen((char *)entry.desc);
        return (u_char*)return_buf;
      case DIFFSERVPOLICYMAPELEMENTINDEXLIST:
        memcpy(return_buf,  entry.policy_map_element_index_list,MAXSIZE_diffServPolicyMapElementIndexList);
        *var_len  = entry.size_of_element_index_list;
        return (u_char*)return_buf;
      case DIFFSERVPOLICYMAPSTATUS:
        long_return = entry.row_status;
        *var_len = sizeof(long_return);
        return (u_char *) &long_return;
    default:
        ERROR_MSG("");
    }
    return NULL;
}

int write_diffServPolicyMapName(int       action,
                                         u_char    *var_val,
                                         u_char    var_val_type,
                                         size_t    var_val_len,
                                         u_char    *statP,
                                         oid       *name,
                                         size_t    name_len)
{
    int size;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    /*check max length of the inputing index */
    if(name_len > oid_name_length+diffServPolicyMapEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch (action)
    {
        case RESERVE1:
        {
            size = var_val_len;
            if (var_val_type != ASN_OCTET_STR)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if(size > SYS_ADPT_DIFFSERV_MAX_NAME_LENGTH)
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }
        case RESERVE2:
        {
            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            UI32_T  index;
            char    buffer[SYS_ADPT_DIFFSERV_MAX_NAME_LENGTH+1];
            index = name[oid_name_length];
            memcpy(buffer, var_val, var_val_len);
            buffer[var_val_len]='\0';
            if(!L_STDLIB_StrIsAsciiPrintWithCount((char *)buffer, var_val_len))
            {
                return SNMP_ERR_COMMITFAILED;
            }
            if (NULL != strpbrk((char *)buffer, invalid_char_in_name))
                return SNMP_ERR_COMMITFAILED;
            if(L4_PMGR_QoS_SetDiffServPolicyMapName(index, buffer) != TRUE)
                return SNMP_ERR_COMMITFAILED;
            break;
        }

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }
    return SNMP_ERR_NOERROR;
}

int write_diffServPolicyMapDescription(int       action,
                                         u_char    *var_val,
                                         u_char    var_val_type,
                                         size_t    var_val_len,
                                         u_char    *statP,
                                         oid       *name,
                                         size_t    name_len)
{
    int size;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    /*check max length of the inputing index */
    if(name_len > oid_name_length+diffServPolicyMapEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch (action)
    {
        case RESERVE1:
        {
            size = var_val_len;
            if (var_val_type != ASN_OCTET_STR)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if(size > MAXSIZE_diffServPolicyMapDescription)
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }
        case RESERVE2:
        {
            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            UI32_T  index;
            char     buffer[MAXSIZE_diffServPolicyMapDescription+1];
            index = name[oid_name_length];
            memcpy(buffer, var_val, var_val_len);
            buffer[var_val_len]='\0';
            if(!L_STDLIB_StrIsAsciiPrintWithCount((char *)buffer, var_val_len))
            {
                return SNMP_ERR_COMMITFAILED;
            }
            if (NULL != strpbrk((char *)buffer, invalid_char_in_desc))
                return SNMP_ERR_COMMITFAILED;
            if(L4_PMGR_QoS_SetDiffServPolicyMapDescription(index, buffer) != TRUE)
                return SNMP_ERR_COMMITFAILED;
            break;
        }

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }
    return SNMP_ERR_NOERROR;
}

int write_diffServPolicyMapStatus(int       action,
                                         u_char    *var_val,
                                         u_char    var_val_type,
                                         size_t    var_val_len,
                                         u_char    *statP,
                                         oid       *name,
                                         size_t    name_len)
{
    long value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    /*check max length of the inputing index */
    if(name_len > oid_name_length+diffServPolicyMapEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            if (*(long *)var_val < VAL_diffServPolicyMapElementStatus_active || *(long *)var_val>VAL_diffServPolicyMapElementStatus_destroy )
            {
                return SNMP_ERR_WRONGVALUE;
            }
            if (*(long *)var_val == VAL_diffServPolicyMapStatus_notReady)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }

        case RESERVE2:
        {
            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            UI32_T  index;
            index = name[oid_name_length];
            value = *(long *)var_val;
            if(L4_PMGR_QoS_SetDiffServPolicyMapStatus(index, value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
            break;
        }

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }
    return SNMP_ERR_NOERROR;
}


static UI32_T diffServPolicyMapAttachCtlIndex=0;
static UI32_T diffServPolicyMapAttachCtlElementIndex=0;
static UI32_T diffServPolicyMapAttachCtlAction=VAL_diffServPolicyMapAttachCtlAction_notAction;

int do_diffServPolicyMapAttachCtlIndex(netsnmp_mib_handler          *handler,
                                       netsnmp_handler_registration *reginfo,
                                       netsnmp_agent_request_info   *reqinfo,
                                       netsnmp_request_info         *requests)
{
    switch (reqinfo->mode)
    {
        case MODE_GET:
        {
            long_return = diffServPolicyMapAttachCtlIndex;
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));

            break;
        }

        case MODE_SET_RESERVE1:
            if ((requests->requestvb->type)!= ASN_INTEGER)
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_WRONGTYPE);

            break;

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            break;

        case MODE_SET_ACTION:
        {
            diffServPolicyMapAttachCtlIndex = (*requests->requestvb->val.integer);
            break;
        }

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int do_diffServPolicyMapAttachCtlElementIndex(netsnmp_mib_handler          *handler,
                                       netsnmp_handler_registration *reginfo,
                                       netsnmp_agent_request_info   *reqinfo,
                                       netsnmp_request_info         *requests)
{
    switch (reqinfo->mode)
    {
        case MODE_GET:
        {
            long_return = diffServPolicyMapAttachCtlElementIndex;
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));

            break;
        }

        case MODE_SET_RESERVE1:
            if ((requests->requestvb->type)!= ASN_INTEGER)
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_WRONGTYPE);

            break;

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            break;

        case MODE_SET_ACTION:
        {
            diffServPolicyMapAttachCtlElementIndex = (*requests->requestvb->val.integer);
            break;
        }

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int do_diffServPolicyMapAttachCtlAction(netsnmp_mib_handler          *handler,
                                       netsnmp_handler_registration *reginfo,
                                       netsnmp_agent_request_info   *reqinfo,
                                       netsnmp_request_info         *requests)
{
    switch (reqinfo->mode)
    {
        case MODE_GET:
        {
            long_return = VAL_diffServPolicyMapAttachCtlAction_notAction;
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));

            break;
        }

        case MODE_SET_RESERVE1:
        {
            if ((requests->requestvb->type)!= ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_WRONGTYPE);
                break;
            }

            if (((*requests->requestvb->val.integer)<VAL_diffServPolicyMapAttachCtlAction_notAction)  || ((*requests->requestvb->val.integer)>VAL_diffServPolicyMapAttachCtlAction_notAttaching))
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_WRONGVALUE);

            break;
        }

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            break;

        case MODE_SET_ACTION:
        {
              diffServPolicyMapAttachCtlAction = (*requests->requestvb->val.integer);

              if (L4_PMGR_QoS_SetPolicydiffServPolicyMapAttachCtlAction(diffServPolicyMapAttachCtlIndex, diffServPolicyMapAttachCtlElementIndex,diffServPolicyMapAttachCtlAction)!= TRUE)
                  netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
              diffServPolicyMapAttachCtlAction = VAL_diffServPolicyMapAttachCtlAction_notAction;
            break;
        }

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

#define diffServPolicyMapElementEntry_INSTANCE_LEN 1

static BOOL_T diffServPolicyMapElementTable_get(int      compc,
                                oid     *compl,
                                UI32_T  *index,
                                RULE_TYPE_PolicyElement_T   *data)
{
    if (compc !=diffServPolicyMapElementEntry_INSTANCE_LEN)
    {
        return FALSE;
    }
    *index = compl[0];
    memset(data, 0, sizeof(RULE_TYPE_PolicyElement_T));

    /*get data
     */
    if (L4_PMGR_QoS_GetDiffServPolicyMapElementEntry(*index,data)!=TRUE)
    {
        return FALSE;
    }
    else
    {
        return TRUE;
    } /*End of if */
}

static BOOL_T diffServPolicyMapElementTable_next(int      compc,
                                 oid     *compl,
                                 UI32_T  *index,
                                 RULE_TYPE_PolicyElement_T    *data)
{
    *index = compl[0];
    memset(data, 0, sizeof(RULE_TYPE_PolicyElement_T));
    /*check  the length of inputing index,if <1 we should try get {0.0.0.0.0...} */
    if (compc<1)
    {
        /*get data*/
        if (L4_PMGR_QoS_GetDiffServPolicyMapElementEntry(*index,data)!=TRUE)
        {
            /*get data*/
            if (L4_PMGR_QoS_GetNextDiffServPolicyMapElementEntry(index,data)!=TRUE)
            {
                return FALSE;
            }
        }
    }
    else
    {
        /*get data*/
        if (L4_PMGR_QoS_GetNextDiffServPolicyMapElementEntry(index,data)!=TRUE)
        {
            return FALSE;
        }
    }
    return TRUE;
}


unsigned char  *
var_diffServPolicyMapElementTable(struct variable *vp,
                                oid * name,
                                size_t * length,
                                int exact,
                                size_t * var_len,
                                WriteMethod ** write_method)
{
    UI32_T compc=0;
    UI32_T  index=0;
    oid compl[diffServPolicyMapElementEntry_INSTANCE_LEN];
    oid best_inst[diffServPolicyMapElementEntry_INSTANCE_LEN];
    RULE_TYPE_PolicyElement_T  entry;

    switch (vp->magic) {

      case DIFFSERVPOLICYMAPELEMENTCLASSMAPINDEX:
        *write_method = write_diffServPolicyMapElementClassMapIndex;
         break;
      case DIFFSERVPOLICYMAPELEMENTMETERINDEX:
        *write_method = write_diffServPolicyMapElementMeterIndex;
         break;
      case DIFFSERVPOLICYMAPELEMENTACTIONINDEX:
        *write_method = write_diffServPolicyMapElementActionIndex;
         break;
      case DIFFSERVPOLICYMAPELEMENTSTATUS:
        *write_method = write_diffServPolicyMapElementStatus;
         break;
    default:
        *write_method = 0;
         break;
    }


    /*check compc, retrive compl*/
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,compl, diffServPolicyMapElementEntry_INSTANCE_LEN);

    if (exact)/*get,set*/
    {
        if (!diffServPolicyMapElementTable_get(compc, compl, &index,  &entry))
            return NULL;
    }
    else/*getnext*/
    {
        if (!diffServPolicyMapElementTable_next(compc, compl, &index,  &entry))
        {
            return NULL;
        }
    }

    memcpy(name, vp->name, vp->namelen*sizeof(oid));
    best_inst[0] = index;
    memcpy(name + vp->namelen, best_inst, diffServPolicyMapElementEntry_INSTANCE_LEN*sizeof(oid));
    *length = vp->namelen + diffServPolicyMapElementEntry_INSTANCE_LEN;

    switch (vp->magic) {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
      case DIFFSERVPOLICYMAPELEMENTINDEX:
        long_return = index;
        *var_len = sizeof(long_return);
        return (u_char *) &long_return;
#endif
      case DIFFSERVPOLICYMAPELEMENTCLASSMAPINDEX:
     long_return = entry.class_map_index;
        *var_len = sizeof(long_return);
        return (u_char *) &long_return;

      case DIFFSERVPOLICYMAPELEMENTMETERINDEX:
        long_return = entry.meter_index;
        *var_len = sizeof(long_return);
        return (u_char *) &long_return;
      case DIFFSERVPOLICYMAPELEMENTACTIONINDEX:
        long_return = entry.action_index;
        *var_len = sizeof(long_return);
        return (u_char *) &long_return;
      case DIFFSERVPOLICYMAPELEMENTSTATUS:
        long_return = entry.row_status;
        *var_len = sizeof(long_return);
        return (u_char *) &long_return;
    default:
        ERROR_MSG("");
    }
    return NULL;
}

int write_diffServPolicyMapElementClassMapIndex(int       action,
                                         u_char    *var_val,
                                         u_char    var_val_type,
                                         size_t    var_val_len,
                                         u_char    *statP,
                                         oid       *name,
                                         size_t    name_len)
{
    long value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    /*check max length of the inputing index */
    if(name_len > oid_name_length+diffServPolicyMapElementEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }

        case RESERVE2:
        {
            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            UI32_T  index;
            index = name[oid_name_length];
            value = *(long *)var_val;
            if(L4_PMGR_QoS_SetDiffServPolicyMapElementClassMapIndex(index, value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
            break;
        }

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }
    return SNMP_ERR_NOERROR;
}

int write_diffServPolicyMapElementMeterIndex(int       action,
                                         u_char    *var_val,
                                         u_char    var_val_type,
                                         size_t    var_val_len,
                                         u_char    *statP,
                                         oid       *name,
                                         size_t    name_len)
{
    long value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    /*check max length of the inputing index */
    if(name_len > oid_name_length+diffServPolicyMapElementEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }

        case RESERVE2:
        {
            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            UI32_T  index;
            index = name[oid_name_length];
            value = *(long *)var_val;
            if(L4_PMGR_QoS_SetDiffServPolicyMapElementMeterIndex(index, value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
            break;
        }

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }
    return SNMP_ERR_NOERROR;
}

int write_diffServPolicyMapElementActionIndex(int       action,
                                         u_char    *var_val,
                                         u_char    var_val_type,
                                         size_t    var_val_len,
                                         u_char    *statP,
                                         oid       *name,
                                         size_t    name_len)
{
    long value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    /*check max length of the inputing index */
    if(name_len > oid_name_length+diffServPolicyMapElementEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }

        case RESERVE2:
        {
            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            UI32_T  index;
            index = name[oid_name_length];
            value = *(long *)var_val;
            if(L4_PMGR_QoS_SetDiffServPolicyMapElementActionIndex(index, value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
            break;
        }

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }
    return SNMP_ERR_NOERROR;
}
int write_diffServPolicyMapElementStatus(int       action,
                                         u_char    *var_val,
                                         u_char    var_val_type,
                                         size_t    var_val_len,
                                         u_char    *statP,
                                         oid       *name,
                                         size_t    name_len)
{
    long value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    /*check max length of the inputing index */
    if(name_len > oid_name_length+diffServPolicyMapElementEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            if (*(long *)var_val < VAL_diffServPolicyMapElementStatus_active || *(long *)var_val>VAL_diffServPolicyMapElementStatus_destroy )
            {
                return SNMP_ERR_WRONGVALUE;
            }
            if (*(long *)var_val == VAL_diffServPolicyMapElementStatus_notReady)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }

        case RESERVE2:
        {
            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            UI32_T  index;
            index = name[oid_name_length];
            value = *(long *)var_val;
            if(L4_PMGR_QoS_SetDiffServPolicyMapElementStatus(index, value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
            break;
        }

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }
    return SNMP_ERR_NOERROR;
}

#define diffServClassMapEntry_INSTANCE_LEN 1

static BOOL_T diffServClassMapTable_get(int      compc,
                                oid     *compl,
                                UI32_T  *index,
                                RULE_TYPE_MIB_ClassMap_T   *data)
{
    if (compc !=diffServClassMapEntry_INSTANCE_LEN)
    {
        return FALSE;
    }
    *index = compl[0];
    memset(data, 0, sizeof(RULE_TYPE_MIB_ClassMap_T));

    /*get data
     */
    if (L4_PMGR_QoS_GetDiffServClassMapEntry(*index,data)!=TRUE)
    {
        return FALSE;
    }
    else
    {
        return TRUE;
    } /*End of if */
}

static BOOL_T diffServClassMapTable_next(int      compc,
                                 oid     *compl,
                                 UI32_T  *index,
                                 RULE_TYPE_MIB_ClassMap_T    *data)
{
    *index = compl[0];
    memset(data, 0, sizeof(RULE_TYPE_MIB_ClassMap_T));
    /*check  the length of inputing index,if <1 we should try get {0.0.0.0.0...} */
    if (compc<1)
    {
        /*get data*/
        if (L4_PMGR_QoS_GetDiffServClassMapEntry(*index,data)!=TRUE)
        {
            /*get data*/
            if (L4_PMGR_QoS_GetNextDiffServClassMapEntry(index,data)!=TRUE)
            {
                return FALSE;
            }
        }
    }
    else
    {
        /*get data*/
        if (L4_PMGR_QoS_GetNextDiffServClassMapEntry(index,data)!=TRUE)
        {
            return FALSE;
        }
    }
    return TRUE;
}

/*
 * var_diffServClassMapTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_diffServClassMapTable(struct variable *vp,
                        oid * name,
                        size_t * length,
                        int exact,
                        size_t * var_len, WriteMethod ** write_method)
{
    UI32_T compc=0;
    UI32_T index=0;
    oid compl[diffServClassMapEntry_INSTANCE_LEN];
    oid best_inst[diffServClassMapEntry_INSTANCE_LEN];
    RULE_TYPE_MIB_ClassMap_T  entry;

    switch (vp->magic) {
      case DIFFSERVCLASSMAPNAME_2:
        *write_method = write_diffServClassMapName_2;
     break;
      case DIFFSERVCLASSMAPDESCRIPTION:
        *write_method = write_diffServClassMapDescription;
     break;
      case DIFFSERVCLASSMAPMATCHTYPE:
        *write_method = write_diffServClassMapMatchType;
     break;
      case DIFFSERVCLASSMAPSTATUS:
        *write_method = write_diffServClassMapStatus;
     break;
    default:
        ERROR_MSG("");
    }

    /*check compc, retrive compl*/
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,compl, diffServClassMapEntry_INSTANCE_LEN);

    if (exact)/*get,set*/
    {
        if (!diffServClassMapTable_get(compc, compl,&index, &entry))
            return NULL;
    }
    else/*getnext*/
    {
        if (!diffServClassMapTable_next(compc, compl,&index, &entry))
        {
            return NULL;
        }
    }

    memcpy(name, vp->name, vp->namelen*sizeof(oid));
    best_inst[0] = index;
    memcpy(name + vp->namelen, best_inst, diffServClassMapEntry_INSTANCE_LEN*sizeof(oid));
    *length = vp->namelen + diffServClassMapEntry_INSTANCE_LEN;

    /*
     * * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
      case DIFFSERVCLASSMAPINDEX:
        long_return = index;
        *var_len = sizeof(long_return);
        return (u_char *) &long_return;
#endif
      case DIFFSERVCLASSMAPNAME_2:
        memcpy(return_buf,  entry.class_map_name,SYS_ADPT_DIFFSERV_MAX_NAME_LENGTH);
        *var_len  =  strlen((char *)entry.class_map_name);
        return (u_char*)return_buf;
      case DIFFSERVCLASSMAPDESCRIPTION:
        memcpy(return_buf,  entry.desc,MAXSIZE_diffServClassMapDescription);
        *var_len  =  strlen((char *)entry.desc);
        return (u_char*)return_buf;
      case DIFFSERVCLASSMAPMATCHTYPE:
        long_return = entry.class_map_match_type;
        *var_len = sizeof(long_return);
        return (u_char *) &long_return;
      case DIFFSERVCLASSMAPELEMENTINDEXTYPELIST:
        memcpy(return_buf,  entry.class_type,MAXSIZE_diffServClassMapElementIndexTypeList);
        *var_len  =  entry.size_of_list;
        return (u_char*)return_buf;
      case DIFFSERVCLASSMAPELEMENTINDEXLIST:
        memcpy(return_buf,  entry.class_index_list,MAXSIZE_diffServClassMapElementIndexList);
        *var_len  =   entry.size_of_list;
        return (u_char*)return_buf;
      case DIFFSERVCLASSMAPSTATUS:
        long_return = entry.row_status;
        *var_len = sizeof(long_return);
        return (u_char *) &long_return;
    default:
        ERROR_MSG("");
    }
    return NULL;
}

int write_diffServClassMapName_2(int       action,
                                         u_char    *var_val,
                                         u_char    var_val_type,
                                         size_t    var_val_len,
                                         u_char    *statP,
                                         oid       *name,
                                         size_t    name_len)
{
    int size;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    /*check max length of the inputing index */
    if(name_len > oid_name_length+diffServClassMapEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch (action)
    {
        case RESERVE1:
        {
            size = var_val_len;
            if (var_val_type != ASN_OCTET_STR)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if(size > SYS_ADPT_DIFFSERV_MAX_NAME_LENGTH)
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }
        case RESERVE2:
        {
            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            UI32_T  index;
            char    buffer[SYS_ADPT_DIFFSERV_MAX_NAME_LENGTH+1];
            index = name[oid_name_length];
            memcpy(buffer, var_val, var_val_len);
            buffer[var_val_len]='\0';
            if(!L_STDLIB_StrIsAsciiPrintWithCount((char *)buffer, var_val_len))
            {
                return SNMP_ERR_COMMITFAILED;
            }
            if (NULL != strpbrk((char *)buffer, invalid_char_in_name))
                return SNMP_ERR_COMMITFAILED;
            if(L4_PMGR_QoS_SetDiffServClassMapName(index, buffer) != TRUE)
                return SNMP_ERR_COMMITFAILED;
            break;
        }

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }
    return SNMP_ERR_NOERROR;
}

int write_diffServClassMapDescription(int       action,
                                         u_char    *var_val,
                                         u_char    var_val_type,
                                         size_t    var_val_len,
                                         u_char    *statP,
                                         oid       *name,
                                         size_t    name_len)
{
    int size;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    /*check max length of the inputing index */
    if(name_len > oid_name_length+diffServClassMapEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch (action)
    {
        case RESERVE1:
        {
            size = var_val_len;
            if (var_val_type != ASN_OCTET_STR)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if(size > MAXSIZE_diffServClassMapDescription)
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }
        case RESERVE2:
        {
            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            UI32_T  index;
            char    buffer[MAXSIZE_diffServClassMapDescription+1];
            index = name[oid_name_length];
            memcpy(buffer, var_val, var_val_len);
            buffer[var_val_len]='\0';
            if(!L_STDLIB_StrIsAsciiPrintWithCount((char *)buffer, var_val_len))
            {
                return SNMP_ERR_COMMITFAILED;
            }
            if (NULL != strpbrk((char *)buffer, invalid_char_in_desc))
                return SNMP_ERR_COMMITFAILED;
            if(L4_PMGR_QoS_SetDiffServClassMapDescription(index, buffer) != TRUE)
                return SNMP_ERR_COMMITFAILED;
            break;
        }

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }
    return SNMP_ERR_NOERROR;
}

int write_diffServClassMapMatchType(int       action,
                                         u_char    *var_val,
                                         u_char    var_val_type,
                                         size_t    var_val_len,
                                         u_char    *statP,
                                         oid       *name,
                                         size_t    name_len)
{
    long value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    /*check max length of the inputing index */
    if(name_len > oid_name_length+diffServClassMapEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            if (*(long *)var_val < VAL_diffServClassMapMatchType_matchAny || *(long *)var_val>VAL_diffServClassMapMatchType_matchAll )
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }

        case RESERVE2:
        {
            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            UI32_T  index;
            index = name[oid_name_length];
            value = *(long *)var_val;
            if(L4_PMGR_QoS_SetDiffServClassMapMatchType(index, value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
            break;
        }

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }
    return SNMP_ERR_NOERROR;
}

int write_diffServClassMapStatus(int       action,
                                         u_char    *var_val,
                                         u_char    var_val_type,
                                         size_t    var_val_len,
                                         u_char    *statP,
                                         oid       *name,
                                         size_t    name_len)
{
    long value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    /*check max length of the inputing index */
    if(name_len > oid_name_length+diffServClassMapEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            if (*(long *)var_val < VAL_diffServClassMapStatus_active || *(long *)var_val>VAL_diffServClassMapStatus_destroy )
            {
                return SNMP_ERR_WRONGVALUE;
            }
            if (*(long *)var_val == VAL_diffServClassMapStatus_notReady)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }

        case RESERVE2:
        {
            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            UI32_T  index;
            index = name[oid_name_length];
            value = *(long *)var_val;
            if(L4_PMGR_QoS_SetDiffServClassMapStatus(index, value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
            break;
        }

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }
    return SNMP_ERR_NOERROR;
}



static UI32_T diffServClassMapAttachCtlIndex=0;
static UI32_T diffServClassMapAttachCtlElementIndexType=1;
static UI32_T diffServClassMapAttachCtlElementIndex=0;
static UI32_T diffServClassMapAttachCtlAction=VAL_diffServClassMapAttachCtlAction_notAction;

int do_diffServClassMapAttachCtlIndex(netsnmp_mib_handler          *handler,
                                       netsnmp_handler_registration *reginfo,
                                       netsnmp_agent_request_info   *reqinfo,
                                       netsnmp_request_info         *requests)
{
    switch (reqinfo->mode)
    {
        case MODE_GET:
        {
            long_return = diffServClassMapAttachCtlIndex;
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));

            break;
        }

        case MODE_SET_RESERVE1:
            if ((requests->requestvb->type)!= ASN_INTEGER)
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_WRONGTYPE);

            break;

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            break;

        case MODE_SET_ACTION:
        {
            diffServClassMapAttachCtlIndex = (*requests->requestvb->val.integer);
            break;
        }

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int do_diffServClassMapAttachCtlElementIndexType(netsnmp_mib_handler          *handler,
                                       netsnmp_handler_registration *reginfo,
                                       netsnmp_agent_request_info   *reqinfo,
                                       netsnmp_request_info         *requests)
{
    switch (reqinfo->mode)
    {
        case MODE_GET:
        {
            long_return = diffServClassMapAttachCtlElementIndexType;
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));

            break;
        }

        case MODE_SET_RESERVE1:
            if ((requests->requestvb->type)!= ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_WRONGTYPE);
                break;
            }

            if((*requests->requestvb->val.integer) < VAL_diffServClassMapAttachCtlElementIndexType_macAce ||
               VAL_diffServClassMapAttachCtlElementIndexType_ipv6Ace < (*requests->requestvb->val.integer))
            {
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_WRONGVALUE);
            }

            break;

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            break;

        case MODE_SET_ACTION:
        {
            diffServClassMapAttachCtlElementIndexType = (*requests->requestvb->val.integer);
            break;
        }

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int do_diffServClassMapAttachCtlElementIndex(netsnmp_mib_handler          *handler,
                                       netsnmp_handler_registration *reginfo,
                                       netsnmp_agent_request_info   *reqinfo,
                                       netsnmp_request_info         *requests)
{
    switch (reqinfo->mode)
    {
        case MODE_GET:
        {
            long_return = diffServClassMapAttachCtlElementIndex;
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));

            break;
        }

        case MODE_SET_RESERVE1:
            if ((requests->requestvb->type)!= ASN_INTEGER)
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_WRONGTYPE);

            break;

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            break;

        case MODE_SET_ACTION:
        {
            diffServClassMapAttachCtlElementIndex = (*requests->requestvb->val.integer);
            break;
        }

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int do_diffServClassMapAttachCtlAction(netsnmp_mib_handler          *handler,
                                       netsnmp_handler_registration *reginfo,
                                       netsnmp_agent_request_info   *reqinfo,
                                       netsnmp_request_info         *requests)
{
    switch (reqinfo->mode)
    {
        case MODE_GET:
        {
            long_return = VAL_diffServClassMapAttachCtlAction_notAction;
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));

            break;
        }

        case MODE_SET_RESERVE1:
        {
            if ((requests->requestvb->type)!= ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_WRONGTYPE);
                break;
            }

            if (((*requests->requestvb->val.integer)<VAL_diffServClassMapAttachCtlAction_notAction)  || ((*requests->requestvb->val.integer)>VAL_diffServClassMapAttachCtlAction_notAttaching))
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_WRONGVALUE);

            break;
        }


        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            break;

        case MODE_SET_ACTION:
        {
            diffServClassMapAttachCtlAction = (*requests->requestvb->val.integer);
            if(L4_PMGR_QoS_SetDiffServClassMapAttachCtlAction(diffServClassMapAttachCtlIndex,diffServClassMapAttachCtlElementIndexType,diffServClassMapAttachCtlElementIndex,diffServClassMapAttachCtlAction)!=TRUE)
                return SNMP_ERR_COMMITFAILED;
            diffServClassMapAttachCtlAction  = VAL_diffServClassMapAttachCtlAction_notAction;
            break;
        }

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}


#define diffServAclEntry_INSTANCE_LEN 1

static BOOL_T diffServAclTable_get(int      compc,
                                oid     *compl,
                                UI32_T  *index,
                                RULE_TYPE_MIB_Acl_T   *data)
{
    if (compc !=diffServAclEntry_INSTANCE_LEN)
    {
        return FALSE;
    }
    *index = compl[0];
    memset(data, 0, sizeof(RULE_TYPE_MIB_Acl_T));

    if (L4_PMGR_QoS_GetDiffServAclEntry(*index,data)!=TRUE)
    {
        return FALSE;
    }
    else
    {
        return TRUE;
    } /*End of if */
}

static BOOL_T diffServAclTable_next(int      compc,
                                 oid     *compl,
                                 UI32_T  *index,
                                 RULE_TYPE_MIB_Acl_T    *data)
{
    *index = compl[0];
    memset(data, 0, sizeof(RULE_TYPE_MIB_Acl_T));

    if (compc<1)
    {
        if (L4_PMGR_QoS_GetDiffServAclEntry(*index,data)!=TRUE)
        {
            if (L4_PMGR_QoS_GetNextDiffServAclEntry(index,data)!=TRUE)
            {
                return FALSE;
            }
        }
    }
    else
    {
        if (L4_PMGR_QoS_GetNextDiffServAclEntry(index,data)!=TRUE)
        {
            return FALSE;
        }
    }
    return TRUE;
}


unsigned char  *
var_diffServAclTable(struct variable *vp,
                   oid * name,
                   size_t * length,
                   int exact,
                   size_t * var_len, WriteMethod ** write_method)
{
    UI32_T compc=0;
    UI32_T  index=0;
    oid compl[diffServAclEntry_INSTANCE_LEN];
    oid best_inst[diffServAclEntry_INSTANCE_LEN];
    RULE_TYPE_MIB_Acl_T  entry;

    switch (vp->magic)
    {
        case DIFFSERVACLNAME:
            *write_method = write_diffServAclName;
            break;
        case DIFFSERVACLTYPE:
            *write_method = write_diffServAclType;
            break;
        case DIFFSERVACLSTATUS:
            *write_method = write_diffServAclStatus;
            break;
        default:
            *write_method = 0;
            break;
    }

    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,compl, diffServAclEntry_INSTANCE_LEN);

    if (exact)/*get,set*/
    {
        if (!diffServAclTable_get(compc, compl,&index,  &entry))
            return NULL;
    }
    else/*getnext*/
    {
        if (!diffServAclTable_next(compc, compl,&index,  &entry))
        {
            return NULL;
        }
    }

    memcpy(name, vp->name, vp->namelen*sizeof(oid));
    best_inst[0] = index;
    memcpy(name + vp->namelen, best_inst, diffServAclEntry_INSTANCE_LEN*sizeof(oid));
    *length = vp->namelen + diffServAclEntry_INSTANCE_LEN;
    /*
     * * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
      case DIFFSERVACLINDEX:
        long_return = index;
        *var_len = sizeof(long_return);
        return (u_char *) &long_return;
#endif
      case DIFFSERVACLNAME:
        memcpy(return_buf,  entry.acl_name,SYS_ADPT_ACL_MAX_NAME_LEN);
        return_buf[SYS_ADPT_ACL_MAX_NAME_LEN] = '\0';
        *var_len  =  strlen((char *)entry.acl_name);
        return (u_char*)return_buf;
      case DIFFSERVACLTYPE:
        long_return = entry.acl_type;
        *var_len = sizeof(long_return);
        return (u_char *) &long_return;
      case DIFFSERVACLACEINDEXLIST:
        memcpy(return_buf,  entry.ace_index_list,MAXSIZE_diffServAclAceIndexList);
        *var_len  = entry.size_of_ace_index_list;
        return (u_char*)return_buf;
      case DIFFSERVACLSTATUS:
        long_return = entry.row_status;
        *var_len = sizeof(long_return);
        return (u_char *) &long_return;
    default:
        ERROR_MSG("");
    }
    return NULL;
}

int write_diffServAclName(int       action,
                                         u_char    *var_val,
                                         u_char    var_val_type,
                                         size_t    var_val_len,
                                         u_char    *statP,
                                         oid       *name,
                                         size_t    name_len)
{
    int size;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    if(name_len > oid_name_length+diffServAclEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch (action)
    {
        case RESERVE1:
        {
            size = var_val_len;
            if (var_val_type != ASN_OCTET_STR)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if(size > SYS_ADPT_ACL_MAX_NAME_LEN)
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }
        case RESERVE2:
        {
            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            UI32_T  index;
            UI8_T buffer[SYS_ADPT_ACL_MAX_NAME_LEN+1];
            index = name[oid_name_length];
            memcpy(buffer, var_val, var_val_len);
            buffer[var_val_len]='\0';

            if(!L_STDLIB_StrIsAsciiPrintWithCount((char *)buffer, var_val_len))
            {
                return SNMP_ERR_COMMITFAILED;
            }
            if(L4_PMGR_QoS_SetDiffServAclName(index, buffer) != TRUE)
                return SNMP_ERR_COMMITFAILED;
            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }
    return SNMP_ERR_NOERROR;
}

int write_diffServAclType(int       action,
                                         u_char    *var_val,
                                         u_char    var_val_type,
                                         size_t    var_val_len,
                                         u_char    *statP,
                                         oid       *name,
                                         size_t    name_len)
{
    long value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    if(name_len > oid_name_length+diffServAclEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }

        case RESERVE2:
            switch (*(long *)var_val)
            {
                case VAL_diffServAclType_mac:
                    break;

                case VAL_diffServAclType_ipstandard:
                    break;

                case VAL_diffServAclType_ipextended:
                    break;

#if (SYS_CPNT_ACL_IPV6 == TRUE)
                case VAL_diffServAclType_ipv6standard:
                    break;

                case VAL_diffServAclType_ipv6extended:
                    break;
#endif /* #if (SYS_CPNT_ACL_IPV6 == TRUE) */

#if (SYS_CPNT_DAI == TRUE)
                case VAL_diffServAclType_arp:
                    break;
#endif /* #if (SYS_CPNT_DAI == TRUE) */

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T  index;
            index = name[oid_name_length];
            value = *(long *)var_val;

            if(L4_PMGR_QoS_SetDiffServAclType(index, value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }
    return SNMP_ERR_NOERROR;
}

int write_diffServAclStatus(int       action,
                                         u_char    *var_val,
                                         u_char    var_val_type,
                                         size_t    var_val_len,
                                         u_char    *statP,
                                         oid       *name,
                                         size_t    name_len)
{
    long value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    if(name_len > oid_name_length+diffServAclEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            if (*(long *)var_val < VAL_diffServAclStatus_active || *(long *)var_val>VAL_diffServAclStatus_destroy )
            {
                return SNMP_ERR_WRONGVALUE;
            }

            break;
        }

        case RESERVE2:
        {
            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            UI32_T  index;
            index = name[oid_name_length];
            value = *(long *)var_val;

            if(L4_PMGR_QoS_SetDiffServAclStatus(index, value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }
    return SNMP_ERR_NOERROR;
}

static UI32_T diffServAclAttachCtlIndex=0;
static UI32_T diffServAclAttachCtlAceType=VAL_diffServAclAttachCtlAceType_macAce;
static UI32_T diffServAclAttachCtlAceIndex=0;
static UI32_T diffServAclAttachCtlAction=VAL_diffServAclAttachCtlAction_notAction;

int do_diffServAclAttachCtlIndex(netsnmp_mib_handler          *handler,
                                       netsnmp_handler_registration *reginfo,
                                       netsnmp_agent_request_info   *reqinfo,
                                       netsnmp_request_info         *requests)
{
    switch (reqinfo->mode)
    {
        case MODE_GET:
        {
            long_return = diffServAclAttachCtlIndex;
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));

            break;
        }

        case MODE_SET_RESERVE1:
            break;

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            break;

        case MODE_SET_ACTION:
        {
            diffServAclAttachCtlIndex = (*requests->requestvb->val.integer);
            break;
        }

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int do_diffServAclAttachCtlAceType(netsnmp_mib_handler          *handler,
                                       netsnmp_handler_registration *reginfo,
                                       netsnmp_agent_request_info   *reqinfo,
                                       netsnmp_request_info         *requests)
{
    switch (reqinfo->mode)
    {
        case MODE_GET:
        {
            long_return = diffServAclAttachCtlAceType;
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));

            break;
        }

        case MODE_SET_RESERVE1:
            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
            }
            break;

        case MODE_SET_RESERVE2:
            switch (*requests->requestvb->val.integer)
            {
                case VAL_diffServAclAttachCtlAceType_macAce:
                    break;

                case VAL_diffServAclAttachCtlAceType_ipAce:
                    break;

#if (SYS_CPNT_ACL_IPV6 == TRUE)
                case VAL_diffServAclAttachCtlAceType_ipv6Ace:
                    break;
#endif /* #if (SYS_CPNT_ACL_IPV6 == TRUE) */

#if (SYS_CPNT_DAI == TRUE)
                case VAL_diffServAclAttachCtlAceType_arpAce:
                    break;
#endif /* #if (SYS_CPNT_DAI == TRUE) */

                default:
                    netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            }
            break;

        case MODE_SET_FREE:
            break;

        case MODE_SET_ACTION:
        {
            diffServAclAttachCtlAceType = (*requests->requestvb->val.integer);
            break;
        }

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int do_diffServAclAttachCtlAceIndex(netsnmp_mib_handler          *handler,
                                       netsnmp_handler_registration *reginfo,
                                       netsnmp_agent_request_info   *reqinfo,
                                       netsnmp_request_info         *requests)
{
    switch (reqinfo->mode)
    {
        case MODE_GET:
        {
            long_return = diffServAclAttachCtlAceIndex;
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));

            break;
        }

        case MODE_SET_RESERVE1:
            break;

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            break;

        case MODE_SET_ACTION:
        {
            diffServAclAttachCtlAceIndex = (*requests->requestvb->val.integer);
            break;
        }

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int do_diffServAclAttachCtlAction(netsnmp_mib_handler          *handler,
                                       netsnmp_handler_registration *reginfo,
                                       netsnmp_agent_request_info   *reqinfo,
                                       netsnmp_request_info         *requests)
{
    switch (reqinfo->mode)
    {
        case MODE_GET:
        {
            long_return = VAL_diffServAclAttachCtlAction_notAction;
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));

            break;
        }

        case MODE_SET_RESERVE1:
    {
            if (((*requests->requestvb->val.integer)<VAL_diffServAclAttachCtlAction_notAction)  || ((*requests->requestvb->val.integer)>VAL_diffServAclAttachCtlAction_notAttaching))
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_WRONGVALUE);
        }
            break;

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            break;

        case MODE_SET_ACTION:
        {
            diffServAclAttachCtlAction = (*requests->requestvb->val.integer);

            if(L4_PMGR_QoS_SetDiffServAclAttachCtlAction(diffServAclAttachCtlIndex,diffServAclAttachCtlAceType,diffServAclAttachCtlAceIndex,diffServAclAttachCtlAction )!=TRUE)
                return SNMP_ERR_COMMITFAILED;
            diffServAclAttachCtlAction=VAL_diffServAclAttachCtlAction_notAction;
            break;
        }

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}


#define diffServIpAceEntry_INSTANCE_LEN 1

static BOOL_T
diffServIpAceTable_get(
    int      compc,
    oid     *compl,
    UI32_T  *index,
    RULE_TYPE_UI_Ace_Entry_T *ace_p)
{
    if (compc !=diffServIpAceEntry_INSTANCE_LEN)
    {
        return FALSE;
    }
    *index = compl[0];
    memset(ace_p, 0, sizeof(*ace_p));

    if (L4_PMGR_QoS_GetDiffServIpAceEntry(*index, ace_p) != RULE_TYPE_OK)
    {
        return FALSE;
    }

    switch (ace_p->ace_type)
    {
        case RULE_TYPE_IP_EXT_ACL:
            ace_p->ace_type = VAL_diffServIpAceType_extended;
            break;

        case RULE_TYPE_IP_STD_ACL:
            ace_p->ace_type = VAL_diffServIpAceType_standard;
            break;

        default:
            break;
    }

    return TRUE;
}

static BOOL_T
diffServIpAceTable_next(
    int      compc,
    oid     *compl,
    UI32_T  *index,
    RULE_TYPE_UI_Ace_Entry_T *ace_p)
{
    *index = compl[0];
    memset(ace_p, 0, sizeof(*ace_p));

    if (compc < 1)
    {
        if (L4_PMGR_QoS_GetDiffServIpAceEntry(*index, ace_p) != RULE_TYPE_OK)
        {
            if (L4_PMGR_QoS_GetNextDiffServIpAceEntry(index, ace_p) != RULE_TYPE_OK)
            {
                return FALSE;
            }
        }
    }
    else
    {
        if (L4_PMGR_QoS_GetNextDiffServIpAceEntry(index, ace_p) != RULE_TYPE_OK)
        {
            return FALSE;
        }
    }

    switch (ace_p->ace_type)
    {
        case RULE_TYPE_IP_EXT_ACL:
            ace_p->ace_type = VAL_diffServIpAceType_extended;
            break;

        case RULE_TYPE_IP_STD_ACL:
            ace_p->ace_type = VAL_diffServIpAceType_standard;
            break;

        default:
            break;
    }

    return TRUE;
}

/*
 * var_diffServIpAceTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_diffServIpAceTable(struct variable *vp,
                     oid * name,
                     size_t * length,
                     int exact,
                     size_t * var_len, WriteMethod ** write_method)
{
    UI32_T compc=0;
    UI32_T  index=0;
    oid compl[diffServIpAceEntry_INSTANCE_LEN];
    oid best_inst[diffServIpAceEntry_INSTANCE_LEN];
    RULE_TYPE_UI_Ace_Entry_T ace;

    switch (vp->magic)
    {
        case DIFFSERVIPACETYPE:
            *write_method = write_diffServIpAceType;
            break;
        case DIFFSERVIPACEACCESS:
            *write_method = write_diffServIpAceAccess;
            break;
        case DIFFSERVIPACESOURCEIPADDR:
            *write_method = write_diffServIpAceSourceIpAddr;
            break;
        case DIFFSERVIPACESOURCEIPADDRBITMASK:
            *write_method = write_diffServIpAceSourceIpAddrBitmask;
            break;
        case DIFFSERVIPACEDESTIPADDR:
            *write_method = write_diffServIpAceDestIpAddr;
            break;
        case DIFFSERVIPACEDESTIPADDRBITMASK:
            *write_method =  write_diffServIpAceDestIpAddrBitmask;
            break;
        case DIFFSERVIPACEPROTOCOL:
            *write_method = write_diffServIpAceProtocol;
            break;

#if (SYS_CPNT_ACL_IP_EXT_PREC == TRUE)
        case DIFFSERVIPACEPREC:
            *write_method = write_diffServIpAcePrec;
            break;
#endif

#if (SYS_CPNT_ACL_IP_EXT_TOS == TRUE)
        case DIFFSERVIPACETOS:
            *write_method = write_diffServIpAceTos;
            break;
#endif

#if (SYS_CPNT_ACL_IP_EXT_DSCP == TRUE)
        case DIFFSERVIPACEDSCP:
            *write_method = write_diffServIpAceDscp;
            break;
#endif

        case DIFFSERVIPACESOURCEPORTOP:
            *write_method = write_diffServIpAceSourcePortOp;
            break;
        case DIFFSERVIPACEMINSOURCEPORT:
            *write_method = write_diffServIpAceMinSourcePort;
            break;
        case DIFFSERVIPACEMAXSOURCEPORT:
            *write_method = write_diffServIpAceMaxSourcePort;
            break;
        case DIFFSERVIPACESOURCEPORTBITMASK:
            *write_method = write_diffServIpAceSourcePortBitmask;
            break;
        case DIFFSERVIPACEDESTPORTOP:
            *write_method = write_diffServIpAceDestPortOp;
            break;
        case DIFFSERVIPACEMINDESTPORT:
            *write_method = write_diffServIpAceMinDestPort;
            break;
        case DIFFSERVIPACEMAXDESTPORT:
            *write_method = write_diffServIpAceMaxDestPort;
            break;
        case DIFFSERVIPACEDESTPORTBITMASK:
            *write_method = write_diffServIpAceDestPortBitmask;
            break;
        case DIFFSERVIPACECONTROLCODE:
            *write_method = write_diffServIpAceControlCode;
            break;
        case DIFFSERVIPACECONTROLCODEBITMASK:
            *write_method = write_diffServIpAceControlCodeBitmask;
            break;
        case DIFFSERVIPACESTATUS:
            *write_method = write_diffServIpAceStatus;
            break;
#if (SYS_CPNT_ACL_IP_EXT_ICMP == TRUE)
        case DIFFSERVIPACEICMPTYPE:
            *write_method = write_diffServIpAceIcmpType;
            break;
#endif
        default:
            *write_method = 0;
    }


    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,compl,
        diffServIpAceEntry_INSTANCE_LEN);

    if (exact)/*get,set*/
    {
        if (!diffServIpAceTable_get(compc, compl,&index,  &ace))
            return NULL;
    }
    else/*getnext*/
    {
        if (!diffServIpAceTable_next(compc, compl,&index,  &ace))
        {
            return NULL;
        }
    }

    memcpy(name, vp->name, vp->namelen*sizeof(oid));
    best_inst[0] = index;
    memcpy(name + vp->namelen, best_inst, diffServIpAceEntry_INSTANCE_LEN*sizeof(oid));
    *length = vp->namelen + diffServIpAceEntry_INSTANCE_LEN;

    /*
     * * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic)
    {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case DIFFSERVIPACEINDEX:
            long_return = index;
            *var_len = sizeof(long_return);
            return (u_char *) &long_return;
#endif
        case DIFFSERVIPACETYPE:
            long_return = (UI32_T)ace.ace_type;
            *var_len = sizeof(long_return);
            return (u_char *) &long_return;
        case DIFFSERVIPACEACCESS:
            long_return = ace.access;
            *var_len = sizeof(long_return);
            return (u_char *) &long_return;
        case DIFFSERVIPACESOURCEIPADDR:
            {
                /* net byte order -> host byte order */
                UI32_T *ip_addr = (UI32_T *)& ace.ipv4.sip.addr;

                ipaddr_return = L_STDLIB_Ntoh32(*ip_addr);
                *var_len = sizeof(ipaddr_return);
            }
            return (u_char *) &ipaddr_return;
        case DIFFSERVIPACESOURCEIPADDRBITMASK:
            {
                /* net byte order -> host byte order */
                UI32_T *ip_mask = (UI32_T *)& ace.ipv4.sip.mask;

                ipaddr_return= L_STDLIB_Ntoh32(*ip_mask);
                *var_len = sizeof(ipaddr_return);
            }
            return (u_char *) &ipaddr_return;
        case DIFFSERVIPACEDESTIPADDR:
            {
                /* net byte order -> host byte order */
                UI32_T *ip_addr = (UI32_T *)& ace.ipv4.dip.addr;

                ipaddr_return = L_STDLIB_Ntoh32(*ip_addr);
                *var_len = sizeof(ipaddr_return);
            }
            return (u_char *) &ipaddr_return;
        case DIFFSERVIPACEDESTIPADDRBITMASK:
            {
                /* net byte order -> host byte order */
                UI32_T *ip_mask = (UI32_T *)& ace.ipv4.dip.mask;

                ipaddr_return= L_STDLIB_Ntoh32(*ip_mask);
                *var_len = sizeof(ipaddr_return);
            }
            return (u_char *) &ipaddr_return;
        case DIFFSERVIPACEPROTOCOL:
            long_return = ace.ipv4.protocol.u.s.data;
            *var_len = sizeof(long_return);
            return (u_char *) &long_return;

#if (SYS_CPNT_ACL_IP_EXT_PREC == TRUE)
        case DIFFSERVIPACEPREC:
            if (ace.ipv4.dscp.op == RULE_TYPE_IPV4_DSCP_OP_PRECEDENCE ||
                ace.ipv4.dscp.op == RULE_TYPE_IPV4_DSCP_OP_PRECEDENCE_AND_TOS)
            long_return = ace.ipv4.dscp.u.tos.precedence;
            else
                long_return = MAX_diffServIpAcePrec;
            *var_len = sizeof(long_return);
            return (u_char *) &long_return;
#endif

#if (SYS_CPNT_ACL_IP_EXT_TOS == TRUE)
        case DIFFSERVIPACETOS:
            if (ace.ipv4.dscp.op == RULE_TYPE_IPV4_DSCP_OP_TOS ||
                ace.ipv4.dscp.op == RULE_TYPE_IPV4_DSCP_OP_PRECEDENCE_AND_TOS)
            long_return = ace.ipv4.dscp.u.tos.tos;
            else
                long_return = MAX_diffServIpAceTos;
            *var_len = sizeof(long_return);
            return (u_char *) &long_return;
#endif

#if (SYS_CPNT_ACL_IP_EXT_DSCP == TRUE)
        case DIFFSERVIPACEDSCP:
            if (ace.ipv4.dscp.op == RULE_TYPE_IPV4_DSCP_OP_DSCP)
            long_return = ace.ipv4.dscp.u.ds;
            else
                long_return = MAX_diffServIpAceDscp;
            *var_len = sizeof(long_return);
            return (u_char *) &long_return;
#endif

        case DIFFSERVIPACESOURCEPORTOP:
            long_return = ace.l4_common.sport.op;
            *var_len = sizeof(long_return);
            return (u_char *) &long_return;
        case DIFFSERVIPACEMINSOURCEPORT:
            long_return = (VAL_diffServIpAceSourcePortOp_range == ace.l4_common.sport.op)
                          ? ace.l4_common.sport.u.range.min : ace.l4_common.sport.u.s.data;
            *var_len = sizeof(long_return);
            return (u_char *) &long_return;
        case DIFFSERVIPACEMAXSOURCEPORT:
            long_return = ace.l4_common.sport.u.range.max;
            *var_len = sizeof(long_return);
            return (u_char *) &long_return;
        case DIFFSERVIPACESOURCEPORTBITMASK:
            long_return = ace.l4_common.sport.u.s.mask;
            *var_len = sizeof(long_return);
            return (u_char *) &long_return;
        case DIFFSERVIPACEDESTPORTOP:
            long_return = ace.l4_common.dport.op;
            *var_len = sizeof(long_return);
            return (u_char *) &long_return;
        case DIFFSERVIPACEMINDESTPORT:
            long_return = (VAL_diffServIpAceDestPortOp_range == ace.l4_common.dport.op)
                          ? ace.l4_common.dport.u.range.min : ace.l4_common.dport.u.s.data;
            *var_len = sizeof(long_return);
            return (u_char *) &long_return;
        case DIFFSERVIPACEMAXDESTPORT:
            long_return = ace.l4_common.dport.u.range.max;
            *var_len = sizeof(long_return);
            return (u_char *) &long_return;
        case DIFFSERVIPACEDESTPORTBITMASK:
            long_return = ace.l4_common.dport.u.s.mask;
            *var_len = sizeof(long_return);
            return (u_char *) &long_return;
        case DIFFSERVIPACECONTROLCODE:
            long_return = ace.tcp.flags.data.u.code;
            *var_len = sizeof(long_return);
            return (u_char *) &long_return;
        case DIFFSERVIPACECONTROLCODEBITMASK:
            long_return = ace.tcp.flags.mask.u.code;
            *var_len = sizeof(long_return);
            return (u_char *) &long_return;
        case DIFFSERVIPACESTATUS:
            long_return = ace.row_status;
            *var_len = sizeof(long_return);
            return (u_char *) &long_return;
#if (SYS_CPNT_ACL_IP_EXT_ICMP == TRUE)
        case DIFFSERVIPACEICMPTYPE:
            if (ace.icmp.icmp_type.op == RULE_TYPE_ICMP_ICMPTYPE_OP_NO_OPERATION)
            {
                long_return = RULE_TYPE_UNDEF_ICMP_TYPE;
            }
            else
            {
                long_return = ace.icmp.icmp_type.u.s.data;
            }
            *var_len = sizeof(long_return);
            return (u_char *) &long_return;
#endif
        default:
            ERROR_MSG("");
    }

    return NULL;
}

int
write_diffServIpAceType(
    int     action,
    u_char  *var_val,
    u_char  var_val_type,
    size_t  var_val_len,
    u_char  *statP,
    oid     *name,
    size_t  name_len)
{
    long value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    if(name_len > oid_name_length + diffServIpAceEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }

            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }

            if (*(long *)var_val < VAL_diffServIpAceType_standard ||
                *(long *)var_val > VAL_diffServIpAceType_extended )
            {
                return SNMP_ERR_WRONGVALUE;
            }

            break;
        }

        case RESERVE2:
        {
            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            UI32_T  index;
            index = name[oid_name_length];
            value = *(long *)var_val;

            if(L4_PMGR_QoS_SetDiffServIpAceType(index, (UI8_T)value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}


int
write_diffServIpAceAccess(
    int     action,
    u_char  *var_val,
    u_char  var_val_type,
    size_t  var_val_len,
    u_char  *statP,
    oid     *name,
    size_t  name_len)
{
    long value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    if(name_len > oid_name_length + diffServIpAceEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }

            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }

            if (*(long *)var_val < VAL_diffServIpAceAccess_permit ||
                *(long *)var_val > VAL_diffServIpAceAccess_deny )
            {
                return SNMP_ERR_WRONGVALUE;
            }

            break;
        }

        case RESERVE2:
        {
            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            UI32_T  index;
            index = name[oid_name_length];
            value = *(long *)var_val;

            if(L4_PMGR_QoS_SetDiffServIpAceAccess(index, value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }
    return SNMP_ERR_NOERROR;
}

int write_diffServIpAceSourceIpAddr(int       action,
                                         u_char    *var_val,
                                         u_char    var_val_type,
                                         size_t    var_val_len,
                                         u_char    *statP,
                                         oid       *name,
                                         size_t    name_len)
{
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    if(name_len > oid_name_length+diffServIpAceEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_IPADDRESS)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len !=  SYS_ADPT_IPV4_ADDR_LEN)
            {
                return SNMP_ERR_WRONGLENGTH;
            }

            break;
        }

        case RESERVE2:
        {
            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            UI32_T  index;
            UI32_T value = 0;
            index = name[oid_name_length];
            memcpy(&value, var_val, var_val_len);
            /* convert host order */
            if(L4_PMGR_QoS_SetDiffServIpAceSourceIpAddr(index, value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }
    return SNMP_ERR_NOERROR;
}

int write_diffServIpAceSourceIpAddrBitmask(int       action,
                                         u_char    *var_val,
                                         u_char    var_val_type,
                                         size_t    var_val_len,
                                         u_char    *statP,
                                         oid       *name,
                                         size_t    name_len)
{
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    if(name_len > oid_name_length+diffServIpAceEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_IPADDRESS)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len !=  SYS_ADPT_IPV4_ADDR_LEN)
            {
                return SNMP_ERR_WRONGLENGTH;
            }

            break;
        }

        case RESERVE2:
        {
            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            UI32_T  index;
            UI32_T value = 0;
            index = name[oid_name_length];
            memcpy(&value, var_val, var_val_len);

            if(L4_PMGR_QoS_SetDiffServIpAceSourceIpAddrBitmask(index, value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }
    return SNMP_ERR_NOERROR;
}
int write_diffServIpAceDestIpAddr(int       action,
                                         u_char    *var_val,
                                         u_char    var_val_type,
                                         size_t    var_val_len,
                                         u_char    *statP,
                                         oid       *name,
                                         size_t    name_len)
{
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    if(name_len > oid_name_length+diffServIpAceEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_IPADDRESS)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len !=  SYS_ADPT_IPV4_ADDR_LEN)
            {
                return SNMP_ERR_WRONGLENGTH;
            }

            break;
        }

        case RESERVE2:
        {
            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            UI32_T  index;
            UI32_T value = 0;
            index = name[oid_name_length];
            memcpy(&value, var_val, var_val_len);

            if(L4_PMGR_QoS_SetDiffServIpAceDestIpAddr(index, value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }
    return SNMP_ERR_NOERROR;
}
int write_diffServIpAceDestIpAddrBitmask(int       action,
                                         u_char    *var_val,
                                         u_char    var_val_type,
                                         size_t    var_val_len,
                                         u_char    *statP,
                                         oid       *name,
                                         size_t    name_len)
{
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    if(name_len > oid_name_length+diffServIpAceEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_IPADDRESS)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len !=  SYS_ADPT_IPV4_ADDR_LEN)
            {
                return SNMP_ERR_WRONGLENGTH;
            }

            break;
        }

        case RESERVE2:
        {
            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            UI32_T  index;
            UI32_T value = 0;
            index = name[oid_name_length];
            memcpy(&value, var_val, var_val_len);

            if(L4_PMGR_QoS_SetDiffServIpAceDestIpAddrBitmask(index, value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }
    return SNMP_ERR_NOERROR;
}
int write_diffServIpAceProtocol(int       action,
                                         u_char    *var_val,
                                         u_char    var_val_type,
                                         size_t    var_val_len,
                                         u_char    *statP,
                                         oid       *name,
                                         size_t    name_len)
{
    long value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    if(name_len > oid_name_length+diffServIpAceEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            if (*(long *)var_val < MIN_diffServIpAceProtocol || *(long *)var_val > MAX_diffServIpAceProtocol)
            {
                return SNMP_ERR_WRONGVALUE;
            }

            break;
        }

        case RESERVE2:
        {
            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            UI32_T  index;
            index = name[oid_name_length];
            value = *(long *)var_val;

            if(L4_PMGR_QoS_SetDiffServIpAceProtocol(index, value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }
    return SNMP_ERR_NOERROR;
}

#if (SYS_CPNT_ACL_IP_EXT_PREC == TRUE)
int write_diffServIpAcePrec(int       action,
                                         u_char    *var_val,
                                         u_char    var_val_type,
                                         size_t    var_val_len,
                                         u_char    *statP,
                                         oid       *name,
                                         size_t    name_len)
{
    long value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    if(name_len > oid_name_length+diffServIpAceEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            if (*(long *)var_val < MIN_diffServIpAcePrec|| *(long *)var_val > MAX_diffServIpAcePrec)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }

        case RESERVE2:
        {
            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            UI32_T  index;
            index = name[oid_name_length];
            value = *(long *)var_val;

            if(L4_PMGR_QoS_SetDiffServIpAcePrec(index, value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }
    return SNMP_ERR_NOERROR;
}
#endif

#if (SYS_CPNT_ACL_IP_EXT_TOS == TRUE)
int write_diffServIpAceTos(int       action,
                                         u_char    *var_val,
                                         u_char    var_val_type,
                                         size_t    var_val_len,
                                         u_char    *statP,
                                         oid       *name,
                                         size_t    name_len)
{
    long value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    if(name_len > oid_name_length+diffServIpAceEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            if (*(long *)var_val < MIN_diffServIpAceTos|| *(long *)var_val > MAX_diffServIpAceTos)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }

        case RESERVE2:
        {
            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            UI32_T  index;
            index = name[oid_name_length];
            value = *(long *)var_val;

            if(L4_PMGR_QoS_SetDiffServIpAceTos(index, value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }
    return SNMP_ERR_NOERROR;
}
#endif

#if (SYS_CPNT_ACL_IP_EXT_DSCP == TRUE)
int write_diffServIpAceDscp(int       action,
                                         u_char    *var_val,
                                         u_char    var_val_type,
                                         size_t    var_val_len,
                                         u_char    *statP,
                                         oid       *name,
                                         size_t    name_len)
{
    long value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    if(name_len > oid_name_length+diffServIpAceEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            if (*(long *)var_val < MIN_diffServIpAceDscp|| *(long *)var_val > MAX_diffServIpAceDscp)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }

        case RESERVE2:
        {
            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            UI32_T  index;
            index = name[oid_name_length];
            value = *(long *)var_val;

            if(L4_PMGR_QoS_SetDiffServIpAceDscp(index, value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }
    return SNMP_ERR_NOERROR;
}
#endif

int write_diffServIpAceSourcePortOp(int       action,
                                         u_char    *var_val,
                                         u_char    var_val_type,
                                         size_t    var_val_len,
                                         u_char    *statP,
                                         oid       *name,
                                         size_t    name_len)
{
    long value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    if(name_len > oid_name_length+diffServIpAceEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            if (*(long *)var_val < VAL_diffServIpAceDestPortOp_noOperator|| *(long *)var_val > VAL_diffServIpAceDestPortOp_range)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }

        case RESERVE2:
        {
            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            UI32_T  index;
            index = name[oid_name_length];
            value = *(long *)var_val;

            if(L4_PMGR_QoS_SetDiffServIpAceSourcePortOp(index, value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }
    return SNMP_ERR_NOERROR;
}

int write_diffServIpAceMinSourcePort(int       action,
                                         u_char    *var_val,
                                         u_char    var_val_type,
                                         size_t    var_val_len,
                                         u_char    *statP,
                                         oid       *name,
                                         size_t    name_len)
{
    long value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    if(name_len > oid_name_length+diffServIpAceEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            if (*(long *)var_val < MIN_diffServIpAceMinSourcePort|| *(long *)var_val > MAX_diffServIpAceMinSourcePort)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }

        case RESERVE2:
        {
            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            UI32_T  index;
            index = name[oid_name_length];
            value = *(long *)var_val;

            /* min && max should be the same
             */
            if(L4_PMGR_QoS_SetDiffServIpAceMinSourcePort(index, value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }
    return SNMP_ERR_NOERROR;
}

int write_diffServIpAceMaxSourcePort(int       action,
                                         u_char    *var_val,
                                         u_char    var_val_type,
                                         size_t    var_val_len,
                                         u_char    *statP,
                                         oid       *name,
                                         size_t    name_len)
{
    long value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    if(name_len > oid_name_length+diffServIpAceEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            if (*(long *)var_val < MIN_diffServIpAceMaxSourcePort|| *(long *)var_val > MAX_diffServIpAceMaxSourcePort)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }

        case RESERVE2:
        {
            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            UI32_T  index;
            index = name[oid_name_length];
            value = *(long *)var_val;

            if(L4_PMGR_QoS_SetDiffServIpAceMaxSourcePort(index, value) != TRUE)
                return SNMP_ERR_COMMITFAILED;

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }
    return SNMP_ERR_NOERROR;
}

int write_diffServIpAceSourcePortBitmask(int       action,
                                         u_char    *var_val,
                                         u_char    var_val_type,
                                         size_t    var_val_len,
                                         u_char    *statP,
                                         oid       *name,
                                         size_t    name_len)
{
    long value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    if(name_len > oid_name_length+diffServIpAceEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            if (*(long *)var_val < MIN_diffServIpAceSourcePortBitmask|| *(long *)var_val > MAX_diffServIpAceSourcePortBitmask)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }

        case RESERVE2:
        {
            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            UI32_T  index;
            index = name[oid_name_length];
            value = *(long *)var_val;

            if(L4_PMGR_QoS_SetDiffServIpAceSourcePortBitmask(index, value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }
    return SNMP_ERR_NOERROR;
}

int write_diffServIpAceDestPortOp(int       action,
                                         u_char    *var_val,
                                         u_char    var_val_type,
                                         size_t    var_val_len,
                                         u_char    *statP,
                                         oid       *name,
                                         size_t    name_len)
{
    long value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    if(name_len > oid_name_length+diffServIpAceEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            if (*(long *)var_val < VAL_diffServIpAceDestPortOp_noOperator|| *(long *)var_val > VAL_diffServIpAceDestPortOp_range)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }

        case RESERVE2:
        {
            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            UI32_T  index;
            index = name[oid_name_length];
            value = *(long *)var_val;

            if(L4_PMGR_QoS_SetDiffServIpAceDestPortOp(index, value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }
    return SNMP_ERR_NOERROR;
}

int write_diffServIpAceMinDestPort(int       action,
                                         u_char    *var_val,
                                         u_char    var_val_type,
                                         size_t    var_val_len,
                                         u_char    *statP,
                                         oid       *name,
                                         size_t    name_len)
{
    long value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    if(name_len > oid_name_length+diffServIpAceEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            if (*(long *)var_val < MIN_diffServIpAceMinDestPort|| *(long *)var_val > MAX_diffServIpAceMinDestPort)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }

        case RESERVE2:
        {
            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            UI32_T  index;
            index = name[oid_name_length];
            value = *(long *)var_val;

            if(L4_PMGR_QoS_SetDiffServIpAceMinDestPort(index, value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }
    return SNMP_ERR_NOERROR;
}

int write_diffServIpAceMaxDestPort(int       action,
                                         u_char    *var_val,
                                         u_char    var_val_type,
                                         size_t    var_val_len,
                                         u_char    *statP,
                                         oid       *name,
                                         size_t    name_len)
{
    long value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    if(name_len > oid_name_length+diffServIpAceEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            if (*(long *)var_val < MIN_diffServIpAceMaxDestPort|| *(long *)var_val > MAX_diffServIpAceMaxDestPort)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }

        case RESERVE2:
        {
            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            UI32_T  index;
            index = name[oid_name_length];
            value = *(long *)var_val;

            /* min && max should be the same
             */
            if(L4_PMGR_QoS_SetDiffServIpAceMaxDestPort(index, value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }
    return SNMP_ERR_NOERROR;
}

int write_diffServIpAceDestPortBitmask(int       action,
                                         u_char    *var_val,
                                         u_char    var_val_type,
                                         size_t    var_val_len,
                                         u_char    *statP,
                                         oid       *name,
                                         size_t    name_len)
{
    long value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    if(name_len > oid_name_length+diffServIpAceEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            if (*(long *)var_val < MIN_diffServIpAceDestPortBitmask||*(long *) var_val > MAX_diffServIpAceDestPortBitmask)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }

        case RESERVE2:
        {
            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            UI32_T  index;
            index = name[oid_name_length];
            value = *(long *)var_val;

            if(L4_PMGR_QoS_SetDiffServIpAceDestPortBitmask(index, value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }
    return SNMP_ERR_NOERROR;
}

int write_diffServIpAceControlCode(int       action,
                                         u_char    *var_val,
                                         u_char    var_val_type,
                                         size_t    var_val_len,
                                         u_char    *statP,
                                         oid       *name,
                                         size_t    name_len)
{
    long value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    if(name_len > oid_name_length+diffServIpAceEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            if (*(long *)var_val < MIN_diffServIpAceControlCode|| *(long *)var_val > MAX_diffServIpAceControlCode)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }

        case RESERVE2:
        {
            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            UI32_T  index;
            index = name[oid_name_length];
            value = *(long *)var_val;

            if(L4_PMGR_QoS_SetDiffServIpAceControlCode(index, value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }
    return SNMP_ERR_NOERROR;
}

int write_diffServIpAceControlCodeBitmask(int       action,
                                         u_char    *var_val,
                                         u_char    var_val_type,
                                         size_t    var_val_len,
                                         u_char    *statP,
                                         oid       *name,
                                         size_t    name_len)
{
    long value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    if(name_len > oid_name_length+diffServIpAceEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            if (*(long *)var_val < MIN_diffServIpAceControlCodeBitmask|| *(long *)var_val > MAX_diffServIpAceControlCodeBitmask)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }

        case RESERVE2:
        {
            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            UI32_T  index;
            index = name[oid_name_length];
            value = *(long *)var_val;

            if(L4_PMGR_QoS_SetDiffServIpAceControlCodeBitmask(index, value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }
    return SNMP_ERR_NOERROR;
}

int write_diffServIpAceStatus(int       action,
                                         u_char    *var_val,
                                         u_char    var_val_type,
                                         size_t    var_val_len,
                                         u_char    *statP,
                                         oid       *name,
                                         size_t    name_len)
{
    long value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    if(name_len > oid_name_length+diffServIpAceEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            if (*(long *)var_val < VAL_diffServIpAceStatus_active || *(long *)var_val>VAL_diffServIpAceStatus_destroy )
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }

        case RESERVE2:
        {
            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            UI32_T  index;
            index = name[oid_name_length];
            value = *(long *)var_val;

            if(L4_PMGR_QoS_SetDiffServIpAceStatus(index, value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }
    return SNMP_ERR_NOERROR;
}

#if (SYS_CPNT_ACL_IP_EXT_ICMP == TRUE)
int write_diffServIpAceIcmpType(int       action,
                                         u_char    *var_val,
                                         u_char    var_val_type,
                                         size_t    var_val_len,
                                         u_char    *statP,
                                         oid       *name,
                                         size_t    name_len)
{
    long value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    if(name_len > oid_name_length+diffServIpAceEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            if (*(long *)var_val < MIN_diffServIpAceIcmpType|| *(long *)var_val > MAX_diffServIpAceIcmpType)
            {
                return SNMP_ERR_WRONGVALUE;
            }

            break;
        }

        case RESERVE2:
        {
            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            UI32_T  index;
            index = name[oid_name_length];
            value = *(long *)var_val;

            if(SNMP_MGR_IsDebugMode())
            {
                printf("%s, %d: index: %lu, value: %lu \r\n", __FUNCTION__, __LINE__, (unsigned long)index, (unsigned long)value);
            }
            if(L4_PMGR_QoS_SetDiffServIpAceIcmpType(index, value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }
    return SNMP_ERR_NOERROR;
}
#endif /*#if (SYS_CPNT_ACL_IP_EXT_ICMP == TRUE)*/

#if (SYS_CPNT_ACL_IPV6 == TRUE)
#define diffServIpv6AceEntry_INSTANCE_LEN 1
/*
 * var_diffServMeterTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */

static BOOL_T
diffServIpv6AceTable_get(
    int      compc,
    oid     *compl,
    UI32_T *index,
    RULE_TYPE_UI_Ace_Entry_T *ace_p)
{
    if (compc !=diffServIpv6AceEntry_INSTANCE_LEN)
    {
        return FALSE;
    }
    *index = compl[0];
    memset(ace_p, 0, sizeof(*ace_p));


    /*get data
     */
    if (L4_PMGR_QoS_GetDiffServIpv6AceEntry(*index, ace_p) != RULE_TYPE_OK)
    {
        return FALSE;
    }

    switch (ace_p->ace_type)
    {
        case RULE_TYPE_IPV6_EXT_ACL:
            ace_p->ace_type   = VAL_diffServIpv6AceType_extended;
            break;

        case RULE_TYPE_IPV6_STD_ACL:
            ace_p->ace_type   = VAL_diffServIpv6AceType_standard;
            break;

        default:
            break;
    }

    return TRUE;
}

static BOOL_T
diffServIpv6AceTable_next(
    int      compc,
    oid     *compl,
    UI32_T *index,
    RULE_TYPE_UI_Ace_Entry_T *ace_p)
{
    *index = compl[0];
    memset(ace_p, 0, sizeof(*ace_p));
    /*check  the length of inputing index,if <1 we should try get {0.0.0.0.0...} */
    if (compc < 1)
    {
        /*get data*/
        if (L4_PMGR_QoS_GetDiffServIpv6AceEntry(*index, ace_p) != RULE_TYPE_OK)
        {
            /*get data*/
            if (L4_PMGR_QoS_GetNextDiffServIpv6AceEntry(index, ace_p) != RULE_TYPE_OK)
            {
                return FALSE;
            }
        }
    }
    else
    {
        /*get data*/
        if (L4_PMGR_QoS_GetNextDiffServIpv6AceEntry(index, ace_p) != RULE_TYPE_OK)
        {
            return FALSE;
        }
    }

    switch (ace_p->ace_type)
    {
        case RULE_TYPE_IPV6_EXT_ACL:
            ace_p->ace_type   = VAL_diffServIpv6AceType_extended;
            break;

        case RULE_TYPE_IPV6_STD_ACL:
            ace_p->ace_type   = VAL_diffServIpv6AceType_standard;
            break;

        default:
            break;
    }

    return TRUE;
}

/*
 * var_diffServIpv6AceTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_diffServIpv6AceTable(struct variable *vp,
                         oid * name,
                         size_t * length,
                         int exact,
                         size_t * var_len, WriteMethod ** write_method)
{
    UI32_T compc=0;
    UI32_T index=0;
    oid compl[diffServIpv6AceEntry_INSTANCE_LEN];
    oid best_inst[diffServIpv6AceEntry_INSTANCE_LEN];
    RULE_TYPE_UI_Ace_Entry_T ace;

    switch (vp->magic) {
         case DIFFSERVIPV6ACETYPE:
           *write_method = write_diffServIpv6AceType;
           break;
         case DIFFSERVIPV6ACEACCESS:
           *write_method = write_diffServIpv6AceAccess;
           break;
         case DIFFSERVIPV6ACESOURCEIPADDR:
           *write_method = write_diffServIpv6AceSourceIpAddr;
           break;
         case DIFFSERVIPV6ACESOURCEIPADDRPREFIXLEN:
           *write_method = write_diffServIpv6AceSourceIpAddrPrefixLen;
           break;
         case DIFFSERVIPV6ACEDESTIPADDR:
           *write_method = write_diffServIpv6AceDestIpAddr;
           break;
         case DIFFSERVIPV6ACEDESTIPADDRPREFIXLEN:
           *write_method = write_diffServIpv6AceDestIpAddrPrefixLen;
           break;

#if (SYS_CPNT_ACL_IPV6_EXT_NEXT_HEADER == TRUE)
         case DIFFSERVIPV6ACENEXTHEADER:
           *write_method = write_diffServIpv6AceNextHeader;
           break;
#endif /* end of #if (SYS_CPNT_ACL_IPV6_EXT_NEXT_HEADER == TRUE) */

         case DIFFSERVIPV6ACEDSCP:
           *write_method = write_diffServIpv6AceDscp;
           break;

#if (SYS_CPNT_ACL_IPV6_EXT_FLOW_LABEL == TRUE)
         case DIFFSERVIPV6ACEFLOWLABEL:
           *write_method = write_diffServIpv6AceFlowLabel;
           break;
#endif /* end of #if (SYS_CPNT_ACL_IPV6_EXT_FLOW_LABEL == TRUE) */

         case DIFFSERVIPV6ACESTATUS:
           *write_method = write_diffServIpv6AceStatus;
           break;
       default:
           *write_method = 0;
           break;
       }

    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,compl, diffServIpv6AceEntry_INSTANCE_LEN);

    if (exact)/*get,set*/
    {
        if (!diffServIpv6AceTable_get(compc, compl, &index, &ace))
            return NULL;
    }
    else/*getnext*/
    {
        if (!diffServIpv6AceTable_next(compc, compl, &index, &ace))
        {
            return NULL;
        }
    }

    memcpy(name, vp->name, vp->namelen*sizeof(oid));
    best_inst[0] = index;
    memcpy(name + vp->namelen, best_inst, diffServIpv6AceEntry_INSTANCE_LEN*sizeof(oid));
    *length = vp->namelen + diffServIpv6AceEntry_INSTANCE_LEN;

    /*
     * * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
      case DIFFSERVIPV6ACEINDEX:
        long_return = index;
        *var_len = sizeof(long_return);
        return (u_char *) &long_return;
#endif
      case DIFFSERVIPV6ACETYPE:
        long_return = ace.ace_type;
        *var_len = sizeof(long_return);
        return (u_char *) &long_return;
      case DIFFSERVIPV6ACEACCESS:
        long_return = (UI32_T)ace.access;
        *var_len = sizeof(long_return);
        return (u_char *) &long_return;
      case DIFFSERVIPV6ACESOURCEIPADDR:
        memcpy(return_buf, ace.ipv6.sip.addr, MAXSIZE_diffServIpv6AceSourceIpAddr);
        *var_len = MAXSIZE_diffServIpv6AceSourceIpAddr;
        return (u_char *) &return_buf;
      case DIFFSERVIPV6ACESOURCEIPADDRPREFIXLEN:
        long_return = (UI32_T)ace.ipv6.sip.prefix_len;
        *var_len = sizeof(long_return);
        return (u_char *) &long_return;
      case DIFFSERVIPV6ACEDESTIPADDR:
        memcpy(return_buf, ace.ipv6.dip.addr, MAXSIZE_diffServIpv6AceDestIpAddr);
        *var_len = MAXSIZE_diffServIpv6AceDestIpAddr;
        return (u_char *) &return_buf;
      case DIFFSERVIPV6ACEDESTIPADDRPREFIXLEN:
        long_return = (UI32_T)ace.ipv6.dip.prefix_len;
        *var_len = sizeof(long_return);
        return (u_char *) &long_return;

#if (SYS_CPNT_ACL_IPV6_EXT_NEXT_HEADER == TRUE)
      case DIFFSERVIPV6ACENEXTHEADER:
        long_return = (UI32_T)ace.ipv6.next_header.u.s.data;
        *var_len = sizeof(long_return);
        return (u_char *) &long_return;
#endif /* end of #if (SYS_CPNT_ACL_IPV6_EXT_NEXT_HEADER == TRUE) */

      case DIFFSERVIPV6ACEDSCP:
        /* traffic class =  DS field(6 bits) + ECN (2 bits)
         */
        long_return = (UI32_T)ace.ipv6.traffic_class.u.s.data >> 2;
        *var_len = sizeof(long_return);
        return (u_char *) &long_return;

#if (SYS_CPNT_ACL_IPV6_EXT_FLOW_LABEL == TRUE)
      case DIFFSERVIPV6ACEFLOWLABEL:
        long_return = (UI32_T)ace.ipv6.flow_label.u.s.data;
        *var_len = sizeof(long_return);
        return (u_char *) &long_return;
#endif /* end of #if (SYS_CPNT_ACL_IPV6_EXT_FLOW_LABEL == TRUE) */

      case DIFFSERVIPV6ACESTATUS:
        long_return = (UI32_T)ace.row_status;
        *var_len = sizeof(long_return);
        return (u_char *) &long_return;
    default:
        ERROR_MSG("");
    }
    return NULL;
}

int
write_diffServIpv6AceType(int action,
                            u_char * var_val,
                            u_char var_val_type,
                            size_t var_val_len,
                            u_char * statP, oid * name, size_t name_len)
{
    long value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    /*check max length of the inputing index */
    if(name_len > oid_name_length+diffServIpv6AceEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            if (*(long *)var_val  < VAL_diffServIpv6AceType_standard || *(long *)var_val  > VAL_diffServIpv6AceType_extended)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }

        case RESERVE2:
        {
            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            UI32_T  index;
            index = name[oid_name_length];
            value = *(long *)var_val;
            if(L4_PMGR_QoS_SetDiffServIpv6AceType(index, (UI8_T)value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
            break;
        }

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_diffServIpv6AceAccess(int action,
                            u_char * var_val,
                            u_char var_val_type,
                            size_t var_val_len,
                            u_char * statP, oid * name, size_t name_len)
{
    long value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    /*check max length of the inputing index */
    if(name_len > oid_name_length+diffServIpv6AceEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            if (*(long *)var_val  < VAL_diffServIpv6AceAccess_permit || *(long *)var_val  > VAL_diffServIpv6AceAccess_deny)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }

        case RESERVE2:
        {
            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            UI32_T  index;
            index = name[oid_name_length];
            value = *(long *)var_val;
            if(L4_PMGR_QoS_SetDiffServIpv6AceAccess(index, value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
            break;
        }

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_diffServIpv6AceSourceIpAddr(int action,
                                  u_char * var_val,
                                  u_char var_val_type,
                                  size_t var_val_len,
                                  u_char * statP,
                                  oid * name, size_t name_len)
{
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    /*check max length of the inputing index */
    if(name_len > oid_name_length+diffServIpv6AceEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_OCTET_STR)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > MAXSIZE_diffServIpv6AceSourceIpAddr)
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }

        case RESERVE2:
        {
            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            UI32_T  index;
            UI8_T buffer[MAXSIZE_diffServIpv6AceSourceIpAddr] = {0};
            index = name[oid_name_length];
            memcpy(buffer,var_val,var_val_len);
            if(L4_PMGR_QoS_SetDiffServIpv6AceSourceIpAddr(index, buffer) != TRUE)
                return SNMP_ERR_COMMITFAILED;
            break;
        }

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_diffServIpv6AceSourceIpAddrPrefixLen(int action,
                                           u_char * var_val,
                                           u_char var_val_type,
                                           size_t var_val_len,
                                           u_char * statP,
                                           oid * name, size_t name_len)
{
    long value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    /*check max length of the inputing index */
    if(name_len > oid_name_length+diffServIpv6AceEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            if ( *(long *)var_val  > MAX_diffServIpv6AceSourceIpAddrPrefixLen)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }

        case RESERVE2:
        {
            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            UI32_T  index;
            index = name[oid_name_length];
            value = *(long *)var_val;
            if(L4_PMGR_QoS_SetDiffServIpv6AceSourceIpAddrPrefix(index, value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
            break;
        }

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_diffServIpv6AceDestIpAddr(int action,
                                u_char * var_val,
                                u_char var_val_type,
                                size_t var_val_len,
                                u_char * statP,
                                oid * name, size_t name_len)
{
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    /*check max length of the inputing index */
    if(name_len > oid_name_length+diffServIpv6AceEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_OCTET_STR)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > MAXSIZE_diffServIpv6AceDestIpAddr)
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }

        case RESERVE2:
        {
            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            UI32_T  index;
            UI8_T buffer[MAXSIZE_diffServIpv6AceDestIpAddr] = {0};
            index = name[oid_name_length];
            memcpy(buffer,var_val,var_val_len);
            if(L4_PMGR_QoS_SetDiffServIpv6AceDestIpAddr(index, buffer) != TRUE)
                return SNMP_ERR_COMMITFAILED;
            break;
        }

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_diffServIpv6AceDestIpAddrPrefixLen(int action,
                                         u_char * var_val,
                                         u_char var_val_type,
                                         size_t var_val_len,
                                         u_char * statP,
                                         oid * name, size_t name_len)
{
    long value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    /*check max length of the inputing index */
    if(name_len > oid_name_length+diffServIpv6AceEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            if ( *(long *)var_val  > SYS_ADPT_ACL_MAX_DST_IPV6_PREFIX_LEN)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }

        case RESERVE2:
        {
            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            UI32_T  index;
            index = name[oid_name_length];
            value = *(long *)var_val;
            if( L4_PMGR_QoS_SetDiffServIpv6AceDestIpAddrPrefix(index, value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
            break;
        }

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }
    return SNMP_ERR_NOERROR;
}

#if (SYS_CPNT_ACL_IPV6_EXT_NEXT_HEADER == TRUE)
int
write_diffServIpv6AceNextHeader(int action,
                                u_char * var_val,
                                u_char var_val_type,
                                size_t var_val_len,
                                u_char * statP,
                                oid * name, size_t name_len)
{
    long value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    /*check max length of the inputing index */
    if(name_len > oid_name_length+diffServIpv6AceEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            if ( *(long *)var_val  > MAX_diffServIpv6AceNextHeader)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }

        case RESERVE2:
        {
            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            UI32_T  index;
            index = name[oid_name_length];
            value = *(long *)var_val;
            if(L4_PMGR_QoS_SetDiffServIpv6AceNextHeader(index, value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
            break;
        }

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }
    return SNMP_ERR_NOERROR;
}
#endif /* end of #if (SYS_CPNT_ACL_IPV6_EXT_NEXT_HEADER == TRUE) */

int
write_diffServIpv6AceDscp(int action,
                          u_char * var_val,
                          u_char var_val_type,
                          size_t var_val_len,
                          u_char * statP, oid * name, size_t name_len)
{
    long value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    /*check max length of the inputing index */
    if(name_len > oid_name_length+diffServIpv6AceEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            if ( *(long *)var_val  > MAX_diffServIpv6AceDscp)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }

        case RESERVE2:
        {
            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            UI32_T  index;
            index = name[oid_name_length];
            value = *(long *)var_val;
            if(L4_PMGR_QoS_SetDiffServIpv6AceDscp(index, value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
            break;
        }

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }
    return SNMP_ERR_NOERROR;
}

#if (SYS_CPNT_ACL_IPV6_EXT_FLOW_LABEL == TRUE)
int
write_diffServIpv6AceFlowLabel(int action,
                               u_char * var_val,
                               u_char var_val_type,
                               size_t var_val_len,
                               u_char * statP, oid * name, size_t name_len)
{
    long value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    /*check max length of the inputing index */
    if(name_len > oid_name_length+diffServIpv6AceEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            if (*(long *) var_val < MIN_diffServIpv6AceFlowLabel|| *(long *) var_val > MAX_diffServIpv6AceFlowLabel)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }

        case RESERVE2:
        {
            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            UI32_T  index;
            index = name[oid_name_length];
            value = *(long *)var_val;
            if(L4_PMGR_QoS_SetDiffServIpv6AceFlowLabel(index, value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
            break;
        }

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }
    return SNMP_ERR_NOERROR;
}
#endif /* end of #if (SYS_CPNT_ACL_IPV6_EXT_FLOW_LABEL == TRUE) */

int
write_diffServIpv6AceStatus(int action,
                            u_char * var_val,
                            u_char var_val_type,
                            size_t var_val_len,
                            u_char * statP, oid * name, size_t name_len)
{
    long value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    /*check max length of the inputing index */
    if(name_len > oid_name_length+diffServIpv6AceEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            if (*(long *)var_val  < VAL_diffServIpv6AceStatus_active || *(long *)var_val > VAL_diffServIpv6AceStatus_destroy)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            else if (*(long *)var_val == VAL_aclIpAceStatus_notReady)
              return SNMP_ERR_WRONGVALUE;
            break;
        }

        case RESERVE2:
        {
            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            UI32_T  index;
            index = name[oid_name_length];
            value = *(long *)var_val;
            if(L4_PMGR_QoS_SetDiffServIpv6AceStatus(index, value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
            break;
        }

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }
    return SNMP_ERR_NOERROR;
}
#endif /* end of #if (SYS_CPNT_ACL_IPV6 == TRUE) */

#define diffServMacAceEntry_INSTANCE_LEN 1

static BOOL_T
diffServMacAceTable_get(
    int      compc,
    oid     *compl,
    UI32_T  *index,
    RULE_TYPE_UI_Ace_Entry_T  *ace_p)
{
    if (compc != diffServMacAceEntry_INSTANCE_LEN)
    {
        return FALSE;
    }
    *index = compl[0];
    memset(ace_p, 0, sizeof(RULE_TYPE_UI_Ace_Entry_T));

    if (L4_PMGR_QoS_GetDiffServMacAceEntry(*index, ace_p) == RULE_TYPE_OK)
    {
        return TRUE;
    }

    return FALSE;
}

static BOOL_T
diffServMacAceTable_next(
    int      compc,
    oid     *compl,
    UI32_T  *index,
    RULE_TYPE_UI_Ace_Entry_T  *ace_p)
{
    *index = compl[0];
    memset(ace_p, 0, sizeof(RULE_TYPE_UI_Ace_Entry_T));

    if (compc<1)
    {
        if (L4_PMGR_QoS_GetDiffServMacAceEntry(*index, ace_p)!= RULE_TYPE_OK)
        {
            if (L4_PMGR_QoS_GetNextDiffServMacAceEntry(index, ace_p)!=TRUE)
            {
                return FALSE;
            }
        }
    }
    else
    {
        if (L4_PMGR_QoS_GetNextDiffServMacAceEntry(index, ace_p)!= TRUE)
        {
            return FALSE;
        }
    }
    return TRUE;
}

unsigned char  *
var_diffServMacAceTable(
    struct variable *vp,
    oid * name,
    size_t * length,
    int exact,
    size_t * var_len, WriteMethod ** write_method)
{
    UI32_T compc=0;
    UI32_T index=0;
    oid compl[diffServMacAceEntry_INSTANCE_LEN];
    oid best_inst[diffServMacAceEntry_INSTANCE_LEN];
    RULE_TYPE_UI_Ace_Entry_T ace;

    switch (vp->magic)
    {
        case DIFFSERVMACACEACCESS:
            *write_method = write_diffServMacAceAccess;
            break;
        case DIFFSERVMACACEPKTFORMAT:
            *write_method = write_diffServMacAcePktformat;
            break;
        case DIFFSERVMACACESOURCEMACADDR:
            *write_method = write_diffServMacAceSourceMacAddr;
            break;
        case DIFFSERVMACACESOURCEMACADDRBITMASK:
            *write_method = write_diffServMacAceSourceMacAddrBitmask;
            break;
        case DIFFSERVMACACEDESTMACADDR:
            *write_method = write_diffServMacAceDestMacAddr;
            break;
        case DIFFSERVMACACEDESTMACADDRBITMASK:
            *write_method = write_diffServMacAceDestMacAddrBitmask;
            break;
        case DIFFSERVMACACEVIDOP:
            *write_method = write_diffServMacAceVidOp;
            break;
        case DIFFSERVMACACEMINVID:
            *write_method = write_diffServMacAceMinVid;
            break;
        case DIFFSERVMACACEVIDBITMASK:
            *write_method = write_diffServMacAceVidBitmask;
            break;
        case DIFFSERVMACACEMAXVID:
            *write_method = write_diffServMacAceMaxVid;
            break;;
        case DIFFSERVMACACEETHERTYPEOP:
            *write_method = write_diffServMacAceEtherTypeOp;
            break;
        case DIFFSERVMACACEETHERTYPEBITMASK:
            *write_method = write_diffServMacAceEtherTypeBitmask;
            break;
        case DIFFSERVMACACEMINETHERTYPE:
            *write_method = write_diffServMacAceMinEtherType;
            break;
        case DIFFSERVMACACEMAXETHERTYPE:
            *write_method = write_diffServMacAceMaxEtherType;
            break;
        case DIFFSERVMACACESTATUS:
            *write_method = write_diffServMacAceStatus;
            break;
        case DIFFSERVMACACECOSOP:
            *write_method = write_diffServMacAceCosOp;
            break;
        case DIFFSERVMACACECOSBITMASK:
            *write_method = write_diffServMacAceCosBitmask;
            break;
        case DIFFSERVMACACEMINCOS:
            *write_method = write_diffServMacAceMinCos;
            break;
        case DIFFSERVMACACEMAXCOS:
            *write_method = write_diffServMacAceMaxCos;
            break;
        case DIFFSERVMACACESOURCEIPADDR:
            *write_method = write_diffServMacAceSourceIpAddr;
            break;
        case DIFFSERVMACACESOURCEIPADDRBITMASK:
            *write_method = write_diffServMacAceSourceIpAddrBitmask;
            break;
        case DIFFSERVMACACEDESTIPADDR:
            *write_method = write_diffServMacAceDestinationIpAddr;
            break;
        case DIFFSERVMACACEDESTIPADDRBITMASK:
            *write_method = write_diffServMacAceDestinationIpAddrBitmask;
            break;
        case DIFFSERVMACACESOURCEIPV6ADDR:
            *write_method = write_diffServMacAceSourceIpv6Addr;
            break;
        case DIFFSERVMACACESOURCEIPV6ADDRPREFIXLEN:
            *write_method = write_diffServMacAceSourceIpv6PrefixLen;
            break;
        case DIFFSERVMACACEDESTIPV6ADDR:
            *write_method = write_diffServMacAceDestIpv6Addr;
            break;
        case DIFFSERVMACACEDESTIPV6ADDRPREFIXLEN:
            *write_method = write_diffServMacAceDestIpIpv6PrefixLen;
            break;
        case DIFFSERVMACACEIPPROTOCOL:
            *write_method = write_diffServMacAceIpProtocol;
            break;
        case DIFFSERVMACACEL4SOURCEPORTOP:
            *write_method = write_diffServMacAceSourcePortOp;
            break;
        case DIFFSERVMACACEL4SOURCEPORT:
            *write_method = write_diffServMacAceSourcePort;
            break;
        case DIFFSERVMACACEL4SOURCEPORTBITMASK:
            *write_method = write_diffServMacAceSourcePortBitMask;
            break;
        case DIFFSERVMACACEL4DESTPORTOP:
            *write_method = write_diffServMacAceDestPortOp;
            break;
        case DIFFSERVMACACEL4DESTPORT:
            *write_method = write_diffServMacAceDestPort;
            break;
        case DIFFSERVMACACEL4DESTPORTBITMASK:
            *write_method = write_diffServMacAceDestPortBitmask;
            break;
        default:
            *write_method = 0;
    }

    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,compl,
        diffServMacAceEntry_INSTANCE_LEN);

    if (exact)/*get,set*/
    {
        if (!diffServMacAceTable_get(compc, compl,&index, &ace))
            return NULL;
    }
    else/*getnext*/
    {
        if (!diffServMacAceTable_next(compc, compl,&index, &ace))
        {
            return NULL;
        }
    }

    memcpy(name, vp->name, vp->namelen*sizeof(oid));
    best_inst[0] = index;
    memcpy(name + vp->namelen, best_inst, diffServMacAceEntry_INSTANCE_LEN*sizeof(oid));
    *length = vp->namelen + diffServMacAceEntry_INSTANCE_LEN;

    switch (vp->magic)
    {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case DIFFSERVMACACEINDEX:
            long_return = index;
            *var_len = sizeof(long_return);
            return (u_char *) &long_return;
#endif
        case DIFFSERVMACACEACCESS:
            long_return = ace.access;
            *var_len = sizeof(long_return);
            return (u_char *) &long_return;
        case DIFFSERVMACACEPKTFORMAT:
            long_return = ace.pkt_format;
            *var_len = sizeof(long_return);
            return (u_char *) &long_return;
        case DIFFSERVMACACESOURCEMACADDR:
            memcpy(return_buf, ace.ether.sa.addr,
                SIZE_diffServMacAceSourceMacAddr);
            *var_len  =  SIZE_diffServMacAceSourceMacAddr;
            return (u_char*)return_buf;
        case DIFFSERVMACACESOURCEMACADDRBITMASK:
            memcpy(return_buf, ace.ether.sa.mask,
                SIZE_diffServMacAceSourceMacAddrBitmask);
            *var_len  =  SIZE_diffServMacAceSourceMacAddrBitmask;
            return (u_char*)return_buf;
        case DIFFSERVMACACEDESTMACADDR:
            memcpy(return_buf, ace.ether.da.addr,
                SIZE_diffServMacAceDestMacAddr);
            *var_len  =  SIZE_diffServMacAceDestMacAddr;
            return (u_char*)return_buf;
        case DIFFSERVMACACEDESTMACADDRBITMASK:
            memcpy(return_buf, ace.ether.da.mask,
                SIZE_diffServMacAceDestMacAddr);
            *var_len  =  SIZE_diffServMacAceDestMacAddr;
            return (u_char*)return_buf;
        case DIFFSERVMACACEVIDOP:
            long_return = ace.ether.vid.op;
            *var_len = sizeof(long_return);
            return (u_char *) &long_return;
        case DIFFSERVMACACEMINVID:
            long_return = (ace.ether.vid.op == VAL_diffServMacAceVidOp_range)
                          ? ace.ether.vid.u.range.min : ace.ether.vid.u.s.data;
            *var_len = sizeof(long_return);
            return (u_char *) &long_return;
        case DIFFSERVMACACEVIDBITMASK:
            long_return = ace.ether.vid.u.s.mask;
            *var_len = sizeof(long_return);
            return (u_char *) &long_return;
        case DIFFSERVMACACEMAXVID:
            long_return = (ace.ether.vid.op == VAL_diffServMacAceVidOp_range)
                          ? ace.ether.vid.u.range.max : ace.ether.vid.u.s.data;
            *var_len = sizeof(long_return);
            return (u_char *) &long_return;
        case DIFFSERVMACACEETHERTYPEOP:
            long_return = ace.ether.ethertype.op;
            *var_len = sizeof(long_return);
            return (u_char *) &long_return;
        case DIFFSERVMACACEETHERTYPEBITMASK:
            long_return = ace.ether.ethertype.u.s.mask;
            *var_len = sizeof(long_return);
            return (u_char *) &long_return;
        case DIFFSERVMACACEMINETHERTYPE:
           long_return = (ace.ether.ethertype.op == VAL_diffServMacAceEtherTypeOp_range)
                          ? ace.ether.ethertype.u.range.min : ace.ether.ethertype.u.s.data;
            *var_len = sizeof(long_return);
            return (u_char *) &long_return;
        case DIFFSERVMACACEMAXETHERTYPE:
            long_return = (ace.ether.ethertype.op == VAL_diffServMacAceEtherTypeOp_range)
                          ? ace.ether.ethertype.u.range.max : ace.ether.ethertype.u.s.data;
            *var_len = sizeof(long_return);
            return (u_char *) &long_return;
        case DIFFSERVMACACESTATUS:
            long_return = ace.row_status;
            *var_len = sizeof(long_return);
            return (u_char *) &long_return;

        case DIFFSERVMACACECOSOP:
            long_return = ace.ether.cos.op;
            *var_len = sizeof(long_return);
            return (u_char *) &long_return;

        case DIFFSERVMACACECOSBITMASK:
            long_return = ace.ether.cos.u.s.mask;
            *var_len = sizeof(long_return);
            return (u_char *) &long_return;

        case DIFFSERVMACACEMINCOS:
            long_return = (ace.ether.cos.op == VAL_diffServMacAceCosOp_range)
                          ? ace.ether.cos.u.range.min : ace.ether.cos.u.s.data;
            *var_len = sizeof(long_return);
            return (u_char *) &long_return;

        case DIFFSERVMACACEMAXCOS:
            long_return = (ace.ether.cos.op == VAL_diffServMacAceCosOp_range)
                          ? ace.ether.cos.u.range.max : ace.ether.cos.u.s.data;
            *var_len = sizeof(long_return);
            return (u_char *) &long_return;

#if (SYS_CPNT_ACL_MAC_IP_MIX == TRUE)
        case DIFFSERVMACACESOURCEIPADDR:
            {
                UI32_T *ip_addr = (UI32_T *)& ace.ipv4.sip.addr;

                long_return =  L_STDLIB_Ntoh32(*ip_addr);
            }
            *var_len = sizeof(long_return);
            return (u_char *) &long_return;

        case DIFFSERVMACACESOURCEIPADDRBITMASK:
            {
                UI32_T *ip_addr = (UI32_T *)& ace.ipv4.sip.mask;

                long_return =  L_STDLIB_Ntoh32(*ip_addr);
            }
            *var_len = sizeof(long_return);
            return (u_char *) &long_return;

        case DIFFSERVMACACEDESTIPADDR:
            {
                UI32_T *ip_addr = (UI32_T *)& ace.ipv4.dip.addr;

                long_return =  L_STDLIB_Ntoh32(*ip_addr);
            }
            *var_len = sizeof(long_return);
            return (u_char *) &long_return;

        case DIFFSERVMACACEDESTIPADDRBITMASK:
            {
                UI32_T *ip_addr = (UI32_T *)& ace.ipv4.dip.mask;

                long_return =  L_STDLIB_Ntoh32(*ip_addr);
            }
            *var_len = sizeof(long_return);
            return (u_char *) &long_return;

        case DIFFSERVMACACESOURCEIPV6ADDR:
            memcpy(return_buf, ace.ipv6.sip.addr,
                MAXSIZE_diffServIpv6AceSourceIpAddr);
            *var_len = MAXSIZE_diffServIpv6AceSourceIpAddr;
            return (u_char *) return_buf;

        case DIFFSERVMACACESOURCEIPV6ADDRPREFIXLEN:
            long_return = ace.ipv6.sip.prefix_len;
            *var_len = sizeof(long_return);
            return (u_char *) &long_return;

        case DIFFSERVMACACEDESTIPV6ADDR:
            memcpy(return_buf, ace.ipv6.dip.addr,
                MAXSIZE_diffServIpv6AceDestIpAddr);
            *var_len = MAXSIZE_diffServIpv6AceDestIpAddr;
            return (u_char *) return_buf;

        case DIFFSERVMACACEDESTIPV6ADDRPREFIXLEN:
            long_return = ace.ipv6.dip.prefix_len;
            *var_len = sizeof(long_return);
            return (u_char *) &long_return;

        case DIFFSERVMACACEIPPROTOCOL:
            *var_len = sizeof(long_return);
            long_return = RULE_TYPE_UNDEF_IP_PROTOCOL;

            if (ace.ipv4.protocol.op == RULE_TYPE_IPV4_PROTOCOL_OP_EQUAL)
            {
                long_return = ace.ipv4.protocol.u.s.data;
            }
            else if (ace.ipv6.next_header.op == RULE_TYPE_IPV6_NEXT_HEADER_OP_EQUAL)
            {
                long_return = ace.ipv6.next_header.u.s.data;
            }

            return (u_char *) &long_return;

        case DIFFSERVMACACEL4SOURCEPORTOP:
            long_return = ace.l4_common.sport.op;
            *var_len = sizeof(long_return);
            return (u_char *) &long_return;

        case DIFFSERVMACACEL4SOURCEPORT:
            long_return = ace.l4_common.sport.u.s.data;
            *var_len = sizeof(long_return);
            return (u_char *) &long_return;

        case DIFFSERVMACACEL4SOURCEPORTBITMASK:
            long_return = ace.l4_common.sport.u.s.mask;
            *var_len = sizeof(long_return);
            return (u_char *) &long_return;

        case DIFFSERVMACACEL4DESTPORTOP:
            long_return = ace.l4_common.dport.op;
            *var_len = sizeof(long_return);
            return (u_char *) &long_return;

        case DIFFSERVMACACEL4DESTPORT:
            long_return = ace.l4_common.dport.u.s.data;
            *var_len = sizeof(long_return);
            return (u_char *) &long_return;

        case DIFFSERVMACACEL4DESTPORTBITMASK:
             long_return = ace.l4_common.dport.u.s.mask;
            *var_len = sizeof(long_return);
            return (u_char *) &long_return;
#endif /* SYS_CPNT_ACL_MAC_IP_MIX */

        default:
            ERROR_MSG("");
            break;
    }

    return NULL;
}

int write_diffServMacAceAccess(int       action,
                                         u_char    *var_val,
                                         u_char    var_val_type,
                                         size_t    var_val_len,
                                         u_char    *statP,
                                         oid       *name,
                                         size_t    name_len)
{
    int value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    if(name_len > oid_name_length+diffServMacAceEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            if (*(long *)var_val < VAL_diffServMacAceAccess_permit|| *(long *)var_val > VAL_diffServMacAceAccess_deny)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }

        case RESERVE2:
        {
            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            UI32_T  index;
            index = name[oid_name_length];
            value = *(long *)var_val;

            if(L4_PMGR_QoS_SetDiffServMacAceAccess(index, value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }
    return SNMP_ERR_NOERROR;
}

int write_diffServMacAcePktformat(int       action,
                                         u_char    *var_val,
                                         u_char    var_val_type,
                                         size_t    var_val_len,
                                         u_char    *statP,
                                         oid       *name,
                                         size_t    name_len)
{
    long value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    if(name_len > oid_name_length+diffServMacAceEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            if (*(long *)var_val < VAL_diffServMacAcePktformat_any|| *(long *)var_val > VAL_diffServMacAcePktformat_tagged802Dot3)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }

        case RESERVE2:
        {
            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            UI32_T  index;
            index = name[oid_name_length];
            value = *(long *)var_val;

            if(L4_PMGR_QoS_SetDiffServMacAcePktformat(index, value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }
    return SNMP_ERR_NOERROR;
}

int write_diffServMacAceSourceMacAddr(int       action,
                                         u_char    *var_val,
                                         u_char    var_val_type,
                                         size_t    var_val_len,
                                         u_char    *statP,
                                         oid       *name,
                                         size_t    name_len)
{
    int size;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    if(name_len > oid_name_length+diffServMacAceEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch (action)
    {
        case RESERVE1:
        {
            size = var_val_len;
            if (var_val_type != ASN_OCTET_STR)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if(size > SIZE_diffServMacAceSourceMacAddr)
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }
        case RESERVE2:
        {
            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            UI32_T  index;
            UI8_T buffer[SIZE_diffServMacAceSourceMacAddr+1];
            index = name[oid_name_length];
            memcpy(buffer, var_val, var_val_len);
            buffer[var_val_len]='\0';

            if(L4_PMGR_QoS_SetDiffServMacAceSourceMacAddr(index, buffer) != TRUE)
                return SNMP_ERR_COMMITFAILED;
            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }
    return SNMP_ERR_NOERROR;
}

int write_diffServMacAceSourceMacAddrBitmask(int       action,
                                         u_char    *var_val,
                                         u_char    var_val_type,
                                         size_t    var_val_len,
                                         u_char    *statP,
                                         oid       *name,
                                         size_t    name_len)
{
    int size;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    if(name_len > oid_name_length+diffServMacAceEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch (action)
    {
        case RESERVE1:
        {
            size = var_val_len;
            if (var_val_type != ASN_OCTET_STR)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if(size > SIZE_diffServMacAceSourceMacAddrBitmask)
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }
        case RESERVE2:
        {
            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            UI32_T  index;
            UI8_T buffer[SIZE_diffServMacAceSourceMacAddrBitmask+1];
            index = name[oid_name_length];
            memcpy(buffer, var_val, var_val_len);
            buffer[var_val_len]='\0';

            if(L4_PMGR_QoS_SetDiffServMacAceSourceMacAddrBitmask(index, buffer) != TRUE)
                return SNMP_ERR_COMMITFAILED;
            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }
    return SNMP_ERR_NOERROR;
}

int write_diffServMacAceDestMacAddr(int       action,
                                         u_char    *var_val,
                                         u_char    var_val_type,
                                         size_t    var_val_len,
                                         u_char    *statP,
                                         oid       *name,
                                         size_t    name_len)
{
    int size;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    if(name_len > oid_name_length+diffServMacAceEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch (action)
    {
        case RESERVE1:
        {
            size = var_val_len;
            if (var_val_type != ASN_OCTET_STR)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if(size > SIZE_diffServMacAceDestMacAddr)
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }
        case RESERVE2:
        {
            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            UI32_T  index;
            UI8_T buffer[SIZE_diffServMacAceDestMacAddr+1];
            index = name[oid_name_length];
            memcpy(buffer, var_val, var_val_len);
            buffer[var_val_len]='\0';

            if(L4_PMGR_QoS_SetDiffServMacAceDestMacAddr(index, buffer) != TRUE)
                return SNMP_ERR_COMMITFAILED;
            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }
    return SNMP_ERR_NOERROR;
}

int write_diffServMacAceDestMacAddrBitmask(int       action,
                                         u_char    *var_val,
                                         u_char    var_val_type,
                                         size_t    var_val_len,
                                         u_char    *statP,
                                         oid       *name,
                                         size_t    name_len)
{
    int size;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    if(name_len > oid_name_length+diffServMacAceEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch (action)
    {
        case RESERVE1:
        {
            size = var_val_len;
            if (var_val_type != ASN_OCTET_STR)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if(size > SIZE_diffServMacAceDestMacAddrBitmask)
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }
        case RESERVE2:
        {
            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            UI32_T  index;
            UI8_T buffer[SIZE_diffServMacAceDestMacAddrBitmask+1];
            index = name[oid_name_length];
            memcpy(buffer, var_val, var_val_len);
            buffer[var_val_len]='\0';

            if(L4_PMGR_QoS_SetDiffServMacAceDestMacAddrBitmask(index, buffer) != TRUE)
                return SNMP_ERR_COMMITFAILED;
            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }
    return SNMP_ERR_NOERROR;
}

int write_diffServMacAceVidOp(int       action,
                                         u_char    *var_val,
                                         u_char    var_val_type,
                                         size_t    var_val_len,
                                         u_char    *statP,
                                         oid       *name,
                                         size_t    name_len)
{
    long value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    if(name_len > oid_name_length+diffServMacAceEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            if (*(long *)var_val < VAL_diffServMacAceVidOp_noOperator|| *(long *)var_val > VAL_diffServMacAceEtherTypeOp_range)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }

        case RESERVE2:
        {
            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            UI32_T  index;
            index = name[oid_name_length];
            value = *(long *)var_val;

            if(L4_PMGR_QoS_SetDiffServMacAceVidOp(index, value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }
    return SNMP_ERR_NOERROR;
}
int write_diffServMacAceMinVid(int       action,
                                         u_char    *var_val,
                                         u_char    var_val_type,
                                         size_t    var_val_len,
                                         u_char    *statP,
                                         oid       *name,
                                         size_t    name_len)
{
    long value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    if(name_len > oid_name_length+diffServMacAceEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            if (*(long *)var_val < MIN_diffServMacAceMinVid|| *(long *)var_val > MAX_diffServMacAceMinVid)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }

        case RESERVE2:
        {
            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            UI32_T  index;
            index = name[oid_name_length];
            value = *(long *)var_val;

            /* min && max should be the same
             */
            if(L4_PMGR_QoS_SetDiffServMacAceMinVid(index, value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }
    return SNMP_ERR_NOERROR;
}

int write_diffServMacAceVidBitmask(int       action,
                                         u_char    *var_val,
                                         u_char    var_val_type,
                                         size_t    var_val_len,
                                         u_char    *statP,
                                         oid       *name,
                                         size_t    name_len)
{
    long value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    if(name_len > oid_name_length+diffServMacAceEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            if (*(long *)var_val < MIN_diffServMacAceVidBitmask|| *(long *)var_val > MAX_diffServMacAceVidBitmask)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }

        case RESERVE2:
        {
            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            UI32_T  index;
            index = name[oid_name_length];
            value = *(long *)var_val;

            if(L4_PMGR_QoS_SetDiffServMacAceVidBitmask(index, value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }
    return SNMP_ERR_NOERROR;
}

int write_diffServMacAceMaxVid(int       action,
                                         u_char    *var_val,
                                         u_char    var_val_type,
                                         size_t    var_val_len,
                                         u_char    *statP,
                                         oid       *name,
                                         size_t    name_len)
{
    long value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    if(name_len > oid_name_length+diffServMacAceEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            if (*(long *)var_val < MIN_diffServMacAceMaxVid|| *(long *)var_val > MAX_diffServMacAceMaxVid)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }

        case RESERVE2:
        {
            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            UI32_T  index;
            index = name[oid_name_length];
            value = *(long *)var_val;

            if(L4_PMGR_QoS_SetDiffServMacAceMaxVid(index, value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }
    return SNMP_ERR_NOERROR;
}

int write_diffServMacAceEtherTypeOp(int       action,
                                         u_char    *var_val,
                                         u_char    var_val_type,
                                         size_t    var_val_len,
                                         u_char    *statP,
                                         oid       *name,
                                         size_t    name_len)
{
    long value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    if(name_len > oid_name_length+diffServMacAceEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            if (*(long *)var_val < VAL_diffServMacAceEtherTypeOp_noOperator|| *(long *)var_val > VAL_diffServMacAceEtherTypeOp_range)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }

        case RESERVE2:
        {
            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            UI32_T  index;
            index = name[oid_name_length];
            value = *(long *)var_val;

            if(L4_PMGR_QoS_SetDiffServMacAceEtherTypeOp(index, value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }
    return SNMP_ERR_NOERROR;
}

int write_diffServMacAceEtherTypeBitmask(int       action,
                                         u_char    *var_val,
                                         u_char    var_val_type,
                                         size_t    var_val_len,
                                         u_char    *statP,
                                         oid       *name,
                                         size_t    name_len)
{
    long value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    if(name_len > oid_name_length+diffServMacAceEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            if (*(long *)var_val < MIN_diffServMacAceEtherTypeBitmask|| *(long *)var_val > MAX_diffServMacAceEtherTypeBitmask)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }

        case RESERVE2:
        {
            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            UI32_T  index;
            index = name[oid_name_length];
            value = *(long *)var_val;
            if(L4_PMGR_QoS_SetDiffServMacAceEtherTypeBitmask(index, value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }
    return SNMP_ERR_NOERROR;
}

int write_diffServMacAceMinEtherType(int       action,
                                         u_char    *var_val,
                                         u_char    var_val_type,
                                         size_t    var_val_len,
                                         u_char    *statP,
                                         oid       *name,
                                         size_t    name_len)
{
    long value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    if(name_len > oid_name_length+diffServMacAceEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            if (*(long *)var_val < MIN_diffServMacAceMinEtherType|| *(long *)var_val > MAX_diffServMacAceMinEtherType)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }

        case RESERVE2:
        {
            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            UI32_T  index;
            index = name[oid_name_length];
            value = *(long *)var_val;

            /* min && max should be the same
             */
            if(L4_PMGR_QoS_SetDiffServMacAceMinEtherType(index, value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }
    return SNMP_ERR_NOERROR;
}

int write_diffServMacAceMaxEtherType(int       action,
                                         u_char    *var_val,
                                         u_char    var_val_type,
                                         size_t    var_val_len,
                                         u_char    *statP,
                                         oid       *name,
                                         size_t    name_len)
{
    long value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    if(name_len > oid_name_length+diffServMacAceEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            if (*(long *)var_val < MIN_diffServMacAceMaxEtherType|| *(long *)var_val > MAX_diffServMacAceMaxEtherType)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }

        case RESERVE2:
        {
            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            UI32_T  index;
            index = name[oid_name_length];
            value = *(long *)var_val;

            /* min && max should be the same
             */
            if(L4_PMGR_QoS_SetDiffServMacAceMaxEtherType(index, value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }
    return SNMP_ERR_NOERROR;
}

int write_diffServMacAceStatus(int       action,
                                         u_char    *var_val,
                                         u_char    var_val_type,
                                         size_t    var_val_len,
                                         u_char    *statP,
                                         oid       *name,
                                         size_t    name_len)
{
    long value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    if(name_len > oid_name_length+diffServMacAceEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            if (*(long *)var_val < VAL_diffServIpAceStatus_active|| *(long *)var_val > VAL_diffServIpAceStatus_destroy)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }

        case RESERVE2:
        {
            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            UI32_T  index;
            index = name[oid_name_length];
            value = *(long *)var_val;

            if(L4_PMGR_QoS_SetDiffServMacAceStatus(index, value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }
    return SNMP_ERR_NOERROR;
}

int write_diffServMacAceCosOp(int       action,
                                         u_char    *var_val,
                                         u_char    var_val_type,
                                         size_t    var_val_len,
                                         u_char    *statP,
                                         oid       *name,
                                         size_t    name_len)
{
    long value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    if(name_len > oid_name_length+diffServMacAceEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            if (*(long *)var_val < VAL_diffServMacAceVidOp_noOperator|| *(long *)var_val > VAL_diffServMacAceEtherTypeOp_range)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }

        case RESERVE2:
        {
            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            UI32_T  index;
            index = name[oid_name_length];
            value = *(long *)var_val;

            if(L4_PMGR_QoS_SetDiffServMacAceCosOp(index, value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }
    return SNMP_ERR_NOERROR;
}

int write_diffServMacAceCosBitmask(int       action,
                                         u_char    *var_val,
                                         u_char    var_val_type,
                                         size_t    var_val_len,
                                         u_char    *statP,
                                         oid       *name,
                                         size_t    name_len)
{
    long value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    if(name_len > oid_name_length+diffServMacAceEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            if (*(long *)var_val < VAL_diffServMacAceVidOp_noOperator|| *(long *)var_val > VAL_diffServMacAceEtherTypeOp_range)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }

        case RESERVE2:
        {
            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            UI32_T  index;
            index = name[oid_name_length];
            value = *(long *)var_val;

            if(L4_PMGR_QoS_SetDiffServMacAceCosBitmask(index, value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }
    return SNMP_ERR_NOERROR;
}

int write_diffServMacAceMinCos(int       action,
                                         u_char    *var_val,
                                         u_char    var_val_type,
                                         size_t    var_val_len,
                                         u_char    *statP,
                                         oid       *name,
                                         size_t    name_len)
{
    long value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    if(name_len > oid_name_length+diffServMacAceEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            if (*(long *)var_val < VAL_diffServMacAceVidOp_noOperator|| *(long *)var_val > VAL_diffServMacAceEtherTypeOp_range)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }

        case RESERVE2:
        {
            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            UI32_T  index;
            index = name[oid_name_length];
            value = *(long *)var_val;

            /* min && max should be the same
             */
            if(L4_PMGR_QoS_SetDiffServMacAceMinCos(index, value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }
    return SNMP_ERR_NOERROR;
}

int write_diffServMacAceMaxCos(int       action,
                                         u_char    *var_val,
                                         u_char    var_val_type,
                                         size_t    var_val_len,
                                         u_char    *statP,
                                         oid       *name,
                                         size_t    name_len)
{
    long value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    if(name_len > oid_name_length+diffServMacAceEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            if (*(long *)var_val < VAL_diffServMacAceVidOp_noOperator|| *(long *)var_val > VAL_diffServMacAceEtherTypeOp_range)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }

        case RESERVE2:
        {
            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            UI32_T  index;
            index = name[oid_name_length];
            value = *(long *)var_val;

            if(L4_PMGR_QoS_SetDiffServMacAceMaxCos(index, value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_diffServMacAceSourceIpAddr(
    int       action,
    u_char    *var_val,
    u_char    var_val_type,
    size_t    var_val_len,
    u_char    *statP,
    oid       *name,
    size_t    name_len)
{
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    if(name_len > oid_name_length+diffServMacAceEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_IPADDRESS)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len !=  SYS_ADPT_IPV4_ADDR_LEN)
            {
                return SNMP_ERR_WRONGLENGTH;
            }

            break;
        }

        case RESERVE2:
        {
            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            UI32_T  index;
            UI32_T value = 0;
            index = name[oid_name_length];
            memcpy(&value, var_val, var_val_len);
            /* convert host order */
            if(L4_PMGR_QoS_SetDiffServMacAceSourceIpAddr(index, value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_diffServMacAceSourceIpAddrBitmask(
    int       action,
    u_char    *var_val,
    u_char    var_val_type,
    size_t    var_val_len,
    u_char    *statP,
    oid       *name,
    size_t    name_len)
{
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    if(name_len > oid_name_length+diffServMacAceEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_IPADDRESS)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len !=  SYS_ADPT_IPV4_ADDR_LEN)
            {
                return SNMP_ERR_WRONGLENGTH;
            }

            break;
        }

        case RESERVE2:
        {
            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            UI32_T  index;
            UI32_T value = 0;
            index = name[oid_name_length];
            memcpy(&value, var_val, var_val_len);
            /* convert host order */
            if(L4_PMGR_QoS_SetDiffServMacAceSourceIpAddrBitmask(index, value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_diffServMacAceDestinationIpAddr(
    int       action,
    u_char    *var_val,
    u_char    var_val_type,
    size_t    var_val_len,
    u_char    *statP,
    oid       *name,
    size_t    name_len)
{
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    if(name_len > oid_name_length+diffServMacAceEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_IPADDRESS)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len !=  SYS_ADPT_IPV4_ADDR_LEN)
            {
                return SNMP_ERR_WRONGLENGTH;
            }

            break;
        }

        case RESERVE2:
        {
            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            UI32_T  index;
            UI32_T value = 0;
            index = name[oid_name_length];
            memcpy(&value, var_val, var_val_len);
            /* convert host order */
            if(L4_PMGR_QoS_SetDiffServMacAceDestIpAddr(index, value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_diffServMacAceDestinationIpAddrBitmask(
    int       action,
    u_char    *var_val,
    u_char    var_val_type,
    size_t    var_val_len,
    u_char    *statP,
    oid       *name,
    size_t    name_len)
{
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    if(name_len > oid_name_length+diffServMacAceEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_IPADDRESS)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len !=  SYS_ADPT_IPV4_ADDR_LEN)
            {
                return SNMP_ERR_WRONGLENGTH;
            }

            break;
        }

        case RESERVE2:
        {
            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            UI32_T  index;
            UI32_T value = 0;
            index = name[oid_name_length];
            memcpy(&value, var_val, var_val_len);
            /* convert host order */
            if(L4_PMGR_QoS_SetDiffServMacAceDestIpAddrBitmask(index, value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_diffServMacAceSourceIpv6Addr(
    int action,
    u_char * var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char * statP,
    oid * name, size_t name_len)
{
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    /*check max length of the inputing index */
    if(name_len > oid_name_length+diffServMacAceEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_OCTET_STR)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > MAXSIZE_diffServIpv6AceSourceIpAddr)
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }

        case RESERVE2:
        {
            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            UI32_T  index;
            UI8_T buffer[MAXSIZE_diffServIpv6AceSourceIpAddr] = {0};
            index = name[oid_name_length];
            memcpy(buffer,var_val,var_val_len);
            if(L4_PMGR_QoS_SetDiffServMaceAceSourceIpv6Addr(index, buffer) != TRUE)
                return SNMP_ERR_COMMITFAILED;
            break;
        }

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_diffServMacAceSourceIpv6PrefixLen(
    int action,
    u_char * var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char * statP,
    oid * name, size_t name_len)
{
    long value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    /*check max length of the inputing index */
    if(name_len > oid_name_length+diffServMacAceEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            if ( *(long *)var_val  > MAX_diffServIpv6AceSourceIpAddrPrefixLen)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }

        case RESERVE2:
        {
            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            UI32_T  index;
            index = name[oid_name_length];
            value = *(long *)var_val;
            if(L4_PMGR_QoS_SetDiffServMacAceSourceIpv6AddrPrefix(index, value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
            break;
        }

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_diffServMacAceDestIpv6Addr(
    int action,
    u_char * var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char * statP,
    oid * name, size_t name_len)
{
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    /*check max length of the inputing index */
    if(name_len > oid_name_length+diffServMacAceEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_OCTET_STR)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > MAXSIZE_diffServIpv6AceDestIpAddr)
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }

        case RESERVE2:
        {
            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            UI32_T  index;
            UI8_T buffer[MAXSIZE_diffServIpv6AceDestIpAddr] = {0};
            index = name[oid_name_length];
            memcpy(buffer,var_val,var_val_len);
            if(L4_PMGR_QoS_SetDiffServMacAceDestIpv6Addr(index, buffer) != TRUE)
                return SNMP_ERR_COMMITFAILED;
            break;
        }

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_diffServMacAceDestIpIpv6PrefixLen(
    int action,
    u_char * var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char * statP,
    oid * name, size_t name_len)
{
    long value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    /*check max length of the inputing index */
    if(name_len > oid_name_length+diffServMacAceEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            if ( *(long *)var_val  > SYS_ADPT_ACL_MAX_DST_IPV6_PREFIX_LEN)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }

        case RESERVE2:
        {
            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            UI32_T  index;
            index = name[oid_name_length];
            value = *(long *)var_val;
            if( L4_PMGR_QoS_SetDiffServMacAceDestIpv6AddrPrefix(index, value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
            break;
        }

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }
    return SNMP_ERR_NOERROR;
}



int
write_diffServMacAceIpProtocol(
    int       action,
    u_char    *var_val,
    u_char    var_val_type,
    size_t    var_val_len,
    u_char    *statP,
    oid       *name,
    size_t    name_len)
{
    long value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    if(name_len > oid_name_length+diffServMacAceEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            if (*(long *)var_val < MIN_diffServMacAceProtocol ||
                *(long *)var_val > MAX_diffServMacAceProtocol)
            {
                return SNMP_ERR_WRONGVALUE;
            }

            break;
        }

        case RESERVE2:
        {
            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            UI32_T  index;
            index = name[oid_name_length];
            value = *(long *)var_val;

            if(L4_PMGR_QoS_SetDiffServMacAceProtocol(index, value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_diffServMacAceSourcePortOp(
    int       action,
    u_char    *var_val,
    u_char    var_val_type,
    size_t    var_val_len,
    u_char    *statP,
    oid       *name,
    size_t    name_len)
{
    long value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    if(name_len > oid_name_length+diffServMacAceEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            if (*(long *)var_val < VAL_diffServIpAceSourcePortOp_noOperator ||
                *(long *)var_val > VAL_diffServIpAceSourcePortOp_range)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }

        case RESERVE2:
        {
            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            UI32_T  index;
            index = name[oid_name_length];
            value = *(long *)var_val;

            if(L4_PMGR_QoS_SetDiffServMacAceSourcePortOp(index, value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_diffServMacAceSourcePort(
    int       action,
    u_char    *var_val,
    u_char    var_val_type,
    size_t    var_val_len,
    u_char    *statP,
    oid       *name,
    size_t    name_len)
{
    long value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    if(name_len > oid_name_length+diffServMacAceEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            if (*(long *)var_val < MIN_diffServIpAceMinSourcePort ||
                *(long *)var_val > MAX_diffServIpAceMinSourcePort)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }

        case RESERVE2:
        {
            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            UI32_T  index;
            index = name[oid_name_length];
            value = *(long *)var_val;

            /* min && max should be the same
             */
            if(L4_PMGR_QoS_SetDiffServMacAceSourcePort(index, value) != TRUE)
                return SNMP_ERR_COMMITFAILED;

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_diffServMacAceSourcePortBitMask(
    int       action,
    u_char    *var_val,
    u_char    var_val_type,
    size_t    var_val_len,
    u_char    *statP,
    oid       *name,
    size_t    name_len)
{
    long value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    if(name_len > oid_name_length+diffServMacAceEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            if (*(long *)var_val < MIN_diffServIpAceSourcePortBitmask ||
                *(long *)var_val > MAX_diffServIpAceSourcePortBitmask)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }

        case RESERVE2:
        {
            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            UI32_T  index;
            index = name[oid_name_length];
            value = *(long *)var_val;

            if(L4_PMGR_QoS_SetDiffServMacAceSourcePortBitmask(index, value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_diffServMacAceDestPortOp(
    int       action,
    u_char    *var_val,
    u_char    var_val_type,
    size_t    var_val_len,
    u_char    *statP,
    oid       *name,
    size_t    name_len)
{
    long value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    if(name_len > oid_name_length+diffServMacAceEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            if (*(long *)var_val < VAL_diffServIpAceDestPortOp_noOperator ||
                *(long *)var_val > VAL_diffServIpAceDestPortOp_range)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }

        case RESERVE2:
        {
            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            UI32_T  index;
            index = name[oid_name_length];
            value = *(long *)var_val;

            if(L4_PMGR_QoS_SetDiffServMacAceDestPortOp(index, value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_diffServMacAceDestPort(
    int       action,
    u_char    *var_val,
    u_char    var_val_type,
    size_t    var_val_len,
    u_char    *statP,
    oid       *name,
    size_t    name_len)
{
    long value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    if(name_len > oid_name_length+diffServMacAceEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            if (*(long *)var_val < MIN_diffServIpAceMinDestPort ||
                *(long *)var_val > MAX_diffServIpAceMinDestPort)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }

        case RESERVE2:
        {
            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            UI32_T  index;
            index = name[oid_name_length];
            value = *(long *)var_val;

            if(L4_PMGR_QoS_SetDiffServMacAceDestPort(index, value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_diffServMacAceDestPortBitmask(
    int       action,
    u_char    *var_val,
    u_char    var_val_type,
    size_t    var_val_len,
    u_char    *statP,
    oid       *name,
    size_t    name_len)
{
    long value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    if(name_len > oid_name_length+diffServMacAceEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            if (*(long *)var_val < MIN_diffServIpAceDestPortBitmask ||
                *(long *)var_val > MAX_diffServIpAceDestPortBitmask)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }

        case RESERVE2:
        {
            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            UI32_T  index;
            index = name[oid_name_length];
            value = *(long *)var_val;

            if(L4_PMGR_QoS_SetDiffServMacAceDestPortBitmask(index, value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }
    return SNMP_ERR_NOERROR;
}

#define DIFFSERVACTIONENTRY_INSTANCE_LEN  1

BOOL_T diffServActionTable_OidIndexToData(UI32_T exact, UI32_T compc,
            oid * compl ,  UI32_T  *index)
{

    /* get or write
     */
    if(exact)
    {

        /* check the index length
         */

        if(compc != DIFFSERVACTIONENTRY_INSTANCE_LEN) /* the constant size index*/
        {
            return FALSE;
        }
    }
    *index=compl[0];
    return TRUE;
}

/*
 * var_diffServActionTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *
var_diffServActionTable(struct variable *vp,
            oid     *name,
            size_t  *length,
            int     exact,
            size_t  *var_len,
            WriteMethod **write_method)
{
    /* variables we may use later */
    UI32_T compc=0;
    oid compl[DIFFSERVACTIONENTRY_INSTANCE_LEN];
    oid best_inst[DIFFSERVACTIONENTRY_INSTANCE_LEN];
    RULE_TYPE_MIB_Action_T  entry;
    UI32_T index=0;

    switch(vp->magic)
    {
    case LEAF_diffServActionList:
        *write_method = write_diffServActionList;
        break;
    case LEAF_diffServActionPktNewPri:
        *write_method = write_diffServActionPktNewPri;
        break;
    case LEAF_diffServActionPktNewPhb:
        *write_method = write_diffServActionPktPhb;
        break;
    case LEAF_diffServActionGreenPktTransmit:
        *write_method = write_diffServActionGreenPktTransmit;
        break;
    case LEAF_diffServActionGreenPktNewDscp:
        *write_method = write_diffServActionGreenPktNewDscp;
        break;
    case LEAF_diffServActionYellowPktNewDscp:
        *write_method = write_diffServActionYellowPktNewDscp;
        break;
    case LEAF_diffServActionYellowPktDrop:
        *write_method = write_diffServActionYellowPktDrop;
        break;
    case LEAF_diffServActionRedPktNewDscp:
        *write_method = write_diffServActionRedPktNewDscp;
        break;
    case LEAF_diffServActionRedPktDrop:
        *write_method = write_diffServActionRedPktDrop;
        break;
    case LEAF_diffServActionStatus:
        *write_method = write_diffServActionStatus;
        break;
    case LEAF_diffServActionPktNewIpPrec:
        *write_method = write_diffServActionPktNewIpPrec;
        break;
    case LEAF_diffServActionPktNewDscp:
        *write_method = write_diffServActionPktNewDscp;
        break;
    default:
        *write_method = 0;
    }

    /*check compc, retrive compl*/
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,compl, DIFFSERVACTIONENTRY_INSTANCE_LEN);

    memset(&entry, 0, sizeof(entry));

    if (exact)/*get,set*/
    {
        if(compc != DIFFSERVACTIONENTRY_INSTANCE_LEN) /* the constant size index*/
        {
            return FALSE;
        }
        index=compl[0];

        if (L4_PMGR_QoS_GetDiffServActionEntry(index,  &entry)!=TRUE)
        {
            return NULL;
        }
    }
    else/*getnext*/
    {
        if (compc< DIFFSERVACTIONENTRY_INSTANCE_LEN)
        {
            index=0;
            if ( L4_PMGR_QoS_GetDiffServActionEntry(index,  &entry)!=TRUE)
            {

                /*get next data*/
                if ( L4_PMGR_QoS_GetNextDiffServActionEntry(&index,  &entry)!=TRUE)
                {
                    return NULL;
                }
            }
        }
        else
        {
            index=compl[0];
            /*get next data*/
            if ( L4_PMGR_QoS_GetNextDiffServActionEntry(&index,  &entry)!=TRUE)
            {
                return NULL;
            }
        }
    }

    memcpy(name, vp->name, ( vp->namelen)*sizeof(oid));
    /* assign data to the oid index
     */

    best_inst[0]=index;

    memcpy(name+vp->namelen,best_inst,DIFFSERVACTIONENTRY_INSTANCE_LEN*sizeof(oid));
    *length = vp->namelen+DIFFSERVACTIONENTRY_INSTANCE_LEN;

    *var_len = sizeof(long_return);

    /* this is where we do the value assignments for the mib results.
     */
    switch(vp->magic) {

#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    case LEAF_diffServActionIndex:
        long_return = index;
        return (u_char *) &long_return;
#endif
    case LEAF_diffServActionList:
        memcpy(return_buf, entry.action_bitmap,SIZE_diffServActionList);
        *var_len = SIZE_diffServActionList;
        return (u_char*)return_buf;
    case LEAF_diffServActionPktNewPri:
        long_return =(UI32_T) entry.pkt_new_pri;
        return (u_char *) &long_return;
    case LEAF_diffServActionPktNewPhb:
        long_return =(UI32_T)  entry.pkt_phb;
        return (u_char *) &long_return;
    case LEAF_diffServActionGreenPktTransmit:
        long_return =(UI32_T) entry.green_pkt_transmit;
        return (u_char *) &long_return;
    case LEAF_diffServActionGreenPktNewDscp:
        long_return =(UI32_T)  entry.green_pkt_new_dscp;
        return (u_char *) &long_return;
    case LEAF_diffServActionYellowPktNewDscp:
        long_return = (UI32_T) entry.yellow_pkt_new_dscp;
        return (u_char *) &long_return;
    case LEAF_diffServActionYellowPktDrop:
        long_return =(UI32_T)  entry.yellow_drop;
        return (u_char *) &long_return;
    case LEAF_diffServActionRedPktNewDscp:
        long_return =(UI32_T)  entry.red_pkt_new_dscp;
        return (u_char *) &long_return;
    case LEAF_diffServActionRedPktDrop:
        long_return =(UI32_T)  entry.red_drop;
        return (u_char *) &long_return;
    case LEAF_diffServActionStatus:
        long_return =(UI32_T)  entry.row_status;
        return (u_char *) &long_return;
    case LEAF_diffServActionPktNewIpPrec:
        long_return = (UI32_T)entry.pkt_new_ip_prec;
        return (u_char*)&long_return;
    case LEAF_diffServActionPktNewDscp:
        long_return =(UI32_T)entry.pkt_new_dscp;
        return (u_char*)&long_return;
    default:
      ERROR_MSG("");
    }
    return NULL;
}

int
write_diffServActionList(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    switch ( action ) {

        case RESERVE1:

          if (var_val_type != ASN_OCTET_STR)
          {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len != SIZE_diffServActionList)
          {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
          break;

        case ACTION:
        {
            UI32_T index;
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
            UI8_T byte_buffer[SIZE_diffServActionList]={0};
            if(diffServActionTable_OidIndexToData(TRUE,name_len-oid_name_length,&(name[oid_name_length]),&index)==FALSE)
                return SNMP_ERR_COMMITFAILED;
            memcpy(byte_buffer,var_val,var_val_len);
            if(L4_PMGR_QoS_SetDiffServActionBitmap(index,byte_buffer) != TRUE )
                return SNMP_ERR_COMMITFAILED;
        }
            break;

        case UNDO:
          break;

        case COMMIT:
          break;
    }
    return SNMP_ERR_NOERROR;
}

int write_diffServActionPktNewPri(int       action,
                                         u_char    *var_val,
                                         u_char    var_val_type,
                                         size_t    var_val_len,
                                         u_char    *statP,
                                         oid       *name,
                                         size_t    name_len)
{
    long value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    /*check max length of the inputing index */
    if(name_len > oid_name_length+DIFFSERVACTIONENTRY_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            if (*(long *) var_val < MIN_diffServActionPktNewPri || *(long *) var_val > MAX_diffServActionPktNewPri)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }

        case RESERVE2:
        {
            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            UI32_T  index;
            index = name[oid_name_length];
            value = *(long *)var_val;
            if(L4_PMGR_QoS_SetDiffServActionPktNewPri(index, value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
            break;
        }

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }
    return SNMP_ERR_NOERROR;
}

int write_diffServActionPktPhb(int       action,
                                         u_char    *var_val,
                                         u_char    var_val_type,
                                         size_t    var_val_len,
                                         u_char    *statP,
                                         oid       *name,
                                         size_t    name_len)
{
    long value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    /*check max length of the inputing index */
    if(name_len > oid_name_length+DIFFSERVACTIONENTRY_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            if (*(long *) var_val < MIN_diffServActionPktNewPhb || *(long *) var_val > MAX_diffServActionPktNewPhb)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }

        case RESERVE2:
        {
            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            UI32_T  index;
            index = name[oid_name_length];
            value = *(long *)var_val;
            if(L4_PMGR_QoS_SetDiffServActionPktNewPhb(index, value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
            break;
        }

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }
    return SNMP_ERR_NOERROR;
}

int write_diffServActionPktNewIpPrec(int       action,
                                     u_char    *var_val,
                                     u_char    var_val_type,
                                     size_t    var_val_len,
                                     u_char    *statP,
                                     oid       *name,
                                     size_t    name_len)
{
    long value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    /*check max length of the inputing index */
    if(name_len > oid_name_length+DIFFSERVACTIONENTRY_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            if (*(long *) var_val < MIN_diffServActionPktNewIpPrec || *(long *) var_val > MAX_diffServActionPktNewIpPrec)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }

        case RESERVE2:
        {
            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            UI32_T  index;
            index = name[oid_name_length];
            value = *(long *)var_val;
            if(L4_PMGR_QoS_SetDiffServActionPktNewIpPrec(index, value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
            break;
        }

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }
    return SNMP_ERR_NOERROR;
}

int write_diffServActionPktNewDscp(int       action,
                                   u_char    *var_val,
                                   u_char    var_val_type,
                                   size_t    var_val_len,
                                   u_char    *statP,
                                   oid       *name,
                                   size_t    name_len)
{
    long value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    /*check max length of the inputing index */
    if(name_len > oid_name_length+DIFFSERVACTIONENTRY_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            if (*(long *) var_val < MIN_diffServActionPktNewDscp|| *(long *) var_val > MAX_diffServActionPktNewDscp)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }

        case RESERVE2:
        {
            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            UI32_T  index;
            index = name[oid_name_length];
            value = *(long *)var_val;
            if(L4_PMGR_QoS_SetDiffServActionPktNewDscp(index, value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
            break;
        }

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }
    return SNMP_ERR_NOERROR;
}

int write_diffServActionGreenPktNewDscp(int       action,
                                        u_char    *var_val,
                                        u_char    var_val_type,
                                        size_t    var_val_len,
                                        u_char    *statP,
                                        oid       *name,
                                        size_t    name_len)
{
    long value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    /*check max length of the inputing index */
    if(name_len > oid_name_length+DIFFSERVACTIONENTRY_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            if (*(long *) var_val < MIN_diffServActionGreenPktNewDscp|| *(long *) var_val > MAX_diffServActionGreenPktNewDscp)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }

        case RESERVE2:
        {
            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            UI32_T  index;
            index = name[oid_name_length];
            value = *(long *)var_val;
            if(L4_PMGR_QoS_SetDiffServActionGreenPktNewDscp(index, value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
            break;
        }

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }
    return SNMP_ERR_NOERROR;
}

int write_diffServActionGreenPktTransmit(int       action,
                                         u_char    *var_val,
                                         u_char    var_val_type,
                                         size_t    var_val_len,
                                         u_char    *statP,
                                         oid       *name,
                                         size_t    name_len)
{
    long value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    /*check max length of the inputing index */
    if(name_len > oid_name_length+DIFFSERVACTIONENTRY_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            if (!((*(long *) var_val == VAL_diffServActionGreenPktTransmit_enabled)|| (*(long *) var_val == VAL_diffServActionGreenPktTransmit_disabled)))
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }

        case RESERVE2:
        {
            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            UI32_T  index;
            index = name[oid_name_length];
            value = *(long *)var_val;
            if(L4_PMGR_QoS_SetDiffServActionGreenPktTransmit(index, value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
            break;
        }

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }
    return SNMP_ERR_NOERROR;
}

int write_diffServActionYellowPktNewDscp(int       action,
                                         u_char    *var_val,
                                         u_char    var_val_type,
                                         size_t    var_val_len,
                                         u_char    *statP,
                                         oid       *name,
                                         size_t    name_len)
{
    long value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    /*check max length of the inputing index */
    if(name_len > oid_name_length+DIFFSERVACTIONENTRY_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            if (*(long *) var_val < MIN_diffServActionYellowPktNewDscp || *(long *) var_val > MAX_diffServActionYellowPktNewDscp)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }

        case RESERVE2:
        {
            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            UI32_T  index;
            index = name[oid_name_length];
            value = *(long *)var_val;
            if(L4_PMGR_QoS_SetDiffServActionYellowPktNewDscp(index, value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
            break;
        }

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }
    return SNMP_ERR_NOERROR;
}

int write_diffServActionYellowPktDrop(int       action,
                                         u_char    *var_val,
                                         u_char    var_val_type,
                                         size_t    var_val_len,
                                         u_char    *statP,
                                         oid       *name,
                                         size_t    name_len)
{
    long value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    /*check max length of the inputing index */
    if(name_len > oid_name_length+DIFFSERVACTIONENTRY_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            if (!((*(long *) var_val == VAL_diffServActionYellowPktDrop_enabled) || (*(long *) var_val == VAL_diffServActionYellowPktDrop_disabled)))
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }

        case RESERVE2:
        {
            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            UI32_T  index;
            index = name[oid_name_length];
            value = *(long *)var_val;
            if(L4_PMGR_QoS_SetDiffServActionYellowPktDrop(index, value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
            break;
        }

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }
    return SNMP_ERR_NOERROR;
}

int write_diffServActionRedPktNewDscp(int       action,
                                         u_char    *var_val,
                                         u_char    var_val_type,
                                         size_t    var_val_len,
                                         u_char    *statP,
                                         oid       *name,
                                         size_t    name_len)
{
    long value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    /*check max length of the inputing index */
    if(name_len > oid_name_length+DIFFSERVACTIONENTRY_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            if (*(long *) var_val < MIN_diffServActionRedPktNewDscp || *(long *) var_val > MAX_diffServActionRedPktNewDscp)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }

        case RESERVE2:
        {
            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            UI32_T  index;
            index = name[oid_name_length];
            value = *(long *)var_val;
            if(L4_PMGR_QoS_SetDiffServActionRedPktNewDscp(index, value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
            break;
        }

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }
    return SNMP_ERR_NOERROR;
}

int write_diffServActionRedPktDrop(int       action,
                                         u_char    *var_val,
                                         u_char    var_val_type,
                                         size_t    var_val_len,
                                         u_char    *statP,
                                         oid       *name,
                                         size_t    name_len)
{
    long value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    /*check max length of the inputing index */
    if(name_len > oid_name_length+DIFFSERVACTIONENTRY_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            if (!((*(long *) var_val == VAL_diffServActionRedPktDrop_enabled) || (*(long *) var_val == VAL_diffServActionRedPktDrop_disabled)))
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }

        case RESERVE2:
        {
            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            UI32_T  index;
            index = name[oid_name_length];
            value = *(long *)var_val;
            if(L4_PMGR_QoS_SetDiffServActionRedPktDrop(index, value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
            break;
        }

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }
    return SNMP_ERR_NOERROR;
}

int write_diffServActionStatus(int       action,
                                         u_char    *var_val,
                                         u_char    var_val_type,
                                         size_t    var_val_len,
                                         u_char    *statP,
                                         oid       *name,
                                         size_t    name_len)
{
    long value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    /*check max length of the inputing index */
    if(name_len > oid_name_length+DIFFSERVACTIONENTRY_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            if (*(long *)var_val < VAL_diffServActionStatus_active|| *(long *)var_val > VAL_diffServActionStatus_destroy)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            if (*(long *)var_val == VAL_diffServActionStatus_notReady)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }

        case RESERVE2:
        {
            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            UI32_T  index;
            index = name[oid_name_length];
            value = *(long *)var_val;
            if(L4_PMGR_QoS_SetDiffServActionStatus(index, value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
            break;
        }

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }
    return SNMP_ERR_NOERROR;
}

#define diffServMeterEntry_INSTANCE_LEN 1
/*
 * var_diffServMeterTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */

static BOOL_T diffServMeterTable_get(int      compc,
                                oid     *compl,
                                UI32_T *index,
                                RULE_TYPE_TBParamEntry_T   *data)
{
    if (compc !=diffServMeterEntry_INSTANCE_LEN)
    {
        return FALSE;
    }
    *index = compl[0];
    memset(data, 0, sizeof(RULE_TYPE_TBParamEntry_T));

    /*get data
     */
    if (L4_PMGR_QoS_GetDiffServMeterEntry(*index,data)!=TRUE)
    {
        return FALSE;
    }
    else
    {
        return TRUE;
    } /*End of if */
}

static BOOL_T diffServMeterTable_next(int      compc,
                                 oid     *compl,
                                 UI32_T *index,
                                 RULE_TYPE_TBParamEntry_T    *data)
{
    *index = compl[0];
    memset(data, 0, sizeof(RULE_TYPE_TBParamEntry_T));
    /*check  the length of inputing index,if <1 we should try get {0.0.0.0.0...} */
    if (compc<1)
    {
        /*get data*/
        if (L4_PMGR_QoS_GetDiffServMeterEntry(*index,data)!=TRUE)
        {
            /*get data*/
            if (L4_PMGR_QoS_GetNextDiffServMeterEntry(index,data)!=TRUE)
            {
                return FALSE;
            }
        }
    }
    else
    {
        /*get data*/
        if (L4_PMGR_QoS_GetNextDiffServMeterEntry(index,data)!=TRUE)
        {
            return FALSE;
        }
    }
    return TRUE;
}

unsigned char  *
var_diffServMeterTable(struct variable *vp,
                     oid * name,
                     size_t * length,
                     int exact,
                     size_t * var_len, WriteMethod ** write_method)
{
    UI32_T compc=0;
    UI32_T index=0;
    oid compl[diffServMeterEntry_INSTANCE_LEN];
    oid best_inst[diffServMeterEntry_INSTANCE_LEN];
    RULE_TYPE_TBParamEntry_T  entry;


    switch (vp->magic) {
      case DIFFSERVMETERMODEL:
        *write_method = write_diffServMeterModel;
        break;
      case DIFFSERVMETERRATE:
        *write_method = write_diffServMeterRate;
        break;
      case DIFFSERVMETERBURSTSIZE:
        *write_method = write_diffServMeterBurstSize;
        break;
      case DIFFSERVMETERPEAKRATE:
        *write_method = write_diffServMeterPeakRate;
        break;
      case DIFFSERVMETERPEAKBURSTSIZE:
        *write_method = write_diffServMeterPeakBurstSize;
        break;
      case DIFFSERVMETERSTATUS:
        *write_method = write_diffServMeterStatus;
        break;
    default:
        *write_method = 0;
        }

   SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,compl, diffServMeterEntry_INSTANCE_LEN);

    if (exact)/*get,set*/
    {
        if (!diffServMeterTable_get(compc, compl, &index, &entry))
            return NULL;
    }
    else/*getnext*/
    {
        if (!diffServMeterTable_next(compc, compl, &index, &entry))
        {
            return NULL;
        }
    }

    memcpy(name, vp->name, vp->namelen*sizeof(oid));
    best_inst[0] = index;
    memcpy(name + vp->namelen, best_inst, diffServMeterEntry_INSTANCE_LEN*sizeof(oid));
    *length = vp->namelen + diffServMeterEntry_INSTANCE_LEN;

    *var_len = sizeof(long_return);

    switch (vp->magic) {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
      case DIFFSERVMETERINDEX:
        long_return = index;
        return (u_char *) &long_return;
#endif
      case DIFFSERVMETERMODEL:
        long_return = entry.meter_model;
        return (u_char *) &long_return;
      case DIFFSERVMETERRATE:
        long_return = entry.rate;
        return (u_char *) &long_return;
      case DIFFSERVMETERBURSTSIZE:
        long_return = entry.burst_size;
        return (u_char *) &long_return;
      case DIFFSERVMETERPEAKRATE:
        long_return = entry.peak_rate;
        return (u_char *) &long_return;
      case DIFFSERVMETERPEAKBURSTSIZE:
        long_return = entry.peak_burst_size;
        return (u_char *) &long_return;
      case DIFFSERVMETERSTATUS:
        long_return = entry.row_status;
        return (u_char *) &long_return;
    default:
        ERROR_MSG("");
    }
    return NULL;
}

int write_diffServMeterModel(int       action,
                                         u_char    *var_val,
                                         u_char    var_val_type,
                                         size_t    var_val_len,
                                         u_char    *statP,
                                         oid       *name,
                                         size_t    name_len)
{
    long value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    /*check max length of the inputing index */
    if(name_len > oid_name_length+diffServMeterEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            if (*(long *)var_val < VAL_diffServMeterModel_default|| *(long *)var_val > VAL_diffServMeterModel_srTcmColorAware)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            else if (VAL_diffServMeterModel_default == *(long *)var_val )
            {
                return SNMP_ERR_INCONSISTENTVALUE;
            }
            else if (*(long *)var_val > VAL_diffServMeterModel_trTcmColorAware&& *(long *)var_val < VAL_diffServMeterModel_srTcmColorBlind)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }

        case RESERVE2:
        {
            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            UI32_T  index;
            index = name[oid_name_length];
            value = *(long *)var_val;
            if(L4_PMGR_QoS_SetDiffServMeterModel(index, value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
            break;
        }

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }
    return SNMP_ERR_NOERROR;
}


int write_diffServMeterRate(int       action,
                                         u_char    *var_val,
                                         u_char    var_val_type,
                                         size_t    var_val_len,
                                         u_char    *statP,
                                         oid       *name,
                                         size_t    name_len)
{
    long value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    /*check max length of the inputing index */
    if(name_len > oid_name_length+diffServMeterEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            if (*(long *) var_val < SYS_ADPT_DIFFSERV_MIN_POLICE_RATE|| *(long *) var_val > SYS_ADPT_DIFFSERV_MAX_POLICE_RATE)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }

        case RESERVE2:
        {
            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            UI32_T  index;
            index = name[oid_name_length];
            value = *(long *)var_val;
            if(L4_PMGR_QoS_SetDiffServMeterRate(index, value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
            break;
        }

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }
    return SNMP_ERR_NOERROR;
}
int write_diffServMeterBurstSize(int       action,
                                         u_char    *var_val,
                                         u_char    var_val_type,
                                         size_t    var_val_len,
                                         u_char    *statP,
                                         oid       *name,
                                         size_t    name_len)
{
    long value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    /*check max length of the inputing index */
    if(name_len > oid_name_length+diffServMeterEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            if (*(long *) var_val < SYS_ADPT_DIFFSERV_MIN_POLICE_BURST || *(long *) var_val > SYS_ADPT_DIFFSERV_MAX_POLICE_BURST)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }

        case RESERVE2:
        {
            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            UI32_T  index;
            index = name[oid_name_length];
            value = *(long *)var_val;
            if(L4_PMGR_QoS_SetDiffServMeterBurstSize(index,value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
            break;
        }

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }
    return SNMP_ERR_NOERROR;
}
int write_diffServMeterPeakRate(int       action,
                                         u_char    *var_val,
                                         u_char    var_val_type,
                                         size_t    var_val_len,
                                         u_char    *statP,
                                         oid       *name,
                                         size_t    name_len)
{
    long value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    /*check max length of the inputing index */
    if(name_len > oid_name_length+diffServMeterEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            if (*(long *) var_val < SYS_ADPT_DIFFSERV_MIN_POLICE_RATE|| *(long *) var_val > SYS_ADPT_DIFFSERV_MAX_POLICE_RATE)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }

        case RESERVE2:
        {
            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            UI32_T  index;
            index = name[oid_name_length];
            value = *(long *)var_val;
            if(L4_PMGR_QoS_SetDiffServMeterPeakRate(index, value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
            break;
        }

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }
    return SNMP_ERR_NOERROR;
}

int write_diffServMeterPeakBurstSize(int       action,
                                         u_char    *var_val,
                                         u_char    var_val_type,
                                         size_t    var_val_len,
                                         u_char    *statP,
                                         oid       *name,
                                         size_t    name_len)
{
    long value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    /*check max length of the inputing index */
    if(name_len > oid_name_length+diffServMeterEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            if (*(long *) var_val < SYS_ADPT_DIFFSERV_MIN_POLICE_BURST || *(long *) var_val > SYS_ADPT_DIFFSERV_MAX_POLICE_BURST)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }

        case RESERVE2:
        {
            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            UI32_T  index;
            index = name[oid_name_length];
            value = *(long *)var_val;
            if(L4_PMGR_QoS_SetDiffServMeterPeakBurstSize(index,value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
            break;
        }

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }
    return SNMP_ERR_NOERROR;
}

int write_diffServMeterStatus(int       action,
                                         u_char    *var_val,
                                         u_char    var_val_type,
                                         size_t    var_val_len,
                                         u_char    *statP,
                                         oid       *name,
                                         size_t    name_len)
{
    long value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    /*check max length of the inputing index */
    if(name_len > oid_name_length+diffServMeterEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            if (*(long *)var_val < VAL_diffServMeterStatus_active|| *(long *)var_val > VAL_diffServMeterStatus_destroy)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            if (*(long *)var_val == VAL_diffServMeterStatus_notReady)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }

        case RESERVE2:
        {
            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            UI32_T  index;
            index = name[oid_name_length];
            value = *(long *)var_val;
            if(L4_PMGR_QoS_SetDiffServMeterStatus(index, value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
            break;
        }

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }
    return SNMP_ERR_NOERROR;
}

#if (SYS_CPNT_DAI == TRUE)
#define DIFFSERVARPACEENTRY_INSTANCE_LEN 1

BOOL_T diffServArpAceTable_OidIndexToData(UI32_T exact, UI32_T compc,
    oid *compl, UI32_T *ace_index_p)
{
    if (exact)
    {
        if (compc != DIFFSERVARPACEENTRY_INSTANCE_LEN) /* the constant size index */
        {
            return FALSE;
        }
    }

    *ace_index_p = compl[0];

    return TRUE;
}

/* var_diffServArpAceTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *var_diffServArpAceTable(struct variable *vp,
    oid *name,
    size_t *length,
    int exact,
    size_t *var_len,
    WriteMethod **write_method)
{
    UI32_T compc = 0;
    UI32_T ace_index;
    oid compl[DIFFSERVARPACEENTRY_INSTANCE_LEN] = {0};
    oid best_inst[DIFFSERVARPACEENTRY_INSTANCE_LEN] = {0};
    RULE_TYPE_UI_Ace_Entry_T ace;

    switch (vp->magic)
    {
        case LEAF_diffServArpAceAction:
            *write_method = write_diffServArpAceAction;
            break;

        case LEAF_diffServArpAcePktType:
            *write_method = write_diffServArpAcePktType;
            break;

        case LEAF_diffServArpAceSourceIpAddr:
            *write_method = write_diffServArpAceSourceIpAddr;
            break;

        case LEAF_diffServArpAceSourceIpAddrBitmask:
            *write_method = write_diffServArpAceSourceIpAddrBitmask;
            break;

        case LEAF_diffServArpAceDestIpAddr:
            *write_method = write_diffServArpAceDestIpAddr;
            break;

        case LEAF_diffServArpAceDestIpAddrBitmask:
            *write_method = write_diffServArpAceDestIpAddrBitmask;
            break;

        case LEAF_diffServArpAceSourceMacAddr:
            *write_method = write_diffServArpAceSourceMacAddr;
            break;

        case LEAF_diffServArpAceSourceMacAddrBitmask:
            *write_method = write_diffServArpAceSourceMacAddrBitmask;
            break;

        case LEAF_diffServArpAceDestMacAddr:
            *write_method = write_diffServArpAceDestMacAddr;
            break;

        case LEAF_diffServArpAceDestMacAddrBitmask:
            *write_method = write_diffServArpAceDestMacAddrBitmask;
            break;

        case LEAF_diffServArpAceLogStatus:
            *write_method = write_diffServArpAceLogStatus;
            break;

        case LEAF_diffServArpAceStatus:
            *write_method = write_diffServArpAceStatus;
            break;

        default:
            *write_method = 0;
            break;
    }

    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl,
                           DIFFSERVARPACEENTRY_INSTANCE_LEN);

    memset(&ace, 0, sizeof(ace));

    if (exact)
    {
        if (diffServArpAceTable_OidIndexToData(exact, compc, compl, &ace_index) == FALSE)
        {
            return NULL;
        }

        if (L4_PMGR_QoS_GetDiffServARPAceEntry(ace_index, &ace) != RULE_TYPE_OK)
        {
            return NULL;
        }
    }
    else /* getnext */
    {
        diffServArpAceTable_OidIndexToData(exact, compc, compl, &ace_index);

        /* check the length of inputing index,if < 1 we should try get
         * {0.0.0.0.0...}
         */
        if (compc < 1)
        {
            if (L4_PMGR_QoS_GetDiffServARPAceEntry(ace_index, &ace) != RULE_TYPE_OK)
            {
                if (L4_PMGR_QoS_GetNextDiffServArpAceEntry(&ace_index, &ace) != RULE_TYPE_OK)
                {
                    return NULL;
                }
            }
        }
        else
        {
            if (L4_PMGR_QoS_GetNextDiffServArpAceEntry(&ace_index, &ace) != RULE_TYPE_OK)
            {
                return NULL;
            }
        }
    }

    memcpy(name, vp->name, vp->namelen * sizeof(oid));

    /* assign data to the oid index
     */
    best_inst[0] = ace_index;

    memcpy(name + vp->namelen, best_inst, DIFFSERVARPACEENTRY_INSTANCE_LEN * sizeof(oid));
    *length = vp->namelen + DIFFSERVARPACEENTRY_INSTANCE_LEN;

    switch (vp->magic)
    {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case LEAF_diffServArpAceIndex:
            *var_len = sizeof(long_return);
            long_return = ace_index;
            return (u_char *) &long_return;
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

        case LEAF_diffServArpAceAction:
            *var_len = sizeof(long_return);
            long_return = ace.access;
            return (u_char *) &long_return;

        case LEAF_diffServArpAcePktType:
            *var_len = sizeof(long_return);
            switch (ace.arp.arp_type)
            {
                case RULE_TYPE_ARP_REQUEST:
                    long_return = VAL_diffServArpAcePktType_request;
                    break;

                case RULE_TYPE_ARP_REPLY:
                    long_return = VAL_diffServArpAcePktType_response;
                    break;

                case RULE_TYPE_ARP_BOTH:
                    long_return = VAL_diffServArpAcePktType_both;
                    break;

                default:
                    return NULL;
            }
            return (u_char *) &long_return;

        case LEAF_diffServArpAceSourceIpAddr:
            *var_len = sizeof(ipaddr_return);
            {
                UI32_T *ip_addr = (UI32_T *) &ace.arp.sender.ip.addr;
                ipaddr_return = *ip_addr;
            }
            return (u_char *) &ipaddr_return;

        case LEAF_diffServArpAceSourceIpAddrBitmask:
            *var_len = sizeof(ipaddr_return);
            {
                UI32_T *ip_mask = (UI32_T *) &ace.arp.sender.ip.mask;
                ipaddr_return = *ip_mask;
            }
            return (u_char *) &ipaddr_return;

        case LEAF_diffServArpAceDestIpAddr:
            *var_len = sizeof(ipaddr_return);
            {
                UI32_T *ip_addr = (UI32_T *) &ace.arp.target.ip.addr;
                ipaddr_return = *ip_addr;
            }
            return (u_char *) &ipaddr_return;

        case LEAF_diffServArpAceDestIpAddrBitmask:
            *var_len = sizeof(ipaddr_return);
            {
                UI32_T *ip_mask = (UI32_T *) &ace.arp.target.ip.mask;
                ipaddr_return = *ip_mask;
            }
            return (u_char *) &ipaddr_return;

        case LEAF_diffServArpAceSourceMacAddr:
            *var_len = SIZE_diffServArpAceSourceMacAddr;
            memcpy(return_buf, ace.arp.sender.mac.addr, *var_len);
            return (u_char *) return_buf;

        case LEAF_diffServArpAceSourceMacAddrBitmask:
            *var_len = SIZE_diffServArpAceSourceMacAddrBitmask;
            memcpy(return_buf, ace.arp.sender.mac.mask, *var_len);
            return (u_char *) return_buf;

        case LEAF_diffServArpAceDestMacAddr:
            *var_len = SIZE_diffServArpAceDestMacAddr;
            memcpy(return_buf, ace.arp.target.mac.addr, *var_len);
            return (u_char *) return_buf;

        case LEAF_diffServArpAceDestMacAddrBitmask:
            *var_len = SIZE_diffServArpAceDestMacAddrBitmask;
            memcpy(return_buf, ace.arp.target.mac.mask, *var_len);
            return (u_char *) return_buf;

        case LEAF_diffServArpAceLogStatus:
            *var_len = sizeof(long_return);
            long_return = (ace.arp.is_log == TRUE) ?
                              VAL_diffServArpAceLogStatus_enabled :
                              VAL_diffServArpAceLogStatus_disabled;
            return (u_char *) &long_return;

        case LEAF_diffServArpAceStatus:
            *var_len = sizeof(long_return);
            long_return = ace.row_status;
            return (u_char *) &long_return;

        default:
            ERROR_MSG("");
    }

    return NULL;
}

int write_diffServArpAceAction(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            switch (*(long *)var_val)
            {
                case VAL_diffServArpAceAction_permit:
                    break;

                case VAL_diffServArpAceAction_deny:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
            I32_T value = 0;
            UI32_T index = 0;

            if (diffServArpAceTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &index) == FALSE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            value = *(long *)var_val;

            if (L4_PMGR_QoS_SetDiffServArpAceAction(index, value) != TRUE)
            {
                return SNMP_ERR_COMMITFAILED;
            }
        }
            break;

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

int write_diffServArpAcePktType(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            switch (*(long *)var_val)
            {
                case VAL_diffServArpAcePktType_request:
                    break;

                case VAL_diffServArpAcePktType_response:
                    break;

                case VAL_diffServArpAcePktType_both:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
            I32_T value = 0;
            UI32_T index = 0;

            if (diffServArpAceTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &index) == FALSE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            value = *(long *)var_val;

            switch (value)
            {
                case VAL_diffServArpAcePktType_request:
                    value = RULE_TYPE_ARP_REQUEST;
                    break;

                case VAL_diffServArpAcePktType_response:
                    value = RULE_TYPE_ARP_REPLY;
                    break;

                case VAL_diffServArpAcePktType_both:
                    value = RULE_TYPE_ARP_BOTH;
                    break;
            }

            if (L4_PMGR_QoS_SetDiffServArpAcePktType(index, value) != TRUE)
            {
                return SNMP_ERR_COMMITFAILED;
            }
        }
            break;

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

int write_diffServArpAceSourceIpAddr(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_IPADDRESS)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len !=  SYS_ADPT_IPV4_ADDR_LEN)
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;

        case RESERVE2:
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
            UI32_T value = 0;
            UI32_T index = 0;

            if (diffServArpAceTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &index) == FALSE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            memcpy(&value, var_val, var_val_len);

            if (L4_PMGR_QoS_SetDiffServArpAceSrcIpAddr(index, value) != TRUE)
            {
                return SNMP_ERR_COMMITFAILED;
            }
        }
            break;

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

int write_diffServArpAceSourceIpAddrBitmask(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_IPADDRESS)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len !=  SYS_ADPT_IPV4_ADDR_LEN)
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;

        case RESERVE2:
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
            UI32_T value = 0;
            UI32_T index = 0;

            if (diffServArpAceTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &index) == FALSE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            memcpy(&value, var_val, var_val_len);

            if (L4_PMGR_QoS_SetDiffServArpAceSrcIpAddrMask(index, value) != TRUE)
            {
                return SNMP_ERR_COMMITFAILED;
            }
        }
            break;

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

int write_diffServArpAceDestIpAddr(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_IPADDRESS)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len !=  SYS_ADPT_IPV4_ADDR_LEN)
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;

        case RESERVE2:
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
            UI32_T value = 0;
            UI32_T index = 0;

            if (diffServArpAceTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &index) == FALSE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            memcpy(&value, var_val, var_val_len);

            if (L4_PMGR_QoS_SetDiffServArpAceDstIpAddr(index, value) != TRUE)
            {
                return SNMP_ERR_COMMITFAILED;
            }
        }
            break;

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

int write_diffServArpAceDestIpAddrBitmask(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_IPADDRESS)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len !=  SYS_ADPT_IPV4_ADDR_LEN)
            {
                return SNMP_ERR_WRONGLENGTH;
            }

            break;

        case RESERVE2:
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
            UI32_T value = 0;
            UI32_T index = 0;

            if (diffServArpAceTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &index) == FALSE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            memcpy(&value, var_val, var_val_len);

            if (L4_PMGR_QoS_SetDiffServArpAceDstIpAddrMask(index, value) != TRUE)
            {
                return SNMP_ERR_COMMITFAILED;
            }
        }
            break;

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

int write_diffServArpAceSourceMacAddr(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_OCTET_STR)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len != SIZE_diffServArpAceSourceMacAddr)
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;

        case RESERVE2:
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
            UI8_T byte_buffer[SIZE_diffServArpAceSourceMacAddr] = {0};
            UI32_T index = 0;

            if (diffServArpAceTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &index) == FALSE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            memcpy(byte_buffer, var_val, var_val_len);

            if (L4_PMGR_QoS_SetDiffServArpAceSrcMacAddr(index, byte_buffer) != TRUE)
            {
                return SNMP_ERR_COMMITFAILED;
            }
        }
            break;

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

int write_diffServArpAceSourceMacAddrBitmask(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_OCTET_STR)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len != SIZE_diffServArpAceSourceMacAddrBitmask)
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;

        case RESERVE2:
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
            UI8_T byte_buffer[SIZE_diffServArpAceSourceMacAddrBitmask] = {0};
            UI32_T index = 0;

            if (diffServArpAceTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &index) == FALSE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            memcpy(byte_buffer, var_val, var_val_len);

            if (L4_PMGR_QoS_SetDiffServArpAceSrcMacAddrMask(index, byte_buffer) != TRUE)
            {
                return SNMP_ERR_COMMITFAILED;
            }
        }
            break;

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

int write_diffServArpAceDestMacAddr(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_OCTET_STR)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len != SIZE_diffServArpAceDestMacAddr)
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;

        case RESERVE2:
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
            UI8_T byte_buffer[SIZE_diffServArpAceDestMacAddr] = {0};
            UI32_T index = 0;

            if (diffServArpAceTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &index) == FALSE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            memcpy(byte_buffer, var_val, var_val_len);

            if (L4_PMGR_QoS_SetDiffServArpAceDstMacAddr(index, byte_buffer) != TRUE)
            {
                return SNMP_ERR_COMMITFAILED;
            }
        }
            break;

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

int write_diffServArpAceDestMacAddrBitmask(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_OCTET_STR)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len != SIZE_diffServArpAceDestMacAddrBitmask)
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;

        case RESERVE2:
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
            UI8_T byte_buffer[SIZE_diffServArpAceDestMacAddrBitmask] = {0};
            UI32_T index = 0;

            if (diffServArpAceTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &index) == FALSE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            memcpy(byte_buffer, var_val, var_val_len);

            if (L4_PMGR_QoS_SetDiffServArpAceDstMacAddrMask(index, byte_buffer) != TRUE)
            {
                return SNMP_ERR_COMMITFAILED;
            }
        }
            break;

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

int write_diffServArpAceLogStatus(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            switch (*(long *)var_val)
            {
                case VAL_diffServArpAceLogStatus_enabled:
                    break;

                case VAL_diffServArpAceLogStatus_disabled:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
            I32_T value = 0;
            UI32_T index = 0;

            if (diffServArpAceTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &index) == FALSE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            value = *(long *)var_val;
            value = (value == VAL_diffServArpAceLogStatus_enabled) ? TRUE : FALSE;

            if (L4_PMGR_QoS_SetDiffServArpAceLogStatus(index, value) != TRUE)
            {
                return SNMP_ERR_COMMITFAILED;
            }
        }
            break;

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

int write_diffServArpAceStatus(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            switch (*(long *)var_val)
            {
                case VAL_diffServArpAceStatus_active:
                    break;

                case VAL_diffServArpAceStatus_notInService:
                    break;

                case VAL_diffServArpAceStatus_notReady:
                    break;

                case VAL_diffServArpAceStatus_createAndGo:
                    break;

                case VAL_diffServArpAceStatus_createAndWait:
                    break;

                case VAL_diffServArpAceStatus_destroy:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
            I32_T value = 0;
            UI32_T index = 0;

            if (diffServArpAceTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &index) == FALSE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            value = *(long *)var_val;

            if (L4_PMGR_QoS_SetDiffServArpAceStatus(index, value) != TRUE)
            {
                return SNMP_ERR_COMMITFAILED;
            }
        }
            break;

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

#define DIFFSERVARPENTRY_INSTANCE_LEN (1 + MAXSIZE_diffServArpAclName)

BOOL_T diffServArpTable_OidIndexToData(UI32_T exact, UI32_T compc,
    oid *compl, UI8_T *name_p)
{
    UI32_T i;

    /* get or set
     */
    if (exact)
    {
        /* check the index length
         */
        if (compc < 2  || compc > DIFFSERVARPENTRY_INSTANCE_LEN) /* the dynamic size index */
        {
            return FALSE;
        }
    }

    if ((compl[0] < MINSIZE_diffServArpAclName) ||
        (compl[0] > MAXSIZE_diffServArpAclName))
    {
        return FALSE;
    }

    for (i = 0; i < compl[0]; i++)
    {
        name_p[i] = compl[1 + i];
    }
    name_p[compl[0]] = '\0';

    return TRUE;
}

/*
 * var_diffServArpTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *var_diffServArpTable(struct variable *vp,
    oid *name,
    size_t *length,
    int exact,
    size_t *var_len,
    WriteMethod **write_method)
{
    UI32_T compc = 0;
    UI32_T acl_index = 0;
    UI32_T i;
    oid compl[DIFFSERVARPENTRY_INSTANCE_LEN] = {0};
    oid best_inst[DIFFSERVARPENTRY_INSTANCE_LEN] = {0};
    RULE_TYPE_UI_AclEntry_T entry;

    switch (vp->magic)
    {
        default:
            *write_method = 0;
            break;
    }

    /* check compc, retrive compl
     */
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl, DIFFSERVARPENTRY_INSTANCE_LEN);

    memset(&entry, 0, sizeof(entry));
    entry.acl_type = RULE_TYPE_ARP_ACL;

    if (exact) /* get or set */
    {
        if (diffServArpTable_OidIndexToData(exact, compc, compl, (UI8_T *)entry.acl_name) == FALSE)
        {
            return NULL;
        }

        if (L4_PMGR_ACL_GetAclIdByName(entry.acl_name, &acl_index) != RULE_TYPE_OK)
        {
            return NULL;
        }
    }
    else /* getnext */
    {
        diffServArpTable_OidIndexToData(exact, compc, compl, (UI8_T *)entry.acl_name);

        L4_PMGR_ACL_GetAclIdByName(entry.acl_name, &acl_index);

        /* check the length of inputing index,if < 1 we should try get
         * {0.0.0.0.0...}
         */
        if (compc < 1)
        {
            if (L4_PMGR_ACL_GetNextAcl(&acl_index, &entry) != RULE_TYPE_OK)
            {
                return NULL;
            }
        }
        else
        {
            if (L4_PMGR_ACL_GetNextAcl(&acl_index, &entry) != RULE_TYPE_OK)
            {
                return NULL;
            }
        }
    }

    memcpy(name, vp->name, vp->namelen * sizeof(oid));

    /* assign data to the oid index
     */
    best_inst[0] = strlen(entry.acl_name);

    for (i = 0; i < best_inst[0]; i++)
    {
        best_inst[1 + i] = entry.acl_name[i];
    }
    memcpy(name + vp->namelen, best_inst, (1 + best_inst[0]) * sizeof(oid));
    *length = vp->namelen + 1 + best_inst[0];

    switch (vp->magic)
    {
        case LEAF_diffServArpAclName:
            *var_len = strlen(entry.acl_name);
            memcpy(return_buf, entry.acl_name, *var_len);
            return (u_char *) return_buf;

        default:
            ERROR_MSG("");
    }

    return NULL;
}
#endif /* #if (SYS_CPNT_DAI == TRUE) */

int get_diffServTcamTotalPolicyControlEntries(netsnmp_mib_handler *handler,
    netsnmp_handler_registration *reginfo,
    netsnmp_agent_request_info *reqinfo,
    netsnmp_request_info *requests)
{
    switch (reqinfo->mode)
    {
        case MODE_GET:
            {
                RULE_TYPE_TCAMUtilization_T tcam_util;
                UI32_T var_len = 0;

                memset(&tcam_util, 0, sizeof(tcam_util));

                if(TRUE == L4_PMGR_GetTCAMUtilization(&tcam_util))
                {
                    long_return = tcam_util.pce_total;
                    snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
                }
                else
                {
                    return SNMP_ERR_GENERR;
                }

                break;
            }

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int get_diffServTcamFreePolicyControlEntries(netsnmp_mib_handler *handler,
    netsnmp_handler_registration *reginfo,
    netsnmp_agent_request_info *reqinfo,
    netsnmp_request_info *requests)
{
    switch (reqinfo->mode)
    {
        case MODE_GET:
            {
                RULE_TYPE_TCAMUtilization_T tcam_util;
                UI32_T var_len = 0;

                memset(&tcam_util, 0, sizeof(tcam_util));

                if(TRUE == L4_PMGR_GetTCAMUtilization(&tcam_util))
                {
                    long_return = tcam_util.pce_free;
                    snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
                }
                else
                {
                    return SNMP_ERR_GENERR;
                }

                break;
            }

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int get_diffServTcamUtilization(netsnmp_mib_handler *handler,
    netsnmp_handler_registration *reginfo,
    netsnmp_agent_request_info *reqinfo,
    netsnmp_request_info *requests)
{
    switch (reqinfo->mode)
    {
        case MODE_GET:
            {
                RULE_TYPE_TCAMUtilization_T tcam_util;
                UI32_T var_len = 0;

                memset(&tcam_util, 0, sizeof(tcam_util));

                if(TRUE == L4_PMGR_GetTCAMUtilization(&tcam_util))
                {
                    long_return = (tcam_util.pce_utility_rate * 100);
                    snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
                }
                else
                {
                    return SNMP_ERR_GENERR;
                }

                break;
            }

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int get_diffServTcamEntriesUsedBySystem(netsnmp_mib_handler *handler,
    netsnmp_handler_registration *reginfo,
    netsnmp_agent_request_info *reqinfo,
    netsnmp_request_info *requests)
{
    switch (reqinfo->mode)
    {
        case MODE_GET:
            {
                RULE_TYPE_TCAMUtilization_T tcam_util;
                UI32_T var_len = 0;

                memset(&tcam_util, 0, sizeof(tcam_util));

                if(TRUE == L4_PMGR_GetTCAMUtilization(&tcam_util))
                {
                    long_return = tcam_util.pce_used_by_system;
                    snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
                }
                else
                {
                    return SNMP_ERR_GENERR;
                }

                break;
            }

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int get_diffServTcamEntriesUsedByUser(netsnmp_mib_handler *handler,
    netsnmp_handler_registration *reginfo,
    netsnmp_agent_request_info *reqinfo,
    netsnmp_request_info *requests)
{
    switch (reqinfo->mode)
    {
        case MODE_GET:
            {
                RULE_TYPE_TCAMUtilization_T tcam_util;
                UI32_T var_len = 0;

                memset(&tcam_util, 0, sizeof(tcam_util));

                if(TRUE == L4_PMGR_GetTCAMUtilization(&tcam_util))
                {
                    long_return = tcam_util.pce_used_by_user;
                    snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
                }
                else
                {
                    return SNMP_ERR_GENERR;
                }

                break;
            }

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

#if (SYS_CPNT_ACL_COUNTER == TRUE)
#define diffServAclHwCounterEntry_INSTANCE_LEN 4

static BOOL_T
diffServAclHwCounterTable_get(
    int compc,
    oid *compl,
    UI32_T *if_index,
    UI32_T *direction,
    UI32_T *acl_index,
    UI32_T *ace_index,
    RULE_TYPE_Ace_Entry_T *data)
{
    RULE_TYPE_InOutDirection_T  inout_profile;

    memset(data, 0, sizeof(RULE_TYPE_Ace_Entry_T));

    if (compc != diffServAclHwCounterEntry_INSTANCE_LEN) {
        return FALSE;
    }

    *if_index  = (UI32_T)compl[0];
    *direction = (UI32_T)compl[1];
    *acl_index = (UI32_T)compl[2];
    *ace_index = (UI32_T)compl[3];

    switch (*direction)
    {
        case VAL_diffServAclHwCounterDirection_ingress:
            inout_profile = RULE_TYPE_INBOUND;
            break;
        case VAL_diffServAclHwCounterDirection_egress:
            inout_profile = RULE_TYPE_OUTBOUND;
            break;
        default:
            return FALSE;
    }


   if (RULE_TYPE_OK == L4_PMGR_QoS_GetDiffServAclHwCounterEntry(*if_index,
                                                                inout_profile,
                                                                *acl_index,
                                                                *ace_index,
                                                                data))
   {
       return TRUE;
   }

    return FALSE;
}

static BOOL_T
diffServAclHwCounterTable_next(
    int compc,
    oid *compl,
    UI32_T *if_index,
    UI32_T *direction,
    UI32_T *acl_index,
    UI32_T *ace_index,
    RULE_TYPE_Ace_Entry_T *data)
{
    RULE_TYPE_InOutDirection_T  inout_profile;

    memset(data, 0, sizeof(RULE_TYPE_Ace_Entry_T));

    if (compc < diffServAclHwCounterEntry_INSTANCE_LEN - 1)
    {
        *if_index  = 0;
        *direction = 0;
        *acl_index = 0;
        *ace_index = 0;
    }
    else
    {
        *if_index  = compl[0];
        *direction = compl[1];
        *acl_index = compl[2];
        *ace_index = (compc == diffServAclHwCounterEntry_INSTANCE_LEN) ? compl[3] : 0;
    }

    switch (*direction)
    {
        case VAL_diffServAclHwCounterDirection_egress:
            inout_profile = RULE_TYPE_OUTBOUND;
            break;
        case VAL_diffServAclHwCounterDirection_ingress:
        default:
            inout_profile = RULE_TYPE_INBOUND;
            break;
    }

    while (RULE_TYPE_OK == L4_PMGR_QoS_GetNextDiffServAclHwCounterEntry(if_index,
                                                                        &inout_profile,
                                                                        acl_index,
                                                                        ace_index,
                                                                        data))
    {
        switch (inout_profile)
        {
            case RULE_TYPE_OUTBOUND:
                *direction = VAL_diffServAclHwCounterDirection_egress;
                break;
            case RULE_TYPE_INBOUND:
                *direction = VAL_diffServAclHwCounterDirection_ingress;
                break;
            default :
                continue;
        }
        return TRUE;
    }

    return FALSE;
}

/*
 * var_diffServAclCounterTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_diffServAclHwCounterTable(
    struct variable *vp,
    oid * name,
    size_t * length,
    int exact,
    size_t * var_len,
    WriteMethod ** write_method)
{
    UI32_T compc = 0;
    UI32_T if_index = 0, direction = RULE_TYPE_INBOUND, acl_index, ace_index;
    oid compl[diffServAclHwCounterEntry_INSTANCE_LEN];
    oid next_inst[diffServAclHwCounterEntry_INSTANCE_LEN];
    RULE_TYPE_Ace_Entry_T entry;

    switch (vp->magic)
    {
        default:
            *write_method = 0;
    }

    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl,
        diffServAclHwCounterEntry_INSTANCE_LEN);

    if (exact)/*get,set*/
    {
        if (!diffServAclHwCounterTable_get(compc, compl, &if_index, &direction,
                 &acl_index, &ace_index, &entry))
        {
            return NULL;
        }
    }
    else/*getnext*/
    {
      if (!diffServAclHwCounterTable_next(compc, compl, &if_index, &direction,
               &acl_index, &ace_index, &entry))
      {
          return NULL;
      }
    }

    memcpy(name, vp->name, vp->namelen*sizeof(oid));
    next_inst[0] = if_index;
    next_inst[1] = direction;
    next_inst[2] = acl_index;
    next_inst[3] = ace_index;
    memcpy(name + vp->namelen, next_inst, diffServAclHwCounterEntry_INSTANCE_LEN * sizeof(oid));
    *length = vp->namelen + diffServAclHwCounterEntry_INSTANCE_LEN;
    *var_len = sizeof(long_return);

    switch (vp->magic)
    {
        case DIFFSERVACLHWCOUNTERIFINDEX:
            long_return = if_index;
            return (u_char *) &long_return;
        case DIFFSERVACLHWCOUNTERDIRECTION:
            long_return = direction;
            return (u_char *) &long_return;
        case DIFFSERVACLHWCOUNTERACLINDEX:
            long_return = acl_index;
            return (u_char *) &long_return;
        case DIFFSERVACLHWCOUNTERACEINDEX:
            long_return = ace_index;
            return (u_char *) &long_return;
        case DIFFSERVACLHWCOUNTERACEHITCOUNT:
            long_return = entry.counter.total_packets;
            return (u_char *) &long_return;

        default:
            ERROR_MSG("");
    }

    return NULL;
}
#endif /* #if (SYS_CPNT_ACL_COUNTER == TRUE) */

#define diffServPolicyMapPortTable_INSTANCE_LEN 2

BOOL_T
diffServPolicyMapPortTable_OidIndexToData(
    UI32_T compc,
    oid *  compl,
    UI32_T *ifindex_p,
    UI32_T *direction_p)
{
    *ifindex_p = 0;
    *direction_p = RULE_TYPE_UNSPEC_DIRECTION;

    if (0 < compc)
    {
        *ifindex_p = compl[0];

        if (compc == diffServPolicyMapPortTable_INSTANCE_LEN)
        {
            *direction_p = compl[1];
        }
    }

    return TRUE;
}

unsigned char  *
var_diffServPolicyMapPortTable(
    struct variable *vp,
    oid * name,
    size_t * length,
    int exact,
    size_t * var_len,
    WriteMethod ** write_method)
{
    /*
     * variables we may use later
     */
    UI32_T compc=0;
    oid compl[diffServPolicyMapPortTable_INSTANCE_LEN];
    oid best_inst[diffServPolicyMapPortTable_INSTANCE_LEN];
    RULE_TYPE_MIB_PolicyMapPortEntry_T entry;

    memset(&entry, 0, sizeof(entry));

    switch (vp->magic) {
      case DIFFSERVPOLICYMAPPORTPOLICYMAPINDEX:
        *write_method = write_diffServPolicyMapPortPolicyMapIndex;
        break;

      case DIFFSERVPOLICYMAPPORTSTATUS:
        *write_method = write_diffServPolicyMapPortStatus;
        break;

      default:
        *write_method = 0;
        break;
    }

    /*check compc, retrive compl*/
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,compl, diffServPolicyMapPortTable_INSTANCE_LEN);

    if (FALSE == diffServPolicyMapPortTable_OidIndexToData(compc, compl, &entry.ifindex, &entry.direction))
    {
        return NULL;
    }

    if (exact)
    {
        if (L4_PMGR_QoS_GetPolicyMapPortEntry(&entry)!= RULE_TYPE_OK)
        {
            return NULL;
        }
    }
    else
    {
        if (L4_PMGR_QoS_GetNextPolicyMapPortEntry(&entry)!= RULE_TYPE_OK)
        {
            return NULL;
        }
    }

    if (entry.ifindex == SYS_ADPT_CPU_1_IF_INDEX_NUMBER)
    {
        return NULL;
    }

    memcpy(name, vp->name, vp->namelen*sizeof(oid));
    best_inst[0] = entry.ifindex;
    best_inst[1] = entry.direction;
    memcpy(name + vp->namelen, best_inst, diffServPolicyMapPortTable_INSTANCE_LEN*sizeof(oid));
    *length = vp->namelen + diffServPolicyMapPortTable_INSTANCE_LEN;

    *var_len = sizeof(long_return);

    switch (vp->magic) {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
      case DIFFSERVPOLICYMAPPORTIFINDEX:
            long_return = entry.ifindex;
            return (u_char *) &long_return;

      case DIFFSERVPOLICYMAPPORTDIRECTION:
            long_return = entry.direction;
            return (u_char *) &long_return;
#endif /* SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE */

      case DIFFSERVPOLICYMAPPORTPOLICYMAPINDEX:
            long_return = entry.policy_map_index;
            return (u_char *) &long_return;
      case DIFFSERVPOLICYMAPPORTSTATUS:
            long_return = entry.row_status;
            return (u_char *) &long_return;

      default:
          ERROR_MSG("");
    }
    return NULL;
}

int write_diffServPolicyMapPortPolicyMapIndex(
    int       action,
    u_char    *var_val,
    u_char    var_val_type,
    size_t    var_val_len,
    u_char    *statP,
    oid       *name,
    size_t    name_len)
{
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    /*check max length of the inputing index */
    if(name_len > oid_name_length+diffServPolicyMapPortTable_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }

        case RESERVE2:
        {
            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            UI32_T ifindex, direction, policy_map_index;

            ifindex = name[oid_name_length];
            direction = name[oid_name_length+1];
            policy_map_index = *(long *)var_val;

            if (RULE_TYPE_OK != L4_PMGR_QoS_SetPolicyMapPortPolcyMapIndex(ifindex,
                                                                          direction,
                                                                          policy_map_index))
            {
                return SNMP_ERR_COMMITFAILED;
            }
            break;
        }

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }
    return SNMP_ERR_NOERROR;
}

int write_diffServPolicyMapPortStatus(
    int       action,
    u_char    *var_val,
    u_char    var_val_type,
    size_t    var_val_len,
    u_char    *statP,
    oid       *name,
    size_t    name_len)
{
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    /*check max length of the inputing index */
    if(name_len > oid_name_length+diffServPolicyMapPortTable_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }

             if (*(long *)var_val < VAL_diffServPolicyMapPortPortStatus_active ||
                 VAL_diffServPolicyMapPortPortStatus_destroy < *(long *)var_val)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }

        case RESERVE2:
        {
            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            UI32_T ifindex, direction, row_status;

            ifindex = name[oid_name_length];
            direction = name[oid_name_length+1];
            row_status = *(long *)var_val;

            if (RULE_TYPE_OK != L4_PMGR_QoS_SetPolicyMapPortRowStatus(ifindex,
                                                                      direction,
                                                                      row_status))
            {
                return SNMP_ERR_COMMITFAILED;
            }
            break;
        }

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }
    return SNMP_ERR_NOERROR;
}

#define diffServAccessGroupTable_INSTANCE_LEN 3

BOOL_T
diffServAccessGroupTable_OidIndexToData(
    UI32_T compc,
    oid *  compl,
    UI32_T *ifindex_p,
    UI32_T *direction_p,
    UI32_T *type_p)
{
    *ifindex_p = 0;
    *direction_p = RULE_TYPE_UNSPEC_DIRECTION;
    *type_p = 0;

    if (0 < compc)
    {
        *ifindex_p = compl[0];
        if (1 < compc)
        {
            *direction_p = compl[1];
            if (2 < compc)
            {
                *type_p = compl[2];
            }
        }
    }

    return TRUE;
}

unsigned char  *
var_diffServAccessGroupTable(
    struct variable *vp,
    oid * name,
    size_t * length,
    int exact,
    size_t * var_len,
    WriteMethod ** write_method)
{
    /*
     * variables we may use later
     */
    UI32_T compc=0;
    oid compl[diffServAccessGroupTable_INSTANCE_LEN];
    oid best_inst[diffServAccessGroupTable_INSTANCE_LEN];
    RULE_TYPE_MIB_AccessGroupEntry_T entry;

    memset(&entry, 0, sizeof(entry));

    switch (vp->magic) {
      case DIFFSERVACCESSGROUPACLINDEX:
        *write_method = write_diffServAccessGroupAclIndex;
        break;

#if (SYS_CPNT_TIME_BASED_ACL == TRUE)
      case DIFFSERVACCESSGROUPTIMERANGENAME:
        *write_method = write_diffServAccessGroupTimeRangeName;
        break;
#endif /* (SYS_CPNT_TIME_BASED_ACL == TRUE) */

#if (SYS_CPNT_ACL_COUNTER == TRUE)
      case DIFFSERVACCESSGROUPCOUNTERSTATUS:
        *write_method = write_diffServAccessGroupCounterStatus;
        break;
#endif /* (SYS_CPNT_ACL_COUNTER == TRUE) */

      case DIFFSERVACCESSGROUPSTATUS:
        *write_method = write_diffServAccessGroupStatus;
        break;

      default:
        *write_method = 0;
        break;
    }

    /*check compc, retrive compl*/
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,compl,
                           diffServAccessGroupTable_INSTANCE_LEN);

    if (FALSE == diffServAccessGroupTable_OidIndexToData(compc, compl,
                                                         &entry.ifindex,
                                                         &entry.direction,
                                                         &entry.type))
    {
        return NULL;
    }

    if (exact)
    {
        if (L4_PMGR_QoS_GetAccessGroupEntry(&entry)!= RULE_TYPE_OK)
        {
            return NULL;
        }
    }
    else
    {
        if (L4_PMGR_QoS_GetNextAccessGroupEntry(&entry)!= RULE_TYPE_OK)
        {
            return NULL;
        }
    }

    memcpy(name, vp->name, vp->namelen*sizeof(oid));
    best_inst[0] = entry.ifindex;
    best_inst[1] = entry.direction;
    best_inst[2] = entry.type;
    memcpy(name + vp->namelen, best_inst, diffServAccessGroupTable_INSTANCE_LEN*sizeof(oid));
    *length = vp->namelen + diffServAccessGroupTable_INSTANCE_LEN;

    *var_len = sizeof(long_return);

    switch (vp->magic) {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
      case DIFFSERVACCESSGROUPIFINDEX:
            long_return = entry.ifindex;
            return (u_char *) &long_return;

      case DIFFSERVACCESSGROUPDIRECTION:
            long_return = entry.direction;
            return (u_char *) &long_return;

      case DIFFSERVACCESSGROUPTYPE:
            long_return = entry.type;
            return (u_char *) &long_return;
#endif /* SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE */

      case DIFFSERVACCESSGROUPACLINDEX:
            long_return = entry.acl_index;
            return (u_char *) &long_return;

#if (SYS_CPNT_TIME_BASED_ACL == TRUE)
      case DIFFSERVACCESSGROUPTIMERANGENAME:
            memcpy(return_buf, entry.time_range_name,
                   strlen(entry.time_range_name));
            *var_len = strlen(entry.time_range_name);
            return (u_char *)return_buf;
#endif /* (SYS_CPNT_TIME_BASED_ACL == TRUE) */

#if (SYS_CPNT_ACL_COUNTER == TRUE)
      case DIFFSERVACCESSGROUPCOUNTERSTATUS:
            long_return = entry.counter_status;
            return (u_char *) &long_return;
#endif /* (SYS_CPNT_ACL_COUNTER == TRUE) */

      case DIFFSERVACCESSGROUPSTATUS:
            long_return = entry.row_status;
            return (u_char *) &long_return;

      default:
          ERROR_MSG("");
    }
    return NULL;
}

int write_diffServAccessGroupAclIndex(
    int       action,
    u_char    *var_val,
    u_char    var_val_type,
    size_t    var_val_len,
    u_char    *statP,
    oid       *name,
    size_t    name_len)
{
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    /*check max length of the inputing index */
    if(name_len > oid_name_length+diffServAccessGroupTable_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }

        case RESERVE2:
        {
            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            UI32_T ifindex, direction, acl_type, acl_index;

            ifindex = name[oid_name_length];
            direction = name[oid_name_length+1];
            acl_type = name[oid_name_length+2];
            acl_index = *(long *)var_val;

            if(RULE_TYPE_OK != L4_PMGR_QoS_SetAccessGroupAclIndex(ifindex,
                                                                  direction,
                                                                  acl_type,
                                                                  acl_index))
            {
                return SNMP_ERR_COMMITFAILED;
            }
            break;
        }

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }
    return SNMP_ERR_NOERROR;
}

#if (SYS_CPNT_TIME_BASED_ACL == TRUE)
int write_diffServAccessGroupTimeRangeName(
    int       action,
    u_char    *var_val,
    u_char    var_val_type,
    size_t    var_val_len,
    u_char    *statP,
    oid       *name,
    size_t    name_len)
{
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    /*check max length of the inputing index */
    if(name_len > oid_name_length+diffServAccessGroupTable_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_OCTET_STR)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (SYS_ADPT_MAX_LENGTH_OF_TIME_ACL_TABLE_NAME < var_val_len)
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }

        case RESERVE2:
        {
            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            UI32_T ifindex, direction, acl_type;
            char time_range_name[SYS_ADPT_MAX_LENGTH_OF_TIME_ACL_TABLE_NAME+1] = {0};

            ifindex = name[oid_name_length];
            direction = name[oid_name_length+1];
            acl_type = name[oid_name_length+2];

            strncpy(time_range_name, (char *)var_val, var_val_len);
            time_range_name[var_val_len] = '\0';

            if(RULE_TYPE_OK != L4_PMGR_QoS_SetAccessGroupTimeRangeName(ifindex,
                                                                       direction,
                                                                       acl_type,
                                                                       time_range_name))
            {
                return SNMP_ERR_COMMITFAILED;
            }
            break;
        }

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }
    return SNMP_ERR_NOERROR;
}
#endif /* (SYS_CPNT_TIME_BASED_ACL == TRUE) */

#if (SYS_CPNT_ACL_COUNTER == TRUE)
int write_diffServAccessGroupCounterStatus(
    int       action,
    u_char    *var_val,
    u_char    var_val_type,
    size_t    var_val_len,
    u_char    *statP,
    oid       *name,
    size_t    name_len)
{
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    /*check max length of the inputing index */
    if(name_len > oid_name_length+diffServAccessGroupTable_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }

            if (*(long *)var_val < VAL_diffServAccessGroupCounterStatus_enabled ||
                VAL_diffServAccessGroupCounterStatus_disabled < *(long *)var_val)
            {
                return SNMP_ERR_WRONGVALUE;
            }

            break;
        }

        case RESERVE2:
        {
            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            UI32_T ifindex, direction, acl_type, counter_status;

            ifindex = name[oid_name_length];
            direction = name[oid_name_length+1];
            acl_type = name[oid_name_length+2];
            counter_status = *(long *)var_val;

            if(RULE_TYPE_OK != L4_PMGR_QoS_SetAccessGroupCounterStatus(ifindex,
                                                                       direction,
                                                                       acl_type,
                                                                       counter_status))
            {
                return SNMP_ERR_COMMITFAILED;
            }
            break;
        }

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }
    return SNMP_ERR_NOERROR;
}
#endif /* (SYS_CPNT_ACL_COUNTER == TRUE) */

int write_diffServAccessGroupStatus(
    int       action,
    u_char    *var_val,
    u_char    var_val_type,
    size_t    var_val_len,
    u_char    *statP,
    oid       *name,
    size_t    name_len)
{
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    /*check max length of the inputing index */
    if(name_len > oid_name_length+diffServAccessGroupTable_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }

            if (*(long *)var_val < VAL_diffServAccessGroupStatus_active ||
                VAL_diffServAccessGroupStatus_destroy < *(long *)var_val)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }

        case RESERVE2:
        {
            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            UI32_T ifindex, direction, acl_type, row_status;

            ifindex = name[oid_name_length];
            direction = name[oid_name_length+1];
            acl_type = name[oid_name_length+2];
            row_status = *(long *)var_val;

            if(RULE_TYPE_OK != L4_PMGR_QoS_SetAccessGroupRowStatus(ifindex,
                                                                   direction,
                                                                   acl_type,
                                                                   row_status))
            {
                return SNMP_ERR_COMMITFAILED;
            }
            break;
        }

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }
    return SNMP_ERR_NOERROR;
}

#define DIFFSERVTCAMTABLE_INSTANCE_LEN  3

static BOOL_T
differServTcamTable_OidIndexToData(
    UI32_T compc,
    oid *  compl,
    RULE_TYPE_TCAM_ENTRY_T *tcam_entry_p)
{
    memset(tcam_entry_p, 0, sizeof(*tcam_entry_p));

    tcam_entry_p->device_id = RULE_TYPE_UNDEF_DEVICE_ID;
    tcam_entry_p->pool_id = RULE_TYPE_UNDEF_POOL_ID;

    if (compc)
    {
        if (DIFFSERVTCAMTABLE_INSTANCE_LEN < compc)
        {
            return FALSE;
        }

        tcam_entry_p->unit = compl[0];

        if (1 < compc)
        {
            tcam_entry_p->device_id = compl[1];

            if (2 < compc)
            {
                tcam_entry_p->pool_id = compl[2];
            }
        }
    }

    return TRUE;
}
/*
 * var_diffServTcamTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_diffServTcamTable(
    struct variable *vp,
    oid * name,
    size_t * length,
    int exact,
    size_t * var_len,
    WriteMethod ** write_method)
{
    UI32_T compc = 0;
    oid compl[DIFFSERVTCAMTABLE_INSTANCE_LEN];
    oid next_inst[DIFFSERVTCAMTABLE_INSTANCE_LEN];
    RULE_TYPE_TCAM_ENTRY_T tcam_entry;

    switch (vp->magic)
    {
        default:
            *write_method = 0;
    }

    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl,
        DIFFSERVTCAMTABLE_INSTANCE_LEN);

    if (TRUE != differServTcamTable_OidIndexToData(compc, compl, &tcam_entry))
    {
        return NULL;
    }

    if (exact)
    {
        if (TRUE != L4_PMGR_GetTcamEntry(&tcam_entry))
        {
            return NULL;
        }
    }
    else
    {
        if (TRUE != L4_PMGR_GetNextTcamEntry(&tcam_entry))
        {
            return NULL;
        }
    }

    memcpy(name, vp->name, vp->namelen*sizeof(oid));
    next_inst[0] = tcam_entry.unit;
    next_inst[1] = tcam_entry.device_id;
    next_inst[2] = tcam_entry.pool_id;
    memcpy(name + vp->namelen, next_inst, DIFFSERVTCAMTABLE_INSTANCE_LEN * sizeof(oid));
    *length = vp->namelen + DIFFSERVTCAMTABLE_INSTANCE_LEN;
    *var_len = sizeof(long_return);

    switch (vp->magic)
    {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case DIFFSERVTCAMUNIT:
            long_return = tcam_entry.unit;
            return (u_char *) &long_return;
        case DIFFSERVTCAMDEVICE:
            long_return = tcam_entry.device_id;
            return (u_char *) &long_return;
        case DIFFSERVTCAMPOOL:
            long_return = tcam_entry.pool_id;
            return (u_char *) &long_return;
#endif /* SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE */
        case DIFFSERVTCAMPOOLCAPABILITY:
            memcpy(return_buf, tcam_entry.cap_bitmap.bits, RULE_TYEP_TCAM_CAP_MAX_BITMAP_SIZE);
            *var_len = RULE_TYEP_TCAM_CAP_MAX_BITMAP_SIZE;
            return (u_char*)return_buf;
        case DIFFSERVTCAMTOTAL:
            long_return = tcam_entry.total;
            return (u_char *) &long_return;
        case DIFFSERVTCAMFREE:
            long_return = tcam_entry.free;
            return (u_char *) &long_return;
        case DIFFSERVTCAMUSED:
            long_return = tcam_entry.used;
            return (u_char *) &long_return;

        default:
            ERROR_MSG("");
    }

    return NULL;
}

#if (SYS_CPNT_QOS_V2_CPU_PORT == TRUE)
int do_diffServPolicyMapControlPlanePolicyMapIndex(
    netsnmp_mib_handler          *handler,
    netsnmp_handler_registration *reginfo,
    netsnmp_agent_request_info   *reqinfo,
    netsnmp_request_info         *requests)
{
    switch (reqinfo->mode)
    {
        case MODE_GET:
        {
            RULE_TYPE_MIB_PolicyMapPortEntry_T entry;

            memset(&entry, 0, sizeof(entry));
            entry.ifindex = SYS_ADPT_CPU_1_IF_INDEX_NUMBER;
            entry.direction = VAL_diffServPolicyMapPortDirection_egress;
            if (L4_PMGR_QoS_GetPolicyMapPortEntry(&entry)!= RULE_TYPE_OK)
            {
                long_return = 0;
            }
            else
            {
                long_return = entry.policy_map_index;
            }
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));

            break;
        }

        case MODE_SET_RESERVE1:
            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
            }
            break;

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            break;

        case MODE_SET_ACTION:
        {
            UI32_T policy_map_index;

            policy_map_index = *requests->requestvb->val.integer;

            if(SNMP_MGR_IsDebugMode())
            {
                printf("%s, %d: policy_map_index: %lu\r\n",__FUNCTION__, __LINE__, (unsigned long)policy_map_index);
            }

            if (RULE_TYPE_OK != L4_PMGR_QoS_SetPolicyMapPortPolcyMapIndex(
                                                SYS_ADPT_CPU_1_IF_INDEX_NUMBER,
                                                VAL_diffServPolicyMapPortDirection_egress,
                                                policy_map_index))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int do_diffServPolicyMapControlPlaneStatus(
    netsnmp_mib_handler          *handler,
    netsnmp_handler_registration *reginfo,
    netsnmp_agent_request_info   *reqinfo,
    netsnmp_request_info         *requests)
{
    switch (reqinfo->mode)
    {
        case MODE_GET:
        {
            RULE_TYPE_MIB_PolicyMapPortEntry_T entry;

            memset(&entry, 0, sizeof(entry));
            entry.ifindex = SYS_ADPT_CPU_1_IF_INDEX_NUMBER;
            entry.direction = VAL_diffServPolicyMapPortDirection_egress;
            if (L4_PMGR_QoS_GetPolicyMapPortEntry(&entry)!= RULE_TYPE_OK)
            {
                long_return = 0;
            }
            else
            {
                long_return = entry.row_status;
            }
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));

            break;
        }

        case MODE_SET_RESERVE1:
            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
            }
            break;

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            break;

        case MODE_SET_ACTION:
        {
            if (RULE_TYPE_OK != L4_PMGR_QoS_SetPolicyMapPortRowStatus(
                                                SYS_ADPT_CPU_1_IF_INDEX_NUMBER,
                                                VAL_diffServPolicyMapPortDirection_egress,
                                                (*requests->requestvb->val.integer)))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

#if (SYS_CPNT_QOS_V2_COUNTER == TRUE)
#define diffServControlPlaneHwCounterEntry_INSTANCE_LEN 1

static BOOL_T diffServControlPlaneHwCounterTable_OidIndexToData(
    int      compc,
    oid     *compl,
    UI32_T  *class_map_index)
{
    *class_map_index = 0;

    if (0 < compc)
    {
        if (compc > diffServControlPlaneHwCounterEntry_INSTANCE_LEN)
        {
            return FALSE;
        }

        *class_map_index = compl[0];
    }

    return TRUE;
}

int  write_diffServControlPlaneHwCounterClassMapClearAction(
    int       action,
    u_char    *var_val,
    u_char    var_val_type,
    size_t    var_val_len,
    u_char    *statP,
    oid       *name,
    size_t    name_len)
{
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    /*check max length of the inputing index */
    if(name_len > oid_name_length+diffServControlPlaneHwCounterEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch (action)
    {
        case RESERVE1:
            /* check type and length
             */
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            /* check valid values
             */
            switch (*(long *) var_val)
            {
                case VAL_diffServControlPlaneHwCounterClassMapClearAction_true:
                    break;

                case VAL_diffServControlPlaneHwCounterClassMapClearAction_false:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            RULE_TYPE_MIB_PolicyMapPortEntry_T policy_entry;
            UI32_T class_map_index = name[oid_name_length];

            if (*(long *) var_val == VAL_diffServControlPlaneHwCounterClassMapClearAction_false)
            {
                return SNMP_ERR_NOERROR;
            }

            if(SNMP_MGR_IsDebugMode())
            {
                printf("%s, %d: class_map_index: %lu\r\n",__FUNCTION__, __LINE__, (unsigned long)class_map_index);
            }

            policy_entry.ifindex = SYS_ADPT_CPU_1_IF_INDEX_NUMBER;
            policy_entry.direction = VAL_diffServPolicyMapPortDirection_egress;
            if (RULE_TYPE_OK != L4_PMGR_QoS_GetPolicyMapPortEntry(&policy_entry))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            if(RULE_TYPE_OK != L4_PMGR_QoS_ClearDiffServPolicyMapHwCounter(
                                       SYS_ADPT_CPU_1_IF_INDEX_NUMBER,
                                       RULE_TYPE_OUTBOUND,
                                       policy_entry.policy_map_index,
                                       class_map_index))
            {
                return SNMP_ERR_COMMITFAILED;
            }
            break;
        }

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }
    return SNMP_ERR_NOERROR;
}

unsigned char  *
var_diffServControlPlaneHwCounterTable(
    struct variable *vp,
    oid * name,
    size_t * length,
    int exact,
    size_t * var_len,
    WriteMethod ** write_method)
{
    UI32_T compc = 0;
    oid compl[diffServControlPlaneHwCounterEntry_INSTANCE_LEN];
    oid next_inst[diffServControlPlaneHwCounterEntry_INSTANCE_LEN];
    UI32_T class_map_index=0;
    RULE_TYPE_MIB_PolicyMapPortEntry_T policy_entry;
    RULE_TYPE_CounterRec_T counter;

    switch (vp->magic)
    {
        case DIFFSERVCONTROLPLANEHWCOUNTERCLASSMAPCLEARACTION:
            *write_method = write_diffServControlPlaneHwCounterClassMapClearAction;
            break;

        default:
            *write_method = 0;
    }

    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl,
        DIFFSERVTCAMTABLE_INSTANCE_LEN);

    if (TRUE != diffServControlPlaneHwCounterTable_OidIndexToData(compc, compl, &class_map_index))
    {
        return NULL;
    }

    policy_entry.ifindex = SYS_ADPT_CPU_1_IF_INDEX_NUMBER;
    policy_entry.direction = VAL_diffServPolicyMapPortDirection_egress;
    if (RULE_TYPE_OK != L4_PMGR_QoS_GetPolicyMapPortEntry(&policy_entry))
    {
        return NULL;
    }

    if (exact)
    {
        if (class_map_index == 0)
        {
            return NULL;
        }

        if (RULE_TYPE_OK != L4_PMGR_QoS_GetDiffServPolicyMapHwCounter(
                                 SYS_ADPT_CPU_1_IF_INDEX_NUMBER,
                                 RULE_TYPE_OUTBOUND,
                                 policy_entry.policy_map_index,
                                 class_map_index,
                                 &counter))
        {
            return NULL;
        }

    }
    else
    {
        if (TRUE != L4_PMGR_Qos_GetNextDiffServClassMapIndexOfPolicyMap(
                                 policy_entry.policy_map_index,
                                 &class_map_index))
        {
            return NULL;
        }

        if (RULE_TYPE_OK != L4_PMGR_QoS_GetDiffServPolicyMapHwCounter(
                                 SYS_ADPT_CPU_1_IF_INDEX_NUMBER,
                                 RULE_TYPE_OUTBOUND,
                                 policy_entry.policy_map_index,
                                 class_map_index,
                                 &counter))
        {
            return NULL;
        }
    }

    memcpy(name, vp->name, vp->namelen*sizeof(oid));
    next_inst[0] = class_map_index;
    memcpy(name + vp->namelen, next_inst, diffServControlPlaneHwCounterEntry_INSTANCE_LEN * sizeof(oid));
    *length = vp->namelen + diffServControlPlaneHwCounterEntry_INSTANCE_LEN;
    *var_len = sizeof(long_return);

    switch (vp->magic)
    {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case DIFFSERVCONTROLPLANEHWCOUNTERCLASSMAPINDEX:
            long_return = class_map_index;
            return (u_char *) &long_return;
#endif /* SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE */
        case DIFFSERVCONTROLPLANEHWCOUNTERCLASSMAPRECEIVEPACKETS:
            long_return = counter.receive_packets;
            return (u_char *) &long_return;
        case DIFFSERVCONTROLPLANEHWCOUNTERCLASSMAPDROPPACKETS:
            long_return = counter.drop_packets;
            return (u_char *) &long_return;
        case DIFFSERVCONTROLPLANEHWCOUNTERCLASSMAPCLEARACTION:
            long_return = FALSE;
            return (u_char *) &long_return;
        default:
            ERROR_MSG("");
    }

    return NULL;
}
#endif /* #if (SYS_CPNT_QOS_V2_COUNTER == TRUE) */
#endif /* #if (SYS_CPNT_QOS_V2_CPU_PORT == TRUE)*/

#endif /* end of #if (SYS_CPNT_QOS_V2 == TRUE) */

#if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION==TRUE)
/********************************************
 ************privateVlanMgt******************
 ********************************************
 */
#if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE != SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE_MULTIPLE_SESSION)
int
do_privateVlanUplinkPorts(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one.
     */

    switch (reqinfo->mode) {

    case MODE_GET:
    {
        SWCTRL_PrivateVlan_T value;
        if (SWCTRL_POM_GetPrivateVlan(&value))
        {
            memcpy( return_buf, value.uplink_ports, SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST);
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, (u_char *) return_buf, SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST);
        }
        else
        {
            if(SNMP_MGR_IsDebugMode())
                printf("do_privateVlanUplinkPorts:SWCTRL_GetPrivateVlan return false\n");
            return SNMP_ERR_GENERR;
        }
        break;
     }
        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            if (requests->requestvb->type != ASN_OCTET_STR)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
            }

            if (requests->requestvb->val_len > SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGLENGTH);
            }
            break;

        case MODE_SET_RESERVE2:
            break;

    case MODE_SET_FREE:
        /*
         * XXX: free resources allocated in RESERVE1 and/or
         * RESERVE2.  Something failed somewhere, and the states
         * below won't be called.
         */
        break;
    case MODE_SET_ACTION:
    {
       /*
        * XXX: perform the value change here
        */
       UI8_T UpLinkPorts[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST];
       UI8_T DownLinkPorts[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST];
       SWCTRL_PrivateVlan_T strucPrivateVlan;
       int i;

       if (SWCTRL_POM_GetPrivateVlan(&strucPrivateVlan))
       {
            memcpy(DownLinkPorts, strucPrivateVlan.downlink_ports, SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST);
            memset(UpLinkPorts, 0, SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST);
            memcpy(UpLinkPorts, requests->requestvb->val.string, requests->requestvb->val_len);
            if(SNMP_MGR_IsDebugMode())
            {
                printf("\nUpLinkPorts=");
                for (i=0;i<SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST;i++)
                    printf("%02x-", UpLinkPorts[i]);
                printf("\nDownLinkPorts=");
                for (i=0;i<SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST;i++)
                    printf("%02x-", DownLinkPorts[i]);
                printf("\n");
            }
            if (SWCTRL_PMGR_SetPrivateVlan(UpLinkPorts, DownLinkPorts)!=TRUE)
            {
                if(SNMP_MGR_IsDebugMode())
                    printf("do_privateVlanUplinkPorts:SWCTRL_SetPrivateVlan return false\n");
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            }

       }
       else
       {
            if(SNMP_MGR_IsDebugMode())
                 printf("do_privateVlanUplinkPorts:SWCTRL_GetPrivateVlan return false\n");
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
       }
       break;
     }
    case MODE_SET_COMMIT:
        /*
         * XXX: delete temporary storage
         */

        break;

    case MODE_SET_UNDO:
        /*
         * XXX: UNDO and return to previous value for the object
         */

        break;
    default:
        /*
         * we should never get here, so this is a really bad error
         */
        return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}

int
do_privateVlanDownlinkPorts(netsnmp_mib_handler *handler,
                            netsnmp_handler_registration *reginfo,
                            netsnmp_agent_request_info *reqinfo,
                            netsnmp_request_info *requests)
{
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one.
     */

    switch (reqinfo->mode) {

    case MODE_GET:
    {
        SWCTRL_PrivateVlan_T value;
        if (SWCTRL_POM_GetPrivateVlan(&value))
        {
            memcpy( return_buf, value.downlink_ports, SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST);
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, (u_char *) return_buf, SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST);
        }
        else
        {
            if(SNMP_MGR_IsDebugMode())
                printf("do_privateVlanDownlinkPorts:SWCTRL_GetPrivateVlan return false\n");
            return SNMP_ERR_GENERR;
        }
        break;
     }
        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            if (requests->requestvb->type != ASN_OCTET_STR)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
            }

            if (requests->requestvb->val_len > SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGLENGTH);
            }
            break;

        case MODE_SET_RESERVE2:
            break;

    case MODE_SET_FREE:
        /*
         * XXX: free resources allocated in RESERVE1 and/or
         * RESERVE2.  Something failed somewhere, and the states
         * below won't be called.
         */
        break;
    case MODE_SET_ACTION:
    {
       /*
        * XXX: perform the value change here
        */
       UI8_T UpLinkPorts[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST];
       UI8_T DownLinkPorts[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST];
       SWCTRL_PrivateVlan_T strucPrivateVlan;
       int i;

       if (SWCTRL_POM_GetPrivateVlan(&strucPrivateVlan))
       {
            memcpy(UpLinkPorts, strucPrivateVlan.uplink_ports, SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST);
            memset(DownLinkPorts, 0, SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST);
            memcpy(DownLinkPorts, requests->requestvb->val.string, requests->requestvb->val_len);
            if(SNMP_MGR_IsDebugMode())
            {
                printf("\nUpLinkPorts=");
                for (i=0;i<SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST;i++)
                    printf("%02x-", UpLinkPorts[i]);
                printf("\nDownLinkPorts=");
                for (i=0;i<SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST;i++)
                    printf("%02x-", DownLinkPorts[i]);
                printf("\n");
            }
            if (SWCTRL_PMGR_SetPrivateVlan(UpLinkPorts, DownLinkPorts)!=TRUE)
            {
                if(SNMP_MGR_IsDebugMode())
                    printf("do_privateVlanDownlinkPorts:SWCTRL_SetPrivateVlan return false\n");
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            }

       }
       else
       {
            if(SNMP_MGR_IsDebugMode())
                 printf("do_privateVlanDownlinkPorts:SWCTRL_GetPrivateVlan return false\n");
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
       }
       break;
     }
    case MODE_SET_COMMIT:
        break;
    case MODE_SET_UNDO:
        break;
    default:
        /*
         * we should never get here, so this is a really bad error
         */
        return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}
#endif/* end of #if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE != SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE_MULTIPLE_SESSION) */

int
do_privateVlanStatus(netsnmp_mib_handler *handler,
                     netsnmp_handler_registration *reginfo,
                     netsnmp_agent_request_info *reqinfo,
                     netsnmp_request_info *requests)
{
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one.
     */

    switch (reqinfo->mode) {

    case MODE_GET:
    {
        UI32_T value;
        if (SWCTRL_POM_GetPrivateVlanStatus(&value))
        {
            long_return=value;
            /* shumin.wang fix bug for ES2628BT-FLF-ZZ-00419 */
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *)&long_return, sizeof(long_return));
        }
        else
        {
            if(SNMP_MGR_IsDebugMode())
                printf("do_privateVlanStatus:SWCTRL_GetPrivateVlanStatus return false\n");
            return SNMP_ERR_GENERR;
        }
        break;
     }
        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
            }
            break;

        case MODE_SET_RESERVE2:
            switch (*requests->requestvb->val.integer)
            {
                case VAL_privateVlanStatus_enabled:
                    break;

                case VAL_privateVlanStatus_disabled:
                    break;

                default:
                    netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            }
            break;

    case MODE_SET_FREE:
        /*
         * XXX: free resources allocated in RESERVE1 and/or
         * RESERVE2.  Something failed somewhere, and the states
         * below won't be called.
         */
        break;

    case MODE_SET_ACTION:
    {
       /*
        * XXX: perform the value change here
        */
       UI32_T value;
       value = *requests->requestvb->val.integer;
       if(SNMP_MGR_IsDebugMode())
          printf("do_privateVlanStatus:value=[%lu]\n", (unsigned long)value);
       switch(value)
       {
            case VAL_privateVlanStatus_enabled:
                if (SWCTRL_PMGR_EnablePrivateVlan() != TRUE)
                {
                    if(SNMP_MGR_IsDebugMode())
                        printf("do_privateVlanStatus:SWCTRL_EnablePrivateVlan return false\n");
                    netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
                }
                break;
            case VAL_privateVlanStatus_disabled:
                if (SWCTRL_PMGR_DisablePrivateVlan() != TRUE)
                {
                    if(SNMP_MGR_IsDebugMode())
                        printf("do_privateVlanStatus:SWCTRL_DisablePrivateVlan return false\n");
                    netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
                }
                break;
            default:
                if(SNMP_MGR_IsDebugMode())
                    printf("do_privateVlanStatus:unknow value\n");
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
                break;
       }
       break;
     }
    case MODE_SET_COMMIT:
        break;
    case MODE_SET_UNDO:
        break;
    default:
        /*
         * we should never get here, so this is a really bad error
         */
        return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}

#if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE == SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE_MULTIPLE_SESSION)
/********************************************
 **********privateVlanSessionTable***********
 ********************************************
 */
#define privateVlanSessionEntry_INSTANCE_LEN  1
#define privateVlanSessionEntry_OID_NAME_LEN    (SNMP_MGR_Get_PrivateMibRootLen() + 6)


static BOOL_T privateVlanSessionTable_get(int      compc,
                                oid     *compl,
                                UI32_T  *session_id,
                                UI8_T  uplink_port_list  [SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST],
                                UI8_T  downlink_port_list[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST])
{

    if (compc !=privateVlanSessionEntry_INSTANCE_LEN)
    {
        return FALSE;
    }
    *session_id = compl[0];

    if (SWCTRL_POM_GetPrivateVlanBySessionId(*session_id, uplink_port_list, downlink_port_list)!=TRUE)
    {
        return FALSE;
    }
    else
    {
        return TRUE;

    } /*End of if */
}

static BOOL_T privateVlanSessionTable_next(int      compc,
                                oid     *compl,
                                UI32_T  *session_id,
                                UI8_T  uplink_port_list  [SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST],
                                UI8_T  downlink_port_list[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST])
{
    oid tmp_compl[privateVlanSessionEntry_INSTANCE_LEN];

    memcpy(tmp_compl, compl, sizeof(tmp_compl));
    SNMP_MGR_ConvertRemainToZero(compc,privateVlanSessionEntry_INSTANCE_LEN, tmp_compl);
    *session_id = tmp_compl[0];

    if (compc<privateVlanSessionEntry_INSTANCE_LEN)
    {
        if (SWCTRL_POM_GetPrivateVlanBySessionId(*session_id, uplink_port_list, downlink_port_list)!=TRUE)
        {
            if (SWCTRL_POM_GetNextSessionFromPrivateVlanPortList(session_id, uplink_port_list, downlink_port_list)!=TRUE)
            {
                return FALSE;
            }
        }
    }
    else
    {
        if (SWCTRL_POM_GetNextSessionFromPrivateVlanPortList(session_id, uplink_port_list, downlink_port_list)!=TRUE)
        {
            return FALSE;
        }
    }
    return TRUE;
}

/*
 * var_privateVlanSessionTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_privateVlanSessionTable(struct variable *vp,
                          oid * name,
                          size_t * length,
                          int exact,
                          size_t * var_len, WriteMethod ** write_method)
{
    UI32_T compc=0;
    UI32_T session_id=0;
    oid compl[privateVlanSessionEntry_INSTANCE_LEN];
    oid best_inst[privateVlanSessionEntry_INSTANCE_LEN];
    UI8_T  uplink_port_list  [SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST];
    UI8_T  downlink_port_list[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST];

   /*Since this table allow for entry that does not exist, (creation). we need to know the write method first*/
    switch (vp->magic)
    {
        case PRIVATEVLANSESSIONUPLINKPORTS:
            *write_method = write_privateVlanSessionUplinkPorts;
            break;
        case PRIVATEVLANSESSIONDOWNLINKPORTS:
            *write_method = write_privateVlanSessionDownlinkPorts;
            break;
        case PRIVATEVLANSESSIONSTATUS:
            *write_method = write_privateVlanSessionStatus;
            break;
        default:
            *write_method =0;
             break;
    }

    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,compl, privateVlanSessionEntry_INSTANCE_LEN);

     /*check compc, retrive compl*/
    if (exact)/*get,set*/
    {
        if (privateVlanSessionTable_get(compc, compl, &session_id, uplink_port_list, downlink_port_list)!=TRUE)
        {
            return NULL;
        }
    }
    else/*getnext*/
    {
        if (privateVlanSessionTable_next(compc, compl, &session_id, uplink_port_list, downlink_port_list)!=TRUE)
        {
            return NULL;
        }
    }
    memcpy(name, vp->name, vp->namelen*sizeof(oid));
    best_inst[0]=session_id;
    memcpy(name + vp->namelen, best_inst, privateVlanSessionEntry_INSTANCE_LEN*sizeof(oid));
    *length = vp->namelen + privateVlanSessionEntry_INSTANCE_LEN;

    *var_len = sizeof(long_return);

    /* this is where we do the value assignments for the mib results. */
    switch (vp->magic)
    {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case PRIVATEVLANSESSIONID:
            *var_len = sizeof(long_return);
            long_return = session_id
            return (u_char *) &long_return;

#endif
        case PRIVATEVLANSESSIONUPLINKPORTS:
            *var_len = SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST;
            memcpy(return_buf, uplink_port_list, *var_len);
            return (u_char*)return_buf;

        case PRIVATEVLANSESSIONDOWNLINKPORTS:
            *var_len = SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST;
            memcpy(return_buf, downlink_port_list, *var_len);
            return (u_char*)return_buf;

        case PRIVATEVLANSESSIONSTATUS:
            *var_len = sizeof(long_return);
            long_return = VAL_privateVlanStatus_enabled;
            return (u_char *) &long_return;

        default:
            ERROR_MSG("");
    }
    return NULL;
}

int
write_privateVlanSessionUplinkPorts(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_OCTET_STR)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len != SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST)
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;

        case RESERVE2:
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI8_T  uplink_port_list[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST] = {0};
            UI8_T  downlink_port_list[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST] = {0};
            UI8_T  zero_port_list[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST] = {0};
            UI32_T session_id = 0;

            session_id = name[privateVlanSessionEntry_OID_NAME_LEN];

            /* Basing on swctrl behavior, we must remove original port list, then add new port list.
             */
            if (SWCTRL_POM_GetPrivateVlanBySessionId( session_id, uplink_port_list, downlink_port_list) != TRUE)
            {
                return SNMP_ERR_COMMITFAILED;
            }
            /* if original uplink_port_list is zero, then it doesn't remove.
             */
            else if (memcmp(uplink_port_list, zero_port_list, SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST) > 0)
            {
                if (SWCTRL_PMGR_DeletePrivateVlanPortlistBySessionId( session_id, uplink_port_list, downlink_port_list) != TRUE)
                {
                    return SNMP_ERR_COMMITFAILED;
                }
            }

            memcpy(uplink_port_list, var_val, var_val_len);

            if (SWCTRL_PMGR_SetPrivateVlanBySessionId( session_id, uplink_port_list, downlink_port_list) != TRUE)
            {
                return SNMP_ERR_COMMITFAILED;
            }
        }
            break;

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

int
write_privateVlanSessionDownlinkPorts(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_OCTET_STR)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len != SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST)
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;

        case RESERVE2:
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI8_T  uplink_port_list[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST] = {0};
            UI8_T  downlink_port_list[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST] = {0};
            UI8_T  zero_port_list[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST] = {0};
            UI32_T session_id = 0;

            session_id = name[privateVlanSessionEntry_OID_NAME_LEN];
            /* Basing on swctrl behavior, we must remove original port list, then add new port list.
             */
            if (SWCTRL_POM_GetPrivateVlanBySessionId( session_id, uplink_port_list, downlink_port_list) != TRUE)
            {
                return SNMP_ERR_COMMITFAILED;
            }
            /* if original uplink_port_list is zero, then it doesn't remove.
             */
            else if (memcmp(uplink_port_list, zero_port_list, SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST) > 0)
            {
                if (SWCTRL_PMGR_DeletePrivateVlanPortlistBySessionId( session_id, uplink_port_list, downlink_port_list) != TRUE)
                {
                    return SNMP_ERR_COMMITFAILED;
                }
            }

            memcpy(downlink_port_list, var_val, var_val_len);

            if (SWCTRL_PMGR_SetPrivateVlanBySessionId( session_id, uplink_port_list, downlink_port_list) != TRUE)
                return SNMP_ERR_COMMITFAILED;
        }
            break;

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

int
write_privateVlanSessionStatus(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            switch (*(long *)var_val)
            {
                case VAL_privateVlanSessionStatus_valid:
                    break;

                case VAL_privateVlanSessionStatus_invalid:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI8_T  uplink_port_list[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST] = {0};
            UI8_T  downlink_port_list[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST] = {0};
            UI32_T session_id = 0;
            UI32_T session_status = *(long *) var_val;

            session_id = name[privateVlanSessionEntry_OID_NAME_LEN];

            if(session_status == VAL_privateVlanSessionStatus_valid)
            {
                if (SWCTRL_PMGR_SetPrivateVlanBySessionId( session_id, uplink_port_list, downlink_port_list) != TRUE)
                {
                    return SNMP_ERR_COMMITFAILED;
                }
            }
            else
            {
                /* SWCTRL_PMGR_DestroyPrivateVlanSession( session_id, TRUE, TRUE) means delete this session_id
                 */
                if (SWCTRL_PMGR_DestroyPrivateVlanSession( session_id, TRUE, TRUE) != TRUE)
                {
                    return SNMP_ERR_COMMITFAILED;
                }
            }
        }
            break;

        case UNDO:
          break;

        case COMMIT:
          break;
    }

    return SNMP_ERR_NOERROR;
}

/********************************************
 *********privateVlanUplinkToUplink**********
 ********************************************
 */
int
do_privateVlanUplinkToUplink(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{

    switch(reqinfo->mode)
    {
        case MODE_GET:
        {
            UI32_T value = 0;

            if (SWCTRL_POM_GetPrivateVlanUplinkToUplinkStatus(&value)==TRUE)
            {
                long_return = value;
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER , (u_char *)&long_return , sizeof(long_return) );
            }
            else
            {
                return SNMP_ERR_GENERR;
            }
        }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:

            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
            }

            break;
        case MODE_SET_RESERVE2:

            switch ( *requests->requestvb->val.integer )
            {
                case VAL_privateVlanUplinkToUplink_blocking:
                    break;
                case VAL_privateVlanUplinkToUplink_forwarding:
                    break;
                default:
                    netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
        {
            UI32_T mode = (UI32_T) *requests->requestvb->val.integer;

            if(mode == VAL_privateVlanUplinkToUplink_blocking)
            {
                if (SWCTRL_PMGR_EnablePrivateVlanUplinkToUplinkBlockingMode()!=TRUE)
                {
                    netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
                }
            }
            else
            {
                if (SWCTRL_PMGR_DisablePrivateVlanUplinkToUplinkBlockingMode()!=TRUE)
                {
                    netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
                }
            }

        }
            break;

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
#endif /* end of #if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE == SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE_MULTIPLE_SESSION) */

#if (SYS_DFLT_TRAFFIC_SEG_METHOD == SYS_DFLT_TRAFFIC_SEG_METHOD_PORT_PRIVATE_MODE)

#define PRIVATEVLANEDGEPORTENTRY_INSTANCE_LEN  1

BOOL_T privateVlanEdgePortTable_OidIndexToData(UI32_T exact, UI32_T compc,
            oid * compl,  UI32_T *pvePortIfIndex)
{
    /* get or write */
    if (exact)
    {
        /* check the index length */
        if (compc != PRIVATEVLANEDGEPORTENTRY_INSTANCE_LEN) /* the constant size index */
        {
            return FALSE;
        }
    }
    *pvePortIfIndex = compl[0];
    return TRUE;
}

/*
 * var_privateVlanEdgePortTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *
var_privateVlanEdgePortTable(struct variable *vp,
            oid     *name,
            size_t  *length,
            int     exact,
            size_t  *var_len,
            WriteMethod **write_method)
{
    /* variables we may use later */
    UI32_T compc = 0;
    oid compl[PRIVATEVLANEDGEPORTENTRY_INSTANCE_LEN] = {0};
    oid best_inst[PRIVATEVLANEDGEPORTENTRY_INSTANCE_LEN] = {0};
    UI32_T  ifIndex;
    UI32_T  status;

    switch (vp->magic)
    {
        case LEAF_pvePortStatus:
            *write_method = write_pvePortStatus;
            break;

        default:
            *write_method = 0;
            break;
    }

    /* check compc, retrive compl */
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,
                           compl, PRIVATEVLANEDGEPORTENTRY_INSTANCE_LEN);

    if (exact) /* get,set */
    {
        /* get index */
        if (privateVlanEdgePortTable_OidIndexToData(exact, compc, compl,  &ifIndex) == FALSE)
        {
            return NULL;
        }

        /* get data */
        if (SWCTRL_POM_GetPortPrivateMode(ifIndex, &status)!= TRUE)
        {
            return NULL;
        }
    }
    else /* getnext */
    {
        /* get index */
        privateVlanEdgePortTable_OidIndexToData(exact, compc, compl,  &ifIndex);

        /* check the length of inputing index,if < 1 we should try get
         * {0.0.0.0.0...}
         */
        if (compc < 1)
        {
            /* get data */
            if (SWCTRL_POM_GetPortPrivateMode(ifIndex, &status) != TRUE)
            {
                /* get next data */
                if (SWCTRL_POM_GetNextPortPrivateMode(&ifIndex, &status) != TRUE)
                {
                    return NULL;
                }
            }
        }
        else
        {
            /* get next data */
            if (SWCTRL_POM_GetNextPortPrivateMode(&ifIndex, &status) != TRUE)
            {
                return NULL;
            }
        }
    }

    memcpy(name, vp->name, vp->namelen*sizeof(oid));

    /* assign data to the oid index */
    best_inst[0] = ifIndex;
    memcpy(name + vp->namelen, best_inst,
           PRIVATEVLANEDGEPORTENTRY_INSTANCE_LEN * sizeof(oid));
    *length = vp->namelen + PRIVATEVLANEDGEPORTENTRY_INSTANCE_LEN ;

    /* this is where we do the value assignments for the mib results. */
    switch (vp->magic)
    {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case LEAF_pvePortIfIndex:
            *var_len = sizeof(long_return);
            long_return = ifIndex;
            return (u_char *) &long_return;

#endif
        case LEAF_pvePortStatus:
            *var_len = sizeof(long_return);
            long_return = status;
            return (u_char *) &long_return;

        default:
            ERROR_MSG("");
    }

    return NULL;
}

int
write_pvePortStatus(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            switch (*(long *)var_val)
            {
                case VAL_pvePortStatus_enabled:
                    break;

                case VAL_pvePortStatus_disabled:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
            I32_T value = 0;
            UI32_T pvePortIfIndex = 0;

            if (privateVlanEdgePortTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &pvePortIfIndex) == FALSE)
                return SNMP_ERR_COMMITFAILED;

            value = *(long *)var_val;

            if (SWCTRL_PMGR_SetPortPrivateMode( pvePortIfIndex, value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
        }
            break;

        case UNDO:
          break;

        case COMMIT:
          break;
    }

    return SNMP_ERR_NOERROR;
}

#endif    /* #if (SYS_DFLT_TRAFFIC_SEG_METHOD == SYS_DFLT_TRAFFIC_SEG_METHOD_PORT_PRIVATE_MODE) */


#endif/*end of #if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION==TRUE)*/

#if (SYS_CPNT_PORT_SECURITY==TRUE)
/********************************************
 ************portSecPortTable****************
 ********************************************
 */
static int
header_portSecPortTable(struct variable *vp,
               oid * name,
               size_t * length,
               int exact, size_t * var_len, WriteMethod ** write_method,
               PSEC_MGR_PortSecurityEntry_T  *entry)
{
   unsigned int ifIndex = 0;

    if(!entry || l_snmp_index_get(vp,name,length,&ifIndex,exact) < 0 )
       return MATCH_FAILED;

    /*
     * find "next" interface
     */

    entry->portsec_port_index = ifIndex;
    if(!exact)
    {
     if (PSEC_PMGR_GetNextPortSecurityEntry(entry)!=TRUE)
       return MATCH_FAILED;

     l_snmp_index_set(vp,name,length,entry->portsec_port_index);

   }
   else
   {
       if(PSEC_PMGR_GetPortSecurityEntry(entry)!=TRUE)
           return MATCH_FAILED;
   }

    *write_method = 0;
    *var_len = sizeof(long);    /* default to 'long' results */

    return entry->portsec_port_index;
}


/*
 * var_portSecPortTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *
var_portSecPortTable(struct variable *vp,
            oid     *name,
            size_t  *length,
            int     exact,
            size_t  *var_len,
            WriteMethod **write_method)
{
   PSEC_MGR_PortSecurityEntry_T  entry;

   memset( &entry, 0, sizeof(entry));

    if(MATCH_FAILED==header_portSecPortTable(vp, name, length, exact, var_len, write_method,&entry))
        return NULL;

    /*
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    case PORTSECPORTINDEX:
        long_return = entry.portsec_port_index;
        return (u_char*) &long_return;
#endif
    case PORTSECPORTSTATUS:
     *write_method = write_portSecPortStatus;
     long_return = entry.portsec_port_status;
     return (u_char*) &long_return;


    case PORTSECACTION:
    {
        UI32_T status;
        *write_method = write_portSecAction;

        if (PSEC_PMGR_GetPortSecurityActionStatus(entry.portsec_port_index, &status) != TRUE)
            return NULL;
        long_return = status;
        return (u_char*) &long_return;
    }
    case PORTSECMAXMACCOUNT:
    {
        UI32_T PortSecMaxMacCount;

        *write_method = write_portSecMaxMacCount;

        if(PSEC_PMGR_GetPortSecurityMacCount(entry.portsec_port_index, &PortSecMaxMacCount) != TRUE)
            return NULL;

        long_return = PortSecMaxMacCount;
        return (u_char*) &long_return;
    }
    case PORTSECLEARNINGSTATUS:
    {
        UI32_T status;
        *write_method = write_portSecLearningStatus;

        if(!PSEC_PMGR_GetPortSecurityLearningStatus(entry.portsec_port_index, &status))
        {
            return NULL;
        }

        long_return = status;
        return (u_char*) &long_return;
    }

    default:
      ERROR_MSG("");
    }
    return NULL;
}


int
write_portSecPortStatus(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int oid_name_length;

    oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          value = *(long *)var_val;
          if ((value <1) || (value >2))
             return SNMP_ERR_WRONGVALUE;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
                    value = * (long *) var_val;

#if (SYS_CPNT_NETACCESS == TRUE)
               if (NETACCESS_PMGR_SetPortSecurityStatus(name[oid_name_length], value) != TRUE)
#else
               if (PSEC_PMGR_SetPortSecurityStatus(name[oid_name_length], value) != TRUE)
#endif
                 return SNMP_ERR_COMMITFAILED;
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_portSecAction(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int oid_name_length;

    oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          value = *(long *)var_val;
          if ((value <VAL_portSecAction_none) || (value >VAL_portSecAction_trapAndShutdown))
             return SNMP_ERR_WRONGVALUE;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
                    value = * (long *) var_val;

#if (SYS_CPNT_NETACCESS == TRUE)
               if (NETACCESS_PMGR_SetPortSecurityActionStatus(name[oid_name_length], value) != TRUE)
#else
               if (PSEC_PMGR_SetPortSecurityActionStatus(name[oid_name_length], value) != TRUE)
#endif
                 return SNMP_ERR_COMMITFAILED;
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_portSecMaxMacCount(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int oid_name_length;

    oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          value = *(long *)var_val;
          if ((value <MIN_portSecMaxMacCount) || (value >MAX_portSecMaxMacCount))
             return SNMP_ERR_WRONGVALUE;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
                    value = * (long *) var_val;

#if (SYS_CPNT_NETACCESS == TRUE)
               if (NETACCESS_PMGR_SetPortSecurityMaxMacCount(name[oid_name_length], value) != TRUE)
#else
               if (PSEC_PMGR_SetPortSecurityMacCount(name[oid_name_length], value) != TRUE)
#endif
                 return SNMP_ERR_COMMITFAILED;
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_portSecLearningStatus(int action,
                            u_char * var_val,
                            u_char var_val_type,
                            size_t var_val_len,
                            u_char * statP, oid * name, size_t name_len)
{
    long value;
    int oid_name_length;

    oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len !=  1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch ( action )
    {
        case RESERVE1:
        {
            if(var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }

            if(var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }

            break;
        }

        case RESERVE2:
        {
            value = *(long *)var_val;

            if((value < VAL_portSecLearningStatus_enabled) || (value > VAL_portSecLearningStatus_disabled))
                return SNMP_ERR_WRONGVALUE;

            break;
        }
        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */

            value = *(long *)var_val;

            if(PSEC_PMGR_SetPortSecurityLearningStatus(name[oid_name_length], value) != TRUE)
                return SNMP_ERR_COMMITFAILED;

            break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }

    return SNMP_ERR_NOERROR;
}

/********************************************
 *******portSecMacAsPermanentMgt********
 ********************************************
 */

static UI32_T portSecMacAsPermanentPortIndex = PSEC_MGR_INTERFACE_INDEX_FOR_ALL;

int
do_portSecMacAsPermanentPortIndex(netsnmp_mib_handler *handler,
                                  netsnmp_handler_registration *reginfo,
                                  netsnmp_agent_request_info *reqinfo,
                                  netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.
     */

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one.
     */

    switch(reqinfo->mode)
    {
        case MODE_GET:
            {
                long_return = portSecMacAsPermanentPortIndex;
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
            }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
            }

            if (requests->requestvb->val_len > SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST * sizeof(char))
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGLENGTH);
            }
            break;

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called.
             */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here
             */
            {
                UI32_T value;
                value = (*requests->requestvb->val.integer);
                portSecMacAsPermanentPortIndex = value;
            }
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage
             */

            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object
             */

            break;

        default:
            /* we should never get here, so this is a really bad error
             */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_portSecMacAsPermanentAction(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.
     */

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one.
     */

    switch(reqinfo->mode)
    {
        case MODE_GET:
            {
                long_return = VAL_portSecMacAsPermanentAction_noAction;
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
            }
            break;
        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
            }
            break;

        case MODE_SET_RESERVE2:
            switch (*requests->requestvb->val.integer)
            {
                case VAL_portSecMacAsPermanentAction_noAction:
                    break;

                case VAL_portSecMacAsPermanentAction_action:
                    break;

                default:
                    netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
             *  RESERVE2.  Something failed somewhere, and the states
             *  below won't be called.
             */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here
             */
            {
#if (SYS_CPNT_NETACCESS == TRUE)
                if (TRUE != NETACCESS_PMGR_ConvertPortSecuritySecuredAddressIntoManual(portSecMacAsPermanentPortIndex))
#else
                if (TRUE != PSEC_PMGR_ConvertSecuredAddressIntoManual(portSecMacAsPermanentPortIndex))
#endif
                {
                    return SNMP_ERR_COMMITFAILED;
                }

                portSecMacAsPermanentPortIndex = PSEC_MGR_INTERFACE_INDEX_FOR_ALL;
            }
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage
             */

            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object
             */

            break;

        default:
            /* we should never get here, so this is a really bad error
             */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
#endif

#if (SYS_CPNT_PFU == TRUE)
/********************************************
 **********packetFilterUnitMgt***************
 ********************************************
 */
int
do_pfuInsert(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
        /* when get, always return 0*/
                  long_return = 0;
                  snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
                  break;
        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
         {
         UI32_T value;
          value = *requests->requestvb->val.integer;

          if ((value< MIN_pfuInsert) || (value>MAX_pfuInsert))
              netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
        }
        break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */

            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
          {
           UI32_T value;
          value = *requests->requestvb->val.integer;

        if (PFU_MGR_InsertRuleEntry(value)!= TRUE)
          netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);

       }

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */

            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */

            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
get_pfuNextAvailable(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
        {
            UI32_T value = 0;


        /* Values:
           *  enabled(1)  = VAL_switchJumboFrameStatus_enabled
           *  disabled(2) = VAL_switchJumboFrameStatus_disabled
           */
            PFU_MGR_GetNextAvailable(&value);

            long_return = value;
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *)&long_return, sizeof(long_return));
        }
            break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

/********************************************
 ****************pfuRuleTable****************
 ********************************************
 */
static int
header_pfuRuleTable(struct variable *vp,
               oid * name,
               size_t * length,
               int exact, size_t * var_len, WriteMethod ** write_method)
{
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    oid             newname[MAX_OID_LEN];
    int    interface;
    int             result;
   PFU_TYPE_RuleEntry_T  entry;
   int ifIndex = 0;
   BOOL_T return_val;


    memcpy((char *) newname, (char *) vp->name,
           (int) vp->namelen * sizeof(oid));
    /*
     * find "next" interface
     */


     while (  return_val= PFU_MGR_GetNextRuleEntry( &ifIndex, &entry))
     {

        newname[oid_name_length] = (oid) ifIndex;
        result =
            snmp_oid_compare(name, *length, newname,
                             (int) vp->namelen + 1);
        if ((exact && (result == 0)) || (!exact && (result < 0)))
            break;
    }
    if (!return_val ) {

        return MATCH_FAILED;
    }


    memcpy((char *) name, (char *) newname,
           ((int) vp->namelen + 1) * sizeof(oid));
    *length = vp->namelen + 1;
    *var_len = sizeof(long);    /* default to 'long' results */
    interface = newname[oid_name_length];



    return interface;
}

/* This entry is used for entry which have the ability to row create*/
static PFU_TYPE_RuleEntry_T pfuRuleEntry;

/*
 * var_pfuRuleTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *
var_pfuRuleTable(struct variable *vp,
            oid     *name,
            size_t  *length,
            int     exact,
            size_t  *var_len,
            WriteMethod **write_method)
{
   PFU_TYPE_RuleEntry_T  entry;
    int             interface;

    /* Give default value for the record first.
     * We use the row_status = 0 to indicate if this set operation is Set by field
     * or set by record(included row creation), if the row_status =0, this record
     * mean set by field, otherwise, we just think it is a normal set operation
     */
    pfuRuleEntry.pfu_rule_precedence=0;
    pfuRuleEntry.pfu_rule_action=VAL_pfuRuleAction_deny;
    pfuRuleEntry.pfu_protocol=PFU_TYPE_IP_PROTOCOL_ANY ;
    pfuRuleEntry.pfu_srcip_addr=0;
    pfuRuleEntry.pfu_srcip_bitmask=0;
    pfuRuleEntry.pfu_dstip_addr=0;
    pfuRuleEntry.pfu_dstip_bitmask=0;
    pfuRuleEntry.pfu_sport_range1=PFU_TYPE_SPORT_ANY;
    pfuRuleEntry.pfu_sport_range2=PFU_TYPE_SPORT_ANY;
    entry.pfu_dport_range1=PFU_TYPE_SPORT_ANY;
    pfuRuleEntry.pfu_dport_range2=PFU_TYPE_SPORT_ANY;
    pfuRuleEntry.pfu_tcp_code=PFU_TYPE_TCP_CODE_DEFAULT;
    pfuRuleEntry.pfu_tcp_code_bitmask=PFU_TYPE_TCP_CODE_BITMASK_DEFAULT;
    pfuRuleEntry.pfu_rule_log=VAL_pfuRuleLog_disabled;
    pfuRuleEntry.pfu_rule_fragments=VAL_pfuRuleFragments_disabled;
    pfuRuleEntry.pfu_row_status= 0;

   switch(vp->magic) {

    case PFURULEACTION:
        *write_method = write_pfuRuleAction;
        break;
   case  PFURULEPROTOCOL:
        *write_method = write_pfuRuleProtocol;
        break;
   case PFURULESRCIPADDR:
        *write_method = write_pfuRuleSrcIpAddr;
       break;
    case PFURULESRCIPBITMASK:
        *write_method = write_pfuRuleSrcIpBitmask;
        break;
    case PFURULESRCPORTRANGE1:
        *write_method = write_pfuRuleSrcPortRange1;
        break;
    case PFURULESRCPORTRANGE2:
        *write_method = write_pfuRuleSrcPortRange2;
       break;
    case PFURULEDSTIPADDR:
        *write_method = write_pfuRuleDstIpAddr;
        break;
    case PFURULEDSTIPBITMASK:
        *write_method = write_pfuRuleDstIpBitmask;
        break;
    case PFURULEDSTPORTRANGE1:
        *write_method = write_pfuRuleDstPortRange1;
        break;
   case PFURULEDSTPORTRANGE2:
        *write_method = write_pfuRuleDstPortRange2;
        break;
    case PFURULETCPCODE:
        *write_method = write_pfuRuleTcpCode;
        break;
    case PFURULETCPCODEBITMASK:
        *write_method = write_pfuRuleTcpCodeBitmask;
        break;
    case PFURULEFRAGMENTS:
        *write_method = write_pfuRuleFragments;
        break;
    case PFURULELOG:
        *write_method = write_pfuRuleLog;
        break;
    case PFURULEROWSTATUS:
        *write_method = write_pfuRuleRowStatus;
        break;
    default:
         *write_method =0;
         break;
     }
   memset( &entry, 0, sizeof(entry));
    interface =
        header_pfuRuleTable(vp, name, length, exact, var_len, write_method);
    if (interface == MATCH_FAILED)
        return NULL;


   if (PFU_MGR_GetRuleEntry( interface, &entry)!= TRUE)
            return NULL;
    /*
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    case PFURULEINDEX:
        long_return = interface;
        return (u_char*) &long_return;
#endif
    case PFURULEACTION:
       long_return = entry.pfu_rule_action;
        return (u_char*) &long_return;
   case  PFURULEPROTOCOL:
        long_return = entry.pfu_protocol;
        return (u_char*) &long_return;
   case PFURULESRCIPADDR:
        *var_len = sizeof(ipaddr_return);
        ipaddr_return = entry.pfu_srcip_addr;
        return (u_char*) &ipaddr_return;
    case PFURULESRCIPBITMASK:
        *var_len = sizeof(ipaddr_return);
        ipaddr_return = entry.pfu_srcip_bitmask;
        return (u_char*) &ipaddr_return;
    case PFURULESRCPORTRANGE1:
         long_return = entry.pfu_sport_range1;
        return (u_char*) &long_return;
    case PFURULESRCPORTRANGE2:
         long_return = entry.pfu_sport_range2;
        return (u_char*) &long_return;
    case PFURULEDSTIPADDR:
        *var_len = sizeof(ipaddr_return);
        ipaddr_return = entry.pfu_dstip_addr;
        return (u_char*) &ipaddr_return;
    case PFURULEDSTIPBITMASK:
        *var_len = sizeof(ipaddr_return);
        ipaddr_return = entry.pfu_dstip_bitmask;
        return (u_char*) &ipaddr_return;
    case PFURULEDSTPORTRANGE1:
         long_return = entry.pfu_dport_range1;
        return (u_char*) &long_return;
   case PFURULEDSTPORTRANGE2:
        long_return = entry.pfu_dport_range2;
        return (u_char*) &long_return;
    case PFURULETCPCODE:
         long_return = entry.pfu_tcp_code;
        return (u_char*) &long_return;
    case PFURULETCPCODEBITMASK:
        long_return = entry.pfu_tcp_code_bitmask;
        return (u_char*) &long_return;
    case PFURULEFRAGMENTS:
         long_return = entry.pfu_rule_fragments;
        return (u_char*) &long_return;
    case PFURULELOG:
         long_return = entry.pfu_rule_log;
        return (u_char*) &long_return;
    case PFURULEROWSTATUS:
        long_return = entry.pfu_row_status;
        return (u_char*) &long_return;
    default:
      ERROR_MSG("");
    }
    return NULL;
}


int
write_pfuRuleAction(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
     UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
   /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
           /* In reserve2, we overwrite the set value to pfuRuleEntry*/
          pfuRuleEntry.pfu_rule_action = *(long *)var_val;
          if ((pfuRuleEntry.pfu_rule_action <1) || (pfuRuleEntry.pfu_rule_action >2))
             return SNMP_ERR_WRONGVALUE;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
        {
           /* For row creation, if row_status =0, mean that this is a normal
            * operation, we do the normal set operation, otherwise it is a row
            * creation operation, will do nothing here, and the overall entry
            * will perform in the write_xxxRowStatus function.
              */
            PFU_TYPE_RuleEntry_T ord_entry;
            if (pfuRuleEntry.pfu_row_status == 0)
              {
                  if (PFU_MGR_GetRuleEntry(name[oid_name_length], &ord_entry)!=TRUE)
                 {
                      return SNMP_ERR_COMMITFAILED;
                 }
                 ord_entry.pfu_rule_action= pfuRuleEntry.pfu_rule_action;

               if (PFU_MGR_SetRuleEntry(name[oid_name_length], &ord_entry) != TRUE)
                 {
                 return SNMP_ERR_COMMITFAILED;
             }
             }
         }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_pfuRuleProtocol(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
   /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          /* In reserve2, we overwrite the set value to pfuRuleEntry*/
          pfuRuleEntry.pfu_protocol = *(long *)var_val;
          if ((pfuRuleEntry.pfu_protocol <0) || (pfuRuleEntry.pfu_protocol >256))
             return SNMP_ERR_WRONGVALUE;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
        {
           /* For row creation, if row_status =0, mean that this is a normal
            * operation, we do the normal set operation, otherwise it is a row
            * creation operation, will do nothing here, and the overall entry
            * will perform in the write_xxxRowStatus function.
              */
            PFU_TYPE_RuleEntry_T ord_entry;
            if (pfuRuleEntry.pfu_row_status == 0)
               {
                  if (PFU_MGR_GetRuleEntry(name[oid_name_length], &ord_entry)!=TRUE)
                      return SNMP_ERR_COMMITFAILED;

                   ord_entry.pfu_protocol= pfuRuleEntry.pfu_protocol;

               if (PFU_MGR_SetRuleEntry(name[oid_name_length], &ord_entry) != TRUE)
                 return SNMP_ERR_COMMITFAILED;
             }
         }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_pfuRuleSrcIpAddr(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{

    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
   /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_IPADDRESS) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len !=  SYS_ADPT_IPV4_ADDR_LEN)
          {
        return SNMP_ERR_WRONGLENGTH;
      }
          break;

        case RESERVE2:
          /* In reserve2, we overwrite the set value to pfuRuleEntry*/
          memcpy(pfuRuleEntry.pfu_srcip_addr, var_val, var_val_len);
          if (!IP_LIB_IsValidForNetworkInterface(pfuRuleEntry.pfu_srcip_addr))
          {
             return SNMP_ERR_WRONGVALUE;
          }
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
           /* For row creation, if row_status =0, mean that this is a normal
            * operation, we do the normal set operation, otherwise it is a row
            * creation operation, will do nothing here, and the overall entry
            * will perform in the write_xxxRowStatus function.
              */
          {
               PFU_TYPE_RuleEntry_T ord_entry;
            if (pfuRuleEntry.pfu_row_status == 0)
            {
                  if (PFU_MGR_GetRuleEntry(name[oid_name_length], &ord_entry)!=TRUE)
                 {
                      return SNMP_ERR_COMMITFAILED;
                 }
                 ord_entry.pfu_srcip_addr= pfuRuleEntry.pfu_srcip_addr;

               if (PFU_MGR_SetRuleEntry(name[oid_name_length], &ord_entry) != TRUE)
                 {
                 return SNMP_ERR_COMMITFAILED;
             }
             }
         }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_pfuRuleSrcIpBitmask(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{

    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
   /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_IPADDRESS) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len !=  SYS_ADPT_IPV4_ADDR_LEN)
      {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
         /* In reserve2, we overwrite the set value to pfuRuleEntry*/
          memcpy(&pfuRuleEntry.pfu_srcip_bitmask, var_val, var_val_len);
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
           /* For row creation, if row_status =0, mean that this is a normal
            * operation, we do the normal set operation, otherwise it is a row
            * creation operation, will do nothing here, and the overall entry
            * will perform in the write_xxxRowStatus function.
              */
              {
               PFU_TYPE_RuleEntry_T ord_entry;
            if (pfuRuleEntry.pfu_row_status == 0)
            {
                  if (PFU_MGR_GetRuleEntry(name[oid_name_length], &ord_entry)!=TRUE)
                      return SNMP_ERR_COMMITFAILED;

                   ord_entry.pfu_srcip_bitmask= pfuRuleEntry.pfu_srcip_bitmask;

               if (PFU_MGR_SetRuleEntry(name[oid_name_length], &ord_entry) != TRUE)
                 return SNMP_ERR_COMMITFAILED;
             }
         }
          break;


        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_pfuRuleSrcPortRange1(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
   /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          /* In reserve2, we overwrite the set value to pfuRuleEntry*/
          pfuRuleEntry.pfu_sport_range1 = *(long *)var_val;
          if ((pfuRuleEntry.pfu_sport_range1 <0) || (pfuRuleEntry.pfu_sport_range1 >65536))
             return SNMP_ERR_WRONGVALUE;
          break;


        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
           /* For row creation, if row_status =0, mean that this is a normal
            * operation, we do the normal set operation, otherwise it is a row
            * creation operation, will do nothing here, and the overall entry
            * will perform in the write_xxxRowStatus function.
              */
                 {
               PFU_TYPE_RuleEntry_T ord_entry;

            if (pfuRuleEntry.pfu_row_status == 0)
            {
                  if (PFU_MGR_GetRuleEntry(name[oid_name_length], &ord_entry)!=TRUE)
                      return SNMP_ERR_COMMITFAILED;

                   ord_entry.pfu_sport_range1= pfuRuleEntry.pfu_sport_range1;

               if (PFU_MGR_SetRuleEntry(name[oid_name_length], &ord_entry) != TRUE)
                 return SNMP_ERR_COMMITFAILED;
             }
         }
          break;


        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_pfuRuleSrcPortRange2(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
   /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
           /* In reserve2, we overwrite the set value to pfuRuleEntry*/
          pfuRuleEntry.pfu_sport_range2 = *(long *)var_val;
          if ((pfuRuleEntry.pfu_sport_range2 <0) || (pfuRuleEntry.pfu_sport_range2 >65536))
             return SNMP_ERR_WRONGVALUE;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
           /* For row creation, if row_status =0, mean that this is a normal
            * operation, we do the normal set operation, otherwise it is a row
            * creation operation, will do nothing here, and the overall entry
            * will perform in the write_xxxRowStatus function.
              */
            {
               PFU_TYPE_RuleEntry_T ord_entry;

            if (pfuRuleEntry.pfu_row_status == 0)
            {
                  if (PFU_MGR_GetRuleEntry(name[oid_name_length], &ord_entry)!=TRUE)
                      return SNMP_ERR_COMMITFAILED;

                   ord_entry.pfu_sport_range2= pfuRuleEntry.pfu_sport_range2;

               if (PFU_MGR_SetRuleEntry(name[oid_name_length], &ord_entry) != TRUE)
                 return SNMP_ERR_COMMITFAILED;
             }
        }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_pfuRuleDstIpAddr(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{

    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
   /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_IPADDRESS) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len !=  SYS_ADPT_IPV4_ADDR_LEN)
      {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
         /* In reserve2, we overwrite the set value to pfuRuleEntry*/
          memcpy(&pfuRuleEntry.pfu_dstip_addr, var_val, var_val_len);
          if (!IP_LIB_IsValidForNetworkInterface(pfuRuleEntry.pfu_dstip_addr))
          {
             return SNMP_ERR_WRONGVALUE;
          }
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
           /* For row creation, if row_status =0, mean that this is a normal
            * operation, we do the normal set operation, otherwise it is a row
            * creation operation, will do nothing here, and the overall entry
            * will perform in the write_xxxRowStatus function.
              */
              {
               PFU_TYPE_RuleEntry_T ord_entry;

            if (pfuRuleEntry.pfu_row_status == 0)
            {
                  if (PFU_MGR_GetRuleEntry(name[oid_name_length], &ord_entry)!=TRUE)
                      return SNMP_ERR_COMMITFAILED;

                   ord_entry.pfu_dstip_addr= pfuRuleEntry.pfu_dstip_addr;

               if (PFU_MGR_SetRuleEntry(name[oid_name_length], &ord_entry) != TRUE)
                 return SNMP_ERR_COMMITFAILED;
             }
          }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_pfuRuleDstIpBitmask(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
   /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_IPADDRESS) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len !=  SYS_ADPT_IPV4_ADDR_LEN)
      {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
         /* In reserve2, we overwrite the set value to pfuRuleEntry*/
          memcpy(&pfuRuleEntry.pfu_dstip_bitmask, var_val, var_val_len);
          break;
        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
           /* For row creation, if row_status =0, mean that this is a normal
            * operation, we do the normal set operation, otherwise it is a row
            * creation operation, will do nothing here, and the overall entry
            * will perform in the write_xxxRowStatus function.
              */
               {
               PFU_TYPE_RuleEntry_T ord_entry;

            if (pfuRuleEntry.pfu_row_status == 0)
            {
                  if (PFU_MGR_GetRuleEntry(name[oid_name_length], &ord_entry)!=TRUE)
                      return SNMP_ERR_COMMITFAILED;

                   ord_entry.pfu_dstip_bitmask= pfuRuleEntry.pfu_dstip_bitmask;

               if (PFU_MGR_SetRuleEntry(name[oid_name_length], &ord_entry) != TRUE)
                 return SNMP_ERR_COMMITFAILED;
             }
         }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_pfuRuleDstPortRange1(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{

    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
   /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
           /* In reserve2, we overwrite the set value to pfuRuleEntry*/
          pfuRuleEntry.pfu_dport_range1 = *(long *)var_val;
          if ((pfuRuleEntry.pfu_dport_range1 <0) || (pfuRuleEntry.pfu_dport_range1 >65536))
             return SNMP_ERR_WRONGVALUE;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
           /* For row creation, if row_status =0, mean that this is a normal
            * operation, we do the normal set operation, otherwise it is a row
            * creation operation, will do nothing here, and the overall entry
            * will perform in the write_xxxRowStatus function.
              */
         {
               PFU_TYPE_RuleEntry_T ord_entry;

            if (pfuRuleEntry.pfu_row_status == 0)
            {
                  if (PFU_MGR_GetRuleEntry(name[oid_name_length], &ord_entry)!=TRUE)
                      return SNMP_ERR_COMMITFAILED;

                   ord_entry.pfu_dport_range1= pfuRuleEntry.pfu_dport_range1;

               if (PFU_MGR_SetRuleEntry(name[oid_name_length], &ord_entry) != TRUE)
                 return SNMP_ERR_COMMITFAILED;
             }
        }
        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_pfuRuleDstPortRange2(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{

    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
   /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
         /* In reserve2, we overwrite the set value to pfuRuleEntry*/
          pfuRuleEntry.pfu_dport_range2 = *(long *)var_val;
          if ((pfuRuleEntry.pfu_dport_range2 <0) || (value >pfuRuleEntry.pfu_dport_range2))
             return SNMP_ERR_WRONGVALUE;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
           /* For row creation, if row_status =0, mean that this is a normal
            * operation, we do the normal set operation, otherwise it is a row
            * creation operation, will do nothing here, and the overall entry
            * will perform in the write_xxxRowStatus function.
              */
          {
               PFU_TYPE_RuleEntry_T ord_entry;

            if (pfuRuleEntry.pfu_row_status == 0)
            {
                  if (PFU_MGR_GetRuleEntry(name[oid_name_length], &ord_entry)!=TRUE)
                      return SNMP_ERR_COMMITFAILED;

                   ord_entry.pfu_dport_range2= pfuRuleEntry.pfu_dport_range2;

               if (PFU_MGR_SetRuleEntry(name[oid_name_length], &ord_entry) != TRUE)
                 return SNMP_ERR_COMMITFAILED;
             }
         }
        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_pfuRuleTcpCode(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;

    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
   /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }


    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
         /* In reserve2, we overwrite the set value to pfuRuleEntry*/
          pfuRuleEntry.pfu_tcp_code = *(long *)var_val;
          if ((pfuRuleEntry.pfu_tcp_code <0) || (pfuRuleEntry.pfu_tcp_code >63))
             return SNMP_ERR_WRONGVALUE;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
           /* For row creation, if row_status =0, mean that this is a normal
            * operation, we do the normal set operation, otherwise it is a row
            * creation operation, will do nothing here, and the overall entry
            * will perform in the write_xxxRowStatus function.
              */
        {
            PFU_TYPE_RuleEntry_T ord_entry;

            if (pfuRuleEntry.pfu_row_status == 0)
           {
                  if (PFU_MGR_GetRuleEntry(name[oid_name_length], &ord_entry)!=TRUE)
                      return SNMP_ERR_COMMITFAILED;

                   ord_entry.pfu_tcp_code= pfuRuleEntry.pfu_tcp_code;

               if (PFU_MGR_SetRuleEntry(name[oid_name_length], &ord_entry) != TRUE)
                 return SNMP_ERR_COMMITFAILED;
             }
         }
          break;
        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_pfuRuleTcpCodeBitmask(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
   /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          /* In reserve2, we overwrite the set value to pfuRuleEntry*/
          pfuRuleEntry.pfu_tcp_code_bitmask = *(long *)var_val;
          if ((pfuRuleEntry.pfu_tcp_code_bitmask <MIN_pfuRuleTcpCodeBitmask) || (pfuRuleEntry.pfu_tcp_code_bitmask >MAX_pfuRuleTcpCodeBitmask))
             return SNMP_ERR_WRONGVALUE;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
           /* For row creation, if row_status =0, mean that this is a normal
            * operation, we do the normal set operation, otherwise it is a row
            * creation operation, will do nothing here, and the overall entry
            * will perform in the write_xxxRowStatus function.
              */
         {
               PFU_TYPE_RuleEntry_T ord_entry;

            if (pfuRuleEntry.pfu_row_status == 0)
            {
                  if (PFU_MGR_GetRuleEntry(name[oid_name_length], &ord_entry)!=TRUE)
                      return SNMP_ERR_COMMITFAILED;

                   ord_entry.pfu_tcp_code_bitmask= pfuRuleEntry.pfu_tcp_code_bitmask;

               if (PFU_MGR_SetRuleEntry(name[oid_name_length], &ord_entry) != TRUE)
                 return SNMP_ERR_COMMITFAILED;
             }
         }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_pfuRuleFragments(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
   /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          /* In reserve2, we overwrite the set value to pfuRuleEntry*/
          pfuRuleEntry.pfu_rule_fragments = *(long *)var_val;
          if ((value <VAL_pfuRuleFragments_enabled) || (value >VAL_pfuRuleFragments_disabled))
             return SNMP_ERR_WRONGVALUE;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
           /* For row creation, if row_status =0, mean that this is a normal
            * operation, we do the normal set operation, otherwise it is a row
            * creation operation, will do nothing here, and the overall entry
            * will perform in the write_xxxRowStatus function.
              */
         {
               PFU_TYPE_RuleEntry_T ord_entry;

            if (pfuRuleEntry.pfu_row_status == 0)
            {
                  if (PFU_MGR_GetRuleEntry(name[oid_name_length], &ord_entry)!=TRUE)
                      return SNMP_ERR_COMMITFAILED;

                    ord_entry.pfu_rule_fragments= pfuRuleEntry.pfu_rule_fragments;

               if (PFU_MGR_SetRuleEntry(name[oid_name_length], &ord_entry) != TRUE)
                 return SNMP_ERR_COMMITFAILED;
             }
         }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_pfuRuleLog(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
   /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
         /* In reserve2, we overwrite the set value to pfuRuleEntry*/
          pfuRuleEntry.pfu_rule_log = *(long *)var_val;
          if ((value <VAL_pfuRuleLog_enabled) || (value >VAL_pfuRuleLog_disabled))
             return SNMP_ERR_WRONGVALUE;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
           /* For row creation, if row_status =0, mean that this is a normal
            * operation, we do the normal set operation, otherwise it is a row
            * creation operation, will do nothing here, and the overall entry
            * will perform in the write_xxxRowStatus function.
              */
        {
               PFU_TYPE_RuleEntry_T ord_entry;

            if (pfuRuleEntry.pfu_row_status == 0)
            {
                  if (PFU_MGR_GetRuleEntry(name[oid_name_length], &ord_entry)!=TRUE)
                      return SNMP_ERR_COMMITFAILED;

                   ord_entry.pfu_rule_log= pfuRuleEntry.pfu_rule_log;

               if (PFU_MGR_SetRuleEntry(name[oid_name_length], &ord_entry) != TRUE)
                 return SNMP_ERR_COMMITFAILED;
             }
         }
          break;
        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_pfuRuleRowStatus(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
   /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
           /* In reserve2, we overwrite the set value to pfuRuleEntry*/
          pfuRuleEntry.pfu_row_status = *(long *)var_val;
          if ((value <VAL_pfuRuleRowStatus_active) || (value >VAL_pfuRuleRowStatus_destroy))
             return SNMP_ERR_WRONGVALUE;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
           /* We perform the row creation here, if the row status = 4(createAndGo),
           * or 5 (createAndWait), we call the SetByEntry API, otherwise, call the
           * set rowstatus API
              */
          switch (pfuRuleEntry.pfu_row_status)
          {
              case VAL_pfuRuleRowStatus_createAndGo:
              case VAL_pfuRuleRowStatus_createAndWait:
                if (PFU_MGR_SetRowStatus( name[oid_name_length], pfuRuleEntry.pfu_row_status) != TRUE)
                {
                    return SNMP_ERR_COMMITFAILED;
                }
                if (PFU_MGR_SetRuleEntry( name[oid_name_length], &pfuRuleEntry) != TRUE)
           {
                    return SNMP_ERR_COMMITFAILED;
                }

              break;
              case VAL_pfuRuleRowStatus_active:
              case VAL_pfuRuleRowStatus_notInService:
              case VAL_pfuRuleRowStatus_notReady:
              case VAL_pfuRuleRowStatus_destroy:
                if (PFU_MGR_SetRowStatus(name[oid_name_length], pfuRuleEntry.pfu_row_status) != TRUE)
                {
                    return SNMP_ERR_COMMITFAILED;
                }
                break;
              default:
                 return SNMP_ERR_COMMITFAILED;
             }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
#endif

#if (SYS_CPNT_RADIUS == TRUE)
/********************************************
 *******************radiusMgt****************
 ********************************************
 */
int
do_radiusServerGlobalAuthPort(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode)
    {

        case MODE_GET:
            long_return = RADIUS_POM_Get_Server_Port();
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *)&long_return, sizeof(long_return));
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
            }
            break;

        case MODE_SET_RESERVE2:

            if (*requests->requestvb->val.integer < MIN_radiusServerGlobalAuthPort ||
                *requests->requestvb->val.integer > MAX_radiusServerGlobalAuthPort)
            {
               netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
              {
                UI32_T value;
                value = (*requests->requestvb->val.integer);
                 if (RADIUS_PMGR_Set_Server_Port(value) != TRUE)
                       netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */

            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */

            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}

#if (SYS_CPNT_RADIUS_ACCOUNTING == TRUE)
int
do_radiusServerGlobalAcctPort(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode)
    {
        case MODE_GET:
        {
            UI32_T value = 0;

            if(RADIUS_POM_GetServerAcctPort(&value)==TRUE)
            {
                long_return = value;
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
                break;
            }
            else
            {
                return SNMP_ERR_GENERR;
            }
            break;
        }

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
            }
            break;

        case MODE_SET_RESERVE2:

            if (*requests->requestvb->val.integer < MIN_radiusServerGlobalAcctPort ||
                *requests->requestvb->val.integer > MAX_radiusServerGlobalAcctPort)
            {
               netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
            {
                UI32_T value;
                value = (*requests->requestvb->val.integer);
                if (RADIUS_PMGR_SetServerAcctPort(value) != TRUE)
                    netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */

            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */

            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
#endif /* #if (SYS_CPNT_RADIUS_ACCOUNTING == TRUE) */

int
do_radiusServerGlobalKey(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
            return_buf[0] = '\0';
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, (u_char *)return_buf , 0);
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            if (requests->requestvb->type != ASN_OCTET_STR)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
            }

            if (requests->requestvb->val_len < MINSIZE_radiusServerGlobalKey || requests->requestvb->val_len > MAXSIZE_radiusServerGlobalKey)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGLENGTH);
            }
            break;

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
           {
               UI8_T  buffer[MAXSIZE_radiusServerGlobalKey+1];
               memcpy(buffer, requests->requestvb->val.string, requests->requestvb->val_len);
               buffer[requests->requestvb->val_len]= '\0';
                  if (RADIUS_PMGR_Set_Server_Secret(buffer)!= TRUE)
                  netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */

            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */

            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_radiusServerGlobalRetransmit(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:

                     long_return =  RADIUS_POM_Get_Retransmit_Times();
                     snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));

            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
            }
            break;

        case MODE_SET_RESERVE2:

            if (*requests->requestvb->val.integer < SYS_ADPT_RADIUS_MIN_RETRANSMIT ||
                *requests->requestvb->val.integer > SYS_ADPT_RADIUS_MAX_RETRANSMIT)
            {
               netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
            {
                UI32_T value;
                value = (*requests->requestvb->val.integer);
                if (RADIUS_PMGR_Set_Retransmit_Times(value) != TRUE)
                    netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */

            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */

            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_radiusServerGlobalTimeout(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
            long_return = RADIUS_POM_Get_Request_Timeout();
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
            }
            break;

        case MODE_SET_RESERVE2:

            if (*requests->requestvb->val.integer < SYS_ADPT_RADIUS_MIN_TIMEOUT ||
                *requests->requestvb->val.integer > SYS_ADPT_RADIUS_MAX_TIMEOUT)
            {
               netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
            {
                UI32_T value;
                value = (*requests->requestvb->val.integer);
                if (RADIUS_PMGR_Set_Request_Timeout(value) != TRUE)
                    netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */

            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */

            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

/********************************************
 *********radiusServerTable**********
 ********************************************
 */
/* radiusServerTable*/
#define radiusServerEntry_INSTANCE_LEN 1
static BOOL_T radiusServerTable_get(int      compc,
                                oid     *compl,
                                UI32_T  *index,
                                RADIUS_Server_Host_T   *data)
{

    if (compc !=radiusServerEntry_INSTANCE_LEN)
    {
        return FALSE;
    }
    *index = compl[0];

    if (RADIUS_POM_Get_Server_Host(*index - 1, data)!=TRUE)
    {
        return FALSE;
    }
    else
    {
        return TRUE;
    } /*End of if */
}

static BOOL_T
radiusServerTable_next(
   int      compc,
   oid     *compl,
   UI32_T  *index,
   RADIUS_Server_Host_T    *data)
{
    oid tmp_compl[radiusServerEntry_INSTANCE_LEN];

    memcpy(tmp_compl, compl, sizeof(tmp_compl));
    SNMP_MGR_ConvertRemainToZero(compc, radiusServerEntry_INSTANCE_LEN, tmp_compl);
    *index = tmp_compl[0];

    if (RADIUS_POM_GetNext_Server_Host(index, data) != TRUE)
    {
        return FALSE;
    }

    *index = data->server_index;

    return TRUE;
}

/*
 * var_radiusServerTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_radiusServerTable(struct variable *vp,
                          oid * name,
                          size_t * length,
                          int exact,
                          size_t * var_len, WriteMethod ** write_method)
{

    UI32_T compc=0;
    UI32_T idx1;
    oid compl[radiusServerEntry_INSTANCE_LEN];
    oid best_inst[radiusServerEntry_INSTANCE_LEN];
    RADIUS_Server_Host_T  data;

   /*Since this table allow for entry that does not exist, (creation). we need to know the write method first*/
    switch (vp->magic)
    {
        case RADIUSSERVERADDRESS:
            *write_method = write_radiusServerAddress;
            break;
        case RADIUSSERVERAUTHPORTNUMBER:
            *write_method = write_radiusServerAuthPortNumber;
            break;

#if (SYS_CPNT_RADIUS_ACCOUNTING == TRUE)
        case RADIUSSERVERACCTPORTNUMBER:
            *write_method = write_radiusServerAcctPortNumber;
            break;
#endif /* #if (SYS_CPNT_RADIUS_ACCOUNTING == TRUE) */

        case RADIUSSERVERKEY:
            *write_method = write_radiusServerKey;
            break;
        case RADIUSSERVERRETRANSMIT:
            *write_method = write_radiusServerRetransmit;
            break;
        case RADIUSSERVERTIMEOUT:
            *write_method = write_radiusServerTimeout;
            break;
        case RADIUSSERVERSTATUS:
            *write_method = write_radiusServerStatus;
            break;
        default:
            *write_method =0;
            break;
    }

    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,compl, radiusServerEntry_INSTANCE_LEN);

     /*check compc, retrive compl*/
    if (exact)/*get,set*/
    {
        if (!radiusServerTable_get(compc, compl, &idx1, &data))
            return NULL;
    }
    else/*getnext*/
    {
        if (!radiusServerTable_next(compc, compl, &idx1, &data))
        {
            return NULL;
        }
    }
    memcpy(name, vp->name, vp->namelen*sizeof(oid));
    best_inst[0]=idx1;
    memcpy(name + vp->namelen, best_inst, radiusServerEntry_INSTANCE_LEN*sizeof(oid));
    *length = vp->namelen +radiusServerEntry_INSTANCE_LEN;

    *var_len = sizeof(long_return);

    /*
     * * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic)
    {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case RADIUSSERVERINDEX:
            long_return = idx1;
            return (u_char*) &long_return;
#endif
        case RADIUSSERVERADDRESS:
            *var_len = sizeof(ipaddr_return);
            ipaddr_return = data.server_ip;
            return (u_char*) &ipaddr_return;
        case RADIUSSERVERAUTHPORTNUMBER:
            long_return = data.server_port;
            return (u_char*) &long_return;

#if (SYS_CPNT_RADIUS_ACCOUNTING == TRUE)
        case RADIUSSERVERACCTPORTNUMBER:
            long_return = data.acct_port;
            return (u_char*) &long_return;
#endif /* #if (SYS_CPNT_RADIUS_ACCOUNTING == TRUE) */

        case RADIUSSERVERKEY:
        {
            return_buf[0] = '\0';
            *var_len = 0;
            return (u_char*) return_buf;
        }
        case RADIUSSERVERRETRANSMIT:
            long_return = data.retransmit;
            return (u_char*)&long_return;
        case RADIUSSERVERTIMEOUT:
            long_return = data.timeout;
            return (u_char*)&long_return;
        case RADIUSSERVERSTATUS:
            long_return = VAL_radiusServerStatus_valid;
            return (u_char*) &long_return;
        default:
            ERROR_MSG("");
    }
    return NULL;
}

int
write_radiusServerAddress(int action,
                                 u_char * var_val,
                                 u_char var_val_type,
                                 size_t var_val_len,
                                 u_char * statP,
                                 oid * name, size_t name_len)
{

    //int size;
    UI32_T index;
    UI32_T value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

      /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    index = name[oid_name_length];
    switch ( action )
    {
        case RESERVE1:
            if (var_val_type != ASN_IPADDRESS)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len !=  SYS_ADPT_IPV4_ADDR_LEN)
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;

        case RESERVE2:
            break;

        case FREE:
             /* Release any resources that have been allocated */
            break;

        case ACTION:
        {
            /*
             * The variable has been stored in 'value' for you to use,
             * and you have just been asked to do something with it.
             * Note that anything done here must be reversable in the UNDO case
             */
            RADIUS_Server_Host_T entry;

            if (RADIUS_POM_Get_Server_Host(index-1,  &entry)!= TRUE)
            {
                return SNMP_ERR_COMMITFAILED;
            }
            memcpy(&entry.server_ip, var_val, var_val_len);
            if (RADIUS_PMGR_Set_Server_Host(index, &entry)!= TRUE)
            {
                return SNMP_ERR_COMMITFAILED;
            }
        }
        break;

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }
    return SNMP_ERR_NOERROR;
}

#if (SYS_CPNT_RADIUS_ACCOUNTING == TRUE)
int
write_radiusServerAcctPortNumber(int action,
                                 u_char * var_val,
                                 u_char var_val_type,
                                 size_t var_val_len,
                                 u_char * statP,
                                 oid * name, size_t name_len)
{
    long value;
    UI32_T index;

    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

      /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    index = name[oid_name_length];
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          value = *(long *)var_val;

          if ((value <MIN_radiusServerAuthPortNumber) || (value >MAX_radiusServerAuthPortNumber))
              return SNMP_ERR_WRONGVALUE;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
        {
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
              RADIUS_Server_Host_T entry;

              value = * (long *) var_val;
              if (RADIUS_POM_Get_Server_Host(index-1,  &entry)!= TRUE)
              {
                  return SNMP_ERR_COMMITFAILED;
              }
              entry.acct_port = value;
              if (RADIUS_PMGR_Set_Server_Host(index, &entry)!= TRUE)
              {
                  return SNMP_ERR_COMMITFAILED;
              }

         }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
#endif /* #if (SYS_CPNT_RADIUS_ACCOUNTING == TRUE) */

int
write_radiusServerKey(int action,
                                 u_char * var_val,
                                 u_char var_val_type,
                                 size_t var_val_len,
                                 u_char * statP,
                                 oid * name, size_t name_len)
{

    UI32_T index;

    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

      /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    index = name[oid_name_length];
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(char)*MAXSIZE_radiusServerKey) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
        {
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
              RADIUS_Server_Host_T entry;
              UI8_T buffer[MAXSIZE_radiusServerKey+1];
              memcpy( buffer, var_val, var_val_len);
              if (RADIUS_POM_Get_Server_Host(index-1,  &entry)!= TRUE)
              {
                  return SNMP_ERR_COMMITFAILED;
              }
              memcpy(entry.secret, buffer,var_val_len);
              entry.secret[var_val_len] = '\0';

              if (RADIUS_PMGR_Set_Server_Host(index, &entry)!= TRUE)
              {
                  return SNMP_ERR_COMMITFAILED;
              }

         }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_radiusServerRetransmit(int action,
                                 u_char * var_val,
                                 u_char var_val_type,
                                 size_t var_val_len,
                                 u_char * statP,
                                 oid * name, size_t name_len)
{
    long value;
    UI32_T index;

    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

      /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    index = name[oid_name_length];
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          value = *(long *)var_val;
          if ((value <SYS_ADPT_RADIUS_MIN_RETRANSMIT) || (value >SYS_ADPT_RADIUS_MAX_RETRANSMIT))
             return SNMP_ERR_WRONGVALUE;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
        {
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
              RADIUS_Server_Host_T entry;

              value = * (long *) var_val;
              if (RADIUS_POM_Get_Server_Host(index-1,  &entry)!= TRUE)
              {
                  return SNMP_ERR_COMMITFAILED;
              }
              entry.retransmit = value;
              if (RADIUS_PMGR_Set_Server_Host(index, &entry)!= TRUE)
              {
                  return SNMP_ERR_COMMITFAILED;
              }

         }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_radiusServerTimeout(int action,
                                 u_char * var_val,
                                 u_char var_val_type,
                                 size_t var_val_len,
                                 u_char * statP,
                                 oid * name, size_t name_len)
{
    long value;
    UI32_T index;

    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

      /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    index = name[oid_name_length];
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          value = *(long *)var_val;
          if ((value <SYS_ADPT_RADIUS_MIN_TIMEOUT) || (value >SYS_ADPT_RADIUS_MAX_TIMEOUT))
             return SNMP_ERR_WRONGVALUE;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
        {
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
              RADIUS_Server_Host_T entry;

              value = * (long *) var_val;
              if (RADIUS_POM_Get_Server_Host(index-1,  &entry)!= TRUE)
              {
                  return SNMP_ERR_COMMITFAILED;
              }
              entry.timeout = value;
              if (RADIUS_PMGR_Set_Server_Host(index, &entry)!= TRUE)
              {
                  return SNMP_ERR_COMMITFAILED;
              }

         }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_radiusServerAuthPortNumber(int action,
                                 u_char * var_val,
                                 u_char var_val_type,
                                 size_t var_val_len,
                                 u_char * statP,
                                 oid * name, size_t name_len)
{
    UI32_T index;
    long value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
      /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    index = name[oid_name_length];
    switch ( action )
    {
        case RESERVE1:
          value = *(long *)var_val;
          if ((value <MIN_radiusServerAcctPortNumber) || (value >MAX_radiusServerAcctPortNumber))
            {
              return SNMP_ERR_WRONGVALUE;
            }
            break;
        case RESERVE2:

            break;

        case FREE:
            /* Release any resources that have been allocated */
            break;

        case ACTION:
            {
                /*
                 * The variable has been stored in 'value' for you to use,
                 * and you have just been asked to do something with it.
                 * Note that anything done here must be reversable in the UNDO case
                 */
                RADIUS_Server_Host_T entry;

                value = * (long *) var_val;
                if (RADIUS_POM_Get_Server_Host(index-1,  &entry)!= TRUE)
                {
                    return SNMP_ERR_COMMITFAILED;
                }
                entry.server_port = value;
                if (RADIUS_PMGR_Set_Server_Host(index, &entry)!= TRUE)
                {
                    return SNMP_ERR_COMMITFAILED;
                }

            }
            break;

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_radiusServerStatus(int action,
                                 u_char * var_val,
                                 u_char var_val_type,
                                 size_t var_val_len,
                                 u_char * statP,
                                 oid * name, size_t name_len)
{
    long value;
    UI32_T index;

    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    index = name[oid_name_length];
    switch ( action )
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }
          break;

        case RESERVE2:
            value = *(long *)var_val;
            if ((value <VAL_radiusServerStatus_valid) || (value >VAL_radiusServerStatus_invalid))
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            /* Release any resources that have been allocated */
            break;

        case ACTION:
            {
                /*
                 * The variable has been stored in 'value' for you to use,
                 * and you have just been asked to do something with it.
                 * Note that anything done here must be reversable in the UNDO case
                 */
                RADIUS_Server_Host_T entry;

                value = * (long *) var_val;

                if (value == VAL_radiusServerStatus_valid)
                {
                    if (! RADIUS_POM_Get_Server_Host(index - 1, &entry))
                    {
                        memset(&entry, 0, sizeof(entry));
                        entry.server_ip = RADIUS_POM_Get_Server_IP();

                        if (RADIUS_PMGR_Set_Server_Host(index, &entry) != TRUE)
                        {
                            return SNMP_ERR_COMMITFAILED;
                        }
                    }
                    else
                    {
                        return SNMP_ERR_COMMITFAILED;
                    }
                }
                else if (value == VAL_radiusServerStatus_invalid)
                {
                    if (RADIUS_PMGR_Destroy_Server_Host(index) != TRUE)
                    {
                        return SNMP_ERR_COMMITFAILED;
                    }
                }
             }
             break;

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }
    return SNMP_ERR_NOERROR;
}
#endif /* #if (SYS_CPNT_RADIUS == TRUE) */

#if (SYS_CPNT_TACACS == TRUE)
/********************************************
 **************tacacsMgt************************
 *********************************************/
int
do_tacacsPlusServerGlobalPortNumber(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
     UI32_T value;
     /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one.
     */

    switch(reqinfo->mode) {

        case MODE_GET:
          long_return = TACACS_POM_Get_Server_Port();
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&long_return, sizeof(long_return));
            break;

        case MODE_SET_RESERVE1:
            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
            }
            break;

        case MODE_SET_RESERVE2:

            if (*requests->requestvb->val.integer < MIN_tacacsPlusServerGlobalPortNumber ||
                *requests->requestvb->val.integer > MAX_tacacsPlusServerGlobalPortNumber)
            {
               netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            }
            break;

        case MODE_SET_FREE:
            break;

        case MODE_SET_ACTION:
        value = (*requests->requestvb->val.integer);
        if (TACACS_PMGR_Set_Server_Port(value) != TRUE)
                       netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
            break;

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;

    }

    return SNMP_ERR_NOERROR;
}

int
do_tacacsPlusServerGlobalKey(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{

    switch(reqinfo->mode) {

        case MODE_GET:
            strcpy((char *)return_buf, "");
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, (u_char *)return_buf , 0);
            break;

        case MODE_SET_RESERVE1:
            if (requests->requestvb->type != ASN_OCTET_STR)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
            }

            if (requests->requestvb->val_len < MINSIZE_tacacsPlusServerGlobalKey || requests->requestvb->val_len > MAXSIZE_tacacsPlusServerGlobalKey)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGLENGTH);
            }
            break;

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            break;

        case MODE_SET_ACTION:
              {
               UI8_T  buffer[MAXSIZE_tacacsPlusServerGlobalKey+1];
               memcpy(buffer, requests->requestvb->val.string, requests->requestvb->val_len);
               buffer[requests->requestvb->val_len]= '\0';
               if (TACACS_PMGR_Set_Server_Secret(buffer)!= TRUE)
                       netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */

            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */

            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

/*
 * var_tacacsPlusServerTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */

#define tacacsPlusServerEntry_INSTANCE_LEN 1

static BOOL_T tacacsPlusServerTable_get(int      compc,
                                oid     *compl,
                                UI32_T  *index,
                                TACACS_Server_Host_T   *data)
{

    if (compc !=tacacsPlusServerEntry_INSTANCE_LEN)
    {
            return FALSE;
    }
    *index = compl[0];
        if (TACACS_POM_Get_Server_Host(*index, data)!=TRUE)
        {
                return FALSE;
        }
        else
        {
                return TRUE;

        } /*End of if */
}

static BOOL_T tacacsPlusServerTable_next(int      compc,
                                 oid     *compl,
                                 UI32_T  *index,
                                 TACACS_Server_Host_T    *data)
{
        oid tmp_compl[tacacsPlusServerEntry_INSTANCE_LEN];

        /* Generate the instance of each table entry and find the
         * smallest instance that's larger than compc/compl.
         *
         * Step 1: Verify and extract the input key from "compc" and "compl"
         * Note: The number of input key is defined by "compc".
         *       The key for the specified instance is defined in compl.
         */
        memcpy(tmp_compl, compl, sizeof(tmp_compl));
        SNMP_MGR_ConvertRemainToZero(compc,tacacsPlusServerEntry_INSTANCE_LEN, tmp_compl);
        *index = tmp_compl[0];

    if (compc<tacacsPlusServerEntry_INSTANCE_LEN)
        {
                if (TACACS_POM_Get_Server_Host(*index, data)!=TRUE)
        {
            if (TACACS_POM_GetNext_Server_Host(index, data)!=TRUE)
                {
                        return FALSE;
                    }
        }
        }
        else
        {
                if (TACACS_POM_GetNext_Server_Host(index, data)!=TRUE)
                {
                        return FALSE;
                }
        }
        return TRUE;
}
unsigned char  *
var_tacacsPlusServerTable(struct variable *vp,
                          oid * name,
                          size_t * length,
                          int exact,
                          size_t * var_len, WriteMethod ** write_method)
{

    UI32_T compc=0;
    UI32_T idx1;
    oid compl[tacacsPlusServerEntry_INSTANCE_LEN];
    oid best_inst[tacacsPlusServerEntry_INSTANCE_LEN];
    TACACS_Server_Host_T  data;

    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,compl, tacacsPlusServerEntry_INSTANCE_LEN);
     /*check compc, retrive compl*/

    switch (vp->magic)
    {
      case TACACSPLUSSERVERADDRESS:
           *write_method = write_tacacsPlusServerAddress;
           break;

      case TACACSPLUSSERVERPORTNUMBER:
           *write_method = write_tacacsPlusServerPortNumber;
           break;

      case TACACSPLUSSERVERKEY:
           *write_method = write_tacacsPlusServerKey;
           break;

      case TACACSPLUSSERVERSTATUS:
           *write_method = write_tacacsPlusServerStatus;
           break;

      default:
           ERROR_MSG("");
    }

    if (exact)/*get,set*/
    {
        if (!tacacsPlusServerTable_get(compc, compl, &idx1, &data))
            return NULL;
    }
    else/*getnext*/
    {
        if (!tacacsPlusServerTable_next(compc, compl, &idx1, &data))
        {
            return NULL;
        }
    }
    memcpy(name, vp->name, vp->namelen*sizeof(oid));
    best_inst[0]=idx1;
    memcpy(name + vp->namelen, best_inst, tacacsPlusServerEntry_INSTANCE_LEN*sizeof(oid));
    *length = vp->namelen +tacacsPlusServerEntry_INSTANCE_LEN;

    *var_len = sizeof(long_return);

    switch (vp->magic) {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
      case TACACSPLUSSERVERINDEX:
           long_return = data.server_index;            /* XXX */
           return (u_char *) & long_return;
#endif
      case TACACSPLUSSERVERADDRESS:
           *var_len = sizeof(ipaddr_return);
           ipaddr_return = data.server_ip;            /* XXX */
           return (u_char *) & ipaddr_return;

      case TACACSPLUSSERVERPORTNUMBER:
           long_return = data.server_port;            /* XXX */
           return (u_char *) & long_return;

      case TACACSPLUSSERVERKEY:
      {
           strcpy((char *)return_buf, "");
           *var_len = 0;
           return (u_char*) return_buf;
      }
      case TACACSPLUSSERVERSTATUS:
           long_return = VAL_tacacsPlusServerStatus_valid;            /* XXX */
           return (u_char *) & long_return;

      default:
           ERROR_MSG("");
    }
    return NULL;
}

int
write_tacacsPlusServerAddress(int action,
                              u_char * var_val,
                              u_char var_val_type,
                              size_t var_val_len,
                              u_char * statP, oid * name, size_t name_len)
{

    //int size;
    UI32_T index;
    UI32_T value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

      /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    index = name[oid_name_length];
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_IPADDRESS) {
              return SNMP_ERR_WRONGTYPE;
          }

          if (var_val_len !=  SYS_ADPT_IPV4_ADDR_LEN)
          {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
            break;

        case ACTION:
        {
        /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
         */
              TACACS_Server_Host_T entry;

              if (TACACS_POM_Get_Server_Host(index,  &entry)!= TRUE)
              {
                  return SNMP_ERR_COMMITFAILED;
              }
              memcpy(&entry.server_ip, var_val, var_val_len);
              if (TACACS_PMGR_Set_Server_Host(index, &entry)!= TRUE)
              {
                  return SNMP_ERR_COMMITFAILED;
              }

         }
            break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
            break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_tacacsPlusServerPortNumber(int action,
                                 u_char * var_val,
                                 u_char var_val_type,
                                 size_t var_val_len,
                                 u_char * statP,
                                 oid * name, size_t name_len)
{
    long value;
    UI32_T index;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    index = name[oid_name_length];

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            return SNMP_ERR_WRONGLENGTH;
        }
            break;

    case RESERVE2:
          value = *(long *)var_val;
          if ((value <MIN_tacacsPlusServerPortNumber) || (value >MAX_tacacsPlusServerPortNumber))
             return SNMP_ERR_WRONGVALUE;
          break;
    case FREE:
        break;

    case ACTION:
             {
              TACACS_Server_Host_T entry;
              value = * (long *) var_val;
              if (TACACS_POM_Get_Server_Host(index,  &entry)!= TRUE)
              {
                  return SNMP_ERR_COMMITFAILED;
              }
              entry.server_port = value;
              if (TACACS_PMGR_Set_Server_Host(index, &entry)!= TRUE)
              {
                  return SNMP_ERR_COMMITFAILED;
              }
            }
            break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
            break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_tacacsPlusServerKey(int action,
                          u_char * var_val,
                          u_char var_val_type,
                          size_t var_val_len,
                          u_char * statP, oid * name, size_t name_len)
{
    UI32_T index;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    index = name[oid_name_length];

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_OCTET_STR) {
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(char)*MAXSIZE_tacacsPlusServerKey) {
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        break;

    case FREE:
        /*
         * Release any resources that have been allocated
         */
        break;

    case ACTION:
    {
              TACACS_Server_Host_T entry;
              UI8_T buffer[MAXSIZE_tacacsPlusServerKey+1];
              memcpy( buffer, var_val, var_val_len);
               if (TACACS_POM_Get_Server_Host(index,  &entry)!= TRUE)
              {
                  return SNMP_ERR_COMMITFAILED;
              }
              memcpy(entry.secret, buffer,var_val_len);
              entry.secret[var_val_len] = '\0';
              if (TACACS_PMGR_Set_Server_Host(index, &entry)!= TRUE)
              {
                  return SNMP_ERR_COMMITFAILED;
              }
        }
              break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_tacacsPlusServerStatus(int action,
                             u_char * var_val,
                             u_char var_val_type,
                             size_t var_val_len,
                             u_char * statP, oid * name, size_t name_len)
{
    long   value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    UI32_T index;

    index = name[oid_name_length];

    switch (action)
    {
       case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
               return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long))
            {
               return SNMP_ERR_WRONGLENGTH;
            }
            break;

       case RESERVE2:
            value = *(long *)var_val;

            switch(value)
            {
                case VAL_tacacsPlusServerStatus_valid:
                case VAL_tacacsPlusServerStatus_invalid:
                    break;
                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

       case FREE:
            break;

       case ACTION:
       {
            TACACS_Server_Host_T data;

            value = * (long *) var_val;

            if (value == VAL_tacacsPlusServerStatus_valid)
            {
               if (TACACS_POM_Get_Server_Host(index, &data) != TRUE)
               {
                   memset(&data, 0, sizeof(data));
                   data.server_ip =TACACS_POM_Get_Server_IP();
                   if (TACACS_PMGR_Set_Server_Host(index, &data) != TRUE)
                   {
                       return SNMP_ERR_COMMITFAILED;
                   }
               }
               else
               {
                   return SNMP_ERR_COMMITFAILED;
               }
            }
            else if (value == VAL_tacacsPlusServerStatus_invalid)
            {
               if (TACACS_POM_Get_Server_Host(index, &data) != TRUE)
               {
                   return SNMP_ERR_COMMITFAILED;
               }
               else if (TACACS_PMGR_Destroy_Server_Host_By_Index(index) != TRUE)
               {
                   return SNMP_ERR_COMMITFAILED;
               }
            }
            break;
       }

       case UNDO:
           /*
            * Back out any changes made in the ACTION case
            */
           break;

       case COMMIT:
           /*
            * Things are working well, so it's now safe to make the change
            * permanently.  Make sure that anything done here can't fail!
            */
           break;
    }
    return SNMP_ERR_NOERROR;
}
#endif /* #if (SYS_CPNT_TACACS == TRUE) */

#if (SYS_CPNT_SSHD == TRUE || SYS_CPNT_SSH2 == TRUE)
/********************************************
 *******************sshMgt*******************
 ********************************************
 */
int
do_sshServerStatus(netsnmp_mib_handler *handler,
                   netsnmp_handler_registration *reginfo,
                   netsnmp_agent_request_info *reqinfo,
                   netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode)
     {

        case MODE_GET:
           {
               SSHD_STATE_T sshServerStatus;

                sshServerStatus=SSHD_PMGR_GetSshdStatus();

                long_return = sshServerStatus;
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
            }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
            }
            break;

        case MODE_SET_RESERVE2:
            switch (*requests->requestvb->val.integer)
            {
                case VAL_sshServerStatus_enabled:
                    break;

                case VAL_sshServerStatus_disabled:
                    break;

                default:
                    netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
        {
            UI32_T sshServerStatus;

            sshServerStatus = *requests->requestvb->val.integer;


            if (SSHD_PMGR_SetSshdStatus( sshServerStatus)!= TRUE)
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);

         }
          break;

        case MODE_SET_COMMIT:

            break;

        case MODE_SET_UNDO:

            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_sshServerMajorVersion(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
            {
                UI32_T major;
                UI32_T minor;

                if (SSHD_PMGR_GetSshServerVersion(&major,&minor) != TRUE)
                    return SNMP_ERR_GENERR;

                long_return = major;
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *)&long_return, sizeof(long_return));
            }
            break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_sshServerMinorVersion(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
            {

                UI32_T major;
                UI32_T minor;

                if (SSHD_PMGR_GetSshServerVersion(&major,&minor) != TRUE)
                    return SNMP_ERR_GENERR;

                long_return = minor;
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *)&long_return, sizeof(long_return));
            }
            break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_sshTimeout(netsnmp_mib_handler *handler,
              netsnmp_handler_registration *reginfo,
              netsnmp_agent_request_info *reqinfo,
              netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode)
     {

        case MODE_GET:
            {
                UI32_T sshTimeout;

                sshTimeout=SSHD_PMGR_GetNegotiationTimeout();

                long_return = sshTimeout;
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
            }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
            }
            break;

        case MODE_SET_RESERVE2:

            if (*requests->requestvb->val.integer < MIN_sshTimeout ||
                *requests->requestvb->val.integer > MAX_sshTimeout)
            {
               netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
        {
            UI32_T sshTimeout;

            sshTimeout = *requests->requestvb->val.integer;


            if (SSHD_PMGR_SetNegotiationTimeout( sshTimeout)!= TRUE)
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);

         }
          break;

        case MODE_SET_COMMIT:

            break;

        case MODE_SET_UNDO:

            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_sshAuthRetries(netsnmp_mib_handler *handler,
                  netsnmp_handler_registration *reginfo,
                  netsnmp_agent_request_info *reqinfo,
                  netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode)
     {

        case MODE_GET:
            {
                UI32_T sshAuthRetries;

                sshAuthRetries=SSHD_PMGR_GetAuthenticationRetries();

                long_return = sshAuthRetries;
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
            }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
            }
            break;

        case MODE_SET_RESERVE2:

            if (*requests->requestvb->val.integer < MIN_sshAuthRetries ||
                *requests->requestvb->val.integer > MAX_sshAuthRetries)
            {
               netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
       {
            UI32_T sshAuthRetries;

            sshAuthRetries = *requests->requestvb->val.integer;


         if (SSHD_PMGR_SetAuthenticationRetries( sshAuthRetries)!= TRUE)
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);

         }
          break;

        case MODE_SET_COMMIT:

            break;

        case MODE_SET_UNDO:

            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

#if (SYS_CPNT_SSH2 == TRUE)
int
get_sshDsaHostKey5(netsnmp_mib_handler *handler,
                   netsnmp_handler_registration *reginfo,
                   netsnmp_agent_request_info *reqinfo,
                   netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
       struct
       {
           UI8_T rsa[1024+1];
           UI8_T dsa[1024+1];
           UI8_T key[MAXSIZE_sshDsaHostKey5+1];
       } *buf_p;
       UI32_T partialVarLen, start;
       UI32_T unitIndex=5;

       buf_p = L_MM_Malloc(sizeof(*buf_p), L_MM_USER_ID2(SYS_MODULE_SNMP, SNMP_TYPE_TRACE_ID_GET_SSHDSAHOSTKEY5));
       if (buf_p==NULL)
       {
           return SNMP_ERR_GENERR;
       }
    switch(reqinfo->mode) {

        case MODE_GET:
            if (KEYGEN_PMGR_GetHostPublicKey(buf_p->rsa,buf_p->dsa))
            {
                SNMP_MGR_CalPartialVarLen(1024,strlen((char *)buf_p->dsa),MAXSIZE_sshDsaHostKey5,unitIndex,&start,&partialVarLen);
                strncpy((char *)buf_p->key, (char *)buf_p->dsa+(start-1), partialVarLen);
                buf_p->key[partialVarLen]=0;
                strcpy((char *) return_buf, (char *)buf_p->key);
                L_MM_Free(buf_p);
                snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, (u_char *) return_buf, strlen((char *)return_buf));
            }
            else
            {
                L_MM_Free(buf_p);
                return SNMP_ERR_GENERR;
            }
            break;


        default:
            L_MM_Free(buf_p);
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_sshDsaHostKey6(netsnmp_mib_handler *handler,
                   netsnmp_handler_registration *reginfo,
                   netsnmp_agent_request_info *reqinfo,
                   netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
       struct
       {
           UI8_T rsa[1024+1];
           UI8_T dsa[1024+1];
           UI8_T key[MAXSIZE_sshDsaHostKey6+1];
       } *buf_p;
       UI32_T partialVarLen, start;
       UI32_T unitIndex=6;

       buf_p = L_MM_Malloc(sizeof(*buf_p), L_MM_USER_ID2(SYS_MODULE_SNMP, SNMP_TYPE_TRACE_ID_GET_SSHDSAHOSTKEY6));
       if(buf_p==NULL)
       {
           SYSFUN_Debug_Printf("sshMgt_get_value: mem alloc err,LEAF_sshDsaHostKey5\n");
           return SNMP_ERR_GENERR;
       }
    switch(reqinfo->mode) {

        case MODE_GET:
            if (KEYGEN_PMGR_GetHostPublicKey(buf_p->rsa,buf_p->dsa))
            {
                SNMP_MGR_CalPartialVarLen(1024,strlen((char *)buf_p->dsa),MAXSIZE_sshDsaHostKey6,unitIndex,&start,&partialVarLen);
                strncpy((char *)buf_p->key, (char *)buf_p->dsa+(start-1), partialVarLen);
                buf_p->key[partialVarLen]=0;
                strcpy((char *)return_buf, (char *)buf_p->key);
                L_MM_Free(buf_p);
                snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, (u_char *) return_buf, strlen((char *)return_buf));
            }
            else
            {
                L_MM_Free(buf_p);
                return SNMP_ERR_GENERR;
            }
            break;


        default:
            L_MM_Free(buf_p);
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_sshDsaHostKey7(netsnmp_mib_handler *handler,
                   netsnmp_handler_registration *reginfo,
                   netsnmp_agent_request_info *reqinfo,
                   netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
       struct
       {
           UI8_T rsa[1024+1];
           UI8_T dsa[1024+1];
           UI8_T key[MAXSIZE_sshDsaHostKey7+1];
       } *buf_p;
       UI32_T partialVarLen, start;
       UI32_T unitIndex=7;

       buf_p = L_MM_Malloc(sizeof(*buf_p), L_MM_USER_ID2(SYS_MODULE_SNMP, SNMP_TYPE_TRACE_ID_GET_SSHDSAHOSTKEY7));
       if (buf_p==NULL)
       {
           SYSFUN_Debug_Printf("sshMgt_get_value: mem alloc err,LEAF_sshDsaHostKey5\n");
           return SNMP_ERR_GENERR;
       }
    switch(reqinfo->mode) {

        case MODE_GET:
            if (KEYGEN_PMGR_GetHostPublicKey(buf_p->rsa,buf_p->dsa))
            {
                SNMP_MGR_CalPartialVarLen(1024,strlen((char *)buf_p->dsa),MAXSIZE_sshDsaHostKey7,unitIndex,&start,&partialVarLen);
                strncpy((char *)buf_p->key, (char *)buf_p->dsa+(start-1), partialVarLen);
                buf_p->key[partialVarLen]=0;
                strcpy((char *)return_buf, (char *)buf_p->key);
                L_MM_Free(buf_p);
                snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, (u_char *) return_buf, strlen((char *)return_buf));
            }
            else
            {
                L_MM_Free(buf_p);
                return SNMP_ERR_GENERR;
            }
            break;


        default:
            L_MM_Free(buf_p);
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_sshDsaHostKey8(netsnmp_mib_handler *handler,
                   netsnmp_handler_registration *reginfo,
                   netsnmp_agent_request_info *reqinfo,
                   netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
       struct
       {
           UI8_T rsa[1024+1];
           UI8_T dsa[1024+1];
           UI8_T key[MAXSIZE_sshDsaHostKey8+1];
       } *buf_p;
       UI32_T partialVarLen, start;
       UI32_T unitIndex=8;

       buf_p = L_MM_Malloc(sizeof(*buf_p), L_MM_USER_ID2(SYS_MODULE_SNMP, SNMP_TYPE_TRACE_ID_GET_SSHDSAHOSTKEY8));
       if(buf_p==NULL)
       {
           SYSFUN_Debug_Printf("sshMgt_get_value: mem alloc err,LEAF_sshDsaHostKey5\n");
           return SNMP_ERR_GENERR;
       }
    switch(reqinfo->mode) {

        case MODE_GET:
            if (KEYGEN_PMGR_GetHostPublicKey(buf_p->rsa,buf_p->dsa))
            {
                SNMP_MGR_CalPartialVarLen(1024,strlen((char *)buf_p->dsa),MAXSIZE_sshDsaHostKey8,unitIndex,&start,&partialVarLen);
                strncpy((char *)buf_p->key, (char *)buf_p->dsa+(start-1), partialVarLen);
                buf_p->key[partialVarLen]=0;
                strcpy( (char *)return_buf, (char *)buf_p->key);
                L_MM_Free(buf_p);
                snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, (u_char *) return_buf, strlen((char *)return_buf));
            }
            else
            {
                L_MM_Free(buf_p);
                return SNMP_ERR_GENERR;
            }
            break;


        default:
            L_MM_Free(buf_p);
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_sshHostKeyGenStatus(netsnmp_mib_handler *handler,
                        netsnmp_handler_registration *reginfo,
                        netsnmp_agent_request_info *reqinfo,
                        netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
           {
               UI32_T status;


            if (SSHD_PMGR_GetGenerateHostKeyStatus(&status) != TRUE)
                return SNMP_ERR_GENERR;

                long_return =  status;
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *)&long_return, sizeof(long_return));
            }
            break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_sshHostKeySaveAction(netsnmp_mib_handler *handler,
                        netsnmp_handler_registration *reginfo,
                        netsnmp_agent_request_info *reqinfo,
                        netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode)
     {

        case MODE_GET:
           {
               UI32_T sshHostKeySaveAction;

                if (SSHD_PMGR_GetWriteHostKey2FlashAction(&sshHostKeySaveAction)!= TRUE)
                {
                    return SNMP_ERR_GENERR;
                }
                   long_return = sshHostKeySaveAction;
                  snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
            }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
            }
            break;

        case MODE_SET_RESERVE2:
            switch (*requests->requestvb->val.integer)
            {
                case VAL_sshHostKeySaveAction_noSave:
                    netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_INCONSISTENTVALUE);
                    break;

                case VAL_sshHostKeySaveAction_save:
                    break;

                default:
                    netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
       {

         if (SSHD_PMGR_AsyncWriteHostKey2Flash()!= TRUE)
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);

        }
          break;

        case MODE_SET_COMMIT:

            break;

        case MODE_SET_UNDO:

            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}



int
get_sshHostKeySaveStatus(netsnmp_mib_handler *handler,
                         netsnmp_handler_registration *reginfo,
                         netsnmp_agent_request_info *reqinfo,
                         netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
           {

            UI32_T sshHostKeySaveStatus;


        if (SSHD_PMGR_GetWriteHostKey2FlashStatus(&sshHostKeySaveStatus) != TRUE)
           return SNMP_ERR_GENERR;

            long_return = sshHostKeySaveStatus;
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *)&long_return, sizeof(long_return));
            }
            break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_sshRsaHostKeySHA1FingerPrint(netsnmp_mib_handler *handler,
                         netsnmp_handler_registration *reginfo,
                         netsnmp_agent_request_info *reqinfo,
                         netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
            {
                struct
                {
                     UI8_T buffer1[SIZE_sshRsaHostKeySHA1FingerPrint+1];
                     UI8_T buffer2[SIZE_sshRsaHostKeyMD5FingerPrint+1];
                     UI8_T buffer3[SIZE_sshDsaHostKeySHA1FingerPrint+1];
                     UI8_T buffer4[SIZE_sshDsaHostKeyMD5FingerPrint+1];
                } *buf_p;

                buf_p = L_MM_Malloc(sizeof(*buf_p), L_MM_USER_ID2(SYS_MODULE_SNMP, SNMP_TYPE_TRACE_ID_GET_SSHRSAHOSTKEYSHA1FINGERPRINT));
                if (buf_p==NULL)
                {
                    return SNMP_ERR_GENERR;
                }

                if (!KEYGEN_PMGR_GetHostPublicKeyFingerPrint(buf_p->buffer1, buf_p->buffer2, buf_p->buffer3, buf_p->buffer4))
                {
                    L_MM_Free(buf_p);
                    return SNMP_ERR_GENERR;
                }
                memcpy( return_buf, buf_p->buffer1, SIZE_sshRsaHostKeySHA1FingerPrint);
                L_MM_Free(buf_p);
                return_buf[SIZE_sshRsaHostKeySHA1FingerPrint]='\0';
                snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, (u_char *)return_buf, SIZE_sshRsaHostKeySHA1FingerPrint);
            }
            break;
        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_sshRsaHostKeyMD5FingerPrint(netsnmp_mib_handler *handler,
                         netsnmp_handler_registration *reginfo,
                         netsnmp_agent_request_info *reqinfo,
                         netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
           {
               struct
               {
                   UI8_T buffer1[SIZE_sshRsaHostKeySHA1FingerPrint+1];
                   UI8_T buffer2[SIZE_sshRsaHostKeyMD5FingerPrint+1];
                   UI8_T buffer3[SIZE_sshDsaHostKeySHA1FingerPrint+1];
                   UI8_T buffer4[SIZE_sshDsaHostKeyMD5FingerPrint+1];
               } *buf_p;

               buf_p = L_MM_Malloc(sizeof(*buf_p), L_MM_USER_ID2(SYS_MODULE_SNMP, SNMP_TYPE_TRACE_ID_GET_SSHRSAHOSTKEYMD5FINGERPRINT));
               if (buf_p==NULL)
               {
                   return SNMP_ERR_GENERR;
               }

               if (!KEYGEN_PMGR_GetHostPublicKeyFingerPrint(buf_p->buffer1, buf_p->buffer2, buf_p->buffer3, buf_p->buffer4))
               {
                   L_MM_Free(buf_p);
                   return SNMP_ERR_GENERR;
               }
               memcpy( return_buf, buf_p->buffer2, SIZE_sshRsaHostKeyMD5FingerPrint);
               L_MM_Free(buf_p);
               return_buf[SIZE_sshRsaHostKeyMD5FingerPrint]='\0';
               snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, (u_char *)return_buf, SIZE_sshRsaHostKeyMD5FingerPrint);
            }
            break;
        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_sshDsaHostKeySHA1FingerPrint(netsnmp_mib_handler *handler,
                         netsnmp_handler_registration *reginfo,
                         netsnmp_agent_request_info *reqinfo,
                         netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
            {
                struct
                {
                    UI8_T buffer1[SIZE_sshRsaHostKeySHA1FingerPrint+1];
                    UI8_T buffer2[SIZE_sshRsaHostKeyMD5FingerPrint+1];
                    UI8_T buffer3[SIZE_sshDsaHostKeySHA1FingerPrint+1];
                    UI8_T buffer4[SIZE_sshDsaHostKeyMD5FingerPrint+1];
                } *buf_p;

                buf_p = L_MM_Malloc(sizeof(*buf_p), L_MM_USER_ID2(SYS_MODULE_SNMP, SNMP_TYPE_TRACE_ID_GET_SSHDSAHOSTKEYSHA1FINGERPRINT));
                if (buf_p==NULL)
                {
                    return SNMP_ERR_GENERR;
                }

                if (!KEYGEN_PMGR_GetHostPublicKeyFingerPrint(buf_p->buffer1, buf_p->buffer2, buf_p->buffer3, buf_p->buffer4))
                {
                    L_MM_Free(buf_p);
                    return SNMP_ERR_GENERR;
                }
                memcpy( return_buf, buf_p->buffer3, SIZE_sshDsaHostKeySHA1FingerPrint);
                L_MM_Free(buf_p);
                return_buf[SIZE_sshDsaHostKeySHA1FingerPrint]='\0';
                snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, (u_char *)return_buf, SIZE_sshDsaHostKeySHA1FingerPrint);
            }
            break;
        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_sshDsaHostKeyMD5FingerPrint(netsnmp_mib_handler *handler,
                         netsnmp_handler_registration *reginfo,
                         netsnmp_agent_request_info *reqinfo,
                         netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
            {
                struct
                {
                    UI8_T buffer1[SIZE_sshRsaHostKeySHA1FingerPrint+1];
                    UI8_T buffer2[SIZE_sshRsaHostKeyMD5FingerPrint+1];
                    UI8_T buffer3[SIZE_sshDsaHostKeySHA1FingerPrint+1];
                    UI8_T buffer4[SIZE_sshDsaHostKeyMD5FingerPrint+1];
                } *buf_p;

                buf_p=L_MM_Malloc(sizeof(*buf_p), L_MM_USER_ID2(SYS_MODULE_SNMP, SNMP_TYPE_TRACE_ID_GET_SSHDSAHOSTKEYMD5FINGERPRINT));
                if (buf_p==NULL)
                {
                    return SNMP_ERR_GENERR;
                }

                if (!KEYGEN_PMGR_GetHostPublicKeyFingerPrint(buf_p->buffer1, buf_p->buffer2, buf_p->buffer3, buf_p->buffer4))
                {
                    L_MM_Free(buf_p);
                    return SNMP_ERR_GENERR;
                }
                memcpy( return_buf, buf_p->buffer4, SIZE_sshDsaHostKeyMD5FingerPrint);
                L_MM_Free(buf_p);
                return_buf[SIZE_sshDsaHostKeyMD5FingerPrint]='\0';
                snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, (u_char *)return_buf, SIZE_sshDsaHostKeyMD5FingerPrint);
            }
            break;
        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_sshKeySize(netsnmp_mib_handler *handler,
              netsnmp_handler_registration *reginfo,
              netsnmp_agent_request_info *reqinfo,
              netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode)
    {

        case MODE_GET:
           {
               UI32_T sshKeySize;

                if (!SSHD_PMGR_GetServerKeySize(&sshKeySize))
                {
                     return SNMP_ERR_GENERR;
                }
                long_return = sshKeySize;
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
            }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
            }
            break;

        case MODE_SET_RESERVE2:

            if (*requests->requestvb->val.integer < MIN_sshKeySize ||
                *requests->requestvb->val.integer > MAX_sshKeySize)
            {
               netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
        {
            UI32_T sshKeySize;

            sshKeySize = *requests->requestvb->val.integer;


            if (SSHD_PMGR_SetServerKeySize( sshKeySize)!= TRUE)
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);

        }
            break;

        case MODE_SET_COMMIT:

            break;

        case MODE_SET_UNDO:

            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}


int
do_sshHostKeyDelAction(netsnmp_mib_handler *handler,
                       netsnmp_handler_registration *reginfo,
                       netsnmp_agent_request_info *reqinfo,
                       netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode)
    {

        case MODE_GET:
           {

                long_return = VAL_sshHostKeyDelAction_noDel;
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
            }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
            }
            break;

        case MODE_SET_RESERVE2:
            switch (*requests->requestvb->val.integer)
            {
                case VAL_sshHostKeyDelAction_noDel:
                    netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_INCONSISTENTVALUE);
                    break;

                case VAL_sshHostKeyDelAction_delRsaKey:
                    break;

                case VAL_sshHostKeyDelAction_delDsaKey:
                    break;

                case VAL_sshHostKeyDelAction_delBothKeys:
                    break;

                default:
                    netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
        {
            UI32_T sshHostKeyDelAction;

            sshHostKeyDelAction = *requests->requestvb->val.integer;


            if (KEYGEN_PMGR_DeleteHostKeyPair( sshHostKeyDelAction)!= TRUE)
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);

        }
            break;

        case MODE_SET_COMMIT:

            break;

        case MODE_SET_UNDO:

            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_sshRsaHostKey1(netsnmp_mib_handler *handler,
                   netsnmp_handler_registration *reginfo,
                   netsnmp_agent_request_info *reqinfo,
                   netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    struct
    {
        UI8_T rsa[1024+1];
        UI8_T dsa[1024+1];
        UI8_T key[MAXSIZE_sshRsaHostKey1+1];
    } *buf_p;
    UI32_T partialVarLen, start;
    UI32_T unitIndex=1;

    buf_p = L_MM_Malloc(sizeof(*buf_p), L_MM_USER_ID2(SYS_MODULE_SNMP, SNMP_TYPE_TRACE_ID_GET_SSHRSAHOSTKEY1));
    if (buf_p==NULL)
    {
        SYSFUN_Debug_Printf("sshMgt_get_value: mem alloc err,LEAF_sshRsaHostKey1\n");
        return SNMP_ERR_GENERR;
    }
    switch(reqinfo->mode) {

        case MODE_GET:
            if (KEYGEN_PMGR_GetHostPublicKey(buf_p->rsa,buf_p->dsa))
            {
                SNMP_MGR_CalPartialVarLen(1024,strlen((char *)buf_p->rsa),MAXSIZE_sshRsaHostKey1,unitIndex,&start,&partialVarLen);
                strncpy((char *)buf_p->key, (char *)buf_p->rsa+(start-1), partialVarLen);
                buf_p->key[partialVarLen]=0;
                strcpy( (char *)return_buf, (char *)buf_p->key);
                L_MM_Free(buf_p);
                snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, (u_char *) return_buf, strlen((char *)return_buf));
            }
            else
            {
                L_MM_Free(buf_p);
                return SNMP_ERR_GENERR;
            }
            break;


        default:
            L_MM_Free(buf_p);
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_sshRsaHostKey2(netsnmp_mib_handler *handler,
                   netsnmp_handler_registration *reginfo,
                   netsnmp_agent_request_info *reqinfo,
                   netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    struct
    {
        UI8_T rsa[1024+1];
        UI8_T dsa[1024+1];
        UI8_T key[MAXSIZE_sshRsaHostKey2+1];
    } *buf_p;
    UI32_T partialVarLen, start;
    UI32_T unitIndex=2;

    buf_p=L_MM_Malloc(sizeof(*buf_p), L_MM_USER_ID2(SYS_MODULE_SNMP, SNMP_TYPE_TRACE_ID_GET_SSHRSAHOSTKEY2));
    if (buf_p==NULL)
    {
        SYSFUN_Debug_Printf("sshMgt_get_value: mem alloc err,LEAF_sshRsaHostKey1\n");
        return SNMP_ERR_GENERR;
    }
    switch(reqinfo->mode) {

        case MODE_GET:
            if (KEYGEN_PMGR_GetHostPublicKey(buf_p->rsa,buf_p->dsa))
            {
                SNMP_MGR_CalPartialVarLen(1024,strlen((char *)buf_p->rsa),MAXSIZE_sshRsaHostKey2,unitIndex,&start,&partialVarLen);
                strncpy((char *)buf_p->key, (char *)buf_p->rsa+(start-1), partialVarLen);
                buf_p->key[partialVarLen]=0;
                strcpy( (char *)return_buf, (char *)buf_p->key);
                L_MM_Free(buf_p);
                snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, (u_char *) return_buf, strlen((char *)return_buf));
            }
            else
            {
                L_MM_Free(buf_p);
                return SNMP_ERR_GENERR;
            }
            break;


        default:
            L_MM_Free(buf_p);
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_sshRsaHostKey3(netsnmp_mib_handler *handler,
                   netsnmp_handler_registration *reginfo,
                   netsnmp_agent_request_info *reqinfo,
                   netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    struct
    {
        UI8_T rsa[1024+1];
        UI8_T dsa[1024+1];
        UI8_T key[MAXSIZE_sshRsaHostKey3+1];
    } *buf_p;
    UI32_T partialVarLen, start;
    UI32_T unitIndex=3;

    buf_p=L_MM_Malloc(sizeof(*buf_p), L_MM_USER_ID2(SYS_MODULE_SNMP, SNMP_TYPE_TRACE_ID_GET_SSHRSAHOSTKEY3));
    if (buf_p==NULL)
    {
        SYSFUN_Debug_Printf("sshMgt_get_value: mem alloc err,LEAF_sshRsaHostKey31\n");
        return SNMP_ERR_GENERR;
    }
    switch(reqinfo->mode) {

        case MODE_GET:
            if (KEYGEN_PMGR_GetHostPublicKey(buf_p->rsa,buf_p->dsa))
            {
                SNMP_MGR_CalPartialVarLen(1024,strlen((char *)buf_p->rsa),MAXSIZE_sshRsaHostKey3,unitIndex,&start,&partialVarLen);
                strncpy((char *)buf_p->key, (char *)buf_p->rsa+(start-1), partialVarLen);
                buf_p->key[partialVarLen]=0;
                strcpy( (char *)return_buf, (char *)buf_p->key);
                L_MM_Free(buf_p);
                snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, (u_char *) return_buf, strlen((char *)return_buf));
            }
            else
            {
                L_MM_Free(buf_p);
                return SNMP_ERR_GENERR;
            }
            break;


        default:
            L_MM_Free(buf_p);
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_sshRsaHostKey4(netsnmp_mib_handler *handler,
                   netsnmp_handler_registration *reginfo,
                   netsnmp_agent_request_info *reqinfo,
                   netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    struct
    {
        UI8_T rsa[1024+1];
        UI8_T dsa[1024+1];
        UI8_T key[MAXSIZE_sshRsaHostKey4+1];
    } *buf_p;
    UI32_T partialVarLen, start;
    UI32_T unitIndex=4;

    buf_p = L_MM_Malloc(sizeof(*buf_p), L_MM_USER_ID2(SYS_MODULE_SNMP, SNMP_TYPE_TRACE_ID_GET_SSHRSAHOSTKEY4));
    if (buf_p==NULL)
    {
        SYSFUN_Debug_Printf("sshMgt_get_value: mem alloc err,LEAF_sshRsaHostKey4\n");
        return SNMP_ERR_GENERR;
    }
    switch(reqinfo->mode) {

        case MODE_GET:
            if (KEYGEN_PMGR_GetHostPublicKey(buf_p->rsa,buf_p->dsa))
            {
                SNMP_MGR_CalPartialVarLen(1024,strlen((char *)buf_p->rsa),MAXSIZE_sshRsaHostKey4,unitIndex,&start,&partialVarLen);
                strncpy((char *)buf_p->key, (char *)buf_p->rsa+(start-1), partialVarLen);
                buf_p->key[partialVarLen]=0;
                strcpy( (char *)return_buf, (char *)buf_p->key);
                L_MM_Free(buf_p);
                snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, (u_char *) return_buf, strlen((char *)return_buf));
            }
            else
            {
                L_MM_Free(buf_p);
                return SNMP_ERR_GENERR;
            }
            break;


        default:
            L_MM_Free(buf_p);
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_sshRsaHostKey5(netsnmp_mib_handler *handler,
                   netsnmp_handler_registration *reginfo,
                   netsnmp_agent_request_info *reqinfo,
                   netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    struct
    {
        UI8_T rsa[1024+1];
        UI8_T dsa[1024+1];
        UI8_T key[MAXSIZE_sshRsaHostKey5+1];
    } *buf_p;
    UI32_T partialVarLen, start;
    UI32_T unitIndex=5;

    buf_p=L_MM_Malloc(sizeof(*buf_p), L_MM_USER_ID2(SYS_MODULE_SNMP, SNMP_TYPE_TRACE_ID_GET_SSHRSAHOSTKEY5));
    if (buf_p==NULL)
    {
        SYSFUN_Debug_Printf("sshMgt_get_value: mem alloc err,LEAF_sshRsaHostKey5\n");
        return SNMP_ERR_GENERR;
    }
    switch(reqinfo->mode) {

        case MODE_GET:
            if (KEYGEN_PMGR_GetHostPublicKey(buf_p->rsa,buf_p->dsa))
            {
                SNMP_MGR_CalPartialVarLen(1024,strlen((char *)buf_p->rsa),MAXSIZE_sshRsaHostKey5,unitIndex,&start,&partialVarLen);
                strncpy((char *)buf_p->key, (char *)buf_p->rsa+(start-1), partialVarLen);
                buf_p->key[partialVarLen]=0;
                strcpy( (char *)return_buf, (char *)buf_p->key);
                L_MM_Free(buf_p);
                snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, (u_char *) return_buf, strlen((char *)return_buf));
            }
            else
            {
                L_MM_Free(buf_p);
                return SNMP_ERR_GENERR;
            }
            break;


        default:
            L_MM_Free(buf_p);
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_sshDsaHostKey1(netsnmp_mib_handler *handler,
                   netsnmp_handler_registration *reginfo,
                   netsnmp_agent_request_info *reqinfo,
                   netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    struct
    {
        UI8_T rsa[1024+1];
        UI8_T dsa[1024+1];
        UI8_T key[MAXSIZE_sshDsaHostKey1+1];
    } *buf_p;
    UI32_T partialVarLen, start;
    UI32_T unitIndex=1;

    buf_p=L_MM_Malloc(sizeof(*buf_p), L_MM_USER_ID2(SYS_MODULE_SNMP, SNMP_TYPE_TRACE_ID_GET_SSHDSAHOSTKEY1));
    if (buf_p==NULL)
    {
        SYSFUN_Debug_Printf("sshMgt_get_value: mem alloc err,LEAF_sshDsaHostKey1\n");
        return SNMP_ERR_GENERR;
    }
    switch(reqinfo->mode) {

        case MODE_GET:
            if (KEYGEN_PMGR_GetHostPublicKey(buf_p->rsa,buf_p->dsa))
            {
                SNMP_MGR_CalPartialVarLen(1024,strlen((char *)buf_p->dsa),MAXSIZE_sshDsaHostKey1,unitIndex,&start,&partialVarLen);
                strncpy((char *)buf_p->key, (char *)buf_p->dsa+(start-1), partialVarLen);
                buf_p->key[partialVarLen]=0;
                strcpy( (char *)return_buf, (char *)buf_p->key);
                L_MM_Free(buf_p);
                snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, (u_char *) return_buf, strlen((char *)return_buf));
            }
            else
            {
                L_MM_Free(buf_p);
                return SNMP_ERR_GENERR;
            }
            break;


        default:
            L_MM_Free(buf_p);
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_sshRsaHostKey6(netsnmp_mib_handler *handler,
                   netsnmp_handler_registration *reginfo,
                   netsnmp_agent_request_info *reqinfo,
                   netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    struct
    {
        UI8_T rsa[1024+1];
        UI8_T dsa[1024+1];
        UI8_T key[MAXSIZE_sshRsaHostKey6+1];
    } *buf_p;
    UI32_T partialVarLen, start;
    UI32_T unitIndex=6;

    buf_p = L_MM_Malloc(sizeof(*buf_p), L_MM_USER_ID2(SYS_MODULE_SNMP, SNMP_TYPE_TRACE_ID_GET_SSHRSAHOSTKEY6));
    if (buf_p==NULL)
    {
        SYSFUN_Debug_Printf("sshMgt_get_value: mem alloc err,LEAF_sshRsaHostKey6\n");
        return SNMP_ERR_GENERR;
    }
    switch(reqinfo->mode) {

        case MODE_GET:
            if (KEYGEN_PMGR_GetHostPublicKey(buf_p->rsa,buf_p->dsa))
            {
                SNMP_MGR_CalPartialVarLen(1024,strlen((char *)buf_p->rsa),MAXSIZE_sshRsaHostKey6,unitIndex,&start,&partialVarLen);
                strncpy((char *)buf_p->key, (char *)buf_p->rsa+(start-1), partialVarLen);
                buf_p->key[partialVarLen]=0;
                strcpy( (char *)return_buf, (char *)buf_p->key);
                L_MM_Free(buf_p);
                snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, (u_char *) return_buf, strlen((char *)return_buf));
            }
            else
            {
                L_MM_Free(buf_p);
                return SNMP_ERR_GENERR;
            }
            break;


        default:
            L_MM_Free(buf_p);
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_sshHostKeyGenAction(netsnmp_mib_handler *handler,
                       netsnmp_handler_registration *reginfo,
                       netsnmp_agent_request_info *reqinfo,
                       netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode)
     {

        case MODE_GET:
           {
            UI32_T action;
                if (SSHD_PMGR_GetGenerateHostKeyAction(&action)!= TRUE)
                {
                    return SNMP_ERR_GENERR;
                }
                long_return = action;
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
            }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
            }
            break;

        case MODE_SET_RESERVE2:
            switch (*requests->requestvb->val.integer)
            {
                case VAL_sshHostKeyGenAction_noGen:
                    netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_INCONSISTENTVALUE);
                    break;

                case VAL_sshHostKeyGenAction_genRsaKey:
                    break;

                case VAL_sshHostKeyGenAction_genDsaKey:
                    break;

                case VAL_sshHostKeyGenAction_genBothKeys:
                    break;

                default:
                    netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
       {
            UI32_T action;

            action = *requests->requestvb->val.integer;


         if (SSHD_PMGR_AsyncGenerateHostKeyPair( action)!= TRUE)
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);

         }
          break;

        case MODE_SET_COMMIT:

            break;

        case MODE_SET_UNDO:

            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_sshDsaHostKey2(netsnmp_mib_handler *handler,
                   netsnmp_handler_registration *reginfo,
                   netsnmp_agent_request_info *reqinfo,
                   netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    struct
    {
        UI8_T rsa[1024+1];
        UI8_T dsa[1024+1];
        UI8_T key[MAXSIZE_sshDsaHostKey2+1];
    } *buf_p;
    UI32_T partialVarLen, start;
    UI32_T unitIndex=2;

    buf_p = L_MM_Malloc(sizeof(*buf_p), L_MM_USER_ID2(SYS_MODULE_SNMP, SNMP_TYPE_TRACE_ID_GET_SSHDSAHOSTKEY2));
    if (buf_p==NULL)
    {
        SYSFUN_Debug_Printf("sshMgt_get_value: mem alloc err,LEAF_sshDsaHostKey1\n");
        return SNMP_ERR_GENERR;
    }
    switch(reqinfo->mode) {

        case MODE_GET:
            if (KEYGEN_PMGR_GetHostPublicKey(buf_p->rsa,buf_p->dsa))
            {
                SNMP_MGR_CalPartialVarLen(1024,strlen((char *)buf_p->dsa),MAXSIZE_sshDsaHostKey2,unitIndex,&start,&partialVarLen);
                strncpy((char *)buf_p->key, (char *)buf_p->dsa+(start-1), partialVarLen);
                buf_p->key[partialVarLen]=0;
                strcpy( (char *)return_buf, (char *)buf_p->key);
                L_MM_Free(buf_p);
                snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, (u_char *) return_buf, strlen((char *)return_buf));
            }
            else
            {
                L_MM_Free(buf_p);
                return SNMP_ERR_GENERR;
            }
            break;


        default:
            L_MM_Free(buf_p);
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_sshRsaHostKey7(netsnmp_mib_handler *handler,
                   netsnmp_handler_registration *reginfo,
                   netsnmp_agent_request_info *reqinfo,
                   netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    struct
    {
        UI8_T rsa[1024+1];
        UI8_T dsa[1024+1];
        UI8_T key[MAXSIZE_sshRsaHostKey6+1];
    } *buf_p;
    UI32_T partialVarLen, start;
    UI32_T unitIndex=7;

    buf_p = L_MM_Malloc(sizeof(*buf_p), L_MM_USER_ID2(SYS_MODULE_SNMP, SNMP_TYPE_TRACE_ID_GET_SSHRSAHOSTKEY7));
    if (buf_p==NULL)
    {
        SYSFUN_Debug_Printf("sshMgt_get_value: mem alloc err,LEAF_sshRsaHostKey7\n");
        return SNMP_ERR_GENERR;
    }
    switch(reqinfo->mode) {

        case MODE_GET:
            if (KEYGEN_PMGR_GetHostPublicKey(buf_p->rsa,buf_p->dsa))
            {
                SNMP_MGR_CalPartialVarLen(1024,strlen((char *)buf_p->rsa),MAXSIZE_sshRsaHostKey7,unitIndex,&start,&partialVarLen);
                strncpy((char *)buf_p->key, (char *)buf_p->rsa+(start-1), partialVarLen);
                buf_p->key[partialVarLen]=0;
                strcpy( (char *)return_buf, (char *)buf_p->key);
                L_MM_Free(buf_p);
                snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, (u_char *) return_buf, strlen((char *)return_buf));
            }
            else
            {
                L_MM_Free(buf_p);
                return SNMP_ERR_GENERR;
            }
            break;


        default:
            L_MM_Free(buf_p);
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_sshRsaHostKey8(netsnmp_mib_handler *handler,
                   netsnmp_handler_registration *reginfo,
                   netsnmp_agent_request_info *reqinfo,
                   netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    struct
    {
        UI8_T rsa[1024+1];
        UI8_T dsa[1024+1];
        UI8_T key[MAXSIZE_sshRsaHostKey8+1];
    } *buf_p;
    UI32_T partialVarLen, start;
    UI32_T unitIndex=8;

    buf_p=L_MM_Malloc(sizeof(*buf_p), L_MM_USER_ID2(SYS_MODULE_SNMP, SNMP_TYPE_TRACE_ID_GET_SSHRSAHOSTKEY8));
    if (buf_p==NULL)
    {
        SYSFUN_Debug_Printf("sshMgt_get_value: mem alloc err,LEAF_sshRsaHostKey8\n");
        return SNMP_ERR_GENERR;
    }
    switch(reqinfo->mode) {

        case MODE_GET:
            if (KEYGEN_PMGR_GetHostPublicKey(buf_p->rsa,buf_p->dsa))
            {
                SNMP_MGR_CalPartialVarLen(1024,strlen((char *)buf_p->rsa),MAXSIZE_sshRsaHostKey8,unitIndex,&start,&partialVarLen);
                strncpy((char *)buf_p->key, (char *)buf_p->rsa+(start-1), partialVarLen);
                buf_p->key[partialVarLen]=0;
                strcpy( (char *)return_buf, (char *)buf_p->key);
                L_MM_Free(buf_p);
                snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, (u_char *) return_buf, strlen((char *)return_buf));
            }
            else
            {
                L_MM_Free(buf_p);
                return SNMP_ERR_GENERR;
            }
            break;


        default:
            L_MM_Free(buf_p);
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_sshDsaHostKey3(netsnmp_mib_handler *handler,
                   netsnmp_handler_registration *reginfo,
                   netsnmp_agent_request_info *reqinfo,
                   netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    struct
    {
        UI8_T rsa[1024+1];
        UI8_T dsa[1024+1];
        UI8_T key[MAXSIZE_sshDsaHostKey3+1];
    } *buf_p;
    UI32_T partialVarLen, start;
    UI32_T unitIndex=3;

    buf_p = L_MM_Malloc(sizeof(*buf_p), L_MM_USER_ID2(SYS_MODULE_SNMP, SNMP_TYPE_TRACE_ID_GET_SSHDSAHOSTKEY3));
    if (buf_p==NULL)
    {
        SYSFUN_Debug_Printf("sshMgt_get_value: mem alloc err,LEAF_sshDsaHostKey3\n");
        return SNMP_ERR_GENERR;
    }
    switch(reqinfo->mode) {

        case MODE_GET:
            if (KEYGEN_PMGR_GetHostPublicKey(buf_p->rsa,buf_p->dsa))
            {
                SNMP_MGR_CalPartialVarLen(1024,strlen((char *)buf_p->dsa),MAXSIZE_sshDsaHostKey3,unitIndex,&start,&partialVarLen);
                strncpy((char *)buf_p->key, (char *)buf_p->dsa+(start-1), partialVarLen);
                buf_p->key[partialVarLen]=0;
                strcpy( (char *)return_buf, (char *)buf_p->key);
                L_MM_Free(buf_p);
                snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, (u_char *) return_buf, strlen((char *)return_buf));
            }
            else
            {
                L_MM_Free(buf_p);
                return SNMP_ERR_GENERR;
            }
            break;


        default:
            L_MM_Free(buf_p);
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_sshDsaHostKey4(netsnmp_mib_handler *handler,
                   netsnmp_handler_registration *reginfo,
                   netsnmp_agent_request_info *reqinfo,
                   netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    struct
    {
        UI8_T rsa[1024+1];
        UI8_T dsa[1024+1];
        UI8_T key[MAXSIZE_sshDsaHostKey4+1];
    } *buf_p;
    UI32_T partialVarLen, start;
    UI32_T unitIndex=4;

    buf_p=L_MM_Malloc(sizeof(*buf_p), L_MM_USER_ID2(SYS_MODULE_SNMP, SNMP_TYPE_TRACE_ID_GET_SSHDSAHOSTKEY4));
    if (buf_p==NULL)
    {
        SYSFUN_Debug_Printf("sshMgt_get_value: mem alloc err,LEAF_sshDsaHostKey4\n");
        return SNMP_ERR_GENERR;
    }
    switch(reqinfo->mode) {

        case MODE_GET:
            if (KEYGEN_PMGR_GetHostPublicKey(buf_p->rsa,buf_p->dsa))
            {
                SNMP_MGR_CalPartialVarLen(1024,strlen((char *)buf_p->dsa),MAXSIZE_sshDsaHostKey4,unitIndex,&start,&partialVarLen);
                strncpy((char *)buf_p->key, (char *)buf_p->dsa+(start-1), partialVarLen);
                buf_p->key[partialVarLen]=0;
                strcpy( (char *)return_buf, (char *)buf_p->key);
                L_MM_Free(buf_p);
                snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, (u_char *) return_buf, strlen((char *)return_buf));
            }
            else
            {
                L_MM_Free(buf_p);
                return SNMP_ERR_GENERR;
            }
            break;


        default:
            L_MM_Free(buf_p);
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
#endif

/********************************************
 **************sshConnInfoTable**************
 ********************************************
 */
static int
header_sshConnInfoTable(struct variable *vp,
               oid * name,
               size_t * length,
               int exact, size_t * var_len, WriteMethod ** write_method)
{
    oid             newname[MAX_OID_LEN];
    int    interface;
    int             result;
   SSHD_CONNECTION_INFO_T  entry;
   I32_T ifIndex = -1;
   BOOL_T return_val;

   UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    memcpy((char *) newname, (char *) vp->name,
           (int) vp->namelen * sizeof(oid));
    /*
     * find "next" interface
     */


     while (  (return_val= SSHD_PMGR_GetNextSshConnectionEntry( &ifIndex, &entry))==TRUE)
     {
        newname[oid_name_length] = (oid) ifIndex;
        result =
            snmp_oid_compare(name, *length, newname,
                             (int) vp->namelen + 1);
        if ((exact && (result == 0)) || (!exact && (result < 0)))
            break;
    }
    if (!return_val ) {

        return MATCH_FAILED;
    }


    memcpy((char *) name, (char *) newname,
           ((int) vp->namelen + 1) * sizeof(oid));
    *length = vp->namelen + 1;
    *var_len = sizeof(long);    /* default to 'long' results */
    interface = newname[oid_name_length];
    return interface;
}


/*
 * var_sshConnInfoTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_sshConnInfoTable(struct variable *vp,
                     oid * name,
                     size_t * length,
                     int exact,
                     size_t * var_len, WriteMethod ** write_method)
{
    SSHD_ConnectionInfo_T   entry;
    int             interface;


   memset( &entry, 0, sizeof(SSHD_ConnectionInfo_T));
    interface =
        header_sshConnInfoTable(vp, name, length, exact, var_len, write_method);
    if (interface == MATCH_FAILED)
        return NULL;


   if (SSHD_PMGR_GetSshConnectionEntry(interface,&entry)!= TRUE)
            return NULL;

    /*
     * * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
      #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
      case SSHCONNID:
        long_return = interface;
        return (u_char*) &long_return;
      #endif
      case SSHCONNMAJORVERSION:
        long_return = entry.major_version;
        return (u_char*) &long_return;
      case SSHCONNMINORVERSION:
        long_return = entry.minor_version;
        return (u_char*) &long_return;
      #if (SYS_CPNT_SSHD == TRUE)
      case SSHCONNENCRYPTIONTYPE:
        long_return = entry.cipher;
        return (u_char*) &long_return;
      #endif
      case SSHCONNSTATUS:
        long_return = entry.status;
        return (u_char*) &long_return;
      case SSHCONNUSERNAME:
        strcpy((char *)return_buf, (char *)entry.username);
        *var_len = strlen((char *)return_buf);
        return (u_char*) return_buf;
      case SSHDISCONNECT:
       *write_method = write_sshDisconnect;
       long_return = VAL_sshDisconnect_noDisconnect;
       return (u_char*) &long_return;
      #if (SYS_CPNT_SSH2 == TRUE)
      case SSHCONNENCRYPTIONTYPESTR:
#if 1
        strcpy((char *)return_buf, (char *)entry.cipher);
        *var_len = strlen((char *)return_buf);
        return (u_char*) return_buf;
#else
        long_return=(UI32_T)entry.cipher;
        return (u_char*) &long_return;
#endif

      #endif
    default:
        ERROR_MSG("");
    }
    return NULL;
}


int
write_sshDisconnect(int action,
                    u_char * var_val,
                    u_char var_val_type,
                    size_t var_val_len,
                    u_char * statP, oid * name, size_t name_len)
{
    long value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;


    if (name_len!=  1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          value = *(long *)var_val;
          if (value !=VAL_sshDisconnect_disconnect)
             return SNMP_ERR_WRONGVALUE;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
        {
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             SSHD_CONNECTION_INFO_T data;
             value = * (long *) var_val;

             if (SSHD_PMGR_GetSshConnectionEntry(name[oid_name_length],&data) == TRUE)
             {
                 if (CLI_PMGR_SetKillWorkingSpaceFlag(name[oid_name_length])!= TRUE)
                 {
                     return SNMP_ERR_COMMITFAILED;
                 }
             }
             else
             {
                 return SNMP_ERR_COMMITFAILED;
             }

        }
        break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

/********************************************
 **************sshUserTable******************
 ********************************************
     */
static int
header_sshUserTable(struct variable *vp,
               oid * name,
               size_t * length,
               int exact, size_t * var_len, WriteMethod ** write_method,
               UI8_T *index1)
{

    oid    newname[MAX_OID_LEN];
    UI8_T  nameIndex[SYS_ADPT_MAX_USER_NAME_LEN + 1];
    int    result;
    int return_val;
    struct
    {
        UI8_T rsa[1024+1];
        UI8_T dsa[1024+1];
    } *buf_p;
    oid  next_inst[SYS_ADPT_MAX_USER_NAME_LEN + 1];
    int i;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    buf_p=L_MM_Malloc(sizeof(*buf_p), L_MM_USER_ID2(SYS_MODULE_SNMP, SNMP_TYPE_TRACE_ID_HEADER_SSHUSERTABLE));
    if (buf_p==NULL)
    {
       SYSFUN_Debug_Printf("sshUserEntry_next: mem alloc err\n");
       return MATCH_FAILED;
    }

     memcpy((char *) newname, (char *) vp->name,
           (int) vp->namelen * sizeof(oid));
    /*
     * find "next" interface
     */

    /*
     * find "next" interface
     */
     nameIndex[0]=0;

     while (  (return_val= KEYGEN_PMGR_GetNextUserPublicKey( nameIndex, buf_p->rsa, buf_p->dsa)) == TRUE)
     {

       for ( i = 0; i< strlen((char *)nameIndex); i++)
       {
           next_inst[i] = nameIndex[i];
       }

        memcpy( (char*)&newname[oid_name_length], (char*) next_inst,  (strlen((char *)nameIndex))*sizeof(oid));
        result =
            snmp_oid_compare(name, *length, newname,
                             (int) vp->namelen + strlen((char *)nameIndex));
        if ((exact && (result == 0)) || (!exact && (result < 0)))
            break;
    }
    if (return_val!= TRUE )
     {
        DEBUGMSGTL(("mibII/interfaces", "... index out of range\n"));
        L_MM_Free(buf_p);
        return MATCH_FAILED;
    }
    memcpy((char *) name, (char *) newname,
           ((int) vp->namelen + strlen((char *)nameIndex)) * sizeof(oid));
    *length = vp->namelen + strlen((char *)nameIndex);
    *var_len = sizeof(long);    /* default to 'long' results */
    strcpy((char *)index1, (char *)nameIndex);
    L_MM_Free(buf_p);
    return TRUE;

}



/*
 * var_sshUserTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_sshUserTable(struct variable *vp,
                 oid * name,
                 size_t * length,
                 int exact, size_t * var_len, WriteMethod ** write_method)
{
    /* variables we may use later */

    UI32_T retval;
    UI8_T index1[MAXSIZE_sshUserName+1];
    struct
    {
        UI8_T rsa[1024+1];
        UI8_T dsa[1024+1];
    } *buf_p;

    retval  = header_sshUserTable(vp, name, length, exact, var_len, write_method,  index1);

    if (retval == MATCH_FAILED)
    {
        return NULL;
    }

    buf_p = L_MM_Malloc(sizeof(*buf_p), L_MM_USER_ID2(SYS_MODULE_SNMP, SNMP_TYPE_TRACE_ID_VAR_SSHUSERTABLE));
    if (buf_p==NULL)
    {
        SYSFUN_Debug_Printf("sshUserEntry_get: mem alloc err\n");
        return NULL;
    }

    if (!SSHD_PMGR_GetUserPublicKey(index1,buf_p->rsa,buf_p->dsa))
    {
        L_MM_Free(buf_p);
        return NULL;
    }
    /*
     * * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
      case SSHUSERNAME:
        strcpy((char *)return_buf, (char *)index1);
        *var_len = strlen((char *)return_buf);
        L_MM_Free(buf_p);
        return( u_char *) return_buf;
    #endif
      case SSHUSERRSAKEY1:
      {
        UI32_T partialVarLen, start;
        UI32_T unitIndex=1;

        SNMP_MGR_CalPartialVarLen(1024,strlen((char *)buf_p->rsa),MAXSIZE_sshUserRsaKey1,unitIndex,&start,&partialVarLen);
        strncpy((char *)return_buf, (char *)buf_p->rsa+(start-1), partialVarLen);
        return_buf[partialVarLen]=0;
        *var_len = strlen((char *)return_buf);
        L_MM_Free(buf_p);
        return( u_char *) return_buf;
      }
      case SSHUSERRSAKEY2:
      {
        UI32_T partialVarLen, start;
        UI32_T unitIndex=2;

        SNMP_MGR_CalPartialVarLen(1024,strlen((char *)buf_p->rsa),MAXSIZE_sshUserRsaKey1,unitIndex,&start,&partialVarLen);
        strncpy((char *)return_buf, (char *)buf_p->rsa+(start-1), partialVarLen);
        return_buf[partialVarLen]=0;
        *var_len = strlen((char *)return_buf);
        L_MM_Free(buf_p);
        return( u_char *) return_buf;
      }
      case SSHUSERRSAKEY3:
      {
        UI32_T partialVarLen, start;
        UI32_T unitIndex=3;

        SNMP_MGR_CalPartialVarLen(1024,strlen((char *)buf_p->rsa),MAXSIZE_sshUserRsaKey1,unitIndex,&start,&partialVarLen);
        strncpy((char *)return_buf, (char *)buf_p->rsa+(start-1), partialVarLen);
        return_buf[partialVarLen]=0;
        *var_len = strlen((char *)return_buf);
        L_MM_Free(buf_p);
        return( u_char *) return_buf;
      }
      case SSHUSERRSAKEY4:
      {
        UI32_T partialVarLen, start;
        UI32_T unitIndex=4;

        SNMP_MGR_CalPartialVarLen(1024,strlen((char *)buf_p->rsa),MAXSIZE_sshUserRsaKey1,unitIndex,&start,&partialVarLen);
        strncpy((char *)return_buf, (char *)buf_p->rsa+(start-1), partialVarLen);
        return_buf[partialVarLen]=0;
        *var_len = strlen((char *)return_buf);
        L_MM_Free(buf_p);
        return( u_char *) return_buf;
      }
      case SSHUSERRSAKEY5:
      {
        UI32_T partialVarLen, start;
        UI32_T unitIndex=5;

        SNMP_MGR_CalPartialVarLen(1024,strlen((char *)buf_p->rsa),MAXSIZE_sshUserRsaKey1,unitIndex,&start,&partialVarLen);
        strncpy((char *)return_buf, (char *)buf_p->rsa+(start-1), partialVarLen);
        return_buf[partialVarLen]=0;
        *var_len = strlen((char *)return_buf);
        L_MM_Free(buf_p);
        return( u_char *) return_buf;
      }
      case SSHUSERRSAKEY6:
      {
        UI32_T partialVarLen, start;
        UI32_T unitIndex=6;

        SNMP_MGR_CalPartialVarLen(1024,strlen((char *)buf_p->rsa),MAXSIZE_sshUserRsaKey1,unitIndex,&start,&partialVarLen);
        strncpy((char *)return_buf, (char *)buf_p->rsa+(start-1), partialVarLen);
        return_buf[partialVarLen]=0;
        *var_len = strlen((char *)return_buf);
        L_MM_Free(buf_p);
        return( u_char *) return_buf;
      }
      case SSHUSERRSAKEY7:
      {
        UI32_T partialVarLen, start;
        UI32_T unitIndex=7;

        SNMP_MGR_CalPartialVarLen(1024,strlen((char *)buf_p->rsa),MAXSIZE_sshUserRsaKey1,unitIndex,&start,&partialVarLen);
        strncpy((char *)return_buf, (char *)buf_p->rsa+(start-1), partialVarLen);
        return_buf[partialVarLen]=0;
        *var_len = strlen((char *)return_buf);
        L_MM_Free(buf_p);
        return( u_char *) return_buf;
      }
      case SSHUSERRSAKEY8:
        {
        UI32_T partialVarLen, start;
        UI32_T unitIndex=8;

        SNMP_MGR_CalPartialVarLen(1024,strlen((char *)buf_p->rsa),MAXSIZE_sshUserRsaKey1,unitIndex,&start,&partialVarLen);
        strncpy((char *)return_buf, (char *)buf_p->rsa+(start-1), partialVarLen);
        return_buf[partialVarLen]=0;
        *var_len = strlen((char *)return_buf);
        L_MM_Free(buf_p);
        return( u_char *) return_buf;
      }
      case SSHUSERDSAKEY1:
        {
        UI32_T partialVarLen, start;
        UI32_T unitIndex=1;

        SNMP_MGR_CalPartialVarLen(1024,strlen((char *)buf_p->dsa),MAXSIZE_sshUserRsaKey1,unitIndex,&start,&partialVarLen);
        strncpy((char *)return_buf, (char *)buf_p->dsa+(start-1), partialVarLen);
        return_buf[partialVarLen]=0;
        *var_len = strlen((char *)return_buf);
        L_MM_Free(buf_p);
        return( u_char *) return_buf;
      }
      case SSHUSERDSAKEY2:
        {
        UI32_T partialVarLen, start;
        UI32_T unitIndex=2;

        SNMP_MGR_CalPartialVarLen(1024,strlen((char *)buf_p->dsa),MAXSIZE_sshUserRsaKey1,unitIndex,&start,&partialVarLen);
        strncpy((char *)return_buf, (char *)buf_p->dsa+(start-1), partialVarLen);
        return_buf[partialVarLen]=0;
        *var_len = strlen((char *)return_buf);
        L_MM_Free(buf_p);
        return( u_char *) return_buf;
      }
      case SSHUSERDSAKEY3:
       {
        UI32_T partialVarLen, start;
        UI32_T unitIndex=3;

        SNMP_MGR_CalPartialVarLen(1024,strlen((char *)buf_p->dsa),MAXSIZE_sshUserRsaKey1,unitIndex,&start,&partialVarLen);
        strncpy((char *)return_buf, (char *)buf_p->dsa+(start-1), partialVarLen);
        return_buf[partialVarLen]=0;
        *var_len = strlen((char *)return_buf);
        L_MM_Free(buf_p);
        return( u_char *) return_buf;
      }
      case SSHUSERDSAKEY4:
        {
        UI32_T partialVarLen, start;
        UI32_T unitIndex=4;

        SNMP_MGR_CalPartialVarLen(1024,strlen((char *)buf_p->dsa),MAXSIZE_sshUserRsaKey1,unitIndex,&start,&partialVarLen);
        strncpy((char *)return_buf, (char *)buf_p->dsa+(start-1), partialVarLen);
        return_buf[partialVarLen]=0;
        *var_len = strlen((char *)return_buf);
        L_MM_Free(buf_p);
        return( u_char *) return_buf;
      }
      case SSHUSERDSAKEY5:
        {
        UI32_T partialVarLen, start;
        UI32_T unitIndex=5;

        SNMP_MGR_CalPartialVarLen(1024,strlen((char *)buf_p->dsa),MAXSIZE_sshUserRsaKey1,unitIndex,&start,&partialVarLen);
        strncpy((char *)return_buf, (char *)buf_p->dsa+(start-1), partialVarLen);
        return_buf[partialVarLen]=0;
        *var_len = strlen((char *)return_buf);
        L_MM_Free(buf_p);
        return( u_char *) return_buf;
      }
      case SSHUSERDSAKEY6:
        {
        UI32_T partialVarLen, start;
        UI32_T unitIndex=6;

        SNMP_MGR_CalPartialVarLen(1024,strlen((char *)buf_p->dsa),MAXSIZE_sshUserRsaKey1,unitIndex,&start,&partialVarLen);
        strncpy((char *)return_buf, (char *)buf_p->dsa+(start-1), partialVarLen);
        return_buf[partialVarLen]=0;
        *var_len = strlen((char *)return_buf);
        L_MM_Free(buf_p);
        return( u_char *) return_buf;
      }
      case SSHUSERDSAKEY7:
        {
        UI32_T partialVarLen, start;
        UI32_T unitIndex=7;

        SNMP_MGR_CalPartialVarLen(1024,strlen((char *)buf_p->dsa),MAXSIZE_sshUserRsaKey1,unitIndex,&start,&partialVarLen);
        strncpy((char *)return_buf, (char *)buf_p->dsa+(start-1), partialVarLen);
        return_buf[partialVarLen]=0;
        *var_len = strlen((char *)return_buf);
        L_MM_Free(buf_p);
        return( u_char *) return_buf;
      }
      case SSHUSERDSAKEY8:
        {
        UI32_T partialVarLen, start;
        UI32_T unitIndex=8;

        SNMP_MGR_CalPartialVarLen(1024,strlen((char *)buf_p->dsa),MAXSIZE_sshUserRsaKey1,unitIndex,&start,&partialVarLen);
        strncpy((char *)return_buf, (char *)buf_p->dsa+(start-1), partialVarLen);
        return_buf[partialVarLen]=0;
        *var_len = strlen((char *)return_buf);
        L_MM_Free(buf_p);
        return( u_char *) return_buf;
      }
      case SSHUSERKEYDELACTION:
      {
           UI32_T action;
        *write_method = write_sshUserKeyDelAction;

        if (!SSHD_PMGR_GetDeleteUserPublicKeyAction(&action))
        {
           L_MM_Free(buf_p);
           return NULL;
        }
        else
        {
        long_return = action;
        }
        L_MM_Free(buf_p);
        return(u_char*) &long_return;
       break;
       }
       default:
        ERROR_MSG("");
    }
    L_MM_Free(buf_p);
    return NULL;
}


int
write_sshUserKeyDelAction(int action,
                          u_char * var_val,
                          u_char var_val_type,
                          size_t var_val_len,
                          u_char * statP, oid * name, size_t name_len)
{
    int i;
    UI32_T value;
    UI8_T buffer[MAXSIZE_sshUserName+1];
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;



    if ((char) name[oid_name_length-1] != SSHUSERKEYDELACTION)
    {
        return SNMP_ERR_NOTWRITABLE;
    }

    if (name_len- oid_name_length> MAXSIZE_sshUserName+1)
    {
        return SNMP_ERR_WRONGLENGTH;
    }



    for (i = 0; i< (name_len -oid_name_length) ; i++)
    {
        buffer[i] = (UI8_T)name[oid_name_length+i];
    }
    buffer[name_len-oid_name_length] = '\0';

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          value = *(long *)var_val;
          if ((value < VAL_sshUserKeyDelAction_delRsaKey) || (value > VAL_sshUserKeyDelAction_delBothKeys))
              return SNMP_ERR_WRONGVALUE;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
          value = *(long *)var_val;

         if (SSHD_PMGR_AsyncDeleteUserPublicKey (buffer, value) != TRUE)
         {
             return SNMP_ERR_COMMITFAILED;
          }
          break;
        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
#endif

/* management vlan */
#if (SYS_CPNT_ISOLATED_MGMT_VLAN == TRUE)
/* mgmtVlanVid */
int
do_mgmtVlanVid(netsnmp_mib_handler *handler,
               netsnmp_handler_registration *reginfo,
               netsnmp_agent_request_info *reqinfo,
               netsnmp_request_info *requests)
{
    switch (reqinfo->mode)
    {
    case MODE_GET:
    {
        UI32_T vid_ifidx, vid;

        switch(NETCFG_MGR_GetManagementVid(&vid_ifidx))
        {
            case NETCFG_MGR_OK:
                break;

            case NETCFG_MGR_FAIL: /* no management vlan */
                vid_ifidx = 0;
                break;

            default:
                return SNMP_ERR_GENERR;
        }

        VLAN_IFINDEX_CONVERTTO_VID(vid_ifidx, vid);

        long_return = vid;
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
        break;
    }

    case MODE_SET_RESERVE1:
    {
        UI32_T vid;
        vid = (*requests->requestvb->val.integer);
        if(vid > MAX_mgmtVlanVid || vid < 0) /* 0 for deleting management vlan */
        {
            netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_INCONSISTENTVALUE);
        }

        break;
    }

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
    {
        UI32_T vid, vid_ifidx;

        vid = (*requests->requestvb->val.integer);

        /* delete management vlan */
        if(vid == 0)
        {
            switch(NETCFG_MGR_DeleteManagementVid())
            {
                case NETCFG_MGR_OK:
                    break;

                case NETCFG_MGR_FAIL:
                    netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);

                default:
                    return SNMP_ERR_GENERR;
            }
        }

        /* set management vlan */
        else{

            VLAN_VID_CONVERTTO_IFINDEX(vid, vid_ifidx);

            switch(NETCFG_MGR_SetManagementVid(vid_ifidx))
            {
                case NETCFG_MGR_OK:
                    break;

                case NETCFG_MGR_IP_ALREADY_EXIST: /* There exist IP in the vlan, have to remove ip address first. */
                    return SNMP_ERR_GENERR;

                case NETCFG_MGR_NO_SUCH_INTERFACE: /* Vlan does not exist */
                    return SNMP_ERR_GENERR;

                case NETCFG_MGR_FAIL:
                    netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);

                default:
                    return SNMP_ERR_GENERR;
            }
        }

        break;
    }

    case MODE_SET_COMMIT:
        break;

    case MODE_SET_UNDO:
        break;

    default:
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

/* mgmtVlanDefaultGateway */
int
do_mgmtVlanDefaultGateway(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    switch (reqinfo->mode)
    {

    case MODE_GET:
    {
        UI32_T default_gateway;

        switch(NETCFG_MGR_GetManagementVlanDefaultGateway(&default_gateway))
        {
            case NETCFG_MGR_OK:
                break;

            case NETCFG_MGR_ENTRY_NOT_EXIST:  /* there is no default-gateway */
                default_gateway = 0;
                break;

            case NETCFG_MGR_CAN_NOT_GET: /* fail to get */
                return SNMP_ERR_GENERR;

            default:
                return SNMP_ERR_GENERR;
        }

        ipaddr_return = default_gateway;

       snmp_set_var_typed_value(requests->requestvb, ASN_IPADDRESS, (u_char *) &ipaddr_return, sizeof(ipaddr_return));
        break;
    }

    case MODE_SET_RESERVE1:
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
    {

        UI32_T default_gateway;

        default_gateway = (*requests->requestvb->val.integer);

        /* delete management vlan default-gateway */
        if(default_gateway == 0)
        {
            switch(NETCFG_MGR_DeleteManagementVlanDefaultGateway())
            {
                case NETCFG_MGR_OK:
                    break;

                case NETCFG_MGR_CAN_NOT_DELETE:
                        netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);

                default:
                    return SNMP_ERR_GENERR;
            }
        }

        /* set management vlan default-gateway */
        else
        {
            switch(NETCFG_MGR_SetManagementVlanDefaultGateway(default_gateway))
            {
                case NETCFG_MGR_OK:
                    break;

                case NETCFG_MGR_INVALID_ARG: /* gateway is invalid */
                    return SNMP_ERR_GENERR;

                case NETCFG_MGR_CAN_NOT_ADD:
                    netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);

                default:
                    return SNMP_ERR_GENERR;
            }
        }

        break;
    }

    case MODE_SET_COMMIT:
        break;

    case MODE_SET_UNDO:
        break;

    default:
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

#endif /* end of #if (SYS_CPNT_ISOLATED_MGMT_VLAN==TRUE)*/

#if (SYS_CPNT_MGMT_IP_FLT == TRUE)

#if (SYS_CPNT_IPV6 != TRUE)
/********************************************
 ************ipFilterSnmpTable***************
 ********************************************
 */
#define IPFILTERSNMPENTRY_INSTANCE_LEN  4

BOOL_T ipFilterSnmpTable_OidIndexToData(UI32_T exact, UI32_T compc,
            oid * compl, UI8_T *ipFilterSnmpStartAddress)
{
    UI32_T i;

    if (exact)
    {
        if (compc != IPFILTERSNMPENTRY_INSTANCE_LEN)
        {
            return FALSE;
        }
    }

    for (i = 0; i < IPFILTERSNMPENTRY_INSTANCE_LEN; i++)
    {
        ipFilterSnmpStartAddress[i] = compl[i];
    }

    return TRUE;
}

/*
 * var_ipFilterSnmpTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *
var_ipFilterSnmpTable(struct variable *vp,
            oid     *name,
            size_t  *length,
            int     exact,
            size_t  *var_len,
            WriteMethod **write_method)
{
    /* variables we may use later */
    UI32_T compc = 0;
    UI32_T i;
    oid compl[IPFILTERSNMPENTRY_INSTANCE_LEN] = {0};
    oid best_inst[IPFILTERSNMPENTRY_INSTANCE_LEN] = {0};
    MGMT_IP_FLT_IpFilter_T entry;
    UI8_T ip_ar[SYS_ADPT_IPV4_ADDR_LEN]={0};

    switch (vp->magic)
    {
        case LEAF_ipFilterSnmpEndAddress:
            *write_method = write_ipFilterSnmpEndAddress;
            break;

        case LEAF_ipFilterSnmpStatus:
            *write_method = write_ipFilterSnmpStatus;
            break;

        default:
            *write_method = 0;
            break;
    }

    /* check compc, retrive compl */
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,
                           compl, IPFILTERSNMPENTRY_INSTANCE_LEN);

    memset(&entry, 0, sizeof(entry));
    entry.start_ipaddress.addrlen = 4;
    entry.start_ipaddress.type = VAL_ipFilterSnmpInetAddressType_ipv4;

    if (exact) /* get,set */
    {
        /* get index */
        if (ipFilterSnmpTable_OidIndexToData(exact, compc, compl, entry.start_ipaddress.addr) == FALSE)
        {
            return NULL;
        }

        /* get data */
       if (MGMT_IP_FLT_OK != MGMT_IP_FLT_Snmp_GetIpFilter(&entry))
        {
            return NULL;
        }
    }
    else /* getnext */
    {
        /* get index */
        ipFilterSnmpTable_OidIndexToData(exact, compc, compl, entry.start_ipaddress.addr);

        if (compc < 1)
        {
            /* get data */
            if (MGMT_IP_FLT_OK != MGMT_IP_FLT_Snmp_GetIpFilter(&entry))
            {
                /* get next data */
                if (MGMT_IP_FLT_OK != MGMT_IP_FLT_Snmp_GetNextIpFilter(&entry))
                {
                    return NULL;
                }
            }
        }
        else
        {
            /* get next data */
            if (MGMT_IP_FLT_OK != MGMT_IP_FLT_Snmp_GetNextIpFilter(&entry))
            {
                return NULL;
            }
        }
    }

    memcpy(name, vp->name, vp->namelen*sizeof(oid));

    /* assign data to the oid index */
    for (i = 0; i < entry.start_ipaddress.addrlen; i++)
    {
        best_inst[i] = entry.start_ipaddress.addr[i];
    }
    memcpy(name + vp->namelen, best_inst,
           IPFILTERSNMPENTRY_INSTANCE_LEN * sizeof(oid));
    *length = vp->namelen + IPFILTERSNMPENTRY_INSTANCE_LEN ;

    /* this is where we do the value assignments for the mib results. */
    switch (vp->magic)
    {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case LEAF_ipFilterSnmpStartAddress:
            *var_len = entry.start_ipaddress.addrlen;
            memcpy(return_buf, entry.start_ipaddress.addr, *var_len);
            return (u_char*)return_buf;

#endif
        case LEAF_ipFilterSnmpEndAddress:
        {
            UI32_T value;

            *var_len = entry.end_ipaddress.addrlen;
            strncpy((char *)ip_ar, (char *)entry.end_ipaddress.addr, *var_len);
            IP_LIB_ArraytoUI32(ip_ar, &value);
            long_return = value;
            return (u_char *) &long_return;
        }

        case LEAF_ipFilterSnmpStatus:
            *var_len = sizeof(long_return);
            long_return = VAL_ipFilterSnmpStatus_valid;
            return (u_char *) &long_return;

        default:
            ERROR_MSG("");
    }

    return NULL;
}

int
write_ipFilterSnmpEndAddress(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_IPADDRESS)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len !=  SYS_ADPT_IPV4_ADDR_LEN)
            {
                return SNMP_ERR_WRONGLENGTH;
            }

            break;

        case RESERVE2:
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
            UI32_T value = 0;
            MGMT_IP_FLT_IpFilter_T filter_entry;
            memset(&filter_entry, 0, sizeof(filter_entry));
            filter_entry.start_ipaddress.addrlen = filter_entry.end_ipaddress.addrlen = SYS_ADPT_IPV4_ADDR_LEN;
            filter_entry.start_ipaddress.type = filter_entry.end_ipaddress.type = VAL_ipFilterSnmpInetAddressType_ipv4;

            if (ipFilterSnmpTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), filter_entry.start_ipaddress.addr) == FALSE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            /* The index does not exist in mgmt IP filter
             */
            if(MGMT_IP_FLT_OK != MGMT_IP_FLT_Snmp_GetIpFilter(&filter_entry))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            memcpy(&value, var_val, var_val_len);
            IP_LIB_UI32toArray(value, filter_entry.end_ipaddress.addr);

            if (MGMT_IP_FLT_SetIpFilter(MGMT_IP_FLT_SNMP, &filter_entry)!=MGMT_IP_FLT_OK)
                return SNMP_ERR_COMMITFAILED;
        }
            break;

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

int
write_ipFilterSnmpStatus(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            switch (*(long *)var_val)
            {
                case VAL_ipFilterSnmpStatus_valid:
                    break;

                case VAL_ipFilterSnmpStatus_invalid:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
            I32_T value = 0;
            MGMT_IP_FLT_IpFilter_T filter_entry;
            memset(&filter_entry, 0, sizeof(filter_entry));
            filter_entry.start_ipaddress.addrlen = SYS_ADPT_IPV4_ADDR_LEN;
            filter_entry.start_ipaddress.type = VAL_ipFilterSnmpInetAddressType_ipv4;
            value = * (long *) var_val;

            if (ipFilterSnmpTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), filter_entry.start_ipaddress.addr) == FALSE)
                return SNMP_ERR_COMMITFAILED;

            if (value == VAL_ipFilterSnmpStatus_valid)
            {
                /* The entry has existed in mgmt IP filter
                 */
                if(MGMT_IP_FLT_OK == MGMT_IP_FLT_Snmp_GetIpFilter(&filter_entry))
                {
                    return SNMP_ERR_COMMITFAILED;
                }

                memcpy(&filter_entry.end_ipaddress, &filter_entry.start_ipaddress, sizeof(filter_entry.end_ipaddress));

                if (MGMT_IP_FLT_OK != MGMT_IP_FLT_SetIpFilter(MGMT_IP_FLT_SNMP, &filter_entry))
                {
                    return SNMP_ERR_COMMITFAILED;
                }
            }
            else    /* VAL_ipFilterSnmpStatus_invalid, end_ipaddress.addrlen should be 0 */
            {
                if (MGMT_IP_FLT_OK != MGMT_IP_FLT_DeleteIpFilter(MGMT_IP_FLT_SNMP, &filter_entry))
                {
                    return SNMP_ERR_COMMITFAILED;
                }
            }
        }
            break;

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

/********************************************
 ************ipFilterHTTPTable***************
 ********************************************
 */
#define IPFILTERHTTPENTRY_INSTANCE_LEN  4

BOOL_T ipFilterHTTPTable_OidIndexToData(UI32_T exact, UI32_T compc,
            oid * compl, UI8_T *ipFilterHTTPStartAddress)
{
    UI32_T i;

    if (exact)
    {
        if (compc != IPFILTERHTTPENTRY_INSTANCE_LEN)
        {
            return FALSE;
        }
    }

    for (i = 0; i < IPFILTERHTTPENTRY_INSTANCE_LEN; i++)
    {
        ipFilterHTTPStartAddress[i] = compl[i];
    }

    return TRUE;
}

/*
 * var_ipFilterHTTPTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *
var_ipFilterHTTPTable(struct variable *vp,
            oid     *name,
            size_t  *length,
            int     exact,
            size_t  *var_len,
            WriteMethod **write_method)
{
    /* variables we may use later */
    UI32_T compc = 0;
    UI32_T i;
    oid compl[IPFILTERHTTPENTRY_INSTANCE_LEN] = {0};
    oid best_inst[IPFILTERHTTPENTRY_INSTANCE_LEN] = {0};
    MGMT_IP_FLT_IpFilter_T entry;
    UI8_T ip_ar[SYS_ADPT_IPV4_ADDR_LEN]={0};

    switch (vp->magic)
    {
        case LEAF_ipFilterHTTPEndAddress:
            *write_method = write_ipFilterHTTPEndAddress;
            break;

        case LEAF_ipFilterHTTPStatus:
            *write_method = write_ipFilterHTTPStatus;
            break;

        default:
            *write_method = 0;
            break;
    }

    /* check compc, retrive compl */
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,
                           compl, IPFILTERHTTPENTRY_INSTANCE_LEN);

    memset(&entry, 0, sizeof(entry));
    entry.start_ipaddress.addrlen = 4;
    entry.start_ipaddress.type = VAL_ipFilterHttpInetAddressType_ipv4;

    if (exact) /* get,set */
    {
        /* get index */
        if (ipFilterHTTPTable_OidIndexToData(exact, compc, compl, entry.start_ipaddress.addr) == FALSE)
        {
            return NULL;
        }

        /* get data */
        if (MGMT_IP_FLT_OK != MGMT_IP_FLT_Web_GetIpFilter(&entry))
        {
            return NULL;
        }
    }
    else /* getnext */
    {
        /* get index */
        ipFilterHTTPTable_OidIndexToData(exact, compc, compl, entry.start_ipaddress.addr);

        if (compc < 1)
        {
            /* get data */
            if (MGMT_IP_FLT_OK != MGMT_IP_FLT_Web_GetIpFilter(&entry))
            {
                /* get next data */
                if (MGMT_IP_FLT_OK != MGMT_IP_FLT_WEB_GetNextIpFilter(&entry))
                {
                    return NULL;
                }
            }
        }
        else
        {
            /* get next data */
            if (MGMT_IP_FLT_OK != MGMT_IP_FLT_WEB_GetNextIpFilter(&entry))
            {
                return NULL;
            }
        }
    }

    memcpy(name, vp->name, vp->namelen*sizeof(oid));

    /* assign data to the oid index */
    for (i = 0; i < entry.start_ipaddress.addrlen; i++)
    {
        best_inst[i] = entry.start_ipaddress.addr[i];
    }
    memcpy(name + vp->namelen, best_inst,
           IPFILTERHTTPENTRY_INSTANCE_LEN * sizeof(oid));
    *length = vp->namelen + IPFILTERHTTPENTRY_INSTANCE_LEN ;

    /* this is where we do the value assignments for the mib results. */
    switch (vp->magic)
    {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case LEAF_ipFilterHTTPStartAddress:
            *var_len = entry.start_ipaddress.addrlen;
            memcpy(return_buf, entry.start_ipaddress.addr, *var_len);
            return (u_char*)return_buf;

#endif
        case LEAF_ipFilterHTTPEndAddress:
        {
            UI32_T value = 0;

            *var_len = entry.end_ipaddress.addrlen;
            strncpy((char *)ip_ar, (char *)entry.end_ipaddress.addr, *var_len);
            IP_LIB_ArraytoUI32(ip_ar, &value);
            long_return = value;
            return (u_char *) &long_return;
        }

        case LEAF_ipFilterHTTPStatus:
            *var_len = sizeof(long_return);
            long_return = VAL_ipFilterHTTPStatus_valid;
            return (u_char *) &long_return;

        default:
            ERROR_MSG("");
    }

    return NULL;
}

int
write_ipFilterHTTPEndAddress(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_IPADDRESS)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len !=  SYS_ADPT_IPV4_ADDR_LEN)
            {
                return SNMP_ERR_WRONGLENGTH;
            }

            break;

        case RESERVE2:
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
            UI32_T value = 0;
            MGMT_IP_FLT_IpFilter_T filter_entry;
            memset(&filter_entry, 0, sizeof(filter_entry));
            filter_entry.start_ipaddress.addrlen = filter_entry.end_ipaddress.addrlen = SYS_ADPT_IPV4_ADDR_LEN;
            filter_entry.start_ipaddress.type = filter_entry.end_ipaddress.type = VAL_ipFilterHttpInetAddressType_ipv4;

            if (ipFilterHTTPTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), filter_entry.start_ipaddress.addr) == FALSE)
                return SNMP_ERR_COMMITFAILED;

            /* The index does not exist in mgmt IP filter
             */
            if(MGMT_IP_FLT_OK != MGMT_IP_FLT_Web_GetIpFilter(&filter_entry))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            memcpy(&value, var_val, var_val_len);
            IP_LIB_UI32toArray(value, filter_entry.end_ipaddress.addr);

            if(MGMT_IP_FLT_OK != MGMT_IP_FLT_SetIpFilter( MGMT_IP_FLT_HTTP, &filter_entry))
                return SNMP_ERR_COMMITFAILED;
        }
            break;

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

int
write_ipFilterHTTPStatus(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            switch (*(long *)var_val)
            {
                case VAL_ipFilterHTTPStatus_valid:
                    break;

                case VAL_ipFilterHTTPStatus_invalid:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
            I32_T value = 0;
            MGMT_IP_FLT_IpFilter_T filter_entry;
            memset(&filter_entry, 0, sizeof(filter_entry));
            filter_entry.start_ipaddress.addrlen = SYS_ADPT_IPV4_ADDR_LEN;
            filter_entry.start_ipaddress.type = VAL_ipFilterHttpInetAddressType_ipv4;
            value = * (long *) var_val;

            if (ipFilterHTTPTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), filter_entry.start_ipaddress.addr) == FALSE)
                return SNMP_ERR_COMMITFAILED;

            if (VAL_ipFilterHTTPStatus_valid == value)
            {
                /* The entry has existed in mgmt IP filter
                 */
                if(MGMT_IP_FLT_OK == MGMT_IP_FLT_Web_GetIpFilter(&filter_entry))
                {
                    return SNMP_ERR_COMMITFAILED;
                }

                memcpy(&filter_entry.end_ipaddress, &filter_entry.start_ipaddress, sizeof(filter_entry.end_ipaddress));

                if (MGMT_IP_FLT_OK != MGMT_IP_FLT_SetIpFilter(MGMT_IP_FLT_HTTP, &filter_entry))
                {
                    return SNMP_ERR_COMMITFAILED;
                }
            }
            else    /* VAL_ipFilterHTTPStatus_invalid, end_ipaddress.addrlen should be 0 */
            {
                if (MGMT_IP_FLT_OK != MGMT_IP_FLT_DeleteIpFilter(MGMT_IP_FLT_HTTP, &filter_entry))
                {
                    return SNMP_ERR_COMMITFAILED;
                }
            }
        }
            break;

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

/********************************************
 **********ipFilterTelnetTable***************
 ********************************************
 */
#define IPFILTERTELNETENTRY_INSTANCE_LEN  4

BOOL_T ipFilterTelnetTable_OidIndexToData(UI32_T exact, UI32_T compc,
            oid * compl, UI8_T *ipFilterTelnetStartAddress)
{
    UI32_T i;

    if (exact)
    {
        if (compc != IPFILTERTELNETENTRY_INSTANCE_LEN)
        {
            return FALSE;
        }
    }

    for (i = 0; i < IPFILTERTELNETENTRY_INSTANCE_LEN; i++)
    {
        ipFilterTelnetStartAddress[i] = compl[i];
    }

    return TRUE;
}

/*
 * var_ipFilterTelnetTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *
var_ipFilterTelnetTable(struct variable *vp,
            oid     *name,
            size_t  *length,
            int     exact,
            size_t  *var_len,
            WriteMethod **write_method)
{
    /* variables we may use later */
    UI32_T compc = 0;
    UI32_T i;
    oid compl[IPFILTERTELNETENTRY_INSTANCE_LEN] = {0};
    oid best_inst[IPFILTERTELNETENTRY_INSTANCE_LEN] = {0};
    MGMT_IP_FLT_IpFilter_T entry;
    UI8_T ip_ar[SYS_ADPT_IPV4_ADDR_LEN]={0};

    switch (vp->magic)
    {
        case LEAF_ipFilterTelnetEndAddress:
            *write_method = write_ipFilterTelnetEndAddress;
            break;

        case LEAF_ipFilterTelnetStatus:
            *write_method = write_ipFilterTelnetStatus;
            break;

        default:
            *write_method = 0;
            break;
    }

    /* check compc, retrive compl */
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,
                           compl, IPFILTERTELNETENTRY_INSTANCE_LEN);

    memset(&entry, 0, sizeof(entry));
    entry.start_ipaddress.addrlen = 4;
    entry.start_ipaddress.type = VAL_ipFilterTelnetInetAddressType_ipv4;

    if (exact) /* get,set */
    {
        /* get index */
        if (ipFilterTelnetTable_OidIndexToData(exact, compc, compl, entry.start_ipaddress.addr) == FALSE)
        {
            return NULL;
        }

        /* get data */
        if (MGMT_IP_FLT_OK != MGMT_IP_FLT_Telnet_GetIpFilter(&entry))
        {
            return NULL;
        }
    }
    else /* getnext */
    {
        /* get index */
        ipFilterTelnetTable_OidIndexToData(exact, compc, compl, entry.start_ipaddress.addr);

        if (compc < 1)
        {
            /* get data */
            if (MGMT_IP_FLT_OK != MGMT_IP_FLT_Telnet_GetIpFilter(&entry))
            {
                /* get next data */
                if (MGMT_IP_FLT_OK != MGMT_IP_FLT_TELNET_GetNextIpFilter(&entry))
                {
                    return NULL;
                }
            }
        }
        else
        {
            /* get next data */
            if (MGMT_IP_FLT_OK != MGMT_IP_FLT_TELNET_GetNextIpFilter(&entry))
            {
                return NULL;
            }
        }
    }

    memcpy(name, vp->name, vp->namelen*sizeof(oid));

    /* assign data to the oid index */
    for (i = 0; i < entry.start_ipaddress.addrlen; i++)
    {
        best_inst[i] = entry.start_ipaddress.addr[i];
    }
    memcpy(name + vp->namelen, best_inst,
           IPFILTERTELNETENTRY_INSTANCE_LEN * sizeof(oid));
    *length = vp->namelen + IPFILTERTELNETENTRY_INSTANCE_LEN ;

    /* this is where we do the value assignments for the mib results. */
    switch (vp->magic)
    {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case LEAF_ipFilterTelnetStartAddress:
            *var_len = entry.start_ipaddress.addrlen;
            memcpy(return_buf, entry.start_ipaddress.addr, *var_len);
            return (u_char*)return_buf;

#endif
        case LEAF_ipFilterTelnetEndAddress:
        {
            UI32_T value = 0;

            *var_len = entry.end_ipaddress.addrlen;
            strncpy((char *)ip_ar, (char *)entry.end_ipaddress.addr, *var_len);
            IP_LIB_ArraytoUI32(ip_ar, &value);
            long_return = value;
            return (u_char *) &long_return;
        }

        case LEAF_ipFilterTelnetStatus:
            *var_len = sizeof(long_return);
            long_return = VAL_ipFilterTelnetStatus_valid;
            return (u_char *) &long_return;

        default:
            ERROR_MSG("");
    }

    return NULL;
}

int
write_ipFilterTelnetEndAddress(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_IPADDRESS)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len !=  SYS_ADPT_IPV4_ADDR_LEN)
            {
                return SNMP_ERR_WRONGLENGTH;
            }

            break;

        case RESERVE2:
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
            UI32_T value = 0;
            MGMT_IP_FLT_IpFilter_T filter_entry;
            memset(&filter_entry, 0, sizeof(filter_entry));
            filter_entry.start_ipaddress.addrlen = filter_entry.end_ipaddress.addrlen = SYS_ADPT_IPV4_ADDR_LEN;
            filter_entry.start_ipaddress.type = filter_entry.end_ipaddress.type = VAL_ipFilterTelnetInetAddressType_ipv4;

            if (ipFilterTelnetTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), filter_entry.start_ipaddress.addr) == FALSE)
                return SNMP_ERR_COMMITFAILED;

            /* The index does not exist in mgmt IP filter
             */
            if(MGMT_IP_FLT_OK != MGMT_IP_FLT_Telnet_GetIpFilter(&filter_entry))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            memcpy(&value, var_val, var_val_len);
            IP_LIB_UI32toArray(value, filter_entry.end_ipaddress.addr);

            if(MGMT_IP_FLT_OK != MGMT_IP_FLT_SetIpFilter( MGMT_IP_FLT_TELNET, &filter_entry))
                return SNMP_ERR_COMMITFAILED;
        }
            break;

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

int
write_ipFilterTelnetStatus(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            switch (*(long *)var_val)
            {
                case VAL_ipFilterTelnetStatus_valid:
                    break;

                case VAL_ipFilterTelnetStatus_invalid:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
            I32_T value = 0;
            MGMT_IP_FLT_IpFilter_T filter_entry;
            memset(&filter_entry, 0, sizeof(filter_entry));
            filter_entry.start_ipaddress.addrlen = SYS_ADPT_IPV4_ADDR_LEN;
            filter_entry.start_ipaddress.type = VAL_ipFilterTelnetInetAddressType_ipv4;
            value = * (long *) var_val;

            if (ipFilterTelnetTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), filter_entry.start_ipaddress.addr) == FALSE)
                return SNMP_ERR_COMMITFAILED;

            if (VAL_ipFilterTelnetStatus_valid == value)  /* add */
            {
                /* The entry has existed in mgmt IP filter
                 */
                if(MGMT_IP_FLT_OK == MGMT_IP_FLT_Telnet_GetIpFilter(&filter_entry))
                {
                    return SNMP_ERR_COMMITFAILED;
                }

                memcpy(&filter_entry.end_ipaddress, &filter_entry.start_ipaddress, sizeof(filter_entry.end_ipaddress));

                if(MGMT_IP_FLT_OK !=
                    MGMT_IP_FLT_SetIpFilter( MGMT_IP_FLT_TELNET, &filter_entry))
                {
                    return SNMP_ERR_COMMITFAILED;
                }
            }
            else /* VAL_ipFilterTelnetStatus_invalid, end_ipaddress.addrlen should be 0 */
            {
                if (MGMT_IP_FLT_OK != MGMT_IP_FLT_DeleteIpFilter(MGMT_IP_FLT_TELNET, &filter_entry))
                {
                    return SNMP_ERR_COMMITFAILED;
                }
            }
        }
            break;

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

#else  /* else of #if (SYS_CPNT_IPV6 != TRUE) */

#define IPFILTERINETENTRY_INSTANCE_LEN  21  /* manually coded for IPv6z */

/* Convert OID to Index for
 * ipFilterSnmpInetTable, ipFilterHttpInetTable, and ipFilterTelnetInetTable.
 * VAL_ipFilterSnmpInetAddressType_ipv4, VAL_ipFilterHttpInetAddressType_ipv4,
 * and VAL_ipFilterTelnetInetAddressType_ipv4 should be the same value.
 */
static BOOL_T ipFilterInetTable_OidIndexToData(UI32_T exact, UI32_T compc,
            oid * compl, UI32_T *ipFilterInetAddressType,
            UI8_T *ipFilterInetAddressStart, UI32_T *ipFilterInetAddressStart_length)
{
    UI32_T  i;

    /* get or write */
    if (exact)
    {
        /* check the index length: variable-length index
         *
         * compc < 1, means the "address content (without length-prefix)" is empty
         */
        if ((compc < 1) || (compc > IPFILTERINETENTRY_INSTANCE_LEN))  /* the dynamic size index */
        {
            return FALSE;
        }
    }

    /* get-next without index
     */
    if (compc == 0)
    {
        return TRUE;
    }

    /* copy type and length
     */
    *ipFilterInetAddressType = compl[0];
    *ipFilterInetAddressStart_length = compc - 1;

    /* copy each byte of the address
     */
    for (i = 0; i < compc - 1; i++)
    {
        ipFilterInetAddressStart[i] = compl[1 + i];
    }

    return TRUE;
}

/********************************************
 ***********ipFilterSnmpInetTable************
 ********************************************
 */
#define IPFILTERSNMPINETENTRY_INSTANCE_LEN  21  /* manually coded for IPv6z */

BOOL_T ipFilterSnmpInetTable_OidIndexToData(UI32_T exact, UI32_T compc,
            oid *compl, UI32_T *ipFilterSnmpInetAddressType,
            UI8_T *ipFilterSnmpInetAddressStart, UI32_T *ipFilterSnmpInetAddressStart_length)
{
    return ipFilterInetTable_OidIndexToData(exact, compc, compl, ipFilterSnmpInetAddressType,
            ipFilterSnmpInetAddressStart, ipFilterSnmpInetAddressStart_length);
}

/*
 * var_ipFilterSnmpInetTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *
var_ipFilterSnmpInetTable(struct variable *vp,
            oid     *name,
            size_t  *length,
            int     exact,
            size_t  *var_len,
            WriteMethod **write_method)
{
    /* variables we may use later */
    UI32_T compc = 0;
    UI32_T i;
    oid compl[IPFILTERSNMPINETENTRY_INSTANCE_LEN] = {0};
    oid best_inst[IPFILTERSNMPINETENTRY_INSTANCE_LEN] = {0};

    /* table-specific variables
     */
    MGMT_IP_FLT_IpFilter_T entry;

    /* extracted from user index sub-OID
     */
    UI32_T type = 0, addr_len = 0, preflen = 0;
    UI8_T addr_ar[SYS_TYPE_IPV6Z_ADDR_LEN] = {0};  /* longest case: IPv6z, with zone ID */

    switch (vp->magic)
    {
        case LEAF_ipFilterSnmpInetAddressEnd:
            *write_method = write_ipFilterSnmpInetAddressEnd;
            break;

        case LEAF_ipFilterSnmpInetStatus:
            *write_method = write_ipFilterSnmpInetStatus;
            break;

        default:
            *write_method = 0;
            break;
    }

    /* check compc, retrive compl */
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,
                           compl, IPFILTERSNMPINETENTRY_INSTANCE_LEN);

    memset(&entry, 0, sizeof(entry));

    if (exact) /* get,set */
    {
        /* get index */
        if (ipFilterSnmpInetTable_OidIndexToData(exact, compc, compl,
            &type, addr_ar, &addr_len) == FALSE)
        {
            return NULL;
        }

        /* convert to L_INET_AddrIp_T
         */
        if (! SNMP_MGR_ConvertInetAddrAndTypeToLInetAddr(type,
            addr_len, addr_ar, 0, (L_INET_Addr_T *) &entry.start_ipaddress))
        {
            return NULL;
        }

        /* get data */
        if (MGMT_IP_FLT_OK != MGMT_IP_FLT_Snmp_GetIpFilter(&entry))
        {
            return NULL;
        }
    }
    else /* getnext */
    {
        /* get index */
        ipFilterSnmpInetTable_OidIndexToData(exact, compc, compl,
            &type, addr_ar, &addr_len);

        /* convert to L_INET_AddrIp_T
         */
        if (! SNMP_MGR_ConvertInetAddrAndTypeToLInetAddr(type,
            addr_len, addr_ar, 0, (L_INET_Addr_T *) &entry.start_ipaddress))
        {
            return NULL;
        }

        /* Check the length of inputing index.  If compc is less than the
         * instance length, we should try get {A.B.C.0.0...}, where A.B.C was
         * obtained from the "..._OidIndexToData" function call, and
         * 0.0... was initialized in the beginning of this function.
         * This instance may exist in the core layer.
         */
        /* NOTE:
         * This is a variable-length index:
         * IfIndex.AddressType.length-prefixed-InetAddress.PrefixLength
         * We check length of address based on type.
         */
        if ( (type == 0)
            || ((type == VAL_ipFilterSnmpInetAddressType_ipv4)
                && (addr_len < SYS_TYPE_IPV4_ADDR_LEN))
            || ((type == VAL_ipFilterSnmpInetAddressType_ipv6)
                && (addr_len < SYS_TYPE_IPV6_ADDR_LEN))
            || ((type == VAL_ipFilterSnmpInetAddressType_ipv4z)
                && (addr_len < SYS_TYPE_IPV4Z_ADDR_LEN))
            || ((type == VAL_ipFilterSnmpInetAddressType_ipv6z)
                && (addr_len < SYS_TYPE_IPV6Z_ADDR_LEN)) )
        {
            /* get data */
            if (MGMT_IP_FLT_OK != MGMT_IP_FLT_Snmp_GetIpFilter(&entry))
            {
                /* get next data */
                if (MGMT_IP_FLT_OK != MGMT_IP_FLT_Snmp_GetNextIpFilter(&entry))
                {
                    return NULL;
                }
            }
        }
        else
        {
            /* get next data */
            if (MGMT_IP_FLT_OK != MGMT_IP_FLT_Snmp_GetNextIpFilter(&entry))
            {
                return NULL;
            }
        }
    }

    memcpy(name, vp->name, vp->namelen*sizeof(oid));

    /* convert L_INET_AddrIp_T back to SNMP values
     */
    if (! SNMP_MGR_ConvertLInetAddrToInetAddrAndType(
        (L_INET_Addr_T *) &entry.start_ipaddress,
        &type, &addr_len, addr_ar, &preflen))
    {
        /* conversion failed
         */
        *var_len = 0;
    }
    else
    {
        *var_len = (size_t) addr_len;
    }

    /* assign data to the oid index */
    best_inst[0] = type;

    for (i = 0; i < addr_len; i++)
    {
        best_inst[1 + i] = addr_ar[i];
    }
    memcpy(name + vp->namelen, best_inst,
           (1 + addr_len) * sizeof(oid));
    *length = vp->namelen + (1 + addr_len);

    /* this is where we do the value assignments for the mib results. */
    switch (vp->magic)
    {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case LEAF_ipFilterSnmpInetAddressType:
            *var_len = sizeof(long_return);
            long_return = type;
            return (u_char *) &long_return;

#endif
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case LEAF_ipFilterSnmpInetAddressStart:
            *var_len = addr_len;
            memcpy(return_buf, addr_ar, *var_len);
            return (u_char*)return_buf;

#endif
        case LEAF_ipFilterSnmpInetAddressEnd:
        {
            UI32_T type, addr_len, preflen;

            if (! SNMP_MGR_ConvertLInetAddrToInetAddrAndType(
                (L_INET_Addr_T *) &entry.end_ipaddress,
                &type, &addr_len, return_buf, &preflen))
            {
                /* conversion failed
                 */
                *var_len = 0;
            }
            else
            {
                *var_len = (size_t) addr_len;
            }

            return (u_char *) return_buf;
        }

        case LEAF_ipFilterSnmpInetStatus:
            *var_len = sizeof(long_return);
            long_return = VAL_ipFilterSnmpInetStatus_valid;
            return (u_char *) &long_return;

        default:
            ERROR_MSG("");
    }

    return NULL;
}

int
write_ipFilterSnmpInetAddressEnd(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    /* extracted from user index sub-OID
     */
    UI32_T type = 0, addr_len = 0;
    UI8_T addr_ar[SYS_TYPE_IPV6Z_ADDR_LEN] = {0};  /* longest case: IPv6z, with zone ID */

    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_OCTET_STR)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len < MINSIZE_ipFilterSnmpInetAddressEnd ||
                var_val_len > MAXSIZE_ipFilterSnmpInetAddressEnd)
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;

        case RESERVE2:
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
            MGMT_IP_FLT_IpFilter_T filter_entry;

            memset(&filter_entry, 0, sizeof(filter_entry));

            /* extract index
             */
            if (FALSE == ipFilterSnmpInetTable_OidIndexToData(
                TRUE, name_len - oid_name_length, &(name[oid_name_length]),
                &type, addr_ar, &addr_len))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            /* only support IPv4(z) and IPv6(z)
             */
            if ( (type < VAL_ipFilterSnmpInetAddressType_ipv4)
                || (type > VAL_ipFilterSnmpInetAddressType_ipv6z) )
            {
                return SNMP_ERR_COMMITFAILED;
            }

            /* convert to L_INET_AddrIp_T (start)
             */
            if (! SNMP_MGR_ConvertInetAddrAndTypeToLInetAddr(type,
                addr_len, addr_ar, 0, (L_INET_Addr_T *) &filter_entry.start_ipaddress))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            /* The index does not exist in mgmt IP filter
             */
            if (MGMT_IP_FLT_OK != MGMT_IP_FLT_Snmp_GetIpFilter(&filter_entry))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            /* convert to L_INET_AddrIp_T (end)
             */
            if (! SNMP_MGR_ConvertInetAddrAndTypeToLInetAddr(type,
                var_val_len, var_val, 0, (L_INET_Addr_T *) &filter_entry.end_ipaddress))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            /* set to core layer
             */
            if (MGMT_IP_FLT_OK != MGMT_IP_FLT_SetIpFilter( MGMT_IP_FLT_SNMP, &filter_entry))
            {
                return SNMP_ERR_COMMITFAILED;
            }
            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

int
write_ipFilterSnmpInetStatus(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    /* extracted from user index sub-OID
     */
    UI32_T type = 0, addr_len = 0;
    UI8_T addr_ar[SYS_TYPE_IPV6Z_ADDR_LEN] = {0};  /* longest case: IPv6z, with zone ID */

    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            switch (*(long *)var_val)
            {
                case VAL_ipFilterSnmpInetStatus_valid:
                    break;

                case VAL_ipFilterSnmpInetStatus_invalid:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
            I32_T value;
            MGMT_IP_FLT_IpFilter_T filter_entry;

            memset(&filter_entry, 0, sizeof(filter_entry));

            /* extract index
             */
            if (FALSE == ipFilterSnmpInetTable_OidIndexToData(
                TRUE, name_len - oid_name_length, &(name[oid_name_length]),
                &type, addr_ar, &addr_len))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            /* only support IPv4(z) and IPv6(z)
             */
            if ( (type < VAL_ipFilterSnmpInetAddressType_ipv4)
                || (type > VAL_ipFilterSnmpInetAddressType_ipv6z) )
            {
                return SNMP_ERR_COMMITFAILED;
            }

            /* convert to L_INET_AddrIp_T (start)
             */
            if (! SNMP_MGR_ConvertInetAddrAndTypeToLInetAddr(type,
                addr_len, addr_ar, 0, (L_INET_Addr_T *) &filter_entry.start_ipaddress))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            /* get user value
             */
            value = * (long *) var_val;

            if (VAL_ipFilterSnmpInetStatus_valid == value)  /* add */
            {
                /* The entry has existed in mgmt IP filter
                 */
                if (MGMT_IP_FLT_OK == MGMT_IP_FLT_Snmp_GetIpFilter(&filter_entry))
                {
                    return SNMP_ERR_COMMITFAILED;
                }

                memcpy(&filter_entry.end_ipaddress, &filter_entry.start_ipaddress, sizeof(filter_entry.end_ipaddress));

                if (MGMT_IP_FLT_OK != MGMT_IP_FLT_SetIpFilter( MGMT_IP_FLT_SNMP, &filter_entry))
                {
                    return SNMP_ERR_COMMITFAILED;
                }
            }
            else    /* VAL_ipFilterSnmpInetStatus_invalid, end_ipaddress.addrlen should be 0 */
            {
                if (MGMT_IP_FLT_OK != MGMT_IP_FLT_DeleteIpFilter(MGMT_IP_FLT_SNMP, &filter_entry))
                {
                    return SNMP_ERR_COMMITFAILED;
                }
            }
            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

/********************************************
 ***********ipFilterHttpInetTable************
 ********************************************
 */
#define IPFILTERHTTPINETENTRY_INSTANCE_LEN  21  /* manually coded for IPv6z */

BOOL_T ipFilterHttpInetTable_OidIndexToData(UI32_T exact, UI32_T compc,
            oid *compl, UI32_T *ipFilterHttpInetAddressType,
            UI8_T *ipFilterHttpInetAddressStart, UI32_T *ipFilterHttpInetAddressStart_length)
{
    return ipFilterInetTable_OidIndexToData(exact, compc, compl, ipFilterHttpInetAddressType,
            ipFilterHttpInetAddressStart, ipFilterHttpInetAddressStart_length);
}

/*
 * var_ipFilterHttpInetTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *
var_ipFilterHttpInetTable(struct variable *vp,
            oid     *name,
            size_t  *length,
            int     exact,
            size_t  *var_len,
            WriteMethod **write_method)
{
    /* variables we may use later */
    UI32_T compc = 0;
    UI32_T i;
    oid compl[IPFILTERHTTPINETENTRY_INSTANCE_LEN] = {0};
    oid best_inst[IPFILTERHTTPINETENTRY_INSTANCE_LEN] = {0};

    /* table-specific variables
     */
    MGMT_IP_FLT_IpFilter_T entry;

    /* extracted from user index sub-OID
     */
    UI32_T type = 0, addr_len = 0, preflen = 0;
    UI8_T addr_ar[SYS_TYPE_IPV6Z_ADDR_LEN] = {0};  /* longest case: IPv6z, with zone ID */

    switch (vp->magic)
    {
        case LEAF_ipFilterHttpInetAddressEnd:
            *write_method = write_ipFilterHttpInetAddressEnd;
            break;

        case LEAF_ipFilterHttpInetStatus:
            *write_method = write_ipFilterHttpInetStatus;
            break;

        default:
            *write_method = 0;
            break;
    }

    /* check compc, retrive compl */
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,
                           compl, IPFILTERHTTPINETENTRY_INSTANCE_LEN);

    memset(&entry, 0, sizeof(entry));

    if (exact) /* get,set */
    {
        /* get index */
        if (ipFilterHttpInetTable_OidIndexToData(exact, compc, compl,
            &type, addr_ar, &addr_len) == FALSE)
        {
            return NULL;
        }

        /* convert to L_INET_AddrIp_T
         */
        if (! SNMP_MGR_ConvertInetAddrAndTypeToLInetAddr(type,
            addr_len, addr_ar, 0, (L_INET_Addr_T *) &entry.start_ipaddress))
        {
            return NULL;
        }

        /* get data */
        if (MGMT_IP_FLT_OK != MGMT_IP_FLT_Web_GetIpFilter(&entry))
        {
            return NULL;
        }
    }
    else /* getnext */
    {
        /* get index */
        ipFilterHttpInetTable_OidIndexToData(exact, compc, compl,
            &type, addr_ar, &addr_len);

        /* convert to L_INET_AddrIp_T
         */
        if (! SNMP_MGR_ConvertInetAddrAndTypeToLInetAddr(type,
            addr_len, addr_ar, 0, (L_INET_Addr_T *) &entry.start_ipaddress))
        {
            return NULL;
        }

        /* Check the length of inputing index.  If compc is less than the
         * instance length, we should try get {A.B.C.0.0...}, where A.B.C was
         * obtained from the "..._OidIndexToData" function call, and
         * 0.0... was initialized in the beginning of this function.
         * This instance may exist in the core layer.
         */
        /* NOTE:
         * This is a variable-length index:
         * IfIndex.AddressType.length-prefixed-InetAddress.PrefixLength
         * We check length of address based on type.
         */
        if ( (type == 0)
            || ((type == VAL_ipFilterHttpInetAddressType_ipv4)
                && (addr_len < SYS_TYPE_IPV4_ADDR_LEN))
            || ((type == VAL_ipFilterHttpInetAddressType_ipv6)
                && (addr_len < SYS_TYPE_IPV6_ADDR_LEN))
            || ((type == VAL_ipFilterHttpInetAddressType_ipv4z)
                && (addr_len < SYS_TYPE_IPV4Z_ADDR_LEN))
            || ((type == VAL_ipFilterHttpInetAddressType_ipv6z)
                && (addr_len < SYS_TYPE_IPV6Z_ADDR_LEN)) )
        {
            /* get data */
            if (MGMT_IP_FLT_OK != MGMT_IP_FLT_Web_GetIpFilter(&entry))
            {
                /* get next data */
                if (MGMT_IP_FLT_OK != MGMT_IP_FLT_WEB_GetNextIpFilter(&entry))
                {
                    return NULL;
                }
            }
        }
        else
        {
            /* get next data */
            if (MGMT_IP_FLT_OK != MGMT_IP_FLT_WEB_GetNextIpFilter(&entry))
            {
                return NULL;
            }
        }
    }

    memcpy(name, vp->name, vp->namelen*sizeof(oid));

    /* convert L_INET_AddrIp_T back to SNMP values
     */
    if (! SNMP_MGR_ConvertLInetAddrToInetAddrAndType(
        (L_INET_Addr_T *) &entry.start_ipaddress,
        &type, &addr_len, addr_ar, &preflen))
    {
        /* convension failure */
        *var_len = 0;
    }
    else
    {
        *var_len = (size_t) addr_len;
    }

    /* assign data to the oid index */
    best_inst[0] = type;

    for (i = 0; i < addr_len; i++)
    {
        best_inst[1 + i] = addr_ar[i];
    }
    memcpy(name + vp->namelen, best_inst, (1 + addr_len) * sizeof(oid));
    *length = vp->namelen + (1 + addr_len);

    /* this is where we do the value assignments for the mib results. */
    switch (vp->magic)
    {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case LEAF_ipFilterHttpInetAddressType:
            *var_len = sizeof(long_return);
            long_return = type;
            return (u_char *) &long_return;

#endif
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case LEAF_ipFilterHttpInetAddressStart:
            *var_len = addr_len;
            memcpy(return_buf, addr_ar, *var_len);
            return (u_char*)return_buf;

#endif
        case LEAF_ipFilterHttpInetAddressEnd:
        {
            UI32_T type, addr_len, preflen;

            if (! SNMP_MGR_ConvertLInetAddrToInetAddrAndType(
                (L_INET_Addr_T *) &entry.end_ipaddress,
                &type, &addr_len, return_buf, &preflen))
            {
                /* conversion failed
                 */
                *var_len = 0;
            }
            else
            {
                *var_len = (size_t) addr_len;
            }

            return (u_char *) return_buf;
        }

        case LEAF_ipFilterHttpInetStatus:
            *var_len = sizeof(long_return);
            long_return = VAL_ipFilterHttpInetStatus_valid;
            return (u_char *) &long_return;

        default:
            ERROR_MSG("");
    }

    return NULL;
}

int
write_ipFilterHttpInetAddressEnd(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    /* extracted from user index sub-OID
     */
    UI32_T type = 0, addr_len = 0;
    UI8_T addr_ar[SYS_TYPE_IPV6Z_ADDR_LEN] = {0};  /* longest case: IPv6z, with zone ID */

    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_OCTET_STR)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len < MINSIZE_ipFilterHttpInetAddressEnd ||
                var_val_len > MAXSIZE_ipFilterHttpInetAddressEnd)
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;

        case RESERVE2:
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
            MGMT_IP_FLT_IpFilter_T filter_entry;

            memset(&filter_entry, 0, sizeof(filter_entry));

            /* extract index
             */
            if (FALSE == ipFilterHttpInetTable_OidIndexToData(
                TRUE, name_len - oid_name_length, &(name[oid_name_length]),
                &type, addr_ar, &addr_len))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            /* only support IPv4(z) and IPv6(z)
             */
            if ( (type < VAL_ipFilterHttpInetAddressType_ipv4)
                || (type > VAL_ipFilterHttpInetAddressType_ipv6z) )
            {
                return SNMP_ERR_COMMITFAILED;
            }

            /* convert to L_INET_AddrIp_T (start)
             */
            if (! SNMP_MGR_ConvertInetAddrAndTypeToLInetAddr(type,
                addr_len, addr_ar, 0, (L_INET_Addr_T *) &filter_entry.start_ipaddress))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            /* The index does not exist in mgmt IP filter
             */
            if (MGMT_IP_FLT_OK != MGMT_IP_FLT_Web_GetIpFilter(&filter_entry))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            /* convert to L_INET_AddrIp_T (end)
             */
            if (! SNMP_MGR_ConvertInetAddrAndTypeToLInetAddr(type,
                var_val_len, var_val, 0, (L_INET_Addr_T *) &filter_entry.end_ipaddress))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            /* set to core layer
             */
            if (MGMT_IP_FLT_OK != MGMT_IP_FLT_SetIpFilter( MGMT_IP_FLT_HTTP, &filter_entry))
            {
                return SNMP_ERR_COMMITFAILED;
            }
            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

int
write_ipFilterHttpInetStatus(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    /* extracted from user index sub-OID
     */
    UI32_T type = 0, addr_len = 0;
    UI8_T addr_ar[SYS_TYPE_IPV6Z_ADDR_LEN] = {0};  /* longest case: IPv6z, with zone ID */

    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            switch (*(long *)var_val)
            {
                case VAL_ipFilterHttpInetStatus_valid:
                    break;

                case VAL_ipFilterHttpInetStatus_invalid:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
            I32_T value;
            MGMT_IP_FLT_IpFilter_T filter_entry;

            memset(&filter_entry, 0, sizeof(filter_entry));

            /* extract index
             */
            if (FALSE == ipFilterHttpInetTable_OidIndexToData(
                TRUE, name_len - oid_name_length, &(name[oid_name_length]),
                &type, addr_ar, &addr_len))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            /* only support IPv4(z) and IPv6(z)
             */
            if ( (type < VAL_ipFilterHttpInetAddressType_ipv4)
                || (type > VAL_ipFilterHttpInetAddressType_ipv6z) )
            {
                return SNMP_ERR_COMMITFAILED;
            }

            /* convert to L_INET_AddrIp_T (start)
             */
            if (! SNMP_MGR_ConvertInetAddrAndTypeToLInetAddr(type,
                addr_len, addr_ar, 0, (L_INET_Addr_T *) &filter_entry.start_ipaddress))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            value = * (long *) var_val;

            if (VAL_ipFilterHttpInetStatus_valid == value)  /* add */
            {
                /* The entry has existed in mgmt IP filter
                 */
                if (MGMT_IP_FLT_OK == MGMT_IP_FLT_Web_GetIpFilter(&filter_entry))
                {
                    return SNMP_ERR_COMMITFAILED;
                }

                memcpy(&filter_entry.end_ipaddress, &filter_entry.start_ipaddress, sizeof(filter_entry.end_ipaddress));

                if (MGMT_IP_FLT_OK !=
                    MGMT_IP_FLT_SetIpFilter( MGMT_IP_FLT_HTTP, &filter_entry))
                {
                    return SNMP_ERR_COMMITFAILED;
                }
            }
            else    /* VAL_ipFilterHttpInetStatus_invalid, end_ipaddress.addrlen should be 0 */
            {
                if (MGMT_IP_FLT_OK != MGMT_IP_FLT_DeleteIpFilter(MGMT_IP_FLT_HTTP, &filter_entry))
                {
                    return SNMP_ERR_COMMITFAILED;
                }
            }
            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

/********************************************
 **********ipFilterTelnetInetTable***********
 ********************************************
 */
#define IPFILTERTELNETINETENTRY_INSTANCE_LEN  21  /* manually coded for IPv6z */

BOOL_T ipFilterTelnetInetTable_OidIndexToData(UI32_T exact, UI32_T compc,
            oid *compl, UI32_T *ipFilterTelnetInetAddressType,
            UI8_T *ipFilterTelnetInetAddressStart,
            UI32_T *ipFilterTelnetInetAddressStart_length)
{
    return ipFilterInetTable_OidIndexToData(exact, compc, compl, ipFilterTelnetInetAddressType,
            ipFilterTelnetInetAddressStart, ipFilterTelnetInetAddressStart_length);
}

/*
 * var_ipFilterTelnetInetTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
/*
 * var_ipFilterTelnetInetTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *
var_ipFilterTelnetInetTable(struct variable *vp,
            oid     *name,
            size_t  *length,
            int     exact,
            size_t  *var_len,
            WriteMethod **write_method)
{
    /* variables we may use later */
    UI32_T compc = 0;
    UI32_T i;
    oid compl[IPFILTERTELNETINETENTRY_INSTANCE_LEN] = {0};
    oid best_inst[IPFILTERTELNETINETENTRY_INSTANCE_LEN] = {0};

    /* table-specific variables
     */
    MGMT_IP_FLT_IpFilter_T entry;

    /* extracted from user index sub-OID
     */
    UI32_T type = 0, addr_len = 0, preflen = 0;
    UI8_T addr_ar[SYS_TYPE_IPV6Z_ADDR_LEN] = {0};  /* longest case: IPv6z, with zone ID */

    switch (vp->magic)
    {
        case LEAF_ipFilterTelnetInetAddressEnd:
            *write_method = write_ipFilterTelnetInetAddressEnd;
            break;

        case LEAF_ipFilterTelnetInetStatus:
            *write_method = write_ipFilterTelnetInetStatus;
            break;

        default:
            *write_method = 0;
            break;
    }

    /* check compc, retrive compl */
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,
                           compl, IPFILTERTELNETINETENTRY_INSTANCE_LEN);

    memset(&entry, 0, sizeof(entry));

    if (exact) /* get,set */
    {
        /* get index */
        if (ipFilterTelnetInetTable_OidIndexToData(exact, compc, compl,
            &type, addr_ar, &addr_len) == FALSE)
        {
            return NULL;
        }

        /* convert to L_INET_AddrIp_T
         */
        if (! SNMP_MGR_ConvertInetAddrAndTypeToLInetAddr(type,
            addr_len, addr_ar, 0, (L_INET_Addr_T *) &entry.start_ipaddress))
        {
            return NULL;
        }

        /* get data */
        if (MGMT_IP_FLT_OK != MGMT_IP_FLT_Telnet_GetIpFilter(&entry))
        {
            return NULL;
        }
    }
    else /* getnext */
    {
        /* get index */
        ipFilterTelnetInetTable_OidIndexToData(exact, compc, compl,
            &type, addr_ar, &addr_len);

        /* convert to L_INET_AddrIp_T
         */
        if (! SNMP_MGR_ConvertInetAddrAndTypeToLInetAddr(type,
            addr_len, addr_ar, 0, (L_INET_Addr_T *) &entry.start_ipaddress))
        {
            return NULL;
        }

        /* Check the length of inputing index.  If compc is less than the
         * instance length, we should try get {A.B.C.0.0...}, where A.B.C was
         * obtained from the "..._OidIndexToData" function call, and
         * 0.0... was initialized in the beginning of this function.
         * This instance may exist in the core layer.
         */
        /* NOTE:
         * This is a variable-length index:
         * IfIndex.AddressType.length-prefixed-InetAddress.PrefixLength
         * We check length of address based on type.
         */
        if ( (type == 0)
            || ((type == VAL_ipFilterTelnetInetAddressType_ipv4)
                && (addr_len < SYS_TYPE_IPV4_ADDR_LEN))
            || ((type == VAL_ipFilterTelnetInetAddressType_ipv6)
                && (addr_len < SYS_TYPE_IPV6_ADDR_LEN))
            || ((type == VAL_ipFilterTelnetInetAddressType_ipv4z)
                && (addr_len < SYS_TYPE_IPV4Z_ADDR_LEN))
            || ((type == VAL_ipFilterTelnetInetAddressType_ipv6z)
                && (addr_len < SYS_TYPE_IPV6Z_ADDR_LEN)) )
        {
            /* get data */
            if (MGMT_IP_FLT_OK != MGMT_IP_FLT_Telnet_GetIpFilter(&entry))
            {
                /* get next data */
                if (MGMT_IP_FLT_OK != MGMT_IP_FLT_TELNET_GetNextIpFilter(&entry))
                {
                    return NULL;
                }
            }
        }
        else
        {
            /* get next data */
            if (MGMT_IP_FLT_OK != MGMT_IP_FLT_TELNET_GetNextIpFilter(&entry))
            {
                return NULL;
            }
        }
    }

    memcpy(name, vp->name, vp->namelen*sizeof(oid));

    /* convert L_INET_AddrIp_T back to SNMP values
     */
    if (! SNMP_MGR_ConvertLInetAddrToInetAddrAndType(
        (L_INET_Addr_T *) &entry.start_ipaddress,
        &type, &addr_len, addr_ar, &preflen))
    {
        /* conversion failed
         */
        *var_len = 0;
    }
    else
    {
        *var_len = (size_t) addr_len;
    }

    /* assign data to the oid index */
    best_inst[0] = type;

    for (i = 0; i < addr_len; i++)
    {
        best_inst[1 + i] = addr_ar[i];
    }
    memcpy(name + vp->namelen, best_inst, (1 + addr_len) * sizeof(oid));
    *length = vp->namelen + (1 + addr_len);

    /* this is where we do the value assignments for the mib results. */
    switch (vp->magic)
    {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case LEAF_ipFilterTelnetInetAddressStartType:
            *var_len = sizeof(long_return);
            long_return = type;
            return (u_char *) &long_return;

#endif
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case LEAF_ipFilterTelnetInetAddressStart:
            *var_len = addr_len;
            memcpy(return_buf, addr_ar, *var_len);
            return (u_char*)return_buf;

#endif
        case LEAF_ipFilterTelnetInetAddressEnd:
        {
            UI32_T type, addr_len, preflen;

            if (! SNMP_MGR_ConvertLInetAddrToInetAddrAndType(
                (L_INET_Addr_T *) &entry.end_ipaddress,
                &type, &addr_len, return_buf, &preflen))
            {
                /* conversion failed
                 */
                *var_len = 0;
            }
            else
            {
                *var_len = (size_t) addr_len;
            }

            return (u_char *) return_buf;
        }

        case LEAF_ipFilterTelnetInetStatus:
            *var_len = sizeof(long_return);
            long_return = VAL_ipFilterTelnetInetStatus_valid;
            return (u_char *) &long_return;

        default:
            ERROR_MSG("");
    }

    return NULL;
}

int
write_ipFilterTelnetInetAddressEnd(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    /* extracted from user index sub-OID
     */
    UI32_T type = 0, addr_len = 0;
    UI8_T addr_ar[SYS_TYPE_IPV6Z_ADDR_LEN] = {0};  /* longest case: IPv6z, with zone ID */

    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_OCTET_STR)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len < MINSIZE_ipFilterTelnetInetAddressEnd ||
                var_val_len > MAXSIZE_ipFilterTelnetInetAddressEnd)
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;

        case RESERVE2:
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
            MGMT_IP_FLT_IpFilter_T filter_entry;

            memset(&filter_entry, 0, sizeof(filter_entry));

            /* extract index
             */
            if (FALSE == ipFilterTelnetInetTable_OidIndexToData(
                TRUE, name_len - oid_name_length, &(name[oid_name_length]),
                &type, addr_ar, &addr_len))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            /* only support IPv4(z) and IPv6(z)
             */
            if ( (type < VAL_ipFilterTelnetInetAddressType_ipv4)
                || (type > VAL_ipFilterTelnetInetAddressType_ipv6z) )
            {
                return SNMP_ERR_COMMITFAILED;
            }

            /* convert to L_INET_AddrIp_T (start)
             */
            if (! SNMP_MGR_ConvertInetAddrAndTypeToLInetAddr(type,
                addr_len, addr_ar, 0, (L_INET_Addr_T *) &filter_entry.start_ipaddress))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            /* The index does not exist in mgmt IP filter
             */
            if (MGMT_IP_FLT_OK != MGMT_IP_FLT_Telnet_GetIpFilter(&filter_entry))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            /* convert to L_INET_AddrIp_T (end)
             */
            if (! SNMP_MGR_ConvertInetAddrAndTypeToLInetAddr(type,
                var_val_len, var_val, 0, (L_INET_Addr_T *) &filter_entry.end_ipaddress))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            /* set to core layer
             */
            if (MGMT_IP_FLT_OK != MGMT_IP_FLT_SetIpFilter( MGMT_IP_FLT_TELNET, &filter_entry))
            {
                return SNMP_ERR_COMMITFAILED;
            }
            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

int
write_ipFilterTelnetInetStatus(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    /* extracted from user index sub-OID
     */
    UI32_T type = 0, addr_len = 0;
    UI8_T addr_ar[SYS_TYPE_IPV6Z_ADDR_LEN] = {0};  /* longest case: IPv6z, with zone ID */

    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            switch (*(long *)var_val)
            {
                case VAL_ipFilterTelnetInetStatus_valid:
                    break;

                case VAL_ipFilterTelnetInetStatus_invalid:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
            I32_T value;
            MGMT_IP_FLT_IpFilter_T filter_entry;

            memset(&filter_entry, 0, sizeof(filter_entry));

            /* extract index
             */
            if (FALSE == ipFilterTelnetInetTable_OidIndexToData(
                TRUE, name_len - oid_name_length, &(name[oid_name_length]),
                &type, addr_ar, &addr_len))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            /* only support IPv4(z) and IPv6(z)
             */
            if ( (type < VAL_ipFilterTelnetInetAddressType_ipv4)
                || (type > VAL_ipFilterTelnetInetAddressType_ipv6z) )
            {
                return SNMP_ERR_COMMITFAILED;
            }

            /* convert to L_INET_AddrIp_T (start)
             */
            if (! SNMP_MGR_ConvertInetAddrAndTypeToLInetAddr(type,
                addr_len, addr_ar, 0, (L_INET_Addr_T *) &filter_entry.start_ipaddress))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            value = * (long *) var_val;

            if (VAL_ipFilterTelnetInetStatus_valid == value)  /* add */
            {
                /* The entry has existed in mgmt IP filter
                 */
                if (MGMT_IP_FLT_OK == MGMT_IP_FLT_Telnet_GetIpFilter(&filter_entry))
                {
                    return SNMP_ERR_COMMITFAILED;
                }

                memcpy(&filter_entry.end_ipaddress, &filter_entry.start_ipaddress, sizeof(filter_entry.end_ipaddress));

                if (MGMT_IP_FLT_OK !=
                    MGMT_IP_FLT_SetIpFilter( MGMT_IP_FLT_TELNET, &filter_entry))
                {
                    return SNMP_ERR_COMMITFAILED;
                }
            }
            else /* VAL_ipFilterTelnetInetStatus_invalid, end_ipaddress.addrlen should be 0 */
            {
                if (MGMT_IP_FLT_OK != MGMT_IP_FLT_DeleteIpFilter(MGMT_IP_FLT_TELNET, &filter_entry))
                {
                    return SNMP_ERR_COMMITFAILED;
                }
            }
            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

#endif  /* #if (SYS_CPNT_IPV6 != TRUE) #else */

int do_ipFilterAllClientCtlInetAddressType(netsnmp_mib_handler *handler,
    netsnmp_handler_registration *reginfo,
    netsnmp_agent_request_info *reqinfo,
    netsnmp_request_info *requests)
{
    switch (reqinfo->mode)
    {
        case MODE_GET:
        {
            long_return = ip_filter_all_client_ctl_entry.start_ipaddress.type;
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
            break;
        }

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
            }
            break;

        case MODE_SET_RESERVE2:
            switch (*requests->requestvb->val.integer)
            {
                case VAL_ipFilterAllClientCtlInetAddressType_unknown:
                    break;

                case VAL_ipFilterAllClientCtlInetAddressType_ipv4:
                    break;

                case VAL_ipFilterAllClientCtlInetAddressType_ipv6:
                    break;

                case VAL_ipFilterAllClientCtlInetAddressType_ipv4z:
                    break;

                case VAL_ipFilterAllClientCtlInetAddressType_ipv6z:
                    break;

                case VAL_ipFilterAllClientCtlInetAddressType_dns:
                    break;

                default:
                    netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called.
             */
            break;

        case MODE_SET_ACTION:
            if (   (VAL_ipFilterAllClientCtlInetAddressType_ipv4 > (*requests->requestvb->val.integer))
                || (VAL_ipFilterAllClientCtlInetAddressType_ipv6z < (*requests->requestvb->val.integer)))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            /* set to temporary storage
             */
            ip_filter_all_client_ctl_type = *requests->requestvb->val.integer;
            break;

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int do_ipFilterAllClientCtlInetAddressStart(netsnmp_mib_handler *handler,
    netsnmp_handler_registration *reginfo,
    netsnmp_agent_request_info *reqinfo,
    netsnmp_request_info *requests)
{
    /* extracted from user index sub-OID
     */
    UI32_T type = 0, preflen = 0;

    switch (reqinfo->mode)
    {
        case MODE_GET:
        {
            UI32_T var_len = 0;

            /* get from temporary structure
             */
            if (! SNMP_MGR_ConvertLInetAddrToInetAddrAndType(
                (L_INET_Addr_T *) &ip_filter_all_client_ctl_entry.start_ipaddress,
                &type, &var_len, return_buf, &preflen))
            {
                var_len = 0;
            }

            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                (u_char *) return_buf, var_len);

            break;
        }

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            if (requests->requestvb->type != ASN_OCTET_STR)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
                return SNMP_ERR_NOERROR;
            }
            if ((requests->requestvb->val_len < MINSIZE_ipFilterAllClientCtlInetAddressStart)
                || (requests->requestvb->val_len > MAXSIZE_ipFilterAllClientCtlInetAddressStart))
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGLENGTH);
                return SNMP_ERR_NOERROR;
            }
            break;

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called.
             */
            break;

        case MODE_SET_ACTION:
            /* NOTE: InetAddressType and InetAddress
             *
             * The following checks use the corresponding InetAddressType.
             * If corresponding InetAddressType and InetAddress are in the
             * same packet, this check must be done in the sequence of
             * RESERVE1->RESERVE2->ACTION after InetAddressType is stored.
             */

            /* check address length based on address type
             */
            if (! SNMP_MGR_IsInetAddrLengthValid(
                ip_filter_all_client_ctl_type,
                requests->requestvb->val_len))
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_INCONSISTENTVALUE);
                return SNMP_ERR_NOERROR;
            }

            /* set to temporary control (ctl) structure
             */
            if (! SNMP_MGR_ConvertInetAddrAndTypeToLInetAddr(ip_filter_all_client_ctl_type,
                requests->requestvb->val_len, requests->requestvb->val.string, 0,
                (L_INET_Addr_T *) &ip_filter_all_client_ctl_entry.start_ipaddress))
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
                return SNMP_ERR_NOERROR;
            }
            break;

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int do_ipFilterAllClientCtlInetAddressEnd(netsnmp_mib_handler *handler,
    netsnmp_handler_registration *reginfo,
    netsnmp_agent_request_info *reqinfo,
    netsnmp_request_info *requests)
{
    /* extracted from user index sub-OID
     */
    UI32_T type = 0, preflen = 0;

    switch (reqinfo->mode)
    {
        case MODE_GET:
        {
            UI32_T var_len = 0;

            /* get from temporary structure
             */
            if (! SNMP_MGR_ConvertLInetAddrToInetAddrAndType(
                (L_INET_Addr_T *) &ip_filter_all_client_ctl_entry.end_ipaddress,
                &type, &var_len, return_buf, &preflen))
            {
                var_len = 0;
            }

            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                (u_char *) return_buf, var_len);

            break;
        }

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            if (requests->requestvb->type != ASN_OCTET_STR)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
                return SNMP_ERR_NOERROR;
            }
            if ((requests->requestvb->val_len < MINSIZE_ipFilterAllClientCtlInetAddressEnd)
                || (requests->requestvb->val_len > MAXSIZE_ipFilterAllClientCtlInetAddressEnd))
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGLENGTH);
                return SNMP_ERR_NOERROR;
            }
            break;

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called.
             */
            break;

        case MODE_SET_ACTION:
            /* NOTE: InetAddressType and InetAddress
             *
             * The following checks use the corresponding InetAddressType.
             * If corresponding InetAddressType and InetAddress are in the
             * same packet, this check must be done in the sequence of
             * RESERVE1->RESERVE2->ACTION after InetAddressType is stored.
             */

            /* check address length based on address type
             */
            if (! SNMP_MGR_IsInetAddrLengthValid(
                ip_filter_all_client_ctl_type,
                requests->requestvb->val_len))
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_INCONSISTENTVALUE);
                return SNMP_ERR_NOERROR;
            }

            /* set to temporary control (ctl) structure
             */
            if (! SNMP_MGR_ConvertInetAddrAndTypeToLInetAddr(ip_filter_all_client_ctl_type,
                requests->requestvb->val_len, requests->requestvb->val.string,
                0, (L_INET_Addr_T *) &ip_filter_all_client_ctl_entry.end_ipaddress))
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
                return SNMP_ERR_NOERROR;
            }
            break;

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int do_ipFilterAllClientCtlAction(netsnmp_mib_handler *handler,
    netsnmp_handler_registration *reginfo,
    netsnmp_agent_request_info *reqinfo,
    netsnmp_request_info *requests)
{
    switch (reqinfo->mode)
    {
        case MODE_GET:
        {
            long_return = VAL_ipFilterAllClientCtlAction_noAction;
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
            break;
        }

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
            }
            break;

        case MODE_SET_RESERVE2:
            switch (*requests->requestvb->val.integer)
            {
                case VAL_ipFilterAllClientCtlAction_noAction:
                    break;

                case VAL_ipFilterAllClientCtlAction_create:
                    break;

                case VAL_ipFilterAllClientCtlAction_destroy:
                    break;

                default:
                    netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called.
             */
            break;

        case MODE_SET_ACTION:
            switch (*requests->requestvb->val.integer)
            {
                case VAL_ipFilterAllClientCtlAction_create:
                    if (MGMT_IP_FLT_SetIpFilter(MGMT_IP_FLT_WEB, &ip_filter_all_client_ctl_entry) != MGMT_IP_FLT_OK)
                    {
                        return SNMP_ERR_COMMITFAILED;
                    }

                    if (MGMT_IP_FLT_SetIpFilter(MGMT_IP_FLT_SNMP, &ip_filter_all_client_ctl_entry) != MGMT_IP_FLT_OK)
                    {
                        return SNMP_ERR_COMMITFAILED;
                    }

                    if (MGMT_IP_FLT_SetIpFilter(MGMT_IP_FLT_TELNET, &ip_filter_all_client_ctl_entry) != MGMT_IP_FLT_OK)
                    {
                        return SNMP_ERR_COMMITFAILED;
                    }
                    break;

                case VAL_ipFilterAllClientCtlAction_destroy:
                    if (MGMT_IP_FLT_DeleteIpFilter(MGMT_IP_FLT_WEB, &ip_filter_all_client_ctl_entry) != MGMT_IP_FLT_OK)
                    {
                        return SNMP_ERR_COMMITFAILED;
                    }

                    if (MGMT_IP_FLT_DeleteIpFilter(MGMT_IP_FLT_SNMP, &ip_filter_all_client_ctl_entry) != MGMT_IP_FLT_OK)
                    {
                        return SNMP_ERR_COMMITFAILED;
                    }

                    if (MGMT_IP_FLT_DeleteIpFilter(MGMT_IP_FLT_TELNET, &ip_filter_all_client_ctl_entry) != MGMT_IP_FLT_OK)
                    {
                        return SNMP_ERR_COMMITFAILED;
                    }
                    break;

                default:
                    break;
            }
            break;

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
#endif  /* end of #if (SYS_CPNT_MGMT_IP_FLT == TRUE)*/


/////////////////////////////////////////////////////////////////////////////////////
#if (SYS_CPNT_DOT1X == TRUE)

#define dot1xAuthConfigExtEntry_INSTANCE_LEN 1

static UI32_T getDot1xAuthConfigExtTableOidNameLen(void)
{
    return SNMP_MGR_Get_PrivateMibRootLen() + 6;
}

/* var_dot1xAuthConfigExtTable  */

static BOOL_T dot1xAuthConfigExtTable_get( int     compc,
                                           oid     *compl,
                                           u_char  magic,
                                           UI32_T  *index,
                                           UI32_T  *oper_mode,
                                           UI32_T  *max_count,
                                           UI32_T  *intrusion_action)
{
    if (compc !=dot1xAuthConfigExtEntry_INSTANCE_LEN)
    {
        return FALSE;
    }

    *index=compl[0];

    switch (magic)
    {
      case DOT1XAUTHCONFIGEXTOPERMODE:
      {
       if(SNMP_MGR_IsDebugMode())
              SYSFUN_Debug_Printf("dot1xAuthConfigExtTable_get before: index=%lu, oper_mode=%lu\n", *index,  *oper_mode);

#if(SYS_CPNT_NETACCESS == TRUE)
           if (NETACCESS_PMGR_GetDot1xPortOperationMode(*index, oper_mode))
#else
           if (DOT1X_PMGR_Get_PortOperationMode(*index, oper_mode))
#endif
       {
           if(SNMP_MGR_IsDebugMode())
                  SYSFUN_Debug_Printf("dot1xAuthConfigExtTable_get before: index=%lu, oper_mode=%lu\n", *index,  *oper_mode);
               return TRUE;
           }
           else
           {
           if(SNMP_MGR_IsDebugMode())
              SYSFUN_Debug_Printf("dot1xAuthConfigExtTable_get after: index=%lu, oper_mode=%lu\n", *index,  *oper_mode);
               return FALSE;
           }
      }
      case DOT1XAUTHCONFIGEXTMULTIHOSTMAXCNT:
#if(SYS_CPNT_NETACCESS == TRUE)
           if (NETACCESS_PMGR_GetDot1xPortMultiHostMacCount(*index, max_count))
#else
           if (DOT1X_PMGR_Get_PortMultiHostMacCount(*index, max_count))
#endif
           {
           if(SNMP_MGR_IsDebugMode())
              SYSFUN_Debug_Printf("dot1xAuthConfigExtMultiHostMaxCnt: index=%lu, oper_mode=%lu\n", *index,  *oper_mode);
            return TRUE;
           }
           else
           {
           if(SNMP_MGR_IsDebugMode())
              SYSFUN_Debug_Printf("dot1xAuthConfigExtMultiHostMaxCnt: index=%lu, oper_mode=%lu\n", *index, *oper_mode);
            return FALSE;
           }
#if (SYS_CPNT_NETACCESS_GUEST_VLAN == TRUE)
       case DOT1XAUTHCONFIGEXTPORTINTRUSIONACTION:
           if (NETACCESS_PMGR_GetDot1xPortIntrusionAction(*index, intrusion_action))
           {
               if(SNMP_MGR_IsDebugMode())
                   SYSFUN_Debug_Printf("dot1xAuthConfigExtMultiHostMaxCnt: index=%lu, oper_mode=%lu\n", *index,  *oper_mode);
               return TRUE;
           }
           else
           {
               if(SNMP_MGR_IsDebugMode())
                   SYSFUN_Debug_Printf("dot1xAuthConfigExtMultiHostMaxCnt: index=%lu, oper_mode=%lu\n", *index, *oper_mode);
               return FALSE;
           }
#endif
      default:
           return TRUE;
    }
}

static BOOL_T dot1xAuthConfigExtTable_next( int     compc,
                                            oid     *compl,
                                            u_char  magic,
                                            UI32_T  *index,
                                            UI32_T  *oper_mode,
                                            UI32_T  *max_count,
                                            UI32_T  *intrusion_action)
{
    oid tmp_compl[dot1xAuthConfigExtEntry_INSTANCE_LEN];

    memcpy(tmp_compl, compl, sizeof(tmp_compl));
    SNMP_MGR_ConvertRemainToZero(compc, dot1xAuthConfigExtEntry_INSTANCE_LEN, tmp_compl);
        *index = tmp_compl[0];

    if (compc < dot1xAuthConfigExtEntry_INSTANCE_LEN)
    {
        switch(magic)
        {
            case DOT1XAUTHCONFIGEXTOPERMODE:

#if(SYS_CPNT_NETACCESS == TRUE)
                 if (!NETACCESS_PMGR_GetDot1xPortOperationMode(*index,oper_mode))
                 {
                    if (!NETACCESS_PMGR_GetNextDot1xPortOperationMode(index, oper_mode))
                        return FALSE;
                    else
                        return TRUE;
                 }
                 else
                 {
                    if (!NETACCESS_PMGR_GetNextDot1xPortOperationMode(index, oper_mode))
                         return FALSE;
                    else
                         return TRUE;
                 }
#else
                 if (!DOT1X_PMGR_Get_PortOperationMode(*index,oper_mode))
                 {
                    if (!DOT1X_PMGR_GetNext_PortOperationMode(index, oper_mode))
                         return FALSE;
                    else
                             return TRUE;
                 }
                 else
                 {
                    if (!DOT1X_PMGR_GetNext_PortOperationMode(index, oper_mode))
                         return FALSE;
                    else
                         return TRUE;
                 }
#endif
                 break;

            case DOT1XAUTHCONFIGEXTMULTIHOSTMAXCNT:
#if(SYS_CPNT_NETACCESS == TRUE)
                 if (!NETACCESS_PMGR_GetDot1xPortMultiHostMacCount(*index, max_count))
                 {
                    if (!NETACCESS_PMGR_GetNextDot1xPortMultiHostMacCount(index, max_count))
                        return FALSE;
                    else
                        return TRUE;
                 }
                 else
                 {
                    if (!NETACCESS_PMGR_GetNextDot1xPortMultiHostMacCount(index, max_count))
                        return FALSE;
                    else
                        return TRUE;
                 }
#else
                 if (!DOT1X_PMGR_Get_PortMultiHostMacCount(*index, max_count))
                 {
                    if (!DOT1X_PMGR_GetNext_PortMultiHostMacCount(index, max_count))
                        return FALSE;
                    else
                        return TRUE;
                 }
                 else
                 {
                    if (!DOT1X_PMGR_GetNext_PortMultiHostMacCount(index, max_count))
                        return FALSE;
                    else
                        return TRUE;
                 }
#endif

                 break;
#if (SYS_CPNT_NETACCESS_GUEST_VLAN == TRUE)
             case DOT1XAUTHCONFIGEXTPORTINTRUSIONACTION:
                 if (!NETACCESS_PMGR_GetDot1xPortIntrusionAction(*index, intrusion_action))
                 {
                    if (!NETACCESS_PMGR_GetNextDot1xPortIntrusionAction(index, intrusion_action))
                        return FALSE;
                    else
                        return TRUE;
                 }
                 else
                 {
                    if (!NETACCESS_PMGR_GetNextDot1xPortIntrusionAction(index, intrusion_action))
                        return FALSE;
                    else
                        return TRUE;
                 }
                 break;
#endif
        }
    }
    else
    {
        switch(magic)
        {
            case DOT1XAUTHCONFIGEXTOPERMODE:
#if(SYS_CPNT_NETACCESS == TRUE)
                 if (!NETACCESS_PMGR_GetNextDot1xPortOperationMode(index, oper_mode))
#else
                 if (!DOT1X_PMGR_GetNext_PortOperationMode(index, oper_mode))
#endif
                      return FALSE;
                 else
                      return TRUE;

            case DOT1XAUTHCONFIGEXTMULTIHOSTMAXCNT:
#if(SYS_CPNT_NETACCESS == TRUE)
                 if (!NETACCESS_PMGR_GetNextDot1xPortMultiHostMacCount(index, max_count))
#else
                 if (!DOT1X_PMGR_GetNext_PortMultiHostMacCount(index, max_count))
#endif
                     return FALSE;
                 else
                     return TRUE;
#if (SYS_CPNT_NETACCESS_GUEST_VLAN == TRUE)
            case DOT1XAUTHCONFIGEXTPORTINTRUSIONACTION:
                 if (!NETACCESS_PMGR_GetNextDot1xPortIntrusionAction(index, intrusion_action))
                     return FALSE;
                 else
                     return TRUE;
#endif
        default:
             return TRUE;
            }

    }
    return TRUE;
}

unsigned char  *
var_dot1xAuthConfigExtTable(struct variable *vp,
                            oid * name,
                            size_t * length,
                            int exact,
                            size_t * var_len, WriteMethod ** write_method)
{

    UI32_T compc=0;
    oid compl[dot1xAuthConfigExtEntry_INSTANCE_LEN];
    UI32_T  nMode  = 0;
    UI32_T  nCount = 0;
    UI32_T  nIndex = 0;
    UI32_T  nAction = 0;
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl, dot1xAuthConfigExtEntry_INSTANCE_LEN);

    if (exact)  /*get,set*/
    {
        if (!dot1xAuthConfigExtTable_get(compc, compl, vp->magic,&nIndex, &nMode, &nCount, &nAction))
        {
            return NULL;
        }
    }
    else    /*getnext*/
    {
        if (!dot1xAuthConfigExtTable_next(compc, compl, vp->magic,&nIndex, &nMode, &nCount, &nAction))
        {
            return NULL;
        }
    }
    memcpy(name, vp->name, vp->namelen*sizeof(oid));
    memcpy(name + vp->namelen, &nIndex, dot1xAuthConfigExtEntry_INSTANCE_LEN*sizeof(oid));
    *length = vp->namelen + dot1xAuthConfigExtEntry_INSTANCE_LEN;
    *var_len = sizeof(long_return);

    /*this is where we do the value assignments for the mib results. */
    switch (vp->magic)
    {
      case DOT1XAUTHCONFIGEXTOPERMODE:
           *write_method = write_dot1xAuthConfigExtOperMode;
           long_return = nMode;
           return (u_char *) & long_return;

      case DOT1XAUTHCONFIGEXTMULTIHOSTMAXCNT:
           *write_method = write_dot1xAuthConfigExtMultiHostMaxCnt;
           long_return = nCount;            /* XXX */
           return (u_char *) & long_return;
#if (SYS_CPNT_NETACCESS_GUEST_VLAN == TRUE)
      case DOT1XAUTHCONFIGEXTPORTINTRUSIONACTION:
           *write_method = write_dot1xAuthConfigExtPortIntrusionAction;
           long_return = nAction;
           return (u_char *) & long_return;
#endif
     default:
           ERROR_MSG("");
    }
    return NULL;
}

int
write_dot1xAuthConfigExtOperMode(int action,
                                 u_char * var_val,
                                 u_char var_val_type,
                                 size_t var_val_len,
                                 u_char * statP,
                                 oid * name, size_t name_len)
{
    UI32_T value;

    switch (action)
    {

       case RESERVE1:
            if (name_len!=  getDot1xAuthConfigExtTableOidNameLen() + dot1xAuthConfigExtEntry_INSTANCE_LEN )
                return SNMP_ERR_WRONGLENGTH;

            if (var_val_type != ASN_INTEGER)
                return SNMP_ERR_WRONGTYPE;

            if (var_val_len > sizeof(long))
            return SNMP_ERR_WRONGLENGTH;

            break;

       case RESERVE2:
       {
            value = *(long *)var_val;

            switch (value)
            {
                case VAL_dot1xAuthConfigExtOperMode_singleHost:
                case VAL_dot1xAuthConfigExtOperMode_multiHost:
            #if (SYS_CPNT_DOT1X_MACBASED_AUTH == TRUE)
                case VAL_dot1xAuthConfigExtOperMode_macBasedAuth:
            #endif
                    break;

                default:
                 return  SNMP_ERR_WRONGVALUE;
            }

        break;
       }
       case FREE:
            break;

       case ACTION:
       {
            UI32_T nIndex;

            value = *(long *)var_val;
            nIndex = name[getDot1xAuthConfigExtTableOidNameLen()];
#if(SYS_CPNT_NETACCESS == TRUE)
            if (NETACCESS_PMGR_SetDot1xPortOperationMode(nIndex, value)==FALSE)
#else
            if (DOT1X_PMGR_Set_PortOperationMode(nIndex, value)==FALSE)
#endif
                return  SNMP_ERR_COMMITFAILED;
            break;
       }
       case UNDO:
       case COMMIT:
            break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot1xAuthConfigExtMultiHostMaxCnt(int action,
                                        u_char * var_val,
                                        u_char var_val_type,
                                        size_t var_val_len,
                                        u_char * statP,
                                        oid * name, size_t name_len)
{
    long value;

    switch (action)
    {
    case RESERVE1:
         if (var_val_type != ASN_INTEGER)
             return SNMP_ERR_WRONGTYPE;

         if (var_val_len > sizeof(long))
            return SNMP_ERR_WRONGLENGTH;

         break;

    case RESERVE2:
    {
         value = *(long *)var_val;
         if ((value < MIN_dot1xAuthConfigExtMultiHostMaxCnt) ||
             (value > MAX_dot1xAuthConfigExtMultiHostMaxCnt))
             return SNMP_ERR_WRONGVALUE;
    }
    case FREE:
         break;

    case ACTION:
    {
         UI32_T nIndex;

         value = *(long *)var_val;
         nIndex = name[getDot1xAuthConfigExtTableOidNameLen()];

#if(SYS_CPNT_NETACCESS == TRUE)
         if (NETACCESS_PMGR_SetDot1xPortMultiHostMacCount(nIndex, value)==FALSE)
#else
         if (DOT1X_PMGR_Set_PortMultiHostMacCount(nIndex, value)==FALSE)
#endif
         {
         if(SNMP_MGR_IsDebugMode())
                SYSFUN_Debug_Printf("dot1xAuthConfigExtMultiHostMaxCnt error: index=%lu value=%lu\n",nIndex, value);
             return SNMP_ERR_COMMITFAILED;
         }
         break;
    }
    case UNDO:
    case COMMIT:
         break;
    }
    return SNMP_ERR_NOERROR;
}

#if (SYS_CPNT_NETACCESS_GUEST_VLAN == TRUE)
int
write_dot1xAuthConfigExtPortIntrusionAction(int action,
                                 u_char * var_val,
                                 u_char var_val_type,
                                 size_t var_val_len,
                                 u_char * statP,
                                 oid * name, size_t name_len)
{
    long value;

    switch (action)
    {

       case RESERVE1:
            if (name_len!=  getDot1xAuthConfigExtTableOidNameLen() + dot1xAuthConfigExtEntry_INSTANCE_LEN )
                return SNMP_ERR_WRONGLENGTH;

            if (var_val_type != ASN_INTEGER)
                return SNMP_ERR_WRONGTYPE;

            if (var_val_len > sizeof(long))
            return SNMP_ERR_WRONGLENGTH;

            break;

       case RESERVE2:
       {
            value = *(long *)var_val;

            if ( (value != VAL_dot1xAuthConfigExtPortIntrusionAction_block_traffic) &&
                 (value != VAL_dot1xAuthConfigExtPortIntrusionAction_guest_vlan))
                 return  SNMP_ERR_WRONGVALUE;

        break;
       }
       case FREE:
            break;

       case ACTION:
       {
            UI32_T nIndex;

            value = *(long *)var_val;
            nIndex = name[getDot1xAuthConfigExtTableOidNameLen()];
            if (NETACCESS_PMGR_SetDot1xPortIntrusionAction(nIndex, value) == FALSE)
                return  SNMP_ERR_COMMITFAILED;
            break;
       }
       case UNDO:
       case COMMIT:
            break;
    }
    return SNMP_ERR_NOERROR;
}
#endif

#endif /* #if (SYS_CPNT_DOT1X == TRUE) */

#if (SYS_CPNT_DOT1X_EAPOL_PASS_THROUGH == TRUE)
int
do_dot1xEapolPassThrough(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    switch (reqinfo->mode)
    {
        case MODE_GET:
        {
            UI32_T value = 0;

#if (SYS_CPNT_NETACCESS == TRUE)
            if (NETACCESS_PMGR_GetDot1xEapolPassThrough(&value) == TRUE)
            {
                long_return = value;
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                         (u_char *)&long_return, sizeof(long_return));
            }
            else
#endif
            {
                return SNMP_ERR_GENERR;
            }
        }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:

            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests,
                                          SNMP_ERR_WRONGTYPE);
            }

            break;
        case MODE_SET_RESERVE2:

            switch (*requests->requestvb->val.integer)
            {
                case VAL_dot1xEapolPassThrough_enabled:
                    break;
                case VAL_dot1xEapolPassThrough_disabled:
                    break;
                default:
                    netsnmp_set_request_error(reqinfo, requests,
                                              SNMP_ERR_WRONGVALUE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
        {
#if (SYS_CPNT_NETACCESS == TRUE)
            if (NETACCESS_PMGR_SetDot1xEapolPassThrough(*requests->requestvb->val.integer) != TRUE)
#endif
            {
                netsnmp_set_request_error(reqinfo, requests,
                                          SNMP_ERR_COMMITFAILED);
            }
        }
            break;

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
#endif /*#if (SYS_CPNT_DOT1X_EAPOL_PASS_THROUGH == TRUE)*/

/////////////////////////////////////////////////////////////////////////////////////

#if 0 /* comment-out by vai */
#if (SYS_CPNT_ROUTING == TRUE)
/********************************************
 ********************arpMgt******************
 ********************************************
 */
int
do_arpCacheTimeout(netsnmp_mib_handler *handler,
                   netsnmp_handler_registration *reginfo,
                   netsnmp_agent_request_info *reqinfo,
                   netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
              {
              UI32_T  value;

              if (NETCFG_MGR_GetIpNetToMediaEntryTimeout(&value)!=NETCFG_MGR_OK)
                       return SNMP_ERR_GENERR;
                  long_return = value;
                  snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
             }
            break;
        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            {
           UI32_T value;
           value = (*requests->requestvb->val.integer);
          if ((value<MIN_arpCacheTimeout)  ||    (value>MAX_arpCacheTimeout))
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_INCONSISTENTVALUE);
          }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */

            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
             {
                UI32_T value;
                value = (*requests->requestvb->val.integer);
                 if (NETCFG_MGR_SetIpNetToMediaEntryTimeout(value) != NETCFG_MGR_OK)
                       netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */

            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */

            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_arpStatRcvRequestPackets(netsnmp_mib_handler *handler,
                             netsnmp_handler_registration *reginfo,
                             netsnmp_agent_request_info *reqinfo,
                             netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
           {
               UI32_T value;
               if (NETCFG_MGR_GetArpInRequest(&value)!=NETCFG_MGR_OK)
                   return SNMP_ERR_GENERR;
                long_return =  value;
                snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *)&long_return, sizeof(long_return));
            }
            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_arpStatSendReplyPackets(netsnmp_mib_handler *handler,
                            netsnmp_handler_registration *reginfo,
                            netsnmp_agent_request_info *reqinfo,
                            netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
           {
               UI32_T value;
               if (NETCFG_MGR_GetArpOutReply(&value)!=NETCFG_MGR_OK)
                   return SNMP_ERR_GENERR;
                long_return =  value;
                snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *)&long_return, sizeof(long_return));
            }
            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_arpStatRcvReplyPackets(netsnmp_mib_handler *handler,
                           netsnmp_handler_registration *reginfo,
                           netsnmp_agent_request_info *reqinfo,
                           netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
           {
               UI32_T value;
               if (NETCFG_MGR_GetArpOutRequest(&value)!=NETCFG_MGR_OK)
                   return SNMP_ERR_GENERR;
                long_return =  value;
                snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *)&long_return, sizeof(long_return));
            }
            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_arpStatSendRequestPackets(netsnmp_mib_handler *handler,
                              netsnmp_handler_registration *reginfo,
                              netsnmp_agent_request_info *reqinfo,
                              netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
           {
               UI32_T value;
               if (NETCFG_MGR_GetArpOutRequest(&value)!=NETCFG_MGR_OK)
                   return SNMP_ERR_GENERR;
                long_return =  value;
                snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *)&long_return, sizeof(long_return));
            }
            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
#endif (SYS_CPNT_ROUTING == TRUE)
#endif /* if 0 */

#if (SYS_CPNT_ROUTING == FALSE)
/* Will provide "clear arp-cache" function for both Layer2 and Layer3 switch.
  Layer2:  ipMgt.arpCacheDeleteAll
  Layer3:  layer3Mgt.arpMgt.arpCacheDeleteAll
*/
int
do_arpCacheDeleteAll(netsnmp_mib_handler *handler,
                     netsnmp_handler_registration *reginfo,
                     netsnmp_agent_request_info *reqinfo,
                     netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
              {

                  long_return = VAL_arpCacheDeleteAll_noDelete;
                  snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
              }
            break;
        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            {
           UI32_T value;
           value = (*requests->requestvb->val.integer);
          if ((value<VAL_arpCacheDeleteAll_delete)  ||    (value>VAL_arpCacheDeleteAll_noDelete))
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_INCONSISTENTVALUE);
          }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */

            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
             {
                UI32_T value;
                value = (*requests->requestvb->val.integer);
                if (value == VAL_arpCacheDeleteAll_delete)
                {
                    if (NETCFG_PMGR_ND_DeleteAllDynamicIpv4NetToMediaEntry()!=NETCFG_TYPE_OK)
                    {
                         netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
                    }
                }
            }
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */

            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */

            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
#endif // (SYS_CPNT_ROUTING == FALSE)
#if 0
#if (SYS_CPNT_ROUTING == TRUE)

/* arpProxyArpTable*/
#define arpProxyArpEntry_INSTANCE_LEN 1


static BOOL_T arpProxyArpTable_get(int      compc,
                                oid     *compl,
                                UI32_T  *index,
                                UI32_T   *value)
{
    if (compc !=arpProxyArpEntry_INSTANCE_LEN)
    {
        return FALSE;
    }
    *index= compl[0];

    if (NETCFG_MGR_GetVlanProxyArpAdminStatus(*index, value)!=NETCFG_MGR_OK)
    {
        return FALSE;
    }
    else
    {
        return TRUE;

    } /*End of if */
}

static BOOL_T arpProxyArpTable_next(int   compc,
                                 oid     *compl,
                                 UI32_T    *index,
                                 UI32_T    *value)
{
    oid tmp_compl[arpProxyArpEntry_INSTANCE_LEN];

    /* Generate the instance of each table entry and find the
     * smallest instance that's larger than compc/compl.
     *
     * Step 1: Verify and extract the input key from "compc" and "compl"
     * Note: The number of input key is defined by "compc".
     *       The key for the specified instance is defined in compl.
     */
    memcpy(tmp_compl, compl, sizeof(tmp_compl));
    SNMP_MGR_checkCompl(0, 0, tmp_compl,SYS_ADPT_MAX_VLAN_ID);
    SNMP_MGR_ConvertRemainToZero(compc,arpProxyArpEntry_INSTANCE_LEN, tmp_compl);

    *index = tmp_compl[0];

    if (compc<arpProxyArpEntry_INSTANCE_LEN)
    {
        if (NETCFG_MGR_GetVlanProxyArpAdminStatus(*index, value)!=NETCFG_MGR_OK)
        {
            if (NETCFG_MGR_GetNextVlanProxyArpAdminStatus(index, value)!=NETCFG_MGR_OK)
            {
                return FALSE;
            }
        }
    }
    else
    {
        if (NETCFG_MGR_GetNextVlanProxyArpAdminStatus(index, value)!=NETCFG_MGR_OK)
        {
            return FALSE;
        }
    }
    return TRUE;
}


/*
 * var_arpProxyArpTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_arpProxyArpTable(struct variable *vp,
                     oid * name,
                     size_t * length,
                     int exact,
                     size_t * var_len, WriteMethod ** write_method)
{
    UI32_T compc=0;
    oid compl[arpProxyArpEntry_INSTANCE_LEN];
    oid best_inst[arpProxyArpEntry_INSTANCE_LEN];
    UI32_T value, index;

   /*Since this table allow for entry that does not exist, (creation). we need to know the write method first*/
    switch (vp->magic)
    {
       case ARPPROXYARPSTATUS:
        *write_method = write_arpProxyArpStatus;
      break;
      default:
         *write_method =0;
         break;
    }

    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,compl, arpProxyArpEntry_INSTANCE_LEN);

     /*check compc, retrive compl*/
    if (exact)/*get,set*/
    {
        if (!arpProxyArpTable_get(compc, compl, &index, &value))
            return NULL;
    }
    else/*getnext*/
    {
        if (!arpProxyArpTable_next(compc, compl, &index, &value))
        {
            return NULL;
        }
    }
    memcpy(name, vp->name, vp->namelen*sizeof(oid));
    best_inst[0] = index;
    memcpy(name + vp->namelen, best_inst, arpProxyArpEntry_INSTANCE_LEN*sizeof(oid));
    *length = vp->namelen +arpProxyArpEntry_INSTANCE_LEN;

    *var_len = sizeof(long_return);

    /*
     * * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
      case ARPPROXYARPIFINDEX:
        long_return = index;
        return (u_char*) &long_return;
    #endif
      case ARPPROXYARPSTATUS:
        long_return = value;
        return (u_char*) &long_return;
    default:
        ERROR_MSG("");
    }
    return NULL;
}


int
write_arpProxyArpStatus(int action,
                        u_char * var_val,
                        u_char var_val_type,
                        size_t var_val_len,
                        u_char * statP, oid * name, size_t name_len)
{
    long value;
    UI32_T index;

    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

      /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    index = name[oid_name_length];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          value = *(long *)var_val;
          if ((value <VAL_arpProxyArpStatus_enabled) || (value >VAL_arpProxyArpStatus_disabled))
             return SNMP_ERR_WRONGVALUE;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
        {

             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */

              value = * (long *) var_val;

              if (value == VAL_arpProxyArpStatus_enabled)
              {
                       if (NETCFG_MGR_EnableProxyArp(index) !=NETCFG_MGR_OK)
                       {
                           return SNMP_ERR_COMMITFAILED;
                       }

              }
              else if (value == VAL_arpProxyArpStatus_disabled)
              {
                   if (NETCFG_MGR_DisableProxyArp(index) !=NETCFG_MGR_OK)
                   {
                      return SNMP_ERR_COMMITFAILED;
                   }
              }
         }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int do_arpCacheTimeoutInMinutes(netsnmp_mib_handler             *handler,
                                netsnmp_handler_registration    *reginfo,
                                netsnmp_agent_request_info      *reqinfo,
                                netsnmp_request_info            *requests)
{
    switch (reqinfo->mode)
    {
        case MODE_GET:
        {
            UI32_T value;

            if (NETCFG_MGR_GetIpNetToMediaEntryTimeout(&value) != NETCFG_MGR_OK)
                return SNMP_ERR_GENERR;

            long_return = value / 60;
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));

            break;
        }

        case MODE_SET_RESERVE1:
        {
            UI32_T value;

            value = (*requests->requestvb->val.integer);

            if ((value < MIN_arpCacheTimeoutInMinutes) || (value > MAX_arpCacheTimeoutInMinutes))
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_INCONSISTENTVALUE);

            break;
        }

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            break;

        case MODE_SET_ACTION:
        {
            UI32_T value;

            value = (*requests->requestvb->val.integer) * 60;

            if (value == 0)
            {
                if (NETCFG_MGR_SetIpNetToMediaEntryNoAgeOutTime() != NETCFG_MGR_OK)
                    netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            }

            else
            {
                if (NETCFG_MGR_SetIpNetToMediaEntryTimeout(value) != NETCFG_MGR_OK)
                    netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            }

            break;
        }

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

#endif /* end of #if (SYS_CPNT_ROUTING == TRUE)*/
#endif /* if 0 */
/********************************************
 ********************ospfMgt***************
 ********************************************
 */
#if 0 /*These functions will be implemented in future -- xiongyu 20090112*/
#if (SYS_CPNT_OSPF == TRUE)

int
do_ospfRfc1583CompatibleState(netsnmp_mib_handler *handler,
                              netsnmp_handler_registration *reginfo,
                              netsnmp_agent_request_info *reqinfo,
                              netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
              {
              UI32_T  value;

              if (NETCFG_MGR_GetOspfCompatibleRfc1583(&value)!=NETCFG_MGR_OK)
                       return SNMP_ERR_GENERR;
                  long_return = value;
                  snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
             }
            break;
        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            {
           UI32_T value;
           value = (*requests->requestvb->val.integer);
          if ((value<VAL_ospfRfc1583CompatibleState_enabled)  ||    (value>VAL_ospfRfc1583CompatibleState_disabled))
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_INCONSISTENTVALUE);
          }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */

            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
             {
                UI32_T value;
                value = (*requests->requestvb->val.integer);
                switch (value)
                {
                case VAL_ospfRfc1583CompatibleState_enabled:
                    if (NETCFG_MGR_EnableOspfCompatibleRfc1583() != NETCFG_MGR_OK)
                    {
                       netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
                    }
                break;
                case VAL_ospfRfc1583CompatibleState_disabled:
                    if (NETCFG_MGR_DisableOspfCompatibleRfc1583() != NETCFG_MGR_OK)
                    {
                       netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
                    }
                break;
                default:
                    netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
                break;
                }
            }
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */

            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */

            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_ospfSpfHoldTime(netsnmp_mib_handler *handler,
                   netsnmp_handler_registration *reginfo,
                   netsnmp_agent_request_info *reqinfo,
                   netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
              {
              UI32_T  value;

              if (NETCFG_MGR_GetOspfSpfHoldTime(&value)!=NETCFG_MGR_OK)
                       return SNMP_ERR_GENERR;
                  long_return = value;
                  snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
             }
            break;
        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            {
           UI32_T value;
           value = (*requests->requestvb->val.integer);
          if ((value<MIN_ospfSpfHoldTime)||(value>MAX_ospfSpfHoldTime))
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_INCONSISTENTVALUE);
          }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */

            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
             {
                UI32_T value;
                value = (*requests->requestvb->val.integer);
                if (NETCFG_MGR_SetOspfSpfHoldTime(value) != NETCFG_MGR_OK)
                {
                    netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
                }
            }
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */

            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */

            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_ospfRouterIdType(netsnmp_mib_handler *handler,
                     netsnmp_handler_registration *reginfo,
                     netsnmp_agent_request_info *reqinfo,
                     netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
           {
               UI32_T value;
               if (NETCFG_MGR_GetOspfRouterIdType(&value)!=NETCFG_MGR_OK)
                   return SNMP_ERR_GENERR;
                long_return =  value;
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *)&long_return, sizeof(long_return));
            }
            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_ospfSpfDelayTime(netsnmp_mib_handler *handler,
                    netsnmp_handler_registration *reginfo,
                    netsnmp_agent_request_info *reqinfo,
                    netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
              {
                  UI32_T  value;

                  /* not support*/
                  value = 0;
                  long_return = value;
                  snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
             }
            break;
        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            {
              /* mot support now*/
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_INCONSISTENTVALUE);
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */

            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */

            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */

            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */

            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_ospfAutoCost(netsnmp_mib_handler *handler,
                netsnmp_handler_registration *reginfo,
                netsnmp_agent_request_info *reqinfo,
                netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
              {
              UI32_T  value;

              if (NETCFG_MGR_GetOspfAutoCost(&value)!=NETCFG_MGR_OK)
                       return SNMP_ERR_GENERR;
                  long_return = value;
                  snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
             }
            break;
        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:

            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */

            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
             {
                UI32_T value;
                value = (*requests->requestvb->val.integer);
                if (NETCFG_MGR_SetOspfAutoCost(value) != NETCFG_MGR_OK)
                {
                    netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
                }
            }
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */

            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */

            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_ospfOriginateDefaultRoute(netsnmp_mib_handler *handler,
                             netsnmp_handler_registration *reginfo,
                             netsnmp_agent_request_info *reqinfo,
                             netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
              {
              UI32_T  value;

              if (NETCFG_MGR_GetOspfOriginateDefaultRoute(&value)!=NETCFG_MGR_OK)
                       return SNMP_ERR_GENERR;
                  long_return = value;
                  snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
             }
            break;
        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
             {
                 UI32_T value;
                 value = (*requests->requestvb->val.integer);
                 if ((value<VAL_ospfOriginateDefaultRoute_enabled)||(value>VAL_ospfOriginateDefaultRoute_disabled))
                   netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_INCONSISTENTVALUE);
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */

            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
             {
                UI32_T value;
                value = (*requests->requestvb->val.integer);
                if (NETCFG_MGR_SetOspfOriginateDefaultRoute(value) != NETCFG_MGR_OK)
                {
                    netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
                }
            }
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */

            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */

            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_ospfAdvertiseDefaultRoute(netsnmp_mib_handler *handler,
                             netsnmp_handler_registration *reginfo,
                             netsnmp_agent_request_info *reqinfo,
                             netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
              {
              UI32_T  value;

              if (NETCFG_MGR_GetOspfAdvertiseDefaultRoute(&value)!=NETCFG_MGR_OK)
                       return SNMP_ERR_GENERR;
                  long_return = value;
                  snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
             }
            break;
        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
             {
                 UI32_T value;
                 value = (*requests->requestvb->val.integer);
                 if ((value<VAL_ospfAdvertiseDefaultRoute_always)||(value>VAL_ospfAdvertiseDefaultRoute_notAlways))
                   netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_INCONSISTENTVALUE);
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */

            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
             {
                UI32_T value;
                value = (*requests->requestvb->val.integer);
                if (NETCFG_MGR_SetOspfAdvertiseDefaultRoute(value) != NETCFG_MGR_OK)
                {
                    netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
                }
            }
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */

            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */

            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_ospfExternalMetricType(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
              {
              UI32_T  value;

              if (NETCFG_MGR_GetOspfExternalMetricType(&value)!=NETCFG_MGR_OK)
                       return SNMP_ERR_GENERR;
                  long_return = value;
                  snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
             }
            break;
        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
             {
                 UI32_T value;
                 value = (*requests->requestvb->val.integer);
                 if ((value<VAL_ospfExternalMetricType_type1)||(value>VAL_ospfExternalMetricType_type2))
                   netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_INCONSISTENTVALUE);
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */

            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
             {
                UI32_T value;
                value = (*requests->requestvb->val.integer);
                if (NETCFG_MGR_SetOspfExternalMetricType(value) != NETCFG_MGR_OK)
                {
                    netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
                }
            }
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */

            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */

            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_ospfAreaNumber(netsnmp_mib_handler *handler,
                   netsnmp_handler_registration *reginfo,
                   netsnmp_agent_request_info *reqinfo,
                   netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
           {
               UI32_T value;
               if (NETCFG_MGR_GetOspfAreaNumber(&value)!=NETCFG_MGR_OK)
                   return SNMP_ERR_GENERR;
                long_return =  value;
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *)&long_return, sizeof(long_return));
            }
            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_ospfDefaultExternalMetric(netsnmp_mib_handler *handler,
                             netsnmp_handler_registration *reginfo,
                             netsnmp_agent_request_info *reqinfo,
                             netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
              {
              UI32_T  value;

              if (NETCFG_MGR_GetOspfDefaultExternalMetric(&value)!=NETCFG_MGR_OK)
                       return SNMP_ERR_GENERR;
                  long_return = value;
                  snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
             }
            break;
        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
             {
                 UI32_T value;
                 value = (*requests->requestvb->val.integer);
                 if ((value<MIN_ospfDefaultExternalMetric)||(value>MAX_ospfDefaultExternalMetric))
                   netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_INCONSISTENTVALUE);
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */

            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
             {
                UI32_T value;
                value = (*requests->requestvb->val.integer);
                if (NETCFG_MGR_SetOspfDefaultExternalMetric(value) != NETCFG_MGR_OK)
                {
                    netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
                }
            }
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */

            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */

            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}


/* ospfNssaTable*/
#define ospfNssaEntry_INSTANCE_LEN 4
static BOOL_T ospfNssaTable_get(int      compc,
                                oid     *compl,
                                OSPF_TYPE_OspfNssaAreaEntry_T   *data)
{
    if (compc !=ospfNssaEntry_INSTANCE_LEN)
    {
        return FALSE;
    }
    SNMP_MGR_ReadIpFromCompl(compl,0, &data->ospf_nssa_area_id);

    if (NETCFG_MGR_GetOspfNssaEntry(data)!=NETCFG_MGR_OK)
    {
        return FALSE;
    }
    else
    {
        return TRUE;

    } /*End of if */
}

static BOOL_T ospfNssaTable_next(int      compc,
                                 oid     *compl,
                                 OSPF_TYPE_OspfNssaAreaEntry_T    *data)
{
    oid tmp_compl[ospfNssaEntry_INSTANCE_LEN];

    /* Generate the instance of each table entry and find the
     * smallest instance that's larger than compc/compl.
     *
     * Step 1: Verify and extract the input key from "compc" and "compl"
     * Note: The number of input key is defined by "compc".
     *       The key for the specified instance is defined in compl.
     */
    memcpy(tmp_compl, compl, sizeof(tmp_compl));
    SNMP_MGR_checkCompl(0, 3, tmp_compl,255);
    SNMP_MGR_ConvertRemainToZero(compc,ospfNssaEntry_INSTANCE_LEN, tmp_compl);

    SNMP_MGR_ReadIpFromCompl(tmp_compl,0,&data->ospf_nssa_area_id);


    if (compc<ospfNssaEntry_INSTANCE_LEN)
    {
        if (NETCFG_MGR_GetOspfNssaEntry(data)!=NETCFG_MGR_OK)
        {
            if (NETCFG_MGR_GetNextOspfNssaEntry(data)!=NETCFG_MGR_OK)
            {
                return FALSE;
            }
        }
    }
    else
    {
        if (NETCFG_MGR_GetNextOspfNssaEntry(data)!=NETCFG_MGR_OK)
        {
            return FALSE;
        }
    }
    return TRUE;
}

/* This entry is used for entry which have the ability to row create*/
static OSPF_TYPE_OspfNssaAreaEntry_T ospfNssaEntry;

/*
 * var_ospfNssaTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_ospfNssaTable(struct variable *vp,
                  oid * name,
                  size_t * length,
                  int exact, size_t * var_len, WriteMethod ** write_method)
{
    UI32_T compc=0;
    oid compl[ospfNssaEntry_INSTANCE_LEN];
    oid best_inst[ospfNssaEntry_INSTANCE_LEN];
    OSPF_TYPE_OspfNssaAreaEntry_T  data;


    /* Give default value for the record first.
     * We use the row_status = 0 to indicate if this set operation is Set by field
     * or set by record(included row creation), if the row_status =0, this record
     * mean set by field, otherwise, we just think it is a normal set operation
     */
    if (NETCFG_MGR_GetDefaultOspfNssaEntry(&ospfNssaEntry)!=NETCFG_MGR_OK)
    {
        if(SNMP_MGR_IsDebugMode())
            SYSFUN_Debug_Printf("FUNCTION:var_ospfNssaTable;DESC:NETCFG_MGR_GetDefaultOspfNssaEntry return NETCFG_MGR_FAIL\n");
        return NULL;
    }
    ospfNssaEntry.ospf_nssa_status = 0;

   /*Since this table allow for entry that does not exist, (creation). we need to know the write method first*/
    switch (vp->magic)
    {
      case OSPFNSSAREDISTRIBUTESTATUS:
        *write_method = write_ospfNssaRedistributeStatus;
        break;
      case OSPFNSSAORIGINATEDEFAULTINFOSTATUS:
        *write_method = write_ospfNssaOriginateDefaultInfoStatus;
         break;
      case OSPFNSSASTATUS:
        *write_method = write_ospfNssaStatus;
        break;
      default:
         *write_method =0;
         break;
    }

    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,compl, ospfNssaEntry_INSTANCE_LEN);

     /*check compc, retrive compl*/
    if (exact)/*get,set*/
    {
        if (!ospfNssaTable_get(compc, compl, &data))
            return NULL;
    }
    else/*getnext*/
    {
        if (!ospfNssaTable_next(compc, compl, &data))
        {
            return NULL;
        }
    }
    memcpy(name, vp->name, vp->namelen*sizeof(oid));
    SNMP_MGR_BindIpInstance(data.ospf_nssa_area_id,0,best_inst);
    memcpy(name + vp->namelen, best_inst, ospfNssaEntry_INSTANCE_LEN*sizeof(oid));
    *length = vp->namelen +ospfNssaEntry_INSTANCE_LEN;

    *var_len = sizeof(long_return);

    /*
     * * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
      #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
      case OSPFNSSAAREAID:
        long_return = data.ospf_nssa_area_id;
        return (u_char*) &long_return;
      #endif
      case OSPFNSSAREDISTRIBUTESTATUS:
        long_return = data.ospf_nssa_redistribute_status;
        return (u_char*) &long_return;
      case OSPFNSSAORIGINATEDEFAULTINFOSTATUS:
        long_return = data.ospf_nssa_default_information_status;
        return (u_char*) &long_return;
      case OSPFNSSASTATUS:
        long_return = data.ospf_nssa_status;
        return (u_char*) &long_return;
    default:
        ERROR_MSG("");
    }
    return NULL;
}


int
write_ospfNssaRedistributeStatus(int action,
                                 u_char * var_val,
                                 u_char var_val_type,
                                 size_t var_val_len,
                                 u_char * statP,
                                 oid * name, size_t name_len)
{
    UI32_T index;

    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

      /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  4 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    SNMP_MGR_ReadIpFromCompl(name, oid_name_length,  &index);
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
         /* In reserve2, we overwrite the set value to ospfNssaEntry*/
          ospfNssaEntry.ospf_nssa_redistribute_status = *(long *)var_val;
          if ((ospfNssaEntry.ospf_nssa_redistribute_status <VAL_ospfNssaRedistributeStatus_enabled) || (ospfNssaEntry.ospf_nssa_redistribute_status >VAL_ospfNssaRedistributeStatus_disabled))
             return SNMP_ERR_WRONGVALUE;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:

         /* For row creation, if row_status =0, mean that this is a normal
          * operation, we do the normal set operation, otherwise it is a row
          * creation operation, will do nothing here, and the overall entry
          * will perform in the write_xxxRowStatus function.
          */
            if ( ospfNssaEntry.ospf_nssa_status == 0)
        {
                if (NETCFG_MGR_SetOspfNssaRedistributeStatus(index, ospfNssaEntry.ospf_nssa_redistribute_status) !=NETCFG_MGR_OK)
              {
                  return SNMP_ERR_COMMITFAILED;
              }

         }

          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_ospfNssaOriginateDefaultInfoStatus(int action,
                                         u_char * var_val,
                                         u_char var_val_type,
                                         size_t var_val_len,
                                         u_char * statP,
                                         oid * name, size_t name_len)
{
    UI32_T index;

    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

      /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  4 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    SNMP_MGR_ReadIpFromCompl(name, oid_name_length,  &index);
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
           /* In reserve2, we overwrite the set value to ospfNssaEntry*/
          ospfNssaEntry.ospf_nssa_default_information_status = *(long *)var_val;
          if ((ospfNssaEntry.ospf_nssa_default_information_status <VAL_ospfNssaOriginateDefaultInfoStatus_enabled) || (ospfNssaEntry.ospf_nssa_default_information_status >VAL_ospfNssaOriginateDefaultInfoStatus_disabled))
             return SNMP_ERR_WRONGVALUE;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
         /* For row creation, if row_status =0, mean that this is a normal
          * operation, we do the normal set operation, otherwise it is a row
          * creation operation, will do nothing here, and the overall entry
          * will perform in the write_xxxRowStatus function.
          */
        if ( ospfNssaEntry.ospf_nssa_status == 0)
        {
              if (NETCFG_MGR_SetOspfNssaOriginateDefaultInfoStatus(index, ospfNssaEntry.ospf_nssa_default_information_status) !=NETCFG_MGR_OK)
              {
                  return SNMP_ERR_COMMITFAILED;
              }

         }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_ospfNssaStatus(int action,
                     u_char * var_val,
                     u_char var_val_type,
                     size_t var_val_len,
                     u_char * statP, oid * name, size_t name_len)
{
    UI32_T index;

    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

      /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  4 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    SNMP_MGR_ReadIpFromCompl(name, oid_name_length,  &index);
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
           /* In reserve2, we overwrite the set value to ospfNssaEntry*/
          ospfNssaEntry.ospf_nssa_status = *(long *)var_val;
          if ((ospfNssaEntry.ospf_nssa_status <VAL_ospfNssaStatus_active) || (ospfNssaEntry.ospf_nssa_status >VAL_ospfNssaStatus_destroy))
             return SNMP_ERR_WRONGVALUE;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
          /* We perform the row creation here, if the row status = 4(createAndGo),
           * or 5 (createAndWait), we call the SetByEntry API, otherwise, call the
           * set rowstatus API
           */
          switch (ospfNssaEntry.ospf_nssa_status)
          {
              case VAL_ospfNssaStatus_createAndGo:
              case VAL_ospfNssaStatus_createAndWait:
                ospfNssaEntry.ospf_nssa_area_id = index;
                if (NETCFG_MGR_SetOspfNssaEntry(&ospfNssaEntry) != NETCFG_MGR_OK)
                {
                    return SNMP_ERR_COMMITFAILED;
                }
              break;
              case VAL_ospfNssaStatus_active:
              case VAL_ospfNssaStatus_notInService:
              case VAL_ospfNssaStatus_notReady:
              case VAL_ospfNssaStatus_destroy:
                if (NETCFG_MGR_SetOspfNssaStatus(index, ospfNssaEntry.ospf_nssa_status) != NETCFG_MGR_OK)
                {
                    return SNMP_ERR_COMMITFAILED;
                }
                break;
              default:
            return SNMP_ERR_COMMITFAILED;
         }
          break;
        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


/* ospfRedistributeTable*/
#define ospfRedistributeEntry_INSTANCE_LEN 1
static BOOL_T ospfRedistributeTable_get(int      compc,
                                oid     *compl,
                                OSPF_TYPE_OspfRedistributeEntry_T   *data)
{
    if (compc !=ospfRedistributeEntry_INSTANCE_LEN)
    {
        return FALSE;
    }
    data->ospf_redistribute_protocol = compl[0];

    if (NETCFG_MGR_GetOspfRedistributeEntry(data)!=NETCFG_MGR_OK)
    {
        return FALSE;
    }
    else
    {
        return TRUE;

    } /*End of if */
}

static BOOL_T ospfRedistributeTable_next(int      compc,
                                 oid     *compl,
                                 OSPF_TYPE_OspfRedistributeEntry_T    *data)
{
    oid tmp_compl[ospfRedistributeEntry_INSTANCE_LEN];

    /* Generate the instance of each table entry and find the
     * smallest instance that's larger than compc/compl.
     *
     * Step 1: Verify and extract the input key from "compc" and "compl"
     * Note: The number of input key is defined by "compc".
     *       The key for the specified instance is defined in compl.
     */
    memcpy(tmp_compl, compl, sizeof(tmp_compl));
    SNMP_MGR_ConvertRemainToZero(compc,ospfRedistributeEntry_INSTANCE_LEN, tmp_compl);
    data->ospf_redistribute_protocol = tmp_compl[0];

    if (compc<ospfRedistributeEntry_INSTANCE_LEN)
    {
        if (NETCFG_MGR_GetOspfRedistributeEntry(data)!=NETCFG_MGR_OK)
        {
            if (NETCFG_MGR_GetNextOspfRedistributeEntry(data)!=NETCFG_MGR_OK)
            {
                return FALSE;
            }
        }
    }
    else
    {
        if (NETCFG_MGR_GetNextOspfRedistributeEntry(data)!=NETCFG_MGR_OK)
        {
            return FALSE;
        }
    }
    return TRUE;
}

/* This entry is used for entry which have the ability to row create*/
static OSPF_TYPE_OspfRedistributeEntry_T ospfRedistributeEntry;

/*
 * var_ospfRedistributeTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_ospfRedistributeTable(struct variable *vp,
                          oid * name,
                          size_t * length,
                          int exact,
                          size_t * var_len, WriteMethod ** write_method)
{
    UI32_T compc=0;
    oid compl[ospfRedistributeEntry_INSTANCE_LEN];
    oid best_inst[ospfRedistributeEntry_INSTANCE_LEN];
    OSPF_TYPE_OspfRedistributeEntry_T  data;

    /* Give default value for the record first.
     * We use the row_status = 0 to indicate if this set operation is Set by field
     * or set by record(included row creation), if the row_status =0, this record
     * mean set by field, otherwise, we just think it is a normal set operation
     */
    if (NETCFG_MGR_GetDefaultOspfRedistributeEntry(&ospfRedistributeEntry)!=NETCFG_MGR_OK)
    {
        if(SNMP_MGR_IsDebugMode())
            SYSFUN_Debug_Printf("FUNCTION:var_ospfRedistributeTable;DESC:NETCFG_MGR_GetDefaultOspfRedistributeEntry return NETCFG_MGR_FAIL\n");
        return NULL;
    }
    ospfRedistributeEntry.ospf_redistribute_status = 0;

   /*Since this table allow for entry that does not exist, (creation). we need to know the write method first*/
    switch (vp->magic)
    {
       case OSPFREDISTRIBUTEMETRICTYPE:
        *write_method = write_ospfRedistributeMetricType;
        break;
      case OSPFREDISTRIBUTEMETRIC:
        *write_method = write_ospfRedistributeMetric;
        break;
      case OSPFREDISTRIBUTESTATUS:
        *write_method = write_ospfRedistributeStatus;
        break;
      default:
         *write_method =0;
         break;
    }

    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,compl, ospfRedistributeEntry_INSTANCE_LEN);

     /*check compc, retrive compl*/
    if (exact)/*get,set*/
    {
        if (!ospfRedistributeTable_get(compc, compl, &data))
            return NULL;
    }
    else/*getnext*/
    {
        if (!ospfRedistributeTable_next(compc, compl, &data))
        {
            return NULL;
        }
    }
    memcpy(name, vp->name, vp->namelen*sizeof(oid));
    best_inst[0]=data.ospf_redistribute_protocol;
    memcpy(name + vp->namelen, best_inst, ospfRedistributeEntry_INSTANCE_LEN*sizeof(oid));
    *length = vp->namelen +ospfRedistributeEntry_INSTANCE_LEN;

    *var_len = sizeof(long_return);

    /*
     * * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
      #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
       case OSPFREDISTRIBUTEPROTOCOL:
        long_return = data.ospf_redistribute_protocol;
        return (u_char*) &long_return;
      #endif
       case OSPFREDISTRIBUTEMETRICTYPE:
        long_return = data.ospf_redistribute_mtype;
        return (u_char*) &long_return;
      case OSPFREDISTRIBUTEMETRIC:
        long_return = data.ospf_redistribute_met;
        return (u_char*) &long_return;
      case OSPFREDISTRIBUTESTATUS:
        long_return = data.ospf_redistribute_status;
        return (u_char*) &long_return;
    default:
        ERROR_MSG("");
    }
    return NULL;
}


int
write_ospfRedistributeMetricType(int action,
                                 u_char * var_val,
                                 u_char var_val_type,
                                 size_t var_val_len,
                                 u_char * statP,
                                 oid * name, size_t name_len)
{
    UI32_T index;

    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

      /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    index = name[oid_name_length];
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
         /* In reserve2, we overwrite the set value to ospfRedistributeEntry*/
          ospfRedistributeEntry.ospf_redistribute_mtype = *(long *)var_val;
          if ((ospfRedistributeEntry.ospf_redistribute_mtype <VAL_ospfRedistributeMetricType_type1) || (ospfRedistributeEntry.ospf_redistribute_mtype >VAL_ospfRedistributeMetricType_type2))
             return SNMP_ERR_WRONGVALUE;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
         /* For row creation, if row_status =0, mean that this is a normal
          * operation, we do the normal set operation, otherwise it is a row
          * creation operation, will do nothing here, and the overall entry
          * will perform in the write_xxxRowStatus function.
          */
        if ( ospfRedistributeEntry.ospf_redistribute_status == 0)
        {
            if (NETCFG_MGR_SetOspfRedistributeMetricType(index, ospfRedistributeEntry.ospf_redistribute_mtype) !=NETCFG_MGR_OK)
              {
                  return SNMP_ERR_COMMITFAILED;
              }

         }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_ospfRedistributeMetric(int action,
                             u_char * var_val,
                             u_char var_val_type,
                             size_t var_val_len,
                             u_char * statP, oid * name, size_t name_len)
{
    UI32_T index;

    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

      /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    index = name[oid_name_length];
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
           /* In reserve2, we overwrite the set value to ospfRedistributeEntry*/
          ospfRedistributeEntry.ospf_redistribute_met = *(long *)var_val;
          if ((ospfRedistributeEntry.ospf_redistribute_met <MIN_ospfRedistributeMetric) || (ospfRedistributeEntry.ospf_redistribute_met >MAX_ospfRedistributeMetric))
             return SNMP_ERR_WRONGVALUE;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
         /* For row creation, if row_status =0, mean that this is a normal
          * operation, we do the normal set operation, otherwise it is a row
          * creation operation, will do nothing here, and the overall entry
          * will perform in the write_xxxRowStatus function.
          */
        if ( ospfRedistributeEntry.ospf_redistribute_status == 0)
        {
              if (NETCFG_MGR_SetOspfRedistributeMetric(index, ospfRedistributeEntry.ospf_redistribute_met) !=NETCFG_MGR_OK)
              {
                  return SNMP_ERR_COMMITFAILED;
              }

         }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_ospfRedistributeStatus(int action,
                             u_char * var_val,
                             u_char var_val_type,
                             size_t var_val_len,
                             u_char * statP, oid * name, size_t name_len)
{

    UI32_T index;

    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

      /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    index = name[oid_name_length];
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
           /* In reserve2, we overwrite the set value to ospfRedistributeEntry*/
          ospfRedistributeEntry.ospf_redistribute_status = *(long *)var_val;
          if ((ospfRedistributeEntry.ospf_redistribute_status <VAL_ospfRedistributeStatus_active) || (ospfRedistributeEntry.ospf_redistribute_status >VAL_ospfRedistributeStatus_destroy))
             return SNMP_ERR_WRONGVALUE;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
          /* We perform the row creation here, if the row status = 4(createAndGo),
           * or 5 (createAndWait), we call the SetByEntry API, otherwise, call the
           * set rowstatus API
           */
          switch (ospfRedistributeEntry.ospf_redistribute_status)
          {
              case VAL_ospfRedistributeStatus_createAndGo:
              case VAL_ospfRedistributeStatus_createAndWait:
                ospfRedistributeEntry.ospf_redistribute_protocol = index;
                if (NETCFG_MGR_SetOspfRedistributeEntry(&ospfRedistributeEntry) != NETCFG_MGR_OK)
        {
                    return SNMP_ERR_COMMITFAILED;
                }
              break;
              case VAL_ospfRedistributeStatus_active:
              case VAL_ospfRedistributeStatus_notInService:
              case VAL_ospfRedistributeStatus_notReady:
              case VAL_ospfRedistributeStatus_destroy:
                if (NETCFG_MGR_SetOspfRedistributeStatus(index, ospfRedistributeEntry.ospf_redistribute_status) != NETCFG_MGR_OK)
              {
                  return SNMP_ERR_COMMITFAILED;
              }
                break;
              default:
            return SNMP_ERR_COMMITFAILED;
         }
          break;
        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


/* ospfSummaryAddressTable*/
#define ospfSummaryAddressEntry_INSTANCE_LEN 8
static BOOL_T ospfSummaryAddressTable_get(int      compc,
                                oid     *compl,
                                OSPF_TYPE_OspfSummaryAddressEntry_T   *data)
{
    if (compc !=ospfSummaryAddressEntry_INSTANCE_LEN)
    {
        return FALSE;
    }
    SNMP_MGR_ReadIpFromCompl(compl,0,&data->ospf_summary_address);
    SNMP_MGR_ReadIpFromCompl(compl,4,&data->ospf_summary_mask);


    if (NETCFG_MGR_GetOspfSummaryAddressEntry(data)!=NETCFG_MGR_OK)
    {
        return FALSE;
    }
    else
    {
        return TRUE;

    } /*End of if */
}

static BOOL_T ospfSummaryAddressTable_next(int      compc,
                                 oid     *compl,
                                 OSPF_TYPE_OspfSummaryAddressEntry_T    *data)
{
    oid tmp_compl[ospfSummaryAddressEntry_INSTANCE_LEN];

    /* Generate the instance of each table entry and find the
     * smallest instance that's larger than compc/compl.
     *
     * Step 1: Verify and extract the input key from "compc" and "compl"
     * Note: The number of input key is defined by "compc".
     *       The key for the specified instance is defined in compl.
     */
    memcpy(tmp_compl, compl, sizeof(tmp_compl));
    SNMP_MGR_checkCompl(0, 7, tmp_compl,255);
    SNMP_MGR_ConvertRemainToZero(compc,ospfSummaryAddressEntry_INSTANCE_LEN, tmp_compl);
    SNMP_MGR_ReadIpFromCompl(tmp_compl,0,&data->ospf_summary_address);
    SNMP_MGR_ReadIpFromCompl(tmp_compl,4,&data->ospf_summary_mask);

    if (compc<ospfSummaryAddressEntry_INSTANCE_LEN)
    {
        if (NETCFG_MGR_GetOspfSummaryAddressEntry(data)!=NETCFG_MGR_OK)
        {
            if (NETCFG_MGR_GetNextOspfSummaryAddressEntry(data)!=NETCFG_MGR_OK)
            {
                return FALSE;
            }
        }
    }
    else
    {
        if (NETCFG_MGR_GetNextOspfSummaryAddressEntry(data)!=NETCFG_MGR_OK)
        {
            return FALSE;
        }
    }
    return TRUE;
}

/* This entry is used for entry which have the ability to row create*/
static OSPF_TYPE_OspfSummaryAddressEntry_T ospfSummaryAddressEntry;

/*
 * var_ospfSummaryAddressTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_ospfSummaryAddressTable(struct variable *vp,
                            oid * name,
                            size_t * length,
                            int exact,
                            size_t * var_len, WriteMethod ** write_method)
{
    UI32_T compc=0;
    oid compl[ospfSummaryAddressEntry_INSTANCE_LEN];
    oid best_inst[ospfSummaryAddressEntry_INSTANCE_LEN];
    OSPF_TYPE_OspfSummaryAddressEntry_T  data;

    /* Give default value for the record first.
     * We use the row_status = 0 to indicate if this set operation is Set by field
     * or set by record(included row creation), if the row_status =0, this record
     * mean set by field, otherwise, we just think it is a normal set operation
     */
    if (NETCFG_MGR_GetDefaultOspfSummaryAddressEntry(&ospfSummaryAddressEntry)!=NETCFG_MGR_OK)
    {
        if(SNMP_MGR_IsDebugMode())
            SYSFUN_Debug_Printf("FUNCTION:ospfSummaryAddressEntry_set;DESC:NETCFG_MGR_GetDefaultOspfSummaryAddressEntry return NETCFG_MGR_FAIL\n");
    }
    ospfSummaryAddressEntry.ospf_summary_status = 0;

   /*Since this table allow for entry that does not exist, (creation). we need to know the write method first*/
    switch (vp->magic)
    {
       case OSPFSUMMARYSTATUS:
        *write_method = write_ospfSummaryStatus;
        break;
      default:
         *write_method =0;
         break;
    }

    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,compl, ospfSummaryAddressEntry_INSTANCE_LEN);

     /*check compc, retrive compl*/
    if (exact)/*get,set*/
    {
        if (!ospfSummaryAddressTable_get(compc, compl, &data))
            return NULL;
    }
    else/*getnext*/
    {
        if (!ospfSummaryAddressTable_next(compc, compl, &data))
        {
            return NULL;
        }
    }
    memcpy(name, vp->name, vp->namelen*sizeof(oid));
    SNMP_MGR_BindIpInstance(data.ospf_summary_address,0,best_inst);
    SNMP_MGR_BindIpInstance(data.ospf_summary_mask,4,best_inst);

    memcpy(name + vp->namelen, best_inst, ospfSummaryAddressEntry_INSTANCE_LEN*sizeof(oid));
    *length = vp->namelen +ospfSummaryAddressEntry_INSTANCE_LEN;

    *var_len = sizeof(long_return);

    /*
     * * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
      #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
      case OSPFSUMMARYADDRESS:
        long_return = data.ospf_summary_address;
        return (u_char*) &long_return;
      case OSPFSUMMARYMASK:
        long_return = data.ospf_summary_mask;
        return (u_char*) &long_return;
      #endif
      case OSPFSUMMARYSTATUS:
        long_return = data.ospf_summary_status;
        return (u_char*) &long_return;
    default:
        ERROR_MSG("");
    }
    return NULL;
}


int
write_ospfSummaryStatus(int action,
                        u_char * var_val,
                        u_char var_val_type,
                        size_t var_val_len,
                        u_char * statP, oid * name, size_t name_len)
{
    UI32_T index,index2;

    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

      /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  8 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    SNMP_MGR_ReadIpFromCompl(name, oid_name_length,  &index);
    SNMP_MGR_ReadIpFromCompl(name, oid_name_length+4,  &index2);


    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
            /* In reserve2, we overwrite the set value to ospfSummaryAddressEntry*/
          ospfSummaryAddressEntry.ospf_summary_status = *(long *)var_val;
          if ((ospfSummaryAddressEntry.ospf_summary_status <VAL_ospfSummaryStatus_active) || (ospfSummaryAddressEntry.ospf_summary_status >VAL_ospfSummaryStatus_destroy))
             return SNMP_ERR_WRONGVALUE;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
         /* We perform the row creation here, if the row status = 4(createAndGo),
          * or 5 (createAndWait), we call the SetByEntry API, otherwise, call the
          * set rowstatus API
          */
        switch (ospfSummaryAddressEntry.ospf_summary_status)
        {
              case VAL_ospfSummaryStatus_createAndGo:
              case VAL_ospfSummaryStatus_createAndWait:
                ospfSummaryAddressEntry.ospf_summary_address = index;
                ospfSummaryAddressEntry.ospf_summary_mask = index2;
                if (NETCFG_MGR_SetOspfSummaryAddressEntry(&ospfSummaryAddressEntry) != NETCFG_MGR_OK)
                {
                    return SNMP_ERR_COMMITFAILED;
                }
              break;
              case VAL_ospfSummaryStatus_active:
              case VAL_ospfSummaryStatus_notInService:
              case VAL_ospfSummaryStatus_notReady:
              case VAL_ospfSummaryStatus_destroy:
                if (NETCFG_MGR_SetOspfSummaryAddressStatus(index, index2, ospfSummaryAddressEntry.ospf_summary_status) != NETCFG_MGR_OK)
              {
                  return SNMP_ERR_COMMITFAILED;
              }
                break;
              default:
                return SNMP_ERR_COMMITFAILED;
         }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


/* ospfNetworkAreaAddressTable*/
#define ospfNetworkAreaAddressEntry_INSTANCE_LEN 8
static BOOL_T ospfNetworkAreaAddressTable_get(int      compc,
                                oid     *compl,
                                OSPF_TYPE_OspfNetworkAreaAddressEntry_T   *data)
{
    if (compc !=ospfNetworkAreaAddressEntry_INSTANCE_LEN)
    {
        return FALSE;
    }
    SNMP_MGR_ReadIpFromCompl(compl,0,&data->ospf_network_area_address);
    SNMP_MGR_ReadIpFromCompl(compl,4,&data->ospf_network_area_wildcard_mask);


    if (NETCFG_MGR_GetOspfNetworkAreaAddressEntry(data)!=NETCFG_MGR_OK)
    {
        return FALSE;
    }
    else
    {
        return TRUE;

    } /*End of if */
}

static BOOL_T ospfNetworkAreaAddressTable_next(int      compc,
                                 oid     *compl,
                                 OSPF_TYPE_OspfNetworkAreaAddressEntry_T    *data)
{
    oid tmp_compl[ospfNetworkAreaAddressEntry_INSTANCE_LEN];

    /* Generate the instance of each table entry and find the
     * smallest instance that's larger than compc/compl.
     *
     * Step 1: Verify and extract the input key from "compc" and "compl"
     * Note: The number of input key is defined by "compc".
     *       The key for the specified instance is defined in compl.
     */
    memcpy(tmp_compl, compl, sizeof(tmp_compl));
    SNMP_MGR_checkCompl(0, 7, tmp_compl,255);
    SNMP_MGR_ConvertRemainToZero(compc,ospfNetworkAreaAddressEntry_INSTANCE_LEN, tmp_compl);
    SNMP_MGR_ReadIpFromCompl(tmp_compl,0,&data->ospf_network_area_address);
    SNMP_MGR_ReadIpFromCompl(tmp_compl,4,&data->ospf_network_area_wildcard_mask);

    if (compc<ospfNetworkAreaAddressEntry_INSTANCE_LEN)
    {
        if (NETCFG_MGR_GetOspfNetworkAreaAddressEntry(data)!=NETCFG_MGR_OK)
        {
            if (NETCFG_MGR_GetNextOspfNetworkAreaAddressEntry(data)!=NETCFG_MGR_OK)
            {
                return FALSE;
            }
        }
    }
    else
    {
        if (NETCFG_MGR_GetNextOspfNetworkAreaAddressEntry(data)!=NETCFG_MGR_OK)
        {
            return FALSE;
        }
    }
    return TRUE;
}


/* This entry is used for entry which have the ability to row create*/
static OSPF_TYPE_OspfNetworkAreaAddressEntry_T ospfNetworkAreaAddress;

/*
 * var_ospfNetworkAreaAddressTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_ospfNetworkAreaAddressTable(struct variable *vp,
                                oid * name,
                                size_t * length,
                                int exact,
                                size_t * var_len,
                                WriteMethod ** write_method)
{
    UI32_T compc=0;
    oid compl[ospfNetworkAreaAddressEntry_INSTANCE_LEN];
    oid best_inst[ospfNetworkAreaAddressEntry_INSTANCE_LEN];
    OSPF_TYPE_OspfNetworkAreaAddressEntry_T  data;

    /* Give default value for the record first.
     * We use the row_status = 0 to indicate if this set operation is Set by field
     * or set by record(included row creation), if the row_status =0, this record
     * mean set by field, otherwise, we just think it is a normal set operation
     */
    if (NETCFG_MGR_GetDefaultOspfNetworkAreaAddressEntry(&ospfNetworkAreaAddress)!=NETCFG_MGR_OK)
    {
        if(SNMP_MGR_IsDebugMode())
            SYSFUN_Debug_Printf("FUNCTION:var_ospfNetworkAreaAddressTable;DESC:NETCFG_MGR_GetDefaultOspfNewrokAreaAddressEntry return NETCFG_MGR_FAIL\n");
        return NULL;
    }
    ospfNetworkAreaAddress.ospf_network_area_status = 0;

   /*Since this table allow for entry that does not exist, (creation). we need to know the write method first*/
    switch (vp->magic)
    {
      case OSPFNETWORKAREASTATUS:
        *write_method = write_ospfNetworkAreaStatus;
        break;
      default:
         *write_method =0;
         break;
    }

    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,compl, ospfNetworkAreaAddressEntry_INSTANCE_LEN);

     /*check compc, retrive compl*/
    if (exact)/*get,set*/
    {
        if (!ospfNetworkAreaAddressTable_get(compc, compl, &data))
            return NULL;
    }
    else/*getnext*/
    {
        if (!ospfNetworkAreaAddressTable_next(compc, compl, &data))
        {
            return NULL;
        }
    }
    memcpy(name, vp->name, vp->namelen*sizeof(oid));
    SNMP_MGR_BindIpInstance(data.ospf_network_area_address,0,best_inst);
    SNMP_MGR_BindIpInstance(data.ospf_network_area_wildcard_mask,4,best_inst);

    memcpy(name + vp->namelen, best_inst, ospfNetworkAreaAddressEntry_INSTANCE_LEN*sizeof(oid));
    *length = vp->namelen +ospfNetworkAreaAddressEntry_INSTANCE_LEN;

    *var_len = sizeof(long_return);

    /*
     * * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
      #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case OSPFNETWORKAAREAADDRESS:
        long_return = data.ospf_network_area_address;
        return (u_char*) &long_return;
      #endif
      case OSPFNETWORKAREAMASK:
        long_return = data.ospf_network_area_wildcard_mask;
        return (u_char*) &long_return;
      case OSPFNETWORKAREAAREAID:
        long_return = data.ospf_network_area_areaid;
        return (u_char*) &long_return;
     case OSPFNETWORKAREASTATUS:
        long_return = data.ospf_network_area_status;
        return (u_char*) &long_return;
    default:
        ERROR_MSG("");
    }
    return NULL;
}


int
write_ospfNetworkAreaStatus(int action,
                            u_char * var_val,
                            u_char var_val_type,
                            size_t var_val_len,
                            u_char * statP, oid * name, size_t name_len)
{
    UI32_T index,index1;

    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

      /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  8 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    SNMP_MGR_ReadIpFromCompl(name, oid_name_length,  &index);
    SNMP_MGR_ReadIpFromCompl(name, oid_name_length+4,  &index1);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
           /* In reserve2, we overwrite the set value to dot1qVlanStaticEntry*/
          ospfNetworkAreaAddress.ospf_network_area_status = *(long *)var_val;
          if ((ospfNetworkAreaAddress.ospf_network_area_status <VAL_ospfNetworkAreaStatus_active) || (ospfNetworkAreaAddress.ospf_network_area_status >VAL_ospfNetworkAreaStatus_destroy))
             return SNMP_ERR_WRONGVALUE;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
         /* We perform the row creation here, if the row status = 4(createAndGo),
          * or 5 (createAndWait), we call the SetByEntry API, otherwise, call the
          * set rowstatus API
          */
        switch (ospfNetworkAreaAddress.ospf_network_area_status)
          {
              case VAL_ospfNetworkAreaStatus_createAndGo:
              case VAL_ospfNetworkAreaStatus_createAndWait:
                ospfNetworkAreaAddress.ospf_network_area_address = index;
                ospfNetworkAreaAddress.ospf_network_area_wildcard_mask = index1;
                if (NETCFG_MGR_SetOspfNetworkAreaAddressEntry(ospfNetworkAreaAddress) != NETCFG_MGR_OK)
        {
                    return SNMP_ERR_COMMITFAILED;
                }
              break;
              case VAL_ospfNetworkAreaStatus_active:
              case VAL_ospfNetworkAreaStatus_notInService:
              case VAL_ospfNetworkAreaStatus_notReady:
              case VAL_ospfNetworkAreaStatus_destroy:
                if (NETCFG_MGR_SetOspfNetworkAreaStatus(index, index1, ospfNetworkAreaAddress.ospf_network_area_status) != NETCFG_MGR_OK)
              {
                  return SNMP_ERR_COMMITFAILED;
              }
                break;
              default:
                return SNMP_ERR_COMMITFAILED;
         }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

#endif /*end of #if (SYS_CPNT_OSPF == TRUE)*/
#endif

#if 0 /*These functions will be implemented in future -- xiongyu 20090112*/
#if (SYS_CPNT_OSPF == TRUE)

#define ipCidrRouteExtEntry_INSTANCE_LEN 13
/*ipCidrRouteExtTable*/
static BOOL_T ipCidrRouteExtTable_get(int      compc,
                                oid     *compl,
                                NETCFG_MGR_ipCidrRouteEntry_T   *data)
{
    if (compc !=ipCidrRouteExtEntry_INSTANCE_LEN)
    {
        return FALSE;
    }

    SNMP_MGR_ReadIpFromCompl(compl,0,&data->ip_cidr_route_dest);
    SNMP_MGR_ReadIpFromCompl(compl,4,&data->ip_cidr_route_mask);
    data->ip_cidr_route_tos = compl[8];
    SNMP_MGR_ReadIpFromCompl(compl,9,&data->ip_cidr_route_next_hop);

    if (NETCFG_MGR_GetIpCidrRouteEntry(data)!=NETCFG_MGR_OK)
    {
        return FALSE;
    }
    else
    {
        return TRUE;

    } /*End of if */
}

static BOOL_T ipCidrRouteExtTable_next(int      compc,
                                 oid     *compl,
                                 NETCFG_MGR_ipCidrRouteEntry_T    *data)
{
    oid tmp_compl[ipCidrRouteExtEntry_INSTANCE_LEN];

    /* Generate the instance of each table entry and find the
     * smallest instance that's larger than compc/compl.
     *
     * Step 1: Verify and extract the input key from "compc" and "compl"
     * Note: The number of input key is defined by "compc".
     *       The key for the specified instance is defined in compl.
     */
    memcpy(tmp_compl, compl, sizeof(tmp_compl));
    SNMP_MGR_checkCompl(0, 7, tmp_compl,255);
    SNMP_MGR_checkCompl(9, 12, tmp_compl,255);
    SNMP_MGR_ConvertRemainToZero(compc,ipCidrRouteExtEntry_INSTANCE_LEN, tmp_compl);
    SNMP_MGR_ReadIpFromCompl(tmp_compl,0,&data->ip_cidr_route_dest);
    SNMP_MGR_ReadIpFromCompl(tmp_compl,4,&data->ip_cidr_route_mask);
    data->ip_cidr_route_tos = tmp_compl[8];
    SNMP_MGR_ReadIpFromCompl(tmp_compl,9,&data->ip_cidr_route_next_hop);
    if (compc<ipCidrRouteExtEntry_INSTANCE_LEN)
    {
        if (NETCFG_MGR_GetIpCidrRouteEntry(data)!=NETCFG_MGR_OK)
        {
            if (NETCFG_MGR_GetNextIpCidrRouteEntry(data)!=NETCFG_MGR_OK)
            {
                return FALSE;
            }
        }
    }
    else
    {
        if (NETCFG_MGR_GetNextIpCidrRouteEntry(data)!=NETCFG_MGR_OK)
        {
            return FALSE;
        }
    }
    return TRUE;
}


/*
 * var_ipCidrRouteExtTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_ipCidrRouteExtTable(struct variable *vp,
                        oid * name,
                        size_t * length,
                        int exact,
                        size_t * var_len, WriteMethod ** write_method)
{
    UI32_T compc=0;
    oid compl[ipCidrRouteExtEntry_INSTANCE_LEN];
    oid best_inst[ipCidrRouteExtEntry_INSTANCE_LEN];
    NETCFG_MGR_ipCidrRouteEntry_T  data;

    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,compl, ipCidrRouteExtEntry_INSTANCE_LEN);

     /*check compc, retrive compl*/
    if (exact)/*get,set*/
    {
        if (!ipCidrRouteExtTable_get(compc, compl, &data))
            return NULL;
    }
    else/*getnext*/
    {
        if (!ipCidrRouteExtTable_next(compc, compl, &data))
        {
            return NULL;
        }
    }
    memcpy(name, vp->name, vp->namelen*sizeof(oid));
    SNMP_MGR_BindIpInstance(data.ip_cidr_route_dest,0,best_inst);
    SNMP_MGR_BindIpInstance(data.ip_cidr_route_mask,4,best_inst);
    best_inst[8] = data.ip_cidr_route_tos;
    SNMP_MGR_BindIpInstance(data.ip_cidr_route_next_hop,9,best_inst);

    memcpy(name + vp->namelen, best_inst, ipCidrRouteExtEntry_INSTANCE_LEN*sizeof(oid));
    *length = vp->namelen +ipCidrRouteExtEntry_INSTANCE_LEN;

    *var_len = sizeof(long_return);

    /*
     * * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
       #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
      case IPCIDRROUTEEXTDEST:
        *var_len = sizeof(ipaddr_return);
        ipaddr_return = data.ip_cidr_route_dest;
        return (u_char*) &ipaddr_return;
      case IPCIDRROUTEEXTMASK:
        *var_len = sizeof(ipaddr_return);
        ipaddr_return = data.ip_cidr_route_mask;
        return (u_char*) &ipaddr_return;
      case IPCIDRROUTEEXTTOS:
        long_return = data.ip_cidr_route_tos;
        return (u_char*) &long_return;
      case IPCIDRROUTEEXTNEXTHOP:
        ipaddr_return = data.ip_cidr_route_next_hop;
        *var_len = sizeof(ipaddr_return);
        return (u_char*) &ipaddr_return;
#endif
      case IPCIDRROUTEEXTOSPFSUBTYPE:
        long_return = data.ip_cidr_route_ext_subtype;
        return (u_char*) &long_return;
    default:
        ERROR_MSG("");
    }
    return NULL;
}
#endif
#endif

#if (SYS_CPNT_NSM == TRUE)
int
do_routeMultipath(netsnmp_mib_handler *handler,
             netsnmp_handler_registration *reginfo,
             netsnmp_agent_request_info *reqinfo,
             netsnmp_request_info *requests)
{
    UI8_T multipath_number;

    switch(reqinfo->mode)
    {
        case MODE_GET:
            if (NSM_PMGR_GetMultipathNumber(&multipath_number) != NSM_TYPE_RESULT_OK)
                return SNMP_ERR_GENERR;

            long_return = multipath_number;
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
            break;
        case MODE_SET_RESERVE1:
            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_WRONGTYPE);
                break;
            }

            multipath_number = (UI8_T)*requests->requestvb->val.integer;

            if (multipath_number < 1 || multipath_number > SYS_ADPT_MAX_NBR_OF_ECMP_ENTRY_PER_ROUTE)
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_WRONGVALUE);

            break;
        case MODE_SET_RESERVE2:
        case MODE_SET_FREE:
            break;
        case MODE_SET_ACTION:
            multipath_number = (UI8_T)*requests->requestvb->val.integer;

            if (NSM_PMGR_SetMultipathNumber(multipath_number) != NSM_TYPE_RESULT_OK)
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);

            break;
        case MODE_SET_COMMIT:
        case MODE_SET_UNDO:
            break;
        default:
            return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}
#endif /* SYS_CPNT_NSM */

#if (SYS_CPNT_AAA == TRUE)
#if (SYS_CPNT_ACCOUNTING == TRUE) /*maggie liu, 2009-03-09*/
/********************************************
 **************aaaMgt************************
 *********************************************/
int
do_aaaUpdate(netsnmp_mib_handler *handler,
             netsnmp_handler_registration *reginfo,
             netsnmp_agent_request_info *reqinfo,
             netsnmp_request_info *requests)
{
    UI32_T nUpdate;

    switch (reqinfo->mode)
    {
        case MODE_GET:
        {
            if (AAA_POM_GetUpdate(&nUpdate) != TRUE)
            {
                return SNMP_ERR_GENERR;
            }

            long_return = nUpdate;
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char*) &long_return, sizeof(long_return));

            break;
        }

        case MODE_SET_RESERVE1:
            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
            }

            break;

        case MODE_SET_RESERVE2:
            if (*requests->requestvb->val.integer < MIN_aaaUpdate ||
                *requests->requestvb->val.integer > MAX_aaaUpdate)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            }

            break;

        case MODE_SET_FREE:
            break;

        case MODE_SET_ACTION:
        {
            nUpdate = *requests->requestvb->val.integer;
            if (AAA_PMGR_SetUpdate(nUpdate) != TRUE)
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);

            break;
        }

        case MODE_SET_COMMIT:
        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}

/********************************************
 **************aaaMethodTable****************
 ********************************************
 */
#define aaaMethodEntry_INSTANCE_LEN  1

static BOOL_T aaaMethodTable_get(int compc,
                                 oid* compl,
                                 AAA_AccListEntryInterface_T   *data)
{
    if (compc != aaaMethodEntry_INSTANCE_LEN)
    {
        return FALSE;
    }

    data->list_index = compl[0];

    if (SNMP_MGR_IsDebugMode())
        SYSFUN_Debug_Printf("aaaMethodTable_get:index=[%d]\n", data->list_index);

    if (!AAA_POM_GetMethodTable(data->list_index, data))
    {
        if (SNMP_MGR_IsDebugMode())
            SYSFUN_Debug_Printf("aaaMethodTable_get:AAA_MGR_GetMethodTable return false\n");

        return FALSE;
    }
    else
    {
        return TRUE;
    } /*End of if */

}

static BOOL_T aaaMethodTable_next(int compc,
                                  oid* compl,
                                  AAA_AccListEntryInterface_T *data)
{
    data->list_index = compl[0];

    if (SNMP_MGR_IsDebugMode())
        SYSFUN_Debug_Printf("aaaMethodTable_next:data->list_index=[%d]\n", data->list_index);

    if (compc < aaaMethodEntry_INSTANCE_LEN)
    {
        if (!AAA_POM_GetMethodTable(data->list_index, data))
        {
            if (!AAA_POM_GetNextMethodTable(data->list_index, data))
            {
                if (SNMP_MGR_IsDebugMode())
                    SYSFUN_Debug_Printf("aaaMethodTable_next: get & genext return false\n");

                return FALSE;
            }
        }
    }
    else
    {
        if (!AAA_POM_GetNextMethodTable(data->list_index, data))
        {
            if (SNMP_MGR_IsDebugMode())
                SYSFUN_Debug_Printf("aaaMethodTable_next: get return false\n");

            return FALSE;
        }
    }

    return TRUE;
}

unsigned char*
var_aaaMethodTable(struct variable *vp,
                   oid *name,
                   size_t *length,
                   int exact,
                   size_t *var_len, WriteMethod **write_method)
{
    UI32_T compc = 0;
    oid compl[aaaMethodEntry_INSTANCE_LEN];
    oid best_inst[aaaMethodEntry_INSTANCE_LEN];
    AAA_AccListEntryInterface_T data;
    memset(&data, 0, sizeof(data));

    switch (vp->magic)
    {
        case AAAMETHODNAME:
            *write_method = write_aaaMethodName;
            break;

        case AAAMETHODGROUPNAME:
            *write_method = write_aaaMethodGroupName;
            break;

        case AAAMETHODMODE:
            *write_method = write_aaaMethodMode;
            break;

        case AAAMETHODSTATUS:
            *write_method = write_aaaMethodStatus;
            break;

        case AAAMETHODCLIENTTYPE:
            *write_method = write_aaaMethodClientType;
            break;

        default:
            *write_method = 0;
            break;
    }

    //step 1: retrive compc, compl
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl, aaaMethodEntry_INSTANCE_LEN);

    //step2: call get/getnext ;check compc, retrive compl
    if (exact) /*get,set*/
    {
        if (!aaaMethodTable_get(compc, compl, &data))
            return NULL;
    }
    else /*getnext*/
    {
        if (!aaaMethodTable_next(compc, compl, &data))
            return NULL;
    }

    //step 3:binds next oid back to agent
    memcpy(name, vp->name, vp->namelen * sizeof(oid));
    best_inst[0] = data.list_index;

    memcpy(name + vp->namelen, best_inst, aaaMethodEntry_INSTANCE_LEN * sizeof(oid));

    //step 4:return get value result to agent
    *length = vp->namelen + aaaMethodEntry_INSTANCE_LEN;

    *var_len = sizeof(long_return);

    // this is where we do the value assignments for the mib results.
    switch (vp->magic)
    {
        case AAAMETHODNAME:
            strcpy((char*)return_buf, (char*)data.list_name);
            *var_len = strlen((char*)return_buf);
            return (u_char*) return_buf;

        case AAAMETHODGROUPNAME:
            strcpy((char*)return_buf, (char*)data.group_name);
            *var_len = strlen((char*)return_buf);
            return (u_char*) return_buf;

        case AAAMETHODMODE:
            /* shumin.wang fix bug ES3628BT-FLF-ZZ-00439 */
            // long_return = VAL_aaaAccountMethodMode_start_stop;
            long_return = data.working_mode;
            return (u_char*) &long_return;

        case AAAMETHODSTATUS:
            long_return = VAL_aaaMethodStatus_valid;
            return (u_char*) &long_return;

        case AAAMETHODCLIENTTYPE:
            long_return = data.client_type;
            return (u_char*) &long_return;

        default:
            ERROR_MSG("");
    }
    return NULL;
}


int
write_aaaMethodName(int action,
                    u_char *var_val,
                    u_char var_val_type,
                    size_t var_val_len,
                    u_char *statP, oid *name, size_t name_len)
{
    UI32_T oid_name_length;

    oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_OCTET_STR)
                return SNMP_ERR_WRONGTYPE;

            if ((var_val_len < MINSIZE_aaaMethodName) || (var_val_len > MAXSIZE_aaaMethodName))
                return SNMP_ERR_WRONGLENGTH;

            break;

        case RESERVE2:
        case FREE:
            break;

        case ACTION:
        {
            UI16_T nIndex;
            char buffer[MAXSIZE_aaaMethodName + 1];

            memset(buffer, 0, sizeof(buffer));
            strncpy((char*)buffer, (char*)var_val, var_val_len);
            nIndex = (UI16_T)name[oid_name_length];
            if (AAA_PMGR_SetMethodName(nIndex, buffer) != TRUE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
        case COMMIT:
            break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_aaaMethodGroupName(int action,
                         u_char *var_val,
                         u_char var_val_type,
                         size_t var_val_len,
                         u_char *statP, oid *name, size_t name_len)
{
    UI32_T oid_name_length;

    oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_OCTET_STR)
                return SNMP_ERR_WRONGTYPE;

            if ((var_val_len < MINSIZE_aaaMethodGroupName) || (var_val_len > MAXSIZE_aaaMethodGroupName))
                return SNMP_ERR_WRONGLENGTH;

            break;

        case RESERVE2:
        case FREE:
            break;

        case ACTION:
        {
            UI16_T nIndex;
            char buffer[MAXSIZE_aaaMethodGroupName + 1];

            memset(buffer, 0, sizeof(buffer));
            strncpy((char*)buffer, (char*)var_val, var_val_len);
            nIndex = (UI16_T)name[oid_name_length];

            if (AAA_PMGR_SetMethodGroupName(nIndex, buffer) != TRUE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
        case COMMIT:
            break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_aaaMethodMode(int action,
                    u_char *var_val,
                    u_char var_val_type,
                    size_t var_val_len,
                    u_char *statP, oid *name, size_t name_len)
{
    long value;
    UI32_T oid_name_length;

    oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
                return SNMP_ERR_WRONGTYPE;

            if (var_val_len > sizeof(long))
                return SNMP_ERR_WRONGLENGTH;

            break;

        case RESERVE2:
            value = *(long*) var_val;
            if (value != VAL_aaaMethodMode_start_stop)
                return SNMP_ERR_WRONGVALUE;

            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T nMode;
            UI16_T nIndex;
            value = *(long *)var_val;
            nIndex = (UI16_T) name[oid_name_length];
            if (AAA_PMGR_SetMethodMode(nIndex, (UI8_T)nMode) != TRUE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
        case COMMIT:
            break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_aaaMethodStatus(int action,
                      u_char *var_val,
                      u_char var_val_type,
                      size_t var_val_len,
                      u_char *statP, oid *name, size_t name_len)
{
    long value;
    UI32_T oid_name_length;

    oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
                return SNMP_ERR_WRONGTYPE;

            if (var_val_len > sizeof(long))
                return SNMP_ERR_WRONGLENGTH;

            break;

        case RESERVE2:
            value = *(long*) var_val;

            switch (value)
            {
                case VAL_aaaMethodStatus_valid:
                case VAL_aaaMethodStatus_invalid:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T nStatus;
            UI16_T nIndex;
            nStatus = *(long *)var_val;
            nIndex  = (UI16_T) name[oid_name_length];

            if (AAA_PMGR_SetMethodStatus(nIndex, (UI8_T)nStatus) != TRUE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
        case COMMIT:
            break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_aaaMethodClientType(int action,
                          u_char *var_val,
                          u_char var_val_type,
                          size_t var_val_len,
                          u_char *statP, oid *name, size_t name_len)
{
    long value;
    UI32_T oid_name_length;

    oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
                return SNMP_ERR_WRONGTYPE;

            if (var_val_len > sizeof(long))
                return SNMP_ERR_WRONGLENGTH;

            break;

        case RESERVE2:
            value = *(long*) var_val;

            switch (value)
            {
                case VAL_aaaMethodClientType_dot1x:
                case VAL_aaaMethodClientType_exec:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T nType;
            UI16_T nIndex = 0;
            nType = *(long *)var_val;
            nIndex = (UI16_T) name[oid_name_length];
            if (AAA_PMGR_SetMethodClientType(nIndex, nType) != TRUE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
        case COMMIT:
            break;
    }
    return SNMP_ERR_NOERROR;
}
#if (SYS_CPNT_RADIUS_ACCOUNTING == TRUE)
/********************************************
 **************aaaRadiusGroupTable***********
 ********************************************
 */
#define aaaRadiusGroupEntry_INSTANCE_LEN  1

static BOOL_T aaaRadiusGroupTable_get(int compc,
                                      oid* compl,
                                      AAA_RadiusGroupEntryMIBInterface_T   *data)
{
    UI16_T nIndex;
    if (compc != aaaRadiusGroupEntry_INSTANCE_LEN)
    {
        return FALSE;
    }

    nIndex = compl[0];
    if (SNMP_MGR_IsDebugMode())
        SYSFUN_Debug_Printf("aaaRadiusGroupTable_get:index=[%d]\n", nIndex);

    if (!AAA_POM_GetRadiusGroupTable(nIndex, data))
    {
        if (SNMP_MGR_IsDebugMode())
            SYSFUN_Debug_Printf("aaaRadiusGroupTable_get:AAA_MGR_GetRadiusGroupTable return false\n");

        return FALSE;
    }
    else
    {
        return TRUE;
    }        /*End of if */

}

static BOOL_T aaaRadiusGroupTable_next(int compc,
                                       oid* compl,
                                       AAA_RadiusGroupEntryMIBInterface_T    *data)
{
    int index = compl[0];

    if (SNMP_MGR_IsDebugMode())
        SYSFUN_Debug_Printf("aaaRadiusGroupTable_next:data->group_index=[%d]\n", index);

    if (compc < aaaRadiusGroupEntry_INSTANCE_LEN)
    {
        if (!AAA_POM_GetRadiusGroupTable(index, data))
        {
            if (!AAA_POM_GetNextRadiusGroupTable(index, data))
            {
                if (SNMP_MGR_IsDebugMode())
                    SYSFUN_Debug_Printf("aaaRadiusGroupTable_next: get & genext return false\n");

                return FALSE;
            }
        }
    }
    else
    {
        if (!AAA_POM_GetNextRadiusGroupTable(index, data))
        {
            if (SNMP_MGR_IsDebugMode())
                SYSFUN_Debug_Printf("aaaRadiusGroupTable_next: get return false\n");

            return FALSE;
        }
    }

    return TRUE;
}


unsigned char*
var_aaaRadiusGroupTable(struct variable *vp,
                        oid *name,
                        size_t *length,
                        int exact,
                        size_t *var_len, WriteMethod **write_method)
{
    UI32_T compc = 0;
    oid compl[aaaRadiusGroupEntry_INSTANCE_LEN];
    oid best_inst[aaaRadiusGroupEntry_INSTANCE_LEN];
    AAA_RadiusGroupEntryMIBInterface_T data;
    memset(&data, 0, sizeof(data));

    switch (vp->magic)
    {
        case AAARADIUSGROUPSERVERBITMAP:
            *write_method = write_aaaRadiusGroupServerBitMap;
            break;

        case AAARADIUSGROUPNAME:
            *write_method = write_aaaRadiusGroupName;
            break;

        case AAARADIUSGROUPSTATUS:
            *write_method = write_aaaRadiusGroupStatus;
            break;

        default:
            *write_method = 0;
            ERROR_MSG("");
            break;
    }

    //step 1: retrive compc, compl
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl, aaaRadiusGroupEntry_INSTANCE_LEN);

    //step2: call get/getnext ;check compc, retrive compl
    if (exact) /*get,set*/
    {
        if (!aaaRadiusGroupTable_get(compc, compl, &data))
            return NULL;
    }
    else /*getnext*/
    {
        if (!aaaRadiusGroupTable_next(compc, compl, &data))
            return NULL;
    }

    //step 3:binds next oid back to agent
    memcpy(name, vp->name, vp->namelen * sizeof(oid));
    best_inst[0] = data.group_index;

    memcpy(name + vp->namelen, best_inst, aaaRadiusGroupEntry_INSTANCE_LEN * sizeof(oid));

    //step 4:return get value result to agent
    *length = vp->namelen + aaaRadiusGroupEntry_INSTANCE_LEN;

    *var_len = sizeof(long_return);

    // this is where we do the value assignments for the mib results.
    switch (vp->magic)
    {
        case AAARADIUSGROUPSERVERBITMAP:
            memcpy(return_buf, &data.radius_server_list, aaaRadiusGroupEntry_INSTANCE_LEN);
            *var_len = aaaRadiusGroupEntry_INSTANCE_LEN;
            return (u_char*) return_buf;

        case AAARADIUSGROUPNAME:
            strcpy((char*)return_buf, (char*)data.group_name);
            *var_len = strlen((char*)return_buf);
            return (u_char*) return_buf;

        case AAARADIUSGROUPSTATUS:
            long_return = VAL_aaaRadiusGroupStatus_valid;
            return (u_char*) &long_return;

        default:
            ERROR_MSG("");
    }
    return NULL;
}


int
write_aaaRadiusGroupServerBitMap(int action,
                                 u_char *var_val,
                                 u_char var_val_type,
                                 size_t var_val_len,
                                 u_char *statP,
                                 oid *name, size_t name_len)
{
    UI32_T oid_name_length;

    oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_OCTET_STR)
                return SNMP_ERR_WRONGTYPE;

            if (var_val_len > sizeof(char))
                return SNMP_ERR_WRONGLENGTH;

            break;

        case RESERVE2:
        case FREE:
            break;

        case ACTION:
        {
            UI16_T nIndex;
            UI8_T nBitMap;
            nBitMap = (UI8_T ) *var_val;
            nIndex  = (UI16_T)name[oid_name_length];
            if (AAA_PMGR_SetRadiusGroupServerBitMap(nIndex, nBitMap) != TRUE)
                return SNMP_ERR_COMMITFAILED;

            break;
        }

        case UNDO:
        case COMMIT:
            break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_aaaRadiusGroupName(int action,
                         u_char *var_val,
                         u_char var_val_type,
                         size_t var_val_len,
                         u_char *statP, oid *name, size_t name_len)
{
    UI32_T oid_name_length;

    oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_OCTET_STR)
                return SNMP_ERR_WRONGTYPE;

            if (var_val_len > MAXSIZE_aaaRadiusGroupName)
                return SNMP_ERR_WRONGLENGTH;

            break;

        case RESERVE2:
        case FREE:
            break;

        case ACTION:
        {
            UI16_T nIndex;
            char buffer[MAXSIZE_aaaRadiusGroupName + 1];

            memset(buffer, 0, sizeof(buffer));
            strncpy((char*)buffer, (char*)var_val, var_val_len);
            nIndex = name[oid_name_length];
            if (AAA_PMGR_SetRadiusGroupName(nIndex, buffer) == FALSE)
                return SNMP_ERR_COMMITFAILED;

            break;
        }

        case UNDO:
        case COMMIT:
            break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_aaaRadiusGroupStatus(int action,
                           u_char *var_val,
                           u_char var_val_type,
                           size_t var_val_len,
                           u_char *statP, oid *name, size_t name_len)
{
    long value;
    UI32_T oid_name_length;

    oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
                return SNMP_ERR_WRONGTYPE;

            if (var_val_len > sizeof(long))
                return SNMP_ERR_WRONGLENGTH;

            break;

        case RESERVE2:
            value = *(long*) var_val;

            switch (value)
            {
                case VAL_aaaRadiusGroupStatus_valid:
                case VAL_aaaRadiusGroupStatus_invalid:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T nStatus;
            UI16_T nIndex;

            nStatus = *(long *)var_val;
            nIndex  = (UI16_T)name[oid_name_length];
            if (AAA_PMGR_SetRadiusGroupStatus(nIndex, (UI8_T)nStatus) != TRUE)
                return SNMP_ERR_COMMITFAILED;

            break;
        }

        case UNDO:
        case COMMIT:
            break;
    }
    return SNMP_ERR_NOERROR;
}
#endif /* end of #if(SYS_CPNT_RADIUS_ACCOUNTING == TRUE )*/

#if (SYS_CPNT_TACACS_PLUS_ACCOUNTING == TRUE)
/********************************************
 **********aaaTacacsPlusGroupTable***********
 ********************************************
 */
#define aaaTacacsPlusGroupEntry_INSTANCE_LEN  1

static BOOL_T aaaTacacsPlusGroupTable_get(int compc,
                                          oid* compl,
                                          AAA_TacacsPlusGroupEntryMIBInterface_T   *data)
{
    UI16_T nIndex;
    if (compc != aaaTacacsPlusGroupEntry_INSTANCE_LEN)
    {
        return FALSE;
    }

    nIndex = compl[0];
    if (SNMP_MGR_IsDebugMode())
        SYSFUN_Debug_Printf("aaaTacacsPlusGroupTable_get:index=[%d]\n", nIndex);

    if (!AAA_POM_GetTacacsPlusGroupTable(nIndex, data))
    {
        if (SNMP_MGR_IsDebugMode())
            SYSFUN_Debug_Printf("aaaTacacsPlusGroupTable_get:AAA_MGR_GetTacacsPlusGroupTable return false\n");

        return FALSE;
    }
    else
    {
        return TRUE;
    }        /*End of if */

}

static BOOL_T aaaTacacsPlusGroupTable_next(int compc,
                                           oid* compl,
                                           AAA_TacacsPlusGroupEntryMIBInterface_T    *data)
{
    int index = compl[0];

    if (SNMP_MGR_IsDebugMode())
        SYSFUN_Debug_Printf("aaaTacacsPlusGroupTable_next:data->group_index=[%d]\n", index);

    if (compc < aaaTacacsPlusGroupEntry_INSTANCE_LEN)
    {
        if (!AAA_POM_GetTacacsPlusGroupTable(index, data))
        {
            if (!AAA_POM_GetNextTacacsPlusGroupTable(index, data))
            {
                if (SNMP_MGR_IsDebugMode())
                    SYSFUN_Debug_Printf("aaaTacacsPlusGroupTable_next: get & genext return false\n");

                return FALSE;
            }
        }
    }
    else
    {
        if (!AAA_POM_GetNextTacacsPlusGroupTable(index, data))
        {
            if (SNMP_MGR_IsDebugMode())
                SYSFUN_Debug_Printf("aaaTacacsPlusGroupTable_next: get return false\n");

            return FALSE;
        }
    }

    return TRUE;
}

unsigned char*
var_aaaTacacsPlusGroupTable(struct variable *vp,
                            oid *name,
                            size_t *length,
                            int exact,
                            size_t *var_len, WriteMethod **write_method)
{
    UI32_T compc = 0;
    oid compl[aaaTacacsPlusGroupEntry_INSTANCE_LEN];
    oid best_inst[aaaTacacsPlusGroupEntry_INSTANCE_LEN];
    AAA_TacacsPlusGroupEntryMIBInterface_T data;
    memset(&data, 0, sizeof(data));

    switch (vp->magic)
    {
        case AAATACACSPLUSGROUPSERVERBITMAP:
            *write_method = write_aaaTacacsPlusGroupServerBitMap;
            break;

        case AAATACACSPLUSGROUPNAME:
            *write_method = write_aaaTacacsPlusGroupName;
            break;

        case AAATACACSPLUSGROUPSTATUS:
            *write_method = write_aaaTacacsPlusGroupStatus;
            break;

        default:
            *write_method = 0;
            ERROR_MSG("");
            break;
    }

    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl, aaaTacacsPlusGroupEntry_INSTANCE_LEN);
    if (exact)
    {
        if (!aaaTacacsPlusGroupTable_get(compc, compl, &data))
            return NULL;
    }
    else
    {
        if (!aaaTacacsPlusGroupTable_next(compc, compl, &data))
            return NULL;
    }

    memcpy(name, vp->name, vp->namelen * sizeof(oid));
    best_inst[0] = data.group_index;

    memcpy(name + vp->namelen, best_inst, aaaTacacsPlusGroupEntry_INSTANCE_LEN * sizeof(oid));

    *length = vp->namelen + aaaTacacsPlusGroupEntry_INSTANCE_LEN;
    *var_len = sizeof(long_return);

    switch (vp->magic)
    {
        case AAATACACSPLUSGROUPSERVERBITMAP:
            memcpy(return_buf, &(data.tacacsplus_server_list), SIZE_aaaTacacsPlusGroupServerBitMap * sizeof(UI8_T));
            *var_len = SIZE_aaaTacacsPlusGroupServerBitMap * sizeof(UI8_T);
            return (u_char*) return_buf;

        case AAATACACSPLUSGROUPNAME:
            memcpy(return_buf, data.group_name, strlen((char*)data.group_name));
            *var_len = strlen((char*)data.group_name);
            return (u_char*) return_buf;

        case AAATACACSPLUSGROUPSTATUS:
            long_return = VAL_aaaTacacsPlusGroupStatus_valid;
            return (u_char*) &long_return;

        default:
            ERROR_MSG("");
    }

    return NULL;
}


int
write_aaaTacacsPlusGroupServerBitMap(int action,
                                     u_char *var_val,
                                     u_char var_val_type,
                                     size_t var_val_len,
                                     u_char *statP,
                                     oid *name, size_t name_len)
{
    UI32_T oid_name_length;

    oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_OCTET_STR)
                return SNMP_ERR_WRONGTYPE;

            if (var_val_len > sizeof(char))
                return SNMP_ERR_WRONGLENGTH;

            break;

        case RESERVE2:
        case FREE:
            break;

        case ACTION:
        {
            UI16_T nIndex;
            UI8_T nBitMap;

            nBitMap = (UI8_T ) *var_val;
            nIndex  = (UI16_T)name[oid_name_length];
            if (AAA_PMGR_SetTacacsPlusGroupServerBitMap(nIndex, nBitMap) != TRUE)
                return SNMP_ERR_COMMITFAILED;

            break;
        }

        case UNDO:
        case COMMIT:
            break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_aaaTacacsPlusGroupName(int action,
                             u_char *var_val,
                             u_char var_val_type,
                             size_t var_val_len,
                             u_char *statP, oid *name, size_t name_len)
{
    UI32_T oid_name_length;

    oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_OCTET_STR)
                return SNMP_ERR_WRONGTYPE;

            if (var_val_len > MAXSIZE_aaaTacacsPlusGroupName)
                return SNMP_ERR_WRONGLENGTH;

            break;

        case RESERVE2:
        case FREE:
            break;

        case ACTION:
        {
            UI16_T nIndex;
            char buffer[MAXSIZE_aaaTacacsPlusGroupName + 1];

            memset(buffer, 0, sizeof(buffer));
            strncpy((char*)buffer, (char*)var_val, var_val_len);
            nIndex = name[oid_name_length];
            if (AAA_PMGR_SetTacacsPlusGroupName(nIndex, buffer) == FALSE)
                return SNMP_ERR_COMMITFAILED;

            break;
        }

        case UNDO:
        case COMMIT:
            break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_aaaTacacsPlusGroupStatus(int action,
                               u_char *var_val,
                               u_char var_val_type,
                               size_t var_val_len,
                               u_char *statP, oid *name, size_t name_len)
{
    long value;
    UI32_T oid_name_length;

    oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
                return SNMP_ERR_WRONGTYPE;

            if (var_val_len > sizeof(long))
                return SNMP_ERR_WRONGLENGTH;

            break;

        case RESERVE2:
            value = *(long*) var_val;

            switch (value)
            {
                case VAL_aaaTacacsPlusGroupStatus_valid:
                case VAL_aaaTacacsPlusGroupStatus_invalid:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T nStatus;
            UI16_T nIndex;

            nStatus = *(long *)var_val;
            nIndex  = (UI16_T)name[oid_name_length];
            if (AAA_PMGR_SetTacacsPlusGroupStatus(nIndex, (UI8_T)nStatus) != TRUE)
                return SNMP_ERR_COMMITFAILED;

            break;
        }

        case UNDO:
        case COMMIT:
            break;
    }
    return SNMP_ERR_NOERROR;
}
#endif /* end of #if(SYS_CPNT_TACACS_PLUS_ACCOUNTING == TRUE )*/

#if (SYS_CPNT_RADIUS_ACCOUNTING == TRUE) /*maggie liu, 2009-03-09*/
/********************************************
 **********aaaAccountTable*******************
 ********************************************
 */
#define aaaAccountEntry_INSTANCE_LEN  1

static BOOL_T aaaAccountTable_get(int compc,
                                  oid* compl,
                                  AAA_AccDot1xEntry_T   *data)
{
    if (compc != aaaAccountEntry_INSTANCE_LEN)
    {
        return FALSE;
    }

    data->ifindex = compl[0];
    if (SNMP_MGR_IsDebugMode())
        SYSFUN_Debug_Printf("aaaAccountTable_get:ifindex=[%d]\n", data->ifindex);

    if (!AAA_POM_GetAccountTable(data->ifindex, data))
    {
        if (SNMP_MGR_IsDebugMode())
            SYSFUN_Debug_Printf("aaaAccountTable_get:AAA_MGR_GetAccountTable return false\n");

        return FALSE;
    }
    else
    {
        return TRUE;
    }        /*End of if */

}

static BOOL_T aaaAccountTable_next(int compc,
                                   oid* compl,
                                   AAA_AccDot1xEntry_T    *data)
{
    data->ifindex = compl[0];

    if (SNMP_MGR_IsDebugMode())
        SYSFUN_Debug_Printf("aaaAccountTable_next:data->ifindex=[%d]\n", data->ifindex);

    if (compc < aaaAccountEntry_INSTANCE_LEN)
    {
        if (!AAA_POM_GetAccountTable(data->ifindex, data))
        {
            if (!AAA_POM_GetNextAccountTable(data->ifindex, data))
            {
                if (SNMP_MGR_IsDebugMode())
                    SYSFUN_Debug_Printf("AAA_MGR_GetNextAccountTable: get & genext return false\n");

                return FALSE;
            }
        }
    }
    else
    {
        if (!AAA_POM_GetNextAccountTable(data->ifindex, data))
        {
            if (SNMP_MGR_IsDebugMode())
                SYSFUN_Debug_Printf("AAA_MGR_GetNextAccountTable: get return false\n");

            return FALSE;
        }
    }

    return TRUE;
}

/*
 * var_aaaAccountTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char*
var_aaaAccountTable(struct variable *vp,
                    oid *name,
                    size_t *length,
                    int exact,
                    size_t *var_len, WriteMethod **write_method)
{
    UI32_T compc = 0;
    oid compl[aaaAccountEntry_INSTANCE_LEN];
    oid best_inst[aaaAccountEntry_INSTANCE_LEN];
    AAA_AccDot1xEntry_T data;
    memset(&data, 0, sizeof(data));

    switch (vp->magic)
    {
        case AAAACCOUNTMETHODNAME:
            *write_method = write_aaaAccountMethodName;
            break;

        case AAAACCOUNTPROTOCOL:
            *write_method = 0;
            break;

        case AAAACCOUNTSTATUS:
            *write_method = write_aaaAccountStatus;
            break;

        default:
            *write_method = 0;
            ERROR_MSG("");
            break;
    }

    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl, aaaAccountEntry_INSTANCE_LEN);

    if (exact)
    {
        if (!aaaAccountTable_get(compc, compl, &data))
            return NULL;
    }
    else
    {
        if (!aaaAccountTable_next(compc, compl, &data))
            return NULL;
    }

    memcpy(name, vp->name, vp->namelen * sizeof(oid));
    best_inst[0] = data.ifindex;
    memcpy(name + vp->namelen, best_inst, aaaAccountEntry_INSTANCE_LEN * sizeof(oid));

    *length = vp->namelen + aaaAccountEntry_INSTANCE_LEN;
    *var_len = sizeof(long_return);

    switch (vp->magic)
    {
        case AAAACCOUNTMETHODNAME:
            strcpy((char*)return_buf, (char*)data.list_name);
            *var_len = strlen((char*)data.list_name) ;
            return (u_char*) return_buf;

        case AAAACCOUNTPROTOCOL:
            long_return = data.configure_mode;
            return (u_char*) &long_return;

        case AAAACCOUNTSTATUS:
            long_return = VAL_aaaAccountStatus_valid;
            return (u_char*) &long_return;

        default:
            ERROR_MSG("");
    }
    return NULL;
}


int
write_aaaAccountMethodName(int action,
                           u_char *var_val,
                           u_char var_val_type,
                           size_t var_val_len,
                           u_char *statP, oid *name, size_t name_len)
{
    UI32_T oid_name_length;

    oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_OCTET_STR)
                return SNMP_ERR_WRONGTYPE;

            if (var_val_len > MAXSIZE_aaaAccountMethodName)
                return SNMP_ERR_WRONGLENGTH;

            break;

        case RESERVE2:
        case FREE:
            break;

        case ACTION:
        {
            UI32_T nIndex;
            char buffer[MAXSIZE_aaaAccountMethodName + 1];

            memset(buffer, 0, sizeof(buffer));
            strncpy((char*)buffer, (char*)var_val, var_val_len);
            nIndex = name[oid_name_length];
            if (AAA_PMGR_SetAccountMethodName(nIndex, buffer) != TRUE)
                return SNMP_ERR_COMMITFAILED;

            break;
        }

        case UNDO:
        case COMMIT:
            break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_aaaAccountStatus(int action,
                       u_char *var_val,
                       u_char var_val_type,
                       size_t var_val_len,
                       u_char *statP, oid *name, size_t name_len)
{
    long value;
    UI32_T oid_name_length;

    oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
                return SNMP_ERR_WRONGTYPE;

            if (var_val_len > sizeof(long))
                return SNMP_ERR_WRONGLENGTH;

            break;

        case RESERVE2:
            value = *(long*) var_val;

            switch (value)
            {
                case VAL_aaaAccountStatus_valid:
                case VAL_aaaAccountStatus_invalid:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T nIndex;
            UI32_T nStatus;

            nStatus = *(long *)var_val;
            nIndex  = name[oid_name_length];
            if (AAA_PMGR_SetAccountStatus(nIndex, (UI8_T)nStatus) != TRUE)
                return SNMP_ERR_COMMITFAILED;

            break;
        }

        case UNDO:
        case COMMIT:
            break;
    }
    return SNMP_ERR_NOERROR;
}
#endif /* #if (SYS_CPNT_RADIUS_ACCOUNTING == TRUE) */

#if (SYS_CPNT_ACCOUNTING_COMMAND == TRUE)

/********************************************
 *********aaaCommandPrivilegesTable**********
 ********************************************
 */
#define aaaCommandPrivilegesEntry_INSTANCE_LEN  2


static BOOL_T aaaCommandPrivilegesTable_get(int      compc,
                                  oid     *compl,
                                  AAA_AccCommandEntry_T   *data)
{
    if (compc != aaaCommandPrivilegesEntry_INSTANCE_LEN)
    {
    return FALSE;
    }

    data->priv_lvl = compl[0];
    data->exec_type = compl[1];

    if(SNMP_MGR_IsDebugMode())
       SYSFUN_Debug_Printf("aaaAccCommandEntry_get:exec_type=[%d] priv_lvl=[%lu]\n", data->exec_type,data->priv_lvl);

    if (! AAA_POM_GetAccCommandEntryInterface(data))
    {
        if(SNMP_MGR_IsDebugMode())
           SYSFUN_Debug_Printf("aaaAccCommandEntry_get:AAA_MGR_GetAccCommandEntry return false\n");

        return FALSE;
    }
    else
    {
        return TRUE;
    }        /*End of if */
}

static BOOL_T aaaCommandPrivilegesTable_next(int      compc,
                                   oid     *compl,
                                   AAA_AccCommandEntry_T    *data)
{
    oid tmp_compl[aaaCommandPrivilegesEntry_INSTANCE_LEN];
    UI32_T index=0;

    memcpy(tmp_compl, compl, sizeof(tmp_compl));
    SNMP_MGR_checkCompl(0, 0, tmp_compl, 2147483647L);
    SNMP_MGR_ConvertRemainToZero(compc,aaaCommandPrivilegesEntry_INSTANCE_LEN, tmp_compl);


    /*
     *  PrivilegesTable index is exec_type.priv_lvl.
     *  The range of exec_type is 0~15. The range of priv_lvl is 1~2.
     *  when the user specific index is error index, fix it.
     *  ex, user specific index is 0.99 and it will be fixed as 0.2 to getnext.
     *  but if user specific index is 20.1, then it will be fixed
     *  because of  20 is greater the range of exec_type, then can't genext.
     */
    data->priv_lvl = compl[0];
    if ( compl[1] > VAL_aaaCommandPrivilegesInterfaceIndex_telnet )
        data->exec_type = VAL_aaaCommandPrivilegesInterfaceIndex_telnet;
    else
        data->exec_type = compl[1];

    /* if first get  */
    if((data->priv_lvl == 0) && (data->exec_type == 0))
        index = 0;
    else /* getnext, the corelayer index is  priv_lvl *2 + exec_type */
        index = (data->priv_lvl *2)+data->exec_type;

    if(SNMP_MGR_IsDebugMode())
       SYSFUN_Debug_Printf("aaaAccCommandEntry_next:exec_type=[%d] priv_lvl=[%lu]\n", data->exec_type,data->priv_lvl);

    if (compc < aaaCommandPrivilegesEntry_INSTANCE_LEN)
    {
        if (!AAA_POM_GetAccCommandEntryInterface(data))
        {
            if (!AAA_POM_GetNextAccCommandEntry(&index, data))
            {
               if(SNMP_MGR_IsDebugMode())
                  SYSFUN_Debug_Printf("AAA_MGR_GetNextAccCommandEntry: get & genext return false\n");
               return FALSE;
            }
        }
    }
    else
    {
        if (!AAA_POM_GetNextAccCommandEntry(&index, data))
        {
            if(SNMP_MGR_IsDebugMode())
               SYSFUN_Debug_Printf("AAA_MGR_GetNextAccCommandEntry: get return false\n");
            return FALSE;
        }
    }
    return TRUE;
}

/*
 *   var_aaaCommandPrivilegesTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
 unsigned char  *
var_aaaCommandPrivilegesTable(struct variable *vp,
                    oid * name,
                    size_t * length,
                    int exact,
                    size_t * var_len, WriteMethod ** write_method)
{
    UI32_T compc=0;
    oid compl[aaaCommandPrivilegesEntry_INSTANCE_LEN];
    oid best_inst[aaaCommandPrivilegesEntry_INSTANCE_LEN];
    AAA_AccCommandEntry_T data;

    switch (vp->magic)
    {
      case AAACOMMANDPRIVILEGESMETHODNAME:
           *write_method = write_aaaCommandPrivilegesMethodName;
           break;

      default:
           *write_method =0;
           ERROR_MSG("");
           break;
    }

    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl, aaaCommandPrivilegesEntry_INSTANCE_LEN);

    if (exact)
    {
        if (!aaaCommandPrivilegesTable_get(compc, compl, &data))
            return NULL;
    }
    else
    {
        if (!aaaCommandPrivilegesTable_next(compc, compl, &data))
            return NULL;
    }

    /* new index */
    memcpy(name, vp->name, vp->namelen * sizeof(oid));
    best_inst[0] = data.priv_lvl;
    best_inst[1] = data.exec_type;
    memcpy(name + vp->namelen, best_inst, aaaCommandPrivilegesEntry_INSTANCE_LEN * sizeof(oid));

    *length = vp->namelen + aaaCommandPrivilegesEntry_INSTANCE_LEN;
    *var_len = sizeof(long_return);

    switch (vp->magic)
    {
        case AAACOMMANDPRIVILEGESMETHODNAME:
             strcpy((char *) return_buf, data.list_name);
             *var_len = strlen(data.list_name) ;
             return (u_char *) return_buf;

        default:
             ERROR_MSG("");
    }
    return NULL;
}

int
write_aaaCommandPrivilegesMethodName(int action,
                           u_char * var_val,
                           u_char var_val_type,
                           size_t var_val_len,
                           u_char * statP, oid * name, size_t name_len)
{
    int     size;
    UI32_T  oid_name_length;

    oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    switch (action)
    {
        case RESERVE1:
             if (var_val_type != ASN_OCTET_STR)
                 return SNMP_ERR_WRONGTYPE;

             if (var_val_len > MAXSIZE_aaaCommandPrivilegesMethodName)
                 return SNMP_ERR_WRONGLENGTH;
             break;

        case RESERVE2:
        case FREE:
             break;

        case ACTION:
        {
             AAA_AccCommandEntry_T entry;

             memset(&entry, 0, sizeof(AAA_AccCommandEntry_T));

             size  = var_val_len;
             strncpy( entry.list_name, (char *) var_val, size);
             entry.priv_lvl = (UI32_T) name[oid_name_length];
             entry.exec_type = (UI32_T) name[oid_name_length+1];

             if(entry.list_name[0] != '\0')
             {
                 if(AAA_PMGR_SetAccCommandEntry(&entry)!=TRUE)
                         return SNMP_ERR_COMMITFAILED;
             }
             else
             {
                 if(AAA_PMGR_DisableAccCommandEntry(&entry)!= TRUE)
                         return SNMP_ERR_COMMITFAILED;
             }
             break;
        }
        case UNDO:
        case COMMIT:
             break;
    }
    return SNMP_ERR_NOERROR;

}
#endif /* end of #if (SYS_CPNT_ACCOUNTING_COMMAND == TRUE) */

/********************************************
 ************aaaAccExecTable******************
 ********************************************
 */
#define aaaAccExecEntry_INSTANCE_LEN  1

static BOOL_T aaaAccExecTable_get(int compc,
                                  oid* compl,
                                  AAA_AccExecEntry_T   *data)
{
    if (compc != aaaAccExecEntry_INSTANCE_LEN)
    {
        return FALSE;
    }

    data->exec_type = compl[0];
    if (SNMP_MGR_IsDebugMode())
        SYSFUN_Debug_Printf("aaaAccExecEntry_get:exec_type=[%lu]\n", data->exec_type);

    if (!AAA_POM_GetAccExecEntry_Ex(data))
    {
        if (SNMP_MGR_IsDebugMode())
            SYSFUN_Debug_Printf("aaaAccExecEntry_get:AAA_POM_GetAccExecEntry_Ex return false\n");

        return FALSE;
    }
    else
    {
        return TRUE;
    }        /*End of if */

}

static BOOL_T aaaAccExecTable_next(int compc,
                                   oid* compl,
                                   AAA_AccExecEntry_T    *data)
{
    data->exec_type = compl[0];
    if (SNMP_MGR_IsDebugMode())
        SYSFUN_Debug_Printf("aaaAccExecEntry_next:exec_type=[%lu]\n", data->exec_type);

    if (compc < aaaAccExecEntry_INSTANCE_LEN)
    {
        if (!AAA_POM_GetAccExecEntry_Ex(data))
        {
            if (!AAA_POM_GetNextAccExecEntry(data))
            {
                if (SNMP_MGR_IsDebugMode())
                    SYSFUN_Debug_Printf("AAA_POM_GetNextAccExecEntry: get & genext return false\n");

                return FALSE;
            }
        }
    }
    else
    {
        if (!AAA_POM_GetNextAccExecEntry(data))
        {
            if (SNMP_MGR_IsDebugMode())
                SYSFUN_Debug_Printf("AAA_POM_GetNextAccExecEntry: get return false\n");

            return FALSE;
        }
    }

    return TRUE;
}

/*
 * var_aaaAccountTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char*
var_aaaAccExecTable(struct variable *vp,
                    oid *name,
                    size_t *length,
                    int exact,
                    size_t *var_len, WriteMethod **write_method)
{
    UI32_T compc = 0;
    oid compl[aaaAccExecEntry_INSTANCE_LEN];
    oid best_inst[aaaAccExecEntry_INSTANCE_LEN];
    AAA_AccExecEntry_T data;
    memset(&data, 0, sizeof(data));

    switch (vp->magic)
    {
        case AAAACCEXECMETHODNAME:
            *write_method = write_aaaAccExecMethodName;
            break;

        default:
            *write_method = 0;
            ERROR_MSG("");
            break;
    }

    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl, aaaAccExecEntry_INSTANCE_LEN);

    if (exact)
    {
        if (!aaaAccExecTable_get(compc, compl, &data))
            return NULL;
    }
    else
    {
        if (!aaaAccExecTable_next(compc, compl, &data))
            return NULL;
    }

    memcpy(name, vp->name, vp->namelen * sizeof(oid));
    best_inst[0] = data.exec_type;
    memcpy(name + vp->namelen, best_inst, aaaAccExecEntry_INSTANCE_LEN * sizeof(oid));

    *length = vp->namelen + aaaAccExecEntry_INSTANCE_LEN;
    *var_len = sizeof(long_return);

    switch (vp->magic)
    {
        case AAAACCEXECMETHODNAME:
            strcpy((char*)return_buf, (char*)data.list_name);
            *var_len = strlen((char*)data.list_name) ;
            return (u_char*) return_buf;

        default:
            ERROR_MSG("");
    }
    return NULL;
}

int
write_aaaAccExecMethodName(int action,
                           u_char *var_val,
                           u_char var_val_type,
                           size_t var_val_len,
                           u_char *statP, oid *name, size_t name_len)
{
    UI32_T oid_name_length;

    oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_OCTET_STR)
                return SNMP_ERR_WRONGTYPE;

            if (var_val_len > MAXSIZE_aaaAccExecMethodName)
                return SNMP_ERR_WRONGLENGTH;

            break;

        case RESERVE2:
        case FREE:
            break;

        case ACTION:
        {
            AAA_AccExecEntry_T entry;
            memset(&entry, 0, sizeof(AAA_AccExecEntry_T));

            strncpy( (char*)entry.list_name, (char*)var_val, var_val_len);
            entry.exec_type = (UI32_T) name[oid_name_length];
            if (strcmp((char*)entry.list_name, "") != 0)
            {
                if (AAA_PMGR_SetAccExecEntry(&entry) != TRUE)
                    return SNMP_ERR_COMMITFAILED;
            }
            else
            {
                if (AAA_PMGR_DisableAccExecEntry(entry.exec_type) != TRUE)
                    return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
        case COMMIT:
            break;
    }
    return SNMP_ERR_NOERROR;
}
#endif /* end of #if (SYS_CPNT_ACCOUNTING == TRUE) */
#endif /* end of #if (SYS_CPNT_AAA == TRUE) */

#if (SYS_CPNT_NETACCESS == TRUE)

/********************************************
 *******networkAccessPortTable********
 ********************************************
 */
#define networkaccessPortEntry_INSTANCE_LEN  1

static BOOL_T networkAccessPortTable_get(int      compc,
                                         oid     *compl,
                                         NETACCESS_MGR_SecurePortEntry_T    *data)
{
    UI32_T nIndex, used_buffer;

    if (compc !=networkaccessPortEntry_INSTANCE_LEN)
    {
        return FALSE;
    }

    nIndex = compl[0];

    if(SNMP_MGR_IsDebugMode())
       SYSFUN_Debug_Printf("networkAccessPortTable_get:lport = [%d]\n", nIndex);

    if (NETACCESS_PMGR_GetSecurePortEntry(SYS_TYPE_FID_ALL, &nIndex, data,sizeof(NETACCESS_MGR_SecurePortEntry_T), &used_buffer) != 0)
    {
        if(SNMP_MGR_IsDebugMode())
           SYSFUN_Debug_Printf("networkAccessPortTable_get:NETACCESS_MGR_GetSecurePortEntry return false\n");

        return FALSE;
    }
    else
    {
       /*work around ,just for snmpwalk pass. secure database is not correct. renxiong will fix*/
        data->lport = nIndex ;
        return TRUE;
    }        /*End of if */
}

static BOOL_T networkAccessPortTable_next(int      compc,
                                          oid     *compl,
                                          NETACCESS_MGR_SecurePortEntry_T    *data)
{
    UI32_T nIndex, used_buffer;
    oid tmp_compl[networkaccessPortEntry_INSTANCE_LEN];

    memcpy(tmp_compl, compl, sizeof(tmp_compl));
    SNMP_MGR_checkCompl(0, 0, tmp_compl, 65535);
    SNMP_MGR_ConvertRemainToZero(compc,networkaccessPortEntry_INSTANCE_LEN, tmp_compl);
    nIndex = tmp_compl[0];

    if(SNMP_MGR_IsDebugMode())
       SYSFUN_Debug_Printf("networkAccessPortTable_next:lport = [%d]\n", nIndex);

    if (compc < networkaccessPortEntry_INSTANCE_LEN)
    {
        if (NETACCESS_PMGR_GetSecurePortEntry(SYS_TYPE_FID_ALL, &nIndex, data,sizeof(NETACCESS_MGR_SecurePortEntry_T), &used_buffer) != 0)
        {
            if (NETACCESS_PMGR_GetNextSecurePortEntry(SYS_TYPE_FID_ALL, &nIndex, data, sizeof(NETACCESS_MGR_SecurePortEntry_T), &used_buffer) != 0)
            {
               if(SNMP_MGR_IsDebugMode())
                  SYSFUN_Debug_Printf("networkAccessPortTable_next: get & genext return false\n");
               return FALSE;
            }
        }
    }
    else
    {
       if (NETACCESS_PMGR_GetNextSecurePortEntry(SYS_TYPE_FID_ALL, &nIndex, data, sizeof(NETACCESS_MGR_SecurePortEntry_T), &used_buffer) != 0)
        {
            if(SNMP_MGR_IsDebugMode())
               SYSFUN_Debug_Printf("networkAccessPortTable_next: get return false\n");
            return FALSE;
        }
       /*work around ,just for snmpwalk pass. secure database is not correct. renxiong will fix*/
        data->lport = nIndex ;
    }
    return TRUE;
}


unsigned char  *
var_networkAccessPortTable(struct variable *vp,
                           oid * name,
                           size_t * length,
                           int exact,
                           size_t * var_len, WriteMethod ** write_method)
{
    UI32_T compc=0;
    oid compl[networkaccessPortEntry_INSTANCE_LEN];
    oid best_inst[networkaccessPortEntry_INSTANCE_LEN];
    NETACCESS_MGR_SecurePortEntry_T data;

    switch (vp->magic)
    {
#if (SYS_CPNT_NETACCESS_DYNAMIC_VLAN == TRUE)
        case NETWORKACCESSPORTDYNAMICVLAN:
            *write_method = write_networkAccessPortDynamicVlan;
            break;
#endif /* #if (SYS_CPNT_NETACCESS_DYNAMIC_VLAN == TRUE) */

#if (SYS_CPNT_NETACCESS_MACAUTH == TRUE)
        case NETWORKACCESSPORTMAXMACCOUNT:
            *write_method = write_networkAccessPortMaxMacCount;
            break;

        case NETWORKACCESSPORTMODE:
            *write_method = write_networkAccessPortMode;
            break;
#endif /* #if (SYS_CPNT_NETACCESS_MACAUTH == TRUE) */

#if (SYS_CPNT_NETACCESS_MAC_FILTER_TABLE == TRUE)
        case NETWORKACCESSPORTMACFILTER:
            *write_method = write_networkAccessPortMacFilter;
            break;
#endif /* #if (SYS_CPNT_NETACCESS_MAC_FILTER_TABLE == TRUE) */

#if (SYS_CPNT_NETACCESS_GUEST_VLAN == TRUE)
        case NETWORKACCESSPORTGUESTVLAN:
            *write_method = write_networkAccessPortGuestVlan;
            break;
#endif /* #if (SYS_CPNT_NETACCESS_GUEST_VLAN == TRUE) */

#if(SYS_CPNT_NETACCESS_LINK_DETECTION == TRUE)
        case LEAF_networkAccessPortLinkDetectionStatus:
            *write_method = write_networkAccessPortLinkDetectionStatus;
            break;

        case LEAF_networkAccessPortLinkDetectionMode:
            *write_method = write_networkAccessPortLinkDetectionMode;
            break;

        case LEAF_networkAccessPortLinkDetectionAciton:
            *write_method = write_networkAccessPortLinkDetectionAciton;
            break;
#endif /* #if(SYS_CPNT_NETACCESS_LINK_DETECTION == TRUE) */

#if(SYS_CPNT_NETACCESS_DYNAMIC_QOS == TRUE)
        case LEAF_networkAccessPortLinkDynamicQos:
            *write_method = write_networkAccessPortLinkDynamicQos;
            break;
#endif /* #if(SYS_CPNT_NETACCESS_DYNAMIC_QOS == TRUE) */

        default:
            *write_method =0;
            ERROR_MSG("");
            break;
    }

    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl, networkaccessPortEntry_INSTANCE_LEN);

    if (exact)
    {
        if (!networkAccessPortTable_get(compc, compl, &data))
            return NULL;
    }
    else
    {
        if (!networkAccessPortTable_next(compc, compl, &data))
            return NULL;
    }

    memcpy(name, vp->name, vp->namelen * sizeof(oid));
    best_inst[0]=data.lport;

    memcpy(name + vp->namelen, best_inst, networkaccessPortEntry_INSTANCE_LEN * sizeof(oid));

    *length = vp->namelen + networkaccessPortEntry_INSTANCE_LEN;
    *var_len = sizeof(long_return);

    switch (vp->magic)
    {
#if (SYS_CPNT_NETACCESS_DYNAMIC_VLAN == TRUE)
        case NETWORKACCESSPORTDYNAMICVLAN:
            long_return = data.dynamic_vlan_status;
            return (u_char *) &long_return;
#endif /* #if (SYS_CPNT_NETACCESS_DYNAMIC_VLAN == TRUE) */

#if (SYS_CPNT_NETACCESS_MACAUTH == TRUE)
        case NETWORKACCESSPORTMAXMACCOUNT:
            long_return = data.number_addresses;
            return (u_char *) &long_return;

        case NETWORKACCESSPORTMODE:
            {
                UI32_T mac_auth_status;
                if (NETACCESS_PMGR_GetMacAuthPortStatus(data.lport, &mac_auth_status) == FALSE)
                {
                    return NULL;
                }

                long_return = mac_auth_status;
                return (u_char *) &long_return;
            }
#endif /* #if (SYS_CPNT_NETACCESS_MACAUTH == TRUE) */

#if (SYS_CPNT_NETACCESS_MAC_FILTER_TABLE == TRUE)
        case NETWORKACCESSPORTMACFILTER:
            long_return = data.filter_id;
            return (u_char *) &long_return;
#endif /* #if (SYS_CPNT_NETACCESS_MAC_FILTER_TABLE == TRUE) */

#if (SYS_CPNT_NETACCESS_GUEST_VLAN == TRUE)
        case NETWORKACCESSPORTGUESTVLAN:
            long_return = data.guest_vlan_id;
            return (u_char *) &long_return;
#endif /* #if (SYS_CPNT_NETACCESS_GUEST_VLAN == TRUE) */

#if (SYS_CPNT_NETACCESS_LINK_DETECTION == TRUE)
        case LEAF_networkAccessPortLinkDetectionStatus:
            long_return = data.link_detection_status;
            return (u_char *) &long_return;

        case LEAF_networkAccessPortLinkDetectionMode:
            long_return = data.link_detection_mode;
            return (u_char *) &long_return;

        case LEAF_networkAccessPortLinkDetectionAciton:
            long_return = data.link_detection_action;
            return (u_char *) &long_return;
#endif /* #if (SYS_CPNT_NETACCESS_LINK_DETECTION == TRUE) */

#if (SYS_CPNT_NETACCESS_DYNAMIC_QOS == TRUE)
        case LEAF_networkAccessPortLinkDynamicQos:
            long_return = data.dynamic_qos_status;
            return (u_char *) &long_return;
#endif /* #if (SYS_CPNT_NETACCESS_DYNAMIC_QOS == TRUE) */

        default:
            ERROR_MSG("");
    }

    return NULL;

}

#if (SYS_CPNT_NETACCESS_DYNAMIC_VLAN == TRUE)
int
write_networkAccessPortDynamicVlan(int action,
                                   u_char * var_val,
                                   u_char var_val_type,
                                   size_t var_val_len,
                                   u_char * statP, oid * name, size_t name_len)
{
    UI32_T  oid_name_length;

    oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
                return SNMP_ERR_WRONGTYPE;

            if (var_val_len > sizeof(long))
                return SNMP_ERR_WRONGLENGTH;

            break;

        case RESERVE2:
        {
            UI32_T value;
            value = *(long *) var_val;
            switch (value)
            {
                case VAL_networkAccessPortDynamicVlan_enabled:
                case VAL_networkAccessPortDynamicVlan_disabled:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
        }
        case FREE:
            break;

        case ACTION:
        {
            UI32_T nIndex;
            UI32_T value;
            nIndex  = (UI32_T) name[oid_name_length];
            value = *(long *) var_val;

            if (NETACCESS_PMGR_SetSecureDynamicVlanStatus(nIndex, value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
            break;
        }
        case UNDO:
        case COMMIT:
            break;
    }
    return SNMP_ERR_NOERROR;
}
#endif /* #if (SYS_CPNT_NETACCESS_DYNAMIC_VLAN == TRUE) */

#if (SYS_CPNT_NETACCESS_MACAUTH == TRUE)
int
write_networkAccessPortMaxMacCount(int action,
                                   u_char * var_val,
                                   u_char var_val_type,
                                   size_t var_val_len,
                                   u_char * statP, oid * name, size_t name_len)
{
    UI32_T  value, oid_name_length;

    oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    switch (action)
    {
         case RESERVE1:
             if (var_val_type != ASN_INTEGER)
                 return SNMP_ERR_WRONGTYPE;

             if (var_val_len > sizeof(long))
                 return SNMP_ERR_WRONGLENGTH;

             break;

         case RESERVE2:
         {
             value = *(long *) var_val;
             if((value < MIN_networkAccessPortMaxMacCount)||(value > MAX_networkAccessPortMaxMacCount))
             {
                 return SNMP_ERR_WRONGVALUE;
             }
         }
         case FREE:
             break;

         case ACTION:
         {
             UI32_T nIndex;
             nIndex  = (UI32_T)name[oid_name_length];
             value = *(long *) var_val;

             if (NETACCESS_PMGR_SetSecureNumberAddresses(nIndex, value) != TRUE)
                 return SNMP_ERR_COMMITFAILED;
             break;
         }
         case UNDO:
         case COMMIT:
             break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_networkAccessPortMode(int action,
                            u_char * var_val,
                            u_char var_val_type,
                            size_t var_val_len,
                            u_char * statP, oid * name, size_t name_len)
{
    UI32_T  value, oid_name_length;

    oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    switch (action)
    {
         case RESERVE1:
             if (var_val_type != ASN_INTEGER)
                 return SNMP_ERR_WRONGTYPE;

             if (var_val_len > sizeof(long))
                 return SNMP_ERR_WRONGLENGTH;

             break;

         case RESERVE2:
             {
                 UI32_T value;
                 value = *(long *) var_val;
                 switch (value)
                 {
                      case VAL_networkAccessPortMode_enabled:
                      case VAL_networkAccessPortMode_disabled:
                         break;

                     default:
                        return SNMP_ERR_WRONGVALUE;
                 }
             }
         case FREE:
             break;

         case ACTION:
         {
             UI32_T nIndex;
             nIndex  = (UI32_T)name[oid_name_length];
             value = *(long *) var_val;

             if (NETACCESS_PMGR_SetMacAuthPortStatus(nIndex, value) != TRUE)
                 return SNMP_ERR_COMMITFAILED;
             break;
         }
         case UNDO:
         case COMMIT:
             break;
    }
    return SNMP_ERR_NOERROR;
}
#endif  /* #if (SYS_CPNT_NETACCESS_MACAUTH == TRUE) */

#if (SYS_CPNT_NETACCESS_MAC_FILTER_TABLE == TRUE)
int
write_networkAccessPortMacFilter(int action,
                                 u_char * var_val,
                                 u_char var_val_type,
                                 size_t var_val_len,
                                 u_char * statP, oid * name, size_t name_len)
{
    UI32_T  value, oid_name_length;

    oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    switch (action)
    {
         case RESERVE1:
             if (var_val_type != ASN_INTEGER)
                 return SNMP_ERR_WRONGTYPE;

             if (var_val_len > sizeof(long))
                 return SNMP_ERR_WRONGLENGTH;

             break;

         case RESERVE2:
             {
                 value = *(long *) var_val;
                 if((value < 0)||(value > MAX_networkAccessPortPortMacFilter))
                 {
                     return SNMP_ERR_WRONGVALUE;
                 }
             }
         case FREE:
             break;

         case ACTION:
         {
             UI32_T nIndex;
             nIndex  = (UI32_T)name[oid_name_length];
             value = *(long *) var_val;

            if(value==0)
            {
                 if (NETACCESS_PMGR_SetFilterIdToPort(nIndex, value) != TRUE) /* temp solution for compiling */
                     return SNMP_ERR_COMMITFAILED;
            }
            else
            {
                if (NETACCESS_PMGR_SetFilterIdToPort(nIndex, value) != TRUE) /* temp solution for compiling */
                    return SNMP_ERR_COMMITFAILED;
            }
             break;
         }
         case UNDO:
         case COMMIT:
             break;
    }
    return SNMP_ERR_NOERROR;
}
#endif  /* #if (SYS_CPNT_NETACCESS_MAC_FILTER_TABLE == TRUE) */

#if (SYS_CPNT_NETACCESS_GUEST_VLAN == TRUE)
int
write_networkAccessPortGuestVlan(int action,
                                   u_char * var_val,
                                   u_char var_val_type,
                                   size_t var_val_len,
                                   u_char * statP, oid * name, size_t name_len)
{
    UI32_T  value, oid_name_length;

    oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    switch (action)
    {
         case RESERVE1:
             if (var_val_type != ASN_INTEGER)
                 return SNMP_ERR_WRONGTYPE;

             if (var_val_len > sizeof(long))
                 return SNMP_ERR_WRONGLENGTH;

             break;

         case RESERVE2:
         {
             value = *(long *) var_val;
             if((value < MIN_networkAccessPortGuestVlan)||(value > MAX_networkAccessPortGuestVlan))
             {
                 return SNMP_ERR_WRONGVALUE;
             }
         }
         case FREE:
             break;

         case ACTION:
         {
             UI32_T nIndex;
             nIndex  = (UI32_T)name[oid_name_length];
             value = *(long *) var_val;

             if (NETACCESS_PMGR_SetSecureGuestVlanId(nIndex, value) != TRUE)
                 return SNMP_ERR_COMMITFAILED;
             break;
         }
         case UNDO:
         case COMMIT:
             break;
    }
    return SNMP_ERR_NOERROR;
}
#endif /* #if (SYS_CPNT_NETACCESS_GUEST_VLAN == TRUE) */

#if (SYS_CPNT_NETACCESS_LINK_DETECTION == TRUE)
int
write_networkAccessPortLinkDetectionStatus(int      action,
                                     u_char   *var_val,
                                     u_char   var_val_type,
                                     size_t   var_val_len,
                                     u_char   *statP,
                                     oid      *name,
                                     size_t   name_len)
{
    UI32_T  value, oid_name_length;

    oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            switch (*(long *)var_val)
            {
                case VAL_networkAccessPortLinkDetectionStatus_enabled:
                    break;

                case VAL_networkAccessPortLinkDetectionStatus_disabled:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
             UI32_T nIndex;
             nIndex  = (UI32_T)name[oid_name_length];
             value = *(long *) var_val;

            if (NETACCESS_PMGR_SetLinkDetectionStatus( nIndex, value ) != TRUE)
                return SNMP_ERR_COMMITFAILED;
        }
            break;

        case UNDO:
          break;

        case COMMIT:
          break;
    }

    return SNMP_ERR_NOERROR;
}

int
write_networkAccessPortLinkDetectionMode(int      action,
                                     u_char   *var_val,
                                     u_char   var_val_type,
                                     size_t   var_val_len,
                                     u_char   *statP,
                                     oid      *name,
                                     size_t   name_len)
{
    UI32_T  value, oid_name_length;

    oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            switch (*(long *)var_val)
            {

                case VAL_networkAccessPortLinkDetectionMode_linkUp:
                    break;

                case VAL_networkAccessPortLinkDetectionMode_linkDown:
                    break;

                case VAL_networkAccessPortLinkDetectionMode_linkUpDown:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
             UI32_T nIndex;
             nIndex  = (UI32_T)name[oid_name_length];
             value = *(long *) var_val;

            if (NETACCESS_PMGR_SetLinkDetectionMode( nIndex, value ) != TRUE)
                return SNMP_ERR_COMMITFAILED;
        }
            break;

        case UNDO:
          break;

        case COMMIT:
          break;
    }

    return SNMP_ERR_NOERROR;
}

int
write_networkAccessPortLinkDetectionAciton(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    UI32_T  value, oid_name_length;

    oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            switch (*(long *)var_val)
            {
                case VAL_networkAccessPortLinkDetectionAciton_trap:
                    break;

                case VAL_networkAccessPortLinkDetectionAciton_shutdown:
                    break;

                case VAL_networkAccessPortLinkDetectionAciton_trapAndShutdown:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
             UI32_T nIndex;
             nIndex  = (UI32_T)name[oid_name_length];
             value = *(long *) var_val;

            if (NETACCESS_PMGR_SetLinkDetectionAction( nIndex, value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
        }
            break;

        case UNDO:
          break;

        case COMMIT:
          break;
    }

    return SNMP_ERR_NOERROR;
}
#endif /* #if (SYS_CPNT_NETACCESS_LINK_DETECTION == TRUE) */

#if (SYS_CPNT_NETACCESS_DYNAMIC_QOS == TRUE)
int
write_networkAccessPortLinkDynamicQos(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            switch (*(long *)var_val)
            {
                case VAL_networkAccessPortLinkDynamicQos_enabled:
                    break;

                case VAL_networkAccessPortLinkDynamicQos_disabled:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
            UI32_T nIndex;
            UI32_T value;
            nIndex  = (UI32_T)name[oid_name_length];

            value = *(long *) var_val;

            if (NETACCESS_PMGR_SetDynamicQosStatus(nIndex, value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
        }
            break;

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}
#endif /* #if (SYS_CPNT_NETACCESS_DYNAMIC_QOS == TRUE) */

#if (SYS_CPNT_DOT1X == TRUE) || (SYS_CPNT_NETACCESS_MACAUTH == TRUE)

/********************************************
 *******networkAccessClearMacAddressMgt********
 ********************************************
 */

static UI32_T networkAccessClearMacAddressAttribute = VAL_networkaccessClearMacAddressAttribute_all;
static UI8_T networkAccessClearMacAddressMacAddress[SIZE_networkaccessClearMacAddressMacAddress] = { 0 };
static UI32_T networkAccessClearMacAddressPort=0;
static UI32_T networkAccessClearMacAddressClearAction = VAL_networkaccessClearMacAddressClearAction_noAction;

int
do_networkAccessClearMacAddressAttribute(netsnmp_mib_handler *handler,
                                         netsnmp_handler_registration *reginfo,
                                         netsnmp_agent_request_info *reqinfo,
                                         netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.
     */

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one.
     */

    switch(reqinfo->mode)
    {

        case MODE_GET:
            {
                long_return = networkAccessClearMacAddressAttribute;
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
            }
            break;
        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
            }
            break;

        case MODE_SET_RESERVE2:
            switch (*requests->requestvb->val.integer)
            {
                case VAL_networkaccessClearMacAddressAttribute_all:
                    break;

                case VAL_networkaccessClearMacAddressAttribute_static:
                    break;

                case VAL_networkaccessClearMacAddressAttribute_dynamic:
                    break;

                default:
                    netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called.
             */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here
             */
            {
                UI32_T value;
                value = (*requests->requestvb->val.integer);
                networkAccessClearMacAddressAttribute = value;
            }
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage
             */

            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object
             */

            break;

        default:
            /* we should never get here, so this is a really bad error
             */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_networkAccessClearMacAddressMacAddress(netsnmp_mib_handler *handler,
                                          netsnmp_handler_registration *reginfo,
                                          netsnmp_agent_request_info *reqinfo,
                                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.
     */

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one.
     */

    switch(reqinfo->mode)
    {

        case MODE_GET:
            {
                memcpy(return_buf,  networkAccessClearMacAddressMacAddress, 6);

                snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, (u_char *) return_buf, 6);
            }
            break;
        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            if (requests->requestvb->type != ASN_OCTET_STR)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
                break;
            }

            if (requests->requestvb->val_len != SIZE_networkaccessClearMacAddressMacAddress)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGLENGTH);
                break;
            }
            break;

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called.
             */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here
         */
            memcpy(networkAccessClearMacAddressMacAddress, requests->requestvb->val.string,
                           requests->requestvb->val_len);

            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage
         */

            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object
             */

            break;

        default:
            /* we should never get here, so this is a really bad error
             */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_networkAccessClearMacAddressPort(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.
     */

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one.
     */

    switch(reqinfo->mode)
    {

        case MODE_GET:
            {
                long_return = networkAccessClearMacAddressPort;
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
            }
            break;
        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
            }

            if (requests->requestvb->val_len > SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST * sizeof(char))
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGLENGTH);
            }
            break;

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called.
             */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here
         */
            {
                UI32_T value;
                value = (*requests->requestvb->val.integer);
                networkAccessClearMacAddressPort = value;
            }
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage
         */

            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object
         */

            break;

        default:
            /* we should never get here, so this is a really bad error
         */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_networkAccessClearMacAddressClearAction(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.
     */

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one.
     */

    switch(reqinfo->mode)
    {

        case MODE_GET:
            {
                long_return = networkAccessClearMacAddressClearAction;
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
            }
            break;
        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
            }
            break;

        case MODE_SET_RESERVE2:
            switch (*requests->requestvb->val.integer)
            {
                case VAL_networkaccessClearMacAddressClearAction_noAction:
                    break;

                case VAL_networkaccessClearMacAddressClearAction_action:
                    break;

                default:
                    netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
             *  RESERVE2.  Something failed somewhere, and the states
             *  below won't be called.
             */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here
             */
            {
                NETACCESS_MGR_SecureAddressFilter_T date;

                memset(&date,0,sizeof(NETACCESS_MGR_SecureAddressFilter_T));

                switch(networkAccessClearMacAddressAttribute)
                {
                    case VAL_networkaccessClearMacAddressAttribute_all:
                         date.type=NETACCESS_ADDRESS_ENTRY_TYPE_ALL;
                         break;
                    case VAL_networkaccessClearMacAddressAttribute_static:
                         date.type= NETACCESS_ADDRESS_ENTRY_TYPE_STATIC;
                         break;
                    case VAL_networkaccessClearMacAddressAttribute_dynamic:
                         date.type= NETACCESS_ADDRESS_ENTRY_TYPE_DYNAMIC;
                         break;
                }

                if(networkAccessClearMacAddressPort > 0)
                    date.sort=NETACCESS_ADDRESS_ENTRY_SORT_INTERFACE;
                else
                    date.sort=NETACCESS_ADDRESS_ENTRY_SORT_ADDRESS;

                date.lport = networkAccessClearMacAddressPort;
                date.type = networkAccessClearMacAddressAttribute;
                memcpy(date.mac,  networkAccessClearMacAddressMacAddress, 6);

                networkAccessClearMacAddressPort = 0;
                networkAccessClearMacAddressAttribute = 1;
                memset(networkAccessClearMacAddressMacAddress, 0, 6);

                if(NETACCESS_PMGR_ClearSecureAddressEntryByFilter(&date) == FALSE)
                {
                    return SNMP_ERR_COMMITFAILED;
                }
            }
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage
             */

            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object
             */

            break;

        default:
            /* we should never get here, so this is a really bad error
             */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

/********************************************
 *********networkAccessMacAddressTable*********
 ********************************************
 */
#define networkAccessMacAddressEntry_INSTANCE_LEN    7
#if 0
static BOOL_T networkAccessMacAddressTable_get(int      compc,
                                               oid     *compl,
                                               NETACCESS_MGR_SecureAddressEntry_T    *entry)
{
    NETACCESS_MGR_SecureAddressEntryKey_T entry_key;
    UI32_T used_buffer;

    memset(&entry_key,0,sizeof(NETACCESS_MGR_SecureAddressEntryKey_T));

    if (compc != networkAccessMacAddressEntry_INSTANCE_LEN)
    {
    return FALSE;
    }

    SNMP_MGR_ReadStrFromCompl(compl, 0, 5, entry_key.mac_address);
    entry_key.lport =  ( UI32_T ) compl[6];

    if(SNMP_MGR_IsDebugMode())
    {
        int i;
        for (i=0; i<6; i++)
            printf("networkAccessMacAddressTable_next:data.mac_address[%d]=%d", i, entry_key.mac_address[i]);
        printf(" lport = [%lu]\n", entry_key.lport);
    }

    if (NETACCESS_PMGR_GetSecureAddressEntry(SYS_TYPE_FID_ALL, &entry_key, entry, sizeof(NETACCESS_MGR_SecureAddressEntry_T), &used_buffer) != 0)
    {
        if(SNMP_MGR_IsDebugMode())
           SYSFUN_Debug_Printf("networkAccessMacAddressTable_get:NETACCESS_MGR_GetSecureAddressEntry return false\n");

        return FALSE;
    }
    else
    {
        return TRUE;
    }        /*End of if */
}

static BOOL_T networkAccessMacAddressTable_next(int      compc,
                                                oid     *compl,
                                                NETACCESS_MGR_SecureAddressEntry_T    *entry)
{
    NETACCESS_MGR_SecureAddressEntryKey_T entry_key;
    UI32_T used_buffer;

    oid tmp_compl[networkAccessMacAddressEntry_INSTANCE_LEN];

    /* Generate the instance of each table entry and find the
     * smallest instance that's larger than compc/compl.
     *
     * Step 1: Verify and extract the input key from "compc" and "compl"
     * Note: The number of input key is defined by "compc".
     * The key for the specified instance is defined in compl.
     */
    memset(&entry_key,0,sizeof(NETACCESS_MGR_SecureAddressEntryKey_T));
    memcpy(tmp_compl, compl, sizeof(tmp_compl));
    SNMP_MGR_ConvertRemainToZero(compc,networkAccessMacAddressEntry_INSTANCE_LEN, tmp_compl);

    SNMP_MGR_ReadStrFromCompl(compl, 0, 5, entry_key.mac_address);
    entry_key.lport =  ( UI32_T ) compl[6];

    if(SNMP_MGR_IsDebugMode())
    {
        int i;
        for (i=0; i<6; i++)
            printf("networkAccessMacAddressTable_next:data.mac_address[%d]=%d", i, entry_key.mac_address[i]);
        printf("lport = [%lu]\n", entry_key.lport);
    }

    if (compc<networkAccessMacAddressEntry_INSTANCE_LEN)
    {
        if (NETACCESS_PMGR_GetSecureAddressEntry(SYS_TYPE_FID_ALL, &entry_key, entry, sizeof(NETACCESS_MGR_SecureAddressEntry_T), &used_buffer) != 0)
        {
            if (NETACCESS_PMGR_GetNextSecureAddressEntry(SYS_TYPE_FID_ALL, &entry_key, entry, sizeof(NETACCESS_MGR_SecureAddressEntry_T), &used_buffer) != 0)
            {
                if(SNMP_MGR_IsDebugMode())
                    printf("networkAccessMacAddressTable_next: get & genext return false\n");
                return FALSE;
            }
        }
    }
    else
    {
        if (NETACCESS_PMGR_GetNextSecureAddressEntry(SYS_TYPE_FID_ALL, &entry_key, entry, sizeof(NETACCESS_MGR_SecureAddressEntry_T), &used_buffer) != 0)
        {
            if(SNMP_MGR_IsDebugMode())
            printf("networkAccessMacAddressTable_next: getnext return false\n");
        return FALSE;
    }
    }
    return TRUE;
}
#endif

/*
 *   networkAccessMacAddressTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *
var_networkAccessMacAddressTable(struct variable *vp,
            oid     *name,
            size_t  *length,
            int     exact,
            size_t  *var_len,
            WriteMethod **write_method)
{
    NETACCESS_MGR_SecureAddressEntry_T entry;
    NETACCESS_MGR_SecureAddressEntryKey_T entry_key = {0};
    UI32_T used_buffer;

    if(l_snmp_mac_addr_int_index_get(vp,name,length,(struct L_SNMP_MAC_ADDR *)(entry_key.mac_address),(int *)&entry_key.lport,exact)<0)
        return NULL;

     /*check compc, retrive compl*/
    if (exact){

        if (NETACCESS_PMGR_GetSecureAddressEntry(SYS_TYPE_FID_ALL,
                                                 &entry_key,
                                                 &entry,
                                                 sizeof(entry),
                                                 &used_buffer) != 0)
        {
            if(SNMP_MGR_IsDebugMode())
               SYSFUN_Debug_Printf("networkAccessMacAddressTable_get:NETACCESS_MGR_GetSecureAddressEntry return false\n");

            return NULL;
        }
    }
    else/*getnext*/
    {
        if (NETACCESS_PMGR_GetNextSecureAddressEntry(SYS_TYPE_FID_ALL,
                                                     &entry_key,
                                                     &entry,
                                                     sizeof(entry),
                                                     &used_buffer) != 0)
        {
            return NULL;
        }

        l_snmp_mac_addr_int_index_set(vp,name,length,(struct L_SNMP_MAC_ADDR *)entry.addr_MAC,(int)entry.addr_lport);
    }

    *var_len = sizeof(long_return);

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch(vp->magic)
    {
        case NETWORKACCESSMACADDRESSRADIUSSERVERADDRESSTYPE:
            long_return  = 1;
            return (u_char*) &long_return;

        case NETWORKACCESSMACADDRESSRADIUSSERVERADDRESS:
            *var_len = sizeof(ipaddr_return);
            ipaddr_return  = entry.server_ip;
            return (u_char*) &ipaddr_return;

        case NETWORKACCESSMACADDRESSTIME:
        {
            int     year;
        int     month;     /* 01-12 */
            int     day;       /* 01-31 */
            int     hour;      /* 00-23 */
            int     minute;    /* 00-59 */
            int     second;    /* 00-59 */

            SYS_TIME_ConvertSecondsToDateTime(entry.record_time,&year,&month,&day,&hour,&minute,&second);
            sprintf((char *)return_buf, " %4dy %02dm %02dd %02dh %02dm %02ds",year,month,day,hour,minute,second);
            *var_len = strlen((char *)return_buf);
            return (u_char*) &return_buf;
        }
        case NETWORKACCESSMACADDRESSATTRIBUTE:
            if (entry.is_learnt == TRUE)
                long_return  = 2.;
        else
                long_return  = 1.;
            return (u_char*) &long_return;

        default:
            ERROR_MSG("");
    }
    return NULL;
}
#endif /* #if (SYS_CPNT_DOT1X == TRUE) || (SYS_CPNT_NETACCESS_MACAUTH == TRUE) */

#if(SYS_CPNT_NETACCESS_AGING_MODE == SYS_CPNT_NETACCESS_AGING_MODE_CONFIGURABLE)
int
do_networkAccessAging(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{

    switch(reqinfo->mode) {
        case MODE_GET:
        {
            UI32_T value = 0;

            if (NETACCESS_PMGR_GetMacAddressAgingMode(&value) == TRUE)
            {
                long_return = value;
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER , (u_char *)&long_return , sizeof(long_return) );
            }
            else
            {
                return SNMP_ERR_GENERR;
            }
        }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:

            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
            }

            break;
        case MODE_SET_RESERVE2:

            switch ( *requests->requestvb->val.integer )
            {
                case VAL_networkAccessAging_enabled:
                    break;
                case VAL_networkAccessAging_disabled:
                    break;
                default:
                    netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
        {
            if (NETACCESS_PMGR_SetMacAddressAgingMode(*requests->requestvb->val.integer) != TRUE )
            {
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
            }
        }
            break;

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
#endif


/********************************************
 ********************macAuthMgt***************
 ********************************************
 */

int
do_macAuthReAuthTime(netsnmp_mib_handler *handler,
                     netsnmp_handler_registration *reginfo,
                     netsnmp_agent_request_info *reqinfo,
                     netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.
     */

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one.
     */

    switch(reqinfo->mode)
    {

        case MODE_GET:
            {
                UI32_T  value;

                if (NETACCESS_PMGR_GetSecureReauthTime(&value)== FALSE)
                {
                    return SNMP_ERR_GENERR;
                }
                long_return = value;
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
            }
            break;
        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
            }
            break;

        case MODE_SET_RESERVE2:

            if (*requests->requestvb->val.integer < MIN_macAuthReAuthTime ||
                *requests->requestvb->val.integer > MAX_macAuthReAuthTime)
            {
               netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
             *  RESERVE2.  Something failed somewhere, and the states
             *  below won't be called.
             */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here
         */
            {
                UI32_T value;
                value = (*requests->requestvb->val.integer);
                if (NETACCESS_PMGR_SetSecureReauthTime(value) == FALSE)
                {
                    netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
                }
            }
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage
         */

            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object
         */

            break;

        default:
            /* we should never get here, so this is a really bad error
         */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

#if(SYS_CPNT_NETACCESS_MACAUTH==TRUE)
/********************************************
 ****************macAuthPortTable*************
 ********************************************
 */

#define macAuthPortEntry_INSTANCE_LEN  1

static BOOL_T macAuthPortTable_get(int      compc,
                                   oid     *compl,
                                   NETACCESS_MGR_MacAuthPortEntry_T    *data)
{
    UI32_T nIndex, used_buffer;

    if (compc != macAuthPortEntry_INSTANCE_LEN)
    {
    return FALSE;
    }

    nIndex = compl[0];

    if(SNMP_MGR_IsDebugMode())
       SYSFUN_Debug_Printf("macAuthPortTable_get:lport = [%d]\n", nIndex);

    if (NETACCESS_PMGR_GetMacAuthPortEntry(SYS_TYPE_FID_ALL, &nIndex, data, sizeof(NETACCESS_MGR_MacAuthPortEntry_T), &used_buffer) != TRUE)
    {
        if(SNMP_MGR_IsDebugMode())
           SYSFUN_Debug_Printf("macAuthPortTable_get:NETACCESS_MGR_GetMacAuthenticationPortEntry return false\n");

        return FALSE;
    }
    else
    {
        /*work around ,just for snmpwalk pass. secure database is not correct. renxiong will fix*/
        data->lport = nIndex ;
        return TRUE;
    }        /*End of if */
}


static BOOL_T macAuthPortTable_next(int      compc,
                                    oid     *compl,
                                    NETACCESS_MGR_MacAuthPortEntry_T    *data)
{
    UI32_T nIndex, used_buffer;
    oid tmp_compl[macAuthPortEntry_INSTANCE_LEN];

    memcpy(tmp_compl, compl, sizeof(tmp_compl));
    SNMP_MGR_checkCompl(0, 0, tmp_compl, 65535);
    SNMP_MGR_ConvertRemainToZero(compc, macAuthPortEntry_INSTANCE_LEN, tmp_compl);
    nIndex = tmp_compl[0];

    if(SNMP_MGR_IsDebugMode())
       SYSFUN_Debug_Printf("macAuthPortTable_next:lport = [%d]\n", nIndex);

    if (compc < macAuthPortEntry_INSTANCE_LEN)
    {
        if (NETACCESS_PMGR_GetMacAuthPortEntry(SYS_TYPE_FID_ALL, &nIndex, data, sizeof(NETACCESS_MGR_MacAuthPortEntry_T), &used_buffer) != TRUE)
        {
            if (NETACCESS_PMGR_GetNextMacAuthPortEntry(SYS_TYPE_FID_ALL, &nIndex, data, sizeof(NETACCESS_MGR_MacAuthPortEntry_T), &used_buffer) != TRUE)
            {
               if(SNMP_MGR_IsDebugMode())
                  SYSFUN_Debug_Printf("macAuthPortTable_next: get & genext return false\n");
               return FALSE;
            }
        }
    }
    else
    {
       if (NETACCESS_PMGR_GetNextMacAuthPortEntry(SYS_TYPE_FID_ALL, &nIndex, data, sizeof(NETACCESS_MGR_MacAuthPortEntry_T), &used_buffer) != TRUE)
        {
            if(SNMP_MGR_IsDebugMode())
               SYSFUN_Debug_Printf("macAuthPortTable_next: get return false\n");
            return FALSE;
        }
        /*work around ,just for snmpwalk pass. secure database is not correct. renxiong will fix*/
        data->lport = nIndex ;

    }
    return TRUE;
}

unsigned char  *
var_macAuthPortTable(struct variable *vp,
                     oid * name,
                     size_t * length,
                     int exact,
                     size_t * var_len, WriteMethod ** write_method)
{
    UI32_T compc=0;
    oid compl[macAuthPortEntry_INSTANCE_LEN];
    oid best_inst[macAuthPortEntry_INSTANCE_LEN];
    NETACCESS_MGR_MacAuthPortEntry_T data;

    switch (vp->magic)
    {
      case MACAUTHPORTMAXMACCOUNT:
           *write_method = write_macAuthPortMaxMacCount;
           break;

      case MACAUTHPORTINTRUSIONACTION:
           *write_method = write_macAuthPortIntrusionAction;
           break;

      default:
           *write_method =0;
           ERROR_MSG("");
           break;
    }

    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl, macAuthPortEntry_INSTANCE_LEN);

    if (exact)
    {
        if (!macAuthPortTable_get(compc, compl, &data))
            return NULL;
    }
    else
    {
        if (!macAuthPortTable_next(compc, compl, &data))
            return NULL;
    }

    memcpy(name, vp->name, vp->namelen * sizeof(oid));
    best_inst[0]=data.lport;

    memcpy(name + vp->namelen, best_inst, macAuthPortEntry_INSTANCE_LEN * sizeof(oid));

    *length = vp->namelen + macAuthPortEntry_INSTANCE_LEN;
    *var_len = sizeof(long_return);

    switch (vp->magic)
    {
        case MACAUTHPORTMAXMACCOUNT:
             long_return = data.configured_number_addresses;
             return (u_char *) &long_return;

        case MACAUTHPORTINTRUSIONACTION:
             long_return = data.intrusion_action;
             return (u_char *) &long_return;

        default:
             ERROR_MSG("");
    }
    return NULL;
}

int
write_macAuthPortMaxMacCount(int action,
                             u_char * var_val,
                             u_char var_val_type,
                             size_t var_val_len,
                             u_char * statP, oid * name, size_t name_len)
{
    long    value;
    int     size;
    UI32_T  oid_name_length;

    oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    switch (action)
    {
         case RESERVE1:
              if (var_val_type != ASN_INTEGER)
                  return SNMP_ERR_WRONGTYPE;

              if (var_val_len > sizeof(long))
                  return SNMP_ERR_WRONGLENGTH;

              break;

         case RESERVE2:
              size = var_val_len;
              value = *(long *) var_val;

              if((value < MIN_macAuthPortMaxMacCount)||(value > MAX_macAuthPortMaxMacCount))
              {
                  return SNMP_ERR_WRONGVALUE;
              }

         case FREE:
              break;

         case ACTION:
         {
              UI32_T nIndex;

              nIndex  = (UI32_T)name[oid_name_length];
              value = *(long *) var_val;

              if (NETACCESS_PMGR_SetMacAuthPortMaxMacCount(nIndex, value) != TRUE)
                  return SNMP_ERR_COMMITFAILED;
              break;
         }
         case UNDO:
         case COMMIT:
              break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_macAuthPortIntrusionAction(int action,
                                 u_char * var_val,
                                 u_char var_val_type,
                                 size_t var_val_len,
                                 u_char * statP, oid * name, size_t name_len)
{
    UI32_T  value, oid_name_length;

    oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    switch (action)
    {
         case RESERVE1:
              if (var_val_type != ASN_INTEGER)
                  return SNMP_ERR_WRONGTYPE;

              if (var_val_len > sizeof(long))
                  return SNMP_ERR_WRONGLENGTH;

              break;

         case RESERVE2:
         {
              UI32_T value;
              value = *(long *) var_val;
              switch (value)
              {
                  case VAL_macAuthPortIntrusionAction_block_traffic:
                  case VAL_macAuthPortIntrusionAction_pass_traffic:
                      break;

                  default:
                      return SNMP_ERR_WRONGVALUE;
              }
         }
         case FREE:
              break;

         case ACTION:
         {
              UI32_T nIndex;
              nIndex  = (UI32_T)name[oid_name_length];
              value = *(long *) var_val;

              if (NETACCESS_PMGR_SetMacAuthPortIntrusionAction(nIndex, value) != TRUE)
                  return SNMP_ERR_COMMITFAILED;
              break;
         }
         case UNDO:
         case COMMIT:
              break;
    }
    return SNMP_ERR_NOERROR;
}
#endif  /*#if(SYS_CPNT_NETACCESS_MACAUTH==TRUE) */

#if(SYS_CPNT_NETACCESS_MAC_FILTER_TABLE == TRUE)
#define NETWORKACCESSMACFILTERWITHMASKENTRY_INSTANCE_LEN  13

BOOL_T networkAccessMacFilterWithMaskTable_OidIndexToData(UI32_T exact, UI32_T compc,
            oid * compl,  UI32_T *networkAccessMacFilterWithMaskID, UI8_T *networkAccessMacFilterWithMaskMacAddress, UI8_T *networkAccessMacFilterWithMaskMacAddressMask)
{
    UI32_T i;

    /* get or write */
    if (exact)
    {
        /* check the index length */
        if (compc != NETWORKACCESSMACFILTERWITHMASKENTRY_INSTANCE_LEN) /* the constant size index */
        {
            return FALSE;
        }
    }

    *networkAccessMacFilterWithMaskID = compl[0];
    for (i=0; i < SIZE_networkAccessMacFilterWithMaskMacAddress; i++)
    {
        networkAccessMacFilterWithMaskMacAddress[i] = compl[1 + i];
    }
    for (i=0; i < SIZE_networkAccessMacFilterWithMaskMacAddressMask; i++)
    {
        networkAccessMacFilterWithMaskMacAddressMask[i] = compl[7 + i];
    }

    return TRUE;
}

/*
 * var_networkAccessMacFilterWithMaskTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *
var_networkAccessMacFilterWithMaskTable(struct variable *vp,
            oid     *name,
            size_t  *length,
            int     exact,
            size_t  *var_len,
            WriteMethod **write_method)
{
    /* variables we may use later */
    UI32_T compc = 0;
    UI32_T i=0;
    UI32_T id=0;
    UI8_T mac[SIZE_networkAccessMacFilterWithMaskMacAddress]={0};
    UI8_T mask[SIZE_networkAccessMacFilterWithMaskMacAddressMask]={0};
    oid compl[NETWORKACCESSMACFILTERWITHMASKENTRY_INSTANCE_LEN] = {0};
    oid best_inst[NETWORKACCESSMACFILTERWITHMASKENTRY_INSTANCE_LEN] = {0};

    switch (vp->magic)
    {
        case LEAF_networkAccessMacFilterWithMaskStatus:
            *write_method = write_networkAccessMacFilterWithMaskStatus;
            break;

        default:
            *write_method = 0;
            break;
    }

    /* check compc, retrive compl */
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,
                           compl, NETWORKACCESSMACFILTERWITHMASKENTRY_INSTANCE_LEN);

    if (exact) /* get,set */
    {
        /* get index */
        if (networkAccessMacFilterWithMaskTable_OidIndexToData(exact, compc, compl,  &id, mac, mask) == FALSE)
        {
            return NULL;
        }

        /* get data */
        if (NETACCESS_PMGR_GetFilterMac(id, mac, mask) != TRUE) /* Temp solution for building */
        {
            return NULL;
        }
    }
    else /* getnext */
    {
        /* get index */
        networkAccessMacFilterWithMaskTable_OidIndexToData(exact, compc, compl,  &id, mac, mask);

        /* check the length of inputing index,if < 1 we should try get
         * {0.0.0.0.0...}
         */
        if (compc < 1)
        {
            /* get data */
            if (NETACCESS_PMGR_GetFilterMac(id, mac, mask) != TRUE) /* Temp solution for building */
            {
                /* get next data */
                if (NETACCESS_PMGR_GetNextFilterMac(&id, mac, mask) != TRUE) /* Temp solution for building */
                {
                    return NULL;
                }
            }
        }
        else
        {
            /* get next data */
            if (NETACCESS_PMGR_GetNextFilterMac(&id, mac, mask) != TRUE) /* Temp solution for building */
            {
                return NULL;
            }
        }
    }

    memcpy(name, vp->name, vp->namelen*sizeof(oid));

    /* assign data to the oid index */
    best_inst[0] = id;
    for (i = 0; i < SIZE_networkAccessMacFilterWithMaskMacAddress; i++)
    {
        best_inst[1 + i] = mac[i];
    }
    for (i = 0; i < SIZE_networkAccessMacFilterWithMaskMacAddressMask; i++)
    {
        best_inst[7 + i] = mask[i];
    }
    memcpy(name + vp->namelen, best_inst, NETWORKACCESSMACFILTERWITHMASKENTRY_INSTANCE_LEN * sizeof(oid));
    *length = vp->namelen + NETWORKACCESSMACFILTERWITHMASKENTRY_INSTANCE_LEN ;

    /* this is where we do the value assignments for the mib results. */
    switch (vp->magic)
    {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case LEAF_networkAccessMacFilterWithMaskID:
            *var_len = sizeof(long_return);
            long_return = id;
            return (u_char *) &long_return;

        case LEAF_networkAccessMacFilterWithMaskMacAddress:
            *var_len = SIZE_networkAccessMacFilterWithMaskMacAddress;
            memcpy(return_buf, mac, *var_len);
            return (u_char*)return_buf;

        case LEAF_networkAccessMacFilterWithMaskMacAddressMask:
            *var_len = SIZE_networkAccessMacFilterWithMaskMacAddressMask;
            memcpy(return_buf, mask, *var_len);
            return (u_char*)return_buf;

#endif
        case LEAF_networkAccessMacFilterWithMaskStatus:
            *var_len = sizeof(long_return);
            long_return = VAL_networkAccessMacFilterWithMaskStatus_valid;
            return (u_char *) &long_return;

        default:
            ERROR_MSG("");
    }

    return NULL;
}

int
write_networkAccessMacFilterWithMaskStatus(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    UI32_T  oid_name_length;

    oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            switch (*(long *)var_val)
            {
                case VAL_networkAccessMacFilterWithMaskStatus_valid:
                    break;

                case VAL_networkAccessMacFilterWithMaskStatus_invalid:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            BOOL_T is_add = 0;
            UI32_T i;
            UI32_T filter_id = 0;
            UI8_T mac_address[SIZE_networkAccessMacFilterWithMaskMacAddress] = {0};
            UI8_T mask[SIZE_networkAccessMacFilterWithMaskMacAddressMask] = {0};

            filter_id = name[oid_name_length];
            for (i = 0; i < SIZE_networkAccessMacFilterWithMaskMacAddress; i++)
            {
                mac_address[i] = name[oid_name_length + 1 + i];
            }
            for (i = 0; i < SIZE_networkAccessMacFilterWithMaskMacAddressMask; i++)
            {
                mask[i] = name[oid_name_length + 7 + i];
            }

            switch (*(long *)var_val)
            {
                case VAL_networkAccessMacFilterWithMaskStatus_valid:
                    is_add = TRUE;
                    break;

                case VAL_networkAccessMacFilterWithMaskStatus_invalid:
                    is_add = FALSE;
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }

            if(FALSE == NETACCESS_PMGR_SetFilterMac(filter_id, mac_address, mask, is_add)) /* temp solution for building */
            {
                return SNMP_ERR_COMMITFAILED;
            }
            break;
        }

        case UNDO:
          break;

        case COMMIT:
          break;
    }

    return SNMP_ERR_NOERROR;
}
#endif /* end of #if (SYS_CPNT_NETACCESS_MAC_FILTER_TABLE == TRUE) */
#endif /* end of #if (SYS_CPNT_NETACCESS == TRUE) */

#if (SYS_CPNT_WEBAUTH == TRUE)

/********************************************
 ******************webAuthMgt***************
 ********************************************
 */
int
do_webAuthSystemAuthControl(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
            {
                UI8_T  status;

                if (WEBAUTH_PMGR_GetSystemStatus(&status)== FALSE)
                    return SNMP_ERR_GENERR;
          else
                    long_return = status;

                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
            }
            break;
        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:

            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
            }

            break;
        case MODE_SET_RESERVE2:

            switch ( *requests->requestvb->val.integer )
            {
                case VAL_webAuthSystemAuthControl_enabled:
                    break;
                case VAL_webAuthSystemAuthControl_disabled:
                    break;
                default:
                    netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
            {
                UI8_T status;
                status= (UI8_T)(*requests->requestvb->val.integer);
                if (WEBAUTH_PMGR_SetSystemStatus(status) == WEBAUTH_TYPE_RETURN_ERROR)
                    netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */

            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */

            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

#if 0 /* doesn't support presently*/
int
do_webAuthLoginPageUrl(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
            {
                UI8_T  url[WEBAUTH_TYPE_MAX_URL_LENGTH];
                memset(url,0 ,sizeof(url));

                if (WEBAUTH_PMGR_GetExternalURL(url, WEBAUTH_TYPE_EXTERNAL_URL_Login) == WEBAUTH_TYPE_RETURN_ERROR)
                    return SNMP_ERR_GENERR;
             else
                    strcpy( return_buf, url);

                snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, (u_char *) return_buf, strlen(return_buf));
            }
            break;
        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:

            if(requests->requestvb->val_len>WEBAUTH_TYPE_MAX_URL_LENGTH)
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_WRONGLENGTH);
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */

            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
            {
                UI8_T  url[WEBAUTH_TYPE_MAX_URL_LENGTH];
                memset(url,0 ,sizeof(url));

                memcpy(url, requests->requestvb->val.string, requests->requestvb->val_len);
                if (WEBAUTH_PMGR_SetExternalURL(url, WEBAUTH_TYPE_EXTERNAL_URL_Login) == WEBAUTH_TYPE_RETURN_ERROR)
                    netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */

            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */

            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_webAuthLoginFailPageUrl(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
            {
                UI8_T  url[WEBAUTH_TYPE_MAX_URL_LENGTH];
                memset(url,0 ,sizeof(url));

                if (WEBAUTH_PMGR_GetExternalURL(url, WEBAUTH_TYPE_EXTERNAL_URL_Login_fail) == WEBAUTH_TYPE_RETURN_ERROR)
                    return SNMP_ERR_GENERR;
             else
                    strcpy( return_buf, url);

                snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, (u_char *) return_buf, strlen(return_buf));
            }
            break;
        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:

            if(requests->requestvb->val_len>WEBAUTH_TYPE_MAX_URL_LENGTH)
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_WRONGLENGTH);
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */

            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
            {
                UI8_T  url[WEBAUTH_TYPE_MAX_URL_LENGTH];
                memset(url,0 ,sizeof(url));

                memcpy(url, requests->requestvb->val.string, requests->requestvb->val_len);
                if (WEBAUTH_PMGR_SetExternalURL(url, WEBAUTH_TYPE_EXTERNAL_URL_Login_fail) == WEBAUTH_TYPE_RETURN_ERROR)
                    netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */

            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */

            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_webAuthLoginSuccessPageUrl(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
            {
                UI8_T  url[WEBAUTH_TYPE_MAX_URL_LENGTH];
                memset(url,0 ,sizeof(url));

                if (WEBAUTH_PMGR_GetExternalURL(url, WEBAUTH_TYPE_EXTERNAL_URL_Login_Success) == WEBAUTH_TYPE_RETURN_ERROR)
                    return SNMP_ERR_GENERR;
             else
                    strcpy( return_buf, url);

                snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, (u_char *) return_buf, strlen(return_buf));
            }
            break;
        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:

            if(requests->requestvb->val_len>WEBAUTH_TYPE_MAX_URL_LENGTH)
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_WRONGLENGTH);
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */

            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
            {
                UI8_T  url[WEBAUTH_TYPE_MAX_URL_LENGTH];
                memset(url,0 ,sizeof(url));

                memcpy(url, requests->requestvb->val.string, requests->requestvb->val_len);
                if (WEBAUTH_PMGR_SetExternalURL(url, WEBAUTH_TYPE_EXTERNAL_URL_Login_Success) == WEBAUTH_TYPE_RETURN_ERROR)
                    netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */

            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */

            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
#endif

int
do_webAuthSessionTimeout(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
            {
                UI16_T  session_timeout;

                if (WEBAUTH_PMGR_GetSystemSessionTimeout(&session_timeout)== FALSE)
                    return SNMP_ERR_GENERR;
          else
                    long_return = session_timeout;

                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
            }
            break;
        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:

            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
            }

            break;
        case MODE_SET_RESERVE2:

            {
                UI32_T session_timeout;
                session_timeout = (*requests->requestvb->val.integer);
                if ((session_timeout < MIN_webAuthSessionTimeout) ||(session_timeout > MAX_webAuthSessionTimeout))
                    netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_WRONGVALUE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
            {
                UI16_T session_timeout;
                session_timeout = (UI16_T)(*requests->requestvb->val.integer);
                if (WEBAUTH_PMGR_SetSystemSessionTimeout(session_timeout) == WEBAUTH_TYPE_RETURN_ERROR)
                    netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */

            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */

            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_webAuthQuietPeriod(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
            {
                UI16_T  quiet_period;

                if (WEBAUTH_PMGR_GetQuietPeriod(&quiet_period)== FALSE)
                    return SNMP_ERR_GENERR;
          else
                    long_return = quiet_period;

                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
            }
            break;
        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:

            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
            }

            break;
        case MODE_SET_RESERVE2:

            {
                UI32_T quiet_period;
                quiet_period = (*requests->requestvb->val.integer);
                if ((quiet_period < MIN_webAuthQuietPeriod) ||(quiet_period > MAX_webAuthQuietPeriod))
                    netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_WRONGVALUE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
            {
                UI16_T quiet_period;
                quiet_period = (UI16_T)(*requests->requestvb->val.integer);
                if (WEBAUTH_PMGR_SetQuietPeriod(quiet_period) == WEBAUTH_TYPE_RETURN_ERROR)
                    netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */

            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */

            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_webAuthLoginAttempts(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
            {
                UI8_T  max_login_attempt;

                if (WEBAUTH_PMGR_GetMaxLoginAttempts(&max_login_attempt)== FALSE)
                    return SNMP_ERR_GENERR;
          else
                    long_return = max_login_attempt;

                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
            }
            break;
        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:

            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
            }

            break;
        case MODE_SET_RESERVE2:

            {
                UI32_T max_login_attempt;
                max_login_attempt = (*requests->requestvb->val.integer);
                if ((max_login_attempt < MIN_webAuthLoginAttempts) ||(max_login_attempt > MAX_webAuthLoginAttempts))
                    netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_WRONGVALUE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
            {
                UI8_T max_login_attempt;
                max_login_attempt = (UI8_T)(*requests->requestvb->val.integer);
                if (WEBAUTH_PMGR_SetMaxLoginAttempts(max_login_attempt) == WEBAUTH_TYPE_RETURN_ERROR)
                    netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */

            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */

            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

/********************************************
 ***********webAuthReauthenticateMgt***********
 ********************************************
 */
static UI32_T webAuthReauthenticatePort = 1;
static UI32_T webAuthReauthenticateInetAddressType = 1;
static UI32_T webAuthReauthenticateInetAddress;
static UI32_T webAuthReauthenticateAction = VAL_webAuthReauthenticateAction_noReauth;

int
do_webAuthReauthenticatePort(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
            {
                long_return = webAuthReauthenticatePort;
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
            }
            break;
        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:

            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
            }

            break;
        case MODE_SET_RESERVE2:

            {
                UI32_T ifindex;
                ifindex = (*requests->requestvb->val.integer);
                if (SWCTRL_POM_LogicalPortExisting(ifindex) == FALSE)
                    netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_WRONGVALUE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
            {
                UI32_T ifindex;
                ifindex = (*requests->requestvb->val.integer);
                webAuthReauthenticatePort = ifindex;
            }
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */

            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */

            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_webAuthReauthenticateInetAddressType(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
            {
                long_return = webAuthReauthenticateInetAddressType;
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
            }
            break;
        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:

            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
            }

            break;
        case MODE_SET_RESERVE2:

            {
                UI32_T ipAddressType;
                ipAddressType = (*requests->requestvb->val.integer);

                if (ipAddressType != VAL_webAuthReauthenticateInetAddressType_ipv4)
                    netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_WRONGVALUE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
            {
                webAuthReauthenticateInetAddressType = *requests->requestvb->val.integer;
            }
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */

            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */

            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_webAuthReauthenticateInetAddress(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
            {
                long_return = webAuthReauthenticateInetAddress;
                snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, (u_char *) &long_return, sizeof(long_return));
            }
            break;
        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:

            if (requests->requestvb->type != ASN_OCTET_STR)
            {
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
            }
            if (requests->requestvb->val_len != sizeof(UI32_T))
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
            {
                UI8_T ipaddress[4];

                memset(ipaddress, 0x0, sizeof(ipaddress));
                memcpy(ipaddress, requests->requestvb->val.string,
                               requests->requestvb->val_len);

                webAuthReauthenticateInetAddress = ipaddress[0] * (256 * 256 * 256) + ipaddress[1] * (256 * 256) + ipaddress[2] * 256 + ipaddress[3];
            }
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */

            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */

            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_webAuthReauthenticateAction(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
            {
                long_return = webAuthReauthenticateAction;
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
            }
            break;
        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:

            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
            }

            break;
        case MODE_SET_RESERVE2:

            {
                UI32_T value;
                value =  (*requests->requestvb->val.integer);
                switch (value)
                {
                    case VAL_webAuthReauthenticateAction_noReauth:
                    case VAL_webAuthReauthenticateAction_reauth:
                        break;

                    default:
                        return SNMP_ERR_WRONGVALUE;
                }
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
            {
                if(webAuthReauthenticateInetAddress == 0)
                {
                    if(WEBAUTH_PMGR_ReAuthByLPort(webAuthReauthenticatePort) != WEBAUTH_TYPE_RETURN_OK)
                 {
                        netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
                    }
              else
              {
                        webAuthReauthenticatePort = 1;
                        webAuthReauthenticateInetAddressType = 1;
                        webAuthReauthenticateInetAddress = 0;
                        webAuthReauthenticateAction = VAL_webAuthReauthenticateAction_noReauth;
              }
                }
             else
             {
                    if(WEBAUTH_PMGR_ReAuthHostByLPort(webAuthReauthenticatePort, webAuthReauthenticateInetAddress) != WEBAUTH_TYPE_RETURN_OK)
                 {
                        netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
                    }
                    else
                    {
                        webAuthReauthenticatePort = 1;
                        webAuthReauthenticateInetAddressType = 1;
                        webAuthReauthenticateInetAddress = 0;
                        webAuthReauthenticateAction = VAL_webAuthReauthenticateAction_noReauth;
                    }
             }
            }
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */

            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */

            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

/********************************************
 ************webAuthPortConfigTable************
 ********************************************
 */
#define webAuthPortConfigEntry_INSTANCE_LEN  1


static BOOL_T webAuthPortConfigTable_get(int      compc,
                                      oid     *compl,
                                      WEBAUTH_TYPE_Port_Info_T   *data, UI32_T nIndex)
{

    if (compc !=webAuthPortConfigEntry_INSTANCE_LEN)
    {
    return FALSE;
    }

    if(SNMP_MGR_IsDebugMode())
       SYSFUN_Debug_Printf("webAuthPortConfigTable_get:index=[%lu]\n", nIndex);

    if (WEBAUTH_PMGR_GetPortInfoByLPort(nIndex, data) == WEBAUTH_TYPE_RETURN_ERROR)
    {
        if(SNMP_MGR_IsDebugMode())
           SYSFUN_Debug_Printf("webAuthPortConfigTable_get:WEBAUTH_PMGR_GetPortInfoByLPort return false\n");

        return FALSE;
    }
    else
    {
        return TRUE;
    }        /*End of if */
}

static BOOL_T webAuthPortConfigTable_next(int      compc,
                                       oid     *compl,
                                       WEBAUTH_TYPE_Port_Info_T    *data, UI32_T *nIndex)
{

    if(SNMP_MGR_IsDebugMode())
       SYSFUN_Debug_Printf("webAuthPortConfigTable_next:nIndex=[%lu]\n", *nIndex);

    if (compc < webAuthPortConfigEntry_INSTANCE_LEN)
    {
        if (WEBAUTH_PMGR_GetPortInfoByLPort(*nIndex, data) == WEBAUTH_TYPE_RETURN_ERROR)
        {
            if (WEBAUTH_PMGR_GetNextPortInfoByLPort(nIndex, data) == WEBAUTH_TYPE_RETURN_ERROR)
            {
               if(SNMP_MGR_IsDebugMode())
                  SYSFUN_Debug_Printf("webAuthPortConfigTable_next: get & genext return false\n");
               return FALSE;
            }
        }
    }
    else
    {
        if (WEBAUTH_PMGR_GetNextPortInfoByLPort(nIndex, data) == WEBAUTH_TYPE_RETURN_ERROR)
        {
            if(SNMP_MGR_IsDebugMode())
               SYSFUN_Debug_Printf("webAuthPortConfigTable_next: get return false\n");
            return FALSE;
        }
    }
    return TRUE;
}


unsigned char  *
var_webAuthPortConfigTable(struct variable *vp,
                        oid * name,
                        size_t * length,
                        int exact,
                        size_t * var_len, WriteMethod ** write_method)
{
    UI32_T nIndex=0, compc=0;
    oid compl[webAuthPortConfigEntry_INSTANCE_LEN];
    oid best_inst[webAuthPortConfigEntry_INSTANCE_LEN];
    WEBAUTH_TYPE_Port_Info_T data;

    switch (vp->magic)
    {
        case WEBAUTHPORTCONFIGSTATUS:
            *write_method = write_webAuthPortConfigStatus;
            break;

        default:
            *write_method =0;
            ERROR_MSG("");
            break;
    }

    //step 1: retrive compc, compl
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl, webAuthPortConfigEntry_INSTANCE_LEN);

    nIndex = compl[0];

    //step2: call get/getnext ;check compc, retrive compl
    if (exact)/*get,set*/
    {
        if (!webAuthPortConfigTable_get(compc, compl, &data, nIndex))
            return NULL;
    }
    else/*getnext*/
    {
        if (!webAuthPortConfigTable_next(compc, compl, &data,  &nIndex))
            return NULL;
    }

    //step 3:binds next oid back to agent
    memcpy(name, vp->name, vp->namelen * sizeof(oid));
    best_inst[0]=nIndex;

    memcpy(name + vp->namelen, best_inst, webAuthPortConfigEntry_INSTANCE_LEN * sizeof(oid));

    //step 4:return get value result to agent
    *length = vp->namelen + webAuthPortConfigEntry_INSTANCE_LEN;

    *var_len = sizeof(long_return);

    // this is where we do the value assignments for the mib results.
    switch (vp->magic)
    {
        case WEBAUTHPORTCONFIGSTATUS:
             long_return = (long) data.status;
             return (u_char *) &long_return;

        case WEBAUTHPORTCONFIGAUTHENTICATEDHOSTCOUNT:
             long_return = (long) data.success_count;
             return (u_char *) &long_return;

        default:
             ERROR_MSG("");
    }
    return NULL;
}

int
write_webAuthPortConfigStatus(int action,
                               u_char * var_val,
                               u_char var_val_type,
                               size_t var_val_len,
                               u_char * statP, oid * name, size_t name_len)
{
    long    value;
    int     size;
    UI32_T  oid_name_length;

    oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    switch (action)
    {
         case RESERVE1:
              if (var_val_type != ASN_INTEGER)
                  return SNMP_ERR_WRONGTYPE;

              if (var_val_len > sizeof(long))
                  return SNMP_ERR_WRONGLENGTH;

              break;

         case RESERVE2:
              size = var_val_len;
              value = *(long *) var_val;

              switch(value)
              {
                  case VAL_webAuthReauthenticateAction_noReauth:
                  case VAL_webAuthReauthenticateAction_reauth:
                       break;

                  default:
                       return SNMP_ERR_WRONGVALUE;
              }
              break;

         case FREE:
              break;

         case ACTION:
         {
              UI32_T nIndex;
              UI8_T  nStatus;

              size    = var_val_len;
              nStatus = *(long *)var_val;
              nIndex  = name[oid_name_length];

              if (WEBAUTH_PMGR_SetStatusByLPort(nIndex, nStatus) != WEBAUTH_TYPE_RETURN_OK)
                  return SNMP_ERR_COMMITFAILED;
              break;
         }
         case UNDO:
         case COMMIT:
              break;
    }
    return SNMP_ERR_NOERROR;
}

/********************************************
 ************webAuthPortInfoTable**************
 ********************************************
 */
#define WEBAUTHPORTINFOENTRY_INSTANCE_LEN  2

BOOL_T webAuthPortInfoTable_OidIndexToData(UI32_T exact, UI32_T compc,
    oid *compl, UI32_T *port_index_p, UI8_T *success_index_p)
{
    /* get or set
     */
    if (exact)
    {
        /* check the index length
         */
        if (compc != WEBAUTHPORTINFOENTRY_INSTANCE_LEN) /* the constant size index */
        {
            return FALSE;
        }
    }

    *port_index_p = compl[0];
    *success_index_p = compl[1];

    return TRUE;
}

/*
 * var_webAuthPortInfoTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *var_webAuthPortInfoTable(struct variable *vp,
    oid *name,
    size_t *length,
    int exact,
    size_t *var_len,
    WriteMethod **write_method)
{
    UI32_T compc = 0;
    UI32_T port_index = 0;
    UI8_T success_index = 0;
    oid compl[WEBAUTHPORTINFOENTRY_INSTANCE_LEN] = {0};
    oid best_inst[WEBAUTHPORTINFOENTRY_INSTANCE_LEN] = {0};
    WEBAUTH_TYPE_Host_Info_T entry;

    switch (vp->magic)
    {
        default:
            *write_method = 0;
            break;
    }

    /* check compc, retrive compl
     */
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl, WEBAUTHPORTINFOENTRY_INSTANCE_LEN);

    memset(&entry, 0, sizeof(entry));

    if (exact) /* get or set */
    {
        if (webAuthPortInfoTable_OidIndexToData(exact, compc, compl, &port_index, &success_index) == FALSE)
        {
            return NULL;
        }

        if (WEBAUTH_PMGR_GetSuccessHostByLPort(&entry, port_index, success_index) != WEBAUTH_TYPE_RETURN_OK)
        {
            return NULL;
        }
    }
    else /* getnext */
    {
        webAuthPortInfoTable_OidIndexToData(exact, compc, compl, &port_index, &success_index);

        /* check the length of inputing index,if < 1 we should try get
         * {0.0.0.0.0...}
         */
        if (compc < 1)
        {
            if (WEBAUTH_PMGR_GetSuccessHostByLPort(&entry, port_index, success_index) != WEBAUTH_TYPE_RETURN_OK)
            {
                if (WEBAUTH_PMGR_GetNextSuccessHostByLPortAndSuccIndex(&entry, &port_index, &success_index) != WEBAUTH_TYPE_RETURN_OK)
                {
                    return NULL;
                }
            }
        }
        else
        {
            if (WEBAUTH_PMGR_GetNextSuccessHostByLPortAndSuccIndex(&entry, &port_index, &success_index) != WEBAUTH_TYPE_RETURN_OK)
            {
                return NULL;
            }
        }
    }

    memcpy(name, vp->name, vp->namelen * sizeof(oid));

    /* assign data to the oid index
     */
    best_inst[0] = port_index;
    best_inst[1] = success_index;
    memcpy(name + vp->namelen, best_inst, WEBAUTHPORTINFOENTRY_INSTANCE_LEN * sizeof(oid));
    *length = vp->namelen + WEBAUTHPORTINFOENTRY_INSTANCE_LEN;

    switch (vp->magic)
    {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case LEAF_webAuthPortInfoPortIndex:
            *var_len = sizeof(long_return);
            long_return = port_index;
            return (u_char *) &long_return;
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case LEAF_webAuthPortInfoPortAuthSuccessIndex:
            *var_len = sizeof(long_return);
            long_return = success_index;
            return (u_char *) &long_return;
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

        case LEAF_webAuthPortInfoInetAddressType:
            *var_len = sizeof(long_return);
            long_return = VAL_webAuthPortInfoInetAddressType_ipv4;
            return (u_char *) &long_return;

        case LEAF_webAuthPortInfoInetAddress:
            *var_len = sizeof(long_return);
            IP_LIB_UI32toArray(entry.ip, return_buf);
            return (u_char *) return_buf;

        case LEAF_webAuthPortInfoRemainingSessiontime:
            *var_len = sizeof(long_return);
            long_return = entry.remaining_time;
            return (u_char *) &long_return;

        case LEAF_webAuthPortInfoStatus:
            *var_len = sizeof(long_return);
            long_return = entry.state;
            return (u_char *) &long_return;

        default:
            ERROR_MSG("");
    }

    return NULL;
}
#endif /* end of #if (SYS_CPNT_WEBAUTH == TRUE) */

#if (SYS_CPNT_DOS == TRUE)
/********************************************
 ******************dosMgt********************
 ********************************************
 */
static int
do_dosStatusByFieldId(DOS_TYPE_FieldId_T field_id,
                          netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
            {
                UI32_T  value;

                if (DOS_PMGR_GetDataByField(field_id, &value) != DOS_TYPE_E_OK)
                    return SNMP_ERR_GENERR;

                switch (value)
                {
                    case DOS_TYPE_STATUS_ENABLED:
                        long_return = VAL_enabled;
                        break;
                    case DOS_TYPE_STATUS_DISABLED:
                        long_return = VAL_disabled;
                        break;
                    default:
                        return SNMP_ERR_GENERR;
                }

                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
            }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_WRONGTYPE);
                break;
            }
            break;

        case MODE_SET_RESERVE2:
            {
                UI32_T value;
                value = (*requests->requestvb->val.integer);
                if ((value != VAL_enabled) &&
                    (value != VAL_disabled))
                {
                    netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_WRONGVALUE);
                }
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
            {
                UI32_T value;

                value = (*requests->requestvb->val.integer);
                switch (value)
                {
                    case VAL_enabled:
                        value = DOS_TYPE_STATUS_ENABLED;
                        break;
                    case VAL_disabled:
                        value = DOS_TYPE_STATUS_DISABLED;
                        break;
                    default:
                        return SNMP_ERR_GENERR;
                }

                if (DOS_PMGR_SetDataByField(field_id, &value) != DOS_TYPE_E_OK)
                    netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */

            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */

            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

static int
do_dosRateLimitInKiloByFieldId(DOS_TYPE_FieldId_T field_id,
                          netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
            {
                UI32_T  value;

                if (DOS_PMGR_GetDataByField(field_id, &value) != DOS_TYPE_E_OK)
                    return SNMP_ERR_GENERR;

                long_return = value;

                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
            }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_WRONGTYPE);
                break;
            }
            break;

        case MODE_SET_RESERVE2:
            {
                UI32_T value;
                value = (*requests->requestvb->val.integer);
                if ((value < SYS_ADPT_DOS_MIN_RATELIMIT) ||
                    (value > SYS_ADPT_DOS_MAX_RATELIMIT))
                {
                    netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_WRONGVALUE);
                }
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
            {
                UI32_T value;

                value = (*requests->requestvb->val.integer);

                if (DOS_PMGR_SetDataByField(field_id, &value) != DOS_TYPE_E_OK)
                    netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */

            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */

            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_dosEchoChargenStatus(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    return do_dosStatusByFieldId(
        DOS_TYPE_FLD_SYSTEM_ECHO_CHARGEN_STATUS, handler, reginfo, reqinfo, requests);
}

int
do_dosEchoChargenRateLimitInKilo(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    return do_dosRateLimitInKiloByFieldId(
        DOS_TYPE_FLD_SYSTEM_ECHO_CHARGEN_RATELIMIT, handler, reginfo, reqinfo, requests);
}

int
do_dosLandStatus(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    return do_dosStatusByFieldId(
        DOS_TYPE_FLD_SYSTEM_LAND_STATUS, handler, reginfo, reqinfo, requests);
}

int
do_dosSmurfStatus(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    return do_dosStatusByFieldId(
        DOS_TYPE_FLD_SYSTEM_SMURF_STATUS, handler, reginfo, reqinfo, requests);
}

int
do_dosTcpFloodingStatus(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    return do_dosStatusByFieldId(
        DOS_TYPE_FLD_SYSTEM_TCP_FLOODING_STATUS, handler, reginfo, reqinfo, requests);
}

int
do_dosTcpFloodingRateLimitInKilo(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    return do_dosRateLimitInKiloByFieldId(
        DOS_TYPE_FLD_SYSTEM_TCP_FLOODING_RATELIMIT, handler, reginfo, reqinfo, requests);
}

int
do_dosTcpNullScanStatus(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    return do_dosStatusByFieldId(
        DOS_TYPE_FLD_SYSTEM_TCP_NULL_SCAN_STATUS, handler, reginfo, reqinfo, requests);
}

int
do_dosTcpSynFinScanStatus(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    return do_dosStatusByFieldId(
        DOS_TYPE_FLD_SYSTEM_TCP_SYN_FIN_SCAN_STATUS, handler, reginfo, reqinfo, requests);
}

int
do_dosTcpXmasScanStatus(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    return do_dosStatusByFieldId(
        DOS_TYPE_FLD_SYSTEM_TCP_XMAS_SCAN_STATUS, handler, reginfo, reqinfo, requests);
}

int
do_dosUdpFloodingStatus(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    return do_dosStatusByFieldId(
        DOS_TYPE_FLD_SYSTEM_UDP_FLOODING_STATUS, handler, reginfo, reqinfo, requests);
}

int
do_dosUdpFloodingRateLimitInKilo(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    return do_dosRateLimitInKiloByFieldId(
        DOS_TYPE_FLD_SYSTEM_UDP_FLOODING_RATELIMIT, handler, reginfo, reqinfo, requests);
}

int
do_dosWinNukeStatus(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    return do_dosStatusByFieldId(
        DOS_TYPE_FLD_SYSTEM_WIN_NUKE_STATUS, handler, reginfo, reqinfo, requests);
}

int
do_dosWinNukeRateLimitInKilo(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    return do_dosRateLimitInKiloByFieldId(
        DOS_TYPE_FLD_SYSTEM_WIN_NUKE_RATELIMIT, handler, reginfo, reqinfo, requests);
}

int
do_dosTcpScanStatus(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    return do_dosStatusByFieldId(
        DOS_TYPE_FLD_SYSTEM_TCP_SCAN_STATUS, handler, reginfo, reqinfo, requests);
}

int
do_dosTcpUdpPortZeroStatus(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    return do_dosStatusByFieldId(
        DOS_TYPE_FLD_SYSTEM_TCP_UDP_PORT_ZERO_STATUS, handler, reginfo, reqinfo, requests);
}
#endif /* (SYS_CPNT_DOS == TRUE) */

#if (SYS_CPNT_APP_FILTER == TRUE)
#define APP_FILTER_PORT_ENTRY_INSTANCE_LEN 2

enum
{
    PKT_CDP  = 1,
    PKT_PVST = 2,

    PKT_MIN_NUM = 1,
    PKT_MAX_NUM = PKT_PVST
};

static BOOL_T
appFilterPortTable_getPortStatus(
    UI32_T *ifindex_p,
    UI32_T *protocol_type_p,
    UI32_T *pkt_status_p)
{
    AF_TYPE_STATUS_T status;
    AF_TYPE_ErrorCode_T result;

    switch (*protocol_type_p)
    {
        case PKT_CDP:
            result = AF_PMGR_GetPortCdpStatus(*ifindex_p, &status);
            break;
        case PKT_PVST:
            result = AF_PMGR_GetPortPvstStatus(*ifindex_p, &status);
            break;
        default:
            return FALSE;
    }

    if (result == AF_TYPE_SUCCESS)
    {
        *pkt_status_p = status;
        return TRUE;
    }

    return FALSE;
}

static BOOL_T
appFilterPortTable_get(
    int compc,
    oid *compl,
    UI32_T *ifindex_p,
    UI32_T *protocol_type_p,
    UI32_T *pkt_status_p)
{
    if (compc != APP_FILTER_PORT_ENTRY_INSTANCE_LEN)
    {
        return FALSE;
    }

    *ifindex_p       = (UI32_T)compl[0];
    *protocol_type_p = (UI32_T)compl[1];

    return appFilterPortTable_getPortStatus(ifindex_p, protocol_type_p,
               pkt_status_p);
}

static BOOL_T
appFilterPortTable_next(
    int compc,
    oid *compl,
    UI32_T *ifindex_p,
    UI32_T *protocol_type_p,
    UI32_T *pkt_status_p)
{
    if (compc != APP_FILTER_PORT_ENTRY_INSTANCE_LEN)
    {
        *ifindex_p      = 1;
        *protocol_type_p = PKT_CDP;
    }
    else
    {
        *ifindex_p       = (UI32_T)compl[0];
        *protocol_type_p = (UI32_T)compl[1];

        if (PKT_MAX_NUM == *protocol_type_p)
        {
            *protocol_type_p = PKT_MIN_NUM;
            *ifindex_p = *ifindex_p + 1;
        }
        else
        {
            *protocol_type_p = *protocol_type_p + 1;
        }
    }

    return appFilterPortTable_getPortStatus(ifindex_p, protocol_type_p,
               pkt_status_p);
}

/*
 * var_appFilterPortTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_appFilterPortTable(
    struct variable * vp,
    oid             * name,
    size_t          * length,
    int             exact,
    size_t          * var_len,
    WriteMethod     ** write_method)
{
    UI32_T compc;
    UI32_T ifindex , protocol_type, pkt_status;
    oid compl[APP_FILTER_PORT_ENTRY_INSTANCE_LEN];
    oid next_inst[APP_FILTER_PORT_ENTRY_INSTANCE_LEN];

    switch (vp->magic)
    {
        case APPFILTERPKTSTATUS:
            *write_method = write_appFilterPktStatus;
            break;
        default:
            *write_method = 0;
            break;
    }

    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl,
        APP_FILTER_PORT_ENTRY_INSTANCE_LEN);

    if (exact)/*get,set*/
    {
        if (TRUE != appFilterPortTable_get(compc, compl, &ifindex,
                        &protocol_type, &pkt_status))
        {
            return NULL;
        }
    }
    else/*getnext*/
    {
      if (TRUE != appFilterPortTable_next(compc, compl, &ifindex,
                      &protocol_type, &pkt_status))
      {
          return NULL;
      }
    }

    memcpy(name, vp->name, vp->namelen*sizeof(oid));
    next_inst[0] = ifindex;
    next_inst[1] = protocol_type;

    memcpy(name + vp->namelen, next_inst, APP_FILTER_PORT_ENTRY_INSTANCE_LEN * sizeof(oid));
    *length = vp->namelen + APP_FILTER_PORT_ENTRY_INSTANCE_LEN;
    *var_len = sizeof(long_return);

    switch (vp->magic)
    {
        case APPFILTERPKTSTATUS:
            long_return = pkt_status;
            return (u_char *) &long_return;

        default:
            ERROR_MSG("");
    }

    return NULL;
}

int
write_appFilterPktStatus(
    int      action,
    u_char   *var_val,
    u_char   var_val_type,
    size_t   var_val_len,
    u_char   *statP,
    oid      *name,
    size_t   name_len)
{

    AF_TYPE_STATUS_T pkt_status;
    UI32_T value, ifindex, protocol_type;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    value = *(long *)var_val;
    pkt_status = (AF_TYPE_STATUS_T)value;

    ifindex = (UI32_T)name[oid_name_length];
    protocol_type = (UI32_T)name[oid_name_length + 1];

    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }

            if (name_len != oid_name_length + 2)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            switch (protocol_type)
            {
                case PKT_CDP:
                case PKT_PVST:

                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }

            if (AF_TYPE_STATUS_MAX < pkt_status ||
                AF_TYPE_STATUS_MIN > pkt_status)
            {
                return SNMP_ERR_WRONGVALUE;
            }

            break;

        case FREE:
            break;

        case ACTION:
            switch (protocol_type)
            {
                case PKT_CDP:
                    if (AF_TYPE_SUCCESS != AF_PMGR_SetPortCdpStatus(ifindex,
                                               pkt_status))
                    {
                        return SNMP_ERR_COMMITFAILED;
                    }
                    break;
                case PKT_PVST:
                    if (AF_TYPE_SUCCESS != AF_PMGR_SetPortPvstStatus(ifindex,
                                               pkt_status))
                    {
                        return SNMP_ERR_COMMITFAILED;
                    }
                    break;
                default:
                    return SNMP_ERR_COMMITFAILED;
            }
            break;

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}
#endif /* #if (SYS_CPNT_APP_FILTER == TRUE) */

#if (SYS_CPNT_SYSLOG == TRUE)
/********************************************
 ********************sysLogMgt***************
 ********************************************
 */
int
do_sysLogHistoryFlashLevel(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
              {
              UI32_T  value;

              if (SYSLOG_PMGR_GetFlashLogLevel(&value)== FALSE)
                       return SNMP_ERR_GENERR;
                  long_return = value;

                     snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
             }
            break;
        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
        {
            UI32_T value;
            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_WRONGTYPE);
                break;
            }
            value = (*requests->requestvb->val.integer);
            if ((value<MIN_sysLogHistoryFlashLevel)  ||    (value>MAX_sysLogHistoryFlashLevel))
            {
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_WRONGVALUE);
                break;
            }
        }
        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */

            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
             {
                UI32_T value;
                value = (*requests->requestvb->val.integer);
                 if (SYSLOG_PMGR_SetFlashLogLevel(value) != SYSLOG_RETURN_OK)
                       netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */

            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */

            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_sysLogHistoryRamLevel(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
             {
              UI32_T  value;

              if (SYSLOG_PMGR_GetUcLogLevel(&value)== FALSE)
                       return SNMP_ERR_GENERR;
                  long_return = value;

                     snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
             }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
        {
            UI32_T value;
            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_WRONGTYPE);
                break;
            }
            value = (*requests->requestvb->val.integer);
            if ((value<MIN_sysLogHistoryRamLevel)  ||    (value>MAX_sysLogHistoryRamLevel))
            {
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_WRONGVALUE);
                break;
            }
        }
        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */

            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
              {
                UI32_T value;
                value = (*requests->requestvb->val.integer);
                 if (SYSLOG_PMGR_SetUcLogLevel(value) != SYSLOG_RETURN_OK)
                       netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
            }
            break;


        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */

            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */

            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
do_sysLogStatus(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
            {
              UI32_T  value;

              if (SYSLOG_PMGR_GetSyslogStatus(&value)== FALSE)
                       return SNMP_ERR_GENERR;

                  if (value == SYSLOG_STATUS_ENABLE)
                         value = VAL_sysLogStatus_enabled;
                    else if (value == SYSLOG_STATUS_DISABLE)
                         value = VAL_sysLogStatus_disabled;
                  long_return = value;

                     snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
             }
            break;


        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
        {
            UI32_T value;
            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_WRONGTYPE);
                break;
            }
            value = (*requests->requestvb->val.integer);
            if ((value<VAL_sysLogStatus_enabled)  ||    (value>VAL_sysLogStatus_disabled))
            {
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_WRONGVALUE);
                break;
            }
        }
        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */

            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
            {
                UI32_T value;
                value = (*requests->requestvb->val.integer);

                  if (value == VAL_sysLogStatus_enabled)
                         value = SYSLOG_STATUS_ENABLE;
                   else if (value == VAL_sysLogStatus_disabled)
                          value = SYSLOG_STATUS_DISABLE;
                 if (SYSLOG_PMGR_SetSyslogStatus(value) != TRUE)
                       netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */

            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */

            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

#if 0
int
do_sysLogLoggingCount(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
             {
              UI32_T  value;

              if (SYSLOG_PMGR_GetFlashLogLevel(&value)== FALSE)
                       return SNMP_ERR_GENERR;
                  long_return = value;

                     snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
             }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            if (/* XXX: check incoming data in requests->requestvb->val.XXX for failures, like an incorrect type or an illegal value or ... */) {
                netsnmp_set_request_error(reqinfo, requests, /* XXX: set error code depending on problem (like SNMP_ERR_WRONGTYPE or SNMP_ERR_WRONGVALUE or ... */);
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            if (/* XXX if malloc, or whatever, failed: */) {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCESUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
            if (/* XXX: error? */) {
                netsnmp_set_request_error(reqinfo, requests, /* some error */);
            }
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            if (/* XXX: error? */) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            if (/* XXX: error? */) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
do_remoteLogStatus(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) /* XXX: a pointer to the scalar's data */, /* XXX: the length of the data in bytes */);
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            if (/* XXX: check incoming data in requests->requestvb->val.XXX for failures, like an incorrect type or an illegal value or ... */) {
                netsnmp_set_request_error(reqinfo, requests, /* XXX: set error code depending on problem (like SNMP_ERR_WRONGTYPE or SNMP_ERR_WRONGVALUE or ... */);
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            if (/* XXX if malloc, or whatever, failed: */) {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCESUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
            if (/* XXX: error? */) {
                netsnmp_set_request_error(reqinfo, requests, /* some error */);
            }
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            if (/* XXX: error? */) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            if (/* XXX: error? */) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_sysLogLoggingInterval(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) /* XXX: a pointer to the scalar's data */, /* XXX: the length of the data in bytes */);
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            if (/* XXX: check incoming data in requests->requestvb->val.XXX for failures, like an incorrect type or an illegal value or ... */) {
                netsnmp_set_request_error(reqinfo, requests, /* XXX: set error code depending on problem (like SNMP_ERR_WRONGTYPE or SNMP_ERR_WRONGVALUE or ... */);
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            if (/* XXX if malloc, or whatever, failed: */) {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCESUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
            if (/* XXX: error? */) {
                netsnmp_set_request_error(reqinfo, requests, /* some error */);
            }
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            if (/* XXX: error? */) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            if (/* XXX: error? */) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
do_remoteLogFacilityType(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) /* XXX: a pointer to the scalar's data */, /* XXX: the length of the data in bytes */);
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            if (/* XXX: check incoming data in requests->requestvb->val.XXX for failures, like an incorrect type or an illegal value or ... */) {
                netsnmp_set_request_error(reqinfo, requests, /* XXX: set error code depending on problem (like SNMP_ERR_WRONGTYPE or SNMP_ERR_WRONGVALUE or ... */);
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            if (/* XXX if malloc, or whatever, failed: */) {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCESUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
            if (/* XXX: error? */) {
                netsnmp_set_request_error(reqinfo, requests, /* some error */);
            }
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            if (/* XXX: error? */) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            if (/* XXX: error? */) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
do_remoteLogLevel(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) /* XXX: a pointer to the scalar's data */, /* XXX: the length of the data in bytes */);
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            if (/* XXX: check incoming data in requests->requestvb->val.XXX for failures, like an incorrect type or an illegal value or ... */) {
                netsnmp_set_request_error(reqinfo, requests, /* XXX: set error code depending on problem (like SNMP_ERR_WRONGTYPE or SNMP_ERR_WRONGVALUE or ... */);
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            if (/* XXX if malloc, or whatever, failed: */) {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCESUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
            if (/* XXX: error? */) {
                netsnmp_set_request_error(reqinfo, requests, /* some error */);
            }
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            if (/* XXX: error? */) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            if (/* XXX: error? */) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
#endif
#endif

#if (SYS_CPNT_REMOTELOG == TRUE)
/********************************************
 *****************remoteLogMgt***************
 ********************************************
 */
int
do_remoteLogStatus(netsnmp_mib_handler *handler,
                   netsnmp_handler_registration *reginfo,
                   netsnmp_agent_request_info *reqinfo,
                   netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode)
     {



        case MODE_GET:
           {
            UI32_T remoteLogStatus;

                if (SYSLOG_PMGR_GetRemoteLogStatus(&remoteLogStatus)!=SYSLOG_REMOTE_SUCCESS)
                {
                return SNMP_ERR_GENERR;
                }
                long_return = remoteLogStatus;
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
            }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
        {
            UI32_T remoteLogStatus;
            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_WRONGTYPE);
                break;
            }
            remoteLogStatus = *requests->requestvb->val.integer;

            if ((remoteLogStatus!= VAL_remoteLogStatus_enabled) && (remoteLogStatus !=VAL_remoteLogStatus_disabled))
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
                break;
            }
        }
        case MODE_SET_RESERVE2:

            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
       {
            UI32_T remoteLogStatus;

            remoteLogStatus = *requests->requestvb->val.integer;


            if (SYSLOG_PMGR_SetRemoteLogStatus(remoteLogStatus) != SYSLOG_REMOTE_SUCCESS)
             netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);

         }
          break;

        case MODE_SET_COMMIT:

            break;

        case MODE_SET_UNDO:

            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_remoteLogFacilityType(netsnmp_mib_handler *handler,
                         netsnmp_handler_registration *reginfo,
                         netsnmp_agent_request_info *reqinfo,
                         netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode)
     {

        case MODE_GET:
           {
#if (SYS_CPNT_REMOTELOG_FACILITY_LEVEL_FOR_EVERY_SERVER == FALSE)
            UI32_T remoteLogFacilityType;

                if (SYSLOG_PMGR_GetRemoteLogFacility(&remoteLogFacilityType)!=SYSLOG_REMOTE_SUCCESS)
                {
                return SNMP_ERR_GENERR;
                }
                long_return = remoteLogFacilityType;
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
#endif
            }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
        {
            UI32_T remoteLogFacilityType;
            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_WRONGTYPE);
                break;
            }
            remoteLogFacilityType = *requests->requestvb->val.integer;

            if ((remoteLogFacilityType<VAL_remoteLogFacilityType_localUse0)|| (remoteLogFacilityType >VAL_remoteLogFacilityType_localUse7))
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
                break;
            }
        }
        case MODE_SET_RESERVE2:

            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
       {
#if (SYS_CPNT_REMOTELOG_FACILITY_LEVEL_FOR_EVERY_SERVER == FALSE)
            UI32_T remoteLogFacilityType;

            remoteLogFacilityType = *requests->requestvb->val.integer;


            if (SYSLOG_PMGR_SetRemoteLogFacility(remoteLogFacilityType) != SYSLOG_REMOTE_SUCCESS)
             netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
#endif
         }
          break;

        case MODE_SET_COMMIT:

            break;

        case MODE_SET_UNDO:

            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_remoteLogLevel(netsnmp_mib_handler *handler,
                  netsnmp_handler_registration *reginfo,
                  netsnmp_agent_request_info *reqinfo,
                  netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode)
     {



        case MODE_GET:
           {
#if (SYS_CPNT_REMOTELOG_FACILITY_LEVEL_FOR_EVERY_SERVER == FALSE)
            UI32_T remoteLogLevel;

                if (SYSLOG_PMGR_GetRemoteLogLevel(&remoteLogLevel)!=SYSLOG_REMOTE_SUCCESS)
                {
                return SNMP_ERR_GENERR;
                }
                long_return = remoteLogLevel;
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
#endif
            }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
        {
            UI32_T remoteLogLevel;
            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_WRONGTYPE);
                break;
            }
            remoteLogLevel = *requests->requestvb->val.integer;

            if ((remoteLogLevel< MIN_remoteLogLevel) || (remoteLogLevel >MAX_remoteLogLevel))
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
                break;
            }
        }
        case MODE_SET_RESERVE2:

            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
       {
#if (SYS_CPNT_REMOTELOG_FACILITY_LEVEL_FOR_EVERY_SERVER == FALSE)
            UI32_T remoteLogLevel;

            remoteLogLevel = *requests->requestvb->val.integer;


            if (SYSLOG_PMGR_SetRemoteLogLevel(remoteLogLevel) != SYSLOG_REMOTE_SUCCESS)
             netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
#endif
         }
          break;

        case MODE_SET_COMMIT:

            break;

        case MODE_SET_UNDO:

            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

/********************************************
 ***********remoteLogServerInetTable*********
 ********************************************
 */
/* PENDING:
 * This table will go back to this original index
 * as InetAddressType.InetAddress.
 * Use remoteLogServerInetTable in the ASF4612MMS-FLF-08
 * profile to rewrite this table.
 */
#define REMOTE_LOG_SERVER_ADDRESS_TYPE_LEN        1
#define REMOTE_LOG_SERVER_INETENTRY_INSTANCE_LEN  (REMOTE_LOG_SERVER_ADDRESS_TYPE_LEN + SYS_TYPE_IPV6Z_ADDR_LEN)

BOOL_T
remoteLogServerInetTable_OidIndexToData(
    UI32_T exact,
    UI32_T compc,
    oid *  compl,
    UI32_T *addr_type_p,
    UI8_T *addr_p,
    UI32_T *addr_len_p)
{
    UI32_T i = 0;

    if (   (NULL == compl)
        || (NULL == addr_type_p)
        || (NULL == addr_p)
        || (NULL == addr_len_p))
    {
        return FALSE;
    }

    if (   (exact)
        && (   (compc < 1)
            || (compc > REMOTE_LOG_SERVER_INETENTRY_INSTANCE_LEN)
            )
        )
    {
        return FALSE;
    }

    if (0 == compc)
    {
        return TRUE;
    }

    *addr_type_p = compl[0];

    compc = (compc > REMOTE_LOG_SERVER_INETENTRY_INSTANCE_LEN) ? REMOTE_LOG_SERVER_INETENTRY_INSTANCE_LEN : compc;
    *addr_len_p = compc - REMOTE_LOG_SERVER_ADDRESS_TYPE_LEN;

    for (i = 0; i < *addr_len_p; i++)
    {
        addr_p[i] = compl[REMOTE_LOG_SERVER_ADDRESS_TYPE_LEN + i];
    }

    return TRUE;
}

unsigned char *
var_remoteLogServerInetTable(
    struct variable *vp,
    oid     *name,
    size_t  *length,
    int     exact,
    size_t  *var_len,
    WriteMethod **write_method)
{
    UI32_T compc = 0;
    UI32_T i;
    UI32_T type = 0, addr_len = 0, preflen;
    UI8_T addr_ar[SYS_TYPE_IPV6Z_ADDR_LEN] = {0};  /* longest case: IPv6z, with zone ID */
    BOOL_T ret;
    oid compl[REMOTE_LOG_SERVER_INETENTRY_INSTANCE_LEN] = {0};
    oid best_inst[REMOTE_LOG_SERVER_INETENTRY_INSTANCE_LEN] = {0};
    SYSLOG_MGR_Remote_Server_Config_T entry;

    switch (vp->magic)
    {
        case LEAF_remoteLogServerStatus:
            *write_method = write_remoteLogServerStatus;
            break;

        case LEAF_remoteLogServerUdpPort:
            *write_method = write_remoteLogServerUdpPort;
            break;

#if (SYS_CPNT_REMOTELOG_FACILITY_LEVEL_FOR_EVERY_SERVER == TRUE)
        case LEAF_remoteLogServerFacilityType:
            *write_method = write_remoteLogServerFacilityType;
            break;

        case LEAF_remoteLogServerHostLevel:
            *write_method = write_remoteLogServerHostLevel;
            break;
#endif /*end (SYS_CPNT_REMOTELOG_FACILITY_LEVEL_FOR_EVERY_SERVER == TRUE)*/

        default:
            *write_method = 0;
            break;
    }

    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,
                           compl, REMOTE_LOG_SERVER_INETENTRY_INSTANCE_LEN);

    memset(&entry, 0, sizeof(entry));

    if (FALSE == remoteLogServerInetTable_OidIndexToData(exact, compc, compl,
        &type, addr_ar, &addr_len))
    {
        return NULL;
    }

    if (FALSE == SNMP_MGR_ConvertInetAddrAndTypeToLInetAddr(type, addr_len,
        addr_ar, 0, (L_INET_Addr_T *)&entry.ipaddr))
    {
        return NULL;
    }

    if (exact)
    {
        ret = SYSLOG_PMGR_GetRemoteLogServer(&entry);
    }
    else
    {
        ret = SYSLOG_PMGR_GetNextRemoteLogServer(&entry);
    }

    if (ret != SYSLOG_REMOTE_SUCCESS)
    {
        return NULL;
    }

    if (FALSE == SNMP_MGR_ConvertLInetAddrToInetAddrAndType(
        (L_INET_Addr_T *)&entry.ipaddr, &type, &addr_len, addr_ar, &preflen))
    {
        return NULL;
    }

    memcpy(name, vp->name, vp->namelen*sizeof(oid));

    /* assign data to the oid index
     */
    best_inst[0] = type;

    for (i = 0; i < addr_len; i++)
    {
        best_inst[REMOTE_LOG_SERVER_ADDRESS_TYPE_LEN + i] = addr_ar[i];
    }

    memcpy(name + vp->namelen, best_inst,
        (REMOTE_LOG_SERVER_ADDRESS_TYPE_LEN + addr_len) * sizeof(oid));
    *length = vp->namelen + (REMOTE_LOG_SERVER_ADDRESS_TYPE_LEN + addr_len);

    /* this is where we do the value assignments for the mib results.
     */
    switch (vp->magic)
    {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case LEAF_remoteLogServerInetAddressType:
            *var_len = sizeof(long_return);
            long_return = entry.ipaddr.type;
            return (u_char *) &long_return;

        case LEAF_remoteLogServerInetAddress:
            *var_len = entry.ipaddr.addrlen;
            memcpy(return_buf, &entry.ipaddr, *var_len);
            return (u_char*)return_buf;
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

        case LEAF_remoteLogServerStatus:
            *var_len = sizeof(long_return);
            long_return = VAL_remoteLogServerStatus_valid;
            return (u_char *) &long_return;

        case LEAF_remoteLogServerUdpPort:
            *var_len = sizeof(long_return);
            long_return = entry.udp_port;
            return (u_char *) &long_return;

#if (SYS_CPNT_REMOTELOG_FACILITY_LEVEL_FOR_EVERY_SERVER == TRUE)
        case LEAF_remoteLogServerFacilityType:
            *var_len = sizeof(long_return);
            long_return = entry.facility;
            return (u_char *) &long_return;

        case LEAF_remoteLogServerHostLevel:
            *var_len = sizeof(long_return);
            long_return = entry.level;
            return (u_char *) &long_return;
#endif /* #if (SYS_CPNT_REMOTELOG_FACILITY_LEVEL_FOR_EVERY_SERVER == TRUE) */

        default:
            ERROR_MSG("");
    }

    return NULL;
}

int
write_remoteLogServerStatus(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            switch (*(long *)var_val)
            {
                case VAL_remoteLogServerStatus_valid:
                    break;

                case VAL_remoteLogServerStatus_invalid:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
            I32_T value = 0;
            UI32_T type = 0, addr_len = 0;
            UI8_T addr_ar[SYS_TYPE_IPV6Z_ADDR_LEN] = {0};  /* longest case: IPv6z, with zone ID */
            L_INET_AddrIp_T ip_address;

            memset(&ip_address, 0, sizeof(ip_address));
            value = * (long *) var_val;

            if (FALSE == remoteLogServerInetTable_OidIndexToData(TRUE,
                name_len - oid_name_length, &(name[oid_name_length]), &type,
                addr_ar, &addr_len))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            if (FALSE == SNMP_MGR_ConvertInetAddrAndTypeToLInetAddr(type,
                addr_len, addr_ar, 0, (L_INET_Addr_T *)&ip_address))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            /* only support IPv4 and IPv6
             */
            if((ip_address.type==L_INET_ADDR_TYPE_UNKNOWN)||(ip_address.type == L_INET_ADDR_TYPE_DNS))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            if (value == VAL_remoteLogServerStatus_valid)
            {
                if (SYSLOG_PMGR_CreateRemoteLogServer(&ip_address) != SYSLOG_REMOTE_SUCCESS)
                {
                    return SNMP_ERR_COMMITFAILED;
                }
            }
            else
            {
                if (SYSLOG_PMGR_DeleteRemoteLogServer(&ip_address) != SYSLOG_REMOTE_SUCCESS)
                {
                    return SNMP_ERR_COMMITFAILED;
                }
            }
        }
            break;

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

int
write_remoteLogServerUdpPort(
    int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            if (MIN_remoteLogServerUdpPort > *(long *)var_val ||
                *(long *)var_val > MAX_remoteLogServerUdpPort)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
            I32_T value = 0;
            UI32_T type = 0, addr_len = 0, preflen;
            UI8_T addr_ar[SYS_TYPE_IPV6Z_ADDR_LEN] = {0};  /* longest case: IPv6z, with zone ID */
            L_INET_AddrIp_T ip_address;

            memset(&ip_address, 0, sizeof(ip_address));

            if (FALSE == remoteLogServerInetTable_OidIndexToData(TRUE,
                name_len - oid_name_length, &(name[oid_name_length]), &type,
                addr_ar, &addr_len))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            if (FALSE == SNMP_MGR_ConvertInetAddrAndTypeToLInetAddr(type,
                addr_len, addr_ar, 0, (L_INET_Addr_T *)&ip_address))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            if ((ip_address.type == L_INET_ADDR_TYPE_UNKNOWN) || (ip_address.type == L_INET_ADDR_TYPE_DNS))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            value = * (long *) var_val;

            if (SYSLOG_REMOTE_SUCCESS != SYSLOG_PMGR_SetRemoteLogServerPort(&ip_address, value))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}
#if (SYS_CPNT_REMOTELOG_FACILITY_LEVEL_FOR_EVERY_SERVER == TRUE)
int write_remoteLogServerFacilityType(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            switch (*(long *)var_val)
            {
                case VAL_remoteLogFacilityType_localUse0:
                    break;

                case VAL_remoteLogFacilityType_localUse1:
                    break;

                case VAL_remoteLogFacilityType_localUse2:
                    break;

                case VAL_remoteLogFacilityType_localUse3:
                    break;

                case VAL_remoteLogFacilityType_localUse4:
                    break;

                case VAL_remoteLogFacilityType_localUse5:
                    break;

                case VAL_remoteLogFacilityType_localUse6:
                    break;

                case VAL_remoteLogFacilityType_localUse7:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
            I32_T value = 0;
            L_INET_AddrIp_T ip_address;

            memset(&ip_address, 0, sizeof(ip_address));

            if (FALSE == remoteLogServerInetTable_OidIndexToData(name_len - oid_name_length,
                                                                 &(name[oid_name_length]),
                                                                 &ip_address))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            value = * (long *) var_val;

            if (SYSLOG_PMGR_SetRemoteLogServerFacility(&ip_address, value) != TRUE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}
int
write_remoteLogServerHostLevel(
    int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            if (MIN_remoteLogLevel > *(long *)var_val || *(long *)var_val > MAX_remoteLogLevel)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
            I32_T value = 0;
            L_INET_AddrIp_T ip_address;

            memset(&ip_address, 0, sizeof(ip_address));

            if (FALSE == remoteLogServerInetTable_OidIndexToData(name_len - oid_name_length,
                                                                 &(name[oid_name_length]),
                                                                 &ip_address))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            if((ip_address.type==L_INET_ADDR_TYPE_UNKNOWN)||(ip_address.type == L_INET_ADDR_TYPE_DNS))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            value = * (long *) var_val;

            if (SYSLOG_PMGR_SetRemoteLogServerLevel(&ip_address, value) != TRUE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}
#endif /*#if (SYS_CPNT_REMOTELOG_FACILITY_LEVEL_FOR_EVERY_SERVER == TRUE)*/
#endif  /* #if (SYS_CPNT_REMOTELOG == TRUE) */

#if (SYS_CPNT_SMTP == TRUE)
/********************************************
 ***************smtpMgt**********************
 ********************************************
 */
int
do_smtpStatus(netsnmp_mib_handler *handler,
              netsnmp_handler_registration *reginfo,
              netsnmp_agent_request_info *reqinfo,
              netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode)
     {

        case MODE_GET:
           {
               UI32_T smtpStatus;

           if (SMTP_PMGR_GetSmtpAdminStatus(&smtpStatus)!=SMTP_RETURN_SUCCESS)
           {
               return SNMP_ERR_GENERR;
           }

                long_return = smtpStatus;
                if (long_return == SMTP_STATUS_ENABLE)
                {
                    long_return = VAL_smtpStatus_enabled;
                }
                else if (long_return ==SMTP_STATUS_DISABLE )
                {
                    long_return = VAL_smtpStatus_disabled;
                }
                else
                {
                     return SNMP_ERR_GENERR;
                }
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
            }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
        {
            UI32_T smtpStatus;
            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_WRONGTYPE);
                break;
            }
            smtpStatus = (*requests->requestvb->val.integer);
            if ((smtpStatus<VAL_smtpStatus_enabled)  || (smtpStatus>VAL_smtpStatus_disabled))
            {
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_WRONGVALUE);
                break;
            }
        }
        case MODE_SET_RESERVE2:

            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
       {
            UI32_T smtpStatus;

            smtpStatus = *requests->requestvb->val.integer;

            switch(smtpStatus)
            {
                case VAL_smtpStatus_enabled:
                  if (SMTP_PMGR_EnableSmtpAdminStatus()!= SMTP_RETURN_SUCCESS)
                      netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
                break;
                case VAL_smtpStatus_disabled:
                    if (SMTP_PMGR_DisableSmtpAdminStatus()!= SMTP_RETURN_SUCCESS)
                      netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
                break;
                default:
                     netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            }
         }
          break;

        case MODE_SET_COMMIT:

            break;

        case MODE_SET_UNDO:

            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_smtpSeverityLevel(netsnmp_mib_handler *handler,
                     netsnmp_handler_registration *reginfo,
                     netsnmp_agent_request_info *reqinfo,
                     netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode)
     {

        case MODE_GET:
           {
            UI32_T smtpSeverityLevel;
                if (SMTP_PMGR_GetEmailSeverityLevel(&smtpSeverityLevel)!= SMTP_RETURN_SUCCESS)
                {
                    return SNMP_ERR_GENERR;
                }
                long_return = smtpSeverityLevel;
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
            }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
        {
            UI32_T smtpSeverityLevel;
            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_WRONGTYPE);
                break;
            }
            smtpSeverityLevel = (*requests->requestvb->val.integer);
            if ((smtpSeverityLevel<MIN_smtpSeverityLevel)  || (smtpSeverityLevel>MAX_smtpSeverityLevel))
            {
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_WRONGVALUE);
                break;
            }
        }
        case MODE_SET_RESERVE2:

            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
       {
            UI32_T smtpSeverityLevel;

            smtpSeverityLevel = *requests->requestvb->val.integer;


         if (SMTP_PMGR_SetEmailSeverityLevel( smtpSeverityLevel)!= SMTP_RETURN_SUCCESS)
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);

         }
          break;

        case MODE_SET_COMMIT:

            break;

        case MODE_SET_UNDO:

            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}


int
do_smtpSourceEMail(netsnmp_mib_handler *handler,
                   netsnmp_handler_registration *reginfo,
                   netsnmp_agent_request_info *reqinfo,
                   netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
            {

             UI8_T buffer[MAXSIZE_smtpSourceEMail+1];

              if (SMTP_PMGR_GetSmtpSourceEmailAddr(buffer)!= SMTP_RETURN_SUCCESS)
                       return SNMP_ERR_GENERR;
                 strcpy( (char *)return_buf, (char *)buffer);
               snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, (u_char *) return_buf, strlen((char *)return_buf));
           }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            if (requests->requestvb->type != ASN_OCTET_STR)
            {
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_WRONGTYPE);
                break;
            }
            if ((requests->requestvb->val_len<MINSIZE_smtpSourceEMail)  ||    (requests->requestvb->val_len>MAXSIZE_smtpSourceEMail))
            {
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_WRONGLENGTH);
                break;
            }

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */

            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
           {
               UI8_T  buffer[MAXSIZE_smtpSourceEMail+1];
               memcpy(buffer, requests->requestvb->val.string, requests->requestvb->val_len);
               buffer[requests->requestvb->val_len]= '\0';
                  if (SMTP_PMGR_SetSmtpSourceEmailAddr(buffer)!= SMTP_RETURN_SUCCESS)
                  netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */

            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */

            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

/********************************************
 ***************smtpServerIpTable************
 ********************************************
 */
#define SMTPSERVERIPENTRY_INSTANCE_LEN  4

BOOL_T smtpServerIpTable_OidIndexToData(UI32_T exact, UI32_T compc,
            oid * compl,  UI32_T *smtpServerIp)
{
    if (exact)
    {
        if (compc != SMTPSERVERIPENTRY_INSTANCE_LEN)
        {
            return FALSE;
        }
    }

    if (SNMP_MGR_ReadIpFromCompl(compl, 0, smtpServerIp) != TRUE)
    {
        return FALSE;
    }

    return TRUE;
}

/*
 * var_smtpServerIpTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *
var_smtpServerIpTable(struct variable *vp,
            oid     *name,
            size_t  *length,
            int     exact,
            size_t  *var_len,
            WriteMethod **write_method)
{
    UI32_T compc = 0;
    oid compl[SMTPSERVERIPENTRY_INSTANCE_LEN] = {0};
    oid best_inst[SMTPSERVERIPENTRY_INSTANCE_LEN] = {0};
    UI32_T ip_addr;

    switch (vp->magic)
    {
        case LEAF_smtpServerIpStatus:
            *write_method = write_smtpServerIpStatus;
            break;

        default:
            *write_method = 0;
            break;
    }

    /* check compc, retrive compl */
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,
                           compl, SMTPSERVERIPENTRY_INSTANCE_LEN);

    if (exact) /* get,set */
    {
        /* get index */
        if (smtpServerIpTable_OidIndexToData(exact, compc, compl, &ip_addr) == FALSE)
        {
            return NULL;
        }

        /* get data */
        if (SMTP_PMGR_GetSmtpServerIPAddr(&ip_addr) != SMTP_RETURN_SUCCESS)
        {
            return NULL;
        }
    }
    else /* getnext */
    {
        /* get index */
        smtpServerIpTable_OidIndexToData(exact, compc, compl, &ip_addr);

        /* check the length of inputing index,if < 1 we should try get
         * {0.0.0.0.0...}
         */
        if (compc < 1)
        {
            /* get data */
            if (SMTP_PMGR_GetSmtpServerIPAddr(&ip_addr) != SMTP_RETURN_SUCCESS)
            {
                /* get next data */
                if (SMTP_PMGR_GetNextSmtpServerIPAddr(&ip_addr) != SMTP_RETURN_SUCCESS)
                {
                    return NULL;
                }
            }
        }
        else
        {
            /* get next data */
            if (SMTP_PMGR_GetNextSmtpServerIPAddr(&ip_addr) != SMTP_RETURN_SUCCESS)
            {
                return NULL;
            }
        }
    }

    memcpy(name, vp->name, vp->namelen*sizeof(oid));

    best_inst[0] = *((UI8_T *)&ip_addr);
    best_inst[1] = *((UI8_T *)&ip_addr + 1);
    best_inst[2] = *((UI8_T *)&ip_addr + 2);
    best_inst[3] = *((UI8_T *)&ip_addr + 3);
    memcpy(name + vp->namelen, best_inst,
           SMTPSERVERIPENTRY_INSTANCE_LEN * sizeof(oid));
    *length = vp->namelen + SMTPSERVERIPENTRY_INSTANCE_LEN ;

    switch (vp->magic)
    {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case LEAF_smtpServerIp:
            *var_len = sizeof(ipaddr_return);
            ipaddr_return = ip_addr;
            return (u_char *) &ipaddr_return;
#endif

        case LEAF_smtpServerIpStatus:
            *var_len = sizeof(long_return);
            long_return = VAL_smtpServerIpStatus_valid;
            return (u_char *) &long_return;

        default:
            ERROR_MSG("");
    }

    return NULL;
}


int
write_smtpServerIpStatus(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            switch (*(long *)var_val)
            {
                case VAL_smtpServerIpStatus_valid:
                    break;

                case VAL_smtpServerIpStatus_invalid:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
            I32_T value = * (long *) var_val;
            UI32_T smtpServerIp = 0;

            if (smtpServerIpTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]),  &smtpServerIp) == FALSE)
                return SNMP_ERR_COMMITFAILED;

            switch(value)
            {
                case VAL_smtpServerIpStatus_valid:

                    if (SMTP_PMGR_AddSmtpServerIPAddr(smtpServerIp) != SMTP_RETURN_SUCCESS)
                    {
                        return SNMP_ERR_COMMITFAILED;
                    }
                    break;

                case VAL_smtpServerIpStatus_invalid:

                    if ( SMTP_PMGR_DeleteSmtpServerIPAddr(smtpServerIp)!= SMTP_RETURN_SUCCESS)
                    {
                        return SNMP_ERR_COMMITFAILED;
                    }
                    break;
            }
        }
            break;

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

/********************************************
 ***************smtpDestEMailTable************
 ********************************************
 */
#define SMTPDESTEMAILENTRY_INSTANCE_LEN  42

BOOL_T smtpDestEMailTable_OidIndexToData(UI32_T exact, UI32_T compc,
            oid * compl,  UI8_T *smtpDestEMail)
{
    int i;

    if (exact)
    {
        if (compc < 2  || compc > SMTPDESTEMAILENTRY_INSTANCE_LEN)
        {
            return FALSE;
        }
    }

    if ((compl[0] < MINSIZE_smtpDestEMail) ||
        (compl[0] > MAXSIZE_smtpDestEMail ))
    {
        return FALSE;
    }

    for (i = 0; i < compl[0]; i++)
    {
        smtpDestEMail[i] = compl[1 + i];
    }
    smtpDestEMail[compl[0]] = '\0';

    return TRUE;
}

/*
 * var_smtpDestEMailTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *
var_smtpDestEMailTable(struct variable *vp,
            oid     *name,
            size_t  *length,
            int     exact,
            size_t  *var_len,
            WriteMethod **write_method)
{
    UI32_T compc = 0;
    oid compl[SMTPDESTEMAILENTRY_INSTANCE_LEN] = {0};
    oid best_inst[SMTPDESTEMAILENTRY_INSTANCE_LEN] = {0};
    UI8_T smtp_mail[MAXSIZE_smtpDestEMail+1] = {0};
    int i;

    switch (vp->magic)
    {
        case LEAF_smtpDestEMailStatus:
            *write_method = write_smtpDestEMailStatus;
            break;

        default:
            *write_method = 0;
            break;
    }

    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,
                           compl, SMTPDESTEMAILENTRY_INSTANCE_LEN);

    if (exact) /* get,set */
    {
        /* get index */
        if (smtpDestEMailTable_OidIndexToData(exact, compc, compl, smtp_mail) == FALSE)
        {
            return NULL;
        }

        /* get data */
        if (SMTP_PMGR_GetSmtpDestinationEmailAddr(smtp_mail) != SMTP_RETURN_SUCCESS)
        {
            return NULL;
        }
    }
    else /* getnext */
    {
        /* get index */
        smtpDestEMailTable_OidIndexToData(exact, compc, compl, smtp_mail);

        /* check the length of inputing index,if < 1 we should try get
         * {0.0.0.0.0...}
         */
        if (compc < 1)
        {
            /* get data */
            if (SMTP_PMGR_GetSmtpDestinationEmailAddr(smtp_mail) != SMTP_RETURN_SUCCESS)
            {
                /* get next data */
                if (SMTP_PMGR_GetNextSmtpDestinationEmailAddr(smtp_mail) != SMTP_RETURN_SUCCESS)
                {
                    return NULL;
                }
            }
        }
        else
        {
            /* get next data */
            if (SMTP_PMGR_GetNextSmtpDestinationEmailAddr(smtp_mail) != SMTP_RETURN_SUCCESS)
            {
                return NULL;
            }
        }
    }

    memcpy(name, vp->name, vp->namelen*sizeof(oid));

    best_inst[0] = strlen((char *)smtp_mail);

    for (i = 0; i < best_inst[0]; i++)
    {
        best_inst[1 + i] = smtp_mail[i];
    }
    memcpy(name + vp->namelen, best_inst,
           (1+best_inst[0]) * sizeof(oid));
    *length = vp->namelen + 1+best_inst[0] ;

    switch (vp->magic)
    {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case LEAF_smtpDestEMail:
            *var_len  =   strlen(smtp_mail);
            memcpy(return_buf, smtp_mail, *var_len);
            return (u_char*)return_buf;

#endif
        case LEAF_smtpDestEMailStatus:
            *var_len = sizeof(long_return);
            long_return = VAL_smtpDestEMailStatus_valid;
            return (u_char *) &long_return;

        default:
            ERROR_MSG("");
    }

    return NULL;
}

int
write_smtpDestEMailStatus(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            switch (*(long *)var_val)
            {
                case VAL_smtpDestEMailStatus_valid:
                    break;

                case VAL_smtpDestEMailStatus_invalid:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
            I32_T value = * (long *) var_val;
            UI8_T smtpDestEMail[MAXSIZE_smtpDestEMail+1] = {0};

            if (smtpDestEMailTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]),  smtpDestEMail) == FALSE)
                return SNMP_ERR_COMMITFAILED;

            switch(value)
            {
                case VAL_smtpDestEMailStatus_valid:

                    if (SMTP_PMGR_AddSmtpDestinationEmailAddr(smtpDestEMail) != SMTP_RETURN_SUCCESS)
                    {
                        return SNMP_ERR_COMMITFAILED;
                    }
                    break;

                case VAL_smtpServerIpStatus_invalid:

                    if ( SMTP_PMGR_DeleteSmtpDestinationEmailAddr(smtpDestEMail)!= SMTP_RETURN_SUCCESS)
                    {
                        return SNMP_ERR_COMMITFAILED;
                    }
                break;
            }
        }
            break;

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}


#endif

/********************************************
 ***************consoleMgt*******************
 ********************************************
 */
int
do_consoleStopBits(netsnmp_mib_handler *handler,
                   netsnmp_handler_registration *reginfo,
                   netsnmp_agent_request_info *reqinfo,
                   netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode)
     {

        case MODE_GET:
           {
                SYS_MGR_Uart_Cfg_T entry;

                memset(&entry, 0, sizeof(entry));

                if (!SYS_PMGR_GetUartParameters(&entry))
                {
                     return SNMP_ERR_GENERR;
                }
                long_return = entry.stop_bits;
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
            }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
             {
                UI32_T consoleStopBits;
                consoleStopBits = (*requests->requestvb->val.integer);
                if (requests->requestvb->type != ASN_INTEGER)
                {
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
                break;
                }
                if ((consoleStopBits<VAL_consoleStopBits_stopbits1)  || (consoleStopBits>VAL_consoleStopBits_stopbits2))
                    netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_WRONGVALUE);
              }
            break;

        case MODE_SET_RESERVE2:

            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
       {
             SYS_MGR_Uart_Stop_Bits_T consoleStopBits;

            consoleStopBits = *requests->requestvb->val.integer;


         if (SYS_PMGR_SetUartStopBits( consoleStopBits)!= TRUE)
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);

         }
          break;

        case MODE_SET_COMMIT:

            break;

        case MODE_SET_UNDO:

            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_consoleParity(netsnmp_mib_handler *handler,
                 netsnmp_handler_registration *reginfo,
                 netsnmp_agent_request_info *reqinfo,
                 netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode)
     {

        case MODE_GET:
           {
                SYS_MGR_Uart_Cfg_T entry;

                memset(&entry, 0, sizeof(entry));

                if (!SYS_PMGR_GetUartParameters(&entry))
                {
                     return SNMP_ERR_GENERR;
                }
                switch (entry.parity)
                {
                    case SYS_MGR_UART_PARITY_NONE:
                        entry.parity = VAL_consoleParity_partyNone;
                    break;
                    case SYS_MGR_UART_PARITY_EVEN:
                         entry.parity = VAL_consoleParity_partyEven;
                    break;
                    case SYS_MGR_UART_PARITY_ODD:
                         entry.parity = VAL_consoleParity_partyOdd;
                    break;
                    default:
                         entry.parity = VAL_consoleParity_partyNone;
                    break;
                }
                long_return = entry.parity;
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
            }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
             {
                UI32_T consoleParity;
                consoleParity = (*requests->requestvb->val.integer);
                if (requests->requestvb->type != ASN_INTEGER)
                {
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
                break;
                }
                if ((consoleParity<VAL_consoleParity_partyNone)  || (consoleParity>VAL_consoleParity_partyOdd))
                    netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_WRONGVALUE);
              }
            break;

        case MODE_SET_RESERVE2:

            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
       {
             UI32_T consoleParity;

             consoleParity = *requests->requestvb->val.integer;

             switch(consoleParity)
             {
             case VAL_consoleParity_partyNone:
                consoleParity = SYS_MGR_UART_PARITY_NONE;
             break;
             case VAL_consoleParity_partyEven:
                consoleParity = SYS_MGR_UART_PARITY_EVEN;
             break;
             case VAL_consoleParity_partyOdd:
                consoleParity = SYS_MGR_UART_PARITY_ODD;
             break;
             }
            if (SYS_PMGR_SetUartParity( consoleParity)!= TRUE)
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);

         }
          break;

        case MODE_SET_COMMIT:

            break;

        case MODE_SET_UNDO:

            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_consolePasswordThreshold(netsnmp_mib_handler *handler,
                            netsnmp_handler_registration *reginfo,
                            netsnmp_agent_request_info *reqinfo,
                            netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode)
     {

        case MODE_GET:
           {
                 SYS_MGR_Console_T  console_entry;

                 memset(&console_entry, 0, sizeof(console_entry));

                if (!SYS_PMGR_GetConsoleCfg(&console_entry))
                {
                     return SNMP_ERR_GENERR;
                }
                long_return = console_entry.password_threshold;
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
            }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            {
                UI32_T consolePasswordThreshold;
                consolePasswordThreshold = (*requests->requestvb->val.integer);

                if (requests->requestvb->type != ASN_INTEGER)
                {
                    netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
                }

                if ((consolePasswordThreshold != SYSMGMT_TYPE_PASSWORD_THRESHOLD_DISABLED) &&
                    ((consolePasswordThreshold < SYS_ADPT_SYSMGR_CONSOLE_PASSWORD_THRESHOLD_MIN) ||
                     (consolePasswordThreshold > SYS_ADPT_SYSMGR_CONSOLE_PASSWORD_THRESHOLD_MAX)))
                {
                    netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_WRONGVALUE);
                }
            }
            break;

        case MODE_SET_RESERVE2:

            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
       {
             UI32_T consolePasswordThreshold;

            consolePasswordThreshold = *requests->requestvb->val.integer;


         if (SYS_PMGR_SetPasswordThreshold( consolePasswordThreshold)!= TRUE)
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);

         }
          break;

        case MODE_SET_COMMIT:

            break;

        case MODE_SET_UNDO:

            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

#if (SYS_CPNT_AUTOBAUDRATE == TRUE)
int
do_consoleAdminBaudRate(netsnmp_mib_handler *handler,
                   netsnmp_handler_registration *reginfo,
                   netsnmp_agent_request_info *reqinfo,
                   netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode)
     {

        case MODE_GET:
           {
                SYS_MGR_Uart_Cfg_T entry;

                memset(&entry, 0, sizeof(entry));

                if (!SYS_PMGR_GetUartParameters(&entry))
                {
                     return SNMP_ERR_GENERR;
                }
                long_return = entry.baudrate;
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
            }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
        {
             UI32_T consoleAdminBaudRate;

             consoleAdminBaudRate = *requests->requestvb->val.integer;
             if (requests->requestvb->type != ASN_INTEGER)
             {
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
                break;
             }

             if (((consoleAdminBaudRate < SYS_ADPT_MIN_UART_BAUDRATE) ||
                  (consoleAdminBaudRate > SYS_ADPT_MAX_UART_BAUDRATE)) &&
                 (consoleAdminBaudRate != 0))
                 return SNMP_ERR_WRONGVALUE;

             switch(consoleAdminBaudRate)
             {
                 case SYS_MGR_UART_BAUDRATE_AUTO :
                 case SYS_MGR_UART_BAUDRATE_1200:
                 case SYS_MGR_UART_BAUDRATE_2400:
                 case SYS_MGR_UART_BAUDRATE_4800:
                 case SYS_MGR_UART_BAUDRATE_9600:
                 case SYS_MGR_UART_BAUDRATE_19200:
                 case SYS_MGR_UART_BAUDRATE_38400:
                 case SYS_MGR_UART_BAUDRATE_57600:
                 case SYS_MGR_UART_BAUDRATE_115200:
                      break;

                 default:
                      return SNMP_ERR_WRONGVALUE;
             }
             break;
        }
        case MODE_SET_RESERVE2:

            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

         case MODE_SET_ACTION:
       {
             UI32_T consoleAdminBaudRate;

             consoleAdminBaudRate = *requests->requestvb->val.integer;


            if (SYS_PMGR_SetUartBaudrate( consoleAdminBaudRate)!= TRUE)
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);

         }
          break;

        case MODE_SET_COMMIT:

            break;

        case MODE_SET_UNDO:

            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_consoleOperBaudRate(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
        {

         SYS_MGR_Uart_BaudRate_T operbaudrate;
         if (SYS_PMGR_GetUartOperBaudrate(&operbaudrate)!=TRUE)
         {
             return SNMP_ERR_GENERR;
         }
         long_return = operbaudrate;
         snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));

         }
            break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

#else
int
do_consoleBaudRate(netsnmp_mib_handler *handler,
                   netsnmp_handler_registration *reginfo,
                   netsnmp_agent_request_info *reqinfo,
                   netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode)
     {

        case MODE_GET:
           {
                SYS_MGR_Uart_Cfg_T entry;

                memset(&entry, 0, sizeof(entry));

                if (!SYS_PMGR_GetUartParameters(&entry))
                {
                     return SNMP_ERR_GENERR;
                }
                if (entry.baudrate == SYS_MGR_UART_BAUDRATE_9600)
                  entry.baudrate = VAL_consoleBaudRate_baudRate9600;
                if (entry.baudrate == SYS_MGR_UART_BAUDRATE_19200)
                  entry.baudrate = VAL_consoleBaudRate_baudRate19200;
                if (entry.baudrate == SYS_MGR_UART_BAUDRATE_38400)
                  entry.baudrate = VAL_consoleBaudRate_baudRate38400;
                if (entry.baudrate == SYS_MGR_UART_BAUDRATE_57600)
                   entry.baudrate = VAL_consoleBaudRate_baudRate57600;
                if (entry.baudrate == SYS_MGR_UART_BAUDRATE_115200)
                   entry.baudrate = VAL_consoleBaudRate_baudRate115200;
                long_return = entry.baudrate;
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
            }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            if (requests->requestvb->type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }

            switch (*requests->requestvb->val.integer)
            {
                case VAL_consoleBaudRate_baudRate9600:
                case VAL_consoleBaudRate_baudRate19200:
                case VAL_consoleBaudRate_baudRate38400:
                case VAL_consoleBaudRate_baudRate57600:
                case VAL_consoleBaudRate_baudRate115200:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case MODE_SET_RESERVE2:

            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

         case MODE_SET_ACTION:
       {
             UI32_T consoleBaudRate;

             consoleBaudRate = *requests->requestvb->val.integer;

             switch(consoleBaudRate)
             {
             case VAL_consoleBaudRate_baudRate9600:
                consoleBaudRate = SYS_MGR_UART_BAUDRATE_9600;
             break;
             case VAL_consoleBaudRate_baudRate19200:
                consoleBaudRate = SYS_MGR_UART_BAUDRATE_19200;
             break;
             case VAL_consoleBaudRate_baudRate38400:
                consoleBaudRate = SYS_MGR_UART_BAUDRATE_38400;
             break;
             case VAL_consoleBaudRate_baudRate57600:
                consoleBaudRate = SYS_MGR_UART_BAUDRATE_57600;
             break;
             case VAL_consoleBaudRate_baudRate115200:
                consoleBaudRate = SYS_MGR_UART_BAUDRATE_115200;
             break;

             }
            if (SYS_PMGR_SetUartBaudrate( consoleBaudRate)!= TRUE)
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);

         }
          break;

        case MODE_SET_COMMIT:

            break;

        case MODE_SET_UNDO:

            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
#endif

int
do_consoleDataBits(netsnmp_mib_handler *handler,
                   netsnmp_handler_registration *reginfo,
                   netsnmp_agent_request_info *reqinfo,
                   netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode)
     {

        case MODE_GET:
           {
                SYS_MGR_Uart_Cfg_T entry;

                memset(&entry, 0, sizeof(entry));

                if (!SYS_PMGR_GetUartParameters(&entry))
                {
                     return SNMP_ERR_GENERR;
                }
                if (entry.data_length == SYS_MGR_UART_DATA_LENGTH_7_BITS)
                   entry.data_length = VAL_consoleDataBits_databits7;
                if (entry.data_length == SYS_MGR_UART_DATA_LENGTH_8_BITS)
                   entry.data_length = VAL_consoleDataBits_databits8;
                long_return = entry.data_length;
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
            }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
             {
                UI32_T consoleDataBits;
                consoleDataBits = (*requests->requestvb->val.integer);
                if (requests->requestvb->type != ASN_INTEGER)
                {
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
                break;
                }
                if ((consoleDataBits<VAL_consoleDataBits_databits7)  || (consoleDataBits>VAL_consoleDataBits_databits8))
                    netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_WRONGVALUE);
              }
            break;

        case MODE_SET_RESERVE2:

            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

         case MODE_SET_ACTION:
       {
             UI32_T consoleDataBits;

             consoleDataBits = *requests->requestvb->val.integer;

             switch(consoleDataBits)
             {
             case VAL_consoleDataBits_databits7:
                consoleDataBits = SYS_MGR_UART_DATA_LENGTH_7_BITS;
             break;
             case VAL_consoleDataBits_databits8:
                consoleDataBits = SYS_MGR_UART_DATA_LENGTH_8_BITS;
             break;
             }
            if (SYS_PMGR_SetUartDataBits( consoleDataBits)!= TRUE)
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);

         }
          break;

        case MODE_SET_COMMIT:

            break;

        case MODE_SET_UNDO:

            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_consoleExecTimeout(netsnmp_mib_handler *handler,
                      netsnmp_handler_registration *reginfo,
                      netsnmp_agent_request_info *reqinfo,
                      netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode)
     {

        case MODE_GET:
           {
                 SYS_MGR_Console_T  console_entry;

                 memset(&console_entry, 0, sizeof(console_entry));

                if (!SYS_PMGR_GetConsoleCfg(&console_entry))
                {
                     return SNMP_ERR_GENERR;
                }
                long_return = console_entry.exec_timeout;
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
            }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            {
                UI32_T consoleExecTimeout;
                consoleExecTimeout = (*requests->requestvb->val.integer);

                if (requests->requestvb->type != ASN_INTEGER)
                {
                    netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
                }

                if ((consoleExecTimeout != SYSMGMT_TYPE_EXEC_TIMEOUT_DISABLED) &&
                    ((consoleExecTimeout < SYS_ADPT_SYSMGR_CONSOLE_EXEC_TIMEOUT_MIN) ||
                     (consoleExecTimeout > SYS_ADPT_SYSMGR_CONSOLE_EXEC_TIMEOUT_MAX)))
                {
                    netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
                }
            }
            break;

        case MODE_SET_RESERVE2:

            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
       {
             UI32_T consoleExecTimeout;

            consoleExecTimeout = *requests->requestvb->val.integer;


         if (SYS_PMGR_SetConsoleExecTimeOut( consoleExecTimeout)!= TRUE)
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);

         }
          break;

        case MODE_SET_COMMIT:

            break;

        case MODE_SET_UNDO:

            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_consoleSilentTime(netsnmp_mib_handler *handler,
                     netsnmp_handler_registration *reginfo,
                     netsnmp_agent_request_info *reqinfo,
                     netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode)
     {

        case MODE_GET:
           {
                 SYS_MGR_Console_T  console_entry;

                 memset(&console_entry, 0, sizeof(console_entry));

                if (!SYS_PMGR_GetConsoleCfg(&console_entry))
                {
                     return SNMP_ERR_GENERR;
                }
                long_return = console_entry.silent_time;
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
            }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            {
                UI32_T consoleSilentTime;
                consoleSilentTime = (*requests->requestvb->val.integer);

                if (requests->requestvb->type != ASN_INTEGER)
                {
                    netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
                }

                if ((consoleSilentTime != SYSMGMT_TYPE_SILENT_TIME_DISABLED) &&
                    ((consoleSilentTime < SYS_ADPT_SYSMGR_CONSOLE_SILENT_TIME_MIN) ||
                     (consoleSilentTime > SYS_ADPT_SYSMGR_CONSOLE_SILENT_TIME_MAX)))
                {
                    netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_WRONGVALUE);
                }
            }
            break;

        case MODE_SET_RESERVE2:

            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
       {
             UI32_T consoleSilentTime;

            consoleSilentTime = *requests->requestvb->val.integer;


         if (SYS_PMGR_SetConsoleSilentTime( consoleSilentTime)!= TRUE)
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);

         }
          break;

        case MODE_SET_COMMIT:

            break;

        case MODE_SET_UNDO:

            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_consoleLoginResponseTimeout(netsnmp_mib_handler *handler,
                               netsnmp_handler_registration *reginfo,
                               netsnmp_agent_request_info *reqinfo,
                               netsnmp_request_info *requests)
{
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one.
     */

    switch (reqinfo->mode) {

    case MODE_GET:
    {
        SYS_MGR_Console_T  entry;
        if (SYS_PMGR_GetConsoleCfg(&entry))
        {
            long_return=entry.login_timeout;
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *)&long_return,sizeof(long_return));
        }
        else
        {
            if(SNMP_MGR_IsDebugMode())
                SYSFUN_Debug_Printf("do_consoleLoginResponseTimeout:SYS_MGR_GetConsoleCfg return false\n");
            return SNMP_ERR_GENERR;
        }
        break;
     }
        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
    case MODE_SET_RESERVE1:
    {
        UI32_T value;
        value = *requests->requestvb->val.integer;

        if (requests->requestvb->type != ASN_INTEGER)
        {
            netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
        }

        if ((value < SYS_ADPT_SYSMGR_CONSOLE_LOGIN_RESPONSE_TIMEOUT_MIN) ||
            (value > SYS_ADPT_SYSMGR_CONSOLE_LOGIN_RESPONSE_TIMEOUT_MAX))
        {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
        }
        break;
    }
    case MODE_SET_RESERVE2:
        /*
         * XXX malloc "undo" storage buffer
         */
        break;

    case MODE_SET_FREE:
        /*
         * XXX: free resources allocated in RESERVE1 and/or
         * RESERVE2.  Something failed somewhere, and the states
         * below won't be called.
         */
        break;

    case MODE_SET_ACTION:
    {
       /*
        * XXX: perform the value change here
        */
       UI32_T value;
       value = *requests->requestvb->val.integer;
       if(SNMP_MGR_IsDebugMode())
          SYSFUN_Debug_Printf("do_consoleLoginResponseTimeout:value=[%lu]\n", value);
       if (!SYS_PMGR_SetConsoleLoginTimeOut(value))
       {
           netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
           if(SNMP_MGR_IsDebugMode())
                SYSFUN_Debug_Printf("do_consoleLoginResponseTimeout:SYS_MGR_SetConsoleLoginTimeOut return false\n");
       }
       break;
     }
    case MODE_SET_COMMIT:
        /*
         * XXX: delete temporary storage
         */
        break;

    case MODE_SET_UNDO:
        /*
         * XXX: UNDO and return to previous value for the object
         */
        break;

    default:
        /*
         * we should never get here, so this is a really bad error
         */
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

#if (SYS_CPNT_TELNET == TRUE)
/********************************************
 ***************telnetMgt********************
 ********************************************
 */
int do_telnetPortNumber(netsnmp_mib_handler          *handler,
                        netsnmp_handler_registration *reginfo,
                        netsnmp_agent_request_info   *reqinfo,
                        netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    UI32_T telnetPort;

    switch(reqinfo->mode)
    {
        case MODE_GET:
            if (!TELNET_PMGR_GetTnpdPort(&telnetPort))
            {
                 return SNMP_ERR_GENERR;
            }

            long_return = telnetPort;
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
            break;

        case MODE_SET_RESERVE1:
            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
            }
            break;

        case MODE_SET_RESERVE2:

            if (*requests->requestvb->val.integer < MIN_telnetPortNumber ||
                *requests->requestvb->val.integer > MAX_telnetPortNumber)
            {
               netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            }
            break;

        case MODE_SET_FREE:
            break;

        case MODE_SET_ACTION:
            telnetPort = *requests->requestvb->val.integer;
            if (!TELNET_PMGR_SetTnpdPort(telnetPort))
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            break;

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int do_telnetStatus(netsnmp_mib_handler          *handler,
                    netsnmp_handler_registration *reginfo,
                    netsnmp_agent_request_info   *reqinfo,
                    netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    TELNET_State_T telnetStatus;

    switch(reqinfo->mode)
    {
        case MODE_GET:
            if (!TELNET_PMGR_GetTnpdStatus(&telnetStatus))
            {
                 return SNMP_ERR_GENERR;
            }

            long_return = telnetStatus;
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
            break;

        case MODE_SET_RESERVE1:
            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
            }
            break;

        case MODE_SET_RESERVE2:
            switch (*requests->requestvb->val.integer)
            {
                case VAL_telnetStatus_enabled:
                    break;

                case VAL_telnetStatus_disabled:
                    break;

                default:
                    netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            }
            break;

        case MODE_SET_FREE:
            break;

        case MODE_SET_ACTION:
            telnetStatus = *requests->requestvb->val.integer;
            if (!TELNET_PMGR_SetTnpdStatus(telnetStatus))
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            break;

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
#endif /* #if (SYS_CPNT_TELNET == TRUE) */

/********************************************
 ***************vtyMgt***********************
 ********************************************
 */
int do_vtyExecTimeout(netsnmp_mib_handler *handler,
                     netsnmp_handler_registration *reginfo,
                     netsnmp_agent_request_info *reqinfo,
                     netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode)
     {

        case MODE_GET:
           {
               SYS_MGR_Telnet_T entry;

                if (SYS_PMGR_GetTelnetCfg(&entry)!= TRUE)
                {
                     return SNMP_ERR_GENERR;
                }
                long_return = entry.exec_timeout;
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
            }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
            }
            break;

        case MODE_SET_RESERVE2:

            if ((*requests->requestvb->val.integer < SYS_ADPT_SYSMGR_TELNET_EXEC_TIMEOUT_MIN) ||
                (*requests->requestvb->val.integer > SYS_ADPT_SYSMGR_TELNET_EXEC_TIMEOUT_MAX))
            {
               netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
       {
             UI32_T telnetExecTimeout;

            telnetExecTimeout = *requests->requestvb->val.integer;


         if (SYS_PMGR_SetTelnetExecTimeOut( telnetExecTimeout)!= TRUE)
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);

         }
          break;

        case MODE_SET_COMMIT:

            break;

        case MODE_SET_UNDO:

            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_vtyPasswordThreshold(netsnmp_mib_handler *handler,
                           netsnmp_handler_registration *reginfo,
                           netsnmp_agent_request_info *reqinfo,
                           netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode)
     {

        case MODE_GET:
           {
               SYS_MGR_Telnet_T entry;

                if (SYS_PMGR_GetTelnetCfg(&entry)!= TRUE)
                {
                     return SNMP_ERR_GENERR;
                }
                long_return = entry.password_threshold;
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
            }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
            }
            break;

        case MODE_SET_RESERVE2:

            if ((*requests->requestvb->val.integer != SYSMGMT_TYPE_PASSWORD_THRESHOLD_DISABLED) &&
                ((*requests->requestvb->val.integer < SYS_ADPT_SYSMGR_TELNET_PASSWORD_THRESHOLD_MIN) ||
                 (*requests->requestvb->val.integer > SYS_ADPT_SYSMGR_TELNET_PASSWORD_THRESHOLD_MAX)))
            {
               netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
       {
             UI32_T telnetPasswordThreshold;

            telnetPasswordThreshold = *requests->requestvb->val.integer;


         if (SYS_PMGR_SetTelnetPasswordThreshold( telnetPasswordThreshold)!= TRUE)
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);

         }
          break;

        case MODE_SET_COMMIT:

            break;

        case MODE_SET_UNDO:

            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_vtyLoginResponseTimeout(netsnmp_mib_handler *handler,
                              netsnmp_handler_registration *reginfo,
                              netsnmp_agent_request_info *reqinfo,
                              netsnmp_request_info *requests)
{
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one.
     */

    switch (reqinfo->mode) {

    case MODE_GET:
    {
        SYS_MGR_Telnet_T entry;
        if (SYS_PMGR_GetTelnetCfg(&entry))
        {
            long_return=entry.login_timeout;
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *)&long_return,sizeof(long_return));
        }
        else
        {
            if(SNMP_MGR_IsDebugMode())
                SYSFUN_Debug_Printf("do_telnetLoginResponseTimeout:SYS_MGR_GetTelnetCfg return false\n");
            return SNMP_ERR_GENERR;
        }
        break;
     }
        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
            }
            break;

        case MODE_SET_RESERVE2:
            if ((*requests->requestvb->val.integer < SYS_ADPT_SYSMGR_TELNET_LOGIN_RESPONSE_TIMEOUT_MIN) ||
                (*requests->requestvb->val.integer > SYS_ADPT_SYSMGR_TELNET_LOGIN_RESPONSE_TIMEOUT_MAX))
            {
               netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            }
            break;

    case MODE_SET_FREE:
        /*
         * XXX: free resources allocated in RESERVE1 and/or
         * RESERVE2.  Something failed somewhere, and the states
         * below won't be called.
         */
        break;

    case MODE_SET_ACTION:
    {
       UI32_T value;
       value = *requests->requestvb->val.integer;
       if(SNMP_MGR_IsDebugMode())
          SYSFUN_Debug_Printf("do_telnetLoginResponseTimeout:value=[%lu]\n", value);
       if (!SYS_PMGR_SetTelnetLoginTimeOut(value))
       {
           netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
           if(SNMP_MGR_IsDebugMode())
                SYSFUN_Debug_Printf("do_telnetLoginResponseTimeout:SYS_MGR_SetTelnetLoginTimeOut return false\n");
       }
       break;
     }
    case MODE_SET_COMMIT:
        /*
         * XXX: delete temporary storage
         */
        break;
    case MODE_SET_UNDO:
        /*
         * XXX: UNDO and return to previous value for the object
         */
        break;

    default:
        /*
         * we should never get here, so this is a really bad error
         */
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int do_vtyMaxSession(netsnmp_mib_handler          *handler,
                        netsnmp_handler_registration *reginfo,
                        netsnmp_agent_request_info   *reqinfo,
                        netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    UI32_T telnetMaxSession;

    switch(reqinfo->mode)
    {
        case MODE_GET:
            if (!TELNET_PMGR_GetTnpdMaxSession(&telnetMaxSession))
            {
                 return SNMP_ERR_GENERR;
            }
            long_return = telnetMaxSession;
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
            break;

        case MODE_SET_RESERVE1:
            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
            }
            break;

        case MODE_SET_RESERVE2:

            if (*requests->requestvb->val.integer < MIN_vtyMaxSession ||
                *requests->requestvb->val.integer > SYS_ADPT_MAX_TELNET_NUM)
            {
               netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            }
            break;

        case MODE_SET_FREE:
            break;

        case MODE_SET_ACTION:
            telnetMaxSession = *requests->requestvb->val.integer;
            if (!TELNET_PMGR_SetTnpdMaxSession(telnetMaxSession))
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            break;

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int do_vtySilentTime(netsnmp_mib_handler *handler,
                    netsnmp_handler_registration *reginfo,
                    netsnmp_agent_request_info   *reqinfo,
                    netsnmp_request_info         *requests)
{
    switch(reqinfo->mode)
    {
        case MODE_GET:
        {
            SYS_MGR_Telnet_T entry;
            if (SYS_PMGR_GetTelnetCfg(&entry) == TRUE)
            {
                long_return = entry.silent_time;
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
            }
            else
            {
                 return SNMP_ERR_GENERR;
            }

            break;
        }

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            if (requests->requestvb->type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case MODE_SET_RESERVE2:
            if ((*requests->requestvb->val.integer != SYSMGMT_TYPE_SILENT_TIME_DISABLED) &&
                ((*requests->requestvb->val.integer < SYS_ADPT_SYSMGR_TELNET_SILENT_TIME_MIN) ||
                 (*requests->requestvb->val.integer > SYS_ADPT_SYSMGR_TELNET_SILENT_TIME_MAX)))
            {
               return SNMP_ERR_WRONGVALUE;
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called.
             */
            break;

        case MODE_SET_ACTION:
{
            if (SYS_PMGR_SetTelnetSilentTime(*requests->requestvb->val.integer) != TRUE)
    {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
            }

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

#if (SYS_CPNT_SNTP == TRUE)

/********************************************
 ***************sysTimeMgt********************
 ********************************************
 */
int
do_sntpStatus(netsnmp_mib_handler *handler,
              netsnmp_handler_registration *reginfo,
              netsnmp_agent_request_info *reqinfo,
              netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode)
     {

        case MODE_GET:
           {
               UI32_T sntpStatus;

           if (SNTP_PMGR_GetStatus(&sntpStatus)!=TRUE)
           {
               return SNMP_ERR_GENERR;
           }

                long_return = sntpStatus;

                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
            }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
        {
            UI32_T sntpStatus;

            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_WRONGTYPE);
                break;
            }
            sntpStatus = (*requests->requestvb->val.integer);
            if ((sntpStatus<VAL_sntpStatus_enabled)  || (sntpStatus>VAL_sntpStatus_disabled))
            {
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_WRONGVALUE);
                break;
            }
        }
        case MODE_SET_RESERVE2:

            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
       {
            UI32_T sntpStatus;

            sntpStatus = *requests->requestvb->val.integer;


            if (SNTP_PMGR_SetStatus(sntpStatus)!= TRUE)
               netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
        }
          break;

        case MODE_SET_COMMIT:

            break;

        case MODE_SET_UNDO:

            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_sntpServiceMode(netsnmp_mib_handler *handler,
                   netsnmp_handler_registration *reginfo,
                   netsnmp_agent_request_info *reqinfo,
                   netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode)
     {

        case MODE_GET:
           {
            UI32_T sntpServiceMode;
                if (SNTP_PMGR_GetServiceOperationMode(&sntpServiceMode)!= TRUE)
                {
                    return SNMP_ERR_GENERR;
                }
                long_return = sntpServiceMode;
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
            }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
        {
            UI32_T sntpServiceMode;
            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_WRONGTYPE);
                break;
            }
            sntpServiceMode = (*requests->requestvb->val.integer);
            if ((sntpServiceMode<VAL_sntpServiceMode_unicast)  || (sntpServiceMode>VAL_sntpServiceMode_anycast))
            {
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_WRONGVALUE);
                break;
            }
        }
        case MODE_SET_RESERVE2:

            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
       {
            UI32_T sntpServiceMode;

            sntpServiceMode = *requests->requestvb->val.integer;


         if (SNTP_PMGR_SetServiceOperationMode( sntpServiceMode)!= TRUE)
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);

         }
          break;

        case MODE_SET_COMMIT:

            break;

        case MODE_SET_UNDO:

            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}


int
do_sntpPollInterval(netsnmp_mib_handler *handler,
                    netsnmp_handler_registration *reginfo,
                    netsnmp_agent_request_info *reqinfo,
                    netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode)
     {

        case MODE_GET:
           {
            UI32_T sntpPollInterval;
                if (SNTP_PMGR_GetPollTime(&sntpPollInterval)!= TRUE)
                {
                    return SNMP_ERR_GENERR;
                }
                long_return = sntpPollInterval;
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
            }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
        {
            UI32_T sntpPollInterval;
            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_WRONGTYPE);
                break;
            }
            sntpPollInterval = (*requests->requestvb->val.integer);
            if ((sntpPollInterval<MIN_sntpPollInterval)  || (sntpPollInterval>MAX_sntpPollInterval))
            {
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_WRONGVALUE);
                break;
            }
        }
        case MODE_SET_RESERVE2:

            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
       {
            UI32_T sntpPollInterval;

            sntpPollInterval = *requests->requestvb->val.integer;


         if (SNTP_PMGR_SetPollTime( sntpPollInterval)!= TRUE)
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);

         }
          break;

        case MODE_SET_COMMIT:

            break;

        case MODE_SET_UNDO:

            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

#if (SYS_CPNT_NTP == TRUE)

/********************************************
 ***************ntpMgt***********************
 ********************************************
 */
int
do_ntpStatus(netsnmp_mib_handler *handler,
              netsnmp_handler_registration *reginfo,
              netsnmp_agent_request_info *reqinfo,
              netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode)
    {

        case MODE_GET:
            {
                UI32_T ntpStatus;

                if (NTP_PMGR_GetStatus(&ntpStatus)!=TRUE)
                {
                    return SNMP_ERR_GENERR;
                }
                long_return = ntpStatus;
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
            }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            {
                UI32_T ntpStatus;
                ntpStatus = (*requests->requestvb->val.integer);
                if ((ntpStatus<VAL_ntpStatus_enabled)  || (ntpStatus>VAL_ntpStatus_disabled))
                    netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_INCONSISTENTVALUE);
            }
            break;

        case MODE_SET_RESERVE2:

            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called.
             */
            break;

        case MODE_SET_ACTION:
            {
                UI32_T ntpStatus;

                ntpStatus = *requests->requestvb->val.integer;

                if (NTP_PMGR_SetStatus(ntpStatus)!= TRUE)
                    netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_COMMIT:

            break;

        case MODE_SET_UNDO:

            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}

int
do_ntpServiceMode( netsnmp_mib_handler *handler,
                   netsnmp_handler_registration *reginfo,
                   netsnmp_agent_request_info *reqinfo,
                   netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode)
    {

        case MODE_GET:
            {
                UI32_T ntpServiceMode;
                if (NTP_PMGR_GetServiceOperationMode(&ntpServiceMode)!= TRUE)
                {
                    return SNMP_ERR_GENERR;
                }
                long_return = ntpServiceMode;
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
            }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            {
                UI32_T ntpServiceMode;
                ntpServiceMode = (*requests->requestvb->val.integer);
                if ((ntpServiceMode<VAL_ntpServiceMode_unicast)  || (ntpServiceMode>VAL_ntpServiceMode_anycast))
                    netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_INCONSISTENTVALUE);
            }
            break;

        case MODE_SET_RESERVE2:

            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            {
                UI32_T ntpServiceMode;

                ntpServiceMode = *requests->requestvb->val.integer;

                if (NTP_PMGR_SetServiceOperationMode( ntpServiceMode)!= TRUE)
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_COMMIT:

            break;

        case MODE_SET_UNDO:

            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}


int
get_ntpPollInterval(netsnmp_mib_handler *handler,
                    netsnmp_handler_registration *reginfo,
                    netsnmp_agent_request_info *reqinfo,
                    netsnmp_request_info *requests)
{
    switch(reqinfo->mode)
    {

        case MODE_GET:
            {
                UI32_T ntpPollInterval;

                if (NTP_PMGR_GetPollTime(&ntpPollInterval)!= TRUE)
                {
                    return SNMP_ERR_GENERR;
                }
                long_return = ntpPollInterval;
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
            }
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_ntpAuthenticateStatus(netsnmp_mib_handler *handler,
                         netsnmp_handler_registration *reginfo,
                         netsnmp_agent_request_info *reqinfo,
                         netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode)
    {

        case MODE_GET:
            {
                UI32_T ntpAuthenticateStatus;
                if (NTP_PMGR_GetAuthStatus(&ntpAuthenticateStatus)!= TRUE)
                {
                    return SNMP_ERR_GENERR;
                }
                long_return = ntpAuthenticateStatus;
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
            }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            {
                UI32_T ntpAuthenticateStatus;

                ntpAuthenticateStatus = (*requests->requestvb->val.integer);
                if ((ntpAuthenticateStatus<VAL_ntpAuthenticateStatus_enabled)  || (ntpAuthenticateStatus>VAL_ntpAuthenticateStatus_disabled))
                    netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_INCONSISTENTVALUE);
            }
            break;

        case MODE_SET_RESERVE2:

            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            {
            UI32_T status;

                status =*requests->requestvb->val.integer ;
                if (NTP_PMGR_SetAuthStatus(status)!= TRUE)   /* !!! */
                {
                    if(SNMP_MGR_IsDebugMode())
                        printf("ntpMgt_set:NTP_PMGR_SetAuthStatus return false, status=[%lu]\n",(unsigned long)status);

                    return SNMP_ERR_COMMITFAILED;
                }
            }
            break;

        case MODE_SET_COMMIT:

            break;

        case MODE_SET_UNDO:

            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}

#define NTPSERVERENTRY_INSTANCE_LEN  4

BOOL_T ntpServerTable_OidIndexToData(UI32_T exact, UI32_T compc,
            oid *compl, UI32_T *ntpServerIpAddress)
{
    /* get or write
     */
    if(exact)
    {
        /* check the index length
         */
        if(compc != NTPSERVERENTRY_INSTANCE_LEN) /* the constant size index*/
        {
            return FALSE;
        }
    }
    SNMP_MGR_ReadIpFromCompl(compl,0, ntpServerIpAddress);
    return TRUE;
}

/*
 * var_ntpServerTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *
var_ntpServerTable(struct variable *vp,
            oid     *name,
            size_t  *length,
            int     exact,
            size_t  *var_len,
            WriteMethod **write_method)
{
    /* variables we may use later */

    UI32_T compc=0;
    oid compl[NTPSERVERENTRY_INSTANCE_LEN] = {0};
    oid best_inst[NTPSERVERENTRY_INSTANCE_LEN] = {0};
    NTP_MGR_SERVER_T  entry;
    UI32_T ntpServerIpAddress=0;

    switch(vp->magic)
    {
        case LEAF_ntpServerVersion:
            *write_method = write_ntpServerVersion;
            break;

        case LEAF_ntpServerKeyId:
            *write_method = write_ntpServerKeyId;
            break;

        case LEAF_ntpServerStatus:
            *write_method = write_ntpServerStatus;
            break;

        default:
            *write_method = 0;
            break;
    }

    /*check compc, retrive compl*/
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,compl, NTPSERVERENTRY_INSTANCE_LEN);

    memset(&entry, 0, sizeof(entry));
    if (exact)/*get,set*/
    {
        /* get index */
        if(ntpServerTable_OidIndexToData(exact,compc,compl,&ntpServerIpAddress)==FALSE)
        {
            return NULL;
        }

        /*get data
         */
        if (NTP_PMGR_FindServer(ntpServerIpAddress,&entry)!=TRUE)
        {
            return NULL;
        }
    }
    else/*getnext*/
    {
        /*get index*/
        ntpServerTable_OidIndexToData(exact,compc,compl,&ntpServerIpAddress);
       /* SNMP_MGR_ReadIpFromCompl(name, oid_name_length, &ntpServerIpAddress); */
        /* check the length of inputing index,if <1 we should try get {0.0.0.0.0...}
         */
        if (compc< NTPSERVERENTRY_INSTANCE_LEN)
        {
            /* get data */
            if ( NTP_PMGR_FindServer(ntpServerIpAddress,&entry)!=TRUE)
            {
                /*get next data*/
                if (NTP_PMGR_FindNextServer(ntpServerIpAddress,&entry)!=TRUE)
                {
                    return NULL;
                }
            }
        }
        else
        {
            /*get next data*/
            if (NTP_PMGR_FindNextServer(ntpServerIpAddress,&entry)!=TRUE)
            {
                return NULL;
            }
        }
    }

    memcpy(name, vp->name, vp->namelen*sizeof(oid));
    /* assign data to the oid index
     */
    SNMP_MGR_BindIpInstance(entry.srcadr.sin_addr.s_addr, 0, best_inst);
    memcpy(name+vp->namelen,best_inst,NTPSERVERENTRY_INSTANCE_LEN*sizeof(oid));
    *length = vp->namelen+NTPSERVERENTRY_INSTANCE_LEN ;

    /* this is where we do the value assignments for the mib results.
     */
    switch(vp->magic)
    {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case LEAF_ntpServerIpAddress:
            *var_len = sizeof(ipaddr_return);
            ipaddr_return = entry.srcadr.sin_addr.s_addr;
            return (u_char *) &ipaddr_return;
#endif

        case LEAF_ntpServerVersion:
            *var_len = sizeof(long_return);
            long_return = entry.version;
            return (u_char *) &long_return;

        case LEAF_ntpServerKeyId:
            *var_len = sizeof(long_return);
            long_return = entry.keyid;
            return (u_char *) &long_return;

        case LEAF_ntpServerStatus:
            *var_len = sizeof(long_return);
            long_return = entry.ntpServerStatus;
            return (u_char *) &long_return;

        default:
            ERROR_MSG("");
    }
    return NULL;
}

int
write_ntpServerVersion(int  action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    /* check 1: check if the input index is exactly match, if not return fail*/
    switch (action)
    {
        case RESERVE1:

            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:

            if (*(long *)var_val< MIN_ntpServerVersion || *(long *)var_val > MAX_ntpServerVersion)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
            {
                UI32_T ntpServerIpAddress = 0;
                UI32_T version=0;
                UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

                if(ntpServerTable_OidIndexToData(TRUE,name_len-oid_name_length,&(name[oid_name_length]), &ntpServerIpAddress)==FALSE)
                    return SNMP_ERR_COMMITFAILED;

                version = *(long *)var_val;

                if(NTP_PMGR_AddServerIp(ntpServerIpAddress, version, VAL_ntpServerKey_no)!= TRUE)
                {
                    return SNMP_ERR_COMMITFAILED;
                }
            }
            break;

        case UNDO:
            break;

        case COMMIT:
            break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_ntpServerKeyId(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{

    switch ( action )
    {

        case RESERVE1:

            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:

            if (*(long *)var_val< MIN_ntpServerKeyId ||*(long *)var_val > MAX_ntpServerKeyId)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:

            break;

        case ACTION:
            {
                UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
                UI32_T keyid=0;
                UI32_T ntpServerIpAddress=0;

                if(ntpServerTable_OidIndexToData(TRUE,name_len-oid_name_length,&(name[oid_name_length]), &ntpServerIpAddress)==FALSE)
                    return SNMP_ERR_COMMITFAILED;

                keyid = *(long *)var_val;

                if(NTP_PMGR_AddServerIp(ntpServerIpAddress, NTP_VERSION, keyid) != TRUE)
                {
                    return SNMP_ERR_COMMITFAILED;
                }
            }
            break;

        case UNDO:
            break;

        case COMMIT:
            break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_ntpServerStatus(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

      /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  4 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch ( action )
    {
        case RESERVE1:

            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:

            switch ( *(long *)var_val )
            {
                case VAL_ntpServerStatus_valid:
                    break;

                case VAL_ntpServerStatus_invalid:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:

            break;

        case ACTION:
            {
                UI32_T status;
                UI32_T ntpServerIpAddress=0;

                status =*(long *)var_val;
                ntpServerTable_OidIndexToData(TRUE, name_len-oid_name_length, &(name[oid_name_length]), &ntpServerIpAddress);

                if (status == VAL_ntpServerStatus_valid)
                {
                    if (NTP_PMGR_AddServerIp(ntpServerIpAddress, NTP_VERSION, VAL_ntpServerKey_no) != TRUE)
                    {
                        return SNMP_ERR_COMMITFAILED;
                    }
                }
                else if (status == VAL_ntpServerStatus_invalid)
                {
                    if (NTP_PMGR_DeleteServerIp(ntpServerIpAddress) != TRUE)
                    {
                        return SNMP_ERR_COMMITFAILED;
                    }
                }
            }
            break;

        case UNDO:
            break;

        case COMMIT:
            break;
    }
    return SNMP_ERR_NOERROR;
}

#define NTPAUTHKEYENTRY_INSTANCE_LEN  1

BOOL_T ntpAuthKeyTable_OidIndexToData(UI32_T exact, UI32_T compc,
            oid * compl ,  UI32_T *ntpAuthKeyId)
{
    /* get or write
     */
    if(exact)
    {

        /* check the index length
         */
        if(compc != NTPAUTHKEYENTRY_INSTANCE_LEN) /* the constant size index*/
        {
            return FALSE;
        }
    }
    *ntpAuthKeyId=compl[0];
    return TRUE;
}

/*
 * var_ntpAuthKeyTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *
var_ntpAuthKeyTable(struct variable *vp,
            oid     *name,
            size_t  *length,
            int     exact,
            size_t  *var_len,
            WriteMethod **write_method)
{
    /* variables we may use later */
    UI32_T compc=0;
    oid compl[NTPAUTHKEYENTRY_INSTANCE_LEN] = {0};
    oid best_inst[NTPAUTHKEYENTRY_INSTANCE_LEN] = {0};
    NTP_MGR_AUTHKEY_T  entry;
    switch(vp->magic)
    {
        case LEAF_ntpAuthKeyWord:
            *write_method = write_ntpAuthKeyWord;
            break;
        case LEAF_ntpAuthKeyStatus:
            *write_method = write_ntpAuthKeyStatus;
            break;
        default:
            *write_method = 0;
            break;
    }

    /*check compc, retrive compl*/
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,compl, NTPAUTHKEYENTRY_INSTANCE_LEN);

    memset(&entry, 0, sizeof(entry));

    if (exact)/*get,set*/
    {
        /* get index */
        if(ntpAuthKeyTable_OidIndexToData(exact,compc,compl, &entry.keyid)==FALSE)
        {
            return NULL;
        }

        /*get data
         */
        if (NTP_PMGR_FindKey(entry.keyid,&entry)!=TRUE)
        {
            return NULL;
        }
     }
     else/*getnext*/
     {
        /*get index*/
        ntpAuthKeyTable_OidIndexToData(exact,compc,compl, &entry.keyid);
        /* check the length of inputing index,if <1 we should try get {0.0.0.0.0...}
         */
        if (compc< NTPAUTHKEYENTRY_INSTANCE_LEN)
        {
            /* get data */
            if ( NTP_PMGR_FindKey(entry.keyid,&entry)!=TRUE)
            {
                /*get next data*/
                if ( NTP_PMGR_GetNextKey(&entry)!=TRUE)
                {
                    return NULL;
                }
             }
         }
         else
         {
            /*get next data*/
            if ( NTP_PMGR_GetNextKey(&entry)!=TRUE)
            {
                return NULL;
             }
          }
       }

    memcpy(name, vp->name, vp->namelen*sizeof(oid));
    /* assign data to the oid index
     */

    best_inst[0]=entry.keyid;
    memcpy(name+vp->namelen,best_inst,NTPAUTHKEYENTRY_INSTANCE_LEN*sizeof(oid));
    *length = vp->namelen+NTPAUTHKEYENTRY_INSTANCE_LEN ;

    /* this is where we do the value assignments for the mib results.
     */
    switch(vp->magic)
    {

#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case LEAF_ntpAuthKeyId:
            *var_len = sizeof(long_return);
            long_return = entry.keyid;
            return (u_char *) &long_return;
#endif
        case LEAF_ntpAuthKeyWord:
            *var_len  =   strlen(entry.k.MD5_key);
            memcpy(return_buf, entry.k.MD5_key,*var_len);
            return (u_char*)return_buf;

        case LEAF_ntpAuthKeyStatus:
            *var_len = sizeof(long_return);
            long_return = entry.ntpAuthKeyStatus;
            return (u_char *) &long_return;

        default:
            ERROR_MSG("");
    }
    return NULL;
}

int
write_ntpAuthKeyWord(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{

    switch ( action )
    {
        case RESERVE1:

            if (var_val_type != ASN_OCTET_STR)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len< MINSIZE_ntpAuthKeyWord ||var_val_len > MAXSIZE_ntpAuthKeyWord)
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;

        case RESERVE2:
            break;

        case FREE:
            break;

        case ACTION:
            {
                UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
                char   byte_buffer[MAXSIZE_ntpAuthKeyWord+1]={0};
                NTP_MGR_AUTHKEY_T authkey;

                memset(&authkey,0,sizeof(NTP_MGR_AUTHKEY_T));

                if(ntpAuthKeyTable_OidIndexToData(TRUE,name_len-oid_name_length,&(name[oid_name_length]), &authkey.keyid)==FALSE)
                {
                    return SNMP_ERR_COMMITFAILED;
                }

                memcpy(byte_buffer,var_val,var_val_len);
                byte_buffer[var_val_len]='\0';
                strncpy(authkey.k.MD5_key, byte_buffer, sizeof(authkey.k.MD5_key)-1);
                authkey.k.MD5_key[sizeof(authkey.k.MD5_key)-1] = '\0';

                if(NTP_PMGR_AddAuthKey(authkey.keyid,(char *)authkey.k.MD5_key)!=TRUE)
                {
                   return SNMP_ERR_COMMITFAILED;
                }
            }
            break;

        case UNDO:
            break;

        case COMMIT:
            break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_ntpAuthKeyStatus(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    NTP_MGR_AUTHKEY_T authkey;
    switch ( action ) {

    case RESERVE1:

        if (var_val_type != ASN_INTEGER)
        {
            return SNMP_ERR_WRONGTYPE;
        }
          break;

    case RESERVE2:

        switch ( *(long *)var_val )
        {
            case VAL_ntpAuthKeyStatus_valid:
                break;

            case VAL_ntpAuthKeyStatus_invalid:
                break;

            default:
                return SNMP_ERR_WRONGVALUE;
        }
        break;

    case FREE:
        break;

    case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
            I32_T value=0;
            if(ntpAuthKeyTable_OidIndexToData(TRUE,name_len-oid_name_length,&(name[oid_name_length]), &authkey.keyid)==FALSE)
            {
                return SNMP_ERR_COMMITFAILED;
            }
            value = *(long *)var_val;
            if(value <VAL_ntpAuthKeyStatus_valid || value > VAL_ntpAuthKeyStatus_invalid )
            {
                return SNMP_ERR_COMMITFAILED;
            }

            if (NTP_PMGR_SetAuthKeyStatus(authkey.keyid, value) != TRUE)
            {
                return SNMP_ERR_COMMITFAILED;
            }
        }
        break;

    case UNDO:
        break;

    case COMMIT:
        break;
    }
    return SNMP_ERR_NOERROR;
}
#endif

int
do_sysCurrentTime(netsnmp_mib_handler *handler,
                  netsnmp_handler_registration *reginfo,
                  netsnmp_agent_request_info *reqinfo,
                  netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
            {
                UI32_T sec;
                char buffer[SIZE_sysCurrentTime+1];

                SYS_TIME_GetRealTimeBySec(&sec);
                if (!SYS_TIME_ConvertTime(sec, buffer))
                {
                       return SNMP_ERR_GENERR;
                }
                 strcpy( (char *)return_buf, buffer);
               snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, (u_char *) return_buf, strlen((char *)return_buf));
           }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            if (requests->requestvb->type != ASN_OCTET_STR)
            {
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_WRONGTYPE);
                break;
            }
            if (requests->requestvb->val_len!=SIZE_sysCurrentTime)
            {
              netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_WRONGLENGTH);
              break;
            }

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */

            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
           {
               char  buffer[SIZE_sysCurrentTime+1];
               memcpy(buffer, requests->requestvb->val.string, requests->requestvb->val_len);
               buffer[requests->requestvb->val_len]= '\0';
               if (!L_STDLIB_StrIsAsciiPrintWithCount((char *)buffer, requests->requestvb->val_len))
               {
                    netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
                    break;
               }

               if (!SYS_TIME_SetRealTimeClockByStr(buffer))
               {
                  netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
                  break;
               }
            }
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */

            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */

            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_sysTimeZoneName(netsnmp_mib_handler *handler,
                   netsnmp_handler_registration *reginfo,
                   netsnmp_agent_request_info *reqinfo,
                   netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
            {
                char buffer[MAXSIZE_sysTimeZoneName+1];

                if (!SYS_TIME_GetTimeZoneNameByStr(buffer))
                {
                    return SNMP_ERR_GENERR;
                }

                strcpy( (char *)return_buf, buffer);
                snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, (u_char *) return_buf, strlen((char *)return_buf));
           }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            if (requests->requestvb->type != ASN_OCTET_STR)
            {
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_WRONGTYPE);
                break;
            }
            if ((requests->requestvb->val_len<MINSIZE_sysTimeZoneName) || (requests->requestvb->val_len>MAXSIZE_sysTimeZoneName))
            {
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_WRONGLENGTH);
                break;
            }
            if ((requests->requestvb->val_len<MINSIZE_sysTimeZoneName) || (requests->requestvb->val_len>MAXSIZE_sysTimeZoneName))
            {
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_WRONGLENGTH);
                break;
            }

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */

            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
           {
               char  buffer[MAXSIZE_sysTimeZoneName+1];
               memcpy(buffer, requests->requestvb->val.string, requests->requestvb->val_len);
               buffer[requests->requestvb->val_len]= '\0';
               if (!L_STDLIB_StrIsAsciiPrintWithCount(buffer, requests->requestvb->val_len))
               {
                    netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
                    break;
               }

               if (!SYS_TIME_SetTimeZoneNameByStr(buffer))
               {
                  netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
                  break;
               }
            }
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */

            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */

            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_sysTimeZone(netsnmp_mib_handler *handler,
               netsnmp_handler_registration *reginfo,
               netsnmp_agent_request_info *reqinfo,
               netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
            {

                char buffer[SIZE_sysTimeZone+1];

                if (!SYS_TIME_GetTimeZoneByStr(buffer))
                {
                       return SNMP_ERR_GENERR;
                }
                 strcpy( (char *)return_buf, buffer);
               snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, (u_char *) return_buf, strlen((char *)return_buf));
           }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            if (requests->requestvb->type != ASN_OCTET_STR)
            {
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_WRONGTYPE);
                break;
            }
            if (requests->requestvb->val_len!=SIZE_sysTimeZone)
            {
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_WRONGLENGTH);
                break;
            }

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */

            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
           {
               char  buffer[SIZE_sysTimeZone+1];
               memcpy(buffer, requests->requestvb->val.string, requests->requestvb->val_len);
               buffer[requests->requestvb->val_len]= '\0';
               if (!L_STDLIB_StrIsAsciiPrintWithCount(buffer,requests->requestvb->val_len))
               {
                    netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
                    break;
               }

               if (!SYS_TIME_SetTimeZoneByStr(buffer))
               {
                  netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
                  break;
               }
            }
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */

            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */

            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

/********************************************
 ***************sntpServerTable**************
 ********************************************
 */

#define SNTPSERVERENTRY_INSTANCE_LEN  1

BOOL_T sntpServerTable_OidIndexToData(UI32_T exact, UI32_T compc,
            oid * compl,  UI32_T *sntpServerIndex)
     {
    /* get or write */
    if (exact)
    {
        /* check the index length */
        if (compc != SNTPSERVERENTRY_INSTANCE_LEN) /* the constant size index */
        {
            return FALSE;
        }
    }

    *sntpServerIndex = compl[0];

    return TRUE;
}

/*
 * var_sntpServerTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_sntpServerTable(struct variable *vp,
                    oid * name,
                    size_t * length,
                    int exact,
                    size_t  *var_len,
                    WriteMethod **write_method)
{
    /* variables we may use later */
    UI32_T compc = 0;
    oid compl[SNTPSERVERENTRY_INSTANCE_LEN] = {0};
    oid best_inst[SNTPSERVERENTRY_INSTANCE_LEN] = {0};
    L_INET_AddrIp_T entry;
    UI32_T nIndex = 0;

     switch(vp->magic)
     {
        case LEAF_sntpServerInetAddressType:
            *write_method = write_sntpServerInetAddressType;
            break;

        case LEAF_sntpServerInetAddress:
            *write_method = write_sntpServerInetAddress;
            break;

        case LEAF_sntpServerStatus:
            *write_method = write_sntpServerStatus;
            break;

        default:
            *write_method = 0;
      break;
      }

    /* check compc, retrive compl */
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,
                           compl, SNTPSERVERENTRY_INSTANCE_LEN);

    memset(&entry, 0, sizeof(entry));

    if (exact) /* get,set */
    {
        /* get index */
        if (sntpServerTable_OidIndexToData(exact, compc, compl,  &nIndex) == FALSE)
        {
            return NULL;
        }

        /* get data */
        if (SNTP_PMGR_GetServerIp( nIndex, &entry) != TRUE)
        {
            return NULL;
        }
    }
    else /* getnext */
    {
        /* get index */
        sntpServerTable_OidIndexToData(exact, compc, compl,  &nIndex);

        /* check the length of input index;
         * if not complete we should pad with 0 index and try to get exact,
         * in case this instance exists
         */
        if (compc < SNTPSERVERENTRY_INSTANCE_LEN)
        {
            /* get data */
            if (SNTP_PMGR_GetServerIp( nIndex, &entry) != TRUE)
            {
                /* get next data */
                if (SNTP_PMGR_GetNextServerIp(&nIndex, &entry) != TRUE)
                {
                    return NULL;
                }
            }
        }
        else
        {
            /* get next data */
            if (SNTP_PMGR_GetNextServerIp(&nIndex, &entry) != TRUE)
            {
                return NULL;
            }
        }
    }

    memcpy(name, vp->name, vp->namelen*sizeof(oid));

    /* assign data to the oid index */
    best_inst[0] = nIndex;
    memcpy(name + vp->namelen, best_inst,
           SNTPSERVERENTRY_INSTANCE_LEN * sizeof(oid));
    *length = vp->namelen + SNTPSERVERENTRY_INSTANCE_LEN ;

    /* this is where we do the value assignments for the mib results. */
    switch (vp->magic)
    {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case LEAF_sntpServerIndex:
            *var_len = sizeof(long_return);
            long_return = nIndex;
        return (u_char*) &long_return;
#endif

        case LEAF_sntpServerInetAddressType:
            *var_len = sizeof(long_return);
            long_return = entry.type;
            return (u_char*) &long_return;

        case LEAF_sntpServerInetAddress:
        {
            UI32_T type, addr_len, preflen;

            if (! SNMP_MGR_ConvertLInetAddrToInetAddrAndType(
                (L_INET_Addr_T *) &entry,
                &type, &addr_len, return_buf, &preflen))
            {
                /* conversion failed
                 */
                *var_len = 0;
            }
            else
            {
                *var_len = (size_t) addr_len;
            }

            return (u_char *) return_buf;
        }

        case LEAF_sntpServerStatus:
            *var_len = sizeof(long_return);
            long_return = VAL_sntpServerStatus_valid;
            return (u_char*) &long_return;

        default:
            ERROR_MSG("");
    }

    return NULL;
}

int
write_sntpServerInetAddressType(int      action,
                          u_char * var_val,
                          u_char var_val_type,
                          size_t var_val_len,
                          u_char   *statP,
                          oid      *name,
                          size_t   name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            switch (*(long *)var_val)
            {
                case VAL_sntpServerInetAddressType_ipv4:
                    break;

                case VAL_sntpServerInetAddressType_ipv6:
                    break;

                case VAL_sntpServerInetAddressType_ipv4z:
                    break;

                case VAL_sntpServerInetAddressType_ipv6z:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
            I32_T value = 0;
            UI32_T sntpServerIndex = 0;

            if (sntpServerTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]),  &sntpServerIndex) == FALSE)
                return SNMP_ERR_COMMITFAILED;

            value = *(long *)var_val;

            sntp_server_inet_address_type = value;
            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

int
write_sntpServerInetAddress(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_OCTET_STR)
            {
              return SNMP_ERR_WRONGTYPE;
            }
            if ((var_val_len < MINSIZE_sntpServerInetAddress)
                || (var_val_len > MAXSIZE_sntpServerInetAddress))
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;

        case RESERVE2:
            break;

        case FREE:
            /* Release any resources that have been allocated */
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
            UI32_T sntpServerIndex = 0;
            L_INET_AddrIp_T ip_addr;

            if (sntpServerTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]),  &sntpServerIndex) == FALSE)
                return SNMP_ERR_COMMITFAILED;

            /* check address length based on address type
             */
            if (! SNMP_MGR_IsInetAddrLengthValid(
                sntp_server_inet_address_type,
                (UI32_T) var_val_len))
            {
                return SNMP_ERR_INCONSISTENTVALUE;
            }

            /* check address value based on address type
             */
            if (! SNMP_MGR_IsInetAddrValueValid(
                sntp_server_inet_address_type,
                var_val))
            {
                return SNMP_ERR_INCONSISTENTVALUE;
            }

            /* compose address structure
             */
            if (! SNMP_MGR_ConvertInetAddrAndTypeToLInetAddr(sntp_server_inet_address_type,
                var_val_len, var_val, 0,
                (L_INET_Addr_T *) &ip_addr))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            /* set to core layer
             */
            if (SNTP_PMGR_AddServerIp(sntpServerIndex, &ip_addr) != TRUE)
                return SNMP_ERR_COMMITFAILED;

            /* clear InetAddressType to wait for next write;
             * It is ported from Galaxy.
             */
            sntp_server_inet_address_type = VAL_sntpServerInetAddressType_unknown;
            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

int
write_sntpServerStatus(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            switch (*(long *)var_val)
            {
                case VAL_sntpServerStatus_valid:
                    break;

                case VAL_sntpServerStatus_invalid:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
            I32_T value = 0;
            UI32_T sntpServerIndex = 0;
            L_INET_AddrIp_T ip_addr;

            if (sntpServerTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]),  &sntpServerIndex) == FALSE)
                return SNMP_ERR_COMMITFAILED;

            if (sntpServerIndex < MIN_sntpServerIndex || sntpServerIndex > MAX_sntpServerIndex)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            value = *(long *)var_val;

            if (VAL_sntpServerStatus_valid == value)
            {
                UI32_T i;
                UI32_T default_ip = L_STDLIB_Hton32(SNTP_DEFAILT_SERVER_IP);

                /* it does not allow valid existed entry
                 */
                if(SNTP_PMGR_GetServerIp(sntpServerIndex, &ip_addr)==TRUE)
                {
                    return SNMP_ERR_COMMITFAILED;
                }

                /* assign default IP address (use ipv4 start from 10.1.0.1 to 10.1.0.3)
                 * if default IP already exist, it will add 1.
                 */
                memset(&ip_addr, 0, sizeof(ip_addr));
                ip_addr.type = L_INET_ADDR_TYPE_IPV4;
                ip_addr.addrlen = SYS_ADPT_IPV4_ADDR_LEN;

                for (i=0; i<MAX_sntpServerIndex; i++)
                {
                    memcpy(ip_addr.addr, &default_ip, SYS_ADPT_IPV4_ADDR_LEN);

                    if(SNTP_PMGR_AddServerIp(sntpServerIndex, &ip_addr) == TRUE)
                    {
                        break;
                    }
                    else
                    {
                        default_ip++;
                    }
                }
            }
            else  /* delete */
            {
                if (SNTP_PMGR_DeleteServerIpForSNMP(sntpServerIndex) == FALSE)
                {
                    return SNMP_ERR_COMMITFAILED;
                }
            }
            break;
        }

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

#endif

/********************************************
 ***************fileCopyMgt******************
 ********************************************
 */
static UI32_T remote_server_address_type = 0;

int
do_fileCopySrcFileName(netsnmp_mib_handler *handler,
                       netsnmp_handler_registration *reginfo,
                       netsnmp_agent_request_info *reqinfo,
                       netsnmp_request_info *requests)
{
    switch (reqinfo->mode)
    {
        case MODE_GET:
        {
            XFER_MGR_FileCopyMgt_T entry;

            if (XFER_PMGR_GetFileCopyMgtEntry(&entry) != TRUE)
            {
                return SNMP_ERR_GENERR;
            }

            strcpy( (char *)return_buf, (char *)entry.src_file_name);
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, (u_char *) return_buf, strlen((char *)return_buf));

            break;
        }

        case MODE_SET_RESERVE1:
            if (requests->requestvb->type != ASN_OCTET_STR)
            {
                return SNMP_ERR_WRONGTYPE;
            }

            if (   (requests->requestvb->val_len < MINSIZE_fileCopySrcFileName)
                || (requests->requestvb->val_len > MAXSIZE_fileCopySrcFileName))
            {
                return SNMP_ERR_WRONGLENGTH;
            }

            break;

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            break;

        case MODE_SET_ACTION:
        {
           UI8_T  buffer[MAXSIZE_fileCopySrcFileName + 1];

            memcpy(buffer, requests->requestvb->val.string, requests->requestvb->val_len);
            buffer[requests->requestvb->val_len]= '\0';

            if (L_STDLIB_StrIsAsciiPrintWithCount((char *)buffer, requests->requestvb->val_len) == FALSE)
            {
                return SNMP_ERR_WRONGVALUE;
            }

#if (SYS_CPNT_DBSYNC_TXT == TRUE)
            if (SNMP_MGR_SetTmpDirty(0) == FALSE)
            {
                SYSFUN_Debug_Printf("autoSave   Fail\n");
            }
#endif /* #if (SYS_CPNT_DBSYNC_TXT == TRUE) */

            if (XFER_PMGR_SetFileCopySrcFileName(buffer) != TRUE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case MODE_SET_COMMIT:

            break;

        case MODE_SET_UNDO:

            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_fileCopyStatus(netsnmp_mib_handler *handler,
                   netsnmp_handler_registration *reginfo,
                   netsnmp_agent_request_info *reqinfo,
                   netsnmp_request_info *requests)
{
    switch (reqinfo->mode)
    {
        case MODE_GET:
        {
            XFER_MGR_FileCopyMgt_T entry;

            if (XFER_PMGR_GetFileCopyMgtEntry(&entry) != TRUE)
            {
                return SNMP_ERR_GENERR;
            }

            long_return = entry.status;
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));

            break;
        }

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_fileCopySrcOperType(netsnmp_mib_handler *handler,
                       netsnmp_handler_registration *reginfo,
                       netsnmp_agent_request_info *reqinfo,
                       netsnmp_request_info *requests)
{
    switch (reqinfo->mode)
    {
        case MODE_GET:
        {
            XFER_MGR_FileCopyMgt_T entry;

            if (XFER_PMGR_GetFileCopyMgtEntry(&entry) != TRUE)
            {
                return SNMP_ERR_GENERR;
            }

            long_return = entry.src_oper_type;
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
        }

        case MODE_SET_RESERVE1:
            if (requests->requestvb->type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }

            if (requests->requestvb->val_len != sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;

        case MODE_SET_RESERVE2:
        {
            UI32_T value;

            value = (*requests->requestvb->val.integer);

            if (   ((value < VAL_fileCopySrcOperType_file) || (value > VAL_fileCopySrcOperType_tftp))
#if (SYS_CPNT_SFTP == TRUE)
                && (value != VAL_fileCopySrcOperType_sftp)
#endif /* #if (SYS_CPNT_SFTP == TRUE) */
#if (SYS_CPNT_XFER_FTP == TRUE)
                && (value != VAL_fileCopySrcOperType_ftp)
#endif /* #if (SYS_CPNT_XFER_FTP == TRUE) */
#if (SYS_CPNT_XFER_FTP_FTPS == TRUE)
                && (value != VAL_fileCopySrcOperType_ftps)
#endif /* #if (SYS_CPNT_XFER_FTP_FTPS == TRUE) */
                && (value != VAL_fileCopySrcOperType_unit)
            )
            {
                return SNMP_ERR_WRONGVALUE;
            }

            break;
        }

        case MODE_SET_FREE:
            break;

        case MODE_SET_ACTION:
        {
            UI32_T value;

            value = (*requests->requestvb->val.integer);

#if (SYS_CPNT_DBSYNC_TXT == TRUE)
            if (SNMP_MGR_SetTmpDirty(0) == FALSE)
            {
                SYSFUN_Debug_Printf("autoSave   Fail\n");
            }
#endif /* #if (SYS_CPNT_DBSYNC_TXT == TRUE) */

            if (XFER_PMGR_SetFileCopySrcOperType(value) != TRUE)
            {
                return SNMP_ERR_COMMITFAILED;
            }
        }
            break;

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_fileCopyDestFileName(netsnmp_mib_handler *handler,
                        netsnmp_handler_registration *reginfo,
                        netsnmp_agent_request_info *reqinfo,
                        netsnmp_request_info *requests)
{
    switch (reqinfo->mode)
    {
        case MODE_GET:
        {
            XFER_MGR_FileCopyMgt_T entry;

            if (XFER_PMGR_GetFileCopyMgtEntry(&entry) != TRUE)
            {
                return SNMP_ERR_GENERR;
            }

            strcpy( (char *)return_buf, (char *)entry.dest_file_name);
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, (u_char *) return_buf, strlen((char *)return_buf));

            break;
        }

        case MODE_SET_RESERVE1:
            if (requests->requestvb->type != ASN_OCTET_STR)
            {
                return SNMP_ERR_WRONGTYPE;
            }

            if (   (requests->requestvb->val_len < MINSIZE_fileCopyDestFileName)
                || (requests->requestvb->val_len > MAXSIZE_fileCopyDestFileName))
            {
                return SNMP_ERR_WRONGLENGTH;
            }

            break;

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            break;

        case MODE_SET_ACTION:
        {
            UI8_T buffer[MAXSIZE_fileCopyDestFileName + 1];

            memcpy(buffer, requests->requestvb->val.string, requests->requestvb->val_len);
            buffer[requests->requestvb->val_len]= '\0';

            if (!L_STDLIB_StrIsAsciiPrintWithCount((char *)buffer, requests->requestvb->val_len))
            {
                return SNMP_ERR_WRONGVALUE;
            }

#if (SYS_CPNT_DBSYNC_TXT == TRUE)
            if (SNMP_MGR_SetTmpDirty(0) == FALSE)
            {
                SYSFUN_Debug_Printf("autoSave   Fail\n");
            }
#endif /* #if (SYS_CPNT_DBSYNC_TXT == TRUE) */

            if (XFER_PMGR_SetFileCopyDestFileName(buffer) != TRUE)
            {
                return SNMP_ERR_COMMITFAILED;
            }
            break;
        }

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_fileCopyTftpServer(netsnmp_mib_handler *handler,
                      netsnmp_handler_registration *reginfo,
                      netsnmp_agent_request_info *reqinfo,
                      netsnmp_request_info *requests)
{
    switch (reqinfo->mode)
    {
        case MODE_GET:
        {
            XFER_MGR_FileCopyMgt_T entry;

            if (XFER_PMGR_GetFileCopyMgtEntry(&entry) != TRUE)
            {
                return SNMP_ERR_GENERR;
            }

            IP_LIB_ArraytoUI32(entry.server_address.addr, &ipaddr_return);
            snmp_set_var_typed_value(requests->requestvb, ASN_IPADDRESS, (u_char *) &ipaddr_return, sizeof(ipaddr_return));

            break;
        }

        case MODE_SET_RESERVE1:
            if (requests->requestvb->type != ASN_IPADDRESS)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            break;

        case MODE_SET_ACTION:
        {
            L_INET_AddrIp_T tftpServer;
            UI32_T value = (*requests->requestvb->val.integer);

            memset(&tftpServer, 0, sizeof(tftpServer));

            tftpServer.addrlen = SYS_ADPT_IPV4_ADDR_LEN;
            tftpServer.type = VAL_fileCopyServerInetAddressType_ipv4;
            IP_LIB_UI32toArray(value, tftpServer.addr);

            if(TRUE == L_INET_ADDR_IS_IPV4_LINK_LOCAL(tftpServer.addr))
            {
                tftpServer.type = VAL_fileCopyServerInetAddressType_ipv4z;
            }
            else
            {
                tftpServer.type = VAL_fileCopyServerInetAddressType_ipv4;
            }

#if (SYS_CPNT_DBSYNC_TXT == TRUE)
            if (SNMP_MGR_SetTmpDirty(0) == FALSE)
            {
                SYSFUN_Debug_Printf("autoSave Fail\n");
            }
#endif /* #if (SYS_CPNT_DBSYNC_TXT == TRUE) */

            if (XFER_PMGR_SetFileCopyTftpServer(&tftpServer) != TRUE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            remote_server_address_type = tftpServer.type;
            break;
        }

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_fileCopyUnitId(netsnmp_mib_handler *handler,
                  netsnmp_handler_registration *reginfo,
                  netsnmp_agent_request_info *reqinfo,
                  netsnmp_request_info *requests)
{
    switch (reqinfo->mode)
    {
        case MODE_GET:
        {
            XFER_MGR_FileCopyMgt_T entry;

            if (XFER_PMGR_GetFileCopyMgtEntry(&entry) != TRUE)
            {
                return SNMP_ERR_GENERR;
            }

            long_return = entry.unit;
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
        }

        case MODE_SET_RESERVE1:
            break;

        case MODE_SET_RESERVE2:
            if (requests->requestvb->type != ASN_INTEGER)
            {
                return  SNMP_ERR_WRONGTYPE;
            }
            break;

        case MODE_SET_FREE:
            break;

        case MODE_SET_ACTION:
        {
            UI32_T value;

            value = (*requests->requestvb->val.integer);

#if (SYS_CPNT_DBSYNC_TXT == TRUE)
            if (SNMP_MGR_SetTmpDirty(0) == FALSE)
            {
                SYSFUN_Debug_Printf("autoSave   Fail\n");
            }
#endif /* #if (SYS_CPNT_DBSYNC_TXT == TRUE) */

            if (XFER_PMGR_SetFileCopyUnit(value) != TRUE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}


int
do_fileCopyAction(netsnmp_mib_handler *handler,
                  netsnmp_handler_registration *reginfo,
                  netsnmp_agent_request_info *reqinfo,
                  netsnmp_request_info *requests)
{
    switch (reqinfo->mode)
    {
        case MODE_GET:
        {
            XFER_MGR_FileCopyMgt_T entry;

            if (XFER_PMGR_GetFileCopyMgtEntry(&entry) != TRUE)
            {
                return SNMP_ERR_GENERR;
            }

            long_return = entry.action;
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
        }

        case MODE_SET_RESERVE1:
            if (requests->requestvb->type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }

            break;

        case MODE_SET_RESERVE2:
        {
            UI32_T value;

            value = (*requests->requestvb->val.integer);

            if (   (value < VAL_fileCopyAction_notCopying)
                || (value > VAL_fileCopyAction_abortTftp))
            {
                return SNMP_ERR_WRONGVALUE;
            }

            break;
        }

        case MODE_SET_FREE:
            break;

        case MODE_SET_ACTION:
        {
            XFER_MGR_UserInfo_T  user_info;
            UI32_T value;

#if (SYS_CPNT_ECCMIB == TRUE)
                struct sockaddr_in    *ipaddress;
                UI8_T  user_name[MAXSIZE_usmUserName+1];
                XFER_TYPE_Method_T method;
#endif//end of #if (SYS_CPNT_ECCMIB == TRUE)
                value = (*requests->requestvb->val.integer);
#if (SYS_CPNT_ECCMIB == TRUE)
                method.type=XFER_TYPE_METHOD_TYPE_SNMP;

                ipaddress = (struct sockaddr_in *)reqinfo->asp->pdu->transport_data;
                /* V1 or V2 model, copy community name*/
                if ( (reqinfo->asp->pdu->securityModel == SNMP_SEC_MODEL_SNMPv1) ||
                   (reqinfo->asp->pdu->securityModel == SNMP_SEC_MODEL_SNMPv2c))
                {
                    if (reqinfo->asp->pdu->community_len <=MAXSIZE_usmUserName)
                    {
                       memcpy(user_name, reqinfo->asp->pdu->community, reqinfo->asp->pdu->community_len);
                       user_name[reqinfo->asp->pdu->community_len]='\0';
                    }
                    else
                    {
                       strcpy(user_name, "");
                    }
                } /*v3 model copy user name*/
                else if (reqinfo->asp->pdu->securityModel == SNMP_SEC_MODEL_USM)
                {
                    if (reqinfo->asp->pdu->securityNameLen <=MAXSIZE_usmUserName)
                    {
                       memcpy(user_name, reqinfo->asp->pdu->securityName, reqinfo->asp->pdu->securityNameLen);
                       user_name[reqinfo->asp->pdu->securityNameLen]='\0';
                    }
                    else
                    {
                       strcpy(user_name, "");
                    }

                }
                else /* unknown model copy unknown user name*/
                {
                    strcpy( user_name, "unknown");
                }

                method.ip = ipaddress->sin_addr;
                strcpy(method.user, user_name);
                if (XFER_MGR_SetFileCopyMethod(&method)!= TRUE)
                {
                  netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
                }
#endif//end of #if (SYS_CPNT_ECCMIB == TRUE)

#if (SYS_CPNT_DBSYNC_TXT == TRUE)
            if (SNMP_MGR_SetTmpDirty(0) == FALSE)
            {
                SYSFUN_Debug_Printf("autoSave   Fail\n");
            }
#endif /* #if (SYS_CPNT_DBSYNC_TXT == TRUE) */

            memset(&user_info, 0, sizeof(user_info));
            fileCopyUserInfo_get(reqinfo, &user_info);

            if (XFER_PMGR_SetFileCopyAction(&user_info, value, 0, SYS_BLD_SNMP_GROUP_IPCMSGQ_KEY, 0) != TRUE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_fileCopyFileType(netsnmp_mib_handler *handler,
                    netsnmp_handler_registration *reginfo,
                    netsnmp_agent_request_info *reqinfo,
                    netsnmp_request_info *requests)
{
    switch (reqinfo->mode)
    {
        case MODE_GET:
        {
            XFER_MGR_FileCopyMgt_T entry;

            if (XFER_PMGR_GetFileCopyMgtEntry(&entry) != TRUE)
            {
                return SNMP_ERR_GENERR;
            }

            switch (entry.file_type)
            {
                case FS_FILE_TYPE_DIAG:
                    entry.file_type= VAL_fileCopyFileType_bootRom;
                    break;

                case FS_TYPE_OPCODE_FILE_TYPE:
                    entry.file_type=VAL_fileCopyFileType_opcode;
                    break;

                case FS_FILE_TYPE_CONFIG:
                    entry.file_type= VAL_fileCopyFileType_config;
                    break;

                case FS_FILE_TYPE_CERTIFICATE:
                    // FIXME:
                    // [PATCH: wrong syslog for copying cert](AOS5600-52X-00408)
                    // This convert is not correct also. Type is mismatched.
                    // entry.file_type= VAL_fileCopyFileType_publickey;
                    entry.file_type= entry.publickey_username[0] == '\0' ?
                        VAL_fileCopyFileType_certificate : VAL_fileCopyFileType_publickey;
                    break;

                case FS_FILE_TYPE_TOTAL:
                    entry.file_type= VAL_fileCopyFileType_loader;
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }

            long_return = entry.file_type;
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
        }

        case MODE_SET_RESERVE1:

        if (requests->requestvb->type != ASN_INTEGER)
        {
            return SNMP_ERR_WRONGTYPE;
        }

            break;

        case MODE_SET_RESERVE2:
        {
            UI32_T value;

            value = (*requests->requestvb->val.integer);

            if (   (value < VAL_fileCopyFileType_opcode)
                || (value > VAL_fileCopyFileType_config))
            {
                return SNMP_ERR_WRONGVALUE;
            }

            break;
        }

        case MODE_SET_FREE:
            break;

        case MODE_SET_ACTION:
        {
            UI32_T value;
            value = (*requests->requestvb->val.integer);

#if (SYS_CPNT_DBSYNC_TXT == TRUE)
            if (SNMP_MGR_SetTmpDirty(0) == FALSE)
            {
                SYSFUN_Debug_Printf("autoSave   Fail\n");
            }
#endif /* #if (SYS_CPNT_DBSYNC_TXT == TRUE) */

            if (XFER_PMGR_SetFileCopyFileType(value) != TRUE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_fileCopyDestOperType(netsnmp_mib_handler *handler,
                        netsnmp_handler_registration *reginfo,
                        netsnmp_agent_request_info *reqinfo,
                        netsnmp_request_info *requests)
{
    switch (reqinfo->mode)
    {
        case MODE_GET:
        {
            XFER_MGR_FileCopyMgt_T entry;

            if (XFER_PMGR_GetFileCopyMgtEntry(&entry) != TRUE)
            {
                return SNMP_ERR_GENERR;
            }

            long_return = entry.dest_oper_type;
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
        }

        case MODE_SET_RESERVE1:
            if (requests->requestvb->type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }

            if (requests->requestvb->val_len != sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;

        case MODE_SET_RESERVE2:
        {
            UI32_T value;

            value = (*requests->requestvb->val.integer);

            if (   ((value < VAL_fileCopyDestOperType_file) || (value > VAL_fileCopyDestOperType_tftp))
#if (SYS_CPNT_SFTP == TRUE)
                && (value != VAL_fileCopyDestOperType_sftp)
#endif /* #if (SYS_CPNT_SFTP == TRUE) */
#if (SYS_CPNT_XFER_FTP == TRUE)
                && (value != VAL_fileCopyDestOperType_ftp)
#endif /* #if (SYS_CPNT_XFER_FTP == TRUE) */
#if (SYS_CPNT_XFER_FTP_FTPS == TRUE)
                && (value != VAL_fileCopyDestOperType_ftps)
#endif /* #if (SYS_CPNT_XFER_FTP_FTPS == TRUE) */
#if (SYS_CPNT_CLI_ADD_TO_RUNNING_CONFIG == TRUE)
                && (value != VAL_fileCopyDestOperType_addRunningCfg)
#endif /* #if (SYS_CPNT_CLI_ADD_TO_RUNNING_CONFIG == TRUE) */
                && (value != VAL_fileCopyDestOperType_unit)
            )
            {
                return SNMP_ERR_WRONGVALUE;
            }

            break;
        }

        case MODE_SET_FREE:
            break;

        case MODE_SET_ACTION:
        {
            UI32_T value;

            value = (*requests->requestvb->val.integer);

#if (SYS_CPNT_DBSYNC_TXT == TRUE)
            if (SNMP_MGR_SetTmpDirty(0) == FALSE)
            {
                SYSFUN_Debug_Printf("autoSave   Fail\n");
            }
#endif /* #if (SYS_CPNT_DBSYNC_TXT == TRUE) */

            if (XFER_PMGR_SetFileCopyDestOperType(value) != TRUE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_fileCopyServerInetAddressType(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    switch (reqinfo->mode)
    {
        case MODE_GET:
        {
            XFER_MGR_FileCopyMgt_T entry;

            /* read from core layer
             */
            if (FALSE == XFER_PMGR_GetFileCopyMgtEntry(&entry))
            {
                return SNMP_ERR_GENERR;
            }

            long_return = entry.server_address.type;
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));

            break;
        }

        case MODE_SET_RESERVE1:
            if (requests->requestvb->type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }

            break;

        case MODE_SET_RESERVE2:
            switch (*requests->requestvb->val.integer)
            {
                case VAL_fileCopyServerInetAddressType_ipv4:
                case VAL_fileCopyServerInetAddressType_ipv6:
                case VAL_fileCopyServerInetAddressType_ipv4z:
                case VAL_fileCopyServerInetAddressType_ipv6z:
                    break;

                case VAL_fileCopyServerInetAddressType_unknown:
                case VAL_fileCopyServerInetAddressType_dns:
                default:
                    netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            }
            break;

        case MODE_SET_FREE:
            break;

        case MODE_SET_ACTION:
        {
            UI32_T value = (*requests->requestvb->val.integer);

            remote_server_address_type = value;
            break;
        }

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_fileCopyServerInetAddress(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    switch (reqinfo->mode)
    {
        case MODE_GET:
        {
            UI32_T var_len = 0;
            XFER_MGR_FileCopyMgt_T entry;
            UI32_T type, preflen;

            /* read from core layer
             */
            if (FALSE == XFER_PMGR_GetFileCopyMgtEntry(&entry))
            {
                return SNMP_ERR_GENERR;
            }

            /* convert to SNMP value
             */
            if (! SNMP_MGR_ConvertLInetAddrToInetAddrAndType(
                (L_INET_Addr_T *) &entry.server_address,
                &type, &var_len, return_buf, &preflen))
            {
                /* conversion failed
                 */
                var_len = 0;
            }

            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                     (u_char *) return_buf, var_len);

            break;
        }

        case MODE_SET_RESERVE1:
            if (requests->requestvb->type != ASN_OCTET_STR)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
                return SNMP_ERR_NOERROR;
            }
            if ((requests->requestvb->val_len < MINSIZE_fileCopyServerInetAddress)
                || (requests->requestvb->val_len > MAXSIZE_fileCopyServerInetAddress))
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGLENGTH);
                return SNMP_ERR_NOERROR;
            }
            break;

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            break;

        case MODE_SET_ACTION:
        {
            L_INET_AddrIp_T server_address;

            /* NOTE: InetAddressType and InetAddress
             *
             * The following checks use the corresponding InetAddressType.
             * If corresponding InetAddressType and InetAddress are in the
             * same packet, this check must be done in the sequence of
             * RESERVE1->RESERVE2->ACTION after InetAddressType is stored.
             */

            /* check address length based on address type
             */
            if (! SNMP_MGR_IsInetAddrLengthValid(
                remote_server_address_type,
                requests->requestvb->val_len))
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_INCONSISTENTVALUE);
                return SNMP_ERR_NOERROR;
            }

            /* check address value based on address type
             */
            if (! SNMP_MGR_IsInetAddrValueValid(
                remote_server_address_type,
                requests->requestvb->val.string))
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_INCONSISTENTVALUE);
                return SNMP_ERR_NOERROR;
            }

            /* compose address structure
             */
            if (! SNMP_MGR_ConvertInetAddrAndTypeToLInetAddr(remote_server_address_type,
                requests->requestvb->val_len, requests->requestvb->val.string, 0,
                (L_INET_Addr_T *) &server_address))
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
                return SNMP_ERR_NOERROR;
            }

            /* set to core layer
             */
            if (XFER_PMGR_SetFileCopyServerInetAddress(&server_address) != TRUE)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
                return SNMP_ERR_NOERROR;
            }

            /* clear InetAddressType to wait for next write;
             * It is ported from Galaxy.
             */
            remote_server_address_type = VAL_fileCopyServerInetAddressType_unknown;
            break;
        }

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

#if (SYS_CPNT_XFER_FTP == TRUE || SYS_CPNT_SFTP == TRUE)
int
do_fileCopyServerUserName(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    switch (reqinfo->mode)
    {
        case MODE_GET:
        {
            UI32_T var_len = 0;
            XFER_MGR_FileCopyMgt_T entry;

            if (FALSE == XFER_PMGR_GetFileCopyMgtEntry(&entry))
            {
                return SNMP_ERR_GENERR;
            }

            strncpy((char *)return_buf, (char *)entry.username, MAXSIZE_fileCopyServerUserName);
            return_buf[MAXSIZE_fileCopyServerUserName] = '\0';
            var_len = strlen((char *)return_buf);

            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, (u_char *)return_buf, var_len);
        }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            if (requests->requestvb->type != ASN_OCTET_STR)
            {
                return SNMP_ERR_WRONGTYPE;
            }

            if (requests->requestvb->val_len < MINSIZE_fileCopyServerUserName ||
                requests->requestvb->val_len > MAXSIZE_fileCopyServerUserName)
            {
                return SNMP_ERR_WRONGLENGTH;
            }

            break;
        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            break;

        case MODE_SET_ACTION:
        {
            UI8_T fileCopyServerUserName[MAXSIZE_fileCopyServerUserName + 1];

            memcpy(fileCopyServerUserName, requests->requestvb->val.string, requests->requestvb->val_len);
            fileCopyServerUserName[requests->requestvb->val_len] = '\0';

            if (XFER_PMGR_SetFileCopyServerUserName(fileCopyServerUserName) != TRUE)
            {
                return SNMP_ERR_COMMITFAILED;
            }
        }
            break;

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_fileCopyServerPassword(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    switch (reqinfo->mode)
    {
        case MODE_GET:
            strcpy((char *)return_buf, "");
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, (u_char *)return_buf, strlen((char *)return_buf));
            break;

        case MODE_SET_RESERVE1:
            if (requests->requestvb->type != ASN_OCTET_STR)
            {
                return SNMP_ERR_WRONGTYPE;
            }

            if (requests->requestvb->val_len < MINSIZE_fileCopyServerPassword ||
                requests->requestvb->val_len > MAXSIZE_fileCopyServerPassword)
            {
                return SNMP_ERR_WRONGLENGTH;
            }

            break;
        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            break;

        case MODE_SET_ACTION:
        {
            UI8_T fileCopyServerPassword[MAXSIZE_fileCopyServerPassword + 1];

            memcpy(fileCopyServerPassword, requests->requestvb->val.string, requests->requestvb->val_len);
            fileCopyServerPassword[requests->requestvb->val_len] = '\0';

            if (XFER_PMGR_SetFileCopyServerPassword(fileCopyServerPassword) != TRUE)
            {
                return SNMP_ERR_COMMITFAILED;
            }
        }
            break;

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
#endif /* #if (SYS_CPNT_XFER_FTP == TRUE || SYS_CPNT_SFTP == TRUE) */

/********************************************
 **************fileInfoTable*****************
 ********************************************
     */
static int
header_fileInfoTable(struct variable *vp,
               oid * name,
               size_t * length,
               int exact, size_t * var_len, WriteMethod ** write_method,
               UI32_T *index1, I8_T *index2, UI32_T *index2_len)
{

    oid    newname[MAX_OID_LEN];
    UI32_T    ifIndex=0;
    int    result;
   FS_File_Attr_T  entry;
   I8_T file_index2[MAXSIZE_fileInfoFileName+1];
   int return_val;
   oid  next_inst[1+MAXSIZE_fileInfoFileName];
   int i;
   UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

     memcpy((char *) newname, (char *) vp->name,
           (int) vp->namelen * sizeof(oid));
    /*
     * find "next" interface
     */
    memset(  &entry, 0 , sizeof(entry));

    /*
     * find "next" interface
     */
     entry.file_type_mask=FS_FILE_TYPE_MASK(FS_FILE_TYPE_DIAG)|FS_FILE_TYPE_MASK(FS_TYPE_OPCODE_FILE_TYPE)|FS_FILE_TYPE_MASK(FS_FILE_TYPE_CONFIG);

     while (  (return_val= FS_GetNextFileInfo( &ifIndex, &entry)) == FS_RETURN_OK)
     {
       strcpy((char *)file_index2, (char *)entry.file_name);

       next_inst[0] =ifIndex;
       for ( i = 0; i< strlen((char *)file_index2); i++)
       {
           next_inst[i+1] = file_index2[i];
       }

        memcpy( (char*)&newname[oid_name_length], (char*) next_inst,  (1+strlen((char *)file_index2))*sizeof(oid));
        result =
            snmp_oid_compare(name, *length, newname,
                             (int) vp->namelen + 1+strlen((char *)file_index2));
        if ((exact && (result == 0)) || (!exact && (result < 0)))
            break;
    }
    if (return_val!= FS_RETURN_OK ) {
        DEBUGMSGTL(("mibII/interfaces", "... index out of range\n"));
        return MATCH_FAILED;
    }
    memcpy((char *) name, (char *) newname,
           ((int) vp->namelen + 1+strlen((char *)file_index2)) * sizeof(oid));
    *length = vp->namelen + 1+strlen((char *)file_index2);
    *var_len = sizeof(long);    /* default to 'long' results */
    *index1 = ifIndex;
     strcpy( (char *)index2, (char *)file_index2);
     *index2_len = strlen((char *)index2);
    return TRUE;

}
/*EPR_ID:ES3628BT-FLF-ZZ-00286
  *Problem: ConfigurationFile-MIB: Node fileInfoFileType value is wrong.
  *Root Cause: fileInfoFileType's enumerate variable is wrong.Insert FS_FILE_TYPE_KERNEL before the fs type.
  *Solution: entry.file_type - 1.
  *Modified files:
  *        src\user\apps\snmpmgmt\v3\snmp\mibgroup\es3626a_superset2.0.c
  */
static int
mapping_fileInfoType(int mapping_type)
{
    int ture_type = 0;

    ture_type = mapping_type - 1;
    return ture_type;
}

/*
 * var_fileInfoTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_fileInfoTable(struct variable *vp,
                  oid * name,
                  size_t * length,
                  int exact, size_t * var_len, WriteMethod ** write_method)
{
    /* variables we may use later */

    UI32_T index1 = 0,index2_len = 0, retval;
    I8_T index2[MAXSIZE_fileInfoFileName+1];


    FS_File_Attr_T  entry;

    memset( &entry, 0, sizeof(entry));

     retval  = header_fileInfoTable(vp, name, length, exact, var_len, write_method,  &index1,index2, &index2_len);

    if (retval == MATCH_FAILED)
        return NULL;


    memcpy(entry.file_name,index2, index2_len);
    entry.file_type_mask=FS_FILE_TYPE_MASK(FS_FILE_TYPE_DIAG)|FS_FILE_TYPE_MASK(FS_TYPE_OPCODE_FILE_TYPE)|FS_FILE_TYPE_MASK(FS_FILE_TYPE_CONFIG);
    if (FS_GetFileInfo(index1, &entry)!= FS_RETURN_OK)
            return NULL;

    /*
     * * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
   #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
      case FILEINFOUNITID:
        long_return =index1;
        return (u_char *) &long_return;
      case FILEINFOFILENAME:
        strcpy(return_buf, index2);
        *var_len = strlen(return_buf);
        return (u_char *)return_buf;
   #endif
      case FILEINFOFILETYPE:
        /*EPR_ID:ES3628BT-FLF-ZZ-00286
         *Problem: ConfigurationFile-MIB: Node fileInfoFileType value is wrong.
         *Root Cause: fileInfoFileType's enumerate variable is wrong.Insert FS_FILE_TYPE_KERNEL before the fs type.
         *Solution: entry.file_type - 1.
         *Modified files:
         *        src\user\apps\snmpmgmt\v3\snmp\mibgroup\es3626a_superset2.0.c
         */
        long_return = mapping_fileInfoType(entry.file_type);
        return (u_char *) &long_return;
      case FILEINFOISSTARTUP:
        *write_method = write_fileInfoIsStartUp;
        long_return =entry.startup_file;
        if (long_return == 1)
        {
            long_return = VAL_fileInfoIsStartUp_true;
        }
        else if (long_return == 0)
        {
            long_return = VAL_fileInfoIsStartUp_false;
        }
        return (u_char *) &long_return;
      case FILEINFOFILESIZE:
        long_return =entry.file_size;
        return (u_char *) &long_return;
      case FILEINFOCREATIONTIME:
      {
        char creationTime[SIZE_fileInfoCreationTime];

        if (!SYS_TIME_ConvertTime(entry.create_time, creationTime))
            return NULL;
        strcpy((char *)return_buf, creationTime);
        *var_len = strlen((char *)return_buf);
        return (u_char *) return_buf;
      }
      case FILEINFODELETE:
        *write_method = write_fileInfoDelete;
        long_return =VAL_fileInfoDelete_noDelete;
        return (u_char *) &long_return;
    default:
        ERROR_MSG("");
    }
    return NULL;
}


int
write_fileInfoIsStartUp(int action,
                        u_char * var_val,
                        u_char var_val_type,
                        size_t var_val_len,
                        u_char * statP, oid * name, size_t name_len)
{
    int i;
    UI8_T buffer[MAXSIZE_fileInfoFileName+1];
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    UI32_T unit_id ;


    if ((char) name[oid_name_length-1] != FILEINFOISSTARTUP)
    {
        return SNMP_ERR_NOTWRITABLE;
    }

    if (name_len-oid_name_length-1 > MAXSIZE_fileInfoFileName+1)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    unit_id =  name[oid_name_length];   /*get unit id from oid */

    for (i = 0; i< name_len-oid_name_length-1 ; i++)
    {
        buffer[i] = name[oid_name_length+1+i];
    }
    buffer[name_len-oid_name_length-1] = '\0';

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          if (*(long *)var_val != VAL_fileInfoIsStartUp_true)
              return SNMP_ERR_WRONGVALUE;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
        {
            FS_File_Attr_T data;

            strcpy((char *)data.file_name, (char *)buffer);
            data.file_type_mask=FS_FILE_TYPE_MASK(FS_TYPE_OPCODE_FILE_TYPE)|FS_FILE_TYPE_MASK(FS_FILE_TYPE_CONFIG);


            if (FS_GetFileInfo(name[oid_name_length],&data)!=FS_RETURN_OK)
                return SNMP_ERR_COMMITFAILED;

            if (FS_SetStartupFilename(name[oid_name_length],data.file_type,data.file_name)!=FS_RETURN_OK)
            {
                return SNMP_ERR_COMMITFAILED;
            }
            /*if dut is master ,syn startup file to all slave*/
            {
                UI8_T my_unit_id = 0, i;
                UI8_T  unit_list[SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK] = {0};

                BOOL_T  stacking = FALSE;

                STKTPLG_POM_GetMasterUnitId(&my_unit_id);

                if (unit_id == my_unit_id)
                {
                    /*check current dut in stacking or stand alone mode if stacking syn to slave, if not ,return true*/
                    for(i=1; i<=SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK; i++)
                    {
                        if(i == my_unit_id)
                            continue;

                        if(STKTPLG_POM_UnitExist(i))
                        {
                            stacking = TRUE;
                            break;
                        }
                    }
                    if(!stacking)
                        break;


                    if (XFER_PMGR_AutoDownLoad(unit_list,
                                            buffer,
                                            buffer,
                                            data.file_type,
                                            TRUE,
                                            0,
                                            0,
                                            NULL) == FALSE)
                    {
                        return SNMP_ERR_COMMITFAILED;
                    }



              }
          }
       }
          break;
        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_fileInfoDelete(int action,
                     u_char * var_val,
                     u_char var_val_type,
                     size_t var_val_len,
                     u_char * statP, oid * name, size_t name_len)
{
    int i;
    char buffer[MAXSIZE_fileInfoFileName+1] = {0};
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    UI32_T unit_id ;

    if ((char) name[oid_name_length-1] != FILEINFODELETE)
    {
        return SNMP_ERR_NOTWRITABLE;
    }

    if (name_len-oid_name_length-1 > MAXSIZE_fileInfoFileName+1)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    unit_id =  name[oid_name_length];   /*get unit id from oid */

     for (i = 0; i< name_len-oid_name_length-1 ; i++)
    {
        buffer[i] = name[oid_name_length+1+i];
    }
    buffer[name_len - oid_name_length - 1] = '\0';

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          if (*(long *)var_val !=VAL_fileInfoDelete_delete)
              return SNMP_ERR_WRONGVALUE;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
        {
            FS_File_Attr_T file_attr;
            memset(&file_attr, 0, sizeof(FS_File_Attr_T));

            strcpy((char *)file_attr.file_name, buffer);

            if (!STKTPLG_POM_UnitExist(unit_id))
            {
                return SNMP_ERR_COMMITFAILED;
            }


            file_attr.file_type_mask = FS_FILE_TYPE_MASK(FS_TYPE_OPCODE_FILE_TYPE) |
                                       FS_FILE_TYPE_MASK(FS_FILE_TYPE_CONFIG);

            if( FS_GetFileInfo(unit_id, &file_attr) != FS_RETURN_OK)
            {
                return SNMP_ERR_COMMITFAILED;
            }
            else if(file_attr.file_type == FS_FILE_TYPE_CONFIG && strcmp(buffer, (char *)SYS_DFLT_restartConfigFile) == 0)
            {
                return SNMP_ERR_COMMITFAILED;
            }
            else if(file_attr.startup_file == TRUE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            if(FS_DeleteFile(unit_id, (UI8_T *)buffer)!=FS_RETURN_OK )
            {
                return SNMP_ERR_COMMITFAILED;
            }
        }
          break;
        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

/********************************************
 **************fileAutoDownloadResultTable*****************
 ********************************************
*/
#define fileAutoDownloadResultEntry_INSTANCE_LEN 1

static BOOL_T fileAutoDownloadResultTable_get(int      compc,
                                oid     *compl,
                                UI32_T *idx,
                                XFER_MGR_Auto_Download_T   *data)
{
    if (compc !=fileAutoDownloadResultEntry_INSTANCE_LEN)
    {
        return FALSE;
    }
    *idx=compl[0];

    if(SNMP_MGR_IsDebugMode())
        printf("fileAutoDownloadResultTable_get:idx=[%lu]\n", (unsigned long)*idx);

    if (!XFER_PMGR_GetAutoDownLoad_Status(*idx, data))
    {
        if(SNMP_MGR_IsDebugMode())
            printf("fileAutoDownloadResultTable_get:XFER_MGR_GetAutoDownLoad_Status return false\n");
        return FALSE;
    }
    else
    {
        return TRUE;
    } /*End of if */
}

static BOOL_T fileAutoDownloadResultTable_next(int      compc,
                                 oid     *compl,
                                 UI32_T *idx,
                                 XFER_MGR_Auto_Download_T    *data)
{
    UI32_T nIndex = 0;
    oid tmp_compl[fileAutoDownloadResultEntry_INSTANCE_LEN];

    /* Generate the instance of each table entry and find the
     * smallest instance that's larger than compc/compl.
     *
     * Step 1: Verify and extract the input key from "compc" and "compl"
     * Note: The number of input key is defined by "compc".
     *       The key for the specified instance is defined in compl.
     */

    memcpy(tmp_compl, compl, sizeof(tmp_compl));
    SNMP_MGR_checkCompl(0, 0, tmp_compl,SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK);
    SNMP_MGR_ConvertRemainToZero(compc,fileAutoDownloadResultEntry_INSTANCE_LEN, tmp_compl);
    nIndex = *idx = tmp_compl[0];


    if(SNMP_MGR_IsDebugMode())
        printf("fileAutoDownloadResultTable_next:idx=[%lu]\n", (unsigned long)*idx);

    if (compc<fileAutoDownloadResultEntry_INSTANCE_LEN)
    {
        if (!XFER_PMGR_GetAutoDownLoad_Status(nIndex, data))
        {
            if (!XFER_PMGR_GetNextAutoDownLoad_Status(idx, data))
            {
                if(SNMP_MGR_IsDebugMode())
                    printf("fileAutoDownloadResultTable_next: get & genext return false\n");
                return FALSE;
            }
        }
    }
    else
    {
        if (!XFER_PMGR_GetNextAutoDownLoad_Status(idx, data))
        {
            if(SNMP_MGR_IsDebugMode())
                printf("fileAutoDownloadResultTable_next: getnext return false\n");
            return FALSE;
        }
    }
    return TRUE;
}

/*
 * var_fileAutoDownloadResultTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_fileAutoDownloadResultTable(struct variable *vp,
                                oid * name,
                                size_t * length,
                                int exact,
                                size_t * var_len,
                                WriteMethod ** write_method)
{
    UI32_T compc=0;
    oid compl[fileAutoDownloadResultEntry_INSTANCE_LEN];
    oid best_inst[fileAutoDownloadResultEntry_INSTANCE_LEN];
    XFER_MGR_Auto_Download_T data;
    UI32_T idx;



    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl, fileAutoDownloadResultEntry_INSTANCE_LEN);

     /*check compc, retrive compl*/
    if (exact)/*get,set*/
    {
        if (!fileAutoDownloadResultTable_get(compc, compl, &idx, &data))
            return NULL;
    }
    else/*getnext*/
    {
        if (!fileAutoDownloadResultTable_next(compc, compl, &idx, &data))
            return NULL;
    }
    memcpy(name, vp->name, vp->namelen*sizeof(oid));
    best_inst[0]=idx;

    memcpy(name + vp->namelen, best_inst, fileAutoDownloadResultEntry_INSTANCE_LEN*sizeof(oid));
    *length = vp->namelen +fileAutoDownloadResultEntry_INSTANCE_LEN;

    *var_len = sizeof(long_return);

    /*
     * * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
      case FILEAUTODOWNLOADRESULTUNITID:
        long_return = idx;
        return (u_char*) &long_return;
#endif
      case FILEAUTODOWNLOADRESULTACTION:
        long_return = data.copy_action;
        return (u_char*) &long_return;
      case FILEAUTODOWNLOADRESULTSTATUS:
        long_return = data.auto_download_status;
        return (u_char*) &long_return;
    default:
        ERROR_MSG("");
    }
    return NULL;
}


#if(SYS_CPNT_XFER_AUTO_UPGRADE==TRUE)
/********************************************
 *************fileAutoUpgradeMgt***************
 ********************************************
 */

int
do_fileAutoUpgradeOpCodePath(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    switch (reqinfo->mode)
    {
        case MODE_GET:
        {
            UI32_T var_len = 0;
            char buffer[MAXSIZE_fileAutoUpgradeOpCodePath+1]={0};

            if (XFER_PMGR_GetAutoOpCodeUpgradePath(buffer) == TRUE)
            {
                var_len = strlen(buffer);
                snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,(u_char *)buffer, var_len);
            }
            else
            {
                return SNMP_ERR_GENERR;
            }
            break;
        }

        case MODE_SET_RESERVE1:
            if (requests->requestvb->type != ASN_OCTET_STR)
            {
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
            }

            if (requests->requestvb->val_len < MINSIZE_fileAutoUpgradeOpCodePath ||
                requests->requestvb->val_len > MAXSIZE_fileAutoUpgradeOpCodePath)
            {
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGLENGTH);
            }
            break;

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called.
             */
            break;

        case MODE_SET_ACTION:
        {
            char fileAutoUpgradeOpCodePath[MAXSIZE_fileAutoUpgradeOpCodePath + 1];
            memcpy(fileAutoUpgradeOpCodePath, requests->requestvb->val.string,requests->requestvb->val_len);
            fileAutoUpgradeOpCodePath[requests->requestvb->val_len] = '\0';

            if (XFER_PMGR_SetAutoOpCodeUpgradePath(fileAutoUpgradeOpCodePath) != TRUE)
            {
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_COMMITFAILED);
            }
        }
            break;

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;

    }


int
do_fileAutoUpgradeOpCodeStatus(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    switch (reqinfo->mode)
    {
        case MODE_GET:
        {
            UI32_T value = 0;

            if (XFER_PMGR_GetAutoOpCodeUpgradeStatus(&value) == TRUE)
            {
                long_return = value;
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,(u_char *)&long_return, sizeof(long_return));
            }
            else
            {
                return SNMP_ERR_GENERR;
            }
        }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:

            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
            }

            break;

        case MODE_SET_RESERVE2:

            switch (*requests->requestvb->val.integer)
            {
                case VAL_fileAutoUpgradeOpCodeStatus_enabled:
                    break;
                case VAL_fileAutoUpgradeOpCodeStatus_disabled:
                    break;

                default:
                    netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called.
             */
            break;

        case MODE_SET_ACTION:
        {
            if (XFER_PMGR_SetAutoOpCodeUpgradeStatus(*requests->requestvb->val.integer) != TRUE)
            {
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_COMMITFAILED);
            }
        }
            break;

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int get_fileAutoUpgradeOpCodeFileName(netsnmp_mib_handler *handler,
    netsnmp_handler_registration *reginfo,
    netsnmp_agent_request_info *reqinfo,
    netsnmp_request_info *requests)
{
    switch (reqinfo->mode)
    {
        case MODE_GET:
        {
            UI32_T var_len = 0;

            if (XFER_PMGR_GetAutoOpCodeUpgradeFileName((char *)return_buf) == TRUE)
            {
                var_len = strlen((char *)return_buf);
                snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, (u_char *)return_buf, var_len);
            }
            else
            {
                return SNMP_ERR_GENERR;
            }

            break;
        }

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int do_fileAutoUpgradeOpCodeReloadStatus(netsnmp_mib_handler *handler,
    netsnmp_handler_registration *reginfo,
    netsnmp_agent_request_info *reqinfo,
    netsnmp_request_info *requests)
{
    /* dispatch get vs. set
     */
    switch (reqinfo->mode)
    {
        /* GET REQUEST
         */
        case MODE_GET:
        {
            UI32_T var_len = 0;
            UI32_T get_reload_status = 0;

            /* get from core layer
             */
            if (XFER_PMGR_GetAutoOpCodeUpgradeReloadStatus(&get_reload_status) != TRUE)
            {
                return SNMP_ERR_GENERR;
            }
            else
            {
                long_return = get_reload_status;
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                    (u_char *) &long_return, sizeof(long_return));
            }

            break;
        }

        /* SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            /* check type and length
             */
            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
                return SNMP_ERR_NOERROR;
            }

            break;

        case MODE_SET_RESERVE2:
            switch (*requests->requestvb->val.integer)
            {
                case VAL_fileAutoUpgradeOpCodeReloadStatus_enabled:
                    break;

                case VAL_fileAutoUpgradeOpCodeReloadStatus_disabled:
                    break;

                default:
                    netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
                    return SNMP_ERR_NOERROR;
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called.
             */
            break;

        case MODE_SET_ACTION:
        {
            /* set to core layer
             */
            if (XFER_PMGR_SetAutoOpCodeUpgradeReloadStatus(*requests->requestvb->val.integer) != TRUE)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
                return SNMP_ERR_NOERROR;
            }

            break;
        }

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
#endif /* #if(SYS_CPNT_XFER_AUTO_UPGRADE==TRUE) */

#if (SYS_CPNT_DNS == TRUE)
/********************************************
 *********************dnsMgt*****************
 ********************************************
 */
int
do_dnsDomainName(netsnmp_mib_handler *handler,
                 netsnmp_handler_registration *reginfo,
                 netsnmp_agent_request_info *reqinfo,
                 netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
            {

                char buffer[SYS_ADPT_DNS_MAX_NAME_LENGTH+1];

                memset(buffer, 0, SYS_ADPT_DNS_MAX_NAME_LENGTH+1);

                if (DNS_OK!=DNS_PMGR_GetDnsIpDomain((char *)buffer))
                {
                      strcpy((char *)return_buf, "");
                }
                else
                {
                     strcpy((char *)return_buf, (char *)buffer);
                }
               snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, (u_char *) return_buf, strlen((char *)return_buf));
           }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            if (requests->requestvb->type != ASN_OCTET_STR)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
            }

            if (requests->requestvb->val_len < MINSIZE_dnsDomainName || requests->requestvb->val_len > SYS_ADPT_DNS_MAX_NAME_LENGTH)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGLENGTH);
            }
            break;

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
           {
               char  buffer[SYS_ADPT_DNS_MAX_NAME_LENGTH+1];

               memset(buffer, 0, SYS_ADPT_DNS_MAX_NAME_LENGTH+1);
               memcpy(buffer, requests->requestvb->val.string, requests->requestvb->val_len);
               buffer[requests->requestvb->val_len]= '\0';

               if (   ('\0' != buffer[0])
                   && (L_CHARSET_IsValidUserNameString((const char *)buffer) == 0))
               {
                    netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
                    break;
               }
               if (!L_STDLIB_StrIsAsciiPrintWithCount((char *)buffer, requests->requestvb->val_len))
               {
                    netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
                    break;
               }
               if (strlen((char *)buffer) == 0)
               {
                  if (DNS_PMGR_DeleteDomainName() != DNS_OK)
                  {
                      netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
                      break;
                  }
               }
               else
               {
                   if (DNS_PMGR_AddDomainName(buffer)!= DNS_OK)
                   {
                       netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
                       break;
                   }
               }
            }
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */

            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */

            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
do_dnsDomainLookup(netsnmp_mib_handler *handler,
                   netsnmp_handler_registration *reginfo,
                   netsnmp_agent_request_info *reqinfo,
                   netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
        {
             UI32_T status;
             status=DNS_PMGR_GetDnsStatus();
                  long_return =status;

                     snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
        }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
            }
            break;

        case MODE_SET_RESERVE2:
            switch (*requests->requestvb->val.integer)
            {
                case VAL_dnsDomainLookup_enabled:
                    break;

                case VAL_dnsDomainLookup_disabled:
                    break;

                default:
                    netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
             {
                UI32_T value;
                value = (*requests->requestvb->val.integer);
                 if (DNS_PMGR_SetDnsStatus(value) != TRUE)
                       netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);

            }
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

/********************************************
 *****************dnsHostTable***************
 ********************************************
 */
#define DNSHOSTENTRY_INSTANCE_LEN  1

BOOL_T dnsHostTable_OidIndexToData(UI32_T exact, UI32_T compc,
            oid * compl,  UI32_T *dnsHostIndex)
     {
    /* get or write */
    if (exact)
       {
        /* check the index length */
        if (compc != DNSHOSTENTRY_INSTANCE_LEN) /* the constant size index */
        {
            return FALSE;
        }
    }

    *dnsHostIndex = compl[0];

    return TRUE;
}

/*
 * var_dnsHostTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_dnsHostTable(struct variable *vp,
                 oid * name,
                 size_t * length,
                 int     exact,
                 size_t  *var_len,
                 WriteMethod **write_method)
{
    /* variables we may use later */
    I8_T  hostname_ar[MAXSIZE_dnsHostName+1]={0};
    UI32_T host_idx;
    UI32_T compc = 0;
    oid compl[DNSHOSTENTRY_INSTANCE_LEN] = {0};
    oid best_inst[DNSHOSTENTRY_INSTANCE_LEN] = {0};

    switch(vp->magic)
     {
        case LEAF_dnsHostName:
            *write_method = write_dnsHostName;
            break;

        case LEAF_dnsHostStatus:
            *write_method = write_dnsHostStatus;
        break;

    default:
            *write_method = 0;
            break;
    }

    /* check compc, retrive compl */
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,
                           compl, DNSHOSTENTRY_INSTANCE_LEN);

    if (exact) /* get,set */
    {
        /* get index */
        if (dnsHostTable_OidIndexToData(exact, compc, compl, &host_idx) == FALSE)
        {
        return NULL;
        }

        /* get data */
        if (DNS_PMGR_GetDnsHostEntryForSnmp(host_idx, hostname_ar) != TRUE)
        {
            return NULL;
        }
}
    else /* getnext */
{
        /* get index */
        dnsHostTable_OidIndexToData(exact, compc, compl, &host_idx);

        /* check the length of inputing index,if < 1 we should try get
         * {0.0.0.0.0...}
         */
        if (compc < 1)
        {
            /* get data */
            if (DNS_PMGR_GetDnsHostEntryForSnmp(host_idx, hostname_ar) != TRUE)
            {
                /* get next data */
                if (DNS_PMGR_GetNextDnsHostEntryForSnmp(&host_idx, hostname_ar) != TRUE)
                {
                    return NULL;
                }
            }
        }
        else
        {
            /* get next data */
            if (DNS_PMGR_GetNextDnsHostEntryForSnmp(&host_idx, hostname_ar) != TRUE)
            {
                return NULL;
            }
        }
    }

    memcpy(name, vp->name, vp->namelen*sizeof(oid));

    /* assign data to the oid index */
    best_inst[0] = host_idx;
    memcpy(name + vp->namelen, best_inst,
           DNSHOSTENTRY_INSTANCE_LEN * sizeof(oid));
    *length = vp->namelen + DNSHOSTENTRY_INSTANCE_LEN ;

    /* this is where we do the value assignments for the mib results. */
    switch (vp->magic)
    {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case LEAF_dnsHostIndex:
            *var_len = sizeof(long_return);
            long_return = host_idx;
        return (u_char *) &long_return;

#endif

        case LEAF_dnsHostName:
            *var_len  =  strlen((char *)hostname_ar);
            memcpy(return_buf, hostname_ar, *var_len);
            return (u_char*)return_buf;

        case LEAF_dnsHostStatus:
            *var_len = sizeof(long_return);
            long_return = VAL_dnsHostStatus_valid;
        return (u_char *) &long_return;

    default:
        ERROR_MSG("");
    }

    return NULL;
}

int
write_dnsHostName(int      action,
            u_char * var_val,
            u_char var_val_type,
            size_t var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    switch (action)
    {
      case RESERVE1:
            if (var_val_type != ASN_OCTET_STR)
            {
                 return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len < MINSIZE_dnsHostName ||
                var_val_len > MAXSIZE_dnsHostName)
        {
        return SNMP_ERR_WRONGLENGTH;
        }

        break;

      case RESERVE2:
        break;

      case FREE:

        /*
         * Release any resources that have been allocated
         */

        break;

      case ACTION:
      {
                UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5 ;
                UI32_T dnsHostIndex = 0;
                I8_T  temp_dns_hostname_ar[MAXSIZE_dnsHostName + 1] = {0};

                if (dnsHostTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &dnsHostIndex) == FALSE)
                    return SNMP_ERR_COMMITFAILED;

                memcpy(temp_dns_hostname_ar, var_val, var_val_len);
                temp_dns_hostname_ar[var_val_len] = '\0';

                if (DNS_PMGR_SetDnsHostEntry( dnsHostIndex, temp_dns_hostname_ar) != TRUE)
                {
                    return SNMP_ERR_COMMITFAILED;
                }
            }
            break;

        case UNDO:
        break;

      case COMMIT:

        /*
         *
         * * Things are working well, so it's now safe to make the change
         * * permanently.  Make sure that anything done here can't fail!
         */

        break;
      }

      return SNMP_ERR_NOERROR;
}

int
write_dnsHostStatus(int      action,
                    u_char * var_val,
                    u_char var_val_type,
                    size_t var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
          break;

        case RESERVE2:
            switch (*(long *)var_val)
            {
                case VAL_dnsHostStatus_valid:
                    break;

                case VAL_dnsHostStatus_invalid:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
           }
          break;

        case FREE:
          break;

        case ACTION:
        {
                UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
                UI32_T dnsHostIndex = 0;
                I32_T  value = 0;

                if (dnsHostTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &dnsHostIndex) == FALSE)
                    return SNMP_ERR_COMMITFAILED;

                value = *(long *)var_val;

                if(value == VAL_dnsHostStatus_invalid)
                {
                    /* destroy */
                    if (DNS_PMGR_DestroyDnsHostEntry( dnsHostIndex) != TRUE)
                    {
                         return SNMP_ERR_COMMITFAILED;
                    }
                }
                else
                {
                    if (DNS_PMGR_CreateDnsHostEntry( dnsHostIndex) != TRUE)
                    {
                          return SNMP_ERR_COMMITFAILED;
                    }
                }
        }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


/********************************************
 *****************dnsAliasTable**************
 ********************************************
 */
static int
header_dnsAliasTable(struct variable *vp,
               oid * name,
               size_t * length,
               int exact, size_t * var_len, WriteMethod ** write_method,
               UI8_T *index1, UI8_T *index2)
{

    oid    newname[MAX_OID_LEN];
    int    result;
    I8_T dns_index1[MAXSIZE_dnsHostName+1];
    I8_T dns_index2[MAXSIZE_dnsAliasAlias+1];
    int return_val;
    oid  next_inst[2+MAXSIZE_dnsHostName+MAXSIZE_dnsAliasAlias];
    int i;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;

     memcpy((char *) newname, (char *) vp->name,
           (int) vp->namelen * sizeof(oid));
    /*
     * find "next" interface
     */

    dns_index1[0]=0;
    dns_index2[0]=0;
    /*
     * find "next" interface
     */

 while (  (return_val= DNS_PMGR_GetNextDnsAliasNameBySnmp( dns_index1, dns_index2)) == DNS_OK)
     {

       next_inst[0] =strlen((char *)dns_index1);

       for ( i = 0; i< strlen((char *)dns_index1); i++)
       {
           next_inst[i+1] = dns_index1[i];
       }

       next_inst[next_inst[0]+1] = strlen((char *)dns_index2);

       for (i = 0; i < strlen((char *)dns_index2); i++)
       {
           next_inst[next_inst[0]+2+i] = dns_index2[i];
        }

       memcpy( (char*)&newname[oid_name_length], (char*) next_inst,  (2+strlen((char *)dns_index1)+strlen((char *)dns_index2))*sizeof(oid));
       result =
            snmp_oid_compare(name, *length, newname,
                             (int) vp->namelen + 2+strlen((char *)dns_index1)+strlen((char *)dns_index2));
        if ((exact && (result == 0)) || (!exact && (result < 0)))
            break;
    }
    if (return_val!= DNS_OK ) {
        DEBUGMSGTL(("mibII/interfaces", "... index out of range\n"));
        return MATCH_FAILED;
    }
    memcpy((char *) name, (char *) newname,
           ((int) vp->namelen + 2+strlen((char *)dns_index1)+strlen((char *)dns_index2)) * sizeof(oid));
    *length = vp->namelen + 2+strlen((char *)dns_index1)+strlen((char *)dns_index2);
    *var_len = sizeof(long);    /* default to 'long' results */
    strcpy((char *)index1, (char *)dns_index1);
    strcpy((char *)index2, (char *)dns_index2);
    return TRUE;

}


/*
 * var_dnsAliasTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_dnsAliasTable(struct variable *vp,
                  oid * name,
                  size_t * length,
                  int exact, size_t * var_len, WriteMethod ** write_method)
{
    /* variables we may use later */

    UI32_T  retval;
    I8_T index1[MAXSIZE_dnsHostName+1];
    I8_T index2[MAXSIZE_dnsAliasAlias+1];


     retval  = header_dnsAliasTable(vp, name, length, exact, var_len, write_method, (UI8_T *)index1, (UI8_T *)index2);

    if (retval == MATCH_FAILED)
        return NULL;


    if (DNS_PMGR_GetDnsAliasNameBySnmp(index1, index2)!= DNS_OK)
            return NULL;

    /*
     * * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
      case DNSALIASNAME:
        strcpy((char *)return_buf, (char *)index1);
        *var_len = strlen((char *)return_buf);
        return (u_char *)return_buf;
      case DNSALIASALIAS:
        strcpy((char *)return_buf, (char *)index2);
        *var_len = strlen((char *)return_buf);
        return (u_char *)return_buf;
    default:
        ERROR_MSG("");
    }
    return NULL;
}

/********************************************
 ***************dnsDomainListTable***********
 ********************************************
     */
#define DNSDOMAINLISTENTRY_INSTANCE_LEN  1

BOOL_T dnsDomainListTable_OidIndexToData(UI32_T exact, UI32_T compc,
            oid * compl,  UI32_T *dnsDomainListIndex)
     {
    /* get or write */
    if (exact)
    {
        /* check the index length */
        if (compc != DNSDOMAINLISTENTRY_INSTANCE_LEN) /* the constant size index */
        {
            return FALSE;
        }
    }

    *dnsDomainListIndex = compl[0];

    return TRUE;
}

/*
 * var_dnsDomainListTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_dnsDomainListTable(struct variable *vp,
                       oid * name,
                       size_t * length,
                       int exact,
                       size_t  *var_len,
                       WriteMethod **write_method)
{
    /* variables we may use later */
    UI32_T compc = 0;
    UI32_T domain_idx;
    I8_T  domain_name_ar[MAXSIZE_dnsDomainListName+1]={0};
    oid compl[DNSDOMAINLISTENTRY_INSTANCE_LEN] = {0};
    oid best_inst[DNSDOMAINLISTENTRY_INSTANCE_LEN] = {0};

    switch(vp->magic)
     {
        case LEAF_dnsDomainListName:
            *write_method = write_dnsDomainListName;
            break;

        case LEAF_dnsDomainListStatus:
        *write_method = write_dnsDomainListStatus;
        break;

    default:
            *write_method = 0;
            break;
    }

    /* check compc, retrive compl */
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,
                           compl, DNSDOMAINLISTENTRY_INSTANCE_LEN);

    if (exact) /* get,set */
    {
        /* get index */
        if (dnsDomainListTable_OidIndexToData(exact, compc, compl, &domain_idx) == FALSE)
        {
        return NULL;
        }

        /* get data */
        if (DNS_POM_GetDomainNameListEntry(domain_idx, domain_name_ar) != TRUE)
        {
            return NULL;
        }
    }
    else /* getnext */
    {
        /* get index */
        dnsDomainListTable_OidIndexToData(exact, compc, compl, &domain_idx);

        /* check the length of inputing index,if < 1 we should try get
         * {0.0.0.0.0...}
         */
        if (compc < 1)
        {
            /* get data */
            if (DNS_POM_GetDomainNameListEntry(domain_idx, domain_name_ar) != TRUE)
            {
                /* get next data */
                if (DNS_POM_GetNextDomainNameListEntry(&domain_idx, domain_name_ar) != TRUE)
                {
                    return NULL;
                }
            }
        }
        else
        {
            /* get next data */
            if (DNS_POM_GetNextDomainNameListEntry(&domain_idx, domain_name_ar) != TRUE)
            {
                return NULL;
            }
        }
    }

    memcpy(name, vp->name, vp->namelen*sizeof(oid));

    /* assign data to the oid index */
    best_inst[0] = domain_idx;
    memcpy(name + vp->namelen, best_inst,
           DNSDOMAINLISTENTRY_INSTANCE_LEN * sizeof(oid));
    *length = vp->namelen + DNSDOMAINLISTENTRY_INSTANCE_LEN ;

    /* this is where we do the value assignments for the mib results. */
    switch (vp->magic)
    {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case LEAF_dnsDomainListIndex:
            *var_len = sizeof(long_return);
            long_return = domain_idx;
            return (u_char *) &long_return;

#endif
        case LEAF_dnsDomainListName:
            *var_len  =   strlen((char *)domain_name_ar);
            memcpy(return_buf, domain_name_ar, *var_len);
            return (u_char*)return_buf;

        case LEAF_dnsDomainListStatus:
            *var_len = sizeof(long_return);
        long_return = VAL_dnsDomainListStatus_valid;
        return (u_char*) &long_return;

    default:
        ERROR_MSG("");
    }

    return NULL;
}

int
write_dnsDomainListName(int      action,
                          u_char * var_val,
                          u_char var_val_type,
                          size_t var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_OCTET_STR)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len < MINSIZE_dnsDomainListName ||
                var_val_len > MAXSIZE_dnsDomainListName)
            {
                   return SNMP_ERR_WRONGLENGTH;
            }
            break;

        case RESERVE2:
            break;

        case FREE:
            break;

        case ACTION:
        {
                UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
                UI32_T dnsDomainListIndex = 0;
                I8_T  tmp_dns_domain_name_ar[MAXSIZE_dnsDomainListName+1]={0};

                if (dnsDomainListTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &dnsDomainListIndex) == FALSE)
                    return SNMP_ERR_COMMITFAILED;

                memcpy(tmp_dns_domain_name_ar, var_val, var_val_len);
                tmp_dns_domain_name_ar[var_val_len] = '\0';

                if (DNS_PMGR_SetDomainNameListEntry( dnsDomainListIndex, tmp_dns_domain_name_ar) != TRUE)
                {
                     return SNMP_ERR_COMMITFAILED;
                }
            }
            break;

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

int
write_dnsDomainListStatus(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
              return SNMP_ERR_WRONGTYPE;
          }
          break;

        case RESERVE2:
            switch (*(long *)var_val)
            {
                case VAL_dnsDomainListStatus_valid:
                    break;

                case VAL_dnsDomainListStatus_invalid:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
               {
                UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
                UI32_T dnsDomainListIndex = 0;
                I32_T  value = 0;

                if (dnsDomainListTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]),  &dnsDomainListIndex) == FALSE)
                    return SNMP_ERR_COMMITFAILED;

                value = *(long *)var_val;

                if(value == VAL_dnsDomainListStatus_invalid)
                 {
                    /* destroy */
                    if (DNS_PMGR_DestroyDomainNameListEntry( dnsDomainListIndex) != TRUE)
                   {
                      return SNMP_ERR_COMMITFAILED;
                    }
                 }
                else
                {
                    if (DNS_PMGR_CreateDomainNameListEntry( dnsDomainListIndex) != TRUE)
                    {
                       return SNMP_ERR_COMMITFAILED;
                    }
                }
                }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

/********************************************
 **************dnsCacheTable*****************
 ********************************************
 */

#define DNSCACHEENTRY_INSTANCE_LEN  1

BOOL_T dnsCacheTable_OidIndexToData(UI32_T exact, UI32_T compc,
            oid * compl,  UI32_T *dnsCacheIndex)
{
    /* get or write */
    if (exact)
    {
        /* check the index length */
        if (compc != DNSCACHEENTRY_INSTANCE_LEN) /* the constant size index */
        {
            return FALSE;
        }
    }

    *dnsCacheIndex = compl[0];

    return TRUE;
}

/*
 * var_dnsCacheTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_dnsCacheTable(struct variable *vp,
                  oid * name,
                  size_t * length,
            int     exact,
            size_t  *var_len,
            WriteMethod **write_method)
{
    /* variables we may use later */
    UI32_T   compc=0;
    oid compl[DNSCACHEENTRY_INSTANCE_LEN] = {0};
    oid best_inst[DNSCACHEENTRY_INSTANCE_LEN] = {0};
    DNS_CacheRecord_T entry;
    UI32_T nIndex =0;

    switch (vp->magic)
    {
        default:
            *write_method = 0;
            break;
    }

    /* check compc, retrive compl */
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,
                           compl, DNSCACHEENTRY_INSTANCE_LEN);

    memset(&entry, 0, sizeof(entry));

    if (exact)/*get,set*/
    {
        /* get index */
        if (dnsCacheTable_OidIndexToData(exact, compc, compl,  &nIndex) == FALSE)
        {
            return NULL;
        }

        /* get data */
        if (DNS_PMGR_GetCacheEntryForSNMP((I32_T)nIndex, &entry) != TRUE)
        {
            return NULL;
        }
    }
    else/*getnext*/
    {
        /* get index */
        dnsCacheTable_OidIndexToData(exact, compc, compl,  &nIndex);

        /* check the length of inputing index,if < 1 we should try get
         * {0.0.0.0.0...}
         */
        if (compc < 1)
        {
            /* get data */
            if (DNS_PMGR_GetCacheEntryForSNMP((I32_T)nIndex, &entry) != TRUE)
            {
                /* get next data */
                if (DNS_PMGR_GetNextCacheEntryForSNMP((I32_T *)&nIndex, &entry) != TRUE)
                {
            return NULL;
    }
            }
        }
        else
        {
            /* get next data */
            if (DNS_PMGR_GetNextCacheEntryForSNMP((I32_T *)&nIndex, &entry) != TRUE)
            {
                  return NULL;
            }
        }
    }

    memcpy(name, vp->name, vp->namelen*sizeof(oid));

    /* assign data to the oid index */
    best_inst[0] = nIndex;
    memcpy(name + vp->namelen, best_inst, DNSCACHEENTRY_INSTANCE_LEN * sizeof(oid));
    *length = vp->namelen + DNSCACHEENTRY_INSTANCE_LEN ;

    /* this is where we do the value assignments for the mib results. */
    switch (vp->magic)
    {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case LEAF_dnsCacheIndex:
            *var_len = sizeof(long_return);
           long_return = nIndex;
           return (u_char*) &long_return;
#endif
        case LEAF_dnsCacheFlag:
            *var_len = sizeof(long_return);
            long_return = entry.flag;
           return (u_char*) &long_return;

        case LEAF_dnsCacheType:
            *var_len = sizeof(long_return);
            long_return = entry.type;

           if (long_return == DNS_CACHE_ENTRY_TYPE_CNAME)
           {
                long_return = VAL_dnsCacheType_address;
           }
           else if (long_return == DNS_CACHE_ENTRY_TYPE_ALIAS)
           {
                long_return = VAL_dnsCacheType_cname;
           }
           else
           {
              long_return = 0;
           }

           return (u_char*) &long_return;

        case LEAF_dnsCacheIp:
        {
            UI32_T value = 0;

            IP_LIB_ArraytoUI32(entry.ip.addr, &value);

            *var_len = sizeof(ipaddr_return);
            ipaddr_return = value;
            return (u_char*) &ipaddr_return;
        }

        case LEAF_dnsCacheTtl:
            *var_len = sizeof(long_return);
            long_return = entry.ttl;
           return (u_char*) &long_return;

        case LEAF_dnsCacheDomain:
           strcpy((char *)return_buf,entry.name);
           *var_len = strlen(entry.name);
           return (u_char*)return_buf;

        case LEAF_dnsCacheInetAddressType:
            *var_len = sizeof(long_return);
            long_return = entry.ip.type;
           return (u_char*) &long_return;

        case LEAF_dnsCacheInetAddress:
            *var_len  = entry.ip.addrlen;
            memcpy(return_buf, entry.ip.addr, *var_len);
           return (u_char*)return_buf;

      default:
           ERROR_MSG("");
    }

    return NULL;
}

/********************************************
 **************dnsAliasByIdTable*************
 ********************************************
 */
#if 0
#define dnsAliasByIdEntry_INSTANCE_LEN 2

static BOOL_T dnsAliasByIdTable_get(int      compc,
                                    oid     *compl,
                                    DNS_AliasRecord_T   *data)
{
    UI8_T nIndexName  = 0;
    UI8_T nIndexAlias = 0;

    if (compc != dnsAliasByIdEntry_INSTANCE_LEN)
    {
        return FALSE;
    }
    nIndexName  = (UI8_T)compl[0];
    nIndexAlias = (UI8_T)compl[1];

    if (!DNS_MGR_GetAliasByIdEntry(nIndexName, nIndexAlias, data))
    {
        return FALSE;
    }
    else
    {
        return TRUE;
    }
}

static BOOL_T dnsAliasByIdTable_next(int                compc,
                                     oid                *compl,
                                     DNS_AliasRecord_T  *data)
{
    UI8_T nIndexName  = 0;
    UI8_T nIndexAlias = 0;
    oid tmp_compl[dnsAliasByIdEntry_INSTANCE_LEN];

    memcpy(tmp_compl, compl, sizeof(tmp_compl));
    SNMP_MGR_ConvertRemainToZero(compc, dnsAliasByIdEntry_INSTANCE_LEN, tmp_compl);

    nIndexName  = tmp_compl[0];
    nIndexAlias = tmp_compl[1];

    if (compc < dnsAliasByIdEntry_INSTANCE_LEN)
    {
        if (!DNS_MGR_GetAliasByIdEntry(&nIndexName, &nIndexAlias, data))
        {
            if (!DNS_MGR_GetNextAliasByIdEntry(&nIndexName, &nIndexAlias, data))
            {
                return FALSE;
            }
        }
    }
    else
    {
        if (!DNS_MGR_GetNextAliasByIdEntry(&nIndexName, &nIndexAlias, data))
        {
            return FALSE;
        }
    }
    return TRUE;
}

unsigned char  *
var_dnsAliasByIdTable(struct variable *vp,
                      oid * name,
                      size_t * length,
                      int exact,
                      size_t * var_len, WriteMethod ** write_method)
{
    UI32_T   compc=0;
    oid compl[dnsAliasByIdEntry_INSTANCE_LEN];
    oid best_inst[dnsAliasByIdEntry_INSTANCE_LEN];
    DNS_AliasRecord_T data;

    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl, dnsAliasByIdEntry_INSTANCE_LEN);

    if (exact)
    {
        if (!dnsAliasByIdTable_get(compc, compl, &data))
            return NULL;
    }
    else
    {
        if (!dnsAliasByIdTable_next(compc, compl, &data))
            return NULL;
    }

    memcpy(name, vp->name, vp->namelen*sizeof(oid));
    best_inst[0] = data->name_index;
    best_inst[1] = data->alias_index;

    memcpy(name + vp->namelen, best_inst, dnsAliasByIdEntry_INSTANCE_LEN * sizeof(oid));

    *length = vp->namelen + dnsAliasByIdEntry_INSTANCE_LEN;
    *var_len = sizeof(long_return);

    switch (vp->magic)
    {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)

      case DNSALIASBYIDNAMEINDEX:
           long_return = data->name_index;
           return (u_char*) &long_return;

      case DNSALIASBYIDALIASINDEX:
           long_return = data->alias_index;
           return (u_char*) &long_return;

#endif
      case DNSALIASBYIDNAME:
           strcpy(return_buf, data->name);
           *var_len = strlen(data->name);
           return (u_char*)return_buf;

      case DNSALIASBYIDALIAS:
           strcpy(return_buf, data->alias_name);
           *var_len = strlen(data->alias_name);
           return (u_char*)return_buf;

      default:
           ERROR_MSG("");
    }
    return NULL;
}
#endif

/********************************************
 ***************dnsHostAddrTable***************
 ********************************************
 */
#if (SYS_CPNT_IPV6 == TRUE)
#define DNSHOSTIPENTRY_INSTANCE_LEN  (2 + SYS_TYPE_IPV6Z_ADDR_LEN)  /* manually coded */
#else
#define DNSHOSTIPENTRY_INSTANCE_LEN  (2 + SYS_TYPE_IPV4Z_ADDR_LEN)  /* manually coded */
#endif  /* #if (SYS_CPNT_IPV6 == TRUE) */

BOOL_T dnsHostAddrTable_OidIndexToData(UI32_T exact, UI32_T compc,
            oid *compl, UI32_T *dnsHostIndex, UI32_T *dnsHostAddrInetAddressType,
            UI8_T *dnsHostAddrInetAddress, UI32_T *dnsHostAddrInetAddress_length)
{
    UI32_T i;

    /* get or write */
    if (exact)
    {
        /* check the index length: variable-length index
         *
         * compc < 3, means the "address content (IMPLIED: without length-prefix)" is empty
         */
        if ((compc < 3) || (compc > DNSHOSTIPENTRY_INSTANCE_LEN))  /* the dynamic size index */
        {
            return FALSE;
        }
    }

    /* get-next without host index
     */
    if (compc == 0)
    {
        return TRUE;
    }

    /* copy host index
     */
    *dnsHostIndex = compl[0];

    /* get-next without address
     */
    if (compc == 1)
    {
        return TRUE;
    }

    /* copy type and length
     */
    *dnsHostAddrInetAddressType = compl[1];
    *dnsHostAddrInetAddress_length = compc - 2;

    /* copy each byte of the address
     */
    for (i = 0; i < compc - 2; i++)
    {
        dnsHostAddrInetAddress[i] = compl[2 + i];
    }

    return TRUE;
}

/*
 * var_dnsHostAddrTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *
var_dnsHostAddrTable(struct variable *vp,
            oid     *name,
            size_t  *length,
            int     exact,
            size_t  *var_len,
            WriteMethod **write_method)
{
    /* variables we may use later */
    UI32_T compc = 0;
    UI32_T i;
    oid compl[DNSHOSTIPENTRY_INSTANCE_LEN] = {0};
    oid best_inst[DNSHOSTIPENTRY_INSTANCE_LEN] = {0};

    /* table-specific variables
     */
    UI32_T host_idx = 0;
    L_INET_AddrIp_T entry;

    /* extracted from user index sub-OID
     */
    UI32_T type = 0, addr_len = 0, preflen = 0;
    UI8_T addr_ar[SYS_TYPE_IPV6Z_ADDR_LEN] = {0};  /* longest case: IPv6z, with zone ID */

    switch (vp->magic)
    {
        case LEAF_dnsHostAddrStatus:
            *write_method = write_dnsHostAddrStatus;
            break;

        default:
            *write_method = 0;
            break;
    }

    /* check compc, retrive compl */
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,
                           compl, DNSHOSTIPENTRY_INSTANCE_LEN);

    memset(&entry, 0, sizeof(entry));

    if (exact) /* get,set */
    {
        /* get index */
        if (dnsHostAddrTable_OidIndexToData(exact, compc, compl,
            &host_idx, &type, addr_ar, &addr_len) == FALSE)
        {
            return NULL;
        }

        /* only support IPv4(z) and IPv6(z)
         */
        if ( (type < VAL_dnsHostAddrInetAddressType_ipv4)
            || (type > VAL_dnsHostAddrInetAddressType_ipv6z) )
        {
            return NULL;
        }

        /* convert to L_INET_AddrIp_T
         */
        if (! SNMP_MGR_ConvertInetAddrAndTypeToLInetAddr(type,
            addr_len, addr_ar, 0, (L_INET_Addr_T *) &entry))
        {
            return NULL;
        }

        /* get data */
        if (! DNS_PMGR_GetDnsHostAddrEntry(host_idx, &entry))
        {
            return NULL;
        }
    }
    else /* getnext */
    {
        /* get index */
        dnsHostAddrTable_OidIndexToData(exact, compc, compl,
            &host_idx, &type, addr_ar, &addr_len);

        /* only support IPv4(z) and IPv6(z) - only check upper bound for get-next
         */
        if (type > VAL_dnsHostAddrInetAddressType_ipv6z)
        {
            return NULL;
        }

        /* convert to L_INET_AddrIp_T
         */
        if (! SNMP_MGR_ConvertInetAddrAndTypeToLInetAddr(type,
            addr_len, addr_ar, 0, (L_INET_Addr_T *) &entry))
        {
            return NULL;
        }

        /* Check the length of inputing index.  If compc is less than the
         * instance length, we should try get {A.B.C.0.0...}, where A.B.C was
         * obtained from the "..._OidIndexToData" function call, and
         * 0.0... was initialized in the beginning of this function.
         * This instance may exist in the core layer.
         */
        /* NOTE:
         * This is a variable-length index:
         * IfIndex.AddressType.length-prefixed-InetAddress.PrefixLength
         * We check length of address based on type.
         */
        if ( (type == 0)
            || ((type == VAL_dnsHostAddrInetAddressType_ipv4)
                && (addr_len < SYS_TYPE_IPV4_ADDR_LEN))
            || ((type == VAL_dnsHostAddrInetAddressType_ipv6)
                && (addr_len < SYS_TYPE_IPV6_ADDR_LEN))
            || ((type == VAL_dnsHostAddrInetAddressType_ipv4z)
                && (addr_len < SYS_TYPE_IPV4Z_ADDR_LEN))
            || ((type == VAL_dnsHostAddrInetAddressType_ipv6z)
                && (addr_len < SYS_TYPE_IPV6Z_ADDR_LEN)) )
        {
            /* get data */
            if (! DNS_PMGR_GetDnsHostAddrEntry(host_idx, &entry))
            {
                /* get next data */
                if (! DNS_PMGR_GetNextDnsHostAddrEntry(&host_idx, &entry))
                {
                    return NULL;
                }
            }
        }
        else
        {
            /* get next data */
            if (! DNS_PMGR_GetNextDnsHostAddrEntry(&host_idx, &entry))
            {
                return NULL;
            }
        }
    }

    memcpy(name, vp->name, vp->namelen*sizeof(oid));

    /* convert L_INET_AddrIp_T back to SNMP values
     */
    if (! SNMP_MGR_ConvertLInetAddrToInetAddrAndType(
        (L_INET_Addr_T *) &entry,
        &type, &addr_len, addr_ar, &preflen))
    {
        /* conversion failed
         */
        *var_len = 0;
    }
    else
    {
        *var_len = (size_t) addr_len;
    }

    /* assign data to the oid index */
    best_inst[0] = host_idx;
    best_inst[1] = type;

    for (i = 0; i < addr_len; i++)
    {
        best_inst[2 + i] = addr_ar[i];
    }

    memcpy(name + vp->namelen, best_inst, (2 + addr_len) * sizeof(oid));
    *length = vp->namelen + (2 + addr_len);

    /* this is where we do the value assignments for the mib results. */
    switch (vp->magic)
    {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case LEAF_dnsHostAddrInetAddressType:
            *var_len = sizeof(long_return);
            long_return = type;
            return (u_char *) &long_return;

#endif

#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case LEAF_dnsHostAddrInetAddress:
            *var_len  = addr_len;
            memcpy(return_buf, addr_ar, *var_len);
            return (u_char*)return_buf;

#endif

        case LEAF_dnsHostAddrStatus:
            *var_len = sizeof(long_return);
            long_return = VAL_dnsHostAddrStatus_valid;
            return (u_char *) &long_return;

        default:
            ERROR_MSG("");
    }

    return NULL;
}

int
write_dnsHostAddrStatus(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    /* extracted from user index sub-OID
     */
    UI32_T type = 0, addr_len = 0;
    UI8_T addr_ar[SYS_TYPE_IPV6Z_ADDR_LEN] = {0};  /* longest case: IPv6z, with zone ID */

    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            switch (*(long *)var_val)
            {
                case VAL_dnsHostAddrStatus_valid:
                    break;

                case VAL_dnsHostAddrStatus_invalid:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            I32_T  value = 0;
            UI32_T dnsHostIndex = 0;
            BOOL_T is_add;
            L_INET_AddrIp_T entry;

            memset(&entry, 0, sizeof(entry));

            /* extract index
             */
            if (! dnsHostAddrTable_OidIndexToData(
                TRUE, name_len - oid_name_length, &(name[oid_name_length]),
                &dnsHostIndex, &type, addr_ar, &addr_len))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            /* only support IPv4(z) and IPv6(z)
             */
            if ( (type < VAL_dnsHostAddrInetAddressType_ipv4)
                || (type > VAL_dnsHostAddrInetAddressType_ipv6z) )
            {
                return SNMP_ERR_COMMITFAILED;
            }

            /* convert to L_INET_AddrIp_T
             */
            if (! SNMP_MGR_ConvertInetAddrAndTypeToLInetAddr(type,
                addr_len, addr_ar, 0, (L_INET_Addr_T *) &entry))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            value = *(long *)var_val;

            if (VAL_dnsHostAddrStatus_valid == value)
            {
                is_add = TRUE;
            }
            else
            {
                is_add = FALSE;
            }

            if (DNS_PMGR_SetDnsHostAddrEntry(dnsHostIndex, &entry, is_add) != TRUE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

/********************************************
 ***************dnsNameServerTable***********
 ********************************************
 */

#if (SYS_CPNT_IPV6 == TRUE)
#define DNSNAMESERVERINETENTRY_INSTANCE_LEN  (1 + SYS_ADPT_IPV6_ADDR_LEN)
#else
#define DNSNAMESERVERINETENTRY_INSTANCE_LEN  (1 + SYS_ADPT_IPV4_ADDR_LEN)
#endif /* #if (SYS_CPNT_IPV6 == TRUE) */

BOOL_T dnsNameServerInetTable_OidIndexToData(UI32_T exact, UI32_T compc,
    oid *compl, L_INET_AddrIp_T *addr_p)
{
    UI32_T i;
    UI32_T address_len;

    /* get or set
     */
    if (exact)
    {
        /* check the index length
         */
        if (compc < 2 || compc > DNSNAMESERVERINETENTRY_INSTANCE_LEN) /* the dynamic size index */
        {
            return FALSE;
        }
    }

    address_len = compc - 1;

    if (L_INET_ADDR_TYPE_IPV4 == compl[0])
    {
        if (SYS_ADPT_IPV4_ADDR_LEN != address_len)
        {
            return FALSE;
        }
    }
    else if (L_INET_ADDR_TYPE_IPV6 == compl[0])
    {
        if (SYS_ADPT_IPV6_ADDR_LEN != address_len)
        {
            return FALSE;
        }
    }
    else
    {
        return FALSE;
    }

    addr_p->type = compl[0];
    addr_p->addrlen = address_len;

    for (i = 0; i < addr_p->addrlen; i++)
    {
        addr_p->addr[i] = compl[1 + i];
    }

    addr_p->addr[addr_p->addrlen] = '\0';

    return TRUE;
}

/*
 * var_dnsNameServerInetTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *var_dnsNameServerInetTable(struct variable *vp,
    oid *name,
    size_t *length,
    int exact,
    size_t *var_len,
    WriteMethod **write_method)
{
    UI32_T compc = 0;
    UI32_T i;
    oid compl[DNSNAMESERVERINETENTRY_INSTANCE_LEN] = {0};
    oid best_inst[DNSNAMESERVERINETENTRY_INSTANCE_LEN] = {0};
    L_INET_AddrIp_T entry;

    switch (vp->magic)
    {
        case LEAF_dnsNameServerInetStatus:
            *write_method = write_dnsNameServerInetStatus;
            break;

        default:
            *write_method = 0;
            break;
    }

    /* check compc, retrive compl
     */
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl, DNSNAMESERVERINETENTRY_INSTANCE_LEN);

    memset(&entry, 0, sizeof(entry));

    if (exact) /* get or set */
    {
        if (dnsNameServerInetTable_OidIndexToData(exact, compc, compl, &entry) == FALSE)
        {
            return NULL;
        }

        if (DNS_PMGR_GetNameServerList(&entry) != TRUE)
        {
            return NULL;
        }
    }
    else /* getnext */
    {
        dnsNameServerInetTable_OidIndexToData(exact, compc, compl, &entry);

        /* check the length of inputing index,if < 1 we should try get
         * {0.0.0.0.0...}
         */
        if (compc < 1)
        {
            if (DNS_PMGR_GetNameServerList(&entry) != TRUE)
            {
                if (DNS_POM_GetNextNameServerList(&entry) != TRUE)
                {
                    return NULL;
                }
            }
        }
        else
        {
            if (DNS_POM_GetNextNameServerList(&entry) != TRUE)
            {
                return NULL;
            }
        }
    }

    memcpy(name, vp->name, vp->namelen * sizeof(oid));

    /* assign data to the oid index
     */
    best_inst[0] = entry.type;

    for (i = 0; i < entry.addrlen; i++)
    {
        best_inst[1 + i] = entry.addr[i];
    }
    memcpy(name + vp->namelen, best_inst, (1 + entry.addrlen) * sizeof(oid));
    *length = vp->namelen + 1 + entry.addrlen;

    switch (vp->magic)
    {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case LEAF_dnsNameServerInetAddressType:
            *var_len = sizeof(long_return);
            long_return = entry.type;
            return (u_char *) &long_return;
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case LEAF_dnsNameServerInetAddress:
            *var_len = entry.addrlen;
            memcpy(return_buf, entry.addr, *var_len);
            return (u_char *) return_buf;
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

        case LEAF_dnsNameServerInetStatus:
            *var_len = sizeof(long_return);
            long_return = VAL_dnsNameServerInetStatus_valid;
            return (u_char *) &long_return;

        default:
            ERROR_MSG("");
    }

    return NULL;
}

int write_dnsNameServerInetStatus(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            switch (*(long *)var_val)
            {
                case VAL_dnsNameServerInetStatus_valid:
                    break;

                case VAL_dnsNameServerInetStatus_invalid:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            I32_T value = 0;
            L_INET_AddrIp_T entry;

            memset(&entry, 0, sizeof(entry));

            if (dnsNameServerInetTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &entry) == FALSE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            value = *(long *)var_val;

            if (VAL_dnsNameServerInetStatus_valid == value)
            {
                if (DNS_ERROR == DNS_PMGR_AddNameServer(&entry))
                {
                    return SNMP_ERR_COMMITFAILED;
                }
            }
            else
            {
                if (DNS_ERROR == DNS_PMGR_DeleteNameServer(&entry))
                {
                    return SNMP_ERR_COMMITFAILED;
                }
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}
#endif /*end of #if (SYS_CPNT_DNS == TRUE)*/
#if (SYS_CPNT_POE == TRUE)

#define PETHPSEMAINEXTENTRY_INSTANCE_LEN  1

BOOL_T pethPseMainExtTable_OidIndexToData(UI32_T exact, UI32_T compc,
            oid * compl,  UI32_T *pethMainPseGroupIndex)
{
    /* get or write */
    if (exact)
    {
        /* check the index length */
        if (compc != PETHPSEMAINEXTENTRY_INSTANCE_LEN) /* the constant size index */
        {
            return FALSE;
        }
    }

    *pethMainPseGroupIndex = compl[0];

    return TRUE;
}

/*
 * var_pethPseMainExtTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *
var_pethPseMainExtTable(struct variable *vp,
            oid     *name,
            size_t  *length,
            int     exact,
            size_t  *var_len,
            WriteMethod **write_method)
{
    /* variables we may use later */
    UI32_T compc = 0;
    oid compl[PETHPSEMAINEXTENTRY_INSTANCE_LEN] = {0};
    oid best_inst[PETHPSEMAINEXTENTRY_INSTANCE_LEN] = {0};
    UI32_T in_group_index, group_index, port_index;
    POE_OM_PsePort_T entry;

#ifdef SYS_CPNT_POE_PSE_DOT3AT
    POE_TYPE_Dot3atPowerInfo_T dot3at_info_str;
#endif

    switch (vp->magic)
    {
        default:
            *write_method = 0;
            break;
    }

    /* check compc, retrive compl */
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,
                           compl, PETHPSEMAINEXTENTRY_INSTANCE_LEN);

    memset(&entry, 0, sizeof(entry));

    /* The private MIB is designed as per-group,
     * but the core API is per-port.
     * So, we need to get the first port.
     */
    if (exact) /* get,set */
    {
        /* get index */
        if (pethPseMainExtTable_OidIndexToData(exact, compc, compl, &in_group_index) == FALSE)
        {
            return NULL;
        }

        /* get data: get first port for this group */
        group_index = in_group_index;
        port_index = 0;

        if (POE_POM_GetNextPsePortEntry(&group_index, &port_index, &entry) != TRUE)
        {
            return NULL;
        }

        /* if there is no port for this group, fail
         */
        if (in_group_index != group_index)
        {
            return NULL;
        }
    }
    else /* getnext */
    {
        /* get index */
        pethPseMainExtTable_OidIndexToData(exact, compc, compl, &in_group_index);

        /* check the length of inputing index,if < 1 we should try get
         * {0.0.0.0.0...}
         */
        if (compc < 1)
        {
            /* get data: get first port */
            group_index = port_index = 0;

            if (POE_POM_GetNextPsePortEntry(&group_index, &port_index, &entry) != TRUE)
            {
                return NULL;
            }
        }
        else
        {
            /* get next data: increment group index and get next port */
            group_index = in_group_index + 1;
            port_index = 0;

            if (POE_POM_GetNextPsePortEntry(&group_index, &port_index, &entry) != TRUE)
            {
                return NULL;
            }
        }
    }

    memcpy(name, vp->name, vp->namelen*sizeof(oid));

    /* assign data to the oid index */
    best_inst[0] = group_index;
    memcpy(name + vp->namelen, best_inst,
           PETHPSEMAINEXTENTRY_INSTANCE_LEN * sizeof(oid));
    *length = vp->namelen + PETHPSEMAINEXTENTRY_INSTANCE_LEN ;

    /* get corresponding entry for 802.3at
     */
#ifdef SYS_CPNT_POE_PSE_DOT3AT
    if (POE_POM_GetPortDot3atPowerInfo(group_index, port_index, &dot3at_info_str) != TRUE)
    {
        return NULL;
    }
#endif

    /* this is where we do the value assignments for the mib results. */
    switch (vp->magic)
    {
        case LEAF_pethPseMainExtDllPowerType:
            *var_len = sizeof(long_return);
            long_return = (UI32_T) dot3at_info_str.power_type;
            return (u_char *) &long_return;

        case LEAF_pethPseMainExtDllPowerSource:
            *var_len = sizeof(long_return);

            /* The ">> 4" below is needed because the core layer
             * encodes it as 2 bits, 5:4 (bit 0 being LSB).
             */
            long_return = (UI32_T) dot3at_info_str.power_source >> 4;
            return (u_char *) &long_return;

        default:
            ERROR_MSG("");
    }

    return NULL;
}

#define PETHPSEPORTEXTENTRY_INSTANCE_LEN  2

BOOL_T pethPsePortExtTable_OidIndexToData(UI32_T exact, UI32_T compc,
            oid * compl,  UI32_T *pethPsePortGroupIndex, UI32_T *pethPsePortIndex)
{
    /* get or write */
    if (exact)
    {
        /* check the index length */
        if (compc != PETHPSEPORTEXTENTRY_INSTANCE_LEN) /* the constant size index */
        {
            return FALSE;
        }
    }

    *pethPsePortGroupIndex = compl[0];
    *pethPsePortIndex = compl[1];

    return TRUE;
}

/*
 * var_pethPsePortExtTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *
var_pethPsePortExtTable(struct variable *vp,
            oid     *name,
            size_t  *length,
            int     exact,
            size_t  *var_len,
            WriteMethod **write_method)
{
    /* variables we may use later */
    UI32_T compc = 0;
    oid compl[PETHPSEPORTEXTENTRY_INSTANCE_LEN] = {0};
    oid best_inst[PETHPSEPORTEXTENTRY_INSTANCE_LEN] = {0};
    UI32_T group_index = 0, port_index = 0;
    POE_OM_PsePort_T entry;

#ifdef SYS_CPNT_POE_PSE_DOT3AT
    POE_TYPE_Dot3atPowerInfo_T dot3at_info_str;
#endif

    switch (vp->magic)
    {

#if (SYS_CPNT_POE_TIME_RANGE == TRUE)
        case LEAF_pethPsePortTimeRange:
            *write_method = write_pethPsePortTimeRange;
            break;
#endif /* #if (SYS_CPNT_POE_TIME_RANGE == TRUE) */

        case LEAF_pethPsePortExtMaximumPowerValue:
            *write_method = write_pethPsePortExtMaximumPowerValue;
            break;

        default:
            *write_method = 0;
            break;
    }

    /* check compc, retrive compl */
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,
                           compl, PETHPSEPORTEXTENTRY_INSTANCE_LEN);

    memset(&entry, 0, sizeof(entry));

    if (exact) /* get,set */
    {
        /* get index */
        if (pethPsePortExtTable_OidIndexToData(exact, compc, compl, &group_index, &port_index) == FALSE)
        {
            return NULL;
        }

        /* get data */
        if (POE_POM_GetPsePortEntry(group_index, port_index, &entry) != TRUE)
        {
            return NULL;
        }
    }
    else /* getnext */
    {
        /* get index */
        pethPsePortExtTable_OidIndexToData(exact, compc, compl, &group_index, &port_index);

        /* check the length of inputing index,if < 1 we should try get
         * {0.0.0.0.0...}
         */
        if (compc < 1)
        {
            /* get data */
            if (POE_POM_GetPsePortEntry(group_index, port_index, &entry) != TRUE)
            {
                /* get next data */
                if (POE_POM_GetNextPsePortEntry(&group_index, &port_index, &entry) != TRUE)
                {
                    return NULL;
                }
            }
        }
        else
        {
            /* get next data */
            if (POE_POM_GetNextPsePortEntry(&group_index, &port_index, &entry) != TRUE)
            {
                return NULL;
            }
        }
    }

    memcpy(name, vp->name, vp->namelen*sizeof(oid));

    /* assign data to the oid index */
    best_inst[0] = group_index;
    best_inst[1] = port_index;
    memcpy(name + vp->namelen, best_inst,
           PETHPSEPORTEXTENTRY_INSTANCE_LEN * sizeof(oid));
    *length = vp->namelen + PETHPSEPORTEXTENTRY_INSTANCE_LEN ;

    /* get corresponding entry for 802.3at
     */
#ifdef SYS_CPNT_POE_PSE_DOT3AT
    if (POE_POM_GetPortDot3atPowerInfo(group_index, port_index, &dot3at_info_str) != TRUE)
    {
        return NULL;
    }
#endif

    /* this is where we do the value assignments for the mib results. */
    switch (vp->magic)
    {
#if 0  /* in superset MIB but not supported */
        case LEAF_pethPsePortExtMirroredDllPowerType:
            *var_len = sizeof(long_return);
            long_return = (UI32_T) dot3at_info_str.power_type;
            return (u_char *) &long_return;

        case LEAF_pethPsePortExtMirroredDllPowerSource:
            *var_len = sizeof(long_return);
            long_return = (UI32_T) dot3at_info_str.power_source;
            return (u_char *) &long_return;

        case LEAF_pethPsePortExtMirroredDllPdPowerPriority:
            *var_len = sizeof(long_return);
            long_return = (UI32_T) dot3at_info_str.power_priority;
            return (u_char *) &long_return;
#endif

        case LEAF_pethPsePortExtMirroredDllPdRequestedPowerValue:
            *var_len = sizeof(long_return);
            long_return = (UI32_T) dot3at_info_str.pd_requested_power;
            return (u_char *) &long_return;

#if 0  /* in superset MIB but not supported */
        case LEAF_pethPsePortExtDllPdRequestedPowerValueEcho:
            *var_len = sizeof(long_return);
            long_return = (UI32_T) dot3at_info_str.pethPsePortExtDllPdRequestedPowerValueEcho;
            return (u_char *) &long_return;
#endif

        case LEAF_pethPsePortExtDllPseAllocatedPowerValue:
            *var_len = sizeof(long_return);
            long_return = (UI32_T) dot3at_info_str.pse_allocated_power;
            return (u_char *) &long_return;

#if 0  /* in superset MIB but not supported */
        case LEAF_pethPsePortExtMirroredDllPseAllocatedPowerValueEcho:
            *var_len = sizeof(long_return);
            long_return = (UI32_T) dot3at_info_str.pethPsePortExtMirroredDllPseAllocatedPowerValueEcho;
            return (u_char *) &long_return;

        case LEAF_pethPsePortExtDllPseResponseTime:
            *var_len = sizeof(long_return);
            long_return = (UI32_T) dot3at_info_str.pethPsePortExtDllPseResponseTime;
            return (u_char *) &long_return;

        case LEAF_pethPsePortExtDllReady:
            *var_len = sizeof(long_return);
            long_return = entry.pethPsePortExtDllReady;???
            return (u_char *) &long_return;

        case LEAF_pethPsePortExtOverloadAutoRecover:
            *var_len = sizeof(long_return);
            long_return = entry.pethPsePortExtOverloadAutoRecover;???
            return (u_char *) &long_return;
#endif

#if (SYS_CPNT_POE_TIME_RANGE == TRUE)
        case LEAF_pethPsePortTimeRange:
            if(entry.pse_port_time_range_status == POE_TYPE_TIMERANGE_STATUS_NONE)
            {
                *var_len = 0;
                return_buf[0] = '\0';
            }
            else
            {
                *var_len = strlen((char *)entry.pse_port_time_range_name);
                memcpy(return_buf, entry.pse_port_time_range_name, *var_len);
            }
            return (u_char*)return_buf;

        case LEAF_pethPsePortTimeRangeStatus:
            *var_len = sizeof(long_return);
            long_return = entry.pse_port_time_range_status;
            return (u_char *) &long_return;
#endif /* #if (SYS_CPNT_POE_TIME_RANGE == TRUE) */

        case LEAF_pethPsePortExtMaximumPowerValue:
            *var_len = sizeof(long_return);
            long_return = (UI32_T) entry.pse_port_power_max_allocation;
            return (u_char *) &long_return;

        case LEAF_pethPsePortExtUsedPowerValue:
            *var_len = sizeof(long_return);
            long_return = (UI32_T) entry.pse_port_consumption_power;
            return (u_char *) &long_return;

        default:
            ERROR_MSG("");
    }

    return NULL;
}

#if (SYS_CPNT_POE_TIME_RANGE == TRUE)
int
write_pethPsePortTimeRange(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_OCTET_STR)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len < MINSIZE_pethPsePortTimeRange ||
                var_val_len > MAXSIZE_pethPsePortTimeRange)
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;

        case RESERVE2:
            break;

        case FREE:
            break;

        case ACTION:
            {
                UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
                UI8_T byte_buffer[MAXSIZE_pethPsePortTimeRange + 1] = {0};
                UI32_T pethPsePortGroupIndex = 0;
                UI32_T pethPsePortIndex = 0;

                if (pethPsePortExtTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &pethPsePortGroupIndex, &pethPsePortIndex) == FALSE)
                    return SNMP_ERR_COMMITFAILED;

                if (0 == var_val_len)
                {
                    if (POE_PMGR_UnbindTimeRangeToPsePort( pethPsePortGroupIndex, pethPsePortIndex) != TRUE)
                    {
                        return SNMP_ERR_COMMITFAILED;
                    }
                }
                else
                {
                    memcpy(byte_buffer, var_val, var_val_len);
                    byte_buffer[var_val_len] = '\0';

                    if (POE_PMGR_BindTimeRangeToPsePort( pethPsePortGroupIndex, pethPsePortIndex, byte_buffer) != TRUE)
                    {
                        return SNMP_ERR_COMMITFAILED;
                    }
                }
            }
            break;

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}
#endif /* #if (SYS_CPNT_POE_TIME_RANGE == TRUE) */

int
write_pethPsePortExtMaximumPowerValue(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            {
                UI32_T value;

                value = *(long *)var_val;

                if (value < SYS_HWCFG_MIN_POWER_INLINE_ALLOCATION ||
                    value > SYS_HWCFG_MAX_POWER_INLINE_ALLOCATION)
                {
                    return SNMP_ERR_WRONGVALUE;
                }
            }
            break;

        case FREE:
            break;

        case ACTION:
            {
                UI32_T value;

                value = *(long *)var_val;

                UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
                UI32_T pethPsePortGroupIndex = 0;
                UI32_T pethPsePortIndex = 0;

                /* extract indexes
                 */
                if (pethPsePortExtTable_OidIndexToData(TRUE, name_len - oid_name_length,
                    &(name[oid_name_length]), &pethPsePortGroupIndex, &pethPsePortIndex) == FALSE)
                {
                    return SNMP_ERR_COMMITFAILED;
                }

                /* set to core layer
                 */
                if (POE_PMGR_SetPortPowerMaximumAllocation(pethPsePortGroupIndex,
                    pethPsePortIndex, value) != TRUE)
                {
                    return SNMP_ERR_COMMITFAILED;
                }
            }
            break;

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

#endif  /*#if (SYS_CPNT_POE == TRUE) */

#if (SYS_CPNT_HSRP == TRUE)

int
do_cHsrpConfigTimeout(netsnmp_mib_handler *handler,
                      netsnmp_handler_registration *reginfo,
                      netsnmp_agent_request_info *reqinfo,
                      netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
        {
             UI32_T value;
             if (HSRP_MGR_GetConfigTimeout(&value)!=HSRP_ACCESS_SUCCESS)
             {
                 netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
             }
             long_return =value;
             snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, (u_char *) &long_return, sizeof(long_return));
        }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            {
           UI32_T value;
           value = (*requests->requestvb->val.integer);
          if ((value<MIN_cHsrpConfigTimeout) || (value>MAX_cHsrpConfigTimeout))
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_INCONSISTENTVALUE);
          }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
             {
                UI32_T value;
                value = (*requests->requestvb->val.integer);
                 if (HSRP_MGR_SetConfigTimeout(value) != HSRP_ACCESS_SUCCESS)
                       netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);

            }
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}


/* cHsrpGrpTable*/
#define cHsrpGrpEntry_INSTANCE_LEN 2
static BOOL_T cHsrpGrpTable_get(int      compc,
                                oid     *compl,
                                HSRP_GRP_ENTRY_T   *data)
{
    if (compc !=cHsrpGrpEntry_INSTANCE_LEN)
    {
        return FALSE;
    }
    data->ifindex=compl[0];
    data->grp_number=compl[1];

    if (HSRP_MGR_GetHsrpGrpEntry(data)!=HSRP_ACCESS_SUCCESS)
    {
        return FALSE;
    }
    else
    {
        return TRUE;

    } /*End of if */
}

static BOOL_T cHsrpGrpTable_next(int   compc,
                                 oid     *compl,
                                 HSRP_GRP_ENTRY_T    *data)
{
    oid tmp_compl[cHsrpGrpEntry_INSTANCE_LEN];

    /* Generate the instance of each table entry and find the
     * smallest instance that's larger than compc/compl.
     *
     * Step 1: Verify and extract the input key from "compc" and "compl"
     * Note: The number of input key is defined by "compc".
     *       The key for the specified instance is defined in compl.
     */
    memcpy(tmp_compl, compl, sizeof(tmp_compl));
    SNMP_MGR_ConvertRemainToZero(compc,cHsrpGrpEntry_INSTANCE_LEN, tmp_compl);

        data->ifindex=tmp_compl[0];
        data->grp_number=tmp_compl[1];

    if (compc<cHsrpGrpEntry_INSTANCE_LEN)
    {
        if (HSRP_MGR_GetHsrpGrpEntry(data)!=HSRP_ACCESS_SUCCESS)
            {
                    if (HSRP_MGR_GetNextHsrpGrpEntry(data)!=HSRP_ACCESS_SUCCESS)
                {
                return FALSE;
                }
            }
    }
    else
    {
        if (HSRP_MGR_GetNextHsrpGrpEntry(data)!=HSRP_ACCESS_SUCCESS)
        {
            return FALSE;
        }
    }
    return TRUE;
}


/* This entry is used for entry which have the ability to row create*/
static HSRP_GRP_ENTRY_T cHsrpGrpEntry;

/*
 * var_cHsrpGrpTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_cHsrpGrpTable(struct variable *vp,
                  oid * name,
                  size_t * length,
                  int exact, size_t * var_len, WriteMethod ** write_method)
{
    UI32_T compc=0;
    oid compl[cHsrpGrpEntry_INSTANCE_LEN];
    oid best_inst[cHsrpGrpEntry_INSTANCE_LEN];
    HSRP_GRP_ENTRY_T data;

    /* Give default value for the record first.
     * We use the row_status = 0 to indicate if this set operation is Set by field
     * or set by record(included row creation), if the row_status =0, this record
     * mean set by field, otherwise, we just think it is a normal set operation
     */
     if (HSRP_MGR_GetDefaultHsrpGrpEntry(&cHsrpGrpEntry)!=HSRP_ACCESS_SUCCESS)
     {
        if(SNMP_MGR_IsDebugMode())
            SYSFUN_Debug_Printf("var_cHsrpGrpTable:HSRP_MGR_GetDefaultHsrpGrpEntry return false\n");
        return NULL;
     }
     cHsrpGrpEntry.grp_row_status = 0;

   /*Since this table allow for entry that does not exist, (creation). we need to know the write method first*/
    switch (vp->magic)
    {
      case CHSRPGRPAUTH:
        *write_method = write_cHsrpGrpAuth;
        break;
      case CHSRPGRPPRIORITY:
        *write_method = write_cHsrpGrpPriority;
        break;
      case CHSRPGRPPREEMPT:
        *write_method = write_cHsrpGrpPreempt;
        break;
      case CHSRPGRPPREEMPTDELAY:
        *write_method = write_cHsrpGrpPreemptDelay;
        break;
      case CHSRPGRPCONFIGUREDHELLOTIME:
        *write_method = write_cHsrpGrpConfiguredHelloTime;
        break;
      case CHSRPGRPCONFIGUREDHOLDTIME:
        *write_method = write_cHsrpGrpConfiguredHoldTime;
        break;
      case CHSRPGRPVIRTUALIPADDR:
        *write_method = write_cHsrpGrpVirtualIpAddr;
        break;
      case CHSRPGRPENTRYROWSTATUS:
        *write_method = write_cHsrpGrpEntryRowStatus;
        break;
      default:
         *write_method =0;
         break;
    }

    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,compl, cHsrpGrpEntry_INSTANCE_LEN);

     /*check compc, retrive compl*/
    if (exact)/*get,set*/
    {
        if (!cHsrpGrpTable_get(compc, compl, &data))
            return NULL;
    }
    else/*getnext*/
    {
        if (!cHsrpGrpTable_next(compc, compl, &data))
        {
            return NULL;
        }
    }
    memcpy(name, vp->name, vp->namelen*sizeof(oid));
    best_inst[0]=data.ifindex;
    best_inst[1]=data.grp_number;
    memcpy(name + vp->namelen, best_inst, cHsrpGrpEntry_INSTANCE_LEN*sizeof(oid));
    *length = vp->namelen +cHsrpGrpEntry_INSTANCE_LEN;

    *var_len = sizeof(long_return);

    /*
     * * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
     #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
      case CHSRPGRPNUMBER:
        long_return = data.grp_number;
        return (u_char*) &long_return;
     #endif
      case CHSRPGRPAUTH:
        memcpy(return_buf, data.grp_auth, strlen(data.grp_auth));
        *var_len = strlen(data.grp_auth);
        return (u_char*) return_buf;
      case CHSRPGRPPRIORITY:
        long_return = data.grp_priority;
        return (u_char*) &long_return;
      case CHSRPGRPPREEMPT:
        long_return = data.grp_preempt;
        return (u_char*) &long_return;
      case CHSRPGRPPREEMPTDELAY:
        long_return = data.grp_preempt_delay;
        return (u_char*) &long_return;
      case CHSRPGRPUSECONFIGUREDTIMERS:
        long_return = data.grp_use_configured_timers;
        return (u_char*) &long_return;
      case CHSRPGRPCONFIGUREDHELLOTIME:
        long_return = data.grp_configured_hello_time*1000;
        return (u_char*) &long_return;
      case CHSRPGRPCONFIGUREDHOLDTIME:
        long_return = data.grp_configured_hold_time*1000;
        return (u_char*) &long_return;
      case CHSRPGRPLEARNEDHELLOTIME:
        long_return = data.grp_learned_hello_time*1000;
        return (u_char*) &long_return;
      case CHSRPGRPLEARNEDHOLDTIME:
        long_return = data.grp_learned_hold_time*1000;
        return (u_char*) &long_return;
      case CHSRPGRPVIRTUALIPADDR:
        *var_len = sizeof(ipaddr_return);
        ipaddr_return = data.grp_virtual_ip_addr;
        return (u_char*) &ipaddr_return;
      case CHSRPGRPUSECONFIGVIRTUALIPADDR:
        long_return = data.grp_use_config_virtual_ip_addr;
        return (u_char*) &long_return;
      case CHSRPGRPACTIVEROUTER:
        *var_len = sizeof(ipaddr_return);
        ipaddr_return = data.grp_active_router;
        return (u_char*) &ipaddr_return;
      case CHSRPGRPSTANDBYROUTER:
        *var_len = sizeof(ipaddr_return);
        ipaddr_return = data.grp_standby_router;
        return (u_char*) &ipaddr_return;
      case CHSRPGRPSTANDBYSTATE:
        long_return = data.grp_standby_state;
        return (u_char*) &long_return;
      case CHSRPGRPVIRTUALMACADDR:
        memcpy(return_buf, data.grp_virtual_mac_addr, SIZE_cHsrpGrpVirtualMacAddr);
        *var_len = SIZE_cHsrpGrpVirtualMacAddr;
        return (u_char*) return_buf;
      case CHSRPGRPENTRYROWSTATUS:
        long_return = data.grp_row_status;
        return (u_char*) &long_return;
    default:
        ERROR_MSG("");
    }
    return NULL;
}


int
write_cHsrpGrpAuth(int action,
                   u_char * var_val,
                   u_char var_val_type,
                   size_t var_val_len,
                   u_char * statP, oid * name, size_t name_len)
{
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    UI32_T index1, index2;

    if (name_len!=  2 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    index1=name[oid_name_length];
    index2 = name[oid_name_length+1];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > MAXSIZE_cHsrpGrpAuth*sizeof(UI8_T)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
        /* In reserve2, we overwrite the set value to cHsrpGrpEntry*/
         memcpy(cHsrpGrpEntry.grp_auth, var_val, var_val_len);
         cHsrpGrpEntry.grp_auth[var_val_len] = 0;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
           /* For row creation, if row_status =0, mean that this is a normal
            * operation, we do the normal set operation, otherwise it is a row
            * creation operation, will do nothing here, and the overall entry
            * will perform in the write_xxxRowStatus function.
              */
           if (cHsrpGrpEntry.grp_row_status == 0)
           {

             if (!L_STDLIB_StrIsAsciiPrintWithCount(cHsrpGrpEntry.grp_auth, strlen(cHsrpGrpEntry.grp_auth)))
             {
                 return SNMP_ERR_COMMITFAILED;
             }
             if (HSRP_MGR_SetAuthenticationString(index1, index2, cHsrpGrpEntry.grp_auth) != HSRP_ACCESS_SUCCESS)
             {
                     return SNMP_ERR_COMMITFAILED;
             }
           }

         break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_cHsrpGrpPriority(int action,
                       u_char * var_val,
                       u_char var_val_type,
                       size_t var_val_len,
                       u_char * statP, oid * name, size_t name_len)
{
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    UI32_T index1, index2;

    if (name_len!=  2 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    index1=name[oid_name_length];
    index2 = name[oid_name_length+1];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_UNSIGNED) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(u_long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          /* In reserve2, we overwrite the set value to cHsrpGrpEntry*/
          cHsrpGrpEntry.grp_priority = *(u_long *)var_val;
          if ((cHsrpGrpEntry.grp_priority <MIN_cHsrpGrpPriority) || (cHsrpGrpEntry.grp_priority >MAX_cHsrpGrpPriority))
             return SNMP_ERR_WRONGVALUE;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
           /* For row creation, if row_status =0, mean that this is a normal
            * operation, we do the normal set operation, otherwise it is a row
            * creation operation, will do nothing here, and the overall entry
            * will perform in the write_xxxRowStatus function.
              */
           if (cHsrpGrpEntry.grp_row_status == 0)
           {
               if (HSRP_MGR_SetPriority(index1, index2, cHsrpGrpEntry.grp_row_status) != HSRP_ACCESS_SUCCESS)
                     return SNMP_ERR_COMMITFAILED;
           }
         break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_cHsrpGrpPreempt(int action,
                      u_char * var_val,
                      u_char var_val_type,
                      size_t var_val_len,
                      u_char * statP, oid * name, size_t name_len)
{
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    UI32_T index1, index2;

    if (name_len!=  2 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    index1=name[oid_name_length];
    index2 = name[oid_name_length+1];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          /* In reserve2, we overwrite the set value to cHsrpGrpEntry*/
          cHsrpGrpEntry.grp_preempt = *(long *)var_val;
          if ((cHsrpGrpEntry.grp_preempt <VAL_cHsrpGrpPreempt_true) || (cHsrpGrpEntry.grp_preempt >VAL_cHsrpGrpPreempt_false))
             return SNMP_ERR_WRONGVALUE;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
           /* For row creation, if row_status =0, mean that this is a normal
            * operation, we do the normal set operation, otherwise it is a row
            * creation operation, will do nothing here, and the overall entry
            * will perform in the write_xxxRowStatus function.
              */
           if (cHsrpGrpEntry.grp_row_status == 0)
           {
               if (HSRP_MGR_SetPreemptMode(index1, index2, cHsrpGrpEntry.grp_preempt) != HSRP_ACCESS_SUCCESS)
                     return SNMP_ERR_COMMITFAILED;
           }
         break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_cHsrpGrpPreemptDelay(int action,
                           u_char * var_val,
                           u_char var_val_type,
                           size_t var_val_len,
                           u_char * statP, oid * name, size_t name_len)
{
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    UI32_T index1, index2;

    if (name_len!=  2 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    index1=name[oid_name_length];
    index2 = name[oid_name_length+1];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_UNSIGNED) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(u_long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          /* In reserve2, we overwrite the set value to cHsrpGrpEntry*/
          cHsrpGrpEntry.grp_preempt_delay = *(u_long *)var_val;
          if ((cHsrpGrpEntry.grp_preempt_delay <MIN_cHsrpGrpPreemptDelay) || (cHsrpGrpEntry.grp_preempt_delay >MAX_cHsrpGrpPreemptDelay))
             return SNMP_ERR_WRONGVALUE;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
           /* For row creation, if row_status =0, mean that this is a normal
            * operation, we do the normal set operation, otherwise it is a row
            * creation operation, will do nothing here, and the overall entry
            * will perform in the write_xxxRowStatus function.
              */
           if (cHsrpGrpEntry.grp_row_status == 0)
           {
               if (HSRP_MGR_SetPreemptDelayTime(index1, index2, cHsrpGrpEntry.grp_preempt_delay) != HSRP_ACCESS_SUCCESS)
                     return SNMP_ERR_COMMITFAILED;
           }
         break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_cHsrpGrpConfiguredHelloTime(int action,
                                  u_char * var_val,
                                  u_char var_val_type,
                                  size_t var_val_len,
                                  u_char * statP,
                                  oid * name, size_t name_len)
{
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    UI32_T index1, index2;

    if (name_len!=  2 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    index1=name[oid_name_length];
    index2 = name[oid_name_length+1];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_UNSIGNED) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(u_long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          /* In reserve2, we overwrite the set value to cHsrpGrpEntry*/
          cHsrpGrpEntry.grp_configured_hello_time = *(u_long *)var_val;
          break;
        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
           /* For row creation, if row_status =0, mean that this is a normal
            * operation, we do the normal set operation, otherwise it is a row
            * creation operation, will do nothing here, and the overall entry
            * will perform in the write_xxxRowStatus function.
              */
           if (cHsrpGrpEntry.grp_row_status == 0)
           {
               if (HSRP_MGR_SetHelloTime(index1, index2, cHsrpGrpEntry.grp_configured_hello_time/1000) != HSRP_ACCESS_SUCCESS)
                     return SNMP_ERR_COMMITFAILED;
           }
                 break;
        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_cHsrpGrpConfiguredHoldTime(int action,
                                 u_char * var_val,
                                 u_char var_val_type,
                                 size_t var_val_len,
                                 u_char * statP,
                                 oid * name, size_t name_len)
{
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    UI32_T index1, index2;

    if (name_len!=  2 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    index1=name[oid_name_length];
    index2 = name[oid_name_length+1];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_UNSIGNED) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(u_long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          /* In reserve2, we overwrite the set value to cHsrpGrpEntry*/
          cHsrpGrpEntry.grp_configured_hold_time = *(u_long *)var_val;
          break;
        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
           /* For row creation, if row_status =0, mean that this is a normal
            * operation, we do the normal set operation, otherwise it is a row
            * creation operation, will do nothing here, and the overall entry
            * will perform in the write_xxxRowStatus function.
              */
           if (cHsrpGrpEntry.grp_row_status == 0)
           {
               if (HSRP_MGR_SetHoldTime(index1, index2, cHsrpGrpEntry.grp_configured_hold_time/1000) != HSRP_ACCESS_SUCCESS)
                     return SNMP_ERR_COMMITFAILED;
           }
                 break;
        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_cHsrpGrpVirtualIpAddr(int action,
                            u_char * var_val,
                            u_char var_val_type,
                            size_t var_val_len,
                            u_char * statP, oid * name, size_t name_len)
{
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    UI32_T index1, index2;

    if (name_len!=  2 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    index1=name[oid_name_length];
    index2 = name[oid_name_length+1];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_IPADDRESS) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len !=  SYS_ADPT_IPV4_ADDR_LEN)
          {
             return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
         /* In reserve2, we overwrite the set value to cHsrpGrpEntry*/
          memcpy(&cHsrpGrpEntry.grp_virtual_ip_addr, var_val, var_val_len);
          if (!IP_LIB_IsValidForNetworkInterface(cHsrpGrpEntry.grp_virtual_ip_addr))
             return SNMP_ERR_WRONGVALUE;
          break;
        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
           /* For row creation, if row_status =0, mean that this is a normal
            * operation, we do the normal set operation, otherwise it is a row
            * creation operation, will do nothing here, and the overall entry
            * will perform in the write_xxxRowStatus function.
              */
           if (cHsrpGrpEntry.grp_row_status == 0)
           {
               if (HSRP_MGR_SetVirtualIpAddress(index1, index2, cHsrpGrpEntry.grp_virtual_ip_addr, PRIMARY_ADDRESS) != HSRP_ACCESS_SUCCESS)
                     return SNMP_ERR_COMMITFAILED;
           }
         break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_cHsrpGrpEntryRowStatus(int action,
                             u_char * var_val,
                             u_char var_val_type,
                             size_t var_val_len,
                             u_char * statP, oid * name, size_t name_len)
{
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    UI32_T index1, index2;

    if (name_len!=  2 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    index1=name[oid_name_length];
    index2 = name[oid_name_length+1];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
           /* In reserve2, we overwrite the set value to cHsrpGrpEntry*/
          cHsrpGrpEntry.grp_row_status = *(long *)var_val;
          if ((cHsrpGrpEntry.grp_row_status <VAL_cHsrpGrpEntryRowStatus_active) || (cHsrpGrpEntry.grp_row_status >VAL_cHsrpGrpEntryRowStatus_destroy))
             return SNMP_ERR_WRONGVALUE;
          break;
        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
          /* We perform the row creation here, if the row status = 4(createAndGo),
           * or 5 (createAndWait), we call the SetByEntry API, otherwise, call the
           * set rowstatus API
              */
          switch (cHsrpGrpEntry.grp_row_status)
          {
              case VAL_cHsrpGrpEntryRowStatus_createAndGo:
              case VAL_cHsrpGrpEntryRowStatus_createAndWait:
                cHsrpGrpEntry.grp_number = name[oid_name_length];
                if (HSRP_MGR_SetHsrpGrpEntry(&cHsrpGrpEntry) != HSRP_ACCESS_SUCCESS)
                {
                    return SNMP_ERR_COMMITFAILED;
                }
              break;
              case VAL_cHsrpGrpEntryRowStatus_active:
              case VAL_cHsrpGrpEntryRowStatus_notInService:
              case VAL_cHsrpGrpEntryRowStatus_notReady:
              case VAL_cHsrpGrpEntryRowStatus_destroy:
                cHsrpGrpEntry.grp_number = name[oid_name_length];
                if (HSRP_MGR_SetHsrpGrpEntryRowStatus(&cHsrpGrpEntry) != HSRP_ACCESS_SUCCESS)
        {
                     return SNMP_ERR_COMMITFAILED;
                }
                 break;
              default:
            return SNMP_ERR_COMMITFAILED;
         }
         break;
        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}



/* cHsrpExtIfTrackedTable*/
#define cHsrpExtIfTrackedEntry_INSTANCE_LEN 3
static BOOL_T cHsrpExtIfTrackedTable_get(int      compc,
                                oid     *compl,
                                UI32_T  *idx1,
                                UI32_T  *idx2,
                                HSRP_IF_TRACKED_ENTRY_T   *data)
{
    if (compc !=cHsrpExtIfTrackedEntry_INSTANCE_LEN)
    {
        return FALSE;
    }
    *idx1=compl[0];
    *idx2=compl[1];
    data->tracked_ifindex = compl[2];

    if (HSRP_MGR_GetHsrpExtIfTrackedEntry(*idx1,*idx2, data)!=NETCFG_MGR_OK)
    {
        return FALSE;
    }
    else
    {
        return TRUE;

    } /*End of if */
}

static BOOL_T cHsrpExtIfTrackedTable_next(int   compc,
                                 oid     *compl,
                                 UI32_T  *index1,
                                 UI32_T  *index2,
                                 HSRP_IF_TRACKED_ENTRY_T    *data)
{
    oid tmp_compl[cHsrpExtIfTrackedEntry_INSTANCE_LEN];

    /* Generate the instance of each table entry and find the
     * smallest instance that's larger than compc/compl.
     *
     * Step 1: Verify and extract the input key from "compc" and "compl"
     * Note: The number of input key is defined by "compc".
     *       The key for the specified instance is defined in compl.
     */
    memcpy(tmp_compl, compl, sizeof(tmp_compl));
    SNMP_MGR_ConvertRemainToZero(compc,cHsrpExtIfTrackedEntry_INSTANCE_LEN, tmp_compl);

    *index1=tmp_compl[0];
    *index2=tmp_compl[1];
    data->tracked_ifindex = tmp_compl[2];

    if (compc<cHsrpExtIfTrackedEntry_INSTANCE_LEN)
    {
        if (HSRP_MGR_GetHsrpExtIfTrackedEntry(*index1,*index2,data)!=HSRP_ACCESS_SUCCESS)
        {
            if (HSRP_MGR_GetNextHsrpExtIfTrackedEntry(index1,index2,data)!=HSRP_ACCESS_SUCCESS)
            {
                return FALSE;
            }
        }
    }
    else
    {
        if (HSRP_MGR_GetNextHsrpExtIfTrackedEntry(index1, index2, data)!=HSRP_ACCESS_SUCCESS)
        {
            return FALSE;
        }
    }
    return TRUE;
}


/* This entry is used for entry which have the ability to row create*/
static HSRP_IF_TRACKED_ENTRY_T cHsrpExtIfTrackedEntry;

/*
 * var_cHsrpExtIfTrackedTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_cHsrpExtIfTrackedTable(struct variable *vp,
                           oid * name,
                           size_t * length,
                           int exact,
                           size_t * var_len, WriteMethod ** write_method)
{
    UI32_T compc=0;
    oid compl[cHsrpExtIfTrackedEntry_INSTANCE_LEN];
    oid best_inst[cHsrpExtIfTrackedEntry_INSTANCE_LEN];
    UI32_T  index1, index2;
    HSRP_IF_TRACKED_ENTRY_T data;


    /* Give default value for the record first.
     * We use the row_status = 0 to indicate if this set operation is Set by field
     * or set by record(included row creation), if the row_status =0, this record
     * mean set by field, otherwise, we just think it is a normal set operation
     */
    if (!HSRP_SYS_ADPT_GetDefaultIfTrackedPriority(&cHsrpExtIfTrackedEntry.tracked_priority))
    {
        if(SNMP_MGR_IsDebugMode())
            SYSFUN_Debug_Printf("cHsrpExtIfTrackedEntry_set:HSRP_SYS_ADPT_GetDefaultIfTrackedPriority return!=HSRP_ACCESS_SUCCESS\n");
        return NULL;
    }
    cHsrpExtIfTrackedEntry.row_status = 0;

   /*Since this table allow for entry that does not exist, (creation). we need to know the write method first*/
    switch (vp->magic)
    {
       case CHSRPEXTIFTRACKEDPRIORITY:
        *write_method = write_cHsrpExtIfTrackedPriority;
        break;
      case CHSRPEXTIFTRACKEDROWSTATUS:
        *write_method = write_cHsrpExtIfTrackedRowStatus;
        break;
      default:
         *write_method =0;
         break;
    }

    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,compl, cHsrpExtIfTrackedEntry_INSTANCE_LEN);

     /*check compc, retrive compl*/
    if (exact)/*get,set*/
    {
        if (!cHsrpExtIfTrackedTable_get(compc, compl, &index1, &index2, &data))
            return NULL;
    }
    else/*getnext*/
    {
        if (!cHsrpExtIfTrackedTable_next(compc, compl, &index1, &index2, &data))
        {
            return NULL;
        }
    }
    memcpy(name, vp->name, vp->namelen*sizeof(oid));
    best_inst[0]=index1;
    best_inst[1]=index2;
    best_inst[2]= data.tracked_ifindex;
    memcpy(name + vp->namelen, best_inst, cHsrpExtIfTrackedEntry_INSTANCE_LEN*sizeof(oid));
    *length = vp->namelen +cHsrpExtIfTrackedEntry_INSTANCE_LEN;

    *var_len = sizeof(long_return);

    /*
     * * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
     #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
      case CHSRPEXTIFTRACKED:
        long_return = data.tracked_ifindex;
        return (u_char*) &long_return;
     #endif
      case CHSRPEXTIFTRACKEDPRIORITY:
        long_return = data.tracked_priority;
        return (u_char*) &long_return;
      case CHSRPEXTIFTRACKEDROWSTATUS:
        long_return = data.row_status;
        return (u_char*) &long_return;
    default:
        ERROR_MSG("");
    }
    return NULL;
}


int
write_cHsrpExtIfTrackedPriority(int action,
                                u_char * var_val,
                                u_char var_val_type,
                                size_t var_val_len,
                                u_char * statP,
                                oid * name, size_t name_len)
{
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    UI32_T index1, index2,index3;

    if (name_len!=  3 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    index1=name[oid_name_length];
    index2 = name[oid_name_length+1];
    index3 = name[oid_name_length+2];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_UNSIGNED) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(u_long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          /* In reserve2, we overwrite the set value to cHsrpExtIfTrackedEntry*/
          cHsrpExtIfTrackedEntry.tracked_priority = *(u_long *)var_val;
          if ((cHsrpExtIfTrackedEntry.tracked_priority <MIN_cHsrpExtIfTrackedPriority) || (cHsrpExtIfTrackedEntry.tracked_priority >MAX_cHsrpExtIfTrackedPriority))
             return SNMP_ERR_WRONGVALUE;
          break;
        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
           /* For row creation, if row_status =0, mean that this is a normal
            * operation, we do the normal set operation, otherwise it is a row
            * creation operation, will do nothing here, and the overall entry
            * will perform in the write_xxxRowStatus function.
              */
           if (cHsrpExtIfTrackedEntry.row_status == 0)
        {
               if (HSRP_MGR_SetIfTrackedPriority(index1,index2,index3, cHsrpExtIfTrackedEntry.tracked_priority) != HSRP_ACCESS_SUCCESS)
                     return SNMP_ERR_COMMITFAILED;
         }
         break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_cHsrpExtIfTrackedRowStatus(int action,
                                 u_char * var_val,
                                 u_char var_val_type,
                                 size_t var_val_len,
                                 u_char * statP,
                                 oid * name, size_t name_len)
{
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    UI32_T index1, index2,index3;

    if (name_len!=  3 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    index1=name[oid_name_length];
    index2 = name[oid_name_length+1];
    index3 = name[oid_name_length+2];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
           /* In reserve2, we overwrite the set value to cHsrpExtIfTrackedEntry*/
          cHsrpExtIfTrackedEntry.row_status = *(long *)var_val;
          if ((cHsrpExtIfTrackedEntry.row_status <VAL_cHsrpExtIfTrackedRowStatus_active) || (cHsrpExtIfTrackedEntry.row_status >VAL_cHsrpExtIfTrackedRowStatus_destroy))
             return SNMP_ERR_WRONGVALUE;
          break;
        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
          /* We perform the row creation here, if the row status = 4(createAndGo),
           * or 5 (createAndWait), we call the SetByEntry API, otherwise, call the
           * set rowstatus API
              */
          switch (cHsrpExtIfTrackedEntry.row_status)
          {
              case VAL_cHsrpExtSecAddrRowStatus_createAndGo:
              case VAL_cHsrpExtSecAddrRowStatus_createAndWait:
                cHsrpExtIfTrackedEntry.tracked_ifindex = index3;
                if (HSRP_MGR_SetHsrpExtIfTrackedEntry(index1, index2,&cHsrpExtIfTrackedEntry) != HSRP_ACCESS_SUCCESS)
                {
                    return SNMP_ERR_COMMITFAILED;
                }
              break;
              case VAL_cHsrpExtSecAddrRowStatus_active:
              case VAL_cHsrpExtSecAddrRowStatus_notInService:
              case VAL_cHsrpExtSecAddrRowStatus_notReady:
              case VAL_cHsrpExtSecAddrRowStatus_destroy:
                cHsrpExtIfTrackedEntry.tracked_ifindex = index3;
                if (HSRP_MGR_SetHsrpExtIfTrackedEntryRowStatus(index1, index2, &cHsrpExtIfTrackedEntry) != HSRP_ACCESS_SUCCESS)
        {
                     return SNMP_ERR_COMMITFAILED;
                }
                 break;
              default:
            return SNMP_ERR_COMMITFAILED;
         }
         break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


/* cHsrpExtSecAddrTable*/
#define cHsrpExtSecAddrEntry_INSTANCE_LEN 6
static BOOL_T cHsrpExtSecAddrTable_get(int      compc,
                                oid     *compl,
                                UI32_T  *idx1,
                                UI32_T  *idx2,
                                HSRP_SEC_ADDR_ENTRY_T   *data)
{
    if (compc !=cHsrpExtSecAddrEntry_INSTANCE_LEN)
    {
        return FALSE;
    }
    *idx1=compl[0];
    *idx2=compl[1];
    SNMP_MGR_ReadIpFromCompl(compl,2,&data->sec_addr);

    if (HSRP_MGR_GetHsrpExtSecAddrEntry(*idx1,*idx2, data)!=NETCFG_MGR_OK)
    {
        return FALSE;
    }
    else
    {
        return TRUE;

    } /*End of if */
}

static BOOL_T cHsrpExtSecAddrTable_next(int   compc,
                                 oid     *compl,
                                 UI32_T  *index1,
                                 UI32_T  *index2,
                                 HSRP_SEC_ADDR_ENTRY_T    *data)
{
    oid tmp_compl[cHsrpExtSecAddrEntry_INSTANCE_LEN];

    /* Generate the instance of each table entry and find the
     * smallest instance that's larger than compc/compl.
     *
     * Step 1: Verify and extract the input key from "compc" and "compl"
     * Note: The number of input key is defined by "compc".
     *       The key for the specified instance is defined in compl.
     */
    memcpy(tmp_compl, compl, sizeof(tmp_compl));
    SNMP_MGR_ConvertRemainToZero(compc,cHsrpExtSecAddrEntry_INSTANCE_LEN, tmp_compl);

    *index1=tmp_compl[0];
    *index2=tmp_compl[1];
     SNMP_MGR_ReadIpFromCompl(tmp_compl,2,&data->sec_addr);


    if (compc<cHsrpExtSecAddrEntry_INSTANCE_LEN)
    {
        if (HSRP_MGR_GetHsrpExtSecAddrEntry(*index1,*index2,data)!=HSRP_ACCESS_SUCCESS)
        {
            if (HSRP_MGR_GetNextHsrpExtSecAddrEntry(index1,index2,data)!=HSRP_ACCESS_SUCCESS)
            {
                return FALSE;
            }
        }
    }
    else
    {
        if (HSRP_MGR_GetNextHsrpExtSecAddrEntry(index1, index2, data)!=HSRP_ACCESS_SUCCESS)
        {
            return FALSE;
        }
    }
    return TRUE;
}

/*
 * var_cHsrpExtSecAddrTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_cHsrpExtSecAddrTable(struct variable *vp,
                         oid * name,
                         size_t * length,
                         int exact,
                         size_t * var_len, WriteMethod ** write_method)
{
    UI32_T compc=0;
    oid compl[cHsrpExtSecAddrEntry_INSTANCE_LEN];
    oid best_inst[cHsrpExtSecAddrEntry_INSTANCE_LEN];
    UI32_T  index1, index2;
    HSRP_SEC_ADDR_ENTRY_T data;

   /*Since this table allow for entry that does not exist, (creation). we need to know the write method first*/
    switch (vp->magic)
    {
       case CHSRPEXTSECADDRROWSTATUS:
        *write_method = write_cHsrpExtSecAddrRowStatus;
        break;
      default:
         *write_method =0;
         break;
    }

    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,compl, cHsrpExtSecAddrEntry_INSTANCE_LEN);

     /*check compc, retrive compl*/
    if (exact)/*get,set*/
    {
        if (!cHsrpExtSecAddrTable_get(compc, compl, &index1, &index2, &data))
            return NULL;
    }
    else/*getnext*/
    {
        if (!cHsrpExtSecAddrTable_next(compc, compl, &index1, &index2, &data))
        {
            return NULL;
        }
    }
    memcpy(name, vp->name, vp->namelen*sizeof(oid));
    best_inst[0]=index1;
    best_inst[1]=index2;
   SNMP_MGR_BindIpInstance(data.sec_addr,2,best_inst);

    memcpy(name + vp->namelen, best_inst, cHsrpExtSecAddrEntry_INSTANCE_LEN*sizeof(oid));
    *length = vp->namelen +cHsrpExtSecAddrEntry_INSTANCE_LEN;

    *var_len = sizeof(long_return);

    /*
     * * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
      case CHSRPEXTSECADDRADDRESS:
      #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        *var_len = sizeof(ipaddr_return);
        ipaddr_return = data.sec_addr;
        return (u_char*) &ipaddr_return;
      #endif
      case CHSRPEXTSECADDRROWSTATUS:
        long_return = data.row_status;
        return (u_char*) &long_return;
    default:
        ERROR_MSG("");
    }
    return NULL;
}


int
write_cHsrpExtSecAddrRowStatus(int action,
                               u_char * var_val,
                               u_char var_val_type,
                               size_t var_val_len,
                               u_char * statP, oid * name, size_t name_len)
{
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    UI32_T index1, index2,index3;
    UI32_T value;

    if (name_len!=  6 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    index1=name[oid_name_length];
    index2 = name[oid_name_length+1];
    SNMP_MGR_ReadIpFromCompl(name, oid_name_length+2,  &index3);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
           value = value = *(long *)var_val;
          if ((value <VAL_cHsrpExtSecAddrRowStatus_active) || (value >VAL_cHsrpExtSecAddrRowStatus_destroy))
             return SNMP_ERR_WRONGVALUE;
          break;
        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
        {
            HSRP_SEC_ADDR_ENTRY_T entry;
             value = *(long *)var_val;
             entry.sec_addr = index3;
             entry.row_status = value;

               if (HSRP_MGR_SetHsrpExtSecAddrEntryRowStatus(index1,index2, &entry) != HSRP_ACCESS_SUCCESS)
                     return SNMP_ERR_COMMITFAILED;
                 break;
         }
         break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

#endif /*end of #if (SYS_CPNT_HSRP == TRUE)*/


#if (SYS_CPNT_ALERT_LED == TRUE)
int do_alertLedAdminStatus(netsnmp_mib_handler             *handler,
                           netsnmp_handler_registration    *reginfo,
                           netsnmp_agent_request_info      *reqinfo,
                           netsnmp_request_info            *requests)
{
    switch(reqinfo->mode)
    {
        case MODE_GET:
        {
            UI32_T alertLedAdminStatus;

            if(!LED_MGR_AlertGetAdminState(&alertLedAdminStatus))
            {
                return SNMP_ERR_GENERR;
            }

            long_return = alertLedAdminStatus;
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *)&long_return, sizeof(long_return));

            break;
        }

        case MODE_SET_RESERVE1:
        {
            UI32_T value;

            value = (*requests->requestvb->val.integer);

            if((value != VAL_alertLedAdminStatus_enabled) && (value != VAL_alertLedAdminStatus_disabled))
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            }

            break;
        }

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            break;

        case MODE_SET_ACTION:
        {
            UI32_T value;

            value = (*requests->requestvb->val.integer);

            if(!LED_MGR_AlertSetAdminState(value))
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            }

            break;
        }

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}


int get_alertLedOperStatus(netsnmp_mib_handler             *handler,
                           netsnmp_handler_registration    *reginfo,
                           netsnmp_agent_request_info      *reqinfo,
                           netsnmp_request_info            *requests)
{
    switch(reqinfo->mode)
    {
        case MODE_GET:
        {
            UI32_T alertLedOperStatus;

            if(!LED_MGR_AlertGetOperState(&alertLedOperStatus))
            {
                return SNMP_ERR_GENERR;
            }

            long_return = alertLedOperStatus;
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));

            break;
        }

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}


int do_alertLedAcknoledge(netsnmp_mib_handler             *handler,
                          netsnmp_handler_registration    *reginfo,
                          netsnmp_agent_request_info      *reqinfo,
                          netsnmp_request_info            *requests)
{
    switch(reqinfo->mode)
    {
        case MODE_GET:
        {
            long_return = VAL_alertLedAcknoledge_noAcknowledge;
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));

            break;
        }

        case MODE_SET_RESERVE1:
        {
            UI32_T value;

            value = (*requests->requestvb->val.integer);

            if((value != VAL_alertLedAcknoledge_acknowledge) && (value != VAL_alertLedAcknoledge_noAcknowledge))
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            }

            break;
        }

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            break;

        case MODE_SET_ACTION:
        {
            UI32_T value;

            value = (*requests->requestvb->val.integer);

            switch(value)
            {
                case VAL_alertLedAcknoledge_acknowledge:
                {
                    if(!LED_MGR_AlertAcknowledge())
                    {
                        netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
                    }

                    break;
                }

                case VAL_alertLedAcknoledge_noAcknowledge:
                default:
                    break;
            }

            break;
        }

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
#endif

/* dhcpSnoopMgt */
#if (SYS_CPNT_DHCPSNP == TRUE)

/* dhcpSnoopEnable*/
int
do_dhcpSnoopEnable(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{

    switch(reqinfo->mode) {
        case MODE_GET:
        {
            UI8_T  status = 0;

            if (DHCPSNP_PMGR_GetGlobalDhcpSnoopingStatus(&status)==DHCPSNP_TYPE_OK)
            {
                long_return = status;
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER , (u_char *)&long_return , sizeof(long_return) );
            }
            else
            {
                return SNMP_ERR_GENERR;
            }
        }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:

            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
            }

            break;
        case MODE_SET_RESERVE2:

            switch ( *requests->requestvb->val.integer )
            {
                case VAL_dhcpSnoopEnable_enabled:
                    break;
                case VAL_dhcpSnoopEnable_disabled:
                    break;
                default:
                    netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
        {
            if (DHCPSNP_PMGR_SetGlobalDhcpSnoopingStatus((UI8_T)(*requests->requestvb->val.integer))!=DHCPSNP_TYPE_OK)
            {
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
            }
        }
            break;

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

/* dhcpSnoopVerifyMacAddressEnable */
int
do_dhcpSnoopVerifyMacAddressEnable(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{

    switch(reqinfo->mode) {
        case MODE_GET:
        {
            UI8_T   status = 0;

            if (DHCPSNP_PMGR_GetVerifyMacAddressStatus(&status)==DHCPSNP_TYPE_OK)
            {
                long_return = status;
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER , (u_char *)&long_return , sizeof(long_return) );
            }
            else
            {
                return SNMP_ERR_GENERR;
            }
        }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:

            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
            }

            break;
        case MODE_SET_RESERVE2:

            switch ( *requests->requestvb->val.integer )
            {
                case VAL_dhcpSnoopVerifyMacAddressEnable_enabled:
                    break;
                case VAL_dhcpSnoopVerifyMacAddressEnable_disabled:
                    break;
                default:
                    netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
        {
            if (DHCPSNP_PMGR_SetVerifyMacAddressStatus((UI8_T)(*requests->requestvb->val.integer))!=DHCPSNP_TYPE_OK)
            {
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
            }
        }
            break;

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

#if (SYS_CPNT_DHCPSNP_INFORMATION_OPTION == TRUE)
int
do_dhcpSnoopInformationOptionEnable(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{

    switch(reqinfo->mode) {
        case MODE_GET:
        {
            UI8_T  status = 0;

            if (DHCPSNP_PMGR_GetInformationOptionStatus(&status) == DHCPSNP_TYPE_OK)
            {
                long_return = status;
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER , (u_char *)&long_return , sizeof(long_return) );
            }
            else
            {
                return SNMP_ERR_GENERR;
            }
        }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:

            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
            }

            break;
        case MODE_SET_RESERVE2:

            switch ( *requests->requestvb->val.integer )
            {
                case VAL_dhcpSnoopInformationOptionEnable_enabled:
                    break;
                case VAL_dhcpSnoopInformationOptionEnable_disabled:
                    break;
                default:
                    netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
        {
            if (DHCPSNP_PMGR_SetInformationOptionStatus((UI8_T)(*requests->requestvb->val.integer)) != DHCPSNP_TYPE_OK)
            {
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
            }
        }
            break;

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
do_dhcpSnoopInformationOptionPolicy(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{

    switch(reqinfo->mode) {
        case MODE_GET:
        {
            UI8_T  policy = 0;

            if (DHCPSNP_PMGR_GetInformationPolicy(&policy) == DHCPSNP_TYPE_OK)
            {
                long_return = policy;
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER , (u_char *)&long_return , sizeof(long_return) );
            }
            else
            {
                return SNMP_ERR_GENERR;
            }
        }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:

            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
            }

            break;
        case MODE_SET_RESERVE2:

            switch ( *requests->requestvb->val.integer )
            {
                case VAL_dhcpSnoopInformationOptionPolicy_drop:
                    break;
                case VAL_dhcpSnoopInformationOptionPolicy_keep:
                    break;
                case VAL_dhcpSnoopInformationOptionPolicy_replace:
                    break;
                default:
                    netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
        {
            if (DHCPSNP_PMGR_SetInformationPolicy((UI8_T)(*requests->requestvb->val.integer)) != DHCPSNP_TYPE_OK)
            {
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
            }
        }
            break;

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
#endif

#if (SYS_CPNT_CFGDB == TRUE)

static UI32_T dhcpSnoopBindingsTableCtlAction = VAL_dhcpSnoopBindingsTableCtlAction_noAction;
int
do_dhcpSnoopBindingsTableCtlAction(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{

    switch(reqinfo->mode) {
        case MODE_GET:
        {
            long_return = dhcpSnoopBindingsTableCtlAction;
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER , (u_char *)&long_return , sizeof(long_return) );
        }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:

            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
            }

            break;
        case MODE_SET_RESERVE2:

            switch ( *requests->requestvb->val.integer )
            {
                case VAL_dhcpSnoopBindingsTableCtlAction_noAction:
                    break;
                case VAL_dhcpSnoopBindingsTableCtlAction_store:
                    break;
                case VAL_dhcpSnoopBindingsTableCtlAction_clear:
                    break;
                default:
                    netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
        {
            dhcpSnoopBindingsTableCtlAction = *requests->requestvb->val.integer;
            switch ( dhcpSnoopBindingsTableCtlAction )
            {
                case VAL_dhcpSnoopBindingsTableCtlAction_noAction :
                    break;
                case VAL_dhcpSnoopBindingsTableCtlAction_store :
                    if (DHCPSNP_PMGR_WriteBindingEntriesToFlash() != DHCPSNP_TYPE_OK)
                    {
                        netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
                    }
                    dhcpSnoopBindingsTableCtlAction  = VAL_dhcpSnoopBindingsTableCtlAction_noAction;
                    break;
                case VAL_dhcpSnoopBindingsTableCtlAction_clear :
                    if (DHCPSNP_PMGR_ClearBindingEntriesInFlash() != DHCPSNP_TYPE_OK)
                    {
                        netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
                    }
                    dhcpSnoopBindingsTableCtlAction = VAL_dhcpSnoopBindingsTableCtlAction_noAction;
                    break;
                default:
                    netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
            }
        }
            break;

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
#endif

#if (SYS_CPNT_DHCPSNP_SYSTEM_RATELIMIT == TRUE)
int do_dhcpSnoopLimitRate(netsnmp_mib_handler *handler,
    netsnmp_handler_registration *reginfo,
    netsnmp_agent_request_info *reqinfo,
    netsnmp_request_info *requests)
{
    switch (reqinfo->mode)
    {
        case MODE_GET:
        {
            UI32_T value = 0;

            if (DHCPSNP_PMGR_GetGlobalRateLimit(&value) == DHCPSNP_TYPE_OK)
            {
                long_return = value;
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *)&long_return, sizeof(long_return));
            }
            else
            {
                return SNMP_ERR_GENERR;
            }

            break;
        }

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            if (requests->requestvb->type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case MODE_SET_RESERVE2:
            if ((*requests->requestvb->val.integer < MIN_dhcpSnoopLimitRate) || (*requests->requestvb->val.integer > MAX_dhcpSnoopLimitRate))
            {
               return SNMP_ERR_WRONGVALUE;
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called.
             */
            break;

        case MODE_SET_ACTION:
        {
            if (DHCPSNP_PMGR_SetGlobalRateLimit(*requests->requestvb->val.integer) != DHCPSNP_TYPE_OK)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
#endif

/* dhcpSnoopVlanConfigTable*/
#define DHCPSNOOPVLANCONFIGENTRY_INSTANCE_LEN  1

BOOL_T dhcpSnoopVlanConfigTable_OidIndexToData(UI32_T exact, UI32_T compc,
            oid * compl ,  UI32_T *dhcpSnoopVlanIndex)
{
    /* get or write
     */
    if(exact)
    {

        /* check the index length
         */

        if(compc != DHCPSNOOPVLANCONFIGENTRY_INSTANCE_LEN) /* the constant size index*/
        {
            return FALSE;
        }
    }
    *dhcpSnoopVlanIndex=compl[0];
    return TRUE;
}

/*
 * var_dhcpSnoopVlanConfigTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *
var_dhcpSnoopVlanConfigTable(struct variable *vp,
            oid     *name,
            size_t  *length,
            int     exact,
            size_t  *var_len,
            WriteMethod **write_method)
{
    /* variables we may use later */
    UI32_T compc=0;
    oid compl[DHCPSNOOPVLANCONFIGENTRY_INSTANCE_LEN] = {0};
    oid best_inst[DHCPSNOOPVLANCONFIGENTRY_INSTANCE_LEN] = {0};
    UI32_T  vid = 0;
    UI8_T   status = 0;
    switch(vp->magic)
    {
    case LEAF_dhcpSnoopVlanEnable:
        *write_method = write_dhcpSnoopVlanEnable;
        break;
    default:
        *write_method = 0;
        break;
    }

    /*check compc, retrive compl*/
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,compl, DHCPSNOOPVLANCONFIGENTRY_INSTANCE_LEN);


    if (exact)/*get,set*/
    {
        if(dhcpSnoopVlanConfigTable_OidIndexToData(exact,compc,compl, &vid)==FALSE)
        {
            return NULL;
        }

        /*get data
         */
        if (DHCPSNP_PMGR_GetDhcpSnoopingStatusByVlan(vid, &status)!=DHCPSNP_TYPE_OK)
        {
            return NULL;
        }
    }
    else/*getnext*/
    {

        dhcpSnoopVlanConfigTable_OidIndexToData(exact,compc,compl, &vid);
        /* check the length of inputing index,if <1 we should try get {0.0.0.0.0...}
         */
        if (compc< 1)
        {

            if ( DHCPSNP_PMGR_GetDhcpSnoopingStatusByVlan(vid, &status)!=DHCPSNP_TYPE_OK)
            {

                /*get next data*/
                if ( DHCPSNP_PMGR_GetNextDhcpSnoopingStatusByVlan(&vid, &status )!=DHCPSNP_TYPE_OK)
                {
                    return NULL;
                }
            }
        }
        else
        {

            /*get next data*/
            if ( DHCPSNP_PMGR_GetNextDhcpSnoopingStatusByVlan(&vid, &status )!=DHCPSNP_TYPE_OK)
            {
                return NULL;
            }
        }
    }

    memcpy(name, vp->name, vp->namelen*sizeof(oid));
    /* assign data to the oid index
     */


    best_inst[0]=vid;
    memcpy(name+vp->namelen,best_inst,DHCPSNOOPVLANCONFIGENTRY_INSTANCE_LEN*sizeof(oid));
    *length = vp->namelen+DHCPSNOOPVLANCONFIGENTRY_INSTANCE_LEN ;

    /* this is where we do the value assignments for the mib results.
     */
    switch(vp->magic) {

#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    case LEAF_dhcpSnoopVlanIndex:
        *var_len = sizeof(long_return);
        long_return = vid;
        return (u_char *) &long_return;
#endif
    case LEAF_dhcpSnoopVlanEnable:
        *var_len = sizeof(long_return);
        long_return = status;
        return (u_char *) &long_return;
    default:
      ERROR_MSG("");
    }
    return NULL;
}

int
write_dhcpSnoopVlanEnable(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{

    switch ( action ) {

        case RESERVE1:

          if (var_val_type != ASN_INTEGER)
          {
              return SNMP_ERR_WRONGTYPE;
          }
          break;

        case RESERVE2:
            switch ( *(long *)var_val )
            {
                case VAL_dhcpSnoopVlanEnable_enabled:
                    break;
                case VAL_dhcpSnoopVlanEnable_disabled:
                    break;
                default:
                    return SNMP_ERR_WRONGVALUE;
            }
          break;

        case FREE:
          break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
            I32_T value=0;
            UI32_T dhcpSnoopVlanIndex = 0;

            if(dhcpSnoopVlanConfigTable_OidIndexToData(TRUE,name_len-oid_name_length,&(name[oid_name_length]), &dhcpSnoopVlanIndex)==FALSE)
                return SNMP_ERR_COMMITFAILED;
            value = *(long *)var_val;

            /* check value */
            if(value == VAL_dhcpSnoopVlanEnable_enabled)
            {
                if(DHCPSNP_PMGR_EnableDhcpSnoopingByVlan(dhcpSnoopVlanIndex) != DHCPSNP_TYPE_OK)
                {
                    return SNMP_ERR_COMMITFAILED;
                }
            }
            else if (value == VAL_dhcpSnoopVlanEnable_disabled)
            {
                if(DHCPSNP_PMGR_DisableDhcpSnoopingByVlan(dhcpSnoopVlanIndex) != DHCPSNP_TYPE_OK)
                {
                    return SNMP_ERR_COMMITFAILED;
                }
            }
            else
                return SNMP_ERR_COMMITFAILED;
        }
            break;

        case UNDO:
          break;

        case COMMIT:
          break;
    }
    return SNMP_ERR_NOERROR;
}

/* dhcpSnoopPortConfigTable*/
#define DHCPSNOOPPORTCONFIGENTRY_INSTANCE_LEN  1

BOOL_T dhcpSnoopPortConfigTable_OidIndexToData(UI32_T exact, UI32_T compc,
            oid * compl ,  UI32_T *dhcpSnoopPortIfIndex)
{
    /* get or write
     */
    if(exact)
    {

        /* check the index length
         */

        if(compc != DHCPSNOOPPORTCONFIGENTRY_INSTANCE_LEN) /* the constant size index*/
        {
            return FALSE;
        }
    }
    *dhcpSnoopPortIfIndex=compl[0];
    return TRUE;
}

/*
 * var_dhcpSnoopPortConfigTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *
var_dhcpSnoopPortConfigTable(struct variable *vp,
            oid     *name,
            size_t  *length,
            int     exact,
            size_t  *var_len,
            WriteMethod **write_method)
{
    /* variables we may use later */
    UI32_T compc=0;
    oid compl[DHCPSNOOPPORTCONFIGENTRY_INSTANCE_LEN] = {0};
    oid best_inst[DHCPSNOOPPORTCONFIGENTRY_INSTANCE_LEN] = {0};
    UI32_T  lport_ifindex = 0;
    DHCPSNP_TYPE_PortInfo_T  entry;
    switch(vp->magic)
    {
    case LEAF_dhcpSnoopPortTrustEnable:
        *write_method = write_dhcpSnoopPortTrustEnable;
        break;
    default:
        *write_method = 0;
        break;
    }

    /*check compc, retrive compl*/
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,compl, DHCPSNOOPPORTCONFIGENTRY_INSTANCE_LEN);

    memset(&entry, 0, sizeof(entry));

    if (exact)/*get,set*/
    {
        if(dhcpSnoopPortConfigTable_OidIndexToData(exact,compc,compl, &lport_ifindex)==FALSE)
        {
            return NULL;
        }

        /*get data
         */
        if (DHCPSNP_PMGR_GetPortInfo(lport_ifindex, &entry)!=DHCPSNP_TYPE_OK)
        {
            return NULL;
        }
    }
    else/*getnext*/
    {

        dhcpSnoopPortConfigTable_OidIndexToData(exact,compc,compl, &lport_ifindex);
        /* check the length of inputing index,if <1 we should try get {0.0.0.0.0...}
         */
        if (compc< 1)
        {

            if ( DHCPSNP_PMGR_GetPortInfo(lport_ifindex, &entry)!=DHCPSNP_TYPE_OK)
            {

                /*get next data*/
                if ( DHCPSNP_PMGR_GetNextPortInfo(&lport_ifindex, &entry)!=DHCPSNP_TYPE_OK)
                {
                    return NULL;
                }
            }
        }
        else
        {

            /*get next data*/
            if ( DHCPSNP_PMGR_GetNextPortInfo(&lport_ifindex, &entry)!=DHCPSNP_TYPE_OK)
            {
                return NULL;
            }
        }
    }

    memcpy(name, vp->name, vp->namelen*sizeof(oid));
    /* assign data to the oid index
     */


    best_inst[0]=lport_ifindex;
    memcpy(name+vp->namelen,best_inst,DHCPSNOOPPORTCONFIGENTRY_INSTANCE_LEN*sizeof(oid));
    *length = vp->namelen+DHCPSNOOPPORTCONFIGENTRY_INSTANCE_LEN ;

    /* this is where we do the value assignments for the mib results.
     */
    switch(vp->magic) {

#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    case LEAF_dhcpSnoopPortIfIndex:
        *var_len = sizeof(long_return);
        long_return = lport_ifindex;
        return (u_char *) &long_return;
#endif
    case LEAF_dhcpSnoopPortTrustEnable:
        *var_len = sizeof(long_return);
        long_return = entry.trust_status;
        return (u_char *) &long_return;
    default:
      ERROR_MSG("");
    }
    return NULL;
}

int
write_dhcpSnoopPortTrustEnable(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{

    switch ( action ) {

        case RESERVE1:

          if (var_val_type != ASN_INTEGER)
          {
              return SNMP_ERR_WRONGTYPE;
          }
          break;

        case RESERVE2:
            switch ( *(long *)var_val )
            {
                case VAL_dhcpSnoopPortTrustEnable_enabled:
                    break;
                case VAL_dhcpSnoopPortTrustEnable_disabled:
                    break;
                default:
                    return SNMP_ERR_WRONGVALUE;
            }
          break;

        case FREE:
          break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
            I32_T value=0;
            UI32_T dhcpSnoopPortIfIndex = 0;

            if(dhcpSnoopPortConfigTable_OidIndexToData(TRUE,name_len-oid_name_length,&(name[oid_name_length]), &dhcpSnoopPortIfIndex)==FALSE)
                return SNMP_ERR_COMMITFAILED;
            value = *(long *)var_val;
            if(DHCPSNP_PMGR_SetPortTrustStatus( dhcpSnoopPortIfIndex, value) != DHCPSNP_TYPE_OK)
                return SNMP_ERR_COMMITFAILED;
        }
            break;

        case UNDO:
          break;

        case COMMIT:
          break;
    }
    return SNMP_ERR_NOERROR;
}


/* dhcpSnoopingBindingsTable*/
#define DHCPSNOOPBINDINGSENTRY_INSTANCE_LEN  7

BOOL_T dhcpSnoopBindingsTable_OidIndexToData(UI32_T exact, UI32_T compc,
            oid * compl ,  UI32_T *dhcpSnoopBindingsVlanIndex, UI8_T *dhcpSnoopBindingsMacAddress)
{
    int i;
    /* get or write
     */
    if(exact)
    {

        /* check the index length
         */

        if(compc != DHCPSNOOPBINDINGSENTRY_INSTANCE_LEN) /* the constant size index*/
        {
            return FALSE;
        }
    }
    *dhcpSnoopBindingsVlanIndex=compl[0];
    for( i=0;i< SIZE_dhcpSnoopBindingsMacAddress ;i++)
    {
        dhcpSnoopBindingsMacAddress[i]=compl[1+i];
    }

    return TRUE;
}

/*
 * var_dhcpSnoopBindingsTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *
var_dhcpSnoopBindingsTable(struct variable *vp,
            oid     *name,
            size_t  *length,
            int     exact,
            size_t  *var_len,
            WriteMethod **write_method)
{
    int i;
    /* variables we may use later */
    UI32_T compc=0;
    oid compl[DHCPSNOOPBINDINGSENTRY_INSTANCE_LEN] = {0};
    oid best_inst[DHCPSNOOPBINDINGSENTRY_INSTANCE_LEN] = {0};
    DHCPSNP_TYPE_BindingEntry_T  entry;
    switch(vp->magic)
    {
#if 0
    case LEAF_dhcpSnoopBindingsAddrType:
        *write_method = write_dhcpSnoopBindingsAddrType;
        break;
    case LEAF_dhcpSnoopBindingsIpAddress:
        *write_method = write_dhcpSnoopBindingsIpAddress;
        break;
    case LEAF_dhcpSnoopBindingsPortIfIndex:
        *write_method = write_dhcpSnoopBindingsPortIfIndex;
        break;
    case LEAF_dhcpSnoopBindingsLeaseTime:
        *write_method = write_dhcpSnoopBindingsLeaseTime;
        break;
    case LEAF_dhcpSnoopBindingsStatus:
        *write_method = write_dhcpSnoopBindingsStatus;
        break;
#endif
    default:
        *write_method = 0;
        break;
    }

    /*check compc, retrive compl*/
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,compl, DHCPSNOOPBINDINGSENTRY_INSTANCE_LEN);

    memset(&entry, 0, sizeof(entry));

    if (exact)/*get,set*/
    {
        if(dhcpSnoopBindingsTable_OidIndexToData(exact,compc,compl, &entry.vid_ifindex, entry.mac_p)==FALSE)
        {
            return NULL;
        }

        /*get data
         */
        if (DHCPSNP_PMGR_GetDhcpSnoopingBindingEntry(&entry)!=DHCPSNP_TYPE_OK)
        {
            return NULL;
        }
    }
    else/*getnext*/
    {

        dhcpSnoopBindingsTable_OidIndexToData(exact,compc,compl, &entry.vid_ifindex, entry.mac_p);
        /* check the length of inputing index,if <1 we should try get {0.0.0.0.0...}
         */
        if (compc< 1)
        {

            if ( DHCPSNP_PMGR_GetDhcpSnoopingBindingEntry(&entry)!=DHCPSNP_TYPE_OK)
            {

                /*get next data*/
                if ( DHCPSNP_PMGR_GetNextDhcpSnoopingBindingEntry(&entry)!=DHCPSNP_TYPE_OK)
                {
                    return NULL;
                }
            }
        }
        else
        {

            /*get next data*/
            if ( DHCPSNP_PMGR_GetNextDhcpSnoopingBindingEntry(&entry)!=DHCPSNP_TYPE_OK)
            {
                return NULL;
            }
        }
    }

    memcpy(name, vp->name, vp->namelen*sizeof(oid));
    /* assign data to the oid index
     */


    best_inst[0]=entry.vid_ifindex;
    for( i=0;i< SIZE_dhcpSnoopBindingsMacAddress ;i++)
    {
        best_inst[1+i]=entry.mac_p[i];
    }
    memcpy(name+vp->namelen,best_inst,DHCPSNOOPBINDINGSENTRY_INSTANCE_LEN*sizeof(oid));
    *length = vp->namelen+DHCPSNOOPBINDINGSENTRY_INSTANCE_LEN ;

    /* this is where we do the value assignments for the mib results.
     */
    switch(vp->magic) {

#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    case LEAF_dhcpSnoopBindingsVlanIndex:
        *var_len = sizeof(long_return);
        long_return = entry.vid_ifindex;
        return (u_char *) &long_return;
#endif
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    case LEAF_dhcpSnoopBindingsMacAddress:
        *var_len = SIZE_dhcpSnoopBindingsMacAddress;
        memcpy(return_buf, entry.mac_p,*var_len);
        return (u_char*)return_buf;
#endif
    case LEAF_dhcpSnoopBindingsAddrType:
        *var_len = sizeof(long_return);
        long_return = entry.ip_addr_type;
        return (u_char *) &long_return;
    case LEAF_dhcpSnoopBindingsEntryType:
        *var_len = sizeof(long_return);
        long_return = entry.type;
        return (u_char *) &long_return;
    case LEAF_dhcpSnoopBindingsIpAddress:
        *var_len = sizeof(ipaddr_return);
        ipaddr_return = entry.ip_addr;
        return (u_char *) &ipaddr_return;
    case LEAF_dhcpSnoopBindingsPortIfIndex:
        *var_len = sizeof(long_return);
        long_return = entry.lport_ifindex;
        return (u_char *) &long_return;
    case LEAF_dhcpSnoopBindingsLeaseTime:
        *var_len = sizeof(long_return);
        long_return = entry.lease_time;
        return (u_char *) &long_return;
#if 0
    case LEAF_dhcpSnoopBindingsStatus:
        *var_len = sizeof(long_return);
        long_return = entry.row_status;
        return (u_char *) &long_return;
#endif
    default:
      ERROR_MSG("");
    }
    return NULL;
}
#if 0
int
write_dhcpSnoopBindingsAddrType(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{

    switch ( action ) {

        case RESERVE1:

          if (var_val_type != ASN_INTEGER)
          {
              return SNMP_ERR_WRONGTYPE;
          }
          break;

        case RESERVE2:
            switch ( *(long *)var_val )
            {
                case VAL_dhcpSnoopBindingsAddrType_unknown:
                    break;
                case VAL_dhcpSnoopBindingsAddrType_ipv4:
                    break;
                case VAL_dhcpSnoopBindingsAddrType_ipv6:
                    break;
                case VAL_dhcpSnoopBindingsAddrType_ipv4z:
                    break;
                case VAL_dhcpSnoopBindingsAddrType_ipv6z:
                    break;
                case VAL_dhcpSnoopBindingsAddrType_dns:
                    break;
                default:
                    return SNMP_ERR_WRONGVALUE;
            }
          break;

        case FREE:
          break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
            I32_T value=0;
            UI32_T dhcpSnoopBindingsVlanIndex = 0;
            UI8_T dhcpSnoopBindingsMacAddress[SIZE_dhcpSnoopBindingsMacAddress] = {0};

            if(dhcpSnoopBindingsTable_OidIndexToData(TRUE,name_len-oid_name_length,&(name[oid_name_length]), &dhcpSnoopBindingsVlanIndex, dhcpSnoopBindingsMacAddress)==FALSE)
                return SNMP_ERR_COMMITFAILED;
            value = *(long *)var_val;
            if(DHCPSNP_PMGR_SetBindingsAddrType( dhcpSnoopBindingsVlanIndex, dhcpSnoopBindingsMacAddress, value) != DHCPSNP_TYPE_OK)
                return SNMP_ERR_COMMITFAILED;
        }
            break;

        case UNDO:
          break;

        case COMMIT:
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_dhcpSnoopBindingsIpAddress(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{

    switch ( action ) {

        case RESERVE1:

          if (var_val_type != ASN_IPADDRESS)
          {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len !=  SYS_ADPT_IPV4_ADDR_LEN)
          {
              return SNMP_ERR_WRONGLENGTH;
          }

          break;

        case RESERVE2:
          break;

        case FREE:
          break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
            UI32_T value=0;
            UI32_T dhcpSnoopBindingsVlanIndex = 0;
            UI8_T dhcpSnoopBindingsMacAddress[SIZE_dhcpSnoopBindingsMacAddress] = {0};

            if(dhcpSnoopBindingsTable_OidIndexToData(TRUE,name_len-oid_name_length,&(name[oid_name_length]), &dhcpSnoopBindingsVlanIndex, dhcpSnoopBindingsMacAddress)==FALSE)
                return SNMP_ERR_COMMITFAILED;
            memcpy(&value, var_val, var_val_len);
            if(DHCPSNP_PMGR_SetBindingsIpAddress( dhcpSnoopBindingsVlanIndex, dhcpSnoopBindingsMacAddress, value) != DHCPSNP_TYPE_OK)
                return SNMP_ERR_COMMITFAILED;
        }
            break;

        case UNDO:
          break;

        case COMMIT:
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_dhcpSnoopBindingsPortIfIndex(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{

    switch ( action ) {

        case RESERVE1:

          if (var_val_type != ASN_INTEGER)
          {
              return SNMP_ERR_WRONGTYPE;
          }
          break;

        case RESERVE2:

            if (*(long *)var_val< MIN_dhcpSnoopBindingsPortIfIndex ||*(long *)var_val > MAX_dhcpSnoopBindingsPortIfIndex)
            {
                return SNMP_ERR_WRONGVALUE;
            }
          break;

        case FREE:
          break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
            I32_T value=0;
            UI32_T dhcpSnoopBindingsVlanIndex = 0;
            UI8_T dhcpSnoopBindingsMacAddress[SIZE_dhcpSnoopBindingsMacAddress] = {0};

            if(dhcpSnoopBindingsTable_OidIndexToData(TRUE,name_len-oid_name_length,&(name[oid_name_length]), &dhcpSnoopBindingsVlanIndex, dhcpSnoopBindingsMacAddress)==FALSE)
                return SNMP_ERR_COMMITFAILED;
            value = *(long *)var_val;
            if(DHCPSNP_PMGR_SetBindingsPortIfIndex( dhcpSnoopBindingsVlanIndex, dhcpSnoopBindingsMacAddress, value) != DHCPSNP_TYPE_OK)
                return SNMP_ERR_COMMITFAILED;
        }
            break;

        case UNDO:
          break;

        case COMMIT:
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_dhcpSnoopBindingsLeaseTime(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{

    switch ( action ) {

        case RESERVE1:

          if (var_val_type != ASN_UNSIGNED)
          {
              return SNMP_ERR_WRONGTYPE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
          break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
            UI32_T value=0;
            UI32_T dhcpSnoopBindingsVlanIndex = 0;
            UI8_T dhcpSnoopBindingsMacAddress[SIZE_dhcpSnoopBindingsMacAddress] = {0};

            if(dhcpSnoopBindingsTable_OidIndexToData(TRUE,name_len-oid_name_length,&(name[oid_name_length]), &dhcpSnoopBindingsVlanIndex, dhcpSnoopBindingsMacAddress)==FALSE)
                return SNMP_ERR_COMMITFAILED;
            value = *(u_long *)var_val;
            if(DHCPSNP_PMGR_SetBindingsLeaseTime( dhcpSnoopBindingsVlanIndex, dhcpSnoopBindingsMacAddress, value) != DHCPSNP_TYPE_OK)
                return SNMP_ERR_COMMITFAILED;
        }
            break;

        case UNDO:
          break;

        case COMMIT:
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_dhcpSnoopBindingsStatus(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{

    switch ( action ) {

        case RESERVE1:

          if (var_val_type != ASN_INTEGER)
          {
              return SNMP_ERR_WRONGTYPE;
          }
          break;

        case RESERVE2:
            switch ( *(long *)var_val )
            {

                case VAL_dhcpSnoopBindingsStatus_active:
                    break;
                case VAL_dhcpSnoopBindingsStatus_notInService:
                    break;
                case VAL_dhcpSnoopBindingsStatus_notReady:
                    break;
                case VAL_dhcpSnoopBindingsStatus_createAndGo:
                    break;
                case VAL_dhcpSnoopBindingsStatus_createAndWait:
                    break;
                case VAL_dhcpSnoopBindingsStatus_destroy:
                    break;
                default:
                    return SNMP_ERR_WRONGVALUE;
            }
          break;

        case FREE:
          break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
            I32_T value=0;
            UI32_T dhcpSnoopBindingsVlanIndex = 0;
            UI8_T dhcpSnoopBindingsMacAddress[SIZE_dhcpSnoopBindingsMacAddress] = {0};

            if(dhcpSnoopBindingsTable_OidIndexToData(TRUE,name_len-oid_name_length,&(name[oid_name_length]), &dhcpSnoopBindingsVlanIndex, dhcpSnoopBindingsMacAddress)==FALSE)
                return SNMP_ERR_COMMITFAILED;
            value = *(long *)var_val;
            if(DHCPSNP_PMGR_SetBindingsRowStatus( dhcpSnoopBindingsVlanIndex, dhcpSnoopBindingsMacAddress, value) != DHCPSNP_TYPE_OK)
                return SNMP_ERR_COMMITFAILED;
        }
            break;

        case UNDO:
          break;

        case COMMIT:
          break;
    }
    return SNMP_ERR_NOERROR;
}
#endif

/* dhcpSnoopTotalForwardedPkts */
int
get_dhcpSnoopTotalForwardedPkts(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{

    switch(reqinfo->mode) {
        case MODE_GET:
        {
            UI32_T value = 0;

            if (DHCPSNP_PMGR_GetTotalForwardedPktCounter(&value)==DHCPSNP_TYPE_OK)
            {
                long_return = value;
                snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER , (u_char *)&long_return , sizeof(long_return) );
            }
            else
            {
                return SNMP_ERR_GENERR;
            }
        }
            break;


        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

/* get_dhcpSnoopUntrustedPortDroppedPkts */
int
get_dhcpSnoopUntrustedPortDroppedPkts(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{

    switch(reqinfo->mode) {
        case MODE_GET:
        {
            UI32_T value = 0;

            if (DHCPSNP_PMGR_GetUntrustedDroppedPktCounter(&value)==DHCPSNP_TYPE_OK)
            {
                long_return = value;
                snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER , (u_char *)&long_return , sizeof(long_return) );
            }
            else
            {
                return SNMP_ERR_GENERR;
            }
        }
            break;


        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

#endif

#if (SYS_CPNT_CLUSTER==TRUE)

int
do_clusterEnable(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{

    switch(reqinfo->mode) {
        case MODE_GET:
        {
            UI32_T value = 0;

            if (CLUSTER_POM_GetClusterStatusEx(&value)==TRUE)
            {
                long_return = value;
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER , (u_char *)&long_return , sizeof(long_return) );
            }
            else
            {
                return SNMP_ERR_GENERR;
            }
        }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:

            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
            }

            break;
        case MODE_SET_RESERVE2:

            switch ( *requests->requestvb->val.integer )
            {
                case VAL_clusterEnable_enabled:
                    break;
                case VAL_clusterEnable_disabled:
                    break;
                default:
                    netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
        {
            if (CLUSTER_PMGR_SetClusterStatus(*requests->requestvb->val.integer)!=CLUSTER_TYPE_OK)
            {
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
            }
        }
            break;

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_clusterCommanderEnable(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{

    switch(reqinfo->mode) {
        case MODE_GET:
        {
            CLUSTER_TYPE_EntityInfo_T cluster;
            if (CLUSTER_POM_GetClusterInfo(&cluster)==TRUE)
            {
                if(cluster.role==CLUSTER_TYPE_COMMANDER)
                    long_return=VAL_clusterCommanderEnable_enabled;
                else
                    long_Return=VAL_clusterCommanderEnable_disabled;

                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER , (u_char *)&long_return , sizeof(long_return) );
            }
            else
            {
                return SNMP_ERR_GENERR;
            }
        }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:

            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
            }

            break;
        case MODE_SET_RESERVE2:

            switch ( *requests->requestvb->val.integer )
            {
                case VAL_clusterCommanderEnable_enabled:
                    break;
                case VAL_clusterCommanderEnable_disabled:
                    break;
                default:
                    netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
        {
            if (CLUSTER_PMGR_SetClusterCommander(*requests->requestvb->val.integer)!=TRUE)
            {
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
            }
        }
            break;

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_clusterIpPool(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{

    switch(reqinfo->mode) {
        case MODE_GET:
        {
            if (CLUSTER_POM_GetIpPool((UI8_T *)&ipaddr_return)==TRUE)
            {
                snmp_set_var_typed_value(requests->requestvb, ASN_IPADDRESS , (u_char *)&ipaddr_return , sizeof(ipaddr_return));
            }
            else
            {
                return SNMP_ERR_GENERR;
            }
        }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:

            if (requests->requestvb->type != ASN_IPADDRESS)
            {
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
            }

            break;
        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
        {
            if (CLUSTER_PMGR_SetIpPool(requests->requestvb->val.string)!=TRUE)
            {
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
            }
        }
            break;

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_clusterClearCandidateTable(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{

    switch(reqinfo->mode) {
        case MODE_GET:
        {
            long_return = VAL_clusterClearCandidateTable_noClear;
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *)&long_return, sizeof(long_return));

            break;
        }

        case MODE_SET_RESERVE1:
            if (requests->requestvb->type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }

            break;

        case MODE_SET_RESERVE2:
            switch (*requests->requestvb->val.integer)
            {
                case VAL_clusterClearCandidateTable_noClear:
                    break;

                case VAL_clusterClearCandidateTable_clear:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case MODE_SET_FREE:
            break;

        case MODE_SET_ACTION:
            if (   (*requests->requestvb->val.integer == VAL_clusterClearCandidateTable_clear)
                && (CLUSTER_PMGR_ClearCandidateTable() != TRUE))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_clusterRole(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{

    switch(reqinfo->mode) {
        case MODE_GET:
        {
            CLUSTER_TYPE_EntityInfo_T cluster;
            if (CLUSTER_POM_GetClusterInfo(&cluster)==TRUE)
            {
                switch(cluster.role)
                {
                    case CLUSTER_TYPE_COMMANDER:
                        long_return=VAL_clusterRole_commander;
                        break;
                    case CLUSTER_TYPE_CANDIDATE:
                    case CLUSTER_TYPE_MEMBER_TOBE:
                    case CLUSTER_TYPE_INACTIVE_MEMBER:
                    default:
                        long_return=VAL_clusterRole_candidate;
                        break;
                    case CLUSTER_TYPE_ACTIVE_MEMBER:
                        long_return=VAL_clusterRole_activeMember;
                        break;
                    case CLUSTER_TYPE_DISABLE:
                        long_return=VAL_clusterRole_disabled;
                        break;
                }

                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER , (u_char *)&long_return , sizeof(long_return) );
            }
            else
            {
                return SNMP_ERR_GENERR;
            }
        }
            break;


        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_clusterMemberCount(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{

    switch(reqinfo->mode) {
        case MODE_GET:
        {
            CLUSTER_TYPE_EntityInfo_T cluster;
            if (CLUSTER_POM_GetClusterInfo(&cluster)==TRUE)
            {
                long_return=cluster.number_of_members;
                snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER , (u_char *)&long_return , sizeof(long_return) );
            }
            else
            {
                return SNMP_ERR_GENERR;
            }
        }
            break;


        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_clusterCandidateCount(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{

    switch(reqinfo->mode) {
        case MODE_GET:
        {
            CLUSTER_TYPE_EntityInfo_T cluster;
            if (CLUSTER_POM_GetClusterInfo(&cluster)==TRUE)
            {
                long_return=cluster.number_of_candidates;
                snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER , (u_char *)&long_return , sizeof(long_return) );
            }
            else
            {
                return SNMP_ERR_GENERR;
            }
        }
            break;


        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}


static UI32_T cluster_member_add_ctl_id=0;
static UI8_T cluster_member_add_ctl_mac_addr[SIZE_clusterMemberAddCtlMacAddr]={0};

int
do_clusterMemberAddCtlMacAddr(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{


    switch(reqinfo->mode) {
        case MODE_GET:
        {
            UI32_T var_len=0;
            {
                memcpy(return_buf,cluster_member_add_ctl_mac_addr,SIZE_clusterMemberAddCtlMacAddr);
                var_len = SIZE_clusterMemberAddCtlMacAddr;
                snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR , (u_char *)return_buf , var_len );
            }
        }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:

            if (requests->requestvb->type != ASN_OCTET_STR)
            {
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
            }

            if (requests->requestvb->val_len != SIZE_clusterMemberAddCtlMacAddr)
            {
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGLENGTH);
            }

            break;
        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
        {
            memcpy(cluster_member_add_ctl_mac_addr,requests->requestvb->val.string,SIZE_clusterMemberAddCtlMacAddr);
        }
            break;

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_clusterMemberAddCtlId(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    switch(reqinfo->mode) {
        case MODE_GET:
        {
            {
                long_return=cluster_member_add_ctl_id;
                snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED , (u_char *)&long_return , sizeof(long_return) );
            }
        }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:

            if (requests->requestvb->type != ASN_UNSIGNED)
            {
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
            }

            break;
        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
        {
            cluster_member_add_ctl_id=*requests->requestvb->val.integer;
        }
            break;

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_clusterMemberAddCtlAction(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{

    switch(reqinfo->mode) {
        case MODE_GET:
        {
            {
                long_return=VAL_clusterMemberAddCtlAction_noAdd;
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER , (u_char *)&long_return , sizeof(long_return) );
            }
        }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:

            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
            }

            break;
        case MODE_SET_RESERVE2:

            switch ( *requests->requestvb->val.integer )
            {
                case VAL_clusterMemberAddCtlAction_noAdd:
                    break;
                case VAL_clusterMemberAddCtlAction_add:
                    break;
                default:
                    netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
        {
            if ((*requests->requestvb->val.integer!=VAL_clusterMemberAddCtlAction_add)
                 ||(CLUSTER_PMGR_AddMember(cluster_member_add_ctl_mac_addr,cluster_member_add_ctl_id)!=TRUE))
            {
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
            }
        }
            break;

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

static UI32_T cluster_member_remove_ctl_id=0;

int
do_clusterMemberRemoveCtlId(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{

    switch(reqinfo->mode) {
        case MODE_GET:
        {
            {
                long_return=cluster_member_remove_ctl_id;
                snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED , (u_char *)&long_return , sizeof(long_return) );
            }
        }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:

            if (requests->requestvb->type != ASN_UNSIGNED)
            {
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
            }

            break;
        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
        {
            cluster_member_remove_ctl_id=*requests->requestvb->val.integer;
        }
            break;

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_clusterMemberRemoveCtlAction(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{

    switch(reqinfo->mode) {
        case MODE_GET:
        {
            {
               long_return=VAL_clusterMemberRemoveCtlAction_noRemove;
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER , (u_char *)&long_return , sizeof(long_return) );
            }
        }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:

            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
            }

            break;
        case MODE_SET_RESERVE2:

            switch ( *requests->requestvb->val.integer )
            {
                case VAL_clusterMemberRemoveCtlAction_noRemove:
                    break;
                case VAL_clusterMemberRemoveCtlAction_remove:
                    break;
                default:
                    netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
        {
            CLUSTER_TYPE_MemberEntry_T entry;
            if (CLUSTER_POM_GetNMembers((UI8_T) cluster_member_remove_ctl_id, &entry,1)!=1)
            {
                  netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
            }
            if ((*requests->requestvb->val.integer!=VAL_clusterMemberRemoveCtlAction_remove)
                 ||(CLUSTER_PMGR_RemoveMember(entry.mac,cluster_member_remove_ctl_id)!=TRUE))
            {
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
            }
        }
            break;

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}


#define CLUSTERCANDIDATEENTRY_INSTANCE_LEN  6

BOOL_T clusterCandidateTable_OidIndexToData(UI32_T exact, UI32_T compc,
            oid * compl ,  UI8_T *cluster_candidate_mac_addr)
{
    UI32_T i;
    /* get or write
     */
    if(exact)
    {

        /* check the index length
         */

        if(compc != CLUSTERCANDIDATEENTRY_INSTANCE_LEN) /* the constant size index*/
        {
            return FALSE;
        }
    }
    for( i=0;i< SIZE_clusterCandidateMacAddr ;i++)
    {
        cluster_candidate_mac_addr[i]=(UI8_T)compl[0+i];
    }

    return TRUE;
}

/*
 * var_clusterCandidateTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *
var_clusterCandidateTable(struct variable *vp,
            oid     *name,
            size_t  *length,
            int     exact,
            size_t  *var_len,
            WriteMethod **write_method)
{
    /* variables we may use later */
    UI32_T compc=0,i;
    oid compl[CLUSTERCANDIDATEENTRY_INSTANCE_LEN];
    oid best_inst[CLUSTERCANDIDATEENTRY_INSTANCE_LEN];
    CLUSTER_TYPE_CandidateEntry_T  entry;
    switch(vp->magic)
    {
    default:
        *write_method = 0;
        break;
    }

    /*check compc, retrive compl*/
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,compl, CLUSTERCANDIDATEENTRY_INSTANCE_LEN);

    memset(&entry, 0, sizeof(entry));

    if (exact)/*get,set*/
    {
        if(clusterCandidateTable_OidIndexToData(exact,compc,compl, entry.mac)==FALSE)
        {
            return NULL;
        }

        /*get data
         */
        if (CLUSTER_POM_GetNCandidates(&entry,1)!=1)
        {
            return NULL;
        }
    }
    else/*getnext*/
    {

        clusterCandidateTable_OidIndexToData(exact,compc,compl, entry.mac);
        /* check the length of inputing index,if <1 we should try get {0.0.0.0.0...}
         */
        if (compc< 1)
        {

            if ( CLUSTER_POM_GetNCandidates(&entry,1)!=1)
            {
                /*get next data*/
                if ( CLUSTER_POM_GetNextCandidate(&entry)!=TRUE)
                {
                    return NULL;
                }
            }
        }
        else
        {

            /*get next data*/
            if ( CLUSTER_POM_GetNextCandidate(&entry)!=TRUE)
            {
                return NULL;
            }
        }
    }

    memcpy(name, vp->name, vp->namelen*sizeof(oid));
    /* assign data to the oid index
     */


    for( i=0;i< SIZE_clusterCandidateMacAddr ;i++)
    {
        best_inst[0+i]=entry.mac[i];
    }
    memcpy(name+vp->namelen,best_inst,CLUSTERCANDIDATEENTRY_INSTANCE_LEN*sizeof(oid));
    *length = vp->namelen+CLUSTERCANDIDATEENTRY_INSTANCE_LEN ;

    /* this is where we do the value assignments for the mib results.
     */
    switch(vp->magic) {

#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    case LEAF_clusterCandidateMacAddr:
        *var_len = SIZE_clusterCandidateMacAddr;
        memcpy(return_buf, entry.mac,*var_len); or memcpy(return_buf, &entry.mac,*var_len);
        return (u_char*)return_buf;
#endif
    case LEAF_clusterCandidateDesc:
        *var_len  =  strlen((char *)(entry.description)) ;
        memcpy(return_buf, entry.description,*var_len);
        return (u_char*)return_buf;
    case LEAF_clusterCandidateRole:
        switch(entry.role)
        {
            case CLUSTER_TYPE_COMMANDER:
            case CLUSTER_TYPE_CANDIDATE:
            case CLUSTER_TYPE_MEMBER_TOBE:
            case CLUSTER_TYPE_DISABLE:
            default:
                long_return=VAL_clusterCandidateRole_candidate;
                break;
            case CLUSTER_TYPE_ACTIVE_MEMBER:
                long_return=VAL_clusterCandidateRole_activeMember;
                break;
            case CLUSTER_TYPE_INACTIVE_MEMBER:
                long_return=VAL_clusterCandidateRole_inactiveMember;
                break;
        }
        *var_len = sizeof(long_return);
        return (u_char *) &long_return;
    default:
      ERROR_MSG("");
    }
    return NULL;
}

#define CLUSTERMEMBERENTRY_INSTANCE_LEN  1

BOOL_T clusterMemberTable_OidIndexToData(UI32_T exact, UI32_T compc,
            oid * compl ,  UI8_T *cluster_member_id)
{
    /* get or write
     */
    if(exact)
    {

        /* check the index length
         */

        if(compc != CLUSTERMEMBERENTRY_INSTANCE_LEN) /* the constant size index*/
        {
            return FALSE;
        }
    }
    *cluster_member_id=(UI8_T)compl[0];
    return TRUE;
}

/*
 * var_clusterMemberTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *
var_clusterMemberTable(struct variable *vp,
            oid     *name,
            size_t  *length,
            int     exact,
            size_t  *var_len,
            WriteMethod **write_method)
{
    /* variables we may use later */
    UI32_T compc=0;
    oid compl[CLUSTERMEMBERENTRY_INSTANCE_LEN];
    oid best_inst[CLUSTERMEMBERENTRY_INSTANCE_LEN];
    CLUSTER_TYPE_MemberEntry_T  entry;
    UI8_T cluster_member_id = 0;
    switch(vp->magic)
    {
    default:
        *write_method = 0;
        break;
    }

    /*check compc, retrive compl*/
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,compl, CLUSTERMEMBERENTRY_INSTANCE_LEN);

    memset(&entry, 0, sizeof(entry));

    if (exact)/*get,set*/
    {
        if(clusterMemberTable_OidIndexToData(exact,compc,compl, &cluster_member_id)==FALSE)
        {
            return NULL;
        }

        /*get data
         */
        if (CLUSTER_POM_GetNMembers( cluster_member_id, &entry,1)!=1)
        {
            return NULL;
        }
    }
    else/*getnext*/
    {

        clusterMemberTable_OidIndexToData(exact,compc,compl, &cluster_member_id);
        /* check the length of inputing index,if <1 we should try get {0.0.0.0.0...}
         */
        if (compc< 1)
        {

            if ( CLUSTER_POM_GetNMembers( cluster_member_id, &entry,1)!=1)
            {

                /*get next data*/
                if ( CLUSTER_POM_GetNextMember( &cluster_member_id, &entry)!=TRUE)
                {
                    return NULL;
                }
            }
        }
        else
        {

            /*get next data*/
            if ( CLUSTER_POM_GetNextMember( &cluster_member_id, &entry)!=TRUE)
            {
                return NULL;
            }
        }
    }

    memcpy(name, vp->name, vp->namelen*sizeof(oid));
    /* assign data to the oid index
     */


    best_inst[0]=(UI32_T)cluster_member_id;
    memcpy(name+vp->namelen,best_inst,CLUSTERMEMBERENTRY_INSTANCE_LEN*sizeof(oid));
    *length = vp->namelen+CLUSTERMEMBERENTRY_INSTANCE_LEN ;

    /* this is where we do the value assignments for the mib results.
     */
    switch(vp->magic) {

#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    case LEAF_clusterMemberId:
        *var_len = sizeof(long_return);
        long_return = (UI32_T)entry.id;
        return (u_char *) &long_return;
#endif
    case LEAF_clusterMemberMacAddr:
        *var_len = SIZE_clusterMemberMacAddr;
        memcpy(return_buf, entry.mac,*var_len);
        return (u_char*)return_buf;
    case LEAF_clusterMemberDesc:
        *var_len  =  strlen((char *)entry.description) ;
        memcpy(return_buf, entry.description,*var_len);
        return (u_char*)return_buf;
    case LEAF_clusterMemberActive:
        switch(entry.role)
        {
            case CLUSTER_TYPE_ACTIVE_MEMBER:
                long_return=VAL_clusterMemberActive_activeMember;
                break;
            case CLUSTER_TYPE_COMMANDER:
            case CLUSTER_TYPE_CANDIDATE:
            case CLUSTER_TYPE_MEMBER_TOBE:
            case CLUSTER_TYPE_INACTIVE_MEMBER:
            case CLUSTER_TYPE_DISABLE:
            default:
                long_return=VAL_clusterMemberActive_inactiveMember;
                break;
        }
        *var_len = sizeof(long_return);
        return (u_char *) &long_return;
    default:
      ERROR_MSG("");
    }
    return NULL;
}
#endif /*end of #if (SYS_CPNT_CLUSTER==TRUE)*/

#if (SYS_CPNT_IP_SOURCE_GUARD == TRUE)

#define IPSRCGUARDCONFIGENTRY_INSTANCE_LEN  1

BOOL_T ipSrcGuardConfigTable_OidIndexToData(UI32_T exact, UI32_T compc, oid *compl, UI32_T *ipSrcGuardPortIfIndex)
{
    /* get or write
     */
    if (exact)
    {
        /* check the index length
         */
        if (compc != IPSRCGUARDCONFIGENTRY_INSTANCE_LEN)    /* the constant size index*/
        {
            return FALSE;
        }
    }

    *ipSrcGuardPortIfIndex = compl[0];
    return TRUE;
}

/*
 * var_ipSrcGuardConfigTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *var_ipSrcGuardConfigTable(
    struct variable *vp,
    oid             *name,
    size_t          *length,
    int             exact,
    size_t          *var_len,
    WriteMethod     **write_method)
{
    /* variables we may use later */
    UI32_T                  compc = 0;
    oid                     compl[IPSRCGUARDCONFIGENTRY_INSTANCE_LEN] = { 0 };
    oid                     best_inst[IPSRCGUARDCONFIGENTRY_INSTANCE_LEN] = { 0 };
    UI32_T                  lport_ifindex = 0;
    UI32_T                  unit = 0;
    UI32_T                  port = 0;
    UI32_T                  trunk_id = 0;

    IPSG_TYPE_PortInfo_T entry;
    switch (vp->magic)
    {
        case LEAF_ipSrcGuardMode:
            *write_method = write_ipSrcGuardMode;
            break;
        case LEAF_ipSrcGuardTableMode:
            *write_method = write_ipSrcGuardTableMode;
            break;

        case LEAF_ipSrcGuardAclMaxBinding:
            *write_method = write_ipSrcGuardAclMaxBinding;
            break;

        case LEAF_ipSrcGuardMacMaxBinding:
            *write_method = write_ipSrcGuardMacMaxBinding;
            break;
        default:
            *write_method = 0;
            break;
    }

    /*check compc, retrive compl*/
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl, IPSRCGUARDCONFIGENTRY_INSTANCE_LEN);

    memset(&entry, 0, sizeof(entry));

    if (exact)  /*get,set*/
    {
        if (ipSrcGuardConfigTable_OidIndexToData(exact, compc, compl, &lport_ifindex) == FALSE)
        {
            return NULL;
        }
        /*get data
         */
        if (IPSG_POM_GetPortInfo(lport_ifindex, &entry) != IPSG_TYPE_OK)
        {
            return NULL;
        }
    }
    else        /*getnext*/
    {
        ipSrcGuardConfigTable_OidIndexToData(exact, compc, compl, &lport_ifindex);

        /* check the length of inputing index,if <1 we should try get {0.0.0.0.0...}
         */
        if (compc < 1)
        {
            if (IPSG_POM_GetPortInfo(lport_ifindex, &entry)!=IPSG_TYPE_OK)
            {
                /*get next data*/
                if (IPSG_PMGR_GetNextPortInfo(&lport_ifindex, &entry) != IPSG_TYPE_OK)
                {
                    return NULL;
                }
            }
        }
        else
        {
            /*get next data*/
            if (IPSG_PMGR_GetNextPortInfo(&lport_ifindex, &entry) != IPSG_TYPE_OK)
            {
                return NULL;
            }
        }
    }

    /* we don't support trunk port ip source guard
     */
    if(SWCTRL_LPORT_NORMAL_PORT != SWCTRL_PMGR_LogicalPortToUserPort(lport_ifindex, &unit, &port, &trunk_id))
    {
       return NULL;
    }

    memcpy(name, vp->name, vp->namelen * sizeof(oid));

    /* assign data to the oid index
     */
    best_inst[0] = lport_ifindex;
    memcpy(name + vp->namelen, best_inst, IPSRCGUARDCONFIGENTRY_INSTANCE_LEN * sizeof(oid));
    *length = vp->namelen + IPSRCGUARDCONFIGENTRY_INSTANCE_LEN;

    /* this is where we do the value assignments for the mib results.
     */
    switch (vp->magic)
    {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    case LEAF_ipSrcGuardPortIfIndex:
        *var_len = sizeof(long_return);
        long_return = lport_ifindex;
        return (u_char *) &long_return;
#endif

    case LEAF_ipSrcGuardMode:
        *var_len = sizeof(long_return);
        long_return = entry.filter_mode;
        return (u_char *) &long_return;
    case LEAF_ipSrcGuardTableMode:
        *var_len = sizeof(long_return);
        long_return = entry.table_mode;
        return (u_char *) &long_return;

    case LEAF_ipSrcGuardAclMaxBinding:
        *var_len = sizeof(long_return);
        long_return = entry.acl_limit;
        return (u_char *) &long_return;

    case LEAF_ipSrcGuardMacMaxBinding:
        *var_len = sizeof(long_return);
        long_return = entry.mac_limit;
        return (u_char *) &long_return;
    default:
        ERROR_MSG("");
    }

    return NULL;
}

int write_ipSrcGuardMode(
    int     action,
    u_char  *var_val,
    u_char  var_val_type,
    size_t  var_val_len,
    u_char  *statP,
    oid     *name,
    size_t  name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            switch (*(long *) var_val)
            {
                case VAL_ipSrcGuardMode_diabled:
                case VAL_ipSrcGuardMode_srcIp:
                case VAL_ipSrcGuardMode_srcIpMac:
                    break;
                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
            {
                UI32_T  oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
                I32_T   value = 0;
                UI32_T  ipSrcGuardPortIfIndex = 0;

                if (ipSrcGuardConfigTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &ipSrcGuardPortIfIndex) == FALSE)
                    return SNMP_ERR_COMMITFAILED;

                value = *(long *)var_val;
                if(IPSG_TYPE_OK != IPSG_PMGR_SetPortFilterMode(ipSrcGuardPortIfIndex, value))
                    return SNMP_ERR_COMMITFAILED;
            }
            break;

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

int write_ipSrcGuardTableMode(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    /* dispatch action
     */
    switch (action)
    {
        case RESERVE1:
            /* check type and length
             */
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            /* check valid values
             */
            switch (*(long *) var_val)
            {
                case VAL_ipSrcGuardTableMode_acl:
                    break;

                case VAL_ipSrcGuardTableMode_mac:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            I32_T value = 0;

            /* table-specific variables
             */
            UI32_T ipSrcGuardPortIfIndex = 0;

            /* extract index
             */
            if (! ipSrcGuardConfigTable_OidIndexToData(TRUE,
                name_len - oid_name_length,
                &(name[oid_name_length]),
                &ipSrcGuardPortIfIndex))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            /* get user value
             */
            value = *(long *)var_val;

            /* set to core layer
             */
            if(IPSG_TYPE_OK != IPSG_PMGR_SetPortTableMode(ipSrcGuardPortIfIndex, value))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    /* return success
     */
    return SNMP_ERR_NOERROR;
}

int write_ipSrcGuardAclMaxBinding(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    /* dispatch action
     */
    switch (action)
    {
        case RESERVE1:
            /* check type and length
             */
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            /* check valid values
             */
            if ((*(long *) var_val < MIN_ipSrcGuardAclMaxBinding)
                || (*(long *) var_val > MAX_ipSrcGuardAclMaxBinding))
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            I32_T value = 0;

            /* table-specific variables
             */
            UI32_T ipSrcGuardPortIfIndex = 0;

            /* extract index
             */
            if (! ipSrcGuardConfigTable_OidIndexToData(TRUE,
                name_len - oid_name_length,
                &(name[oid_name_length]),
                &ipSrcGuardPortIfIndex))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            /* get user value
             */
            value = *(long *)var_val;

            /* set to core layer
             */
            if(IPSG_TYPE_OK !=
                IPSG_PMGR_SetPortEntryLimit(ipSrcGuardPortIfIndex, IPSG_TYPE_TABLE_MODE_ACL, value))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    /* return success
     */
    return SNMP_ERR_NOERROR;
}

int write_ipSrcGuardMacMaxBinding(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    /* dispatch action
     */
    switch (action)
    {
        case RESERVE1:
            /* check type and length
             */
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            /* check valid values
             */
            if ((*(long *) var_val < MIN_ipSrcGuardMacMaxBinding)
                || (*(long *) var_val > MAX_ipSrcGuardMacMaxBinding))
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            I32_T value = 0;

            /* table-specific variables
             */
            UI32_T ipSrcGuardPortIfIndex = 0;

            /* extract index
             */
            if (! ipSrcGuardConfigTable_OidIndexToData(TRUE,
                name_len - oid_name_length,
                &(name[oid_name_length]),
                &ipSrcGuardPortIfIndex))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            /* get user value
             */
            value = *(long *)var_val;

            /* set to core layer
             */
            if(IPSG_TYPE_OK !=
                IPSG_PMGR_SetPortEntryLimit(ipSrcGuardPortIfIndex, IPSG_TYPE_TABLE_MODE_MAC, value))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    /* return success
     */
    return SNMP_ERR_NOERROR;
}
/* Deprecated */
#if 0
#define IPSRCGUARDADDRENTRY_INSTANCE_LEN    7

BOOL_T ipSrcGuardAddrTable_OidIndexToData(
    UI32_T  exact,
    UI32_T  compc,
    oid     *compl,
    UI32_T  *ipSrcGuardBindingsVlanIndex,
    UI8_T   *ipSrcGuardBindingsMacAddress)
{
    int i;

    /* get or write
     */
    if (exact)
    {
        /* check the index length
         */
        if (compc != IPSRCGUARDADDRENTRY_INSTANCE_LEN)  /* the constant size index*/
        {
            return FALSE;
        }
    }

    *ipSrcGuardBindingsVlanIndex = compl[0];
    for (i = 0; i < SIZE_ipSrcGuardBindingsMacAddress; i++)
    {
        ipSrcGuardBindingsMacAddress[i] = compl[1 + i];
    }

    return TRUE;
}

/*
 * var_ipSrcGuardAddrTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *var_ipSrcGuardAddrTable(
    struct variable *vp,
    oid             *name,
    size_t          *length,
    int             exact,
    size_t          *var_len,
    WriteMethod     **write_method)
{
    int i;

    /* variables we may use later */
    UI32_T                      compc = 0;
    oid                         compl[IPSRCGUARDADDRENTRY_INSTANCE_LEN] = { 0 };
    oid                         best_inst[IPSRCGUARDADDRENTRY_INSTANCE_LEN] = { 0 };
    DHCPSNP_TYPE_BindingEntry_T entry;
    switch (vp->magic)
    {
        case LEAF_ipSrcGuardBindingsAddrType:
            *write_method = write_ipSrcGuardBindingsAddrType;
            break;
        case LEAF_ipSrcGuardBindingsIpAddress:
            *write_method = write_ipSrcGuardBindingsIpAddress;
            break;
        case LEAF_ipSrcGuardBindingsPortIfIndex:
            *write_method = write_ipSrcGuardBindingsPortIfIndex;
            break;
        case LEAF_ipSrcGuardBindingsStatus:
            *write_method = write_ipSrcGuardBindingsStatus;
            break;
        default:
            *write_method = 0;
            break;
    }

    /*check compc, retrive compl*/
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl, IPSRCGUARDADDRENTRY_INSTANCE_LEN);

    memset(&entry, 0, sizeof(entry));

    if (exact)  /*get,set*/
    {
        if (ipSrcGuardAddrTable_OidIndexToData(exact, compc, compl, &entry.vid, entry.mac_p) == FALSE)
        {
            return NULL;
        }

        /*get data
         */
        if (DHCPSNP_PMGR_GetIpSrcGuardBindingEntry(&entry) != DHCPSNP_TYPE_OK)
        {
            return NULL;
        }
    }
    else        /*getnext*/
    {
        ipSrcGuardAddrTable_OidIndexToData(exact, compc, compl, &entry.vid, entry.mac_p);

        /* check the length of inputing index,if <1 we should try get {0.0.0.0.0...}
         */
        if (compc < 1)
        {
            if (DHCPSNP_PMGR_GetIpSrcGuardBindingEntry(&entry) != DHCPSNP_TYPE_OK)
            {
                /*get next data*/
                if (DHCPSNP_PMGR_GetNextIpSrcGuardBindingEntry(&entry) != DHCPSNP_TYPE_OK)
                {
                    return NULL;
                }
            }
        }
        else
        {
            /*get next data*/
            if (DHCPSNP_PMGR_GetNextIpSrcGuardBindingEntry(&entry) != DHCPSNP_TYPE_OK)
            {
                return NULL;
            }
        }
    }

    memcpy(name, vp->name, vp->namelen * sizeof(oid));

    /* assign data to the oid index
     */
    best_inst[0] = entry.vid;
    for (i = 0; i < SIZE_ipSrcGuardBindingsMacAddress; i++)
    {
        best_inst[1 + i] = entry.mac_p[i];
    }

    memcpy(name + vp->namelen, best_inst, IPSRCGUARDADDRENTRY_INSTANCE_LEN * sizeof(oid));
    *length = vp->namelen + IPSRCGUARDADDRENTRY_INSTANCE_LEN;

    /* this is where we do the value assignments for the mib results.
     */
    switch (vp->magic)
    {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    case LEAF_ipSrcGuardBindingsVlanIndex:
        *var_len = sizeof(long_return);
        long_return = entry.vid;
        return (u_char *) &long_return;

    case LEAF_ipSrcGuardBindingsMacAddress:
        *var_len = SIZE_ipSrcGuardBindingsMacAddress;
        memcpy(return_buf, entry.mac_p, *var_len);
        return (u_char *) return_buf;
#endif

    case LEAF_ipSrcGuardBindingsAddrType:
        *var_len = sizeof(long_return);
        long_return = entry.ip_addr_type;
        return (u_char *) &long_return;

    case LEAF_ipSrcGuardBindingsEntryType:
        *var_len = sizeof(long_return);
        long_return = entry.type;
        return (u_char *) &long_return;

    case LEAF_ipSrcGuardBindingsIpAddress:
        *var_len = sizeof(ipaddr_return);
        ipaddr_return = entry.ip_addr;
        return (u_char *) &ipaddr_return;

    case LEAF_ipSrcGuardBindingsPortIfIndex:
        *var_len = sizeof(long_return);
        long_return = entry.lport_ifindex;
        return (u_char *) &long_return;

    case LEAF_ipSrcGuardBindingsLeaseTime:
        *var_len = sizeof(long_return);
        long_return = entry.lease_time;
        return (u_char *) &long_return;

    case LEAF_ipSrcGuardBindingsStatus:
        *var_len = sizeof(long_return);
        long_return = entry.row_status;
        return (u_char *) &long_return;

    default:
        ERROR_MSG("");
    }

    return NULL;
}

int write_ipSrcGuardBindingsAddrType(
    int     action,
    u_char  *var_val,
    u_char  var_val_type,
    size_t  var_val_len,
    u_char  *statP,
    oid     *name,
    size_t  name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            switch (*(long *) var_val)
            {
                case VAL_ipSrcGuardBindingsAddrType_unknown:
                case VAL_ipSrcGuardBindingsAddrType_ipv4:
                case VAL_ipSrcGuardBindingsAddrType_ipv6:
                case VAL_ipSrcGuardBindingsAddrType_ipv4z:
                case VAL_ipSrcGuardBindingsAddrType_ipv6z:
                case VAL_ipSrcGuardBindingsAddrType_dns:
                    break;
                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
            {
                UI32_T  oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
                I32_T   value = 0;
                UI32_T  ipSrcGuardBindingsVlanIndex = 0;
                UI8_T   ipSrcGuardBindingsMacAddress[SIZE_ipSrcGuardBindingsMacAddress] = { 0 };

                if (ipSrcGuardAddrTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &ipSrcGuardBindingsVlanIndex, ipSrcGuardBindingsMacAddress) == FALSE)
                    return SNMP_ERR_COMMITFAILED;

                value = *(long *)var_val;
                if (DHCPSNP_PMGR_SetBindingsAddrType(ipSrcGuardBindingsVlanIndex, ipSrcGuardBindingsMacAddress, value) != DHCPSNP_TYPE_OK)
                    return SNMP_ERR_COMMITFAILED;
            }
            break;

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

int write_ipSrcGuardBindingsIpAddress(
    int     action,
    u_char  *var_val,
    u_char  var_val_type,
    size_t  var_val_len,
    u_char  *statP,
    oid     *name,
    size_t  name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_IPADDRESS)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len !=  SYS_ADPT_IPV4_ADDR_LEN)
            {
                return SNMP_ERR_WRONGLENGTH;
            }

            break;

        case RESERVE2:
            break;

        case FREE:
            break;

        case ACTION:
            {
                UI32_T  oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
                UI32_T  value = 0;
                UI32_T  ipSrcGuardBindingsVlanIndex = 0;
                UI8_T   ipSrcGuardBindingsMacAddress[SIZE_ipSrcGuardBindingsMacAddress] = { 0 };

                if (ipSrcGuardAddrTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &ipSrcGuardBindingsVlanIndex, ipSrcGuardBindingsMacAddress) == FALSE)
                    return SNMP_ERR_COMMITFAILED;
                memcpy(&value, var_val, var_val_len);
                if (DHCPSNP_PMGR_SetBindingsIpAddress(ipSrcGuardBindingsVlanIndex, ipSrcGuardBindingsMacAddress, value) != DHCPSNP_TYPE_OK)
                    return SNMP_ERR_COMMITFAILED;
            }
            break;

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

int write_ipSrcGuardBindingsPortIfIndex(
    int     action,
    u_char  *var_val,
    u_char  var_val_type,
    size_t  var_val_len,
    u_char  *statP,
    oid     *name,
    size_t  name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            if (*(long *) var_val < MIN_ipSrcGuardBindingsPortIfIndex ||
                *(long *) var_val > MAX_ipSrcGuardBindingsPortIfIndex)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
            {
                UI32_T  oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
                I32_T   value = 0;
                UI32_T  ipSrcGuardBindingsVlanIndex = 0;
                UI8_T   ipSrcGuardBindingsMacAddress[SIZE_ipSrcGuardBindingsMacAddress] = { 0 };

                if (ipSrcGuardAddrTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &ipSrcGuardBindingsVlanIndex, ipSrcGuardBindingsMacAddress) == FALSE)
                    return SNMP_ERR_COMMITFAILED;
                value = *(long *)var_val;
                if (DHCPSNP_PMGR_SetBindingsPortIfIndex(ipSrcGuardBindingsVlanIndex, ipSrcGuardBindingsMacAddress, value) != DHCPSNP_TYPE_OK)
                    return SNMP_ERR_COMMITFAILED;
            }
            break;

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

int write_ipSrcGuardBindingsStatus(
    int     action,
    u_char  *var_val,
    u_char  var_val_type,
    size_t  var_val_len,
    u_char  *statP,
    oid     *name,
    size_t  name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            switch (*(long *) var_val)
            {
                case VAL_ipSrcGuardBindingsStatus_active:
                case VAL_ipSrcGuardBindingsStatus_notInService:
                case VAL_ipSrcGuardBindingsStatus_notReady:
                case VAL_ipSrcGuardBindingsStatus_createAndGo:
                case VAL_ipSrcGuardBindingsStatus_createAndWait:
                case VAL_ipSrcGuardBindingsStatus_destroy:
                    break;
                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
            {
                UI32_T  oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
                I32_T   value = 0;
                UI32_T  ipSrcGuardBindingsVlanIndex = 0;
                UI8_T   ipSrcGuardBindingsMacAddress[SIZE_ipSrcGuardBindingsMacAddress] = { 0 };

                if (ipSrcGuardAddrTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &ipSrcGuardBindingsVlanIndex, ipSrcGuardBindingsMacAddress) == FALSE)
                    return SNMP_ERR_COMMITFAILED;
                value = *(long *)var_val;
                if (DHCPSNP_PMGR_SetBindingsRowStatus(ipSrcGuardBindingsVlanIndex, ipSrcGuardBindingsMacAddress, value) != DHCPSNP_TYPE_OK)
                    return SNMP_ERR_COMMITFAILED;
            }
            break;

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}
#endif

#if (SYS_CPNT_IPSG_BINDING_FILTER_SOURCE == TRUE)
/* ipSrcGuardBindingFilterSource*/
int
do_ipSrcGuardBindingFilterSource(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{

    switch(reqinfo->mode) {
        case MODE_GET:
        {
            UI32_T status = 0;

            if (IPSG_POM_GetBindingFilterSource(&status) == IPSG_TYPE_OK)
            {
                long_return = status;
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER , (u_char *)&long_return , sizeof(long_return) );
            }
            else
            {
                return SNMP_ERR_GENERR;
            }
        }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:

            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
            }

            break;
        case MODE_SET_RESERVE2:

            switch ( *requests->requestvb->val.integer )
            {
                case IPSG_TYPE_IPSG_BINDING_FILTER_SOURCE_ALL:
                    break;
                case IPSG_TYPE_IPSG_BINDING_FILTER_SOURCE_STATIC:
                    break;
                default:
                    netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
        {
            if (IPSG_PMGR_SetBindingFilterSource((UI32_T)(*requests->requestvb->val.integer)) != IPSG_TYPE_OK)
            {
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
            }
        }
            break;

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
#endif /* #if (SYS_CPNT_IPSG_BINDING_FILTER_SOURCE == TRUE) */

#define IPSRCGUARDACLENTRY_INSTANCE_LEN  11

BOOL_T ipSrcGuardAclTable_OidIndexToData(UI32_T exact, UI32_T compc,
    oid *compl, UI8_T *ipSrcGuardAclBindingIpAddress, UI8_T *ipSrcGuardAclBindingMacAddress, UI32_T *ipSrcGuardAclBindingEntryType)
{
    UI32_T i=0;
    /* get or set
     */
    if (exact)
    {
        /* check the index length
         */
        if (compc != IPSRCGUARDACLENTRY_INSTANCE_LEN) /* the constant size index */
        {
            return FALSE;
        }
    }

    for (i=0; i < SYS_ADPT_IPV4_ADDR_LEN; i++)
    {
        ipSrcGuardAclBindingIpAddress[i] = compl[0 + i];
    }

    for (i=0; i < SIZE_ipSrcGuardAclBindingMacAddress; i++)
    {
        ipSrcGuardAclBindingMacAddress[i] = compl[4 + i];
    }

    *ipSrcGuardAclBindingEntryType = compl[10];

    return TRUE;
}

/*
 * var_ipSrcGuardAclTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *var_ipSrcGuardAclTable(struct variable *vp,
    oid *name,
    size_t *length,
    int exact,
    size_t *var_len,
    WriteMethod **write_method)
{
    UI32_T compc = 0;
    UI32_T i=0;
    oid compl[IPSRCGUARDACLENTRY_INSTANCE_LEN] = {0};
    oid best_inst[IPSRCGUARDACLENTRY_INSTANCE_LEN] = {0};
    UI32_T type=0;
    IPSG_TYPE_BindingEntry_T entry;

    switch (vp->magic)
    {
        case LEAF_ipSrcGuardAclBindingVlanIndex:
            *write_method = write_ipSrcGuardAclBindingVlanIndex;
            break;

        case LEAF_ipSrcGuardAclBindingPortIfIndex:
            *write_method = write_ipSrcGuardAclBindingPortIfIndex;
            break;

        case LEAF_ipSrcGuardAclBindingStatus:
            *write_method = write_ipSrcGuardAclBindingStatus;
            break;

        default:
            *write_method = 0;
            break;
    }

    /* check compc, retrive compl
     */
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl, IPSRCGUARDACLENTRY_INSTANCE_LEN);

    memset(&entry, 0, sizeof(entry));

    if (exact) /* get or set */
    {
        if (ipSrcGuardAclTable_OidIndexToData(exact, compc, compl, entry.ip_addr, entry.mac_addr, &type) == FALSE)
        {
            return NULL;
        }

        entry.type = (UI8_T) type;

        if (IPSG_POM_GetAclBinding(&entry) != IPSG_TYPE_OK)
        {
            return NULL;
        }
    }
    else /* getnext */
    {
        ipSrcGuardAclTable_OidIndexToData(exact, compc, compl, entry.ip_addr, entry.mac_addr, &type);

        entry.type = (UI8_T) type;

        /* check the length of inputing index,if < 1 we should try get
         * {0.0.0.0.0...}
         */
        if (compc < 1)
        {
            if (IPSG_POM_GetAclBinding(&entry) != IPSG_TYPE_OK)
            {
                if (IPSG_POM_GetNextAclBinding(IPSG_OM_ACL_KEY_BY_IP_MAC_TYPE_INDEX,&entry) != IPSG_TYPE_OK)
                {
                    return NULL;
                }
            }
        }
        else
        {
            if (IPSG_POM_GetNextAclBinding(IPSG_OM_ACL_KEY_BY_IP_MAC_TYPE_INDEX,&entry) != IPSG_TYPE_OK)
            {
                return NULL;
            }
        }
    }

    memcpy(name, vp->name, vp->namelen * sizeof(oid));

    /* assign data to the oid index
     */
    for (i = 0; i< SYS_ADPT_IPV4_ADDR_LEN; i ++)
    {
        best_inst[0 + i] = entry.ip_addr[i];
    }

    for (i = 0; i < SIZE_ipSrcGuardAclBindingMacAddress; i++)
    {
        best_inst[4 + i] = entry.mac_addr[i];
    }

    best_inst[10] = entry.type;

    memcpy(name + vp->namelen, best_inst, IPSRCGUARDACLENTRY_INSTANCE_LEN * sizeof(oid));
    *length = vp->namelen + IPSRCGUARDACLENTRY_INSTANCE_LEN;

    switch (vp->magic)
    {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case LEAF_ipSrcGuardAclBindingIpAddress:
            *var_len = sizeof(ipaddr_return);
            memcpy(&ipaddr_return, entry.ip_addr, *var_len);
            return (u_char *) &ipaddr_return;
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case LEAF_ipSrcGuardAclBindingMacAddress:
            *var_len = SIZE_ipSrcGuardAclBindingMacAddress;
            memcpy(return_buf, entry.mac_addr, *var_len);
            return (u_char *) return_buf;
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case LEAF_ipSrcGuardAclBindingEntryType:
            *var_len = sizeof(long_return);
            long_return = (UI32_T)entry.type;
            return (u_char *) &long_return;
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

        case LEAF_ipSrcGuardAclBindingVlanIndex:
            *var_len = sizeof(long_return);
            long_return = entry.vid_ifindex;
            return (u_char *) &long_return;

        case LEAF_ipSrcGuardAclBindingPortIfIndex:
            *var_len = sizeof(long_return);
            long_return = entry.lport;
            return (u_char *) &long_return;

        case LEAF_ipSrcGuardAclBindingStatus:
            *var_len = sizeof(long_return);
            long_return = entry.row_status;
            return (u_char *) &long_return;

        default:
            ERROR_MSG("");
    }

    return NULL;
}

int write_ipSrcGuardAclBindingVlanIndex(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_UNSIGNED)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            UI32_T value = 0;
            UI8_T ip_addr[SYS_ADPT_IPV4_ADDR_LEN]={0};
            UI8_T mac_addr[SYS_ADPT_MAC_ADDR_LEN]={0};
            UI32_T type = 0;

            if (ipSrcGuardAclTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), ip_addr, mac_addr, &type) == FALSE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            value = *(u_long *)var_val;

            if (IPSG_PMGR_SetAclBindingVlanIndex(ip_addr, mac_addr, (UI8_T)type, value) != IPSG_TYPE_OK)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

int write_ipSrcGuardAclBindingPortIfIndex(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            if (MIN_ipSrcGuardAclBindingPortIfIndex > *(long *)var_val || *(long *)var_val > MAX_ipSrcGuardAclBindingPortIfIndex)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            I32_T value = 0;
            UI8_T ip_addr[SYS_ADPT_IPV4_ADDR_LEN]={0};
            UI8_T mac_addr[SYS_ADPT_MAC_ADDR_LEN]={0};
            UI32_T type = 0;

            if (ipSrcGuardAclTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), ip_addr, mac_addr, &type) == FALSE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            value = *(long *)var_val;

            if (IPSG_PMGR_SetAclBindingPortIfIndex(ip_addr, mac_addr, (UI8_T)type, value) != IPSG_TYPE_OK)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

int write_ipSrcGuardAclBindingStatus(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            switch (*(long *)var_val)
            {
                case VAL_ipSrcGuardAclBindingStatus_active:
                    break;

                case VAL_ipSrcGuardAclBindingStatus_notInService:
                    break;

                case VAL_ipSrcGuardAclBindingStatus_notReady:
                    break;

                case VAL_ipSrcGuardAclBindingStatus_createAndGo:
                    break;

                case VAL_ipSrcGuardAclBindingStatus_createAndWait:
                    break;

                case VAL_ipSrcGuardAclBindingStatus_destroy:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            I32_T value = 0;
            UI8_T ip_addr[SYS_ADPT_IPV4_ADDR_LEN]={0};
            UI8_T mac_addr[SYS_ADPT_MAC_ADDR_LEN]={0};
            UI32_T type = 0;

            if (ipSrcGuardAclTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), ip_addr, mac_addr, &type) == FALSE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            value = *(long *)var_val;

            if (IPSG_PMGR_SetAclBindingRowStatus(ip_addr, mac_addr, (UI8_T)type, value) != IPSG_TYPE_OK)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

#if (SYS_CPNT_IPSG_MAC_MODE == TRUE)
#define IPSRCGUARDMACENTRY_INSTANCE_LEN  10

BOOL_T ipSrcGuardMacTable_OidIndexToData(UI32_T exact, UI32_T compc,
    oid *compl, UI8_T *ipSrcGuardMacBindingMacAddress, UI8_T *ipSrcGuardMacBindingIpAddress)
{
    UI32_T i=0;

    /* get or set
     */
    if (exact)
    {
        /* check the index length
         */
        if (compc != IPSRCGUARDMACENTRY_INSTANCE_LEN)  /* the constant size index */
        {
            return FALSE;
        }
    }


    for (i=0; i < SIZE_ipSrcGuardMacBindingMacAddress; i++)
    {
        ipSrcGuardMacBindingMacAddress[i] = compl[0 + i];
    }

    ipSrcGuardMacBindingIpAddress[0] = compl[6];
    ipSrcGuardMacBindingIpAddress[1] = compl[7];
    ipSrcGuardMacBindingIpAddress[2] = compl[8];
    ipSrcGuardMacBindingIpAddress[3] = compl[9];

    return TRUE;
}

/*
 * var_ipSrcGuardMacTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *var_ipSrcGuardMacTable(struct variable *vp,
    oid *name,
    size_t *length,
    int exact,
    size_t *var_len,
    WriteMethod **write_method)
{
    UI32_T compc = 0;
    UI32_T i=0;
    oid compl[IPSRCGUARDMACENTRY_INSTANCE_LEN] = {0};
    oid best_inst[IPSRCGUARDMACENTRY_INSTANCE_LEN] = {0};

    /* table-specific variables
     */
    IPSG_TYPE_Ip_Mac_BindingEntry_T entry;

    /* dispatch node to set write method
     */
    switch (vp->magic)
    {
        case LEAF_ipSrcGuardMacBindingStartVlan:
            *write_method = write_ipSrcGuardMacBindingStartVlan;
            break;

        case LEAF_ipSrcGuardMacBindingEndVlan:
            *write_method = write_ipSrcGuardMacBindingEndVlan;
            break;

        case LEAF_ipSrcGuardMacBindingPortList:
            *write_method = write_ipSrcGuardMacBindingPortList;
            break;

        case LEAF_ipSrcGuardMacBindingStatus:
            *write_method = write_ipSrcGuardMacBindingStatus;
            break;

        default:
            *write_method = 0;
            break;
    }

    /* check compc, retrive compl
     */
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl, IPSRCGUARDMACENTRY_INSTANCE_LEN);

    memset(&entry, 0, sizeof(entry));

    /* dispatch get-exact versus get-next
     */
    if (exact)  /* get or set */
    {
        /* extract index
         */
        if (! ipSrcGuardMacTable_OidIndexToData(exact, compc, compl, entry.mac, entry.ip_addr))
        {
            return NULL;
        }

        /* get-exact from core layer
         */
        if (IPSG_TYPE_OK != IPSG_POM_GetMacBinding(&entry))
        {
            return NULL;
        }
    }
    else  /* get-next */
    {
        /* extract index
         */
        ipSrcGuardMacTable_OidIndexToData(exact, compc, compl, entry.mac, entry.ip_addr);

        /* Check the length of inputing index.  If compc is less than the
         * instance length, we should try get {A.B.C.0.0...}, where A.B.C was
         * obtained from the "..._OidIndexToData" function call, and
         * 0.0... was initialized in the beginning of this function.
         * This instance may exist in the core layer.
         */
        if (compc < IPSRCGUARDMACENTRY_INSTANCE_LEN)  /* incomplete index */
        {
            /* get-exact, in case this instance exists
             */
            if (IPSG_TYPE_OK != IPSG_POM_GetMacBinding(&entry))
            {
                /* get-next according to lexicographic order; if none, fail
                 */
                if (IPSG_TYPE_OK !=
                    IPSG_POM_GetNextMacBinding(
                        IPSG_OM_MAC_KEY_BY_MAC_IP_INDEX,
                        &entry))
                {
                    return NULL;
                }
            }
        }
        else   /* complete index */
        {
            /* get-next according to lexicographic order; if none, fail
             */
            if (IPSG_TYPE_OK !=
                IPSG_POM_GetNextMacBinding(
                    IPSG_OM_MAC_KEY_BY_MAC_IP_INDEX,
                    &entry))
            {
                return NULL;
            }
        }
    }

    /* copy base OID (without index) to output
     */
    memcpy(name, vp->name, vp->namelen * sizeof(oid));

    /* assign data to the OID index
     */

    for (i = 0; i < SIZE_ipSrcGuardMacBindingMacAddress; i++)
    {
        best_inst[0 + i] = entry.mac[i];
    }

    best_inst[6] = entry.ip_addr[0];
    best_inst[7] = entry.ip_addr[1];
    best_inst[8] = entry.ip_addr[2];
    best_inst[9] = entry.ip_addr[3];
    memcpy(name + vp->namelen, best_inst, IPSRCGUARDMACENTRY_INSTANCE_LEN * sizeof(oid));
    *length = vp->namelen + IPSRCGUARDMACENTRY_INSTANCE_LEN;

    /* dispatch node to read value
     */
    switch (vp->magic)
    {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case LEAF_ipSrcGuardMacBindingMacAddress:
            *var_len = SIZE_ipSrcGuardMacBindingMacAddress;
            memcpy(return_buf, entry.mac, *var_len);
            return (u_char *) return_buf;
#endif
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case LEAF_ipSrcGuardMacBindingIpAddress:
            *var_len = sizeof(long_return);
            memcpy(return_buf, entry.ip_addr, *var_len);
            return (u_char *) &long_return;
#endif
        case LEAF_ipSrcGuardMacBindingStartVlan:
            *var_len = sizeof(long_return);
            long_return = entry.vlan_range.start;
            return (u_char *) &long_return;

        case LEAF_ipSrcGuardMacBindingEndVlan:
            *var_len = sizeof(long_return);
            long_return = entry.vlan_range.end;
            return (u_char *) &long_return;

        case LEAF_ipSrcGuardMacBindingPortList:
        {
            char   output_str[128]={0};

            SNMP_MGR_BitmapToString(
                entry.port_bitmap,
                SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST,
                output_str,
                sizeof(output_str));

            *var_len = strlen(output_str);
            memcpy(return_buf, output_str, *var_len);
            return (u_char *) return_buf;
        }
        case LEAF_ipSrcGuardMacBindingStatus:
            *var_len = sizeof(long_return);
            long_return = entry.row_status;
            return (u_char *) &long_return;

        default:
            ERROR_MSG("");
            break;
    }

    /* return failure
     */
    return NULL;
}

int write_ipSrcGuardMacBindingStartVlan(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    /* dispatch action
     */
    switch (action)
    {
        case RESERVE1:
            /* check type and length
             */
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            /* check valid values
             */
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            I32_T value = 0;

            /* table-specific variables
             */
            UI8_T ipSrcGuardMacBindingMacAddress[SIZE_ipSrcGuardMacBindingMacAddress] = {0};
            UI8_T ipSrcGuardMacBindingIpAddress[SYS_ADPT_IPV4_ADDR_LEN] = {0};

            /* extract index
             */
            if (! ipSrcGuardMacTable_OidIndexToData(TRUE,
                name_len - oid_name_length,
                &(name[oid_name_length]),
                ipSrcGuardMacBindingMacAddress, ipSrcGuardMacBindingIpAddress))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            /* get user value
             */
            value = *(long *)var_val;

            /* set to core layer
             */
            if (IPSG_TYPE_OK !=
                IPSG_PMGR_SetMacBindingStartVid(
                    ipSrcGuardMacBindingMacAddress,
                    ipSrcGuardMacBindingIpAddress,
                    value))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    /* return success
     */
    return SNMP_ERR_NOERROR;
}

int write_ipSrcGuardMacBindingEndVlan(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    /* dispatch action
     */
    switch (action)
    {
        case RESERVE1:
            /* check type and length
             */
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            /* check valid values
             */
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            I32_T value = 0;

            /* table-specific variables
             */
            UI8_T ipSrcGuardMacBindingMacAddress[SIZE_ipSrcGuardMacBindingMacAddress] = {0};
            UI8_T ipSrcGuardMacBindingIpAddress[SYS_ADPT_IPV4_ADDR_LEN] = {0};

            /* extract index
             */
            if (! ipSrcGuardMacTable_OidIndexToData(TRUE,
                name_len - oid_name_length,
                &(name[oid_name_length]),
                ipSrcGuardMacBindingMacAddress, ipSrcGuardMacBindingIpAddress))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            /* get user value
             */
            value = *(long *)var_val;

            /* set to core layer
             */
            if (IPSG_TYPE_OK !=
                IPSG_PMGR_SetMacBindingEndVid(
                    ipSrcGuardMacBindingMacAddress,
                    ipSrcGuardMacBindingIpAddress,
                    value))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    /* return success
     */
    return SNMP_ERR_NOERROR;
}

int write_ipSrcGuardMacBindingPortList(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    /* dispatch action
     */
    switch (action)
    {
        case RESERVE1:
            /* check type and length
             */
            if (var_val_type != ASN_OCTET_STR)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if ((var_val_len < MINSIZE_ipSrcGuardMacBindingPortList)
                || (var_val_len > MAXSIZE_ipSrcGuardMacBindingPortList))
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;

        case RESERVE2:
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            UI8_T byte_buffer[MAXSIZE_ipSrcGuardMacBindingPortList + 1] = {0};
            UI8_T port_bitmap[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST]={0};

            /* table-specific variables
             */
            UI8_T ipSrcGuardMacBindingMacAddress[SIZE_ipSrcGuardMacBindingMacAddress] = {0};
            UI8_T ipSrcGuardMacBindingIpAddress[SYS_ADPT_IPV4_ADDR_LEN] = {0};

            /* extract index
             */
            if (! ipSrcGuardMacTable_OidIndexToData(TRUE,
                name_len - oid_name_length,
                &(name[oid_name_length]),
                ipSrcGuardMacBindingMacAddress, ipSrcGuardMacBindingIpAddress))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            /* get user value
             */
            memcpy(byte_buffer, var_val, var_val_len);

            byte_buffer[var_val_len] = '\0';
            if(!SNMP_MGR_StringToBitmap(
                                    (char *)byte_buffer,
                                    port_bitmap,
                                    SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            if(IPSG_TYPE_OK !=
                IPSG_PMGR_SetMacBindingPortBitmap(
                    ipSrcGuardMacBindingMacAddress,
                    ipSrcGuardMacBindingIpAddress,
                    port_bitmap))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    /* return success
     */
    return SNMP_ERR_NOERROR;
}

int write_ipSrcGuardMacBindingStatus(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    /* dispatch action
     */
    switch (action)
    {
        case RESERVE1:
            /* check type and length
             */
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            /* check valid values
             */
            switch (*(long *) var_val)
            {
                case VAL_ipSrcGuardMacBindingStatus_active:
                    break;

                case VAL_ipSrcGuardMacBindingStatus_notInService:
                    break;

                case VAL_ipSrcGuardMacBindingStatus_notReady:
                    break;

                case VAL_ipSrcGuardMacBindingStatus_createAndGo:
                    break;

                case VAL_ipSrcGuardMacBindingStatus_createAndWait:
                    break;

                case VAL_ipSrcGuardMacBindingStatus_destroy:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            I32_T value = 0;

            /* table-specific variables
             */
            UI8_T ipSrcGuardMacBindingMacAddress[SIZE_ipSrcGuardMacBindingMacAddress] = {0};
            UI8_T ipSrcGuardMacBindingIpAddress[SYS_ADPT_IPV4_ADDR_LEN] = {0};

            /* extract index
             */
            if (! ipSrcGuardMacTable_OidIndexToData(TRUE,
                name_len - oid_name_length,
                &(name[oid_name_length]),
                ipSrcGuardMacBindingMacAddress, ipSrcGuardMacBindingIpAddress))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            /* get user value
             */
            value = *(long *)var_val;

            /* set to core layer
             */
            if (IPSG_TYPE_OK !=
                IPSG_PMGR_SetMacBindingRowStatus(
                    ipSrcGuardMacBindingMacAddress,
                    ipSrcGuardMacBindingIpAddress,
                    value))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    /* return success
     */
    return SNMP_ERR_NOERROR;
}
#endif /* SYS_CPNT_IPSG_MAC_MODE */
#endif /* #if (SYS_CPNT_IP_SOURCE_GUARD == TRUE) */

#if (SYS_CPNT_MAC_VLAN == TRUE)
/********************************************
 *****************macVlanMgt*****************
 ********************************************
 */

#define MACVLANENTRY_INSTANCE_LEN  12

BOOL_T macVlanTable_OidIndexToData(UI32_T exact, UI32_T compc,
    oid *compl, UI8_T *macVlanMacMask, UI8_T *macVlanMacAddress)
{
    UI32_T i=0;

    /* get or set
     */
    if (exact)
    {
        /* check the index length
         */
        if (compc != MACVLANENTRY_INSTANCE_LEN) /* the constant size index */
        {
            return FALSE;
        }
    }

    for (i=0; i < SIZE_macVlanMacMask; i++)
    {
#if (SYS_CPNT_MAC_VLAN_WITH_MASK == TRUE)
        macVlanMacMask[i] = compl[0 + i];
#else
        macVlanMacMask[i] = 0xff;
#endif
    }

    for (i=0; i < SIZE_macVlanMacAddress; i++)
    {
#if (SYS_CPNT_MAC_VLAN_WITH_MASK == TRUE)
        macVlanMacAddress[i] = compl[6 + i];
#else
        macVlanMacAddress[i] = compl[0 + i];
#endif
    }

    return TRUE;
}

/*
 * var_macVlanTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *
var_macVlanTable(struct variable *vp,
            oid     *name,
            size_t  *length,
            int     exact,
            size_t  *var_len,
            WriteMethod **write_method)
{
    /* variables we may use later */
    UI32_T compc = 0;
    oid compl[MACVLANENTRY_INSTANCE_LEN] = {0};
    oid best_inst[MACVLANENTRY_INSTANCE_LEN] = {0};
    VLAN_TYPE_MacVlanEntry_T entry;
    int i;

    switch (vp->magic)
    {
        case LEAF_macVlanId:
            *write_method = write_macVlanId;
            break;

#if (SYS_CPNT_MAC_VLAN_WITH_PRIORITY == TRUE)
        case LEAF_macVlanPriority:
            *write_method = write_macVlanPriority;
            break;
#endif

        case LEAF_macVlanStatus:
            *write_method = write_macVlanStatus;
            break;
        default:
            *write_method = 0;
            break;
    }

    /* check compc, retrive compl */
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,compl,
                           MACVLANENTRY_INSTANCE_LEN);

    memset(&entry, 0, sizeof(entry));

    if (exact) /* get,set */
    {
        /* get index */
        if (macVlanTable_OidIndexToData(exact,compc,compl, entry.mask, entry.mac_address) == FALSE)
        {
            return NULL;
        }

        /* get data */
        if (VLAN_OM_GetMacVlanEntry(&entry) != TRUE)
        {
            return NULL;
        }
    }
    else /* getnext */
    {
        /* get index */
        macVlanTable_OidIndexToData(exact,compc,compl, entry.mask, entry.mac_address);

        /* check the length of inputing index,if <1 we should try get
         * {0.0.0.0.0...}
         */
        if (compc < 1)
        {
            /* get data */
            if (VLAN_OM_GetMacVlanEntry(&entry) != TRUE)
            {
                /* get next data */
                if (VLAN_OM_GetNextMacVlanEntry(&entry) != TRUE)
                {
                    return NULL;
                }
            }
        }
        else
        {

            /* get next data */
            if (VLAN_OM_GetNextMacVlanEntry(&entry) != TRUE)
            {
                return NULL;
            }
        }
    }

    memcpy(name, vp->name, vp->namelen*sizeof(oid));

    /* assign data to the oid index */
#if (SYS_CPNT_MAC_VLAN_WITH_MASK == TRUE)
    for (i = 0; i < SIZE_macVlanMacMask; i++)
    {
        best_inst[0 + i] = entry.mask[i];
    }

    for (i = 0; i < SIZE_macVlanMacAddress; i++)
    {
        best_inst[6 + i] = entry.mac_address[i];
    }
#else
    for (i = 0; i < SIZE_macVlanMacAddress; i++)
    {
        best_inst[0 + i] = entry.mac_address[i];
    }
#endif

    memcpy(name + vp->namelen, best_inst,
           MACVLANENTRY_INSTANCE_LEN * sizeof(oid));

    *length = vp->namelen + MACVLANENTRY_INSTANCE_LEN ;

    /* this is where we do the value assignments for the mib results. */
    switch(vp->magic)
    {

#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case LEAF_macVlanMacAddress:
            *var_len = SIZE_macVlanMacAddress;
            memcpy(return_buf, entry.mac_address, *var_len);
            return (u_char*)return_buf;
#endif

        case LEAF_macVlanId:
            *var_len = sizeof(long_return);
            long_return = entry.vid;
            return (u_char *) &long_return;

#if (SYS_CPNT_MAC_VLAN_WITH_PRIORITY == TRUE)
        case LEAF_macVlanPriority:
            *var_len = sizeof(long_return);
            long_return = entry.priority;
            return (u_char *) &long_return;
#endif

        case LEAF_macVlanStatus:
            *var_len = sizeof(long_return);
            long_return = VAL_macVlanStatus_valid;
            return (u_char *) &long_return;

#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case LEAF_macVlanMacMask:
            *var_len = SIZE_macVlanMacMask;
            memcpy(return_buf, entry.macVlanMacMask, *var_len);
            return (u_char *) return_buf;
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

        default:
            ERROR_MSG("");
    }

    return NULL;
}

int
write_macVlanId(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{

    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:

            if (*(long *)var_val < 1 || *(long *)var_val > SYS_DFLT_DOT1QMAXVLANID)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            I32_T value = 0;
            UI8_T macVlanMacAddress[SIZE_macVlanMacAddress] = {0};
            UI8_T mask[SYS_ADPT_MAC_ADDR_LEN]={0};
            VLAN_TYPE_MacVlanEntry_T entry;

            if (macVlanTable_OidIndexToData(TRUE, name_len-oid_name_length,
                                            &(name[oid_name_length]),
                                            mask, macVlanMacAddress) == FALSE)
                return SNMP_ERR_COMMITFAILED;

            /* get the vid */
            value = *(long *)var_val;

            memset(&entry, 0, sizeof(entry));
            memcpy(entry.mac_address, macVlanMacAddress, sizeof(entry.mac_address));
            memcpy(entry.mask, mask, sizeof(entry.mask));

            if (VLAN_OM_GetMacVlanEntry(&entry) == FALSE)
                return SNMP_ERR_COMMITFAILED; /* the entry isn't exist */

            if(VLAN_PMGR_SetMacVlanEntry(macVlanMacAddress, mask, value, entry.priority) != TRUE)
                return SNMP_ERR_COMMITFAILED;
        }
            break;

        case UNDO:
          break;

        case COMMIT:
          break;
    }
    return SNMP_ERR_NOERROR;
}

#if (SYS_CPNT_MAC_VLAN_WITH_PRIORITY == TRUE)
int
write_macVlanPriority(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{

    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:

            if (*(long *)var_val < MIN_macVlanPriority || *(long *)var_val > MAX_macVlanPriority)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            I32_T value = 0;
            UI8_T macVlanMacAddress[SIZE_macVlanMacAddress] = {0};
            UI8_T mask[SYS_ADPT_MAC_ADDR_LEN]={0};
            VLAN_TYPE_MacVlanEntry_T entry;

            if (macVlanTable_OidIndexToData(TRUE, name_len-oid_name_length,
                                            &(name[oid_name_length]),
                                            mask, macVlanMacAddress) == FALSE)
                return SNMP_ERR_COMMITFAILED;

            /* get the priority */
            value = *(long *)var_val;

            memset(&entry, 0, sizeof(entry));
            memcpy(entry.mac_address, macVlanMacAddress, sizeof(entry.mac_address));
            memcpy(entry.mask, mask, sizeof(entry.mask));

            if (VLAN_OM_GetMacVlanEntry(&entry) == FALSE)
                return SNMP_ERR_COMMITFAILED; /* the entry isn't exist */

            if(VLAN_PMGR_SetMacVlanEntry(macVlanMacAddress, mask, entry.vid, value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
        }
            break;

        case UNDO:
          break;

        case COMMIT:
          break;
    }
    return SNMP_ERR_NOERROR;
}
#endif  /* #if (SYS_CPNT_MAC_VLAN_WITH_PRIORITY == TRUE) */

int
write_macVlanStatus(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{

    switch (action)
    {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER)
          {
              return SNMP_ERR_WRONGTYPE;
          }
          break;

        case RESERVE2:
            switch (*(long *)var_val)
            {
                case VAL_macVlanStatus_valid:
                    break;
                case VAL_macVlanStatus_invalid:
                    break;
                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            I32_T value = 0;
            UI8_T macVlanMacAddress[SIZE_macVlanMacAddress] = {0};
            UI8_T mask[SYS_ADPT_MAC_ADDR_LEN]={0};

            if (macVlanTable_OidIndexToData(TRUE, name_len-oid_name_length,
                                           &(name[oid_name_length]),
                                           mask, macVlanMacAddress) == FALSE)
                return SNMP_ERR_COMMITFAILED;

            value = *(long *)var_val;

            if (value == VAL_macVlanStatus_valid)
            {
                /* create a new entry (vlan id = 1 and priority = 0) */
                if (VLAN_PMGR_SetMacVlanEntry(macVlanMacAddress, mask, 1, SYS_DFLT_1P_PORT_DEFAULT_USER_PRIORITY) != TRUE)
                    return SNMP_ERR_COMMITFAILED;
            }
            else if (value == VAL_macVlanStatus_invalid)
            {
                /* delete an existing entry */
                if(VLAN_PMGR_DeleteMacVlanEntry(macVlanMacAddress, mask) != TRUE)
                    return SNMP_ERR_COMMITFAILED;
            }
        }
            break;

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

int
do_macVlanClearAction(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    switch (reqinfo->mode) {
        case MODE_GET:
        {
            /* always returns noClear when get macVlanClearAction. */
            long_return = VAL_macVlanClearAction_noClear;
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                     (u_char *)&long_return, sizeof(long_return));
        }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:

            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
            }

            break;

        case MODE_SET_RESERVE2:

            switch (*requests->requestvb->val.integer)
            {
                case VAL_macVlanClearAction_noClear:
                    break;
                case VAL_macVlanClearAction_clear:
                    break;
                default:
                    netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            }

            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
        {
            /* clear all entries in macVlanTable */
            if ((*requests->requestvb->val.integer == VAL_macVlanClearAction_clear) &&
                VLAN_PMGR_DeleteAllMacVlanEntry() != TRUE)
                return SNMP_ERR_COMMITFAILED;
        }
            break;

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
#endif  /* #if (SYS_CPNT_MAC_VLAN == TRUE) */

#if (SYS_CPNT_EFM_OAM == TRUE)
#define OAMPORTCLEARSTATENTRY_INSTANCE_LEN  1

BOOL_T oamPortClearStatTable_OidIndexToData(UI32_T exact, UI32_T compc,
            oid * compl,  UI32_T *oamPortClearStatIndex)
{
    /* get or write */
    if (exact)
    {
        /* check the index length */
        if (compc != OAMPORTCLEARSTATENTRY_INSTANCE_LEN) /* the constant size index */
        {
            return FALSE;
        }
    }

    *oamPortClearStatIndex = compl[0];

    return TRUE;
}

/*
 * var_oamPortClearStatTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *
var_oamPortClearStatTable(struct variable *vp,
            oid     *name,
            size_t  *length,
            int     exact,
            size_t  *var_len,
            WriteMethod **write_method)
{
    /* variables we may use later */
    UI32_T compc = 0;
    oid compl[OAMPORTCLEARSTATENTRY_INSTANCE_LEN] = {0};
    oid best_inst[OAMPORTCLEARSTATENTRY_INSTANCE_LEN] = {0};
    EFM_OAM_SNMP_ENTRY_T entry;
    UI32_T ifindex;

    switch (vp->magic)
    {
        case LEAF_oamClearStatistics:
            *write_method = write_oamClearStatistics;
            break;

        default:
            *write_method = 0;
            break;
    }

    /* check compc, retrive compl */
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,
                           compl, OAMPORTCLEARSTATENTRY_INSTANCE_LEN);

    memset(&entry, 0, sizeof(entry));

    if (exact) /* get,set */
    {
        /* get index */
        if (oamPortClearStatTable_OidIndexToData(exact, compc, compl,  &ifindex) == FALSE)
        {
            return NULL;
        }

        /* get data */
        if (EFM_OAM_POM_GetOAMEntry_SNMP(ifindex, &entry) != TRUE)
        {
            return NULL;
        }
    }
    else /* getnext */
    {
        /* get index */
        oamPortClearStatTable_OidIndexToData(exact, compc, compl,  &ifindex);

        /* check the length of inputing index,if < 1 we should try get
         * {0.0.0.0.0...}
         */
        if (compc < 1)
        {
            /* get data */
            if (EFM_OAM_POM_GetOAMEntry_SNMP(ifindex, &entry) != TRUE)
            {
                /* get next data */
                if (EFM_OAM_POM_GetNextOAMEntry_SNMP(&ifindex, &entry) != TRUE)
                {
                    return NULL;
                }
            }
        }
        else
        {
            /* get next data */
            if (EFM_OAM_POM_GetNextOAMEntry_SNMP(&ifindex, &entry) != TRUE)
            {
                return NULL;
            }
        }
    }

    memcpy(name, vp->name, vp->namelen*sizeof(oid));

    /* assign data to the oid index */
    best_inst[0] = ifindex;
    memcpy(name + vp->namelen, best_inst,
           OAMPORTCLEARSTATENTRY_INSTANCE_LEN * sizeof(oid));
    *length = vp->namelen + OAMPORTCLEARSTATENTRY_INSTANCE_LEN ;

    /* this is where we do the value assignments for the mib results. */
    switch (vp->magic)
    {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case LEAF_oamPortClearStatIndex:
            *var_len = sizeof(long_return);
            long_return = ifindex;
            return (u_char *) &long_return;

#endif
        case LEAF_oamClearStatistics:
            *var_len = sizeof(long_return);
            long_return = VAL_oamClearStatistics_noClear;
            return (u_char *) &long_return;

        default:
            ERROR_MSG("");
    }

    return NULL;
}

int
write_oamClearStatistics(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            switch (*(long *)var_val)
            {
                case VAL_oamClearStatistics_noClear:
                    break;

                case VAL_oamClearStatistics_clear:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            UI32_T oamPortClearStatIndex = 0;

            if (oamPortClearStatTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]),  &oamPortClearStatIndex) == FALSE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            if (*(long *)var_val==VAL_oamClearStatistics_clear)
            {
                if (EFM_OAM_PMGR_CleanStatis( oamPortClearStatIndex) != TRUE)
                {
                    return SNMP_ERR_COMMITFAILED;
                }
            }
        }
            break;

        case UNDO:
          break;

        case COMMIT:
          break;
    }

    return SNMP_ERR_NOERROR;
}

#define OAMPORTCLEAREVENTLOGENTRY_INSTANCE_LEN  1

BOOL_T oamPortClearEventLogTable_OidIndexToData(UI32_T exact, UI32_T compc,
    oid *compl, UI32_T *oamPortClearEventLogIndex)
{
    /* get or set
     */
    if (exact)
    {
        /* check the index length
         */
        if (compc != OAMPORTCLEAREVENTLOGENTRY_INSTANCE_LEN)  /* the constant size index */
        {
            return FALSE;
        }
    }

    *oamPortClearEventLogIndex = compl[0];

    return TRUE;
}

/*
 * var_oamPortClearEventLogTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *var_oamPortClearEventLogTable(struct variable *vp,
    oid *name,
    size_t *length,
    int exact,
    size_t *var_len,
    WriteMethod **write_method)
{
    UI32_T compc = 0;
    oid compl[OAMPORTCLEAREVENTLOGENTRY_INSTANCE_LEN] = {0};
    oid best_inst[OAMPORTCLEAREVENTLOGENTRY_INSTANCE_LEN] = {0};
    EFM_OAM_SNMP_ENTRY_T entry;
    UI32_T ifindex;

    switch (vp->magic)
    {
        case LEAF_oamPortClearEventLogAction:
            *write_method = write_oamPortClearEventLogAction;
            break;

        default:
            *write_method = 0;
            break;
    }

    /* check compc, retrive compl
     */
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl,
        OAMPORTCLEAREVENTLOGENTRY_INSTANCE_LEN);

    memset(&entry, 0, sizeof(entry));

    if (exact)  /* get or set */
    {
        /* extract index
         */
        if (! oamPortClearEventLogTable_OidIndexToData(exact, compc, compl, &ifindex))
        {
            return NULL;
        }

        /* get-exact from core layer
         */
        if (FALSE == EFM_OAM_POM_GetOAMEntry_SNMP(ifindex, &entry))
        {
            return NULL;
        }
    }
    else  /* get-next */
    {
        /* extract index
         */
        oamPortClearEventLogTable_OidIndexToData(exact, compc, compl, &ifindex);

        /* Check the length of inputing index.  If compc is less than the
         * instance length, we should try get {A.B.C.0.0...}, where A.B.C was
         * obtained from the "..._OidIndexToData" function call, and
         * 0.0... was initialized in the beginning of this function.
         * This instance may exist in the core layer.
         */
        if (compc < OAMPORTCLEAREVENTLOGENTRY_INSTANCE_LEN)  /* incomplete index */
        {
            /* get-exact, in case this instance exists
             */
            if (FALSE == EFM_OAM_POM_GetOAMEntry_SNMP(ifindex, &entry))
            {
                /* get-next according to lexicographic order; if none, fail
                 */
                if (FALSE == EFM_OAM_POM_GetNextOAMEntry_SNMP(&ifindex, &entry))
                {
                    return NULL;
                }
            }
        }
        else   /* complete index */
        {
            /* get-next according to lexicographic order; if none, fail
             */
            if (FALSE == EFM_OAM_POM_GetNextOAMEntry_SNMP(&ifindex, &entry))
            {
                return NULL;
            }
        }
    }

    /* copy base OID (without index) to output
     */
    memcpy(name, vp->name, vp->namelen * sizeof(oid));

    /* assign data to the OID index
     */
    best_inst[0] = ifindex;
    memcpy(name + vp->namelen, best_inst, OAMPORTCLEAREVENTLOGENTRY_INSTANCE_LEN * sizeof(oid));
    *length = vp->namelen + OAMPORTCLEAREVENTLOGENTRY_INSTANCE_LEN;

    /* dispatch node to read value
     */
    switch (vp->magic)
    {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case LEAF_oamPortClearEventLogIndex:
            *var_len = sizeof(long_return);
            long_return = ifindex;
            return (u_char *) &long_return;
#endif  /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

        case LEAF_oamPortClearEventLogAction:
            *var_len = sizeof(long_return);
            long_return = VAL_oamPortClearEventLogAction_noClear;
            return (u_char *) &long_return;

        default:
            ERROR_MSG("");
            break;
    }

    /* return failure
     */
    return NULL;
}

int write_oamPortClearEventLogAction(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    /* dispatch action
     */
    switch (action)
    {
        case RESERVE1:
            /* check type and length
             */
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            /* check valid values
             */
            switch (*(long *) var_val)
            {
                case VAL_oamPortClearEventLogAction_noClear:
                    break;

                case VAL_oamPortClearEventLogAction_clear:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            UI32_T oamPortClearEventLogIndex = 0;

            /* extract index
             */
            if (! oamPortClearEventLogTable_OidIndexToData(TRUE,
                name_len - oid_name_length,
                &(name[oid_name_length]),
                &oamPortClearEventLogIndex))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            /* set to core layer
             */
            if (FALSE == EFM_OAM_PMGR_ClearEventlog(oamPortClearEventLogIndex))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    /* return success
     */
    return SNMP_ERR_NOERROR;
}

#if (SYS_CPNT_EFM_OAM_REMOTE_LB_ACTIVELY == TRUE)

#define OAMLOOPBACKENTRY_INSTANCE_LEN  1

BOOL_T oamLoopbackTable_OidIndexToData(UI32_T exact, UI32_T compc,
    oid *compl, UI32_T *oamLoopbackTestIfIndex)
{
    /* get or set
     */
    if (exact)
    {
        /* check the index length
         */
        if (compc != OAMLOOPBACKENTRY_INSTANCE_LEN)  /* the constant size index */
        {
            return FALSE;
        }
    }

    *oamLoopbackTestIfIndex = compl[0];

    return TRUE;
}

/*
 * var_oamLoopbackTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *var_oamLoopbackTable(struct variable *vp,
    oid *name,
    size_t *length,
    int exact,
    size_t *var_len,
    WriteMethod **write_method)
{
    UI32_T compc = 0;
    oid compl[OAMLOOPBACKENTRY_INSTANCE_LEN] = {0};
    oid best_inst[OAMLOOPBACKENTRY_INSTANCE_LEN] = {0};
    UI32_T  lport_ifindex = 0;
    EFM_OAM_LOOPBACK_WORKING_SNMP_ENTRY_T  lbw_entry;

    /* dispatch node to set write method
     */
    switch (vp->magic)
    {
    case LEAF_oamLoopbackTestPacketNumber:
        *write_method = write_oamLoopbackTestPacketNumber;
        break;

    case LEAF_oamLoopbackTestPacketSize:
        *write_method = write_oamLoopbackTestPacketSize;
        break;

    case LEAF_oamLoopbackTestAction:
        *write_method = write_oamLoopbackTestAction;
        break;

    default:
        *write_method = 0;
        break;
    }

    /* check compc, retrive compl
     */
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl,
        OAMLOOPBACKENTRY_INSTANCE_LEN);

    memset(&lbw_entry, 0, sizeof(lbw_entry));

    /* dispatch get-exact versus get-next
     */
    if (exact)  /* get or set */
    {
        /* extract index
         */
        if (FALSE == oamLoopbackTable_OidIndexToData(
                        exact, compc, compl, &lport_ifindex))
        {
            return NULL;
        }

        /* get-exact from core layer
         */
        if (FALSE== EFM_OAM_POM_GetLoopbackWorkEntry_SNMP(lport_ifindex, &lbw_entry))
        {
            return NULL;
        }
    }
    else  /* get-next */
    {
        /* extract index
         */
        oamLoopbackTable_OidIndexToData(exact, compc, compl, &lport_ifindex);

        /* Check the length of inputing index.  If compc is less than the
         * instance length, we should try get {A.B.C.0.0...}, where A.B.C was
         * obtained from the "..._OidIndexToData" function call, and
         * 0.0... was initialized in the beginning of this function.
         * This instance may exist in the core layer.
         */
        if (compc < OAMLOOPBACKENTRY_INSTANCE_LEN)  /* incomplete index */
        {
            /* get-exact, in case this instance exists
             */
            if (FALSE == EFM_OAM_POM_GetLoopbackWorkEntry_SNMP(
                            lport_ifindex, &lbw_entry))
            {
                /* get-next according to lexicographic order; if none, fail
                 */
                if (FALSE == EFM_OAM_POM_GetNextLoopbackWorkEntry_SNMP(
                                &lport_ifindex, &lbw_entry))
                {
                    return NULL;
                }
            }
        }
        else   /* complete index */
        {
            /* get-next according to lexicographic order; if none, fail
             */
            if (FALSE == EFM_OAM_POM_GetNextLoopbackWorkEntry_SNMP(
                            &lport_ifindex, &lbw_entry))
            {
                return NULL;
            }
        }
    }

    /* copy base OID (without index) to output
     */
    memcpy(name, vp->name, vp->namelen * sizeof(oid));

    /* assign data to the OID index
     */
    best_inst[0] = lport_ifindex;
    memcpy(name + vp->namelen, best_inst, OAMLOOPBACKENTRY_INSTANCE_LEN * sizeof(oid));
    *length = vp->namelen + OAMLOOPBACKENTRY_INSTANCE_LEN;

    /* dispatch node to read value
     */
    switch (vp->magic)
    {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case LEAF_oamLoopbackTestIfIndex:
            *var_len = sizeof(long_return);
            long_return = lport_ifindex;
            return (u_char *) &long_return;
#endif  /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

        case LEAF_oamLoopbackTestPacketNumber:
            *var_len = sizeof(long_return);
            long_return = lbw_entry.pkt_number;
            return (u_char *) &long_return;

        case LEAF_oamLoopbackTestPacketSize:
            *var_len = sizeof(long_return);
            long_return = lbw_entry.pkt_size;
            return (u_char *) &long_return;

        case LEAF_oamLoopbackTestAction:
            *var_len = sizeof(long_return);
            long_return = lbw_entry.action;
            return (u_char *) &long_return;

        case LEAF_oamLoopbackTestResultTx:
            *var_len = sizeof(long_return);
            long_return = lbw_entry.tx_count;
            return (u_char *) &long_return;

        case LEAF_oamLoopbackTestResultRx:
            *var_len = sizeof(long_return);
            long_return = lbw_entry.rx_count;
            return (u_char *) &long_return;

        case LEAF_oamLoopbackTestResultLossRate:
            *var_len = sizeof(long_return);
            long_return = lbw_entry.loss_hund_of_percent;
            return (u_char *) &long_return;

        default:
            ERROR_MSG("");
            break;
    }

    /* return failure
     */
    return NULL;
}

int write_oamLoopbackTestPacketNumber(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    /* dispatch action
     */
    switch (action)
    {
        case RESERVE1:
            /* check type and length
             */
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            /* check valid values
             */
            if ((*(long *) var_val < MIN_oamLoopbackTestPacketNumber)
                || (*(long *) var_val > MAX_oamLoopbackTestPacketNumber))
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            I32_T value = 0;
            UI32_T oamLoopbackTestIfIndex = 0;

            /* extract index
             */
            if (! oamLoopbackTable_OidIndexToData(TRUE,
                name_len - oid_name_length,
                &(name[oid_name_length]),
                &oamLoopbackTestIfIndex))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            /* get user value
             */
            value = *(long *)var_val;

            /* set to core layer
             */
            if (FALSE == EFM_OAM_PMGR_SetLoopbackWorkEntryPktNum(
                            oamLoopbackTestIfIndex, value))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    /* return success
     */
    return SNMP_ERR_NOERROR;
}

int write_oamLoopbackTestPacketSize(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    /* dispatch action
     */
    switch (action)
    {
        case RESERVE1:
            /* check type and length
             */
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            /* check valid values
             */
            if ((*(long *) var_val < MIN_oamLoopbackTestPacketSize)
                || (*(long *) var_val > MAX_oamLoopbackTestPacketSize))
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            I32_T value = 0;
            UI32_T oamLoopbackTestIfIndex = 0;

            /* extract index
             */
            if (! oamLoopbackTable_OidIndexToData(TRUE,
                name_len - oid_name_length,
                &(name[oid_name_length]),
                &oamLoopbackTestIfIndex))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            /* get user value
             */
            value = *(long *)var_val;

            /* set to core layer
             */
            if (FALSE == EFM_OAM_PMGR_SetLoopbackWorkEntryPktSize(
                            oamLoopbackTestIfIndex, value))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    /* return success
     */
    return SNMP_ERR_NOERROR;
}

int write_oamLoopbackTestAction(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    /* dispatch action
     */
    switch (action)
    {
        case RESERVE1:
            /* check type and length
             */
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            /* check valid values
             */
            switch (*(long *) var_val)
            {
                case VAL_oamLoopbackTestAction_noTest:
                    break;

                case VAL_oamLoopbackTestAction_test:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            I32_T value = 0;
            UI32_T oamLoopbackTestIfIndex = 0;

            /* extract index
             */
            if (! oamLoopbackTable_OidIndexToData(TRUE,
                name_len - oid_name_length,
                &(name[oid_name_length]),
                &oamLoopbackTestIfIndex))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            /* get user value
             */
            value = *(long *)var_val;

            /* set to core layer
             */
            if (FALSE == EFM_OAM_PMGR_SetLoopbackWorkEntryState(
                            oamLoopbackTestIfIndex, value))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    /* return success
     */
    return SNMP_ERR_NOERROR;
}
#endif /* #if (SYS_CPNT_EFM_OAM_REMOTE_LB_ACTIVELY == TRUE) */
#endif    /* #if (SYS_CPNT_EFM_OAM == TRUE) */


#if (SYS_CPNT_MLDSNP == TRUE)

int
do_mldSnoopStatus(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{

    switch(reqinfo->mode) {
        case MODE_GET:
        {
            MLDSNP_TYPE_MLDSNP_STATUS_T status;

            if (MLDSNP_POM_GetMldStatus(&status)==TRUE)
            {
                long_return = status;
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER , (u_char *)&long_return , sizeof(long_return) );
            }
            else
            {
                return SNMP_ERR_GENERR;
            }
        }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:

            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
            }

            break;
        case MODE_SET_RESERVE2:

            switch ( *requests->requestvb->val.integer )
            {
                case VAL_mldSnoopStatus_enabled:
                    break;
                case VAL_mldSnoopStatus_disabled:
                    break;
                default:
                    netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
        {
            if (MLDSNP_PMGR_SetMldStatus(*requests->requestvb->val.integer)!=MLDSNP_TYPE_RETURN_SUCCESS)
            {
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
            }
        }
            break;

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_mldSnoopQuerier(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{

    switch(reqinfo->mode) {
        case MODE_GET:
        {
            MLDSNP_TYPE_QuerierStatus_T status;

            if (MLDSNP_POM_GetQuerierStatus(&status)==TRUE)
            {
                long_return = status;
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER , (u_char *)&long_return , sizeof(long_return) );
            }
            else
            {
                return SNMP_ERR_GENERR;
            }
        }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:

            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
            }

            break;
        case MODE_SET_RESERVE2:

            switch ( *requests->requestvb->val.integer )
            {
                case VAL_mldSnoopQuerier_enabled:
                    break;
                case VAL_mldSnoopQuerier_disabled:
                    break;
                default:
                    netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
        {
            if (MLDSNP_PMGR_SetQuerierStatus(*requests->requestvb->val.integer)!=MLDSNP_TYPE_RETURN_SUCCESS)
            {
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
            }
        }
            break;

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_mldSnoopRobustness(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{

    switch(reqinfo->mode) {
        case MODE_GET:
        {
            UI16_T ret_val;

            if (MLDSNP_POM_GetRobustnessValue(&ret_val)==TRUE)
            {
                long_return = ret_val;
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER , (u_char *)&long_return , sizeof(long_return) );
            }
            else
            {
                return SNMP_ERR_GENERR;
            }
        }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:

            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
            }

            break;
        case MODE_SET_RESERVE2:

            if (*requests->requestvb->val.integer< MIN_mldSnoopRobustness ||*requests->requestvb->val.integer > MAX_mldSnoopRobustness)
            {
               netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
        {
            if (MLDSNP_PMGR_SetRobustnessValue(*requests->requestvb->val.integer)!=MLDSNP_TYPE_RETURN_SUCCESS)
            {
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
            }
        }
            break;

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_mldSnoopQueryInterval(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{

    switch(reqinfo->mode) {
        case MODE_GET:
        {
            UI16_T ret_val;

            if (MLDSNP_POM_GetQueryInterval(&ret_val)==TRUE)
            {
                long_return = ret_val;
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER , (u_char *)&long_return , sizeof(long_return) );
            }
            else
            {
                return SNMP_ERR_GENERR;
            }
        }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:

            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
            }

            break;
        case MODE_SET_RESERVE2:

            if (*requests->requestvb->val.integer< MIN_mldSnoopQueryInterval ||*requests->requestvb->val.integer > MAX_mldSnoopQueryInterval)
            {
               netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
        {
            if (MLDSNP_PMGR_SetQueryInterval(*requests->requestvb->val.integer)!=MLDSNP_TYPE_RETURN_SUCCESS)
            {
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
            }
        }
            break;

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_mldSnoopQueryMaxResponseTime(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{

    switch(reqinfo->mode) {
        case MODE_GET:
        {
            UI16_T ret_val;

            if (MLDSNP_POM_GetQueryResponseInterval(&ret_val)==TRUE)
            {
                long_return = ret_val;
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER , (u_char *)&long_return , sizeof(long_return) );
            }
            else
            {
                return SNMP_ERR_GENERR;
            }
        }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:

            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
            }

            break;
        case MODE_SET_RESERVE2:

            if (*requests->requestvb->val.integer< MIN_mldSnoopQueryMaxResponseTime ||*requests->requestvb->val.integer > MAX_mldSnoopQueryMaxResponseTime)
            {
               netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
        {
            if (MLDSNP_PMGR_SetQueryResponseInterval(*requests->requestvb->val.integer)!=MLDSNP_TYPE_RETURN_SUCCESS)
            {
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
            }
        }
            break;

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_mldSnoopRouterPortExpireTime(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{

    switch(reqinfo->mode) {
        case MODE_GET:
        {
            UI16_T ret_val;

            if (MLDSNP_POM_GetRouterExpireTime(&ret_val)==TRUE)
            {
                long_return = ret_val;
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER , (u_char *)&long_return , sizeof(long_return) );
            }
            else
            {
                return SNMP_ERR_GENERR;
            }
        }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:

            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
            }

            break;
        case MODE_SET_RESERVE2:

            if (*requests->requestvb->val.integer< MIN_mldSnoopRouterPortExpireTime ||*requests->requestvb->val.integer > MAX_mldSnoopRouterPortExpireTime)
            {
               netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
        {
            if (MLDSNP_PMGR_SetRouterExpireTime(*requests->requestvb->val.integer)!=MLDSNP_TYPE_RETURN_SUCCESS)
            {
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
            }
        }
            break;

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_mldSnoopVersion(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{

    switch(reqinfo->mode) {
        case MODE_GET:
        {
            UI16_T ret_val;

            if (MLDSNP_POM_GetMldSnpVer(&ret_val)==TRUE)
            {
                long_return = ret_val;
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER , (u_char *)&long_return , sizeof(long_return) );
            }
            else
            {
                return SNMP_ERR_GENERR;
            }
        }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:

            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
            }

            break;
        case MODE_SET_RESERVE2:

            if (*requests->requestvb->val.integer< MIN_mldSnoopVersion ||*requests->requestvb->val.integer > MAX_mldSnoopVersion)
            {
               netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
        {
            if (MLDSNP_PMGR_SetMldSnpVer(*requests->requestvb->val.integer)!=MLDSNP_TYPE_RETURN_SUCCESS)
            {
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
            }
        }
            break;

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_mldSnoopUnknownMcastMode(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{

    switch(reqinfo->mode) {
        case MODE_GET:
        {
            MLDSNP_TYPE_UnknownBehavior_T mode;

            if (MLDSNP_POM_GetUnknownFloodBehavior(1, &mode)==TRUE)
            {
                long_return = mode;
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER , (u_char *)&long_return , sizeof(long_return) );
            }
            else
            {
                return SNMP_ERR_GENERR;
            }
        }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:

            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
            }

            break;
        case MODE_SET_RESERVE2:

            switch ( *requests->requestvb->val.integer )
            {
                case VAL_mldSnoopUnknownMcastMode_flood:
                    break;
                case VAL_mldSnoopUnknownMcastMode_toRouterPort:
                    break;
                default:
                    netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
        {
            if (MLDSNP_PMGR_SetUnknownFloodBehavior(0, *requests->requestvb->val.integer)!=MLDSNP_TYPE_RETURN_SUCCESS)
            {
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
            }
        }
            break;

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

#define MLDSNOOPROUTERCURRENTENTRY_INSTANCE_LEN  1

BOOL_T mldSnoopRouterCurrentTable_OidIndexToData(UI32_T exact, UI32_T compc,
            oid * compl,  UI32_T *mldSnoopRouterCurrentVlanIndex)
{
    /* get or write */
    if (exact)
    {
        /* check the index length */
        if (compc != MLDSNOOPROUTERCURRENTENTRY_INSTANCE_LEN) /* the constant size index */
        {
            return FALSE;
        }
    }
    *mldSnoopRouterCurrentVlanIndex = compl[0];
    return TRUE;
}

/*
 * var_mldSnoopRouterCurrentTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *
var_mldSnoopRouterCurrentTable(struct variable *vp,
            oid     *name,
            size_t  *length,
            int     exact,
            size_t  *var_len,
            WriteMethod **write_method)
{
    /* variables we may use later */
    UI32_T compc = 0, vid=0;
    oid compl[MLDSNOOPROUTERCURRENTENTRY_INSTANCE_LEN] = {0};
    oid best_inst[MLDSNOOPROUTERCURRENTENTRY_INSTANCE_LEN] = {0};
    MLDSNP_OM_RouterPortList_T entry;
    UI16_T next_vid;

    switch (vp->magic)
    {
        default:
            *write_method = 0;
            break;
    }

    /* check compc, retrive compl */
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,
                           compl, MLDSNOOPROUTERCURRENTENTRY_INSTANCE_LEN);

    memset(&entry, 0, sizeof(entry));

    if (exact) /* get,set */
    {
        /* get index */
        if (mldSnoopRouterCurrentTable_OidIndexToData(exact, compc, compl,  &vid) == FALSE)
        {
            return NULL;
        }

        /* get data */
        if (MLDSNP_POM_GetVlanRouterPortlist( vid, &entry) != TRUE)
        {
            return NULL;
        }
    }
    else /* getnext */
    {
        /* get index */
        mldSnoopRouterCurrentTable_OidIndexToData(exact, compc, compl, &vid);
        next_vid = vid;
        /* check the length of inputing index,if < 1 we should try get
         * {0.0.0.0.0...}
         */
        if (compc < 1)
        {
            /* get data */
            if (MLDSNP_POM_GetVlanRouterPortlist(vid , &entry) != TRUE)
            {
                /* get next data */
                if (MLDSNP_POM_GetNextVlanRouterPortlist( &next_vid, &entry) != TRUE)
                {
                    return NULL;
                }
                vid = next_vid;
            }
        }
        else
        {
            /* get next data */
            if (MLDSNP_POM_GetNextVlanRouterPortlist(&next_vid, &entry) != TRUE)
            {
                return NULL;
            }
            vid = next_vid;
        }
    }

    memcpy(name, vp->name, vp->namelen*sizeof(oid));

    /* assign data to the oid index */
    best_inst[0] = vid;
    memcpy(name + vp->namelen, best_inst,
           MLDSNOOPROUTERCURRENTENTRY_INSTANCE_LEN * sizeof(oid));
    *length = vp->namelen + MLDSNOOPROUTERCURRENTENTRY_INSTANCE_LEN ;

    /* this is where we do the value assignments for the mib results. */
    switch (vp->magic)
    {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case LEAF_mldSnoopRouterCurrentVlanIndex:
            *var_len = sizeof(long_return);
            long_return = vid;
            return (u_char *) &long_return;

#endif
        case LEAF_mldSnoopRouterCurrentPorts:
            *var_len = SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST;
            memcpy(return_buf, entry.router_port_bitmap, *var_len);
            return (u_char*)return_buf;

        default:
            ERROR_MSG("");
    }

    return NULL;
}

#define MLDSNOOPROUTERSTATICENTRY_INSTANCE_LEN  1

BOOL_T mldSnoopRouterStaticTable_OidIndexToData(UI32_T exact, UI32_T compc,
            oid * compl,  UI32_T *mldSnoopRouterStaticVlanIndex)
{
    /* get or write */
    if (exact)
    {
        /* check the index length */
        if (compc != MLDSNOOPROUTERSTATICENTRY_INSTANCE_LEN) /* the constant size index */
        {
            return FALSE;
        }
    }
    *mldSnoopRouterStaticVlanIndex = compl[0];
    return TRUE;
}

/*
 * var_mldSnoopRouterStaticTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *
var_mldSnoopRouterStaticTable(struct variable *vp,
            oid     *name,
            size_t  *length,
            int     exact,
            size_t  *var_len,
            WriteMethod **write_method)
{
    /* variables we may use later */
    UI32_T compc = 0, vid;
    oid compl[MLDSNOOPROUTERSTATICENTRY_INSTANCE_LEN] = {0};
    oid best_inst[MLDSNOOPROUTERSTATICENTRY_INSTANCE_LEN] = {0};
    MLDSNP_OM_RouterPortList_T entry;
    UI16_T next_vid;

    switch (vp->magic)
    {
        case LEAF_mldSnoopRouterStaticPorts:
            *write_method = write_mldSnoopRouterStaticPorts;
            break;

#if 0
        case LEAF_mldSnoopRouterStaticStatus:
            *write_method = write_mldSnoopRouterStaticStatus;
            break;
#endif

        default:
            *write_method = 0;
            break;
    }

    /* check compc, retrive compl */
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,
                           compl, MLDSNOOPROUTERSTATICENTRY_INSTANCE_LEN);

    memset(&entry, 0, sizeof(entry));

    if (exact) /* get,set */
    {
        /* get index */
        if (mldSnoopRouterStaticTable_OidIndexToData(exact, compc, compl, &vid) == FALSE)
        {
            return NULL;
        }

        /* get data */
        if (MLDSNP_POM_GetVlanRouterPortlist(vid, &entry) != TRUE)
        {
            return NULL;
        }
    }
    else /* getnext */
    {
        /* get index */
        mldSnoopRouterStaticTable_OidIndexToData(exact, compc, compl, &vid);
        next_vid = vid;
        /* check the length of inputing index,if < 1 we should try get
         * {0.0.0.0.0...}
         */
        if (compc < 1)
        {
            /* get data */
            if (MLDSNP_POM_GetVlanRouterPortlist( vid, &entry) != TRUE)
            {
                /* get next data */
                if (MLDSNP_POM_GetNextVlanRouterPortlist( &next_vid, &entry) != TRUE)
                {
                    return NULL;
                }
                vid = next_vid;
            }
        }
        else
        {
            /* get next data */
            if (MLDSNP_POM_GetNextVlanRouterPortlist( &next_vid, &entry) != TRUE)
            {
                return NULL;
            }
            vid = next_vid;
        }
    }

    memcpy(name, vp->name, vp->namelen*sizeof(oid));

    /* assign data to the oid index */
    best_inst[0] = vid;
    memcpy(name + vp->namelen, best_inst,
           MLDSNOOPROUTERSTATICENTRY_INSTANCE_LEN * sizeof(oid));
    *length = vp->namelen + MLDSNOOPROUTERSTATICENTRY_INSTANCE_LEN ;

    /* this is where we do the value assignments for the mib results. */
    switch (vp->magic)
    {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case LEAF_mldSnoopRouterStaticVlanIndex:
            *var_len = sizeof(long_return);
            long_return = vid;
            return (u_char *) &long_return;

#endif
        case LEAF_mldSnoopRouterStaticPorts:
            *var_len = SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST;
            memcpy(return_buf, entry.static_router_port_bitmap, *var_len);
            return (u_char*)return_buf;

#if 0
        case LEAF_mldSnoopRouterStaticStatus:
            *var_len = sizeof(long_return);
            long_return = 1;
            return (u_char *) &long_return;
#endif

        default:
            ERROR_MSG("");
    }

    return NULL;
}

int
write_mldSnoopRouterStaticPorts(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_OCTET_STR)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST*sizeof(char))
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;

        case RESERVE2:
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            UI32_T vid = 0;
            UI8_T mld_router_static_port[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST] = {0};
            if (mldSnoopRouterStaticTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &vid) == FALSE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            memcpy(mld_router_static_port, var_val, var_val_len);

            if (MLDSNP_PMGR_SetStaticRouterPortlist( vid, mld_router_static_port) != MLDSNP_TYPE_RETURN_SUCCESS)
            {
                return SNMP_ERR_COMMITFAILED;
            }
        }
            break;

        case UNDO:
          break;

        case COMMIT:
          break;
    }

    return SNMP_ERR_NOERROR;
}

#if 0
int
write_mldSnoopRouterStaticStatus(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            switch (*(long *)var_val)
            {
                case VAL_mldSnoopRouterStaticStatus_valid:
                    break;

                case VAL_mldSnoopRouterStaticStatus_invalid:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
#if 0
            UI32_T vid = 0;
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            I32_T value = 0;

            if (mldSnoopRouterStaticTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]),  &vid) == FALSE)
                return SNMP_ERR_COMMITFAILED;

            value = *(long *)var_val;

            switch(value)
            {
                case VAL_mldSnoopRouterStaticStatus_valid:

                    if (MLDSNP_PMGR_SetStaticRouterPortlist( vid, mld_router_static_port) != MLDSNP_TYPE_RETURN_SUCCESS)
                    {
                        return SNMP_ERR_COMMITFAILED;
                    }
                    break;

                case VAL_mldSnoopRouterStaticStatus_invalid:

                    if (MLDSNP_PMGR_DeleteStaticRouterPortlist( vid, mld_router_static_port) != MLDSNP_TYPE_RETURN_SUCCESS)
                    {
                        return SNMP_ERR_COMMITFAILED;
                    }
                    break;
            }
#endif
        }
            break;

        case UNDO:
          break;

        case COMMIT:
          break;
    }

    return SNMP_ERR_NOERROR;
}
#endif

#define MLDSNOOPMULTICASTCURRENTENTRY_INSTANCE_LEN  17

BOOL_T mldSnoopMulticastCurrentTable_OidIndexToData(UI32_T exact, UI32_T compc,
            oid * compl,  UI32_T *mldSnoopMulticastCurrentVlanIndex, UI8_T *mldSnoopMulticastCurrentIpAddress)
{
    UI32_T i;
    /* get or write */
    if (exact)
    {
        /* check the index length */
        if (compc != MLDSNOOPMULTICASTCURRENTENTRY_INSTANCE_LEN) /* the constant size index */
        {
            return FALSE;
        }
    }
    *mldSnoopMulticastCurrentVlanIndex = compl[0];

    for (i=0; i < MLDSNP_TYPE_IPV6_DST_IP_LEN; i++)
    {
        mldSnoopMulticastCurrentIpAddress[i] = compl[1 + i];
    }
    return TRUE;
}

/*
 * var_mldSnoopMulticastCurrentTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *
var_mldSnoopMulticastCurrentTable(struct variable *vp,
            oid     *name,
            size_t  *length,
            int     exact,
            size_t  *var_len,
            WriteMethod **write_method)
{
    /* variables we may use later */
    UI32_T compc = 0, vid;
    oid compl[MLDSNOOPMULTICASTCURRENTENTRY_INSTANCE_LEN] = {0};
    oid best_inst[MLDSNOOPMULTICASTCURRENTENTRY_INSTANCE_LEN] = {0};
    UI32_T i;
    MLDSNP_OM_GroupInfo_T entry;
    UI16_T next_vid;

    switch (vp->magic)
    {
        default:
            *write_method = 0;
            break;
    }

    /* check compc, retrive compl */
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,
                           compl, MLDSNOOPMULTICASTCURRENTENTRY_INSTANCE_LEN);

    memset(&entry, 0, sizeof(entry));

    if (exact) /* get,set */
    {
        /* get index */
        if (mldSnoopMulticastCurrentTable_OidIndexToData(exact, compc, compl, &vid, entry.gip_a) == FALSE)
        {
            return NULL;
        }

        /* get data */
        if (MLDSNP_POM_GetGroupPortlist(vid, entry.gip_a, entry.sip_a, &entry)!= TRUE)
        {
            return NULL;
        }
    }
    else /* getnext */
    {
        /* get index */
        mldSnoopMulticastCurrentTable_OidIndexToData(exact, compc, compl, &vid, entry.gip_a);
        next_vid = vid;
        /* check the length of inputing index,if < 1 we should try get
         * {0.0.0.0.0...}
         */
        if (compc < 1)
        {
            /* get data */
            if (MLDSNP_POM_GetGroupPortlist( next_vid, entry.gip_a, entry.sip_a, &entry)!= TRUE)
            {
                /* get next data */
                if (MLDSNP_POM_GetNextGroupPortlist( &next_vid, entry.gip_a, entry.sip_a, &entry)!= TRUE)
                {
                    return NULL;
                }
                vid = next_vid;
            }
        }
        else
        {
            /* get next data */
            if (MLDSNP_POM_GetNextGroupPortlist( &next_vid, entry.gip_a, entry.sip_a, &entry)!= TRUE)
            {
                return NULL;
            }
            vid = next_vid;
        }
    }

    memcpy(name, vp->name, vp->namelen*sizeof(oid));

    /* assign data to the oid index */
    best_inst[0] = vid;
    for (i = 0; i < MLDSNP_TYPE_IPV6_DST_IP_LEN; i++)
    {
        best_inst[1 + i] = entry.gip_a[i];
    }
    memcpy(name + vp->namelen, best_inst,
           MLDSNOOPMULTICASTCURRENTENTRY_INSTANCE_LEN * sizeof(oid));
    *length = vp->namelen + MLDSNOOPMULTICASTCURRENTENTRY_INSTANCE_LEN ;

    /* this is where we do the value assignments for the mib results. */
    switch (vp->magic)
    {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case LEAF_mldSnoopMulticastCurrentVlanIndex:
            *var_len = sizeof(long_return);
            long_return = vid;
            return (u_char *) &long_return;

#endif
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case LEAF_mldSnoopMulticastCurrentIpAddress:
            *var_len = MLDSNP_TYPE_IPV6_DST_IP_LEN;
            memcpy(return_buf, entry.gip_a, *var_len);
            return (u_char*)return_buf;

#endif
        case LEAF_mldSnoopMulticastCurrentPorts:
            *var_len = SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST;

            for(i=0; i<SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST; i++)
            {
                return_buf[i] |=entry.dynamic_port_bitmap[i];
                return_buf[i] |=entry.static_port_bitmap[i];
            }

            return (u_char*)return_buf;

        default:
            ERROR_MSG("");
    }

    return NULL;
}

#define MLDSNOOPMULTICASTSTATICENTRY_INSTANCE_LEN  17

BOOL_T mldSnoopMulticastStaticTable_OidIndexToData(UI32_T exact, UI32_T compc,
            oid * compl,  UI32_T *mldSnoopMulticastStaticVlanIndex, UI8_T *mldSnoopMulticastStaticIpAddress)
{
    UI32_T i;
    /* get or write */
    if (exact)
    {
        /* check the index length */
        if (compc != MLDSNOOPMULTICASTSTATICENTRY_INSTANCE_LEN) /* the constant size index */
        {
            return FALSE;
        }
    }
    *mldSnoopMulticastStaticVlanIndex = compl[0];

    for (i=0; i < MLDSNP_TYPE_IPV6_SRC_IP_LEN; i++)
    {
        mldSnoopMulticastStaticIpAddress[i] = compl[1 + i];
    }
    return TRUE;
}

/*
 * var_mldSnoopMulticastStaticTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *
var_mldSnoopMulticastStaticTable(struct variable *vp,
            oid     *name,
            size_t  *length,
            int     exact,
            size_t  *var_len,
            WriteMethod **write_method)
{
    /* variables we may use later */
    UI32_T compc = 0, vid =0;
    oid compl[MLDSNOOPMULTICASTSTATICENTRY_INSTANCE_LEN] = {0};
    oid best_inst[MLDSNOOPMULTICASTSTATICENTRY_INSTANCE_LEN] = {0};
    UI32_T i;
    MLDSNP_OM_GroupInfo_T entry;
    UI16_T next_vid;

    switch (vp->magic)
    {
        case LEAF_mldSnoopMulticastStaticPorts:
            *write_method = write_mldSnoopMulticastStaticPorts;
            break;

#if 0
        case LEAF_mldSnoopMulticastStaticStatus:
            *write_method = write_mldSnoopMulticastStaticStatus;
            break;
#endif

        default:
            *write_method = 0;
            break;
    }

    /* check compc, retrive compl */
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,
                           compl, MLDSNOOPMULTICASTSTATICENTRY_INSTANCE_LEN);

    memset(&entry, 0, sizeof(entry));

    if (exact) /* get,set */
    {
        /* get index */
        if (mldSnoopMulticastStaticTable_OidIndexToData(exact, compc, compl, &vid, entry.gip_a) == FALSE)
        {
            return NULL;
        }

        /* get data */
        if (MLDSNP_POM_GetStaticGroupPortlist(vid, entry.gip_a, entry.sip_a, entry.static_port_bitmap)!= TRUE)
        {
            return NULL;
        }
    }
    else /* getnext */
    {
        /* get index */
        mldSnoopMulticastStaticTable_OidIndexToData(exact, compc, compl, &vid, entry.gip_a);

        next_vid = vid;
        /* check the length of inputing index,if < 1 we should try get
         * {0.0.0.0.0...}
         */
        if (compc < 1)
        {
            /* get data */
            if (MLDSNP_POM_GetStaticGroupPortlist( next_vid, entry.gip_a, entry.sip_a, entry.static_port_bitmap)!= TRUE)
            {
                /* get next data */
                if (MLDSNP_POM_GetNextStaticGroupPortlist( &next_vid, entry.gip_a, entry.sip_a, entry.static_port_bitmap)!= TRUE)
                {
                    return NULL;
                }
            }
        }
        else
        {
            /* get next data */
            if (MLDSNP_POM_GetNextStaticGroupPortlist( &next_vid, entry.gip_a, entry.sip_a, entry.static_port_bitmap)!= TRUE)
            {
                return NULL;
            }
        }
        vid = next_vid;
    }

    memcpy(name, vp->name, vp->namelen*sizeof(oid));

    /* assign data to the oid index */
    best_inst[0] = vid;
    for (i = 0; i < MLDSNP_TYPE_IPV6_SRC_IP_LEN; i++)
    {
        best_inst[1 + i] = entry.gip_a[i];
    }
    memcpy(name + vp->namelen, best_inst,
           MLDSNOOPMULTICASTSTATICENTRY_INSTANCE_LEN * sizeof(oid));
    *length = vp->namelen + MLDSNOOPMULTICASTSTATICENTRY_INSTANCE_LEN ;

    /* this is where we do the value assignments for the mib results. */
    switch (vp->magic)
    {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case LEAF_mldSnoopMulticastStaticVlanIndex:
            *var_len = sizeof(long_return);
            long_return = vid;
            return (u_char *) &long_return;

#endif
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case LEAF_mldSnoopMulticastStaticIpAddress:
            *var_len = MLDSNP_TYPE_IPV6_SRC_IP_LEN;
            memcpy(return_buf, entry.gip_a, *var_len);
            return (u_char*)return_buf;

#endif
        case LEAF_mldSnoopMulticastStaticPorts:
            *var_len = SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST;
            memcpy(return_buf, entry.static_port_bitmap, *var_len);
            return (u_char*)return_buf;

#if 0
        case LEAF_mldSnoopMulticastStaticStatus:
            *var_len = sizeof(long_return);
            long_return = 1;
            return (u_char *) &long_return;
#endif

        default:
            ERROR_MSG("");
    }

    return NULL;
}

int
write_mldSnoopMulticastStaticPorts(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_OCTET_STR)
            {
                return SNMP_ERR_WRONGTYPE;
            }

            if (var_val_len > SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST)
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;

        case RESERVE2:
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            UI32_T vid = 0;
            UI8_T ipadd_ar[MLDSNP_TYPE_IPV6_SRC_IP_LEN] = {0};
            UI8_T sip_ar[MLDSNP_TYPE_IPV6_DST_IP_LEN] = {0};
            UI8_T mld_multi_static_port[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST] = {0};

            if (mldSnoopMulticastStaticTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]),  &vid, ipadd_ar) == FALSE)
            {
                return SNMP_ERR_COMMITFAILED;
            }
            memcpy(mld_multi_static_port, var_val, var_val_len);

            if (MLDSNP_PMGR_SetPortListStaticJoinGroup( vid, ipadd_ar, sip_ar, mld_multi_static_port) != MLDSNP_TYPE_RETURN_SUCCESS)
            {
                return SNMP_ERR_COMMITFAILED;
            }
        }
            break;

        case UNDO:
          break;

        case COMMIT:
          break;
    }

    return SNMP_ERR_NOERROR;
}

#if 0
int
write_mldSnoopMulticastStaticStatus(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            switch (*(long *)var_val)
            {
                case VAL_mldSnoopMulticastStaticStatus_valid:
                    break;

                case VAL_mldSnoopMulticastStaticStatus_invalid:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
#if 0
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            I32_T value = 0;
            UI32_T vid = 0;
            UI8_T ipadd_ar[MLDSNP_TYPE_IPV6_SRC_IP_LEN] = {0};
            UI8_T sip_ar[MLDSNP_TYPE_IPV6_DST_IP_LEN] = {0};

            if (mldSnoopMulticastStaticTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]),  &vid, ipadd_ar) == FALSE)
                return SNMP_ERR_COMMITFAILED;

            value = *(long *)var_val;

            switch(value)
            {
                case VAL_mldSnoopMulticastStaticStatus_valid:

                    if (MLDSNP_PMGR_SetPortListStaticJoinGroup( vid, ipadd_ar, sip_ar, mld_multi_static_port) != MLDSNP_TYPE_RETURN_SUCCESS)
                    {
                        return SNMP_ERR_COMMITFAILED;
                    }
                    break;

                case VAL_mldSnoopMulticastStaticStatus_invalid:

                    if (MLDSNP_PMGR_SetPortListStaticLeaveGroup( vid, ipadd_ar, sip_ar, mld_multi_static_port) != MLDSNP_TYPE_RETURN_SUCCESS)
                    {
                        return SNMP_ERR_COMMITFAILED;
                    }
                    break;
            }
#endif
        }
            break;

        case UNDO:
          break;

        case COMMIT:
          break;
    }

    return SNMP_ERR_NOERROR;
}
#endif

#define MLDSNOOPCURRENTVLANENTRY_INSTANCE_LEN  1

BOOL_T mldSnoopCurrentVlanTable_OidIndexToData(UI32_T exact, UI32_T compc,
            oid * compl,  UI32_T *mldSnoopCurrentVlanIndex)
{
    /* get or write */
    if (exact)
    {
        /* check the index length */
        if (compc != MLDSNOOPCURRENTVLANENTRY_INSTANCE_LEN) /* the constant size index */
        {
            return FALSE;
        }
    }
    *mldSnoopCurrentVlanIndex = compl[0];
    return TRUE;
}

/*
 * var_mldSnoopCurrentVlanTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *
var_mldSnoopCurrentVlanTable(struct variable *vp,
            oid     *name,
            size_t  *length,
            int     exact,
            size_t  *var_len,
            WriteMethod **write_method)
{
    MLDSNP_TYPE_ImmediateStatus_T  status;
    MLDSNP_TYPE_ImmediateByHostStatus_T  status_byhost;
    /* variables we may use later */
    UI32_T compc = 0;
    oid compl[MLDSNOOPCURRENTVLANENTRY_INSTANCE_LEN] = {0};
    oid best_inst[MLDSNOOPCURRENTVLANENTRY_INSTANCE_LEN] = {0};
    UI32_T  vid;
    UI16_T next_vid =0;

    switch (vp->magic)
    {
        case LEAF_mldSnoopCurrentVlanImmediateLeave:
            *write_method = write_mldSnoopCurrentVlanImmediateLeave;
            break;

        case LEAF_mldSnoopCurrentVlanImmediateLeaveByHostIp:
            *write_method = write_mldSnoopCurrentVlanImmediateLeaveByHostIp;
            break;

        default:
            *write_method = 0;
            break;
    }

    /* check compc, retrive compl */
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,
                           compl, MLDSNOOPCURRENTVLANENTRY_INSTANCE_LEN);

    if (exact) /* get,set */
    {
        /* get index */
        if (mldSnoopCurrentVlanTable_OidIndexToData(exact, compc, compl, &vid) == FALSE)
        {
            return NULL;
        }

        /* get data */
        switch(vp->magic)
        {
            case LEAF_mldSnoopCurrentVlanImmediateLeave:

        if (MLDSNP_POM_GetImmediateLeaveStatus( vid, &status) != TRUE)
        {
            return NULL;
        }
                break;

            case LEAF_mldSnoopCurrentVlanImmediateLeaveByHostIp:

                if (MLDSNP_POM_GetImmediateLeaveByHostStatus( vid, &status_byhost) != TRUE)
                {
                    return NULL;
                }
                break;

            default:
                break;
        }
    }
    else /* getnext */
    {
        /* get index */
        mldSnoopCurrentVlanTable_OidIndexToData(exact, compc, compl, &vid);
        next_vid = vid;
        /* check the length of inputing index,if < 1 we should try get
         * {0.0.0.0.0...}
         */
        switch(vp->magic)
        {
            case LEAF_mldSnoopCurrentVlanImmediateLeave:
        if (compc < 1)
        {
            /* get data */
            if (MLDSNP_POM_GetImmediateLeaveStatus( vid, &status) != TRUE)
            {
                /* get next data */
                if (MLDSNP_POM_GetNextImmediateLeaveStatus(&next_vid, &status) != TRUE)
                {
                    return NULL;
                }
                vid = next_vid;
            }
        }
        else
        {
            /* get next data */
            if (MLDSNP_POM_GetNextImmediateLeaveStatus(&next_vid, &status) != TRUE)
            {
                return NULL;
            }
            vid = next_vid;
        }
                break;

            case LEAF_mldSnoopCurrentVlanImmediateLeaveByHostIp:
                if (compc < 1)
                {
                    /* get data */
                    if (MLDSNP_POM_GetImmediateLeaveByHostStatus( vid, &status_byhost) != TRUE)
                    {
                        /* get next data */
                        if (MLDSNP_POM_GetNextImmediateLeaveByHostStatus(&next_vid, &status_byhost) != TRUE)
                        {
                            return NULL;
                        }
                        vid = next_vid;
                    }

                }
                else
                {
                    /* get next data */
                    if (MLDSNP_POM_GetNextImmediateLeaveByHostStatus(&next_vid, &status_byhost) != TRUE)
                    {
                        return NULL;
                    }
                    vid = next_vid;
                }
                break;

            default:
                break;
        }
    }

    memcpy(name, vp->name, vp->namelen*sizeof(oid));

    /* assign data to the oid index */
    best_inst[0] = vid;
    memcpy(name + vp->namelen, best_inst,
           MLDSNOOPCURRENTVLANENTRY_INSTANCE_LEN * sizeof(oid));
    *length = vp->namelen + MLDSNOOPCURRENTVLANENTRY_INSTANCE_LEN ;

    /* this is where we do the value assignments for the mib results. */
    switch (vp->magic)
    {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case LEAF_mldSnoopCurrentVlanIndex:
            *var_len = sizeof(long_return);
            long_return = vid;
            return (u_char *) &long_return;

#endif
        case LEAF_mldSnoopCurrentVlanImmediateLeave:
            *var_len = sizeof(long_return);
            long_return = status;
            return (u_char *) &long_return;

        case LEAF_mldSnoopCurrentVlanImmediateLeaveByHostIp:
            *var_len = sizeof(long_return);
            long_return = status_byhost;
            return (u_char *) &long_return;

        default:
            ERROR_MSG("");
    }

    return NULL;
}

int
write_mldSnoopCurrentVlanImmediateLeave(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            switch (*(long *)var_val)
            {
                case VAL_mldSnoopCurrentVlanImmediateLeave_enabled:
                    break;

                case VAL_mldSnoopCurrentVlanImmediateLeave_disabled:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            I32_T value = 0;
            UI32_T vid = 0;

            if (mldSnoopCurrentVlanTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &vid) == FALSE)
            {
                return SNMP_ERR_COMMITFAILED;
            }
            value = *(long *)var_val;

            if (MLDSNP_PMGR_SetImmediateLeaveStatus( vid, value) != MLDSNP_TYPE_RETURN_SUCCESS)
            {
                return SNMP_ERR_COMMITFAILED;
            }
        }
            break;

        case UNDO:
          break;

        case COMMIT:
          break;
    }

    return SNMP_ERR_NOERROR;
}

int
write_mldSnoopCurrentVlanImmediateLeaveByHostIp(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            switch (*(long *)var_val)
            {
                case VAL_mldSnoopCurrentVlanImmediateLeaveByHost_enabled:
                    break;

                case VAL_mldSnoopCurrentVlanImmediateLeaveByHost_disabled:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = 15;
            I32_T value = 0;
            UI32_T vid = 0;

            if (mldSnoopCurrentVlanTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &vid) == FALSE)
            {
                return SNMP_ERR_COMMITFAILED;
            }
            value = *(long *)var_val;

            if (MLDSNP_PMGR_SetImmediateLeaveByHostStatus( vid, value) != MLDSNP_TYPE_RETURN_SUCCESS)
            {
                return SNMP_ERR_COMMITFAILED;
            }
        }
            break;

        case UNDO:
          break;

        case COMMIT:
          break;
    }

    return SNMP_ERR_NOERROR;
}



#if (SYS_CPNT_FILTER_THROOTTLE_MLDSNP == TRUE)

int
do_mldSnoopFilterStatus(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{

    switch(reqinfo->mode) {
        case MODE_GET:
        {
            UI32_T value = 0;

            if (MLDSNP_POM_GetMLDFilterStatus(&value) == TRUE)
            {
                long_return = value;
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER , (u_char *)&long_return , sizeof(long_return) );
            }
            else
            {
                return SNMP_ERR_GENERR;
            }
        }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:

            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
            }

            break;
        case MODE_SET_RESERVE2:

            switch ( *requests->requestvb->val.integer )
            {
                case VAL_mldSnoopFilterStatus_enabled:
                    break;
                case VAL_mldSnoopFilterStatus_disabled:
                    break;
                default:
                    netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
        {
            if (MLDSNP_PMGR_SetMldFilter(*requests->requestvb->val.integer)!=MLDSNP_TYPE_RETURN_SUCCESS)
            {
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
            }
        }
            break;

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

/********************************************
 **********mldSnoopProfileTable*************
 ********************************************
 */
#define MLDSNOOPPROFILEENTRY_INSTANCE_LEN  1

BOOL_T mldSnoopProfileTable_OidIndexToData(UI32_T exact, UI32_T compc,
            oid * compl ,  UI32_T *mldSnoopProfileId)
{
    /* get or write
     */
    if(exact)
    {

        /* check the index length
         */

        if(compc != MLDSNOOPPROFILEENTRY_INSTANCE_LEN) /* the constant size index*/
        {
            return FALSE;
        }
    }
    *mldSnoopProfileId=compl[0];
    return TRUE;
}

/*
 * var_mldSnoopProfileTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *
var_mldSnoopProfileTable(struct variable *vp,
            oid     *name,
            size_t  *length,
            int     exact,
            size_t  *var_len,
            WriteMethod **write_method)
{
    /* variables we may use later */
    UI32_T compc=0;
    oid compl[MLDSNOOPPROFILEENTRY_INSTANCE_LEN];
    oid best_inst[MLDSNOOPPROFILEENTRY_INSTANCE_LEN];
    UI32_T mldSnoopProfileId = 0;
    switch(vp->magic)
    {
    case LEAF_mldSnoopProfileAction:
        *write_method = write_mldSnoopProfileAction;
        break;
    case LEAF_mldSnoopProfileStatus:
        *write_method = write_mldSnoopProfileStatus;
        break;
    default:
        *write_method = 0;
        break;
    }

    /*check compc, retrive compl*/
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,compl, MLDSNOOPPROFILEENTRY_INSTANCE_LEN);

    if (exact)/*get,set*/
    {
        if(mldSnoopProfileTable_OidIndexToData(exact,compc,compl, &mldSnoopProfileId)==FALSE)
        {
            return NULL;
        }
        if ( MLDSNP_POM_IsMLDProfileExist( mldSnoopProfileId) != TRUE )
        {
            return NULL;
        }
    }
    else/*getnext*/
    {

        mldSnoopProfileTable_OidIndexToData(exact,compc,compl, &mldSnoopProfileId);
        /* check the length of inputing index,if <1 we should try get {0.0.0.0.0...}
         */
        if (compc< 1)
        {
            if ( MLDSNP_POM_IsMLDProfileExist( mldSnoopProfileId) != TRUE )
            {

                /*get next index*/
                if ( MLDSNP_POM_GetNextMLDProfileID( &mldSnoopProfileId ) != TRUE )
                {
                    return NULL;
                }
            }
        }
        else
        {
            /*get next index*/
            if ( MLDSNP_POM_GetNextMLDProfileID( &mldSnoopProfileId ) != TRUE )
            {
                return NULL;
            }
        }
    }

    memcpy(name, vp->name, vp->namelen*sizeof(oid));
    /* assign data to the oid index
     */


    best_inst[0] = mldSnoopProfileId;
    memcpy(name+vp->namelen, best_inst, MLDSNOOPPROFILEENTRY_INSTANCE_LEN*sizeof(oid));
    *length = vp->namelen + MLDSNOOPPROFILEENTRY_INSTANCE_LEN ;

    /* this is where we do the value assignments for the mib results.
     */
    switch(vp->magic) {

#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    case LEAF_mldSnoopProfileId:
    {
        *var_len = sizeof(long_return);
        long_return = mldSnoopProfileId;
        return (u_char *) &long_return;
    }
#endif
    case LEAF_mldSnoopProfileAction:
    {
        UI32_T value = 0;

        *var_len = sizeof(long_return);
        if (MLDSNP_POM_GetMLDProfileAccessMode(mldSnoopProfileId, &value) != TRUE)
        {
            return NULL;
        }
        long_return = value;
        return (u_char *) &long_return;
    }
    case LEAF_mldSnoopProfileStatus:
    {
        *var_len = sizeof(long_return);
        long_return = 1;
        return (u_char *) &long_return;
    }
    default:
      ERROR_MSG("");
    }
    return NULL;
}

int
write_mldSnoopProfileAction(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{

    switch ( action ) {

        case RESERVE1:

          if (var_val_type != ASN_INTEGER)
          {
              return SNMP_ERR_WRONGTYPE;
          }
          break;

        case RESERVE2:
            switch ( *(long *)var_val )
            {
                case VAL_mldSnoopProfileAction_permit:
                    break;
                case VAL_mldSnoopProfileAction_deny:
                    break;
                default:
                    return SNMP_ERR_WRONGVALUE;
            }
          break;

        case FREE:
          break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            I32_T value = 0;
            UI32_T mldSnoopProfileId = 0;

            if(mldSnoopProfileTable_OidIndexToData(TRUE, name_len-oid_name_length, &(name[oid_name_length]), &mldSnoopProfileId) == FALSE)
                return SNMP_ERR_COMMITFAILED;
            value = *(long *)var_val;
            if(MLDSNP_PMGR_SetMLDProfileAccessMode( mldSnoopProfileId, value) != MLDSNP_TYPE_RETURN_SUCCESS )
                return SNMP_ERR_COMMITFAILED;
        }
            break;

        case UNDO:
          break;

        case COMMIT:
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_mldSnoopProfileStatus(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{

    switch ( action ) {

        case RESERVE1:

          if (var_val_type != ASN_INTEGER)
          {
              return SNMP_ERR_WRONGTYPE;
          }
          break;

        case RESERVE2:
            switch ( *(long *)var_val )
            {
                case VAL_mldSnoopProfileStatus_valid:
                    break;
                case VAL_mldSnoopProfileStatus_invalid:
                    break;
                default:
                    return SNMP_ERR_WRONGVALUE;
            }
          break;

        case FREE:
          break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            I32_T value = 0;
            UI32_T mldSnoopProfileId = 0;

            if(mldSnoopProfileTable_OidIndexToData(TRUE, name_len-oid_name_length, &(name[oid_name_length]), &mldSnoopProfileId) == FALSE)
                return SNMP_ERR_COMMITFAILED;
            value = *(long *)var_val;
            if(value == VAL_mldSnoopProfileStatus_valid)
            {
                if(MLDSNP_PMGR_CreateMLDProfileEntry(mldSnoopProfileId) != MLDSNP_TYPE_RETURN_SUCCESS)
                {
                    return SNMP_ERR_COMMITFAILED;
                }

            }
            else if(value == VAL_mldSnoopProfileStatus_invalid)
            {
                if(MLDSNP_PMGR_DestroyMLDProfileEntry(mldSnoopProfileId) != MLDSNP_TYPE_RETURN_SUCCESS)
                {
                    return SNMP_ERR_COMMITFAILED;
                }
            }
        }
            break;

        case UNDO:
          break;

        case COMMIT:
          break;
    }
    return SNMP_ERR_NOERROR;
}



/********************************************
 ************mldSnoopProfileCtl*************
 ********************************************
 */
static UI32_T mldSnoopProfileCtlId = 0;
static UI32_T mldSnoopProfileCtlInetAddressType = 0;
static UI8_T mldSnoopProfileCtlStartInetAddress[SYS_ADPT_IPV6_ADDR_LEN] = {0};
static UI8_T mldSnoopProfileCtlEndInetAddress[SYS_ADPT_IPV6_ADDR_LEN] = {0};
static UI32_T mldSnoopProfileCtlAction = VAL_mldSnoopProfileCtlAction_noAction;

int
do_mldSnoopProfileCtlId(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{

    switch(reqinfo->mode) {
        case MODE_GET:
        {
           long_return = mldSnoopProfileCtlId;
           snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED , (u_char *) &long_return , sizeof(long_return) );

        }
        break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:

            if (requests->requestvb->type != ASN_UNSIGNED)
            {
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
            }

            break;
        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
        {
            mldSnoopProfileCtlId = (*requests->requestvb->val.integer);
        }
            break;

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
do_mldSnoopProfileCtlInetAddressType(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{

    switch(reqinfo->mode) {
        case MODE_GET:
        {
            long_return = mldSnoopProfileCtlInetAddressType;
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER , (u_char *)&long_return , sizeof(long_return) );

        }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:

            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
            }
            break;
        case MODE_SET_RESERVE2:
            {
                UI32_T type;
                type = (*requests->requestvb->val.integer);
                if ( type != VAL_mldSnoopProfileCtlInetAddressType_ipv6)
                  netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_INCONSISTENTVALUE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
        {
            mldSnoopProfileCtlInetAddressType = (*requests->requestvb->val.integer);
        }
            break;

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
do_mldSnoopProfileCtlStartInetAddress(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{

    switch(reqinfo->mode) {
        case MODE_GET:
        {
            memcpy(return_buf, mldSnoopProfileCtlStartInetAddress, sizeof(mldSnoopProfileCtlStartInetAddress));
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR , (u_char *)return_buf , sizeof(mldSnoopProfileCtlStartInetAddress) );

        }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:

            if (requests->requestvb->type != ASN_OCTET_STR)
            {
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
            }
            if (requests->requestvb->val_len > sizeof(mldSnoopProfileCtlStartInetAddress))
            {
                return SNMP_ERR_WRONGLENGTH;
            }

            break;
        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
        {
            memcpy(mldSnoopProfileCtlStartInetAddress, requests->requestvb->val.string, sizeof(mldSnoopProfileCtlStartInetAddress));
        }
            break;

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
do_mldSnoopProfileCtlEndInetAddress(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{

    switch(reqinfo->mode) {
        case MODE_GET:
        {
            memcpy(return_buf, mldSnoopProfileCtlEndInetAddress, sizeof(mldSnoopProfileCtlEndInetAddress));
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR , (u_char *)return_buf , sizeof(mldSnoopProfileCtlEndInetAddress) );
        }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:

            if (requests->requestvb->type != ASN_OCTET_STR)
            {
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
            }
            if (requests->requestvb->val_len > sizeof(mldSnoopProfileCtlEndInetAddress))
            {
                return SNMP_ERR_WRONGLENGTH;
            }

            break;
        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
        {
           memcpy(mldSnoopProfileCtlEndInetAddress, requests->requestvb->val.string, sizeof(mldSnoopProfileCtlEndInetAddress));
        }
            break;

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
do_mldSnoopProfileCtlAction(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{

    switch(reqinfo->mode) {
        case MODE_GET:
        {
            long_return = mldSnoopProfileCtlAction;
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER , (u_char *)&long_return , sizeof(long_return) );
        }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:

            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
            }

            break;
        case MODE_SET_RESERVE2:

            switch ( *requests->requestvb->val.integer )
            {
                case VAL_mldSnoopProfileCtlAction_noAction:
                    break;
                case VAL_mldSnoopProfileCtlAction_create:
                    break;
                case VAL_mldSnoopProfileCtlAction_destroy:
                    break;
                default:
                    netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
        {
            mldSnoopProfileCtlAction = *requests->requestvb->val.integer;
            switch ( mldSnoopProfileCtlAction )
            {
                case VAL_mldSnoopProfileCtlAction_noAction :
                    break;
                case VAL_mldSnoopProfileCtlAction_create :

                    if(MLDSNP_PMGR_CreateMLDProfileEntry(mldSnoopProfileCtlId)!= MLDSNP_TYPE_RETURN_SUCCESS)
                    {
                        netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
                    }
                    if (MLDSNP_PMGR_AddMLDProfileGroup(mldSnoopProfileCtlId , mldSnoopProfileCtlStartInetAddress, mldSnoopProfileCtlEndInetAddress) != MLDSNP_TYPE_RETURN_SUCCESS)
                    {
                        netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
                    }
                    mldSnoopProfileCtlAction  = VAL_mldSnoopProfileCtlAction_noAction;
                    break;
                case VAL_mldSnoopProfileCtlAction_destroy :
                    if (MLDSNP_PMGR_DeleteMLDProfileGroup(mldSnoopProfileCtlId , mldSnoopProfileCtlStartInetAddress, mldSnoopProfileCtlEndInetAddress) != MLDSNP_TYPE_RETURN_SUCCESS)
                    {
                        netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
                    }
                    mldSnoopProfileCtlAction = VAL_mldSnoopProfileCtlAction_noAction;
                    break;
                default:
                    netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
            }
        }
            break;

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

/********************************************
 *********mldSnoopProfileRangeTable*********
 ********************************************
 */
#define MLDSNOOPPROFILERANGEENTRY_INSTANCE_LEN  34

BOOL_T mldSnoopProfileRangeTable_OidIndexToData(UI32_T exact, UI32_T compc,
    oid *compl, UI32_T *mldSnoopProfileRangeProfileId,
    UI32_T *mldSnoopProfileRangeInetAddressType,
    UI8_T *mldSnoopProfileRangeStartInetAddress,
    UI32_T *mldSnoopProfileRangeStartInetAddress_length,
    UI8_T *mldSnoopProfileRangeEndInetAddress,
    UI32_T *mldSnoopProfileRangeEndInetAddress_length)
{
    UI16_T i;
    /* get or set
     */
    if (exact)
    {
        /* check the index length
         */
        if ((compc < 6)
            || (compc > MLDSNOOPPROFILERANGEENTRY_INSTANCE_LEN))  /* the dynamic size index */
        {
            return FALSE;
        }
    }

    *mldSnoopProfileRangeProfileId = compl[0];
    *mldSnoopProfileRangeInetAddressType = compl[1];

    if(compl[1]!= VAL_mldSnoopProfileCtlInetAddressType_ipv6)
        return FALSE;

    for (i = 0; i < 16; i++)
    {
        mldSnoopProfileRangeStartInetAddress[i] = compl[2 + i];
    }
    *mldSnoopProfileRangeStartInetAddress_length = 16;

    for (i = 0; i < 16; i++)
    {
        mldSnoopProfileRangeEndInetAddress[i] = compl[18+ i];
    }
    *mldSnoopProfileRangeEndInetAddress_length = 16;

    return TRUE;
}
/*
 * var_mldSnoopProfileRangeTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *
var_mldSnoopProfileRangeTable(struct variable *vp,
            oid     *name,
            size_t  *length,
            int     exact,
            size_t  *var_len,
            WriteMethod **write_method)
{
    /* variables we may use later */
    UI32_T compc = 0;
    oid compl[MLDSNOOPPROFILERANGEENTRY_INSTANCE_LEN];
    oid best_inst[MLDSNOOPPROFILERANGEENTRY_INSTANCE_LEN];
    UI32_T mldSnoopProfileRangeProfileId = 0;
    UI32_T mldSnoopProfileRangeInetAddressType = 0;
    UI32_T mldSnoopProfileRangeStartInetAddress_Length = 0;
    UI8_T mldSnoopProfileRangeStartInetAddress[SYS_ADPT_IPV6_ADDR_LEN] = {0};
    UI32_T mldSnoopProfileRangeEndInetAddress_Length = 0;
    UI8_T mldSnoopProfileRangeEndInetAddress[SYS_ADPT_IPV6_ADDR_LEN] = {0};
    BOOL_T find=FALSE;
    int i = 0;

    switch(vp->magic)
    {
        default:
            *write_method = 0;
            break;
    }

    /*check compc, retrive compl*/
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,compl, MLDSNOOPPROFILERANGEENTRY_INSTANCE_LEN);

    if (exact)/*get,set*/
    {
        if (! mldSnoopProfileRangeTable_OidIndexToData(exact, compc, compl,
            &mldSnoopProfileRangeProfileId, &mldSnoopProfileRangeInetAddressType, mldSnoopProfileRangeStartInetAddress, &mldSnoopProfileRangeStartInetAddress_Length, mldSnoopProfileRangeEndInetAddress, &mldSnoopProfileRangeEndInetAddress_Length))
        {
            return NULL;
        }

        /*get*/
        if(IGMPSNP_PMGR_IsIGMPProfileExist(mldSnoopProfileRangeProfileId))
        {
           UI8_T temp_start[SYS_ADPT_IPV6_ADDR_LEN]={0}, temp_end[SYS_ADPT_IPV6_ADDR_LEN]={0};
            /*get next data*/
            while(MLDSNP_POM_GetNextMLDProfileGroupbyPid(mldSnoopProfileRangeProfileId, temp_start, temp_end) == TRUE)
            {
                if(memcmp(mldSnoopProfileRangeStartInetAddress, temp_start, SYS_ADPT_IPV6_ADDR_LEN) ==0
                   &&memcmp(mldSnoopProfileRangeEndInetAddress, temp_end, SYS_ADPT_IPV6_ADDR_LEN)   ==0)
                {
                    find=TRUE;
                    break;
                }
            }
        }

        if(find == FALSE)
            return NULL;
    }
    else/*getnext*/
    {
        mldSnoopProfileRangeTable_OidIndexToData(exact, compc, compl,
            &mldSnoopProfileRangeProfileId, &mldSnoopProfileRangeInetAddressType, mldSnoopProfileRangeStartInetAddress, &mldSnoopProfileRangeStartInetAddress_Length, mldSnoopProfileRangeEndInetAddress, &mldSnoopProfileRangeEndInetAddress_Length) ;
       /* check the length of inputing index,if <1 we should try get {0.0.0.0.0...}
         */
        if (compc< 1)
        {
            /*get next group*/
            if(IGMPSNP_PMGR_IsIGMPProfileExist(mldSnoopProfileRangeProfileId))
            {
                /*get next data*/
                while(MLDSNP_POM_GetNextMLDProfileGroupbyPid(mldSnoopProfileRangeProfileId, mldSnoopProfileRangeStartInetAddress, mldSnoopProfileRangeEndInetAddress) == TRUE)
                {
                    break;
                }
            }
            else /*getnetxt profile id*/
            {
                if(MLDSNP_POM_GetNextMLDProfileID(&mldSnoopProfileRangeProfileId))
                {
                    memset(mldSnoopProfileRangeStartInetAddress, 0, SYS_ADPT_IPV6_ADDR_LEN);
                    memset(mldSnoopProfileRangeEndInetAddress, 0, SYS_ADPT_IPV6_ADDR_LEN);
                    /*get next data*/
                    if ( MLDSNP_POM_GetNextMLDProfileGroupbyPid(mldSnoopProfileRangeProfileId, mldSnoopProfileRangeStartInetAddress, mldSnoopProfileRangeEndInetAddress) != TRUE)
                    {
                        return NULL;
                    }
                    else
                    {
                        find = TRUE;
                    }
                }
                else
                {
                    return NULL;
                }
            }

            if(find == FALSE)
            {
              /*getnext profile and group */
              if (MLDSNP_POM_GetNextMLDProfileGroupbyPid( mldSnoopProfileRangeProfileId, mldSnoopProfileRangeStartInetAddress, mldSnoopProfileRangeEndInetAddress) != TRUE )
              {
                  if(MLDSNP_POM_GetNextMLDProfileID(&mldSnoopProfileRangeProfileId))
                  {
                      memset(mldSnoopProfileRangeStartInetAddress, 0, SYS_ADPT_IPV6_ADDR_LEN);
                      memset(mldSnoopProfileRangeEndInetAddress, 0, SYS_ADPT_IPV6_ADDR_LEN);
                      /*get next data*/
                      if ( MLDSNP_POM_GetNextMLDProfileGroupbyPid(mldSnoopProfileRangeProfileId, mldSnoopProfileRangeStartInetAddress, mldSnoopProfileRangeEndInetAddress) != TRUE)
                      {
                          return NULL;
                      }
                  }
                  else
                  {
                    return NULL;
                  }
              }
            }
        }
        else
        {
            if (MLDSNP_POM_GetNextMLDProfileGroupbyPid( mldSnoopProfileRangeProfileId, mldSnoopProfileRangeStartInetAddress, mldSnoopProfileRangeEndInetAddress) != TRUE )
            {
                if(MLDSNP_POM_GetNextMLDProfileID(&mldSnoopProfileRangeProfileId))
                {
                    memset(mldSnoopProfileRangeStartInetAddress, 0, SYS_ADPT_IPV6_ADDR_LEN);
                    memset(mldSnoopProfileRangeEndInetAddress, 0, SYS_ADPT_IPV6_ADDR_LEN);
                    /*get next data*/
                    if ( MLDSNP_POM_GetNextMLDProfileGroupbyPid(mldSnoopProfileRangeProfileId, mldSnoopProfileRangeStartInetAddress, mldSnoopProfileRangeEndInetAddress) != TRUE)
                    {
                        return NULL;
                    }
                }
                else
                {
                    return NULL;
                }
            }
        }
    }

    memcpy(name, vp->name, vp->namelen*sizeof(oid));
    /* assign data to the oid index
     */
    best_inst[0] = mldSnoopProfileRangeProfileId;
    /* only support IPV6*/
    mldSnoopProfileRangeInetAddressType = VAL_mldSnoopProfileCtlInetAddressType_ipv6;
    best_inst[1] = mldSnoopProfileRangeInetAddressType;

    for( i = 0; i< 16 ;i++)
    {
        best_inst[2+i] = (UI32_T)(mldSnoopProfileRangeStartInetAddress[i]);
    }

    for( i = 0; i< 16 ;i++)
    {
        best_inst[18+i] = (UI32_T)(mldSnoopProfileRangeEndInetAddress[i]);
    }

    memcpy(name+vp->namelen, best_inst, MLDSNOOPPROFILERANGEENTRY_INSTANCE_LEN * sizeof(oid));
    *length = vp->namelen + MLDSNOOPPROFILERANGEENTRY_INSTANCE_LEN ;

    /* this is where we do the value assignments for the mib results.
     */
    switch(vp->magic) {

#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    case LEAF_mldSnoopProfileRangeProfileId:
        *var_len = sizeof(long_return);
        long_return = mldSnoopProfileRangeProfileId;
        return (u_char *) &long_return;
#endif
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    case LEAF_mldSnoopProfileRangeInetAddressType:
        *var_len = sizeof(long_return);
        long_return = mldSnoopProfileRangeInetAddressType
        return (u_char*) &long_return;
#endif
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    case LEAF_mldSnoopProfileRangeStartInetAddress:
        *var_len = SYS_ADPT_IPV6_ADDR_LEN;
        memcpy(return_buf, mldSnoopProfileRangeStartInetAddress, *var_len);
        return (u_char*)return_buf;
#endif
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    case LEAF_mldSnoopProfileRangeEndInetAddress:
        *var_len = SYS_ADPT_IPV6_ADDR_LEN;
        memcpy(return_buf, mldSnoopProfileRangeEndInetAddress, *var_len);
        return (u_char*)return_buf;
#endif
    case LEAF_mldSnoopProfileRangeAction:
    {
        UI32_T value = 0;

        *var_len = sizeof(long_return);
        if (MLDSNP_POM_GetMLDProfileAccessMode(mldSnoopProfileRangeProfileId, &value) != TRUE)
        {
            return NULL;
        }
        long_return = value;
        return (u_char *) &long_return;
    }

    default:
      ERROR_MSG("");
    }
    return NULL;
}

/********************************************
 ***********mldSnoopFilterPortTable*********
 ********************************************
 */
 #define MLDSNOOPFILTERPORTENTRY_INSTANCE_LEN  1

BOOL_T mldSnoopFilterPortTable_OidIndexToData(UI32_T exact, UI32_T compc,
            oid * compl ,  UI32_T *mldSnoopFilterPortIndex)
{
    /* get or write
     */
    if(exact)
    {

        /* check the index length
         */

        if(compc != MLDSNOOPFILTERPORTENTRY_INSTANCE_LEN) /* the constant size index*/
        {
            return FALSE;
        }
    }
    *mldSnoopFilterPortIndex = compl[0];
    return TRUE;
}

/*
 * var_mldSnoopFilterPortTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *
var_mldSnoopFilterPortTable(struct variable *vp,
            oid     *name,
            size_t  *length,
            int     exact,
            size_t  *var_len,
            WriteMethod **write_method)
{
    /* variables we may use later */
    UI32_T compc = 0;
    oid compl[MLDSNOOPFILTERPORTENTRY_INSTANCE_LEN];
    oid best_inst[MLDSNOOPFILTERPORTENTRY_INSTANCE_LEN];
    UI32_T mldSnoopFilterPortIndex = 0;
    UI32_T mldSnoopFilterPortProfileId = 0;
    switch(vp->magic)
    {
    case LEAF_mldSnoopFilterPortProfileId:
        *write_method = write_mldSnoopFilterPortProfileId;
        break;
    default:
        *write_method = 0;
        break;
    }

    /*check compc, retrive compl*/
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,compl, MLDSNOOPFILTERPORTENTRY_INSTANCE_LEN);

    if (exact)/*get,set*/
    {
        if(mldSnoopFilterPortTable_OidIndexToData(exact, compc, compl, &mldSnoopFilterPortIndex) == FALSE)
        {
            return NULL;
        }

        /*get data
         */
        if (MLDSNP_POM_GetPortMLDProfileID( mldSnoopFilterPortIndex, &mldSnoopFilterPortProfileId) != TRUE)
        {
            return NULL;
        }
    }
    else/*getnext*/
    {
        mldSnoopFilterPortTable_OidIndexToData(exact, compc, compl, &mldSnoopFilterPortIndex);
        /* check the length of inputing index,if <1 we should try get {0.0.0.0.0...}
         */
        if (compc < 1)
        {
            if (MLDSNP_POM_GetPortMLDProfileID( mldSnoopFilterPortIndex, &mldSnoopFilterPortProfileId) != TRUE)
            {
                /*get next data*/
                if ( MLDSNP_PMGR_GetNextPortMLDProfileID( &mldSnoopFilterPortIndex, &mldSnoopFilterPortProfileId) != MLDSNP_TYPE_RETURN_SUCCESS)
                {
                    return NULL;
                }
            }
        }
        else
        {
            /*get next data*/
            if ( MLDSNP_PMGR_GetNextPortMLDProfileID( &mldSnoopFilterPortIndex, &mldSnoopFilterPortProfileId) != MLDSNP_TYPE_RETURN_SUCCESS)
            {
                return NULL;
            }
        }
    }

    memcpy(name, vp->name, vp->namelen*sizeof(oid));
    /* assign data to the oid index
     */


    best_inst[0] = mldSnoopFilterPortIndex;
    memcpy(name+vp->namelen, best_inst, MLDSNOOPFILTERPORTENTRY_INSTANCE_LEN * sizeof(oid));
    *length = vp->namelen + MLDSNOOPFILTERPORTENTRY_INSTANCE_LEN ;

    /* this is where we do the value assignments for the mib results.
     */
    switch(vp->magic) {

#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    case LEAF_mldSnoopFilterPortIndex:
        *var_len = sizeof(long_return);
        long_return = mldSnoopFilterPortIndex;
        return (u_char *) &long_return;
#endif
    case LEAF_mldSnoopFilterPortProfileId:
        *var_len = sizeof(long_return);
        long_return = mldSnoopFilterPortProfileId;
        return (u_char *) &long_return;
    default:
      ERROR_MSG("");
    }
    return NULL;
}

int
write_mldSnoopFilterPortProfileId(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{

    switch ( action )
    {
        case RESERVE1:

          if (var_val_type != ASN_INTEGER)
          {
              return SNMP_ERR_WRONGTYPE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
          break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            UI32_T value = 0;
            UI32_T mldSnoopFilterPortIndex = 0;

            if(mldSnoopFilterPortTable_OidIndexToData(TRUE, name_len-oid_name_length, &(name[oid_name_length]), &mldSnoopFilterPortIndex) == FALSE)
                return SNMP_ERR_COMMITFAILED;

            value = *(long *)var_val;
            if(value == 0)
            {
                if(MLDSNP_PMGR_RemoveMLDProfileFromPort( mldSnoopFilterPortIndex) != TRUE )
                    return SNMP_ERR_COMMITFAILED;
            }
            else
            {
                if(MLDSNP_PMGR_AddMLDProfileToPort( mldSnoopFilterPortIndex, value) != TRUE )
                    return SNMP_ERR_COMMITFAILED;
            }
        }
            break;

        case UNDO:
          break;

        case COMMIT:
          break;
    }
    return SNMP_ERR_NOERROR;
}


/********************************************
 *********mldSnoopThrottlePortTable*********
 ********************************************
 */
 #define MLDSNOOPTHROTTLEPORTENTRY_INSTANCE_LEN  1

BOOL_T mldSnoopThrottlePortTable_OidIndexToData(UI32_T exact, UI32_T compc,
            oid * compl ,  UI32_T *mldSnoopThrottlePortIndex)
{
    /* get or write
     */
    if(exact)
    {
        /* check the index length
         */

        if(compc != MLDSNOOPTHROTTLEPORTENTRY_INSTANCE_LEN) /* the constant size index*/
        {
            return FALSE;
        }
    }
    *mldSnoopThrottlePortIndex  =compl[0];
    return TRUE;
}

/*
 * var_mldSnoopThrottlePortTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *
var_mldSnoopThrottlePortTable(struct variable *vp,
            oid     *name,
            size_t  *length,
            int     exact,
            size_t  *var_len,
            WriteMethod **write_method)
{
    /* variables we may use later */
    UI32_T compc = 0;
    oid compl[MLDSNOOPTHROTTLEPORTENTRY_INSTANCE_LEN];
    oid best_inst[MLDSNOOPTHROTTLEPORTENTRY_INSTANCE_LEN];
    MLDSNP_OM_Throttle_T info;
    UI32_T mldSnoopThrottlePortIndex = 0;

    switch(vp->magic)
    {
    case LEAF_mldSnoopThrottlePortAction:
        *write_method = write_mldSnoopThrottlePortAction;
        break;
    case LEAF_mldSnoopThrottlePortMaxGroups:
        *write_method = write_mldSnoopThrottlePortMaxGroups;
        break;
    default:
        *write_method = 0;
        break;
    }

    memset(&info, 0, sizeof(MLDSNP_OM_Throttle_T));

    /*check compc, retrive compl*/
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,compl, MLDSNOOPTHROTTLEPORTENTRY_INSTANCE_LEN);

    if (exact)/*get,set*/
    {
        if(mldSnoopThrottlePortTable_OidIndexToData(exact, compc, compl, &mldSnoopThrottlePortIndex) == FALSE)
        {
            return NULL;
        }

        /*get data
         */
        if (MLDSNP_POM_GetMLDThrottlingInfo( mldSnoopThrottlePortIndex, &info) != TRUE)
        {
            return NULL;
        }
    }
    else/*getnext*/
    {

        mldSnoopThrottlePortTable_OidIndexToData(exact, compc,compl, &mldSnoopThrottlePortIndex);
        /* check the length of inputing index,if <1 we should try get {0.0.0.0.0...}
         */
        if (compc < 1)
        {

            if (MLDSNP_POM_GetMLDThrottlingInfo( mldSnoopThrottlePortIndex, &info) != TRUE)
            {

                /*get next data*/
                if(SWCTRL_LPORT_UNKNOWN_PORT != SWCTRL_POM_GetNextLogicalPort(&mldSnoopThrottlePortIndex))
                {
                  if ( MLDSNP_POM_GetMLDThrottlingInfo(mldSnoopThrottlePortIndex, &info) != TRUE)
                  {
                      return NULL;
                  }
                }
                else
                {
                    return NULL;
                }
            }
        }
        else
        {
            /*get next data*/
            if(SWCTRL_LPORT_UNKNOWN_PORT != SWCTRL_POM_GetNextLogicalPort(&mldSnoopThrottlePortIndex))
            {
              if ( MLDSNP_POM_GetMLDThrottlingInfo(mldSnoopThrottlePortIndex, &info) != TRUE)
              {
                  return NULL;
              }
            }
            else
            {
                return NULL;
            }
        }
    }

    memcpy(name, vp->name, vp->namelen*sizeof(oid));
    /* assign data to the oid index
     */


    best_inst[0] = mldSnoopThrottlePortIndex;
    memcpy(name+vp->namelen, best_inst, MLDSNOOPTHROTTLEPORTENTRY_INSTANCE_LEN * sizeof(oid));
    *length = vp->namelen + MLDSNOOPTHROTTLEPORTENTRY_INSTANCE_LEN ;

    /* this is where we do the value assignments for the mib results.
     */
    switch(vp->magic) {

#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    case LEAF_mldSnoopThrottlePortIndex:
        *var_len = sizeof(long_return);
        long_return = mldSnoopThrottlePortIndex;
        return (u_char *) &long_return;
#endif
    case LEAF_mldSnoopThrottlePortRunningStatus:
        *var_len = sizeof(long_return);
        long_return = info.throttle_status;
        return (u_char *) &long_return;

    case LEAF_mldSnoopThrottlePortAction:
        *var_len = sizeof(long_return);
        long_return = info.action;
        return (u_char *) &long_return;
    case LEAF_mldSnoopThrottlePortMaxGroups:
        *var_len = sizeof(long_return);
        long_return = info.max_group_number;
        return (u_char *) &long_return;

    case LEAF_mldSnoopThrottlePortCurrentGroups:
        *var_len = sizeof(long_return);
        long_return = info.current_group_count;
        return (u_char *) &long_return;

    default:
      ERROR_MSG("");
    }
    return NULL;
}

int
write_mldSnoopThrottlePortAction(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{

    switch ( action )
    {

        case RESERVE1:

          if (var_val_type != ASN_INTEGER)
          {
              return SNMP_ERR_WRONGTYPE;
          }
          break;

        case RESERVE2:
            switch ( *(long *)var_val )
            {
                case VAL_mldSnoopThrottlePortAction_replace:
                    break;
                case VAL_mldSnoopThrottlePortAction_deny:
                    break;
                default:
                    return SNMP_ERR_WRONGVALUE;
            }
          break;

        case FREE:
          break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            I32_T value = 0;
            UI32_T mldSnoopThrottlePortIndex = 0;

            if(mldSnoopThrottlePortTable_OidIndexToData(TRUE, name_len-oid_name_length, &(name[oid_name_length]), &mldSnoopThrottlePortIndex) == FALSE)
                return SNMP_ERR_COMMITFAILED;

            value = *(long *)var_val;

            if(MLDSNP_PMGR_SetMLDThrottlingActionToPort( mldSnoopThrottlePortIndex, value) != MLDSNP_TYPE_RETURN_SUCCESS )
                return SNMP_ERR_COMMITFAILED;
        }
            break;

        case UNDO:
          break;

        case COMMIT:
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_mldSnoopThrottlePortMaxGroups(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{

    switch ( action ) {

        case RESERVE1:

          if (var_val_type != ASN_INTEGER)
          {
              return SNMP_ERR_WRONGTYPE;
          }
          break;

        case RESERVE2:

            if (*(long *)var_val< MIN_mldSnoopThrottlePortMaxGroups ||*(long *)var_val > SYS_ADPT_IGMP_MAX_SUPPORT_GROUP)
            {
                return SNMP_ERR_WRONGVALUE;
            }
          break;

        case FREE:
          break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            I32_T value = 0;
            UI32_T mldSnoopThrottlePortIndex = 0;

            if(mldSnoopThrottlePortTable_OidIndexToData(TRUE, name_len-oid_name_length, &(name[oid_name_length]), &mldSnoopThrottlePortIndex) == FALSE)
                return SNMP_ERR_COMMITFAILED;

            value = *(long *)var_val;

            if(MLDSNP_PMGR_SetMLDThrottlingNumberToPort( mldSnoopThrottlePortIndex, value) != MLDSNP_TYPE_RETURN_SUCCESS)
                return SNMP_ERR_COMMITFAILED;
        }
            break;

        case UNDO:
          break;

        case COMMIT:
          break;
    }
    return SNMP_ERR_NOERROR;
}

#endif 


#define MLDSNOOPPORTENTRY_INSTANCE_LEN  1

BOOL_T mldSnoopPortTable_OidIndexToData(UI32_T exact, UI32_T compc,
    oid *compl, UI32_T *mldSnoopPortIndex)
{
    /* get or set
     */
    if (exact)
    {
        /* check the index length
         */
        if (compc != MLDSNOOPPORTENTRY_INSTANCE_LEN)  /* the constant size index */
        {
            return FALSE;
        }
    }

    *mldSnoopPortIndex = compl[0];

    return TRUE;
}

/*
 * var_mldSnoopPortTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *var_mldSnoopPortTable(struct variable *vp,
    oid *name,
    size_t *length,
    int exact,
    size_t *var_len,
    WriteMethod **write_method)
{
    UI32_T compc = 0, lport=0;
    oid compl[MLDSNOOPPORTENTRY_INSTANCE_LEN] = {0};
    oid best_inst[MLDSNOOPPORTENTRY_INSTANCE_LEN] = {0};
    MLDSNP_MGR_InfStat_T statistics;
#if (SYS_CPNT_MLDSNP_QUERY_DROP == TRUE || SYS_CPNT_IPV6_MULTICAST_DATA_DROP== TRUE)
    UI32_T status=0;
#endif
    switch (vp->magic)
    {
#if (SYS_CPNT_MLDSNP_QUERY_DROP == TRUE)
        case LEAF_mldSnoopQueryDrop:
            *write_method = write_mldSnoopQueryDrop;
            break;
#endif
#if (SYS_CPNT_IPV6_MULTICAST_DATA_DROP== TRUE)
        case LEAF_mldSnoopMulticastDataDrop:
            *write_method = write_mldSnoopMulticastDataDrop;
            break;
#endif
        case LEAF_mldSnoopPortClearStatistics:
            *write_method = write_mldSnoopPortClearStatistics;
            break;
        default:
            *write_method = 0;
            break;
    }

    memset(&statistics, 0, sizeof(statistics));

    /* check compc, retrive compl
     */
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl, MLDSNOOPPORTENTRY_INSTANCE_LEN);

    if (exact) /* get or set */
    {
        if (mldSnoopPortTable_OidIndexToData(exact, compc, compl, &lport) == FALSE)
        {
            return NULL;
        }
#if (SYS_CPNT_MLDSNP_QUERY_DROP == TRUE)
        if(vp->magic == LEAF_mldSnoopQueryDrop)
        {
            if (MLDSNP_POM_GetQueryDropStatus(lport, &status)!= TRUE)
            {
                return NULL;
            }
            status = status?VAL_mldSnoopQueryDrop_enable:VAL_mldSnoopQueryDrop_disable;
        }
#endif
#if (SYS_CPNT_IPV6_MULTICAST_DATA_DROP== TRUE)
        if(vp->magic == LEAF_mldSnoopMulticastDataDrop)
        {
            if (MLDSNP_POM_GetMulticastDataDropStatus(lport, &status)!= TRUE)
            {
                return NULL;
            }
            status = status?VAL_mldSnoopMulticastDataDrop_enable:VAL_mldSnoopMulticastDataDrop_disable;
        }
#endif
        if(vp->magic != LEAF_mldSnoopQueryDrop
            &&vp->magic != LEAF_mldSnoopMulticastDataDrop)
        {
            if(FALSE == MLDSNP_PMGR_GetInfStatistics(lport, FALSE, &statistics))
              return NULL;
        }
    }
    else /* getnext */
    {
        mldSnoopPortTable_OidIndexToData(exact, compc, compl, &lport);

        /* check the length of inputing index,if < 1 we should try get
         * {0.0.0.0.0...}
         */
        if (compc < 1)
        {
#if (SYS_CPNT_MLDSNP_QUERY_DROP == TRUE)
            if(vp->magic == LEAF_mldSnoopQueryDrop)
            {
                if (MLDSNP_POM_GetQueryDropStatus(lport, &status)!= TRUE)
                {
                    if (MLDSNP_PMGR_GetNextQueryDropStatus(&lport, &status)!= MLDSNP_TYPE_RETURN_SUCCESS)
                    {
                        return NULL;
                    }
                }
                else
                  status = status?VAL_mldSnoopQueryDrop_enable:VAL_mldSnoopQueryDrop_disable;
            }
#endif
#if (SYS_CPNT_IPV6_MULTICAST_DATA_DROP== TRUE)
            if(vp->magic == LEAF_mldSnoopMulticastDataDrop)
            {
                if (MLDSNP_POM_GetMulticastDataDropStatus(lport, &status)!= TRUE)
                {
                    if (MLDSNP_PMGR_GetNextMulticastDataDropStatus(&lport, &status)!= MLDSNP_TYPE_RETURN_SUCCESS)
                    {
                        return NULL;
                    }
                }
                else
                    status = status?VAL_mldSnoopMulticastDataDrop_enable:VAL_mldSnoopMulticastDataDrop_disable;
            }
#endif
            if(vp->magic != LEAF_mldSnoopQueryDrop
                &&vp->magic != LEAF_mldSnoopMulticastDataDrop)
            {
                if(FALSE == MLDSNP_PMGR_GetInfStatistics(lport, FALSE, &statistics))
                {
                   if(SWCTRL_POM_GetNextLogicalPort(&lport)== SWCTRL_LPORT_UNKNOWN_PORT)
                     return NULL;

                   if(FALSE == MLDSNP_PMGR_GetInfStatistics(lport, FALSE, &statistics))
                     return NULL;
                }
            }
        }
        else
        {
#if (SYS_CPNT_MLDSNP_QUERY_DROP == TRUE)
            if(vp->magic == LEAF_mldSnoopQueryDrop)
            {
                if (MLDSNP_PMGR_GetNextQueryDropStatus(&lport, &status)!= MLDSNP_TYPE_RETURN_SUCCESS)
                {
                    return NULL;
                }
            }
#endif
#if (SYS_CPNT_IPV6_MULTICAST_DATA_DROP== TRUE)
            if(vp->magic == LEAF_mldSnoopMulticastDataDrop)
            {
                if (MLDSNP_PMGR_GetNextMulticastDataDropStatus(&lport, &status)!= MLDSNP_TYPE_RETURN_SUCCESS)
                {
                    return NULL;
                }
            }
#endif
            if(vp->magic != LEAF_mldSnoopQueryDrop
                &&vp->magic != LEAF_mldSnoopMulticastDataDrop)
            {
               if(SWCTRL_POM_GetNextLogicalPort(&lport)== SWCTRL_LPORT_UNKNOWN_PORT)
                 return NULL;

               if(FALSE == MLDSNP_PMGR_GetInfStatistics(lport, FALSE, &statistics))
                 return NULL;
            }
        }
    }

    memcpy(name, vp->name, vp->namelen * sizeof(oid));

    /* assign data to the oid index
     */
    best_inst[0] = lport;
    memcpy(name + vp->namelen, best_inst, MLDSNOOPPORTENTRY_INSTANCE_LEN * sizeof(oid));
    *length = vp->namelen + MLDSNOOPPORTENTRY_INSTANCE_LEN;

    switch (vp->magic)
    {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case LEAF_mldSnoopPortIndex:
            *var_len = sizeof(long_return);
            long_return =lport;
            return (u_char *) &long_return;
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */
#if (SYS_CPNT_MLDSNP_QUERY_DROP == TRUE)
        case LEAF_mldSnoopQueryDrop:
            *var_len = sizeof(long_return);
            long_return =status;
            return (u_char *) &long_return;
#endif
#if (SYS_CPNT_IPV6_MULTICAST_DATA_DROP== TRUE)
        case LEAF_mldSnoopMulticastDataDrop:
            *var_len = sizeof(long_return);
            long_return =status;
            return (u_char *) &long_return;
#endif
        case LEAF_mldSnoopPortNumGroups:
            *var_len = sizeof(long_return);
            long_return = statistics.counter.num_grecs;
            return (u_char *) &long_return;

        case LEAF_mldSnoopPortNumJoinSend:
            *var_len = sizeof(long_return);
            long_return = statistics.counter.num_joins_send;
            return (u_char *) &long_return;

        case LEAF_mldSnoopPortNumJoins:
            *var_len = sizeof(long_return);
            long_return = statistics.counter.num_joins;
            return (u_char *) &long_return;

        case LEAF_mldSnoopPortNumJoinSuccess:
            *var_len = sizeof(long_return);
            long_return = statistics.counter.num_joins_succ;
            return (u_char *) &long_return;

        case LEAF_mldSnoopPortNumLeavesSend:
            *var_len = sizeof(long_return);
            long_return = statistics.counter.num_leaves_send;
            return (u_char *) &long_return;

        case LEAF_mldSnoopPortNumLeaves:
            *var_len = sizeof(long_return);
            long_return = statistics.counter.num_leaves;
            return (u_char *) &long_return;

        case LEAF_mldSnoopPortNumGeneralQuerySend:
            *var_len = sizeof(long_return);
            long_return = statistics.counter.num_gq_send;
            return (u_char *) &long_return;

        case LEAF_mldSnoopPortNumGeneralQueryRecevied:
            *var_len = sizeof(long_return);
            long_return = statistics.counter.num_gq_recv;
            return (u_char *) &long_return;

        case LEAF_mldSnoopPortNumSepcificQuerySend:
            *var_len = sizeof(long_return);
            long_return = statistics.counter.num_sq_send;
            return (u_char *) &long_return;

        case LEAF_mldsnoopPortNumSpecificQueryReceived:
            *var_len = sizeof(long_return);
            long_return = statistics.counter.num_sq_recv;
            return (u_char *) &long_return;

        case LEAF_mldSnoopPortNumInvalidReport:
            *var_len = sizeof(long_return);
            long_return = statistics.counter.num_invalid_mld_recv;
            return (u_char *) &long_return;

        case LEAF_mldSnoopPortClearStatistics:
            *var_len = sizeof(long_return);
            long_return = FALSE;
            return (u_char *) &long_return;

        default:
            ERROR_MSG("");
    }

    return NULL;
}

#if(SYS_CPNT_MLDSNP_QUERY_DROP == TRUE )
int write_mldSnoopQueryDrop(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    /* dispatch action
     */
    switch (action)
    {
        case RESERVE1:
            /* check type and length
             */
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            /* check valid values
             */
            switch (*(long *) var_val)
            {
                case VAL_mldSnoopQueryDrop_enable:
                    break;

                case VAL_mldSnoopQueryDrop_disable:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            I32_T value = 0;

            /* table-specific variables
             */
            UI32_T mldSnoopPortIndex = 0;

            /* extract index
             */
            if (! mldSnoopPortTable_OidIndexToData(TRUE,
                name_len - oid_name_length,
                &(name[oid_name_length]),
                &mldSnoopPortIndex))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            /* get user value
             */
            value = *(long *)var_val;

            /* set to core layer
             */
            if (MLDSNP_TYPE_RETURN_SUCCESS != MLDSNP_PMGR_SetQueryDropStatus(mldSnoopPortIndex, value) )
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    /* return success
     */
    return SNMP_ERR_NOERROR;
}
#endif

#if(SYS_CPNT_IPV6_MULTICAST_DATA_DROP == TRUE)
int write_mldSnoopMulticastDataDrop(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    /* dispatch action
     */
    switch (action)
    {
        case RESERVE1:
            /* check type and length
             */
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            /* check valid values
             */
            switch (*(long *) var_val)
            {
                case VAL_mldSnoopMulticastDataDrop_enable:
                    break;

                case VAL_mldSnoopMulticastDataDrop_disable:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            I32_T value = 0;

            /* table-specific variables
             */
            UI32_T mldSnoopPortIndex = 0;

            /* extract index
             */
            if (! mldSnoopPortTable_OidIndexToData(TRUE,
                name_len - oid_name_length,
                &(name[oid_name_length]),
                &mldSnoopPortIndex))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            /* get user value
             */
            value = *(long *)var_val;

            /* set to core layer
             */
            if (MLDSNP_TYPE_RETURN_SUCCESS != MLDSNP_PMGR_SetMulticastDataDropStatus(mldSnoopPortIndex, value) )
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    /* return success
     */
    return SNMP_ERR_NOERROR;
}
#endif

int write_mldSnoopPortClearStatistics(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    /* dispatch action
     */
    switch (action)
    {
        case RESERVE1:
            /* check type and length
             */
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            /* check valid values
             */
            switch (*(long *) var_val)
            {
                case VAL_mldSnoopPortClearStatistics_true:
                    break;

                case VAL_mldSnoopPortClearStatistics_false:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            I32_T value = 0;

            /* table-specific variables
             */
            UI32_T mldSnoopPortIndex = 0;

            /* extract index
             */
            if (! mldSnoopPortTable_OidIndexToData(TRUE,
                name_len - oid_name_length,
                &(name[oid_name_length]),
                &mldSnoopPortIndex))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            /* get user value
             */
            value = *(long *)var_val;

            /* set to core layer
             */
            if (! MLDSNP_PMGR_Clear_Ipv6_Mld_snooping_Statistics(mldSnoopPortIndex) )
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    /* return success
     */
    return SNMP_ERR_NOERROR;
}

#if(SYS_CPNT_MLDSNP_PROXY == TRUE)
int do_mldSnoopProxyReporting(netsnmp_mib_handler *handler,
    netsnmp_handler_registration *reginfo,
    netsnmp_agent_request_info *reqinfo,
    netsnmp_request_info *requests)
{
    /* dispatch get vs. set
     */
    switch (reqinfo->mode)
    {
        /* GET REQUEST
         */
        case MODE_GET:
        {
            MLDSNP_TYPE_ProxyReporting_T status;
            /* get from core layer
             */
            if (! MLDSNP_POM_GetProxyReporting(&status))
            {
                return SNMP_ERR_GENERR;
            }
            else
            {
                long_return = status;
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                    (u_char *) &long_return, sizeof(long_return));
            }

            break;
        }

        /* SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            /* check type and length
             */
            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
                return SNMP_ERR_NOERROR;
            }

            break;

        case MODE_SET_RESERVE2:
            switch (*requests->requestvb->val.integer)
            {
                case VAL_mldSnoopProxyReporting_enabled:
                    break;

                case VAL_mldSnoopProxyReporting_disabled:
                    break;

                default:
                    netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
                    return SNMP_ERR_NOERROR;
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called.
             */
            break;

        case MODE_SET_ACTION:
        {
            /* set to core layer
             */
            if (MLDSNP_TYPE_RETURN_FAIL == MLDSNP_PMGR_SetMldSnoopProxyReporting(*requests->requestvb->val.integer))
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
                return SNMP_ERR_NOERROR;
            }

            break;
        }

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int do_mldSnoopUnsolicitedReportInterval(netsnmp_mib_handler *handler,
    netsnmp_handler_registration *reginfo,
    netsnmp_agent_request_info *reqinfo,
    netsnmp_request_info *requests)
{
    /* dispatch get vs. set
     */
    switch (reqinfo->mode)
    {
        /* GET REQUEST
         */
        case MODE_GET:
        {
            UI32_T value = 0;

            /* get from core layer
             */
            if (! MLDSNP_POM_GetUnsolicitedReportInterval(&value))
            {
                return SNMP_ERR_GENERR;
            }
            else
            {
                long_return = value;
                snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED,
                    (u_char *) &long_return, sizeof(long_return));
            }

            break;
        }

        /* SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            /* check type and length
             */
            if (requests->requestvb->type != ASN_UNSIGNED)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
                return SNMP_ERR_NOERROR;
            }

            break;

        case MODE_SET_RESERVE2:
            if ((*requests->requestvb->val.integer < MIN_mldSnoopUnsolicitedReportInterval)
                || (*requests->requestvb->val.integer > MAX_mldSnoopUnsolicitedReportInterval))
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
                return SNMP_ERR_NOERROR;
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called.
             */
            break;

        case MODE_SET_ACTION:
        {
            /* set to core layer
             */
            if (MLDSNP_TYPE_RETURN_SUCCESS != MLDSNP_PMGR_SetUnsolicitedReportInterval(*requests->requestvb->val.integer))
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
                return SNMP_ERR_NOERROR;
            }

            break;
        }

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

#endif /*SYS_CPNT_MLDSNP_PROXY == TRUE*/


int do_mldSnoopClearDynamicGroups(netsnmp_mib_handler *handler,
    netsnmp_handler_registration *reginfo,
    netsnmp_agent_request_info *reqinfo,
    netsnmp_request_info *requests)
{
    /* dispatch get vs. set
     */
    switch (reqinfo->mode)
    {
        /* GET REQUEST
         */
        case MODE_GET:
        {
            /* get from core layer
             */
            {
                long_return = FALSE;
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                    (u_char *) &long_return, sizeof(long_return));
            }

            break;
        }

        /* SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            /* check type and length
             */
            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
                return SNMP_ERR_NOERROR;
            }

            break;

        case MODE_SET_RESERVE2:
            switch (*requests->requestvb->val.integer)
            {
                case VAL_mldSnoopClearDynamicGroups_true:
                    break;

                case VAL_mldSnoopClearDynamicGroups_false:
                    break;

                default:
                    netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
                    return SNMP_ERR_NOERROR;
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called.
             */
            break;

        case MODE_SET_ACTION:
        {
            /* set to core layer
             */
            if(*requests->requestvb->val.integer == VAL_mldSnoopClearDynamicGroups_true)
            {
              if (! MLDSNP_PMGR_ClearMldSnoopingDynamicgGroup())
              {
                  netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
                  return SNMP_ERR_NOERROR;
              }
            }
            break;
        }

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

#define MLDSNOOPVLANENTRY_INSTANCE_LEN  1

BOOL_T mldSnoopVlanTable_OidIndexToData(UI32_T exact, UI32_T compc,
    oid *compl, UI32_T *mldSnoopVlanIndex)
{
    /* get or set
     */
    if (exact)
    {
        /* check the index length
         */
        if (compc != MLDSNOOPVLANENTRY_INSTANCE_LEN)  /* the constant size index */
        {
            return FALSE;
        }
    }

    *mldSnoopVlanIndex = compl[0];

    return TRUE;
}

/*
 * var_mldSnoopVlanTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *var_mldSnoopVlanTable(struct variable *vp,
    oid *name,
    size_t *length,
    int exact,
    size_t *var_len,
    WriteMethod **write_method)
{
    UI32_T compc = 0;
    oid compl[MLDSNOOPVLANENTRY_INSTANCE_LEN] = {0};
    oid best_inst[MLDSNOOPVLANENTRY_INSTANCE_LEN] = {0};

    /* table-specific variables
     */
    MLDSNP_MGR_InfStat_T entry;
    UI32_T vid;

    /* dispatch node to set write method
     */
    switch (vp->magic)
    {
        case LEAF_mldSnoopVlanClearStatistics:
            *write_method = write_mldSnoopVlanClearStatistics;
            break;

        default:
            *write_method = 0;
            break;
    }

    /* check compc, retrive compl
     */
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl,
        MLDSNOOPVLANENTRY_INSTANCE_LEN);

    memset(&entry, 0, sizeof(entry));

    /* dispatch get-exact versus get-next
     */
    if (exact)  /* get or set */
    {
        /* extract index
         */
        if (! mldSnoopVlanTable_OidIndexToData(exact, compc, compl,
            &vid))
        {
            return NULL;
        }

        /* get-exact from core layer
         */
        if (! MLDSNP_PMGR_GetInfStatistics(vid, TRUE, &entry))
        {
            return NULL;
        }
    }
    else  /* get-next */
    {
        /* extract index
         */
        mldSnoopVlanTable_OidIndexToData(exact, compc, compl,
            &vid);

        /* Check the length of inputing index.  If compc is less than the
         * instance length, we should try get {A.B.C.0.0...}, where A.B.C was
         * obtained from the "..._OidIndexToData" function call, and
         * 0.0... was initialized in the beginning of this function.
         * This instance may exist in the core layer.
         */
        if (compc < MLDSNOOPVLANENTRY_INSTANCE_LEN)  /* incomplete index */
        {
            /* get-exact, in case this instance exists
             */
            if (! MLDSNP_PMGR_GetInfStatistics(vid, TRUE, &entry))
            {
                /* get-next according to lexicographic order; if none, fail
                 */
                if(FALSE == VLAN_OM_GetNextVlanId(0, &vid))
                  return NULL;

                if (! MLDSNP_PMGR_GetInfStatistics(vid, TRUE, &entry))
                {
                    return NULL;
                }
            }
        }
        else   /* complete index */
        {
            /* get-next according to lexicographic order; if none, fail
             */
            if(FALSE == VLAN_OM_GetNextVlanId(0, &vid))
              return NULL;

            if (! MLDSNP_PMGR_GetInfStatistics(vid, TRUE, &entry))
            {
                return NULL;
            }
        }
    }

    /* copy base OID (without index) to output
     */
    memcpy(name, vp->name, vp->namelen * sizeof(oid));

    /* assign data to the OID index
     */
    best_inst[0] = vid;
    memcpy(name + vp->namelen, best_inst, MLDSNOOPVLANENTRY_INSTANCE_LEN * sizeof(oid));
    *length = vp->namelen + MLDSNOOPVLANENTRY_INSTANCE_LEN;

    /* dispatch node to read value
     */
    switch (vp->magic)
    {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case LEAF_mldSnoopVlanIndex:
            *var_len = sizeof(long_return);
            long_return = vid;
            return (u_char *) &long_return;
#endif  /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

        case LEAF_mldSnoopVlanNumGroups:
            *var_len = sizeof(long_return);
            long_return = entry.counter.num_grecs;
            return (u_char *) &long_return;

        case LEAF_mldSnoopVlanNumJoinSend:
            *var_len = sizeof(long_return);
            long_return = entry.counter.num_joins_send;
            return (u_char *) &long_return;

        case LEAF_mldSnoopVlanNumJoins:
            *var_len = sizeof(long_return);
            long_return = entry.counter.num_joins;
            return (u_char *) &long_return;

        case LEAF_mldSnoopVlanNumJoinSuccess:
            *var_len = sizeof(long_return);
            long_return = entry.counter.num_joins_succ;
            return (u_char *) &long_return;

        case LEAF_mldSnoopVlanNumLeavesSend:
            *var_len = sizeof(long_return);
            long_return = entry.counter.num_leaves_send;
            return (u_char *) &long_return;

        case LEAF_mldSnoopVlanNumLeaves:
            *var_len = sizeof(long_return);
            long_return = entry.counter.num_leaves;
            return (u_char *) &long_return;

        case LEAF_mldSnoopVlanNumGeneralQuerySend:
            *var_len = sizeof(long_return);
            long_return = entry.counter.num_gq_send;
            return (u_char *) &long_return;

        case LEAF_mldSnoopVlanNumGeneralQueryRecevied:
            *var_len = sizeof(long_return);
            long_return = entry.counter.num_gq_recv;
            return (u_char *) &long_return;

        case LEAF_mldSnoopVlanNumSepcificQuerySend:
            *var_len = sizeof(long_return);
            long_return = entry.counter.num_sq_send;
            return (u_char *) &long_return;

        case LEAF_mldsnoopVlanNumSpecificQueryReceived:
            *var_len = sizeof(long_return);
            long_return = entry.counter.num_sq_recv;
            return (u_char *) &long_return;

        case LEAF_mldSnoopVlanNumInvalidReport:
            *var_len = sizeof(long_return);
            long_return = entry.counter.num_invalid_mld_recv;
            return (u_char *) &long_return;

        case LEAF_mldSnoopVlanClearStatistics:
            *var_len = sizeof(long_return);
            long_return = FALSE;
            return (u_char *) &long_return;

        default:
            ERROR_MSG("");
            break;
    }

    /* return failure
     */
    return NULL;
}

int write_mldSnoopVlanClearStatistics(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    UI32_T ifindex;
    /* dispatch action
     */
    switch (action)
    {
        case RESERVE1:
            /* check type and length
             */
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            /* check valid values
             */
            switch (*(long *) var_val)
            {
                case VAL_mldSnoopVlanClearStatistics_true:
                    break;

                case VAL_mldSnoopVlanClearStatistics_false:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            I32_T value = 0;

            /* table-specific variables
             */
            UI32_T mldSnoopVlanIndex = 0;

            /* extract index
             */
            if (! mldSnoopVlanTable_OidIndexToData(TRUE,
                name_len - oid_name_length,
                &(name[oid_name_length]),
                &mldSnoopVlanIndex))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            /* get user value
             */
            value = *(long *)var_val;

            /* set to core layer
             */
            VLAN_VID_CONVERTTO_IFINDEX(value, ifindex);
            if (! MLDSNP_PMGR_Clear_Ipv6_Mld_snooping_Statistics(ifindex) )
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    /* return success
     */
    return SNMP_ERR_NOERROR;
}


#endif /* end of #if (SYS_CPNT_MLDSNP == TRUE) */

static int
userauth_table_index_get(
    struct variable *vp,
    oid * name,
    size_t * length, char *index_username,
    int exact)
{
    int result;
    int len,i;
    char index_temp[SYS_ADPT_MAX_USER_NAME_LEN + 1] = {0};

    result = snmp_oid_compare(name, *length, vp->name, (int) vp->namelen );
    len = *length - vp->namelen;
    memset(index_temp, 0, SYS_ADPT_MAX_USER_NAME_LEN + 1);

    if (exact)
    {
        /* Check the length.
         */
        if (result < 0 || len > SYS_ADPT_MAX_USER_NAME_LEN || len < 1)
            return -1;

        for(i = 0; i < len; i ++)
        {
            index_temp[i] = (UI8_T)name[vp->namelen + i];
        }

        memcpy(index_username, index_temp, len);

        return 0;
    }
    else
    /* GETNEXT request
     */
    {
        /* Check the length. River@Aug 23, 2007.
         */
        if (len > SYS_ADPT_MAX_USER_NAME_LEN)
            return -1;

        if (result >= 0)
        {
            /* use index value if present, otherwise 0.
             */
            if (len >= 1)
            {

                for(i = 0; i < len; i ++)
                {
                    index_temp[i] = (UI8_T)name[vp->namelen + i];
                }

                memcpy(index_username, index_temp, strlen(index_temp));
            }

            return 0;
        }
        else
        {
            /* set the user's oid to be ours
             */
            memcpy((char*)name, (char *)vp->name, ((int) vp->namelen) * sizeof (oid));

            return 0;
        }
    }

    return -1;
}

void
userauth_table_index_set (
    struct variable *v,
    oid *name,
    size_t *length,
    char *index)
{
    int i;
    oid temp_index[MAX_OID_LEN] = {0};

    memcpy (name, v->name, (v->namelen)* sizeof (oid));

    for (i = 0; i < (int)strlen(index); i ++)
    {
        temp_index[i] = index[i];
    }

    memcpy (name + v->namelen, temp_index, strlen(index)* sizeof (oid));

    *length = v->namelen + strlen(index);

    return;
}

/* Callback function for userAuthTable
 */
unsigned char  *
var_userAuthTable(
    struct variable *vp,
    oid * name,
    size_t * length,
    int exact,
    size_t * var_len,
    WriteMethod ** write_method)
{
    USERAUTH_LoginLocal_T  entry;
    char index_username[SYS_ADPT_MAX_USER_NAME_LEN + 1] = {0};
    int ret;
    BOOL_T return_val;
#if 0
    #if(AMS_SYS_CPNT_SSH2 == TRUE)
    UI32_T key_type;
    char keytype[20] = {0};
    #endif
#endif

    memset(&entry, 0, sizeof(USERAUTH_LoginLocal_T));
    ret = userauth_table_index_get (vp, name, length, index_username, exact);

    if (ret < 0)
    {
        return NULL;
    }

    switch (vp->magic)
    {
        case USERAUTHPASSWORD:
            *write_method = (WriteMethod *)write_userAuthPassword;
            break;

        case USERAUTHPRIVILEGE:
            *write_method = (WriteMethod *)write_userAuthPrivilege;
            break;

        case USERAUTHSTATUS:
            *write_method = (WriteMethod *)write_userAuthStatus;
            break;

        default:
            break;
    }

    memcpy(entry.username,index_username,SYS_ADPT_MAX_USER_NAME_LEN + 1);

    if (!exact)
    {
        return_val = USERAUTH_PMGR_GetNextLoginLocalUser(&entry);

        if (return_val != TRUE)
        {
            return NULL;
        }

        memcpy(index_username, entry.username, SYS_ADPT_MAX_USER_NAME_LEN + 1);
    }
    else
    {
        if (!USERAUTH_PMGR_GetLoginLocalUser(&entry))
        {
            return NULL;
        }
    }

    if (!exact)
    {
        userauth_table_index_set(vp, name, length, index_username);
    }

    switch (vp->magic)
    {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case USERAUTHUSERNAME:
            memcpy(return_buf, index_username, SYS_ADPT_MAX_USER_NAME_LEN + 1);
            *var_len = strlen(return_buf);

            return( u_char *) return_buf;
            break;
#endif
        case USERAUTHPASSWORD:
            memset(return_buf, '*', SYS_ADPT_MAX_PASSWORD_LEN);
            *var_len = strlen((char *)return_buf);

            return( u_char *) return_buf;
            break;

        case USERAUTHPRIVILEGE:
            *var_len = sizeof(long_return);
            long_return = entry.privilege;

            return (u_char*)&long_return;
            break;
#if 0
        case ACCTSUERAUTHPUBLICKEY:
            AMS_SSHD_MGR_GetUserPublicKeyType(ua_user->name, vr_id, &key_type);

            switch(key_type)
            {
                case  KEY_TYPE_RSA:
                    strlcpy(keytype, "RSA", strlen("RSA") + 1);
                    break;
                case  KEY_TYPE_DSA:
                    strlcpy(keytype, "DSA", strlen("DSA") + 1);
                    break;
                case  KEY_TYPE_BOTH_RSA_AND_DSA:
                    strlcpy(keytype, "Both", strlen("Both") + 1);
                    break;
                default:
                    strlcpy(keytype, "None", strlen("None") + 1);
                    break;
            }

            memcpy(return_buf, keytype, strlen(keytype) + 1);
            *var_len = strlen(return_buf);

            return( u_char *) return_buf;
            break;
#endif
        case USERAUTHSTATUS:
            long_return = entry.status;
            *var_len = sizeof(long_return);

            return (u_char*)&long_return;
            break;

        default:
            break;
    }

    return NULL;
}

int
write_userAuthPassword(
    int action,
    u_char * var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char * statP,
    oid * name,
    size_t name_len)
{
    int i;
    UI8_T buffer[SYS_ADPT_MAX_USER_NAME_LEN + 1] = {0};
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    USERAUTH_LoginLocal_T  entry;

    if (name_len - oid_name_length > SYS_ADPT_MAX_USER_NAME_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    for (i = 0; i < name_len - oid_name_length ; i ++)
    {
        buffer[i] = name[oid_name_length + i];
    }

    buffer[name_len - oid_name_length] = '\0';

    switch ( action )
    {
        case RESERVE1:
            if (var_val_type != ASN_OCTET_STR)
            {
                return SNMP_ERR_WRONGTYPE;
            }

            if (var_val_len > SYS_ADPT_MAX_PASSWORD_LEN)
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;

        case RESERVE2:
            break;

        case FREE:
            /* Release any resources that have been allocated
             */
            break;

        case ACTION:
        {
            UI8_T  password[SYS_ADPT_MAX_ENCRYPTED_PASSWORD_LEN + 1] = {0};

            memset(password, 0, sizeof(password));
            L_MD5_MDString(password, var_val, var_val_len);
            memset(&entry, 0, sizeof(USERAUTH_LoginLocal_T));
            memcpy(entry.username,buffer,SYS_ADPT_MAX_USER_NAME_LEN + 1);

            if (!USERAUTH_PMGR_GetLoginLocalUser(&entry))
                if(!USERAUTH_PMGR_SetLoginLocalUserStatus(buffer, USERAUTH_ENTRY_VALID)) /*create user*/
                {
                    return SNMP_ERR_COMMITFAILED;
                }

            if (!USERAUTH_PMGR_SetLoginLocalUserPassword(buffer, password))
                return SNMP_ERR_COMMITFAILED;

        }
            break;
        case UNDO:
            /* Back out any changes made in the ACTION case
             */
            break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
            break;
    }

    return SNMP_ERR_NOERROR;
}


int
write_userAuthPrivilege(
    int action,
    u_char * var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char * statP,
    oid * name,
    size_t name_len)
{
    long value,i;
    UI8_T buffer[SYS_ADPT_MAX_USER_NAME_LEN + 1] = {0};
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    USERAUTH_LoginLocal_T  entry;
    UI8_T encrypted_empty_password[SYS_ADPT_MAX_ENCRYPTED_PASSWORD_LEN + 1];
    UI8_T plain_empty_password[1 + 1];

    memset(plain_empty_password, 0, sizeof(plain_empty_password));
    memset(encrypted_empty_password, 0, sizeof(encrypted_empty_password));
    L_MD5_MDString(encrypted_empty_password, plain_empty_password, strlen((char *)plain_empty_password));

    if (name_len - oid_name_length > SYS_ADPT_MAX_USER_NAME_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    for (i = 0; i < name_len - oid_name_length ; i ++)
    {
        buffer[i] = name[oid_name_length + i];
    }

    buffer[name_len - oid_name_length] = '\0';
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }

            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }

            break;
        case RESERVE2:
            value = *(long *)var_val;

#if (SYS_CPNT_CLI_MULTI_PRIVILEGE_LEVEL == TRUE)
            if (value < MIN_userPrivilege || value > SYS_ADPT_MAX_LOGIN_PRIVILEGE)
            {
                return SNMP_ERR_WRONGVALUE;
            }
#else
            if ((value != MIN_userPrivilege) && (value != SYS_ADPT_MAX_LOGIN_PRIVILEGE))
                return SNMP_ERR_WRONGVALUE;
#endif

            break;
        case FREE:
            break;

        case ACTION:
        {
            value = *(long *)var_val;

            memset(&entry, 0, sizeof(USERAUTH_LoginLocal_T));
            memcpy(entry.username,buffer,SYS_ADPT_MAX_USER_NAME_LEN + 1);
            if (!USERAUTH_PMGR_GetLoginLocalUser(&entry))
                if(!USERAUTH_PMGR_SetLoginLocalUserStatus(buffer, USERAUTH_ENTRY_VALID)) /*create user*/
                {
                    return SNMP_ERR_COMMITFAILED;
                }

            if (!USERAUTH_PMGR_SetLoginLocalUserPrivilege(buffer, value))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            if (!USERAUTH_PMGR_SetLoginLocalUserPassword(buffer, encrypted_empty_password))
            {
                return SNMP_ERR_COMMITFAILED;
            }
        }
            break;

        case UNDO:
            /*
             * Back out any changes made in the ACTION case
             */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }

    return SNMP_ERR_NOERROR;
}


int
write_userAuthStatus(
    int action,
    u_char * var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char * statP,
    oid * name,
    size_t name_len)
{
    long value, i;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    UI8_T buffer[SYS_ADPT_MAX_USER_NAME_LEN + 1] = {0};
    UI8_T encrypted_empty_password[SYS_ADPT_MAX_ENCRYPTED_PASSWORD_LEN + 1];
    UI8_T plain_empty_password[1 + 1];

    memset(plain_empty_password, 0, sizeof(plain_empty_password));
    memset(encrypted_empty_password, 0, sizeof(encrypted_empty_password));
    L_MD5_MDString(encrypted_empty_password, plain_empty_password, strlen((char *)plain_empty_password));

    if (name_len-oid_name_length > SYS_ADPT_MAX_USER_NAME_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    for (i = 0; i < name_len-oid_name_length ; i ++)
    {
        buffer[i] = name[oid_name_length + i];
    }

    buffer[name_len - oid_name_length] = '\0';

    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }

            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }

            break;
        case RESERVE2:
            value = *(long *)var_val;

            if ((value != VAL_userAuthDelete) && (value != VAL_userAuthCreate))
                return SNMP_ERR_WRONGVALUE;

            break;
        case FREE:
            break;
        case ACTION:
        {
            value = *(long *)var_val;

            if(!USERAUTH_PMGR_SetLoginLocalUserStatus(buffer, value)) /*create user*/
            {
                return SNMP_ERR_COMMITFAILED;
            }
            if (!USERAUTH_PMGR_SetLoginLocalUserPassword(buffer, encrypted_empty_password))
            {
                return SNMP_ERR_COMMITFAILED;
            }
        }
            break;

        case UNDO:
            /*
             * Back out any changes made in the ACTION case
             */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }

    return SNMP_ERR_NOERROR;
}

int
do_enablePassword(netsnmp_mib_handler *handler,
             netsnmp_handler_registration *reginfo,
             netsnmp_agent_request_info *reqinfo,
             netsnmp_request_info *requests)
{
    UI8_T  password_encryt[SYS_ADPT_MAX_ENCRYPTED_PASSWORD_LEN+1] = {0};
    UI8_T  password_plain[SYS_ADPT_MAX_PASSWORD_LEN + 1] = {0};
    UI32_T var_len=0;

    switch(reqinfo->mode) {
        case MODE_GET:
        {
            memset(return_buf, '*', SYS_ADPT_MAX_PASSWORD_LEN);
            var_len = SYS_ADPT_MAX_PASSWORD_LEN;
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR , (u_char *)return_buf , var_len );
            break;
        }

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            if (requests->requestvb->type != ASN_OCTET_STR)
            {
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
            }
            if (requests->requestvb->val_len > SYS_ADPT_MAX_PASSWORD_LEN)
            {
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGLENGTH);
            }
            break;

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
        {
            memset(password_encryt, 0, sizeof(password_encryt));
            memset(password_plain, 0, sizeof(password_plain));

            if ((requests->requestvb->val_len == 0)&&(password_plain[0] == 0))
                memcpy(password_plain,"super",5);
            else
                memcpy(password_plain,requests->requestvb->val.string,requests->requestvb->val_len);

            L_MD5_MDString(password_encryt,password_plain, strlen((char *)password_plain));

            if (!USERAUTH_PMGR_SetPrivilegePassword(MAX_userPrivilege, password_encryt))
            {
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
            }
            else if (!USERAUTH_PMGR_SetPrivilegePasswordStatus(MAX_userPrivilege,USERAUTH_ENTRY_VALID))
            {
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
            }
            break;
        }

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}


int
do_authMethod (netsnmp_mib_handler *handler,
             netsnmp_handler_registration *reginfo,
             netsnmp_agent_request_info *reqinfo,
             netsnmp_request_info *requests)
{
    int value;
    //UI8_T  password[SYS_ADPT_MAX_PASSWORD_LEN+1] = {0};
    USERAUTH_Auth_Method_T       auth_method[5] = {0};

    switch(reqinfo->mode) {
        case MODE_GET:
        {
            USERAUTH_PMGR_GetAuthMethod(auth_method);
            if(auth_method[0] == USERAUTH_AUTH_LOCAL && auth_method[1] == USERAUTH_AUTH_NONE)
                long_return = 1;
            else if(auth_method[0] == USERAUTH_AUTH_LOCAL && auth_method[1] == USERAUTH_AUTH_RADIUS && auth_method[2] == USERAUTH_AUTH_NONE)
                long_return = 2;
            else if(auth_method[0] == USERAUTH_AUTH_LOCAL && auth_method[1] == USERAUTH_AUTH_RADIUS && auth_method[2] == USERAUTH_AUTH_TACACS)
                long_return = 3;
            else if(auth_method[0] == USERAUTH_AUTH_LOCAL && auth_method[1] == USERAUTH_AUTH_TACACS && auth_method[2] == USERAUTH_AUTH_NONE)
                long_return = 4;
            else if(auth_method[0] == USERAUTH_AUTH_LOCAL && auth_method[1] == USERAUTH_AUTH_TACACS && auth_method[2] == USERAUTH_AUTH_RADIUS)
                long_return = 5;
            else if(auth_method[0] == USERAUTH_AUTH_RADIUS && auth_method[1] == USERAUTH_AUTH_NONE && auth_method[2] == USERAUTH_AUTH_NONE)
                long_return = 6;
            else if(auth_method[0] == USERAUTH_AUTH_RADIUS && auth_method[1] == USERAUTH_AUTH_LOCAL && auth_method[2] == USERAUTH_AUTH_NONE)
                long_return = 7;
            else if(auth_method[0] == USERAUTH_AUTH_RADIUS && auth_method[1] == USERAUTH_AUTH_LOCAL && auth_method[2] == USERAUTH_AUTH_TACACS)
                long_return = 8;
            else if(auth_method[0] == USERAUTH_AUTH_RADIUS && auth_method[1] == USERAUTH_AUTH_TACACS && auth_method[2] == USERAUTH_AUTH_NONE)
                long_return = 9;
            else if(auth_method[0] == USERAUTH_AUTH_RADIUS && auth_method[1] == USERAUTH_AUTH_TACACS && auth_method[2] == USERAUTH_AUTH_LOCAL)
                long_return = 10;
            else if(auth_method[0] == USERAUTH_AUTH_TACACS && auth_method[1] == USERAUTH_AUTH_NONE && auth_method[2] == USERAUTH_AUTH_NONE)
                long_return = 11;
            else if(auth_method[0] == USERAUTH_AUTH_TACACS && auth_method[1] == USERAUTH_AUTH_LOCAL && auth_method[2] == USERAUTH_AUTH_NONE)
                long_return = 12;
            else if(auth_method[0] == USERAUTH_AUTH_TACACS && auth_method[1] == USERAUTH_AUTH_LOCAL && auth_method[2] == USERAUTH_AUTH_RADIUS)
                long_return = 13;
            else if(auth_method[0] == USERAUTH_AUTH_TACACS && auth_method[1] == USERAUTH_AUTH_RADIUS && auth_method[2] == USERAUTH_AUTH_NONE)
                long_return = 14;
            else if(auth_method[0] == USERAUTH_AUTH_TACACS && auth_method[1] == USERAUTH_AUTH_RADIUS && auth_method[2] == USERAUTH_AUTH_LOCAL)
                long_return = 15;

            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER , (u_char *)&long_return , sizeof(long_return) );
        }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGTYPE);
            }
            break;
        case MODE_SET_RESERVE2:
            if (*requests->requestvb->val.integer< MIN_userAuthMethod ||*requests->requestvb->val.integer > MAX_userAuthMethod)
            {
               netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_WRONGVALUE);
            }

            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
        {
           value = *requests->requestvb->val.integer;
           if(value == 1)
            {
                auth_method[0] = USERAUTH_AUTH_LOCAL;
                auth_method[1] = USERAUTH_AUTH_NONE;
                auth_method[2] = USERAUTH_AUTH_NONE;
            }
            if(value == 2)
            {
                auth_method[0] = USERAUTH_AUTH_LOCAL;
                auth_method[1] = USERAUTH_AUTH_RADIUS;
                auth_method[2] = USERAUTH_AUTH_NONE;
            }
            else if(value == 3)
            {
                auth_method[0] = USERAUTH_AUTH_LOCAL;
                auth_method[1] = USERAUTH_AUTH_RADIUS;
                auth_method[2] = USERAUTH_AUTH_TACACS;
            }
            else if(value == 4)
            {
                auth_method[0] = USERAUTH_AUTH_LOCAL;
                auth_method[1] = USERAUTH_AUTH_TACACS;
                auth_method[2] = USERAUTH_AUTH_NONE;
            }
            else if(value == 5)
            {
                auth_method[0] = USERAUTH_AUTH_LOCAL;
                auth_method[1] = USERAUTH_AUTH_TACACS;
                auth_method[2] = USERAUTH_AUTH_RADIUS;
            }

            else if(value == 6)
            {
                auth_method[0] = USERAUTH_AUTH_RADIUS;
                auth_method[1] = USERAUTH_AUTH_NONE;
                auth_method[2] = USERAUTH_AUTH_NONE;
            }
            else if(value == 7)
            {
                auth_method[0] = USERAUTH_AUTH_RADIUS;
                auth_method[1] = USERAUTH_AUTH_LOCAL;
                auth_method[2] = USERAUTH_AUTH_NONE;
            }
            else if(value == 8)
            {
                auth_method[0] = USERAUTH_AUTH_RADIUS;
                auth_method[1] = USERAUTH_AUTH_LOCAL;
                auth_method[2] = USERAUTH_AUTH_TACACS;
            }
            else if(value == 9)
            {
                auth_method[0] = USERAUTH_AUTH_RADIUS;
                auth_method[1] = USERAUTH_AUTH_TACACS;
                auth_method[2] = USERAUTH_AUTH_NONE;
            }
            else if(value == 10)
            {
                auth_method[0] = USERAUTH_AUTH_RADIUS;
                auth_method[1] = USERAUTH_AUTH_TACACS;
                auth_method[2] = USERAUTH_AUTH_LOCAL;
            }

            else if(value == 11)
            {
                auth_method[0] = USERAUTH_AUTH_TACACS;
                auth_method[1] = USERAUTH_AUTH_NONE;
                auth_method[2] = USERAUTH_AUTH_NONE;
            }
            else if(value == 12)
            {
                auth_method[0] = USERAUTH_AUTH_TACACS;
                auth_method[1] = USERAUTH_AUTH_LOCAL;
                auth_method[2] = USERAUTH_AUTH_NONE;
            }
            else if(value == 13)
            {
                auth_method[0] = USERAUTH_AUTH_TACACS;
                auth_method[1] = USERAUTH_AUTH_LOCAL;
                auth_method[2] = USERAUTH_AUTH_RADIUS;
            }
            else if(value == 14)
            {
                auth_method[0] = USERAUTH_AUTH_TACACS;
                auth_method[1] = USERAUTH_AUTH_RADIUS;
                auth_method[2] = USERAUTH_AUTH_NONE;
            }
            else if(value == 15)
            {
                auth_method[0] = USERAUTH_AUTH_TACACS;
                auth_method[1] = USERAUTH_AUTH_RADIUS;
                auth_method[2] = USERAUTH_AUTH_LOCAL;
            }
            if(! USERAUTH_PMGR_SetAuthMethod(auth_method))
            {
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
            }
        }
            break;

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

#if (SYS_CPNT_UDP_HELPER == TRUE)
int do_udpHelperStatus(netsnmp_mib_handler *handler,
    netsnmp_handler_registration *reginfo,
    netsnmp_agent_request_info *reqinfo,
    netsnmp_request_info *requests)
{
    switch (reqinfo->mode)
    {
        case MODE_GET:
            {
                UI32_T value;

                if (UDPHELPER_PMGR_GetStatus(&value) == UDPHELPER_TYPE_RESULT_SUCCESS)
                {
                    long_return = (value == TRUE) ? VAL_udpHelperStatus_enabled : VAL_udpHelperStatus_disabled;
                    snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *)&long_return, sizeof(long_return));
                }
                else
                {
                    return SNMP_ERR_GENERR;
                }

                break;
            }

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
            }
            break;

        case MODE_SET_RESERVE2:
            switch (*requests->requestvb->val.integer)
            {
                case VAL_udpHelperStatus_enabled:
                    break;

                case VAL_udpHelperStatus_disabled:
                    break;

                default:
                    netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called.
             */
            break;

        case MODE_SET_ACTION:
            {
                UI32_T value;

                value = (*requests->requestvb->val.integer == VAL_udpHelperStatus_enabled) ? TRUE : FALSE;

                if (UDPHELPER_PMGR_SetStatus(value) != UDPHELPER_TYPE_RESULT_SUCCESS)
                {
                    netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
                }

                break;
            }

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

#define UDPHELPERFORWARDPROTOCOLENTRY_INSTANCE_LEN  1

BOOL_T udpHelperForwardProtocolTable_OidIndexToData(UI32_T exact, UI32_T compc,
    oid *compl, UI32_T *port_p)
{
    /* get or set
     */
    if (exact)
    {
        /* check the index length
         */
        if (compc != UDPHELPERFORWARDPROTOCOLENTRY_INSTANCE_LEN) /* the constant size index */
        {
            return FALSE;
        }
    }

    *port_p = compl[0];

    return TRUE;
}

/*
 * var_udpHelperForwardProtocolTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *var_udpHelperForwardProtocolTable(struct variable *vp,
    oid *name,
    size_t *length,
    int exact,
    size_t *var_len,
    WriteMethod **write_method)
{
    UI32_T compc = 0;
    UI32_T port = 0;
    oid compl[UDPHELPERFORWARDPROTOCOLENTRY_INSTANCE_LEN] = {0};
    oid best_inst[UDPHELPERFORWARDPROTOCOLENTRY_INSTANCE_LEN] = {0};

    switch (vp->magic)
    {
        case LEAF_udpHelperForwardProtocolStatus:
            *write_method = write_udpHelperForwardProtocolStatus;
            break;

        default:
            *write_method = 0;
            break;
    }

    /* check compc, retrive compl
     */
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl, UDPHELPERFORWARDPROTOCOLENTRY_INSTANCE_LEN);

    if (exact) /* get or set */
    {
        if (udpHelperForwardProtocolTable_OidIndexToData(exact, compc, compl, &port) == FALSE)
        {
            return NULL;
        }

        if (UDPHELPER_PMGR_GetForwardPort(port) != UDPHELPER_TYPE_RESULT_SUCCESS)
        {
            return NULL;
        }
    }
    else /* getnext */
    {
        udpHelperForwardProtocolTable_OidIndexToData(exact, compc, compl, &port);

        /* check the length of inputing index,if < 1 we should try get
         * {0.0.0.0.0...}
         */
        if (compc < 1)
        {
            if (UDPHELPER_PMGR_GetForwardPort(port) != UDPHELPER_TYPE_RESULT_SUCCESS)
            {
                if (UDPHELPER_PMGR_GetNextForwardPort(&port) != UDPHELPER_TYPE_RESULT_SUCCESS)
                {
                    return NULL;
                }
            }
        }
        else
        {
            if (UDPHELPER_PMGR_GetNextForwardPort(&port) != UDPHELPER_TYPE_RESULT_SUCCESS)
            {
                return NULL;
            }
        }
    }

    memcpy(name, vp->name, vp->namelen * sizeof(oid));

    /* assign data to the oid index
     */
    best_inst[0] = port;
    memcpy(name + vp->namelen, best_inst, UDPHELPERFORWARDPROTOCOLENTRY_INSTANCE_LEN * sizeof(oid));
    *length = vp->namelen + UDPHELPERFORWARDPROTOCOLENTRY_INSTANCE_LEN;

    switch (vp->magic)
    {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case LEAF_udpHelperForwardProtocolPort:
            *var_len = sizeof(long_return);
            long_return = port;
            return (u_char *) &long_return;
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

        case LEAF_udpHelperForwardProtocolStatus:
            *var_len = sizeof(long_return);
            long_return = VAL_udpHelperForwardProtocolStatus_valid;
            return (u_char *) &long_return;

        default:
            ERROR_MSG("");
    }

    return NULL;
}

int write_udpHelperForwardProtocolStatus(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            switch (*(long *)var_val)
            {
                case VAL_udpHelperForwardProtocolStatus_valid:
                    break;

                case VAL_udpHelperForwardProtocolStatus_invalid:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            I32_T value = 0;
            UI32_T port = 0;

            if (udpHelperForwardProtocolTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &port) == FALSE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            value = *(long *)var_val;

            if (value == VAL_udpHelperForwardProtocolStatus_valid)
            {
                if (UDPHELPER_PMGR_AddForwardUdpPort(port) != UDPHELPER_TYPE_RESULT_SUCCESS)
                {
                    return SNMP_ERR_COMMITFAILED;
                }
            }
            else
            {
                if (UDPHELPER_PMGR_DelForwardUdpPort(port) != UDPHELPER_TYPE_RESULT_SUCCESS)
                {
                    return SNMP_ERR_COMMITFAILED;
                }
            }
        }
            break;

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

#define UDPHELPERINETADDRENTRY_INSTANCE_LEN  6

BOOL_T udpHelperInetAddrTable_OidIndexToData(UI32_T exact, UI32_T compc,
    oid *compl, UI32_T *vlan_index_p, L_INET_AddrIp_T *addr_p)
{
    UI32_T i;

    /* get or set
     */
    if (exact)
    {
        /* check the index length
         */
        if (compc != UDPHELPERINETADDRENTRY_INSTANCE_LEN) /* the constant size index */
        {
            return FALSE;
        }
    }

    *vlan_index_p = compl[0];

    if (VAL_udpHelperInetAddrType_ipv4 != compl[1])
    {
        return FALSE;
    }

    for (i = 0; i < 4; i++)
    {
        addr_p->addr[i] = compl[2 + i];
    }

    addr_p->addrlen = SYS_ADPT_IPV4_ADDR_LEN;
    addr_p->type = L_INET_ADDR_TYPE_IPV4;

    return TRUE;
}

static UI32_T udphelper_getnext_helper(UI32_T *vlan_index, L_INET_AddrIp_T *addr)
{
    NETCFG_TYPE_L3_Interface_T vlan_interface;
    UI32_T flag = FALSE;

    memset(&vlan_interface, 0, sizeof(NETCFG_TYPE_L3_Interface_T));
    vlan_interface.ifindex = *vlan_index;

    do
    {
        if(flag)
            memset(addr, 0, sizeof(L_INET_AddrIp_T));
        flag = TRUE;
        while (UDPHELPER_PMGR_GetNextHelper(vlan_interface.ifindex, addr) == UDPHELPER_TYPE_RESULT_SUCCESS)
        {
            *vlan_index = vlan_interface.ifindex;
            return UDPHELPER_TYPE_RESULT_SUCCESS;
        }
    }
    while (NETCFG_POM_IP_GetNextL3Interface(&vlan_interface) == NETCFG_TYPE_OK);

    return UDPHELPER_TYPE_RESULT_FAIL;
}

/*
 * var_udpHelperInetAddrTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *var_udpHelperInetAddrTable(struct variable *vp,
    oid *name,
    size_t *length,
    int exact,
    size_t *var_len,
    WriteMethod **write_method)
{
    UI32_T compc = 0;
    UI32_T vlan_index = 0;
    UI32_T i = 0;
    oid compl[UDPHELPERINETADDRENTRY_INSTANCE_LEN] = {0};
    oid best_inst[UDPHELPERINETADDRENTRY_INSTANCE_LEN] = {0};
    L_INET_AddrIp_T addr = {0};

    memset(&addr, 0, sizeof(addr));

    switch (vp->magic)
    {
        case LEAF_udpHelperInetAddrStatus:
            *write_method = write_udpHelperInetAddrStatus;
            break;

        default:
            *write_method = 0;
            break;
    }

    /* check compc, retrive compl
     */
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl, UDPHELPERINETADDRENTRY_INSTANCE_LEN);

    if (exact) /* get or set */
    {
        if (udpHelperInetAddrTable_OidIndexToData(exact, compc, compl, &vlan_index, &addr) == FALSE)
        {
            return NULL;
        }

        if (UDPHELPER_PMGR_GetHelper(vlan_index, &addr) != UDPHELPER_TYPE_RESULT_SUCCESS)
        {
            return NULL;
        }
    }
    else /* getnext */
    {
        udpHelperInetAddrTable_OidIndexToData(exact, compc, compl, &vlan_index, &addr);

        /* check the length of inputing index,if < 1 we should try get
         * {0.0.0.0.0...}
         */
        if (compc < 1)
        {
            if (UDPHELPER_PMGR_GetHelper(vlan_index, &addr) != UDPHELPER_TYPE_RESULT_SUCCESS)
            {
                if (udphelper_getnext_helper(&vlan_index, &addr) != UDPHELPER_TYPE_RESULT_SUCCESS)
                {
                    return NULL;
                }
            }
        }
        else
        {
            if (udphelper_getnext_helper(&vlan_index, &addr) != UDPHELPER_TYPE_RESULT_SUCCESS)
            {
                return NULL;
            }
        }
    }

    memcpy(name, vp->name, vp->namelen * sizeof(oid));

    /* assign data to the oid index
     */
    best_inst[0] = vlan_index;
    best_inst[1] = VAL_udpHelperInetAddrType_ipv4;

    for (i = 0; i < 4; i++)
    {
        best_inst[2 + i] = addr.addr[i];
    }
    memcpy(name + vp->namelen, best_inst, UDPHELPERINETADDRENTRY_INSTANCE_LEN * sizeof(oid));
    *length = vp->namelen + UDPHELPERINETADDRENTRY_INSTANCE_LEN;

    switch (vp->magic)
    {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case LEAF_udpHelperInetAddrIfIndex:
            *var_len = sizeof(long_return);
            long_return = vlan_index;
            return (u_char *) &long_return;
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case LEAF_udpHelperInetAddrType:
            *var_len = sizeof(long_return);
            long_return = VAL_udpHelperInetAddrType_ipv4;
            return (u_char *) &long_return;
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case LEAF_udpHelperInetAddr:
            *var_len = addr.addrlen;
            memcpy(return_buf, addr.addr, *var_len);
            return (u_char*)return_buf;
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

        case LEAF_udpHelperInetAddrStatus:
            *var_len = sizeof(long_return);
            long_return = VAL_udpHelperInetAddrStatus_valid;
            return (u_char *) &long_return;

        default:
            ERROR_MSG("");
    }

    return NULL;
}

int write_udpHelperInetAddrStatus(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            switch (*(long *)var_val)
            {
                case VAL_udpHelperInetAddrStatus_valid:
                    break;

                case VAL_udpHelperInetAddrStatus_invalid:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            I32_T value = 0;
            UI32_T vlan_index = 0;
            L_INET_AddrIp_T addr;

            memset(&addr, 0, sizeof(addr));

            if (udpHelperInetAddrTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &vlan_index, &addr) == FALSE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            value = *(long *)var_val;

            if (value == VAL_udpHelperInetAddrStatus_valid)
            {
                if (UDPHELPER_PMGR_AddHelperAddress(vlan_index, addr) != UDPHELPER_TYPE_RESULT_SUCCESS)
                {
                    return SNMP_ERR_COMMITFAILED;
                }
            }
            else
            {
                if (UDPHELPER_PMGR_DelHelperAddress(vlan_index, addr) != UDPHELPER_TYPE_RESULT_SUCCESS)
                {
                    return SNMP_ERR_COMMITFAILED;
                }
            }
        }
            break;

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}
#endif /* #if (SYS_CPNT_UDP_HELPER == TRUE) */

#if (SYS_CPNT_SYSMGMT_RESMIB == TRUE)
int
get_cpuCurrentUti(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    switch (reqinfo->mode)
    {
        case MODE_GET:
        {
            UI32_T value = 0;
            UI32_T usage_floag;

            if (SYS_PMGR_GetCpuUsagePercentage(&value, &usage_floag) == TRUE)
            {
                long_return = value;
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                         (u_char *)&long_return, sizeof(long_return));
            }
            else
            {
                return SNMP_ERR_GENERR;
            }
        }
            break;


        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
get_cpuStatMaxUti(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    switch (reqinfo->mode)
    {
        case MODE_GET:
        {
            UI32_T value = 0;

            if (SYS_PMGR_GetCpuUsageMaximum(&value) == TRUE)
            {
                long_return = value;
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                         (u_char *)&long_return, sizeof(long_return));
            }
            else
            {
                return SNMP_ERR_GENERR;
            }
        }
            break;


        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
get_cpuStatAvgUti(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    switch (reqinfo->mode)
    {
        case MODE_GET:
        {
            UI32_T value = 0;

            if (SYS_PMGR_GetCpuUsageAverage(&value) == TRUE)
            {
                long_return = value;
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                         (u_char *) &long_return, sizeof(long_return));
            }
            else
            {
                return SNMP_ERR_GENERR;
            }
        }
            break;


        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
get_cpuPeakTime(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    switch (reqinfo->mode)
    {
        case MODE_GET:
        {
            UI32_T value = 0;
            UI32_T var_len = 0;
            /* The pointer type must be consistent with the Core Layer API */
            if (SYS_PMGR_GetCpuUsagePeakTime(&value) == TRUE)
            {
                SYS_TIME_ConvertTime(value, (char *)return_buf);
                var_len = strlen((char *)return_buf);
                snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                         (u_char *) return_buf, var_len);
            }
            else
            {
                return SNMP_ERR_GENERR;
            }
        }
            break;


        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
get_cpuPeakDuration(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    switch (reqinfo->mode)
    {
        case MODE_GET:
        {
            UI32_T value = 0;

            if (SYS_PMGR_GetCpuUsagePeakDuration(&value) == TRUE)
            {
                long_return = value;
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                         (u_char *) &long_return, sizeof(long_return));
            }
            else
            {
                return SNMP_ERR_GENERR;
            }
        }
            break;


        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
do_cpuUtiRisingThreshold(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    switch (reqinfo->mode)
    {
        case MODE_GET:
        {
            UI32_T value = 0;

            if (SYS_PMGR_GetCpuUtilRisingThreshold(&value) == TRUE)
            {
                long_return = value;
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                         (u_char *) &long_return, sizeof(long_return));
            }
            else
            {
                return SNMP_ERR_GENERR;
            }
        }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:

            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests,
                                          SNMP_ERR_WRONGTYPE);
            }

            break;
        case MODE_SET_RESERVE2:

            if (*requests->requestvb->val.integer < MIN_cpuUtiRisingThreshold ||
                *requests->requestvb->val.integer > MAX_cpuUtiRisingThreshold)
            {
               netsnmp_set_request_error(reqinfo, requests,
                                         SNMP_ERR_WRONGVALUE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
        {
            if (SYS_PMGR_SetCpuUtilRisingThreshold(*requests->requestvb->val.integer) != TRUE)
            {
                netsnmp_set_request_error(reqinfo, requests,
                                          SNMP_ERR_COMMITFAILED);
            }
        }
            break;

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
do_cpuUtiFallingThreshold(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    switch (reqinfo->mode)
    {
        case MODE_GET:
        {
            UI32_T value = 0;

            if (SYS_PMGR_GetCpuUtilFallingThreshold(&value) == TRUE)
            {
                long_return = value;
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                         (u_char *) &long_return, sizeof(long_return));
            }
            else
            {
                return SNMP_ERR_GENERR;
            }
        }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:

            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests,
                                          SNMP_ERR_WRONGTYPE);
            }

            break;
        case MODE_SET_RESERVE2:

            if (*requests->requestvb->val.integer < MIN_cpuUtiFallingThreshold ||
                *requests->requestvb->val.integer > MAX_cpuUtiFallingThreshold)
            {
               netsnmp_set_request_error(reqinfo, requests,
                                         SNMP_ERR_WRONGVALUE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
        {
            if (SYS_PMGR_SetCpuUtilFallingThreshold(*requests->requestvb->val.integer) != TRUE)
            {
                netsnmp_set_request_error(reqinfo, requests,
                                          SNMP_ERR_COMMITFAILED);
            }
        }
            break;

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_memoryTotal(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    switch (reqinfo->mode)
    {
        case MODE_GET:
        {
            MEM_SIZE_T bytes = 0;

            if (SYS_PMGR_GetMemoryUtilTotalMemory(&bytes) == TRUE)
            {
                long_return = bytes >> 10; /*kilobytes*/
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                         (u_char *) &long_return, sizeof(long_return));
            }
            else
            {
                return SNMP_ERR_GENERR;
            }
        }
            break;


        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
get_memoryAllocated(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    switch (reqinfo->mode)
    {
        case MODE_GET:
        {
            SYS_MGR_MemoryUtilBrief_T entry;

            if (SYS_PMGR_GetMemoryUtilizationBrief(&entry) == TRUE)
            {
                long_return = entry.used_bytes >> 10; /*kilobytes*/
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                         (u_char *)&long_return, sizeof(long_return));
            }
            else
            {
                return SNMP_ERR_GENERR;
            }
        }
            break;


        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
get_memoryFreed(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    switch (reqinfo->mode)
    {
        case MODE_GET:
        {
            SYS_MGR_MemoryUtilBrief_T entry;

            if (SYS_PMGR_GetMemoryUtilizationBrief(&entry) == TRUE)
            {
                long_return = entry.free_bytes >> 10; /*kilobytes*/
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                         (u_char *) &long_return, sizeof(long_return));
            }
            else
            {
                return SNMP_ERR_GENERR;
            }
        }
            break;


        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
get_memoryFreedInPercent(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    switch (reqinfo->mode)
    {
        case MODE_GET:
        {
            UI32_T value = 0;

            if (SYS_PMGR_GetMemoryUtilFreePercentage(&value) == TRUE)
            {
                long_return = value;
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                         (u_char *) &long_return, sizeof(long_return));
            }
            else
            {
                return SNMP_ERR_GENERR;
            }
        }
            break;


        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
do_memoryUtiRisingThreshold(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    switch (reqinfo->mode)
    {
        case MODE_GET:
        {
            UI32_T value = 0;

            if (SYS_PMGR_GetMemoryUtilRisingThreshold(&value) == TRUE)
            {
                long_return = value;
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                         (u_char *) &long_return, sizeof(long_return));
            }
            else
            {
                return SNMP_ERR_GENERR;
            }
        }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:

            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests,
                                          SNMP_ERR_WRONGTYPE);
            }

            break;
        case MODE_SET_RESERVE2:

            if (*requests->requestvb->val.integer < MIN_memoryUtiRisingThreshold ||
                *requests->requestvb->val.integer > MAX_memoryUtiRisingThreshold)
            {
               netsnmp_set_request_error(reqinfo, requests,
                                         SNMP_ERR_WRONGVALUE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
        {
            if (SYS_PMGR_SetMemoryUtilRisingThreshold(*requests->requestvb->val.integer) != TRUE)
            {
                netsnmp_set_request_error(reqinfo, requests,
                                          SNMP_ERR_COMMITFAILED);
            }
        }
            break;

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
do_memoryUtiFallingThreshold(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    switch (reqinfo->mode)
    {
        case MODE_GET:
        {
            UI32_T value = 0;

            if (SYS_PMGR_GetMemoryUtilFallingThreshold(&value) == TRUE)
            {
                long_return = value;
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                         (u_char *) &long_return, sizeof(long_return));
            }
            else
            {
                return SNMP_ERR_GENERR;
            }
        }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:

            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests,
                                          SNMP_ERR_WRONGTYPE);
            }

            break;
        case MODE_SET_RESERVE2:

            if (*requests->requestvb->val.integer < MIN_memoryUtiFallingThreshold ||
                *requests->requestvb->val.integer > MAX_memoryUtiFallingThreshold)
            {
               netsnmp_set_request_error(reqinfo, requests,
                                         SNMP_ERR_WRONGVALUE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
        {
            if (SYS_PMGR_SetMemoryUtilFallingThreshold(*requests->requestvb->val.integer) != TRUE)
            {
                netsnmp_set_request_error(reqinfo, requests,
                                          SNMP_ERR_COMMITFAILED);
            }
        }
            break;

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

#if (SYS_CPNT_SYSMGMT_MONITORING_PROCESS_CPU_PER_TASK == TRUE)

#define TASKCPUENTRY_INSTANCE_LEN   MAXSIZE_taskCpuName

BOOL_T taskCpuTable_OidIndexToData(UI32_T exact, UI32_T compc,
    oid *compl, SYS_MGR_TaskCpuUtilInfo_T *cpu_util_info_p)
{
    int i;

    /* get or set
     */
    if (exact)
    {
        /* check the index length
         */
        if (compc > TASKCPUENTRY_INSTANCE_LEN) /* the constant size index */
        {
            return FALSE;
        }
    }

    if (compc > 0)
    {
        for (i = 0; i < compc; i++)
        {
            cpu_util_info_p->task_name[i] = compl[i];
        }

        cpu_util_info_p->task_name[i] = 0;
    }
    else
    {
        cpu_util_info_p->task_name[0] = 0;
    }

    return TRUE;
}

unsigned char *var_taskCpuTable(struct variable *vp,
    oid *name,
    size_t *length,
    int exact,
    size_t *var_len,
    WriteMethod **write_method)
{
    UI32_T compc = 0;
    oid compl[TASKCPUENTRY_INSTANCE_LEN] = {0};
    oid best_inst[TASKCPUENTRY_INSTANCE_LEN] = {0};
    SYS_MGR_TaskCpuUtilInfo_T cpu_util_info;
    int i, best_inst_len;

    switch (vp->magic)
    {
        default:
            *write_method = 0;
            break;
    }

    /* check compc, retrive compl
     */
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl, TASKCPUENTRY_INSTANCE_LEN);

    memset(&cpu_util_info, 0, sizeof(cpu_util_info));

    if (exact) /* get or set */
    {
        if (taskCpuTable_OidIndexToData(exact, compc, compl, &cpu_util_info) == FALSE)
        {
            return NULL;
        }

        if (!SYS_PMGR_GetCpuUtilByName(&cpu_util_info, FALSE))
        {
            return NULL;
        }
    }
    else /* getnext */
    {
        taskCpuTable_OidIndexToData(exact, compc, compl, &cpu_util_info);

        /* check the length of inputing index,if < 1 we should try get
         * {0.0.0.0.0...}
         */
        if (compc < 1)
        {
            if (!SYS_PMGR_GetCpuUtilByName(&cpu_util_info, FALSE))
            {
                if (!SYS_PMGR_GetCpuUtilByName(&cpu_util_info, TRUE))
                {
                    return NULL;
                }
            }
        }
        else
        {
            if (!SYS_PMGR_GetCpuUtilByName(&cpu_util_info, TRUE))
            {
                return NULL;
            }
        }
    }

    memcpy(name, vp->name, vp->namelen * sizeof(oid));

    /* assign data to the oid index
     */
    best_inst_len = strlen(cpu_util_info.task_name);

    for (i = 0; i < best_inst_len; i++)
    {
        best_inst[i] = cpu_util_info.task_name[i];
    }

    memcpy(name + vp->namelen, best_inst, best_inst_len * sizeof(oid));
    *length = vp->namelen + best_inst_len;

    switch (vp->magic)
    {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case LEAF_taskCpuName:
            *var_len = strlen(cpu_util_info.task_name);
            memcpy(return_buf, cpu_util_info.task_name, *var_len);
            return (u_char*)return_buf;
#endif

        case LEAF_taskCpuCurrentUti:
            *var_len = sizeof(long_return);
            long_return = cpu_util_info.cpu_util * 100 + cpu_util_info.cpu_util_float / 10;
            return (u_char *) &long_return;

        case LEAF_taskCpuStatMaxUti:
            *var_len = sizeof(long_return);
            long_return = cpu_util_info.cpu_util_max * 100 + cpu_util_info.cpu_util_max_float / 10;
            return (u_char *) &long_return;

        case LEAF_taskCpuStatAvgUti:
            *var_len = sizeof(long_return);
            long_return = cpu_util_info.cpu_util_avg * 100 + cpu_util_info.cpu_util_avg_float / 10;
            return (u_char *) &long_return;

        default:
            ERROR_MSG("");
    }

    return NULL;
}
#endif /* (SYS_CPNT_SYSMGMT_MONITORING_PROCESS_CPU_PER_TASK == TRUE) */

#if (SYS_CPNT_SYSMGMT_CPU_GUARD == TRUE)
int
do_cpuGuardStatus(netsnmp_mib_handler *handler,
                  netsnmp_handler_registration *reginfo,
                  netsnmp_agent_request_info   *reqinfo,
                  netsnmp_request_info         *requests)
{
    switch (reqinfo->mode)
    {
        case MODE_GET:
        {
            SYS_MGR_CpuGuardInfo_T info;

            if (SYS_PMGR_GetCpuGuardInfo(&info) == TRUE)
            {
                if (info.status)
                    long_return = VAL_cpuGuardStatus_enabled;
                else
                    long_return = VAL_cpuGuardStatus_disabled;
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                         (u_char *) &long_return, sizeof(long_return));
            }
            else
            {
                return SNMP_ERR_GENERR;
            }
            break;
        }

        case MODE_SET_RESERVE1:
        {
            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
            }
            break;
        }

        case MODE_SET_RESERVE2:
        {
            switch (*requests->requestvb->val.integer)
            {
                case VAL_cpuGuardStatus_enabled:
                case VAL_cpuGuardStatus_disabled:
                    break;

                default:
                    netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            }
            break;
        }

        case MODE_SET_FREE:
            break;

        case MODE_SET_ACTION:
        {
            BOOL_T status;
            status = (*requests->requestvb->val.integer == VAL_cpuGuardStatus_enabled);

            if (SYS_PMGR_SetCpuGuardStatus(status) != TRUE)
            {
                netsnmp_set_request_error(reqinfo, requests,
                                          SNMP_ERR_COMMITFAILED);
            }
            break;
        }

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}

int
do_cpuGuardHighWatermark(netsnmp_mib_handler *handler,
                         netsnmp_handler_registration *reginfo,
                         netsnmp_agent_request_info   *reqinfo,
                         netsnmp_request_info         *requests)
{
    switch (reqinfo->mode)
    {
        case MODE_GET:
        {
            SYS_MGR_CpuGuardInfo_T info;

            if (SYS_PMGR_GetCpuGuardInfo(&info) == TRUE)
            {
                long_return = info.watermark_high;
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                         (u_char *) &long_return, sizeof(long_return));
            }
            else
            {
                return SNMP_ERR_GENERR;
            }
            break;
        }

        case MODE_SET_RESERVE1:
        {
            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
            }
            break;
        }

        case MODE_SET_RESERVE2:
        {
            I32_T val = *requests->requestvb->val.integer;

            if (val < SYS_ADPT_CPU_UTILIZATION_WATERMARK_LOW ||
                val > SYS_ADPT_CPU_UTILIZATION_WATERMARK_HIGH)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            }
            break;
        }

        case MODE_SET_FREE:
            break;

        case MODE_SET_ACTION:
        {
            UI32_T watermark;
            watermark = (UI32_T)*requests->requestvb->val.integer;

            if (SYS_PMGR_SetCpuGuardHighWatermark(watermark) != TRUE)
            {
                netsnmp_set_request_error(reqinfo, requests,
                                          SNMP_ERR_COMMITFAILED);
            }
            break;
        }

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}

int
do_cpuGuardLowWatermark(netsnmp_mib_handler *handler,
                        netsnmp_handler_registration *reginfo,
                        netsnmp_agent_request_info   *reqinfo,
                        netsnmp_request_info         *requests)
{
    switch (reqinfo->mode)
    {
        case MODE_GET:
        {
            SYS_MGR_CpuGuardInfo_T info;

            if (SYS_PMGR_GetCpuGuardInfo(&info) == TRUE)
            {
                long_return = info.watermark_low;
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                         (u_char *) &long_return, sizeof(long_return));
            }
            else
            {
                return SNMP_ERR_GENERR;
            }
            break;
        }

        case MODE_SET_RESERVE1:
        {
            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
            }
            break;
        }

        case MODE_SET_RESERVE2:
        {
            I32_T val = *requests->requestvb->val.integer;

            if (val < SYS_ADPT_CPU_UTILIZATION_WATERMARK_LOW ||
                val > SYS_ADPT_CPU_UTILIZATION_WATERMARK_HIGH)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            }
            break;
        }

        case MODE_SET_FREE:
            break;

        case MODE_SET_ACTION:
        {
            UI32_T watermark;
            watermark = (UI32_T)*requests->requestvb->val.integer;

            if (SYS_PMGR_SetCpuGuardLowWatermark(watermark) != TRUE)
            {
                netsnmp_set_request_error(reqinfo, requests,
                                          SNMP_ERR_COMMITFAILED);
            }
            break;
        }

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}

int
do_cpuGuardMaxThreshold(netsnmp_mib_handler *handler,
                        netsnmp_handler_registration *reginfo,
                        netsnmp_agent_request_info   *reqinfo,
                        netsnmp_request_info         *requests)
{
    switch (reqinfo->mode)
    {
        case MODE_GET:
        {
            SYS_MGR_CpuGuardInfo_T info;

            if (SYS_PMGR_GetCpuGuardInfo(&info) == TRUE)
            {
                long_return = info.threshold_max;
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                         (u_char *) &long_return, sizeof(long_return));
            }
            else
            {
                return SNMP_ERR_GENERR;
            }
            break;
        }

        case MODE_SET_RESERVE1:
        {
            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
            }
            break;
        }

        case MODE_SET_RESERVE2:
        {
            I32_T val = *requests->requestvb->val.integer;

            if (val < SYS_ADPT_CPU_GUARD_THRESHOLD_MIN||
                val > SYS_ADPT_CPU_GUARD_THRESHOLD_MAX)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            }
            break;
        }

        case MODE_SET_FREE:
            break;

        case MODE_SET_ACTION:
        {
            UI32_T threshold;
            threshold = (UI32_T)*requests->requestvb->val.integer;

            if (SYS_PMGR_SetCpuGuardMaxThreshold(threshold) != TRUE)
            {
                netsnmp_set_request_error(reqinfo, requests,
                                          SNMP_ERR_COMMITFAILED);
            }
            break;
        }

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}

int
do_cpuGuardMinThreshold(netsnmp_mib_handler *handler,
                        netsnmp_handler_registration *reginfo,
                        netsnmp_agent_request_info   *reqinfo,
                        netsnmp_request_info         *requests)
{
    switch (reqinfo->mode)
    {
        case MODE_GET:
        {
            SYS_MGR_CpuGuardInfo_T info;

            if (SYS_PMGR_GetCpuGuardInfo(&info) == TRUE)
            {
                long_return = info.threshold_min;
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                         (u_char *) &long_return, sizeof(long_return));
            }
            else
            {
                return SNMP_ERR_GENERR;
            }
            break;
        }

        case MODE_SET_RESERVE1:
        {
            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
            }
            break;
        }

        case MODE_SET_RESERVE2:
        {
            I32_T val = *requests->requestvb->val.integer;

            if (val < SYS_ADPT_CPU_GUARD_THRESHOLD_MIN||
                val > SYS_ADPT_CPU_GUARD_THRESHOLD_MAX)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            }
            break;
        }

        case MODE_SET_FREE:
            break;

        case MODE_SET_ACTION:
        {
            UI32_T threshold;
            threshold = (UI32_T)*requests->requestvb->val.integer;

            if (SYS_PMGR_SetCpuGuardMinThreshold(threshold) != TRUE)
            {
                netsnmp_set_request_error(reqinfo, requests,
                                          SNMP_ERR_COMMITFAILED);
            }
            break;
        }

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}

int
do_cpuGuardTrapStatus(netsnmp_mib_handler *handler,
                      netsnmp_handler_registration *reginfo,
                      netsnmp_agent_request_info   *reqinfo,
                      netsnmp_request_info         *requests)
{
    switch (reqinfo->mode)
    {
        case MODE_GET:
        {
            SYS_MGR_CpuGuardInfo_T info;

            if (SYS_PMGR_GetCpuGuardInfo(&info) == TRUE)
            {
                if (info.trap_status)
                    long_return = VAL_cpuGuardTrapStatus_enabled;
                else
                    long_return = VAL_cpuGuardTrapStatus_disabled;
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                         (u_char *) &long_return, sizeof(long_return));
            }
            else
            {
                return SNMP_ERR_GENERR;
            }
            break;
        }

        case MODE_SET_RESERVE1:
        {
            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
            }
            break;
        }

        case MODE_SET_RESERVE2:
        {
            switch (*requests->requestvb->val.integer)
            {
                case VAL_cpuGuardTrapStatus_enabled:
                case VAL_cpuGuardTrapStatus_disabled:
                    break;

                default:
                    netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            }
            break;
        }

        case MODE_SET_FREE:
            break;

        case MODE_SET_ACTION:
        {
            BOOL_T status;
            status = (*requests->requestvb->val.integer == VAL_cpuGuardTrapStatus_enabled);

            if (SYS_PMGR_SetCpuGuardTrapStatus(status) != TRUE)
            {
                netsnmp_set_request_error(reqinfo, requests,
                                          SNMP_ERR_COMMITFAILED);
            }
            break;
        }

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}

int
get_cpuGuardCurrentThreshold(netsnmp_mib_handler *handler,
                             netsnmp_handler_registration *reginfo,
                             netsnmp_agent_request_info   *reqinfo,
                             netsnmp_request_info         *requests)
{
    switch (reqinfo->mode)
    {
        case MODE_GET:
        {
            SYS_MGR_CpuGuardInfo_T info;

            if (SYS_PMGR_GetCpuGuardInfo(&info) == TRUE)
            {
                long_return = info.cpu_rate;
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                         (u_char *) &long_return, sizeof(long_return));
            }
            else
            {
                return SNMP_ERR_GENERR;
            }
            break;
        }

        default:
            return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}
#endif
#endif /* #if (SYS_CPNT_SYSMGMT_RESMIB == TRUE) */

#if (SYS_CPNT_DAI == TRUE)
int
do_daiGlobalStatus(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    switch (reqinfo->mode)
    {
        case MODE_GET:
        {
            UI8_T status;

            if (DAI_PMGR_GetGlobalDaiStatus(&status) == DAI_TYPE_OK)
            {
                if(DAI_TYPE_GLOBAL_ENABLED == status)
                {
                    long_return = VAL_daiGlobalStatus_enabled;
                }
                else
                {
                    long_return = VAL_daiGlobalStatus_disabled;
                }

                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                         (u_char *)&long_return, sizeof(long_return));
            }
            else
            {
                return SNMP_ERR_GENERR;
            }
        }
            break;

        case MODE_SET_RESERVE1:

            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests,
                                          SNMP_ERR_WRONGTYPE);
            }

            break;

        case MODE_SET_RESERVE2:

            switch (*requests->requestvb->val.integer)
            {
                case VAL_daiGlobalStatus_enabled:
                    break;
                case VAL_daiGlobalStatus_disabled:
                    break;

                default:
                    netsnmp_set_request_error(reqinfo, requests,
                                              SNMP_ERR_WRONGVALUE);
            }
            break;

        case MODE_SET_FREE:
            break;

        case MODE_SET_ACTION:
        {
            if (DAI_PMGR_SetGlobalDaiStatus(*requests->requestvb->val.integer) != DAI_TYPE_OK)
            {
                netsnmp_set_request_error(reqinfo, requests,
                                          SNMP_ERR_COMMITFAILED);
            }
        }
            break;

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_daiGlobalSrcMacValidation(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    UI32_T current_type;

    if(DAI_PMGR_GetAdditionalCheckType(&current_type)!= DAI_TYPE_OK)
    {
        return SNMP_ERR_GENERR;
    }

    switch (reqinfo->mode)
    {
        case MODE_GET:
        {
            if(current_type & DAI_TYPE_ADDITIONAL_VALIDATE_SRCMAC)
            {
                long_return = VAL_daiGlobalSrcMacValidation_enabled;
            }
            else
            {
                long_return = VAL_daiGlobalSrcMacValidation_disabled;
            }

            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                         (u_char *)&long_return, sizeof(long_return));
        }
            break;

        case MODE_SET_RESERVE1:

            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests,
                                          SNMP_ERR_WRONGTYPE);
            }

            break;

        case MODE_SET_RESERVE2:

            switch (*requests->requestvb->val.integer)
            {
                case VAL_daiGlobalSrcMacValidation_enabled:
                    break;
                case VAL_daiGlobalSrcMacValidation_disabled:
                    break;

                default:
                    netsnmp_set_request_error(reqinfo, requests,
                                              SNMP_ERR_WRONGVALUE);
            }
            break;

        case MODE_SET_FREE:
            break;

        case MODE_SET_ACTION:
        {
            if(VAL_daiGlobalSrcMacValidation_enabled == (*requests->requestvb->val.integer))
            {
                current_type |= DAI_TYPE_ADDITIONAL_VALIDATE_SRCMAC;
            }
            else
            {
                current_type &= ~DAI_TYPE_ADDITIONAL_VALIDATE_SRCMAC;
            }

            if (DAI_PMGR_SetAdditionalCheckType(current_type) != DAI_TYPE_OK)
            {
                netsnmp_set_request_error(reqinfo, requests,
                                          SNMP_ERR_COMMITFAILED);
            }
        }
            break;

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_daiGlobalDestMacValidation(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    UI32_T current_type;

    if(DAI_PMGR_GetAdditionalCheckType(&current_type)!= DAI_TYPE_OK)
    {
        return SNMP_ERR_GENERR;
    }

    switch (reqinfo->mode)
    {
        case MODE_GET:
        {
            if(current_type & DAI_TYPE_ADDITIONAL_VALIDATE_DSTMAC)
            {
                long_return = VAL_daiGlobalDestMacValidation_enabled;
            }
            else
            {
                long_return = VAL_daiGlobalDestMacValidation_disabled;
            }

            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                         (u_char *)&long_return, sizeof(long_return));
        }
            break;

        case MODE_SET_RESERVE1:

            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests,
                                          SNMP_ERR_WRONGTYPE);
            }

            break;

        case MODE_SET_RESERVE2:

            switch (*requests->requestvb->val.integer)
            {
                case VAL_daiGlobalDestMacValidation_enabled:
                    break;
                case VAL_daiGlobalDestMacValidation_disabled:
                    break;

                default:
                    netsnmp_set_request_error(reqinfo, requests,
                                              SNMP_ERR_WRONGVALUE);
            }
            break;

        case MODE_SET_FREE:
            break;

        case MODE_SET_ACTION:
        {
            if(VAL_daiGlobalDestMacValidation_enabled == (*requests->requestvb->val.integer))
            {
                current_type |= DAI_TYPE_ADDITIONAL_VALIDATE_DSTMAC;
            }
            else
            {
                current_type &= ~DAI_TYPE_ADDITIONAL_VALIDATE_DSTMAC;
            }

            if (DAI_PMGR_SetAdditionalCheckType(current_type) != DAI_TYPE_OK)
            {
                netsnmp_set_request_error(reqinfo, requests,
                                          SNMP_ERR_COMMITFAILED);
            }
        }
            break;

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_daiGlobalIpAddrValidation(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    UI32_T current_type;

    if(DAI_PMGR_GetAdditionalCheckType(&current_type)!= DAI_TYPE_OK)
    {
        return SNMP_ERR_GENERR;
    }

    switch (reqinfo->mode)
    {
        case MODE_GET:
        {
            if(current_type & DAI_TYPE_ADDITIONAL_VALIDATE_IP)
            {
                long_return = VAL_daiGlobalIpAddrValidation_enabled;
            }
            else
            {
                long_return = VAL_daiGlobalIpAddrValidation_disabled;
            }

            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                         (u_char *)&long_return, sizeof(long_return));
        }
            break;

        case MODE_SET_RESERVE1:

            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests,
                                          SNMP_ERR_WRONGTYPE);
            }

            break;

        case MODE_SET_RESERVE2:

            switch (*requests->requestvb->val.integer)
            {
                case VAL_daiGlobalIpAddrValidation_enabled:
                    break;
                case VAL_daiGlobalIpAddrValidation_disabled:
                    break;

                default:
                    netsnmp_set_request_error(reqinfo, requests,
                                              SNMP_ERR_WRONGVALUE);
            }
            break;

        case MODE_SET_FREE:
            break;

        case MODE_SET_ACTION:
        {
            if(VAL_daiGlobalIpAddrValidation_enabled == (*requests->requestvb->val.integer))
            {
                current_type |= DAI_TYPE_ADDITIONAL_VALIDATE_IP;
            }
            else
            {
                current_type &= ~DAI_TYPE_ADDITIONAL_VALIDATE_IP;
            }

            if (DAI_PMGR_SetAdditionalCheckType(current_type) != DAI_TYPE_OK)
            {
                netsnmp_set_request_error(reqinfo, requests,
                                          SNMP_ERR_COMMITFAILED);
            }
        }
            break;

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_daiGlobalLogNumber(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    switch (reqinfo->mode)
    {
        case MODE_GET:
        {
            UI32_T value = 0;

            if (DAI_PMGR_GetLoggingMessageNumber(&value) == DAI_TYPE_OK)
            {
                long_return = value;
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                         (u_char *)&long_return, sizeof(long_return));
            }
            else
            {
                return SNMP_ERR_GENERR;
            }
        }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:

            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests,
                                          SNMP_ERR_WRONGTYPE);
            }

            break;

        case MODE_SET_RESERVE2:

            if (*requests->requestvb->val.integer < MIN_daiGlobalLogNumber ||
                *requests->requestvb->val.integer > MAX_daiGlobalLogNumber)
            {
               netsnmp_set_request_error(reqinfo, requests,
                                         SNMP_ERR_WRONGVALUE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called.
             */
            break;

        case MODE_SET_ACTION:
        {
            if (DAI_PMGR_SetLoggingMessageNumber(*requests->requestvb->val.integer) != DAI_TYPE_OK)
            {
                netsnmp_set_request_error(reqinfo, requests,
                                          SNMP_ERR_COMMITFAILED);
            }
        }
            break;

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_daiGlobalLogInterval(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    switch (reqinfo->mode)
    {
        case MODE_GET:
        {
            UI32_T value = 0;

            if (DAI_PMGR_GetLoggingMessageInterval(&value) == DAI_TYPE_OK)
            {
                long_return = value;
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                         (u_char *)&long_return, sizeof(long_return));
            }
            else
            {
                return SNMP_ERR_GENERR;
            }
        }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:

            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests,
                                          SNMP_ERR_WRONGTYPE);
            }

            break;

        case MODE_SET_RESERVE2:

            if (*requests->requestvb->val.integer < MIN_daiGlobalLogInterval ||
                *requests->requestvb->val.integer > MAX_daiGlobalLogInterval)
            {
               netsnmp_set_request_error(reqinfo, requests,
                                         SNMP_ERR_WRONGVALUE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called.
             */
            break;

        case MODE_SET_ACTION:
        {
            if (DAI_PMGR_SetLoggingMessageInterval(*requests->requestvb->val.integer) != DAI_TYPE_OK)
            {
                netsnmp_set_request_error(reqinfo, requests,
                                          SNMP_ERR_COMMITFAILED);
            }
        }
            break;

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_daiGlobalAdditionalValidStatus(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    switch (reqinfo->mode)
    {
        case MODE_GET:
        {
            UI8_T status= 0;

            if(DAI_TYPE_OK != DAI_PMGR_GetAdditionalCheckStatus(&status))
            {
                return SNMP_ERR_GENERR;
            }

            if (DAI_TYPE_ADDITIONAL_CHECK_ENABLED == status)
            {
                long_return = VAL_daiGlobalAdditionalValidStatus_enabled;
            }
            else
            {
                long_return = VAL_daiGlobalAdditionalValidStatus_disabled;
            }

            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                         (u_char *)&long_return, sizeof(long_return));
        }
            break;


        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

/********************************************
 ************daiVlanTable********************
 ********************************************
 */
#define DAIVLANENTRY_INSTANCE_LEN  1

BOOL_T daiVlanTable_OidIndexToData(UI32_T exact, UI32_T compc,
            oid * compl,  UI32_T *daiVlanIndex)
{
    /* get or write */
    if (exact)
    {
        /* check the index length */
        if (compc != DAIVLANENTRY_INSTANCE_LEN) /* the constant size index */
        {
            return FALSE;
        }
    }

    *daiVlanIndex = compl[0];

    return TRUE;
}

unsigned char *
var_daiVlanTable(struct variable *vp,
            oid     *name,
            size_t  *length,
            int     exact,
            size_t  *var_len,
            WriteMethod **write_method)
{
    UI32_T compc = 0;
    oid compl[DAIVLANENTRY_INSTANCE_LEN] = {0};
    oid best_inst[DAIVLANENTRY_INSTANCE_LEN] = {0};
    DAI_TYPE_VlanInfo_T entry;
    UI32_T  vid = 0;
    UI8_T   dai_status;

    switch (vp->magic)
    {
        case LEAF_daiVlanStatus:
            *write_method = write_daiVlanStatus;
            break;

        case LEAF_daiVlanArpAclName:
            *write_method = write_daiVlanArpAclName;
            break;

        case LEAF_daiVlanArpAclStatus:
            *write_method = write_daiVlanArpAclStatus;
            break;

        default:
            *write_method = 0;
            break;
    }

    /* check compc, retrive compl */
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,
                           compl, DAIVLANENTRY_INSTANCE_LEN);

    memset(&entry, 0, sizeof(entry));

    if (exact) /* get,set */
    {
        /* get index */
        if (daiVlanTable_OidIndexToData(exact, compc, compl, &vid) == FALSE)
        {
            return NULL;
        }

        /* get data */
        if (DAI_PMGR_GetVlanInfo(vid, &entry, &dai_status) != DAI_TYPE_OK)
        {
            return NULL;
        }
    }
    else /* getnext */
    {
        /* get index */
        daiVlanTable_OidIndexToData(exact, compc, compl, &vid);

        /* check the length of inputing index,if < 1 we should try get
         * {0.0.0.0.0...}
         */
        if (compc < 1)
        {
            /* get data */
            if (DAI_PMGR_GetVlanInfo(vid, &entry, &dai_status) != DAI_TYPE_OK)
            {
                /* get next data */
                if (DAI_PMGR_GetNextVlanInfo(&vid, &entry, &dai_status) != DAI_TYPE_OK)
                {
                    return NULL;
                }
            }
        }
        else
        {
            /* get next data */
            if (DAI_PMGR_GetNextVlanInfo(&vid, &entry, &dai_status) != DAI_TYPE_OK)
            {
                return NULL;
            }
        }
    }

    memcpy(name, vp->name, vp->namelen*sizeof(oid));

    /* assign data to the oid index */
    best_inst[0] = vid;
    memcpy(name + vp->namelen, best_inst,
           DAIVLANENTRY_INSTANCE_LEN * sizeof(oid));
    *length = vp->namelen + DAIVLANENTRY_INSTANCE_LEN ;

    /* this is where we do the value assignments for the mib results. */
    switch (vp->magic)
    {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case LEAF_daiVlanIndex:
            *var_len = sizeof(long_return);
            long_return = vid;
            return (u_char *) &long_return;

#endif
        case LEAF_daiVlanStatus:
            *var_len = sizeof(long_return);
            long_return = (UI32_T)dai_status;
            return (u_char *) &long_return;

        case LEAF_daiVlanArpAclName:
            *var_len  =   strlen((char *)entry.arp_acl_name);
            memcpy(return_buf, entry.arp_acl_name, *var_len);
            return (u_char*)return_buf;

        case LEAF_daiVlanArpAclStatus:
            *var_len = sizeof(long_return);

            if(TRUE == entry.acl_static)
            {
                long_return = VAL_daiVlanArpAclStatus_static;
            }
            else
            {
                long_return = VAL_daiVlanArpAclStatus_dynamic;
            }
            return (u_char *) &long_return;

        default:
            ERROR_MSG("");
    }

    return NULL;
}

int
write_daiVlanStatus(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            switch (*(long *)var_val)
            {
                case VAL_daiVlanStatus_enabled:
                    break;

                case VAL_daiVlanStatus_disabled:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
            I32_T value = 0;
            UI32_T daiVlanIndex = 0;

            if (daiVlanTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]),  &daiVlanIndex) == FALSE)
                return SNMP_ERR_COMMITFAILED;

            value = *(long *)var_val;

            if(VAL_daiVlanStatus_enabled == value)
            {
                if(DAI_TYPE_OK != DAI_PMGR_EnableDaiByVlan(daiVlanIndex))
                {
                    return SNMP_ERR_COMMITFAILED;
                }
            }
            else
            {
                if(DAI_TYPE_OK != DAI_PMGR_DisableDaiByVlan(daiVlanIndex))
                {
                    return SNMP_ERR_COMMITFAILED;
                }
            }
        }
            break;

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

int
write_daiVlanArpAclName(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_OCTET_STR)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len < MINSIZE_daiVlanArpAclName ||
                var_val_len > MAXSIZE_daiVlanArpAclName)
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;

        case RESERVE2:
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
            UI8_T byte_buffer[MAXSIZE_daiVlanArpAclName + 1] = {0};
            UI32_T daiVlanIndex = 0;

            if (daiVlanTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &daiVlanIndex) == FALSE)
                return SNMP_ERR_COMMITFAILED;

            memcpy(byte_buffer, var_val, var_val_len);

            byte_buffer[var_val_len] = '\0';

            if (DAI_TYPE_OK != DAI_PMGR_SetVlanFilter(daiVlanIndex, byte_buffer, FALSE))
            {
                return SNMP_ERR_COMMITFAILED;
            }
        }
            break;

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

int
write_daiVlanArpAclStatus(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    BOOL_T staticStatus = TRUE;

    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            switch (*(long *)var_val)
            {
                case VAL_daiVlanArpAclStatus_static:
                    staticStatus = TRUE;
                    break;

                case VAL_daiVlanArpAclStatus_dynamic:
                    staticStatus = FALSE;
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            DAI_TYPE_VlanInfo_T  entry;
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
            UI32_T daiVlanIndex = 0;
            UI8_T  daiStatus;

            memset(&entry, 0, sizeof(entry));

            if (daiVlanTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &daiVlanIndex) == FALSE)
                return SNMP_ERR_COMMITFAILED;

            if (DAI_TYPE_OK != DAI_PMGR_GetVlanInfo(daiVlanIndex, &entry, &daiStatus))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            if(0 == strlen((char *)entry.arp_acl_name))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            if (DAI_TYPE_OK != DAI_PMGR_SetVlanFilter(daiVlanIndex, entry.arp_acl_name, staticStatus))
            {
                return SNMP_ERR_COMMITFAILED;
            }
        }
            break;

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

/********************************************
 ************daiPortTable********************
 ********************************************
 */
#define DAIPORTENTRY_INSTANCE_LEN  1

BOOL_T daiPortTable_OidIndexToData(UI32_T exact, UI32_T compc,
            oid * compl,  UI32_T *daiPortIfIndex)
{
    /* get or write */
    if (exact)
    {
        /* check the index length */
        if (compc != DAIPORTENTRY_INSTANCE_LEN) /* the constant size index */
        {
            return FALSE;
        }
    }

    *daiPortIfIndex = compl[0];

    return TRUE;
}

unsigned char *
var_daiPortTable(struct variable *vp,
            oid     *name,
            size_t  *length,
            int     exact,
            size_t  *var_len,
            WriteMethod **write_method)
{
    UI32_T compc = 0;
    oid compl[DAIPORTENTRY_INSTANCE_LEN] = {0};
    oid best_inst[DAIPORTENTRY_INSTANCE_LEN] = {0};
    DAI_TYPE_PortInfo_T entry;
    UI32_T ifIndex = 0;

    switch (vp->magic)
    {
        case LEAF_daiPortTrustStatus:
            *write_method = write_daiPortTrustStatus;
            break;

        case LEAF_daiPortRateLimit:
            *write_method = write_daiPortRateLimit;
            break;

        default:
            *write_method = 0;
            break;
    }

    /* check compc, retrive compl */
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,
                           compl, DAIPORTENTRY_INSTANCE_LEN);

    memset(&entry, 0, sizeof(entry));

    if (exact) /* get,set */
    {
        /* get index */
        if (daiPortTable_OidIndexToData(exact, compc, compl, &ifIndex) == FALSE)
        {
            return NULL;
        }

        /* get data */
        if (DAI_PMGR_GetPortInfo(ifIndex, &entry) != DAI_TYPE_OK)
        {
            return NULL;
        }
    }
    else /* getnext */
    {
        /* get index */
        daiPortTable_OidIndexToData(exact, compc, compl, &ifIndex);

        /* check the length of inputing index,if < 1 we should try get
         * {0.0.0.0.0...}
         */
        if (compc < 1)
        {
            /* get data */
            if (DAI_PMGR_GetPortInfo(ifIndex, &entry) != DAI_TYPE_OK)
            {
                /* get next data */
                if (DAI_PMGR_GetNextPortInfo(&ifIndex, &entry) != DAI_TYPE_OK)
                {
                    return NULL;
                }
            }
        }
        else
        {
            /* get next data */
            if (DAI_PMGR_GetNextPortInfo(&ifIndex, &entry) != DAI_TYPE_OK)
            {
                return NULL;
            }
        }
    }

    memcpy(name, vp->name, vp->namelen*sizeof(oid));

    /* assign data to the oid index */
    best_inst[0] = ifIndex;
    memcpy(name + vp->namelen, best_inst,
           DAIPORTENTRY_INSTANCE_LEN * sizeof(oid));
    *length = vp->namelen + DAIPORTENTRY_INSTANCE_LEN ;

    /* this is where we do the value assignments for the mib results. */
    switch (vp->magic)
    {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case LEAF_daiPortIfIndex:
            *var_len = sizeof(long_return);
            long_return = ifIndex;
            return (u_char *) &long_return;

#endif
        case LEAF_daiPortTrustStatus:
            *var_len = sizeof(long_return);
            long_return = (UI32_T)entry.trust_status;
            return (u_char *) &long_return;

        case LEAF_daiPortRateLimit:
            *var_len = sizeof(long_return);
            long_return = entry.rate_limit;
            return (u_char *) &long_return;

        default:
            ERROR_MSG("");
    }

    return NULL;
}

int
write_daiPortTrustStatus(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            switch (*(long *)var_val)
            {
                case VAL_daiPortTrustStatus_enabled:
                    break;

                case VAL_daiPortTrustStatus_disabled:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
            UI32_T daiPortIfIndex = 0;
            UI8_T  status;

            if (daiPortTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &daiPortIfIndex) == FALSE)
                return SNMP_ERR_COMMITFAILED;

            if(VAL_daiPortTrustStatus_enabled == (*(long *)var_val))
            {
                status = DAI_TYPE_PORT_TRUSTED;
            }
            else
            {
                status = DAI_TYPE_PORT_UNTRUSTED;
            }

            if (DAI_TYPE_OK != DAI_PMGR_SetPortTrustStatus(daiPortIfIndex, status))
            {
                return SNMP_ERR_COMMITFAILED;
            }
        }
            break;

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

int
write_daiPortRateLimit(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_UNSIGNED)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:

            if( (*(u_long *)var_val != VAL_daiPortRateLimit_none) &&
                (*(u_long *)var_val < MIN_daiPortRateLimit || *(u_long *)var_val > MAX_daiPortRateLimit) )
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
            UI32_T value = 0;
            UI32_T daiPortIfIndex = 0;

            if (daiPortTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]),  &daiPortIfIndex) == FALSE)
                return SNMP_ERR_COMMITFAILED;

            value = *(u_long *)var_val;

            if (DAI_TYPE_OK != DAI_PMGR_SetPortRateLimit(daiPortIfIndex, value))
            {
                return SNMP_ERR_COMMITFAILED;
            }
        }
            break;

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

/********************************************
 ************daiLogTable*********************
 ********************************************
 */
#define DAILOGENTRY_INSTANCE_LEN  1

BOOL_T daiLogTable_OidIndexToData(UI32_T exact, UI32_T compc,
            oid * compl,  UI32_T *daiLogIndex)
{
    /* get or write */
    if (exact)
    {
        /* check the index length */
        if (compc != DAILOGENTRY_INSTANCE_LEN) /* the constant size index */
        {
            return FALSE;
        }
    }

    *daiLogIndex = compl[0];

    return TRUE;
}

unsigned char *
var_daiLogTable(struct variable *vp,
            oid     *name,
            size_t  *length,
            int     exact,
            size_t  *var_len,
            WriteMethod **write_method)
{
    /* variables we may use later */
    UI32_T compc = 0;
    oid compl[DAILOGENTRY_INSTANCE_LEN] = {0};
    oid best_inst[DAILOGENTRY_INSTANCE_LEN] = {0};
    DAI_TYPE_LogEntry_T entry;
    UI32_T  index = 0;

    switch (vp->magic)
    {
        default:
            *write_method = 0;
            break;
    }

    /* check compc, retrive compl */
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,
                           compl, DAILOGENTRY_INSTANCE_LEN);

    memset(&entry, 0, sizeof(entry));

    if (exact) /* get,set */
    {
        /* get index */
        if (daiLogTable_OidIndexToData(exact, compc, compl, &index) == FALSE)
        {
            return NULL;
        }

        /* get data */
        if (DAI_PMGR_GetLogEntry(index, &entry) != DAI_TYPE_OK)
        {
            return NULL;
        }
    }
    else /* getnext */
    {
        /* get index */
        daiLogTable_OidIndexToData(exact, compc, compl, &index);

        /* check the length of inputing index,if < 1 we should try get
         * {0.0.0.0.0...}
         */
        if (compc < 1)
        {
            /* get data */
            if (DAI_PMGR_GetLogEntry(index, &entry) != DAI_TYPE_OK)
            {
                /* get next data */
                if (DAI_PMGR_GetNextLogEntry(&index, &entry) != DAI_TYPE_OK)
                {
                    return NULL;
                }
            }
        }
        else
        {
            /* get next data */
            if (DAI_PMGR_GetNextLogEntry(&index, &entry) != DAI_TYPE_OK)
            {
                return NULL;
            }
        }
    }

    memcpy(name, vp->name, vp->namelen*sizeof(oid));

    /* assign data to the oid index */
    best_inst[0] = index;
    memcpy(name + vp->namelen, best_inst,
           DAILOGENTRY_INSTANCE_LEN * sizeof(oid));
    *length = vp->namelen + DAILOGENTRY_INSTANCE_LEN ;

    /* this is where we do the value assignments for the mib results. */
    switch (vp->magic)
    {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case LEAF_daiLogIndex:
            *var_len = sizeof(long_return);
            long_return = index;
            return (u_char *) &long_return;

#endif
        case LEAF_daiLogVlan:
            *var_len = sizeof(long_return);
            long_return = entry.vlan_id;
            return (u_char *) &long_return;

        case LEAF_daiLogPort:
            *var_len = sizeof(long_return);
            long_return = entry.port_num;
            return (u_char *) &long_return;

        case LEAF_daiLogSrcIpAddress:
            *var_len = sizeof(ipaddr_return);
            ipaddr_return = entry.src_ip_addr;
            return (u_char *) &ipaddr_return;

        case LEAF_daiLogDestIpAddress:
            *var_len = sizeof(ipaddr_return);
            ipaddr_return = entry.dst_ip_addr;
            return (u_char *) &ipaddr_return;

        case LEAF_daiLogSrcMacAddress:
            *var_len = SIZE_daiLogSrcMacAddress;
            memcpy(return_buf, entry.src_mac, *var_len);
            return (u_char*)return_buf;

        case LEAF_daiLogDestMacAddress:
            *var_len = SIZE_daiLogDestMacAddress;
            memcpy(return_buf, entry.dst_mac, *var_len);
            return (u_char*)return_buf;

        default:
            ERROR_MSG("");
    }
    return NULL;
}

int
get_daiTotalReceivedPkts(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    switch (reqinfo->mode)
    {
        case MODE_GET:
        {
            UI32_T value = 0;

            if (DAI_PMGR_GetDosAttackRecvCount(&value) == DAI_TYPE_OK)
            {
                long_return = value;
                snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER,
                                         (u_char *)&long_return, sizeof(long_return));
            }
            else
            {
                return SNMP_ERR_GENERR;
            }
        }
            break;


        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_daiTotalDroppedPkts(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    switch (reqinfo->mode)
    {
        case MODE_GET:
        {
            UI32_T value = 0;

            if (DAI_PMGR_GetDosAttackDropCount(&value) == DAI_TYPE_OK)
            {
                long_return = value;
                snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER,
                                         (u_char *)&long_return, sizeof(long_return));
            }
            else
            {
                return SNMP_ERR_GENERR;
            }
        }
            break;


        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_daiTotalProcessedPkts(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    switch (reqinfo->mode)
    {
        case MODE_GET:
        {
            UI32_T value = 0;

            if (DAI_PMGR_GetTotalArpProcessedByDai(&value) == DAI_TYPE_OK)
            {
                long_return = value;
                snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER,
                                         (u_char *)&long_return, sizeof(long_return));
            }
            else
            {
                return SNMP_ERR_GENERR;
            }
        }
            break;


        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_daiTotalSrcMacDroppedPkts(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    switch (reqinfo->mode)
    {
        case MODE_GET:
        {
            UI32_T value = 0;

            if (DAI_PMGR_GetDroppedBySrcmacValidation(&value) == DAI_TYPE_OK)
            {
                long_return = value;
                snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER,
                                         (u_char *)&long_return, sizeof(long_return));
            }
            else
            {
                return SNMP_ERR_GENERR;
            }
        }
            break;


        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_daiTotalDestMacDroppedPkts(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    switch (reqinfo->mode)
    {
        case MODE_GET:
        {
            UI32_T value = 0;

            if (DAI_PMGR_GetDroppedByDstmacValidation(&value) == DAI_TYPE_OK)
            {
                long_return = value;
                snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER,
                                         (u_char *)&long_return, sizeof(long_return));
            }
            else
            {
                return SNMP_ERR_GENERR;
            }
        }
            break;


        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_daiTotalIpAddrDroppedPkts(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    switch (reqinfo->mode)
    {
        case MODE_GET:
        {
            UI32_T value = 0;

            if (DAI_PMGR_GetDroppedByIpValidation(&value) == DAI_TYPE_OK)
            {
                long_return = value;
                snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER,
                                         (u_char *)&long_return, sizeof(long_return));
            }
            else
            {
                return SNMP_ERR_GENERR;
            }
        }
            break;


        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_daiTotalArpAclDroppedPkts(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    switch (reqinfo->mode)
    {
        case MODE_GET:
        {
            UI32_T value = 0;

            if (DAI_PMGR_GetDroppedByArpAcl(&value) == DAI_TYPE_OK)
            {
                long_return = value;
                snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER,
                                         (u_char *)&long_return, sizeof(long_return));
            }
            else
            {
                return SNMP_ERR_GENERR;
            }
        }
            break;


        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_daiTotalDhcpSnoopingDroppedPkts(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    switch (reqinfo->mode)
    {
        case MODE_GET:
        {
            UI32_T value = 0;

            if (DAI_PMGR_GetDroppedByDhcpsnp(&value) == DAI_TYPE_OK)
            {
                long_return = value;
                snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER,
                                         (u_char *)&long_return, sizeof(long_return));
            }
            else
            {
                return SNMP_ERR_GENERR;
            }
        }
            break;


        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
#endif /* #if (SYS_CPNT_DAI == TRUE) */

#if (SYS_CPNT_IP_TUNNEL == TRUE)
/* ipv6TunnelTable */
#define IPV6TUNNELENTRY_INSTANCE_LEN  1

BOOL_T ipv6TunnelTable_OidIndexToData(UI32_T exact, UI32_T compc,
    oid *compl, UI32_T *ipv6TunnelIndex)
{
    /* get or set
     */
    if (exact)
    {
        /* check the index length
         */
        if (compc != IPV6TUNNELENTRY_INSTANCE_LEN) /* the constant size index */
        {
            return FALSE;
        }
    }

    *ipv6TunnelIndex = compl[0];

    return TRUE;
}

/*
 * var_ipv6TunnelTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *var_ipv6TunnelTable(struct variable *vp,
    oid *name,
    size_t *length,
    int exact,
    size_t *var_len,
    WriteMethod **write_method)
{
    UI32_T compc = 0;
    oid compl[IPV6TUNNELENTRY_INSTANCE_LEN] = {0};
    oid best_inst[IPV6TUNNELENTRY_INSTANCE_LEN] = {0};
    UI32_T tunnel_id;
    NETCFG_TYPE_L3_Interface_T tunnel_if;

    switch (vp->magic)
    {

        case LEAF_ipv6TunnelNdRaSuppress:
            *write_method = write_ipv6TunnelNdRaSuppress;
            break;

        case LEAF_ipv6TunnelMode:
            *write_method = write_ipv6TunnelMode;
            break;

        case LEAF_ipv6TunnelTtl:
            *write_method = write_ipv6TunnelTtl;
            break;

        case LEAF_ipv6TunnelDestination:
            *write_method = write_ipv6TunnelDestination;
            break;

        case LEAF_ipv6TunnelSourceVlanIfindex:
            *write_method = write_ipv6TunnelSourceVlanIfindex;
            break;

        case LEAF_ipv6TunnelRowStatus:
            *write_method = write_ipv6TunnelRowStatus;
            break;

        default:
            *write_method = 0;
            break;
    }

    /* check compc, retrive compl
     */
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl, IPV6TUNNELENTRY_INSTANCE_LEN);

    memset(&tunnel_if, 0, sizeof(tunnel_if));

    if (exact) /* get or set */
    {
        if (ipv6TunnelTable_OidIndexToData(exact, compc, compl, &tunnel_id) == FALSE)
        {
            return NULL;
        }

        if(FALSE == IP_LIB_ConvertTunnelIdToIfindex(tunnel_id, &(tunnel_if.ifindex)))
        {
            return NULL;
        }

        if (NETCFG_POM_IP_GetL3Interface(&tunnel_if) != NETCFG_TYPE_OK)
        {
            return NULL;
        }
    }
    else /* getnext */
    {
        ipv6TunnelTable_OidIndexToData(exact, compc, compl, &tunnel_id);

        /* check the length of inputing index,if < 1 we should try get
         * {0.0.0.0.0...}
         */
        if (compc < 1)
        {
            if(FALSE == IP_LIB_ConvertTunnelIdToIfindex(tunnel_id, &(tunnel_if.ifindex)))
            {
                return NULL;
            }
            if (NETCFG_POM_IP_GetL3Interface(&tunnel_if) != NETCFG_TYPE_OK)
            {

                if (NETCFG_POM_IP_GetNextL3Interface(&tunnel_if) != NETCFG_TYPE_OK)
                {
                    return NULL;
                }
            }
        }
        else
        {
            if (NETCFG_POM_IP_GetNextL3Interface(&tunnel_if) != NETCFG_TYPE_OK)
            {
                return NULL;
            }
        }
    }

    memcpy(name, vp->name, vp->namelen * sizeof(oid));

    /* assign data to the oid index
     */
    if(FALSE == IP_LIB_ConvertTunnelIdFromIfindex(tunnel_if.ifindex,&tunnel_id))
    {
        return NULL;
    }

    best_inst[0] = tunnel_id;
    memcpy(name + vp->namelen, best_inst, IPV6TUNNELENTRY_INSTANCE_LEN * sizeof(oid));
    *length = vp->namelen + IPV6TUNNELENTRY_INSTANCE_LEN;

    switch (vp->magic)
    {
        case LEAF_ipv6TunnelIndex:
            *var_len = sizeof(long_return);
            long_return = tunnel_id;
            return (u_char *) &long_return;

        case LEAF_ipv6TunnelNdRaSuppress:
        {
            BOOL_T suppress = FALSE;


            if(FALSE == NETCFG_POM_ND_GetNdRaSuppress(tunnel_if.ifindex, &suppress))
            {
                return NULL;
            }

            *var_len = sizeof(long_return);
            if(suppress)
                long_return = VAL_ipv6TunnelNdRaSuppress_suppress ;
            else
                long_return = VAL_ipv6TunnelNdRaSuppress_do_not_suppress;

            return (u_char *) &long_return;
        }
        case LEAF_ipv6TunnelMode:
            *var_len = sizeof(long_return);
            long_return = tunnel_if.u.tunnel_intf.tunnel_mode;
            return (u_char *) &long_return;

        case LEAF_ipv6TunnelTtl:
            *var_len = sizeof(long_return);
            long_return = tunnel_if.u.tunnel_intf.ttl;
            return (u_char *) &long_return;

        case LEAF_ipv6TunnelDestination:
        {
            char addr_str[L_INET_MAX_IP4ADDR_STR_LEN+1] = {0};
            L_INET_Ntop(L_INET_AF_INET, tunnel_if.u.tunnel_intf.dip.addr, addr_str, sizeof(addr_str));
            *var_len = strlen(addr_str);
            memcpy(return_buf, addr_str, *var_len);
            return (u_char *) return_buf;
        }
        case LEAF_ipv6TunnelSourceVlanIfindex:
            *var_len = sizeof(long_return);
            long_return = tunnel_if.u.tunnel_intf.src_vid_ifindex;
            return (u_char *) &long_return;

        case LEAF_ipv6TunnelRowStatus:
            *var_len = sizeof(long_return);
            long_return = tunnel_if.u.tunnel_intf.row_status;
            return (u_char *) &long_return;

        default:
            ERROR_MSG("");
    }
    return NULL;
}

int write_ipv6TunnelNdRaSuppress(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            switch (*(long *)var_val)
            {
                case VAL_ipv6TunnelNdRaSuppress_do_not_suppress:
                    break;

                case VAL_ipv6TunnelNdRaSuppress_suppress:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            I32_T value = 0;
            UI32_T ipv6TunnelIndex = 0;
            UI32_T tunnel_ifindex;
            BOOL_T suppress = FALSE;
            if (ipv6TunnelTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &ipv6TunnelIndex) == FALSE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            if(FALSE == IP_LIB_ConvertTunnelIdToIfindex(ipv6TunnelIndex, &tunnel_ifindex))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            value = *(long *)var_val;
            if(value == VAL_ipv6TunnelNdRaSuppress_do_not_suppress)
            {
                suppress = FALSE;
            }
            else if(value == VAL_ipv6TunnelNdRaSuppress_suppress)
            {
                suppress = TRUE;
            }
            else
            {
                return SNMP_ERR_COMMITFAILED;
            }

            if (NETCFG_PMGR_ND_SetNdRaSuppress(tunnel_ifindex, suppress) != NETCFG_TYPE_OK)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

int write_ipv6TunnelMode(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            switch (*(long *)var_val)
            {
                case VAL_ipv6TunnelMode_configured:
                    break;

                case VAL_ipv6TunnelMode_6to4:
                    break;

                case VAL_ipv6TunnelMode_Isatap:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            I32_T value = 0;
            UI32_T ipv6TunnelIndex = 0;
            NETCFG_TYPE_L3_Interface_T tunnel_if;
            if (ipv6TunnelTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &ipv6TunnelIndex) == FALSE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            memset(&tunnel_if, 0, sizeof(NETCFG_TYPE_L3_Interface_T));
            if(FALSE == IP_LIB_ConvertTunnelIdToIfindex(ipv6TunnelIndex,&(tunnel_if.ifindex)))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            if(NETCFG_TYPE_OK != NETCFG_POM_IP_GetL3Interface(&tunnel_if))
            {
                return SNMP_ERR_COMMITFAILED;
            }
            value = *(long *)var_val;

            tunnel_if.u.tunnel_intf.tunnel_mode = (UI8_T)value;
            if (NETCFG_PMGR_IP_SetTunnelInterfaceFromSnmp(&tunnel_if) != NETCFG_TYPE_OK)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

int write_ipv6TunnelTtl(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            if (MIN_ipv6TunnelTtl > *(long *)var_val || *(long *)var_val > MAX_ipv6TunnelTtl)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            I32_T value = 0;
            UI32_T ipv6TunnelIndex = 0;
            UI32_T tunnel_ifindex;

            if (ipv6TunnelTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &ipv6TunnelIndex) == FALSE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            if(FALSE == IP_LIB_ConvertTunnelIdToIfindex(ipv6TunnelIndex, &tunnel_ifindex))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            value = *(long *)var_val;
            if (NETCFG_PMGR_IP_SetTunnelTtl(tunnel_ifindex, value) != NETCFG_TYPE_OK)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

int write_ipv6TunnelDestination(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_OCTET_STR)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if ((MINSIZE_ipv6TunnelDestination > var_val_len) || (var_val_len > MAXSIZE_ipv6TunnelDestination))
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;

        case RESERVE2:
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            char byte_buffer[MAXSIZE_ipv6TunnelDestination + 1] = {0};
            UI32_T ipv6TunnelIndex = 0;
            L_INET_AddrIp_T destination;
            NETCFG_TYPE_L3_Interface_T tunnel_if;
            if (ipv6TunnelTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &ipv6TunnelIndex) == FALSE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            memcpy(byte_buffer, var_val, var_val_len);

            byte_buffer[var_val_len] = '\0';
            memset(&destination, 0, sizeof(L_INET_Addr_T));
            L_INET_StringToInaddr(L_INET_FORMAT_IPV6_UNSPEC, byte_buffer, (L_INET_Addr_T *)&destination, sizeof(destination));

            memset(&tunnel_if, 0, sizeof(NETCFG_TYPE_L3_Interface_T));
            if(FALSE == IP_LIB_ConvertTunnelIdToIfindex(ipv6TunnelIndex,&(tunnel_if.ifindex)))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            if(NETCFG_TYPE_OK != NETCFG_POM_IP_GetL3Interface(&tunnel_if))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            memcpy(&(tunnel_if.u.tunnel_intf.dip),&destination,sizeof(L_INET_AddrIp_T));

            if (NETCFG_PMGR_IP_SetTunnelInterfaceFromSnmp(&tunnel_if) != NETCFG_TYPE_OK)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

int write_ipv6TunnelSourceVlanIfindex(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            I32_T value = 0;
            UI32_T ipv6TunnelIndex = 0;
            NETCFG_TYPE_L3_Interface_T tunnel_if;
            if (ipv6TunnelTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &ipv6TunnelIndex) == FALSE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            value = *(long *)var_val;

            memset(&tunnel_if, 0, sizeof(NETCFG_TYPE_L3_Interface_T));
            if(FALSE == IP_LIB_ConvertTunnelIdToIfindex(ipv6TunnelIndex,&(tunnel_if.ifindex)))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            if(NETCFG_TYPE_OK != NETCFG_POM_IP_GetL3Interface(&tunnel_if))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            tunnel_if.u.tunnel_intf.src_vid_ifindex = (UI32_T)value;
            if (NETCFG_PMGR_IP_SetTunnelInterfaceFromSnmp(&tunnel_if) != NETCFG_TYPE_OK)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

int write_ipv6TunnelRowStatus(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            switch (*(long *)var_val)
            {
                case VAL_ipv6TunnelRowStatus_active:
                    break;

                case VAL_ipv6TunnelRowStatus_notInService:
                    break;

                case VAL_ipv6TunnelRowStatus_notReady:
                    break;

                case VAL_ipv6TunnelRowStatus_createAndGo:
                    break;

                case VAL_ipv6TunnelRowStatus_createAndWait:
                    break;

                case VAL_ipv6TunnelRowStatus_destroy:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            I32_T value = 0;
            UI32_T ipv6TunnelIndex = 0;

            if (ipv6TunnelTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &ipv6TunnelIndex) == FALSE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            value = *(long *)var_val;

            if (NETCFG_PMGR_IP_SetTunnelRowStatus(ipv6TunnelIndex, (UI16_T)value) != NETCFG_TYPE_OK)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}
#endif

#if (SYS_CPNT_PPPOE_IA == TRUE)
int
do_pppoeiaGlobalStatus(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    BOOL_T status;

    switch (reqinfo->mode)
    {
        case MODE_GET:
        {
            if(TRUE == PPPOE_IA_PMGR_GetGlobalEnable(&status))
            {
                long_return = (status == TRUE)?
                    VAL_pppoeiaGlobalStatus_enabled : VAL_pppoeiaGlobalStatus_disabled;
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
            }
            else
            {
                return SNMP_ERR_GENERR;
            }
        }
            break;

        case MODE_SET_RESERVE1:

            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests,
                                          SNMP_ERR_WRONGTYPE);
            }

            break;

        case MODE_SET_RESERVE2:

            switch (*requests->requestvb->val.integer)
            {
                case VAL_pppoeiaGlobalStatus_enabled:
                    break;
                case VAL_pppoeiaGlobalStatus_disabled:
                    break;

                default:
                    netsnmp_set_request_error(reqinfo, requests,
                                              SNMP_ERR_WRONGVALUE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called.
             */
            break;

        case MODE_SET_ACTION:
        {
            status =
                ((*requests->requestvb->val.integer) == VAL_pppoeiaGlobalStatus_enabled)?
                    TRUE : FALSE;

            if (TRUE != PPPOE_IA_PMGR_SetGlobalEnable(status))
            {
                netsnmp_set_request_error(reqinfo, requests,
                                          SNMP_ERR_COMMITFAILED);
            }
        }
            break;

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_pppoeiaGlobalAccessNodeId(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    switch (reqinfo->mode)
    {
        case MODE_GET:
        {
            UI32_T var_len = 0;

            if (TRUE == PPPOE_IA_PMGR_GetAccessNodeId(FALSE, return_buf))
            {
                var_len = strlen((char *) return_buf);
                snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                         (u_char *)return_buf, var_len);
            }
            else
            {
                return SNMP_ERR_GENERR;
            }
        }
            break;

        case MODE_SET_RESERVE1:

            if (requests->requestvb->type != ASN_OCTET_STR)
            {
                netsnmp_set_request_error(reqinfo, requests,
                                          SNMP_ERR_WRONGTYPE);
            }

            if (requests->requestvb->val_len < MINSIZE_pppoeiaGlobalAccessNodeId ||
                requests->requestvb->val_len > MAXSIZE_pppoeiaGlobalAccessNodeId)
            {
                netsnmp_set_request_error(reqinfo, requests,
                                          SNMP_ERR_WRONGLENGTH);
            }

            break;

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called.
             */
            break;

        case MODE_SET_ACTION:
        {
            UI8_T pppoeiaGlobalAccessNodeId[MAXSIZE_pppoeiaGlobalAccessNodeId + 1];
            memcpy(pppoeiaGlobalAccessNodeId, requests->requestvb->val.string,
                   requests->requestvb->val_len);
            pppoeiaGlobalAccessNodeId[requests->requestvb->val_len] = '\0';

            if (FALSE == PPPOE_IA_PMGR_SetGlobalAdmStrDataByField(
                    PPPOE_IA_TYPE_FLDID_GLOBAL_ACC_NODE_ID,
                    pppoeiaGlobalAccessNodeId, requests->requestvb->val_len))
            {
                netsnmp_set_request_error(reqinfo, requests,
                                          SNMP_ERR_COMMITFAILED);
            }
        }
            break;

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_pppoeiaGlobalOperAccessNodeId(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    switch (reqinfo->mode)
    {
        case MODE_GET:
        {
            UI32_T var_len = 0;

            if (TRUE == PPPOE_IA_PMGR_GetAccessNodeId(TRUE, return_buf))
            {
                var_len = strlen((char *) return_buf);
                snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                         (u_char *)return_buf, var_len);
            }
            else
            {
                return SNMP_ERR_GENERR;
            }
        }
            break;


        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_pppoeiaGlobalGenericErrorMsg(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    switch (reqinfo->mode)
    {
        case MODE_GET:
        {
            UI32_T var_len = 0;

            if (TRUE == PPPOE_IA_PMGR_GetGenericErrMsg(FALSE, return_buf))
            {
                var_len = strlen((char *) return_buf);
                snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                         (u_char *)return_buf, var_len);
            }
            else
            {
                return SNMP_ERR_GENERR;
            }
        }
            break;

        case MODE_SET_RESERVE1:

            if (requests->requestvb->type != ASN_OCTET_STR)
            {
                netsnmp_set_request_error(reqinfo, requests,
                                          SNMP_ERR_WRONGTYPE);
            }

            if (requests->requestvb->val_len < MINSIZE_pppoeiaGlobalGenericErrorMsg ||
                requests->requestvb->val_len > MAXSIZE_pppoeiaGlobalGenericErrorMsg)
            {
                netsnmp_set_request_error(reqinfo, requests,
                                          SNMP_ERR_WRONGLENGTH);
            }

            break;

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called.
             */
            break;

        case MODE_SET_ACTION:
        {
            UI8_T pppoeiaGlobalGenericErrorMsg[MAXSIZE_pppoeiaGlobalGenericErrorMsg + 1];
            memcpy(pppoeiaGlobalGenericErrorMsg, requests->requestvb->val.string,
                   requests->requestvb->val_len);
            pppoeiaGlobalGenericErrorMsg[requests->requestvb->val_len] = '\0';

            if (FALSE == PPPOE_IA_PMGR_SetGlobalAdmStrDataByField(
                    PPPOE_IA_TYPE_FLDID_GLOBAL_GEN_ERMSG,
                    pppoeiaGlobalGenericErrorMsg, requests->requestvb->val_len))
            {
                netsnmp_set_request_error(reqinfo, requests,
                                          SNMP_ERR_COMMITFAILED);
            }
        }
            break;

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_pppoeiaGlobalOperGenericErrorMsg(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    switch (reqinfo->mode)
    {
        case MODE_GET:
        {
            UI32_T var_len = 0;

            if (TRUE == PPPOE_IA_PMGR_GetGenericErrMsg(TRUE, return_buf))
            {
                var_len = strlen((char *) return_buf);
                snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                         (u_char *)return_buf, var_len);
            }
            else
            {
                return SNMP_ERR_GENERR;
            }
        }
            break;


        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_pppoeiaGlobalClearStatisticsAction(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    switch (reqinfo->mode)
    {
        case MODE_GET:
        {
            long_return = VAL_pppoeiaGlobalClearStatisticsAction_noClear;
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
        }
            break;

        case MODE_SET_RESERVE1:

            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests,
                                          SNMP_ERR_WRONGTYPE);
            }

            break;

        case MODE_SET_RESERVE2:

            switch (*requests->requestvb->val.integer)
            {
                case VAL_pppoeiaGlobalClearStatisticsAction_clear:
                    break;
                case VAL_pppoeiaGlobalClearStatisticsAction_noClear:
                    break;

                default:
                    netsnmp_set_request_error(reqinfo, requests,
                                              SNMP_ERR_WRONGVALUE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called.
             */
            break;

        case MODE_SET_ACTION:
        {
            if(VAL_pppoeiaGlobalClearStatisticsAction_clear == (*requests->requestvb->val.integer))
            {
                if (FALSE == PPPOE_IA_PMGR_ClearPortStatistics(0))
                {
                    netsnmp_set_request_error(reqinfo, requests,
                                              SNMP_ERR_COMMITFAILED);
                }
            }
        }
            break;

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

#define PPPOEIAPORTENTRY_INSTANCE_LEN  1

BOOL_T pppoeiaPortTable_OidIndexToData(UI32_T exact, UI32_T compc,
            oid * compl,  UI32_T *pppoeiaPortIndex)
{
    if (exact)
    {
        if (compc != PPPOEIAPORTENTRY_INSTANCE_LEN)
        {
            return FALSE;
        }
    }

    *pppoeiaPortIndex = compl[0];
    return TRUE;
}

/*
 * var_pppoeiaPortTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *
var_pppoeiaPortTable(struct variable *vp,
            oid     *name,
            size_t  *length,
            int     exact,
            size_t  *var_len,
            WriteMethod **write_method)
{
    UI32_T compc = 0;
    UI32_T lport = 0;
    oid compl[PPPOEIAPORTENTRY_INSTANCE_LEN] = {0};
    oid best_inst[PPPOEIAPORTENTRY_INSTANCE_LEN] = {0};
    PPPOE_IA_OM_PortOprCfgEntry_T entry;

    switch (vp->magic)
    {
        case LEAF_pppoeiaPortStatus:
            *write_method = write_pppoeiaPortStatus;
            break;

        case LEAF_pppoeiaPortTrustStatus:
            *write_method = write_pppoeiaPortTrustStatus;
            break;

        case LEAF_pppoeiaPortVendorTagStrip:
            *write_method = write_pppoeiaPortVendorTagStrip;
            break;

        case LEAF_pppoeiaPortCircuitId:
            *write_method = write_pppoeiaPortCircuitId;
            break;

        case LEAF_pppoeiaPortRemoteId:
            *write_method = write_pppoeiaPortRemoteId;
            break;

#if (SYS_CPNT_PPPOE_IA_REMOTE_ID_ENHANCE == TRUE)
        case LEAF_pppoeiaPortRemoteIdDelimiterEnable:
            *write_method = write_pppoeiaPortRemoteIdDelimiterEnable;
            break;

        case LEAF_pppoeiaPortRemoteIdDelimiterAscii:
            *write_method = write_pppoeiaPortRemoteIdDelimiterAscii;
            break;
#endif
        default:
            *write_method = 0;
            break;
    }

    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,
                           compl, PPPOEIAPORTENTRY_INSTANCE_LEN);

    memset(&entry, 0, sizeof(entry));

    if (exact) /* get,set */
    {
        if (pppoeiaPortTable_OidIndexToData(exact, compc, compl, &lport) == FALSE)
        {
            return NULL;
        }

        if (PPPOE_IA_PMGR_GetPortOprCfgEntry(lport, &entry) != TRUE)
        {
            return NULL;
        }
    }
    else /* getnext */
    {
        pppoeiaPortTable_OidIndexToData(exact, compc, compl, &lport);

        /* check the length of inputing index,if < 1 we should try get
         * {0.0.0.0.0...}
         */
        if (compc < 1)
        {
            if (PPPOE_IA_PMGR_GetPortOprCfgEntry(lport, &entry) != TRUE)
            {
                if (PPPOE_IA_PMGR_GetNextPortConfigEntry(&lport, &entry) != TRUE)
                {
                    return NULL;
                }
            }
        }
        else
        {
            if (PPPOE_IA_PMGR_GetNextPortConfigEntry(&lport, &entry) != TRUE)
            {
                return NULL;
            }
        }
    }

    memcpy(name, vp->name, vp->namelen*sizeof(oid));

    best_inst[0] = lport;
    memcpy(name + vp->namelen, best_inst,
           PPPOEIAPORTENTRY_INSTANCE_LEN * sizeof(oid));
    *length = vp->namelen + PPPOEIAPORTENTRY_INSTANCE_LEN ;

    switch (vp->magic)
    {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case LEAF_pppoeiaPortIndex:
            *var_len = sizeof(long_return);
            long_return = lport;
            return (u_char *) &long_return;

#endif
        case LEAF_pppoeiaPortStatus:
            *var_len = sizeof(long_return);
            long_return = (TRUE == entry.adm_cfg.is_enable)? 1:2;
            return (u_char *) &long_return;

        case LEAF_pppoeiaPortTrustStatus:
            *var_len = sizeof(long_return);
            long_return = (TRUE == entry.adm_cfg.is_trust)? 1:2;
            return (u_char *) &long_return;

        case LEAF_pppoeiaPortVendorTagStrip:
            *var_len = sizeof(long_return);
            long_return = (TRUE == entry.adm_cfg.is_strip_vtag)? 1:2;
            return (u_char *) &long_return;

        case LEAF_pppoeiaPortCircuitId:
            *var_len  =   strlen((char *) entry.adm_cfg.circuit_id);
            memcpy(return_buf, (char *) entry.adm_cfg.circuit_id, *var_len);
            return (u_char*)return_buf;

        case LEAF_pppoeiaPortOperCircuitId:
            *var_len  =   strlen((char *) entry.opr_ccid);
            memcpy(return_buf, (char *) entry.opr_ccid, *var_len);
            return (u_char*)return_buf;

        case LEAF_pppoeiaPortRemoteId:
            *var_len  =   strlen((char *) entry.adm_cfg.remote_id);
            memcpy(return_buf, (char *) entry.adm_cfg.remote_id, *var_len);
            return (u_char*)return_buf;

        case LEAF_pppoeiaPortOperRemoteId:
            *var_len  =   strlen((char *) entry.opr_rmid);
            memcpy(return_buf, (char *) entry.opr_rmid, *var_len);
            return (u_char*)return_buf;

#if (SYS_CPNT_PPPOE_IA_REMOTE_ID_ENHANCE == TRUE)
        case LEAF_pppoeiaPortRemoteIdDelimiterEnable:
            *var_len = sizeof(long_return);
            long_return = (TRUE == entry.adm_cfg.is_rid_delim_en)? 1:2;
            return (u_char *) &long_return;

        case LEAF_pppoeiaPortRemoteIdDelimiterAscii:
            *var_len = sizeof(long_return);
            long_return = entry.adm_cfg.rid_delim_ascii;
            return (u_char *) &long_return;
#endif
        default:
            ERROR_MSG("");
    }

    return NULL;
}

int
write_pppoeiaPortStatus(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            switch (*(long *)var_val)
            {
                case VAL_pppoeiaPortStatus_enabled:
                    break;

                case VAL_pppoeiaPortStatus_disabled:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            UI32_T pppoeiaPortIndex = 0;
            BOOL_T status;

            if (pppoeiaPortTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]),  &pppoeiaPortIndex) == FALSE)
                return SNMP_ERR_COMMITFAILED;

            status = ((*(long *)var_val) == VAL_pppoeiaPortStatus_enabled)?TRUE:FALSE;

            if (FALSE == PPPOE_IA_PMGR_SetPortBoolDataByField(
                    pppoeiaPortIndex, PPPOE_IA_TYPE_FLDID_PORT_ENABLE, status))
            {
                return SNMP_ERR_COMMITFAILED;
            }
        }
            break;

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

int
write_pppoeiaPortTrustStatus(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            switch (*(long *)var_val)
            {
                case VAL_pppoeiaPortTrustStatus_enabled:
                    break;

                case VAL_pppoeiaPortTrustStatus_disabled:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            UI32_T pppoeiaPortIndex = 0;
            BOOL_T status;

            if (pppoeiaPortTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &pppoeiaPortIndex) == FALSE)
                return SNMP_ERR_COMMITFAILED;

            status = ((*(long *)var_val) == VAL_pppoeiaPortTrustStatus_enabled)?TRUE:FALSE;

            if (FALSE == PPPOE_IA_PMGR_SetPortBoolDataByField(
                    pppoeiaPortIndex, PPPOE_IA_TYPE_FLDID_PORT_TRUST, status))
            {
                return SNMP_ERR_COMMITFAILED;
            }

        }
            break;

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

int
write_pppoeiaPortVendorTagStrip(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            switch (*(long *)var_val)
            {
                case VAL_pppoeiaPortVendorTagStrip_enabled:
                    break;

                case VAL_pppoeiaPortVendorTagStrip_disabled:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            UI32_T pppoeiaPortIndex = 0;
            BOOL_T status;

            if (pppoeiaPortTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]),  &pppoeiaPortIndex) == FALSE)
                return SNMP_ERR_COMMITFAILED;

            status = ((*(long *)var_val) == VAL_pppoeiaPortTrustStatus_enabled)?TRUE:FALSE;

            if (FALSE == PPPOE_IA_PMGR_SetPortBoolDataByField(
                    pppoeiaPortIndex, PPPOE_IA_TYPE_FLDID_PORT_STRIP_VENDOR, status))
            {
                return SNMP_ERR_COMMITFAILED;
            }
        }
            break;

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

int
write_pppoeiaPortCircuitId(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_OCTET_STR)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len < MINSIZE_pppoeiaPortCircuitId ||
                var_val_len > MAXSIZE_pppoeiaPortCircuitId)
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;

        case RESERVE2:
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            UI8_T byte_buffer[MAXSIZE_pppoeiaPortCircuitId + 1] = {0};
            UI32_T pppoeiaPortIndex = 0;

            if (pppoeiaPortTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &pppoeiaPortIndex) == FALSE)
                return SNMP_ERR_COMMITFAILED;

            memcpy(byte_buffer, var_val, var_val_len);
            byte_buffer[var_val_len] = '\0';

            if (FALSE == PPPOE_IA_PMGR_SetPortAdmStrDataByField(
                pppoeiaPortIndex, PPPOE_IA_TYPE_FLDID_PORT_CIRCUIT_ID, byte_buffer, var_val_len))
            {
                return SNMP_ERR_COMMITFAILED;
            }
        }
            break;

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

int
write_pppoeiaPortRemoteId(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_OCTET_STR)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len < MINSIZE_pppoeiaPortRemoteId ||
                var_val_len > MAXSIZE_pppoeiaPortRemoteId)
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;

        case RESERVE2:
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            UI8_T byte_buffer[MAXSIZE_pppoeiaPortRemoteId + 1] = {0};
            UI32_T pppoeiaPortIndex = 0;

            if (pppoeiaPortTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &pppoeiaPortIndex) == FALSE)
                return SNMP_ERR_COMMITFAILED;

            memcpy(byte_buffer, var_val, var_val_len);
            byte_buffer[var_val_len] = '\0';

            if (FALSE == PPPOE_IA_PMGR_SetPortAdmStrDataByField(
                pppoeiaPortIndex, PPPOE_IA_TYPE_FLDID_PORT_REMOTE_ID, byte_buffer, var_val_len))
            {
                return SNMP_ERR_COMMITFAILED;
            }
        }
            break;

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

#if (SYS_CPNT_PPPOE_IA_REMOTE_ID_ENHANCE == TRUE)
int write_pppoeiaPortRemoteIdDelimiterEnable(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    /* dispatch action
     */
    switch (action)
    {
        case RESERVE1:
            /* check type and length
             */
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            /* check valid values
             */
            switch (*(long *) var_val)
            {
                case VAL_pppoeiaPortRemoteIdDelimiterEnable_enabled:
                    break;

                case VAL_pppoeiaPortRemoteIdDelimiterEnable_disabled:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            UI32_T pppoeiaPortIndex = 0;
            BOOL_T status;

            if (pppoeiaPortTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]),  &pppoeiaPortIndex) == FALSE)
                return SNMP_ERR_COMMITFAILED;

            status = ((*(long *)var_val) == VAL_pppoeiaPortRemoteIdDelimiterEnable_enabled)?TRUE:FALSE;

            if (FALSE == PPPOE_IA_PMGR_SetPortBoolDataByField(
                    pppoeiaPortIndex, PPPOE_IA_TYPE_FLDID_PORT_RID_DELIM, status))
            {
                return SNMP_ERR_COMMITFAILED;
            }
        }
            break;

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    /* return success
     */
    return SNMP_ERR_NOERROR;
}

int write_pppoeiaPortRemoteIdDelimiterAscii(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    /* dispatch action
     */
    switch (action)
    {
        case RESERVE1:
            /* check type and length
             */
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            /* check valid values
             */
            if ((*(long *) var_val < MIN_pppoeiaPortRemoteIdDelimiterAscii)
                || (*(long *) var_val > MAX_pppoeiaPortRemoteIdDelimiterAscii))
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            UI32_T pppoeiaPortIndex = 0;
            UI32_T tmp_val;

            if (pppoeiaPortTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]),  &pppoeiaPortIndex) == FALSE)
                return SNMP_ERR_COMMITFAILED;

            tmp_val = *(long *)var_val;

            if (tmp_val == MAX_pppoeiaPortRemoteIdDelimiterAscii)
            {
                tmp_val = PPPOE_IA_TYPE_DFLT_RID_DASCII;
            }

            if (FALSE == PPPOE_IA_PMGR_SetPortUi32DataByField(
                    pppoeiaPortIndex, PPPOE_IA_TYPE_FLDID_PORT_RID_DASCII, tmp_val))
            {
                return SNMP_ERR_COMMITFAILED;
            }
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    /* return success
     */
    return SNMP_ERR_NOERROR;
}
#endif  /* #if (SYS_CPNT_PPPOE_IA_REMOTE_ID_ENHANCE == TRUE) */

#define PPPOEIAPORTSTATSENTRY_INSTANCE_LEN  1

BOOL_T pppoeiaPortStatsTable_OidIndexToData(UI32_T exact, UI32_T compc,
            oid * compl,  UI32_T *pppoeiaPortStatsIndex)
{
    if (exact)
    {
        if (compc != PPPOEIAPORTSTATSENTRY_INSTANCE_LEN)
        {
            return FALSE;
        }
    }

    *pppoeiaPortStatsIndex = compl[0];

    return TRUE;
}

unsigned char *
var_pppoeiaPortStatsTable(struct variable *vp,
            oid     *name,
            size_t  *length,
            int     exact,
            size_t  *var_len,
            WriteMethod **write_method)
{
    UI32_T compc = 0;
    UI32_T lport = 0;
    oid compl[PPPOEIAPORTSTATSENTRY_INSTANCE_LEN] = {0};
    oid best_inst[PPPOEIAPORTSTATSENTRY_INSTANCE_LEN] = {0};
    PPPOE_IA_OM_PortStsEntry_T entry;

    switch (vp->magic)
    {
        case LEAF_pppoeiaPortStatsClearAction:
            *write_method = write_pppoeiaPortStatsClearAction;
            break;

        default:
            *write_method = 0;
            break;
    }

    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,
                           compl, PPPOEIAPORTSTATSENTRY_INSTANCE_LEN);

    memset(&entry, 0, sizeof(entry));

    if (exact)
    {
        if (pppoeiaPortStatsTable_OidIndexToData(exact, compc, compl, &lport) == FALSE)
        {
            return NULL;
        }

        if (PPPOE_IA_PMGR_GetPortStatisticsEntry(lport, &entry) != TRUE)
        {
            return NULL;
        }
    }
    else
    {
        pppoeiaPortStatsTable_OidIndexToData(exact, compc, compl, &lport);

        if (compc < 1)
        {
            if (PPPOE_IA_PMGR_GetPortStatisticsEntry(lport, &entry) != TRUE)
            {
                if (PPPOE_IA_PMGR_GetNextPortStatisticsEntry(&lport, &entry) != TRUE)
                {
                    return NULL;
                }
            }
        }
        else
        {
            if (PPPOE_IA_PMGR_GetNextPortStatisticsEntry(&lport, &entry) != TRUE)
            {
                return NULL;
            }
        }
    }

    memcpy(name, vp->name, vp->namelen*sizeof(oid));

    best_inst[0] = lport;
    memcpy(name + vp->namelen, best_inst,
           PPPOEIAPORTSTATSENTRY_INSTANCE_LEN * sizeof(oid));
    *length = vp->namelen + PPPOEIAPORTSTATSENTRY_INSTANCE_LEN ;

    switch (vp->magic)
    {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case LEAF_pppoeiaPortStatsIndex:
            *var_len = sizeof(long_return);
            long_return = lport;
            return (u_char *) &long_return;

#endif
        case LEAF_pppoeiaPortStatsRecvPkts:
            *var_len = sizeof(long_return);
            long_return = entry.all;
            return (u_char *) &long_return;

        case LEAF_pppoeiaPortStatsRecvPadiPkts:
            *var_len = sizeof(long_return);
            long_return = entry.padi;
            return (u_char *) &long_return;

        case LEAF_pppoeiaPortStatsRecvPadoPkts:
            *var_len = sizeof(long_return);
            long_return = entry.pado;
            return (u_char *) &long_return;

        case LEAF_pppoeiaPortStatsRecvPadrPkts:
            *var_len = sizeof(long_return);
            long_return = entry.padr;
            return (u_char *) &long_return;

        case LEAF_pppoeiaPortStatsRecvPadsPkts:
            *var_len = sizeof(long_return);
            long_return = entry.pads;
            return (u_char *) &long_return;

        case LEAF_pppoeiaPortStatsRecvPadtPkts:
            *var_len = sizeof(long_return);
            long_return = entry.padt;
            return (u_char *) &long_return;

        case LEAF_pppoeiaPortStatsDropUntrustRespPkts:
            *var_len = sizeof(long_return);
            long_return = entry.rep_untrust;
            return (u_char *) &long_return;

        case LEAF_pppoeiaPortStatsDropUntrustReqPkts:
            *var_len = sizeof(long_return);
            long_return = entry.req_untrust;
            return (u_char *) &long_return;

        case LEAF_pppoeiaPortStatsDropMalformedPkts:
            *var_len = sizeof(long_return);
            long_return = entry.malform;
            return (u_char *) &long_return;

        case LEAF_pppoeiaPortStatsClearAction:
            *var_len = sizeof(long_return);
            long_return = VAL_pppoeiaPortStatsClearAction_noClear;
            return (u_char *) &long_return;

        default:
            ERROR_MSG("");
    }

    return NULL;
}

int
write_pppoeiaPortStatsClearAction(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            switch (*(long *)var_val)
            {
                case VAL_pppoeiaPortStatsClearAction_clear:
                    break;

                case VAL_pppoeiaPortStatsClearAction_noClear:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            I32_T value = 0;
            UI32_T pppoeiaPortStatsIndex = 0;

            if (pppoeiaPortStatsTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &pppoeiaPortStatsIndex) == FALSE)
                return SNMP_ERR_COMMITFAILED;

            value = *(long *)var_val;

            if(VAL_pppoeiaPortStatsClearAction_clear == (*(long *)var_val))
            {
                if (FALSE == PPPOE_IA_PMGR_ClearPortStatistics(pppoeiaPortStatsIndex))
                {
                    return SNMP_ERR_COMMITFAILED;
                }
            }
        }
            break;

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

#endif /* #if (SYS_CPNT_PPPOE_IA == TRUE) */

#if (SYS_CPNT_IPV6_RA_GUARD == TRUE)

#define IPV6RAGUARDPORTENTRY_INSTANCE_LEN  1

BOOL_T ipv6RaGuardPortTable_OidIndexToData(UI32_T exact, UI32_T compc,
    oid *compl, UI32_T *ipv6RaGuardPortIndex)
{
    /* get or set
     */
    if (exact)
    {
        /* check the index length
         */
        if (compc != IPV6RAGUARDPORTENTRY_INSTANCE_LEN) /* the constant size index */
        {
            return FALSE;
        }
    }

    *ipv6RaGuardPortIndex = compl[0];

    return TRUE;
}

/*
 * var_ipv6RaGuardPortTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *var_ipv6RaGuardPortTable(struct variable *vp,
    oid *name,
    size_t *length,
    int exact,
    size_t *var_len,
    WriteMethod **write_method)
{
    UI32_T  compc = 0;
    oid     compl[IPV6RAGUARDPORTENTRY_INSTANCE_LEN] = {0};
    oid     best_inst[IPV6RAGUARDPORTENTRY_INSTANCE_LEN] = {0};
    UI32_T  lport;
    BOOL_T  is_enable;

    switch (vp->magic)
    {
        case LEAF_ipv6RaGuardPortStatus:
            *write_method = write_ipv6RaGuardPortStatus;
            break;

        default:
            *write_method = 0;
            break;
    }

    /* check compc, retrive compl
     */
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl, IPV6RAGUARDPORTENTRY_INSTANCE_LEN);

    if (exact) /* get or set */
    {
        if (ipv6RaGuardPortTable_OidIndexToData(exact, compc, compl, &lport) == FALSE)
        {
            return NULL;
        }

        if (NETCFG_PMGR_ND_RAGUARD_GetPortStatus(lport, &is_enable) != TRUE)
        {
            return NULL;
        }
    }
    else /* getnext */
    {
        ipv6RaGuardPortTable_OidIndexToData(exact, compc, compl, &lport);

        /* check the length of inputing index,if < 1 we should try get
         * {0.0.0.0.0...}
         */
        if (compc < 1)
        {
            if (NETCFG_PMGR_ND_RAGUARD_GetPortStatus(lport, &is_enable) != TRUE)
            {
                if (NETCFG_PMGR_ND_RAGUARD_GetNextPortStatus(&lport, &is_enable) != TRUE)
                {
                    return NULL;
                }
            }
        }
        else
        {
            if (NETCFG_PMGR_ND_RAGUARD_GetNextPortStatus(&lport, &is_enable) != TRUE)
            {
                return NULL;
            }
        }
    }

    memcpy(name, vp->name, vp->namelen * sizeof(oid));

    /* assign data to the oid index
     */
    best_inst[0] = lport;
    memcpy(name + vp->namelen, best_inst, IPV6RAGUARDPORTENTRY_INSTANCE_LEN * sizeof(oid));
    *length = vp->namelen + IPV6RAGUARDPORTENTRY_INSTANCE_LEN;

    switch (vp->magic)
    {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case LEAF_ipv6RaGuardPortIndex:
            *var_len = sizeof(long_return);

            long_return = lport;

            return (u_char *) &long_return;
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

        case LEAF_ipv6RaGuardPortStatus:
            *var_len = sizeof(long_return);

            long_return = (is_enable == TRUE) ?
                            VAL_ipv6RaGuardPortStatus_enabled :
                            VAL_ipv6RaGuardPortStatus_disabled;

            return (u_char *) &long_return;

        default:
            ERROR_MSG("");
    }

    return NULL;
}

int write_ipv6RaGuardPortStatus(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            switch (*(long *)var_val)
            {
                case VAL_ipv6RaGuardPortStatus_enabled:
                    break;

                case VAL_ipv6RaGuardPortStatus_disabled:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T  oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            I32_T   value = 0;
            UI32_T  lport = 0;
            BOOL_T  is_enable;

            if (ipv6RaGuardPortTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &lport) == FALSE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            value = *(long *)var_val;

            is_enable = (value == VAL_ipv6RaGuardPortStatus_enabled) ? TRUE : FALSE;

            if (NETCFG_PMGR_ND_RAGUARD_SetPortStatus(lport, is_enable) != TRUE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}
#endif /* #if (SYS_CPNT_IPV6_RA_GUARD == TRUE) */

#if (SYS_CPNT_DHCP_INFORM == TRUE)
/********************************************
 *****************dhcpInformTable***************
 ********************************************
 */
#define DHCPINFORMENTRY_INSTANCE_LEN  1

BOOL_T dhcpInformTable_OidIndexToData(UI32_T exact, UI32_T compc,
    oid *compl, UI32_T *dhcpInformIfIndex)
{
    /* get or set
     */
    if (exact)
    {
        /* check the index length
         */
        if (compc != DHCPINFORMENTRY_INSTANCE_LEN) /* the constant size index */
        {
            return FALSE;
        }
    }

    *dhcpInformIfIndex = compl[0];

    return TRUE;
}

/*
 * var_dhcpInformTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *var_dhcpInformTable(struct variable *vp,
    oid *name,
    size_t *length,
    int exact,
    size_t *var_len,
    WriteMethod **write_method)
{
    UI32_T compc = 0;
    oid compl[DHCPINFORMENTRY_INSTANCE_LEN] = {0};
    oid best_inst[DHCPINFORMENTRY_INSTANCE_LEN] = {0};
    UI32_T ifindex=0;
    NETCFG_TYPE_L3_Interface_T l3_if;

    switch (vp->magic)
    {
        case LEAF_dhcpInformStatus:
            *write_method = write_dhcpInformStatus;
            break;

        default:
            *write_method = 0;
            break;
    }

    /* check compc, retrive compl
     */
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl, DHCPINFORMENTRY_INSTANCE_LEN);
    memset(&l3_if, 0, sizeof(l3_if));

    if (exact) /* get or set */
    {
        if (dhcpInformTable_OidIndexToData(exact, compc, compl, &ifindex) == FALSE)
        {
            return NULL;
        }

        l3_if.ifindex = ifindex;
        if (NETCFG_POM_IP_GetL3Interface(&l3_if) != NETCFG_TYPE_OK)
        {
            return NULL;
        }
    }
    else /* getnext */
    {
        dhcpInformTable_OidIndexToData(exact, compc, compl, &ifindex);

        /* check the length of inputing index,if < 1 we should try get
         * {0.0.0.0.0...}
         */
        if (compc < 1)
        {
            l3_if.ifindex = SYS_ADPT_VLAN_1_IF_INDEX_NUMBER -1;
            if(NETCFG_POM_IP_GetNextL3Interface(&l3_if)!= NETCFG_TYPE_OK)
            {
                return NULL;
            }
        }
        else
        {
            l3_if.ifindex = ifindex;
            if(NETCFG_POM_IP_GetNextL3Interface(&l3_if)!= NETCFG_TYPE_OK)
            {
                return NULL;
            }
        }

    }

    memcpy(name, vp->name, vp->namelen * sizeof(oid));

    /* assign data to the oid index
     */
    best_inst[0] = l3_if.ifindex;
    memcpy(name + vp->namelen, best_inst, DHCPINFORMENTRY_INSTANCE_LEN * sizeof(oid));
    *length = vp->namelen + DHCPINFORMENTRY_INSTANCE_LEN;

    switch (vp->magic)
    {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case LEAF_dhcpInformIfIndex:
            *var_len = sizeof(long_return);
            long_return = l3_if.ifindex;
            return (u_char *) &long_return;
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

        case LEAF_dhcpInformStatus:
            *var_len = sizeof(long_return);
            if(l3_if.dhcp_inform)
                long_return = VAL_dhcpInformStatus_enabled;
            else
                long_return = VAL_dhcpInformStatus_disabled;
            return (u_char *) &long_return;

        default:
            ERROR_MSG("");
    }

    return NULL;
}

int write_dhcpInformStatus(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            switch (*(long *)var_val)
            {
                case VAL_dhcpInformStatus_enabled:
                    break;

                case VAL_dhcpInformStatus_disabled:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 7;
            I32_T value = 0;
            UI32_T dhcpInformIfIndex = 0;

            if (dhcpInformTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &dhcpInformIfIndex) == FALSE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            value = *(long *)var_val;

            if(value == VAL_dhcpInformStatus_enabled)
            {
                if(NETCFG_PMGR_IP_SetDhcpInform(dhcpInformIfIndex, TRUE) != NETCFG_TYPE_OK)
                {
                    return SNMP_ERR_COMMITFAILED;
                }
            }
            else if(value == VAL_dhcpInformStatus_disabled)
            {
                if(NETCFG_PMGR_IP_SetDhcpInform(dhcpInformIfIndex, FALSE) != NETCFG_TYPE_OK)
                {
                    return SNMP_ERR_COMMITFAILED;
                }
            }
            else
                return SNMP_ERR_COMMITFAILED;


            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}
#endif /* #if (SYS_CPNT_DHCP_INFORM == TRUE)*/

#if (SYS_CPNT_DHCPV6SNP == TRUE)
/********************************************
 *****************dhcpv6SnoopMgt*************
 ********************************************
 */
int do_dhcpv6SnoopEnable(netsnmp_mib_handler *handler,
    netsnmp_handler_registration *reginfo,
    netsnmp_agent_request_info *reqinfo,
    netsnmp_request_info *requests)
{
    UI8_T global_status=0;
    /* dispatch get vs. set
     */
    switch (reqinfo->mode)
    {
        /* GET REQUEST
         */
        case MODE_GET:
        {
            /* get from core layer
             */

            if (DHCPV6SNP_TYPE_OK!=DHCPV6SNP_POM_GetGlobalSnoopingStatus(&global_status))
            {
                return SNMP_ERR_GENERR;
            }
            else
            {
                long_return = global_status;
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                    (u_char *) &long_return, sizeof(long_return));
            }

            break;
        }

        /* SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            /* check type and length
             */
            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
                return SNMP_ERR_NOERROR;
            }

            break;

        case MODE_SET_RESERVE2:
            switch (*requests->requestvb->val.integer)
            {
                case VAL_dhcpv6SnoopEnable_enabled:
                    break;

                case VAL_dhcpv6SnoopEnable_disabled:
                    break;

                default:
                    netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
                    return SNMP_ERR_NOERROR;
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called.
             */
            break;

        case MODE_SET_ACTION:
        {
            /* set to core layer
             */
            if (DHCPV6SNP_TYPE_OK!=DHCPV6SNP_PMGR_SetGlobalSnoopingStatus((UI8_T)(*requests->requestvb->val.integer)))
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
                return SNMP_ERR_NOERROR;
            }

            break;
        }

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}



int do_dhcpv6SnoopBindingTableClearAction(netsnmp_mib_handler *handler,
    netsnmp_handler_registration *reginfo,
    netsnmp_agent_request_info *reqinfo,
    netsnmp_request_info *requests)
{

    /* dispatch get vs. set
     */
    switch (reqinfo->mode)
    {

        /* GET REQUEST
         */
        case MODE_GET:
        {
            /* always returns noClear when get dhcpv6SnoopBindingTableClearAction. */
            long_return = VAL_dhcpv6SnoopBindingTableClearAction_noClear;
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                    (u_char *) &long_return, sizeof(long_return));

        }
        break;

        /* SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            /* check type and length
             */
            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
                return SNMP_ERR_NOERROR;
            }

            break;

        case MODE_SET_RESERVE2:
            switch (*requests->requestvb->val.integer)
            {
                case VAL_dhcpv6SnoopBindingTableClearAction_noClear:
                    break;

                case VAL_dhcpv6SnoopBindingTableClearAction_clear:
                    break;

                default:
                    netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
                    return SNMP_ERR_NOERROR;
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called.
             */
            break;

        case MODE_SET_ACTION:
        {

            /* set to core layer
             */
            if (*requests->requestvb->val.integer == VAL_dhcpv6SnoopBindingTableClearAction_clear)
            {
                if(DHCPV6SNP_TYPE_OK!=DHCPV6SNP_PMGR_ClearAllDynamicBindingTable())
                {
                    netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
                    return SNMP_ERR_COMMITFAILED;
                }
            }

            break;
        }

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int do_dhcpv6SnoopStatisticsClearAction(netsnmp_mib_handler *handler,
    netsnmp_handler_registration *reginfo,
    netsnmp_agent_request_info *reqinfo,
    netsnmp_request_info *requests)
{

    /* dispatch get vs. set
     */
    switch (reqinfo->mode)
    {
        /* GET REQUEST
         */
        case MODE_GET:
        {
            /* always returns noClear when get dhcpv6SnoopStatisticsClearAction. */
            long_return = VAL_dhcpv6SnoopStatisticsClearAction_noClear;
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                    (u_char *) &long_return, sizeof(long_return));

        }
        break;
        /* SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            /* check type and length
             */
            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
                return SNMP_ERR_NOERROR;
            }

            break;

        case MODE_SET_RESERVE2:
            switch (*requests->requestvb->val.integer)
            {
                case VAL_dhcpv6SnoopStatisticsClearAction_noClear:
                    break;

                case VAL_dhcpv6SnoopStatisticsClearAction_clear:
                    break;

                default:
                    netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
                    return SNMP_ERR_NOERROR;
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called.
             */
            break;

        case MODE_SET_ACTION:
        {

            /* set to core layer
             */
            if (*requests->requestvb->val.integer == VAL_dhcpv6SnoopStatisticsClearAction_clear)
            {
                if(DHCPV6SNP_TYPE_OK!=DHCPV6SNP_PMGR_ClearStatisticCounters())
                {
                    netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
                    return SNMP_ERR_COMMITFAILED;
                }
            }
            break;
        }

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

#if(SYS_CPNT_DHCPV6SNP_REMOTE_ID_OPTION == TRUE)
int do_dhcpv6SnoopOptionRemoteIdEnable(netsnmp_mib_handler *handler,
    netsnmp_handler_registration *reginfo,
    netsnmp_agent_request_info *reqinfo,
    netsnmp_request_info *requests)
{
    switch (reqinfo->mode)
    {
        case MODE_GET:
        {
            UI8_T  status  = 0;
            if (DHCPV6SNP_TYPE_OK == DHCPV6SNP_POM_GetRemoteIdStatus(&status))
            {
                long_return = status;
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *)&long_return, sizeof(long_return));
            }
            else
            {
                return SNMP_ERR_GENERR;
            }

            break;
        }

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            if (requests->requestvb->type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case MODE_SET_RESERVE2:
            switch (*requests->requestvb->val.integer)
            {
                case VAL_dhcpv6SnoopOptionRemoteIdEnable_enabled:
                    break;

                case VAL_dhcpv6SnoopOptionRemoteIdEnable_disabled:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called.
             */
            break;

        case MODE_SET_ACTION:
        {
            if (DHCPV6SNP_TYPE_OK != DHCPV6SNP_PMGR_SetRemoteIdStatus(*requests->requestvb->val.integer))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int do_dhcpv6SnoopOptionRemoteIdPolicy(netsnmp_mib_handler *handler,
    netsnmp_handler_registration *reginfo,
    netsnmp_agent_request_info *reqinfo,
    netsnmp_request_info *requests)
{
    switch (reqinfo->mode)
    {
        case MODE_GET:
        {
            UI8_T  policy  = 0;
            if (DHCPV6SNP_TYPE_OK != DHCPV6SNP_POM_GetRemoteIdPolicy(&policy))
            {
                long_return = policy;
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *)&long_return, sizeof(long_return));
            }
            else
            {
                return SNMP_ERR_GENERR;
            }

            break;
        }

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            if (requests->requestvb->type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case MODE_SET_RESERVE2:
            switch (*requests->requestvb->val.integer)
            {
                case VAL_dhcpv6SnoopOptionRemoteIdPolicy_drop:
                    break;

                case VAL_dhcpv6SnoopOptionRemoteIdPolicy_keep:
                    break;

                case VAL_dhcpv6SnoopOptionRemoteIdPolicy_replace:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called.
             */
            break;

        case MODE_SET_ACTION:
        {
            if (DHCPV6SNP_TYPE_OK != DHCPV6SNP_PMGR_SetRemoteIdPolicy(*requests->requestvb->val.integer))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
#endif


#define DHCPV6SNOOPVLANCONFIGENTRY_INSTANCE_LEN  1

BOOL_T dhcpv6SnoopVlanConfigTable_OidIndexToData(UI32_T exact, UI32_T compc,
    oid *compl, UI32_T *dhcpv6SnoopVlanIndex)
{
    /* get or set
     */
    if (exact)
    {
        /* check the index length
         */
        if (compc != DHCPV6SNOOPVLANCONFIGENTRY_INSTANCE_LEN)  /* the constant size index */
        {
            return FALSE;
        }
    }

    *dhcpv6SnoopVlanIndex = compl[0];

    return TRUE;
}

/*
 * var_dhcpv6SnoopVlanConfigTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *var_dhcpv6SnoopVlanConfigTable(struct variable *vp,
    oid *name,
    size_t *length,
    int exact,
    size_t *var_len,
    WriteMethod **write_method)
{
    UI32_T compc = 0;
    oid compl[DHCPV6SNOOPVLANCONFIGENTRY_INSTANCE_LEN] = {0};
    oid best_inst[DHCPV6SNOOPVLANCONFIGENTRY_INSTANCE_LEN] = {0};

    /* table-specific variables
     */
    UI32_T vid=0;
    UI8_T  vlan_status=0;


    /* dispatch node to set write method
     */
    switch (vp->magic)
    {
        case LEAF_dhcpv6SnoopVlanEnable:
            *write_method = write_dhcpv6SnoopVlanEnable;
            break;

        default:
            *write_method = 0;
            break;
    }

    /* check compc, retrive compl
     */
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl,
        DHCPV6SNOOPVLANCONFIGENTRY_INSTANCE_LEN);

    /* dispatch get-exact versus get-next
     */
    if (exact)  /* get or set */
    {
        /* extract index
         */
        if (! dhcpv6SnoopVlanConfigTable_OidIndexToData(exact, compc, compl,&vid))
        {
            return NULL;
        }

        /* get-exact from core layer
         */
        if (DHCPV6SNP_TYPE_OK!=DHCPV6SNP_POM_GetVlanSnoopingStatus(vid, &vlan_status))
        {
            return NULL;
        }
    }
    else  /* get-next */
    {
        /* extract index
         */
        if(!dhcpv6SnoopVlanConfigTable_OidIndexToData(exact, compc, compl,&vid))
        {
            return NULL;
        }

        /* Check the length of inputing index.  If compc is less than the
         * instance length, we should try get {A.B.C.0.0...}, where A.B.C was
         * obtained from the "..._OidIndexToData" function call, and
         * 0.0... was initialized in the beginning of this function.
         * This instance may exist in the core layer.
         */
        if (compc < DHCPV6SNOOPVLANCONFIGENTRY_INSTANCE_LEN)  /* incomplete index */
        {

            /* get-exact, in case this instance exists
             */
            if (DHCPV6SNP_TYPE_OK != DHCPV6SNP_POM_GetVlanSnoopingStatus(vid, &vlan_status))
            {

                if (DHCPV6SNP_TYPE_OK != DHCPV6SNP_PMGR_GetNextExistVlanSnoopingStatus(&vid, &vlan_status))
                {
                    return NULL;
                }

            }
        }
        else   /* complete index */
        {

            if (DHCPV6SNP_TYPE_OK != DHCPV6SNP_PMGR_GetNextExistVlanSnoopingStatus(&vid, &vlan_status))
            {
                return NULL;
            }

        }
    }

    /* copy base OID (without index) to output
     */
    memcpy(name, vp->name, vp->namelen * sizeof(oid));

    /* assign data to the OID index
     */
    best_inst[0] = vid;
    memcpy(name + vp->namelen, best_inst, DHCPV6SNOOPVLANCONFIGENTRY_INSTANCE_LEN * sizeof(oid));
    *length = vp->namelen + DHCPV6SNOOPVLANCONFIGENTRY_INSTANCE_LEN;

    /* dispatch node to read value
     */
    switch (vp->magic)
    {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case LEAF_dhcpv6SnoopVlanIndex:
            *var_len = sizeof(long_return);
            long_return = vid;
            return (u_char *) &long_return;
#endif  /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */
        case LEAF_dhcpv6SnoopVlanEnable:
            *var_len = sizeof(long_return);
            long_return = vlan_status;
            return (u_char *) &long_return;

        default:
            ERROR_MSG("");
            break;
    }

    /* return failure
     */
    return NULL;
}

int write_dhcpv6SnoopVlanEnable(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    /* dispatch action
     */
    switch (action)
    {
        case RESERVE1:
            /* check type and length
             */
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            /* check valid values
             */
            switch (*(long *) var_val)
            {
                case VAL_dhcpv6SnoopVlanEnable_enabled:
                    break;

                case VAL_dhcpv6SnoopVlanEnable_disabled:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
            I32_T value = 0;

            /* table-specific variables
             */
            UI32_T dhcpv6SnoopVlanIndex = 0;

            /* extract index
             */
            if (! dhcpv6SnoopVlanConfigTable_OidIndexToData(TRUE,
                name_len - oid_name_length,
                &(name[oid_name_length]),
                &dhcpv6SnoopVlanIndex))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            /* get user value
             */
            value = *(long *)var_val;

            /* set to core layer
             */
            if (DHCPV6SNP_TYPE_OK != DHCPV6SNP_PMGR_SetVlanSnoopingStatus(dhcpv6SnoopVlanIndex, (UI8_T)value))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    /* return success
     */
    return SNMP_ERR_NOERROR;
}


#define DHCPV6SNOOPPORTCONFIGENTRY_INSTANCE_LEN  1

BOOL_T dhcpv6SnoopPortConfigTable_OidIndexToData(UI32_T exact, UI32_T compc,
    oid *compl, UI32_T *dhcpv6SnoopPortIfIndex)
{
    /* get or set
     */
    if (exact)
    {
        /* check the index length
         */
        if (compc != DHCPV6SNOOPPORTCONFIGENTRY_INSTANCE_LEN)  /* the constant size index */
        {
            return FALSE;
        }
    }

    *dhcpv6SnoopPortIfIndex = compl[0];

    return TRUE;
}

/*
 * var_dhcpv6SnoopPortConfigTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *var_dhcpv6SnoopPortConfigTable(struct variable *vp,
    oid *name,
    size_t *length,
    int exact,
    size_t *var_len,
    WriteMethod **write_method)
{
    UI32_T compc = 0;
    oid compl[DHCPV6SNOOPPORTCONFIGENTRY_INSTANCE_LEN] = {0};
    oid best_inst[DHCPV6SNOOPPORTCONFIGENTRY_INSTANCE_LEN] = {0};

    /* table-specific variables
     */
    UI32_T lport=0;
    DHCPV6SNP_OM_PortConfig_T entry;

    /* dispatch node to set write method
     */
    switch (vp->magic)
    {
        case LEAF_dhcpv6SnoopPortTrustEnable:
            *write_method = write_dhcpv6SnoopPortTrustEnable;
            break;

        case LEAF_dhcpv6SnoopPortMaxBinding:
            *write_method = write_dhcpv6SnoopPortMaxBinding;
            break;

        default:
            *write_method = 0;
            break;
    }

    /* check compc, retrive compl
     */
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl,
        DHCPV6SNOOPPORTCONFIGENTRY_INSTANCE_LEN);

    memset(&entry, 0, sizeof(entry));

    /* dispatch get-exact versus get-next
     */
    if (exact)  /* get or set */
    {
        /* extract index
         */
        if (! dhcpv6SnoopPortConfigTable_OidIndexToData(exact, compc, compl,&lport))
        {
            return NULL;
        }

        /* get-exact from core layer
         */
        if (DHCPV6SNP_TYPE_OK != DHCPV6SNP_POM_GetPortInfo(lport,&entry))
        {
            return NULL;
        }
    }
    else  /* get-next */
    {
        /* extract index
         */
        if(!dhcpv6SnoopPortConfigTable_OidIndexToData(exact, compc, compl,&lport))
        {
            return NULL;
        }

        /* Check the length of inputing index.  If compc is less than the
         * instance length, we should try get {A.B.C.0.0...}, where A.B.C was
         * obtained from the "..._OidIndexToData" function call, and
         * 0.0... was initialized in the beginning of this function.
         * This instance may exist in the core layer.
         */
        if (compc < DHCPV6SNOOPPORTCONFIGENTRY_INSTANCE_LEN)  /* incomplete index */
        {
            /* get-exact, in case this instance exists
             */
            if (DHCPV6SNP_TYPE_OK != DHCPV6SNP_POM_GetPortInfo(lport,&entry))
            {
                if(DHCPV6SNP_TYPE_OK != DHCPV6SNP_POM_GetNextPortInfo(&lport, &entry))
                {
                    return NULL;
                }

            }
        }
        else   /* complete index */
        {
            /* get-next according to lexicographic order; if none, fail
             */

            if(DHCPV6SNP_TYPE_OK != DHCPV6SNP_POM_GetNextPortInfo(&lport, &entry))
            {
                return NULL;
            }
        }
    }

    /* copy base OID (without index) to output
     */
    memcpy(name, vp->name, vp->namelen * sizeof(oid));

    /* assign data to the OID index
     */
    best_inst[0] = lport;
    memcpy(name + vp->namelen, best_inst, DHCPV6SNOOPPORTCONFIGENTRY_INSTANCE_LEN * sizeof(oid));
    *length = vp->namelen + DHCPV6SNOOPPORTCONFIGENTRY_INSTANCE_LEN;

    /* dispatch node to read value
     */
    switch (vp->magic)
    {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case LEAF_dhcpv6SnoopPortIfIndex:
            *var_len = sizeof(long_return);
            long_return = lport;
            return (u_char *) &long_return;
#endif  /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

        case LEAF_dhcpv6SnoopPortTrustEnable:
            *var_len = sizeof(long_return);
            long_return = entry.trust_status;
            return (u_char *) &long_return;

        case LEAF_dhcpv6SnoopPortMaxBinding:
            *var_len = sizeof(long_return);
            long_return = entry.max_binding;
            return (u_char *) &long_return;

        case LEAF_dhcpv6SnoopPortCurrentBinding:
            *var_len = sizeof(long_return);
            long_return = entry.binding_num;
            return (u_char *) &long_return;

        default:
            ERROR_MSG("");
            break;
    }

    /* return failure
     */
    return NULL;
}

int write_dhcpv6SnoopPortTrustEnable(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    /* dispatch action
     */
    switch (action)
    {
        case RESERVE1:
            /* check type and length
             */
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            /* check valid values
             */
            switch (*(long *) var_val)
            {
                case VAL_dhcpv6SnoopPortTrustEnable_enabled:
                    break;

                case VAL_dhcpv6SnoopPortTrustEnable_disabled:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
            I32_T value = 0;

            /* table-specific variables
             */
            UI32_T dhcpv6SnoopPortIfIndex = 0;

            /* extract index
             */
            if (! dhcpv6SnoopPortConfigTable_OidIndexToData(TRUE,
                name_len - oid_name_length,
                &(name[oid_name_length]),
                &dhcpv6SnoopPortIfIndex))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            /* get user value
             */
            value = *(long *)var_val;

            /* set to core layer
             */
            if (DHCPV6SNP_TYPE_OK != DHCPV6SNP_PMGR_SetPortTrustStatus(dhcpv6SnoopPortIfIndex, (UI8_T)value))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    /* return success
     */
    return SNMP_ERR_NOERROR;
}

int write_dhcpv6SnoopPortMaxBinding(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    /* dispatch action
     */
    switch (action)
    {
        case RESERVE1:
            /* check type and length
             */
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            /* check valid values
             */
            if ((*(long *) var_val < MIN_dhcpv6SnoopPortMaxBinding)
                || (*(long *) var_val > MAX_dhcpv6SnoopPortMaxBinding))
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
            I32_T value = 0;

            /* table-specific variables
             */
            UI32_T dhcpv6SnoopPortIfIndex = 0;

            /* extract index
             */
            if (! dhcpv6SnoopPortConfigTable_OidIndexToData(TRUE,
                name_len - oid_name_length,
                &(name[oid_name_length]),
                &dhcpv6SnoopPortIfIndex))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            /* get user value
             */
            value = *(long *)var_val;

            /* set to core layer
             */
            if (DHCPV6SNP_TYPE_OK != DHCPV6SNP_PMGR_SetPortMaxBinding(dhcpv6SnoopPortIfIndex, (UI8_T)value))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    /* return success
     */
    return SNMP_ERR_NOERROR;
}



#define DHCPV6SNOOPBINDINGENTRY_INSTANCE_LEN  264

BOOL_T dhcpv6SnoopBindingTable_OidIndexToData(UI32_T exact, UI32_T compc,
    oid *compl, UI8_T *dhcpv6SnoopBindingLinkLayerAddress, UI32_T *dhcpv6SnoopBindingIaType, UI32_T *dhcpv6SnoopBindingIaId, UI8_T *dhcpv6SnoopBindingIpv6Address,UI32_T *dhcpv6SnoopBindingIpv6Address_length)
{
    UI32_T i=0;
    /* get or set
     */
    if (exact)
    {
        /* check the index length
         */
        if ((compc < 10)
            || (compc > DHCPV6SNOOPBINDINGENTRY_INSTANCE_LEN))  /* the dynamic size index */
        {
            return FALSE;
        }
    }


    for (i=0; i < SIZE_dhcpv6SnoopBindingLinkLayerAddress; i++)
    {
        dhcpv6SnoopBindingLinkLayerAddress[i] = compl[0 + i];
    }

    *dhcpv6SnoopBindingIaType = compl[6];
    *dhcpv6SnoopBindingIaId = compl[7];
    if ((compl[8] < MINSIZE_dhcpv6SnoopBindingIpv6Address)
        || (compl[8] > MAXSIZE_dhcpv6SnoopBindingIpv6Address))
    {
        return FALSE;
    }

    for (i = 0; i < compl[8]; i++)
    {
        dhcpv6SnoopBindingIpv6Address[i] = compl[9 + i];
    }
    dhcpv6SnoopBindingIpv6Address[compl[8]] = '\0';
    *dhcpv6SnoopBindingIpv6Address_length = compl[8];

    return TRUE;
}

/*
 * var_dhcpv6SnoopBindingTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *var_dhcpv6SnoopBindingTable(struct variable *vp,
    oid *name,
    size_t *length,
    int exact,
    size_t *var_len,
    WriteMethod **write_method)
{
    UI32_T compc = 0;
    oid compl[DHCPV6SNOOPBINDINGENTRY_INSTANCE_LEN] = {0};
    oid best_inst[DHCPV6SNOOPBINDINGENTRY_INSTANCE_LEN] = {0};

    /* table-specific variables
     */
    DHCPV6SNP_TYPE_Binding_T entry;
    UI32_T i=0;
    UI32_T addr_len=0;
    UI8_T addr_str[MAXSIZE_dhcpv6SnoopBindingIpv6Address+1]={0};
    UI32_T ia_type=0;
    /* dispatch node to set write method
     */
    switch (vp->magic)
    {
        default:
            *write_method = 0;
            break;
    }

    /* check compc, retrive compl
     */
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl,
        DHCPV6SNOOPBINDINGENTRY_INSTANCE_LEN);

    memset(&entry, 0, sizeof(entry));

    /* dispatch get-exact versus get-next
     */
    if (exact)  /* get or set */
    {
        /* extract index
         */
        if (! dhcpv6SnoopBindingTable_OidIndexToData(exact, compc, compl,
            entry.link_layer_addr,
            &ia_type,
            &(entry.ia_info.ia_id),
            addr_str,
            &addr_len))
        {
            return NULL;
        }

        entry.ia_info.ia_type = (UI16_T) ia_type;

        if(TRUE != L_INET_Pton(L_INET_AF_INET6, (char *)addr_str, entry.ia_info.addr.addr))
        {
            return NULL;
        }

        /* get-exact from core layer
         */
        if (DHCPV6SNP_TYPE_OK != DHCPV6SNP_POM_GetBindingEntryForMIB(DHCPV6SNP_OM_SECOND_KEY_INDEX,&entry))
        {
            return NULL;
        }
    }
    else  /* get-next */
    {
        /* extract index
         */
        if(!dhcpv6SnoopBindingTable_OidIndexToData(exact, compc, compl,
            entry.link_layer_addr,
            &ia_type,
            &(entry.ia_info.ia_id),
            addr_str,
            &addr_len))
        {
            return NULL;
        }

        entry.ia_info.ia_type = (UI16_T) ia_type;

        if(TRUE != L_INET_Pton(L_INET_AF_INET6, (char *)addr_str, entry.ia_info.addr.addr))
        {
            if (DHCPV6SNP_TYPE_OK != DHCPV6SNP_POM_GetNextBindingEntryForMIB(DHCPV6SNP_OM_SECOND_KEY_INDEX,&entry))
            {
                return NULL;
            }
        }
        else
        {
            /* check the length of inputing index,if < 1 we should try get
             * {0.0.0.0.0...}
             */
            if (compc < 1)  /* incomplete index */
            {
                /* get-exact, in case this instance exists */
                if (DHCPV6SNP_TYPE_OK != DHCPV6SNP_POM_GetBindingEntryForMIB(DHCPV6SNP_OM_SECOND_KEY_INDEX,&entry))
                {
                   /* get-next according to lexicographic order; if none, fail*/
                   if (DHCPV6SNP_TYPE_OK != DHCPV6SNP_POM_GetNextBindingEntryForMIB(DHCPV6SNP_OM_SECOND_KEY_INDEX,&entry))
                    {
                        return NULL;
                    }
                }
            }
            else   /* complete index */
            {
                /* get-next according to lexicographic order; if none, fail
                 */
                if (DHCPV6SNP_TYPE_OK != DHCPV6SNP_POM_GetNextBindingEntryForMIB(DHCPV6SNP_OM_SECOND_KEY_INDEX,&entry))
                {
                    return NULL;
                }
            }
        }
    }
    /* copy base OID (without index) to output
     */
    memcpy(name, vp->name, vp->namelen * sizeof(oid));

    /* assign data to the OID index
     */

    for (i = 0; i < SIZE_dhcpv6SnoopBindingLinkLayerAddress; i++)
    {
        best_inst[0 + i] = entry.link_layer_addr[i];
    }

    best_inst[6] = entry.ia_info.ia_type;
    best_inst[7] = entry.ia_info.ia_id;

    L_INET_Ntop(L_INET_AF_INET6, entry.ia_info.addr.addr, (char*)addr_str, sizeof(addr_str));
    addr_len = strlen((char*)addr_str);

    best_inst[8] = addr_len;

    for (i = 0; i < best_inst[8]; i++)
    {
        best_inst[9 + i] = addr_str[i];
    }

    memcpy(name + vp->namelen, best_inst, (9 + best_inst[8]) * sizeof(oid)); /* check */
    *length = vp->namelen + 9 + best_inst[8];

    /* dispatch node to read value */
    switch (vp->magic)
    {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case LEAF_dhcpv6SnoopBindingLinkLayerAddress:
            *var_len = SIZE_dhcpv6SnoopBindingLinkLayerAddress;
            memcpy(return_buf, entry.link_layer_addr, *var_len);
            return (u_char *) return_buf;
#endif  /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case LEAF_dhcpv6SnoopBindingIaType:
            *var_len = sizeof(long_return);
            long_return = entry.ia_info.ia_type;
            return (u_char *) &long_return;
#endif  /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case LEAF_dhcpv6SnoopBindingIaId:
            *var_len = sizeof(long_return);
            long_return = entry.ia_info.ia_id;
            return (u_char *) &long_return;
#endif  /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case LEAF_dhcpv6SnoopBindingIpv6Address:
            *var_len = addr_len;
            memcpy(return_buf, addr_str, *var_len);
            return (u_char *) return_buf;
#endif  /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

        case LEAF_dhcpv6SnoopBindingVlanIndex:
            *var_len = sizeof(long_return);
            long_return = entry.vid;
            return (u_char *) &long_return;

        case LEAF_dhcpv6SnoopBindingPortIfIndex:
            *var_len = sizeof(long_return);
            long_return = entry.lport;
            return (u_char *) &long_return;

        case LEAF_dhcpv6SnoopBindingLifeTime:
            *var_len = sizeof(long_return);
            long_return = entry.ia_info.lifetime;
            return (u_char *) &long_return;

        default:
            ERROR_MSG("");
            break;
    }

    /* return failure
     */
    return NULL;
}

int get_dhcpSnoopRecvClientPkts(netsnmp_mib_handler *handler,
    netsnmp_handler_registration *reginfo,
    netsnmp_agent_request_info *reqinfo,
    netsnmp_request_info *requests)
{
    DHCPV6SNP_OM_Statistics_T statistic;
    /* dispatch get vs. set
     */
    switch (reqinfo->mode)
    {
        /* GET REQUEST
         */
        case MODE_GET:
        {
            memset(&statistic, 0, sizeof(statistic));

            /* get from core layer
             */
            if(DHCPV6SNP_TYPE_OK != DHCPV6SNP_POM_GetStatisticCounter(DHCPV6SNP_TYPE_STATISTIC_COUNTER_ROLE_CLIENT, &statistic))
            {
                return SNMP_ERR_GENERR;
            }
            else
            {
                long_return = statistic.counter[DHCPV6SNP_TYPE_STATISTIC_COUNTER_TYPE_RECEIVE];
                snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER,
                    (u_char *) &long_return, sizeof(long_return));
            }

            break;
        }

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int get_dhcpSnoopSentClientPkts(netsnmp_mib_handler *handler,
    netsnmp_handler_registration *reginfo,
    netsnmp_agent_request_info *reqinfo,
    netsnmp_request_info *requests)
{
    DHCPV6SNP_OM_Statistics_T statistic;
    /* dispatch get vs. set
     */
    switch (reqinfo->mode)
    {
        /* GET REQUEST
         */
        case MODE_GET:
        {
            memset(&statistic, 0, sizeof(statistic));
            /* get from core layer
             */
            if(DHCPV6SNP_TYPE_OK != DHCPV6SNP_POM_GetStatisticCounter(DHCPV6SNP_TYPE_STATISTIC_COUNTER_ROLE_CLIENT, &statistic))
            {
                return SNMP_ERR_GENERR;
            }
            else
            {
                long_return = statistic.counter[DHCPV6SNP_TYPE_STATISTIC_COUNTER_TYPE_FORWARD];
                snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER,
                    (u_char *) &long_return, sizeof(long_return));
            }

            break;
        }

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int get_dhcpSnoopDroppedClientPkts(netsnmp_mib_handler *handler,
    netsnmp_handler_registration *reginfo,
    netsnmp_agent_request_info *reqinfo,
    netsnmp_request_info *requests)
{
    DHCPV6SNP_OM_Statistics_T statistic;
    /* dispatch get vs. set
     */
    switch (reqinfo->mode)
    {
        /* GET REQUEST
         */
        case MODE_GET:
        {
            memset(&statistic, 0, sizeof(statistic));
            /* get from core layer
             */
            if(DHCPV6SNP_TYPE_OK != DHCPV6SNP_POM_GetStatisticCounter(DHCPV6SNP_TYPE_STATISTIC_COUNTER_ROLE_CLIENT, &statistic))
            {
                return SNMP_ERR_GENERR;
            }
            else
            {
                long_return = statistic.counter[DHCPV6SNP_TYPE_STATISTIC_COUNTER_TYPE_DROP];
                snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER,
                    (u_char *) &long_return, sizeof(long_return));
            }

            break;
        }

        default:
            return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}
int get_dhcpSnoopRecvServerPkts(netsnmp_mib_handler *handler,
    netsnmp_handler_registration *reginfo,
    netsnmp_agent_request_info *reqinfo,
    netsnmp_request_info *requests)
{
    DHCPV6SNP_OM_Statistics_T statistic;
    /* dispatch get vs. set
     */
    switch (reqinfo->mode)
    {
        /* GET REQUEST
         */
        case MODE_GET:
        {
            memset(&statistic, 0, sizeof(statistic));
            /* get from core layer
             */
            if(DHCPV6SNP_TYPE_OK != DHCPV6SNP_POM_GetStatisticCounter(DHCPV6SNP_TYPE_STATISTIC_COUNTER_ROLE_SERVER, &statistic))
            {
                return SNMP_ERR_GENERR;
            }
            else
            {
                long_return = statistic.counter[DHCPV6SNP_TYPE_STATISTIC_COUNTER_TYPE_RECEIVE];
                snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER,
                    (u_char *) &long_return, sizeof(long_return));
            }

            break;
        }

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int get_dhcpSnoopSentServerPkts(netsnmp_mib_handler *handler,
    netsnmp_handler_registration *reginfo,
    netsnmp_agent_request_info *reqinfo,
    netsnmp_request_info *requests)
{
    DHCPV6SNP_OM_Statistics_T statistic;
    /* dispatch get vs. set
     */
    switch (reqinfo->mode)
    {
        /* GET REQUEST
         */
        case MODE_GET:
        {
            memset(&statistic, 0, sizeof(statistic));
            /* get from core layer
             */
            if(DHCPV6SNP_TYPE_OK != DHCPV6SNP_POM_GetStatisticCounter(DHCPV6SNP_TYPE_STATISTIC_COUNTER_ROLE_SERVER, &statistic))
            {
                return SNMP_ERR_GENERR;
            }
            else
            {
                long_return = statistic.counter[DHCPV6SNP_TYPE_STATISTIC_COUNTER_TYPE_FORWARD];
                snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER,
                    (u_char *) &long_return, sizeof(long_return));
            }

            break;
        }

        default:
            return SNMP_ERR_GENERR;
    }


    return SNMP_ERR_NOERROR;
}
int get_dhcpSnoopDroppedServerPkts(netsnmp_mib_handler *handler,
    netsnmp_handler_registration *reginfo,
    netsnmp_agent_request_info *reqinfo,
    netsnmp_request_info *requests)
{
    DHCPV6SNP_OM_Statistics_T statistic;
    /* dispatch get vs. set
     */
    switch (reqinfo->mode)
    {
        /* GET REQUEST
         */
        case MODE_GET:
        {
            memset(&statistic, 0, sizeof(statistic));
            /* get from core layer
             */
            if(DHCPV6SNP_TYPE_OK != DHCPV6SNP_POM_GetStatisticCounter(DHCPV6SNP_TYPE_STATISTIC_COUNTER_ROLE_SERVER, &statistic))
            {
                return SNMP_ERR_GENERR;
            }
            else
            {
                long_return = statistic.counter[DHCPV6SNP_TYPE_STATISTIC_COUNTER_TYPE_DROP];
                snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER,
                    (u_char *) &long_return, sizeof(long_return));
            }

            break;
        }

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int get_dhcpSnoopRecvRelayPkts(netsnmp_mib_handler *handler,
    netsnmp_handler_registration *reginfo,
    netsnmp_agent_request_info *reqinfo,
    netsnmp_request_info *requests)
{
    DHCPV6SNP_OM_Statistics_T statistic;
    /* dispatch get vs. set
     */
    switch (reqinfo->mode)
    {
        /* GET REQUEST
         */
        case MODE_GET:
        {
            memset(&statistic, 0, sizeof(statistic));
            /* get from core layer
             */
            if(DHCPV6SNP_TYPE_OK != DHCPV6SNP_POM_GetStatisticCounter(DHCPV6SNP_TYPE_STATISTIC_COUNTER_ROLE_RELAY, &statistic))
            {
                return SNMP_ERR_GENERR;
            }
            else
            {
                long_return = statistic.counter[DHCPV6SNP_TYPE_STATISTIC_COUNTER_TYPE_RECEIVE];
                snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER,
                    (u_char *) &long_return, sizeof(long_return));
            }

            break;
        }

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;

}
int get_dhcpSnoopSentRelayPkts(netsnmp_mib_handler *handler,
    netsnmp_handler_registration *reginfo,
    netsnmp_agent_request_info *reqinfo,
    netsnmp_request_info *requests)
{
    DHCPV6SNP_OM_Statistics_T statistic;
    /* dispatch get vs. set
     */
    switch (reqinfo->mode)
    {
        /* GET REQUEST
         */
        case MODE_GET:
        {
            memset(&statistic, 0, sizeof(statistic));
            /* get from core layer
             */
            if(DHCPV6SNP_TYPE_OK != DHCPV6SNP_POM_GetStatisticCounter(DHCPV6SNP_TYPE_STATISTIC_COUNTER_ROLE_RELAY, &statistic))
            {
                return SNMP_ERR_GENERR;
            }
            else
            {
                long_return = statistic.counter[DHCPV6SNP_TYPE_STATISTIC_COUNTER_TYPE_FORWARD];
                snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER,
                    (u_char *) &long_return, sizeof(long_return));
            }

            break;
        }

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int get_dhcpSnoopDroppedRelayPkts(netsnmp_mib_handler *handler,
    netsnmp_handler_registration *reginfo,
    netsnmp_agent_request_info *reqinfo,
    netsnmp_request_info *requests)
{
    DHCPV6SNP_OM_Statistics_T statistic;
    /* dispatch get vs. set
     */
    switch (reqinfo->mode)
    {
        /* GET REQUEST
         */
        case MODE_GET:
        {
            memset(&statistic, 0, sizeof(statistic));
            /* get from core layer
             */
            if(DHCPV6SNP_TYPE_OK != DHCPV6SNP_POM_GetStatisticCounter(DHCPV6SNP_TYPE_STATISTIC_COUNTER_ROLE_RELAY, &statistic))
            {
                return SNMP_ERR_GENERR;
            }
            else
            {
                long_return = statistic.counter[DHCPV6SNP_TYPE_STATISTIC_COUNTER_TYPE_DROP];
                snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER,
                    (u_char *) &long_return, sizeof(long_return));
            }

            break;
        }

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

#endif /* end of #if (SYS_CPNT_DHCPV6SNP == TRUE)*/


#if (SYS_CPNT_IPV6_SOURCE_GUARD == TRUE)
/********************************************
 *****************ip6SrcGuardMgt*************
 ********************************************
 */
#define IP6SRCGUARDCONFIGENTRY_INSTANCE_LEN  1

BOOL_T ip6SrcGuardConfigTable_OidIndexToData(UI32_T exact, UI32_T compc,
    oid *compl, UI32_T *ip6SrcGuardPortIfIndex)
{
    /* get or set
     */
    if (exact)
    {
        /* check the index length
         */
        if (compc != IP6SRCGUARDCONFIGENTRY_INSTANCE_LEN) /* the constant size index */
        {
            return FALSE;
        }
    }

    *ip6SrcGuardPortIfIndex = compl[0];

    return TRUE;
}

/*
 * var_ip6SrcGuardConfigTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *var_ip6SrcGuardConfigTable(struct variable *vp,
    oid *name,
    size_t *length,
    int exact,
    size_t *var_len,
    WriteMethod **write_method)
{
    UI32_T compc = 0;
    oid compl[IP6SRCGUARDCONFIGENTRY_INSTANCE_LEN] = {0};
    oid best_inst[IP6SRCGUARDCONFIGENTRY_INSTANCE_LEN] = {0};
    IP6SG_OM_PortConfig_T entry;
    UI32_T lport=0;
    UI32_T trunk_ifindex=0;
    BOOL_T is_static=FALSE;

    switch (vp->magic)
    {
        case LEAF_ip6SrcGuardMode:
            *write_method = write_ip6SrcGuardMode;
            break;

        case LEAF_ip6SrcGuardMaxBinding:
            *write_method = write_ip6SrcGuardMaxBinding;
            break;

        default:
            *write_method = 0;
            break;
    }

    /* check compc, retrive compl
     */
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl, IP6SRCGUARDCONFIGENTRY_INSTANCE_LEN);

    memset(&entry, 0, sizeof(entry));

    if (exact) /* get or set */
    {
        if (ip6SrcGuardConfigTable_OidIndexToData(exact, compc, compl, &lport) == FALSE)
        {
            return NULL;
        }

        if (IP6SG_TYPE_OK != IP6SG_POM_GetPortInfo(lport, &entry))
        {
            return NULL;
        }
    }
    else /* getnext */
    {
        ip6SrcGuardConfigTable_OidIndexToData(exact, compc, compl, &lport);

        /* check the length of inputing index,if < 1 we should try get
         * {0.0.0.0.0...}
         */
        if (compc < 1)
        {
            if (IP6SG_TYPE_OK != IP6SG_POM_GetPortInfo(lport, &entry))
            {
                if (IP6SG_TYPE_OK != IP6SG_POM_GetNextPortInfo(&lport, &entry))
                {
                    return NULL;
                }
            }
        }
        else
        {
            if (IP6SG_TYPE_OK != IP6SG_POM_GetNextPortInfo(&lport, &entry))
            {
                return NULL;
            }
        }
    }

    if(SWCTRL_POM_IsTrunkMember(lport, &trunk_ifindex, &is_static))
    {
        return NULL;
    }

    if(SWCTRL_POM_LogicalPortIsTrunkPort(lport))
    {
        return NULL;
    }

    memcpy(name, vp->name, vp->namelen * sizeof(oid));

    /* assign data to the oid index
     */
    best_inst[0] = lport;
    /* check next line description */
    memcpy(name + vp->namelen, best_inst, IP6SRCGUARDCONFIGENTRY_INSTANCE_LEN * sizeof(oid));
    *length = vp->namelen + IP6SRCGUARDCONFIGENTRY_INSTANCE_LEN;

    switch (vp->magic)
    {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case LEAF_ip6SrcGuardPortIfIndex:
            *var_len = sizeof(long_return);
            long_return = lport;
            return (u_char *) &long_return;
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

        case LEAF_ip6SrcGuardMode:
            *var_len = sizeof(long_return);
            long_return = entry.filter_mode;
            return (u_char *) &long_return;

        case LEAF_ip6SrcGuardMaxBinding:
            *var_len = sizeof(long_return);
            long_return = entry.max_binding;
            return (u_char *) &long_return;

        default:
            ERROR_MSG("");
    }

    return NULL;
}

int write_ip6SrcGuardMode(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            switch (*(long *)var_val)
            {
                case VAL_ip6SrcGuardMode_disabled:
                    break;

                case VAL_ip6SrcGuardMode_srcIp:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            UI32_T value = 0;
            UI32_T ip6SrcGuardPortIfIndex = 0;

            if (ip6SrcGuardConfigTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &ip6SrcGuardPortIfIndex) == FALSE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            value = *(long *)var_val;

            if (IP6SG_TYPE_OK != IP6SG_PMGR_SetPortFilterMode(ip6SrcGuardPortIfIndex, (UI8_T)value))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

int write_ip6SrcGuardMaxBinding(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            if (MIN_ip6SrcGuardMaxBinding > *(long *)var_val || *(long *)var_val > MAX_ip6SrcGuardMaxBinding)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            UI32_T value = 0;
            UI32_T ip6SrcGuardPortIfIndex = 0;

            if (ip6SrcGuardConfigTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &ip6SrcGuardPortIfIndex) == FALSE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            value = *(long *)var_val;

            if (IP6SG_TYPE_OK != IP6SG_PMGR_SetPortMaxBinding(ip6SrcGuardPortIfIndex, (UI8_T)value))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

#define IP6SRCGUARDADDRENTRY_INSTANCE_LEN  23

BOOL_T ip6SrcGuardAddrTable_OidIndexToData(UI32_T exact, UI32_T compc,
    oid *compl, UI32_T *ip6SrcGuardBindingType, UI8_T *ip6SrcGuardBindingMacAddress, UI8_T *ip6SrcGuardBindingIpv6Address)
{
    UI32_T i=0;

    /* get or set
     */
    if (exact)
    {
        /* check the index length
         */
        if (compc != IP6SRCGUARDADDRENTRY_INSTANCE_LEN) /* the constant size index */
        {
            return FALSE;
        }
    }

    *ip6SrcGuardBindingType = compl[0];
    for (i=0; i < SIZE_ip6SrcGuardBindingMacAddress; i++)
    {
        ip6SrcGuardBindingMacAddress[i] = compl[1 + i];
    }
    for (i=0; i < SIZE_ip6SrcGuardBindingIpv6Address; i++)
    {
        ip6SrcGuardBindingIpv6Address[i] = compl[7 + i];
    }

    return TRUE;
}

/*
 * var_ip6SrcGuardAddrTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *var_ip6SrcGuardAddrTable(struct variable *vp,
    oid *name,
    size_t *length,
    int exact,
    size_t *var_len,
    WriteMethod **write_method)
{
    UI32_T compc = 0;
    oid compl[IP6SRCGUARDADDRENTRY_INSTANCE_LEN] = {0};
    oid best_inst[IP6SRCGUARDADDRENTRY_INSTANCE_LEN] = {0};
    IP6SG_TYPE_Binding_T entry;
    UI32_T i=0;
    UI32_T binding_type=0;

    switch (vp->magic)
    {
        case LEAF_ip6SrcGuardBindingVlanIndex:
            *write_method = write_ip6SrcGuardBindingVlanIndex;
            break;

        case LEAF_ip6SrcGuardBindingPortIfIndex:
            *write_method = write_ip6SrcGuardBindingPortIfIndex;
            break;

        case LEAF_ip6SrcGuardBindingStatus:
            *write_method = write_ip6SrcGuardBindingStatus;
            break;

        default:
            *write_method = 0;
            break;
    }

    /* check compc, retrive compl
     */
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl, IP6SRCGUARDADDRENTRY_INSTANCE_LEN);

    memset(&entry, 0, sizeof(entry));

    if (exact) /* get or set */
    {
        if (ip6SrcGuardAddrTable_OidIndexToData(exact, compc, compl, &binding_type, entry.link_layer_addr, entry.ipv6_addr.addr) == FALSE)
        {
            return NULL;
        }

        entry.binding_type = (UI8_T)binding_type;
        if (IP6SG_TYPE_OK != IP6SG_POM_GetBindingEntry(&entry))
        {
            return NULL;
        }
    }
    else /* getnext */
    {
        ip6SrcGuardAddrTable_OidIndexToData(exact, compc, compl, &binding_type, entry.link_layer_addr, entry.ipv6_addr.addr);
        entry.binding_type = (UI8_T)binding_type;
        /* check the length of inputing index,if < 1 we should try get
         * {0.0.0.0.0...}
         */
        if (compc < 1)
        {
            if (IP6SG_TYPE_OK != IP6SG_POM_GetBindingEntry(&entry))
            {
                if (IP6SG_TYPE_OK != IP6SG_POM_GetNextBindingEntryFromSnmp(&entry))
                {
                    return NULL;
                }
            }
        }
        else
        {
            if (IP6SG_TYPE_OK != IP6SG_POM_GetNextBindingEntryFromSnmp(&entry))
            {
                return NULL;
            }
        }
    }

    memcpy(name, vp->name, vp->namelen * sizeof(oid));

    /* assign data to the oid index
     */
    best_inst[0] = entry.binding_type;
    for (i = 0; i < SIZE_ip6SrcGuardBindingMacAddress; i++)
    {
        best_inst[1 + i] = entry.link_layer_addr[i];
    }
    for (i = 0; i < SIZE_ip6SrcGuardBindingIpv6Address; i++)
    {
        best_inst[7 + i] = entry.ipv6_addr.addr[i];
    }
    /* need to check next line */
    memcpy(name + vp->namelen, best_inst, IP6SRCGUARDADDRENTRY_INSTANCE_LEN * sizeof(oid));
    *length = vp->namelen + IP6SRCGUARDADDRENTRY_INSTANCE_LEN;

    switch (vp->magic)
    {
        case LEAF_ip6SrcGuardBindingType:
            *var_len = sizeof(long_return);
            long_return = entry.binding_type;
            return (u_char *) &long_return;

#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case LEAF_ip6SrcGuardBindingMacAddress:
            *var_len = SIZE_ip6SrcGuardBindingMacAddress;
            memcpy(return_buf, entry.link_layer_addr, *var_len);
            return (u_char *) return_buf;
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case LEAF_ip6SrcGuardBindingIpv6Address:
            *var_len = SIZE_ip6SrcGuardBindingIpv6Address;
            memcpy(return_buf, entry.ipv6_addr, *var_len);
            return (u_char *) return_buf;
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

        case LEAF_ip6SrcGuardBindingVlanIndex:
            *var_len = sizeof(long_return);
            long_return = entry.vid;
            return (u_char *) &long_return;

        case LEAF_ip6SrcGuardBindingPortIfIndex:
            *var_len = sizeof(long_return);
            long_return = entry.lport;
            return (u_char *) &long_return;

        case LEAF_ip6SrcGuardBindingStatus:
            *var_len = sizeof(long_return);
            long_return = entry.row_status;
            return (u_char *) &long_return;

        default:
            ERROR_MSG("");
    }

    return NULL;
}

int write_ip6SrcGuardBindingVlanIndex(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_UNSIGNED)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            UI32_T value = 0;
            UI32_T ip6SrcGuardBindingType = 0;
            UI8_T ip6SrcGuardBindingMacAddress[SIZE_ip6SrcGuardBindingMacAddress] = {0};
            UI8_T ip6SrcGuardBindingIpv6Address[SIZE_ip6SrcGuardBindingIpv6Address] = {0};

            if (ip6SrcGuardAddrTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &ip6SrcGuardBindingType, ip6SrcGuardBindingMacAddress, ip6SrcGuardBindingIpv6Address) == FALSE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            value = *(u_long *)var_val;

            if (IP6SG_TYPE_OK != IP6SG_PMGR_SetBindingVlanIndex((UI8_T)ip6SrcGuardBindingType, ip6SrcGuardBindingMacAddress, ip6SrcGuardBindingIpv6Address, value))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

int write_ip6SrcGuardBindingPortIfIndex(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            if (MIN_ip6SrcGuardBindingPortIfIndex > *(long *)var_val || *(long *)var_val > MAX_ip6SrcGuardBindingPortIfIndex)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            I32_T value = 0;
            UI32_T ip6SrcGuardBindingType = 0;
            UI8_T ip6SrcGuardBindingMacAddress[SIZE_ip6SrcGuardBindingMacAddress] = {0};
            UI8_T ip6SrcGuardBindingIpv6Address[SIZE_ip6SrcGuardBindingIpv6Address] = {0};

            if (ip6SrcGuardAddrTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &ip6SrcGuardBindingType, ip6SrcGuardBindingMacAddress, ip6SrcGuardBindingIpv6Address) == FALSE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            value = *(long *)var_val;

            if (IP6SG_TYPE_OK != IP6SG_PMGR_SetBindingPortIfIndex((UI8_T)ip6SrcGuardBindingType, ip6SrcGuardBindingMacAddress, ip6SrcGuardBindingIpv6Address, value))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

int write_ip6SrcGuardBindingStatus(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            switch (*(long *)var_val)
            {
                case VAL_ip6SrcGuardBindingStatus_active:
                    break;

                case VAL_ip6SrcGuardBindingStatus_notInService:
                    break;

                case VAL_ip6SrcGuardBindingStatus_notReady:
                    break;

                case VAL_ip6SrcGuardBindingStatus_createAndGo:
                    break;

                case VAL_ip6SrcGuardBindingStatus_createAndWait:
                    break;

                case VAL_ip6SrcGuardBindingStatus_destroy:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            I32_T value = 0;
            UI32_T ip6SrcGuardBindingType = 0;
            UI8_T ip6SrcGuardBindingMacAddress[SIZE_ip6SrcGuardBindingMacAddress] = {0};
            UI8_T ip6SrcGuardBindingIpv6Address[SIZE_ip6SrcGuardBindingIpv6Address] = {0};

            if (ip6SrcGuardAddrTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &ip6SrcGuardBindingType, ip6SrcGuardBindingMacAddress, ip6SrcGuardBindingIpv6Address) == FALSE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            value = *(long *)var_val;

            if (IP6SG_TYPE_OK != IP6SG_PMGR_SetBindingRowStatus((UI8_T)ip6SrcGuardBindingType, ip6SrcGuardBindingMacAddress, ip6SrcGuardBindingIpv6Address, value))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}




#endif /* end of #if (SYS_CPNT_IPV6_SOURCE_GUARD == TRUE)*/

#if (SYS_CPNT_CN == TRUE)
/********************************************
 *****************cnGlobal*******************
 ********************************************
 */
int do_cnGlobalAdminStatus(netsnmp_mib_handler *handler,
    netsnmp_handler_registration *reginfo,
    netsnmp_agent_request_info *reqinfo,
    netsnmp_request_info *requests)
{
    switch (reqinfo->mode)
    {
        case MODE_GET:
        {
            UI32_T value = 0;

            if (CN_POM_GetGlobalAdminStatus(&value) == CN_TYPE_RETURN_OK)
            {
                long_return = value;
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *)&long_return, sizeof(long_return));
            }
            else
            {
                return SNMP_ERR_GENERR;
            }

            break;
        }

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            if (requests->requestvb->type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case MODE_SET_RESERVE2:
            switch (*requests->requestvb->val.integer)
            {
                case VAL_cnGlobalAdminStatus_enabled:
                case VAL_cnGlobalAdminStatus_disabled:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called.
             */
            break;

        case MODE_SET_ACTION:
        {
            if (CN_PMGR_SetGlobalAdminStatus(*requests->requestvb->val.integer) != CN_TYPE_RETURN_OK)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int get_cnGlobalOperStatus(netsnmp_mib_handler *handler,
    netsnmp_handler_registration *reginfo,
    netsnmp_agent_request_info *reqinfo,
    netsnmp_request_info *requests)
{
    switch (reqinfo->mode)
    {
        case MODE_GET:
        {
            UI32_T value = 0;
            if (CN_POM_GetGlobalOperStatus(&value) == CN_TYPE_RETURN_OK)
            {
                long_return = value;
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *)&long_return, sizeof(long_return));
            }
            else
            {
                return SNMP_ERR_GENERR;
            }

            break;
        }

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int do_cnCnmTransmitPriority(netsnmp_mib_handler *handler,
    netsnmp_handler_registration *reginfo,
    netsnmp_agent_request_info *reqinfo,
    netsnmp_request_info *requests)
{
    switch (reqinfo->mode)
    {
        case MODE_GET:
        {
            UI32_T value = 0;

            if (CN_POM_GetCnmTxPriority(&value) == CN_TYPE_RETURN_OK)
            {
                long_return = value;
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *)&long_return, sizeof(long_return));
            }
            else
            {
                return SNMP_ERR_GENERR;
            }

            break;
        }

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            if (requests->requestvb->type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case MODE_SET_RESERVE2:
            if ((*requests->requestvb->val.integer < MIN_cnCnmTransmitPriority) ||
                (*requests->requestvb->val.integer > MAX_cnCnmTransmitPriority))
            {
               return SNMP_ERR_WRONGVALUE;
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called.
             */
            break;

        case MODE_SET_ACTION:
        {
            if (CN_PMGR_SetCnmTxPriority(*requests->requestvb->val.integer) != CN_TYPE_RETURN_OK)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int get_cnDiscardedFrames(netsnmp_mib_handler *handler,
    netsnmp_handler_registration *reginfo,
    netsnmp_agent_request_info *reqinfo,
    netsnmp_request_info *requests)
{
    switch (reqinfo->mode)
    {
        case MODE_GET:
        {
#if (SYS_CPNT_NMTR_PERQ_COUNTER == TRUE)
            SWDRV_IfPerQStats_T     if_perq_stats;
            CN_TYPE_CpEntry_T       cp_entry;
            UI32_T                  ifindex, i;
#endif
            UI64_T                  count;

            count = 0;

#if (SYS_CPNT_NMTR_PERQ_COUNTER == TRUE)
            ifindex = 0;
            while (NMTR_PMGR_GetNextSystemwideIfPerQStats(&ifindex, &if_perq_stats) == TRUE)
            {
                for (i = 0; i < SYS_ADPT_CN_MAX_NBR_OF_CP_PER_PORT; i++)
                {
                    cp_entry.lport = ifindex;
                    cp_entry.cp_index = i;
                    if (CN_POM_GetCpEntry(&cp_entry) != CN_TYPE_RETURN_OK)
                    {
                        continue;
                    }
                    count += if_perq_stats.cosq[cp_entry.queue].ifOutDiscardPkts;
                }
            }
#endif

            SNMP_MGR_UI64_T_TO_COUNTER64(long64_return, count);
            snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER64, (u_char *)&long64_return, sizeof(long64_return));

            break;
        }

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

/********************************************
 *****************cnPriTable*****************
 ********************************************
 */
#define CNPRIENTRY_INSTANCE_LEN  1

BOOL_T cnPriTable_OidIndexToData(UI32_T exact, UI32_T compc,
    oid *compl, UI32_T *cnPriPriority)
{
    /* get or set
     */
    if (exact)
    {
        /* check the index length
         */
        if (compc != CNPRIENTRY_INSTANCE_LEN) /* the constant size index */
        {
            return FALSE;
        }
    }

    *cnPriPriority = compl[0];

    return TRUE;
}

/*
 * var_cnPriTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *var_cnPriTable(struct variable *vp,
    oid *name,
    size_t *length,
    int exact,
    size_t *var_len,
    WriteMethod **write_method)
{
    UI32_T compc = 0;
    oid compl[CNPRIENTRY_INSTANCE_LEN] = {0};
    oid best_inst[CNPRIENTRY_INSTANCE_LEN] = {0};
    CN_TYPE_CnpvEntry_T entry;
    UI32_T priority;

    switch (vp->magic)
    {
        case LEAF_cnPriDefenseMode:
            *write_method = write_cnPriDefenseMode;
            break;

        case LEAF_cnPriAdminAlternatePriority:
            *write_method = write_cnPriAdminAlternatePriority;
            break;

        case LEAF_cnPriRowStatus:
            *write_method = write_cnPriRowStatus;
            break;

        default:
            *write_method = NULL;
            break;
    }

    /* check compc, retrive compl
     */
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl, CNPRIENTRY_INSTANCE_LEN);

    memset(&entry, 0, sizeof(entry));

    if (exact) /* get or set */
    {
        if (cnPriTable_OidIndexToData(exact, compc, compl, &priority) == FALSE)
        {
            return NULL;
        }

        entry.cnpv = priority;
        if (CN_POM_GetCnpvEntry(&entry) != CN_TYPE_RETURN_OK)
        {
            return NULL;
        }
    }
    else /* getnext */
    {
        if (cnPriTable_OidIndexToData(exact, compc, compl, &priority) == FALSE)
        {
            return NULL;
        }

        /* check the length of inputing index, if < 1 we should try get
         * {0.0.0.0.0...}
         */
        if (compc < 1)
        {
            if (CN_POM_GetCnpvEntry(&entry) != CN_TYPE_RETURN_OK)
            {
                if (CN_POM_GetNextCnpvEntry(&entry) != CN_TYPE_RETURN_OK)
                {
                    return NULL;
                }
            }
        }
        else
        {
            entry.cnpv = priority;
            if (CN_POM_GetNextCnpvEntry(&entry) != CN_TYPE_RETURN_OK)
            {
                return NULL;
            }
        }
    }

    memcpy(name, vp->name, vp->namelen * sizeof(oid));

    /* assign data to the oid index
     */
    best_inst[0] = entry.cnpv;
    memcpy(name + vp->namelen, best_inst, CNPRIENTRY_INSTANCE_LEN * sizeof(oid));
    *length = vp->namelen + CNPRIENTRY_INSTANCE_LEN;

    switch (vp->magic)
    {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    case LEAF_cnPriPriority:
        *var_len = sizeof(long_return);
        long_return = entry.cnpv;
        return (u_char *)&long_return;
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

    case LEAF_cnPriDefenseMode:
        *var_len = sizeof(long_return);
        long_return = entry.defense_mode;
        return (u_char *)&long_return;

    case LEAF_cnPriAdminAlternatePriority:
        *var_len = sizeof(long_return);
        long_return = entry.admin_alt_priority;
        return (u_char *)&long_return;

    case LEAF_cnPriAutoAlternatePriority:
        *var_len = sizeof(long_return);
        long_return = entry.auto_alt_priority;
        return (u_char *)&long_return;

    case LEAF_cnPriRowStatus:
        *var_len = sizeof(long_return);
        long_return = VAL_cnPriRowStatus_active;
        return (u_char *)&long_return;

    default:
        ERROR_MSG("");
    }

    return NULL;
}

int write_cnPriDefenseMode(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    UI32_T  mode = *(long *)var_val;

    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            switch (mode)
            {
            case VAL_cnPriDefenseMode_disabled:
            case VAL_cnPriDefenseMode_edge:
            case VAL_cnPriDefenseMode_interior:
            case VAL_cnPriDefenseMode_interiorReady:
            case VAL_cnPriDefenseMode_auto:
                break;

            default:
                return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            UI32_T priority = 0;

            if (cnPriTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &priority) == FALSE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            if (CN_PMGR_SetCnpvDefenseMode(priority, mode) != CN_TYPE_RETURN_OK)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

int write_cnPriAdminAlternatePriority(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    UI32_T alt_pri = *(u_long *)var_val;

    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_UNSIGNED)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            if ((alt_pri < MIN_cnPriAdminAlternatePriority) ||
                (alt_pri > MAX_cnPriAdminAlternatePriority))
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            UI32_T priority = 0;

            if (cnPriTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &priority) == FALSE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            if (CN_PMGR_SetCnpvAlternatePriority(priority, alt_pri) != CN_TYPE_RETURN_OK)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

int write_cnPriRowStatus(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    UI32_T row_status = *(long *)var_val;

    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            switch (row_status)
            {
#if 0 /* not support currently */
            case VAL_cnPriRowStatus_active:
            case VAL_cnPriRowStatus_notInService:
            case VAL_cnPriRowStatus_notReady:
#endif
            case VAL_cnPriRowStatus_createAndGo:
#if 0 /* not support currently */
            case VAL_cnPriRowStatus_createAndWait:
#endif
            case VAL_cnPriRowStatus_destroy:
                break;

            default:
                return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            UI32_T priority = 0;

            if (cnPriTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &priority) == FALSE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            if (row_status == VAL_cnPriRowStatus_createAndGo)
            {
                if (CN_PMGR_SetCnpv(priority, TRUE) != CN_TYPE_RETURN_OK)
                {
                    return SNMP_ERR_COMMITFAILED;
                }
            }
            else
            {
                if (CN_PMGR_SetCnpv(priority, FALSE) != CN_TYPE_RETURN_OK)
                {
                    return SNMP_ERR_COMMITFAILED;
                }
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

/********************************************
 *****************cnPortPriTable*************
 ********************************************
 */

#define CNPORTPRIENTRY_INSTANCE_LEN  2

BOOL_T cnPortPriTable_OidIndexToData(UI32_T exact, UI32_T compc,
    oid *compl, UI32_T *cnPortPriPriority, UI32_T *cnPortPriIfIndex)
{
    /* get or set
     */
    if (exact)
    {
        /* check the index length
         */
        if (compc != CNPORTPRIENTRY_INSTANCE_LEN) /* the constant size index */
        {
            return FALSE;
        }
    }

    *cnPortPriPriority = compl[0];
    *cnPortPriIfIndex = compl[1];

    return TRUE;
}

/*
 * var_cnPortPriTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *var_cnPortPriTable(struct variable *vp,
    oid *name,
    size_t *length,
    int exact,
    size_t *var_len,
    WriteMethod **write_method)
{
    UI32_T compc = 0;
    oid compl[CNPORTPRIENTRY_INSTANCE_LEN] = {0};
    oid best_inst[CNPORTPRIENTRY_INSTANCE_LEN] = {0};
    CN_TYPE_PortCnpvEntry_T entry;
    UI32_T priority;
    UI32_T lport;

    switch (vp->magic)
    {
        case LEAF_cnPortPriAdminDefenseMode:
            *write_method = write_cnPortPriAdminDefenseMode;
            break;

        case LEAF_cnPortPriAdminAlternatePriority:
            *write_method = write_cnPortPriAdminAlternatePriority;
            break;

        default:
            *write_method = NULL;
            break;
    }

    /* check compc, retrive compl
     */
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl, CNPORTPRIENTRY_INSTANCE_LEN);

    memset(&entry, 0, sizeof(entry));

    if (exact) /* get or set */
    {
        if (cnPortPriTable_OidIndexToData(exact, compc, compl, &priority, &lport) == FALSE)
        {
            return NULL;
        }

        entry.cnpv = priority;
        entry.lport = lport;
        if (CN_POM_GetPortCnpvEntry(&entry) != CN_TYPE_RETURN_OK)
        {
            return NULL;
        }
    }
    else /* getnext */
    {
        if (cnPortPriTable_OidIndexToData(exact, compc, compl, &priority, &lport) == FALSE)
        {
            return NULL;
        }

        /* check the length of inputing index, if < 1 we should try get
         * {0.0.0.0.0...}
         */
        if (compc < 1)
        {
            if (CN_POM_GetPortCnpvEntry(&entry) != CN_TYPE_RETURN_OK)
            {
                if (CN_POM_GetNextPortCnpvEntry(&entry) != CN_TYPE_RETURN_OK)
                {
                    return NULL;
                }
            }
        }
        else
        {
            entry.cnpv = priority;
            entry.lport = lport;
            if (CN_POM_GetNextPortCnpvEntry(&entry) != CN_TYPE_RETURN_OK)
            {
                return NULL;
            }
        }
    }

    memcpy(name, vp->name, vp->namelen * sizeof(oid));

    /* assign data to the oid index
     */
    best_inst[0] = entry.cnpv;
    best_inst[1] = entry.lport;
    memcpy(name + vp->namelen, best_inst, CNPORTPRIENTRY_INSTANCE_LEN * sizeof(oid));
    *length = vp->namelen + CNPORTPRIENTRY_INSTANCE_LEN;

    switch (vp->magic)
    {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    case LEAF_cnPortPriPriority:
        *var_len = sizeof(long_return);
        long_return = entry.cnpv;
        return (u_char *)&long_return;

    case LEAF_cnPortPriIfIndex:
        *var_len = sizeof(long_return);
        long_return = entry.lport;
        return (u_char *)&long_return;
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

    case LEAF_cnPortPriAdminDefenseMode:
        *var_len = sizeof(long_return);
        long_return = entry.admin_defense_mode;
        return (u_char *)&long_return;

    case LEAF_cnPortPriOperDefenseMode:
        *var_len = sizeof(long_return);
        long_return = entry.oper_defense_mode;
        return (u_char *)&long_return;

    case LEAF_cnPortPriAdminAlternatePriority:
        *var_len = sizeof(long_return);
        long_return = entry.admin_alt_priority;
        return (u_char *)&long_return;

    case LEAF_cnPortPriOperAlternatePriority:
        *var_len = sizeof(long_return);
        long_return = entry.oper_alt_priority;
        return (u_char *)&long_return;

    default:
        ERROR_MSG("");
    }

    return NULL;
}

int write_cnPortPriAdminDefenseMode(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    UI32_T mode = *(long *)var_val;

    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            switch (mode)
            {
            case VAL_cnPortPriAdminDefenseMode_disabled:
            case VAL_cnPortPriAdminDefenseMode_edge:
            case VAL_cnPortPriAdminDefenseMode_interior:
            case VAL_cnPortPriAdminDefenseMode_interiorReady:
            case VAL_cnPortPriAdminDefenseMode_auto:
            case VAL_cnPortPriAdminDefenseMode_byGlobal:
                break;

            default:
                return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            UI32_T priority;
            UI32_T lport;

            if (cnPortPriTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &priority, &lport) == FALSE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            if (CN_PMGR_SetPortCnpvDefenseMode(priority, lport, mode) != CN_TYPE_RETURN_OK)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

int write_cnPortPriAdminAlternatePriority(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    UI32_T alt_pri = *(u_long *)var_val;

    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_UNSIGNED)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            if ((alt_pri != VAL_cnPortPriAdminAlternatePriority_byGlobal) &&
                ((alt_pri < MIN_cnPortPriAdminAlternatePriority) ||
                 (alt_pri > MAX_cnPortPriAdminAlternatePriority)))
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            UI32_T priority;
            UI32_T lport;

            if (cnPortPriTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &priority, &lport) == FALSE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            if (CN_PMGR_SetPortCnpvAlternatePriority(priority, lport, alt_pri) != CN_TYPE_RETURN_OK)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

/********************************************
 *****************cnCpTable******************
 ********************************************
 */

#define CNCPENTRY_INSTANCE_LEN  2

BOOL_T cnCpTable_OidIndexToData(UI32_T exact, UI32_T compc,
    oid *compl, UI32_T *cnCpIfIndex, UI32_T *cnCpIndex)
{
    /* get or set
     */
    if (exact)
    {
        /* check the index length
         */
        if (compc != CNCPENTRY_INSTANCE_LEN) /* the constant size index */
        {
            return FALSE;
        }
    }

    *cnCpIfIndex = compl[0];
    *cnCpIndex = compl[1];

    return TRUE;
}

/*
 * var_cnCpTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *var_cnCpTable(struct variable *vp,
    oid *name,
    size_t *length,
    int exact,
    size_t *var_len,
    WriteMethod **write_method)
{
    UI32_T              compc = 0;
    oid                 compl[CNCPENTRY_INSTANCE_LEN] = {0};
    oid                 best_inst[CNCPENTRY_INSTANCE_LEN] = {0};
    CN_TYPE_CpEntry_T   entry;
    UI32_T              lport;
    UI32_T              cp_index;
    UI8_T               cpid[CN_TYPE_CPID_SIZE] = {0};
    UI64_T              discarded_frames, transmitted_frames;
#if (SYS_CPNT_NMTR_PERQ_COUNTER == TRUE)
    SWDRV_IfPerQStats_T if_perq_stats;
#endif
    SWDRV_QcnStats_T    qcn_stats;

    switch (vp->magic)
    {
        default:
            *write_method = NULL;
            break;
    }

    /* check compc, retrive compl
     */
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl, CNCPENTRY_INSTANCE_LEN);

    memset(&entry, 0, sizeof(entry));

    if (exact) /* get or set */
    {
        if (cnCpTable_OidIndexToData(exact, compc, compl, &lport, &cp_index) == FALSE)
        {
            return NULL;
        }

        entry.lport = lport;
        entry.cp_index = cp_index;
        if (CN_POM_GetCpEntry(&entry) != CN_TYPE_RETURN_OK)
        {
            return NULL;
        }
    }
    else /* getnext */
    {
        if (cnCpTable_OidIndexToData(exact, compc, compl, &lport, &cp_index) == FALSE)
        {
            return NULL;
        }

        /* check the length of inputing index, if < 1 we should try get
         * {0.0.0.0.0...}
         */
        if (compc < 1)
        {
            if (CN_POM_GetCpEntry(&entry) != CN_TYPE_RETURN_OK)
            {
                if (CN_POM_GetNextCpEntry(&entry) != CN_TYPE_RETURN_OK)
                {
                    return NULL;
                }
            }
        }
        else
        {
            entry.lport = lport;
            entry.cp_index = cp_index;
            if (CN_POM_GetNextCpEntry(&entry) != CN_TYPE_RETURN_OK)
            {
                return NULL;
            }
        }
    }

    if (SWCTRL_PMGR_GetPortQcnCpid(entry.lport, entry.queue, cpid) == FALSE)
    {
        return NULL;
    }
#if (SYS_CPNT_NMTR_PERQ_COUNTER == TRUE)
    if (NMTR_PMGR_GetSystemwideIfPerQStats(entry.lport, &if_perq_stats) == FALSE)
    {
        return NULL;
    }
#endif
    if (NMTR_PMGR_GetSystemwideQcnStats(entry.lport, &qcn_stats) == FALSE)
    {
        return NULL;
    }

    discarded_frames = transmitted_frames = 0;
#if (SYS_CPNT_NMTR_PERQ_COUNTER == TRUE)
    discarded_frames = if_perq_stats.cosq[entry.queue].ifOutDiscardPkts;
    transmitted_frames = if_perq_stats.cosq[entry.queue].ifOutPkts;
#endif

    memcpy(name, vp->name, vp->namelen * sizeof(oid));

    /* assign data to the oid index
     */
    best_inst[0] = entry.lport;
    best_inst[1] = entry.cp_index;
    memcpy(name + vp->namelen, best_inst, CNCPENTRY_INSTANCE_LEN * sizeof(oid));
    *length = vp->namelen + CNCPENTRY_INSTANCE_LEN;

    switch (vp->magic)
    {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    case LEAF_cnCpIfIndex:
        *var_len = sizeof(long_return);
        long_return = entry.lport;
        return (u_char *)&long_return;

    case LEAF_cnCpIndex:
        *var_len = sizeof(long_return);
        long_return = entry.cp_index;
        return (u_char *)&long_return;
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

    case LEAF_cnCpIdentifier:
        *var_len = CN_TYPE_CPID_SIZE;
        memcpy(return_buf, cpid, *var_len);
        return (u_char *)return_buf;

    case LEAF_cnCpQueue:
        *var_len = sizeof(long_return);
        long_return = entry.queue;
        return (u_char *)&long_return;

    case LEAF_cnCpManagedCnpvs:
        *var_len = sizeof(UI8_T);
        memcpy(return_buf, &entry.managed_cnpvs, *var_len);
        return (u_char *)return_buf;

    case LEAF_cnCpMacAddress:
        *var_len = SYS_ADPT_MAC_ADDR_LEN;
        memcpy(return_buf, entry.mac_address, *var_len);
        return (u_char *)return_buf;

    case LEAF_cnCpSetPoint:
        *var_len = sizeof(long_return);
        long_return = entry.set_point;
        return (u_char *)&long_return;

    case LEAF_cnCpFeedbackWeight:
        *var_len = sizeof(long_return);
        long_return = entry.feedback_weight;
        return (u_char *)&long_return;

    case LEAF_cnCpMinSampleBase:
        *var_len = sizeof(long_return);
        long_return = entry.min_sample_base;
        return (u_char *)&long_return;

    case LEAF_cnCpDiscardedFrames:
        *var_len = sizeof(long64_return);
        SNMP_MGR_UI64_T_TO_COUNTER64(long64_return, discarded_frames);
        return (u_char *)&long64_return;

    case LEAF_cnCpTransmittedFrames:
        *var_len = sizeof(long64_return);
        SNMP_MGR_UI64_T_TO_COUNTER64(long64_return, transmitted_frames);
        return (u_char *)&long64_return;

    case LEAF_cnCpTransmittedCnms:
        *var_len = sizeof(long64_return);
        SNMP_MGR_UI64_T_TO_COUNTER64(long64_return, qcn_stats.cpq[entry.cp_index].qcnStatsOutCnms);
        return (u_char *)&long64_return;

    default:
        ERROR_MSG("");
    }

    return NULL;
}
#endif /* #if (SYS_CPNT_CN == TRUE) */

#if (SYS_CPNT_DCBX == TRUE)
/********************************************
 *****************dcbxPortTable**************
 ********************************************
 */
#define DCBXPORTENTRY_INSTANCE_LEN  1

BOOL_T dcbxPortTable_OidIndexToData(UI32_T exact, UI32_T compc,
    oid *compl, UI32_T *dcbxPortIfIndex)
{
    /* get or set
     */
    if (exact)
    {
        /* check the index length
         */
        if (compc != DCBXPORTENTRY_INSTANCE_LEN) /* the constant size index */
        {
            return FALSE;
        }
    }

    *dcbxPortIfIndex = compl[0];

    return TRUE;
}

/*
 * var_cnPriTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *var_dcbxPortTable(struct variable *vp,
    oid *name,
    size_t *length,
    int exact,
    size_t *var_len,
    WriteMethod **write_method)
{
    UI32_T compc = 0;
    oid compl[DCBXPORTENTRY_INSTANCE_LEN] = {0};
    oid best_inst[DCBXPORTENTRY_INSTANCE_LEN] = {0};
    UI32_T lport = 0;
    BOOL_T status = FALSE;
    UI32_T mode = VAL_dcbxPortMode_manual;

    switch (vp->magic)
    {
        case LEAF_dcbxPortStatus:
            *write_method = write_dcbxPortStatus;
            break;

        case LEAF_dcbxPortMode:
            *write_method = write_dcbxPortMode;
            break;

        default:
            *write_method = NULL;
            break;
    }

    /* check compc, retrive compl
     */
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl, DCBXPORTENTRY_INSTANCE_LEN);

    if (exact) /* get or set */
    {
        if (dcbxPortTable_OidIndexToData(exact, compc, compl, &lport) == FALSE)
        {
            return NULL;
        }

        if (DCBX_PMGR_GetPortStatus(lport, &status) != DCBX_TYPE_RETURN_OK)
        {
            return NULL;
        }
        if (DCBX_PMGR_GetPortMode(lport, &mode) != DCBX_TYPE_RETURN_OK)
        {
            return NULL;
        }
    }
    else /* getnext */
    {
        if (dcbxPortTable_OidIndexToData(exact, compc, compl, &lport) == FALSE)
        {
            return NULL;
        }

        /* check the length of inputing index, if < 1 we should try get
         * {0.0.0.0.0...}
         */
        if (compc < 1)
        {
            if (DCBX_PMGR_GetPortStatus(lport, &status) != DCBX_TYPE_RETURN_OK)
            {
                if (SWCTRL_POM_GetNextLogicalPort(&lport) == SWCTRL_LPORT_UNKNOWN_PORT)
                {
                    return NULL;
                }

                if (DCBX_PMGR_GetPortStatus(lport, &status) != DCBX_TYPE_RETURN_OK)
                {
                    return NULL;
                }

                if (DCBX_PMGR_GetPortMode(lport, &mode) != DCBX_TYPE_RETURN_OK)
                {
                    return NULL;
                }
            }
        }
        else
        {
            if (SWCTRL_POM_GetNextLogicalPort(&lport) == SWCTRL_LPORT_UNKNOWN_PORT)
            {
                return NULL;
            }

            if (DCBX_PMGR_GetPortStatus(lport, &status) != DCBX_TYPE_RETURN_OK)
            {
                return NULL;
            }

            if (DCBX_PMGR_GetPortMode(lport, &mode) != DCBX_TYPE_RETURN_OK)
            {
                return NULL;
            }
        }
    }

    memcpy(name, vp->name, vp->namelen * sizeof(oid));

    /* assign data to the oid index
     */
    best_inst[0] = lport;
    memcpy(name + vp->namelen, best_inst, DCBXPORTENTRY_INSTANCE_LEN * sizeof(oid));
    *length = vp->namelen + DCBXPORTENTRY_INSTANCE_LEN;

    switch (vp->magic)
    {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    case LEAF_dcbxPortIfIndex:
        *var_len = sizeof(long_return);
        long_return = lport;
        return (u_char *)&long_return;
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

    case LEAF_dcbxPortStatus:
        *var_len = sizeof(long_return);
        long_return = (status == TRUE)?VAL_dcbxPortStatus_enabled:VAL_dcbxPortStatus_disabled;
        return (u_char *)&long_return;

    case LEAF_dcbxPortMode:
        *var_len = sizeof(long_return);
        long_return = mode;
        return (u_char *)&long_return;

    default:
        ERROR_MSG("");
    }

    return NULL;
}

int write_dcbxPortStatus(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            switch (*(long *)var_val)
            {
            case VAL_dcbxPortStatus_enabled:
            case VAL_dcbxPortStatus_disabled:
                break;

            default:
                return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            UI32_T lport;
            BOOL_T status;

            if (dcbxPortTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &lport) == FALSE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            status = (*(long *)var_val == VAL_dcbxPortStatus_enabled) ? TRUE : FALSE;
            if (DCBX_PMGR_SetPortStatus(lport, status) != DCBX_TYPE_RETURN_OK)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

int write_dcbxPortMode(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    UI32_T mode = *(long *)var_val;

    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            switch (mode)
            {
            case VAL_dcbxPortMode_manual:
            case VAL_dcbxPortMode_configSource:
            case VAL_dcbxPortMode_autoUp:
            case VAL_dcbxPortMode_autoDown:
                break;

            default:
                return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            UI32_T lport;

            if (dcbxPortTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &lport) == FALSE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            if (DCBX_PMGR_SetPortMode(lport, mode) != DCBX_TYPE_RETURN_OK)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}
#endif /* #if (SYS_CPNT_DCBX == TRUE) */

#if (SYS_CPNT_VXLAN == TRUE)
int do_vxlanUdpDstPort(netsnmp_mib_handler *handler,
    netsnmp_handler_registration *reginfo,
    netsnmp_agent_request_info *reqinfo,
    netsnmp_request_info *requests)
{
    switch (reqinfo->mode)
    {
        case MODE_GET:
        {
            UI16_T udp_port = 0;

            if (VXLAN_POM_GetUdpDstPort(&udp_port) == VXLAN_TYPE_RETURN_OK)
            {
                long_return = udp_port;
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *)&long_return, sizeof(long_return));
            }
            else
            {
                return SNMP_ERR_GENERR;
            }

            break;
        }

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            if (requests->requestvb->type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case MODE_SET_RESERVE2:
            if ((*requests->requestvb->val.integer < MIN_vxlanUdpDstPort) || (*requests->requestvb->val.integer > MAX_vxlanUdpDstPort))
            {
               return SNMP_ERR_WRONGVALUE;
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called.
             */
            break;

        case MODE_SET_ACTION:
        {
            if (VXLAN_PMGR_SetUdpDstPort((UI16_T)*requests->requestvb->val.integer) != VXLAN_TYPE_RETURN_OK)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

#define VXLANFLOODENTRY_INSTANCE_LEN  5

BOOL_T vxlanFloodTable_OidIndexToData(UI32_T exact, UI32_T compc,
    oid *compl, UI32_T *vxlanFloodVniIndex, UI32_T *vxlanFloodRemoteIpAddress)
{
    /* get or set
     */
    if (exact)
    {
        /* check the index length
         */
        if (compc != VXLANFLOODENTRY_INSTANCE_LEN) /* the constant size index */
        {
            return FALSE;
        }
    }

    *vxlanFloodVniIndex = compl[0];
    *((UI8_T *)vxlanFloodRemoteIpAddress)=(UI8_T)compl[1];
    *((UI8_T *)vxlanFloodRemoteIpAddress+1)=(UI8_T)compl[2];
    *((UI8_T *)vxlanFloodRemoteIpAddress+2)=(UI8_T)compl[3];
    *((UI8_T *)vxlanFloodRemoteIpAddress+3)=(UI8_T)compl[4];

    return TRUE;
}

/* This entry is used for entry which have the ability to row create*/
static VXLAN_OM_RVtep_T m_rvtep_entry;
static BOOL_T m_rvtep_in_local = FALSE;
/*
 * var_vxlanFloodTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *var_vxlanFloodTable(struct variable *vp,
    oid *name,
    size_t *length,
    int exact,
    size_t *var_len,
    WriteMethod **write_method)
{
    UI32_T compc = 0;
    oid compl[VXLANFLOODENTRY_INSTANCE_LEN] = {0};
    oid best_inst[VXLANFLOODENTRY_INSTANCE_LEN] = {0};
    VXLAN_OM_RVtep_T rvtep_entry;
    L_INET_AddrIp_T remote_ip;
    BOOL_T m_local_found = FALSE;
    UI32_T vni = 0, lport = 0, ip_addr = 0;
    UI16_T vid = 0;
    UI8_T ip_ar[SYS_ADPT_IPV4_ADDR_LEN]={0};

    switch (vp->magic)
    {
        case LEAF_vxlanFloodVlanIndex:
            *write_method = write_vxlanFloodVlanIndex;
            break;

        case LEAF_vxlanFloodEgressPort:
            *write_method = write_vxlanFloodEgressPort;
            break;

        case LEAF_vxlanFloodStatus:
            *write_method = write_vxlanFloodStatus;
            break;

        default:
            *write_method = 0;
            break;
    }

    /* check compc, retrive compl
     */
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl, VXLANFLOODENTRY_INSTANCE_LEN);

    memset(&rvtep_entry, 0, sizeof(rvtep_entry));
    memset(&remote_ip, 0, sizeof(remote_ip));
    if (exact) /* get or set */
    {
        if (vxlanFloodTable_OidIndexToData(exact, compc, compl, &vni, &ip_addr) == FALSE)
        {
            return NULL;
        }

        IP_LIB_UI32toArray(ip_addr, remote_ip.addr);
        remote_ip.addrlen = SYS_ADPT_IPV4_ADDR_LEN;
        remote_ip.type = L_INET_ADDR_TYPE_IPV4;
        rvtep_entry.vni = vni;
        if (TRUE == IP_LIB_IsMulticastIp(remote_ip.addr))
        {
            if (VXLAN_POM_GetFloodMulticastByVni(&rvtep_entry) != VXLAN_TYPE_RETURN_OK)
            {
                /* Have data in local m_rvtep_entry, will allow to dispaly.
                 */
                if (    (m_rvtep_entry.vni == vni)
                     && (0 == memcmp(m_rvtep_entry.ip.addr, remote_ip.addr, SYS_ADPT_IPV4_ADDR_LEN))
                     && (   (0 != m_rvtep_entry.vid)
                         || (0 != m_rvtep_entry.lport)
                        )
                   )
                {
                    memcpy(&rvtep_entry, &m_rvtep_entry, sizeof(m_rvtep_entry));
                    m_local_found = TRUE;
                }
                else
                {
                    return NULL;
                }
            }
            else if (0 != memcmp(rvtep_entry.ip.addr, remote_ip.addr, SYS_ADPT_IPV4_ADDR_LEN))
            {
                return NULL;
            }
        }
        else
        {
            memcpy(rvtep_entry.ip.addr, remote_ip.addr, SYS_ADPT_IPV4_ADDR_LEN);
            if (VXLAN_POM_GetFloodRVtepByVniIp(&rvtep_entry) != VXLAN_TYPE_RETURN_OK)
            {
                return NULL;
            }
        }
    }
    else /* getnext */
    {
        vxlanFloodTable_OidIndexToData(exact, compc, compl, &vni, &ip_addr);

        /* check the length of inputing index,if < 1 we should try get
         * {0.0.0.0.0...}
         */

        IP_LIB_UI32toArray(ip_addr, remote_ip.addr);
        remote_ip.addrlen = SYS_ADPT_IPV4_ADDR_LEN;
        remote_ip.type = L_INET_ADDR_TYPE_IPV4;
        rvtep_entry.vni = vni;

        if (compc < 1)
        {
            /* First get unicast VTEP and then multicast.
             */
            if (VXLAN_POM_GetFloodRVtepByVniIp(&rvtep_entry) != VXLAN_TYPE_RETURN_OK)
            {
                if (VXLAN_POM_GetNextFloodRVtep(&rvtep_entry) != VXLAN_TYPE_RETURN_OK)
                {
                    memset(&rvtep_entry, 0, sizeof(rvtep_entry));
                    if (VXLAN_POM_GetNextFloodMulticast(&rvtep_entry) != VXLAN_TYPE_RETURN_OK)
                    {
                        return NULL;
                    }
                }
            }
        }
        else
        {
            if (TRUE == IP_LIB_IsMulticastIp(remote_ip.addr))
            {
                if (VXLAN_POM_GetNextFloodMulticast(&rvtep_entry) != VXLAN_TYPE_RETURN_OK)
                {
                    return NULL;
                }
            }
            else
            {
                /* First get unicast VTEP and then multicast.
                 */
                memcpy(rvtep_entry.ip.addr, remote_ip.addr, SYS_ADPT_IPV4_ADDR_LEN);
                if (VXLAN_POM_GetNextFloodRVtep(&rvtep_entry) != VXLAN_TYPE_RETURN_OK)
                {
                    memset(&rvtep_entry, 0, sizeof(rvtep_entry));
                    if (VXLAN_POM_GetNextFloodMulticast(&rvtep_entry) != VXLAN_TYPE_RETURN_OK)
                    {
                        return NULL;
                    }
                }/* End of VXLAN_POM_GetNextFloodRVtep */
            }/* End of IP_LIB_IsMulticastIp */
        }/* End of else */
    }/* End of getnext */

    memcpy(name, vp->name, vp->namelen * sizeof(oid));

    /* assign data to the oid index
     */
    best_inst[0] = rvtep_entry.vni;
    best_inst[1] = rvtep_entry.ip.addr[0];
    best_inst[2] = rvtep_entry.ip.addr[1];
    best_inst[3] = rvtep_entry.ip.addr[2];
    best_inst[4] = rvtep_entry.ip.addr[3];
    memcpy(name + vp->namelen, best_inst, VXLANFLOODENTRY_INSTANCE_LEN * sizeof(oid));
    *length = vp->namelen + VXLANFLOODENTRY_INSTANCE_LEN;

    switch (vp->magic)
    {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case LEAF_vxlanFloodVniIndex:
            *var_len = sizeof(long_return);
            long_return = rvtep_entry.vni;
            return (u_char *) &long_return;
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case LEAF_vxlanFloodRemoteIpAddress:
        {
            UI32_T value = 0;

            *var_len = sizeof(ipaddr_return);
            strncpy((char *)ip_ar, (char *)rvtep_entry.ip.addr, *var_len);
            IP_LIB_ArraytoUI32(ip_ar, &value);
            ipaddr_return = value;
            return (u_char *) &ipaddr_return;
        }
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

        case LEAF_vxlanFloodSourceIpAddress:
        {
            UI32_T value = 0;

            *var_len = sizeof(ipaddr_return);
            strncpy((char *)ip_ar, (char *)rvtep_entry.s_ip.addr, *var_len);
            IP_LIB_ArraytoUI32(ip_ar, &value);
            ipaddr_return = value;
            return (u_char *) &ipaddr_return;
        }

        case LEAF_vxlanFloodVlanIndex:
            *var_len = sizeof(long_return);
            long_return = (UI32_T)rvtep_entry.vid;
            return (u_char *) &long_return;

        case LEAF_vxlanFloodEgressPort:
            *var_len = sizeof(long_return);
            long_return = rvtep_entry.lport;
            return (u_char *) &long_return;

        case LEAF_vxlanFloodStatus:
            *var_len = sizeof(long_return);
            if (TRUE == m_local_found)
            {
                long_return = VAL_vxlanFloodStatus_notReady;
            }
            else if (0!= rvtep_entry.lport)
            {
                long_return = VAL_vxlanFloodStatus_active;
            }
            else
            {
                long_return = VAL_vxlanFloodStatus_notInService;
            }
            return (u_char *) &long_return;

        default:
            ERROR_MSG("");
    }

    return NULL;
}

int write_vxlanFloodVlanIndex(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            if (MIN_vxlanFloodVlanIndex > *(long *)var_val || *(long *)var_val > MAX_vxlanFloodVlanIndex)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            VXLAN_OM_RVtep_T rvtep_entry;
            L_INET_AddrIp_T remote_ip;
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            I32_T value = 0;
            UI32_T vxlanFloodVniIndex = 0;
            UI32_T vxlanFloodRemoteIpAddress = 0;
            UI32_T ret = VXLAN_TYPE_RETURN_OK;

            if (vxlanFloodTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &vxlanFloodVniIndex, &vxlanFloodRemoteIpAddress) == FALSE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            memset(&rvtep_entry, 0, sizeof(rvtep_entry));
            IP_LIB_UI32toArray(vxlanFloodRemoteIpAddress, remote_ip.addr);
            rvtep_entry.vni = vxlanFloodVniIndex;
            ret = VXLAN_POM_GetFloodMulticastByVni(&rvtep_entry);
            if (    (TRUE == IP_LIB_IsMulticastIp(remote_ip.addr))
                &&  (ret != VXLAN_TYPE_RETURN_OK)
               )
            {
                /* Specified multicast entry is not existed, keep info in local m_rvtep_entry.
                 */
                if (   (TRUE == m_rvtep_in_local)
                    && (m_rvtep_entry.vni != vxlanFloodVniIndex)
                    && (0 == memcmp(m_rvtep_entry.ip.addr, remote_ip.addr, SYS_ADPT_IPV4_ADDR_LEN))
                    && (0 != m_rvtep_entry.lport)
                   )
                {
                    /* Reset lport because key(VNI+IP) is different.
                     */
                    m_rvtep_entry.lport = 0;
                }
                value = *(long *)var_val;
                m_rvtep_entry.vni = vxlanFloodVniIndex;
                memcpy(m_rvtep_entry.ip.addr, remote_ip.addr, SYS_ADPT_IPV4_ADDR_LEN);
                m_rvtep_entry.ip.addrlen = SYS_ADPT_IPV4_ADDR_LEN;
                m_rvtep_entry.ip.type = L_INET_ADDR_TYPE_IPV4;
                m_rvtep_entry.vid = value;
                m_rvtep_in_local = TRUE;
            }
            else
            {
                /* Specified multicast entry is existed, return directly.
                 */
                if (    (ret == VXLAN_TYPE_RETURN_OK)
                    &&  (0 == memcmp(rvtep_entry.ip.addr, remote_ip.addr, SYS_ADPT_IPV4_ADDR_LEN))
                    &&  (rvtep_entry.vid == value)
                   )
                {
                    return SNMP_ERR_NOERROR;
                }

                memset(&m_rvtep_entry, 0, sizeof(m_rvtep_entry));
                m_rvtep_in_local = FALSE;
                return SNMP_ERR_COMMITFAILED;
            }
            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

int write_vxlanFloodEgressPort(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            break;

        case FREE:
            break;

        case ACTION:
        {
            VXLAN_OM_RVtep_T rvtep_entry;
            L_INET_AddrIp_T remote_ip;
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            I32_T value = 0;
            UI32_T vxlanFloodVniIndex = 0;
            UI32_T vxlanFloodRemoteIpAddress = 0;
            UI32_T ret = VXLAN_TYPE_RETURN_OK;

            if (vxlanFloodTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &vxlanFloodVniIndex, &vxlanFloodRemoteIpAddress) == FALSE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            memset(&rvtep_entry, 0, sizeof(rvtep_entry));
            IP_LIB_UI32toArray(vxlanFloodRemoteIpAddress, remote_ip.addr);
            rvtep_entry.vni = vxlanFloodVniIndex;
            ret = VXLAN_POM_GetFloodMulticastByVni(&rvtep_entry);
            if (    (TRUE == IP_LIB_IsMulticastIp(remote_ip.addr))
                &&  (ret != VXLAN_TYPE_RETURN_OK)
               )
            {
                /*  Specified multicast entry is not existed, keep info in local m_rvtep_entry.
                 */
                if (   (TRUE == m_rvtep_in_local)
                    && (m_rvtep_entry.vni != vxlanFloodVniIndex)
                    && (0 == memcmp(m_rvtep_entry.ip.addr, remote_ip.addr, SYS_ADPT_IPV4_ADDR_LEN))
                    && (0 != m_rvtep_entry.vid)
                   )
                {
                    /* Reset vid because key(VNI+IP) is different.
                     */
                    m_rvtep_entry.vid = 0;
                }
                value = *(long *)var_val;
                m_rvtep_entry.vni = vxlanFloodVniIndex;
                memcpy(m_rvtep_entry.ip.addr, remote_ip.addr, SYS_ADPT_IPV4_ADDR_LEN);
                m_rvtep_entry.ip.addrlen = SYS_ADPT_IPV4_ADDR_LEN;
                m_rvtep_entry.ip.type = L_INET_ADDR_TYPE_IPV4;
                m_rvtep_entry.lport = value;
                m_rvtep_in_local = TRUE;
            }
            else
            {
                /* Specified multicast entry is existed, return directly.
                 */
                if (    (ret == VXLAN_TYPE_RETURN_OK)
                    &&  (0 == memcmp(rvtep_entry.ip.addr, m_rvtep_entry.ip.addr, SYS_ADPT_IPV4_ADDR_LEN))
                    &&  (rvtep_entry.lport == value)
                   )
                {
                    return SNMP_ERR_NOERROR;
                }

                memset(&m_rvtep_entry, 0, sizeof(m_rvtep_entry));
                m_rvtep_in_local = FALSE;
                return SNMP_ERR_COMMITFAILED;
            }
            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

int write_vxlanFloodStatus(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            switch (*(long *)var_val)
            {
                case VAL_vxlanFloodStatus_active:
                    break;

                case VAL_vxlanFloodStatus_notInService:
                    break;

                case VAL_vxlanFloodStatus_notReady:
                    break;

                case VAL_vxlanFloodStatus_createAndGo:
                    break;

                case VAL_vxlanFloodStatus_createAndWait:
                    break;

                case VAL_vxlanFloodStatus_destroy:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            L_INET_AddrIp_T remote_ip;
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            I32_T value = 0;
            UI32_T vxlanFloodVniIndex = 0;
            UI32_T vxlanFloodRemoteIpAddress = 0;
            UI32_T ret = VXLAN_TYPE_RETURN_OK;

            if (vxlanFloodTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &vxlanFloodVniIndex, &vxlanFloodRemoteIpAddress) == FALSE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            memset(&remote_ip, 0, sizeof(remote_ip));
            value = *(long *)var_val;

            IP_LIB_UI32toArray(vxlanFloodRemoteIpAddress, remote_ip.addr);
            remote_ip.addrlen = SYS_ADPT_IPV4_ADDR_LEN;
            remote_ip.type = L_INET_ADDR_TYPE_IPV4;

            switch (value)
            {
                case VAL_vxlanFloodStatus_createAndGo:
                    if (TRUE == IP_LIB_IsMulticastIp(remote_ip.addr))
                    {
                        if ((0 == m_rvtep_entry.vid) || (0 == m_rvtep_entry.lport))
                        {
                            /* Not assign vid and egress port for multicast entry.
                             */
                            return SNMP_ERR_COMMITFAILED;
                        }

                        ret = VXLAN_PMGR_AddFloodMulticast(vxlanFloodVniIndex, &remote_ip, m_rvtep_entry.vid, m_rvtep_entry.lport);
                        if (   (VXLAN_TYPE_RETURN_OK != ret)
                            && (VXLAN_TYPE_SRC_IP_NOT_FIND != ret)
                           )
                        {
                            return SNMP_ERR_COMMITFAILED;
                        }
                        memset(&m_rvtep_entry, 0, sizeof(m_rvtep_entry));
                        m_rvtep_in_local = FALSE;
                    }
                    else
                    {
                        ret = VXLAN_PMGR_AddFloodRVtep(vxlanFloodVniIndex, &remote_ip);
                        if (   (VXLAN_TYPE_RETURN_OK != ret)
                            && (VXLAN_TYPE_ROUTE_NOT_FIND != ret)
                            && (VXLAN_TYPE_HOST_NOT_FIND != ret)
                           )
                        {
                            return SNMP_ERR_COMMITFAILED;
                        }
                    }
                    break;
                case VAL_vxlanFloodStatus_createAndWait:
                case VAL_vxlanFloodStatus_active:
                case VAL_vxlanFloodStatus_notInService:
                case VAL_vxlanFloodStatus_notReady:
                    return SNMP_ERR_COMMITFAILED;

                case VAL_vxlanFloodStatus_destroy:
                    if (TRUE == IP_LIB_IsMulticastIp(remote_ip.addr))
                    {
                        if (VXLAN_PMGR_DelFloodMulticast(vxlanFloodVniIndex) != VXLAN_TYPE_RETURN_OK)
                        {
                            return SNMP_ERR_COMMITFAILED;
                        }
                    }
                    else
                    {
                        if (VXLAN_PMGR_DelFloodRVtep(vxlanFloodVniIndex, &remote_ip) != VXLAN_TYPE_RETURN_OK)
                        {
                            return SNMP_ERR_COMMITFAILED;
                        }
                    }

                    break;

                default:
                    return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

#define VXLANVLANVNIMAPPINGENTRY_INSTANCE_LEN  1

BOOL_T vxlanVlanVniMappingTable_OidIndexToData(UI32_T exact, UI32_T compc,
    oid *compl, UI32_T *vxlanVlanIndex)
{
    /* get or set
     */
    if (exact)
    {
        /* check the index length
         */
        if (compc != VXLANVLANVNIMAPPINGENTRY_INSTANCE_LEN) /* the constant size index */
        {
            return FALSE;
        }
    }

    *vxlanVlanIndex = compl[0];

    return TRUE;
}

/*
 * var_vxlanVlanVniMappingTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *var_vxlanVlanVniMappingTable(struct variable *vp,
    oid *name,
    size_t *length,
    int exact,
    size_t *var_len,
    WriteMethod **write_method)
{
    UI32_T compc = 0;
    oid compl[VXLANVLANVNIMAPPINGENTRY_INSTANCE_LEN] = {0};
    oid best_inst[VXLANVLANVNIMAPPINGENTRY_INSTANCE_LEN] = {0};
    UI32_T vid = 0, vni = 0;
    UI16_T get_vid = 0;

    switch (vp->magic)
    {
        case LEAF_vxlanVniIndex:
            *write_method = write_vxlanVniIndex;
            break;

        default:
            *write_method = 0;
            break;
    }

    /* check compc, retrive compl
     */
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl, VXLANVLANVNIMAPPINGENTRY_INSTANCE_LEN);

    if (exact) /* get or set */
    {
        if (vxlanVlanVniMappingTable_OidIndexToData(exact, compc, compl, &vid) == FALSE)
        {
            return NULL;
        }
        get_vid = (UI16_T)vid;
        if (VXLAN_POM_GetVlanVniMapEntry(get_vid, &vni) != VXLAN_TYPE_RETURN_OK)
        {
            return NULL;
        }
    }
    else /* getnext */
    {
        vxlanVlanVniMappingTable_OidIndexToData(exact, compc, compl, &vid);

        /* check the length of inputing index,if < 1 we should try get
         * {0.0.0.0.0...}
         */
        get_vid = (UI16_T)vid;
        if (compc < 1)
        {
            if (VXLAN_POM_GetVlanVniMapEntry(get_vid, &vni) != VXLAN_TYPE_RETURN_OK)
            {
                if (VXLAN_POM_GetNextVlanVniMapEntry(&get_vid, &vni) != VXLAN_TYPE_RETURN_OK)
                {
                    return NULL;
                }
            }
        }
        else
        {
            if (VXLAN_POM_GetNextVlanVniMapEntry(&get_vid, &vni) != VXLAN_TYPE_RETURN_OK)
            {
                return NULL;
            }
        }
    }

    memcpy(name, vp->name, vp->namelen * sizeof(oid));

    /* assign data to the oid index
     */
    best_inst[0] = get_vid;
    memcpy(name + vp->namelen, best_inst, VXLANVLANVNIMAPPINGENTRY_INSTANCE_LEN * sizeof(oid));
    *length = vp->namelen + VXLANVLANVNIMAPPINGENTRY_INSTANCE_LEN;

    switch (vp->magic)
    {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case LEAF_vxlanVlanIndex:
            *var_len = sizeof(long_return);
            long_return = get_vid;
            return (u_char *) &long_return;
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

        case LEAF_vxlanVniIndex:
            *var_len = sizeof(long_return);
            long_return = vni;
            return (u_char *) &long_return;

        default:
            ERROR_MSG("");
    }

    return NULL;
}

int write_vxlanVniIndex(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            if (MIN_vxlanVniIndex > *(long *)var_val || *(long *)var_val > MAX_vxlanVniIndex)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            UI32_T vni = 0;
            UI32_T vxlanVlanIndex = 0;
            BOOL_T is_add = TRUE;

            if (vxlanVlanVniMappingTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &vxlanVlanIndex) == FALSE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            vni = *(long *)var_val;

            /* Set 0 to delete VLAN-VNI Mapping entry
             */
            if (0 == vni)
            {
                if (VXLAN_POM_GetVlanVniMapEntry((UI16_T)vxlanVlanIndex, &vni) != VXLAN_TYPE_RETURN_OK)
                {
                    /* If entry is not exited, no error.
                     */
                    return SNMP_ERR_NOERROR;
                }
                is_add = FALSE;
            }
            if (VXLAN_PMGR_SetVlanVniMap(vxlanVlanIndex, vni, is_add) != VXLAN_TYPE_RETURN_OK)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}
#endif /* #if (SYS_CPNT_VXLAN == TRUE) */

#if (SYS_CPNT_HASH_SELECTION == TRUE)
#define HASHSELTABLEENTRY_INSTANCE_LEN   1

BOOL_T hashSelTable_OidIndexToData(UI32_T exact, UI32_T compc,
    oid *compl, UI8_T *block_index)
{
    /* get or set
     */
    if (exact)
    {
        /* check the index length
         */
        if (compc != HASHSELTABLEENTRY_INSTANCE_LEN) /* the constant size index */
        {
            return FALSE;
        }
    }

    *block_index = (UI8_T) compl[0];

    return TRUE;
}

unsigned char *var_hashSelMacTable(struct variable *vp,
    oid *name,
    size_t *length,
    int exact,
    size_t *var_len,
    WriteMethod **write_method)
{
    UI32_T  compc = 0;
    oid compl[HASHSELTABLEENTRY_INSTANCE_LEN] = {0};
    oid best_inst[HASHSELTABLEENTRY_INSTANCE_LEN] = {0};
    UI8_T block_index;
    SWCTRL_OM_HashSelBlockInfo_T  block_info;

    switch (vp->magic)
    {
        case LEAF_hashSelMacSrcMac:
        case LEAF_hashSelMacDstMac:
        case LEAF_hashSelMacEtherType:
        case LEAF_hashSelMacVlan:
            *write_method = write_hashSelMacField;
            break;

        default:
            *write_method = 0;
            break;
    }

    /* check compc, retrive compl
     */
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl, HASHSELTABLEENTRY_INSTANCE_LEN);

    if (exact) /* get or set */
    {
        if (hashSelTable_OidIndexToData(exact, compc, compl, &block_index) == FALSE)
        {
            return NULL;
        }

        if (TRUE != SWCTRL_POM_GetHashBlockInfo(block_index, &block_info))
        {
            return NULL;
        }
    }
    else /* getnext */
    {
        hashSelTable_OidIndexToData(exact, compc, compl, &block_index);

        /* check the length of inputing index,if < 1 we should try get
         * {0.0.0.0.0...}
         */
        if (compc < 1)
        {
            block_index = 1;
            if (TRUE != SWCTRL_POM_GetHashBlockInfo(block_index, &block_info))
            {
                return NULL;
            }
        }
        else
        {
            block_index ++;
            if (block_index > SYS_ADPT_MAX_HASH_SELECTION_BLOCK_SIZE)
            {
                return NULL;
            }
            else
            {
                if (TRUE != SWCTRL_POM_GetHashBlockInfo(block_index, &block_info))
                {
                    return NULL;
                }
            }
        }
    }

    memcpy(name, vp->name, vp->namelen * sizeof(oid));

    /* assign data to the oid index
     */
    best_inst[0] = block_index;
    memcpy(name + vp->namelen, best_inst, HASHSELTABLEENTRY_INSTANCE_LEN * sizeof(oid));
    *length = vp->namelen + HASHSELTABLEENTRY_INSTANCE_LEN;

    switch (vp->magic)
    {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case LEAF_hashSelMacBlockIndex:
            *var_len = sizeof(long_return);
            long_return = (UI32_T)block_index;
            return (u_char *) &long_return;
#endif
        case LEAF_hashSelMacSrcMac:
            *var_len = sizeof(long_return);
            long_return = (block_info.pkt_l2.arg.item.src_mac? VAL_enabled: VAL_disabled);
            return (u_char *) &long_return;

        case LEAF_hashSelMacDstMac:
            *var_len = sizeof(long_return);
            long_return = (block_info.pkt_l2.arg.item.dst_mac? VAL_enabled: VAL_disabled);
            return (u_char *) &long_return;

        case LEAF_hashSelMacEtherType:
            *var_len = sizeof(long_return);
            long_return = (block_info.pkt_l2.arg.item.ether_type? VAL_enabled: VAL_disabled);
            return (u_char *) &long_return;

        case LEAF_hashSelMacVlan:
            *var_len = sizeof(long_return);
            long_return = (block_info.pkt_l2.arg.item.vlan? VAL_enabled: VAL_disabled);
            return (u_char *) &long_return;

        default:
            ERROR_MSG("");
    }

    return NULL;
}

unsigned char *var_hashSelIpv4Table(struct variable *vp,
    oid *name,
    size_t *length,
    int exact,
    size_t *var_len,
    WriteMethod **write_method)
{
    UI32_T  compc = 0;
    oid compl[HASHSELTABLEENTRY_INSTANCE_LEN] = {0};
    oid best_inst[HASHSELTABLEENTRY_INSTANCE_LEN] = {0};
    UI8_T block_index;
    SWCTRL_OM_HashSelBlockInfo_T  block_info;

    switch (vp->magic)
    {
        case LEAF_hashSelIpv4SrcIp:
        case LEAF_hashSelIpv4DstIp:
        case LEAF_hashSelIpv4SrcL4Port:
        case LEAF_hashSelIpv4DstL4Port:
        case LEAF_hashSelIpv4ProtocolId:
        case LEAF_hashSelIpv4Vlan:
            *write_method = write_hashSelIpv4Field;
            break;

        default:
            *write_method = 0;
            break;
    }

    /* check compc, retrive compl
     */
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl, HASHSELTABLEENTRY_INSTANCE_LEN);

    if (exact) /* get or set */
    {
        if (hashSelTable_OidIndexToData(exact, compc, compl, &block_index) == FALSE)
        {
            return NULL;
        }

        if (TRUE != SWCTRL_POM_GetHashBlockInfo(block_index, &block_info))
        {
            return NULL;
        }
    }
    else /* getnext */
    {
        hashSelTable_OidIndexToData(exact, compc, compl, &block_index);

        /* check the length of inputing index,if < 1 we should try get
         * {0.0.0.0.0...}
         */
        if (compc < 1)
        {
            block_index = 1;
            if (TRUE != SWCTRL_POM_GetHashBlockInfo(block_index, &block_info))
            {
                return NULL;
            }
        }
        else
        {
            block_index ++;
            if (block_index > SYS_ADPT_MAX_HASH_SELECTION_BLOCK_SIZE)
            {
                return NULL;
            }
            else
            {
                if (TRUE != SWCTRL_POM_GetHashBlockInfo(block_index, &block_info))
                {
                    return NULL;
                }
            }
        }
    }

    memcpy(name, vp->name, vp->namelen * sizeof(oid));

    /* assign data to the oid index
     */
    best_inst[0] = block_index;
    memcpy(name + vp->namelen, best_inst, HASHSELTABLEENTRY_INSTANCE_LEN * sizeof(oid));
    *length = vp->namelen + HASHSELTABLEENTRY_INSTANCE_LEN;

    switch (vp->magic)
    {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case LEAF_hashSelIpv4BlockIndex:
            *var_len = sizeof(long_return);
            long_return = (UI32_T)block_index;
            return (u_char *) &long_return;
#endif
        case LEAF_hashSelIpv4SrcIp:
            *var_len = sizeof(long_return);
            long_return = (block_info.pkt_ipv4.arg.item.src_ip? VAL_enabled: VAL_disabled);
            return (u_char *) &long_return;

        case LEAF_hashSelIpv4DstIp:
            *var_len = sizeof(long_return);
            long_return = (block_info.pkt_ipv4.arg.item.dst_ip? VAL_enabled: VAL_disabled);
            return (u_char *) &long_return;

        case LEAF_hashSelIpv4SrcL4Port:
            *var_len = sizeof(long_return);
            long_return = (block_info.pkt_ipv4.arg.item.src_l4_port? VAL_enabled: VAL_disabled);
            return (u_char *) &long_return;

        case LEAF_hashSelIpv4DstL4Port:
            *var_len = sizeof(long_return);
            long_return = (block_info.pkt_ipv4.arg.item.dst_l4_port? VAL_enabled: VAL_disabled);
            return (u_char *) &long_return;

        case LEAF_hashSelIpv4ProtocolId:
            *var_len = sizeof(long_return);
            long_return = (block_info.pkt_ipv4.arg.item.protocol_id? VAL_enabled: VAL_disabled);
            return (u_char *) &long_return;

        case LEAF_hashSelIpv4Vlan:
            *var_len = sizeof(long_return);
            long_return = (block_info.pkt_ipv4.arg.item.vlan? VAL_enabled: VAL_disabled);
            return (u_char *) &long_return;

        default:
            ERROR_MSG("");
    }

    return NULL;
}

unsigned char *var_hashSelIpv6Table(struct variable *vp,
    oid *name,
    size_t *length,
    int exact,
    size_t *var_len,
    WriteMethod **write_method)
{
    UI32_T  compc = 0;
    oid compl[HASHSELTABLEENTRY_INSTANCE_LEN] = {0};
    oid best_inst[HASHSELTABLEENTRY_INSTANCE_LEN] = {0};
    UI8_T block_index;
    SWCTRL_OM_HashSelBlockInfo_T  block_info;

    switch (vp->magic)
    {
        case LEAF_hashSelIpv6SrcIp:
        case LEAF_hashSelIpv6DstIp:
        case LEAF_hashSelIpv6SrcL4Port:
        case LEAF_hashSelIpv6DstL4Port:
        case LEAF_hashSelIpv6NextHeader:
        case LEAF_hashSelIpv6Vlan:
            *write_method = write_hashSelIpv6Field;
            break;

        default:
            *write_method = 0;
            break;
    }

    /* check compc, retrive compl
     */
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl, HASHSELTABLEENTRY_INSTANCE_LEN);

    if (exact) /* get or set */
    {
        if (hashSelTable_OidIndexToData(exact, compc, compl, &block_index) == FALSE)
        {
            return NULL;
        }

        if (TRUE != SWCTRL_POM_GetHashBlockInfo(block_index, &block_info))
        {
            return NULL;
        }
    }
    else /* getnext */
    {
        hashSelTable_OidIndexToData(exact, compc, compl, &block_index);

        /* check the length of inputing index,if < 1 we should try get
         * {0.0.0.0.0...}
         */
        if (compc < 1)
        {
            block_index = 1;
            if (TRUE != SWCTRL_POM_GetHashBlockInfo(block_index, &block_info))
            {
                return NULL;
            }
        }
        else
        {
            block_index ++;
            if (block_index > SYS_ADPT_MAX_HASH_SELECTION_BLOCK_SIZE)
            {
                return NULL;
            }
            else
            {
                if (TRUE != SWCTRL_POM_GetHashBlockInfo(block_index, &block_info))
                {
                    return NULL;
                }
            }
        }
    }

    memcpy(name, vp->name, vp->namelen * sizeof(oid));

    /* assign data to the oid index
     */
    best_inst[0] = block_index;
    memcpy(name + vp->namelen, best_inst, HASHSELTABLEENTRY_INSTANCE_LEN * sizeof(oid));
    *length = vp->namelen + HASHSELTABLEENTRY_INSTANCE_LEN;

    switch (vp->magic)
    {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case LEAF_hashSelIpv6BlockIndex:
            *var_len = sizeof(long_return);
            long_return = (UI32_T)block_index;
            return (u_char *) &long_return;
#endif
        case LEAF_hashSelIpv6SrcIp:
            *var_len = sizeof(long_return);
            long_return = (block_info.pkt_ipv6.arg.item.src_ip? VAL_enabled: VAL_disabled);
            return (u_char *) &long_return;

        case LEAF_hashSelIpv6DstIp:
            *var_len = sizeof(long_return);
            long_return = (block_info.pkt_ipv6.arg.item.dst_ip? VAL_enabled: VAL_disabled);
            return (u_char *) &long_return;

        case LEAF_hashSelIpv6SrcL4Port:
            *var_len = sizeof(long_return);
            long_return = (block_info.pkt_ipv6.arg.item.src_l4_port? VAL_enabled: VAL_disabled);
            return (u_char *) &long_return;

        case LEAF_hashSelIpv6DstL4Port:
            *var_len = sizeof(long_return);
            long_return = (block_info.pkt_ipv6.arg.item.dst_l4_port? VAL_enabled: VAL_disabled);
            return (u_char *) &long_return;

        case LEAF_hashSelIpv6NextHeader:
            *var_len = sizeof(long_return);
            long_return = (block_info.pkt_ipv6.arg.item.next_header? VAL_enabled: VAL_disabled);
            return (u_char *) &long_return;

        case LEAF_hashSelIpv6Vlan:
            *var_len = sizeof(long_return);
            long_return = (block_info.pkt_ipv6.arg.item.vlan? VAL_enabled: VAL_disabled);
            return (u_char *) &long_return;

        default:
            ERROR_MSG("");
    }

    return NULL;
}

int write_hashSelMacField(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            switch (*(long *)var_val)
            {
            case VAL_enabled:
            case VAL_disabled:
                break;

            default:
                return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            UI8_T block_index;
            SWCTRL_OM_HashSelection_T selection;

            selection.type = SWCTRL_OM_HASH_PACKET_TYPE_L2;
            selection.sel.l2.arg.value = 0;

            if (hashSelTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &block_index) == FALSE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            switch (name[oid_name_length-1])
            {
                case LEAF_hashSelMacSrcMac:
                    selection.sel.l2.arg.item.src_mac = 1;
                    break;

                case LEAF_hashSelMacDstMac:
                    selection.sel.l2.arg.item.dst_mac = 1;
                    break;

                case LEAF_hashSelMacEtherType:
                    selection.sel.l2.arg.item.ether_type = 1;
                    break;

                case LEAF_hashSelMacVlan:
                    selection.sel.l2.arg.item.vlan = 1;
                    break;
            }

            if (*(long *)var_val == VAL_enabled)
            {
                if (TRUE != SWCTRL_PMGR_AddHashSelection(block_index, &selection))
                    return SNMP_ERR_COMMITFAILED;
            }

            if (*(long *)var_val == VAL_disabled)
            {
                if (TRUE != SWCTRL_PMGR_RemoveHashSelection(block_index, &selection))
                    return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

int write_hashSelIpv4Field(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            switch (*(long *)var_val)
            {
            case VAL_enabled:
            case VAL_disabled:
                break;

            default:
                return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            UI8_T block_index;
            SWCTRL_OM_HashSelection_T selection;

            selection.type = SWCTRL_OM_HASH_PACKET_TYPE_IPV4;
            selection.sel.ipv4.arg.value = 0;

            if (hashSelTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &block_index) == FALSE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            switch (name[oid_name_length-1])
            {
                case LEAF_hashSelIpv4SrcIp:
                    selection.sel.ipv4.arg.item.src_ip = 1;
                    break;

                case LEAF_hashSelIpv4DstIp:
                    selection.sel.ipv4.arg.item.dst_ip = 1;
                    break;

                case LEAF_hashSelIpv4SrcL4Port:
                    selection.sel.ipv4.arg.item.src_l4_port = 1;
                    break;

                case LEAF_hashSelIpv4DstL4Port:
                    selection.sel.ipv4.arg.item.dst_l4_port = 1;
                    break;

                case LEAF_hashSelIpv4ProtocolId:
                    selection.sel.ipv4.arg.item.protocol_id = 1;
                    break;

                case LEAF_hashSelIpv4Vlan:
                    selection.sel.ipv4.arg.item.vlan = 1;
                    break;
            }

            if (*(long *)var_val == VAL_enabled)
            {
                if (TRUE != SWCTRL_PMGR_AddHashSelection(block_index, &selection))
                    return SNMP_ERR_COMMITFAILED;
            }

            if (*(long *)var_val == VAL_disabled)
            {
                if (TRUE != SWCTRL_PMGR_RemoveHashSelection(block_index, &selection))
                    return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

int write_hashSelIpv6Field(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            switch (*(long *)var_val)
            {
            case VAL_enabled:
            case VAL_disabled:
                break;

            default:
                return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 5;
            UI8_T block_index;
            SWCTRL_OM_HashSelection_T selection;

            selection.type = SWCTRL_OM_HASH_PACKET_TYPE_IPV6;
            selection.sel.ipv6.arg.value = 0;

            if (hashSelTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &block_index) == FALSE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            switch (name[oid_name_length-1])
            {
                case LEAF_hashSelIpv6SrcIp:
                    selection.sel.ipv6.arg.item.src_ip = 1;
                    break;

                case LEAF_hashSelIpv6DstIp:
                    selection.sel.ipv6.arg.item.dst_ip = 1;
                    break;

                case LEAF_hashSelIpv6SrcL4Port:
                    selection.sel.ipv6.arg.item.src_l4_port = 1;
                    break;

                case LEAF_hashSelIpv6DstL4Port:
                    selection.sel.ipv6.arg.item.dst_l4_port = 1;
                    break;

                case LEAF_hashSelIpv6NextHeader:
                    selection.sel.ipv6.arg.item.next_header = 1;
                    break;

                case LEAF_hashSelIpv6Vlan:
                    selection.sel.ipv6.arg.item.vlan = 1;
                    break;
            }

            if (*(long *)var_val == VAL_enabled)
            {
                if (TRUE != SWCTRL_PMGR_AddHashSelection(block_index, &selection))
                    return SNMP_ERR_COMMITFAILED;
            }

            if (*(long *)var_val == VAL_disabled)
            {
                if (TRUE != SWCTRL_PMGR_RemoveHashSelection(block_index, &selection))
                    return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}
#endif /*#if (SYS_CPNT_HASH_SELECTION == TRUE)*/
