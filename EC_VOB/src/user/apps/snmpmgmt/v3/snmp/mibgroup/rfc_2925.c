#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "rfc_2925.h"
#include "sysORTable.h"
#include "snmp_mgr.h"


#if (SYS_CPNT_TRACEROUTE == TRUE)
/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.scalar.conf,v 1.5 2002/07/18 14:18:52 dts12 Exp $
 */

#include "traceroute_type.h"
#include "traceroute_pom.h"
#include "traceroute_pmgr.h"


static L_INET_AddrIp_T compose_inet_addr(UI16_T type,UI8_T* addrp,UI16_T prefixLen)
{
    L_INET_AddrIp_T addr;
    addr.type = type;
    if(L_INET_ADDR_TYPE_IPV4 == type)
        addr.addrlen = SYS_ADPT_IPV4_ADDR_LEN;
    else if(L_INET_ADDR_TYPE_IPV6 == type)
        addr.addrlen = SYS_ADPT_IPV6_ADDR_LEN;
    else{printf ("Wooop! something wring!\r\n");}
    memcpy(addr.addr,addrp,addr.addrlen);
    addr.preflen = prefixLen;
    return addr;
}

void init_traceRouteObjects(void)
{
    oid dismanTraceRoute_module_oid[] = { SNMP_OID_MIB2, 81 };

    static oid traceRouteMaxConcurrentRequests_oid[] = { 1, 3, 6, 1, 2, 1, 81, 1, 1, 0 };

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("traceRouteMaxConcurrentRequests",
                               do_traceRouteMaxConcurrentRequests,
                               traceRouteMaxConcurrentRequests_oid,
                               OID_LENGTH(traceRouteMaxConcurrentRequests_oid),
                               HANDLER_CAN_RWRITE));

    REGISTER_SYSOR_ENTRY(dismanTraceRoute_module_oid, "RFC-2925 DismanTraceRoute MIB");
}


int do_traceRouteMaxConcurrentRequests(netsnmp_mib_handler          *handler,
                                       netsnmp_handler_registration *reginfo,
                                       netsnmp_agent_request_info   *reqinfo,
                                       netsnmp_request_info         *requests)
{
    switch (reqinfo->mode)
    {
        case MODE_GET:
        {
            UI32_T trace_route_max_concurrent_requests = 0;
            /*not support
            if(TRACEROUTE_MGR_GetTraceRouteMaxConcurrentRequests(&trace_route_max_concurrent_requests) != TRACEROUTE_TYPE_OK)
                return SNMP_ERR_GENERR;
            */
            long_return = trace_route_max_concurrent_requests;
            snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, (u_char *) &long_return, sizeof(long_return));

            break;
        }

        case MODE_SET_RESERVE1:
			if (requests->requestvb->type != ASN_UNSIGNED)
            {
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_WRONGTYPE);
            }
            break;

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            break;

        case MODE_SET_ACTION:
        {
            /*not support
            UI32_T trace_route_max_concurrent_requests;
            trace_route_max_concurrent_requests = (*requests->requestvb->val.integer);
            if (TRACEROUTE_MGR_SetTraceRouteMaxConcurrentRequests(trace_route_max_concurrent_requests) != TRACEROUTE_TYPE_OK)
            */
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);

            break;
        }

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}


#define    traceRouteCtlEntry_OID_NAME_LEN    11

oid traceRouteCtlTable_variables_oid[] = { 1, 3, 6, 1, 2, 1, 81, 1 };

struct variable3 traceRouteCtlTable_variables[] =
{
    {TRACEROUTECTLOWNERINDEX, ASN_OCTET_STR, RONLY, var_traceRouteCtlTable, 3, {2, 1, 1}},
    {TRACEROUTECTLTESTNAME, ASN_OCTET_STR, RONLY, var_traceRouteCtlTable, 3, {2, 1, 2}},
    {TRACEROUTECTLTARGETADDRESSTYPE, ASN_INTEGER, RWRITE, var_traceRouteCtlTable, 3, {2, 1, 3}},
    {TRACEROUTECTLTARGETADDRESS, ASN_OCTET_STR, RWRITE, var_traceRouteCtlTable, 3, {2, 1, 4}},
    {TRACEROUTECTLBYPASSROUTETABLE, ASN_INTEGER, RWRITE, var_traceRouteCtlTable, 3, {2, 1, 5}},
    {TRACEROUTECTLDATASIZE, ASN_UNSIGNED, RWRITE, var_traceRouteCtlTable, 3, {2, 1, 6}},
    {TRACEROUTECTLTIMEOUT, ASN_UNSIGNED, RWRITE, var_traceRouteCtlTable, 3, {2, 1, 7}},
    {TRACEROUTECTLPROBESPERHOP, ASN_UNSIGNED, RWRITE, var_traceRouteCtlTable, 3, {2, 1, 8}},
    {TRACEROUTECTLPORT, ASN_UNSIGNED, RWRITE, var_traceRouteCtlTable, 3, {2, 1, 9}},
    {TRACEROUTECTLMAXTTL, ASN_UNSIGNED, RWRITE, var_traceRouteCtlTable, 3, {2, 1, 10}},
    {TRACEROUTECTLDSFIELD, ASN_UNSIGNED, RWRITE, var_traceRouteCtlTable, 3, {2, 1, 11}},
    {TRACEROUTECTLSOURCEADDRESSTYPE, ASN_INTEGER, RWRITE, var_traceRouteCtlTable, 3, {2, 1, 12}},
    {TRACEROUTECTLSOURCEADDRESS, ASN_OCTET_STR, RWRITE, var_traceRouteCtlTable, 3, {2, 1, 13}},
    {TRACEROUTECTLIFINDEX, ASN_INTEGER, RWRITE, var_traceRouteCtlTable, 3, {2, 1, 14}},
    {TRACEROUTECTLMISCOPTIONS, ASN_OCTET_STR, RWRITE, var_traceRouteCtlTable, 3, {2, 1, 15}},
    {TRACEROUTECTLMAXFAILURES, ASN_UNSIGNED, RWRITE, var_traceRouteCtlTable, 3, {2, 1, 16}},
    {TRACEROUTECTLDONTFRAGMENT, ASN_INTEGER, RWRITE, var_traceRouteCtlTable, 3, {2, 1, 17}},
    {TRACEROUTECTLINITIALTTL, ASN_UNSIGNED, RWRITE, var_traceRouteCtlTable, 3, {2, 1, 18}},
    {TRACEROUTECTLFREQUENCY, ASN_UNSIGNED, RWRITE, var_traceRouteCtlTable, 3, {2, 1, 19}},
    {TRACEROUTECTLSTORAGETYPE, ASN_INTEGER, RWRITE, var_traceRouteCtlTable, 3, {2, 1, 20}},
    {TRACEROUTECTLADMINSTATUS, ASN_INTEGER, RWRITE, var_traceRouteCtlTable, 3, {2, 1, 21}},
    {TRACEROUTECTLDESCR, ASN_OCTET_STR, RWRITE, var_traceRouteCtlTable, 3, {2, 1, 22}},
    {TRACEROUTECTLMAXROWS, ASN_UNSIGNED, RWRITE, var_traceRouteCtlTable, 3, {2, 1, 23}},
    {TRACEROUTECTLTRAPGENERATION,ASN_BIT_STR , RWRITE, var_traceRouteCtlTable, 3, {2, 1, 24}},
    {TRACEROUTECTLCREATEHOPSENTRIES, ASN_INTEGER, RWRITE, var_traceRouteCtlTable, 3, {2, 1, 25}},
    {TRACEROUTECTLTYPE, ASN_OBJECT_ID, RWRITE, var_traceRouteCtlTable, 3, {2, 1, 26}},
    {TRACEROUTECTLROWSTATUS, ASN_INTEGER, RWRITE, var_traceRouteCtlTable, 3, {2, 1, 27}},
};


void init_traceRouteCtlTable(void)
{
    REGISTER_MIB("traceRouteCtlTable", traceRouteCtlTable_variables,
                 variable3, traceRouteCtlTable_variables_oid);
}

/* index is index1_length,index1_string,index2_length,inde2_string,so we should add 2.
 */
#define traceRouteCtlEntry_INSTANCE_LEN (2+MAXSIZE_traceRouteCtlOwnerIndex + MAXSIZE_traceRouteCtlTestName)

/* FUNCTION NAME : traceRouteCtlTable_get
 * PURPOSE:
 *          It is called for get data.
 * INPUT:
 *          compc -- the counter of the index
 *		compl  -- the list of the index
 *		data	   -- the data storage
 *
 * OUTPUT:
 *          data
 * RETURN:
 *          TRUE:
 *		FALSE:
 * NOTES:
 *
 */
static BOOL_T traceRouteCtlTable_get(int      compc,
                                oid     *compl,
                                TRACEROUTE_TYPE_TraceRouteCtlEntry_T   *data)
{
    UI8_T   trace_route_ctl_owner_index[MAXSIZE_traceRouteCtlOwnerIndex];    /* KEY 1 */
    UI32_T  trace_route_ctl_owner_index_len;
    UI8_T   trace_route_ctl_test_name[MAXSIZE_traceRouteCtlTestName];        /* KEY 2 */
    UI32_T  trace_route_ctl_test_name_len;

    /*check input length
     */
    if(compl[0]>MAXSIZE_traceRouteCtlOwnerIndex || compl[compl[0]+1]>MAXSIZE_traceRouteCtlTestName||compc>traceRouteCtlEntry_INSTANCE_LEN)
        return FALSE;

    memset(data, 0, sizeof(TRACEROUTE_TYPE_TraceRouteCtlEntry_T));
    trace_route_ctl_owner_index_len=compl[0];
    SNMP_MGR_ReadOctetFromCompl(compl ,1,compl[0],trace_route_ctl_owner_index);
    trace_route_ctl_test_name_len=compl[compl[0]+1];
    SNMP_MGR_ReadOctetFromCompl(compl,compl[0]+2,compl[0]+compl[compl[0]+1]+1,trace_route_ctl_test_name);

    /*get data
     */
    if (TRACEROUTE_POM_GetTraceRouteCtlEntry((char*)trace_route_ctl_owner_index,trace_route_ctl_owner_index_len,(char*)trace_route_ctl_test_name,trace_route_ctl_test_name_len,data)!=TRACEROUTE_TYPE_OK)
    {
        return FALSE;
    }
    else
    {
        return TRUE;
    } /*End of if */
}

static BOOL_T traceRouteCtlTable_next(int      compc,
                                 oid     *compl,
                                 TRACEROUTE_TYPE_TraceRouteCtlEntry_T    *data)
{
    UI8_T   trace_route_ctl_owner_index[MAXSIZE_traceRouteCtlOwnerIndex];    /* KEY 1 */
    UI32_T  trace_route_ctl_owner_index_len;
    UI8_T   trace_route_ctl_test_name[MAXSIZE_traceRouteCtlTestName];        /* KEY 2 */
    UI32_T  trace_route_ctl_test_name_len;
    memset(data, 0, sizeof(TRACEROUTE_TYPE_TraceRouteCtlEntry_T));
    trace_route_ctl_owner_index_len=compl[0];
    SNMP_MGR_ReadOctetFromCompl(compl ,1,compl[0],trace_route_ctl_owner_index);
    trace_route_ctl_test_name_len=compl[compl[0]+1];
    SNMP_MGR_ReadOctetFromCompl(compl,compl[0]+2,compl[0]+compl[compl[0]+1]+1,trace_route_ctl_test_name);

    /*check  the length of inputing index,if <1 we should try get {0.0.0.0.0...} */
    if (compc<2)
    {
        /*get data*/
        if (TRACEROUTE_POM_GetTraceRouteCtlEntry((char*)trace_route_ctl_owner_index,trace_route_ctl_owner_index_len,(char*)trace_route_ctl_test_name,trace_route_ctl_test_name_len,data)!=TRACEROUTE_TYPE_OK)
        {
            /*get data*/
            if (TRACEROUTE_POM_GetNextTraceRouteCtlEntry((char*)trace_route_ctl_owner_index,trace_route_ctl_owner_index_len,(char*)trace_route_ctl_test_name,trace_route_ctl_test_name_len,data)!=TRACEROUTE_TYPE_OK)
            {
                return FALSE;
            }
        }
    }
    else
    {
        /*get data*/
        if (TRACEROUTE_POM_GetNextTraceRouteCtlEntry((char*)trace_route_ctl_owner_index,trace_route_ctl_owner_index_len,(char*)trace_route_ctl_test_name,trace_route_ctl_test_name_len, data)!=TRACEROUTE_TYPE_OK)
        {
            return FALSE;
        }
    }
    return TRUE;
}

unsigned char * var_traceRouteCtlTable(struct variable *vp,
                                       oid             *name,
                                       size_t          *length,
                                       int             exact,
                                       size_t          *var_len,
                                       WriteMethod     **write_method)
{
    UI32_T compc=0;
    oid compl[traceRouteCtlEntry_INSTANCE_LEN];
    oid best_inst[traceRouteCtlEntry_INSTANCE_LEN];
    TRACEROUTE_TYPE_TraceRouteCtlEntry_T  entry;

    switch (vp->magic)
    {
        case TRACEROUTECTLTARGETADDRESSTYPE:
            *write_method = write_traceRouteCtlTargetAddressType;
            break;
        case TRACEROUTECTLTARGETADDRESS:
            *write_method = write_traceRouteCtlTargetAddress;
            break;
        case TRACEROUTECTLBYPASSROUTETABLE:
            *write_method = write_traceRouteCtlByPassRouteTable;
            break;
        case TRACEROUTECTLDATASIZE:
            *write_method = write_traceRouteCtlDataSize;
            break;
        case TRACEROUTECTLTIMEOUT:
            *write_method = write_traceRouteCtlTimeOut;
            break;
        case TRACEROUTECTLPROBESPERHOP:
            *write_method = write_traceRouteCtlProbesPerHop;
            break;
        case TRACEROUTECTLPORT:
            *write_method = write_traceRouteCtlPort;
            break;
        case TRACEROUTECTLMAXTTL:
            *write_method = write_traceRouteCtlMaxTtl;
            break;
        case TRACEROUTECTLDSFIELD:
            *write_method = write_traceRouteCtlDSField;
            break;
        case TRACEROUTECTLSOURCEADDRESSTYPE:
            *write_method = write_traceRouteCtlSourceAddressType;
            break;
        case TRACEROUTECTLSOURCEADDRESS:
            *write_method = write_traceRouteCtlSourceAddress;
            break;
        case TRACEROUTECTLIFINDEX:
            *write_method = write_traceRouteCtlIfIndex;
            break;
        case TRACEROUTECTLMISCOPTIONS:
            *write_method = write_traceRouteCtlMiscOptions;
            break;
        case TRACEROUTECTLMAXFAILURES:
            *write_method = write_traceRouteCtlMaxFailures;
            break;
        case TRACEROUTECTLDONTFRAGMENT:
            *write_method = write_traceRouteCtlDontFragment;
            break;
        case TRACEROUTECTLINITIALTTL:
            *write_method = write_traceRouteCtlInitialTtl;
            break;
        case TRACEROUTECTLFREQUENCY:
            *write_method = write_traceRouteCtlFrequency;
            break;
        case TRACEROUTECTLSTORAGETYPE:
            *write_method = write_traceRouteCtlStorageType;
            break;
        case TRACEROUTECTLADMINSTATUS:
            *write_method = write_traceRouteCtlAdminStatus;
            break;
        case TRACEROUTECTLDESCR:
            *write_method = write_traceRouteCtlDescr;
            break;
        case TRACEROUTECTLMAXROWS:
            *write_method = write_traceRouteCtlMaxRows;
            break;
        case TRACEROUTECTLTRAPGENERATION:
            *write_method = write_traceRouteCtlTrapGeneration;
            break;
        case TRACEROUTECTLCREATEHOPSENTRIES:
            *write_method = write_traceRouteCtlCreateHopsEntries;
            break;
        case TRACEROUTECTLTYPE:
            *write_method = write_traceRouteCtlType;
            break;
        case TRACEROUTECTLROWSTATUS:
            *write_method = write_traceRouteCtlRowStatus;
            break;
        default:
            *write_method = 0;
            break;
    }
    /*check compc, retrive compl*/
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,compl, traceRouteCtlEntry_INSTANCE_LEN);

    if (exact)/*get,set*/
    {
        if (!traceRouteCtlTable_get(compc, compl, &entry))
            return NULL;
    }
    else/*getnext*/
    {
        if (!traceRouteCtlTable_next(compc, compl, &entry))
        {
            return NULL;
        }
    }
    memcpy(name, vp->name, vp->namelen*sizeof(oid));
    best_inst[0] = entry.trace_route_ctl_owner_index_len;
    SNMP_MGR_BindOctetInstance((UI8_T*)entry.trace_route_ctl_owner_index,1,best_inst[0],best_inst);
    best_inst[best_inst[0]+1]=entry.trace_route_ctl_test_name_len;
    SNMP_MGR_BindOctetInstance((UI8_T*)entry.trace_route_ctl_test_name,best_inst[0]+2,best_inst[0]+best_inst[best_inst[0]+1]+1,best_inst);
    memcpy(name + vp->namelen, best_inst, traceRouteCtlEntry_INSTANCE_LEN*sizeof(oid));
    *length = vp->namelen + best_inst[0] + best_inst[best_inst[0]+1]+2;

    *var_len = sizeof(long_return);

    switch (vp->magic)
    {
        case TRACEROUTECTLTARGETADDRESSTYPE:
            long_return = entry.trace_route_ctl_target_address_type;
            return (u_char *) &long_return;
        case TRACEROUTECTLTARGETADDRESS:
            {
                UI32_T out_inet_type, out_inet_addr_len, out_preflen;

                if (!SNMP_MGR_ConvertLInetAddrToInetAddrAndType(
                        (L_INET_Addr_T *)&entry.trace_route_ctl_target_address,
                        &out_inet_type,
                        &out_inet_addr_len,
                        (UI8_T *)return_buf,
                        &out_preflen))
                {
                    return NULL;
                }

                *var_len = out_inet_addr_len;
            }

            return (u_char *) return_buf;
        case TRACEROUTECTLBYPASSROUTETABLE:
            long_return = entry.trace_route_ctl_by_pass_route_table;;
            return (u_char *) &long_return;
        case TRACEROUTECTLDATASIZE:
            long_return = entry.trace_route_ctl_data_size;
            return (u_char *) &long_return;
        case TRACEROUTECTLTIMEOUT:
            long_return = entry.trace_route_ctl_timeout;
            return (u_char *) &long_return;
        case TRACEROUTECTLPROBESPERHOP:
            long_return = entry.trace_route_ctl_probes_per_hop;
            return (u_char *) &long_return;
        case TRACEROUTECTLPORT:
            long_return = entry.trace_route_ctl_port;
            return (u_char *) &long_return;
        case TRACEROUTECTLMAXTTL:
            long_return = entry.trace_route_ctl_max_ttl;
            return (u_char *) &long_return;
        case TRACEROUTECTLDSFIELD:
            long_return = entry.trace_route_ctl_ds_field;
            return (u_char *) &long_return;
        case TRACEROUTECTLSOURCEADDRESSTYPE:
            long_return = entry.trace_route_ctl_source_address_type;
            return (u_char *) &long_return;
        case TRACEROUTECTLSOURCEADDRESS:
            {
                UI32_T out_inet_type, out_inet_addr_len, out_preflen;

                if (!SNMP_MGR_ConvertLInetAddrToInetAddrAndType(
                        (L_INET_Addr_T *)&entry.trace_route_ctl_source_address,
                        &out_inet_type,
                        &out_inet_addr_len,
                        (UI8_T *)return_buf,
                        &out_preflen))
                {
                    return NULL;
                }

                *var_len = out_inet_addr_len;
            }

            return (u_char *) return_buf;
        case TRACEROUTECTLIFINDEX:
            long_return = entry.trace_route_ctl_if_index;
            return (u_char *) &long_return;
        case TRACEROUTECTLMISCOPTIONS:
            memcpy (return_buf, entry.trace_route_ctl_misc_options, entry.trace_route_ctl_misc_options_len);
            *var_len = entry.trace_route_ctl_misc_options_len;
            return (u_char *) return_buf;
        case TRACEROUTECTLMAXFAILURES:
            long_return = entry.trace_route_ctl_max_failures;
            return (u_char *) &long_return;
        case TRACEROUTECTLDONTFRAGMENT:
            long_return = entry.trace_route_ctl_dont_fragment;
            return (u_char *) &long_return;
        case TRACEROUTECTLINITIALTTL:
            long_return = entry.trace_route_ctl_initial_ttl;
            return (u_char *) &long_return;
        case TRACEROUTECTLFREQUENCY:
            long_return = entry.trace_route_ctl_frequency;
            return (u_char *) &long_return;
        case TRACEROUTECTLSTORAGETYPE:
            long_return = entry.trace_route_ctl_storage_type;
            return (u_char *) &long_return;
        case TRACEROUTECTLADMINSTATUS:
            long_return = entry.trace_route_ctl_admin_status;
            return (u_char *) &long_return;
        case TRACEROUTECTLDESCR:
            memcpy (return_buf, entry.trace_route_ctl_descr, entry.trace_route_ctl_descr_len);
            *var_len = entry.trace_route_ctl_descr_len;
            return (u_char *) return_buf;
        case TRACEROUTECTLMAXROWS:
            long_return = entry.trace_route_ctl_max_rows;
            return (u_char *) &long_return;
        case TRACEROUTECTLTRAPGENERATION:
            long_return = (UI32_T)entry.trace_route_ctl_trap_generation;
            long_return = L_STDLIB_Hton32(long_return);
            return (u_char *) &long_return;
        case TRACEROUTECTLCREATEHOPSENTRIES:
            long_return = entry.trace_route_ctl_create_hops_entries;
            return (u_char *) &long_return;
        case TRACEROUTECTLTYPE:
        {
            oid trace_route_ctl_type[9] = {1, 3, 6, 1, 2, 1, 81, 3, 0};
            *var_len = 9 * sizeof(oid);
            trace_route_ctl_type[8] = entry.trace_route_ctl_type;
            memcpy(oid_return, trace_route_ctl_type, *var_len);
            return (u_char*) oid_return;
        }
        case TRACEROUTECTLROWSTATUS:
            long_return = entry.trace_route_ctl_rowstatus;
            return (u_char *) &long_return;
        default:
            ERROR_MSG("");
    }

    return NULL;
}


int write_traceRouteCtlTargetAddressType(int       action,
                                         u_char    *var_val,
                                         u_char    var_val_type,
                                         size_t    var_val_len,
                                         u_char    *statP,
                                         oid       *name,
                                         size_t    name_len)
{
    long value;

    /*check max length of the inputing index */
    if(name_len > traceRouteCtlEntry_INSTANCE_LEN+traceRouteCtlEntry_OID_NAME_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    /*check length*/
    if(name[traceRouteCtlEntry_OID_NAME_LEN] > MAXSIZE_traceRouteCtlOwnerIndex)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    /*check length*/
    if(name[traceRouteCtlEntry_OID_NAME_LEN + 1 + name[traceRouteCtlEntry_OID_NAME_LEN]] > MAXSIZE_traceRouteCtlTestName)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }

            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }

            break;
        }

        case RESERVE2:
        {
            value = *(long *)var_val;

            switch (value)
            {
                case VAL_traceRouteCtlTargetAddressType_unknown:
                case VAL_traceRouteCtlTargetAddressType_ipv4:
                case VAL_traceRouteCtlTargetAddressType_ipv6:
                case VAL_traceRouteCtlTargetAddressType_ipv4z:
                case VAL_traceRouteCtlTargetAddressType_ipv6z:
                case VAL_traceRouteCtlTargetAddressType_dns:
                    break;
                default:
                    return SNMP_ERR_WRONGVALUE;
            }

            break;
        }

        case FREE:
            /* Release any resources that have been allocated */
            break;

        case ACTION:
        {

            UI32_T i, index1_len, index2_len;
            UI8_T index1[MAXSIZE_traceRouteCtlOwnerIndex], index2[MAXSIZE_traceRouteCtlTestName];
            TRACEROUTE_TYPE_TraceRouteCtlEntry_T ctl_entry;

            memset(index1, 0, MAXSIZE_traceRouteCtlOwnerIndex);
            memset(index2, 0, MAXSIZE_traceRouteCtlTestName);
            memset(&ctl_entry, 0, sizeof(ctl_entry));

            index1_len = name[traceRouteCtlEntry_OID_NAME_LEN];
            for(i = 0; i < index1_len ; i++)
            {
                index1[i] = name[traceRouteCtlEntry_OID_NAME_LEN + 1 + i];
            }

            index2_len = name[traceRouteCtlEntry_OID_NAME_LEN + 1 + index1_len];
            for(i = 0; i <index2_len; i++)
            {
                index2[i] = name[traceRouteCtlEntry_OID_NAME_LEN + 1 + index1_len + 1 + i];
            }

            value = *(long *)var_val;

            memcpy(ctl_entry.trace_route_ctl_owner_index, index1, index1_len);
            ctl_entry.trace_route_ctl_owner_index_len = index1_len;
            memcpy(ctl_entry.trace_route_ctl_test_name, index2, index2_len);
            ctl_entry.trace_route_ctl_test_name_len = index2_len;

            ctl_entry.trace_route_ctl_target_address_type = value;

            if(TRACEROUTE_PMGR_SetCtlEntryByField(&ctl_entry, TRACEROUTE_TYPE_CTLENTRYFIELD_TARGET_ADDRESS_TYPE) != TRACEROUTE_TYPE_OK)
                return SNMP_ERR_COMMITFAILED;

            break;
        }

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }

    return SNMP_ERR_NOERROR;
}


int write_traceRouteCtlTargetAddress(int       action,
                                     u_char    *var_val,
                                     u_char    var_val_type,
                                     size_t    var_val_len,
                                     u_char    *statP,
                                     oid       *name,
                                     size_t    name_len)
{
    int size;

    /*check max length of the inputing index */
    if(name_len >traceRouteCtlEntry_INSTANCE_LEN+traceRouteCtlEntry_OID_NAME_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    /*check  length */
    if(name[traceRouteCtlEntry_OID_NAME_LEN] > MAXSIZE_traceRouteCtlOwnerIndex)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    /*check  length */
    if(name[traceRouteCtlEntry_OID_NAME_LEN + 1 + name[traceRouteCtlEntry_OID_NAME_LEN]] > MAXSIZE_traceRouteCtlTestName)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_OCTET_STR)
            {
                return SNMP_ERR_WRONGTYPE;
            }

            break;
        }

        case RESERVE2:
        {
            size = var_val_len;

            if(size > MAXSIZE_traceRouteCtlTargetAddress)
            {
                return SNMP_ERR_WRONGLENGTH;
            }

            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            UI32_T i, index1_len, index2_len, buffer_len, in_inet_type;
            UI8_T index1[MAXSIZE_traceRouteCtlOwnerIndex], index2[MAXSIZE_traceRouteCtlTestName];
            UI8_T buffer[MAXSIZE_traceRouteCtlTargetAddress];
            TRACEROUTE_TYPE_TraceRouteCtlEntry_T ctl_entry;

            memset(index1, 0, MAXSIZE_traceRouteCtlOwnerIndex);
            memset(index2, 0, MAXSIZE_traceRouteCtlTestName);
            memset(&ctl_entry, 0, sizeof(ctl_entry));

            index1_len = name[traceRouteCtlEntry_OID_NAME_LEN];
            for(i = 0; i < index1_len ; i++)
            {
                index1[i] = name[traceRouteCtlEntry_OID_NAME_LEN + 1 + i];
            }

            index2_len = name[traceRouteCtlEntry_OID_NAME_LEN + 1 + index1_len];
            for(i = 0; i <index2_len; i++)
            {
                index2[i] = name[traceRouteCtlEntry_OID_NAME_LEN + 1 + index1_len + 1 + i];
            }


            memcpy(buffer, var_val, var_val_len);
            buffer_len = var_val_len;

            memcpy(ctl_entry.trace_route_ctl_owner_index, index1, index1_len);
            ctl_entry.trace_route_ctl_owner_index_len = index1_len;
            memcpy(ctl_entry.trace_route_ctl_test_name, index2, index2_len);
            ctl_entry.trace_route_ctl_test_name_len = index2_len;

            switch (var_val_len)
            {
                case 4:
                    in_inet_type = L_INET_ADDR_TYPE_IPV4;
                    break;
                case 8:
                    in_inet_type = L_INET_ADDR_TYPE_IPV4Z;
                    break;
                case 16:
                    in_inet_type = L_INET_ADDR_TYPE_IPV6;
                    break;
                case 20:
                    in_inet_type = L_INET_ADDR_TYPE_IPV6Z;
                    break;
                default:
                    return SNMP_ERR_COMMITFAILED;
            }

            if (!SNMP_MGR_ConvertInetAddrAndTypeToLInetAddr(
                    in_inet_type,
                    var_val_len,
                    var_val,
                    0,
                    (L_INET_Addr_T *)&ctl_entry.trace_route_ctl_target_address))
            {
                return SNMP_ERR_COMMITFAILED;
            }


            if(TRACEROUTE_PMGR_SetTraceRouteCtlTargetAddress(&ctl_entry) != TRACEROUTE_TYPE_OK)
                return SNMP_ERR_COMMITFAILED;

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}


int write_traceRouteCtlByPassRouteTable(int       action,
                                        u_char    *var_val,
                                        u_char    var_val_type,
                                        size_t    var_val_len,
                                        u_char    *statP,
                                        oid       *name,
                                        size_t    name_len)
{
    long value;

    /*check max length of the inputing index */
    if(name_len >traceRouteCtlEntry_INSTANCE_LEN+traceRouteCtlEntry_OID_NAME_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    /*check  length */
    if(name[traceRouteCtlEntry_OID_NAME_LEN] > MAXSIZE_traceRouteCtlOwnerIndex)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    /*check  length */
    if(name[traceRouteCtlEntry_OID_NAME_LEN + 1 + name[traceRouteCtlEntry_OID_NAME_LEN]] > MAXSIZE_traceRouteCtlTestName)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }

            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }

            break;
        }

        case RESERVE2:
        {
            value = *(long *)var_val;

            if ((value < VAL_traceRouteCtlByPassRouteTable_true) || (value > VAL_traceRouteCtlByPassRouteTable_false))
                return SNMP_ERR_WRONGVALUE;

            break;
        }

        case FREE:
            /* Release any resources that have been allocated */
            break;

        case ACTION:
        {
            /*not support
            UI32_T i, index1_len, index2_len;
            UI8_T index1[MAXSIZE_traceRouteCtlOwnerIndex], index2[MAXSIZE_traceRouteCtlTestName];

            memset(index1, 0, MAXSIZE_traceRouteCtlOwnerIndex);
            memset(index2, 0, MAXSIZE_traceRouteCtlTestName);

            index1_len = name[traceRouteCtlEntry_OID_NAME_LEN];
            for(i = 0; i < index1_len ; i++)
            {
                index1[i] = name[traceRouteCtlEntry_OID_NAME_LEN + 1 + i];
            }

            index2_len = name[traceRouteCtlEntry_OID_NAME_LEN + 1 + index1_len];
            for(i = 0; i <index2_len; i++)
            {
                index2[i] = name[traceRouteCtlEntry_OID_NAME_LEN + 1 + index1_len + 1 + i];
            }

            index2_len = name[traceRouteCtlEntry_OID_NAME_LEN + 1 + index1_len];
            value = *(long *)var_val;

            if(TRACEROUTE_MGR_SetTraceRouteCtlByPassRouteTable(index1, index1_len, index2, index2_len, value) != TRACEROUTE_TYPE_OK)
            */
                return SNMP_ERR_COMMITFAILED;

            break;
        }

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }

    return SNMP_ERR_NOERROR;
}


int write_traceRouteCtlDataSize(int       action,
                                u_char    *var_val,
                                u_char    var_val_type,
                                size_t    var_val_len,
                                u_char    *statP,
                                oid       *name,
                                size_t    name_len)
{
    long value;

    /*check max length of the inputing index */
    if(name_len >traceRouteCtlEntry_INSTANCE_LEN+traceRouteCtlEntry_OID_NAME_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    /*check  length */
    if(name[traceRouteCtlEntry_OID_NAME_LEN] > MAXSIZE_traceRouteCtlOwnerIndex)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    /*check  length */
    if(name[traceRouteCtlEntry_OID_NAME_LEN + 1 + name[traceRouteCtlEntry_OID_NAME_LEN]] > MAXSIZE_traceRouteCtlTestName)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_UNSIGNED)
            {
                return SNMP_ERR_WRONGTYPE;
            }

            if (var_val_len > sizeof(u_long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }

            break;
        }

        case RESERVE2:
        {
            value = *(u_long *) var_val;

            if((value < MIN_traceRouteCtlDataSize) || (value > MAX_traceRouteCtlDataSize))
                return SNMP_ERR_WRONGVALUE;

            break;
        }

        case FREE:
            /* Release any resources that have been allocated */
            break;

        case ACTION:
        {
            /* not support
            UI32_T i, index1_len, index2_len;
            UI8_T index1[MAXSIZE_traceRouteCtlOwnerIndex], index2[MAXSIZE_traceRouteCtlTestName];

            memset(index1, 0, MAXSIZE_traceRouteCtlOwnerIndex);
            memset(index2, 0, MAXSIZE_traceRouteCtlTestName);

            index1_len = name[traceRouteCtlEntry_OID_NAME_LEN];
            for(i = 0; i < index1_len ; i++)
            {
                index1[i] = name[traceRouteCtlEntry_OID_NAME_LEN + 1 + i];
            }

            index2_len = name[traceRouteCtlEntry_OID_NAME_LEN + 1 + index1_len];
            for(i = 0; i <index2_len; i++)
            {
                index2[i] = name[traceRouteCtlEntry_OID_NAME_LEN + 1 + index1_len + 1 + i];
            }

            index2_len = name[traceRouteCtlEntry_OID_NAME_LEN + 1 + index1_len];
            value = *(u_long *)var_val;

            if(TRACEROUTE_MGR_SetTraceRouteCtlDataSize(index1, index1_len, index2, index2_len, value) != TRACEROUTE_TYPE_OK)
            */
                return SNMP_ERR_COMMITFAILED;

            break;
        }

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }

    return SNMP_ERR_NOERROR;
}


int write_traceRouteCtlTimeOut(int       action,
                               u_char    *var_val,
                               u_char    var_val_type,
                               size_t    var_val_len,
                               u_char    *statP,
                               oid       *name,
                               size_t    name_len)
{
    long value;

    /*check max length of the inputing index */
    if(name_len >traceRouteCtlEntry_INSTANCE_LEN+traceRouteCtlEntry_OID_NAME_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    /*check  length */
    if(name[traceRouteCtlEntry_OID_NAME_LEN] > MAXSIZE_traceRouteCtlOwnerIndex)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    /*check  length */
    if(name[traceRouteCtlEntry_OID_NAME_LEN + 1 + name[traceRouteCtlEntry_OID_NAME_LEN]] > MAXSIZE_traceRouteCtlTestName)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_UNSIGNED)
            {
                return SNMP_ERR_WRONGTYPE;
            }

            if (var_val_len > sizeof(u_long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }

            break;
        }

        case RESERVE2:
        {
            value = *(u_long *)var_val;

            if((value < MIN_traceRouteCtlTimeOut) || (value > MAX_traceRouteCtlTimeOut))
                return SNMP_ERR_WRONGVALUE;

            break;
        }

        case FREE:
            /* Release any resources that have been allocated */
            break;

        case ACTION:
        {
            /*not support
            UI32_T i, index1_len, index2_len;
            UI8_T index1[MAXSIZE_traceRouteCtlOwnerIndex], index2[MAXSIZE_traceRouteCtlTestName];

            memset(index1, 0, MAXSIZE_traceRouteCtlOwnerIndex);
            memset(index2, 0, MAXSIZE_traceRouteCtlTestName);

            index1_len = name[traceRouteCtlEntry_OID_NAME_LEN];
            for(i = 0; i < index1_len ; i++)
            {
                index1[i] = name[traceRouteCtlEntry_OID_NAME_LEN + 1 + i];
            }

            index2_len = name[traceRouteCtlEntry_OID_NAME_LEN + 1 + index1_len];
            for(i = 0; i <index2_len; i++)
            {
                index2[i] = name[traceRouteCtlEntry_OID_NAME_LEN + 1 + index1_len + 1 + i];
            }

            index2_len = name[traceRouteCtlEntry_OID_NAME_LEN + 1 + index1_len];
            value = *(u_long *)var_val;

            if(TRACEROUTE_MGR_SetTraceRouteCtlTimeOut(index1, index1_len, index2, index2_len, value) != TRACEROUTE_TYPE_OK)
            */
                return SNMP_ERR_COMMITFAILED;

            break;
        }

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }

    return SNMP_ERR_NOERROR;
}


int write_traceRouteCtlProbesPerHop(int       action,
                                    u_char    *var_val,
                                    u_char    var_val_type,
                                    size_t    var_val_len,
                                    u_char    *statP,
                                    oid       *name,
                                    size_t    name_len)
{
    long value;

    /*check max length of the inputing index */
    if(name_len >traceRouteCtlEntry_INSTANCE_LEN+traceRouteCtlEntry_OID_NAME_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    /*check  length */
    if(name[traceRouteCtlEntry_OID_NAME_LEN] > MAXSIZE_traceRouteCtlOwnerIndex)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    /*check  length */
    if(name[traceRouteCtlEntry_OID_NAME_LEN + 1 + name[traceRouteCtlEntry_OID_NAME_LEN]] > MAXSIZE_traceRouteCtlTestName)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_UNSIGNED)
            {
                return SNMP_ERR_WRONGTYPE;
            }

            if (var_val_len > sizeof(u_long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }

            break;
        }

        case RESERVE2:
        {
            value = *(u_long *)var_val;

            if((value < MIN_traceRouteCtlProbesPerHop) || (value > MAX_traceRouteCtlProbesPerHop))
                return SNMP_ERR_WRONGVALUE;

            break;
        }

        case FREE:
            /* Release any resources that have been allocated */
            break;

        case ACTION:
        {
            /*not support
            UI32_T i, index1_len, index2_len;
            UI8_T index1[MAXSIZE_traceRouteCtlOwnerIndex], index2[MAXSIZE_traceRouteCtlTestName];

            memset(index1, 0, MAXSIZE_traceRouteCtlOwnerIndex);
            memset(index2, 0, MAXSIZE_traceRouteCtlTestName);

            index1_len = name[traceRouteCtlEntry_OID_NAME_LEN];
            for(i = 0; i < index1_len ; i++)
            {
                index1[i] = name[traceRouteCtlEntry_OID_NAME_LEN + 1 + i];
            }

            index2_len = name[traceRouteCtlEntry_OID_NAME_LEN + 1 + index1_len];
            for(i = 0; i <index2_len; i++)
            {
                index2[i] = name[traceRouteCtlEntry_OID_NAME_LEN + 1 + index1_len + 1 + i];
            }

            index2_len = name[traceRouteCtlEntry_OID_NAME_LEN + 1 + index1_len];
            value = *(u_long *)var_val;

            if(TRACEROUTE_MGR_SetTraceRouteCtlProbesPerHop(index1, index1_len, index2, index2_len, value) != TRACEROUTE_TYPE_OK)
            */
                return SNMP_ERR_COMMITFAILED;

            break;
        }

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }
    return SNMP_ERR_NOERROR;
}


int write_traceRouteCtlPort(int       action,
                            u_char    *var_val,
                            u_char    var_val_type,
                            size_t    var_val_len,
                            u_char    *statP,
                            oid       *name,
                            size_t    name_len)
{
    long value;

    /*check max length of the inputing index */
    if(name_len >traceRouteCtlEntry_INSTANCE_LEN+traceRouteCtlEntry_OID_NAME_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    /*check  length */
    if(name[traceRouteCtlEntry_OID_NAME_LEN] > MAXSIZE_traceRouteCtlOwnerIndex)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    /*check  length */
    if(name[traceRouteCtlEntry_OID_NAME_LEN + 1 + name[traceRouteCtlEntry_OID_NAME_LEN]] > MAXSIZE_traceRouteCtlTestName)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_UNSIGNED)
            {
                return SNMP_ERR_WRONGTYPE;
            }

            if (var_val_len > sizeof(u_long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }

            break;
        }

        case RESERVE2:
        {
            value = *(u_long *)var_val;

            if((value < MIN_traceRouteCtlPort) || (value > MAX_traceRouteCtlPort))
                return SNMP_ERR_WRONGVALUE;

            break;
        }

        case FREE:
            /* Release any resources that have been allocated */
            break;

        case ACTION:
        {
            /*not support
            UI32_T i, index1_len, index2_len;
            UI8_T index1[MAXSIZE_traceRouteCtlOwnerIndex], index2[MAXSIZE_traceRouteCtlTestName];

            memset(index1, 0, MAXSIZE_traceRouteCtlOwnerIndex);
            memset(index2, 0, MAXSIZE_traceRouteCtlTestName);

            index1_len = name[traceRouteCtlEntry_OID_NAME_LEN];
            for(i = 0; i < index1_len ; i++)
            {
                index1[i] = name[traceRouteCtlEntry_OID_NAME_LEN + 1 + i];
            }

            index2_len = name[traceRouteCtlEntry_OID_NAME_LEN + 1 + index1_len];
            for(i = 0; i <index2_len; i++)
            {
                index2[i] = name[traceRouteCtlEntry_OID_NAME_LEN + 1 + index1_len + 1 + i];
            }

            value = *(u_long *)var_val;

            if(TRACEROUTE_MGR_SetTraceRouteCtlPort(index1, index1_len, index2, index2_len, value) != TRACEROUTE_TYPE_OK)
            */
                return SNMP_ERR_COMMITFAILED;

            break;
        }

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }

    return SNMP_ERR_NOERROR;
}


int write_traceRouteCtlMaxTtl(int       action,
                              u_char    *var_val,
                              u_char    var_val_type,
                              size_t    var_val_len,
                              u_char    *statP,
                              oid       *name,
                              size_t    name_len)
{
    long value;

    /*check max length of the inputing index */
    if(name_len >traceRouteCtlEntry_INSTANCE_LEN+traceRouteCtlEntry_OID_NAME_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    /*check  length */
    if(name[traceRouteCtlEntry_OID_NAME_LEN] > MAXSIZE_traceRouteCtlOwnerIndex)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    /*check  length */
    if(name[traceRouteCtlEntry_OID_NAME_LEN + 1 + name[traceRouteCtlEntry_OID_NAME_LEN]] > MAXSIZE_traceRouteCtlTestName)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_UNSIGNED)
            {
                return SNMP_ERR_WRONGTYPE;
            }

            if (var_val_len > sizeof(u_long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }

            break;
        }

        case RESERVE2:
        {
            value = *(u_long *)var_val;

            if((value < MIN_traceRouteCtlMaxTtl) || (value > MAX_traceRouteCtlMaxTtl))
                return SNMP_ERR_WRONGVALUE;

            break;
        }

        case FREE:
            /* Release any resources that have been allocated */
            break;

        case ACTION:
        {
            /* not support
            UI32_T i, index1_len, index2_len;
            UI8_T index1[MAXSIZE_traceRouteCtlOwnerIndex], index2[MAXSIZE_traceRouteCtlTestName];

            memset(index1, 0, MAXSIZE_traceRouteCtlOwnerIndex);
            memset(index2, 0, MAXSIZE_traceRouteCtlTestName);

            index1_len = name[traceRouteCtlEntry_OID_NAME_LEN];
            for(i = 0; i < index1_len ; i++)
            {
                index1[i] = name[traceRouteCtlEntry_OID_NAME_LEN + 1 + i];
            }

            index2_len = name[traceRouteCtlEntry_OID_NAME_LEN + 1 + index1_len];
            for(i = 0; i <index2_len; i++)
            {
                index2[i] = name[traceRouteCtlEntry_OID_NAME_LEN + 1 + index1_len + 1 + i];
            }

            value = *(u_long *)var_val;

           if(TRACEROUTE_MGR_SetTraceRouteCtlMaxTtl(index1, index1_len, index2, index2_len, value) != TRACEROUTE_TYPE_OK)
           */
                return SNMP_ERR_COMMITFAILED;

            break;
        }

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }

    return SNMP_ERR_NOERROR;
}


int write_traceRouteCtlDSField(int       action,
                               u_char    *var_val,
                               u_char    var_val_type,
                               size_t    var_val_len,
                               u_char    *statP,
                               oid       *name,
                               size_t    name_len)
{
    long value;

    /*check max length of the inputing index */
    if(name_len >traceRouteCtlEntry_INSTANCE_LEN+traceRouteCtlEntry_OID_NAME_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    /*check  length */
    if(name[traceRouteCtlEntry_OID_NAME_LEN] > MAXSIZE_traceRouteCtlOwnerIndex)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    /*check  length */
    if(name[traceRouteCtlEntry_OID_NAME_LEN + 1 + name[traceRouteCtlEntry_OID_NAME_LEN]] > MAXSIZE_traceRouteCtlTestName)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_UNSIGNED)
            {
                return SNMP_ERR_WRONGTYPE;
            }

            if (var_val_len > sizeof(u_long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }

            break;
        }

        case RESERVE2:
        {
            value = *(u_long *)var_val;

            if((value < MIN_traceRouteCtlDSField) || (value > MAX_traceRouteCtlDSField))
                return SNMP_ERR_WRONGVALUE;

            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            /* not support
            UI32_T i, index1_len, index2_len;
            UI8_T index1[MAXSIZE_traceRouteCtlOwnerIndex], index2[MAXSIZE_traceRouteCtlTestName];

            memset(index1, 0, MAXSIZE_traceRouteCtlOwnerIndex);
            memset(index2, 0, MAXSIZE_traceRouteCtlTestName);

            index1_len = name[traceRouteCtlEntry_OID_NAME_LEN];
            for(i = 0; i < index1_len ; i++)
            {
                index1[i] = name[traceRouteCtlEntry_OID_NAME_LEN + 1 + i];
            }

            index2_len = name[traceRouteCtlEntry_OID_NAME_LEN + 1 + index1_len];
            for(i = 0; i <index2_len; i++)
            {
                index2[i] = name[traceRouteCtlEntry_OID_NAME_LEN + 1 + index1_len + 1 + i];
            }

            value = *(u_long *)var_val;

           if(TRACEROUTE_MGR_SetTraceRouteCtlDSField(index1, index1_len, index2, index2_len, value) != TRACEROUTE_TYPE_OK)
           */
                return SNMP_ERR_COMMITFAILED;

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}


int write_traceRouteCtlSourceAddressType(int       action,
                                         u_char    *var_val,
                                         u_char    var_val_type,
                                         size_t    var_val_len,
                                         u_char    *statP,
                                         oid       *name,
                                         size_t    name_len)
{
    long value;

    /*check max length of the inputing index */
    if(name_len >traceRouteCtlEntry_INSTANCE_LEN+traceRouteCtlEntry_OID_NAME_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    /*check  length */
    if(name[traceRouteCtlEntry_OID_NAME_LEN] > MAXSIZE_traceRouteCtlOwnerIndex)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    /*check  length */
    if(name[traceRouteCtlEntry_OID_NAME_LEN + 1 + name[traceRouteCtlEntry_OID_NAME_LEN]] > MAXSIZE_traceRouteCtlTestName)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }

            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }

            break;
        }

        case RESERVE2:
        {
            value = *(long *)var_val;

            switch (value)
            {
                case VAL_traceRouteCtlSourceAddressType_unknown:
                case VAL_traceRouteCtlSourceAddressType_ipv4:
                case VAL_traceRouteCtlSourceAddressType_ipv6:
                case VAL_traceRouteCtlSourceAddressType_ipv4z:
                case VAL_traceRouteCtlSourceAddressType_ipv6z:
                case VAL_traceRouteCtlSourceAddressType_dns:
                    break;
                default:
                    return SNMP_ERR_WRONGVALUE;
            }

            break;
        }

        case FREE:
            /* Release any resources that have been allocated */
            break;

        case ACTION:
        {
            /*not support
            UI32_T i, index1_len, index2_len;
            UI8_T index1[MAXSIZE_traceRouteCtlOwnerIndex], index2[MAXSIZE_traceRouteCtlTestName];

            memset(index1, 0, MAXSIZE_traceRouteCtlOwnerIndex);
            memset(index2, 0, MAXSIZE_traceRouteCtlTestName);

            index1_len = name[traceRouteCtlEntry_OID_NAME_LEN];
            for(i = 0; i < index1_len ; i++)
            {
                index1[i] = name[traceRouteCtlEntry_OID_NAME_LEN + 1 + i];
            }

            index2_len = name[traceRouteCtlEntry_OID_NAME_LEN + 1 + index1_len];
            for(i = 0; i <index2_len; i++)
            {
                index2[i] = name[traceRouteCtlEntry_OID_NAME_LEN + 1 + index1_len + 1 + i];
            }

            value = *(long *)var_val;

            if(TRACEROUTE_MGR_SetTraceRouteCtlSourceAddressType(index1, index1_len, index2, index2_len, value) != TRACEROUTE_TYPE_OK)
            */
                return SNMP_ERR_COMMITFAILED;

            break;
        }

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }

    return SNMP_ERR_NOERROR;
}


int write_traceRouteCtlSourceAddress(int       action,
                                     u_char    *var_val,
                                     u_char    var_val_type,
                                     size_t    var_val_len,
                                     u_char    *statP,
                                     oid       *name,
                                     size_t    name_len)
{
    int size;

    /*check max length of the inputing index */
    if(name_len >traceRouteCtlEntry_INSTANCE_LEN+traceRouteCtlEntry_OID_NAME_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    /*check  length */
    if(name[traceRouteCtlEntry_OID_NAME_LEN] > MAXSIZE_traceRouteCtlOwnerIndex)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    /*check  length */
    if(name[traceRouteCtlEntry_OID_NAME_LEN + 1 + name[traceRouteCtlEntry_OID_NAME_LEN]] > MAXSIZE_traceRouteCtlTestName)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_OCTET_STR)
            {
                return SNMP_ERR_WRONGTYPE;
            }

            break;
        }

        case RESERVE2:
        {
            size = var_val_len;

            if(size > MAXSIZE_traceRouteCtlSourceAddress)
            {
                return SNMP_ERR_WRONGLENGTH;
            }

            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            /*
            UI32_T i, index1_len, index2_len, buffer_len;
            UI8_T index1[MAXSIZE_traceRouteCtlOwnerIndex], index2[MAXSIZE_traceRouteCtlTestName];
            UI8_T buffer[MAXSIZE_traceRouteCtlTargetAddress];

            memset(index1, 0, MAXSIZE_traceRouteCtlOwnerIndex);
            memset(index2, 0, MAXSIZE_traceRouteCtlTestName);

            index1_len = name[traceRouteCtlEntry_OID_NAME_LEN];
            for(i = 0; i < index1_len ; i++)
            {
                index1[i] = name[traceRouteCtlEntry_OID_NAME_LEN + 1 + i];
            }

            index2_len = name[traceRouteCtlEntry_OID_NAME_LEN + 1 + index1_len];
            for(i = 0; i <index2_len; i++)
            {
                index2[i] = name[traceRouteCtlEntry_OID_NAME_LEN + 1 + index1_len + 1 + i];
            }

            memcpy(buffer, var_val, var_val_len);
            buffer_len = var_val_len;

            if(TRACEROUTE_MGR_SetTraceRouteCtlSourceAddress(index1, index1_len, index2, index2_len, buffer, buffer_len) != TRACEROUTE_TYPE_OK)
            */
                return SNMP_ERR_COMMITFAILED;

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}


int write_traceRouteCtlIfIndex(int       action,
                               u_char    *var_val,
                               u_char    var_val_type,
                               size_t    var_val_len,
                               u_char    *statP,
                               oid       *name,
                               size_t    name_len)
{
    //long value;

    /*check max length of the inputing index */
    if(name_len >traceRouteCtlEntry_INSTANCE_LEN+traceRouteCtlEntry_OID_NAME_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    /*check  length */
    if(name[traceRouteCtlEntry_OID_NAME_LEN] > MAXSIZE_traceRouteCtlOwnerIndex)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    /*check  length */
    if(name[traceRouteCtlEntry_OID_NAME_LEN + 1 + name[traceRouteCtlEntry_OID_NAME_LEN]] > MAXSIZE_traceRouteCtlTestName)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }

            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }

            break;
        }

        case RESERVE2:
            break;

        case FREE:
            /* Release any resources that have been allocated */
            break;

        case ACTION:
        {
            /*
            UI32_T i, index1_len, index2_len;
            UI8_T index1[MAXSIZE_traceRouteCtlOwnerIndex], index2[MAXSIZE_traceRouteCtlTestName];

            memset(index1, 0, MAXSIZE_traceRouteCtlOwnerIndex);
            memset(index2, 0, MAXSIZE_traceRouteCtlTestName);

            index1_len = name[traceRouteCtlEntry_OID_NAME_LEN];
            for(i = 0; i < index1_len ; i++)
            {
                index1[i] = name[traceRouteCtlEntry_OID_NAME_LEN + 1 + i];
            }

            index2_len = name[traceRouteCtlEntry_OID_NAME_LEN + 1 + index1_len];
            for(i = 0; i <index2_len; i++)
            {
                index2[i] = name[traceRouteCtlEntry_OID_NAME_LEN + 1 + index1_len + 1 + i];
            }

            value = *(long *)var_val;

            if(TRACEROUTE_MGR_SetTraceRouteCtlIfIndex(index1, index1_len, index2, index2_len, value) != TRACEROUTE_TYPE_OK)
            */
                return SNMP_ERR_COMMITFAILED;

            break;
        }

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }

    return SNMP_ERR_NOERROR;
}


int write_traceRouteCtlMiscOptions(int       action,
                                   u_char    *var_val,
                                   u_char    var_val_type,
                                   size_t    var_val_len,
                                   u_char    *statP,
                                   oid       *name,
                                   size_t    name_len)
{
    /*check max length of the inputing index */
    if(name_len >traceRouteCtlEntry_INSTANCE_LEN+traceRouteCtlEntry_OID_NAME_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    /*check  length */
    if(name[traceRouteCtlEntry_OID_NAME_LEN] > MAXSIZE_traceRouteCtlOwnerIndex)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    /*check  length */
    if(name[traceRouteCtlEntry_OID_NAME_LEN + 1 + name[traceRouteCtlEntry_OID_NAME_LEN]] > MAXSIZE_traceRouteCtlTestName)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_OCTET_STR)
            {
                return SNMP_ERR_WRONGTYPE;
            }

            if (var_val_len > MAXSIZE_traceRouteCtlMiscOptions)
            {
                return SNMP_ERR_WRONGLENGTH;
            }

            break;
        }

        case RESERVE2:
            break;

        case FREE:
            /* Release any resources that have been allocated */
            break;

        case ACTION:
        {
            /*not support
            UI32_T i, index1_len, index2_len, buffer_len;
            UI8_T index1[MAXSIZE_traceRouteCtlOwnerIndex], index2[MAXSIZE_traceRouteCtlTestName];
            UI8_T buffer[MAXSIZE_traceRouteCtlMiscOptions];

            memset(index1, 0, MAXSIZE_traceRouteCtlOwnerIndex);
            memset(index2, 0, MAXSIZE_traceRouteCtlTestName);

            index1_len = name[traceRouteCtlEntry_OID_NAME_LEN];
            for(i = 0; i < index1_len ; i++)
            {
                index1[i] = name[traceRouteCtlEntry_OID_NAME_LEN + 1 + i];
            }

            index2_len = name[traceRouteCtlEntry_OID_NAME_LEN + 1 + index1_len];
            for(i = 0; i <index2_len; i++)
            {
                index2[i] = name[traceRouteCtlEntry_OID_NAME_LEN + 1 + index1_len + 1 + i];
            }

            memcpy(buffer, var_val, var_val_len);
            buffer_len = var_val_len;

           if(TRACEROUTE_MGR_SetTraceRouteCtlMiscOptions(index1, index1_len, index2, index2_len, buffer, buffer_len) != TRACEROUTE_TYPE_OK)
           */
                return SNMP_ERR_COMMITFAILED;

            break;
        }

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }

    return SNMP_ERR_NOERROR;
}


int write_traceRouteCtlMaxFailures(int       action,
                                   u_char    *var_val,
                                   u_char    var_val_type,
                                   size_t    var_val_len,
                                   u_char    *statP,
                                   oid       *name,
                                   size_t    name_len)
{
    long value;

    /*check max length of the inputing index */
    if(name_len >traceRouteCtlEntry_INSTANCE_LEN+traceRouteCtlEntry_OID_NAME_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    /*check  length */
    if(name[traceRouteCtlEntry_OID_NAME_LEN] > MAXSIZE_traceRouteCtlOwnerIndex)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    /*check  length */
    if(name[traceRouteCtlEntry_OID_NAME_LEN + 1 + name[traceRouteCtlEntry_OID_NAME_LEN]] > MAXSIZE_traceRouteCtlTestName)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_UNSIGNED)
            {
                return SNMP_ERR_WRONGTYPE;
            }

            if (var_val_len > sizeof(u_long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }

            break;
        }

        case RESERVE2:
        {
            value = *(u_long *)var_val;

            if((value < MIN_traceRouteCtlMaxFailures) || (value > MAX_traceRouteCtlMaxFailures))
                return SNMP_ERR_WRONGVALUE;

            break;
        }

        case FREE:
            /* Release any resources that have been allocated */
            break;

        case ACTION:
        {
            /*not support
            UI32_T i, index1_len, index2_len;
            UI8_T index1[MAXSIZE_traceRouteCtlOwnerIndex], index2[MAXSIZE_traceRouteCtlTestName];

            memset(index1, 0, MAXSIZE_traceRouteCtlOwnerIndex);
            memset(index2, 0, MAXSIZE_traceRouteCtlTestName);

            index1_len = name[traceRouteCtlEntry_OID_NAME_LEN];
            for(i = 0; i < index1_len ; i++)
            {
                index1[i] = name[traceRouteCtlEntry_OID_NAME_LEN + 1 + i];
            }

            index2_len = name[traceRouteCtlEntry_OID_NAME_LEN + 1 + index1_len];
            for(i = 0; i <index2_len; i++)
            {
                index2[i] = name[traceRouteCtlEntry_OID_NAME_LEN + 1 + index1_len + 1 + i];
            }

            index2_len = name[traceRouteCtlEntry_OID_NAME_LEN + 1 + index1_len];
            value = *(u_long *)var_val;

            if(TRACEROUTE_MGR_SetTraceRouteCtlMaxFailures(index1, index1_len, index2, index2_len, value) != TRACEROUTE_TYPE_OK)
            */
                return SNMP_ERR_COMMITFAILED;

            break;
        }

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }

    return SNMP_ERR_NOERROR;
}


int write_traceRouteCtlDontFragment(int       action,
                                    u_char    *var_val,
                                    u_char    var_val_type,
                                    size_t    var_val_len,
                                    u_char    *statP,
                                    oid       *name,
                                    size_t    name_len)
{
    long value;

    /*check max length of the inputing index */
    if(name_len >traceRouteCtlEntry_INSTANCE_LEN+traceRouteCtlEntry_OID_NAME_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    /*check  length */
    if(name[traceRouteCtlEntry_OID_NAME_LEN] > MAXSIZE_traceRouteCtlOwnerIndex)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    /*check  length */
    if(name[traceRouteCtlEntry_OID_NAME_LEN + 1 + name[traceRouteCtlEntry_OID_NAME_LEN]] > MAXSIZE_traceRouteCtlTestName)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }

            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }

            break;
        }

        case RESERVE2:
        {
            value = *(long *)var_val;

            if((value < VAL_traceRouteCtlDontFragment_true) || (value > VAL_traceRouteCtlDontFragment_false))
                return SNMP_ERR_WRONGVALUE;

            break;
        }

        case FREE:
            /* Release any resources that have been allocated */
            break;

        case ACTION:
        {
            /*not support
            UI32_T i, index1_len, index2_len;
            UI8_T index1[MAXSIZE_traceRouteCtlOwnerIndex], index2[MAXSIZE_traceRouteCtlTestName];

            memset(index1, 0, MAXSIZE_traceRouteCtlOwnerIndex);
            memset(index2, 0, MAXSIZE_traceRouteCtlTestName);

            index1_len = name[traceRouteCtlEntry_OID_NAME_LEN];
            for(i = 0; i < index1_len ; i++)
            {
                index1[i] = name[traceRouteCtlEntry_OID_NAME_LEN + 1 + i];
            }

            index2_len = name[traceRouteCtlEntry_OID_NAME_LEN + 1 + index1_len];
            for(i = 0; i <index2_len; i++)
            {
                index2[i] = name[traceRouteCtlEntry_OID_NAME_LEN + 1 + index1_len + 1 + i];
            }

            value = *(long *)var_val;

            if(TRACEROUTE_MGR_SetTraceRouteCtlDontFragment(index1, index1_len, index2, index2_len, value) != TRACEROUTE_TYPE_OK)
            */
                return SNMP_ERR_COMMITFAILED;

            break;
        }

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }

    return SNMP_ERR_NOERROR;
}


int write_traceRouteCtlInitialTtl(int       action,
                                  u_char    *var_val,
                                  u_char    var_val_type,
                                  size_t    var_val_len,
                                  u_char    *statP,
                                  oid       *name,
                                  size_t    name_len)
{
    long value;

    /*check max length of the inputing index */
    if(name_len >traceRouteCtlEntry_INSTANCE_LEN+traceRouteCtlEntry_OID_NAME_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    /*check  length */
    if(name[traceRouteCtlEntry_OID_NAME_LEN] > MAXSIZE_traceRouteCtlOwnerIndex)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    /*check  length */
    if(name[traceRouteCtlEntry_OID_NAME_LEN + 1 + name[traceRouteCtlEntry_OID_NAME_LEN]] > MAXSIZE_traceRouteCtlTestName)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_UNSIGNED)
            {
                return SNMP_ERR_WRONGTYPE;
            }

            if (var_val_len > sizeof(u_long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }

            break;
        }

        case RESERVE2:
        {
            value = *(u_long *)var_val;

            if((value < MIN_traceRouteCtlInitialTtl) || (value > MAX_traceRouteCtlInitialTtl))
                return SNMP_ERR_WRONGVALUE;

            break;
        }

        case FREE:
            /* Release any resources that have been allocated */
            break;

        case ACTION:
        {
            /*not support
            UI32_T i, index1_len, index2_len;
            UI8_T index1[MAXSIZE_traceRouteCtlOwnerIndex], index2[MAXSIZE_traceRouteCtlTestName];

            memset(index1, 0, MAXSIZE_traceRouteCtlOwnerIndex);
            memset(index2, 0, MAXSIZE_traceRouteCtlTestName);

            index1_len = name[traceRouteCtlEntry_OID_NAME_LEN];
            for(i = 0; i < index1_len ; i++)
            {
                index1[i] = name[traceRouteCtlEntry_OID_NAME_LEN + 1 + i];
            }

            index2_len = name[traceRouteCtlEntry_OID_NAME_LEN + 1 + index1_len];
            for(i = 0; i <index2_len; i++)
            {
                index2[i] = name[traceRouteCtlEntry_OID_NAME_LEN + 1 + index1_len + 1 + i];
            }

            index2_len = name[traceRouteCtlEntry_OID_NAME_LEN + 1 + index1_len];
            value = *(u_long *)var_val;

            if(TRACEROUTE_MGR_SetTraceRouteCtlInitialTtl(index1, index1_len, index2, index2_len, value) != TRACEROUTE_TYPE_OK)
            */
                return SNMP_ERR_COMMITFAILED;

            break;
        }

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }

    return SNMP_ERR_NOERROR;
}


int write_traceRouteCtlFrequency(int       action,
                                 u_char    *var_val,
                                 u_char    var_val_type,
                                 size_t    var_val_len,
                                 u_char    *statP,
                                 oid       *name,
                                 size_t    name_len)
{
    //long value;

    /*check max length of the inputing index */
    if(name_len >traceRouteCtlEntry_INSTANCE_LEN+traceRouteCtlEntry_OID_NAME_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    /*check  length */
    if(name[traceRouteCtlEntry_OID_NAME_LEN] > MAXSIZE_traceRouteCtlOwnerIndex)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    /*check  length */
    if(name[traceRouteCtlEntry_OID_NAME_LEN + 1 + name[traceRouteCtlEntry_OID_NAME_LEN]] > MAXSIZE_traceRouteCtlTestName)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_UNSIGNED)
            {
                return SNMP_ERR_WRONGTYPE;
            }

            if (var_val_len > sizeof(u_long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }

            break;
        }

        case RESERVE2:
            break;

        case FREE:
            /* Release any resources that have been allocated */
            break;

        case ACTION:
        {
            /*not support
            UI32_T i, index1_len, index2_len;
            UI8_T index1[MAXSIZE_traceRouteCtlOwnerIndex], index2[MAXSIZE_traceRouteCtlTestName];

            memset(index1, 0, MAXSIZE_traceRouteCtlOwnerIndex);
            memset(index2, 0, MAXSIZE_traceRouteCtlTestName);

            index1_len = name[traceRouteCtlEntry_OID_NAME_LEN];
            for(i = 0; i < index1_len ; i++)
            {
                index1[i] = name[traceRouteCtlEntry_OID_NAME_LEN + 1 + i];
            }

            index2_len = name[traceRouteCtlEntry_OID_NAME_LEN + 1 + index1_len];
            for(i = 0; i <index2_len; i++)
            {
                index2[i] = name[traceRouteCtlEntry_OID_NAME_LEN + 1 + index1_len + 1 + i];
            }

            value = *(u_long *)var_val;

            if(TRACEROUTE_MGR_SetTraceRouteCtlFrequency(index1, index1_len, index2, index2_len, value) != TRACEROUTE_TYPE_OK)
            */
                return SNMP_ERR_COMMITFAILED;

            break;
        }

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }

    return SNMP_ERR_NOERROR;
}


int write_traceRouteCtlStorageType(int       action,
                                   u_char    *var_val,
                                   u_char    var_val_type,
                                   size_t    var_val_len,
                                   u_char    *statP,
                                   oid       *name,
                                   size_t    name_len)
{
    long value;

    /*check max length of the inputing index */
    if(name_len >traceRouteCtlEntry_INSTANCE_LEN+traceRouteCtlEntry_OID_NAME_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    /*check  length */
    if(name[traceRouteCtlEntry_OID_NAME_LEN] > MAXSIZE_traceRouteCtlOwnerIndex)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    /*check  length */
    if(name[traceRouteCtlEntry_OID_NAME_LEN + 1 + name[traceRouteCtlEntry_OID_NAME_LEN]] > MAXSIZE_traceRouteCtlTestName)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }

            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }

            break;
        }

        case RESERVE2:
        {
            value = *(long *)var_val;

            switch (value)
            {
                case VAL_traceRouteCtlStorageType_other:
                case VAL_traceRouteCtlStorageType_volatile:
                case VAL_traceRouteCtlStorageType_nonVolatile:
                case VAL_traceRouteCtlStorageType_permanent:
                case VAL_traceRouteCtlStorageType_readOnly:
                    break;
                default:
                    return SNMP_ERR_WRONGVALUE;
            }

            break;
        }

        case FREE:
            /* Release any resources that have been allocated */
            break;

        case ACTION:
        {
            /*not support
            UI32_T i, index1_len, index2_len;
            UI8_T index1[MAXSIZE_traceRouteCtlOwnerIndex], index2[MAXSIZE_traceRouteCtlTestName];

            memset(index1, 0, MAXSIZE_traceRouteCtlOwnerIndex);
            memset(index2, 0, MAXSIZE_traceRouteCtlTestName);

            index1_len = name[traceRouteCtlEntry_OID_NAME_LEN];
            for(i = 0; i < index1_len ; i++)
            {
                index1[i] = name[traceRouteCtlEntry_OID_NAME_LEN + 1 + i];
            }

            index2_len = name[traceRouteCtlEntry_OID_NAME_LEN + 1 + index1_len];
            for(i = 0; i <index2_len; i++)
            {
                index2[i] = name[traceRouteCtlEntry_OID_NAME_LEN + 1 + index1_len + 1 + i];
            }

            value = *(long *)var_val;

            if(TRACEROUTE_MGR_SetTraceRouteCtlStorageType(index1, index1_len, index2, index2_len, value) != TRACEROUTE_TYPE_OK)
            */
                return SNMP_ERR_COMMITFAILED;

            break;
        }

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }

    return SNMP_ERR_NOERROR;
}


int write_traceRouteCtlAdminStatus(int       action,
                                   u_char    *var_val,
                                   u_char    var_val_type,
                                   size_t    var_val_len,
                                   u_char    *statP,
                                   oid       *name,
                                   size_t    name_len)
{
    long value;

    /*check max length of the inputing index */
    if(name_len >traceRouteCtlEntry_INSTANCE_LEN+traceRouteCtlEntry_OID_NAME_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    /*check  length */
    if(name[traceRouteCtlEntry_OID_NAME_LEN] > MAXSIZE_traceRouteCtlOwnerIndex)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    /*check  length */
    if(name[traceRouteCtlEntry_OID_NAME_LEN + 1 + name[traceRouteCtlEntry_OID_NAME_LEN]] > MAXSIZE_traceRouteCtlTestName)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }

            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }

            break;
        }

        case RESERVE2:
        {
            value = *(long *)var_val;

            if((value < VAL_traceRouteCtlAdminStatus_enabled) || (value > VAL_traceRouteCtlAdminStatus_disabled))
                return SNMP_ERR_WRONGVALUE;

            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            UI32_T i, index1_len, index2_len;
            UI8_T index1[MAXSIZE_traceRouteCtlOwnerIndex], index2[MAXSIZE_traceRouteCtlTestName];
            TRACEROUTE_TYPE_TraceRouteCtlEntry_T ctl_entry;

            memset(index1, 0, MAXSIZE_traceRouteCtlOwnerIndex);
            memset(index2, 0, MAXSIZE_traceRouteCtlTestName);
            memset(&ctl_entry, 0, sizeof(ctl_entry));

            index1_len = name[traceRouteCtlEntry_OID_NAME_LEN];
            for(i = 0; i < index1_len ; i++)
            {
                index1[i] = name[traceRouteCtlEntry_OID_NAME_LEN + 1 + i];
            }

            index2_len = name[traceRouteCtlEntry_OID_NAME_LEN + 1 + index1_len];
            for(i = 0; i <index2_len; i++)
            {
                index2[i] = name[traceRouteCtlEntry_OID_NAME_LEN + 1 + index1_len + 1 + i];
            }

            value = *(long *)var_val;

            memcpy(ctl_entry.trace_route_ctl_owner_index, index1, index1_len);
            ctl_entry.trace_route_ctl_owner_index_len = index1_len;
            memcpy(ctl_entry.trace_route_ctl_test_name, index2, index2_len);
            ctl_entry.trace_route_ctl_test_name_len = index2_len;
            ctl_entry.trace_route_ctl_admin_status = value;

            /*set value*/
            if(TRACEROUTE_PMGR_SetTraceRouteCtlAdminStatus(&ctl_entry) != TRACEROUTE_TYPE_OK)
                return SNMP_ERR_COMMITFAILED;

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}


int write_traceRouteCtlDescr(int       action,
                             u_char    *var_val,
                             u_char    var_val_type,
                             size_t    var_val_len,
                             u_char    *statP,
                             oid       *name,
                             size_t    name_len)
{
    /*check max length of the inputing index */
    if(name_len >traceRouteCtlEntry_INSTANCE_LEN+traceRouteCtlEntry_OID_NAME_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    /*check  length */
    if(name[traceRouteCtlEntry_OID_NAME_LEN] > MAXSIZE_traceRouteCtlOwnerIndex)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    /*check  length */
    if(name[traceRouteCtlEntry_OID_NAME_LEN + 1 + name[traceRouteCtlEntry_OID_NAME_LEN]] > MAXSIZE_traceRouteCtlTestName)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_OCTET_STR)
            {
                return SNMP_ERR_WRONGTYPE;
            }

            if (var_val_len > MAXSIZE_traceRouteCtlDescr)
            {
                return SNMP_ERR_WRONGLENGTH;
            }

            break;
        }

        case RESERVE2:
            break;

        case FREE:
            /* Release any resources that have been allocated */
            break;

        case ACTION:
        {
            /*not support
            UI32_T i, index1_len, index2_len, buffer_len;
            UI8_T index1[MAXSIZE_traceRouteCtlOwnerIndex], index2[MAXSIZE_traceRouteCtlTestName];
            UI8_T buffer[MAXSIZE_traceRouteCtlDescr];

            memset(index1, 0, MAXSIZE_traceRouteCtlOwnerIndex);
            memset(index2, 0, MAXSIZE_traceRouteCtlTestName);

            index1_len = name[traceRouteCtlEntry_OID_NAME_LEN];
            for(i = 0; i < index1_len ; i++)
            {
                index1[i] = name[traceRouteCtlEntry_OID_NAME_LEN + 1 + i];
            }

            index2_len = name[traceRouteCtlEntry_OID_NAME_LEN + 1 + index1_len];
            for(i = 0; i <index2_len; i++)
            {
                index2[i] = name[traceRouteCtlEntry_OID_NAME_LEN + 1 + index1_len + 1 + i];
            }

            memcpy(buffer, var_val, var_val_len);
            buffer_len = var_val_len;

           if(TRACEROUTE_MGR_SetTraceRouteCtlDescr(index1, index1_len, index2, index2_len, buffer, buffer_len) != TRACEROUTE_TYPE_OK)
           */
                return SNMP_ERR_COMMITFAILED;

            break;
        }

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }

    return SNMP_ERR_NOERROR;
}


int write_traceRouteCtlMaxRows(int       action,
                               u_char    *var_val,
                               u_char    var_val_type,
                               size_t    var_val_len,
                               u_char    *statP,
                               oid       *name,
                               size_t    name_len)
{
    //long value;

    /*check max length of the inputing index */
    if(name_len >traceRouteCtlEntry_INSTANCE_LEN+traceRouteCtlEntry_OID_NAME_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    /*check  length */
    if(name[traceRouteCtlEntry_OID_NAME_LEN] > MAXSIZE_traceRouteCtlOwnerIndex)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    /*check  length */
    if(name[traceRouteCtlEntry_OID_NAME_LEN + 1 + name[traceRouteCtlEntry_OID_NAME_LEN]] > MAXSIZE_traceRouteCtlTestName)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_UNSIGNED)
            {
                return SNMP_ERR_WRONGTYPE;
            }

            if (var_val_len > sizeof(u_long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }

            break;
        }

        case RESERVE2:
            break;

        case FREE:
            /* Release any resources that have been allocated */
            break;

        case ACTION:
        {
            /*not support
            UI32_T i, index1_len, index2_len;
            UI8_T index1[MAXSIZE_traceRouteCtlOwnerIndex], index2[MAXSIZE_traceRouteCtlTestName];

            memset(index1, 0, MAXSIZE_traceRouteCtlOwnerIndex);
            memset(index2, 0, MAXSIZE_traceRouteCtlTestName);

            index1_len = name[traceRouteCtlEntry_OID_NAME_LEN];
            for(i = 0; i < index1_len ; i++)
            {
                index1[i] = name[traceRouteCtlEntry_OID_NAME_LEN + 1 + i];
            }

            index2_len = name[traceRouteCtlEntry_OID_NAME_LEN + 1 + index1_len];
            for(i = 0; i <index2_len; i++)
            {
                index2[i] = name[traceRouteCtlEntry_OID_NAME_LEN + 1 + index1_len + 1 + i];
            }

            value = *(u_long *)var_val;

           if(TRACEROUTE_MGR_SetTraceRouteCtlMaxRows(index1, index1_len, index2, index2_len, value) != TRACEROUTE_TYPE_OK)
           */
                return SNMP_ERR_COMMITFAILED;

            break;
        }

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }

    return SNMP_ERR_NOERROR;
}


int write_traceRouteCtlTrapGeneration(int       action,
                                      u_char    *var_val,
                                      u_char    var_val_type,
                                      size_t    var_val_len,
                                      u_char    *statP,
                                      oid       *name,
                                      size_t    name_len)
{
     //long value;

    /*check max length of the inputing index */
    if(name_len >traceRouteCtlEntry_INSTANCE_LEN+traceRouteCtlEntry_OID_NAME_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    /*check  length */
    if(name[traceRouteCtlEntry_OID_NAME_LEN] > MAXSIZE_traceRouteCtlOwnerIndex)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    /*check  length */
    if(name[traceRouteCtlEntry_OID_NAME_LEN + 1 + name[traceRouteCtlEntry_OID_NAME_LEN]] > MAXSIZE_traceRouteCtlTestName)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_OCTET_STR)
            {
                return SNMP_ERR_WRONGTYPE;
            }

            if (var_val_len > sizeof(char))
            {
                return SNMP_ERR_WRONGLENGTH;
            }

            break;
        }

        case RESERVE2:
            break;

        case FREE:
            /* Release any resources that have been allocated */
            break;

        case ACTION:
        {
            /*
            UI32_T i, index1_len, index2_len;
            UI8_T index1[MAXSIZE_traceRouteCtlOwnerIndex], index2[MAXSIZE_traceRouteCtlTestName];
            UI8_T buffer;
            memset(index1, 0, MAXSIZE_traceRouteCtlOwnerIndex);
            memset(index2, 0, MAXSIZE_traceRouteCtlTestName);

            index1_len = name[traceRouteCtlEntry_OID_NAME_LEN];
            for(i = 0; i < index1_len ; i++)
            {
                index1[i] = name[traceRouteCtlEntry_OID_NAME_LEN + 1 + i];
            }

            index2_len = name[traceRouteCtlEntry_OID_NAME_LEN + 1 + index1_len];
            for(i = 0; i <index2_len; i++)
            {
                index2[i] = name[traceRouteCtlEntry_OID_NAME_LEN + 1 + index1_len + 1 + i];
            }

            memcpy(buffer, var_val, 1);
            if(TRACEROUTE_MGR_SettraceRouteCtlTrapGeneration(index1, index1_len, index2, index2_len, buffer) != TRACEROUTE_TYPE_OK)
            */
                return SNMP_ERR_COMMITFAILED;

            break;
        }

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }
    return SNMP_ERR_NOERROR;
}
int write_traceRouteCtlCreateHopsEntries(int       action,
                                         u_char    *var_val,
                                         u_char    var_val_type,
                                         size_t    var_val_len,
                                         u_char    *statP,
                                         oid       *name,
                                         size_t    name_len)
{
    long value;

    /*check max length of the inputing index */
    if(name_len >traceRouteCtlEntry_INSTANCE_LEN+traceRouteCtlEntry_OID_NAME_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    /*check  length */
    if(name[traceRouteCtlEntry_OID_NAME_LEN] > MAXSIZE_traceRouteCtlOwnerIndex)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    /*check  length */
    if(name[traceRouteCtlEntry_OID_NAME_LEN + 1 + name[traceRouteCtlEntry_OID_NAME_LEN]] > MAXSIZE_traceRouteCtlTestName)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }

            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }

            break;
        }

        case RESERVE2:
        {
            value = *(long *)var_val;

            if((value < VAL_traceRouteCtlCreateHopsEntries_true) || (value > VAL_traceRouteCtlCreateHopsEntries_false))
                return SNMP_ERR_WRONGVALUE;

            break;
        }

        case FREE:
            /* Release any resources that have been allocated */
            break;

        case ACTION:
        {
            /*not support
            UI32_T i, index1_len, index2_len;
            UI8_T index1[MAXSIZE_traceRouteCtlOwnerIndex], index2[MAXSIZE_traceRouteCtlTestName];

            memset(index1, 0, MAXSIZE_traceRouteCtlOwnerIndex);
            memset(index2, 0, MAXSIZE_traceRouteCtlTestName);

            index1_len = name[traceRouteCtlEntry_OID_NAME_LEN];
            for(i = 0; i < index1_len ; i++)
            {
                index1[i] = name[traceRouteCtlEntry_OID_NAME_LEN + 1 + i];
            }

            index2_len = name[traceRouteCtlEntry_OID_NAME_LEN + 1 + index1_len];
            for(i = 0; i <index2_len; i++)
            {
                index2[i] = name[traceRouteCtlEntry_OID_NAME_LEN + 1 + index1_len + 1 + i];
            }

            value = *(long *)var_val;

            if(TRACEROUTE_MGR_SetTraceRouteCtlCreateHopsEntries(index1, index1_len, index2, index2_len, value) != TRACEROUTE_TYPE_OK)
            */
                return SNMP_ERR_COMMITFAILED;

            break;
        }

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }

    return SNMP_ERR_NOERROR;
}


int write_traceRouteCtlType(int       action,
                            u_char    *var_val,
                            u_char    var_val_type,
                            size_t    var_val_len,
                            u_char    *statP,
                            oid       *name,
                            size_t    name_len)
{
    UI32_T  oid[9];
    //long value;

    /*check max length of the inputing index */
    if(name_len >traceRouteCtlEntry_INSTANCE_LEN+traceRouteCtlEntry_OID_NAME_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    /*check  length */
    if(name[traceRouteCtlEntry_OID_NAME_LEN] > MAXSIZE_traceRouteCtlOwnerIndex)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    /*check  length */
    if(name[traceRouteCtlEntry_OID_NAME_LEN + 1 + name[traceRouteCtlEntry_OID_NAME_LEN]] > MAXSIZE_traceRouteCtlTestName)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_OBJECT_ID)
            {
                return SNMP_ERR_WRONGTYPE;
            }

            if (var_val_len > 9 * sizeof(oid))
            {
                return SNMP_ERR_WRONGLENGTH;
            }

            break;
        }

        case RESERVE2:
        {
            memcpy(oid, var_val, var_val_len);

            if ((oid[0] != 1) || (oid[1] != 3) || (oid[2] != 6) || (oid[3] != 1) ||
                (oid[4] != 2) || (oid[5] != 1) || (oid[6] != 81) || (oid[7] != 3))
            {
                return SNMP_ERR_WRONGVALUE;
            }

            break;
        }

        case FREE:
            /* Release any resources that have been allocated */
            break;

        case ACTION:
        {
            /*not support
            UI32_T i, index1_len, index2_len;
            UI8_T index1[MAXSIZE_traceRouteCtlOwnerIndex], index2[MAXSIZE_traceRouteCtlTestName];

            memset(index1, 0, MAXSIZE_traceRouteCtlOwnerIndex);
            memset(index2, 0, MAXSIZE_traceRouteCtlTestName);

            index1_len = name[traceRouteCtlEntry_OID_NAME_LEN];
            for(i = 0; i < index1_len ; i++)
            {
                index1[i] = name[traceRouteCtlEntry_OID_NAME_LEN + 1 + i];
            }

            index2_len = name[traceRouteCtlEntry_OID_NAME_LEN + 1 + index1_len];
            for(i = 0; i <index2_len; i++)
            {
                index2[i] = name[traceRouteCtlEntry_OID_NAME_LEN + 1 + index1_len + 1 + i];
            }

            memcpy(oid, var_val, var_val_len);
            value = oid[8];

           if(TRACEROUTE_MGR_SetTraceRouteCtlType(index1, index1_len, index2, index2_len, value) != TRACEROUTE_TYPE_OK)
           */
                return SNMP_ERR_COMMITFAILED;

            break;
        }

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }

    return SNMP_ERR_NOERROR;
}


int write_traceRouteCtlRowStatus(int       action,
                                 u_char    *var_val,
                                 u_char    var_val_type,
                                 size_t    var_val_len,
                                 u_char    *statP,
                                 oid       *name,
                                 size_t    name_len)
{
    long value;

    /*check max length of the inputing index */
    if(name_len >traceRouteCtlEntry_INSTANCE_LEN+traceRouteCtlEntry_OID_NAME_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    /*check  length */
    if(name[traceRouteCtlEntry_OID_NAME_LEN] > MAXSIZE_traceRouteCtlOwnerIndex)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    /*check  length */
    if(name[traceRouteCtlEntry_OID_NAME_LEN + 1 + name[traceRouteCtlEntry_OID_NAME_LEN]] > MAXSIZE_traceRouteCtlTestName)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }

            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }

            break;
        }

        case RESERVE2:
        {
            value = *(long *)var_val;

            if((value < VAL_traceRouteCtlRowStatus_active) || (value > VAL_traceRouteCtlRowStatus_destroy))
                return SNMP_ERR_WRONGVALUE;

            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            UI32_T i, index1_len, index2_len;
            UI8_T index1[MAXSIZE_traceRouteCtlOwnerIndex], index2[MAXSIZE_traceRouteCtlTestName];
            TRACEROUTE_TYPE_TraceRouteCtlEntry_T ctl_entry;

            memset(index1, 0, MAXSIZE_traceRouteCtlOwnerIndex);
            memset(index2, 0, MAXSIZE_traceRouteCtlTestName);
            memset(&ctl_entry, 0, sizeof(ctl_entry));

            index1_len = name[traceRouteCtlEntry_OID_NAME_LEN];
            for(i = 0; i < index1_len ; i++)
            {
                index1[i] = name[traceRouteCtlEntry_OID_NAME_LEN + 1 + i];
            }

            index2_len = name[traceRouteCtlEntry_OID_NAME_LEN + 1 + index1_len];
            for(i = 0; i <index2_len; i++)
            {
                index2[i] = name[traceRouteCtlEntry_OID_NAME_LEN + 1 + index1_len + 1 + i];
            }

            value = *(long *)var_val;

            memcpy(ctl_entry.trace_route_ctl_owner_index, index1, index1_len);
            ctl_entry.trace_route_ctl_owner_index_len = index1_len;
            memcpy(ctl_entry.trace_route_ctl_test_name, index2, index2_len);
            ctl_entry.trace_route_ctl_test_name_len = index2_len;
            ctl_entry.trace_route_ctl_rowstatus = value;

            if(TRACEROUTE_PMGR_SetTraceRouteCtlRowStatus(&ctl_entry) != TRACEROUTE_TYPE_OK)
                return SNMP_ERR_COMMITFAILED;

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}


oid traceRouteResultsTable_variables_oid[] = { 1, 3, 6, 1, 2, 1, 81, 1 };

struct variable3 traceRouteResultsTable_variables[] =
{
    {TRACEROUTERESULTSOPERSTATUS,       ASN_INTEGER,      RONLY, var_traceRouteResultsTable, 3, {3, 1, 1}},
    {TRACEROUTERESULTSCURHOPCOUNT,      ASN_GAUGE,        RONLY, var_traceRouteResultsTable, 3, {3, 1, 2}},
    {TRACEROUTERESULTSCURPROBECOUNT,    ASN_GAUGE,        RONLY, var_traceRouteResultsTable, 3, {3, 1, 3}},
    {TRACEROUTERESULTSIPTGTADDRTYPE,    ASN_INTEGER,      RONLY, var_traceRouteResultsTable, 3, {3, 1, 4}},
    {TRACEROUTERESULTSIPTGTADDR,        ASN_OCTET_STR,    RONLY, var_traceRouteResultsTable, 3, {3, 1, 5}},
    {TRACEROUTERESULTSTESTATTEMPTS,     ASN_UNSIGNED,     RONLY, var_traceRouteResultsTable, 3, {3, 1, 6}},
    {TRACEROUTERESULTSTESTSUCCESSES,    ASN_UNSIGNED,     RONLY, var_traceRouteResultsTable, 3, {3, 1, 7}},
    {TRACEROUTERESULTSLASTGOODPATH,     ASN_OCTET_STR,    RONLY, var_traceRouteResultsTable, 3, {3, 1, 8}},
};

void init_traceRouteResultsTable(void)
{
    REGISTER_MIB("traceRouteResultsTable", traceRouteResultsTable_variables,
                 variable3, traceRouteResultsTable_variables_oid);
}
#define traceRouteResultsTable_INSTANCE_LEN (2+MAXSIZE_traceRouteCtlOwnerIndex + MAXSIZE_traceRouteCtlTestName)
static BOOL_T traceRouteResultsTable_get(int      compc,
                                oid     *compl,
                                TRACEROUTE_TYPE_TraceRouteResultsEntry_T   *data)
{
    UI8_T   trace_route_ctl_owner_index[MAXSIZE_traceRouteCtlOwnerIndex];    /* KEY 1 */
    UI32_T  trace_route_ctl_owner_index_len;
    UI8_T   trace_route_ctl_test_name[MAXSIZE_traceRouteCtlTestName];        /* KEY 2 */
    UI32_T  trace_route_ctl_test_name_len;

    /*check input length */
    if(compl[0]>MAXSIZE_traceRouteCtlOwnerIndex || compl[compl[0]+1]>MAXSIZE_traceRouteCtlTestName||compc>traceRouteResultsTable_INSTANCE_LEN)
        return FALSE;
    memset(data, 0, sizeof(TRACEROUTE_TYPE_TraceRouteResultsEntry_T));
    trace_route_ctl_owner_index_len=compl[0];
    SNMP_MGR_ReadOctetFromCompl(compl ,1,compl[0],trace_route_ctl_owner_index);
    trace_route_ctl_test_name_len=compl[compl[0]+1];
    SNMP_MGR_ReadOctetFromCompl(compl,compl[0]+2,compl[0]+compl[compl[0]+1]+1,trace_route_ctl_test_name);
    /*get data*/
    if (TRACEROUTE_POM_GetTraceRouteResultsEntry((char*)trace_route_ctl_owner_index,trace_route_ctl_owner_index_len,(char*)trace_route_ctl_test_name,trace_route_ctl_test_name_len,data)!=TRACEROUTE_TYPE_OK)
    {
        return FALSE;
    }
    else
    {
        return TRUE;
    } /*End of if */
}
static BOOL_T traceRouteResultsTable_next(int      compc,
                                 oid     *compl,
                                 TRACEROUTE_TYPE_TraceRouteResultsEntry_T    *data)
{
    UI8_T   trace_route_ctl_owner_index[MAXSIZE_traceRouteCtlOwnerIndex];    /* KEY 1 */
    UI32_T  trace_route_ctl_owner_index_len;
    UI8_T   trace_route_ctl_test_name[MAXSIZE_traceRouteCtlTestName];        /* KEY 2 */
    UI32_T  trace_route_ctl_test_name_len;
    memset(data, 0, sizeof(TRACEROUTE_TYPE_TraceRouteResultsEntry_T));
    trace_route_ctl_owner_index_len=compl[0];
    SNMP_MGR_ReadOctetFromCompl(compl ,1,compl[0],trace_route_ctl_owner_index);
    trace_route_ctl_test_name_len=compl[compl[0]+1];
    SNMP_MGR_ReadOctetFromCompl(compl,compl[0]+2,compl[0]+compl[compl[0]+1]+1,trace_route_ctl_test_name);
    /*check  the length of inputing index,if <1 we should try get {0.0.0.0.0...} */
    if (compc<2)
    {
        if (TRACEROUTE_POM_GetTraceRouteResultsEntry((char*)trace_route_ctl_owner_index,trace_route_ctl_owner_index_len,(char*)trace_route_ctl_test_name,trace_route_ctl_test_name_len,data)!=TRACEROUTE_TYPE_OK)
        {
            if (TRACEROUTE_POM_GetNextTraceRouteResultsEntry((char*)trace_route_ctl_owner_index,trace_route_ctl_owner_index_len,(char*)trace_route_ctl_test_name,trace_route_ctl_test_name_len,data)!=TRACEROUTE_TYPE_OK)
            {
                return FALSE;
            }
        }
    }
    else
    {
        if (TRACEROUTE_POM_GetNextTraceRouteResultsEntry((char*)trace_route_ctl_owner_index,trace_route_ctl_owner_index_len,(char*)trace_route_ctl_test_name,trace_route_ctl_test_name_len,data)!=TRACEROUTE_TYPE_OK)
        {
            return FALSE;
        }
    }
    return TRUE;
}

unsigned char * var_traceRouteResultsTable(struct variable *vp,
                                           oid             *name,
                                           size_t          *length,
                                           int             exact,
                                           size_t          *var_len,
                                           WriteMethod     **write_method)
{
    UI32_T compc=0;
    oid compl[traceRouteResultsTable_INSTANCE_LEN];
    oid best_inst[traceRouteResultsTable_INSTANCE_LEN];
    TRACEROUTE_TYPE_TraceRouteResultsEntry_T  entry;

    /*check compc, retrive compl*/
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,compl, traceRouteResultsTable_INSTANCE_LEN);
    if (exact)/*get,set*/
    {
        if (!traceRouteResultsTable_get(compc, compl, &entry))
            return NULL;
    }
    else/*getnext*/
    {
        if (!traceRouteResultsTable_next(compc, compl, &entry))
        {
            return NULL;
        }
    }
    memcpy(name, vp->name, vp->namelen*sizeof(oid));

    best_inst[0] = entry.trace_route_ctl_owner_index_len;
    SNMP_MGR_BindOctetInstance((UI8_T*)entry.trace_route_ctl_owner_index,1,best_inst[0],best_inst);
    best_inst[best_inst[0]+1]=entry.trace_route_ctl_test_name_len;
    SNMP_MGR_BindOctetInstance((UI8_T*)entry.trace_route_ctl_test_name,best_inst[0]+2,best_inst[0]+best_inst[best_inst[0]+1]+1,best_inst);
    memcpy(name + vp->namelen, best_inst, traceRouteResultsTable_INSTANCE_LEN*sizeof(oid));
    *length = vp->namelen + best_inst[0] + best_inst[best_inst[0]+1]+2;

    *var_len = sizeof(long_return);

    switch (vp->magic)
    {
        case TRACEROUTERESULTSOPERSTATUS:
            long_return = entry.trace_route_results_oper_status;
            return (u_char *) &long_return;
        case TRACEROUTERESULTSCURHOPCOUNT:
            long_return = entry.trace_route_results_cur_hop_count;
            return (u_char *) &long_return;
        case TRACEROUTERESULTSCURPROBECOUNT:
            long_return = entry.trace_route_results_cur_probe_count;
            return (u_char *) &long_return;
        case TRACEROUTERESULTSIPTGTADDRTYPE:
            long_return = entry.trace_route_results_ip_tgt_addr_type;
            return (u_char *) &long_return;
        case TRACEROUTERESULTSIPTGTADDR:
            {
                UI32_T out_inet_type, out_inet_addr_len, out_preflen;

                if (!SNMP_MGR_ConvertLInetAddrToInetAddrAndType(
                        (L_INET_Addr_T *)&entry.trace_route_results_ip_tgt_addr,
                        &out_inet_type,
                        &out_inet_addr_len,
                        (UI8_T *)return_buf,
                        &out_preflen))
                {
                    return NULL;
                }

                *var_len = out_inet_addr_len;
            }

            return (u_char *) return_buf;
        case TRACEROUTERESULTSTESTATTEMPTS:
            long_return = entry.trace_route_results_test_attempts;
            return (u_char *) &long_return;
        case TRACEROUTERESULTSTESTSUCCESSES:
            long_return = entry.trace_route_results_test_successes;
            return (u_char *) &long_return;
        case TRACEROUTERESULTSLASTGOODPATH:
            memcpy (return_buf, entry.trace_route_results_last_good_path, entry.trace_route_results_last_good_path_len);
            *var_len = entry.trace_route_results_last_good_path_len;
            return (u_char *) return_buf;

        default:
            ERROR_MSG("");
    }

    return NULL;
}


oid traceRouteProbeHistoryTable_variables_oid[] = { 1, 3, 6, 1, 2, 1, 81, 1 };

struct variable3 traceRouteProbeHistoryTable_variables[] =
{
    {TRACEROUTEPROBEHISTORYINDEX,         ASN_UNSIGNED,     RONLY, var_traceRouteProbeHistoryTable, 3, {4, 1, 1}},
    {TRACEROUTEPROBEHISTORYHOPINDEX,      ASN_UNSIGNED,     RONLY, var_traceRouteProbeHistoryTable, 3, {4, 1, 2}},
    {TRACEROUTEPROBEHISTORYPROBEINDEX,    ASN_UNSIGNED,     RONLY, var_traceRouteProbeHistoryTable, 3, {4, 1, 3}},
    {TRACEROUTEPROBEHISTORYHADDRTYPE,     ASN_INTEGER,      RONLY, var_traceRouteProbeHistoryTable, 3, {4, 1, 4}},
    {TRACEROUTEPROBEHISTORYHADDR,         ASN_OCTET_STR,    RONLY, var_traceRouteProbeHistoryTable, 3, {4, 1, 5}},
    {TRACEROUTEPROBEHISTORYRESPONSE,      ASN_UNSIGNED,     RONLY, var_traceRouteProbeHistoryTable, 3, {4, 1, 6}},
    {TRACEROUTEPROBEHISTORYSTATUS,        ASN_INTEGER,      RONLY, var_traceRouteProbeHistoryTable, 3, {4, 1, 7}},
    {TRACEROUTEPROBEHISTORYLASTRC,        ASN_INTEGER,      RONLY, var_traceRouteProbeHistoryTable, 3, {4, 1, 8}},
    {TRACEROUTEPROBEHISTORYTIME,          ASN_OCTET_STR,    RONLY, var_traceRouteProbeHistoryTable, 3, {4, 1, 9}},
};


void init_traceRouteProbeHistoryTable(void)
{
    REGISTER_MIB("traceRouteProbeHistoryTable", traceRouteProbeHistoryTable_variables,
                 variable3, traceRouteProbeHistoryTable_variables_oid);
}
#define traceRouteProbeHistoryTable_INSTANCE_LEN (5+MAXSIZE_traceRouteCtlOwnerIndex + MAXSIZE_traceRouteCtlTestName)
static BOOL_T traceRouteProbeHistoryTable_get(int      compc,
                                oid     *compl,
                                TRACEROUTE_TYPE_TraceRouteProbeHistoryEntry_T   *data)
{
    UI8_T   trace_route_ctl_owner_index[MAXSIZE_traceRouteCtlOwnerIndex];    /* KEY 1 */
    UI32_T  trace_route_ctl_owner_index_len;
    UI8_T   trace_route_ctl_test_name[MAXSIZE_traceRouteCtlTestName];        /* KEY 2 */
    UI32_T  trace_route_ctl_test_name_len;
    UI32_T  trace_route_probe_history_index;        /* KEY 3 */
    UI32_T  trace_route_probe_history_hop_index;    /* KEY 4 */
    UI32_T  trace_route_probe_history_probe_index;  /* KEY 5 */
    /*check input length */
    if(compl[0]>MAXSIZE_traceRouteCtlOwnerIndex || compl[compl[0]+1]>MAXSIZE_traceRouteCtlTestName||compc>traceRouteProbeHistoryTable_INSTANCE_LEN)
        return FALSE;
    memset(data, 0, sizeof(TRACEROUTE_TYPE_TraceRouteProbeHistoryEntry_T));
    trace_route_ctl_owner_index_len=compl[0];
    SNMP_MGR_ReadOctetFromCompl(compl ,1,compl[0],trace_route_ctl_owner_index);
    trace_route_ctl_test_name_len=compl[compl[0]+1];
    SNMP_MGR_ReadOctetFromCompl(compl,compl[0]+2,compl[0]+compl[compl[0]+1]+1,trace_route_ctl_test_name);
    trace_route_probe_history_index=compl[compl[0]+compl[compl[0]+1]+2] ;
    trace_route_probe_history_hop_index= compl[compl[0]+compl[compl[0]+1]+3];
    trace_route_probe_history_probe_index=compl[compl[0]+compl[compl[0]+1]+4];
    /*get data*/
    if (TRACEROUTE_POM_GetTraceRouteProbeHistoryEntry((char*)trace_route_ctl_owner_index,trace_route_ctl_owner_index_len,(char*)trace_route_ctl_test_name,trace_route_ctl_test_name_len,trace_route_probe_history_index,trace_route_probe_history_hop_index,trace_route_probe_history_probe_index,data)!=TRACEROUTE_TYPE_OK)
    {
        return FALSE;
    }
    else
    {
        return TRUE;
    } /*End of if */
}
static BOOL_T traceRouteProbeHistoryTable_next(int      compc,
                                 oid     *compl,
                                 TRACEROUTE_TYPE_TraceRouteProbeHistoryEntry_T    *data)
{
    UI8_T   trace_route_ctl_owner_index[MAXSIZE_traceRouteCtlOwnerIndex];    /* KEY 1 */
    UI32_T  trace_route_ctl_owner_index_len;
    UI8_T   trace_route_ctl_test_name[MAXSIZE_traceRouteCtlTestName];        /* KEY 2 */
    UI32_T  trace_route_ctl_test_name_len;
    UI32_T  trace_route_probe_history_index;        /* KEY 3 */
    UI32_T  trace_route_probe_history_hop_index;    /* KEY 4 */
    UI32_T  trace_route_probe_history_probe_index;  /* KEY 5 */
    memset(data, 0, sizeof(TRACEROUTE_TYPE_TraceRouteProbeHistoryEntry_T));
    trace_route_ctl_owner_index_len=compl[0];
    SNMP_MGR_ReadOctetFromCompl(compl ,1,compl[0],trace_route_ctl_owner_index);
    trace_route_ctl_test_name_len=compl[compl[0]+1];
    SNMP_MGR_ReadOctetFromCompl(compl,compl[0]+2,compl[0]+compl[compl[0]+1]+1,trace_route_ctl_test_name);
    trace_route_probe_history_index=compl[compl[0]+compl[compl[0]+1]+2] ;
    trace_route_probe_history_hop_index= compl[compl[0]+compl[compl[0]+1]+3];
    trace_route_probe_history_probe_index=compl[compl[0]+compl[compl[0]+1]+4];
    if (compc<5)
    {
        if (TRACEROUTE_POM_GetTraceRouteProbeHistoryEntry((char*)trace_route_ctl_owner_index,trace_route_ctl_owner_index_len,(char*)trace_route_ctl_test_name,trace_route_ctl_test_name_len,trace_route_probe_history_index,trace_route_probe_history_hop_index,trace_route_probe_history_probe_index,data)!=TRACEROUTE_TYPE_OK)
        {
            if (TRACEROUTE_POM_GetNextTraceRouteProbeHistoryEntry((char*)trace_route_ctl_owner_index,trace_route_ctl_owner_index_len,(char*)trace_route_ctl_test_name,trace_route_ctl_test_name_len,trace_route_probe_history_index,trace_route_probe_history_hop_index,trace_route_probe_history_probe_index,data)!=TRACEROUTE_TYPE_OK)
            {
                return FALSE;
            }
        }
    }
    else
    {
        if (TRACEROUTE_POM_GetNextTraceRouteProbeHistoryEntry((char*)trace_route_ctl_owner_index,trace_route_ctl_owner_index_len,(char*)trace_route_ctl_test_name,trace_route_ctl_test_name_len,trace_route_probe_history_index,trace_route_probe_history_hop_index,trace_route_probe_history_probe_index,data)!=TRACEROUTE_TYPE_OK)
        {
            return FALSE;
        }
    }
    return TRUE;
}
unsigned char * var_traceRouteProbeHistoryTable(struct variable *vp,
                                                oid             *name,
                                                size_t          *length,
                                                int             exact,
                                                size_t          *var_len,
                                                WriteMethod     **write_method)
{
    UI32_T compc=0;
    oid compl[traceRouteProbeHistoryTable_INSTANCE_LEN];
    oid best_inst[traceRouteProbeHistoryTable_INSTANCE_LEN];
    TRACEROUTE_TYPE_TraceRouteProbeHistoryEntry_T  entry;

    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,compl, traceRouteProbeHistoryTable_INSTANCE_LEN);
     /*check compc, retrive compl*/
    if (exact)/*get,set*/
    {
        if (!traceRouteProbeHistoryTable_get(compc, compl, &entry))
            return NULL;
    }
    else/*getnext*/
    {
        if (!traceRouteProbeHistoryTable_next(compc, compl, &entry))
        {
            return NULL;
        }
    }
    memcpy(name, vp->name, vp->namelen*sizeof(oid));
    memset(best_inst, 0,  traceRouteProbeHistoryTable_INSTANCE_LEN*sizeof(oid));
    best_inst[0] = entry.trace_route_ctl_owner_index_len;
    SNMP_MGR_BindOctetInstance((UI8_T*)entry.trace_route_ctl_owner_index,1,best_inst[0],best_inst);
    best_inst[best_inst[0]+1]=entry.trace_route_ctl_test_name_len;
    SNMP_MGR_BindOctetInstance((UI8_T*)entry.trace_route_ctl_test_name,best_inst[0]+2,best_inst[0]+best_inst[best_inst[0]+1]+1,best_inst);
    best_inst[best_inst[0]+best_inst[best_inst[0]+1]+2]=entry.trace_route_probe_history_index ;
    best_inst[best_inst[0]+best_inst[best_inst[0]+1]+3]=entry.trace_route_probe_history_hop_index ;
    best_inst[best_inst[0]+best_inst[best_inst[0]+1]+4]=entry.trace_route_probe_history_probe_index ;
    memcpy(name + vp->namelen, best_inst, traceRouteProbeHistoryTable_INSTANCE_LEN*sizeof(oid));
    *length = vp->namelen + best_inst[0] + best_inst[best_inst[0]+1]+5;

    *var_len = sizeof(long_return);

    switch (vp->magic)
    {
        case TRACEROUTEPROBEHISTORYHADDRTYPE:
            long_return = entry.trace_route_probe_history_haddr_type;
            return (u_char *) &long_return;
        case TRACEROUTEPROBEHISTORYHADDR:
            {
                UI32_T out_inet_type, out_inet_addr_len, out_preflen;

                if (!SNMP_MGR_ConvertLInetAddrToInetAddrAndType(
                        (L_INET_Addr_T *)&entry.trace_route_probe_history_haddr,
                        &out_inet_type,
                        &out_inet_addr_len,
                        (UI8_T *)return_buf,
                        &out_preflen))
                {
                    return NULL;
                }

                *var_len = out_inet_addr_len;
            }
            return (u_char *) return_buf;
        case TRACEROUTEPROBEHISTORYRESPONSE:
            long_return = entry.trace_route_probe_history_response;
            return (u_char *) &long_return;
        case TRACEROUTEPROBEHISTORYSTATUS:
            long_return = entry.trace_route_probe_history_status;
            return (u_char *) &long_return;
        case TRACEROUTEPROBEHISTORYLASTRC:
            long_return = entry.trace_route_probe_history_last_rc;
            return (u_char *) &long_return;
        case TRACEROUTEPROBEHISTORYTIME:
            memcpy (return_buf, entry.trace_route_probe_history_time, entry.trace_route_probe_history_time_len);
            *var_len = entry.trace_route_probe_history_time_len;
            return (u_char *) return_buf;
        default:
            ERROR_MSG("");
    }

    return NULL;
}


oid traceRouteHopsTable_variables_oid[] = { 1, 3, 6, 1, 2, 1, 81, 1 };

struct variable3 traceRouteHopsTable_variables[] =
{
    {TRACEROUTEHOPSHOPINDEX,            ASN_UNSIGNED,     RONLY, var_traceRouteHopsTable, 3, {5, 1, 1}},
    {TRACEROUTEHOPSIPTGTADDRESSTYPE,    ASN_INTEGER,      RONLY, var_traceRouteHopsTable, 3, {5, 1, 2}},
    {TRACEROUTEHOPSIPTGTADDRESS,        ASN_OCTET_STR,    RONLY, var_traceRouteHopsTable, 3, {5, 1, 3}},
    {TRACEROUTEHOPSMINRTT,              ASN_UNSIGNED,     RONLY, var_traceRouteHopsTable, 3, {5, 1, 4}},
    {TRACEROUTEHOPSMAXRTT,              ASN_UNSIGNED,     RONLY, var_traceRouteHopsTable, 3, {5, 1, 5}},
    {TRACEROUTEHOPSAVERAGERTT,          ASN_UNSIGNED,     RONLY, var_traceRouteHopsTable, 3, {5, 1, 6}},
    {TRACEROUTEHOPSRTTSUMOFSQUARES,     ASN_UNSIGNED,     RONLY, var_traceRouteHopsTable, 3, {5, 1, 7}},
    {TRACEROUTEHOPSSENTPROBES,          ASN_UNSIGNED,     RONLY, var_traceRouteHopsTable, 3, {5, 1, 8}},
    {TRACEROUTEHOPSPROBERESPONSES,      ASN_UNSIGNED,     RONLY, var_traceRouteHopsTable, 3, {5, 1, 9}},
    {TRACEROUTEHOPSLASTGOODPROBE,       ASN_OCTET_STR,    RONLY, var_traceRouteHopsTable, 3, {5, 1, 10}},
};


void init_traceRouteHopsTable(void)
{
    REGISTER_MIB("traceRouteHopsTable", traceRouteHopsTable_variables,
                 variable3, traceRouteHopsTable_variables_oid);
}

#define traceRouteHopsTable_INSTANCE_LEN (3+MAXSIZE_traceRouteCtlOwnerIndex + MAXSIZE_traceRouteCtlTestName)

static BOOL_T traceRouteHopsTable_get(int      compc,
                                oid     *compl,
                                TRACEROUTE_TYPE_TraceRouteHopsEntry_T   *data)
{
    UI8_T   trace_route_ctl_owner_index[MAXSIZE_traceRouteCtlOwnerIndex];    /* KEY 1 */
    UI32_T  trace_route_ctl_owner_index_len;
    UI8_T   trace_route_ctl_test_name[MAXSIZE_traceRouteCtlTestName];        /* KEY 2 */
    UI32_T  trace_route_ctl_test_name_len;
    UI32_T  trace_route_hops_hop_index;
    /*check input length */
    if(compl[0]>MAXSIZE_traceRouteCtlOwnerIndex || compl[compl[0]+1]>MAXSIZE_traceRouteCtlTestName||compc>traceRouteHopsTable_INSTANCE_LEN)
        return FALSE;
    memset(data, 0, sizeof(TRACEROUTE_TYPE_TraceRouteHopsEntry_T));
    trace_route_ctl_owner_index_len=compl[0];
    SNMP_MGR_ReadOctetFromCompl(compl ,1,compl[0],trace_route_ctl_owner_index);
    trace_route_ctl_test_name_len=compl[compl[0]+1];
    SNMP_MGR_ReadOctetFromCompl(compl,compl[0]+2,compl[0]+compl[compl[0]+1]+1,trace_route_ctl_test_name);
    trace_route_hops_hop_index=compl[compl[0]+compl[compl[0]+1]+2] ;
    /*
    if (TRACEROUTE_MGR_GetTraceRouteHopsEntry(trace_route_ctl_owner_index,trace_route_ctl_owner_index_len,trace_route_ctl_test_name,trace_route_ctl_test_name_len,trace_route_hops_hop_index,data)!=TRACEROUTE_TYPE_OK)
    {
        return FALSE;
    }
    else
    {
        return TRUE;
    }

    */
    return FALSE;
}
static BOOL_T traceRouteHopsTable_next(int      compc,
                                 oid     *compl,
                                 TRACEROUTE_TYPE_TraceRouteHopsEntry_T    *data)
{
    UI8_T   trace_route_ctl_owner_index[MAXSIZE_traceRouteCtlOwnerIndex];    /* KEY 1 */
    UI32_T  trace_route_ctl_owner_index_len;
    UI8_T   trace_route_ctl_test_name[MAXSIZE_traceRouteCtlTestName];        /* KEY 2 */
    UI32_T  trace_route_ctl_test_name_len;
    UI32_T  trace_route_hops_hop_index;
    memset(data, 0, sizeof(TRACEROUTE_TYPE_TraceRouteHopsEntry_T));
    trace_route_ctl_owner_index_len=compl[0];
    SNMP_MGR_ReadOctetFromCompl(compl ,1,compl[0],trace_route_ctl_owner_index);
    trace_route_ctl_test_name_len=compl[compl[0]+1];
    SNMP_MGR_ReadOctetFromCompl(compl,compl[0]+2,compl[0]+compl[compl[0]+1]+1,trace_route_ctl_test_name);
    trace_route_hops_hop_index=compl[compl[0]+compl[compl[0]+1]+2] ;
    /*
    if (compc<1)
    {
        if (TRACEROUTE_MGR_GetTraceRouteHopsEntry(trace_route_ctl_owner_index,trace_route_ctl_owner_index_len,trace_route_ctl_test_name,trace_route_ctl_test_name_len,trace_route_hops_hop_index,data)!=TRACEROUTE_TYPE_OK)
        {
            if (TRACEROUTE_MGR_GetNextTraceRouteHopsEntry(trace_route_ctl_owner_index,trace_route_ctl_owner_index_len,trace_route_ctl_test_name,trace_route_ctl_test_name_len,trace_route_hops_hop_index,data)!=TRACEROUTE_TYPE_OK)
            {
                return FALSE;
            }
        }
    }
    else
    {
        if (TRACEROUTE_MGR_GetNextTraceRouteHopsEntry(trace_route_ctl_owner_index,trace_route_ctl_owner_index_len,trace_route_ctl_test_name,trace_route_ctl_test_name_len,trace_route_hops_hop_index, data)!=TRACEROUTE_TYPE_OK)
        {
            return FALSE;
        }
    }
    return TRUE;
    */
    return FALSE;
}
unsigned char * var_traceRouteHopsTable(struct variable *vp,
                                        oid             *name,
                                        size_t          *length,
                                        int             exact,
                                        size_t          *var_len,
                                        WriteMethod     **write_method)
{

    UI32_T compc=0;
    oid compl[traceRouteHopsTable_INSTANCE_LEN];
    oid best_inst[traceRouteHopsTable_INSTANCE_LEN];
    TRACEROUTE_TYPE_TraceRouteHopsEntry_T  entry;

    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,compl, traceRouteHopsTable_INSTANCE_LEN);
     /*check compc, retrive compl*/
    if (exact)/*get,set*/
    {
        if (!traceRouteHopsTable_get(compc, compl, &entry))
            return NULL;
    }
    else/*getnext*/
    {
        if (!traceRouteHopsTable_next(compc, compl, &entry))
        {
            return NULL;
        }
    }
    memcpy(name, vp->name, vp->namelen*sizeof(oid));
    memset(best_inst, 0,  traceRouteHopsTable_INSTANCE_LEN*sizeof(oid));
    best_inst[0] = entry.trace_route_ctl_owner_index_len;
    SNMP_MGR_BindOctetInstance((UI8_T*)entry.trace_route_ctl_owner_index,1,best_inst[0],best_inst);
    best_inst[best_inst[0]+1]=entry.trace_route_ctl_test_name_len;
    SNMP_MGR_BindOctetInstance((UI8_T*)entry.trace_route_ctl_test_name,best_inst[0]+2,best_inst[0]+best_inst[best_inst[0]+1]+1,best_inst);
    best_inst[best_inst[0]+best_inst[best_inst[0]+1]+2]=entry.trace_route_hops_hop_index ;
    memcpy(name + vp->namelen, best_inst, traceRouteHopsTable_INSTANCE_LEN*sizeof(oid));
    *length = vp->namelen + best_inst[0] + best_inst[best_inst[0]+1];;

    *var_len = sizeof(long_return);

    switch (vp->magic)
    {
        case TRACEROUTEHOPSIPTGTADDRESSTYPE:
            long_return = entry.trace_route_hops_ip_tgt_address_type;
            return (u_char *) &long_return;
        case TRACEROUTEHOPSIPTGTADDRESS:
            {
                UI32_T out_inet_type, out_inet_addr_len, out_preflen;

                if (!SNMP_MGR_ConvertLInetAddrToInetAddrAndType(
                        (L_INET_Addr_T *)&entry.trace_route_hops_ip_tgt_address,
                        &out_inet_type,
                        &out_inet_addr_len,
                        (UI8_T *)return_buf,
                        &out_preflen))
                {
                    return NULL;
                }

                *var_len = out_inet_addr_len;
            }
            return (u_char *) return_buf;
        case TRACEROUTEHOPSMINRTT:
            long_return = entry.trace_route_hops_min_rtt;
            return (u_char *) &long_return;
        case TRACEROUTEHOPSMAXRTT:
            long_return = entry.trace_route_hops_max_rtt;
            return (u_char *) &long_return;
        case TRACEROUTEHOPSAVERAGERTT:
            long_return = entry.trace_route_hops_average_rtt;
            return (u_char *) &long_return;
        case TRACEROUTEHOPSRTTSUMOFSQUARES:
            long_return = entry.trace_route_hops_rtt_sum_of_squares;
            return (u_char *) &long_return;
        case TRACEROUTEHOPSSENTPROBES:
            long_return = entry.trace_route_hops_sent_probes;
            return (u_char *) &long_return;
        case TRACEROUTEHOPSPROBERESPONSES:
            long_return = entry.trace_route_hops_probe_responses;
            return (u_char *) &long_return;
        case TRACEROUTEHOPSLASTGOODPROBE:
            /*
            memcpy (return_buf, entry.trace_route_hops_last_good_probe, entry.trace_route_hops_last_good_probe_len);
            *var_len = entry.trace_route_hops_last_good_probe_len;
            */
            long_return = entry.trace_route_hops_probe_history_time;
            return (u_char *) return_buf;
        default:
            ERROR_MSG("");
    }

    return NULL;
}
#endif  /* end of  #if (SYS_CPNT_TRACEROUTE == TRUE)*/

/* River@May 7, 2008, add nslookup mib */
#if(SYS_CPNT_NSLOOKUP == TRUE)

#include "dns_pmgr.h"


/** Initializes the lookupObjects module */
void
init_lookupObjects(void)
{
    static oid      lookupMaxConcurrentRequests_oid[] = { 1, 3, 6, 1, 2, 1, 82, 1, 1, 0 };
    static oid      lookupPurgeTime_oid[]             = { 1, 3, 6, 1, 2, 1, 82, 1, 2, 0 };

    netsnmp_register_instance(netsnmp_create_handler_registration
                            ("lookupMaxConcurrentRequests",
                             do_lookupMaxConcurrentRequests,
                             lookupMaxConcurrentRequests_oid,
                             OID_LENGTH(lookupMaxConcurrentRequests_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                            ("lookupPurgeTime",
                             do_lookupPurgeTime,
                             lookupPurgeTime_oid,
                             OID_LENGTH(lookupPurgeTime_oid),
                             HANDLER_CAN_RWRITE));
}

int
do_lookupMaxConcurrentRequests(netsnmp_mib_handler *handler,
                                   netsnmp_handler_registration *reginfo,
                                   netsnmp_agent_request_info *reqinfo,
                                   netsnmp_request_info *requests)
{
    UI32_T value;

    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one.
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        long_return = DNS_DEF_NSLOOKUP_REQUEST;
        snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED,
                                 (u_char *)&long_return, sizeof(long_return));
        break;

    case MODE_SET_RESERVE1:

        /* River@Sep 20, for simple test */
        if (requests->requestvb->type != ASN_GAUGE)
        {
            return SNMP_ERR_WRONGTYPE;
        }


        break;

    case MODE_SET_RESERVE2:

        break;

    case MODE_SET_FREE:

        break;

    case MODE_SET_ACTION:

        value = (*requests->requestvb->val.integer);
        if(value != DNS_DEF_NSLOOKUP_REQUEST)
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);

        break;

    case MODE_SET_COMMIT:

        break;

    case MODE_SET_UNDO:

        break;

    default:

        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_lookupPurgeTime(netsnmp_mib_handler *handler,
                       netsnmp_handler_registration *reginfo,
                       netsnmp_agent_request_info *reqinfo,
                       netsnmp_request_info *requests)
{
    UI32_T value;

    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one.
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        NS_PMGR_GetNslookupPurgeTime(&value);
        long_return = value;
        snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED,
                                 (u_char *)&long_return, sizeof(long_return));

        break;


    case MODE_SET_RESERVE1:

        if (requests->requestvb->type != ASN_GAUGE)
        {
            return SNMP_ERR_WRONGTYPE;
        }

          value = (*requests->requestvb->val.integer);
          if ((value < DNS_MIN_NSLOOKUP_PTIME)  ||    (value > DNS_MAX_NSLOOKUP_PTIME))
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_WRONGVALUE);


        break;

    case MODE_SET_RESERVE2:

        break;

    case MODE_SET_FREE:

        break;

    case MODE_SET_ACTION:

        value = (*requests->requestvb->val.integer);
        if(DNS_PMGR_SetNslookupPurgeTime(value) != TRUE)
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
        break;

    case MODE_SET_COMMIT:

        break;

    case MODE_SET_UNDO:

        break;

    default:

        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}



/*
 * lookupCtlTable_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid             lookupCtlTable_variables_oid[] =
    { 1, 3, 6, 1, 2, 1, 82, 1 };

/*
 * variable4 lookupCtlTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */

struct variable3 lookupCtlTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */

    {LOOKUPCTLOWNERINDEX, ASN_OCTET_STR, RONLY,
        var_lookupCtlTable, 3, {3, 1, 1}},
    {LOOKUPCTLOPERATIONNAME, ASN_OCTET_STR, RONLY,
        var_lookupCtlTable, 3, {3, 1, 2}},
    {LOOKUPCTLTARGETADDRESSTYPE, ASN_INTEGER, RWRITE,
        var_lookupCtlTable, 3, {3, 1, 3}},
    {LOOKUPCTLTARGETADDRESS, ASN_OCTET_STR, RWRITE,
        var_lookupCtlTable, 3, {3, 1, 4}},
    {LOOKUPCTLOPERSTATUS, ASN_INTEGER, RONLY,
        var_lookupCtlTable, 3, {3, 1, 5}},
    {LOOKUPCTLTIME, ASN_UNSIGNED, RONLY,
        var_lookupCtlTable, 3, {3, 1, 6}},
    {LOOKUPCTLRC, ASN_INTEGER, RONLY,
        var_lookupCtlTable, 3, {3, 1, 7}},
    {LOOKUPCTLROWSTATUS, ASN_INTEGER, RWRITE,
        var_lookupCtlTable, 3, {3, 1, 8}},
};

/*
 * (L = length of the oidsuffix)
 */


/** Initializes the lookupCtlTable module */
void
init_lookupCtlTable(void)
{

    /*
     * register ourselves with the agent to handle our mib tree
     */
    REGISTER_MIB("lookupCtlTable", lookupCtlTable_variables, variable3,
                 lookupCtlTable_variables_oid);
}



/********************************************
 *****************lookupCtlTable**************
 ********************************************
 */

#define NSLOOKUP_CTL_TABLE_OID_LEN 11
static int
header_lookupCtlTable(struct variable *vp,
               oid * name,
               size_t * length,
               int exact, size_t * var_len, WriteMethod ** write_method,
               DNS_Nslookup_CTRL_T *CTRL_table)
{

    oid     newname[MAX_OID_LEN];
    int     result;
    int     return_val;
    oid     next_inst[2+MAXSIZE_dnsCtlOwnerIndex+MAXSIZE_dnsCtlOperationName];
    int     i;
    UI32_T  oid_name_length = NSLOOKUP_CTL_TABLE_OID_LEN;

    memcpy((char *) newname, (char *) vp->name,
           (int) vp->namelen * sizeof(oid));
    /*
     * find "next" interface
     */

    memset(CTRL_table, 0, sizeof(DNS_Nslookup_CTRL_T));

    /*
     * find "next" interface
     */

 while (  (return_val= DNS_PMGR_GetNextLookupCtlTable(CTRL_table)) == DNS_OK)
     {

       next_inst[0] =strlen((char *)CTRL_table->CtlOwnerIndex);

       for ( i = 0; i< strlen((char *)CTRL_table->CtlOwnerIndex); i++)
       {
           next_inst[i+1] = CTRL_table->CtlOwnerIndex[i];
       }

       next_inst[next_inst[0]+1] = strlen((char *)CTRL_table->OperationName);

       for (i = 0; i < strlen((char *)CTRL_table->OperationName); i++)
       {
           next_inst[next_inst[0]+2+i] = CTRL_table->OperationName[i];
        }

       memcpy( (char*)&newname[oid_name_length], (char*) next_inst,  (2+strlen((char *)CTRL_table->CtlOwnerIndex)+strlen((char *)CTRL_table->OperationName))*sizeof(oid));
       result =
            snmp_oid_compare(name, *length, newname,
                             (int) vp->namelen + 2+strlen((char *)CTRL_table->CtlOwnerIndex)+strlen((char *)CTRL_table->OperationName));
        if ((exact && (result == 0)) || (!exact && (result < 0)))
            break;
    }
    if (return_val!= DNS_OK ) {
        DEBUGMSGTL(("mibII/interfaces", "... index out of range\n"));
        return MATCH_FAILED;
    }
    memcpy((char *) name, (char *) newname,
           ((int) vp->namelen + 2+strlen((char *)CTRL_table->CtlOwnerIndex)+strlen((char *)CTRL_table->OperationName)) * sizeof(oid));
    *length = vp->namelen + 2+strlen((char *)CTRL_table->CtlOwnerIndex)+strlen((char *)CTRL_table->OperationName);
    *var_len = sizeof(long);    /* default to 'long' results */

    return TRUE;

}

/*
 * var_lookupCtlTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_lookupCtlTable(struct variable *vp,
                   oid * name,
                   size_t *length,
                   int exact, size_t *var_len, WriteMethod ** write_method)
{

    DNS_Nslookup_CTRL_T CTRL_table;

    switch (vp->magic)
    {
        case LOOKUPCTLTARGETADDRESSTYPE:
            *write_method = write_lookupCtlTargetAddressType;
            break;
        case LOOKUPCTLTARGETADDRESS:
            *write_method = write_lookupCtlTargetAddress;
            break;
        case LOOKUPCTLROWSTATUS:
            *write_method = write_lookupCtlRowStatus;
            break;

        default:
            *write_method = 0;
            break;
    }



    /*
     * This assumes that the table is a 'simple' table.
     *  See the implementation documentation for the meaning of this.
     *  You will need to provide the correct value for the TABLE_SIZE parameter
     *
     * If this table does not meet the requirements for a simple table,
     *  you will need to provide the replacement code yourself.
     *  Mib2c is not smart enough to write this for you.
     *    Again, see the implementation documentation for what is required.
     */
    if (header_lookupCtlTable
        (vp, name, length, exact, var_len, write_method, &CTRL_table)
        == MATCH_FAILED)
        return NULL;

    if(DNS_PMGR_GetLookupCtlTable(&CTRL_table) != DNS_OK)
        return NULL;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {

    case LOOKUPCTLTARGETADDRESSTYPE:
        long_return = CTRL_table.TargetAddressType;            /* TargetAddressType */
        return (u_char *) & long_return;
    case LOOKUPCTLTARGETADDRESS:
        *var_len = CTRL_table.TargetAddressLen;
        memcpy(return_buf, CTRL_table.TargetAddress, *var_len);      /* TargetAddress */
        return (u_char *) return_buf;
    case LOOKUPCTLOPERSTATUS:
        long_return = CTRL_table.OperStatus;                        /* OperStatus */
        return (u_char *) & long_return;
    case LOOKUPCTLTIME:
        long_return = CTRL_table.Time;                              /* Time */
        return (u_char *) & long_return;
    case LOOKUPCTLRC:
        long_return = CTRL_table.Rc;                                /* Rc */
        return (u_char *) & long_return;
    case LOOKUPCTLROWSTATUS:
        long_return = CTRL_table.RowStatus;                         /* RowStatus */
        return (u_char *) & long_return;
    default:
        ERROR_MSG("");
    }
    return NULL;
}


int
write_lookupCtlTargetAddressType(int action,
                                 u_char * var_val,
                                 u_char var_val_type,
                                 size_t var_val_len,
                                 u_char * statP,
                                 oid * name, size_t name_len)
{
    long            value;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        value = *(long *)var_val;

        if(value != VAL_dnsCtlTargetAddressType_dns)
        {
            return SNMP_ERR_WRONGVALUE;
        }

        break;

    case FREE:
        /*
         * Release any resources that have been allocated
         */
        break;

    case ACTION:
         {

            UI32_T i, index1_len, index2_len;
            UI8_T index1[MAXSIZE_dnsCtlOwnerIndex], index2[MAXSIZE_dnsCtlOperationName];
	        DNS_Nslookup_CTRL_T CTRL_table;

            memset(index1, 0, MAXSIZE_dnsCtlOwnerIndex);
            memset(index2, 0, MAXSIZE_dnsCtlOperationName);
            memset(&CTRL_table, 0, sizeof(DNS_Nslookup_CTRL_T));

            index1_len = name[NSLOOKUP_CTL_TABLE_OID_LEN];
            for(i = 0; i < index1_len ; i++)
            {
                index1[i] = name[NSLOOKUP_CTL_TABLE_OID_LEN + 1 + i];
            }

            index2_len = name[NSLOOKUP_CTL_TABLE_OID_LEN + 1 + index1_len];
            for(i = 0; i <index2_len; i++)
            {
                index2[i] = name[NSLOOKUP_CTL_TABLE_OID_LEN + 1 + index1_len + 1 + i];
            }

            CTRL_table.CtlOwnerIndexLen = index1_len;
            CTRL_table.OperationNameLen = index2_len;
            memcpy(CTRL_table.CtlOwnerIndex, index1, index1_len);
			memcpy(CTRL_table.OperationName, index2, index2_len);
            value = *(long *)var_val;
            CTRL_table.TargetAddressType = value;


            if (DNS_PMGR_SetDNSCtlTable_TargetAddressType(&CTRL_table) != DNS_OK)
                return SNMP_ERR_COMMITFAILED;

            break;
        }
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_lookupCtlTargetAddress(int action,
                             u_char * var_val,
                             u_char var_val_type,
                             size_t var_val_len,
                             u_char * statP, oid * name, size_t name_len)
{
    int             size;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_OCTET_STR) {
            return SNMP_ERR_WRONGTYPE;
        }

        break;

    case RESERVE2:
        size = var_val_len;
        if(size > MAXSIZE_dnsCtlTargetAddress)
        {
            return SNMP_ERR_WRONGLENGTH;
        }


        break;

    case FREE:
        /*
         * Release any resources that have been allocated
         */
        break;

    case ACTION:
        {

            UI32_T i, index1_len, index2_len;
            UI8_T index1[MAXSIZE_dnsCtlOwnerIndex], index2[MAXSIZE_dnsCtlOperationName];
            DNS_Nslookup_CTRL_T CTRL_table;


            memset(index1, 0, MAXSIZE_dnsCtlOwnerIndex);
            memset(index2, 0, MAXSIZE_dnsCtlOperationName);
            memset(&CTRL_table, 0, sizeof(DNS_Nslookup_CTRL_T)); /*2006-09-07,Grace.zheng, add for bug fix*/

            index1_len = name[NSLOOKUP_CTL_TABLE_OID_LEN];
            for(i = 0; i < index1_len ; i++)
            {
                index1[i] = name[NSLOOKUP_CTL_TABLE_OID_LEN + 1 + i];
            }

            index2_len = name[NSLOOKUP_CTL_TABLE_OID_LEN + 1 + index1_len];
            for(i = 0; i <index2_len; i++)
            {
                index2[i] = name[NSLOOKUP_CTL_TABLE_OID_LEN + 1 + index1_len + 1 + i];
            }

            CTRL_table.CtlOwnerIndexLen = index1_len;
            CTRL_table.OperationNameLen = index2_len;
            memcpy(CTRL_table.CtlOwnerIndex, index1, index1_len);
			memcpy(CTRL_table.OperationName, index2, index2_len);
            CTRL_table.TargetAddressLen = var_val_len;
            memcpy(CTRL_table.TargetAddress, var_val, var_val_len);



            if (DNS_PMGR_SetDNSCtlTable_TargetAddress(&CTRL_table) != DNS_OK)
                return SNMP_ERR_COMMITFAILED;

            break;
        }
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_lookupCtlRowStatus(int action,
                         u_char * var_val,
                         u_char var_val_type,
                         size_t var_val_len,
                         u_char * statP, oid * name, size_t name_len)
{
    long            value;

    if(name[NSLOOKUP_CTL_TABLE_OID_LEN] == 0)
        return SNMP_ERR_NOTWRITABLE;
    else if(name[NSLOOKUP_CTL_TABLE_OID_LEN +name[NSLOOKUP_CTL_TABLE_OID_LEN]+1] == 0)/*Grace.zheng,add +1,2007-02-07*/
        return SNMP_ERR_NOTWRITABLE;


    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        value = *(long *)var_val;

        if((value < VAL_dnsCtlRowStatus_active) || (value > VAL_dnsCtlRowStatus_destroy))
                return SNMP_ERR_WRONGVALUE;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated
         */
        break;

    case ACTION:
        {
            UI32_T i, index1_len, index2_len;
            UI8_T index1[MAXSIZE_dnsCtlOwnerIndex], index2[MAXSIZE_dnsCtlOperationName];
            DNS_Nslookup_CTRL_T CTRL_table;

            memset(index1, 0, MAXSIZE_dnsCtlOwnerIndex);
            memset(index2, 0, MAXSIZE_dnsCtlOperationName);
            memset(&CTRL_table, 0, sizeof(DNS_Nslookup_CTRL_T));

            index1_len = name[NSLOOKUP_CTL_TABLE_OID_LEN];

            /*Grace.zheng,2007-02-07*/
            if(index1_len >= (name_len - NSLOOKUP_CTL_TABLE_OID_LEN - 1))
                return SNMP_ERR_COMMITFAILED;

            index2_len = name[NSLOOKUP_CTL_TABLE_OID_LEN + 1 + index1_len];
            if(index2_len != (name_len - NSLOOKUP_CTL_TABLE_OID_LEN - 1 - index1_len - 1))
                return SNMP_ERR_COMMITFAILED;

            for(i = 0; i < index1_len ; i++)
            {
                index1[i] = name[NSLOOKUP_CTL_TABLE_OID_LEN + 1 + i];
            }

            for(i = 0; i <index2_len; i++)
            {
                index2[i] = name[NSLOOKUP_CTL_TABLE_OID_LEN + 1 + index1_len + 1 + i];
            }

            CTRL_table.CtlOwnerIndexLen = index1_len;
            memcpy(CTRL_table.CtlOwnerIndex, index1, index1_len);
            CTRL_table.OperationNameLen = index2_len;
			memcpy(CTRL_table.OperationName, index2, index2_len);
            value = *(long *)var_val; /*maggie liu, NSLOOKUP*/
            CTRL_table.RowStatus = value;

            if (DNS_OK != DNS_PMGR_SetDNSCtlTable_RowStatus(&CTRL_table))
            {
                return SNMP_ERR_COMMITFAILED;
            }
        }
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}



/*
 * lookupResultsTable_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid             lookupResultsTable_variables_oid[] =
    { 1, 3, 6, 1, 2, 1, 82, 1};

/*
 * variable4 lookupResultsTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */

struct variable3 lookupResultsTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */

    {LOOKUPRESULTSINDEX, ASN_UNSIGNED, RONLY,
        var_lookupResultsTable, 3, {4, 1, 1}},
    {LOOKUPRESULTSADDRESSTYPE, ASN_INTEGER, RONLY,
        var_lookupResultsTable, 3, {4, 1, 2}},
    {LOOKUPRESULTSADDRESS, ASN_OCTET_STR, RONLY,
        var_lookupResultsTable, 3, {4, 1, 3}},
};

/*
 * (L = length of the oidsuffix)
 */


/** Initializes the lookupResultsTable module */
void
init_lookupResultsTable(void)
{


    /*
     * register ourselves with the agent to handle our mib tree
     */
    REGISTER_MIB("lookupResultsTable", lookupResultsTable_variables,
                 variable3, lookupResultsTable_variables_oid);

    /*
     * place any other initialization junk you need here
     */
}


/********************************************
 **************lookupResultsTable************
 ********************************************
 */
#define NSLOOKUP_RESULT_TABLE_OID_LEN   11
static int
header_lookupResultsTable(struct variable *vp,
               oid * name,
               size_t * length,
               int exact, size_t * var_len, WriteMethod ** write_method,
               DNS_Nslookup_Result_T *Result_table)
{

    oid     newname[MAX_OID_LEN];
    int     result;
    int     return_val;
    oid     next_inst[3+MAXSIZE_dnsCtlOwnerIndex+MAXSIZE_dnsCtlOperationName];
    int     i;
    UI32_T  oid_name_length = NSLOOKUP_RESULT_TABLE_OID_LEN;

     memcpy((char *) newname, (char *) vp->name,
           (int) vp->namelen * sizeof(oid));
    /*
     * find "next" interface
     */

    memset(Result_table, 0, sizeof(DNS_Nslookup_Result_T));
    /*
     * find "next" interface
     */

 while (  (return_val = DNS_PMGR_GetNextLookupResultTable(Result_table)) == DNS_OK)
     {

       next_inst[0] =strlen((char *)Result_table->CtlOwnerIndex);

       for ( i = 0; i< strlen((char *)Result_table->CtlOwnerIndex); i++)
       {
           next_inst[i+1] = Result_table->CtlOwnerIndex[i];
       }

       next_inst[next_inst[0]+1] = strlen((char *)Result_table->OperationName);

       for (i = 0; i < strlen((char *)Result_table->OperationName); i++)
       {
           next_inst[next_inst[0]+2+i] = Result_table->OperationName[i];
       }

       next_inst[next_inst[0]+next_inst[next_inst[0]+1]+2] = Result_table->ResultsIndex;
       memcpy( (char*)&newname[oid_name_length], (char*) next_inst,  (2+strlen((char *)Result_table->CtlOwnerIndex)+strlen((char *)Result_table->OperationName)+ 1)*sizeof(oid));
       result =
            snmp_oid_compare(name, *length, newname,
                             (int) vp->namelen + 2+strlen((char *)Result_table->CtlOwnerIndex)+strlen((char *)Result_table->OperationName)+1);
       if ((exact && (result == 0)) || (!exact && (result < 0)))
            break;
    }
    if (return_val!= DNS_OK ) {
        DEBUGMSGTL(("mibII/interfaces", "... index out of range\n"));
        return MATCH_FAILED;
    }
    memcpy((char *) name, (char *) newname,
           ((int) vp->namelen + 2+strlen((char *)Result_table->CtlOwnerIndex)+strlen((char *)Result_table->OperationName)+1) * sizeof(oid));
    *length = vp->namelen + 2+strlen((char *)Result_table->CtlOwnerIndex)+strlen((char *)Result_table->OperationName)+1;
    *var_len = sizeof(long);    /* default to 'long' results */

    return TRUE;

}

/*
 * var_lookupResultsTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_lookupResultsTable(struct variable *vp,
                       oid * name,
                       size_t *length,
                       int exact,
                       size_t *var_len, WriteMethod ** write_method)
{
    DNS_Nslookup_Result_T Result_table;

    /*
     * This assumes that the table is a 'simple' table.
     *  See the implementation documentation for the meaning of this.
     *  You will need to provide the correct value for the TABLE_SIZE parameter
     *
     * If this table does not meet the requirements for a simple table,
     *  you will need to provide the replacement code yourself.
     *  Mib2c is not smart enough to write this for you.
     *    Again, see the implementation documentation for what is required.
     */
    if (header_lookupResultsTable
        (vp, name, length, exact, var_len, write_method, &Result_table)
        == MATCH_FAILED)
        return NULL;
    if (DNS_PMGR_GetLookupResultTable(&Result_table) != DNS_OK)
        return NULL;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic)
    {
        /* lookupResultsAddressType
         */
        case LOOKUPRESULTSADDRESSTYPE:
            long_return = Result_table.ResultsAddress_str.type;
            return (u_char *) & long_return;

        /* lookupResultsAddress
         */
        case LOOKUPRESULTSADDRESS:
        {
            UI32_T type, addr_len, preflen;

            if (! SNMP_MGR_ConvertLInetAddrToInetAddrAndType(
                (L_INET_Addr_T *) & Result_table.ResultsAddress_str,
                &type, &addr_len, return_buf, &preflen))
            {
                /* conversion failed
                 */
                *var_len = 0;
            }
            else
            {
                *var_len = (size_t) addr_len;
            }

            return (u_char *) return_buf;
        }

        default:
            ERROR_MSG("");
    }

    return NULL;
}

#endif
/* River@May 21, 2008, added PING MIB support */
#if (SYS_CPNT_PING == TRUE)

#include "leaf_2925p.h"
#include "ping_type.h"
#include "ping_pom.h"
#include "ping_pmgr.h"

UI32_T PING_PMGR_SetCtlDataSize(PING_TYPE_PingCtlEntry_T *ctl_entry_p, UI32_T data_size);
UI32_T PING_PMGR_SetCtlProbeCount(PING_TYPE_PingCtlEntry_T *ctl_entry_p, UI32_T probe_count);

#define DISMAN_PING_MODULE_OID SNMP_OID_MIB2, 80


void init_pingObjects(void)
{
 /* Not support pingMaxConcurrentRequests,  David Dai , 2007/9/18 */
#if 0
 static oid dismanPing_module_oid[] = { DISMAN_PING_MODULE_OID };
    static oid pingMaxConcurrentRequests_oid[] = { DISMAN_PING_MODULE_OID, 1, 1, 0 };

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("pingMaxConcurrentRequests",
                               do_pingMaxConcurrentRequests,
                               pingMaxConcurrentRequests_oid,
                               OID_LENGTH(pingMaxConcurrentRequests_oid),
                               HANDLER_CAN_RWRITE));

    REGISTER_SYSOR_ENTRY(dismanPing_module_oid, "RFC-2925 DismanPing MIB");
#endif
}
#if 0

int do_pingMaxConcurrentRequests(netsnmp_mib_handler          *handler,
                                                   netsnmp_handler_registration *reginfo,
                                                   netsnmp_agent_request_info   *reqinfo,
                                                   netsnmp_request_info         *requests)
{
    switch (reqinfo->mode)
    {
        case MODE_GET:
        {
            UI32_T ping_max_concurrent_requests = AMS_PING_MGR_MAX_PING_NBR;

            long_return = ping_max_concurrent_requests;
            snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, (u_char *) &long_return, sizeof(long_return));

            break;
        }

        case MODE_SET_RESERVE1:
            break;

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            break;

        case MODE_SET_ACTION:
        {
            netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);

            break;
        }

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
#endif

#define    PINGCTLENTRY_OID_NAME_LEN    11

oid pingCtlTable_variables_oid[] = { DISMAN_PING_MODULE_OID, 1 };

struct variable3 pingCtlTable_variables[] =
{
    { PINGCTLOWNERINDEX, ASN_OCTET_STR, RONLY,
      var_pingCtlTable, 3, {2, 1, 1} },
    { PINGCTLTESTNAME, ASN_OCTET_STR, RONLY,
      var_pingCtlTable, 3, {2, 1, 2} },
    { PINGCTLTARGETADDRESSTYPE, ASN_INTEGER, RWRITE,
      var_pingCtlTable, 3, {2, 1, 3} },
    { PINGCTLTARGETADDRESS, ASN_OCTET_STR, RWRITE,
      var_pingCtlTable, 3, {2, 1, 4} },
    { PINGCTLDATASIZE, ASN_UNSIGNED, RWRITE,
      var_pingCtlTable, 3, {2, 1, 5} },
    { PINGCTLTIMEOUT, ASN_UNSIGNED, RWRITE,
      var_pingCtlTable, 3, {2, 1, 6} },
    { PINGCTLPROBECOUNT, ASN_UNSIGNED, RWRITE,
      var_pingCtlTable, 3, {2, 1, 7} },
    { PINGCTLADMINSTATUS, ASN_INTEGER, RWRITE,
      var_pingCtlTable, 3, {2, 1, 8} },
    { PINGCTLDATAFILL, ASN_OCTET_STR, RWRITE,
      var_pingCtlTable, 3, {2, 1, 9} },
    { PINGCTLFREQUENCY, ASN_UNSIGNED, RWRITE,
      var_pingCtlTable, 3, {2, 1, 10} },
    { PINGCTLMAXROWS, ASN_UNSIGNED, RWRITE,
      var_pingCtlTable, 3, {2, 1, 11} },
    { PINGCTLSTORAGETYPE, ASN_INTEGER, RWRITE,
      var_pingCtlTable, 3, {2, 1, 12} },
    { PINGCTLTRAPGENERATION, ASN_BIT_STR, RWRITE,
      var_pingCtlTable, 3, {2, 1, 13} },
    { PINGCTLTRAPPROBEFAILUREFILTER, ASN_UNSIGNED, RWRITE,
      var_pingCtlTable, 3, {2, 1, 14} },
    { PINGCTLTRAPTESTFAILUREFILTER, ASN_UNSIGNED, RWRITE,
      var_pingCtlTable, 3, {2, 1, 15} },
    { PINGCTLTYPE, ASN_OBJECT_ID, RWRITE,
      var_pingCtlTable, 3, {2, 1, 16} },
    { PINGCTLDESCR, ASN_OCTET_STR, RWRITE,
      var_pingCtlTable, 3, {2, 1, 17} },
    { PINGCTLSOURCEADDRESSTYPE, ASN_INTEGER, RWRITE,
      var_pingCtlTable, 3, {2, 1, 18} },
    { PINGCTLSOURCEADDRESS, ASN_OCTET_STR, RWRITE,
      var_pingCtlTable, 3, {2, 1, 19} },
    { PINGCTLIFINDEX, ASN_INTEGER, RWRITE,
      var_pingCtlTable, 3, {2, 1, 20} },
    { PINGCTLBYPASSROUTETABLE, ASN_INTEGER, RWRITE,
      var_pingCtlTable, 3, {2, 1, 21} },
    { PINGCTLDSFIELD, ASN_UNSIGNED, RWRITE,
      var_pingCtlTable, 3, {2, 1, 22} },
    { PINGCTLROWSTATUS, ASN_INTEGER, RWRITE,
      var_pingCtlTable, 3, {2, 1, 23} }
};


void init_pingCtlTable(void)
{
    REGISTER_MIB("pingCtlTable", pingCtlTable_variables,
                 variable3, pingCtlTable_variables_oid);
}

/* index is index1_length,index1_string,index2_length,inde2_string,so we should add 2.
 */
#define PINGCTLENTRY_INSTANCE_LEN (2 + MAXSIZE_pingCtlOwnerIndex + MAXSIZE_pingCtlTestName)

/* FUNCTION NAME : pingCtlTable_get
 * PURPOSE:
 *          It is called for get data.
 * INPUT:
 *          compc -- the counter of the index
 *		compl  -- the list of the index
 *		data	   -- the data storage
 *
 * OUTPUT:
 *          data
 * RETURN:
 *          TRUE:
 *		FALSE:
 * NOTES:
 *
 */
static BOOL_T pingCtlTable_get(int      compc,
                                oid     *compl,
                                PING_TYPE_PingCtlEntry_T   *data)
{
    UI8_T   ping_ctl_owner_index[MAXSIZE_pingCtlOwnerIndex];    /* KEY 1 */
    UI32_T  ping_ctl_owner_index_len;
    UI8_T   ping_ctl_test_name[MAXSIZE_pingCtlTestName];        /* KEY 2 */
    UI32_T  ping_ctl_test_name_len;

    /*check input length
     */
    if ( compl[0]                 > MAXSIZE_pingCtlOwnerIndex
     ||compl[compl[0] + 1] > MAXSIZE_pingCtlTestName
     ||compc                    > PINGCTLENTRY_INSTANCE_LEN)
        return FALSE;

    memset(data, 0, sizeof(*data));

    ping_ctl_owner_index_len = compl[0];
    SNMP_MGR_ReadOctetFromCompl(compl, 1, compl[0], ping_ctl_owner_index);
    ping_ctl_test_name_len = compl[compl[0] + 1];
    SNMP_MGR_ReadOctetFromCompl(compl, compl[0] + 2, compl[0] + compl[compl[0] + 1] + 1, ping_ctl_test_name);
    data->ping_ctl_owner_index_len = ping_ctl_owner_index_len;
    data->ping_ctl_test_name_len = ping_ctl_test_name_len;
    memcpy(data->ping_ctl_owner_index, ping_ctl_owner_index, ping_ctl_owner_index_len);
    memcpy(data->ping_ctl_test_name, ping_ctl_test_name, ping_ctl_test_name_len);

    /*get data
     */
    if (PING_POM_GetCtlEntry(data) != PING_TYPE_OK)
    {
        return FALSE;
    }

    return TRUE;
}

static BOOL_T pingCtlTable_next(int      compc,
                                 oid     *compl,
                                 PING_TYPE_PingCtlEntry_T    *data)
{
    UI8_T   ping_ctl_owner_index[MAXSIZE_pingCtlOwnerIndex];    /* KEY 1 */
    UI32_T  ping_ctl_owner_index_len;
    UI8_T   ping_ctl_test_name[MAXSIZE_pingCtlTestName];        /* KEY 2 */
    UI32_T  ping_ctl_test_name_len;

    /*check  the length of inputing index,if <1 we should try get {0.0.0.0.0...} */
    memset(data, 0, sizeof(*data));
    if (compc >= 4)
    {
        ping_ctl_owner_index_len = compl[0];
        SNMP_MGR_ReadOctetFromCompl(compl, 1, compl[0], ping_ctl_owner_index);
        ping_ctl_test_name_len = compl[compl[0] + 1];
        SNMP_MGR_ReadOctetFromCompl(compl, compl[0] + 2, compl[0] + compl[compl[0] + 1] + 1, ping_ctl_test_name);

        if ( (ping_ctl_owner_index_len <= MAXSIZE_pingCtlOwnerIndex) && (ping_ctl_test_name_len <= MAXSIZE_pingCtlTestName) )
        {
            data->ping_ctl_owner_index_len = ping_ctl_owner_index_len;
            data->ping_ctl_test_name_len = ping_ctl_test_name_len;
            memcpy(data->ping_ctl_owner_index, ping_ctl_owner_index, ping_ctl_owner_index_len);
            memcpy(data->ping_ctl_test_name, ping_ctl_test_name, ping_ctl_test_name_len);
        }
    }

    /*get next data*/
    if (PING_POM_GetNextCtlEntry(data) != PING_TYPE_OK)
    {
        return FALSE;
    }

    return TRUE;
}

unsigned char * var_pingCtlTable(struct variable *vp,
                                       oid             *name,
                                       size_t          *length,
                                       int             exact,
                                       size_t          *var_len,
                                       WriteMethod     **write_method)
{
    UI32_T                          compc=0;
    oid                                 compl[PINGCTLENTRY_INSTANCE_LEN];
    oid                                 best_inst[PINGCTLENTRY_INSTANCE_LEN];
    PING_TYPE_PingCtlEntry_T   entry;

    switch (vp->magic)
    {
        case PINGCTLTARGETADDRESSTYPE:
            *write_method = write_pingCtlTargetAddressType;
            break;
        case PINGCTLTARGETADDRESS:
            *write_method = write_pingCtlTargetAddress;
            break;
        case PINGCTLDATASIZE:
            *write_method = write_pingCtlDataSize;
            break;
        case PINGCTLTIMEOUT:
            *write_method = write_pingCtlTimeOut;
            break;
        case PINGCTLPROBECOUNT:
            *write_method = write_pingCtlProbeCount;
            break;
        case PINGCTLADMINSTATUS:
            *write_method = write_pingCtlAdminStatus;
            break;
        case PINGCTLDATAFILL:
            *write_method = write_pingCtlDataFill;
            break;
        case PINGCTLFREQUENCY:
            *write_method = write_pingCtlFrequency;
            break;
        case PINGCTLMAXROWS:
            *write_method = write_pingCtlMaxRows;
            break;
        case PINGCTLSTORAGETYPE:
            *write_method = write_pingCtlStorageType;
            break;
        case PINGCTLTRAPGENERATION:
            *write_method = write_pingCtlTrapGeneration;
            break;
        case PINGCTLTRAPPROBEFAILUREFILTER:
            *write_method = write_pingCtlTrapProbeFailureFilter;
            break;
        case PINGCTLTRAPTESTFAILUREFILTER:
            *write_method = write_pingCtlTrapTestFailureFilter;
            break;
        case PINGCTLTYPE:
            *write_method = write_pingCtlType;
            break;
        case PINGCTLDESCR:
            *write_method = write_pingCtlDescr;
            break;
        case PINGCTLSOURCEADDRESSTYPE:
            *write_method = write_pingCtlSourceAddressType;
            break;
        case PINGCTLSOURCEADDRESS:
            *write_method = write_pingCtlSourceAddress;
            break;
        case PINGCTLIFINDEX:
            *write_method = write_pingCtlIfIndex;
            break;
        case PINGCTLBYPASSROUTETABLE:
            *write_method = write_pingCtlByPassRouteTable;
            break;
        case PINGCTLDSFIELD:
            *write_method = write_pingCtlDSField;
            break;
        case PINGCTLROWSTATUS:
            *write_method = write_pingCtlRowStatus;
            break;
        default:
            *write_method = 0;
            break;
    }

    /*check compc, retrive compl*/
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,compl, PINGCTLENTRY_INSTANCE_LEN);

    if (exact) /*get,set*/
    {
        if (!pingCtlTable_get(compc, compl, &entry))
            return NULL;
    }
    else /*getnext*/
    {
        if (!pingCtlTable_next(compc, compl, &entry))
        {
            return NULL;
        }
    }

    memcpy(name, vp->name, vp->namelen*sizeof(oid));
    best_inst[0] = entry.ping_ctl_owner_index_len;
    SNMP_MGR_BindOctetInstance((UI8_T*)entry.ping_ctl_owner_index,1,best_inst[0],best_inst);
    best_inst[best_inst[0]+1]=entry.ping_ctl_test_name_len;
    SNMP_MGR_BindOctetInstance((UI8_T*)entry.ping_ctl_test_name,best_inst[0]+2,best_inst[0]+best_inst[best_inst[0]+1]+1,best_inst);
    memcpy(name + vp->namelen, best_inst, PINGCTLENTRY_INSTANCE_LEN*sizeof(oid));
    *length = vp->namelen + best_inst[0] + best_inst[best_inst[0]+1]+2;


    switch (vp->magic)
    {
        case PINGCTLTARGETADDRESSTYPE:
            *var_len = sizeof(long_return);
            long_return = entry.ping_ctl_target_address_type;
            return (u_char *) &long_return;
        case PINGCTLTARGETADDRESS:
        {
            UI32_T out_inet_type, out_inet_addr_len, out_preflen;

            if (!SNMP_MGR_ConvertLInetAddrToInetAddrAndType(
                    (L_INET_Addr_T *)&entry.ping_ctl_target_address,
                    &out_inet_type,
                    &out_inet_addr_len,
                    (UI8_T *)return_buf,
                    &out_preflen))
            {
                return NULL;
            }

            *var_len = out_inet_addr_len;
            return (u_char *) return_buf;
        }
        case PINGCTLDATASIZE:
            /* shumin.wang modified for EPR_ID:ES3628BT-FLF-ZZ-00469 */
            *var_len = sizeof(long_return);
            long_return = entry.ping_ctl_data_size;
            return (u_char *) &long_return;
        case PINGCTLTIMEOUT:
            *var_len = sizeof(long_return);
            long_return = entry.ping_ctl_timeout;
            return (u_char *) &long_return;
        case PINGCTLPROBECOUNT:
            *var_len = sizeof(long_return);
            long_return = entry.ping_ctl_probe_count;
            return (u_char *) &long_return;
        case PINGCTLADMINSTATUS:
            *var_len = sizeof(long_return);
            long_return = entry.ping_ctl_admin_status;
            return (u_char *) &long_return;
        case PINGCTLDATAFILL:
            *var_len = sizeof(entry.ping_ctl_data_fill);
            memcpy (return_buf, entry.ping_ctl_data_fill, *var_len);
            return (u_char *) &return_buf;
        case PINGCTLFREQUENCY:
            *var_len = sizeof(long_return);
            long_return = entry.ping_ctl_frequency;
            return (u_char *) &long_return;
        case PINGCTLMAXROWS:
            *var_len = sizeof(long_return);
            long_return = entry.ping_ctl_max_rows;
            return (u_char *) &long_return;
        case PINGCTLSTORAGETYPE:
            *var_len = sizeof(long_return);
            long_return = entry.ping_ctl_storage_type;
            return (u_char *) &long_return;
        case PINGCTLTRAPGENERATION:
            *var_len = sizeof(long_return);
            long_return = entry.ping_ctl_trap_generation;
            return (u_char *) &long_return;
        case PINGCTLTRAPPROBEFAILUREFILTER:
            *var_len = sizeof(long_return);
            long_return = entry.ping_ctl_trap_probe_failure_filter;
            return (u_char *) &long_return;
        case PINGCTLTRAPTESTFAILUREFILTER:
            *var_len = sizeof(long_return);
            long_return = entry.ping_ctl_trap_test_failure_filter;
            return (u_char *) &long_return;
        case PINGCTLTYPE:
        {
            oid ping_ctl_type[9] = {DISMAN_PING_MODULE_OID, 3, 1};
            *var_len = 9 * sizeof(oid);
            memcpy(oid_return, ping_ctl_type, *var_len);
            return (u_char*) oid_return;
        }
        case PINGCTLDESCR:
            *var_len = sizeof(entry.ping_ctl_descr);
            memcpy (return_buf, entry.ping_ctl_descr, *var_len);
            return (u_char *) return_buf;
        case PINGCTLSOURCEADDRESSTYPE:
            long_return = entry.ping_ctl_source_address_type;
            *var_len = sizeof(long_return);
            return (u_char *) &long_return;
        case PINGCTLSOURCEADDRESS:
        {
            UI32_T out_inet_type, out_inet_addr_len, out_preflen;

            if (!SNMP_MGR_ConvertLInetAddrToInetAddrAndType(
                    (L_INET_Addr_T *)&entry.ping_ctl_source_address,
                    &out_inet_type,
                    &out_inet_addr_len,
                    (UI8_T *)return_buf,
                    &out_preflen))
            {
                return NULL;
            }

            *var_len = out_inet_addr_len;
            return (u_char *) return_buf;
        }
        case PINGCTLIFINDEX:
            *var_len = sizeof(long_return);
            long_return = entry.ping_ctl_if_index;
            return (u_char *) &long_return;
        case PINGCTLBYPASSROUTETABLE:
            *var_len = sizeof(long_return);
            long_return = entry.ping_ctl_by_pass_route_table;;
            return (u_char *) &long_return;
        case PINGCTLDSFIELD:
            *var_len = sizeof(long_return);
            long_return = entry.ping_ctl_ds_field;
            return (u_char *) &long_return;
        case PINGCTLROWSTATUS:
           *var_len = sizeof(long_return);
            long_return = entry.ping_ctl_rowstatus;
            return (u_char *) &long_return;
        default:
            ERROR_MSG("");
    }

    return NULL;
}


int write_pingCtlTargetAddressType(int       action,
                                         u_char    *var_val,
                                         u_char    var_val_type,
                                         size_t    var_val_len,
                                         u_char    *statP,
                                         oid       *name,
                                         size_t    name_len)
{
    long value;

    /*check max length of the inputing index */
    if(name_len > PINGCTLENTRY_INSTANCE_LEN+PINGCTLENTRY_OID_NAME_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    /*check length*/
    if(name[PINGCTLENTRY_OID_NAME_LEN] > MAXSIZE_pingCtlOwnerIndex)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    /*check length*/
    if(name[PINGCTLENTRY_OID_NAME_LEN + 1 + name[PINGCTLENTRY_OID_NAME_LEN]] > MAXSIZE_pingCtlTestName)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }

            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }

            break;
        }

        case RESERVE2:
        {
            value = *(long *)var_val;

            switch (value)
            {
                case VAL_pingCtlTargetAddressType_ipv4:
                case VAL_pingCtlTargetAddressType_ipv4z:
                case VAL_pingCtlTargetAddressType_ipv6:
                case VAL_pingCtlTargetAddressType_ipv6z:
                      break;
                default:
                    return SNMP_ERR_WRONGVALUE;
            }

            break;
        }

        case FREE:
            /* Release any resources that have been allocated */
            break;

        case ACTION:
        {
            PING_TYPE_PingCtlEntry_T data;
            UI32_T i, index1_len, index2_len;
            UI8_T index1[MAXSIZE_pingCtlOwnerIndex], index2[MAXSIZE_pingCtlTestName];
            memset(index1, 0, MAXSIZE_pingCtlOwnerIndex);
            memset(index2, 0, MAXSIZE_pingCtlTestName);

            index1_len = name[PINGCTLENTRY_OID_NAME_LEN];
            for(i = 0; i < index1_len ; i++)
            {
                index1[i] = name[PINGCTLENTRY_OID_NAME_LEN + 1 + i];
            }

            index2_len = name[PINGCTLENTRY_OID_NAME_LEN + 1 + index1_len];
            for(i = 0; i <index2_len; i++)
            {
                index2[i] = name[PINGCTLENTRY_OID_NAME_LEN + 1 + index1_len + 1 + i];
            }

            memset(&data, 0, sizeof(data));
            data.ping_ctl_owner_index_len = index1_len;
            data.ping_ctl_test_name_len = index2_len;
            memcpy(data.ping_ctl_owner_index, index1, index1_len);
            memcpy(data.ping_ctl_test_name, index2, index2_len);

            value = *(long *)var_val;
            if(PING_POM_GetCtlEntry(&data) != PING_TYPE_OK)
                return SNMP_ERR_COMMITFAILED;

            data.ping_ctl_target_address_type = value;

            if(PING_PMGR_SetCtlEntryByField(&data, PING_TYPE_CTLENTRYFIELD_TARGET_ADDRESS_TYPE) != PING_TYPE_OK)
                return SNMP_ERR_COMMITFAILED;

            break;
        }

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }

    return SNMP_ERR_NOERROR;
}


int write_pingCtlTargetAddress(int       action,
                                     u_char    *var_val,
                                     u_char    var_val_type,
                                     size_t    var_val_len,
                                     u_char    *statP,
                                     oid       *name,
                                     size_t    name_len)
{
    int size;

    /*check max length of the inputing index */
    if(name_len >PINGCTLENTRY_INSTANCE_LEN+PINGCTLENTRY_OID_NAME_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    /*check  length */
    if(name[PINGCTLENTRY_OID_NAME_LEN] > MAXSIZE_pingCtlOwnerIndex)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    /*check  length */
    if(name[PINGCTLENTRY_OID_NAME_LEN + 1 + name[PINGCTLENTRY_OID_NAME_LEN]] > MAXSIZE_pingCtlTestName)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_OCTET_STR)
            {
                return SNMP_ERR_WRONGTYPE;
            }

            break;
        }

        case RESERVE2:
        {
            size = var_val_len;

            if(size > MAXSIZE_pingCtlTargetAddress)
            {
                return SNMP_ERR_WRONGLENGTH;
            }

            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            PING_TYPE_PingCtlEntry_T    data;
            UI32_T i, index1_len, index2_len, in_inet_type;
            UI8_T index1[MAXSIZE_pingCtlOwnerIndex], index2[MAXSIZE_pingCtlTestName];

            memset(index1, 0, MAXSIZE_pingCtlOwnerIndex);
            memset(index2, 0, MAXSIZE_pingCtlTestName);

            index1_len = name[PINGCTLENTRY_OID_NAME_LEN];
            for(i = 0; i < index1_len ; i++)
            {
                index1[i] = name[PINGCTLENTRY_OID_NAME_LEN + 1 + i];
            }

            index2_len = name[PINGCTLENTRY_OID_NAME_LEN + 1 + index1_len];
            for(i = 0; i <index2_len; i++)
            {
                index2[i] = name[PINGCTLENTRY_OID_NAME_LEN + 1 + index1_len + 1 + i];
            }

            memset(&data, 0, sizeof(data));
            data.ping_ctl_owner_index_len = index1_len;
            data.ping_ctl_test_name_len = index2_len;
            memcpy(data.ping_ctl_owner_index, index1, index1_len);
            memcpy(data.ping_ctl_test_name, index2, index2_len);

            switch (var_val_len)
            {
                case 4:
                    in_inet_type = L_INET_ADDR_TYPE_IPV4;
                    break;
                case 8:
                    in_inet_type = L_INET_ADDR_TYPE_IPV4Z;
                    break;
                case 16:
                    in_inet_type = L_INET_ADDR_TYPE_IPV6;
                    break;
                case 20:
                    in_inet_type = L_INET_ADDR_TYPE_IPV6Z;
                    break;
                default:
                    return SNMP_ERR_COMMITFAILED;
            }

            if (!
            SNMP_MGR_ConvertInetAddrAndTypeToLInetAddr(
                    in_inet_type,
                    var_val_len,
                    var_val,
                    0,
                    (L_INET_Addr_T *)&data.ping_ctl_target_address))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            if (PING_PMGR_SetCtlTargetAddress(&data, &data.ping_ctl_target_address) != PING_TYPE_OK)
                return SNMP_ERR_COMMITFAILED;

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}


int write_pingCtlDataSize(int       action,
                                u_char    *var_val,
                                u_char    var_val_type,
                                size_t    var_val_len,
                                u_char    *statP,
                                oid       *name,
                                size_t    name_len)
{
    long value;

    /*check max length of the inputing index */
    if(name_len >PINGCTLENTRY_INSTANCE_LEN+PINGCTLENTRY_OID_NAME_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    /*check  length */
    if(name[PINGCTLENTRY_OID_NAME_LEN] > MAXSIZE_pingCtlOwnerIndex)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    /*check  length */
    if(name[PINGCTLENTRY_OID_NAME_LEN + 1 + name[PINGCTLENTRY_OID_NAME_LEN]] > MAXSIZE_pingCtlTestName)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_UNSIGNED)
            {
                return SNMP_ERR_WRONGTYPE;
            }

            if (var_val_len > sizeof(u_long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }

            break;
        }

        case RESERVE2:
        {
            value = *(u_long *)var_val;

            if((value < 0) || (value > 65507))
                return SNMP_ERR_WRONGVALUE;

            break;
        }

        case FREE:
            /* Release any resources that have been allocated */
            break;

        case ACTION:
        {
            PING_TYPE_PingCtlEntry_T    data;
            UI32_T i, index1_len, index2_len;
            UI8_T index1[MAXSIZE_pingCtlOwnerIndex], index2[MAXSIZE_pingCtlTestName];

            memset(index1, 0, MAXSIZE_pingCtlOwnerIndex);
            memset(index2, 0, MAXSIZE_pingCtlTestName);

            index1_len = name[PINGCTLENTRY_OID_NAME_LEN];
            for(i = 0; i < index1_len ; i++)
            {
                index1[i] = name[PINGCTLENTRY_OID_NAME_LEN + 1 + i];
            }

            index2_len = name[PINGCTLENTRY_OID_NAME_LEN + 1 + index1_len];
            for(i = 0; i <index2_len; i++)
            {
                index2[i] = name[PINGCTLENTRY_OID_NAME_LEN + 1 + index1_len + 1 + i];
            }

            memset(&data, 0, sizeof(data));
            data.ping_ctl_owner_index_len = index1_len;
            data.ping_ctl_test_name_len = index2_len;
            memcpy(data.ping_ctl_owner_index, index1, index1_len);
            memcpy(data.ping_ctl_test_name, index2, index2_len);

            value = *(u_long *)var_val;
            data.ping_ctl_data_size = value;

            if (PING_PMGR_SetCtlDataSize(&data, value) != PING_TYPE_OK)
                return SNMP_ERR_COMMITFAILED;

            break;
        }

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }

    return SNMP_ERR_NOERROR;
}


int write_pingCtlTimeOut(int       action,
                               u_char    *var_val,
                               u_char    var_val_type,
                               size_t    var_val_len,
                               u_char    *statP,
                               oid       *name,
                               size_t    name_len)
{
    long value;

    /*check max length of the inputing index */
    if(name_len >PINGCTLENTRY_INSTANCE_LEN+PINGCTLENTRY_OID_NAME_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    /*check  length */
    if(name[PINGCTLENTRY_OID_NAME_LEN] > MAXSIZE_pingCtlOwnerIndex)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    /*check  length */
    if(name[PINGCTLENTRY_OID_NAME_LEN + 1 + name[PINGCTLENTRY_OID_NAME_LEN]] > MAXSIZE_pingCtlTestName)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_UNSIGNED)
            {
                return SNMP_ERR_WRONGTYPE;
            }

            if (var_val_len > sizeof(u_long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }

            break;
        }

        case RESERVE2:
        {
            value = *(u_long *)var_val;

            if((value < MIN_pingCtlTimeOut) || (value > MAX_pingCtlTimeOut))
                return SNMP_ERR_WRONGVALUE;

            break;
        }

        case FREE:
            /* Release any resources that have been allocated */
            break;

        case ACTION:
        {
#if 0 /* shumin.wang comments for EPR_ID:ES3628BT-FLF-ZZ-00469 */
            PING_TYPE_PingCtlEntry_T    data;
            UI32_T i, index1_len, index2_len;
            UI8_T index1[MAXSIZE_pingCtlOwnerIndex], index2[MAXSIZE_pingCtlTestName];

            memset(index1, 0, MAXSIZE_pingCtlOwnerIndex);
            memset(index2, 0, MAXSIZE_pingCtlTestName);

            index1_len = name[PINGCTLENTRY_OID_NAME_LEN];
            for(i = 0; i < index1_len ; i++)
            {
                index1[i] = name[PINGCTLENTRY_OID_NAME_LEN + 1 + i];
            }

            index2_len = name[PINGCTLENTRY_OID_NAME_LEN + 1 + index1_len];
            for(i = 0; i <index2_len; i++)
            {
                index2[i] = name[PINGCTLENTRY_OID_NAME_LEN + 1 + index1_len + 1 + i];
            }

            memset(&data, 0, sizeof(data));
            data.ping_ctl_owner_index_len = index1_len;
            data.ping_ctl_test_name_len = index2_len;
            memcpy(data.ping_ctl_owner_index, index1, index1_len);
            memcpy(data.ping_ctl_test_name, index2, index2_len);
            value = *(u_long *)var_val;
            data.ping_ctl_timeout = value;

            if (PING_PMGR_SetCtlEntry(&data) != PING_TYPE_OK)
                return SNMP_ERR_COMMITFAILED;
#endif
            break;
        }

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }

    return SNMP_ERR_NOERROR;
}


int write_pingCtlProbeCount(int       action,
                                    u_char    *var_val,
                                    u_char    var_val_type,
                                    size_t    var_val_len,
                                    u_char    *statP,
                                    oid       *name,
                                    size_t    name_len)
{
    long value;
    int size;

    /*check max length of the inputing index */
    if(name_len >PINGCTLENTRY_INSTANCE_LEN+PINGCTLENTRY_OID_NAME_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    /*check  length */
    if(name[PINGCTLENTRY_OID_NAME_LEN] > MAXSIZE_pingCtlOwnerIndex)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    /*check  length */
    if(name[PINGCTLENTRY_OID_NAME_LEN + 1 + name[PINGCTLENTRY_OID_NAME_LEN]] > MAXSIZE_pingCtlTestName)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_UNSIGNED)
            {
                return SNMP_ERR_WRONGTYPE;
            }

            if (var_val_len > sizeof(u_long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }

            break;
        }

        case RESERVE2:
        {
            size = var_val_len;
            value = *(u_long *)var_val;

            if((value < MIN_pingCtlProbeCount) || (value > MAX_pingCtlProbeCount))
                return SNMP_ERR_WRONGVALUE;

            break;
        }

        case FREE:
            /* Release any resources that have been allocated */
            break;

        case ACTION:
        {
            PING_TYPE_PingCtlEntry_T    data;
            UI32_T i, index1_len, index2_len;
            UI8_T index1[MAXSIZE_pingCtlOwnerIndex], index2[MAXSIZE_pingCtlTestName];
            memset(index1, 0, MAXSIZE_pingCtlOwnerIndex);
            memset(index2, 0, MAXSIZE_pingCtlTestName);

            index1_len = name[PINGCTLENTRY_OID_NAME_LEN];
            for(i = 0; i < index1_len ; i++)
            {
                index1[i] = name[PINGCTLENTRY_OID_NAME_LEN + 1 + i];
            }

            index2_len = name[PINGCTLENTRY_OID_NAME_LEN + 1 + index1_len];
            for(i = 0; i <index2_len; i++)
            {
                index2[i] = name[PINGCTLENTRY_OID_NAME_LEN + 1 + index1_len + 1 + i];
            }

            memset(&data, 0, sizeof(data));
            data.ping_ctl_owner_index_len = index1_len;
            data.ping_ctl_test_name_len = index2_len;
            memcpy(data.ping_ctl_owner_index, index1, index1_len);
            memcpy(data.ping_ctl_test_name, index2, index2_len);
            value = *(u_long *)var_val;
            data.ping_ctl_probe_count = value;

            if (PING_PMGR_SetCtlProbeCount(&data, value) != PING_TYPE_OK)
                return SNMP_ERR_COMMITFAILED;

            break;
        }

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }
    return SNMP_ERR_NOERROR;
}

int write_pingCtlAdminStatus(int       action,
                                   u_char    *var_val,
                                   u_char    var_val_type,
                                   size_t    var_val_len,
                                   u_char    *statP,
                                   oid       *name,
                                   size_t    name_len)
{
    long value;

    /*check max length of the inputing index */
    if(name_len >PINGCTLENTRY_INSTANCE_LEN+PINGCTLENTRY_OID_NAME_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    /*check  length */
    if(name[PINGCTLENTRY_OID_NAME_LEN] > MAXSIZE_pingCtlOwnerIndex)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    /*check  length */
    if(name[PINGCTLENTRY_OID_NAME_LEN + 1 + name[PINGCTLENTRY_OID_NAME_LEN]] > MAXSIZE_pingCtlTestName)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }

            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }

            break;
        }

        case RESERVE2:
        {
            value = *(long *)var_val;

            if((value < VAL_pingCtlAdminStatus_enabled) || (value > VAL_pingCtlAdminStatus_disabled))
                return SNMP_ERR_WRONGVALUE;

            break;
        }

        case FREE:
            break;

        case ACTION:
        {
			PING_TYPE_PingCtlEntry_T    data;
            UI32_T i, index1_len, index2_len;
            UI8_T index1[MAXSIZE_pingCtlOwnerIndex], index2[MAXSIZE_pingCtlTestName];

            memset(index1, 0, MAXSIZE_pingCtlOwnerIndex);
            memset(index2, 0, MAXSIZE_pingCtlTestName);

            index1_len = name[PINGCTLENTRY_OID_NAME_LEN];
            for(i = 0; i < index1_len ; i++)
            {
                index1[i] = name[PINGCTLENTRY_OID_NAME_LEN + 1 + i];
            }

            index2_len = name[PINGCTLENTRY_OID_NAME_LEN + 1 + index1_len];
            for(i = 0; i <index2_len; i++)
            {
                index2[i] = name[PINGCTLENTRY_OID_NAME_LEN + 1 + index1_len + 1 + i];
            }

            memset(&data, 0, sizeof(data));
            data.ping_ctl_owner_index_len = index1_len;
            data.ping_ctl_test_name_len = index2_len;
            memcpy(data.ping_ctl_owner_index, index1, index1_len);
            memcpy(data.ping_ctl_test_name, index2, index2_len);
            value = *(long *)var_val;
            data.ping_ctl_admin_status = value;

            if (PING_PMGR_SetCtlAdminStatus(&data, value) != PING_TYPE_OK)
                return SNMP_ERR_COMMITFAILED;
            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}


int write_pingCtlDataFill(int       action,
                            u_char    *var_val,
                            u_char    var_val_type,
                            size_t    var_val_len,
                            u_char    *statP,
                            oid       *name,
                            size_t    name_len)
{
    int size;

    /*check max length of the inputing index */
    if(name_len >PINGCTLENTRY_INSTANCE_LEN+PINGCTLENTRY_OID_NAME_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    /*check  length */
    if(name[PINGCTLENTRY_OID_NAME_LEN] > MAXSIZE_pingCtlOwnerIndex)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    /*check  length */
    if(name[PINGCTLENTRY_OID_NAME_LEN + 1 + name[PINGCTLENTRY_OID_NAME_LEN]] > MAXSIZE_pingCtlTestName)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_OCTET_STR)
            {
                return SNMP_ERR_WRONGTYPE;
            }

            break;
        }

        case RESERVE2:
        {
            size = var_val_len;

            if(size > MAXSIZE_pingCtlDataFill)
            {
                return SNMP_ERR_WRONGLENGTH;
            }

            break;
        }

        case FREE:
            break;

        case ACTION:
        {
#if 0 /* shumin.wang comments for EPR_ID:ES3628BT-FLF-ZZ-00469 */
            PING_TYPE_PingCtlEntry_T    data;
            UI32_T i, index1_len, index2_len;
            UI8_T index1[MAXSIZE_pingCtlOwnerIndex], index2[MAXSIZE_pingCtlTestName];

            memset(index1, 0, MAXSIZE_pingCtlOwnerIndex);
            memset(index2, 0, MAXSIZE_pingCtlTestName);

            index1_len = name[PINGCTLENTRY_OID_NAME_LEN];
            for(i = 0; i < index1_len ; i++)
            {
                index1[i] = name[PINGCTLENTRY_OID_NAME_LEN + 1 + i];
            }

            index2_len = name[PINGCTLENTRY_OID_NAME_LEN + 1 + index1_len];
            for(i = 0; i <index2_len; i++)
            {
                index2[i] = name[PINGCTLENTRY_OID_NAME_LEN + 1 + index1_len + 1 + i];
            }

            memset(&data, 0, sizeof(data));
            data.ping_ctl_owner_index_len = index1_len;
            data.ping_ctl_test_name_len = index2_len;
            memcpy(data.ping_ctl_owner_index, index1, index1_len);
            memcpy(data.ping_ctl_test_name, index2, index2_len);

            memcpy(data.ping_ctl_data_fill, var_val, var_val_len);

            if (PING_PMGR_SetCtlEntry(&data) != PING_TYPE_OK)
                return SNMP_ERR_COMMITFAILED;
#endif
            return SNMP_ERR_COMMITFAILED;
            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}


int write_pingCtlFrequency(int       action,
                                 u_char    *var_val,
                                 u_char    var_val_type,
                                 size_t    var_val_len,
                                 u_char    *statP,
                                 oid       *name,
                                 size_t    name_len)
{

    /*check max length of the inputing index */
    if(name_len >PINGCTLENTRY_INSTANCE_LEN+PINGCTLENTRY_OID_NAME_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    /*check  length */
    if(name[PINGCTLENTRY_OID_NAME_LEN] > MAXSIZE_pingCtlOwnerIndex)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    /*check  length */
    if(name[PINGCTLENTRY_OID_NAME_LEN + 1 + name[PINGCTLENTRY_OID_NAME_LEN]] > MAXSIZE_pingCtlTestName)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_UNSIGNED)
            {
                return SNMP_ERR_WRONGTYPE;
            }

            if (var_val_len > sizeof(u_long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }

            break;
        }

        case RESERVE2:
            break;

        case FREE:
            /* Release any resources that have been allocated */
            break;

        case ACTION:
        {
#if 0 /* shumin.wang comments for EPR_ID:ES3628BT-FLF-ZZ-00469 */
            PING_TYPE_PingCtlEntry_T    data;
            UI32_T i, index1_len, index2_len;
            UI8_T index1[MAXSIZE_pingCtlOwnerIndex], index2[MAXSIZE_pingCtlTestName];

            memset(index1, 0, MAXSIZE_pingCtlOwnerIndex);
            memset(index2, 0, MAXSIZE_pingCtlTestName);

            index1_len = name[PINGCTLENTRY_OID_NAME_LEN];
            for(i = 0; i < index1_len ; i++)
            {
                index1[i] = name[PINGCTLENTRY_OID_NAME_LEN + 1 + i];
            }

            index2_len = name[PINGCTLENTRY_OID_NAME_LEN + 1 + index1_len];
            for(i = 0; i <index2_len; i++)
            {
                index2[i] = name[PINGCTLENTRY_OID_NAME_LEN + 1 + index1_len + 1 + i];
            }

            memset(&data, 0, sizeof(data));
            data.ping_ctl_owner_index_len = index1_len;
            data.ping_ctl_test_name_len = index2_len;
            memcpy(data.ping_ctl_owner_index, index1, index1_len);
            memcpy(data.ping_ctl_test_name, index2, index2_len);

            value = *(u_long *)var_val;
            data.ping_ctl_frequency = value;

            if (PING_PMGR_SetCtlEntry(&data) != PING_TYPE_OK)
                return SNMP_ERR_COMMITFAILED;
#endif
            return SNMP_ERR_COMMITFAILED;
            break;
        }

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }

    return SNMP_ERR_NOERROR;
}


int write_pingCtlMaxRows(int       action,
                               u_char    *var_val,
                               u_char    var_val_type,
                               size_t    var_val_len,
                               u_char    *statP,
                               oid       *name,
                               size_t    name_len)
{

    /*check max length of the inputing index */
    if(name_len >PINGCTLENTRY_INSTANCE_LEN+PINGCTLENTRY_OID_NAME_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    /*check  length */
    if(name[PINGCTLENTRY_OID_NAME_LEN] > MAXSIZE_pingCtlOwnerIndex)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    /*check  length */
    if(name[PINGCTLENTRY_OID_NAME_LEN + 1 + name[PINGCTLENTRY_OID_NAME_LEN]] > MAXSIZE_pingCtlTestName)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_UNSIGNED)
            {
                return SNMP_ERR_WRONGTYPE;
            }

            if (var_val_len > sizeof(u_long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }

            break;
        }

        case RESERVE2:
            break;

        case FREE:
            /* Release any resources that have been allocated */
            break;

        case ACTION:
        {
#if 0 /* shumin.wang comments for EPR_ID:ES3628BT-FLF-ZZ-00469 */
            PING_TYPE_PingCtlEntry_T    data;
            UI32_T i, index1_len, index2_len;
            UI8_T index1[MAXSIZE_pingCtlOwnerIndex], index2[MAXSIZE_pingCtlTestName];

            memset(index1, 0, MAXSIZE_pingCtlOwnerIndex);
            memset(index2, 0, MAXSIZE_pingCtlTestName);

            index1_len = name[PINGCTLENTRY_OID_NAME_LEN];
            for(i = 0; i < index1_len ; i++)
            {
                index1[i] = name[PINGCTLENTRY_OID_NAME_LEN + 1 + i];
            }

            index2_len = name[PINGCTLENTRY_OID_NAME_LEN + 1 + index1_len];
            for(i = 0; i <index2_len; i++)
            {
                index2[i] = name[PINGCTLENTRY_OID_NAME_LEN + 1 + index1_len + 1 + i];
            }

            memset(&data, 0, sizeof(data));
            data.ping_ctl_owner_index_len = index1_len;
            data.ping_ctl_test_name_len = index2_len;
            memcpy(data.ping_ctl_owner_index, index1, index1_len);
            memcpy(data.ping_ctl_test_name, index2, index2_len);

            value = *(u_long *)var_val;
            data.ping_ctl_max_rows = value;

            if (PING_PMGR_SetCtlEntry(&data) != PING_TYPE_OK)
                return SNMP_ERR_COMMITFAILED;
#endif
            return SNMP_ERR_COMMITFAILED;
            break;
        }

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }

    return SNMP_ERR_NOERROR;
}


int write_pingCtlStorageType(int       action,
                                   u_char    *var_val,
                                   u_char    var_val_type,
                                   size_t    var_val_len,
                                   u_char    *statP,
                                   oid       *name,
                                   size_t    name_len)
{
    long value;

    /*check max length of the inputing index */
    if(name_len >PINGCTLENTRY_INSTANCE_LEN+PINGCTLENTRY_OID_NAME_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    /*check  length */
    if(name[PINGCTLENTRY_OID_NAME_LEN] > MAXSIZE_pingCtlOwnerIndex)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    /*check  length */
    if(name[PINGCTLENTRY_OID_NAME_LEN + 1 + name[PINGCTLENTRY_OID_NAME_LEN]] > MAXSIZE_pingCtlTestName)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }

            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }

            break;
        }

        case RESERVE2:
        {
            value = *(long *)var_val;

            switch (value)
            {
                case VAL_pingCtlStorageType_other:
                case VAL_pingCtlStorageType_volatile:
                case VAL_pingCtlStorageType_nonVolatile:
                case VAL_pingCtlStorageType_permanent:
                case VAL_pingCtlStorageType_readOnly:
                    break;
                default:
                    return SNMP_ERR_WRONGVALUE;
            }

            break;
        }

        case FREE:
            /* Release any resources that have been allocated */
            break;

        case ACTION:
    #if 1
            /* Not support now */
            return SNMP_ERR_COMMITFAILED;
            break;
    #else
        {
            PING_CTRL_ENTRY_data_T    data;
            UI32_T i, index1_len, index2_len;
            UI8_T index1[MAXSIZE_pingCtlOwnerIndex], index2[MAXSIZE_pingCtlTestName];

            memset(index1, 0, MAXSIZE_pingCtlOwnerIndex);
            memset(index2, 0, MAXSIZE_pingCtlTestName);

            index1_len = name[PINGCTLENTRY_OID_NAME_LEN];
            for(i = 0; i < index1_len ; i++)
            {
                index1[i] = name[PINGCTLENTRY_OID_NAME_LEN + 1 + i];
            }

            index2_len = name[PINGCTLENTRY_OID_NAME_LEN + 1 + index1_len];
            for(i = 0; i <index2_len; i++)
            {
                index2[i] = name[PINGCTLENTRY_OID_NAME_LEN + 1 + index1_len + 1 + i];
            }

            memset(&data, 0, sizeof(data));
            data.ping_ctl_owner_index_len = index1_len;
            data.ping_ctl_test_name_len = index2_len;
            memcpy(data.ping_ctl_owner_index, index1, index1_len);
            memcpy(data.ping_ctl_test_name, index2, index2_len);

            value = *(long *)var_val;

            if (PING_MGR_SetPingCtlEntry_StorageType(&data, value) != PING_TYPE_OK)
                return SNMP_ERR_COMMITFAILED;

            break;
        }
    #endif

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }

    return SNMP_ERR_NOERROR;
}


int write_pingCtlTrapGeneration(int       action,
                                      u_char    *var_val,
                                      u_char    var_val_type,
                                      size_t    var_val_len,
                                      u_char    *statP,
                                      oid       *name,
                                      size_t    name_len)
{
    /*check max length of the inputing index */
    if(name_len >PINGCTLENTRY_INSTANCE_LEN+PINGCTLENTRY_OID_NAME_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    /*check  length */
    if(name[PINGCTLENTRY_OID_NAME_LEN] > MAXSIZE_pingCtlOwnerIndex)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    /*check  length */
    if(name[PINGCTLENTRY_OID_NAME_LEN + 1 + name[PINGCTLENTRY_OID_NAME_LEN]] > MAXSIZE_pingCtlTestName)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_OCTET_STR)
            {
                return SNMP_ERR_WRONGTYPE;
            }

            if (var_val_len > sizeof(char))
            {
                return SNMP_ERR_WRONGLENGTH;
            }

            break;
        }

        case RESERVE2:
            break;

        case FREE:
            /* Release any resources that have been allocated */
            break;

        case ACTION:
        {
#if 0 /* shumin.wang comments for EPR_ID:ES3628BT-FLF-ZZ-00469 */
            PING_TYPE_PingCtlEntry_T    data;
            UI32_T i, index1_len, index2_len;
            UI8_T index1[MAXSIZE_pingCtlOwnerIndex], index2[MAXSIZE_pingCtlTestName];

            memset(index1, 0, MAXSIZE_pingCtlOwnerIndex);
            memset(index2, 0, MAXSIZE_pingCtlTestName);

            index1_len = name[PINGCTLENTRY_OID_NAME_LEN];
            for(i = 0; i < index1_len ; i++)
            {
                index1[i] = name[PINGCTLENTRY_OID_NAME_LEN + 1 + i];
            }

            index2_len = name[PINGCTLENTRY_OID_NAME_LEN + 1 + index1_len];
            for(i = 0; i <index2_len; i++)
            {
                index2[i] = name[PINGCTLENTRY_OID_NAME_LEN + 1 + index1_len + 1 + i];
            }

            memset(&data, 0, sizeof(data));
            data.ping_ctl_owner_index_len = index1_len;
            data.ping_ctl_test_name_len = index2_len;
            memcpy(data.ping_ctl_owner_index, index1, index1_len);
            memcpy(data.ping_ctl_test_name, index2, index2_len);

            memcpy(&data.ping_ctl_trap_generation, var_val, 1);

            if (PING_PMGR_SetCtlEntry(&data) != PING_TYPE_OK)
                return SNMP_ERR_COMMITFAILED;
#endif
            return SNMP_ERR_COMMITFAILED;
            break;
        }

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }

    return SNMP_ERR_NOERROR;
}


int write_pingCtlTrapProbeFailureFilter(int       action,
                                      u_char    *var_val,
                                      u_char    var_val_type,
                                      size_t    var_val_len,
                                      u_char    *statP,
                                      oid       *name,
                                      size_t    name_len)
{
    long value;

    /*check max length of the inputing index */
    if(name_len >PINGCTLENTRY_INSTANCE_LEN+PINGCTLENTRY_OID_NAME_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    /*check  length */
    if(name[PINGCTLENTRY_OID_NAME_LEN] > MAXSIZE_pingCtlOwnerIndex)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    /*check  length */
    if(name[PINGCTLENTRY_OID_NAME_LEN + 1 + name[PINGCTLENTRY_OID_NAME_LEN]] > MAXSIZE_pingCtlTestName)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_UNSIGNED)
            {
                return SNMP_ERR_WRONGTYPE;
            }

            if (var_val_len > sizeof(u_long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }

            break;
        }

        case RESERVE2:
        {
            value = *(u_long *)var_val;

            if((value < MIN_pingCtlTrapProbeFailureFilter) || (value > MAX_pingCtlTrapProbeFailureFilter))
                return SNMP_ERR_WRONGVALUE;
        }
            break;

        case FREE:
            /* Release any resources that have been allocated */
            break;

        case ACTION:
        {
#if 0 /* shumin.wang comments for EPR_ID:ES3628BT-FLF-ZZ-00469 */
            PING_TYPE_PingCtlEntry_T    data;
            UI32_T i, index1_len, index2_len;
            UI8_T index1[MAXSIZE_pingCtlOwnerIndex], index2[MAXSIZE_pingCtlTestName];

            memset(index1, 0, MAXSIZE_pingCtlOwnerIndex);
            memset(index2, 0, MAXSIZE_pingCtlTestName);

            index1_len = name[PINGCTLENTRY_OID_NAME_LEN];
            for(i = 0; i < index1_len ; i++)
            {
                index1[i] = name[PINGCTLENTRY_OID_NAME_LEN + 1 + i];
            }

            index2_len = name[PINGCTLENTRY_OID_NAME_LEN + 1 + index1_len];
            for(i = 0; i <index2_len; i++)
            {
                index2[i] = name[PINGCTLENTRY_OID_NAME_LEN + 1 + index1_len + 1 + i];
            }

            memset(&data, 0, sizeof(data));
            data.ping_ctl_owner_index_len = index1_len;
            data.ping_ctl_test_name_len = index2_len;
            memcpy(data.ping_ctl_owner_index, index1, index1_len);
            memcpy(data.ping_ctl_test_name, index2, index2_len);

            value = *(u_long *)var_val;
            data.ping_ctl_trap_test_failure_filter = value;

            if (PING_PMGR_SetCtlEntry(&data) != PING_TYPE_OK)
                return SNMP_ERR_COMMITFAILED;
#endif
            return SNMP_ERR_COMMITFAILED;
            break;
        }

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }

    return SNMP_ERR_NOERROR;
}


int write_pingCtlTrapTestFailureFilter(int       action,
                                      u_char    *var_val,
                                      u_char    var_val_type,
                                      size_t    var_val_len,
                                      u_char    *statP,
                                      oid       *name,
                                      size_t    name_len)
{
    long value;

    /*check max length of the inputing index */
    if(name_len >PINGCTLENTRY_INSTANCE_LEN+PINGCTLENTRY_OID_NAME_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    /*check  length */
    if(name[PINGCTLENTRY_OID_NAME_LEN] > MAXSIZE_pingCtlOwnerIndex)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    /*check  length */
    if(name[PINGCTLENTRY_OID_NAME_LEN + 1 + name[PINGCTLENTRY_OID_NAME_LEN]] > MAXSIZE_pingCtlTestName)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_UNSIGNED)
            {
                return SNMP_ERR_WRONGTYPE;
            }

            if (var_val_len > sizeof(u_long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }

            break;
        }

        case RESERVE2:
        {
            value = *(u_long *)var_val;

            if((value < MIN_pingCtlTrapTestFailureFilter) || (value > MAX_pingCtlTrapTestFailureFilter))
                return SNMP_ERR_WRONGVALUE;
        }
            break;

        case FREE:
            /* Release any resources that have been allocated */
            break;

        case ACTION:
        {
#if 0 /* shumin.wang comments for EPR_ID:ES3628BT-FLF-ZZ-00469 */
            PING_TYPE_PingCtlEntry_T    data;
            UI32_T i, index1_len, index2_len;
            UI8_T index1[MAXSIZE_pingCtlOwnerIndex], index2[MAXSIZE_pingCtlTestName];

            memset(index1, 0, MAXSIZE_pingCtlOwnerIndex);
            memset(index2, 0, MAXSIZE_pingCtlTestName);

            index1_len = name[PINGCTLENTRY_OID_NAME_LEN];
            for(i = 0; i < index1_len ; i++)
            {
                index1[i] = name[PINGCTLENTRY_OID_NAME_LEN + 1 + i];
            }

            index2_len = name[PINGCTLENTRY_OID_NAME_LEN + 1 + index1_len];
            for(i = 0; i <index2_len; i++)
            {
                index2[i] = name[PINGCTLENTRY_OID_NAME_LEN + 1 + index1_len + 1 + i];
            }

            memset(&data, 0, sizeof(data));
            data.ping_ctl_owner_index_len = index1_len;
            data.ping_ctl_test_name_len = index2_len;
            memcpy(data.ping_ctl_owner_index, index1, index1_len);
            memcpy(data.ping_ctl_test_name, index2, index2_len);

            value = *(u_long *)var_val;
            data.ping_ctl_trap_test_failure_filter = value;

            if (PING_PMGR_SetCtlEntry(&data) != PING_TYPE_OK)
                return SNMP_ERR_COMMITFAILED;
#endif
            return SNMP_ERR_COMMITFAILED;
            break;
        }

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }

    return SNMP_ERR_NOERROR;
}

int write_pingCtlType(int       action,
                            u_char    *var_val,
                            u_char    var_val_type,
                            size_t    var_val_len,
                            u_char    *statP,
                            oid       *name,
                            size_t    name_len)
{
    UI32_T  oid[9];

    /*check max length of the inputing index */
    if(name_len >PINGCTLENTRY_INSTANCE_LEN+PINGCTLENTRY_OID_NAME_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    /*check  length */
    if(name[PINGCTLENTRY_OID_NAME_LEN] > MAXSIZE_pingCtlOwnerIndex)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    /*check  length */
    if(name[PINGCTLENTRY_OID_NAME_LEN + 1 + name[PINGCTLENTRY_OID_NAME_LEN]] > MAXSIZE_pingCtlTestName)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_OBJECT_ID)
            {
                return SNMP_ERR_WRONGTYPE;
            }

            if (var_val_len > 9 * sizeof(oid))
            {
                return SNMP_ERR_WRONGLENGTH;
            }

            break;
        }

        case RESERVE2:
        {
            memcpy(oid, var_val, var_val_len);

            if ((oid[0] != 1) || (oid[1] != 3) || (oid[2] != 6) || (oid[3] != 1) ||
                (oid[4] != 2) || (oid[5] != 1) || (oid[6] != 81) || (oid[7] != 3))
            {
                return SNMP_ERR_WRONGVALUE;
            }

            break;
        }

        case FREE:
            /* Release any resources that have been allocated */
            break;

        case ACTION:
        {
            return SNMP_ERR_COMMITFAILED;
            break;
        }

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }

    return SNMP_ERR_NOERROR;
}


int write_pingCtlDescr(int       action,
                             u_char    *var_val,
                             u_char    var_val_type,
                             size_t    var_val_len,
                             u_char    *statP,
                             oid       *name,
                             size_t    name_len)
{
    /*check max length of the inputing index */
    if(name_len >PINGCTLENTRY_INSTANCE_LEN+PINGCTLENTRY_OID_NAME_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    /*check  length */
    if(name[PINGCTLENTRY_OID_NAME_LEN] > MAXSIZE_pingCtlOwnerIndex)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    /*check  length */
    if(name[PINGCTLENTRY_OID_NAME_LEN + 1 + name[PINGCTLENTRY_OID_NAME_LEN]] > MAXSIZE_pingCtlTestName)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_OCTET_STR)
            {
                return SNMP_ERR_WRONGTYPE;
            }

            if (var_val_len > MAXSIZE_pingCtlDescr)
            {
                return SNMP_ERR_WRONGLENGTH;
            }

            break;
        }

        case RESERVE2:
            break;

        case FREE:
            /* Release any resources that have been allocated */
            break;

        case ACTION:
        {
#if 0 /* shumin.wang comments for EPR_ID:ES3628BT-FLF-ZZ-00469 */
            PING_TYPE_PingCtlEntry_T    data;
            UI32_T i, index1_len, index2_len;
            UI8_T index1[MAXSIZE_pingCtlOwnerIndex], index2[MAXSIZE_pingCtlTestName];
            memset(index1, 0, MAXSIZE_pingCtlOwnerIndex);
            memset(index2, 0, MAXSIZE_pingCtlTestName);

            index1_len = name[PINGCTLENTRY_OID_NAME_LEN];
            for(i = 0; i < index1_len ; i++)
            {
                index1[i] = name[PINGCTLENTRY_OID_NAME_LEN + 1 + i];
            }

            index2_len = name[PINGCTLENTRY_OID_NAME_LEN + 1 + index1_len];
            for(i = 0; i <index2_len; i++)
            {
                index2[i] = name[PINGCTLENTRY_OID_NAME_LEN + 1 + index1_len + 1 + i];
            }

            memset(&data, 0, sizeof(data));
            data.ping_ctl_owner_index_len = index1_len;
            data.ping_ctl_test_name_len = index2_len;
            memcpy(data.ping_ctl_owner_index, index1, index1_len);
            memcpy(data.ping_ctl_test_name, index2, index2_len);

            memcpy(data.ping_ctl_descr, var_val, var_val_len);

            if (PING_PMGR_SetCtlEntry(&data) != PING_TYPE_OK)
                return SNMP_ERR_COMMITFAILED;
#endif
            return SNMP_ERR_COMMITFAILED;
            break;
        }

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }

    return SNMP_ERR_NOERROR;
}


int write_pingCtlSourceAddressType(int       action,
                                         u_char    *var_val,
                                         u_char    var_val_type,
                                         size_t    var_val_len,
                                         u_char    *statP,
                                         oid       *name,
                                         size_t    name_len)
{
    long value;

    /*check max length of the inputing index */
    if(name_len >PINGCTLENTRY_INSTANCE_LEN+PINGCTLENTRY_OID_NAME_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    /*check  length */
    if(name[PINGCTLENTRY_OID_NAME_LEN] > MAXSIZE_pingCtlOwnerIndex)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    /*check  length */
    if(name[PINGCTLENTRY_OID_NAME_LEN + 1 + name[PINGCTLENTRY_OID_NAME_LEN]] > MAXSIZE_pingCtlTestName)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }

            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }

            break;
        }

        case RESERVE2:
        {
            value = *(long *)var_val;

            switch (value)
            {
                case VAL_pingCtlSourceAddressType_ipv4:
                /* only support ipv4
                case VAL_pingCtlSourceAddressType_ipv6:
                case VAL_pingCtlSourceAddressType_ipv4z:
                case VAL_pingCtlSourceAddressType_ipv6z: */
                case VAL_pingCtlSourceAddressType_dns:
                    break;
                default:
                    return SNMP_ERR_WRONGVALUE;
            }

            break;
        }

        case FREE:
            /* Release any resources that have been allocated */
            break;

        case ACTION:
    #if 1
            /* Not support now */
            return SNMP_ERR_COMMITFAILED;
            break;
    #else
        {
            PING_CTRL_ENTRY_data_T    data;
            UI32_T i, index1_len, index2_len;
            UI8_T index1[MAXSIZE_pingCtlOwnerIndex], index2[MAXSIZE_pingCtlTestName];

            memset(index1, 0, MAXSIZE_pingCtlOwnerIndex);
            memset(index2, 0, MAXSIZE_pingCtlTestName);

            index1_len = name[PINGCTLENTRY_OID_NAME_LEN];
            for(i = 0; i < index1_len ; i++)
            {
                index1[i] = name[PINGCTLENTRY_OID_NAME_LEN + 1 + i];
            }

            index2_len = name[PINGCTLENTRY_OID_NAME_LEN + 1 + index1_len];
            for(i = 0; i <index2_len; i++)
            {
                index2[i] = name[PINGCTLENTRY_OID_NAME_LEN + 1 + index1_len + 1 + i];
            }

            memset(&data, 0, sizeof(data));
            data.ping_ctl_owner_index_len = index1_len;
            data.ping_ctl_test_name_len = index2_len;
            memcpy(data.ping_ctl_owner_index, index1, index1_len);
            memcpy(data.ping_ctl_test_name, index2, index2_len);

            value = *(long *)var_val;

            if (PING_MGR_SetPingCtlEntry_SourceAddressType(&data, value) != PING_TYPE_OK)
                return SNMP_ERR_COMMITFAILED;

            break;
        }
    #endif

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }

    return SNMP_ERR_NOERROR;
}


int write_pingCtlSourceAddress(int       action,
                                     u_char    *var_val,
                                     u_char    var_val_type,
                                     size_t    var_val_len,
                                     u_char    *statP,
                                     oid       *name,
                                     size_t    name_len)
{
    int size;

    /*check max length of the inputing index */
    if(name_len >PINGCTLENTRY_INSTANCE_LEN+PINGCTLENTRY_OID_NAME_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    /*check  length */
    if(name[PINGCTLENTRY_OID_NAME_LEN] > MAXSIZE_pingCtlOwnerIndex)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    /*check  length */
    if(name[PINGCTLENTRY_OID_NAME_LEN + 1 + name[PINGCTLENTRY_OID_NAME_LEN]] > MAXSIZE_pingCtlTestName)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_OCTET_STR)
            {
                return SNMP_ERR_WRONGTYPE;
            }

            break;
        }

        case RESERVE2:
        {
            size = var_val_len;

            if(size > MAXSIZE_pingCtlSourceAddress)
            {
                return SNMP_ERR_WRONGLENGTH;
            }

            break;
        }

        case FREE:
            break;

        case ACTION:
    #if 1
            /* Not support now */
            return SNMP_ERR_COMMITFAILED;
            break;
    #else
        {
            PING_CTRL_ENTRY_data_T    data;
            UI32_T i, index1_len, index2_len, buffer_len;
            UI8_T index1[MAXSIZE_pingCtlOwnerIndex], index2[MAXSIZE_pingCtlTestName];
            UI8_T buffer[MAXSIZE_pingCtlTargetAddress];

            memset(index1, 0, MAXSIZE_pingCtlOwnerIndex);
            memset(index2, 0, MAXSIZE_pingCtlTestName);

            index1_len = name[PINGCTLENTRY_OID_NAME_LEN];
            for(i = 0; i < index1_len ; i++)
            {
                index1[i] = name[PINGCTLENTRY_OID_NAME_LEN + 1 + i];
            }

            index2_len = name[PINGCTLENTRY_OID_NAME_LEN + 1 + index1_len];
            for(i = 0; i <index2_len; i++)
            {
                index2[i] = name[PINGCTLENTRY_OID_NAME_LEN + 1 + index1_len + 1 + i];
            }

            memset(&data, 0, sizeof(data));
            data.ping_ctl_owner_index_len = index1_len;
            data.ping_ctl_test_name_len = index2_len;
            memcpy(data.ping_ctl_owner_index, index1, index1_len);
            memcpy(data.ping_ctl_test_name, index2, index2_len);

            memcpy(buffer, var_val, var_val_len);
            buffer_len = var_val_len;

            if (PING_MGR_SetPingCtlEntry_SourceAddress(&data, buffer, buffer_len) != AMS_PING_MGR_OK)
                return SNMP_ERR_COMMITFAILED;

            break;
        }
    #endif

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}


int write_pingCtlIfIndex(int       action,
                               u_char    *var_val,
                               u_char    var_val_type,
                               size_t    var_val_len,
                               u_char    *statP,
                               oid       *name,
                               size_t    name_len)
{
    /*check max length of the inputing index */
    if(name_len >PINGCTLENTRY_INSTANCE_LEN+PINGCTLENTRY_OID_NAME_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    /*check  length */
    if(name[PINGCTLENTRY_OID_NAME_LEN] > MAXSIZE_pingCtlOwnerIndex)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    /*check  length */
    if(name[PINGCTLENTRY_OID_NAME_LEN + 1 + name[PINGCTLENTRY_OID_NAME_LEN]] > MAXSIZE_pingCtlTestName)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }

            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }

			if(*(long *)var_val < 0)
				return SNMP_ERR_WRONGVALUE;

            break;
        }

        case RESERVE2:
            break;

        case FREE:
            /* Release any resources that have been allocated */
            break;

        case ACTION:
    #if 1
            /* Not support now */
            return SNMP_ERR_COMMITFAILED;
            break;
    #else
        {
            PING_CTRL_ENTRY_data_T    data;
            UI32_T i, index1_len, index2_len;
            UI8_T index1[MAXSIZE_pingCtlOwnerIndex], index2[MAXSIZE_pingCtlTestName];

            memset(index1, 0, MAXSIZE_pingCtlOwnerIndex);
            memset(index2, 0, MAXSIZE_pingCtlTestName);

            index1_len = name[PINGCTLENTRY_OID_NAME_LEN];
            for(i = 0; i < index1_len ; i++)
            {
                index1[i] = name[PINGCTLENTRY_OID_NAME_LEN + 1 + i];
            }

            index2_len = name[PINGCTLENTRY_OID_NAME_LEN + 1 + index1_len];
            for(i = 0; i <index2_len; i++)
            {
                index2[i] = name[PINGCTLENTRY_OID_NAME_LEN + 1 + index1_len + 1 + i];
            }

            memset(&data, 0, sizeof(data));
            data.ping_ctl_owner_index_len = index1_len;
            data.ping_ctl_test_name_len = index2_len;
            memcpy(data.ping_ctl_owner_index, index1, index1_len);
            memcpy(data.ping_ctl_test_name, index2, index2_len);

            value = *(long *)var_val;

            if (PING_MGR_SetPingCtlEntry_IfIndex(&data, value) != AMS_PING_MGR_OK)
                return SNMP_ERR_COMMITFAILED;

            break;
        }
    #endif
        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }

    return SNMP_ERR_NOERROR;
}

int write_pingCtlByPassRouteTable(int       action,
                                        u_char    *var_val,
                                        u_char    var_val_type,
                                        size_t    var_val_len,
                                        u_char    *statP,
                                        oid       *name,
                                        size_t    name_len)
{
    long value;

    /*check max length of the inputing index */
    if(name_len >PINGCTLENTRY_INSTANCE_LEN+PINGCTLENTRY_OID_NAME_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    /*check  length */
    if(name[PINGCTLENTRY_OID_NAME_LEN] > MAXSIZE_pingCtlOwnerIndex)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    /*check  length */
    if(name[PINGCTLENTRY_OID_NAME_LEN + 1 + name[PINGCTLENTRY_OID_NAME_LEN]] > MAXSIZE_pingCtlTestName)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }

            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }

            break;
        }

        case RESERVE2:
        {
            value = *(long *)var_val;

            if ((value < VAL_pingCtlByPassRouteTable_true) || (value > VAL_pingCtlByPassRouteTable_false))
                return SNMP_ERR_WRONGVALUE;

            break;
        }

        case FREE:
            /* Release any resources that have been allocated */
            break;

        case ACTION:
    #if 1
            /* Not support now */
            return SNMP_ERR_COMMITFAILED;
            break;
    #else
        {
            PING_CTRL_ENTRY_data_T    data;
            UI32_T i, index1_len, index2_len;
            UI8_T index1[MAXSIZE_pingCtlOwnerIndex], index2[MAXSIZE_pingCtlTestName];

            memset(index1, 0, MAXSIZE_pingCtlOwnerIndex);
            memset(index2, 0, MAXSIZE_pingCtlTestName);

            index1_len = name[PINGCTLENTRY_OID_NAME_LEN];
            for(i = 0; i < index1_len ; i++)
            {
                index1[i] = name[PINGCTLENTRY_OID_NAME_LEN + 1 + i];
            }

            index2_len = name[PINGCTLENTRY_OID_NAME_LEN + 1 + index1_len];
            for(i = 0; i <index2_len; i++)
            {
                index2[i] = name[PINGCTLENTRY_OID_NAME_LEN + 1 + index1_len + 1 + i];
            }

            memset(&data, 0, sizeof(data));
            data.ping_ctl_owner_index_len = index1_len;
            data.ping_ctl_test_name_len = index2_len;
            memcpy(data.ping_ctl_owner_index, index1, index1_len);
            memcpy(data.ping_ctl_test_name, index2, index2_len);

            value = *(long *)var_val;

            if (PING_MGR_SetPingCtlEntry_BypassRouteTable(&data, value) != AMS_PING_MGR_OK)
                return SNMP_ERR_COMMITFAILED;

            break;
        }
    #endif

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }

    return SNMP_ERR_NOERROR;
}


int write_pingCtlDSField(int       action,
                               u_char    *var_val,
                               u_char    var_val_type,
                               size_t    var_val_len,
                               u_char    *statP,
                               oid       *name,
                               size_t    name_len)
{
    long value;

    /*check max length of the inputing index */
    if(name_len >PINGCTLENTRY_INSTANCE_LEN+PINGCTLENTRY_OID_NAME_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    /*check  length */
    if(name[PINGCTLENTRY_OID_NAME_LEN] > MAXSIZE_pingCtlOwnerIndex)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    /*check  length */
    if(name[PINGCTLENTRY_OID_NAME_LEN + 1 + name[PINGCTLENTRY_OID_NAME_LEN]] > MAXSIZE_pingCtlTestName)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_UNSIGNED)
            {
                return SNMP_ERR_WRONGTYPE;
            }

            if (var_val_len > sizeof(u_long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }

            break;
        }

        case RESERVE2:
        {
            value = *(u_long *)var_val;

            if((value < MIN_pingCtlDSField) || (value > MAX_pingCtlDSField))
                return SNMP_ERR_WRONGVALUE;

            break;
        }

        case FREE:
            break;

        case ACTION:
    #if 1
            /* Not support now */
            return SNMP_ERR_COMMITFAILED;
            break;
    #else
        {
            PING_CTRL_ENTRY_data_T    data;
            UI32_T i, index1_len, index2_len;
            UI8_T index1[MAXSIZE_pingCtlOwnerIndex], index2[MAXSIZE_pingCtlTestName];

            memset(index1, 0, MAXSIZE_pingCtlOwnerIndex);
            memset(index2, 0, MAXSIZE_pingCtlTestName);

            index1_len = name[PINGCTLENTRY_OID_NAME_LEN];
            for(i = 0; i < index1_len ; i++)
            {
                index1[i] = name[PINGCTLENTRY_OID_NAME_LEN + 1 + i];
            }

            index2_len = name[PINGCTLENTRY_OID_NAME_LEN + 1 + index1_len];
            for(i = 0; i <index2_len; i++)
            {
                index2[i] = name[PINGCTLENTRY_OID_NAME_LEN + 1 + index1_len + 1 + i];
            }

            memset(&data, 0, sizeof(data));
            data.ping_ctl_owner_index_len = index1_len;
            data.ping_ctl_test_name_len = index2_len;
            memcpy(data.ping_ctl_owner_index, index1, index1_len);
            memcpy(data.ping_ctl_test_name, index2, index2_len);

            value = *(u_long *)var_val;

            if (PING_MGR_SetPingCtlEntry_DSField(&data, value) != AMS_PING_MGR_OK)
                return SNMP_ERR_COMMITFAILED;

            break;
        }
    #endif

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}


int write_pingCtlRowStatus(int       action,
                                 u_char    *var_val,
                                 u_char    var_val_type,
                                 size_t    var_val_len,
                                 u_char    *statP,
                                 oid       *name,
                                 size_t    name_len)
{
    long value;
    /*check max length of the inputing index */

    if(name_len >PINGCTLENTRY_INSTANCE_LEN+PINGCTLENTRY_OID_NAME_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    /*check  length */
    if(name[PINGCTLENTRY_OID_NAME_LEN] > MAXSIZE_pingCtlOwnerIndex || name[PINGCTLENTRY_OID_NAME_LEN] <= 0)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    /*check  length */
    if(name[PINGCTLENTRY_OID_NAME_LEN + 1 + name[PINGCTLENTRY_OID_NAME_LEN]] > MAXSIZE_pingCtlTestName || name[PINGCTLENTRY_OID_NAME_LEN + 1 + name[PINGCTLENTRY_OID_NAME_LEN]] <=0 )
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }

            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }

            break;
        }

        case RESERVE2:
        {
            value = *(long *)var_val;

            if((value < VAL_pingCtlRowStatus_active) || (value > VAL_pingCtlRowStatus_destroy))
                return SNMP_ERR_WRONGVALUE;

            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            PING_TYPE_PingCtlEntry_T    data;
            UI32_T i, index1_len, index2_len;
            UI8_T index1[MAXSIZE_pingCtlOwnerIndex], index2[MAXSIZE_pingCtlTestName];

            memset(index1, 0, MAXSIZE_pingCtlOwnerIndex);
            memset(index2, 0, MAXSIZE_pingCtlTestName);

            index1_len = name[PINGCTLENTRY_OID_NAME_LEN];
            for(i = 0; i < index1_len ; i++)
            {
                index1[i] = name[PINGCTLENTRY_OID_NAME_LEN + 1 + i];
            }

            index2_len = name[PINGCTLENTRY_OID_NAME_LEN + 1 + index1_len];
            for(i = 0; i <index2_len; i++)
            {
                index2[i] = name[PINGCTLENTRY_OID_NAME_LEN + 1 + index1_len + 1 + i];
            }

            memset(&data, 0, sizeof(data));
            data.ping_ctl_owner_index_len = index1_len;
            data.ping_ctl_test_name_len = index2_len;
            memcpy(data.ping_ctl_owner_index, index1, index1_len);
            memcpy(data.ping_ctl_test_name, index2, index2_len);

            value = *(long *)var_val;

            if (PING_PMGR_SetCtlRowStatus(&data, value) != PING_TYPE_OK)
                return SNMP_ERR_COMMITFAILED;
            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

oid pingResultsTable_variables_oid[] = { DISMAN_PING_MODULE_OID, 1 };

struct variable3 pingResultsTable_variables[] =
{
    { PINGRESULTSOPERSTATUS,       ASN_INTEGER,      RONLY,
      var_pingResultsTable, 3, {3, 1, 1} },
    { PINGRESULTSIPTARGETADDRESSTYPE,      ASN_INTEGER,        RONLY,
      var_pingResultsTable, 3, {3, 1, 2} },
    { PINGRESULTSIPTARGETADDRESS,    ASN_OCTET_STR,        RONLY,
      var_pingResultsTable, 3, {3, 1, 3} },
    { PINGRESULTSMINRTT,    ASN_UNSIGNED,      RONLY,
      var_pingResultsTable, 3, {3, 1, 4} },
    { PINGRESULTSMAXRTT,        ASN_UNSIGNED,    RONLY,
      var_pingResultsTable, 3, {3, 1, 5} },
    { PINGRESULTSAVERAGERTT,     ASN_UNSIGNED,     RONLY,
      var_pingResultsTable, 3, {3, 1, 6} },
    { PINGRESULTSPROBERESPONSES,    ASN_UNSIGNED,     RONLY,
      var_pingResultsTable, 3, {3, 1, 7} },
    { PINGRESULTSSENTPROBES,     ASN_UNSIGNED,    RONLY,
      var_pingResultsTable, 3, {3, 1, 8} },
    { PINGRESULTSRTTSUMOFSQUARES,     ASN_UNSIGNED,    RONLY,
      var_pingResultsTable, 3, {3, 1, 9} },
    { PINGRESULTSLASTGOODPROBE,     ASN_OCTET_STR,    RONLY,
      var_pingResultsTable, 3, {3, 1, 10} },
};

void init_pingResultsTable(void)
{
    REGISTER_MIB("pingResultsTable", pingResultsTable_variables,
                 variable3, pingResultsTable_variables_oid);
}

#define PINGRESULTSENTRY_INSTANCE_LEN (2 + MAXSIZE_pingCtlOwnerIndex + MAXSIZE_pingCtlTestName)

static BOOL_T pingResultsTable_get(int      compc,
                                oid     *compl,
                                PING_TYPE_PingResultsEntry_T   *data)
{
    UI8_T   ping_ctl_owner_index[MAXSIZE_pingCtlOwnerIndex];    /* KEY 1 */
    UI32_T  ping_ctl_owner_index_len;
    UI8_T   ping_ctl_test_name[MAXSIZE_pingCtlTestName];        /* KEY 2 */
    UI32_T  ping_ctl_test_name_len;

    /*check input length
     */
    if ( compl[0]                 > MAXSIZE_pingCtlOwnerIndex
     ||compl[compl[0] + 1] > MAXSIZE_pingCtlTestName
     ||compc                    > PINGCTLENTRY_INSTANCE_LEN)
        return FALSE;

    memset(data, 0, sizeof(*data));

    ping_ctl_owner_index_len = compl[0];
    SNMP_MGR_ReadOctetFromCompl(compl, 1, compl[0], ping_ctl_owner_index);
    ping_ctl_test_name_len = compl[compl[0] + 1];
    SNMP_MGR_ReadOctetFromCompl(compl, compl[0] + 2, compl[0] + compl[compl[0] + 1] + 1, ping_ctl_test_name);
    data->ping_ctl_owner_index_len = ping_ctl_owner_index_len;
    data->ping_ctl_test_name_len = ping_ctl_test_name_len;
    memcpy(data->ping_ctl_owner_index, ping_ctl_owner_index, ping_ctl_owner_index_len);
    memcpy(data->ping_ctl_test_name, ping_ctl_test_name, ping_ctl_test_name_len);

    /*get data
     */
    if (PING_POM_GetResultsEntry(data) != PING_TYPE_OK)
    {
        return FALSE;
    }

    return TRUE;
}

static BOOL_T pingResultsTable_next(int      compc,
                                 oid     *compl,
                                 PING_TYPE_PingResultsEntry_T    *data)
{
    UI8_T   ping_ctl_owner_index[MAXSIZE_pingCtlOwnerIndex];    /* KEY 1 */
    UI32_T  ping_ctl_owner_index_len;
    UI8_T   ping_ctl_test_name[MAXSIZE_pingCtlTestName];        /* KEY 2 */
    UI32_T  ping_ctl_test_name_len;

    /*check  the length of inputing index,if <1 we should try get {0.0.0.0.0...} */
    memset(data, 0, sizeof(*data));

    if (compc >= 4)
    {
        ping_ctl_owner_index_len = compl[0];
        SNMP_MGR_ReadOctetFromCompl(compl, 1, compl[0], ping_ctl_owner_index);
        ping_ctl_test_name_len = compl[compl[0] + 1];
        SNMP_MGR_ReadOctetFromCompl(compl, compl[0] + 2, compl[0] + compl[compl[0] + 1] + 1, ping_ctl_test_name);

        if ( (ping_ctl_owner_index_len <= MAXSIZE_pingCtlOwnerIndex) && (ping_ctl_test_name_len <= MAXSIZE_pingCtlTestName) )
        {
            data->ping_ctl_owner_index_len = ping_ctl_owner_index_len;
            data->ping_ctl_test_name_len = ping_ctl_test_name_len;
            memcpy(data->ping_ctl_owner_index, ping_ctl_owner_index, ping_ctl_owner_index_len);
            memcpy(data->ping_ctl_test_name, ping_ctl_test_name, ping_ctl_test_name_len);
        }
    }

    /*get next data*/
    if (PING_POM_GetNextResultsEntry(data) != PING_TYPE_OK)
    {
        return FALSE;
    }

    return TRUE;
}

unsigned char * var_pingResultsTable(struct variable *vp,
                                           oid             *name,
                                           size_t          *length,
                                           int             exact,
                                           size_t          *var_len,
                                           WriteMethod     **write_method)
{
    UI32_T compc = 0;
    oid       compl[PINGCTLENTRY_INSTANCE_LEN];
    oid       best_inst[PINGCTLENTRY_INSTANCE_LEN];
    PING_TYPE_PingResultsEntry_T  entry;

    /*check compc, retrive compl*/
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl, PINGCTLENTRY_INSTANCE_LEN);

    if (exact)/*get,set*/
    {
        if (!pingResultsTable_get(compc, compl, &entry))
            return NULL;
    }
    else/*getnext*/
    {
        if (!pingResultsTable_next(compc, compl, &entry))
        {
            return NULL;
        }
    }

    memcpy(name, vp->name, vp->namelen*sizeof(oid));

    best_inst[0] = entry.ping_ctl_owner_index_len;
    SNMP_MGR_BindOctetInstance((UI8_T*)entry.ping_ctl_owner_index,1,best_inst[0],best_inst);
    best_inst[best_inst[0]+1]=entry.ping_ctl_test_name_len;
    SNMP_MGR_BindOctetInstance((UI8_T*)entry.ping_ctl_test_name,best_inst[0]+2,best_inst[0]+best_inst[best_inst[0]+1]+1,best_inst);
    memcpy(name + vp->namelen, best_inst, PINGCTLENTRY_INSTANCE_LEN*sizeof(oid));
    *length = vp->namelen + best_inst[0] + best_inst[best_inst[0]+1]+2;

    switch (vp->magic)
    {
        case PINGRESULTSOPERSTATUS:
            long_return = entry.ping_results_oper_status;
            *var_len = sizeof(long_return);
            return (u_char *) &long_return;
        case PINGRESULTSIPTARGETADDRESSTYPE:
            *var_len = sizeof(long_return);
            long_return = entry.ping_results_ip_target_address_type;
            return (u_char *) &long_return;
        case PINGRESULTSIPTARGETADDRESS:
        {
            UI32_T out_inet_type, out_inet_addr_len, out_preflen;

            if (!SNMP_MGR_ConvertLInetAddrToInetAddrAndType(
                    (L_INET_Addr_T *)&entry.ping_results_ip_target_address,
                    &out_inet_type,
                    &out_inet_addr_len,
                    (UI8_T *)return_buf,
                    &out_preflen))
            {
                return NULL;
            }

            *var_len = out_inet_addr_len;
            return (u_char *) return_buf;
        }
        case PINGRESULTSMINRTT:
            long_return = entry.ping_results_min_rtt;
            *var_len = sizeof(long_return);
            return (u_char *) &long_return;
        case PINGRESULTSMAXRTT:
            long_return = entry.ping_results_max_rtt;
            *var_len = sizeof(long_return);
            return (u_char *) &long_return;
        case PINGRESULTSAVERAGERTT:
            long_return = entry.ping_results_average_rtt;
            *var_len = sizeof(long_return);
            return (u_char *) &long_return;
        case PINGRESULTSPROBERESPONSES:
            long_return = entry.ping_results_probe_responses;
            *var_len = sizeof(long_return);
            return (u_char *) &long_return;
        case PINGRESULTSSENTPROBES:
            long_return = entry.ping_results_sent_probes;
            *var_len = sizeof(long_return);
            return (u_char *) &long_return;
        case PINGRESULTSRTTSUMOFSQUARES:
            long_return = entry.ping_results_rtt_sum_of_squares;
            *var_len = sizeof(long_return);
            return (u_char *) &long_return;
        case PINGRESULTSLASTGOODPROBE:
            memcpy(return_buf, entry.ping_results_last_good_probe, entry.ping_results_last_good_probe_len);
            *var_len = entry.ping_results_last_good_probe_len;
            return (u_char *) return_buf;
        default:
            ERROR_MSG("");
    }

    return NULL;
}

oid pingProbeHistoryTable_variables_oid[] = { DISMAN_PING_MODULE_OID, 1 };

struct variable3 pingProbeHistoryTable_variables[] =
{
    { PINGPROBEHISTORYINDEX,         ASN_UNSIGNED,     RONLY,
      var_pingProbeHistoryTable, 3, {4, 1, 1} },
    { PINGPROBEHISTORYRESPONSE,      ASN_UNSIGNED,     RONLY,
      var_pingProbeHistoryTable, 3, {4, 1, 2} },
    { PINGPROBEHISTORYSTATUS,        ASN_INTEGER,      RONLY,
      var_pingProbeHistoryTable, 3, {4, 1, 3} },
    { PINGPROBEHISTORYLASTRC,        ASN_INTEGER,      RONLY,
      var_pingProbeHistoryTable, 3, {4, 1, 4} },
    { PINGPROBEHISTORYTIME,          ASN_OCTET_STR,    RONLY,
      var_pingProbeHistoryTable, 3, {4, 1, 5} },
};


void init_pingProbeHistoryTable(void)
{
    REGISTER_MIB("pingProbeHistoryTable", pingProbeHistoryTable_variables,
                 variable3, pingProbeHistoryTable_variables_oid);
}

#define pingProbeHistoryTable_INSTANCE_LEN (3 + MAXSIZE_pingCtlOwnerIndex + MAXSIZE_pingCtlTestName)

static BOOL_T pingProbeHistoryTable_get(int      compc,
                                oid     *compl,
                                PING_TYPE_PingProbeHistoryEntry_T   *data)
{
     UI8_T   ping_ctl_owner_index[MAXSIZE_pingCtlOwnerIndex];    /* KEY 1 */
    UI32_T  ping_ctl_owner_index_len;
    UI8_T   ping_ctl_test_name[MAXSIZE_pingCtlTestName];        /* KEY 2 */
    UI32_T  ping_ctl_test_name_len;
    UI32_T  index;

    /*check input length
     */
    if ( compl[0]                 > MAXSIZE_pingCtlOwnerIndex
     ||compl[compl[0] + 1] > MAXSIZE_pingCtlTestName
     ||compc                    > PINGCTLENTRY_INSTANCE_LEN)
        return FALSE;

    memset(data, 0, sizeof(*data));

    ping_ctl_owner_index_len = compl[0];
    SNMP_MGR_ReadOctetFromCompl(compl, 1, compl[0], ping_ctl_owner_index);
    ping_ctl_test_name_len = compl[compl[0] + 1];
    SNMP_MGR_ReadOctetFromCompl(compl, compl[0] + 2, compl[0] + compl[compl[0] + 1] + 1, ping_ctl_test_name);
    index = compl[compl[0] + compl[compl[0] + 1] + 2];

    data->ping_ctl_owner_index_len = ping_ctl_owner_index_len;
    data->ping_ctl_test_name_len = ping_ctl_test_name_len;
    data->ping_probe_history_index = index;
    memcpy(data->ping_ctl_owner_index, ping_ctl_owner_index, ping_ctl_owner_index_len);
    memcpy(data->ping_ctl_test_name, ping_ctl_test_name, ping_ctl_test_name_len);

    /*get data
     */
    if (PING_POM_GetProbeHistoryEntry(data) != PING_TYPE_OK)
    {
        return FALSE;
    }

    return TRUE;
}
static BOOL_T pingProbeHistoryTable_next(int      compc,
                                 oid     *compl,
                                 PING_TYPE_PingProbeHistoryEntry_T    *data)
{
    UI8_T   ping_ctl_owner_index[MAXSIZE_pingCtlOwnerIndex];    /* KEY 1 */
    UI32_T  ping_ctl_owner_index_len;
    UI8_T   ping_ctl_test_name[MAXSIZE_pingCtlTestName];        /* KEY 2 */
    UI32_T  ping_ctl_test_name_len;
    UI32_T  index;

    /*check  the length of inputing index,if <1 we should try get {0.0.0.0.0...} */
    memset(data, 0, sizeof(*data));

    if (compc >= 5)
    {
        ping_ctl_owner_index_len = compl[0];
        SNMP_MGR_ReadOctetFromCompl(compl, 1, compl[0], ping_ctl_owner_index);
        ping_ctl_test_name_len = compl[compl[0] + 1];
        SNMP_MGR_ReadOctetFromCompl(compl, compl[0] + 2, compl[0] + compl[compl[0] + 1] + 1, ping_ctl_test_name);
        index = compl[compl[0] + compl[compl[0] + 1] + 2];

        if ( (ping_ctl_owner_index_len <= MAXSIZE_pingCtlOwnerIndex) && (ping_ctl_test_name_len <= MAXSIZE_pingCtlTestName) )
        {
            data->ping_ctl_owner_index_len = ping_ctl_owner_index_len;
            data->ping_ctl_test_name_len = ping_ctl_test_name_len;
            data->ping_probe_history_index = index;
            memcpy(data->ping_ctl_owner_index, ping_ctl_owner_index, ping_ctl_owner_index_len);
            memcpy(data->ping_ctl_test_name, ping_ctl_test_name, ping_ctl_test_name_len);
        }
    }

    /*get next data*/
    if (PING_POM_GetNextProbeHistoryEntry(data) != PING_TYPE_OK)
    {
        return FALSE;
    }

    return TRUE;
}

unsigned char * var_pingProbeHistoryTable(struct variable *vp,
                                                oid             *name,
                                                size_t          *length,
                                                int             exact,
                                                size_t          *var_len,
                                                WriteMethod     **write_method)
{
    UI32_T compc=0;
    oid compl[pingProbeHistoryTable_INSTANCE_LEN];
    oid best_inst[pingProbeHistoryTable_INSTANCE_LEN];
    PING_TYPE_PingProbeHistoryEntry_T  entry;

    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,compl, pingProbeHistoryTable_INSTANCE_LEN);
     /*check compc, retrive compl*/
    if (exact)/*get,set*/
    {
        if (!pingProbeHistoryTable_get(compc, compl, &entry))
            return NULL;
    }
    else/*getnext*/
    {
        if (!pingProbeHistoryTable_next(compc, compl, &entry))
        {
            return NULL;
        }
    }

    memcpy(name, vp->name, vp->namelen*sizeof(oid));
    memset(best_inst, 0,  pingProbeHistoryTable_INSTANCE_LEN*sizeof(oid));

    best_inst[0] = entry.ping_ctl_owner_index_len;
    SNMP_MGR_BindOctetInstance((UI8_T*)entry.ping_ctl_owner_index, 1, entry.ping_ctl_owner_index_len, best_inst);
    best_inst[1 + entry.ping_ctl_owner_index_len]=entry.ping_ctl_test_name_len;
    SNMP_MGR_BindOctetInstance((UI8_T*)entry.ping_ctl_test_name,
        1 + entry.ping_ctl_owner_index_len + 1,
        1 + entry.ping_ctl_owner_index_len + entry.ping_ctl_test_name_len, best_inst);
    best_inst[1 + entry.ping_ctl_owner_index_len + 1 + entry.ping_ctl_test_name_len]=entry.ping_probe_history_index;
    memcpy(name + vp->namelen, best_inst, pingProbeHistoryTable_INSTANCE_LEN*sizeof(oid));
    *length = vp->namelen + 1 + entry.ping_ctl_owner_index_len + 1 + entry.ping_ctl_test_name_len + 1;

    switch (vp->magic)
    {
        case PINGPROBEHISTORYRESPONSE:
            long_return = entry.ping_probe_history_response;
            *var_len = sizeof(long_return);
            return (u_char *) &long_return;
        case PINGPROBEHISTORYSTATUS:
            long_return = entry.ping_probe_history_status;
            *var_len = sizeof(long_return);
            return (u_char *) &long_return;
        case PINGPROBEHISTORYLASTRC:
            long_return = entry.ping_probe_history_last_rc;
            *var_len = sizeof(long_return);
            return (u_char *) &long_return;
        case PINGPROBEHISTORYTIME:
            memcpy (return_buf, entry.ping_probe_history_time, entry.ping_probe_history_time_len);
            *var_len = entry.ping_probe_history_time_len;
            return (u_char *) return_buf;
        default:
            ERROR_MSG("");
    }

    return NULL;
}

#endif  /* end of  #if (AMS_SYS_CPNT_PING == TRUE)*/
/* End of Robie's adding */



