/* MODULE NAME:  foundry_lib.h
 *
 * PURPOSE: Library for common routines for the Brocade Foundry MIB.
 *
 * NOTES:
 *
 * HISTORY (mm/dd/yyyy)
 *    05/17/2011 - Qiyao Zhong, Created
 *
 * Copyright(C)      Accton Corporation, 2011
 */

/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.scalar.conf,v 1.5 2002/07/18 14:18:52 dts12 Exp $
 */
#ifndef FOUNDRY_LIB_H
#define FOUNDRY_LIB_H

/* system
 */
#include "sys_type.h"

/* driver
 */
#include "fs.h"

/* The defines the platform where code is compiled.
 *
 * This must be added to all platforms. Otherwise, missing these definitions
 * would result in #if 0 == 0 during comparison, which means always TRUE.
 */
#define FOUNDRY_LIB_PLATFORM_STYLE_SIMBA        1  /* currently is on LGE 1 phase 2 */
#define FOUNDRY_LIB_PLATFORM_STYLE_EDGE_CORE    2
#define FOUNDRY_LIB_PLATFORM_STYLE              FOUNDRY_LIB_PLATFORM_STYLE_EDGE_CORE

/* Encrypted RADIUS and TACACS+ key length:
 *
 * According to Brocade MIB object description, keys are in encrypted form.
 * Accton encrypted form is BASE64.
 *
 * The original maximum length of the encrypted key was 32
 * (old Foundry MIB), but SYS_ADPT_RADIUS_SECRET_KEY_MAX_LENGTH
 * (plain-text lengths used for both RADIUS and TACACS+ key)
 * creates an encrypted key which is longer than that.
 * Brocade has agreed to remove the size restraint in the MIB,
 * and use SYS_ADPT_RADIUS_SECRET_KEY_MAX_LENGTH as the
 * plain-text length.  Considering that SYS_ADPT_RADIUS_SECRET_KEY_MAX_LENGTH
 * may not be a multiple of 3, the encrypted text length will be:
 * (SYS_ADPT_RADIUS_SECRET_KEY_MAX_LENGTH + 2) / 3 * 4
 */
#define FOUNDRY_LIB_ENCRYPTED_RADIUS_SECRET_MAX_LENGTH ((SYS_ADPT_RADIUS_SECRET_KEY_MAX_LENGTH + 2) / 3 * 4 )

/* ------------------------------------------------------------------------
 * FUNCTION NAME - FOUNDRY_LIB_DivideWithSymmetricRounding
 * ------------------------------------------------------------------------
 * PURPOSE  :   Integer division with symetric rounding,
 *              using positive integer division and symetric "drop 4, take 5",
 *              by a rounding half-integer value to an even number:
 *              3.5 -> 4; 4.5 -> 4; 4.51 -> 5; 5.5 -> 6; 6.5 -> 6
 *
 * INPUT    :   in_dividend -- input dividend (the be-divided value, I32_T)
 *              in_divisor  -- input divisor (the dividing value, UI32_T)
 *
 * RETURN   :   I32_T, quotient, rounded to nearest integer;
 *              half-integer values rounded to even number
 *
 * NOTE     :   To protect against division by 0,
 *              if "in_divisor" is 0, the return value is 0.
 *
 * REF      :  http://www.wikipedia.org/wiki/Rounding#Round_half_to_even
 * ------------------------------------------------------------------------
 */
I32_T FOUNDRY_LIB_DivideWithSymmetricRounding(I32_T in_dividend, UI32_T in_divisor);

/* ------------------------------------------------------------------------
 * FUNCTION NAME - FOUNDRY_LIB_ConvertAcctonToFoundryEnabledStatus
 * ------------------------------------------------------------------------
 * PURPOSE  :   Converts Accton EnabledStatus to Foundry enabled status.
 *
 * INPUT    :   accton_val   -- one of these from private MIB's EnabledStatus,
 *              where <node> is any node name:
 *              VAL_<node>_enabled(1)
 *              VAL_<node>_disabled(2)
 *
 * OUTPUT   :   None.
 *
 * RETURN   :   one of these, from Brocade private MIB:
 *              0   -- disabled
 *              1   -- enabled
 *
 * NOTES    :   An illegal input will return disabled(0).
 * ------------------------------------------------------------------------
 */
UI32_T FOUNDRY_LIB_ConvertAcctonToFoundryEnabledStatus(UI32_T accton_val);

/* ------------------------------------------------------------------------
 * FUNCTION NAME - FOUNDRY_LIB_ConvertFoundryToAcctonEnabledStatus
 * ------------------------------------------------------------------------
 * PURPOSE  :   Converts Foundry EnabledStatus to Foundry enabled status.
 *
 * INPUT    :   brocade_val   -- one of the following, from Brocade private MIB:
 *              0   -- disabled
 *              1   -- enabled
 *
 * OUTPUT   :   None.
 *
 * RETURN   :   one of these from private MIB's EnabledStatus,
 *              where <node> is any node name:
 *              VAL_<node>_enabled(1)
 *              VAL_<node>_disabled(2)
 *
 * NOTES    :   An illegal input will return disabled(2).
 * ------------------------------------------------------------------------
 */
UI32_T FOUNDRY_LIB_ConvertFoundryToAcctonEnabledStatus(UI32_T foundry_val);

/* ------------------------------------------------------------------------
 * FUNCTION NAME - FOUNDRY_LIB_GetSfpPort
 * ------------------------------------------------------------------------
 * PURPOSE  :   Gets an SFP port.
 *              Based on the model of SWCTRL_POM_GetLogicalPort.
 *              Body of function based on CLI "show interfaces transceiver".
 *
 * INPUT    :   lport   -- logical port representing the SFP port
 *
 * OUTPUT   :   *unit_p         -- unit ID for this logical port
 *              *sfp_index_p    -- SFP index used by Stack Topology
 *              *present_p      -- whether a transceiver is present
 *
 * RETURN   :   TRUE    -- this port is an SFP
 *              FALSE   -- this port is not an SFP
 *
 * NOTES    :   If this function returns FALSE, output values are undefined.
 * ------------------------------------------------------------------------
 */
BOOL_T FOUNDRY_LIB_GetSfpPort(UI32_T lport, UI32_T *unit_p, UI32_T *sfp_index_p, BOOL_T *present_p);

/* ------------------------------------------------------------------------
 * FUNCTION NAME - FOUNDRY_LIB_GetNextSfpPort
 * ------------------------------------------------------------------------
 * PURPOSE  :   Gets the next SFP port.
 *              Based on the model of SWCTRL_POM_GetNextLogicalPort.
 *              Body of function based on CLI "show interfaces transceiver".
 *
 * INPUT    :   lport   -- logical port representing the SFP port
 *
 * OUTPUT   :   *unit_p         -- unit ID for this logical port
 *              *sfp_index_p    -- SFP index used by Stack Topology
 *              *present_p      -- whether a transceiver is present
 *
 * RETURN   :   TRUE    -- this port is an SFP
 *              FALSE   -- this port is not an SFP
 *
 * NOTES    :   If this function returns FALSE, output values are undefined.
 * ------------------------------------------------------------------------
 */
BOOL_T FOUNDRY_LIB_GetNextSfpPort(UI32_T *lport_p, UI32_T *unit_p, UI32_T *sfp_index_p, BOOL_T *present_p);

/* ------------------------------------------------------------------------
 * FUNCTION NAME - FOUNDRY_LIB_GetNextNonStartupRuntimeFileInfo
 * ------------------------------------------------------------------------
 * PURPOSE  :   Gets the FS file info of the non-startup runtime.
 *
 * INPUT    :   attr_p  -- pointer to file attribute structure
 *                         pass all-zero content to start
 *
 * OUTPUT   :   *attr_p -- file attributes
 *
 * RETURN   :   TRUE    -- next file exists
 *              FALSE   -- next file does not exist
 *
 * NOTES    :   If this function returns FALSE, output values are undefined.
 * ------------------------------------------------------------------------
 */
BOOL_T FOUNDRY_LIB_GetNextNonStartupRuntimeFileInfo(FS_File_Attr_T *attr_p);

#endif /* FOUNDRY_LIB_H */
