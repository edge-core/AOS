/* MODULE NAME:  foundry_sn_switch_group.c
 *
 * PURPOSE: For SNMP to access Brocade's FOUNDRY-SN-SWITCH-GROUP-MIB:
 *
 * foundry(1991).products(1).switch(1).snSwitch(3)
 *
 * NOTES:
 *
 * HISTORY (mm/dd/yyyy)
 *    05/09/2011 - Qiyao Zhong, Created
 *
 * Copyright(C)      Accton Corporation, 2011
 */

/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.scalar.conf,v 1.8 2004/10/14 12:57:34 dts12 Exp $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

/* system
 */
#include "sys_type.h"
#include "sys_adpt.h"
#include "sys_cpnt.h"
#include "leaf_sys.h"
#include "leaf_foundry_sn_switch_group.h"
#include "l_stdlib.h"
#include "l_base64.h"

/* SNMP itself
 */
#include "snmp_mgr.h"
#include "sysORTable.h"
#include "foundry_lib.h"
#include "foundry_sn_switch_group.h"

/* driver
 */
#include "sys_time.h"

#if (FOUNDRY_LIB_PLATFORM_STYLE == FOUNDRY_LIB_PLATFORM_STYLE_EDGE_CORE)
/*!!PATCH: In the future, when following Simba on latest branch,
 * text generation is done in the core layer for all UI's to get,
 * then this include may be not needed.
 */
#include "swdrv.h"
#endif

/* core (L2)
 */
#include "swctrl.h"
#include "swctrl_pom.h"
#include "swctrl_pmgr.h"
#include "amtr_om.h"
#include "amtr_pmgr.h"
#include "nmtr_pmgr.h"

#if (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_RSTP) || (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_MSTP)
  #include "xstp_pmgr.h"
  #include "xstp_pom.h"
#else
  #include "sta_mgr.h"
#endif

#include "vlan_pom.h"
#include "vlan_pmgr.h"

/* core (management)
 */
#include "stktplg_om.h"
#include "stktplg_pom.h"
#include "stktplg_pmgr.h"

/* core (security)
 */
#include "userauth.h"
#include "userauth_pmgr.h"

#if (SYS_CPNT_RADIUS == TRUE)
#include "radius_pom.h"
#include "radius_pmgr.h"
#endif  /* (SYS_CPNT_RADIUS == TRUE) */

#if (SYS_CPNT_TACACS == TRUE)
#include "tacacs_pom.h"
#include "tacacs_pmgr.h"
#endif  /* (SYS_CPNT_RADIUS == TRUE) */

#if (SYS_CPNT_AAA == TRUE)
#include "aaa_pom.h"
#include "aaa_pmgr.h"
#endif  /* (SYS_CPNT_AAA == TRUE) */

#if (SYS_CPNT_PORT_SECURITY == TRUE)
#include "psec_pmgr.h"
#endif  /* (SYS_CPNT_PORT_SECURITY == TRUE) */

#if (SYS_CPNT_NETACCESS == TRUE)
#include "netaccess_pmgr.h"
#include "netaccess_type.h"
#endif  /* (SYS_CPNT_NETACCESS == TRUE) */

/*--------------------------------------------------------------------------
 * SCALAR NAME - 1.1.3.1 snSwInfo.snFdbTableCurEntry(9)
 *--------------------------------------------------------------------------
 */
void init_snFdbTableCurEntry(void)
{
    static oid snFdbTableCurEntry_oid[] = { 1,3,6,1,4,1,1991,1,1,3,1,9, 0 };

    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("snFdbTableCurEntry",
                                         get_snFdbTableCurEntry,
                                         snFdbTableCurEntry_oid,
                                         OID_LENGTH(snFdbTableCurEntry_oid),
                                         HANDLER_CAN_RONLY));
}

int get_snFdbTableCurEntry(netsnmp_mib_handler *handler,
    netsnmp_handler_registration *reginfo,
    netsnmp_agent_request_info *reqinfo,
    netsnmp_request_info *requests)
{
    /* dispatch get vs. set
     */
    switch (reqinfo->mode)
    {
        /*
         * GET REQUEST
         */
        case MODE_GET:
        {
            UI32_T var_len = 0;
            UI32_T total_entry;

            /* get from core layer
             */
            total_entry = AMTR_OM_GetTotalCounter();
            var_len = 4;
            memcpy(return_buf, &total_entry, sizeof(total_entry));
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                (u_char *) return_buf, var_len);

            break;
        }


        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

/*--------------------------------------------------------------------------
 * SCALAR NAME - 1.1.3.1 snSwInfo.snFdbTableStationFlush(10)
 *--------------------------------------------------------------------------
 */
void init_snFdbTableStationFlush(void)
{
    static oid snFdbTableStationFlush_oid[] = { 1,3,6,1,4,1,1991,1,1,3,1,10, 0 };

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("snFdbTableStationFlush",
                               do_snFdbTableStationFlush,
                               snFdbTableStationFlush_oid,
                               OID_LENGTH(snFdbTableStationFlush_oid),
                               HANDLER_CAN_RWRITE));
}

int do_snFdbTableStationFlush(netsnmp_mib_handler *handler,
    netsnmp_handler_registration *reginfo,
    netsnmp_agent_request_info *reqinfo,
    netsnmp_request_info *requests)
{
    /* dispatch get vs. set
     */
    switch (reqinfo->mode)
    {
        /*
         * GET REQUEST
         */
        case MODE_GET:
        {
            UI32_T var_len = 0;
            UI32_T value = 1;  /* fixed: normal(1) */

            /* get fixed value
             */
            var_len = 4;
            memcpy(return_buf, &value, sizeof(value));
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                (u_char *) return_buf, var_len);

            break;
        }

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            /* check type and length
             */
            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
                return SNMP_ERR_NOERROR;
            }

            break;

        case MODE_SET_RESERVE2:
            switch (*requests->requestvb->val.integer)
            {
                case VAL_snFdbTableStationFlush_normal:
                    break;

                case VAL_snFdbTableStationFlush_error:
                    break;

                case VAL_snFdbTableStationFlush_flush:
                    break;

                case VAL_snFdbTableStationFlush_flushing:
                    break;

                default:
                    netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
                    return SNMP_ERR_NOERROR;
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called.
             */
            break;

        case MODE_SET_ACTION:
        {
            /* set to core layer
             */
            if ((*requests->requestvb->val.integer == VAL_snFdbTableStationFlush_flush)
                && (! AMTR_PMGR_DeleteAddrByLifeTime(AMTR_TYPE_ADDRESS_LIFETIME_DELETE_ON_TIMEOUT)))
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
                return SNMP_ERR_NOERROR;
            }

            break;
        }

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

/*--------------------------------------------------------------------------
 * SCALAR NAME - 1.1.3.1 snSwInfo.snSwGlobalStpMode(14)
 *--------------------------------------------------------------------------
 */
void init_snSwGlobalStpMode(void)
{
    static oid snSwGlobalStpMode_oid[] = { 1,3,6,1,4,1,1991,1,1,3,1,14, 0 };

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("snSwGlobalStpMode",
                               do_snSwGlobalStpMode,
                               snSwGlobalStpMode_oid,
                               OID_LENGTH(snSwGlobalStpMode_oid),
                               HANDLER_CAN_RWRITE));
}

int do_snSwGlobalStpMode(netsnmp_mib_handler *handler,
    netsnmp_handler_registration *reginfo,
    netsnmp_agent_request_info *reqinfo,
    netsnmp_request_info *requests)
{
    /* dispatch get vs. set
     */
    switch (reqinfo->mode)
    {
        /*
         * GET REQUEST
         */
        case MODE_GET:
        {
            UI32_T var_len = 0;
            UI32_T core_val, user_val;

            /* get from core layer
             */
            if (! XSTP_POM_GetSystemSpanningTreeStatus(&core_val))
            {
                return SNMP_ERR_GENERR;
            }
            else
            {
                /* convert to user value
                 */
                user_val = FOUNDRY_LIB_ConvertAcctonToFoundryEnabledStatus(core_val);

                /* respond to user
                 */
                var_len = 4;
                memcpy(return_buf, &user_val, sizeof(user_val));
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                    (u_char *) return_buf, var_len);
            }

            break;
        }

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            /* check type and length
             */
            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
                return SNMP_ERR_NOERROR;
            }

            break;

        case MODE_SET_RESERVE2:
            switch (*requests->requestvb->val.integer)
            {
                case VAL_snSwGlobalStpMode_disabled:
                    break;

                case VAL_snSwGlobalStpMode_enabled:
                    break;

                default:
                    netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
                    return SNMP_ERR_NOERROR;
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called.
             */
            break;

        case MODE_SET_ACTION:
        {
            UI32_T core_val;

            /* convert to core-layer value
             */
            core_val = FOUNDRY_LIB_ConvertFoundryToAcctonEnabledStatus(*requests->requestvb->val.integer);

            /* set to core layer
             */
#if (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_RSTP) || (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_MSTP)
            if (XSTP_PMGR_SetSystemSpanningTreeStatus(core_val) != XSTP_TYPE_RETURN_OK)
#else
            if (STA_MGR_SetStaSystemStatus(core_val) != STA_RETURN_OK)
#endif
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
                return SNMP_ERR_NOERROR;
            }

            break;
        }

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

/*--------------------------------------------------------------------------
 * SCALAR NAME - 1.1.3.1 snSwInfo.snSwIpMcastQuerierMode(15)
 *--------------------------------------------------------------------------
 */
void init_snSwIpMcastQuerierMode(void)
{
    static oid snSwIpMcastQuerierMode_oid[] = { 1,3,6,1,4,1,1991,1,1,3,1,15, 0 };

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("snSwIpMcastQuerierMode",
                               do_snSwIpMcastQuerierMode,
                               snSwIpMcastQuerierMode_oid,
                               OID_LENGTH(snSwIpMcastQuerierMode_oid),
                               HANDLER_CAN_RWRITE));
}

int do_snSwIpMcastQuerierMode(netsnmp_mib_handler *handler,
    netsnmp_handler_registration *reginfo,
    netsnmp_agent_request_info *reqinfo,
    netsnmp_request_info *requests)
{
    /* dispatch get vs. set
     */
    switch (reqinfo->mode)
    {
        /*
         * GET REQUEST
         */
        case MODE_GET:
        {
            UI32_T var_len = 0;
            UI32_T core_val, user_val;

            /* get from core layer
             */
            if (! IGMPSNP_PMGR_GetQuerier(&core_val))
            {
                return SNMP_ERR_GENERR;
            }
            else
            {
                /* convert to user value
                 */
                switch (core_val)
                {
                    case VAL_igmpSnoopQuerier_enabled:
                        user_val = VAL_snSwIpMcastQuerierMode_querier;
                        break;

                    case VAL_igmpSnoopQuerier_disabled:
                        user_val = VAL_snSwIpMcastQuerierMode_nonQuerier;
                        break;

                    default:
                        user_val = VAL_snSwIpMcastQuerierMode_nonQuerier;
                        break;
                }

                /* respond to user
                 */
                var_len = 4;
                memcpy(return_buf, &user_val, sizeof(user_val));
                snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                    (u_char *) return_buf, var_len);
            }

            break;
        }

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            /* check type and length
             */
            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
                return SNMP_ERR_NOERROR;
            }

            break;

        case MODE_SET_RESERVE2:
            switch (*requests->requestvb->val.integer)
            {
                case VAL_snSwIpMcastQuerierMode_querier:
                    break;

                case VAL_snSwIpMcastQuerierMode_nonQuerier:
                    break;

                default:
                    netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
                    return SNMP_ERR_NOERROR;
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called.
             */
            break;

        case MODE_SET_ACTION:
        {
            /* set to core layer
             */
            if (*requests->requestvb->val.integer == 1)  /* hard-coded "enabled" */
            {
                if (! IGMPSNP_PMGR_SetQuerier())
                {
                    netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
                    return SNMP_ERR_NOERROR;
                }
            }
            else  /* 0, hard-coded "disabled" */
            {
                if (! IGMPSNP_PMGR_UnsetQuerier())
                {
                    netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
                    return SNMP_ERR_NOERROR;
                }
            }

            break;
        }

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

#if (SYS_CPNT_SYSTEMWIDE_COUNTER == TRUE)
/*--------------------------------------------------------------------------
 * SCALAR NAME - 1.1.3.1 snSwInfo.snSwClearCounters(33)
 *--------------------------------------------------------------------------
 */
void init_snSwClearCounters(void)
{
    static oid snSwClearCounters_oid[] = { 1,3,6,1,4,1,1991,1,1,3,1,33, 0 };

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("snSwClearCounters",
                               do_snSwClearCounters,
                               snSwClearCounters_oid,
                               OID_LENGTH(snSwClearCounters_oid),
                               HANDLER_CAN_RWRITE));
}

int do_snSwClearCounters(netsnmp_mib_handler *handler,
    netsnmp_handler_registration *reginfo,
    netsnmp_agent_request_info *reqinfo,
    netsnmp_request_info *requests)
{
    /* dispatch get vs. set
     */
    switch (reqinfo->mode)
    {
        /*
         * GET REQUEST
         */
        case MODE_GET:
        {
            UI32_T var_len = 0;
            UI32_T return_val = VAL_snSwClearCounters_valid;

            /* get fixed value
             */
            var_len = 4;
            memcpy(return_buf, &return_val, sizeof(return_val));
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                (u_char *) return_buf, var_len);

            break;
        }

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            /* check type and length
             */
            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
                return SNMP_ERR_NOERROR;
            }

            break;

        case MODE_SET_RESERVE2:
            switch (*requests->requestvb->val.integer)
            {
                case VAL_snSwClearCounters_valid:
                    break;

                case VAL_snSwClearCounters_clear:
                    break;

                default:
                    netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
                    return SNMP_ERR_NOERROR;
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called.
             */
            break;

        case MODE_SET_ACTION:
        {
            /* set to core layer
             */
            if (*requests->requestvb->val.integer == VAL_snSwClearCounters_clear)
            {
                UI32_T port = 0;

                /* clear for all ports
                 */
                while (SWCTRL_POM_GetNextLogicalPort(&port))
                {
                    NMTR_PMGR_ClearSystemwideStats(port);
                }
            }

            break;
        }

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
#endif  /* (SYS_CPNT_SYSTEMWIDE_COUNTER == TRUE) */

/*--------------------------------------------------------------------------
 * SCALAR NAME - 1.1.3.1 snSwInfo.snSwQosMechanism(40)
 *--------------------------------------------------------------------------
 */
void init_snSwQosMechanism(void)
{
    static oid snSwQosMechanism_oid[] = { 1,3,6,1,4,1,1991,1,1,3,1,40, 0 };

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("snSwQosMechanism",
                               do_snSwQosMechanism,
                               snSwQosMechanism_oid,
                               OID_LENGTH(snSwQosMechanism_oid),
                               HANDLER_CAN_RWRITE));
}

int do_snSwQosMechanism(netsnmp_mib_handler *handler,
    netsnmp_handler_registration *reginfo,
    netsnmp_agent_request_info *reqinfo,
    netsnmp_request_info *requests)
{
    /* dispatch get vs. set
     */
    switch (reqinfo->mode)
    {
        /*
         * GET REQUEST
         */
        case MODE_GET:
        {
            UI32_T var_len = 0;
            UI32_T lport = 0, core_val = 0, user_val = 0;

            /* get first port for port-based API; if no port exists, fail
             */
            if (SWCTRL_POM_GetNextLogicalPort(&lport) == SWCTRL_LPORT_UNKNOWN_PORT)
            {
                return SNMP_ERR_GENERR;
            }

            /* get from core layer (get first port for port-based API)
             */
            if (! SWCTRL_POM_GetPortPrioQueueMode(lport, &core_val))
            {
                return SNMP_ERR_GENERR;
            }

            /* convert core-layer value to user value
             */
            switch (core_val)
            {
                /* weigth, assume WRR
                 */
                case VAL_prioQueueMode_wrr:

#if (FOUNDRY_LIB_PLATFORM_STYLE == FOUNDRY_LIB_PLATFORM_STYLE_SIMBA)
                case VAL_prioQueueMode_drr:  /* not settable by this node */
#endif

                    user_val = VAL_snSwQosMechanism_weighted;
                    break;

                /* strict
                 */
                case VAL_prioQueueMode_strict:  /* Simba & Edge-Core platform default */

#if (FOUNDRY_LIB_PLATFORM_STYLE == FOUNDRY_LIB_PLATFORM_STYLE_SIMBA)
                case VAL_prioQueueMode_strict_wrr:  /* not settable by this node */
                case VAL_prioQueueMode_strict_drr:  /* not settable by this node */
#endif

                    user_val = VAL_snSwQosMechanism_strict;
                    break;

                /* should not happen; if happens, is a bug
                 */
                default:
                    break;
            }

            /* respond to user
             */
            var_len = 4;
            memcpy(return_buf, &user_val, sizeof(user_val));
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                (u_char *) return_buf, var_len);

            break;
        }

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            /* check type and length
             */
            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
                return SNMP_ERR_NOERROR;
            }

            break;

        case MODE_SET_RESERVE2:
            switch (*requests->requestvb->val.integer)
            {
                case VAL_snSwQosMechanism_strict:
                    break;

                case VAL_snSwQosMechanism_weighted:
                    break;

                default:
                    netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
                    return SNMP_ERR_NOERROR;
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called.
             */
            break;

        case MODE_SET_ACTION:
        {
            UI32_T lport = 0, core_val = 0;

            /* convert to core-layer value (only two modes are settable by this node)
             */
            switch ((*requests->requestvb->val.integer))
            {
                /* weighted
                 */
                case VAL_snSwQosMechanism_weighted:
                    core_val = VAL_prioQueueMode_wrr;  /* assume WRR */
                    break;

                /* strict
                 */
                case VAL_snSwQosMechanism_strict:
                    core_val = VAL_prioQueueMode_strict;  /* assume strict */
                    break;

                /* should not happen; if happens, is a bug
                 */
                default:
                    core_val = 0;
                    break;
            }

            /* get first port for port-based API; if no port exists, fail
             */
            if (SWCTRL_POM_GetNextLogicalPort(&lport) == SWCTRL_LPORT_UNKNOWN_PORT)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
                return SNMP_ERR_NOERROR;
            }

            /* set to core layer
             */
            if (! SWCTRL_PMGR_SetPortPrioQueueMode(lport, core_val))
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
                return SNMP_ERR_NOERROR;
            }

            break;
        }

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

/*--------------------------------------------------------------------------
 * SCALAR NAME - 1.1.3.1 snSwInfo.snSwSingleStpMode(41)
 *--------------------------------------------------------------------------
 */
void init_snSwSingleStpMode(void)
{
    static oid snSwSingleStpMode_oid[] = { 1,3,6,1,4,1,1991,1,1,3,1,41, 0 };

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("snSwSingleStpMode",
                               do_snSwSingleStpMode,
                               snSwSingleStpMode_oid,
                               OID_LENGTH(snSwSingleStpMode_oid),
                               HANDLER_CAN_RWRITE));
}

int do_snSwSingleStpMode(netsnmp_mib_handler *handler,
    netsnmp_handler_registration *reginfo,
    netsnmp_agent_request_info *reqinfo,
    netsnmp_request_info *requests)
{
    /* dispatch get vs. set
     */
    switch (reqinfo->mode)
    {
        /*
         * GET REQUEST
         */
        case MODE_GET:
        {
            UI32_T var_len = 0;
            UI32_T status, version, user_val;

            /* get from core layer
             */
            if (! XSTP_POM_GetSystemSpanningTreeStatus(&status))
            {
                return SNMP_ERR_GENERR;
            }

            /* if enabled, get STP type
             */
            if (status == VAL_staSystemStatus_enabled)
            {
                if (! XSTP_POM_GetSystemSpanningTreeVersion(&version))
                {
                    return SNMP_ERR_GENERR;
                }

                /* convert core-layer value to user value
                 */
                switch (version)
                {
                    case XSTP_TYPE_STP_PROTOCOL_VERSION_ID:
                        user_val = VAL_snSwSingleStpMode_enableStp;
                        break;
                    case XSTP_TYPE_RSTP_PROTOCOL_VERSION_ID:
                        user_val = VAL_snSwSingleStpMode_enableRstp;
                        break;
                    case XSTP_TYPE_MSTP_PROTOCOL_VERSION_ID:  /* MSTP not supported by this node */
                    default:
                        user_val = VAL_snSwSingleStpMode_disable;
                        break;
                }
            }

            /* else if disabled, tell user
             */
            else
            {
                user_val = VAL_snSwSingleStpMode_disable;
            }

            /* respond to user
             */
            var_len = 4;
            memcpy(return_buf, &user_val, sizeof(user_val));
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                (u_char *) return_buf, var_len);

            break;
        }

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            /* check type and length
             */
            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
                return SNMP_ERR_NOERROR;
            }

            break;

        case MODE_SET_RESERVE2:
            switch (*requests->requestvb->val.integer)
            {
                case VAL_snSwSingleStpMode_disable:
                    break;

                case VAL_snSwSingleStpMode_enableStp:
                    break;

                case VAL_snSwSingleStpMode_enableRstp:
                    break;

                default:
                    netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
                    return SNMP_ERR_NOERROR;
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called.
             */
            break;

        case MODE_SET_ACTION:
        {
            /* set to core layer
             */
            switch (*requests->requestvb->val.integer)
            {
                /* disable
                 */
                case VAL_snSwSingleStpMode_disable:
#if (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_RSTP) || (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_MSTP)
                    if (XSTP_PMGR_SetSystemSpanningTreeStatus(VAL_staSystemStatus_disabled)
                        != XSTP_TYPE_RETURN_OK)
#else
                    if (STA_MGR_SetStaSystemStatus(VAL_staSystemStatus_disabled)
                        != STA_RETURN_OK)
#endif
                    {
                        netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
                        return SNMP_ERR_NOERROR;
                    }

                    break;

                /* enable as STP
                 */
                case VAL_snSwSingleStpMode_enableStp:
#if (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_RSTP) || (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_MSTP)
                    if (XSTP_PMGR_SetSystemSpanningTreeStatus(VAL_staSystemStatus_enabled)
                        != XSTP_TYPE_RETURN_OK)
#else
                    if (STA_MGR_SetStaSystemStatus(VAL_staSystemStatus_enabled)
                        != STA_RETURN_OK)
#endif
                    {
                        netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
                        return SNMP_ERR_NOERROR;
                    }

                    if (XSTP_PMGR_SetSystemSpanningTreeVersion(XSTP_TYPE_STP_PROTOCOL_VERSION_ID)
                        != XSTP_TYPE_RETURN_OK)
                    {
                        netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
                        return SNMP_ERR_NOERROR;
                    }

                    break;

                /* enable as RSTP
                 */
                case VAL_snSwSingleStpMode_enableRstp:
#if (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_RSTP) || (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_MSTP)
                    if (XSTP_PMGR_SetSystemSpanningTreeStatus(VAL_staSystemStatus_enabled) != XSTP_TYPE_RETURN_OK)
#else
                    if (STA_MGR_SetStaSystemStatus(VAL_staSystemStatus_enabled) != STA_RETURN_OK)
#endif
                    {
                        netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
                        return SNMP_ERR_NOERROR;
                    }

                    if (XSTP_PMGR_SetSystemSpanningTreeVersion(XSTP_TYPE_RSTP_PROTOCOL_VERSION_ID)
                        != XSTP_TYPE_RETURN_OK)
                    {
                        netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
                        return SNMP_ERR_NOERROR;
                    }

                    break;

                /* should not happen; if happens, is a bug
                 */
                default:
                    netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
                    return SNMP_ERR_NOERROR;
            }

            break;
        }

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

/* ------------------------------------------------------------------------
 * FUNCTION NAME - init_snSwInfo
 * ------------------------------------------------------------------------
 * PURPOSE  :   The is the entry point for the "1.1.3.1 snSwInfo" subtree.
 *
 * INPUT    :   None.
 *
 * OUTPUT   :   None.
 *
 * RETURN   :   None.
 *
 * NOTES    :   None.
 * ------------------------------------------------------------------------
 */
void init_snSwInfo(void)
{
    /* init individual scalars
     */
    init_snSwGroupIpMcastMode();    /*  1 */
    init_snFdbTableCurEntry();      /*  9 */
    init_snFdbTableStationFlush();  /* 10 */
    init_snSwGlobalStpMode();       /* 14 */
    init_snSwIpMcastQuerierMode();  /* 15 */

#if (SYS_CPNT_SYSTEMWIDE_COUNTER == TRUE)
    init_snSwClearCounters();       /* 33 */
#endif

    init_snSwQosMechanism();        /* 40 */
    init_snSwSingleStpMode();       /* 41 */

    /* init individual tables
     */
}

/*--------------------------------------------------------------------------
 * TABLE NAME - 1.1.3.3.5 snSwIfInfoTable
 *--------------------------------------------------------------------------
 */
oid snSwIfInfoTable_variables_oid[] = { 1,3,6,1,4,1,1991,1,1,3,3 };

/* variable3 snSwIfInfoTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */
struct variable3 snSwIfInfoTable_variables[] =
{
    /* magic number, variable type, ro/rw, callback fn, L, oidsuffix
     *     (L = length of the oidsuffix)
     */
    { LEAF_snSwIfInfoPortNum, ASN_INTEGER, RONLY, var_snSwIfInfoTable, 3, { 5, 1, 1 }},

#if 0  /* deprecated */
    { LEAF_snSwIfInfoMonitorMode, ASN_INTEGER, RWRITE, var_snSwIfInfoTable, 3, { 5, 1, 2 }},
#endif

#if 0  /* not implemented */
    { LEAF_snSwIfInfoMirrorPorts, ASN_OCTET_STR, RWRITE, var_snSwIfInfoTable, 3, { 5, 1, 3 }},
#endif

    { LEAF_snSwIfInfoTagMode, ASN_INTEGER, RWRITE, var_snSwIfInfoTable, 3, { 5, 1, 4 }},
    { LEAF_snSwIfInfoTagType, ASN_INTEGER, RWRITE, var_snSwIfInfoTable, 3, { 5, 1, 5 }},
    { LEAF_snSwIfInfoChnMode, ASN_INTEGER, RWRITE, var_snSwIfInfoTable, 3, { 5, 1, 6 }},
    { LEAF_snSwIfInfoSpeed, ASN_INTEGER, RWRITE, var_snSwIfInfoTable, 3, { 5, 1, 7 }},
    { LEAF_snSwIfInfoMediaType, ASN_INTEGER, RONLY, var_snSwIfInfoTable, 3, { 5, 1, 8 }},
    { LEAF_snSwIfInfoConnectorType, ASN_INTEGER, RONLY, var_snSwIfInfoTable, 3, { 5, 1, 9 }},

#if 0  /* not implemented */
    { LEAF_snSwIfInfoAdminStatus, ASN_INTEGER, RWRITE, var_snSwIfInfoTable, 3, { 5, 1, 10 }},
    { LEAF_snSwIfInfoLinkStatus, ASN_INTEGER, RONLY, var_snSwIfInfoTable, 3, { 5, 1, 11 }},
    { LEAF_snSwIfInfoPortQos, ASN_INTEGER, RWRITE, var_snSwIfInfoTable, 3, { 5, 1, 12 }},
    { LEAF_snSwIfInfoPhysAddress, ASN_OCTET_STR, RONLY, var_snSwIfInfoTable, 3, { 5, 1, 13 }},
    { LEAF_snSwIfLockAddressCount, ASN_INTEGER, RWRITE, var_snSwIfInfoTable, 3, { 5, 1, 14 }},
#endif

    { LEAF_snSwIfStpPortEnable, ASN_INTEGER, RWRITE, var_snSwIfInfoTable, 3, { 5, 1, 15 }},

#if 0  /* not implemented */
    { LEAF_snSwIfDhcpGateListId, ASN_INTEGER, RWRITE, var_snSwIfInfoTable, 3, { 5, 1, 16 }},
    { LEAF_snSwIfName, ASN_OCTET_STR, RWRITE, var_snSwIfInfoTable, 3, { 5, 1, 17 }},
    { LEAF_snSwIfDescr, ASN_OCTET_STR, RONLY, var_snSwIfInfoTable, 3, { 5, 1, 18 }},
#endif

    { LEAF_snSwIfInfoAutoNegotiate, ASN_INTEGER, RWRITE, var_snSwIfInfoTable, 3, { 5, 1, 19 }},
    { LEAF_snSwIfInfoFlowControl, ASN_INTEGER, RWRITE, var_snSwIfInfoTable, 3, { 5, 1, 20 }},
    { LEAF_snSwIfInfoGigType, ASN_INTEGER, RONLY, var_snSwIfInfoTable, 3, { 5, 1, 21 }},
    { LEAF_snSwIfFastSpanPortEnable, ASN_INTEGER, RWRITE, var_snSwIfInfoTable, 3, { 5, 1, 22 }},

#if 0  /* not implemented */
    { LEAF_snSwIfFastSpanUplinkEnable, ASN_INTEGER, RWRITE, var_snSwIfInfoTable, 3, { 5, 1, 23 }},
    { LEAF_snSwIfVlanId, ASN_INTEGER, RWRITE, var_snSwIfInfoTable, 3, { 5, 1, 24 }},
    { LEAF_snSwIfRouteOnly, ASN_INTEGER, RWRITE, var_snSwIfInfoTable, 3, { 5, 1, 25 }},
    { LEAF_snSwIfPresent, ASN_INTEGER, RONLY, var_snSwIfInfoTable, 3, { 5, 1, 26 }},
#endif

    { LEAF_snSwIfGBICStatus, ASN_INTEGER, RONLY, var_snSwIfInfoTable, 3, { 5, 1, 27 }},

#if 0  /* not implemented */
    { LEAF_snSwIfLoadInterval, ASN_INTEGER, RWRITE, var_snSwIfInfoTable, 3, { 5, 1, 28 }},
    { LEAF_snSwIfStatsInFrames, ASN_COUNTER, RONLY, var_snSwIfInfoTable, 3, { 5, 1, 29 }},
    { LEAF_snSwIfStatsOutFrames, ASN_COUNTER, RONLY, var_snSwIfInfoTable, 3, { 5, 1, 30 }},
    { LEAF_snSwIfStatsAlignErrors, ASN_COUNTER, RONLY, var_snSwIfInfoTable, 3, { 5, 1, 31 }},
    { LEAF_snSwIfStatsFCSErrors, ASN_COUNTER, RONLY, var_snSwIfInfoTable, 3, { 5, 1, 32 }},
    { LEAF_snSwIfStatsMultiColliFrames, ASN_COUNTER, RONLY, var_snSwIfInfoTable, 3, { 5, 1, 33 }},
    { LEAF_snSwIfStatsTxColliFrames, ASN_COUNTER, RONLY, var_snSwIfInfoTable, 3, { 5, 1, 34 }},
    { LEAF_snSwIfStatsRxColliFrames, ASN_COUNTER, RONLY, var_snSwIfInfoTable, 3, { 5, 1, 35 }},
    { LEAF_snSwIfStatsFrameTooLongs, ASN_COUNTER, RONLY, var_snSwIfInfoTable, 3, { 5, 1, 36 }},
    { LEAF_snSwIfStatsFrameTooShorts, ASN_COUNTER, RONLY, var_snSwIfInfoTable, 3, { 5, 1, 37 }},
    { LEAF_snSwIfStatsInBcastFrames, ASN_COUNTER, RONLY, var_snSwIfInfoTable, 3, { 5, 1, 38 }},
    { LEAF_snSwIfStatsOutBcastFrames, ASN_COUNTER, RONLY, var_snSwIfInfoTable, 3, { 5, 1, 39 }},
    { LEAF_snSwIfStatsInMcastFrames, ASN_COUNTER, RONLY, var_snSwIfInfoTable, 3, { 5, 1, 40 }},
    { LEAF_snSwIfStatsOutMcastFrames, ASN_COUNTER, RONLY, var_snSwIfInfoTable, 3, { 5, 1, 41 }},
    { LEAF_snSwIfStatsInDiscard, ASN_COUNTER, RONLY, var_snSwIfInfoTable, 3, { 5, 1, 42 }},
    { LEAF_snSwIfStatsOutDiscard, ASN_COUNTER, RONLY, var_snSwIfInfoTable, 3, { 5, 1, 43 }},
#endif

    { LEAF_snSwIfStatsMacStations, ASN_INTEGER, RONLY, var_snSwIfInfoTable, 3, { 5, 1, 44 }},

#if 0  /* not implemented */
    { LEAF_snSwIfStatsLinkChange, ASN_COUNTER, RONLY, var_snSwIfInfoTable, 3, { 5, 1, 45 }},
    { LEAF_snSwIfInOctets, ASN_COUNTER64, RONLY, var_snSwIfInfoTable, 3, { 5, 1, 46 }},
    { LEAF_snSwIfOutOctets, ASN_COUNTER64, RONLY, var_snSwIfInfoTable, 3, { 5, 1, 47 }},
    { LEAF_snSwIfStatsInBitsPerSec, ASN_GAUGE, RONLY, var_snSwIfInfoTable, 3, { 5, 1, 48 }},
    { LEAF_snSwIfStatsOutBitsPerSec, ASN_GAUGE, RONLY, var_snSwIfInfoTable, 3, { 5, 1, 49 }},
    { LEAF_snSwIfStatsInPktsPerSec, ASN_GAUGE, RONLY, var_snSwIfInfoTable, 3, { 5, 1, 50 }},
    { LEAF_snSwIfStatsOutPktsPerSec, ASN_GAUGE, RONLY, var_snSwIfInfoTable, 3, { 5, 1, 51 }},
    { LEAF_snSwIfStatsInUtilization, ASN_INTEGER, RONLY, var_snSwIfInfoTable, 3, { 5, 1, 52 }},
    { LEAF_snSwIfStatsOutUtilization, ASN_INTEGER, RONLY, var_snSwIfInfoTable, 3, { 5, 1, 53 }},
    { LEAF_snSwIfStatsInKiloBitsPerSec, ASN_UNSIGNED, RONLY, var_snSwIfInfoTable, 3, { 5, 1, 54 }},
    { LEAF_snSwIfStatsOutKiloBitsPerSec, ASN_UNSIGNED, RONLY, var_snSwIfInfoTable, 3, { 5, 1, 55 }},
    { LEAF_snSwIfStatsInJumboFrames, ASN_COUNTER64, RONLY, var_snSwIfInfoTable, 3, { 5, 1, 56 }},
    { LEAF_snSwIfStatsOutJumboFrames, ASN_COUNTER64, RONLY, var_snSwIfInfoTable, 3, { 5, 1, 57 }},
    { LEAF_snSwIfInfoMirrorMode, ASN_INTEGER, RWRITE, var_snSwIfInfoTable, 3, { 5, 1, 58 }},
    { LEAF_snSwIfMacLearningDisable, ASN_INTEGER, RWRITE, var_snSwIfInfoTable, 3, { 5, 1, 59 }},
#endif
};

void init_snSwIfInfoTable(void)
{
    /* Register ourselves with the agent to handle our MIB tree
     */
    REGISTER_MIB("snSwIfInfoTable", snSwIfInfoTable_variables, variable3,
                 snSwIfInfoTable_variables_oid);
}

#define SNSWIFINFOENTRY_INSTANCE_LEN  1

BOOL_T snSwIfInfoTable_OidIndexToData(UI32_T exact, UI32_T compc,
    oid *compl, UI32_T *snSwIfInfoPortNum)
{
    /* get or set
     */
    if (exact)
    {
        /* check the index length
         */
        if (compc != SNSWIFINFOENTRY_INSTANCE_LEN)  /* the constant size index */
        {
            return FALSE;
        }
    }

    *snSwIfInfoPortNum = compl[0];

    return TRUE;
}

/*
 * var_snSwIfInfoTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *var_snSwIfInfoTable(struct variable *vp,
    oid *name,
    size_t *length,
    int exact,
    size_t *var_len,
    WriteMethod **write_method)
{
    UI32_T compc = 0;
    oid compl[SNSWIFINFOENTRY_INSTANCE_LEN] = {0};
    oid best_inst[SNSWIFINFOENTRY_INSTANCE_LEN] = {0};

    /* table-specific variables
     */
    UI32_T lport;
    SWCTRL_PortEntry_T port_entry;  /* portTable */
    Port_Info_T port_info;          /* SWCTRL */    

#if (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_RSTP) || (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_MSTP)
    XSTP_MGR_Dot1dStpExtPortEntry_T stp_ext_port_entry;  /* staPortTable */
#else
    STA_MGR_StaPortEntry_T sta_port_entry;  /* staPortTable */
#endif /* #if (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_RSTP) || (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_MSTP) */

    VLAN_OM_VlanPortEntry_T vlan_port_entry;  /* vlanPortTable */

    /* dispatch node to set write method
     */
    switch (vp->magic)
    {
#if 0  /* deprecated */
        case LEAF_snSwIfInfoMonitorMode:
            *write_method = write_snSwIfInfoMonitorMode;
            break;
#endif

#if 0  /* not implemented */
        case LEAF_snSwIfInfoMirrorPorts:
            *write_method = write_snSwIfInfoMirrorPorts;
            break;
#endif

        case LEAF_snSwIfInfoTagMode:
            *write_method = write_snSwIfInfoTagMode;
            break;

        case LEAF_snSwIfInfoTagType:
            *write_method = write_snSwIfInfoTagType;
            break;

        case LEAF_snSwIfInfoChnMode:
            *write_method = write_snSwIfInfoChnMode;
            break;

        case LEAF_snSwIfInfoSpeed:
            *write_method = write_snSwIfInfoSpeed;
            break;

#if 0  /* not implemented */
        case LEAF_snSwIfInfoAdminStatus:
            *write_method = write_snSwIfInfoAdminStatus;
            break;

        case LEAF_snSwIfInfoPortQos:
            *write_method = write_snSwIfInfoPortQos;
            break;

        case LEAF_snSwIfLockAddressCount:
            *write_method = write_snSwIfLockAddressCount;
            break;
#endif

        case LEAF_snSwIfStpPortEnable:
            *write_method = write_snSwIfStpPortEnable;
            break;

#if 0  /* not implemented */
        case LEAF_snSwIfDhcpGateListId:
            *write_method = write_snSwIfDhcpGateListId;
            break;

        case LEAF_snSwIfName:
            *write_method = write_snSwIfName;
            break;
#endif

        case LEAF_snSwIfInfoAutoNegotiate:
            *write_method = write_snSwIfInfoAutoNegotiate;
            break;

        case LEAF_snSwIfInfoFlowControl:
            *write_method = write_snSwIfInfoFlowControl;
            break;

        case LEAF_snSwIfFastSpanPortEnable:
            *write_method = write_snSwIfFastSpanPortEnable;
            break;

#if 0  /* not implemented */
        case LEAF_snSwIfFastSpanUplinkEnable:
            *write_method = write_snSwIfFastSpanUplinkEnable;
            break;

        case LEAF_snSwIfVlanId:
            *write_method = write_snSwIfVlanId;
            break;

        case LEAF_snSwIfRouteOnly:
            *write_method = write_snSwIfRouteOnly;
            break;

        case LEAF_snSwIfLoadInterval:
            *write_method = write_snSwIfLoadInterval;
            break;

        case LEAF_snSwIfInfoMirrorMode:
            *write_method = write_snSwIfInfoMirrorMode;
            break;

        case LEAF_snSwIfMacLearningDisable:
            *write_method = write_snSwIfMacLearningDisable;
            break;
#endif

        default:
            *write_method = 0;
            break;
    }

    /* check compc, retrive compl
     */
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl,
        SNSWIFINFOENTRY_INSTANCE_LEN);

    /* dispatch get-exact versus get-next
     */
    if (exact)  /* get or set */
    {
        /* extract index
         */
        if (! snSwIfInfoTable_OidIndexToData(exact, compc, compl,
            &lport))
        {
            return NULL;
        }

        /* get-exact from core layer
         */
        if (! SWCTRL_POM_LogicalPortExisting(lport))
        {
            return NULL;
        }
    }
    else  /* get-next */
    {
        /* extract index
         */
        snSwIfInfoTable_OidIndexToData(exact, compc, compl,
            &lport);

        /* Check the length of inputing index. If compc is less than instance
         * length, we should try get {A.B.C.0.0...}, where A.B.C was
         * obtained from the "..._OidIndexToData" function call, and
         * 0.0... was initialized in the beginning of this function.
         * This instance may exist in the core layer.
         */
        if (compc < SNSWIFINFOENTRY_INSTANCE_LEN)  /* incomplete index */
        {
            /* get-exact, in case this instance exists
             */
            if (! SWCTRL_POM_LogicalPortExisting(lport))
            {
                /* get-next according to lexicographic order; if none, fail
                 */
                if (SWCTRL_POM_GetNextLogicalPort(&lport) == SWCTRL_LPORT_UNKNOWN_PORT)
                {
                    return NULL;
                }
            }
        }
        else   /* complete index */
        {
            /* get-next according to lexicographic order; if none, fail
             */
            if (SWCTRL_POM_GetNextLogicalPort(&lport) == SWCTRL_LPORT_UNKNOWN_PORT)
            {
                return NULL;
            }
        }
    }

    /* copy base OID (without index) to output
     */
    memcpy(name, vp->name, vp->namelen * sizeof(oid));

    /* assign data to the OID index
     */
    best_inst[0] = lport;
    memcpy(name + vp->namelen, best_inst, SNSWIFINFOENTRY_INSTANCE_LEN * sizeof(oid));
    *length = vp->namelen + SNSWIFINFOENTRY_INSTANCE_LEN;

    /* dispatch node to read value
     */
    switch (vp->magic)
    {
        /* snSwIfInfoPortNum(1)
         */
        case LEAF_snSwIfInfoPortNum:
            *var_len = 4;
            long_return = lport;
            return (u_char *) &long_return;

#if 0  /* deprecated */
        case LEAF_snSwIfInfoMonitorMode:
            *var_len = 4;
            long_return = entry.snSwIfInfoMonitorMode;???
            return (u_char *) &long_return;
#endif

#if 0  /* not implemented */
        case LEAF_snSwIfInfoMirrorPorts:
            *var_len = SIZE_snSwIfInfoMirrorPorts;
            memcpy(return_buf, entry.snSwIfInfoMirrorPorts, *var_len);???
            return (u_char *) return_buf;
#endif

        /* snSwIfInfoTagMode(4)
         */
        case LEAF_snSwIfInfoTagMode:
            memset(&vlan_port_entry, 0, sizeof(vlan_port_entry));

            if (! VLAN_PMGR_GetVlanPortEntry(lport, &vlan_port_entry))
            {
                return NULL;
            }

            switch (vlan_port_entry.vlan_port_mode)
            {
                case VAL_vlanPortMode_hybrid:
                    long_return = VAL_snSwIfInfoTagMode_dual;  /* hybrid or double-tagged? */
                    break;

                case VAL_vlanPortMode_dot1qTrunk:
                    long_return = VAL_snSwIfInfoTagMode_tagged;
                    break;

                case VAL_vlanPortMode_access:
                    long_return = VAL_snSwIfInfoTagMode_untagged;
                    break;

                default:  /* should not happen */
                    long_return = 0;
                    break;
            }

            *var_len = 4;
            return (u_char *) &long_return;

        /* snSwIfInfoTagType(5)
         */
        case LEAF_snSwIfInfoTagType:
            *var_len = 4;
            long_return = SYS_DFLT_DOT1Q_PORT_TPID_FIELD;  /* fixed */
            return (u_char *) &long_return;

        /* snSwIfInfoChnMode(6)
         */
        case LEAF_snSwIfInfoChnMode:
            memset(&port_entry, 0, sizeof(port_entry));
            port_entry.port_index = lport;

            if (! SWCTRL_POM_GetPortEntry(&port_entry))
            {
                return NULL;
            }

            /* MIB object description says that if a port is link down
             * or disabled, this variable should retrun none(0).
             * Note that this bebaviour makes it different from the CLI,
             * because the Accton CLI does not show "none".
             */
            if (! SWCTRL_POM_GetPortInfo(lport, &port_info))
            {
                return NULL;
            }

            if ( (port_info.admin_state == VAL_ifAdminStatus_down)
                || (port_info.link_status == SWCTRL_LINK_DOWN) )
            {
                long_return = VAL_snSwIfInfoChnMode_none;
            }

            /* read-back status (not forced-mode user config):
             * extract duplex mode
             */
            else 
            {
                switch (port_entry.port_speed_dpx_status)
                {
                    case VAL_portSpeedDpxStatus_error:
                        long_return = VAL_snSwIfInfoChnMode_none;
                        break;

                    case VAL_portSpeedDpxStatus_halfDuplex10:
                    case VAL_portSpeedDpxStatus_halfDuplex100:
                    case VAL_portSpeedDpxStatus_halfDuplex1000:
                    case VAL_portSpeedDpxStatus_halfDuplex10g:
                        long_return = VAL_snSwIfInfoChnMode_halfDuplex;
                        break;

                    case VAL_portSpeedDpxStatus_fullDuplex10:
                    case VAL_portSpeedDpxStatus_fullDuplex100:
                    case VAL_portSpeedDpxStatus_fullDuplex1000:
                    case VAL_portSpeedDpxStatus_fullDuplex10g:
                        long_return = VAL_snSwIfInfoChnMode_fullDuplex;
                        break;

                    default:  /* should not happen */
                        long_return = VAL_snSwIfInfoChnMode_none;
                        break;
                }
            }

            *var_len = 4;
            return (u_char *) &long_return;

        /* snSwIfInfoSpeed(7)
         */
        case LEAF_snSwIfInfoSpeed:
            memset(&port_entry, 0, sizeof(port_entry));
            port_entry.port_index = lport;

            if (! SWCTRL_POM_GetPortEntry(&port_entry))
            {
                return NULL;
            }

            /* MIB object description says that if a port is link down
             * or disabled, this variable should retrun none(0).
             * Note that this bebaviour makes it different from the CLI,
             * because the Accton CLI does not show "none".
             */
            if (! SWCTRL_POM_GetPortInfo(lport, &port_info))
            {
                return NULL;
            }

            if ( (port_info.admin_state == VAL_ifAdminStatus_down)
                || (port_info.link_status == SWCTRL_LINK_DOWN) )
            {
                long_return = VAL_snSwIfInfoChnMode_none;
            }

            /* read-back status (not forced-mode user config):
             * extract speed
             */
            else 
            {
                switch (port_entry.port_speed_dpx_status)
                {
                    case VAL_portSpeedDpxStatus_error:
                        long_return = VAL_snSwIfInfoSpeed_none;
                        break;

                    case VAL_portSpeedDpxStatus_halfDuplex10:
                    case VAL_portSpeedDpxStatus_fullDuplex10:
                        long_return = VAL_snSwIfInfoSpeed_s10M;
                        break;

                    case VAL_portSpeedDpxStatus_halfDuplex100:
                    case VAL_portSpeedDpxStatus_fullDuplex100:
                        long_return = VAL_snSwIfInfoSpeed_s100M;
                        break;

                    case VAL_portSpeedDpxStatus_halfDuplex1000:
                    case VAL_portSpeedDpxStatus_fullDuplex1000:
                        long_return = VAL_snSwIfInfoSpeed_s1G;
                        break;

                    case VAL_portSpeedDpxStatus_halfDuplex10g:
                    case VAL_portSpeedDpxStatus_fullDuplex10g:
                        long_return = VAL_snSwIfInfoSpeed_s10G;
                        break;

                    default:  /* should not happen */
                        long_return = VAL_snSwIfInfoSpeed_none;
                        break;
                }
            }

            *var_len = 4;
            return (u_char *) &long_return;

        /* snSwIfInfoMediaType(8)
         */
        case LEAF_snSwIfInfoMediaType:
            memset(&port_entry, 0, sizeof(port_entry));
            port_entry.port_index = lport;

            if (! SWCTRL_POM_GetPortEntry(&port_entry))
            {
                return NULL;
            }

            /* map port type to media type
             *
             * SPECIFICATION:
             * See MIB object description of Accton's "portType"
             * and Brocade's "snSwIfInfoMediaType".
             *
             * MAPPING FILE:
             * portType_20111104_NoTracking.xls
             */
            switch (port_entry.port_type)
            {
                case VAL_portType_other:
                    long_return = VAL_snSwIfInfoMediaType_other;
                    break;

                case VAL_portType_hundredBaseTX:
                    long_return = VAL_snSwIfInfoMediaType_m100BaseTX;
                    break;

                case VAL_portType_hundredBaseFX:
                    long_return = VAL_snSwIfInfoMediaType_m100BaseFX;
                    break;

                case VAL_portType_thousandBaseSX:
                    long_return = VAL_snSwIfInfoMediaType_other;
                    break;

                case VAL_portType_thousandBaseLX:
                    long_return = VAL_snSwIfInfoMediaType_other;
                    break;

                case VAL_portType_thousandBaseT:
                    long_return = VAL_snSwIfInfoMediaType_m1000BaseTX;
                    break;

                case VAL_portType_thousandBaseGBIC:
                    long_return = VAL_snSwIfInfoMediaType_other;
                    break;

                case VAL_portType_thousandBaseSfp:
                    long_return = VAL_snSwIfInfoMediaType_other;
                    break;

                case VAL_portType_hundredBaseFxScSingleMode:
                    long_return = VAL_snSwIfInfoMediaType_m100BaseFX;
                    break;

                case VAL_portType_hundredBaseFxScMultiMode:
                    long_return = VAL_snSwIfInfoMediaType_m100BaseFX;
                    break;

                case VAL_portType_thousandBaseCX:
                    long_return = VAL_snSwIfInfoMediaType_other;
                    break;

                case VAL_portType_tenG:
                    long_return = VAL_snSwIfInfoMediaType_other;
                    break;

                case VAL_portType_hundredBaseBX:
                    long_return = VAL_snSwIfInfoMediaType_other;
                    break;

                case VAL_portType_thousandBaseBX:
                    long_return = VAL_snSwIfInfoMediaType_other;
                    break;

                case VAL_portType_tenGBaseT:
                    long_return = VAL_snSwIfInfoMediaType_other;
                    break;

                case VAL_portType_tenGBaseXFP:
                    long_return = VAL_snSwIfInfoMediaType_other;
                    break;

                case VAL_portType_tenGBaseSFP:
                    long_return = VAL_snSwIfInfoMediaType_other;
                    break;

                case VAL_portType_fortyGBaseQSFP:
                    long_return = VAL_snSwIfInfoMediaType_other;
                    break;

                default:  /* should not happen */
                    long_return = VAL_snSwIfInfoMediaType_other;
                    break;
            }

            *var_len = 4;
            return (u_char *) &long_return;

        /* snSwIfInfoConnectorType(9)
         */
        case LEAF_snSwIfInfoConnectorType:
            memset(&port_entry, 0, sizeof(port_entry));
            port_entry.port_index = lport;

            if (! SWCTRL_POM_GetPortEntry(&port_entry))
            {
                return NULL;
            }

            switch (port_entry.port_type)
            {
                case VAL_portType_other:
                case VAL_portType_tenG:
                    long_return = VAL_snSwIfInfoConnectorType_other;
                    break;

                case VAL_portType_hundredBaseTX:
                case VAL_portType_thousandBaseT:
                case VAL_portType_tenGBaseT:
                    long_return = VAL_snSwIfInfoConnectorType_copper;
                    break;

                case VAL_portType_hundredBaseFX:
                case VAL_portType_thousandBaseSX:
                case VAL_portType_thousandBaseLX:
                case VAL_portType_thousandBaseGBIC:
                case VAL_portType_thousandBaseSfp:
                case VAL_portType_hundredBaseFxScSingleMode:
                case VAL_portType_hundredBaseFxScMultiMode:
                case VAL_portType_thousandBaseCX:
                case VAL_portType_hundredBaseBX:
                case VAL_portType_thousandBaseBX:
                case VAL_portType_tenGBaseXFP:
                    long_return = VAL_snSwIfInfoConnectorType_fiber;
                    break;

                default:
                    long_return = VAL_snSwIfInfoConnectorType_other;
                    break;
            }

            *var_len = 4;
            return (u_char *) &long_return;

#if 0  /* not implemented */
        case LEAF_snSwIfInfoAdminStatus:
            *var_len = 4;
            long_return = entry.snSwIfInfoAdminStatus;???
            return (u_char *) &long_return;

        case LEAF_snSwIfInfoLinkStatus:
            *var_len = 4;
            long_return = entry.snSwIfInfoLinkStatus;???
            return (u_char *) &long_return;

        case LEAF_snSwIfInfoPortQos:
            *var_len = 4;
            long_return = entry.snSwIfInfoPortQos;???
            return (u_char *) &long_return;

        case LEAF_snSwIfInfoPhysAddress:
            *var_len = SIZE_snSwIfInfoPhysAddress;
            memcpy(return_buf, entry.snSwIfInfoPhysAddress, *var_len);???
            return (u_char *) return_buf;

        case LEAF_snSwIfLockAddressCount:
            *var_len = 4;
            long_return = entry.snSwIfLockAddressCount;???
            return (u_char *) &long_return;
#endif  /* not implemented */

        /* snSwIfStpPortEnable(15)
         */
#if (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_RSTP) || (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_MSTP)
        case LEAF_snSwIfStpPortEnable:
            memset(&stp_ext_port_entry, 0, sizeof(stp_ext_port_entry));

            if (! XSTP_POM_GetDot1dMstExtPortEntry(0, lport, &stp_ext_port_entry))
            {
                return NULL;
            }

            *var_len = 4;
            long_return = FOUNDRY_LIB_ConvertAcctonToFoundryEnabledStatus
                (stp_ext_port_entry.dot1d_stp_port_spanning_tree_status);
            return (u_char *) &long_return;
#endif /* #if (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_RSTP) || (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_MSTP) */

#if 0  /* not implemented */
        case LEAF_snSwIfDhcpGateListId:
            *var_len = 4;
            long_return = entry.snSwIfDhcpGateListId;???
            return (u_char *) &long_return;

        case LEAF_snSwIfName:
            *var_len = strlen(entry.snSwIfName);???
            memcpy(return_buf, entry.snSwIfName, *var_len);???
            return (u_char *) return_buf;

        case LEAF_snSwIfDescr:
            *var_len = SIZE_snSwIfDescr;
            memcpy(return_buf, entry.snSwIfDescr, *var_len);???
            return (u_char *) return_buf;
#endif  /* not implemented */

        /* snSwIfInfoAutoNegotiate(19)
         */
        case LEAF_snSwIfInfoAutoNegotiate:
            memset(&port_entry, 0, sizeof(port_entry));
            port_entry.port_index = lport;

            /* get from core layer
             */
            if (! SWCTRL_POM_GetPortEntry(&port_entry))
            {
                return NULL;
            }

            /* convert to user value (enum, but we only support two of them) 
             */
            if (port_entry.port_autonegotiation == VAL_portAutonegotiation_enabled)
            {
                long_return = VAL_snSwIfInfoAutoNegotiate_enabled;
            }
            else
            {
                long_return = VAL_snSwIfInfoAutoNegotiate_disabled;
            }

            /* respond to user
             */
            *var_len = 4;
            return (u_char *) &long_return;

        /* snSwIfInfoFlowControl(20)
         */
        case LEAF_snSwIfInfoFlowControl:
            memset(&port_entry, 0, sizeof(port_entry));
            port_entry.port_index = lport;

            if (! SWCTRL_POM_GetPortEntry(&port_entry))
            {
                return NULL;
            }

            switch (port_entry.port_flow_ctrl_cfg)  /* enum, not EnabledStatus */
            {
                case VAL_portFlowCtrlCfg_enabled:
                    long_return = VAL_snSwIfInfoFlowControl_enabled;
                    break;

                case VAL_portFlowCtrlCfg_disabled:
                    long_return = VAL_snSwIfInfoFlowControl_disabled;
                    break;

                default:   /* should not happen */
                    long_return = VAL_snSwIfInfoFlowControl_disabled;
                    break;
            }

            *var_len = 4;
            return (u_char *) &long_return;

        /* snSwIfInfoGigType(21)
         */
        case LEAF_snSwIfInfoGigType:
            memset(&port_entry, 0, sizeof(port_entry));
            port_entry.port_index = lport;

            if (! SWCTRL_POM_GetPortEntry(&port_entry))
            {
                return NULL;
            }

            /* map port type to gigabit type
             *
             * SPECIFICATION:
             * See MIB object description of Accton's "portType"
             * and Brocade's "snSwIfInfoGigType".
             *
             * MAPPING FILE:
             * portType_20111104_NoTracking.xls
             */
            switch (port_entry.port_type)
            {
                case VAL_portType_other:
                case VAL_portType_hundredBaseTX:
                case VAL_portType_hundredBaseFX:
                    long_return = VAL_snSwIfInfoGigType_notApplicable;
                    break;

                case VAL_portType_thousandBaseSX:
                    long_return = VAL_snSwIfInfoGigType_m1000BaseSX;
                    break;

                case VAL_portType_thousandBaseLX:
                    long_return = VAL_snSwIfInfoGigType_m1000BaseLX;
                    break;

                case VAL_portType_thousandBaseT:
                    long_return = VAL_snSwIfInfoGigType_m1000BaseTX;
                    break;

                case VAL_portType_thousandBaseGBIC:
                case VAL_portType_thousandBaseSfp:
                case VAL_portType_hundredBaseFxScSingleMode:
                case VAL_portType_hundredBaseFxScMultiMode:
                case VAL_portType_thousandBaseCX:
                case VAL_portType_tenG:
                case VAL_portType_hundredBaseBX:
                case VAL_portType_thousandBaseBX:
                case VAL_portType_tenGBaseT:
                case VAL_portType_tenGBaseXFP:
                case VAL_portType_tenGBaseSFP:
                case VAL_portType_fortyGBaseQSFP:
                default:  /* should not happen */
                    long_return = VAL_snSwIfInfoGigType_notApplicable;
                    break;
            }

            *var_len = 4;
            return (u_char *) &long_return;

        /* snSwIfFastSpanPortEnable(22)
         */
        case LEAF_snSwIfFastSpanPortEnable:
            memset(&stp_ext_port_entry, 0, sizeof(stp_ext_port_entry));

            /* get from core layer
             */
            if (! XSTP_POM_GetDot1dMstExtPortEntry(0, lport, &stp_ext_port_entry))
            {
                return NULL;
            }

            /* convert to user value
             */
            switch (stp_ext_port_entry.dot1d_stp_port_admin_edge_port)
            {
                case VAL_staPortAdminEdgePortWithAuto_true:  /* only one of these ... */
                case VAL_staPortAdminEdgePortWithAuto_auto:  /* ... is settable by this node */
                    long_return = VAL_snSwIfFastSpanPortEnable_enabled;
                    break;

                case VAL_staPortAdminEdgePortWithAuto_false:
                default:  /* should not happen */
                    long_return = VAL_snSwIfFastSpanPortEnable_disabled;
                    break;
            }

            /* respond to user
             */
            *var_len = 4;
            return (u_char *) &long_return;

#if 0  /* not implemented */
        case LEAF_snSwIfFastSpanUplinkEnable:
            *var_len = 4;
            long_return = entry.snSwIfFastSpanUplinkEnable;???
            return (u_char *) &long_return;

        case LEAF_snSwIfVlanId:
            *var_len = 4;
            long_return = entry.snSwIfVlanId;???
            return (u_char *) &long_return;

        case LEAF_snSwIfRouteOnly:
            *var_len = 4;
            long_return = entry.snSwIfRouteOnly;???
            return (u_char *) &long_return;

        case LEAF_snSwIfPresent:
            *var_len = 4;
            long_return = entry.snSwIfPresent;???
            return (u_char *) &long_return;
#endif  /* not implemented */

        /* snSwIfGBICStatus(27)
         */
        case LEAF_snSwIfGBICStatus:
            {
                UI32_T unit, sfp_index;
                BOOL_T present;

                /* whether this is an SFP
                 */
                if (! FOUNDRY_LIB_GetSfpPort(lport, &unit, &sfp_index, &present))
                {
                    long_return = VAL_snSwIfGBICStatus_other;
                }

                /* if not present
                 */
                else if (! present)
                {
                    long_return = VAL_snSwIfGBICStatus_empty;
                }

                /* new it is present
                 */
                else
                {
                    long_return = VAL_snSwIfGBICStatus_miniGBIC;
                }

                /* respond to user
                 */
                *var_len = 4;
                return (u_char *) &long_return;
            }

#if 0  /* not implemented */
        case LEAF_snSwIfLoadInterval:
            *var_len = 4;
            long_return = entry.snSwIfLoadInterval;???
            return (u_char *) &long_return;

        case LEAF_snSwIfStatsInFrames:
            *var_len = 4;
            long_return = entry.snSwIfStatsInFrames;???
            return (u_char *) &long_return;

        case LEAF_snSwIfStatsOutFrames:
            *var_len = 4;
            long_return = entry.snSwIfStatsOutFrames;???
            return (u_char *) &long_return;

        case LEAF_snSwIfStatsAlignErrors:
            *var_len = 4;
            long_return = entry.snSwIfStatsAlignErrors;???
            return (u_char *) &long_return;

        case LEAF_snSwIfStatsFCSErrors:
            *var_len = 4;
            long_return = entry.snSwIfStatsFCSErrors;???
            return (u_char *) &long_return;

        case LEAF_snSwIfStatsMultiColliFrames:
            *var_len = 4;
            long_return = entry.snSwIfStatsMultiColliFrames;???
            return (u_char *) &long_return;

        case LEAF_snSwIfStatsTxColliFrames:
            *var_len = 4;
            long_return = entry.snSwIfStatsTxColliFrames;???
            return (u_char *) &long_return;

        case LEAF_snSwIfStatsRxColliFrames:
            *var_len = 4;
            long_return = entry.snSwIfStatsRxColliFrames;???
            return (u_char *) &long_return;

        case LEAF_snSwIfStatsFrameTooLongs:
            *var_len = 4;
            long_return = entry.snSwIfStatsFrameTooLongs;???
            return (u_char *) &long_return;

        case LEAF_snSwIfStatsFrameTooShorts:
            *var_len = 4;
            long_return = entry.snSwIfStatsFrameTooShorts;???
            return (u_char *) &long_return;

        case LEAF_snSwIfStatsInBcastFrames:
            *var_len = 4;
            long_return = entry.snSwIfStatsInBcastFrames;???
            return (u_char *) &long_return;

        case LEAF_snSwIfStatsOutBcastFrames:
            *var_len = 4;
            long_return = entry.snSwIfStatsOutBcastFrames;???
            return (u_char *) &long_return;

        case LEAF_snSwIfStatsInMcastFrames:
            *var_len = 4;
            long_return = entry.snSwIfStatsInMcastFrames;???
            return (u_char *) &long_return;

        case LEAF_snSwIfStatsOutMcastFrames:
            *var_len = 4;
            long_return = entry.snSwIfStatsOutMcastFrames;???
            return (u_char *) &long_return;

        case LEAF_snSwIfStatsInDiscard:
            *var_len = 4;
            long_return = entry.snSwIfStatsInDiscard;???
            return (u_char *) &long_return;

        case LEAF_snSwIfStatsOutDiscard:
            *var_len = 4;
            long_return = entry.snSwIfStatsOutDiscard;???
            return (u_char *) &long_return;
#endif

        /* snSwIfStatsMacStations(44)
         */
        case LEAF_snSwIfStatsMacStations:
            *var_len = 4;
            long_return = AMTR_OM_GetDynCounterByPort(lport);
            return (u_char *) &long_return;

#if 0  /* not implemented */
        case LEAF_snSwIfStatsLinkChange:
            *var_len = 4;
            long_return = entry.snSwIfStatsLinkChange;???
            return (u_char *) &long_return;

        case LEAF_snSwIfInOctets:
            *var_len = 8;
            SNMP_MGR_UI64_T_TO_COUNTER64(long64_return, entry.snSwIfInOctets);???
            return (u_char *) &long64_return;

        case LEAF_snSwIfOutOctets:
            *var_len = 8;
            SNMP_MGR_UI64_T_TO_COUNTER64(long64_return, entry.snSwIfOutOctets);???
            return (u_char *) &long64_return;

        case LEAF_snSwIfStatsInBitsPerSec:
            *var_len = 4;
            long_return = entry.snSwIfStatsInBitsPerSec;???
            return (u_char *) &long_return;

        case LEAF_snSwIfStatsOutBitsPerSec:
            *var_len = 4;
            long_return = entry.snSwIfStatsOutBitsPerSec;???
            return (u_char *) &long_return;

        case LEAF_snSwIfStatsInPktsPerSec:
            *var_len = 4;
            long_return = entry.snSwIfStatsInPktsPerSec;???
            return (u_char *) &long_return;

        case LEAF_snSwIfStatsOutPktsPerSec:
            *var_len = 4;
            long_return = entry.snSwIfStatsOutPktsPerSec;???
            return (u_char *) &long_return;

        case LEAF_snSwIfStatsInUtilization:
            *var_len = 4;
            long_return = entry.snSwIfStatsInUtilization;???
            return (u_char *) &long_return;

        case LEAF_snSwIfStatsOutUtilization:
            *var_len = 4;
            long_return = entry.snSwIfStatsOutUtilization;???
            return (u_char *) &long_return;

        case LEAF_snSwIfStatsInKiloBitsPerSec:
            *var_len = 4;
            long_return = entry.snSwIfStatsInKiloBitsPerSec;???
            return (u_char *) &long_return;

        case LEAF_snSwIfStatsOutKiloBitsPerSec:
            *var_len = 4;
            long_return = entry.snSwIfStatsOutKiloBitsPerSec;???
            return (u_char *) &long_return;

        case LEAF_snSwIfStatsInJumboFrames:
            *var_len = 8;
            SNMP_MGR_UI64_T_TO_COUNTER64(long64_return, entry.snSwIfStatsInJumboFrames);???
            return (u_char *) &long64_return;

        case LEAF_snSwIfStatsOutJumboFrames:
            *var_len = 8;
            SNMP_MGR_UI64_T_TO_COUNTER64(long64_return, entry.snSwIfStatsOutJumboFrames);???
            return (u_char *) &long64_return;

        case LEAF_snSwIfInfoMirrorMode:
            *var_len = 4;
            long_return = entry.snSwIfInfoMirrorMode;???
            return (u_char *) &long_return;

        case LEAF_snSwIfMacLearningDisable:
            *var_len = 4;
            long_return = entry.snSwIfMacLearningDisable;???
            return (u_char *) &long_return;
#endif  /* not implemented */

        default:
            ERROR_MSG("");
            break;
    }

    /* return failure
     */
    return NULL;
}

#if 0  /* deprecated */
int write_snSwIfInfoMonitorMode(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    /* dispatch action
     */
    switch (action)
    {
        case RESERVE1:
            /* check type and length
             */
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            /* check valid values
             */
            switch (*(long *) var_val)
            {
                case VAL_snSwIfInfoMonitorMode_disabled:
                    break;

                case VAL_snSwIfInfoMonitorMode_input:
                    break;

                case VAL_snSwIfInfoMonitorMode_output:
                    break;

                case VAL_snSwIfInfoMonitorMode_both:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = 14;
            I32_T value = 0;

            /* table-specific variables
             */
            UI32_T snSwIfInfoPortNum = 0;

            /* extract index
             */
            if (! snSwIfInfoTable_OidIndexToData(TRUE,
                name_len - oid_name_length,
                &(name[oid_name_length]),
                &snSwIfInfoPortNum))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            /* get user value
             */
            memcpy(&value, var_val, sizeof(I32_T));

            /* set to core layer
             */
            if (XXX_MGR_SetSnSwIfInfoMonitorMode(snSwIfInfoPortNum, value) != TRUE??? )
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    /* return success
     */
    return SNMP_ERR_NOERROR;
}
#endif

#if 0  /* not implemented */
int write_snSwIfInfoMirrorPorts(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    /* dispatch action
     */
    switch (action)
    {
        case RESERVE1:
            /* check type and length
             */
            if (var_val_type != ASN_OCTET_STR)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len != SIZE_snSwIfInfoMirrorPorts)
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;

        case RESERVE2:
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = 14;
            UI8_T byte_buffer[MAXSIZE_snSwIfInfoMirrorPorts + 1] = {0};

            /* table-specific variables
             */
            UI32_T snSwIfInfoPortNum = 0;

            /* extract index
             */
            if (! snSwIfInfoTable_OidIndexToData(TRUE,
                name_len - oid_name_length,
                &(name[oid_name_length]),
                &snSwIfInfoPortNum))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            /* get user value
             */
            memcpy(byte_buffer, var_val, var_val_len);

            /* set to core layer
             */
            if (XXX_MGR_SetSnSwIfInfoMirrorPorts(snSwIfInfoPortNum, byte_buffer) != TRUE??? )
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    /* return success
     */
    return SNMP_ERR_NOERROR;
}
#endif

int write_snSwIfInfoTagMode(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    /* dispatch action
     */
    switch (action)
    {
        case RESERVE1:
            /* check type and length
             */
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            /* check valid values
             */
            switch (*(long *) var_val)
            {
                case VAL_snSwIfInfoTagMode_tagged:
                    break;

                case VAL_snSwIfInfoTagMode_untagged:
                    break;

                case VAL_snSwIfInfoTagMode_dual:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = 14;
            I32_T value = 0;

            /* table-specific variables
             */
            UI32_T snSwIfInfoPortNum = 0;
            UI32_T core_val = 0;

            /* extract index
             */
            if (! snSwIfInfoTable_OidIndexToData(TRUE,
                name_len - oid_name_length,
                &(name[oid_name_length]),
                &snSwIfInfoPortNum))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            /* get user value
             */
            memcpy(&value, var_val, sizeof(I32_T));

            /* convert to core-layer value
             */
            switch (*(long *) var_val)
            {
                case VAL_snSwIfInfoTagMode_tagged:
                    core_val = VAL_vlanPortMode_dot1qTrunk;
                    break;

                case VAL_snSwIfInfoTagMode_untagged:
                    core_val = VAL_vlanPortMode_access;
                    break;

                case VAL_snSwIfInfoTagMode_dual:  /* hybrid or double-tagged? */
                    core_val = VAL_vlanPortMode_hybrid;
                    break;

                default:  /* should not happen */
                    return SNMP_ERR_WRONGVALUE;
            }

            /* set to core layer
             */
            if (! VLAN_PMGR_SetVlanPortMode(snSwIfInfoPortNum, core_val))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    /* return success
     */
    return SNMP_ERR_NOERROR;
}

int write_snSwIfInfoTagType(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    /* dispatch action
     */
    switch (action)
    {
        case RESERVE1:
            /* check type and length
             */
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            /* check valid values
             */
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = 14;
#if 0  /* not supported; ignore */
            I32_T value = 0;
#endif

            /* table-specific variables
             */
            UI32_T snSwIfInfoPortNum = 0;

            /* extract index
             */
            if (! snSwIfInfoTable_OidIndexToData(TRUE,
                name_len - oid_name_length,
                &(name[oid_name_length]),
                &snSwIfInfoPortNum))
            {
                return SNMP_ERR_COMMITFAILED;
            }

#if 0  /* not supported; ignore */
            /* get user value
             */
            memcpy(&value, var_val, sizeof(I32_T));

            /* set to core layer
             */
            if (XXX_MGR_SetSnSwIfInfoTagType(snSwIfInfoPortNum, value) != TRUE??? )
            {
                return SNMP_ERR_COMMITFAILED;
            }
#endif

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    /* return success
     */
    return SNMP_ERR_NOERROR;
}

int write_snSwIfInfoChnMode(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    /* dispatch action
     */
    switch (action)
    {
        case RESERVE1:
            /* check type and length
             */
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            /* check valid values
             */
            switch (*(long *) var_val)
            {
                case VAL_snSwIfInfoChnMode_none:
                    break;

                case VAL_snSwIfInfoChnMode_halfDuplex:
                    break;

                case VAL_snSwIfInfoChnMode_fullDuplex:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = 14;
            I32_T value = 0;

            /* table-specific variables
             */
            UI32_T snSwIfInfoPortNum;
            SWCTRL_PortEntry_T port_entry;  /* portTable */
            UI32_T core_val = 0;

            /* extract index
             */
            if (! snSwIfInfoTable_OidIndexToData(TRUE,
                name_len - oid_name_length,
                &(name[oid_name_length]),
                &snSwIfInfoPortNum))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            /* get user value
             */
            memcpy(&value, var_val, sizeof(I32_T));

            /* read current mode and combine with user mode
             */
            memset(&port_entry, 0, sizeof(port_entry));
            port_entry.port_index = snSwIfInfoPortNum;

            if (! SWCTRL_POM_GetPortEntry(&port_entry))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            /* dispatch new duplex mode
             */
            switch (value)
            {
                /* none
                 */
                case VAL_snSwIfInfoChnMode_none:
                    return SNMP_ERR_WRONGVALUE;

                /* half duplex
                 */
                case VAL_snSwIfInfoChnMode_halfDuplex:

                    /* extract old speed
                     */
                    switch (port_entry.port_speed_dpx_cfg)
                    {
                        case VAL_portSpeedDpxCfg_reserved:
                            return SNMP_ERR_COMMITFAILED;

                        case VAL_portSpeedDpxCfg_halfDuplex10:
                        case VAL_portSpeedDpxCfg_halfDuplex100:
                        case VAL_portSpeedDpxCfg_halfDuplex1000:
                        case VAL_portSpeedDpxCfg_halfDuplex10g:
                            core_val = port_entry.port_speed_dpx_cfg;
                            break;

                        case VAL_portSpeedDpxCfg_fullDuplex10:
                            core_val = VAL_portSpeedDpxCfg_halfDuplex10;
                            break;

                        case VAL_portSpeedDpxCfg_fullDuplex100:
                            core_val = VAL_portSpeedDpxCfg_halfDuplex100;
                            break;

                        case VAL_portSpeedDpxCfg_fullDuplex1000:
                            core_val = VAL_portSpeedDpxCfg_halfDuplex1000;
                            break;

                        case VAL_portSpeedDpxCfg_fullDuplex10g:
                            core_val = VAL_portSpeedDpxCfg_halfDuplex10g;
                            break;

                        default:  /* should not happen */
                            return SNMP_ERR_COMMITFAILED;
                    }  /* switch (port_entry.port_speed_dpx_cfg): old port mode */

                    break;

                /* full duplex
                 */
                case VAL_snSwIfInfoChnMode_fullDuplex:

                    /* extract old speed
                     */
                    switch (port_entry.port_speed_dpx_cfg)
                    {
                        case VAL_portSpeedDpxCfg_reserved:
                            return SNMP_ERR_COMMITFAILED;

                        case VAL_portSpeedDpxCfg_halfDuplex10:
                            core_val = VAL_portSpeedDpxCfg_fullDuplex10;
                            break;

                        case VAL_portSpeedDpxCfg_halfDuplex100:
                            core_val = VAL_portSpeedDpxCfg_fullDuplex100;
                            break;

                        case VAL_portSpeedDpxCfg_halfDuplex1000:
                            core_val = VAL_portSpeedDpxCfg_fullDuplex1000;
                            break;

                        case VAL_portSpeedDpxCfg_halfDuplex10g:
                            core_val = VAL_portSpeedDpxCfg_fullDuplex10g;
                            break;

                        case VAL_portSpeedDpxCfg_fullDuplex10:
                        case VAL_portSpeedDpxCfg_fullDuplex100:
                        case VAL_portSpeedDpxCfg_fullDuplex1000:
                        case VAL_portSpeedDpxCfg_fullDuplex10g:
                            core_val = port_entry.port_speed_dpx_cfg;
                            break;

                        default:  /* should not happen */
                            return SNMP_ERR_COMMITFAILED;
                    }  /* switch (port_entry.port_speed_dpx_cfg) */

                    break;

                /* unrecognised; should not happen
                 */
                default: 
                    return SNMP_ERR_WRONGVALUE;
            }
       
            /* set to core layer
             */
            if (! SWCTRL_PMGR_SetPortSpeedDpxCfg(snSwIfInfoPortNum, core_val))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    /* return success
     */
    return SNMP_ERR_NOERROR;
}

int write_snSwIfInfoSpeed(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    /* dispatch action
     */
    switch (action)
    {
        case RESERVE1:
            /* check type and length
             */
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            /* check valid values
             */
            switch (*(long *) var_val)
            {
                case VAL_snSwIfInfoSpeed_none:
                    break;

                case VAL_snSwIfInfoSpeed_sAutoSense:
                    break;

                case VAL_snSwIfInfoSpeed_s10M:
                    break;

                case VAL_snSwIfInfoSpeed_s100M:
                    break;

                case VAL_snSwIfInfoSpeed_s1G:
                    break;

                case VAL_snSwIfInfoSpeed_s1GM:
                    break;

                case VAL_snSwIfInfoSpeed_s155M:
                    break;

                case VAL_snSwIfInfoSpeed_s10G:
                    break;

                case VAL_snSwIfInfoSpeed_s622M:
                    break;

                case VAL_snSwIfInfoSpeed_s2488M:
                    break;

                case VAL_snSwIfInfoSpeed_s9953M:
                    break;

                case VAL_snSwIfInfoSpeed_s16G:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = 14;
            I32_T value = 0;

            /* table-specific variables
             */
            UI32_T snSwIfInfoPortNum;
            SWCTRL_PortEntry_T port_entry;  /* portTable */
            UI32_T core_val;

            /* extract index
             */
            if (! snSwIfInfoTable_OidIndexToData(TRUE,
                name_len - oid_name_length,
                &(name[oid_name_length]),
                &snSwIfInfoPortNum))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            /* get user value
             */
            memcpy(&value, var_val, sizeof(I32_T));

            /* read current mode and combine with user mode
             */
            memset(&port_entry, 0, sizeof(port_entry));
            port_entry.port_index = snSwIfInfoPortNum;

            if (! SWCTRL_POM_GetPortEntry(&port_entry))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            /* dispatch new speed
             */
            switch (value)
            {
                case VAL_snSwIfInfoSpeed_s10M:

                    /* extract old duplex mode
                     */
                    switch (port_entry.port_speed_dpx_cfg)
                    {
                        case VAL_portSpeedDpxCfg_reserved:
                            return SNMP_ERR_COMMITFAILED;

                        case VAL_portSpeedDpxCfg_halfDuplex10:
                        case VAL_portSpeedDpxCfg_halfDuplex100:
                        case VAL_portSpeedDpxCfg_halfDuplex1000:
                        case VAL_portSpeedDpxCfg_halfDuplex10g:
                            core_val = VAL_portSpeedDpxCfg_halfDuplex10;
                            break;

                        case VAL_portSpeedDpxCfg_fullDuplex10:
                        case VAL_portSpeedDpxCfg_fullDuplex100:
                        case VAL_portSpeedDpxCfg_fullDuplex1000:
                        case VAL_portSpeedDpxCfg_fullDuplex10g:
                            core_val = VAL_portSpeedDpxCfg_fullDuplex10;
                            break;

                        default:  /* should not happen */
                            return SNMP_ERR_COMMITFAILED;
                    }  /* switch (port_entry.port_speed_dpx_cfg): old port mode */

                    break;

                case VAL_snSwIfInfoSpeed_s100M:

                    /* extract old duplex mode
                     */
                    switch (port_entry.port_speed_dpx_cfg)
                    {
                        case VAL_portSpeedDpxCfg_reserved:
                            return SNMP_ERR_COMMITFAILED;

                        case VAL_portSpeedDpxCfg_halfDuplex10:
                        case VAL_portSpeedDpxCfg_halfDuplex100:
                        case VAL_portSpeedDpxCfg_halfDuplex1000:
                        case VAL_portSpeedDpxCfg_halfDuplex10g:
                            core_val = VAL_portSpeedDpxCfg_halfDuplex100;
                            break;

                        case VAL_portSpeedDpxCfg_fullDuplex10:
                        case VAL_portSpeedDpxCfg_fullDuplex100:
                        case VAL_portSpeedDpxCfg_fullDuplex1000:
                        case VAL_portSpeedDpxCfg_fullDuplex10g:
                            core_val = VAL_portSpeedDpxCfg_fullDuplex100;
                            break;

                        default:  /* should not happen */
                            return SNMP_ERR_COMMITFAILED;
                    }  /* switch (port_entry.port_speed_dpx_cfg): old port mode */

                    break;

                case VAL_snSwIfInfoSpeed_s1G:

                    /* extract old duplex mode
                     */
                    switch (port_entry.port_speed_dpx_cfg)
                    {
                        case VAL_portSpeedDpxCfg_reserved:
                            return SNMP_ERR_COMMITFAILED;

                        case VAL_portSpeedDpxCfg_halfDuplex10:
                        case VAL_portSpeedDpxCfg_halfDuplex100:
                        case VAL_portSpeedDpxCfg_halfDuplex1000:
                        case VAL_portSpeedDpxCfg_halfDuplex10g:
                            core_val = VAL_portSpeedDpxCfg_halfDuplex1000;
                            break;

                        case VAL_portSpeedDpxCfg_fullDuplex10:
                        case VAL_portSpeedDpxCfg_fullDuplex100:
                        case VAL_portSpeedDpxCfg_fullDuplex1000:
                        case VAL_portSpeedDpxCfg_fullDuplex10g:
                            core_val = VAL_portSpeedDpxCfg_fullDuplex1000;
                            break;

                        default:  /* should not happen */
                            return SNMP_ERR_COMMITFAILED;
                    }  /* switch (port_entry.port_speed_dpx_cfg): old port mode */

                    break;

                case VAL_snSwIfInfoSpeed_s10G:

                    /* extract old duplex mode
                     */
                    switch (port_entry.port_speed_dpx_cfg)
                    {
                        case VAL_portSpeedDpxCfg_reserved:
                            return SNMP_ERR_COMMITFAILED;

                        case VAL_portSpeedDpxCfg_halfDuplex10:
                        case VAL_portSpeedDpxCfg_halfDuplex100:
                        case VAL_portSpeedDpxCfg_halfDuplex1000:
                        case VAL_portSpeedDpxCfg_halfDuplex10g:
                            core_val = VAL_portSpeedDpxCfg_halfDuplex10g;
                            break;

                        case VAL_portSpeedDpxCfg_fullDuplex10:
                        case VAL_portSpeedDpxCfg_fullDuplex100:
                        case VAL_portSpeedDpxCfg_fullDuplex1000:
                        case VAL_portSpeedDpxCfg_fullDuplex10g:
                            core_val = VAL_portSpeedDpxCfg_fullDuplex10g;
                            break;

                        default:  /* should not happen */
                            return SNMP_ERR_COMMITFAILED;
                    }  /* switch (port_entry.port_speed_dpx_cfg): old port mode */

                    break;

                default:  /* includes other enums and unrecognised values */
                    return SNMP_ERR_WRONGVALUE;
            }
       
            /* set to core layer
             */
            if (! SWCTRL_PMGR_SetPortSpeedDpxCfg(snSwIfInfoPortNum, core_val))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    /* return success
     */
    return SNMP_ERR_NOERROR;
}

#if 0  /* not implemented */
int write_snSwIfInfoAdminStatus(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    /* dispatch action
     */
    switch (action)
    {
        case RESERVE1:
            /* check type and length
             */
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            /* check valid values
             */
            switch (*(long *) var_val)
            {
                case VAL_snSwIfInfoAdminStatus_up:
                    break;

                case VAL_snSwIfInfoAdminStatus_down:
                    break;

                case VAL_snSwIfInfoAdminStatus_testing:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = 14;
            I32_T value = 0;

            /* table-specific variables
             */
            UI32_T snSwIfInfoPortNum = 0;

            /* extract index
             */
            if (! snSwIfInfoTable_OidIndexToData(TRUE,
                name_len - oid_name_length,
                &(name[oid_name_length]),
                &snSwIfInfoPortNum))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            /* get user value
             */
            memcpy(&value, var_val, sizeof(I32_T));

            /* set to core layer
             */
            if (XXX_MGR_SetSnSwIfInfoAdminStatus(snSwIfInfoPortNum, value) != TRUE??? )
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    /* return success
     */
    return SNMP_ERR_NOERROR;
}

int write_snSwIfInfoPortQos(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    /* dispatch action
     */
    switch (action)
    {
        case RESERVE1:
            /* check type and length
             */
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            /* check valid values
             */
            switch (*(long *) var_val)
            {
                case VAL_snSwIfInfoPortQos_level0:
                    break;

                case VAL_snSwIfInfoPortQos_level1:
                    break;

                case VAL_snSwIfInfoPortQos_level2:
                    break;

                case VAL_snSwIfInfoPortQos_level3:
                    break;

                case VAL_snSwIfInfoPortQos_level4:
                    break;

                case VAL_snSwIfInfoPortQos_level5:
                    break;

                case VAL_snSwIfInfoPortQos_level6:
                    break;

                case VAL_snSwIfInfoPortQos_level7:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = 14;
            I32_T value = 0;

            /* table-specific variables
             */
            UI32_T snSwIfInfoPortNum = 0;

            /* extract index
             */
            if (! snSwIfInfoTable_OidIndexToData(TRUE,
                name_len - oid_name_length,
                &(name[oid_name_length]),
                &snSwIfInfoPortNum))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            /* get user value
             */
            memcpy(&value, var_val, sizeof(I32_T));

            /* set to core layer
             */
            if (XXX_MGR_SetSnSwIfInfoPortQos(snSwIfInfoPortNum, value) != TRUE??? )
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    /* return success
     */
    return SNMP_ERR_NOERROR;
}

int write_snSwIfLockAddressCount(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    /* dispatch action
     */
    switch (action)
    {
        case RESERVE1:
            /* check type and length
             */
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            /* check valid values
             */
            if ((*(long *) var_val < MIN_snSwIfLockAddressCount)
                || (*(long *) var_val > MAX_snSwIfLockAddressCount))
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = 14;
            I32_T value = 0;

            /* table-specific variables
             */
            UI32_T snSwIfInfoPortNum = 0;

            /* extract index
             */
            if (! snSwIfInfoTable_OidIndexToData(TRUE,
                name_len - oid_name_length,
                &(name[oid_name_length]),
                &snSwIfInfoPortNum))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            /* get user value
             */
            memcpy(&value, var_val, sizeof(I32_T));

            /* set to core layer
             */
            if (XXX_MGR_SetSnSwIfLockAddressCount(snSwIfInfoPortNum, value) != TRUE??? )
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    /* return success
     */
    return SNMP_ERR_NOERROR;
}
#endif

int write_snSwIfStpPortEnable(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    /* dispatch action
     */
    switch (action)
    {
        case RESERVE1:
            /* check type and length
             */
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            /* check valid values
             */
            switch (*(long *) var_val)
            {
                case VAL_snSwIfStpPortEnable_disabled:
                    break;

                case VAL_snSwIfStpPortEnable_enabled:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = 14;
            I32_T value = 0;

            /* table-specific variables
             */
            UI32_T snSwIfInfoPortNum = 0;
            UI32_T core_val;

            /* extract index
             */
            if (! snSwIfInfoTable_OidIndexToData(TRUE,
                name_len - oid_name_length,
                &(name[oid_name_length]),
                &snSwIfInfoPortNum))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            /* get user value
             */
            memcpy(&value, var_val, sizeof(I32_T));

            /* convert to core-layer value
             */
            core_val = FOUNDRY_LIB_ConvertFoundryToAcctonEnabledStatus(value);

            /* set to core layer
             */
            if (XSTP_PMGR_SetPortSpanningTreeStatus(snSwIfInfoPortNum, core_val) != XSTP_TYPE_RETURN_OK)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    /* return success
     */
    return SNMP_ERR_NOERROR;
}

#if 0  /* not implemented */
int write_snSwIfDhcpGateListId(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    /* dispatch action
     */
    switch (action)
    {
        case RESERVE1:
            /* check type and length
             */
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            /* check valid values
             */
            if ((*(long *) var_val < MIN_snSwIfDhcpGateListId)
                || (*(long *) var_val > MAX_snSwIfDhcpGateListId))
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = 14;
            I32_T value = 0;

            /* table-specific variables
             */
            UI32_T snSwIfInfoPortNum = 0;

            /* extract index
             */
            if (! snSwIfInfoTable_OidIndexToData(TRUE,
                name_len - oid_name_length,
                &(name[oid_name_length]),
                &snSwIfInfoPortNum))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            /* get user value
             */
            memcpy(&value, var_val, sizeof(I32_T));

            /* set to core layer
             */
            if (XXX_MGR_SetSnSwIfDhcpGateListId(snSwIfInfoPortNum, value) != TRUE??? )
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    /* return success
     */
    return SNMP_ERR_NOERROR;
}

int write_snSwIfName(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    /* dispatch action
     */
    switch (action)
    {
        case RESERVE1:
            /* check type and length
             */
            if (var_val_type != ASN_OCTET_STR)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if ((var_val_len < MINSIZE_snSwIfName)
                || (var_val_len > MAXSIZE_snSwIfName))
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;

        case RESERVE2:
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = 14;
            UI8_T byte_buffer[MAXSIZE_snSwIfName + 1] = {0};

            /* table-specific variables
             */
            UI32_T snSwIfInfoPortNum = 0;

            /* extract index
             */
            if (! snSwIfInfoTable_OidIndexToData(TRUE,
                name_len - oid_name_length,
                &(name[oid_name_length]),
                &snSwIfInfoPortNum))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            /* get user value
             */
            memcpy(byte_buffer, var_val, var_val_len);

            byte_buffer[var_val_len] = '\0';

            /* set to core layer
             */
            if (XXX_MGR_SetSnSwIfName(snSwIfInfoPortNum, byte_buffer, var_val_len) != TRUE??? )
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    /* return success
     */
    return SNMP_ERR_NOERROR;
}
#endif

int write_snSwIfInfoAutoNegotiate(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    /* dispatch action
     */
    switch (action)
    {
        case RESERVE1:
            /* check type and length
             */
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            /* check valid values
             */
            switch (*(long *) var_val)
            {
                case VAL_snSwIfInfoAutoNegotiate_disabled:
                    break;

                case VAL_snSwIfInfoAutoNegotiate_enabled:
                    break;

                case VAL_snSwIfInfoAutoNegotiate_negFullAuto:
                    break;

                case VAL_snSwIfInfoAutoNegotiate_global:
                    break;

                case VAL_snSwIfInfoAutoNegotiate_other:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = 14;
            I32_T value = 0;

            /* table-specific variables
             */
            UI32_T snSwIfInfoPortNum = 0;
            UI32_T core_val = 0;

            /* extract index
             */
            if (! snSwIfInfoTable_OidIndexToData(TRUE,
                name_len - oid_name_length,
                &(name[oid_name_length]),
                &snSwIfInfoPortNum))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            /* get user value
             */
            memcpy(&value, var_val, sizeof(I32_T));

            /* convert to core-layer value
             */
            switch (*(long *) var_val)
            {
                case VAL_snSwIfInfoAutoNegotiate_disabled:
                    core_val = VAL_portAutonegotiation_disabled;
                    break;

                case VAL_snSwIfInfoAutoNegotiate_enabled:
                    core_val = VAL_portAutonegotiation_enabled;
                    break;

                case VAL_snSwIfInfoAutoNegotiate_negFullAuto:
                case VAL_snSwIfInfoAutoNegotiate_global:
                case VAL_snSwIfInfoAutoNegotiate_other:
                default:
                    return SNMP_ERR_WRONGVALUE;
            }

            /* set to core layer
             */
            if (! SWCTRL_PMGR_SetPortAutonegotiation(snSwIfInfoPortNum, core_val))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    /* return success
     */
    return SNMP_ERR_NOERROR;
}

int write_snSwIfInfoFlowControl(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    /* dispatch action
     */
    switch (action)
    {
        case RESERVE1:
            /* check type and length
             */
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            /* check valid values
             */
            switch (*(long *) var_val)
            {
                case VAL_snSwIfInfoFlowControl_disabled:
                    break;

                case VAL_snSwIfInfoFlowControl_enabled:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = 14;
            I32_T value = 0;

            /* table-specific variables
             */
            UI32_T snSwIfInfoPortNum = 0;
            UI32_T core_val = 0;

            /* extract index
             */
            if (! snSwIfInfoTable_OidIndexToData(TRUE,
                name_len - oid_name_length,
                &(name[oid_name_length]),
                &snSwIfInfoPortNum))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            /* get user value
             */
            memcpy(&value, var_val, sizeof(I32_T));

            /* convert to core-layer value
             */
            core_val = FOUNDRY_LIB_ConvertFoundryToAcctonEnabledStatus(value);

            /* set to core layer
             */
            if (! SWCTRL_PMGR_SetPortFlowCtrlCfg(snSwIfInfoPortNum, core_val))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    /* return success
     */
    return SNMP_ERR_NOERROR;
}

int write_snSwIfFastSpanPortEnable(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    /* dispatch action
     */
    switch (action)
    {
        case RESERVE1:
            /* check type and length
             */
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            /* check valid values
             */
            switch (*(long *) var_val)
            {
                case VAL_snSwIfFastSpanPortEnable_disabled:
                    break;

                case VAL_snSwIfFastSpanPortEnable_enabled:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = 14;
            I32_T value = 0;

            /* table-specific variables
             */
            UI32_T snSwIfInfoPortNum = 0;
            UI32_T core_val = 0;

            /* extract index
             */
            if (! snSwIfInfoTable_OidIndexToData(TRUE,
                name_len - oid_name_length,
                &(name[oid_name_length]),
                &snSwIfInfoPortNum))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            /* get user value
             */
            memcpy(&value, var_val, sizeof(I32_T));

            /* convert to core-layer value (only two modes are settable by this node)
             */
            switch (*(long *) var_val)
            {
                case VAL_snSwIfFastSpanPortEnable_disabled:
                    core_val = VAL_staPortAdminEdgePortWithAuto_false;
                    break;

                case VAL_snSwIfFastSpanPortEnable_enabled:
#if (SYS_DFLT_STP_PORT_ADMIN_EDGE_PORT == VAL_staPortAdminEdgePortWithAuto_auto)
                    core_val = VAL_staPortAdminEdgePortWithAuto_auto;
#else  /* here, if default is disabled or enabled */
                    core_val = VAL_staPortAdminEdgePortWithAuto_true;
#endif
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }

            /* set to core layer
             */
            if (XSTP_PMGR_SetPortAdminEdgePort(snSwIfInfoPortNum, core_val) != XSTP_TYPE_RETURN_OK)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    /* return success
     */
    return SNMP_ERR_NOERROR;
}

#if 0  /* not implemented */
int write_snSwIfFastSpanUplinkEnable(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    /* dispatch action
     */
    switch (action)
    {
        case RESERVE1:
            /* check type and length
             */
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            /* check valid values
             */
            switch (*(long *) var_val)
            {
                case VAL_snSwIfFastSpanUplinkEnable_disabled:
                    break;

                case VAL_snSwIfFastSpanUplinkEnable_enabled:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = 14;
            I32_T value = 0;

            /* table-specific variables
             */
            UI32_T snSwIfInfoPortNum = 0;

            /* extract index
             */
            if (! snSwIfInfoTable_OidIndexToData(TRUE,
                name_len - oid_name_length,
                &(name[oid_name_length]),
                &snSwIfInfoPortNum))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            /* get user value
             */
            memcpy(&value, var_val, sizeof(I32_T));

            /* set to core layer
             */
            if (XXX_MGR_SetSnSwIfFastSpanUplinkEnable(snSwIfInfoPortNum, value) != TRUE??? )
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    /* return success
     */
    return SNMP_ERR_NOERROR;
}

int write_snSwIfVlanId(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    /* dispatch action
     */
    switch (action)
    {
        case RESERVE1:
            /* check type and length
             */
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            /* check valid values
             */
            if ((*(long *) var_val < MIN_snSwIfVlanId)
                || (*(long *) var_val > MAX_snSwIfVlanId))
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = 14;
            I32_T value = 0;

            /* table-specific variables
             */
            UI32_T snSwIfInfoPortNum = 0;

            /* extract index
             */
            if (! snSwIfInfoTable_OidIndexToData(TRUE,
                name_len - oid_name_length,
                &(name[oid_name_length]),
                &snSwIfInfoPortNum))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            /* get user value
             */
            memcpy(&value, var_val, sizeof(I32_T));

            /* set to core layer
             */
            if (XXX_MGR_SetSnSwIfVlanId(snSwIfInfoPortNum, value) != TRUE??? )
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    /* return success
     */
    return SNMP_ERR_NOERROR;
}

int write_snSwIfRouteOnly(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    /* dispatch action
     */
    switch (action)
    {
        case RESERVE1:
            /* check type and length
             */
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            /* check valid values
             */
            switch (*(long *) var_val)
            {
                case VAL_snSwIfRouteOnly_disabled:
                    break;

                case VAL_snSwIfRouteOnly_enabled:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = 14;
            I32_T value = 0;

            /* table-specific variables
             */
            UI32_T snSwIfInfoPortNum = 0;

            /* extract index
             */
            if (! snSwIfInfoTable_OidIndexToData(TRUE,
                name_len - oid_name_length,
                &(name[oid_name_length]),
                &snSwIfInfoPortNum))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            /* get user value
             */
            memcpy(&value, var_val, sizeof(I32_T));

            /* set to core layer
             */
            if (XXX_MGR_SetSnSwIfRouteOnly(snSwIfInfoPortNum, value) != TRUE??? )
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    /* return success
     */
    return SNMP_ERR_NOERROR;
}

int write_snSwIfLoadInterval(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    /* dispatch action
     */
    switch (action)
    {
        case RESERVE1:
            /* check type and length
             */
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            /* check valid values
             */
            if ((*(long *) var_val < MIN_snSwIfLoadInterval)
                || (*(long *) var_val > MAX_snSwIfLoadInterval))
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = 14;
            I32_T value = 0;

            /* table-specific variables
             */
            UI32_T snSwIfInfoPortNum = 0;

            /* extract index
             */
            if (! snSwIfInfoTable_OidIndexToData(TRUE,
                name_len - oid_name_length,
                &(name[oid_name_length]),
                &snSwIfInfoPortNum))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            /* get user value
             */
            memcpy(&value, var_val, sizeof(I32_T));

            /* set to core layer
             */
            if (XXX_MGR_SetSnSwIfLoadInterval(snSwIfInfoPortNum, value) != TRUE??? )
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    /* return success
     */
    return SNMP_ERR_NOERROR;
}

int write_snSwIfInfoMirrorMode(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    /* dispatch action
     */
    switch (action)
    {
        case RESERVE1:
            /* check type and length
             */
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            /* check valid values
             */
            switch (*(long *) var_val)
            {
                case VAL_snSwIfInfoMirrorMode_disable:
                    break;

                case VAL_snSwIfInfoMirrorMode_enable:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = 14;
            I32_T value = 0;

            /* table-specific variables
             */
            UI32_T snSwIfInfoPortNum = 0;

            /* extract index
             */
            if (! snSwIfInfoTable_OidIndexToData(TRUE,
                name_len - oid_name_length,
                &(name[oid_name_length]),
                &snSwIfInfoPortNum))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            /* get user value
             */
            memcpy(&value, var_val, sizeof(I32_T));

            /* set to core layer
             */
            if (XXX_MGR_SetSnSwIfInfoMirrorMode(snSwIfInfoPortNum, value) != TRUE??? )
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    /* return success
     */
    return SNMP_ERR_NOERROR;
}

int write_snSwIfMacLearningDisable(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    /* dispatch action
     */
    switch (action)
    {
        case RESERVE1:
            /* check type and length
             */
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            /* check valid values
             */
            switch (*(long *) var_val)
            {
                case VAL_snSwIfMacLearningDisable_true:
                    break;

                case VAL_snSwIfMacLearningDisable_false:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = 14;
            I32_T value = 0;

            /* table-specific variables
             */
            UI32_T snSwIfInfoPortNum = 0;

            /* extract index
             */
            if (! snSwIfInfoTable_OidIndexToData(TRUE,
                name_len - oid_name_length,
                &(name[oid_name_length]),
                &snSwIfInfoPortNum))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            /* get user value
             */
            memcpy(&value, var_val, sizeof(I32_T));

            /* set to core layer
             */
            if (XXX_MGR_SetSnSwIfMacLearningDisable(snSwIfInfoPortNum, value) != TRUE??? )
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    /* return success
     */
    return SNMP_ERR_NOERROR;
}
#endif  /* not implemented yet */

/*--------------------------------------------------------------------------
 * TABLE NAME - 1.1.3.3.6 snIfOpticalMonitoringInfoTable
 *--------------------------------------------------------------------------
 */
oid snIfOpticalMonitoringInfoTable_variables_oid[] = { 1,3,6,1,4,1,1991,1,1,3,3 };

/* variable3 snIfOpticalMonitoringInfoTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */
struct variable3 snIfOpticalMonitoringInfoTable_variables[] =
{
    /* magic number, variable type, ro/rw, callback fn, L, oidsuffix
     *     (L = length of the oidsuffix)
     */
    { LEAF_snIfOpticalMonitoringTemperature, ASN_OCTET_STR, RONLY, var_snIfOpticalMonitoringInfoTable, 3, { 6, 1, 1 }},
    { LEAF_snIfOpticalMonitoringTxPower, ASN_OCTET_STR, RONLY, var_snIfOpticalMonitoringInfoTable, 3, { 6, 1, 2 }},
    { LEAF_snIfOpticalMonitoringRxPower, ASN_OCTET_STR, RONLY, var_snIfOpticalMonitoringInfoTable, 3, { 6, 1, 3 }},
    { LEAF_snIfOpticalMonitoringTxBiasCurrent, ASN_OCTET_STR, RONLY, var_snIfOpticalMonitoringInfoTable, 3, { 6, 1, 4 }},
};

void init_snIfOpticalMonitoringInfoTable(void)
{
    /* Register ourselves with the agent to handle our MIB tree
     */
    REGISTER_MIB("snIfOpticalMonitoringInfoTable", snIfOpticalMonitoringInfoTable_variables, variable3,
                 snIfOpticalMonitoringInfoTable_variables_oid);
}

#define SNIFOPTICALMONITORINGINFOENTRY_INSTANCE_LEN  1

BOOL_T snIfOpticalMonitoringInfoTable_OidIndexToData(UI32_T exact, UI32_T compc,
    oid *compl, UI32_T *ifIndex)
{
    /* get or set
     */
    if (exact)
    {
        /* check the index length
         */
        if (compc != SNIFOPTICALMONITORINGINFOENTRY_INSTANCE_LEN)  /* the constant size index */
        {
            return FALSE;
        }
    }

    *ifIndex = compl[0];

    return TRUE;
}

#if (FOUNDRY_LIB_PLATFORM_STYLE == FOUNDRY_LIB_PLATFORM_STYLE_SIMBA)
/* ------------------------------------------------------------------------
 * FUNCTION NAME - var_snIfOpticalMonitoringInfoTable_get (Simba)
 * ------------------------------------------------------------------------
 * PURPOSE  :   To get "snIfOpticalMonitoringInfoTable" for Simba platform.
 *
 * INPUT    :   vp          - pointer to input variable (caller's param)
 *              var_len     - pointer to get output length (caller's param)
 *              unit        - stacking unit ID
 *              sfp_index   - index of SFP on this unit
 *
 * OUTPUT   :   *var_len    - length of output variable (caller's output)
 *              long_return - output value for user (caller's output)
 *              return_buf  - output value for user (caller's output)
 *
 * RETURN   :   pointer to output value (caller's return)
 *
 * NOTES    :   This function is called from var_snIfOpticalMonitoringInfoTable.
 *              This code is based on CLI "show interfaces transceiver".
 * ------------------------------------------------------------------------
 */
static unsigned char *var_snIfOpticalMonitoringInfoTable_get(
    struct variable *vp, size_t *var_len,
    UI32_T unit, UI32_T sfp_index)
{
    STKTPLG_OM_Gbic_Info_T sfp_info;
    STKTPLG_OM_Sfp_A2_Info_T sfp_a2_info;

    /* pointers to status text
     */
    char *normal_p          = "normal",
         *status_p          = normal_p;  /* default; may get one of the following */

    char *low_alarm_p       = "low alarm",
         *low_warning_p     = "low warning",
         *high_warning_p    = "high warning",
         *high_alarm_p      = "high alarm";

    /* clear buffers
     */
    memset(&sfp_info, 0, sizeof(sfp_info));
    memset(&sfp_a2_info, 0, sizeof(sfp_a2_info));

    /* Get Sfp Info from OM
     */
    STKTPLG_POM_GetComboSfpInfo(unit, sfp_index, &sfp_info);

    /* If current sfp module implement ddm, then
     * force to update ddm information via I2C and save in OM.
     */
    /*!!PATCH: SYS_VAL_LOCAL_UNIT_ID should be "unit", but it crashes on LGE 1 phase 2
     *!!PATCH: 0-based index
     */
    if (sfp_info.is_ddm_implemented)
    {
        STKTPLG_PMGR_DetectSfpDDMInfo(SYS_VAL_LOCAL_UNIT_ID, sfp_index - 1);
    }

    /* Now, only internal calibration is implemented.
     * external calibration is not implemented yet.
     */
    if (sfp_info.is_ddm_implemented)
    {
        /* Get Sfp ddm info
        */
        STKTPLG_POM_GetComboSfpDDMInfo(unit, sfp_index, &sfp_a2_info);
    }

    /* dispatch node to read value
     */
    switch (vp->magic)
    {
        /* snIfOpticalMonitoringTemperature
         */
        case LEAF_snIfOpticalMonitoringTemperature:

            /* From MIB object description:
             *
             * The format is xxx.yyyy C(elcius), followed by whether
             * the measured value is normal, high/low alarm or
             * high/low warning.
             */

            /* clear output buffer (zero-ended text string)
             */
            return_buf[0] = '\0';

            /* if DDM is implemented
             */
            if (sfp_info.is_ddm_implemented)
            {
                /* Note: Accton implementation is three decimal places.
                 * If four decimal places is required, we will change "thousandth_part"
                 * to "myriadth_part" and multiply by 10000.  It still will not
                 * overflow the UI32_T.
                 */

                /*  sfp_a2_info.temperature_lsb is a UI32_T number,
                 *  must convert it to correct value by divide 256
                 *  must multiply 1000 to keep 3 digits
                 *  only take 3 digits (ex:0.123)
                 */

                /* sfp_a2_info.temperature_msb (8 bits) and
                 * sfp_a2_info.temperature_lsb (8 bits) combine to form
                 * a signed 16-bit integer, which represents the temperature
                 * in units of 1/256.
                 * So, for printing, determine whether it is positive or negative,
                 * get the absolute value, and extract its integer and decimal parts.
                 */
                I16_T temp256th_i16;
                BOOL_T is_negative = FALSE;
                UI16_T abs256th_ui16;
                UI32_T int_part, thousandth_part;

                temp256th_i16 = (I16_T) ((UI16_T) sfp_a2_info.temperature_msb << 8)
                    + (UI8_T) sfp_a2_info.temperature_lsb;

                if (temp256th_i16 >= 0)
                {
                    abs256th_ui16 = (UI16_T) temp256th_i16;
                }
                else
                {
                    is_negative = TRUE;
                    abs256th_ui16 = (UI16_T) (- temp256th_i16);
                }

                int_part = abs256th_ui16 >> 8;
                thousandth_part = (UI32_T) (abs256th_ui16 & 0xFF) * 1000 / 256;

                /* get state
                 *
                 * Because "warning" is "(! alarm) && warning",
                 * the following sequence must compare alarm first, and then warning.
                 */
                if (sfp_a2_info.is_temperature_high_alarm)
                {
                    status_p = high_alarm_p;
                }
                else if (sfp_a2_info.is_temperature_high_warning)
                {
                    status_p = high_warning_p;
                }
                else if (sfp_a2_info.is_temperature_low_alarm)
                {
                    status_p = low_alarm_p;
                }
                else if (sfp_a2_info.is_temperature_low_warning)
                {
                    status_p = low_warning_p;
                }

                /* print complete string (3 decimal places for Simba)
                 */
                sprintf((char *) return_buf, "%s%3lu.%03lu C %s",
                    (is_negative ? "-" : ""),
                    int_part, thousandth_part, status_p);

                /* respond to user
                 */
                *var_len = strlen((char *) return_buf);
                return (u_char *) return_buf;
            }

            /* else not supported, then no such instance
             */
            else
            {
                return NULL;
            }

            break;

        /* snIfOpticalMonitoringTxPower
         */
        case LEAF_snIfOpticalMonitoringTxPower:

            /* From MIB object description:
             *
             * This object holds the value of the transmitter optical
             * signal power for the interface, measured in dBm, followed
             * by whether this is a normal value, or high/low warning
             * or alarm.
             */

            /* clear output buffer (zero-ended text string)
             */
            return_buf[0] = '\0';

            /* if DDM is implemented
             */
            if (sfp_info.is_ddm_implemented)
            {
                float tx_power = sfp_a2_info.tx_power_real;  /* core layer uses float */

                /* get state
                 *
                 * Because "warning" is "(! alarm) && warning",
                 * the following sequence must compare alarm first, and then warning.
                 */
                if (sfp_a2_info.is_tx_power_high_alarm)
                {
                    status_p = high_alarm_p;
                }
                else if (sfp_a2_info.is_tx_power_high_warning)
                {
                    status_p = high_warning_p;
                }
                else if (sfp_a2_info.is_tx_power_low_alarm)
                {
                    status_p = low_alarm_p;
                }
                else if (sfp_a2_info.is_tx_power_low_warning)
                {
                    status_p = low_warning_p;
                }

                /* print complete string (2 decimal places for Accton)
                 */
                sprintf((char *) return_buf, "%.2f dBm %s",
                    tx_power, status_p);

                /* respond to user
                 */
                *var_len = strlen((char *) return_buf);
                return (u_char *) return_buf;
            }

            /* else not supported, then no such instance
             */
            else
            {
                return NULL;
            }

            break;

        /* snIfOpticalMonitoringRxPower
         */
        case LEAF_snIfOpticalMonitoringRxPower:

            /* From MIB object description:
             *
             * This object holds the value of the receiver optical
             * signal power for the interface, measured in dBm, followed
             * by whether this is a normal value, or high/low warning
             * or alarm.
             */
            
            /* clear output buffer (zero-ended text string)
             */
            return_buf[0] = '\0';

            /* if DDM is implemented
             */
            if (sfp_info.is_ddm_implemented)
            {
                float rx_power = sfp_a2_info.rx_power_real;  /* core layer uses float */

                /* get state
                 *
                 * Because "warning" is "(! alarm) && warning",
                 * the following sequence must compare alarm first, and then warning.
                 */
                if (sfp_a2_info.is_rx_power_high_alarm)
                {
                    status_p = high_alarm_p;
                }
                else if (sfp_a2_info.is_rx_power_high_warning)
                {
                    status_p = high_warning_p;
                }
                else if (sfp_a2_info.is_rx_power_low_alarm)
                {
                    status_p = low_alarm_p;
                }
                else if (sfp_a2_info.is_rx_power_low_warning)
                {
                    status_p = low_warning_p;
                }

                /* print complete string (2 decimal places for Accton)
                 */
                sprintf((char *) return_buf, "%.2f dBm %s",
                    rx_power, status_p);

                /* respond to user
                 */
                *var_len = strlen((char *) return_buf);
                return (u_char *) return_buf;
            }

            /* else not supported, then no such instance
             */
            else
            {
                return NULL;
            }

            break;

        /* snIfOpticalMonitoringTxBiasCurrent
         */
        case LEAF_snIfOpticalMonitoringTxBiasCurrent:

            /* From MIB object description:
             *
             * Tx Bias Current.  It is measured in mA, and is followed
             * by whether this is a normal value, or high/low warning or
             * alarm.
             */

            /* clear output buffer (zero-ended text string)
             */
            return_buf[0] = '\0';

            /* if DDM is implemented
             */
            if (sfp_info.is_ddm_implemented)
            {
                UI32_T int_part = sfp_a2_info.tx_bias * 2 / 1000,
                       thousandth_part = sfp_a2_info.tx_bias * 2 % 1000;
            
                /* get state
                 *
                 * Because "warning" is "(! alarm) && warning",
                 * the following sequence must compare alarm first, and then warning.
                 */
                if (sfp_a2_info.is_tx_bias_high_alarm)
                {
                    status_p = high_alarm_p;
                }
                else if (sfp_a2_info.is_tx_bias_high_warning)
                {
                    status_p = high_warning_p;
                }
                else if (sfp_a2_info.is_tx_bias_low_alarm)
                {
                    status_p = low_alarm_p;
                }
                else if (sfp_a2_info.is_tx_bias_low_warning)
                {
                    status_p = low_warning_p;
                }

                /* print complete string (3 decimal places for Simba)
                 */
                sprintf((char *) return_buf, "%lu.%03lu mA %s",
                    int_part, thousandth_part, status_p);

                /* respond to user
                 */
                *var_len = strlen((char *) return_buf);
                return (u_char *) return_buf;
            }

            /* else not supported, then no such instance
             */
            else
            {
                return NULL;
            }

            break;

        default:
            ERROR_MSG("");
            break;
    }

    /* return failure
     */
    return NULL;
}
#endif  /* (FOUNDRY_LIB_PLATFORM_STYLE == FOUNDRY_LIB_PLATFORM_STYLE_SIMBA) */

#if (FOUNDRY_LIB_PLATFORM_STYLE == FOUNDRY_LIB_PLATFORM_STYLE_EDGE_CORE)
/* ------------------------------------------------------------------------
 * FUNCTION NAME - var_snIfOpticalMonitoringInfoTable_get (Edge-Core)
 * ------------------------------------------------------------------------
 * PURPOSE  :   To get "snIfOpticalMonitoringInfoTable" for Edge-Core platform.
 *
 * INPUT    :   vp          - pointer to input variable (caller's param)
 *              var_len     - pointer to get output length (caller's param)
 *              unit        - stacking unit ID
 *              sfp_index   - index of SFP on this unit
 *
 * OUTPUT   :   *var_len    - length of output variable (caller's output)
 *              long_return - output value for user (caller's output)
 *              return_buf  - output value for user (caller's output)
 *
 * RETURN   :   pointer to output value (caller's return)
 *
 * NOTES    :   This function is called from var_snIfOpticalMonitoringInfoTable.
 *              This code is based on CLI "show interfaces transceiver".
 * ------------------------------------------------------------------------
 */
static unsigned char *var_snIfOpticalMonitoringInfoTable_get(
    struct variable *vp, size_t *var_len,
    UI32_T unit, UI32_T sfp_index)
{
    STKTPLG_OM_GbicInfoInternal_T gbic_info;
    STKTPLG_OM_GbicDDMInfoReadable_T ddm_info_readable;
    STKTPLG_OM_GbicDDMThresholdStatus_T gbic_tholds_status;

    /* pointers to status text
     */
    char *normal_p          = "normal",
         *status_p          = normal_p;  /* default; may get one of the following */

#if (SYS_CPNT_SFP_DDM_ALARMWARN_TRAP == TRUE)
    char *low_alarm_p       = "low alarm",
         *low_warning_p     = "low warning",
         *high_warning_p    = "high warning",
         *high_alarm_p      = "high alarm";
#endif

    /* Get Sfp Info from OM
     */
    if (! (STKTPLG_OM_GetSfpInfoInternal(unit, sfp_index, &gbic_info)))
    {
        return NULL;
    }

    /* If current sfp module implement ddm, then
     * force to update ddm information via I2C and save in OM.
     */

    /* dispatch node to read value
     */
    switch (vp->magic)
    {
        /* snIfOpticalMonitoringTemperature
         */
        case LEAF_snIfOpticalMonitoringTemperature:

            /* From MIB object description:
             *
             * The format is xxx.yyyy C(elcius), followed by whether
             * the measured value is normal, high/low alarm or
             * high/low warning.
             */

            /* clear output buffer (zero-ended text string)
             */
            return_buf[0] = '\0';

            /* if DDM is implemented
             */
            if (gbic_info.support_ddm)
            {
                float temperature;  /* core layer uses float */

                /* Get Sfp ddm info
                 */
                STKTPLG_OM_GetSfpDDMInfo(unit, sfp_index, &ddm_info_readable);
                temperature = ddm_info_readable.diag_temperature;

                /* Get thresholds status to know which threshold trap happened
                 */
                memset(&gbic_tholds_status, 0, sizeof(STKTPLG_OM_GbicDDMThresholdStatus_T));
                STKTPLG_OM_GetGBICThresholdStatus(unit, sfp_index, (STKTPLG_OM_GbicDDMThresholdStatus_T *) &gbic_tholds_status);

#if (SYS_CPNT_SFP_DDM_ALARMWARN_TRAP == TRUE)
                /* get state
                 *
                 * Because "warning" is "(! alarm) && warning",
                 * the following sequence must compare alarm first, and then warning.
                 */
                if (gbic_tholds_status.threshold_status_temp_high_alarm)
                {
                    status_p = high_alarm_p;
                }
                else if (gbic_tholds_status.threshold_status_temp_high_warning)
                {
                    status_p = high_warning_p;
                }
                else if (gbic_tholds_status.threshold_status_temp_low_alarm)
                {
                    status_p = low_alarm_p;
                }
                else if (gbic_tholds_status.threshold_status_temp_low_warning)
                {
                    status_p = low_warning_p;
                }
#endif  /* (SYS_CPNT_SFP_DDM_ALARMWARN_TRAP == TRUE) */

                /* print complete string (2 decimal places for Edge-Core)
                 */
                sprintf((char *) return_buf, "%.2f C %s",
                    temperature /* example: "-12.34" */,
                    status_p);

                /* respond to user
                 */
                *var_len = strlen((char *) return_buf);
                return (u_char *) return_buf;
            }

            /* else not supported, then no such instance
             */
            else
            {
                return NULL;
            }

            break;


        /* snIfOpticalMonitoringTxPower
         */
        case LEAF_snIfOpticalMonitoringTxPower:

            /* From MIB object description:
             *
             * This object holds the value of the transmitter optical
             * signal power for the interface, measured in dBm, followed
             * by whether this is a normal value, or high/low warning
             * or alarm.
             */

            /* clear output buffer (zero-ended text string)
             */
            return_buf[0] = '\0';

            /* if DDM is implemented
             */
            if (gbic_info.support_ddm)
            {
                float tx_power;  /* core layer uses float */

                /* Get Sfp ddm info
                 */
                STKTPLG_OM_GetSfpDDMInfo(unit, sfp_index, &ddm_info_readable);
                tx_power = ddm_info_readable.diag_tx_power;

                /* Get thresholds status to know which threshold trap happened
                 */
                memset(&gbic_tholds_status, 0, sizeof(STKTPLG_OM_GbicDDMThresholdStatus_T));
                STKTPLG_OM_GetGBICThresholdStatus(unit, sfp_index, (STKTPLG_OM_GbicDDMThresholdStatus_T *) &gbic_tholds_status);

#if (SYS_CPNT_SFP_DDM_ALARMWARN_TRAP == TRUE)
                /* get state
                 *
                 * Because "warning" is "(! alarm) && warning",
                 * the following sequence must compare alarm first, and then warning.
                 */
                if (gbic_tholds_status.threshold_status_tx_power_high_alarm)
                {
                    status_p = high_alarm_p;
                }
                else if (gbic_tholds_status.threshold_status_tx_power_high_warning)
                {
                    status_p = high_warning_p;
                }
                else if (gbic_tholds_status.threshold_status_tx_power_low_alarm)
                {
                    status_p = low_alarm_p;
                }
                else if (gbic_tholds_status.threshold_status_tx_power_low_warning)
                {
                    status_p = low_warning_p;
                }
#endif  /* (SYS_CPNT_SFP_DDM_ALARMWARN_TRAP == TRUE) */

                /* print complete string (2 decimal places for Accton)
                 */
                sprintf((char *) return_buf, "%.2f dBm %s",
                    tx_power, status_p);

                /* respond to user
                 */
                *var_len = strlen((char *) return_buf);
                return (u_char *) return_buf;
            }

            /* else not supported, then no such instance
             */
            else
            {
                return NULL;
            }

            break;

        /* snIfOpticalMonitoringRxPower
         */
        case LEAF_snIfOpticalMonitoringRxPower:

            /* From MIB object description:
             *
             * This object holds the value of the receiver optical
             * signal power for the interface, measured in dBm, followed
             * by whether this is a normal value, or high/low warning
             * or alarm.
             */
            
            /* clear output buffer (zero-ended text string)
             */
            return_buf[0] = '\0';

            /* if DDM is implemented
             */
            if (gbic_info.support_ddm)
            {
                float rx_power;  /* core layer uses float */

                /* Get Sfp ddm info
                 */
                STKTPLG_OM_GetSfpDDMInfo(unit, sfp_index, &ddm_info_readable);
                rx_power = ddm_info_readable.diag_rx_power;

                /* Get thresholds status to know which threshold trap happened
                 */
                memset(&gbic_tholds_status, 0, sizeof(STKTPLG_OM_GbicDDMThresholdStatus_T));
                STKTPLG_OM_GetGBICThresholdStatus(unit, sfp_index, (STKTPLG_OM_GbicDDMThresholdStatus_T *) &gbic_tholds_status);

#if (SYS_CPNT_SFP_DDM_ALARMWARN_TRAP == TRUE)
                /* get state
                 *
                 * Because "warning" is "(! alarm) && warning",
                 * the following sequence must compare alarm first, and then warning.
                 */
                if (gbic_tholds_status.threshold_status_rx_power_high_alarm)
                {
                    status_p = high_alarm_p;
                }
                else if (gbic_tholds_status.threshold_status_rx_power_high_warning)
                {
                    status_p = high_warning_p;
                }
                else if (gbic_tholds_status.threshold_status_rx_power_low_alarm)
                {
                    status_p = low_alarm_p;
                }
                else if (gbic_tholds_status.threshold_status_rx_power_low_warning)
                {
                    status_p = low_warning_p;
                }
#endif  /* (SYS_CPNT_SFP_DDM_ALARMWARN_TRAP == TRUE) */

                /* print complete string (2 decimal places for Accton)
                 */
                sprintf((char *) return_buf, "%.2f dBm %s",
                    rx_power, status_p);

                /* respond to user
                 */
                *var_len = strlen((char *) return_buf);
                return (u_char *) return_buf;
            }

            /* else not supported, then no such instance
             */
            else
            {
                return NULL;
            }

            break;


        /* snIfOpticalMonitoringTxBiasCurrent
         */
        case LEAF_snIfOpticalMonitoringTxBiasCurrent:

            /* From MIB object description:
             *
             * Tx Bias Current.  It is measured in mA, and is followed
             * by whether this is a normal value, or high/low warning or
             * alarm.
             */

            /* clear output buffer (zero-ended text string)
             */
            return_buf[0] = '\0';

            /* if DDM is implemented
             */
            if (gbic_info.support_ddm)
            {
                float bias_current;  /* core layer uses float */
            
                /* Get Sfp ddm info
                 */
                STKTPLG_OM_GetSfpDDMInfo(unit, sfp_index, &ddm_info_readable);
                bias_current = ddm_info_readable.diag_tx_bias;

                /* Get thresholds status to know which threshold trap happened
                 */
                memset(&gbic_tholds_status, 0, sizeof(STKTPLG_OM_GbicDDMThresholdStatus_T));
                STKTPLG_OM_GetGBICThresholdStatus(unit, sfp_index, (STKTPLG_OM_GbicDDMThresholdStatus_T *) &gbic_tholds_status);

#if (SYS_CPNT_SFP_DDM_ALARMWARN_TRAP == TRUE)
                /* get state
                 *
                 * Because "warning" is "(! alarm) && warning",
                 * the following sequence must compare alarm first, and then warning.
                 */
                if (gbic_tholds_status.threshold_status_bias_high_alarm)
                {
                    status_p = high_alarm_p;
                }
                else if (gbic_tholds_status.threshold_status_bias_high_warning)
                {
                    status_p = high_warning_p;
                }
                else if (gbic_tholds_status.threshold_status_bias_low_alarm)
                {
                    status_p = low_alarm_p;
                }
                else if (gbic_tholds_status.threshold_status_bias_low_warning)
                {
                    status_p = low_warning_p;
                }
#endif  /* (SYS_CPNT_SFP_DDM_ALARMWARN_TRAP == TRUE) */

                /* print complete string (2 decimal places for Edge-Core)
                 */
                sprintf((char *) return_buf, "%.2f mA %s",
                    bias_current, status_p);

                /* respond to user
                 */
                *var_len = strlen((char *) return_buf);
                return (u_char *) return_buf;
            }

            /* else not supported, then no such instance
             */
            else
            {
                return NULL;
            }

            break;


        default:
            ERROR_MSG("");
            break;
    }

    /* return failure
     */
    return NULL;
}
#endif  /* (FOUNDRY_LIB_PLATFORM_STYLE == FOUNDRY_LIB_PLATFORM_STYLE_EDGE_CORE) */

/*
 * var_snIfOpticalMonitoringInfoTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *var_snIfOpticalMonitoringInfoTable(struct variable *vp,
    oid *name,
    size_t *length,
    int exact,
    size_t *var_len,
    WriteMethod **write_method)
{
    unsigned char *ret_p = NULL;
    UI32_T compc = 0;
    oid compl[SNIFOPTICALMONITORINGINFOENTRY_INSTANCE_LEN] = {0};
    oid best_inst[SNIFOPTICALMONITORINGINFOENTRY_INSTANCE_LEN] = {0};

    /* table-specific variables
     */
    UI32_T lport = 0, unit, sfp_index;
    BOOL_T found = FALSE, present;

    /* dispatch node to set write method
     */
    switch (vp->magic)
    {
        default:
            *write_method = 0;
            break;
    }

    /* check compc, retrive compl
     */
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl,
        SNIFOPTICALMONITORINGINFOENTRY_INSTANCE_LEN);

    /* dispatch get-exact versus get-next
     */
    if (exact)  /* get or set */
    {
        /* extract index
         */
        if (! snIfOpticalMonitoringInfoTable_OidIndexToData(exact, compc, compl,
            &lport))
        {
            return NULL;
        }

        /* get-exact from core layer
         */
        if (! (FOUNDRY_LIB_GetSfpPort(lport, &unit, &sfp_index, &present)
                && present) )
        {
            return NULL;
        }
    }
    else  /* get-next */
    {
        /* extract index
         */
        snIfOpticalMonitoringInfoTable_OidIndexToData(exact, compc, compl,
            &lport);

        /* Check the length of inputing index. If compc is less than instance
         * length, we should try get {A.B.C.0.0...}, where A.B.C was
         * obtained from the "..._OidIndexToData" function call, and
         * 0.0... was initialized in the beginning of this function.
         * This instance may exist in the core layer.
         */
        if (compc < SNIFOPTICALMONITORINGINFOENTRY_INSTANCE_LEN)  /* incomplete index */
        {
            /* get-exact, in case this instance exists
             */
            if (! (FOUNDRY_LIB_GetSfpPort(lport, &unit, &sfp_index, &present)
                    && present) )
            {
                /* get-next according to lexicographic order; if none, fail
                 */
                while (FOUNDRY_LIB_GetNextSfpPort(&lport, &unit, &sfp_index, &present))
                {
                    if (present)
                    {
                        found = TRUE;
                        break;
                    }
                }

                /* if not found, fail
                 */
                if (! found)
                {
                    return NULL;
                }
            }
        }
        else   /* complete index */
        {
            /* get-next according to lexicographic order; if none, fail
             */
            while (FOUNDRY_LIB_GetNextSfpPort(&lport, &unit, &sfp_index, &present))
            {
                if (present)
                {
                    found = TRUE;
                    break;
                }
            }

            /* if not found, fail
             */
            if (! found)
            {
                return NULL;
            }
        }
    }

    /* copy base OID (without index) to output
     */
    memcpy(name, vp->name, vp->namelen * sizeof(oid));

    /* assign data to the OID index
     */
    best_inst[0] = lport;
    memcpy(name + vp->namelen, best_inst, SNIFOPTICALMONITORINGINFOENTRY_INSTANCE_LEN * sizeof(oid));
    *length = vp->namelen + SNIFOPTICALMONITORINGINFOENTRY_INSTANCE_LEN;

#if (SYS_CPNT_STKMGMT_SFP_DDM == TRUE)
    /* Now: get from core layer
     */
    ret_p = var_snIfOpticalMonitoringInfoTable_get(vp, var_len, unit, sfp_index);
#endif

    /* return value (pointer to global) or NULL (failure)
     */
    return ret_p;
}

/*--------------------------------------------------------------------------
 * TABLE NAME - 1.1.3.3.9 snIfMediaInfoTable
 *--------------------------------------------------------------------------
 */
oid snIfMediaInfoTable_variables_oid[] = { 1,3,6,1,4,1,1991,1,1,3,3 };

/* variable3 snIfMediaInfoTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */
struct variable3 snIfMediaInfoTable_variables[] =
{
    /* magic number, variable type, ro/rw, callback fn, L, oidsuffix
     *     (L = length of the oidsuffix)
     */
    { LEAF_snIfMediaType, ASN_OCTET_STR, RONLY, var_snIfMediaInfoTable, 3, { 9, 1, 1 }},
    { LEAF_snIfMediaVendorName, ASN_OCTET_STR, RONLY, var_snIfMediaInfoTable, 3, { 9, 1, 2 }},
    { LEAF_snIfMediaVersion, ASN_OCTET_STR, RONLY, var_snIfMediaInfoTable, 3, { 9, 1, 3 }},
    { LEAF_snIfMediaPartNumber, ASN_OCTET_STR, RONLY, var_snIfMediaInfoTable, 3, { 9, 1, 4 }},
    { LEAF_snIfMediaSerialNumber, ASN_OCTET_STR, RONLY, var_snIfMediaInfoTable, 3, { 9, 1, 5 }},
};

void init_snIfMediaInfoTable(void)
{
    /* Register ourselves with the agent to handle our MIB tree
     */
    REGISTER_MIB("snIfMediaInfoTable", snIfMediaInfoTable_variables, variable3,
                 snIfMediaInfoTable_variables_oid);
}

#define SNIFMEDIAINFOENTRY_INSTANCE_LEN  1

BOOL_T snIfMediaInfoTable_OidIndexToData(UI32_T exact, UI32_T compc,
    oid *compl, UI32_T *ifIndex)
{
    /* get or set
     */
    if (exact)
    {
        /* check the index length
         */
        if (compc != SNIFMEDIAINFOENTRY_INSTANCE_LEN)  /* the constant size index */
        {
            return FALSE;
        }
    }

    *ifIndex = compl[0];

    return TRUE;
}

#if (FOUNDRY_LIB_PLATFORM_STYLE == FOUNDRY_LIB_PLATFORM_STYLE_SIMBA)
/* ------------------------------------------------------------------------
 * FUNCTION NAME - var_snIfMediaInfoTable_get (Simba)
 * ------------------------------------------------------------------------
 * PURPOSE  :   To get "snIfMediaInfoTable" for Simba platform.
 *
 * INPUT    :   vp          - pointer to input variable (caller's param)
 *              var_len     - pointer to get output length (caller's param)
 *              unit        - stacking unit ID
 *              sfp_index   - index of SFP on this unit
 *
 * OUTPUT   :   *var_len    - length of output variable (caller's output)
 *              long_return - output value for user (caller's output)
 *              return_buf  - output value for user (caller's output)
 *
 * RETURN   :   pointer to output value (caller's return)
 *
 * NOTES    :   This function is called from var_snIfMediaInfoTable.
 *              This code is based on CLI "show interfaces transceiver".
 * ------------------------------------------------------------------------
 */
static unsigned char *var_snIfMediaInfoTable_get(
    struct variable *vp, size_t *var_len,
    UI32_T unit, UI32_T sfp_index)
{
    STKTPLG_OM_Gbic_Info_T sfp_info;

    /* text for connector type, media type, and compliance code
     *
     *!!PATCH: These will be moved to the core layer for all UI to use.
     */
    char *connector1_p_ar[] =
    {
        "Unknown or unspecified",  /* 0 */
        "SC",
        "Fibre Channel Style 1 copper connector",
        "Fibre Channel Style 2 copper connector",
        "BNC/TNC",
        "Fibre Channel coaxial headers",
        "Fiber Jack",
        "LC",
        "MT-RJ",
        "MU",
        "SG",
        "Optical pigtail",
        "MPO Parallel Optic"  /* 12 */
    };

    char *connector2_p_ar[]=
    {
        "HSSDC II",  /* 32 */
        "Copper pigtail",
        "RJ45"
    };

    char *fibre_trans_media_p_ar[] =
    {
        "Single Mode (SM)",
        "",
        "Multimode, 50 um (M5, M5E)",  /* assume "u" stands for "Greek mu" */
        "Multimode, 62.5 um (M6)",
        "Video Coax (TV)",
        "Miniature Coax (MI)",
        "Twisted Pair (TP)",
        "Twin Axial Pair (TW)"
    };

    char *ge_compliance_code_p_ar[] =
    {
        "1000BASE-SX",
        "1000BASE-LX",
        "1000BASE-CX",
        "1000BASE-T",
        "100BASE-LX/LX10",
        "100BASE-FX",
        "BASE-BX10",
        "BASE-PX"
    };

    /* clear buffers
     */
    memset(&sfp_info, 0, sizeof(sfp_info));

    /* Get Sfp Info from OM
     */
    STKTPLG_POM_GetComboSfpInfo(unit, sfp_index, &sfp_info);

    /* dispatch node to read value
     */
    switch (vp->magic)
    {
        /* snIfMediaType (MIB: 0..128)
         */
        case LEAF_snIfMediaType:
            /* clear buffer
             */
            return_buf[0] = '\0';

            /* fill connector type
             */
            if (sfp_info.connector_type < 13)
            {
                strcat((char *) return_buf, connector1_p_ar[sfp_info.connector_type]);
            }
            else
            {
                strcat((char *) return_buf, connector2_p_ar[sfp_info.connector_type - 32]);
            }

            strcat(return_buf, "; ");

            /* fill fibre type
             *
             * WARNING: if multiple bits are on, may exceed maximum string length
             */
            {
                UI32_T index = 0;
                BOOL_T is_empty = TRUE;

                /* append string to output
                 */
                for (index = 0;
                    index < sizeof(fibre_trans_media_p_ar)
                        / sizeof(fibre_trans_media_p_ar[0]);
                    index++)
                {
                    if (sfp_info.fibre_trans_media_bitmap[index])
                    {
                        if (is_empty)
                        {
                            is_empty = FALSE;
                        }
                        else
                        {
                            strcat((char *) return_buf, ", ");
                        }

                        strcat((char *) return_buf, fibre_trans_media_p_ar[index]);
                    }
                }
            }

            strcat(return_buf, "; ");

            /* fill compliance code
             *
             * WARNING: if multiple bits are on, may exceed maximum string length
             */
            {
                UI32_T index = 0;
                BOOL_T is_empty = TRUE;

                /* add string to output
                 */
                for (index = 0;
                    index < sizeof(ge_compliance_code_p_ar)
                        / sizeof(ge_compliance_code_p_ar[0]);
                    index++)
                {
                    if (sfp_info.ge_compliance_bitmap[index])
                    {
                        if (is_empty)
                        {
                            is_empty = FALSE;
                        }
                        else
                        {
                            strcat((char *) return_buf, ", ");
                        }

                        strcat((char *) return_buf, ge_compliance_code_p_ar[index]);
                    }
                }
            }

            /* respond to user
             */
            *var_len = strlen((char *) return_buf);
            return (u_char *) return_buf;

        /* snIfMediaVendorName
         */
        case LEAF_snIfMediaVendorName:
            /* compose vendor name and vendor OUI
             */
            sprintf((char *) return_buf, "%s; %02lX-%02lX-%02lX",
                sfp_info.vendor_name,
                (sfp_info.vendor_oui >> 16) & 0xFF,
                (sfp_info.vendor_oui >> 8) & 0xFF,
                sfp_info.vendor_oui & 0xFF);
            *var_len = strlen(return_buf);
            return (u_char *) return_buf;

        /* snIfMediaVersion
         */
        case LEAF_snIfMediaVersion:
            *var_len = strlen(sfp_info.vendor_revision);
            memcpy(return_buf, sfp_info.vendor_revision, *var_len);
            return (u_char *) return_buf;

        /* snIfMediaPartNumber
         */
        case LEAF_snIfMediaPartNumber:
            *var_len = strlen(sfp_info.vendor_part_number);
            memcpy(return_buf, sfp_info.vendor_part_number, *var_len);
            return (u_char *) return_buf;

        /* snIfMediaSerialNumber
         */
        case LEAF_snIfMediaSerialNumber:
            *var_len = strlen(sfp_info.vendor_serial_number);
            memcpy(return_buf, sfp_info.vendor_serial_number, *var_len);
            return (u_char *) return_buf;

        /* unrecognised node
         */
        default:
            ERROR_MSG("");
            break;
    }

    /* return failure
     */
    return NULL;
}
#endif  /* (FOUNDRY_LIB_PLATFORM_STYLE == FOUNDRY_LIB_PLATFORM_STYLE_SIMBA) */

#if (FOUNDRY_LIB_PLATFORM_STYLE == FOUNDRY_LIB_PLATFORM_STYLE_EDGE_CORE)
#if ((SYS_CPNT_SWDRV_SFP_DDM == TRUE) || (SYS_CPNT_STKMGMT_SFP_DDM==TRUE))
/*!!PATCH: These will be moved to the core layer for all UI to use.
 */
/* ------------------------------------------------------------------------
 * FUNCTION NAME - map_sfp_eeprom_connector (Edge-Core)
 * ------------------------------------------------------------------------
 * PURPOSE  :   Fill connector type.
 *
 * INPUT    :   Copied from CLI.
 *
 * OUTPUT   :   Copied from CLI.
 *
 * RETURN   :   Length of appended string.
 *
 * NOTES    :   This function is called from var_snIfMediaInfoTable_get.
 *
 * WARNING  :   If multiple bits are on, may exceed maximum string length
 * ------------------------------------------------------------------------
 */
static UI32_T map_sfp_eeprom_connector(UI8_T index, char *data)
{
    switch (index)
    {
        case SWDRV_GBIC_CONNECTOR_SC:
            sprintf(data, "SC");
            break;
        case SWDRV_GBIC_CONNECTOR_FIBRE_CHANNEL_STYLE_1:
            sprintf(data, "Fibre Channel Style 1 copper connector");
            break;
        case SWDRV_GBIC_CONNECTOR_FIBRE_CHANNEL_STYLE_2:
            sprintf(data, "Fibre Channel Style 2 copper connector");
            break;
        case SWDRV_GBIC_CONNECTOR_BNC_TNC:
            sprintf(data, "BNC/TNC");
            break;
        case SWDRV_GBIC_CONNECTOR_FIBRE_CHANNEL_COAXIAL:
            sprintf(data, "Fibre Channel coaxial headers");
            break;
        case SWDRV_GBIC_CONNECTOR_FIBRE_JACK:
            sprintf(data, "Fiber Jack");
            break;
        case SWDRV_GBIC_CONNECTOR_LC:
            sprintf(data, "LC");
            break;
        case SWDRV_GBIC_CONNECTOR_MT_RJ:
            sprintf(data, "MT-RJ");
            break;
        case SWDRV_GBIC_CONNECTOR_MU:
            sprintf(data, "MU");
            break;
        case SWDRV_GBIC_CONNECTOR_SG:
            sprintf(data, "SG");
            break;
        case SWDRV_GBIC_CONNECTOR_OPTICAL_PIGTAIL:
            sprintf(data, "Optical pigtail");
            break;
        case SWDRV_GBIC_CONNECTOR_MPO_PARALLEL_OPTIC:
            sprintf(data, "MPO Parallel Optic");
            break;
        case SWDRV_GBIC_CONNECTOR_HSSDC_II:
            sprintf(data, "HSSDC II");
            break;
        case SWDRV_GBIC_CONNECTOR_COPPER_PIGTAIL:
            sprintf(data, "Copper pigtail");
            break;
        case SWDRV_GBIC_CONNECTOR_RJ45:
            sprintf(data, "RJ45");
            break;
        case SWDRV_GBIC_CONNECTOR_UNKNOWN:
        default:
            sprintf(data, "unknown");
            break;
    }

    /* return length
     */
    return strlen(data);
}

/*!!PATCH: These will be moved to the core layer for all UI to use.
 */
/* ------------------------------------------------------------------------
 * FUNCTION NAME - map_sfp_eeprom_transceiver_media (Edge-Core)
 * ------------------------------------------------------------------------
 * PURPOSE  :   Fill SFP media type.
 *
 * INPUT    :   Copied from CLI.
 *
 * OUTPUT   :   Copied from CLI.
 *
 * RETURN   :   Length of appended string.
 *
 * NOTES    :   This function is called from var_snIfMediaInfoTable_get.
 *
 * WARNING  :   If multiple bits are on, may exceed maximum string length.
 * ------------------------------------------------------------------------
 */
static UI32_T map_sfp_eeprom_transceiver_media(UI8_T index, UI8_T length_km, char* data)
{
    char *temp = data;

    if (index == 0)
    {
        if (length_km)
        {
            temp += sprintf(temp, "Single Mode (SM), ");
        }
        else
        {
            temp += sprintf(temp, "Multimode Mode, ");
        }
    }
    else
    {
        if (index & SWDRV_GBIC_FIBER_TYPE_SINGLEMODE)
            temp += sprintf(temp, "Single Mode (SM), ");
        if (index & SWDRV_GBIC_FIBER_TYPE_MULTIMODE_5)
            temp += sprintf(temp, "Multimode 50 um (M5), ");
        if (index & SWDRV_GBIC_FIBER_TYPE_MULTIMODE_6)
            temp += sprintf(temp, "Multimode 62.5 um (M6), ");
        if (index & SWDRV_GBIC_FIBER_TYPE_VIDEO_COAX)
            temp += sprintf(temp, "Video Coax (TV), ");
        if (index & SWDRV_GBIC_FIBER_TYPE_MINIATURE_COAX)
            temp += sprintf(temp, "Miniature Coax (MI), ");
        if (index & SWDRV_GBIC_FIBER_TYPE_TWISTED_PAIR)
            temp += sprintf(temp, "Twisted Pair (TP), ");
        if (index & SWDRV_GBIC_FIBER_TYPE_TWIN_AXIAL_PAIR)
            temp += sprintf(temp, "Twin Axial Pair (TW), ");
    }

    /* text generated
     */
    if (temp != data)
    {
        temp -= 2;
        *temp = '\0';
    }

    /* unrecognised
     */
	else
		temp += sprintf(data, "[%02X (hex)]", index);

    /* return length
     */
    return temp - data;
}

/*!!PATCH: These will be moved to the core layer for all UI to use.
 */
/* ------------------------------------------------------------------------
 * FUNCTION NAME - map_sfp_eeprom_transceiver_comp_code (Edge-Core)
 * ------------------------------------------------------------------------
 * PURPOSE  :   Fill SFP compliance code.
 *
 * INPUT    :   Copied from CLI.
 *
 * OUTPUT   :   Copied from CLI.
 *
 * RETURN   :   Length of appended string.
 *
 * NOTES    :   This function is called from var_snIfMediaInfoTable_get.
 *
 * WARNING  :   If multiple bits are on, may exceed maximum string length.
 * ------------------------------------------------------------------------
 */
static UI32_T map_sfp_eeprom_transceiver_comp_code(UI8_T index, UI8_T index10g, UI8_T lenght_km, UI8_T length_100m, char *data)
{
    char *temp = data;

    /* for special case */
    if (index == 0 && index10g == 0)
    {
        if (((lenght_km == 0x1e) || (lenght_km == 0x28)) && (length_100m == 0xff))
            temp += sprintf(temp, "1000BASE-LHX, ");
    }
    else
    {
        if (index & SWDRV_GBIC_ETH_COMP_CODES_1000BASE_SX)
            temp += sprintf(temp, "1000BASE-SX, ");
        if (index & SWDRV_GBIC_ETH_COMP_CODES_1000BASE_LX)
        {
            /* This is a workaround for edgecore because transceiver vendor write 0x02 at byte#6 */
            if (((lenght_km == 0x46) || (lenght_km == 0x50)) && (length_100m == 0xff))
                temp += sprintf(temp, "1000BASE-ZX, ");
            else if (((lenght_km == 0x1e) || (lenght_km == 0x28)) && (length_100m == 0xff))
                temp += sprintf(temp, "1000BASE-LHX, ");
            else
                temp += sprintf(temp, "1000BASE-LX, ");
        }
        if (index & SWDRV_GBIC_ETH_COMP_CODES_1000BASE_CX)
            temp += sprintf(temp, "1000BASE-CX, ");
        if (index & SWDRV_GBIC_ETH_COMP_CODES_1000BASE_T)
            temp += sprintf(temp, "1000BASE-T, ");
        if (index & SWDRV_GBIC_ETH_COMP_CODES_100BASE_LX_LX10)
            temp += sprintf(temp, "100BASE-LX/LX10, ");
        if (index & SWDRV_GBIC_ETH_COMP_CODES_100BASE_FX)
            temp += sprintf(temp, "100BASE-FX, ");
        if (index & SWDRV_GBIC_ETH_COMP_CODES_BASE_BX10)
            temp += sprintf(temp, "BASE-BX10, ");
        if (index & SWDRV_GBIC_ETH_COMP_CODES_BASE_PX)
            temp += sprintf(temp, "BASE-PX, ");

        if (index10g & SWDRV_GBIC_10G_ETH_COMP_CODES_10GBASE_SR)
            temp += sprintf(temp, "10GBASE-SR, ");
        if (index10g & SWDRV_GBIC_10G_ETH_COMP_CODES_10GBASE_LR)
            temp += sprintf(temp, "10GBASE-LR, ");
        if (index10g & SWDRV_GBIC_10G_ETH_COMP_CODES_10GBASE_LRM)
            temp += sprintf(temp, "10GBASE-LRM, ");
        if (index10g & SWDRV_GBIC_10G_ETH_COMP_CODES_10GBASE_ER)
            temp += sprintf(temp, "10GBASE-ER, ");
    }

    /* text generated
     */
    if (temp != data)
    {
        temp -= 2;
        *temp = '\0';
    }

    /* unrecognised
     */
	else
		temp += sprintf(data, "[%02X (hex)]", index);

    /* return length
     */
    return temp - data;
}

/*!!PATCH: These will be moved to the core layer for all UI to use.
 */
/* ------------------------------------------------------------------------
 * FUNCTION NAME - map_xfp_eeprom_transceiver_media (Edge-Core)
 * ------------------------------------------------------------------------
 * PURPOSE  :   Fill XFP media type.
 *
 * INPUT    :   Copied from CLI.
 *
 * OUTPUT   :   Copied from CLI.
 *
 * RETURN   :   Length of appended string.
 *
 * NOTES    :   This function is called from var_snIfMediaInfoTable_get.
 *
 * WARNING  :   If multiple bits are on, may exceed maximum string length.
 * ------------------------------------------------------------------------
 */
static BOOL_T map_xfp_eeprom_transceiver_media(UI8_T length_km, char *data)
{
    char *temp = data;

    if (length_km)
    {
        temp += sprintf(temp, "Single Mode (SM), ");
    }
    else
    {
        temp += sprintf(temp, "Multimode Mode, ");
    }

    /* text generated
     */
    if (temp != data)
    {
        temp -= 2;
        *temp = '\0';
    }

    /* unrecognised
     */
	else
		temp += sprintf(data, "[%02X (hex)]", length_km);

    /* return length
     */
    return temp - data;
}

/* ------------------------------------------------------------------------
 * FUNCTION NAME - map_xfp_eeprom_transceiver_comp_code (Edge-Core)
 * ------------------------------------------------------------------------
 * PURPOSE  :   Fill XFP compliance code.
 *
 * INPUT    :   Copied from CLI.
 *
 * OUTPUT   :   Copied from CLI.
 *
 * RETURN   :   Length of appended string.
 *
 * NOTES    :   This function is called from var_snIfMediaInfoTable_get.
 *
 * WARNING  :   If multiple bits are on, may exceed maximum string length.
 * ------------------------------------------------------------------------
 */
static BOOL_T map_xfp_eeprom_transceiver_comp_code(UI8_T index, UI8_T lenght_km, char *data)
{
    char *temp = data;

    /* for special case */
    if (index == 0)
    {
        if (lenght_km == 80)
            temp += sprintf(temp, "1000BASE-ZR/ZW, ");
    }
    else
    {
        if (index & SWDRV_XFP_10G_ETH_COMP_CODES_10GBASE_SR)
            temp += sprintf(temp, "10GBASE-SR, ");
        if (index & SWDRV_XFP_10G_ETH_COMP_CODES_10GBASE_LR)
            temp += sprintf(temp, "10GBASE-LR, ");
        if (index & SWDRV_XFP_10G_ETH_COMP_CODES_10GBASE_ER)
            temp += sprintf(temp, "10GBASE-ER, ");
        if (index & SWDRV_XFP_10G_ETH_COMP_CODES_10GBASE_SW)
            temp += sprintf(temp, "10GBASE-SW, ");
        if (index & SWDRV_XFP_10G_ETH_COMP_CODES_10GBASE_LW)
            temp += sprintf(temp, "10GBASE-LW, ");
        if (index & SWDRV_XFP_10G_ETH_COMP_CODES_10GBASE_EW)
            temp += sprintf(temp, "10GBASE-EW, ");
    }

    if (temp != data)
    {
        temp -= 2;
        *temp = '\0';
    }
	else
		temp += sprintf(data, "[%02X (hex)]", index);

    return temp - data;
}
#endif  /* ((SYS_CPNT_SWDRV_SFP_DDM == TRUE) || (SYS_CPNT_STKMGMT_SFP_DDM==TRUE)) */

/* still in: #if (FOUNDRY_LIB_PLATFORM_STYLE == FOUNDRY_LIB_PLATFORM_STYLE_EDGE_CORE)
 */
/* ------------------------------------------------------------------------
 * FUNCTION NAME - var_snIfMediaInfoTable_get (Edge-Core)
 * ------------------------------------------------------------------------
 * PURPOSE  :   To get "snIfMediaInfoTable" for Edge-Core platform.
 *
 * INPUT    :   vp          - pointer to input variable (caller's param)
 *              var_len     - pointer to get output length (caller's param)
 *              unit        - stacking unit ID
 *              sfp_index   - index of SFP on this unit
 *
 * OUTPUT   :   *var_len    - length of output variable (caller's output)
 *              long_return - output value for user (caller's output)
 *              return_buf  - output value for user (caller's output)
 *
 * RETURN   :   pointer to output value (caller's return)
 *
 * NOTES    :   This function is called from var_snIfMediaInfoTable.
 *              This code is based on CLI "show interfaces transceiver".
 * ------------------------------------------------------------------------
 */
static unsigned char *var_snIfMediaInfoTable_get(
    struct variable *vp, size_t *var_len,
    UI32_T unit, UI32_T sfp_index)
{
    STKTPLG_OM_GbicInfoInternal_T gbic_info;

    /* clear buffers
     */
    memset(&gbic_info, 0, sizeof(gbic_info));

    /* Get Sfp Info from OM
     */
    if (! STKTPLG_OM_GetSfpInfoInternal(unit, sfp_index, &gbic_info))
    {
        return NULL;
    }

    /* dispatch node to read value
     */
    switch (vp->magic)
    {
        /* snIfMediaType (MIB: 0..128)
         */
        case LEAF_snIfMediaType:
        {
            UI32_T cumulative_length = 0;

            /* clear buffer
             */
            return_buf[0] = '\0';

            /* fill connector type
             */
            cumulative_length += map_sfp_eeprom_connector(gbic_info.connector,
                (char *) return_buf + cumulative_length);

            cumulative_length += sprintf((char *) return_buf + cumulative_length, "; ");

            /* fill media type
             */
            if (gbic_info.identifier == SWDRV_GBIC_ID_XFP)
            {
                cumulative_length += map_xfp_eeprom_transceiver_media(gbic_info.link_length_support_km,
                    (char *) return_buf + cumulative_length);
            }
            else
            {
                cumulative_length += map_sfp_eeprom_transceiver_media(gbic_info.transceiver[6], gbic_info.link_length_support_km,
                    (char *) return_buf + cumulative_length);
            }

            cumulative_length += sprintf((char *) return_buf + cumulative_length, "; ");

            /* fill compliance code
             */
            if (gbic_info.identifier == SWDRV_GBIC_ID_XFP)
            {
                cumulative_length += map_xfp_eeprom_transceiver_comp_code(gbic_info.transceiver[3], gbic_info.link_length_support_km,
                    (char *) return_buf + cumulative_length);
            }
            else
            {
                cumulative_length += map_sfp_eeprom_transceiver_comp_code(gbic_info.transceiver[6], gbic_info.transceiver[3], gbic_info.link_length_support_km, gbic_info.link_length_support_100m,
                    (char *) return_buf + cumulative_length);
            }
            
            /* respond to user
             */
            *var_len = cumulative_length;
            return (u_char *) return_buf;
        }

        /* snIfMediaVendorName
         */
        case LEAF_snIfMediaVendorName:
            /* compose vendor name and vendor OUI
             */
            sprintf((char *) return_buf, "%s; %02X-%02X-%02X",
                gbic_info.vendor_name,
                gbic_info.vendor_oui[0], gbic_info.vendor_oui[1], gbic_info.vendor_oui[2]);
            *var_len = strlen((char *) return_buf);
            return (u_char *) return_buf;

        /* snIfMediaVersion
         */
        case LEAF_snIfMediaVersion:
            *var_len = strlen(gbic_info.vendor_rev);
            memcpy(return_buf, gbic_info.vendor_rev, *var_len);
            return (u_char *) return_buf;

        /* snIfMediaPartNumber
         */
        case LEAF_snIfMediaPartNumber:
            *var_len = strlen(gbic_info.vendor_pn);
            memcpy(return_buf, gbic_info.vendor_pn, *var_len);
            return (u_char *) return_buf;

        /* snIfMediaSerialNumber
         */
        case LEAF_snIfMediaSerialNumber:
            *var_len = strlen(gbic_info.vendor_sn);
            memcpy(return_buf, gbic_info.vendor_sn, *var_len);
            return (u_char *) return_buf;

        /* unrecognised node
         */
        default:
            ERROR_MSG("");
            break;
    }

    /* return failure
     */
    return NULL;
}
#endif  /* (FOUNDRY_LIB_PLATFORM_STYLE == FOUNDRY_LIB_PLATFORM_STYLE_EDGE_CORE) */

/*
 * var_snIfMediaInfoTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *var_snIfMediaInfoTable(struct variable *vp,
    oid *name,
    size_t *length,
    int exact,
    size_t *var_len,
    WriteMethod **write_method)
{
    unsigned char *ret_p = NULL;
    UI32_T compc = 0;
    oid compl[SNIFMEDIAINFOENTRY_INSTANCE_LEN] = {0};
    oid best_inst[SNIFMEDIAINFOENTRY_INSTANCE_LEN] = {0};

    /* table-specific variables
     */
    UI32_T lport = 0, unit, sfp_index;
    BOOL_T found = FALSE, present;

    /* dispatch node to set write method
     */
    switch (vp->magic)
    {
        default:
            *write_method = 0;
            break;
    }

    /* check compc, retrive compl
     */
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl,
        SNIFMEDIAINFOENTRY_INSTANCE_LEN);

    /* dispatch get-exact versus get-next
     */
    if (exact)  /* get or set */
    {
        /* extract index
         */
        if (! snIfMediaInfoTable_OidIndexToData(exact, compc, compl,
            &lport))
        {
            return NULL;
        }

        /* get-exact from core layer
         */
        if (! (FOUNDRY_LIB_GetSfpPort(lport, &unit, &sfp_index, &present)
                && present) )
        {
            return NULL;
        }
    }
    else  /* get-next */
    {
        /* extract index
         */
        snIfMediaInfoTable_OidIndexToData(exact, compc, compl,
            &lport);

        /* Check the length of inputing index. If compc is less than instance
         * length, we should try get {A.B.C.0.0...}, where A.B.C was
         * obtained from the "..._OidIndexToData" function call, and
         * 0.0... was initialized in the beginning of this function.
         * This instance may exist in the core layer.
         */
        if (compc < SNIFMEDIAINFOENTRY_INSTANCE_LEN)  /* incomplete index */
        {
            /* get-exact, in case this instance exists
             */
            if (! (FOUNDRY_LIB_GetSfpPort(lport, &unit, &sfp_index, &present)
                    && present) )
            if (! (FOUNDRY_LIB_GetSfpPort(lport, &unit, &sfp_index, &present)
                    && present) )
            {
                found = FALSE;

                /* get-next according to lexicographic order; if none, fail
                 */
                while (FOUNDRY_LIB_GetNextSfpPort(&lport, &unit, &sfp_index, &present))
                {
                    if (present)
                    {
                        found = TRUE;
                        break;
                    }
                }

                /* if not found, fail
                 */
                if (! found)
                {
                    return NULL;
                }
            }
        }
        else   /* complete index */
        {
            /* get-next according to lexicographic order; if none, fail
             */
            while (FOUNDRY_LIB_GetNextSfpPort(&lport, &unit, &sfp_index, &present))
            {
                if (present)
                {
                    found = TRUE;
                    break;
                }
            }

            /* if not found, fail
             */
            if (! found)
            {
                return NULL;
            }
        }
    }

    /* copy base OID (without index) to output
     */
    memcpy(name, vp->name, vp->namelen * sizeof(oid));

    /* assign data to the OID index
     */
    best_inst[0] = lport;
    memcpy(name + vp->namelen, best_inst, SNIFMEDIAINFOENTRY_INSTANCE_LEN * sizeof(oid));
    *length = vp->namelen + SNIFMEDIAINFOENTRY_INSTANCE_LEN;

    /* Now: get from core layer
     */
    ret_p = var_snIfMediaInfoTable_get(vp, var_len, unit, sfp_index);

    /* return value (pointer to global) or NULL (failure)
     */
    return ret_p;
}

#if (SYS_CPNT_NETACCESS_MACAUTH == TRUE)  /* all of snMacFilterIfAccessTable */
/*--------------------------------------------------------------------------
 * TABLE NAME - 1.1.3.10.3 snMacFilterIfAccessTable
 *--------------------------------------------------------------------------
 */
oid snMacFilterIfAccessTable_variables_oid[] = { 1,3,6,1,4,1,1991,1,1,3,10 };

/* variable3 snMacFilterIfAccessTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */
struct variable3 snMacFilterIfAccessTable_variables[] =
{
    /* magic number, variable type, ro/rw, callback fn, L, oidsuffix
     *     (L = length of the oidsuffix)
     */
    { LEAF_snMacFilterIfAccessPortIndex, ASN_INTEGER, RONLY, var_snMacFilterIfAccessTable, 3, { 3, 1, 1 }},
    { LEAF_snMacFilterIfAccessFilters, ASN_OCTET_STR, RWRITE, var_snMacFilterIfAccessTable, 3, { 3, 1, 2 }},
    { LEAF_snMacFilterIfAccessRowStatus, ASN_INTEGER, RWRITE, var_snMacFilterIfAccessTable, 3, { 3, 1, 3 }},
};

void init_snMacFilterIfAccessTable(void)
{
    /* Register ourselves with the agent to handle our MIB tree
     */
    REGISTER_MIB("snMacFilterIfAccessTable", snMacFilterIfAccessTable_variables, variable3,
                 snMacFilterIfAccessTable_variables_oid);
}

#define SNMACFILTERIFACCESSENTRY_INSTANCE_LEN  1

BOOL_T snMacFilterIfAccessTable_OidIndexToData(UI32_T exact, UI32_T compc,
    oid *compl, UI32_T *snMacFilterIfAccessPortIndex)
{
    /* get or set
     */
    if (exact)
    {
        /* check the index length
         */
        if (compc != SNMACFILTERIFACCESSENTRY_INSTANCE_LEN)  /* the constant size index */
        {
            return FALSE;
        }
    }

    *snMacFilterIfAccessPortIndex = compl[0];

    return TRUE;
}

/*
 * var_snMacFilterIfAccessTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *var_snMacFilterIfAccessTable(struct variable *vp,
    oid *name,
    size_t *length,
    int exact,
    size_t *var_len,
    WriteMethod **write_method)
{
    UI32_T compc = 0;
    oid compl[SNMACFILTERIFACCESSENTRY_INSTANCE_LEN] = {0};
    oid best_inst[SNMACFILTERIFACCESSENTRY_INSTANCE_LEN] = {0};

    /* table-specific variables
     */
    NETACCESS_MGR_SecurePortEntry_T entry;
    UI32_T index = 0, used_buffer = 0;

    /* dispatch node to set write method
     */
    switch (vp->magic)
    {
        case LEAF_snMacFilterIfAccessFilters:
            *write_method = write_snMacFilterIfAccessFilters;
            break;

        case LEAF_snMacFilterIfAccessRowStatus:
            *write_method = write_snMacFilterIfAccessRowStatus;
            break;

        default:
            *write_method = 0;
            break;
    }

    /* check compc, retrive compl
     */
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl,
        SNMACFILTERIFACCESSENTRY_INSTANCE_LEN);

    memset(&entry, 0, sizeof(entry));

    /* dispatch get-exact versus get-next
     */
    if (exact)  /* get or set */
    {
        /* extract index
         */
        if (! snMacFilterIfAccessTable_OidIndexToData(exact, compc, compl,
            &index))
        {
            return NULL;
        }

        /* get-exact from core layer
         */
        if (NETACCESS_PMGR_GetSecurePortEntry(SYS_TYPE_FID_ALL, &index,
            &entry, sizeof(entry), &used_buffer) != 0)
        {
            return NULL;
        }
    }
    else  /* get-next */
    {
        /* extract index
         */
        snMacFilterIfAccessTable_OidIndexToData(exact, compc, compl,
            &index);

        /* Check the length of inputing index. If compc is less than instance
         * length, we should try get {A.B.C.0.0...}, where A.B.C was
         * obtained from the "..._OidIndexToData" function call, and
         * 0.0... was initialized in the beginning of this function.
         * This instance may exist in the core layer.
         */
        if (compc < SNMACFILTERIFACCESSENTRY_INSTANCE_LEN)  /* incomplete index */
        {
            /* get-exact, in case this instance exists
             */
            if (NETACCESS_PMGR_GetSecurePortEntry(SYS_TYPE_FID_ALL, &index,
                &entry, sizeof(entry), &used_buffer) != 0)
            {
                /* get-next according to lexicographic order; if none, fail
                 */
                if (NETACCESS_PMGR_GetNextSecurePortEntry(SYS_TYPE_FID_ALL, &index,
                    &entry, sizeof(entry), &used_buffer) != 0)
                {
                    return NULL;
                }
            }
        }
        else   /* complete index */
        {
            /* get-next according to lexicographic order; if none, fail
             */
            if (NETACCESS_PMGR_GetNextSecurePortEntry(SYS_TYPE_FID_ALL, &index,
                &entry, sizeof(entry), &used_buffer) != 0)
            {
                return NULL;
            }
        }
    }

    /* copy base OID (without index) to output
     */
    memcpy(name, vp->name, vp->namelen * sizeof(oid));

    /* assign data to the OID index
     */
    best_inst[0] = index;
    memcpy(name + vp->namelen, best_inst, SNMACFILTERIFACCESSENTRY_INSTANCE_LEN * sizeof(oid));
    *length = vp->namelen + SNMACFILTERIFACCESSENTRY_INSTANCE_LEN;

    /* dispatch node to read value
     */
    switch (vp->magic)
    {
        case LEAF_snMacFilterIfAccessPortIndex:
            *var_len = 4;
            long_return = index;
            return (u_char *) &long_return;

        case LEAF_snMacFilterIfAccessFilters:
            /* only one filter per port; 1 octet per filter; maximum ID 255
             */
            *var_len = 1;
            return_buf[0] = (UI8_T) entry.filter_id;
            return (u_char *) return_buf;

        case LEAF_snMacFilterIfAccessRowStatus:
            *var_len = 4;

            /* filter == 0; convert to "exists but is invalid"
             */
            if (entry.filter_id == 0)
            {
                long_return = VAL_snMacFilterIfAccessRowStatus_invalid;
            }

            /* filter != 0; convert to "exists and is valid"
             */
            else
            {
                long_return = VAL_snMacFilterIfAccessRowStatus_valid;
            }

            return (u_char *) &long_return;

        default:
            ERROR_MSG("");
            break;
    }

    /* return failure
     */
    return NULL;
}

int write_snMacFilterIfAccessFilters(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    /* dispatch action
     */
    switch (action)
    {
        case RESERVE1:
            /* check type and length
             */
            if (var_val_type != ASN_OCTET_STR)
            {
                return SNMP_ERR_WRONGTYPE;
            }

            /* Accton: only one filter per port
             */
            if (var_val_len != 1  /* was: SIZE_snMacFilterIfAccessFilters */)
            {
                return SNMP_ERR_WRONGLENGTH;
            }

            break;

        case RESERVE2:
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = 14;
            UI8_T byte_buffer[SIZE_snMacFilterIfAccessFilters] = {0};

            /* table-specific variables
             */
            UI32_T snMacFilterIfAccessPortIndex = 0;

            /* extract index
             */
            if (! snMacFilterIfAccessTable_OidIndexToData(TRUE,
                name_len - oid_name_length,
                &(name[oid_name_length]),
                &snMacFilterIfAccessPortIndex))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            /* get user value
             */
            memcpy(byte_buffer, var_val, var_val_len);

            /* set to core layer;
             * 1 filter per port; 1 byte per filter; assume maximum ID 255
             */
            if (! NETACCESS_PMGR_SetFilterIdToPort(snMacFilterIfAccessPortIndex,
                (UI32_T) byte_buffer[0]))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    /* return success
     */
    return SNMP_ERR_NOERROR;
}

int write_snMacFilterIfAccessRowStatus(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    /* dispatch action
     */
    switch (action)
    {
        case RESERVE1:
            /* check type and length
             */
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            /* check valid values
             */
            switch (*(long *) var_val)
            {
                case VAL_snMacFilterIfAccessRowStatus_invalid:
                    break;

                case VAL_snMacFilterIfAccessRowStatus_valid:
                    break;

                case VAL_snMacFilterIfAccessRowStatus_delete:
                    break;

                case VAL_snMacFilterIfAccessRowStatus_create:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = 14;
            I32_T value = 0;

            /* table-specific variables
             */
            UI32_T snMacFilterIfAccessPortIndex = 0;

            /* extract index
             */
            if (! snMacFilterIfAccessTable_OidIndexToData(TRUE,
                name_len - oid_name_length,
                &(name[oid_name_length]),
                &snMacFilterIfAccessPortIndex))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            /* get user value
             */
            memcpy(&value, var_val, sizeof(I32_T));

            /* set to core layer
             */
            switch (value)
            {
                /* convert to "invalid": set filter ID to 0
                 *
                 * The original filter ID is forgotten.
                 * We do not wrap another variable for valid vs. invalid.
                 */
                case VAL_snMacFilterIfAccessRowStatus_invalid:
                case VAL_snMacFilterIfAccessRowStatus_delete:
                    if (! NETACCESS_PMGR_SetFilterIdToPort(snMacFilterIfAccessPortIndex,
                        0))
                    {
                        return SNMP_ERR_COMMITFAILED;
                    }

                    break;

                /* "valid": nothing to do
                 *
                 * If you want to set a filter, use "snMacFilterIfAccessFilters".
                 * We do not wrap another variable for valid vs. invalid.
                 */
                case VAL_snMacFilterIfAccessRowStatus_valid:
                case VAL_snMacFilterIfAccessRowStatus_create:
                default:
                    break;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    /* return success
     */
    return SNMP_ERR_NOERROR;
}
#endif  /* (SYS_CPNT_NETACCESS_MACAUTH == TRUE); all of snMacFilterIfAccessTable */

#if (SYS_CPNT_RADIUS == TRUE)  /* all of snRadius */
/*--------------------------------------------------------------------------
 * SCALAR NAME - 1.1.3.12 snRadius.snRadiusGeneral(1).snRadiusRetransmit(3)
 *--------------------------------------------------------------------------
 */
void init_snRadiusRetransmit(void)
{
    static oid snRadiusRetransmit_oid[] = { 1,3,6,1,4,1,1991,1,1,3,12,1,3, 0 };

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("snRadiusRetransmit",
                               do_snRadiusRetransmit,
                               snRadiusRetransmit_oid,
                               OID_LENGTH(snRadiusRetransmit_oid),
                               HANDLER_CAN_RWRITE));
}

int do_snRadiusRetransmit(netsnmp_mib_handler *handler,
    netsnmp_handler_registration *reginfo,
    netsnmp_agent_request_info *reqinfo,
    netsnmp_request_info *requests)
{
    /* dispatch get vs. set
     */
    switch (reqinfo->mode)
    {
        /*
         * GET REQUEST
         */
        case MODE_GET:
        {
            UI32_T var_len = 0;
            UI32_T value = 0;

            /* get from core layer
             */
            value = RADIUS_POM_Get_Retransmit_Times();
            var_len = 4;
            memcpy(return_buf, &value, sizeof(value));
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                (u_char *) return_buf, var_len);

            break;
        }

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
                return SNMP_ERR_NOERROR;
            }
            break;

        case MODE_SET_RESERVE2:
            if ((*requests->requestvb->val.integer < MIN_snRadiusRetransmit)
                || (*requests->requestvb->val.integer > MAX_snRadiusRetransmit))
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
                return SNMP_ERR_NOERROR;
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called.
             */
            break;

        case MODE_SET_ACTION:
        {
            /* set to core layer
             */
            if (! RADIUS_PMGR_Set_Retransmit_Times(*requests->requestvb->val.integer))
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
                return SNMP_ERR_NOERROR;
            }

            break;
        }

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

/*--------------------------------------------------------------------------
 * SCALAR NAME - 1.1.3.12 snRadius.snRadiusGeneral(1).snRadiusTimeOut(4)
 *--------------------------------------------------------------------------
 */
void init_snRadiusTimeOut(void)
{
    static oid snRadiusTimeOut_oid[] = { 1,3,6,1,4,1,1991,1,1,3,12,1,4, 0 };

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("snRadiusTimeOut",
                               do_snRadiusTimeOut,
                               snRadiusTimeOut_oid,
                               OID_LENGTH(snRadiusTimeOut_oid),
                               HANDLER_CAN_RWRITE));
}

int do_snRadiusTimeOut(netsnmp_mib_handler *handler,
    netsnmp_handler_registration *reginfo,
    netsnmp_agent_request_info *reqinfo,
    netsnmp_request_info *requests)
{
    /* dispatch get vs. set
     */
    switch (reqinfo->mode)
    {
        /*
         * GET REQUEST
         */
        case MODE_GET:
        {
            UI32_T var_len = 0;
            UI32_T value = 0;

            /* get from core layer
             */
            value = RADIUS_POM_Get_Request_Timeout();
            var_len = 4;
            memcpy(return_buf, &value, sizeof(value));
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                (u_char *) return_buf, var_len);

            break;
        }

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
                return SNMP_ERR_NOERROR;
            }
            break;

        case MODE_SET_RESERVE2:
            if ((*requests->requestvb->val.integer < MIN_snRadiusTimeOut)
                || (*requests->requestvb->val.integer > MAX_snRadiusTimeOut))
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
                return SNMP_ERR_NOERROR;
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called.
             */
            break;

        case MODE_SET_ACTION:
        {
            /* set to core layer
             */
            if (! RADIUS_PMGR_Set_Request_Timeout(*requests->requestvb->val.integer))
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
                return SNMP_ERR_NOERROR;
            }

            break;
        }

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

/*--------------------------------------------------------------------------
 * SCALAR NAME - 1.1.3.12 snRadius.snRadiusGeneral(1).snRadiusKey(6)
 *--------------------------------------------------------------------------
 */
void init_snRadiusKey(void)
{
    static oid snRadiusKey_oid[] = { 1,3,6,1,4,1,1991,1,1,3,12,1,6, 0 };

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("snRadiusKey",
                               do_snRadiusKey,
                               snRadiusKey_oid,
                               OID_LENGTH(snRadiusKey_oid),
                               HANDLER_CAN_RWRITE));
}

int do_snRadiusKey(netsnmp_mib_handler *handler,
    netsnmp_handler_registration *reginfo,
    netsnmp_agent_request_info *reqinfo,
    netsnmp_request_info *requests)
{
    /* dispatch get vs. set
     */
    switch (reqinfo->mode)
    {
        /*
         * GET REQUEST
         */
        case MODE_GET:
        {
            UI32_T var_len = 0;

            char    core_sz[SYS_ADPT_RADIUS_SECRET_KEY_MAX_LENGTH + 1];
            char    *alloc_out_sz_p;  /* will get pointer from L_MM_Malloc; will be freed here */
            UI32_T  out_len;

            /* get core-layer value
             */
            /*!!PATCH: should call "RADIUS_POM_Get_Server_Secret";
             * but this function returns a pointer and is wrong
             */
            if (RADIUS_POM_GetRunningServerSecret(core_sz) == SYS_TYPE_GET_RUNNING_CFG_SUCCESS)
            {
                /* if not empty, call L_Base64
                 */
                if (core_sz[0] != '\0')
                {
                    /* According to the MIB object description, this is encrypted form.
                     * Accton encrypted form is BASE64.
                     * The following is based on the RADIUS section
                     * in "show running-config".
                     */
                    if (L_Base64(core_sz, strlen(core_sz), &alloc_out_sz_p, &out_len, L_BASE64_ENCODE))
                    {
                        memcpy(return_buf, alloc_out_sz_p, out_len);
                        return_buf[out_len] = '\0';

                        /* free buffer (no longer needed)
                         */
                        L_MM_Free(alloc_out_sz_p);

                        var_len = out_len;
                    }
                }
            }

            /* reply to user
             */
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                (u_char *) return_buf, var_len);

            break;
        }

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            if (requests->requestvb->type != ASN_OCTET_STR)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
                return SNMP_ERR_NOERROR;
            }
            if ((requests->requestvb->val_len < 0)
                || (requests->requestvb->val_len > FOUNDRY_LIB_ENCRYPTED_RADIUS_SECRET_MAX_LENGTH))
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGLENGTH);
                return SNMP_ERR_NOERROR;
            }
            break;

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called.
             */
            break;

        case MODE_SET_ACTION:
        {
            UI8_T   snRadiusKey[FOUNDRY_LIB_ENCRYPTED_RADIUS_SECRET_MAX_LENGTH + 1];
            char    plain_text_sz[SYS_ADPT_RADIUS_SECRET_KEY_MAX_LENGTH + 1] = {0};
            char    *alloc_out_sz_p;  /* will get pointer from L_MM_Malloc; will be freed below */
            UI32_T  out_len = 0;

            /* According to the MIB object description, this is encrypted form.
             * Accton encrypted form is BASE64.
             * The following is based on the CLI code for
             * "radius-server ... key" during provision.
             */

            /* get user value (encrypted text)
             */
            memcpy(snRadiusKey, requests->requestvb->val.string, requests->requestvb->val_len);
            snRadiusKey[requests->requestvb->val_len] = '\0';

            /* if not empty, call L_Base64
             */
            if (requests->requestvb->val_len != 0)
            {
                /* convert to core-layer value (ASCII text)
                 *
                 * If this succeedes, alloc_out_sz_p contains a buffer from L_MM_Malloc and
                 * must be freed later.
                 */
                if (! L_Base64(snRadiusKey, requests->requestvb->val_len, &alloc_out_sz_p, &out_len, L_BASE64_DECODE))
                {
                    return SNMP_ERR_WRONGVALUE;
                }

                /* check output length, collect output value, and free buffer;
                 *
                 * The input length was already checked in RESERVE1.
                 * But output (plain-text) length still needs to be checked,
                 * especially if the maximum (plain-text) is not a multiple of 3.
                 */
                if (out_len > SYS_ADPT_RADIUS_SECRET_KEY_MAX_LENGTH)
                {
                    /* free buffer (no longer needed)
                     */
                    L_MM_Free(alloc_out_sz_p);

                    return SNMP_ERR_WRONGVALUE;
                }
                else
                {
                    memcpy(plain_text_sz, alloc_out_sz_p, out_len);
                    plain_text_sz[out_len] = '\0';
                    
                    /* free buffer (no longer needed)
                     */
                    L_MM_Free(alloc_out_sz_p);
                }
            }

            /* set to core layer
             */
            if (! RADIUS_PMGR_Set_Server_Secret(plain_text_sz))
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
                return SNMP_ERR_NOERROR;
            }

            break;
        }

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

/*--------------------------------------------------------------------------
 * SCALAR NAME - 1.1.3.12 snRadius.snRadiusGeneral(1).snRadiusLoginMethod(7)
 * SCALAR NAME - 1.1.3.12 snRadius.snRadiusGeneral(1).snRadiusWebServerMethod(9)
 *--------------------------------------------------------------------------
 */
void init_snRadiusLoginMethod(void)
{
    /* Accton has only a systemwide "authentication method".
     * Hard-code this to register both nodes to the same routine, for now.
     */
    static oid snRadiusLoginMethod_oid[] = { 1,3,6,1,4,1,1991,1,1,3,12,1,7, 0 };
    static oid snRadiusWebServerMethod_oid[] = { 1,3,6,1,4,1,1991,1,1,3,12,1,9, 0 };

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("snRadiusLoginMethod",
                               do_snRadiusLoginMethod,
                               snRadiusLoginMethod_oid,
                               OID_LENGTH(snRadiusLoginMethod_oid),
                               HANDLER_CAN_RWRITE));

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("snRadiusWebServerMethod",
                               do_snRadiusLoginMethod,  /* shared with above */
                               snRadiusWebServerMethod_oid,
                               OID_LENGTH(snRadiusLoginMethod_oid),
                               HANDLER_CAN_RWRITE));
}

int do_snRadiusLoginMethod(netsnmp_mib_handler *handler,
    netsnmp_handler_registration *reginfo,
    netsnmp_agent_request_info *reqinfo,
    netsnmp_request_info *requests)
{
    /* dispatch get vs. set
     */
    switch (reqinfo->mode)
    {
        /*
         * GET REQUEST
         */
        case MODE_GET:
        {
            UI32_T var_len = 0;
            USERAUTH_Auth_Method_T auth_method[USERAUTH_NUMBER_Of_AUTH_METHOD] = {0};

            /* get from core layer
             * Accton maximum: USERAUTH_NUMBER_Of_AUTH_METHOD = 3
             * Brocade maximum: MAXSIZE_snRadiusLoginMethod = 7
             */
            if (USERAUTH_PMGR_GetAuthMethod(auth_method))
            {
                UI32_T precedence;

                /* assume maximum length; if not, then truncate
                 */
                var_len = USERAUTH_NUMBER_Of_AUTH_METHOD;

                /* convert to user value
                 *
                 * Allow no holes, and quit at empty element.
                 * Hard-coded values do not have code-gen'd constants.
                 * See DESCRIPTION in MIB node.
                 */
                for (precedence = 0;
                    (precedence < USERAUTH_NUMBER_Of_AUTH_METHOD)
                        && (auth_method[precedence] != USERAUTH_AUTH_NONE);
                    precedence++)
                {
                    switch (auth_method[precedence])
                    {
                        /* local
                         */
                        case USERAUTH_AUTH_LOCAL:
                            return_buf[precedence] = 3;  /* local(3) */
                            break;

                        /* RADIUS
                         */
                        case USERAUTH_AUTH_RADIUS:
                            return_buf[precedence] = 2;  /* radius(2) */
                            break;

                        /* TACACS Plus
                         */
                        case USERAUTH_AUTH_TACACS:
                            return_buf[precedence] = 5;  /* tacplus(5) */
                            break;

                        /* should not happen; if happens, is a bug
                         */
                        default:
                            return_buf[precedence] = 0;
                            break;
                    }  /* switch (auth_method[precedence]) */
                }  /* for (precedence) */

                /* length is 0-based precedence which causes "for" to quit
                 */
                var_len = precedence;

                /* reply to user
                 */
                snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                    (u_char *) return_buf, var_len);
            }
            else
            {
                return SNMP_ERR_GENERR;
            }

            break;
        }

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            /* check type and length
             */
            if (requests->requestvb->type != ASN_OCTET_STR)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
                return SNMP_ERR_NOERROR;
            }

            if ((requests->requestvb->val_len < MINSIZE_snRadiusLoginMethod)
                || (requests->requestvb->val_len > USERAUTH_NUMBER_Of_AUTH_METHOD))
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGLENGTH);
                return SNMP_ERR_NOERROR;
            }

            break;

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called.
             */
            break;

        case MODE_SET_ACTION:
        {
            UI8_T snRadiusLoginMethod[MAXSIZE_snRadiusLoginMethod];
            UI32_T precedence;
            USERAUTH_Auth_Method_T auth_method[USERAUTH_NUMBER_Of_AUTH_METHOD] = {0};

            /* get user value (octet string)
             * Accton maximum: USERAUTH_NUMBER_Of_AUTH_METHOD = 3
             * Brocade maximum: MAXSIZE_snRadiusLoginMethod = 7
             */
            memcpy(snRadiusLoginMethod, requests->requestvb->val.string, requests->requestvb->val_len);

            /* initialise core-layer buffer to default
             *
             * From DESCRIPTION:
             * Setting a zero length octet string invalidates all
 	         * previous authentication methods.
             */
            auth_method[0] = USERAUTH_AUTH_LOCAL;

            for (precedence = 1;
                precedence < USERAUTH_NUMBER_Of_AUTH_METHOD;
                precedence++)
            {
                auth_method[precedence] = USERAUTH_AUTH_NONE;
            }

            /* convert to core-layer value
             *
             * Allow no holes, and quit at empty element.
             * Hard-coded values do not have code-gen'd constants.
             * See DESCRIPTION in MIB node.
             */
            for (precedence = 0;
                (precedence < USERAUTH_NUMBER_Of_AUTH_METHOD)
                    && (precedence < requests->requestvb->val_len)
                    && (snRadiusLoginMethod[precedence] != USERAUTH_AUTH_NONE);
                precedence++)
            {
                switch (snRadiusLoginMethod[precedence])
                {
                    /* local
                     */
                    case 3:  /* local(3) */
                        auth_method[precedence] = USERAUTH_AUTH_LOCAL;
                        break;

                    /* RADIUS */
                    case 2:  /* radius(2) */
                        auth_method[precedence] = USERAUTH_AUTH_RADIUS;
                        break;

                    /* TACACS Plus
                     */
                    case 5:  /* tacplus(5) */
                        auth_method[precedence] = USERAUTH_AUTH_TACACS;
                        break;

                    /* unsupported value
                     */
                    default:
                        netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
                        break;
                }  /* switch (snRadiusLoginMethod[precedence]) */
            }  /* for (precedence) */

            /* set to core layer
             */
            if (! USERAUTH_PMGR_SetAuthMethod(auth_method))
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
                return SNMP_ERR_NOERROR;
            }

            break;
        }

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

/* ------------------------------------------------------------------------
 * FUNCTION NAME - init_snRadius
 * ------------------------------------------------------------------------
 * PURPOSE  :   The is the entry point for the "1.1.3.12 snRadius" subtree.
 *
 * INPUT    :   None.
 *
 * OUTPUT   :   None.
 *
 * RETURN   :   None.
 *
 * NOTES    :   None.
 * ------------------------------------------------------------------------
 */
void init_snRadius(void)
{
    /* init individual scalars
     */
    init_snRadiusRetransmit();  /* 3 */
    init_snRadiusTimeOut();     /* 4 */
    init_snRadiusKey();         /* 6 */
    init_snRadiusLoginMethod(); /* 7, shared with snRadiusWebServerMethod(9) */
}
#endif  /* (SYS_CPNT_RADIUS == TRUE); all of snRadius */

#if (SYS_CPNT_TACACS == TRUE)  /* all of snTacacs */
/*--------------------------------------------------------------------------
 * SCALAR NAME - 1.1.3.13 snTacacs.snTacacsGeneral(1).snTacacsKey(4)
 *--------------------------------------------------------------------------
 */
void init_snTacacsKey(void)
{
    static oid snTacacsKey_oid[] = { 1,3,6,1,4,1,1991,1,1,3,13,1,4, 0 };

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("snTacacsKey",
                               do_snTacacsKey,
                               snTacacsKey_oid,
                               OID_LENGTH(snTacacsKey_oid),
                               HANDLER_CAN_RWRITE));
}

int do_snTacacsKey(netsnmp_mib_handler *handler,
    netsnmp_handler_registration *reginfo,
    netsnmp_agent_request_info *reqinfo,
    netsnmp_request_info *requests)
{
    /* dispatch get vs. set
     */
    switch (reqinfo->mode)
    {
        /*
         * GET REQUEST
         */
        case MODE_GET:
        {
            UI32_T var_len = 0;

            char    core_sz[SYS_ADPT_RADIUS_SECRET_KEY_MAX_LENGTH + 1];
            char    *alloc_out_sz_p;  /* will get pointer from L_MM_Malloc; will be freed here */
            UI32_T  out_len;

            /* get core-layer value
             */
            if (TACACS_POM_Get_Server_Secret(core_sz))
            {
                /* According to the MIB object description, this is encrypted form.
                 * Accton encrypted form is BASE64.
                 * The following is based on the TACACS+ section
                 * in "show running-config".
                 */

                /* if not empty, call L_Base64
                 */
                if (core_sz[0] != '\0')
                {
                    if (L_Base64(core_sz, strlen(core_sz), &alloc_out_sz_p, &out_len, L_BASE64_ENCODE))
                    {
                        memcpy(return_buf, alloc_out_sz_p, out_len);
                        return_buf[out_len] = '\0';

                        /* free buffer (no longer needed)
                         */
                        L_MM_Free(alloc_out_sz_p);

                        var_len = out_len;
                    }
                }
            }

            /* reply to user
             */
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                (u_char *) return_buf, var_len);

            break;
        }

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            if (requests->requestvb->type != ASN_OCTET_STR)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
                return SNMP_ERR_NOERROR;
            }
            if ((requests->requestvb->val_len < 0)
                || (requests->requestvb->val_len > FOUNDRY_LIB_ENCRYPTED_RADIUS_SECRET_MAX_LENGTH))
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGLENGTH);
                return SNMP_ERR_NOERROR;
            }
            break;

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called.
             */
            break;

        case MODE_SET_ACTION:
        {
            UI8_T   snTacacsKey[FOUNDRY_LIB_ENCRYPTED_RADIUS_SECRET_MAX_LENGTH + 1];
            char    plain_text_sz[SYS_ADPT_RADIUS_SECRET_KEY_MAX_LENGTH + 1] = {0};
            char    *alloc_out_sz_p;  /* will get pointer from L_MM_Malloc; will be freed below */
            UI32_T  out_len = 0;

            /* According to the MIB object description, this is encrypted form.
             * Accton encrypted form is BASE64.
             * The following is based on the CLI code for
             * "Tacacs-server ... key" during provision.
             */

            /* get user value (encrypted text)
             */
            memcpy(snTacacsKey, requests->requestvb->val.string, requests->requestvb->val_len);
            snTacacsKey[requests->requestvb->val_len] = '\0';

            /* if not empty, call L_Base64
             */
            if (requests->requestvb->val_len != 0)
            {
                /* convert to core-layer value (ASCII text)
                 *
                 * If this succeedes, alloc_out_sz_p contains a buffer from L_MM_Malloc and
                 * must be freed later.
                 */
                if (! L_Base64(snTacacsKey, requests->requestvb->val_len, &alloc_out_sz_p, &out_len, L_BASE64_DECODE))
                {
                    return SNMP_ERR_WRONGVALUE;
                }

                /* check output length, collect output value, and free buffer;
                 *
                 * The input (encrypted) length was already checked in RESERVE1.
                 * But output (plain-text) length still needs to be checked,
                 * especially if the maximum (plain-text) is not a multiple of 3.
                 */
                if (out_len > SYS_ADPT_RADIUS_SECRET_KEY_MAX_LENGTH)
                {
                    /* free buffer (no longer needed)
                     */
                    L_MM_Free(alloc_out_sz_p);

                    return SNMP_ERR_WRONGVALUE;
                }
                else
                {
                    memcpy(plain_text_sz, alloc_out_sz_p, out_len);
                    plain_text_sz[out_len] = '\0';
                    
                    /* free buffer (no longer needed)
                     */
                    L_MM_Free(alloc_out_sz_p);
                }
            }

            /* set to core layer
             */
            if (! TACACS_PMGR_Set_Server_Secret(plain_text_sz))
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
                return SNMP_ERR_NOERROR;
            }

            break;
        }

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

/* ------------------------------------------------------------------------
 * FUNCTION NAME - init_snTacacs
 * ------------------------------------------------------------------------
 * PURPOSE  :   The is the entry point for the "1.1.3.13 snTacacs" subtree.
 *
 * INPUT    :   None.
 *
 * OUTPUT   :   None.
 *
 * RETURN   :   None.
 *
 * NOTES    :   None.
 * ------------------------------------------------------------------------
 */
void init_snTacacs(void)
{
    /* init individual scalars
     */
    init_snTacacsKey();         /* 4 */
}
#endif  /* (SYS_CPNT_RADIUS == TRUE); all of snTacacs */

#if (SYS_CPNT_AUTHORIZATION == TRUE)  /* all of snAuthorization */
/*--------------------------------------------------------------------------
 * SCALAR NODES - 1.1.3.15 snAAA.snAuthorization(2).snAuthorizationExec(3)
 *--------------------------------------------------------------------------
 */
void init_snAuthorizationExec(void)
{
    static oid snAuthorizationExec_oid[] = { 1,3,6,1,4,1,1991,1,1,3,15,2,3, 0 };

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("snAuthorizationExec",
                               do_snAuthorizationExec,
                               snAuthorizationExec_oid,
                               OID_LENGTH(snAuthorizationExec_oid),
                               HANDLER_CAN_RWRITE));
}

int do_snAuthorizationExec(netsnmp_mib_handler *handler,
    netsnmp_handler_registration *reginfo,
    netsnmp_agent_request_info *reqinfo,
    netsnmp_request_info *requests)
{
    /* hard-coded text; recommended place "aaa_type.h"
     */
    char *default_p = "default",
         *tacacs_p = "tacacs+";

    AAA_AuthorListEntryInterface_T aaa_author_list_entry;
    AAA_AuthorExecEntry_T author_exec_entry;

    /* dispatch get vs. set
     */
    switch (reqinfo->mode)
    {
        /*
         * GET REQUEST
         */
        case MODE_GET:
        {
            UI32_T var_len = 0;
            BOOL_T vty_enabled = FALSE;

            memset(&aaa_author_list_entry, 0, sizeof(AAA_AuthorListEntryInterface_T));
            memset(&author_exec_entry, 0, sizeof(AAA_AuthorExecEntry_T));

            /* check whether VTY is hard-coded "default"; treat as enabled
             */
            author_exec_entry.exec_type = AAA_EXEC_TYPE_VTY;
            AAA_POM_GetAuthorExecEntry_Ex(&author_exec_entry);

            if (strcmp(author_exec_entry.list_name, default_p) == 0)
            {
                vty_enabled = TRUE;
            }

            /* if VTY is disabled, return none(6)
             */
            if (! vty_enabled)
            {
                var_len = 1;
                *(UI8_T *) return_buf = 6;
                snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                    (u_char *) return_buf, var_len);
                break;
            }

            /* prepare for fixed type to get next from 0 (= get first)
             */
            aaa_author_list_entry.client_type = AAA_CLIENT_TYPE_EXEC;
            aaa_author_list_entry.list_index = 0;

            /* get from core layer
             */
            while (AAA_POM_GetNextAuthorListEntryFilterByClientType(&aaa_author_list_entry))
            {
                /* check for the appearance of the entry called "default"
                 * (hard-coded; recommended place is "aaa_type.h")
                 */
                if (strcmp(aaa_author_list_entry.list_name, default_p) == 0)
                {
                    var_len = 1;

                    /* content is hard-coded "tacacs+"
                     */
                    if (strcmp(aaa_author_list_entry.group_name, tacacs_p) == 0)
                    {
                        /* tacplus(5) from MIB object descr.
                         */
                        *(UI8_T *) return_buf = 5;
                    }

                    /* other; assume none
                     */
                    else
                    {
                        /* none(6) from MIB object descr.
                         */
                        *(UI8_T *) return_buf = 6;
                    }

                    /* found
                     */
                    break;
                }
            }

            /* reply to user
             */
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                (u_char *) return_buf, var_len);

            break;
        }

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            /* check type and length
             */
            if (requests->requestvb->type != ASN_OCTET_STR)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
                return SNMP_ERR_NOERROR;
            }

            if ((requests->requestvb->val_len < MINSIZE_snAuthorizationExec)
                || (requests->requestvb->val_len > 1  /* was: MAXSIZE_snAuthorizationExec */))
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGLENGTH);
                return SNMP_ERR_NOERROR;
            }

            break;

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called.
             */
            break;

        case MODE_SET_ACTION:
        {
            UI8_T snAuthorizationExec_ar[1] = {6};  /* at most one type; default none(6) */

            AAA_AuthorExecEntry_T aaa_author_exec_entry;
            BOOL_T vty_enabled = FALSE;
            char *group_p = "";

            /* get user value
             */
            if (requests->requestvb->val_len == 1)
            {
                memcpy(snAuthorizationExec_ar, requests->requestvb->val.string, 1);
            }

            /* convert user value to core-layer value
             *
             * User values are hard-coded according to the MIB object descr.
             */
            switch (snAuthorizationExec_ar[0])
            {
                /* tacplus(5)
                 */
                case 5:
                    vty_enabled = TRUE;
                    group_p = tacacs_p;
                    break;

                /* none(6)
                 */
                case 6:
                    break;

                /* unexpected value
                 */
                default:
                    netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
                    return SNMP_ERR_NOERROR;
            }

            /* if to disable, disable VTY
             */
            if (! vty_enabled)
            {
                if (! AAA_PMGR_DisableAuthorExecEntry(AAA_EXEC_TYPE_VTY))
                {
                    netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
                }

                /* done with "disable"; return
                 */
                return SNMP_ERR_NOERROR;
            }

            /* now: set to core layer to enable
             */
            strcpy(aaa_author_exec_entry.list_name, default_p);
            aaa_author_exec_entry.exec_type = AAA_EXEC_TYPE_VTY;

            if ( (! AAA_PMGR_SetAuthorDefaultList(AAA_CLIENT_TYPE_EXEC,
                        group_p))
                || (! AAA_PMGR_SetAuthorExecEntry(&aaa_author_exec_entry)) )
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
                return SNMP_ERR_NOERROR;
            }

            break;
        }

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
#endif  /* (SYS_CPNT_AUTHORIZATION == TRUE); all of snAuthorization */

#if (SYS_CPNT_ACCOUNTING == TRUE)  /* all of snAccounting */
/*--------------------------------------------------------------------------
 * SCALAR NODES - 1.1.3.15 snAAA.snAccounting(3).snAccountingExec(3)
 *--------------------------------------------------------------------------
 */
void init_snAccountingExec(void)
{
    static oid snAccountingExec_oid[] = { 1,3,6,1,4,1,1991,1,1,3,15,3,3, 0 };

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("snAccountingExec",
                               do_snAccountingExec,
                               snAccountingExec_oid,
                               OID_LENGTH(snAccountingExec_oid),
                               HANDLER_CAN_RWRITE));
}

int do_snAccountingExec(netsnmp_mib_handler *handler,
    netsnmp_handler_registration *reginfo,
    netsnmp_agent_request_info *reqinfo,
    netsnmp_request_info *requests)
{
    /* hard-coded text; recommended place "aaa_type.h"
     */
    char *default_p = "default",
         *radius_p = "radius",
         *tacacs_p = "tacacs+";

    AAA_AccListEntryInterface_T aaa_acc_list_entry;
    AAA_AccExecEntry_T acc_exec_entry;

    /* From MIB object description:
     * 1. It does not support group name, so use "default".
     * 2. This is for VTY only, not for console.
     */

    /* dispatch get vs. set
     */
    switch (reqinfo->mode)
    {
        /*
         * GET REQUEST
         */
        case MODE_GET:
        {
            UI32_T var_len = 0;
            BOOL_T vty_enabled = FALSE;

            memset(&aaa_acc_list_entry, 0, sizeof(AAA_AccListEntryInterface_T));
            memset(&acc_exec_entry, 0, sizeof(AAA_AccExecEntry_T));

            /* check whether VTY is hard-coded "default"; treat as enabled
             */
            acc_exec_entry.exec_type = AAA_EXEC_TYPE_VTY;
            AAA_POM_GetAccExecEntry_Ex(&acc_exec_entry);

            if (strcmp(acc_exec_entry.list_name, default_p) == 0)
            {
                vty_enabled = TRUE;
            }

            /* if VTY is disabled, return none(6)
             */
            if (! vty_enabled)
            {
                var_len = 1;
                *(UI8_T *) return_buf = 6;
                snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                    (u_char *) return_buf, var_len);
                break;
            }

            /* prepare for fixed type to get next from 0 (= get first)
             */
            aaa_acc_list_entry.client_type = AAA_CLIENT_TYPE_EXEC;
            aaa_acc_list_entry.list_index = 0;

            /* get from core layer
             */
            while (AAA_POM_GetNextAccListEntryFilterByClientType(&aaa_acc_list_entry))
            {
                /* check for the appearance of the entry called "default"
                 */
                if (strcmp(aaa_acc_list_entry.list_name, default_p) == 0)
                {
                    var_len = 1;

                    /* content is hard-coded "radius"
                     */
                    if (strcmp(aaa_acc_list_entry.group_name, radius_p) == 0)
                    {
                        /* radius(2) from MIB object descr.
                         */
                        *(UI8_T *) return_buf = 2;
                    }

                    /* content is hard-coded "tacacs+"
                     */
                    else if (strcmp(aaa_acc_list_entry.group_name, tacacs_p) == 0)
                    {
                        /* tacplus(5) from MIB object descr.
                         */
                        *(UI8_T *) return_buf = 5;
                    }

                    /* other; assume none
                     */
                    else
                    {
                        /* none(6) from MIB object descr.
                         */
                        *(UI8_T *) return_buf = 6;
                    }

                    /* found
                     */
                    break;
                }
            }

            /* reply to user
             */
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                (u_char *) return_buf, var_len);

            break;
        }

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            /* check type and length
             */
            if (requests->requestvb->type != ASN_OCTET_STR)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
                return SNMP_ERR_NOERROR;
            }

            /* we accept at most one type at a time
             */
            if ((requests->requestvb->val_len < MINSIZE_snAccountingExec)
                || (requests->requestvb->val_len > 1  /* was: MAXSIZE_snAccountingExec */))
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGLENGTH);
                return SNMP_ERR_NOERROR;
            }

            break;

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called.
             */
            break;

        case MODE_SET_ACTION:
        {
            UI8_T snAccountingExec_ar[1] = {6};  /* at most one type; default none(6) */

            AAA_AccExecEntry_T aaa_acc_exec_entry;

#if (FOUNDRY_LIB_PLATFORM_STYLE == FOUNDRY_LIB_PLATFORM_STYLE_EDGE_CORE)
            AAA_AccListEntryInterface_T aaa_acc_list_entry;
#endif

            BOOL_T vty_enabled = FALSE;
            char *group_p = "";

            memset(&aaa_acc_exec_entry, 0, sizeof(AAA_AccExecEntry_T));

            /* get user value
             */
            if (requests->requestvb->val_len == 1)
            {
                memcpy(snAccountingExec_ar, requests->requestvb->val.string, 1);
            }

            /* convert user value to core-layer value
             *
             * User values are hard-coded according to the MIB object descr.
             */
            switch (snAccountingExec_ar[0])
            {
                /* radius(2)
                 */
                case 2:
                    vty_enabled = TRUE;
                    group_p = radius_p;
                    break;

                /* tacplus(5)
                 */
                case 5:
                    vty_enabled = TRUE;
                    group_p = tacacs_p;
                    break;

                /* none(6)
                 */
                case 6:
                    break;

                /* unexpected value
                 */
                default:
                    netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
                    return SNMP_ERR_NOERROR;
            }

            /* if to disable, disable VTY
             */
            if (! vty_enabled)
            {
                if (! AAA_PMGR_DisableAccExecEntry(AAA_EXEC_TYPE_VTY))
                {
                    netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
                }

                /* done with "disable"; return
                 */
                return SNMP_ERR_NOERROR;
            }

            /* now: set to core layer to enable
             */
            strcpy(aaa_acc_exec_entry.list_name, default_p);
            aaa_acc_exec_entry.exec_type = AAA_EXEC_TYPE_VTY;

#if (FOUNDRY_LIB_PLATFORM_STYLE == FOUNDRY_LIB_PLATFORM_STYLE_SIMBA)
            if ( (! AAA_PMGR_SetDefaultList(AAA_CLIENT_TYPE_EXEC, ACCOUNTING_START_STOP,
                        group_p))
                || (! AAA_PMGR_SetAccExecEntry(&aaa_acc_exec_entry)) )
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
                return SNMP_ERR_NOERROR;
            }
#endif

#if (FOUNDRY_LIB_PLATFORM_STYLE == FOUNDRY_LIB_PLATFORM_STYLE_EDGE_CORE)
            aaa_acc_list_entry.client_type = AAA_CLIENT_TYPE_EXEC;
            aaa_acc_list_entry.working_mode= ACCOUNTING_START_STOP;
            strcpy(aaa_acc_list_entry.group_name, group_p);

            if ( (! AAA_PMGR_SetDefaultList(&aaa_acc_list_entry))
                || (! AAA_PMGR_SetAccExecEntry(&aaa_acc_exec_entry)) )
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
                return SNMP_ERR_NOERROR;
            }
#endif

            break;
        }

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
#endif  /* (SYS_CPNT_ACCOUNTING == TRUE); all of snAccounting */

#if (SYS_CPNT_AAA == TRUE)  /* all of snAAA */
/* ------------------------------------------------------------------------
 * FUNCTION NAME - init_snAAA
 * ------------------------------------------------------------------------
 * PURPOSE  :   The is the entry point for the "1.1.3.15 snAAA" subtree.
 *
 * INPUT    :   None.
 *
 * OUTPUT   :   None.
 *
 * RETURN   :   None.
 *
 * NOTES    :   None.
 * ------------------------------------------------------------------------
 */
void init_snAAA(void)
{
    /* init individual scalars
     */
#if (SYS_CPNT_AUTHORIZATION == TRUE) 
    init_snAuthorizationExec();     /* 2.3 */
#endif

#if (SYS_CPNT_ACCOUNTING == TRUE)
    init_snAccountingExec();        /* 3.3 */
#endif
}
#endif  /* (SYS_CPNT_AAA == TRUE); all of snAAA */

#if (SYS_CPNT_PORT_SECURITY == TRUE)  /* all of snPortMacSecurityIntfContentTable */
/*--------------------------------------------------------------------------
 * TABLE NAME - 1.1.3.24.1.1.3 snPortMacSecurityIntfContentTable
 *--------------------------------------------------------------------------
 */
oid snPortMacSecurityIntfContentTable_variables_oid[] = { 1,3,6,1,4,1,1991,1,1,3,24,1,1 };

/* variable3 snPortMacSecurityIntfContentTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */
struct variable3 snPortMacSecurityIntfContentTable_variables[] =
{
    /* magic number, variable type, ro/rw, callback fn, L, oidsuffix
     *     (L = length of the oidsuffix)
     */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_snPortMacSecurityIntfContentIfIndex, ASN_INTEGER, RONLY, var_snPortMacSecurityIntfContentTable, 3, { 3, 1, 1 }},
#endif  /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

    { LEAF_snPortMacSecurityIntfContentSecurity, ASN_INTEGER, RWRITE, var_snPortMacSecurityIntfContentTable, 3, { 3, 1, 2 }},
    { LEAF_snPortMacSecurityIntfContentViolationType, ASN_INTEGER, RWRITE, var_snPortMacSecurityIntfContentTable, 3, { 3, 1, 3 }},
    { LEAF_snPortMacSecurityIntfContentShutdownTime, ASN_UNSIGNED, RWRITE, var_snPortMacSecurityIntfContentTable, 3, { 3, 1, 4 }},
    { LEAF_snPortMacSecurityIntfContentShutdownTimeLeft, ASN_UNSIGNED, RONLY, var_snPortMacSecurityIntfContentTable, 3, { 3, 1, 5 }},
    { LEAF_snPortMacSecurityIntfContentAgeOutTime, ASN_UNSIGNED, RWRITE, var_snPortMacSecurityIntfContentTable, 3, { 3, 1, 6 }},
    { LEAF_snPortMacSecurityIntfContentMaxLockedMacAllowed, ASN_UNSIGNED, RWRITE, var_snPortMacSecurityIntfContentTable, 3, { 3, 1, 7 }},
    { LEAF_snPortMacSecurityIntfContentTotalMACs, ASN_UNSIGNED, RONLY, var_snPortMacSecurityIntfContentTable, 3, { 3, 1, 8 }},
    { LEAF_snPortMacSecurityIntfContentViolationCounts, ASN_UNSIGNED, RONLY, var_snPortMacSecurityIntfContentTable, 3, { 3, 1, 9 }},
};

void init_snPortMacSecurityIntfContentTable(void)
{
    /* Register ourselves with the agent to handle our MIB tree
     */
    REGISTER_MIB("snPortMacSecurityIntfContentTable", snPortMacSecurityIntfContentTable_variables, variable3,
                 snPortMacSecurityIntfContentTable_variables_oid);
}

#define SNPORTMACSECURITYINTFCONTENTENTRY_INSTANCE_LEN  1

BOOL_T snPortMacSecurityIntfContentTable_OidIndexToData(UI32_T exact, UI32_T compc,
    oid *compl, UI32_T *snPortMacSecurityIntfContentIfIndex)
{
    /* get or set
     */
    if (exact)
    {
        /* check the index length
         */
        if (compc != SNPORTMACSECURITYINTFCONTENTENTRY_INSTANCE_LEN)  /* the constant size index */
        {
            return FALSE;
        }
    }

    *snPortMacSecurityIntfContentIfIndex = compl[0];

    return TRUE;
}

/*
 * var_snPortMacSecurityIntfContentTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *var_snPortMacSecurityIntfContentTable(struct variable *vp,
    oid *name,
    size_t *length,
    int exact,
    size_t *var_len,
    WriteMethod **write_method)
{
    UI32_T compc = 0;
    oid compl[SNPORTMACSECURITYINTFCONTENTENTRY_INSTANCE_LEN] = {0};
    oid best_inst[SNPORTMACSECURITYINTFCONTENTENTRY_INSTANCE_LEN] = {0};

    /* table-specific variables
     */
    PSEC_MGR_PortSecurityEntry_T entry;

    /* dispatch node to set write method
     */
    switch (vp->magic)
    {
        case LEAF_snPortMacSecurityIntfContentSecurity:
            *write_method = write_snPortMacSecurityIntfContentSecurity;
            break;

        case LEAF_snPortMacSecurityIntfContentViolationType:
            *write_method = write_snPortMacSecurityIntfContentViolationType;
            break;

        case LEAF_snPortMacSecurityIntfContentShutdownTime:
            *write_method = write_snPortMacSecurityIntfContentShutdownTime;
            break;

        case LEAF_snPortMacSecurityIntfContentAgeOutTime:
            *write_method = write_snPortMacSecurityIntfContentAgeOutTime;
            break;

        case LEAF_snPortMacSecurityIntfContentMaxLockedMacAllowed:
            *write_method = write_snPortMacSecurityIntfContentMaxLockedMacAllowed;
            break;

        default:
            *write_method = 0;
            break;
    }

    /* check compc, retrive compl
     */
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl,
        SNPORTMACSECURITYINTFCONTENTENTRY_INSTANCE_LEN);

    memset(&entry, 0, sizeof(entry));

    /* dispatch get-exact versus get-next
     */
    if (exact)  /* get or set */
    {
        /* extract index
         */
        if (! snPortMacSecurityIntfContentTable_OidIndexToData(exact, compc, compl,
            &entry.portsec_port_index))
        {
            return NULL;
        }

        /* get-exact from core layer
         */
        if (! PSEC_PMGR_GetPortSecurityEntry(&entry))
        {
            return NULL;
        }
    }
    else  /* get-next */
    {
        /* extract index
         */
        snPortMacSecurityIntfContentTable_OidIndexToData(exact, compc, compl,
            &entry.portsec_port_index);

        /* Check the length of inputing index. If compc is less than instance
         * length, we should try get {A.B.C.0.0...}, where A.B.C was
         * obtained from the "..._OidIndexToData" function call, and
         * 0.0... was initialized in the beginning of this function.
         * This instance may exist in the core layer.
         */
        if (compc < SNPORTMACSECURITYINTFCONTENTENTRY_INSTANCE_LEN)  /* incomplete index */
        {
            /* get-exact, in case this instance exists
             */
            if (! PSEC_PMGR_GetPortSecurityEntry(&entry))
            {
                /* get-next according to lexicographic order; if none, fail
                 */
                if (! PSEC_PMGR_GetNextPortSecurityEntry(&entry))
                {
                    return NULL;
                }
            }
        }
        else  /* complete index */
        {
            /* get-next according to lexicographic order; if none, fail
             */
            if (! PSEC_PMGR_GetNextPortSecurityEntry(&entry))
            {
                return NULL;
            }
        }
    }

    /* copy base OID (without index) to output
     */
    memcpy(name, vp->name, vp->namelen * sizeof(oid));

    /* assign data to the OID index
     */
    best_inst[0] = entry.portsec_port_index;
    memcpy(name + vp->namelen, best_inst, SNPORTMACSECURITYINTFCONTENTENTRY_INSTANCE_LEN * sizeof(oid));
    *length = vp->namelen + SNPORTMACSECURITYINTFCONTENTENTRY_INSTANCE_LEN;

    /* dispatch node to read value
     */
    switch (vp->magic)
    {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case LEAF_snPortMacSecurityIntfContentIfIndex:
            *var_len = 4;
            long_return = entry.portsec_port_index;
            return (u_char *) &long_return;
#endif  /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

        /* snPortMacSecurityIntfContentSecurity
         */
        case LEAF_snPortMacSecurityIntfContentSecurity:
            *var_len = 4;

            /* convert to user value
             */
            long_return = FOUNDRY_LIB_ConvertAcctonToFoundryEnabledStatus
                (entry.portsec_port_status);

            return (u_char *) &long_return;

        /* snPortMacSecurityIntfContentViolationType
         */
        case LEAF_snPortMacSecurityIntfContentViolationType:
            {
                *var_len = 4;
                UI32_T core_val;

                /* get from core layer
                 */
                if (! PSEC_PMGR_GetPortSecurityActionStatus(entry.portsec_port_index,
                    &core_val))
                {
                    return NULL;
                }

                /* convert to user value; trap not supported
                 */
                switch (core_val)
                {
                    /*  Broacde's "restrict"
                     */
                    case VAL_portSecAction_none:
                    case VAL_portSecAction_trap:
                        long_return = VAL_snPortMacSecurityIntfContentViolationType_restrict;
                        break;

                    /* Brocade's "shutdown"
                     */
                    case VAL_portSecAction_shutdown:
                    case VAL_portSecAction_trapAndShutdown:
                        long_return = VAL_snPortMacSecurityIntfContentViolationType_shutdown;
                        break;

                    /* should not happen; if happens; is a bug
                     */
                    default:
                        long_return = VAL_snPortMacSecurityIntfContentViolationType_restrict;
                        break;
                }

                return (u_char*) &long_return;
            }

        /* snPortMacSecurityIntfContentShutdownTime
         */
        case LEAF_snPortMacSecurityIntfContentShutdownTime:
            *var_len = 4;
            long_return = 0;  /* Accton: portSecShutdownInterval */
            return (u_char *) &long_return;

        /* snPortMacSecurityIntfContentShutdownTimeLeft
         */
        case LEAF_snPortMacSecurityIntfContentShutdownTimeLeft:
            *var_len = 4;
            long_return = 0;  /* not supported */
            return (u_char *) &long_return;

        /* snPortMacSecurityIntfContentAgeOutTime
         */
        case LEAF_snPortMacSecurityIntfContentAgeOutTime:
            *var_len = 4;
            long_return = 0;  /* Accton: portSecAgingStatus and BRIDGE-MIB.dot1dTpAgingTime */
            return (u_char *) &long_return;

        /* snPortMacSecurityIntfContentMaxLockedMacAllowed
         */
        case LEAF_snPortMacSecurityIntfContentMaxLockedMacAllowed:
            {
                *var_len = 4;
                UI32_T core_val;

                if (! PSEC_PMGR_GetPortSecurityMacCount(entry.portsec_port_index,
                    &core_val))
                {
                    return NULL;
                }

                long_return = core_val;
                return (u_char*) &long_return;
            }

        /* snPortMacSecurityIntfContentTotalMAC
         */
        case LEAF_snPortMacSecurityIntfContentTotalMACs:
            *var_len = 4;
            long_return = 0;  /* not supported */
            return (u_char *) &long_return;

        /* snPortMacSecurityIntfContentViolationCounts
         */
        case LEAF_snPortMacSecurityIntfContentViolationCounts:
            *var_len = 4;
            long_return = 0;  /* not supported */
            return (u_char *) &long_return;

        /* unrecognised node
         */
        default:
            ERROR_MSG("");
            break;
    }

    /* return failure
     */
    return NULL;
}

int write_snPortMacSecurityIntfContentSecurity(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    /* dispatch action
     */
    switch (action)
    {
        case RESERVE1:
            /* check type and length
             */
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            /* check valid values
             */
            switch (*(long *) var_val)
            {
                case VAL_snPortMacSecurityIntfContentSecurity_disable:
                    break;

                case VAL_snPortMacSecurityIntfContentSecurity_enable:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = 16;
            I32_T value = 0;
            UI32_T core_val = 0;

            /* table-specific variables
             */
            UI32_T snPortMacSecurityIntfContentIfIndex = 0;

            /* extract index
             */
            if (! snPortMacSecurityIntfContentTable_OidIndexToData(TRUE,
                name_len - oid_name_length,
                &(name[oid_name_length]),
                &snPortMacSecurityIntfContentIfIndex))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            /* get user value
             */
            memcpy(&value, var_val, sizeof(I32_T));

            /* convert to core-layer value
             */
            core_val = FOUNDRY_LIB_ConvertFoundryToAcctonEnabledStatus(value);

            /* set to core layer
             */
#if (SYS_CPNT_NETACCESS == TRUE)
            if (! NETACCESS_PMGR_SetPortSecurityStatus(snPortMacSecurityIntfContentIfIndex,
                value))
#else
            if (! PSEC_PMGR_SetPortSecurityStatus(snPortMacSecurityIntfContentIfIndex,
                value))
#endif
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    /* return success
     */
    return SNMP_ERR_NOERROR;
}

int write_snPortMacSecurityIntfContentViolationType(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    /* dispatch action
     */
    switch (action)
    {
        case RESERVE1:
            /* check type and length
             */
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            /* check valid values
             */
            switch (*(long *) var_val)
            {
                case VAL_snPortMacSecurityIntfContentViolationType_shutdown:
                    break;

                case VAL_snPortMacSecurityIntfContentViolationType_restrict:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = 16;
            I32_T value = 0;
            UI32_T core_val = 0;

            /* table-specific variables
             */
            UI32_T snPortMacSecurityIntfContentIfIndex = 0;

            /* extract index
             */
            if (! snPortMacSecurityIntfContentTable_OidIndexToData(TRUE,
                name_len - oid_name_length,
                &(name[oid_name_length]),
                &snPortMacSecurityIntfContentIfIndex))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            /* get user value
             */
            memcpy(&value, var_val, sizeof(I32_T));

            /* convert to core-layer value; trap not supported
             */
            switch (value)
            {
                /* Brocade "shutdown"
                 */
                case VAL_snPortMacSecurityIntfContentViolationType_shutdown:
                    core_val = VAL_portSecAction_shutdown;
                    break;

                /* Brocade "restrict"
                 */
                case VAL_snPortMacSecurityIntfContentViolationType_restrict:
                    core_val = VAL_portSecAction_none;
                    break;

                /* should not happen; if happens, is a bug
                 */
                default:
                    core_val = VAL_portSecPortStatus_disabled;
                    break;
            }

            /* set to core layer
             */
#if (SYS_CPNT_NETACCESS == TRUE)
                if (! NETACCESS_PMGR_SetPortSecurityActionStatus(snPortMacSecurityIntfContentIfIndex,
                    core_val))
#else
                if (! PSEC_PMGR_SetPortSecurityActionStatus(snPortMacSecurityIntfContentIfIndex,
                    core_val))
#endif
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    /* return success
     */
    return SNMP_ERR_NOERROR;
}

int write_snPortMacSecurityIntfContentShutdownTime(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    /* dispatch action
     */
    switch (action)
    {
        case RESERVE1:
            /* check type and length
             */
            if (var_val_type != ASN_UNSIGNED)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            /* check valid values
             */
            if (((*(long *) var_val) < MIN_snPortMacSecurityIntfContentShutdownTime)
                || (*(long *) var_val > MAX_snPortMacSecurityIntfContentShutdownTime))
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = 16;
            UI32_T value = 0;

            /* table-specific variables
             */
            UI32_T snPortMacSecurityIntfContentIfIndex = 0;

            /* extract index
             */
            if (! snPortMacSecurityIntfContentTable_OidIndexToData(TRUE,
                name_len - oid_name_length,
                &(name[oid_name_length]),
                &snPortMacSecurityIntfContentIfIndex))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            /* get user value
             */
            memcpy(&value, var_val, sizeof(UI32_T));

            /* set to core layer
             */
#if (SYS_CPNT_NETACCESS == TRUE)
            if (! NETACCESS_PMGR_SetPortSecurityMaxMacCount(snPortMacSecurityIntfContentIfIndex,
                value))
#else
            if (! PSEC_PMGR_SetPortSecurityMacCount(snPortMacSecurityIntfContentIfIndex,
                value))
#endif
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    /* return success
     */
    return SNMP_ERR_NOERROR;
}

int write_snPortMacSecurityIntfContentAgeOutTime(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    /* dispatch action
     */
    switch (action)
    {
        case RESERVE1:
            /* check type and length
             */
            if (var_val_type != ASN_UNSIGNED)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            /* check valid values
             */
            if ((*(long *) var_val < MIN_snPortMacSecurityIntfContentAgeOutTime)
                || (*(long *) var_val > MAX_snPortMacSecurityIntfContentAgeOutTime))
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = 16;
#if 0  /* not supported; ignore */
            UI32_T value = 0;
#endif

            /* table-specific variables
             */
            UI32_T snPortMacSecurityIntfContentIfIndex = 0;

            /* extract index
             */
            if (! snPortMacSecurityIntfContentTable_OidIndexToData(TRUE,
                name_len - oid_name_length,
                &(name[oid_name_length]),
                &snPortMacSecurityIntfContentIfIndex))
            {
                return SNMP_ERR_COMMITFAILED;
            }

#if 0  /* not supported; ignore */
            /* get user value
             */
            memcpy(&value, var_val, sizeof(UI32_T));

            /* set to core layer
             */
            if (XXX_MGR_SetSnPortMacSecurityIntfContentAgeOutTime(snPortMacSecurityIntfContentIfIndex, value) != TRUE)
            {
                return SNMP_ERR_COMMITFAILED;
            }
#endif

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    /* return success
     */
    return SNMP_ERR_NOERROR;
}

int write_snPortMacSecurityIntfContentMaxLockedMacAllowed(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    /* dispatch action
     */
    switch (action)
    {
        case RESERVE1:
            /* check type and length
             */
            if (var_val_type != ASN_UNSIGNED)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            /* check valid values
             */
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = 16;
            UI32_T value = 0;

            /* table-specific variables
             */
            UI32_T snPortMacSecurityIntfContentIfIndex = 0;

            /* extract index
             */
            if (! snPortMacSecurityIntfContentTable_OidIndexToData(TRUE,
                name_len - oid_name_length,
                &(name[oid_name_length]),
                &snPortMacSecurityIntfContentIfIndex))
            {
                return SNMP_ERR_COMMITFAILED;
            }

            /* get user value
             */
            memcpy(&value, var_val, sizeof(UI32_T));

            /* set to core layer
             */
#if (SYS_CPNT_NETACCESS == TRUE)
            if (! NETACCESS_PMGR_SetPortSecurityMaxMacCount(snPortMacSecurityIntfContentIfIndex,
                value))
#else
            if (! PSEC_PMGR_SetPortSecurityMacCount(snPortMacSecurityIntfContentIfIndex,
                value))
#endif
            {
                return SNMP_ERR_COMMITFAILED;
            }

            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    /* return success
     */
    return SNMP_ERR_NOERROR;
}
#endif  /* (SYS_CPNT_PORT_SECURITY == TRUE); all of snPortMacSecurityIntfContentTable */

/* ------------------------------------------------------------------------
 * FUNCTION NAME - init_snSwitch
 * ------------------------------------------------------------------------
 * PURPOSE  :   This is the entry point into this file for initialisation.
 *
 * INPUT    :   None.
 *
 * OUTPUT   :   None.
 *
 * RETURN   :   None.
 *
 * NOTES    :   None.
 * ------------------------------------------------------------------------
 */
void init_snSwitch(void)
{
    oid snSwitch_oid[] = { 1,3,6,1,4,1,1991,1,1,3 };

    /* register individual subtcrees
     */
    init_snSwInfo();  /* 1 */

#if (SYS_CPNT_RADIUS == TRUE)
    init_snRadius();  /* 12 */
#endif

#if (SYS_CPNT_TACACS == TRUE)
    init_snTacacs();  /* 13 */
#endif

#if (SYS_CPNT_AAA == TRUE)
    init_snAAA();  /* 15 */
#endif

    /* register individual tables
     */
    init_snSwIfInfoTable();                     /* 3.3 */
    init_snIfOpticalMonitoringInfoTable();      /* 3.6 */
    init_snIfMediaInfoTable();                  /* 3.9 */

#if (SYS_CPNT_NETACCESS_MACAUTH == TRUE)
    init_snMacFilterIfAccessTable();            /* 10.3 */
#endif

#if (SYS_CPNT_PORT_SECURITY == TRUE)
    init_snPortMacSecurityIntfContentTable();   /* 24.1.1.3 */
#endif

    /* register ourselves in the sysORTable
     */
    REGISTER_SYSOR_ENTRY(snSwitch_oid,
        "Management Information Base module for the switch group.");
}
