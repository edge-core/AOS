/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.old-api.conf,v 1.3 2002/10/17 09:40:46 dts12 Exp $
 */
#include "sys_cpnt.h"
#if (SYS_CPNT_VRRP == TRUE)
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "rfc_2787.h"
#include "leaf_2787.h"
#include "snmp_mgr.h"
#include "sysORTable.h"
#include "vrrp_type.h"
#include "vrrp_pmgr.h"
#include "vrrp_pom.h"

oid vrrpOperTable_variables_oid[] = { 1,3,6,1,2,1,68,1 };

/* variable3 vrrpOperTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */
struct variable3 vrrpOperTable_variables[] =
{
/* magic number, variable type, ro/rw, callback fn, L, oidsuffix
 */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    {LEAF_vrrpOperVrId, ASN_INTEGER, RONLY, var_vrrpOperTable, 3, { 3, 1, 1 }},
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

    {LEAF_vrrpOperVirtualMacAddr, ASN_OCTET_STR, RONLY, var_vrrpOperTable, 3, { 3, 1, 2 }},
    {LEAF_vrrpOperState, ASN_INTEGER, RONLY, var_vrrpOperTable, 3, { 3, 1, 3 }},
    {LEAF_vrrpOperAdminState, ASN_INTEGER, RWRITE, var_vrrpOperTable, 3, { 3, 1, 4 }},
    {LEAF_vrrpOperPriority, ASN_INTEGER, RWRITE, var_vrrpOperTable, 3, { 3, 1, 5 }},
    {LEAF_vrrpOperIpAddrCount, ASN_INTEGER, RONLY, var_vrrpOperTable, 3, { 3, 1, 6 }},
    {LEAF_vrrpOperMasterIpAddr, ASN_IPADDRESS, RONLY, var_vrrpOperTable, 3, { 3, 1, 7 }},
    {LEAF_vrrpOperPrimaryIpAddr, ASN_IPADDRESS, RWRITE, var_vrrpOperTable, 3, { 3, 1, 8 }},
    {LEAF_vrrpOperAuthType, ASN_INTEGER, RWRITE, var_vrrpOperTable, 3, { 3, 1, 9 }},
    {LEAF_vrrpOperAuthKey, ASN_OCTET_STR, RWRITE, var_vrrpOperTable, 3, { 3, 1, 10 }},
    {LEAF_vrrpOperAdvertisementInterval, ASN_INTEGER, RWRITE, var_vrrpOperTable, 3, { 3, 1, 11 }},
    {LEAF_vrrpOperPreemptMode, ASN_INTEGER, RWRITE, var_vrrpOperTable, 3, { 3, 1, 12 }},
    {LEAF_vrrpOperVirtualRouterUpTime, ASN_TIMETICKS, RONLY, var_vrrpOperTable, 3, { 3, 1, 13 }},
    {LEAF_vrrpOperProtocol, ASN_INTEGER, RWRITE, var_vrrpOperTable, 3, { 3, 1, 14 }},
    {LEAF_vrrpOperRowStatus, ASN_INTEGER, RWRITE, var_vrrpOperTable, 3, { 3, 1, 15 }},
};

oid vrrpAssoIpAddrTable_variables_oid[] = { 1,3,6,1,2,1,68,1 };

/* variable3 vrrpAssoIpAddrTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */
struct variable3 vrrpAssoIpAddrTable_variables[] =
{
/* magic number, variable type, ro/rw, callback fn, L, oidsuffix
 */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    {LEAF_vrrpAssoIpAddr, ASN_IPADDRESS, RONLY, var_vrrpAssoIpAddrTable, 3, { 4, 1, 1 }},
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

    {LEAF_vrrpAssoIpAddrRowStatus, ASN_INTEGER, RWRITE, var_vrrpAssoIpAddrTable, 3, { 4, 1, 2 }},
};

void init_vrrpOperations(void)
{
    static oid vrrp_module_oid[] = { SNMP_OID_MIB2, 68 };
    static oid vrrpNodeVersion_oid[] = { 1,3,6,1,2,1,68,1,1,0 };
#if 0 /* not support now */
    static oid vrrpNotificationCntl_oid[] = { 1,3,6,1,2,1,68,1,2,0 };
#endif /* #if 0 */

    REGISTER_SYSOR_ENTRY(vrrp_module_oid,
                         "This MIB describes objects used for managing Virtual Router Redundancy Protocol (VRRP) routers.");

    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("vrrpNodeVersion",
                                         get_vrrpNodeVersion,
                                         vrrpNodeVersion_oid,
                                         OID_LENGTH(vrrpNodeVersion_oid),
                                         HANDLER_CAN_RONLY));

#if 0 /* not support now */
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("vrrpNotificationCntl",
                               do_vrrpNotificationCntl,
                               vrrpNotificationCntl_oid,
                               OID_LENGTH(vrrpNotificationCntl_oid),
                               HANDLER_CAN_RWRITE));
#endif /* #if 0 */

    REGISTER_MIB("vrrpOperTable", vrrpOperTable_variables, variable3,
                 vrrpOperTable_variables_oid);

    REGISTER_MIB("vrrpAssoIpAddrTable", vrrpAssoIpAddrTable_variables, variable3,
                 vrrpAssoIpAddrTable_variables_oid);
}

int get_vrrpNodeVersion(netsnmp_mib_handler *handler,
    netsnmp_handler_registration *reginfo,
    netsnmp_agent_request_info *reqinfo,
    netsnmp_request_info *requests)
{
    switch (reqinfo->mode)
    {
        case MODE_GET:
            {
                UI32_T value = 0;

                if (VRRP_PMGR_GetVersionNumber(&value) == VRRP_TYPE_OK)
                {
                    long_return = value;
                    snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
                }
                else
                {
                    return SNMP_ERR_GENERR;
                }

                break;
            }


        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

#if 0 /* not support now */
int do_vrrpNotificationCntl(netsnmp_mib_handler *handler,
    netsnmp_handler_registration *reginfo,
    netsnmp_agent_request_info *reqinfo,
    netsnmp_request_info *requests)
{
    switch (reqinfo->mode)
    {
        case MODE_GET:
            {
                UI32_T value = 0;

                if (AMTR_MGR_GetVrrpNotificationCntl(&value) == TRUE)
                {
                    long_return = value;
                    snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *)&long_return, sizeof(long_return));
                }
                else
                {
                    return SNMP_ERR_GENERR;
                }

                break;
            }

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
            }
            break;

        case MODE_SET_RESERVE2:
            switch (*requests->requestvb->val.integer)
            {
                case VAL_vrrpNotificationCntl_enabled:
                    break;

                case VAL_vrrpNotificationCntl_disabled:
                    break;

                default:
                    netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called.
             */
            break;

        case MODE_SET_ACTION:
            {
                if (AMTR_MGR_SetVrrpNotificationCntl(*requests->requestvb->val.integer) != TRUE)
                {
                    netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
                }

                break;
            }

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
#endif /* #if 0 */

#define VRRPOPERENTRY_INSTANCE_LEN  2

BOOL_T vrrpOperTable_OidIndexToData(UI32_T exact, UI32_T compc,
    oid *compl, UI32_T *ifindex_p, UI8_T *vr_id_p)
{
    /* get or set
     */
    if (exact)
    {
        /* check the index length
         */
        if (compc != VRRPOPERENTRY_INSTANCE_LEN) /* the constant size index */
        {
            return FALSE;
        }
    }

    *ifindex_p = compl[0];
    *vr_id_p = compl[1];

    return TRUE;
}

/*
 * var_vrrpOperTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *var_vrrpOperTable(struct variable *vp,
    oid *name,
    size_t *length,
    int exact,
    size_t *var_len,
    WriteMethod **write_method)
{
    UI32_T compc = 0;
    oid compl[VRRPOPERENTRY_INSTANCE_LEN] = {0};
    oid best_inst[VRRPOPERENTRY_INSTANCE_LEN] = {0};
    VRRP_OPER_ENTRY_T entry;

    switch (vp->magic)
    {
        case LEAF_vrrpOperAdminState:
            *write_method = write_vrrpOperAdminState;
            break;

        case LEAF_vrrpOperPriority:
            *write_method = write_vrrpOperPriority;
            break;

        case LEAF_vrrpOperPrimaryIpAddr:
            *write_method = write_vrrpOperPrimaryIpAddr;
            break;

        case LEAF_vrrpOperAuthType:
            *write_method = write_vrrpOperAuthType;
            break;

        case LEAF_vrrpOperAuthKey:
            *write_method = write_vrrpOperAuthKey;
            break;

        case LEAF_vrrpOperAdvertisementInterval:
            *write_method = write_vrrpOperAdvertisementInterval;
            break;

        case LEAF_vrrpOperPreemptMode:
            *write_method = write_vrrpOperPreemptMode;
            break;

        case LEAF_vrrpOperProtocol:
            *write_method = write_vrrpOperProtocol;
            break;

        case LEAF_vrrpOperRowStatus:
            *write_method = write_vrrpOperRowStatus;
            break;

        default:
            *write_method = 0;
            break;
    }

    /* check compc, retrive compl
     */
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl, VRRPOPERENTRY_INSTANCE_LEN);

    memset(&entry, 0, sizeof(entry));

    if (exact) /* get or set */
    {
        if (vrrpOperTable_OidIndexToData(exact, compc, compl, &entry.ifindex, &entry.vrid) == FALSE)
        {
            return NULL;
        }

        if (VRRP_POM_GetVrrpOperEntry(&entry) != VRRP_TYPE_OK)
        {
            return NULL;
        }
    }
    else /* getnext */
    {
        vrrpOperTable_OidIndexToData(exact, compc, compl, &entry.ifindex, &entry.vrid);

        /* check the length of inputing index,if < 1 we should try get
         * {0.0.0.0.0...}
         */
        if (compc < 1)
        {
            if (VRRP_POM_GetVrrpOperEntry(&entry) != VRRP_TYPE_OK)
            {
                if (VRRP_PMGR_GetNextVrrpOperEntry(&entry) != VRRP_TYPE_OK)
                {
                    return NULL;
                }
            }
        }
        else
        {
            if (VRRP_PMGR_GetNextVrrpOperEntry(&entry) != VRRP_TYPE_OK)
            {
                return NULL;
            }
        }
    }

    memcpy(name, vp->name, vp->namelen * sizeof(oid));

    /* assign data to the oid index
     */
    best_inst[0] = entry.ifindex;
    best_inst[1] = entry.vrid;
    memcpy(name + vp->namelen, best_inst, VRRPOPERENTRY_INSTANCE_LEN * sizeof(oid));
    *length = vp->namelen + VRRPOPERENTRY_INSTANCE_LEN;

    switch (vp->magic)
    {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case LEAF_vrrpOperVrId:
            *var_len = sizeof(long_return);
            long_return = entry.vrid;
            return (u_char *) &long_return;
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

        case LEAF_vrrpOperVirtualMacAddr:
            *var_len = SIZE_vrrpOperVirtualMacAddr;
            memcpy(return_buf, entry.virtual_mac, *var_len);
            return (u_char *) return_buf;

        case LEAF_vrrpOperState:
            *var_len = sizeof(long_return);
            long_return = entry.oper_state;
            return (u_char *) &long_return;

        case LEAF_vrrpOperAdminState:
            *var_len = sizeof(long_return);
            long_return = entry.admin_state;
            return (u_char *) &long_return;

        case LEAF_vrrpOperPriority:
            *var_len = sizeof(long_return);
            long_return = entry.priority;
            return (u_char *) &long_return;

        case LEAF_vrrpOperIpAddrCount:
            *var_len = sizeof(long_return);
            long_return = entry.ip_addr_count;
            return (u_char *) &long_return;

        case LEAF_vrrpOperMasterIpAddr:
            *var_len = sizeof(ipaddr_return);
            memcpy(&ipaddr_return, entry.master_ip_addr, *var_len);
            return (u_char *) &ipaddr_return;

        case LEAF_vrrpOperPrimaryIpAddr:
            *var_len = sizeof(ipaddr_return);
            memcpy(&ipaddr_return, entry.primary_ip_addr, *var_len);
            return (u_char *) &ipaddr_return;

        case LEAF_vrrpOperAuthType:
            *var_len = sizeof(long_return);
            long_return = entry.auth_type;
            return (u_char *) &long_return;

        case LEAF_vrrpOperAuthKey:
            *var_len = strlen((char *)entry.auth_key);
            strcpy((char *)return_buf, (char *)entry.auth_key);
            return (u_char *) return_buf;

        case LEAF_vrrpOperAdvertisementInterval:
            *var_len = sizeof(long_return);
            long_return = entry.advertise_interval;
            return (u_char *) &long_return;

        case LEAF_vrrpOperPreemptMode:
            *var_len = sizeof(long_return);
            long_return = entry.preempt_mode;
            return (u_char *) &long_return;

        case LEAF_vrrpOperVirtualRouterUpTime:
            *var_len = sizeof(long_return);
            long_return = entry.virtual_router_up_time;
            return (u_char *) &long_return;

        case LEAF_vrrpOperProtocol:
            *var_len = sizeof(long_return);
            long_return = entry.oper_protocol;
            return (u_char *) &long_return;

        case LEAF_vrrpOperRowStatus:
            *var_len = sizeof(long_return);
            long_return = entry.row_status;
            return (u_char *) &long_return;

        default:
            ERROR_MSG("");
    }

    return NULL;
}

int write_vrrpOperAdminState(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            switch (*(long *)var_val)
            {
                case VAL_vrrpOperAdminState_up:
                    break;

                case VAL_vrrpOperAdminState_down:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = 11;
            I32_T value = 0;
            UI32_T ifindex = 0;
            UI8_T vr_id = 0;

            if (vrrpOperTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &ifindex, &vr_id) == FALSE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            value = *(long *)var_val;

            if (VRRP_PMGR_SetOperAdminStatus(ifindex, vr_id, value) != VRRP_TYPE_OK)
            {
                return SNMP_ERR_COMMITFAILED;
            }
        }
            break;

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

int write_vrrpOperPriority(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            if (MIN_vrrpOperPriority > *(long *)var_val || *(long *)var_val > MAX_vrrpOperPriority)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = 11;
            I32_T value = 0;
            UI32_T ifindex = 0;
            UI8_T vr_id = 0;

            if (vrrpOperTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &ifindex, &vr_id) == FALSE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            value = *(long *)var_val;

            if (VRRP_PMGR_SetPriority(ifindex, vr_id, value) != VRRP_TYPE_OK)
            {
                return SNMP_ERR_COMMITFAILED;
            }
        }
            break;

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

int write_vrrpOperPrimaryIpAddr(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_IPADDRESS)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len != SYS_ADPT_IPV4_ADDR_LEN) {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;

        case RESERVE2:
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = 11;
            UI32_T ifindex = 0;
            UI8_T vr_id = 0;
            UI8_T byte_buffer[4];

            if (vrrpOperTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &ifindex, &vr_id) == FALSE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            memcpy(byte_buffer, var_val, var_val_len);

            if (VRRP_PMGR_SetPrimaryIp(ifindex, vr_id, byte_buffer) != VRRP_TYPE_OK)
            {
                return SNMP_ERR_COMMITFAILED;
            }
        }
            break;

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

int write_vrrpOperAuthType(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            switch (*(long *)var_val)
            {
                case VAL_vrrpOperAuthType_noAuthentication:
                    break;

                case VAL_vrrpOperAuthType_simpleTextPassword:
                    break;

                case VAL_vrrpOperAuthType_ipAuthenticationHeader:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = 11;
            I32_T value = 0;
            UI32_T ifindex = 0;
            UI8_T vr_id = 0;

            if (vrrpOperTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &ifindex, &vr_id) == FALSE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            value = *(long *)var_val;

            if (VRRP_PMGR_SetAuthenticationType(ifindex, vr_id, value) != VRRP_TYPE_OK)
            {
                return SNMP_ERR_COMMITFAILED;
            }
        }
            break;

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

int write_vrrpOperAuthKey(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_OCTET_STR)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if ((MINSIZE_vrrpOperAuthKey > var_val_len) || (var_val_len > MAXSIZE_vrrpOperAuthKey))
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;

        case RESERVE2:
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = 11;
            UI32_T ifindex = 0;
            UI8_T vr_id = 0;
            UI8_T byte_buffer[MAXSIZE_vrrpOperAuthKey + 1] = {0};

            if (vrrpOperTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &ifindex, &vr_id) == FALSE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            memcpy(byte_buffer, var_val, var_val_len);

            byte_buffer[var_val_len] = '\0';

            if (VRRP_PMGR_SetAuthenticationKey(ifindex, vr_id, byte_buffer) != VRRP_TYPE_OK)
            {
                return SNMP_ERR_COMMITFAILED;
            }
        }
            break;

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

int write_vrrpOperAdvertisementInterval(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            if (MIN_vrrpOperAdvertisementInterval > *(long *)var_val || *(long *)var_val > MAX_vrrpOperAdvertisementInterval)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = 11;
            I32_T value = 0;
            UI32_T ifindex = 0;
            UI8_T vr_id = 0;

            if (vrrpOperTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &ifindex, &vr_id) == FALSE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            value = *(long *)var_val;

            if (VRRP_PMGR_SetAdvertisementInterval(ifindex, vr_id, value) != VRRP_TYPE_OK)
            {
                return SNMP_ERR_COMMITFAILED;
            }
        }
            break;

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

int write_vrrpOperPreemptMode(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            switch (*(long *)var_val)
            {
                case VAL_vrrpOperPreemptMode_true:
                    break;

                case VAL_vrrpOperPreemptMode_false:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = 11;
            I32_T value = 0;
            UI32_T ifindex = 0;
            UI8_T vr_id = 0;

            if (vrrpOperTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &ifindex, &vr_id) == FALSE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            value = *(long *)var_val;

            if (VRRP_PMGR_SetPreemptMode(ifindex, vr_id, value) != VRRP_TYPE_OK)
            {
                return SNMP_ERR_COMMITFAILED;
            }
        }
            break;

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

int write_vrrpOperProtocol(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            switch (*(long *)var_val)
            {
                case VAL_vrrpOperProtocol_ip:
                    break;

                case VAL_vrrpOperProtocol_bridge:
                    break;

                case VAL_vrrpOperProtocol_decnet:
                    break;

                case VAL_vrrpOperProtocol_other:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = 11;
            I32_T value = 0;
            UI32_T ifindex = 0;
            UI8_T vr_id = 0;
            VRRP_OPER_ENTRY_T entry;

            if (vrrpOperTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &ifindex, &vr_id) == FALSE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            value = *(long *)var_val;

            if(VRRP_TYPE_OK != VRRP_PMGR_SetOperProtocol(ifindex, vr_id, value))
            {
                return SNMP_ERR_COMMITFAILED;
            }
            break;
        }

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

int write_vrrpOperRowStatus(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            switch (*(long *)var_val)
            {
                case VAL_vrrpOperRowStatus_active:
                    break;

                case VAL_vrrpOperRowStatus_notInService:
                    break;

                case VAL_vrrpOperRowStatus_notReady:
                    break;

                case VAL_vrrpOperRowStatus_createAndGo:
                    break;

                case VAL_vrrpOperRowStatus_createAndWait:
                    break;

                case VAL_vrrpOperRowStatus_destroy:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = 11;
            I32_T value = 0;
            VRRP_OPER_ENTRY_T entry;

            memset(&entry, 0, sizeof(entry));

            if (vrrpOperTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &entry.ifindex, &entry.vrid) == FALSE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            VRRP_PMGR_GetDefaultVrrpOperEntry(&entry);

            value = *(long *)var_val;

            if(VRRP_TYPE_OK != VRRP_PMGR_SetVrrpOperRowStatus(&entry, value))
                {
                    return SNMP_ERR_COMMITFAILED;
                }
            }
            break;

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

#define VRRPASSOIPADDRENTRY_INSTANCE_LEN  6

BOOL_T vrrpAssoIpAddrTable_OidIndexToData(UI32_T exact, UI32_T compc,
    oid *compl, UI32_T *ifindex_p, UI8_T *vr_id_p, UI8_T *addr_p)
{
    /* get or set
     */
    if (exact)
    {
        /* check the index length
         */
        if (compc != VRRPASSOIPADDRENTRY_INSTANCE_LEN) /* the constant size index */
        {
            return FALSE;
        }
    }

    *ifindex_p = compl[0];
    *vr_id_p = compl[1];
    addr_p[0] = compl[2];
    addr_p[1] = compl[3];
    addr_p[2] = compl[4];
    addr_p[3] = compl[5];

    return TRUE;
}

/*
 * var_vrrpAssoIpAddrTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *var_vrrpAssoIpAddrTable(struct variable *vp,
    oid *name,
    size_t *length,
    int exact,
    size_t *var_len,
    WriteMethod **write_method)
{
    UI32_T compc = 0;
    oid compl[VRRPASSOIPADDRENTRY_INSTANCE_LEN] = {0};
    oid best_inst[VRRPASSOIPADDRENTRY_INSTANCE_LEN] = {0};
    VRRP_ASSOC_IP_ENTRY_T entry;

    switch (vp->magic)
    {
        case LEAF_vrrpAssoIpAddrRowStatus:
            *write_method = write_vrrpAssoIpAddrRowStatus;
            break;

        default:
            *write_method = 0;
            break;
    }

    /* check compc, retrive compl
     */
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl, VRRPASSOIPADDRENTRY_INSTANCE_LEN);

    memset(&entry, 0, sizeof(entry));

    if (exact) /* get or set */
    {
        if (vrrpAssoIpAddrTable_OidIndexToData(exact, compc, compl, &entry.ifindex, &entry.vrid, entry.assoc_ip_addr) == FALSE)
        {
            return NULL;
        }

        if (VRRP_PMGR_GetVrrpAssocIpAddrEntry(&entry) != VRRP_TYPE_OK)
        {
            return NULL;
        }
    }
    else /* getnext */
    {
        vrrpAssoIpAddrTable_OidIndexToData(exact, compc, compl, &entry.ifindex, &entry.vrid, entry.assoc_ip_addr);

        /* check the length of inputing index,if < 1 we should try get
         * {0.0.0.0.0...}
         */
        if (compc < 1)
        {
            if (VRRP_PMGR_GetVrrpAssocIpAddrEntry(&entry) != VRRP_TYPE_OK)
            {
                if (VRRP_PMGR_GetNextVrrpAssocIpAddrEntryBySnmp(&entry) != TRUE)
                {
                    return NULL;
                }
            }
        }
        else
        {
            if (VRRP_PMGR_GetNextVrrpAssocIpAddrEntryBySnmp(&entry) != TRUE)
            {
                return NULL;
            }
        }
    }

    memcpy(name, vp->name, vp->namelen * sizeof(oid));

    /* assign data to the oid index
     */
    best_inst[0] = entry.ifindex;
    best_inst[1] = entry.vrid;
    best_inst[2] = entry.assoc_ip_addr[0];
    best_inst[3] = entry.assoc_ip_addr[1];
    best_inst[4] = entry.assoc_ip_addr[2];
    best_inst[5] = entry.assoc_ip_addr[3];
    memcpy(name + vp->namelen, best_inst, VRRPASSOIPADDRENTRY_INSTANCE_LEN * sizeof(oid));
    *length = vp->namelen + VRRPASSOIPADDRENTRY_INSTANCE_LEN;

    switch (vp->magic)
    {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case LEAF_vrrpAssoIpAddr:
            *var_len = sizeof(ipaddr_return);
            ipaddr_return = (entry.assoc_ip_addr[0] << 24) | (entry.assoc_ip_addr[1] << 16) | (entry.assoc_ip_addr[2] << 8) | entry.assoc_ip_addr[3];
            return (u_char *) &ipaddr_return;
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

        case LEAF_vrrpAssoIpAddrRowStatus:
            *var_len = sizeof(long_return);
            long_return = entry.row_status;
            return (u_char *) &long_return;

        default:
            ERROR_MSG("");
    }

    return NULL;
}

int write_vrrpAssoIpAddrRowStatus(int action,
    u_char *var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char *statP,
    oid *name,
    size_t name_len)
{
    switch (action)
    {
        case RESERVE1:
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            break;

        case RESERVE2:
            switch (*(long *)var_val)
            {
                case VAL_vrrpAssoIpAddrRowStatus_active:
                    break;

                case VAL_vrrpAssoIpAddrRowStatus_notInService:
                    break;

                case VAL_vrrpAssoIpAddrRowStatus_notReady:
                    break;

                case VAL_vrrpAssoIpAddrRowStatus_createAndGo:
                    break;

                case VAL_vrrpAssoIpAddrRowStatus_createAndWait:
                    break;

                case VAL_vrrpAssoIpAddrRowStatus_destroy:
                    break;

                default:
                    return SNMP_ERR_WRONGVALUE;
            }
            break;

        case FREE:
            break;

        case ACTION:
        {
            UI32_T oid_name_length = 11;
            VRRP_ASSOC_IP_ENTRY_T entry;

            memset(&entry, 0, sizeof(entry));

            if (vrrpAssoIpAddrTable_OidIndexToData(TRUE, name_len - oid_name_length, &(name[oid_name_length]), &entry.ifindex, &entry.vrid, entry.assoc_ip_addr) == FALSE)
            {
                return SNMP_ERR_COMMITFAILED;
            }

            entry.row_status = *(long *)var_val;

            if (VRRP_PMGR_SetVrrpAssocIpAddrEntry(&entry) != VRRP_TYPE_OK)
            {
                return SNMP_ERR_COMMITFAILED;
            }
        }
            break;

        case UNDO:
            break;

        case COMMIT:
            break;
    }

    return SNMP_ERR_NOERROR;
}

oid vrrpRouterStatsTable_variables_oid[] = { 1,3,6,1,2,1,68,2 };

/* variable3 vrrpRouterStatsTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */
struct variable3 vrrpRouterStatsTable_variables[] =
{
/* magic number, variable type, ro/rw, callback fn, L, oidsuffix
 */
    {LEAF_vrrpStatsBecomeMaster, ASN_COUNTER, RONLY, var_vrrpRouterStatsTable, 3, { 4, 1, 1 }},
    {LEAF_vrrpStatsAdvertiseRcvd, ASN_COUNTER, RONLY, var_vrrpRouterStatsTable, 3, { 4, 1, 2 }},
    {LEAF_vrrpStatsAdvertiseIntervalErrors, ASN_COUNTER, RONLY, var_vrrpRouterStatsTable, 3, { 4, 1, 3 }},
    {LEAF_vrrpStatsAuthFailures, ASN_COUNTER, RONLY, var_vrrpRouterStatsTable, 3, { 4, 1, 4 }},
    {LEAF_vrrpStatsIpTtlErrors, ASN_COUNTER, RONLY, var_vrrpRouterStatsTable, 3, { 4, 1, 5 }},
    {LEAF_vrrpStatsPriorityZeroPktsRcvd, ASN_COUNTER, RONLY, var_vrrpRouterStatsTable, 3, { 4, 1, 6 }},
    {LEAF_vrrpStatsPriorityZeroPktsSent, ASN_COUNTER, RONLY, var_vrrpRouterStatsTable, 3, { 4, 1, 7 }},
    {LEAF_vrrpStatsInvalidTypePktsRcvd, ASN_COUNTER, RONLY, var_vrrpRouterStatsTable, 3, { 4, 1, 8 }},
    {LEAF_vrrpStatsAddressListErrors, ASN_COUNTER, RONLY, var_vrrpRouterStatsTable, 3, { 4, 1, 9 }},
    {LEAF_vrrpStatsInvalidAuthType, ASN_COUNTER, RONLY, var_vrrpRouterStatsTable, 3, { 4, 1, 10 }},
    {LEAF_vrrpStatsAuthTypeMismatch, ASN_COUNTER, RONLY, var_vrrpRouterStatsTable, 3, { 4, 1, 11 }},
    {LEAF_vrrpStatsPacketLengthErrors, ASN_COUNTER, RONLY, var_vrrpRouterStatsTable, 3, { 4, 1, 12 }},
};

void init_vrrpStatistics(void)
{
    static oid vrrpRouterChecksumErrors_oid[] = { 1,3,6,1,2,1,68,2,1,0 };
    static oid vrrpRouterVersionErrors_oid[] = { 1,3,6,1,2,1,68,2,2,0 };
    static oid vrrpRouterVrIdErrors_oid[] = { 1,3,6,1,2,1,68,2,3,0 };

    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("vrrpRouterChecksumErrors",
                                         get_vrrpRouterChecksumErrors,
                                         vrrpRouterChecksumErrors_oid,
                                         OID_LENGTH(vrrpRouterChecksumErrors_oid),
                                         HANDLER_CAN_RONLY));

    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("vrrpRouterVersionErrors",
                                         get_vrrpRouterVersionErrors,
                                         vrrpRouterVersionErrors_oid,
                                         OID_LENGTH(vrrpRouterVersionErrors_oid),
                                         HANDLER_CAN_RONLY));

    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("vrrpRouterVrIdErrors",
                                         get_vrrpRouterVrIdErrors,
                                         vrrpRouterVrIdErrors_oid,
                                         OID_LENGTH(vrrpRouterVrIdErrors_oid),
                                         HANDLER_CAN_RONLY));

    REGISTER_MIB("vrrpRouterStatsTable", vrrpRouterStatsTable_variables, variable3,
                 vrrpRouterStatsTable_variables_oid);
}

int get_vrrpRouterChecksumErrors(netsnmp_mib_handler *handler,
    netsnmp_handler_registration *reginfo,
    netsnmp_agent_request_info *reqinfo,
    netsnmp_request_info *requests)
{
    switch (reqinfo->mode)
    {
        case MODE_GET:
            {
                VRRP_OM_Router_Statistics_Info_T entry;

                if (VRRP_PMGR_GetVrrpSysStatistics(&entry) == VRRP_TYPE_OK)
                {
                    long_return = entry.vrrpRouterChecksumErrors;
                    snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *) &long_return, sizeof(long_return));
                }
                else
                {
                    return SNMP_ERR_GENERR;
                }

                break;
            }


        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int get_vrrpRouterVersionErrors(netsnmp_mib_handler *handler,
    netsnmp_handler_registration *reginfo,
    netsnmp_agent_request_info *reqinfo,
    netsnmp_request_info *requests)
{
    switch (reqinfo->mode)
    {
        case MODE_GET:
            {
                VRRP_OM_Router_Statistics_Info_T entry;

                if (VRRP_PMGR_GetVrrpSysStatistics(&entry) == VRRP_TYPE_OK)
                {
                    long_return = entry.vrrpRouterVersionErrors;
                    snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *) &long_return, sizeof(long_return));
                }
                else
                {
                    return SNMP_ERR_GENERR;
                }

                break;
            }


        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int get_vrrpRouterVrIdErrors(netsnmp_mib_handler *handler,
    netsnmp_handler_registration *reginfo,
    netsnmp_agent_request_info *reqinfo,
    netsnmp_request_info *requests)
{
    switch (reqinfo->mode)
    {
        case MODE_GET:
            {
                VRRP_OM_Router_Statistics_Info_T entry;

                if (VRRP_PMGR_GetVrrpSysStatistics(&entry) == VRRP_TYPE_OK)
                {
                    long_return = entry.vrrpRouterVrIdErrors;
                    snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *) &long_return, sizeof(long_return));
                }
                else
                {
                    return SNMP_ERR_GENERR;
                }

                break;
            }


        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

#define VRRPROUTERSTATSENTRY_INSTANCE_LEN  2

BOOL_T vrrpRouterStatsTable_OidIndexToData(UI32_T exact, UI32_T compc,
    oid *compl, UI32_T *ifindex_p, UI8_T *vr_id_p)
{
    /* get or set
     */
    if (exact)
    {
        /* check the index length
         */
        if (compc != VRRPROUTERSTATSENTRY_INSTANCE_LEN) /* the constant size index */
        {
            return FALSE;
        }
    }

    *ifindex_p = compl[0];
    *vr_id_p = compl[1];

    return TRUE;
}

/*
 * var_vrrpRouterStatsTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *var_vrrpRouterStatsTable(struct variable *vp,
    oid *name,
    size_t *length,
    int exact,
    size_t *var_len,
    WriteMethod **write_method)
{
    UI32_T compc = 0;
    UI32_T ifindex = 0;
    UI8_T vr_id;
    oid compl[VRRPROUTERSTATSENTRY_INSTANCE_LEN] = {0};
    oid best_inst[VRRPROUTERSTATSENTRY_INSTANCE_LEN] = {0};
    VRRP_OM_Vrrp_Statistics_Info_T entry;

    switch (vp->magic)
    {
        default:
            *write_method = 0;
            break;
    }

    /* check compc, retrive compl
     */
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl, VRRPROUTERSTATSENTRY_INSTANCE_LEN);

    memset(&entry, 0, sizeof(entry));

    if (exact) /* get or set */
    {
        if (vrrpRouterStatsTable_OidIndexToData(exact, compc, compl, &ifindex, &vr_id) == FALSE)
        {
            return NULL;
        }

        if (VRRP_PMGR_GetVrrpGroupStatistics(ifindex, vr_id, &entry) != VRRP_TYPE_OK)
        {
            return NULL;
        }
    }
    else /* getnext */
    {
        vrrpRouterStatsTable_OidIndexToData(exact, compc, compl, &ifindex, &vr_id);

        /* check the length of inputing index,if < 1 we should try get
         * {0.0.0.0.0...}
         */
        if (compc < 1)
        {
            if (VRRP_PMGR_GetVrrpGroupStatistics(ifindex, vr_id, &entry) != VRRP_TYPE_OK)
            {
                if (VRRP_PMGR_GetNextVrrpGroupStatistics(&ifindex, &vr_id, &entry) != VRRP_TYPE_OK)
                {
                    return NULL;
                }
            }
        }
        else
        {
            if (VRRP_PMGR_GetNextVrrpGroupStatistics(&ifindex, &vr_id, &entry) != VRRP_TYPE_OK)
            {
                return NULL;
            }
        }
    }

    memcpy(name, vp->name, vp->namelen * sizeof(oid));

    /* assign data to the oid index
     */
    best_inst[0] = ifindex;
    best_inst[1] = vr_id;
    memcpy(name + vp->namelen, best_inst, VRRPROUTERSTATSENTRY_INSTANCE_LEN * sizeof(oid));
    *length = vp->namelen + VRRPROUTERSTATSENTRY_INSTANCE_LEN;

    switch (vp->magic)
    {
        case LEAF_vrrpStatsBecomeMaster:
            *var_len = sizeof(long_return);
            long_return = entry.vrrpStatsBecomeMaster;
            return (u_char *) &long_return;

        case LEAF_vrrpStatsAdvertiseRcvd:
            *var_len = sizeof(long_return);
            long_return = entry.vrrpStatsAdvertiseRcvd;
            return (u_char *) &long_return;

        case LEAF_vrrpStatsAdvertiseIntervalErrors:
            *var_len = sizeof(long_return);
            long_return = entry.vrrpStatsAdvertiseIntervalErrors;
            return (u_char *) &long_return;

        case LEAF_vrrpStatsAuthFailures:
            *var_len = sizeof(long_return);
            long_return = entry.vrrpStatsAuthFailures;
            return (u_char *) &long_return;

        case LEAF_vrrpStatsIpTtlErrors:
            *var_len = sizeof(long_return);
            long_return = entry.vrrpStatsIpTtlErrors;
            return (u_char *) &long_return;

        case LEAF_vrrpStatsPriorityZeroPktsRcvd:
            *var_len = sizeof(long_return);
            long_return = entry.vrrpStatsPriorityZeroPktsRcvd;
            return (u_char *) &long_return;

        case LEAF_vrrpStatsPriorityZeroPktsSent:
            *var_len = sizeof(long_return);
            long_return = entry.vrrpStatsPriorityZeroPktsSent;
            return (u_char *) &long_return;

        case LEAF_vrrpStatsInvalidTypePktsRcvd:
            *var_len = sizeof(long_return);
            long_return = entry.vrrpStatsInvalidTypePktsRcvd;
            return (u_char *) &long_return;

        case LEAF_vrrpStatsAddressListErrors:
            *var_len = sizeof(long_return);
            long_return = entry.vrrpStatsAddressListErrors;
            return (u_char *) &long_return;

        case LEAF_vrrpStatsInvalidAuthType:
            *var_len = sizeof(long_return);
            long_return = entry.vrrpStatsInvalidAuthType;
            return (u_char *) &long_return;

        case LEAF_vrrpStatsAuthTypeMismatch:
            *var_len = sizeof(long_return);
            long_return = entry.vrrpStatsAuthTypeMismatch;
            return (u_char *) &long_return;

        case LEAF_vrrpStatsPacketLengthErrors:
            *var_len = sizeof(long_return);
            long_return = entry.vrrpStatsPacketLengthErrors;
            return (u_char *) &long_return;

        default:
            ERROR_MSG("");
    }

    return NULL;
}

#endif /* #if (SYS_CPNT_VRRP == TRUE) */
