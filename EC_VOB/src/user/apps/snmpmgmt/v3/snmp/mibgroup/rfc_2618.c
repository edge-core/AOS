/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.scalar.conf,v 1.5 2002/07/18 14:18:52 dts12 Exp $
 */
#include "sys_cpnt.h"
#if (SYS_CPNT_RADIUS == TRUE)
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "rfc_2618.h"
#include "leaf_2618.h"
#include "radius_pom.h"
#include "sysORTable.h"


/** Initializes the radiusAuthClient module */
void
init_radiusAuthClient(void)
{
   static oid radius_modules_oid[]= {SNMP_OID_MIB2, 67 };
    static oid radiusAuthClientIdentifier_oid[] = { 1,3,6,1,2,1,67,1,2,1,1,2, 0 };
    static oid radiusAuthClientInvalidServerAddresses_oid[] = { 1,3,6,1,2,1,67,1,2,1,1,1, 0 };



    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("radiusAuthClientIdentifier",
                                         get_radiusAuthClientIdentifier,
                                         radiusAuthClientIdentifier_oid,
                                         OID_LENGTH(radiusAuthClientIdentifier_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("radiusAuthClientInvalidServerAddresses",
                                         get_radiusAuthClientInvalidServerAddresses,
                                         radiusAuthClientInvalidServerAddresses_oid,
                                         OID_LENGTH(radiusAuthClientInvalidServerAddresses_oid),
                                         HANDLER_CAN_RONLY));
      REGISTER_SYSOR_ENTRY(radius_modules_oid,
                         "The Rfc2618 Radius MIB.");
}

int
get_radiusAuthClientIdentifier(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

 UI8_T valueBufferP[MAXSIZE_radiusAuthClientIdentifier+1];

      if (RADIUS_POM_Get_NAS_ID(valueBufferP) != TRUE)
         return SNMP_ERR_GENERR;

     strcpy((char *)return_buf, (char *)valueBufferP);


    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, (u_char *)return_buf, strlen((char *)return_buf) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
get_radiusAuthClientInvalidServerAddresses(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

       UI32_T radiusAuthClientInvalidServerAddresses;

   	radiusAuthClientInvalidServerAddresses = RADIUS_POM_Get_UnknowAddress_Packets();

   long_return = radiusAuthClientInvalidServerAddresses;


    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *)& long_return, sizeof(long_return));
            break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

/*
 * radiusAuthServerTable_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid radiusAuthServerTable_variables_oid[] = { 1,3,6,1,2,1,67,1,2,1,1};

/*
 * variable4 radiusAuthServerTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */

struct variable3 radiusAuthServerTable_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */

#define RADIUSAUTHSERVERINDEX		1
{RADIUSAUTHSERVERINDEX,  ASN_INTEGER,  NOACCESS,   var_radiusAuthServerTable, 3,  { 3, 1, 1 }},
#define RADIUSAUTHSERVERADDRESS		2
{RADIUSAUTHSERVERADDRESS,  ASN_IPADDRESS,  RONLY,   var_radiusAuthServerTable, 3,  { 3, 1, 2 }},
#define RADIUSAUTHCLIENTSERVERPORTNUMBER		3
{RADIUSAUTHCLIENTSERVERPORTNUMBER,  ASN_INTEGER,  RONLY,   var_radiusAuthServerTable, 3,  { 3, 1, 3 }},
#define RADIUSAUTHCLIENTROUNDTRIPTIME		4
{RADIUSAUTHCLIENTROUNDTRIPTIME,  ASN_TIMETICKS,  RONLY,   var_radiusAuthServerTable, 3,  { 3, 1, 4 }},
#define RADIUSAUTHCLIENTACCESSREQUESTS		5
{RADIUSAUTHCLIENTACCESSREQUESTS,  ASN_COUNTER,  RONLY,   var_radiusAuthServerTable, 3,  { 3, 1, 5 }},
#define RADIUSAUTHCLIENTACCESSRETRANSMISSIONS		6
{RADIUSAUTHCLIENTACCESSRETRANSMISSIONS,  ASN_COUNTER,  RONLY,   var_radiusAuthServerTable, 3,  { 3, 1, 6 }},
#define RADIUSAUTHCLIENTACCESSACCEPTS		7
{RADIUSAUTHCLIENTACCESSACCEPTS,  ASN_COUNTER,  RONLY,   var_radiusAuthServerTable, 3,  { 3, 1, 7 }},
#define RADIUSAUTHCLIENTACCESSREJECTS		8
{RADIUSAUTHCLIENTACCESSREJECTS,  ASN_COUNTER,  RONLY,   var_radiusAuthServerTable, 3,  { 3, 1, 8 }},
#define RADIUSAUTHCLIENTACCESSCHALLENGES		9
{RADIUSAUTHCLIENTACCESSCHALLENGES,  ASN_COUNTER,  RONLY,   var_radiusAuthServerTable, 3,  { 3, 1, 9 }},
#define RADIUSAUTHCLIENTMALFORMEDACCESSRESPONSES		10
{RADIUSAUTHCLIENTMALFORMEDACCESSRESPONSES,  ASN_COUNTER,  RONLY,   var_radiusAuthServerTable, 3,  { 3, 1, 10 }},
#define RADIUSAUTHCLIENTBADAUTHENTICATORS		11
{RADIUSAUTHCLIENTBADAUTHENTICATORS,  ASN_COUNTER,  RONLY,   var_radiusAuthServerTable, 3,  { 3, 1, 11 }},
#define RADIUSAUTHCLIENTPENDINGREQUESTS		12
{RADIUSAUTHCLIENTPENDINGREQUESTS,  ASN_GAUGE,  RONLY,   var_radiusAuthServerTable, 3,  { 3, 1, 12 }},
#define RADIUSAUTHCLIENTTIMEOUTS		13
{RADIUSAUTHCLIENTTIMEOUTS,  ASN_COUNTER,  RONLY,   var_radiusAuthServerTable, 3,  { 3, 1, 13 }},
#define RADIUSAUTHCLIENTUNKNOWNTYPES		14
{RADIUSAUTHCLIENTUNKNOWNTYPES,  ASN_COUNTER,  RONLY,   var_radiusAuthServerTable, 3,  { 3, 1, 14 }},
#define RADIUSAUTHCLIENTPACKETSDROPPED		15
{RADIUSAUTHCLIENTPACKETSDROPPED,  ASN_COUNTER,  RONLY,   var_radiusAuthServerTable, 3,  { 3, 1, 15 }},
};
/*    (L = length of the oidsuffix) */


/** Initializes the radiusAuthServerTable module */
void
init_radiusAuthServerTable(void)
{

    DEBUGMSGTL(("radiusAuthServerTable", "Initializing\n"));

    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("radiusAuthServerTable", radiusAuthServerTable_variables, variable3,
               radiusAuthServerTable_variables_oid);

    /* place any other initialization junk you need here */
}

static int
header_radiusAuthServerTable(struct variable *vp,
               oid * name,
               size_t * length,
               int exact, size_t * var_len, WriteMethod ** write_method)
{
#define OID_NAME_LENGTH	14
    oid             newname[MAX_OID_LEN];
    int    interface;
    int             result;
    RADIUS_Server_Host_T server_host;
   UI32_T ifIndex = 0;
   BOOL_T return_val;


    memcpy((char *) newname, (char *) vp->name,
           (int) vp->namelen * sizeof(oid));
    /*
     * find "next" interface
     */

     while (  (return_val= RADIUS_POM_GetNext_Server_Host(&ifIndex,&server_host))==TRUE)
     {


        newname[OID_NAME_LENGTH] = (oid) ifIndex;
        result =
            snmp_oid_compare(name, *length, newname,
                             (int) vp->namelen + 1);
        if ((exact && (result == 0)) || (!exact && (result < 0)))
            break;
    }
    if (!return_val ) {
        return MATCH_FAILED;
    }


    memcpy((char *) name, (char *) newname,
           ((int) vp->namelen + 1) * sizeof(oid));
    *length = vp->namelen + 1;
    *write_method = 0;
    *var_len = sizeof(long);    /* default to 'long' results */
    interface = newname[OID_NAME_LENGTH];


    return interface;
}



/*
 * var_radiusAuthServerTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *
var_radiusAuthServerTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{
//   AuthServerEntry  entry;
    int             interface;
   RADIUS_Server_Host_T server_host;

//   memset( &entry, 0, sizeof(entry));
    interface =
        header_radiusAuthServerTable(vp, name, length, exact, var_len, write_method);

    if (interface == MATCH_FAILED)
        return NULL;

    if (RADIUS_POM_Get_Server_Host(interface - 1,&server_host) != TRUE)
            return NULL;

    /*
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
    case RADIUSAUTHSERVERADDRESS:
      *var_len = sizeof(ipaddr_return);
      ipaddr_return = server_host.server_ip;
        return (u_char*) &ipaddr_return;
   case RADIUSAUTHCLIENTSERVERPORTNUMBER:
      long_return = server_host.server_port;
        return (u_char*) &long_return;
    case RADIUSAUTHCLIENTROUNDTRIPTIME:
      long_return = server_host.server_table.radiusAuthClientRoundTripTime;
        return (u_char*) &long_return;
    case RADIUSAUTHCLIENTACCESSREQUESTS:
       long_return = server_host.server_table.radiusAuthClientAccessRequests;
        return (u_char*) &long_return;
    case RADIUSAUTHCLIENTACCESSRETRANSMISSIONS:
        long_return = server_host.server_table.radiusAuthClientAccessRetransmissions;
        return (u_char*) &long_return;
    case RADIUSAUTHCLIENTACCESSACCEPTS:
        long_return = server_host.server_table.radiusAuthClientAccessAccepts;
        return (u_char*) &long_return;
    case RADIUSAUTHCLIENTACCESSREJECTS:
       long_return =server_host.server_table.radiusAuthClientAccessRejects;
        return (u_char*) &long_return;
    case RADIUSAUTHCLIENTACCESSCHALLENGES:
        long_return = server_host.server_table.radiusAuthClientAccessChallenges;
        return (u_char*) &long_return;
    case RADIUSAUTHCLIENTMALFORMEDACCESSRESPONSES:
        long_return = server_host.server_table.radiusAuthClientMalformedAccessResponses;
        return (u_char*) &long_return;
    case RADIUSAUTHCLIENTBADAUTHENTICATORS:
        long_return = server_host.server_table.radiusAuthClientBadAuthenticators;
        return (u_char*) &long_return;
    case RADIUSAUTHCLIENTPENDINGREQUESTS:
        long_return = server_host.server_table.radiusAuthClientPendingRequests;
        return (u_char*) &long_return;
   case  RADIUSAUTHCLIENTTIMEOUTS:
        long_return = server_host.server_table.radiusAuthClientTimeouts;
        return (u_char*) &long_return;
    case RADIUSAUTHCLIENTUNKNOWNTYPES:
        long_return = server_host.server_table.radiusAuthClientUnknownTypes;
        return (u_char*) &long_return;
    case RADIUSAUTHCLIENTPACKETSDROPPED:
        long_return = server_host.server_table.radiusAuthClientPacketsDropped;
        return (u_char*) &long_return;
    default:
      ERROR_MSG("");
    }
    return NULL;
}
#endif
