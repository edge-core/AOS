/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.scalar.conf,v 1.5 2002/07/18 14:18:52 dts12 Exp $
 */
#if(SYS_CPNT_A3COM515_SNTP_MIB==TRUE)
#include "sys_cpnt.h"
#include "sys_type.h"
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "snmp_mgr.h"
#include "sntp_mgr.h"
#include "sys_time.h"
#include "leaf_a3com515Sntp.h"
#include "a3com515Sntp.h"


void
init_a3ComSntpGroup(void)
{
    static oid      sntpSecondaryServer_oid[] =
        { 1, 3, 6, 1, 4, 1, 43, 10, 50, 3, 0 };
    static oid      dstStartDate_oid[] =
        { 1, 3, 6, 1, 4, 1, 43, 10, 50, 9, 0 };
    static oid      timeZoneOffset_oid[] =
        { 1, 3, 6, 1, 4, 1, 43, 10, 50, 7, 0 };
    static oid      sntpState_oid[] =
        { 1, 3, 6, 1, 4, 1, 43, 10, 50, 1, 0 };
    static oid      dstState_oid[] =
        { 1, 3, 6, 1, 4, 1, 43, 10, 50, 8, 0 };
    static oid      sntpActiveServer_oid[] =
        { 1, 3, 6, 1, 4, 1, 43, 10, 50, 4, 0 };
    static oid      sntpTimeISO_oid[] =
        { 1, 3, 6, 1, 4, 1, 43, 10, 50, 6, 0 };
    static oid      sntpPollInterval_oid[] =
        { 1, 3, 6, 1, 4, 1, 43, 10, 50, 5, 0 };
    static oid      dstEndDate_oid[] =
        { 1, 3, 6, 1, 4, 1, 43, 10, 50, 10, 0 };
    static oid      sntpPrimaryServer_oid[] =
        { 1, 3, 6, 1, 4, 1, 43, 10, 50, 2, 0 };

    DEBUGMSGTL(("a3ComSntpGroup", "Initializing\n"));

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("sntpSecondaryServer",
                               do_sntpSecondaryServer,
                               sntpSecondaryServer_oid,
                               OID_LENGTH(sntpSecondaryServer_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("dstStartDate",
                               do_dstStartDate,
                               dstStartDate_oid,
                               OID_LENGTH(dstStartDate_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("timeZoneOffset",
                               do_timeZoneOffset,
                               timeZoneOffset_oid,
                               OID_LENGTH(timeZoneOffset_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("sntpState",
                               do_sntpState,
                               sntpState_oid,
                               OID_LENGTH(sntpState_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("dstState",
                               do_dstState,
                               dstState_oid,
                               OID_LENGTH(dstState_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("sntpActiveServer",
                                         get_sntpActiveServer,
                                         sntpActiveServer_oid,
                                         OID_LENGTH(sntpActiveServer_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("sntpTimeISO",
                                         get_sntpTimeISO,
                                         sntpTimeISO_oid,
                                         OID_LENGTH(sntpTimeISO_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("sntpPollInterval",
                               do_sntpPollIntervalA3com,
                               sntpPollInterval_oid,
                               OID_LENGTH(sntpPollInterval_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("dstEndDate",
                               do_dstEndDate,
                               dstEndDate_oid,
                               OID_LENGTH(dstEndDate_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("sntpPrimaryServer",
                               do_sntpPrimaryServer,
                               sntpPrimaryServer_oid,
                               OID_LENGTH(sntpPrimaryServer_oid),
                               HANDLER_CAN_RWRITE));
}

int
do_sntpState(netsnmp_mib_handler *handler,
             netsnmp_handler_registration *reginfo,
             netsnmp_agent_request_info *reqinfo,
             netsnmp_request_info *requests)
{

    switch (reqinfo->mode) {

    case MODE_GET:
        if(SNTP_MGR_GetStatus(&long_return)==TRUE)
        {
            switch(long_return)
            {
                case VAL_sntpStatus_enabled:
                    long_return = VAL_sntpState_enable;
                    break ;
                case VAL_sntpStatus_disabled:
                    long_return = VAL_sntpState_disable;
                    break;
                default:
                    return SNMP_ERR_GENERR;
                    break;
            }
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return) );
        }
        else
        {
            return SNMP_ERR_GENERR;
        }
        break;


    case MODE_SET_RESERVE1:
        if(*requests->requestvb->val.integer!=VAL_sntpState_disable && *requests->requestvb->val.integer!=VAL_sntpState_enable)
        {
            netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_WRONGVALUE);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
    {
        UI32_T value;
        switch((*requests->requestvb->val.integer))
        {
            case VAL_sntpState_enable:
                value =  VAL_sntpStatus_enabled;
                if (SNTP_MGR_SetStatus(value)!= TRUE)
                    netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
                break ;
            case VAL_sntpState_disable:
                value =  VAL_sntpStatus_disabled;
                if (SNTP_MGR_SetStatus(value)!= TRUE)
                    netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
                break;
            default:
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
                break;
        }

    }
        break;

    case MODE_SET_COMMIT:
        break;

    case MODE_SET_UNDO:
        break;

    default:
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_sntpPrimaryServer(netsnmp_mib_handler *handler,
                     netsnmp_handler_registration *reginfo,
                     netsnmp_agent_request_info *reqinfo,
                     netsnmp_request_info *requests)
{

    switch (reqinfo->mode) {

    case MODE_GET:
        if(SNTP_MGR_GetServerIp(SNTP_MGR_PRIMARY_SERVER,&long_return)==TRUE)
        {
            snmp_set_var_typed_value(requests->requestvb, ASN_IPADDRESS, (u_char *) &long_return, SYS_TYPE_IPV4_ADDR_LEN);
        }
        else
        {
            return SNMP_ERR_GENERR;
        }
        break;

    case MODE_SET_RESERVE1:
        break;

    case MODE_SET_RESERVE2:

        break;

    case MODE_SET_FREE:
        /*
         * XXX: free resources allocated in RESERVE1 and/or
         * RESERVE2.  Something failed somewhere, and the states
         * below won't be called.
         */
        break;

    case MODE_SET_ACTION:
    {
        UI32_T value;
        value = (*requests->requestvb->val.integer);
        if(value==0)
            SNTP_MGR_DeleteServerIpForSNMP(SNTP_MGR_PRIMARY_SERVER);
        else if (SNTP_MGR_AddServerIp(SNTP_MGR_PRIMARY_SERVER,value)!= TRUE)
            netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
    }

    case MODE_SET_COMMIT:
        break;

    case MODE_SET_UNDO:
        break;

    default:
        /*
         * we should never get here, so this is a really bad error
         */
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}


int
do_sntpSecondaryServer(netsnmp_mib_handler *handler,
                       netsnmp_handler_registration *reginfo,
                       netsnmp_agent_request_info *reqinfo,
                       netsnmp_request_info *requests)
{

    switch (reqinfo->mode) {

    case MODE_GET:
        if(SNTP_MGR_GetServerIp(SNTP_MGR_SECONDARY_SERVER,&long_return)==TRUE)
        {
            snmp_set_var_typed_value(requests->requestvb, ASN_IPADDRESS, (u_char *) &long_return, SYS_TYPE_IPV4_ADDR_LEN);
        }
        else
        {
            return SNMP_ERR_GENERR;
        }
        break;

    case MODE_SET_RESERVE1:
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
    {
        UI32_T value;
        value = (*requests->requestvb->val.integer);
        if(value==0)
            SNTP_MGR_DeleteServerIpForSNMP(SNTP_MGR_SECONDARY_SERVER);
        else if (SNTP_MGR_AddServerIp(SNTP_MGR_SECONDARY_SERVER,value)!= TRUE)
            netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
    }
    break;

    case MODE_SET_COMMIT:
        break;

    case MODE_SET_UNDO:
        break;

    default:
        return SNMP_ERR_GENERR;

    }

    return SNMP_ERR_NOERROR;
}

int
get_sntpActiveServer(netsnmp_mib_handler *handler,
                     netsnmp_handler_registration *reginfo,
                     netsnmp_agent_request_info *reqinfo,
                     netsnmp_request_info *requests)
{

    switch (reqinfo->mode) {

    case MODE_GET:
        if(SNTP_MGR_GetCurrentServer(&long_return)==TRUE)
        {
            snmp_set_var_typed_value(requests->requestvb, ASN_IPADDRESS, (u_char *) &long_return, SYS_TYPE_IPV4_ADDR_LEN);
        }
        else
        {
            return SNMP_ERR_GENERR;
        }
        break;


    default:
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}


int
do_sntpPollIntervalA3com(netsnmp_mib_handler *handler,
                    netsnmp_handler_registration *reginfo,
                    netsnmp_agent_request_info *reqinfo,
                    netsnmp_request_info *requests)
{

    switch (reqinfo->mode) {

    case MODE_GET:
        if(SNTP_MGR_GetPollTime(&long_return)==TRUE)
        {
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return) );
        }
        else
        {
            return SNMP_ERR_GENERR;
        }
        break;

    case MODE_SET_RESERVE1:
        if(*requests->requestvb->val.integer<MIN_sntpPollInterval3com||*requests->requestvb->val.integer>MAX_sntpPollInterval3com)
        {
            netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_WRONGVALUE);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
    {
        UI32_T value;
        value = (*requests->requestvb->val.integer);
        if (SNTP_MGR_SetPollTime(value)!= TRUE)
            netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
    }
    break;

    case MODE_SET_COMMIT:
        break;

    case MODE_SET_UNDO:
        break;

    default:
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_sntpTimeISO(netsnmp_mib_handler *handler,
                netsnmp_handler_registration *reginfo,
                netsnmp_agent_request_info *reqinfo,
                netsnmp_request_info *requests)
{

    switch (reqinfo->mode) {

    case MODE_GET:
    {
              if (SNTP_MGR_GetDSTCurrentSntpTimeISO(return_buf)== FALSE)
                       return SNMP_ERR_GENERR;
               snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, (u_char *) return_buf, strlen(return_buf));
    }
            break;

    default:
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_timeZoneOffset(netsnmp_mib_handler *handler,
                  netsnmp_handler_registration *reginfo,
                  netsnmp_agent_request_info *reqinfo,
                  netsnmp_request_info *requests)
{
    UI8_T tempName[MAXSIZE_sysTimeZoneName + 1];

    switch (reqinfo->mode) {

    case MODE_GET:
       if(SYS_TIME_GetTimeZone(tempName,(int *)&long_return)==TRUE)
        {
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return) );
        }
        else
        {
            return SNMP_ERR_GENERR;
        }
        break;


    case MODE_SET_RESERVE1:
        if(*requests->requestvb->val.integer<MIN_timeZoneOffset||*requests->requestvb->val.integer>MAX_timeZoneOffset)
        {
            netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_WRONGVALUE);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
    {
        int value;
        if(SYS_TIME_GetTimeZone(tempName,(int *)&value)!=TRUE)
            netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
        value = (*requests->requestvb->val.integer);
        if (SYS_TIME_SetTimeZone(tempName,value)!= TRUE)
            netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
    }
    break;

    case MODE_SET_COMMIT:
        break;

    case MODE_SET_UNDO:
        break;

    default:
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_dstState(netsnmp_mib_handler *handler,
             netsnmp_handler_registration *reginfo,
             netsnmp_agent_request_info *reqinfo,
             netsnmp_request_info *requests)
{

    switch (reqinfo->mode) {

    case MODE_GET:
        if(SNTP_MGR_GetDaylightSavingTimeStatus(&long_return)==TRUE)
        {
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return) );
        }
        else
        {
            return SNMP_ERR_GENERR;
        }
        break;

    case MODE_SET_RESERVE1:
        if(*requests->requestvb->val.integer<VAL_dstState_disable||*requests->requestvb->val.integer>VAL_dstState_user_configured)
        {
            netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_WRONGVALUE);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
    {
        UI32_T value;
        value = (*requests->requestvb->val.integer);
        if (SNTP_MGR_SetDSTOptionForSNMP(value)!= TRUE)
            netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
    }

    case MODE_SET_COMMIT:
        break;

    case MODE_SET_UNDO:
        break;

    default:
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_dstStartDate(netsnmp_mib_handler *handler,
                netsnmp_handler_registration *reginfo,
                netsnmp_agent_request_info *reqinfo,
                netsnmp_request_info *requests)
{

    switch (reqinfo->mode) {

    case MODE_GET:
    {
        if (SNTP_MGR_GetDSTFirstDay(return_buf)== FALSE)
            return SNMP_ERR_GENERR;
        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, (u_char *) return_buf, strlen(return_buf));
    }
            break;

    case MODE_SET_RESERVE1:
        if(requests->requestvb->val_len !=SIZE_dstStartDate)
        {
            netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_WRONGVALUE);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
    {
        UI8_T  buffer[SNTP_DEFAULT_DST_TIME_FORMAT_LEN+1];
        memcpy(buffer, requests->requestvb->val.string, requests->requestvb->val_len);
        buffer[requests->requestvb->val_len]=0;
        if (SNTP_MGR_SetDSTFirstdayForSNMP(buffer)== FALSE)
            netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
    }
        break;

    case MODE_SET_COMMIT:
        break;

    case MODE_SET_UNDO:
        break;

    default:
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}


int
do_dstEndDate(netsnmp_mib_handler *handler,
              netsnmp_handler_registration *reginfo,
              netsnmp_agent_request_info *reqinfo,
              netsnmp_request_info *requests)
{

    switch (reqinfo->mode) {

    case MODE_GET:
    {
        if (SNTP_MGR_GetDSTLastDay(return_buf)== FALSE)
            return SNMP_ERR_GENERR;
        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, (u_char *) return_buf, strlen(return_buf));
    }
        break;

    case MODE_SET_RESERVE1:
        if(requests->requestvb->val_len!=SIZE_dstEndDate)
        {
            netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_WRONGVALUE);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
    {
        UI8_T  buffer[SNTP_DEFAULT_DST_TIME_FORMAT_LEN+1];
        memcpy(buffer, requests->requestvb->val.string, requests->requestvb->val_len);
        buffer[requests->requestvb->val_len]=0;
        if (SNTP_MGR_SetDSTLastdayForSNMP(buffer)== FALSE)
            netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_COMMITFAILED);
    }
        break;

    case MODE_SET_COMMIT:
        break;

    case MODE_SET_UNDO:
        break;

    default:
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
#endif/*endif of #if(SYS_CPNT_A3COM515_SNTP_MIB==TRUE)*/
