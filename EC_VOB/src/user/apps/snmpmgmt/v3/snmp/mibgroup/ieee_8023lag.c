/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.old-api.conf,v 1.3 2002/10/17 09:40:46 dts12 Exp $
 */
#include "sys_cpnt.h"
#if (SYS_CPNT_LACP == TRUE)
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "l_snmp.h"
#include "ieee_8023lag.h"
#include "leaf_ieee8023lag.h"
#include "lacp_pmgr.h"
#include "lacp_pom.h"
#include "sysORTable.h"

/*
 * dot3adAggTable_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid             dot3adAggTable_variables_oid[] =
    { 1, 2, 840, 10006, 300, 43, 1, 1 };

 oid             dot3ad_lag_module_oid[] = { 1, 2, 840, 10006, 300, 43 };
/*
 * variable4 dot3adAggTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */

struct variable3 dot3adAggTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */

#define DOT3ADAGGMACADDRESS		2
    {DOT3ADAGGMACADDRESS, ASN_OCTET_STR, RONLY, var_dot3adAggTable, 3,
     {1, 1, 2}},
#define DOT3ADAGGACTORSYSTEMPRIORITY		3
    {DOT3ADAGGACTORSYSTEMPRIORITY, ASN_INTEGER, RWRITE, var_dot3adAggTable,
     3, {1, 1, 3}},
#define DOT3ADAGGACTORSYSTEMID		4
    {DOT3ADAGGACTORSYSTEMID, ASN_OCTET_STR, RONLY, var_dot3adAggTable, 3,
     {1, 1, 4}},
#define DOT3ADAGGAGGREGATEORINDIVIDUAL		5
    {DOT3ADAGGAGGREGATEORINDIVIDUAL, ASN_INTEGER, RONLY,
     var_dot3adAggTable, 3, {1, 1, 5}},
#define DOT3ADAGGACTORADMINKEY		6
    {DOT3ADAGGACTORADMINKEY, ASN_INTEGER, RWRITE, var_dot3adAggTable, 3,
     {1, 1, 6}},
#define DOT3ADAGGACTOROPERKEY		7
    {DOT3ADAGGACTOROPERKEY, ASN_INTEGER, RONLY, var_dot3adAggTable, 3,
     {1, 1, 7}},
#define DOT3ADAGGPARTNERSYSTEMID		8
    {DOT3ADAGGPARTNERSYSTEMID, ASN_OCTET_STR, RONLY, var_dot3adAggTable, 3,
     {1, 1, 8}},
#define DOT3ADAGGPARTNERSYSTEMPRIORITY		9
    {DOT3ADAGGPARTNERSYSTEMPRIORITY, ASN_INTEGER, RONLY,
     var_dot3adAggTable, 3, {1, 1, 9}},
#define DOT3ADAGGPARTNEROPERKEY		10
    {DOT3ADAGGPARTNEROPERKEY, ASN_INTEGER, RONLY, var_dot3adAggTable, 3,
     {1, 1, 10}},
#define DOT3ADAGGCOLLECTORMAXDELAY		11
    {DOT3ADAGGCOLLECTORMAXDELAY, ASN_INTEGER, RWRITE, var_dot3adAggTable,
     3, {1, 1, 11}},
};
/*
 * (L = length of the oidsuffix)
 */


/** Initializes the dot3adAggTable module */
void
init_dot3adAggTable(void)
{

    DEBUGMSGTL(("dot3adAggTable", "Initializing\n"));

    /*
     * register ourselves with the agent to handle our mib tree
     */
    REGISTER_MIB("dot3adAggTable", dot3adAggTable_variables, variable3,
                 dot3adAggTable_variables_oid);

    /*
     * place any other initialization junk you need here
     */
     REGISTER_SYSOR_ENTRY(dot3ad_lag_module_oid,
                         "The IEEE 802.3ad LAG MIB.");
}

static int
header_dot3adAggTable(struct variable *vp,
               oid * name,
               size_t * length,
               int exact, size_t * var_len, WriteMethod ** write_method,
               LACP_MGR_Dot3adAggEntry_T *entry)
{

   unsigned int ifIndex = 0;


     if(!entry || l_snmp_index_get(vp,name,length,&ifIndex,exact) < 0 )
          return MATCH_FAILED;

     entry->dot3ad_agg_index = ifIndex;

     if(!exact){

        if ( LACP_PMGR_GetNextDot3adAggEntry( entry)!=TRUE)
         return MATCH_FAILED;

        l_snmp_index_set(vp,name,length,entry->dot3ad_agg_index);

    }
    else
    {
        if(LACP_PMGR_GetDot3adAggEntry(entry)!=TRUE)
            return MATCH_FAILED;

    }

    *write_method = 0;
    *var_len = sizeof(long);    /* default to 'long' results */

    return entry->dot3ad_agg_index;
}

/*
 * var_dot3adAggTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_dot3adAggTable(struct variable *vp,
                   oid * name,
                   size_t * length,
                   int exact,
                   size_t * var_len, WriteMethod ** write_method)
{

    LACP_MGR_Dot3adAggEntry_T entry;

    memset( &entry, 0, sizeof(entry));

    if(MATCH_FAILED == header_dot3adAggTable(vp, name, length, exact, var_len, write_method,&entry))
        return NULL;
    /*
     * * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {

      case DOT3ADAGGMACADDRESS:

         memcpy(return_buf, entry.dot3ad_agg_mac_address, SIZE_dot3adAggMACAddress);
        *var_len = SIZE_dot3adAggMACAddress;
        return (u_char*) return_buf;
      case DOT3ADAGGACTORSYSTEMPRIORITY:
        *write_method = write_dot3adAggActorSystemPriority;
        long_return = entry.dot3ad_agg_actor_system_priority;
        return (u_char *) & long_return;
      case DOT3ADAGGACTORSYSTEMID:
        memcpy(return_buf, entry.dot3ad_agg_actor_system_id, SIZE_dot3adAggActorSystemID);
        *var_len = SIZE_dot3adAggActorSystemID;
        return (u_char*) return_buf;
      case DOT3ADAGGAGGREGATEORINDIVIDUAL:
        long_return = entry.dot3ad_agg_aggregate_or_individual;
        return (u_char *) & long_return;
      case DOT3ADAGGACTORADMINKEY:
        *write_method = write_dot3adAggActorAdminKey;
        long_return = entry.dot3ad_agg_actor_admin_key;
        return (u_char *) & long_return;
      case DOT3ADAGGACTOROPERKEY:
       long_return = entry.dot3ad_agg_actor_oper_key;
        return (u_char *) & long_return;
      case DOT3ADAGGPARTNERSYSTEMID:
         memcpy(return_buf, entry.dot3ad_agg_partner_system_id, SIZE_dot3adAggPartnerSystemID);
        *var_len = SIZE_dot3adAggPartnerSystemID;
        return (u_char*) return_buf;
      case DOT3ADAGGPARTNERSYSTEMPRIORITY:
       long_return = entry.dot3ad_agg_partner_system_priority;
        return (u_char *) & long_return;
      case DOT3ADAGGPARTNEROPERKEY:
        long_return = entry.dot3ad_agg_partner_oper_key;
        return (u_char *) & long_return;
      case DOT3ADAGGCOLLECTORMAXDELAY:
        *write_method = write_dot3adAggCollectorMaxDelay;
       long_return = entry.dot3ad_agg_collector_max_delay;
        return (u_char *) & long_return;
    default:
        ERROR_MSG("");
    }
    return NULL;
}


int
write_dot3adAggActorSystemPriority(int action,
                                   u_char * var_val,
                                   u_char var_val_type,
                                   size_t var_val_len,
                                   u_char * statP,
                                   oid * name, size_t name_len)
{
    long value;
    int size;


    UI32_T  dot3adAggActorSystemPriority;

    if ((char) name[10] != DOT3ADAGGACTORSYSTEMPRIORITY)
     {
        return SNMP_ERR_NOTWRITABLE;
    }
    if (name_len!=  12)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    dot3adAggActorSystemPriority = *(long *)var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }

          if ((dot3adAggActorSystemPriority <MIN_dot3adAggActorSystemPriority)
                ||(dot3adAggActorSystemPriority >MAX_dot3adAggActorSystemPriority))
          {
              return SNMP_ERR_WRONGVALUE;
          }
          break;


        case RESERVE2:
          size  = var_val_len;
          value = * (long *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:

           if (LACP_PMGR_SetDot3adAggActorSystemPriority(name[11], dot3adAggActorSystemPriority) != LACP_RETURN_SUCCESS)

           return SNMP_ERR_COMMITFAILED;
           break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot3adAggActorAdminKey(int action,
                             u_char * var_val,
                             u_char var_val_type,
                             size_t var_val_len,
                             u_char * statP, oid * name, size_t name_len)
{
    long value;
    int size;


    UI32_T  dot3adAggActorAdminKey;

    if ((char) name[10] != DOT3ADAGGACTORADMINKEY)
     {
        return SNMP_ERR_NOTWRITABLE;
    }
    if (name_len!=  12)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    dot3adAggActorAdminKey = *(long *)var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }

          if ((dot3adAggActorAdminKey <MIN_dot3adAggActorAdminKey)
                || (dot3adAggActorAdminKey >MAX_dot3adAggActorAdminKey))
         {
             return SNMP_ERR_WRONGVALUE;
         }
         break;


        case RESERVE2:
          size  = var_val_len;
          value = * (long *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:

           if (LACP_PMGR_SetDot3adAggActorAdminKey(name[11], dot3adAggActorAdminKey) != LACP_RETURN_SUCCESS)

           return SNMP_ERR_COMMITFAILED;
           break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_dot3adAggCollectorMaxDelay(int action,
                                 u_char * var_val,
                                 u_char var_val_type,
                                 size_t var_val_len,
                                 u_char * statP,
                                 oid * name, size_t name_len)
{
    long value;
    int size;


    UI32_T  dot3adAggCollectorMaxDelay;

    if ((char) name[10] != DOT3ADAGGCOLLECTORMAXDELAY)
     {
        return SNMP_ERR_NOTWRITABLE;
    }
    if (name_len!=  12)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    dot3adAggCollectorMaxDelay = *(long *)var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }

          if ((dot3adAggCollectorMaxDelay <MIN_dot3adAggCollectorMaxDelay)
                || (dot3adAggCollectorMaxDelay >MAX_dot3adAggCollectorMaxDelay))
          {
              return SNMP_ERR_WRONGVALUE;
          }
          break;


        case RESERVE2:
          size  = var_val_len;
          value = * (long *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:

           if (LACP_PMGR_SetDot3adAggCollectorMaxDelay(name[11], dot3adAggCollectorMaxDelay) != LACP_RETURN_SUCCESS)

           return SNMP_ERR_COMMITFAILED;
           break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

/*
 * dot3adAggPortListTable_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid             dot3adAggPortListTable_variables_oid[] =
    { 1, 2, 840, 10006, 300, 43, 1, 1};

/*
 * variable3 dot3adAggPortListTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */

struct variable3 dot3adAggPortListTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */

#define DOT3ADAGGPORTLISTPORTS		1
    {DOT3ADAGGPORTLISTPORTS, ASN_OCTET_STR, RONLY,
     var_dot3adAggPortListTable, 3, {2, 1, 1}},

};
/*
 * (L = length of the oidsuffix)
 */


/** Initializes the dot3adAggPortListTable module */
void
init_dot3adAggPortListTable(void)
{

    DEBUGMSGTL(("dot3adAggPortListTable", "Initializing\n"));

    /*
     * register ourselves with the agent to handle our mib tree
     */
    REGISTER_MIB("dot3adAggPortListTable",
                 dot3adAggPortListTable_variables, variable3,
                 dot3adAggPortListTable_variables_oid);

    /*
     * place any other initialization junk you need here
     */
}

static int
header_dot3adAggPortListTable(struct variable *vp,
               oid * name,
               size_t * length,
               int exact, size_t * var_len, WriteMethod ** write_method,
               LACP_MGR_Dot3adAggPortListEntry_T *entry)
{
  unsigned int ifIndex = 0;


    if(!entry || l_snmp_index_get(vp,name,length,&ifIndex,exact) < 0 )
         return MATCH_FAILED;

    entry->dot3ad_agg_index = ifIndex;

    if(!exact){
      if(LACP_PMGR_GetNextDot3adAggPortListEntry(entry)!=TRUE)
        return MATCH_FAILED;

     l_snmp_index_set(vp,name,length,entry->dot3ad_agg_index);
    }
    else
    {
        if(LACP_PMGR_GetDot3adAggPortListEntry(entry)!=TRUE)
            return MATCH_FAILED;

    }


    *write_method = 0;
    *var_len = sizeof(long);    /* default to 'long' results */

    return entry->dot3ad_agg_index;
}



/*
 * var_dot3adAggPortListTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_dot3adAggPortListTable(struct variable *vp,
                           oid * name,
                           size_t * length,
                           int exact,
                           size_t * var_len, WriteMethod ** write_method)
{

    LACP_MGR_Dot3adAggPortListEntry_T  entry;

    if(MATCH_FAILED == header_dot3adAggPortListTable(vp, name, length, exact, var_len, write_method,&entry))
        return NULL;

    /*
     * * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
      case DOT3ADAGGPORTLISTPORTS:
       memcpy( return_buf, entry.dot3ad_agg_port_list_ports, LACP_PORT_LIST_OCTETS);
       *var_len = LACP_PORT_LIST_OCTETS;
        return (u_char*) return_buf;
    default:
        ERROR_MSG("");
    }
    return NULL;
}

/*
 * dot3adAggPortTable_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid             dot3adAggPortTable_variables_oid[] =
    { 1, 2, 840, 10006, 300, 43, 1, 2 };

/*
 * variable4 dot3adAggPortTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */

struct variable3 dot3adAggPortTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */

#define DOT3ADAGGPORTACTORSYSTEMPRIORITY		2
    {DOT3ADAGGPORTACTORSYSTEMPRIORITY, ASN_INTEGER, RWRITE,
     var_dot3adAggPortTable, 3, {1, 1, 2}},
#define DOT3ADAGGPORTACTORSYSTEMID		3
    {DOT3ADAGGPORTACTORSYSTEMID, ASN_OCTET_STR, RONLY,
     var_dot3adAggPortTable, 3, {1, 1, 3}},
#define DOT3ADAGGPORTACTORADMINKEY		4
    {DOT3ADAGGPORTACTORADMINKEY, ASN_INTEGER, RWRITE,
     var_dot3adAggPortTable, 3, {1, 1, 4}},
#define DOT3ADAGGPORTACTOROPERKEY		5
    {DOT3ADAGGPORTACTOROPERKEY, ASN_INTEGER, RWRITE,
     var_dot3adAggPortTable, 3, {1, 1, 5}},
#define DOT3ADAGGPORTPARTNERADMINSYSTEMPRIORITY		6
    {DOT3ADAGGPORTPARTNERADMINSYSTEMPRIORITY, ASN_INTEGER, RWRITE,
     var_dot3adAggPortTable, 3, {1, 1, 6}},
#define DOT3ADAGGPORTPARTNEROPERSYSTEMPRIORITY		7
    {DOT3ADAGGPORTPARTNEROPERSYSTEMPRIORITY, ASN_INTEGER, RONLY,
     var_dot3adAggPortTable, 3, {1, 1, 7}},
#define DOT3ADAGGPORTPARTNERADMINSYSTEMID		8
    {DOT3ADAGGPORTPARTNERADMINSYSTEMID, ASN_OCTET_STR, RWRITE,
     var_dot3adAggPortTable, 3, {1, 1, 8}},
#define DOT3ADAGGPORTPARTNEROPERSYSTEMID		9
    {DOT3ADAGGPORTPARTNEROPERSYSTEMID, ASN_OCTET_STR, RONLY,
     var_dot3adAggPortTable, 3, {1, 1, 9}},
#define DOT3ADAGGPORTPARTNERADMINKEY		10
    {DOT3ADAGGPORTPARTNERADMINKEY, ASN_INTEGER, RWRITE,
     var_dot3adAggPortTable, 3, {1, 1, 10}},
#define DOT3ADAGGPORTPARTNEROPERKEY		11
    {DOT3ADAGGPORTPARTNEROPERKEY, ASN_INTEGER, RONLY,
     var_dot3adAggPortTable, 3, {1, 1, 11}},
#define DOT3ADAGGPORTSELECTEDAGGID		12
    {DOT3ADAGGPORTSELECTEDAGGID, ASN_INTEGER, RONLY,
     var_dot3adAggPortTable, 3, {1, 1, 12}},
#define DOT3ADAGGPORTATTACHEDAGGID		13
    {DOT3ADAGGPORTATTACHEDAGGID, ASN_INTEGER, RONLY,
     var_dot3adAggPortTable, 3, {1, 1, 13}},
#define DOT3ADAGGPORTACTORPORT		14
    {DOT3ADAGGPORTACTORPORT, ASN_INTEGER, RONLY, var_dot3adAggPortTable, 3,
     {1, 1, 14}},
#define DOT3ADAGGPORTACTORPORTPRIORITY		15
    {DOT3ADAGGPORTACTORPORTPRIORITY, ASN_INTEGER, RWRITE,
     var_dot3adAggPortTable, 3, {1, 1, 15}},
#define DOT3ADAGGPORTPARTNERADMINPORT		16
    {DOT3ADAGGPORTPARTNERADMINPORT, ASN_INTEGER, RWRITE,
     var_dot3adAggPortTable, 3, {1, 1, 16}},
#define DOT3ADAGGPORTPARTNEROPERPORT		17
    {DOT3ADAGGPORTPARTNEROPERPORT, ASN_INTEGER, RONLY,
     var_dot3adAggPortTable, 3, {1, 1, 17}},
#define DOT3ADAGGPORTPARTNERADMINPORTPRIORITY		18
    {DOT3ADAGGPORTPARTNERADMINPORTPRIORITY, ASN_INTEGER, RWRITE,
     var_dot3adAggPortTable, 3, {1, 1, 18}},
#define DOT3ADAGGPORTPARTNEROPERPORTPRIORITY		19
    {DOT3ADAGGPORTPARTNEROPERPORTPRIORITY, ASN_INTEGER, RONLY,
     var_dot3adAggPortTable, 3, {1, 1, 19}},
#define DOT3ADAGGPORTACTORADMINSTATE		20
    {DOT3ADAGGPORTACTORADMINSTATE,ASN_OCTET_STR, RWRITE, var_dot3adAggPortTable, 3,
     {1, 1, 20}},
#define DOT3ADAGGPORTACTOROPERSTATE		21
    {DOT3ADAGGPORTACTOROPERSTATE,ASN_OCTET_STR, RONLY, var_dot3adAggPortTable, 3,
     {1, 1, 21}},
#define DOT3ADAGGPORTPARTNERADMINSTATE		22
    {DOT3ADAGGPORTPARTNERADMINSTATE,ASN_OCTET_STR, RWRITE, var_dot3adAggPortTable, 3,
     {1, 1, 22}},
#define DOT3ADAGGPORTPARTNEROPERSTATE		23
    {DOT3ADAGGPORTPARTNEROPERSTATE,ASN_OCTET_STR, RONLY, var_dot3adAggPortTable, 3,
     {1, 1, 23}},
#define DOT3ADAGGPORTAGGREGATEORINDIVIDUAL		24
    {DOT3ADAGGPORTAGGREGATEORINDIVIDUAL, ASN_INTEGER, RONLY,
     var_dot3adAggPortTable, 3, {1, 1, 24}},
};
/*
 * (L = length of the oidsuffix)
 */


/** Initializes the dot3adAggPortTable module */
void
init_dot3adAggPortTable(void)
{

    DEBUGMSGTL(("dot3adAggPortTable", "Initializing\n"));

    /*
     * register ourselves with the agent to handle our mib tree
     */
    REGISTER_MIB("dot3adAggPortTable", dot3adAggPortTable_variables,
                 variable3, dot3adAggPortTable_variables_oid);

    /*
     * place any other initialization junk you need here
     */
}

static int
header_dot3adAggPortTable(struct variable *vp,
               oid * name,
               size_t * length,
               int exact, size_t * var_len, WriteMethod ** write_method,
               LACP_MGR_Dot3adAggPortEntry_T *entry)
{
  unsigned int ifIndex = 0;


  if(!entry || l_snmp_index_get(vp,name,length,&ifIndex,exact) < 0 )
       return MATCH_FAILED;

 entry->dot3ad_agg_port_index = ifIndex;

   if(!exact){
     if(LACP_PMGR_GetNextDot3adAggPortEntry(entry)!=TRUE)
       return MATCH_FAILED;

     l_snmp_index_set(vp,name,length,entry->dot3ad_agg_port_index);
    }
    else
    {
        if(LACP_PMGR_GetDot3adAggPortEntry(entry)!=TRUE)
            return MATCH_FAILED;

    }


    *write_method = 0;
    *var_len = sizeof(long);    /* default to 'long' results */

    return entry->dot3ad_agg_port_index ;

}


/*
 * var_dot3adAggPortTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_dot3adAggPortTable(struct variable *vp,
                       oid * name,
                       size_t * length,
                       int exact,
                       size_t * var_len, WriteMethod ** write_method)
{

    LACP_MGR_Dot3adAggPortEntry_T  entry;

    if(MATCH_FAILED == header_dot3adAggPortTable(vp, name, length, exact, var_len, write_method,&entry))
        return NULL;

    /*
     * * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {

      case DOT3ADAGGPORTACTORSYSTEMPRIORITY:
        *write_method = write_dot3adAggPortActorSystemPriority;
       long_return = entry.dot3ad_agg_port_actor_system_priority;
        return (u_char *) & long_return;
      case DOT3ADAGGPORTACTORSYSTEMID:
        memcpy( return_buf, entry.dot3ad_agg_port_actor_system_id, SIZE_dot3adAggPortActorSystemID);
       *var_len = SIZE_dot3adAggPortActorSystemID;
        return (u_char*) return_buf;
      case DOT3ADAGGPORTACTORADMINKEY:
        *write_method = write_dot3adAggPortActorAdminKey;
        long_return = entry.dot3ad_agg_port_actor_admin_key;
        return (u_char *) & long_return;
      case DOT3ADAGGPORTACTOROPERKEY:
        *write_method = write_dot3adAggPortActorOperKey;
        long_return = entry.dot3ad_agg_port_actor_oper_key;
        return (u_char *) & long_return;
      case DOT3ADAGGPORTPARTNERADMINSYSTEMPRIORITY:
        *write_method = write_dot3adAggPortPartnerAdminSystemPriority;
        long_return = entry.dot3ad_agg_port_partner_admin_system_priority;
        return (u_char *) & long_return;
      case DOT3ADAGGPORTPARTNEROPERSYSTEMPRIORITY:
       long_return = entry.dot3ad_agg_port_partner_oper_system_priority;
        return (u_char *) & long_return;
      case DOT3ADAGGPORTPARTNERADMINSYSTEMID:
        *write_method = write_dot3adAggPortPartnerAdminSystemID;
        memcpy( return_buf, entry.dot3ad_agg_port_partner_admin_system_id, SIZE_dot3adAggPortPartnerAdminSystemID);
       *var_len = SIZE_dot3adAggPortPartnerAdminSystemID;
        return (u_char*) return_buf;
      case DOT3ADAGGPORTPARTNEROPERSYSTEMID:
        memcpy( return_buf, entry.dot3ad_agg_port_partner_oper_system_id, SIZE_dot3adAggPortPartnerOperSystemID);
       *var_len = SIZE_dot3adAggPortPartnerOperSystemID;
        return (u_char*) return_buf;
      case DOT3ADAGGPORTPARTNERADMINKEY:
        *write_method = write_dot3adAggPortPartnerAdminKey;
        long_return = entry.dot3ad_agg_port_partner_admin_key;
        return (u_char *) & long_return;
      case DOT3ADAGGPORTPARTNEROPERKEY:
        long_return = entry.dot3ad_agg_port_partner_oper_key;
        return (u_char *) & long_return;
      case DOT3ADAGGPORTSELECTEDAGGID:
        long_return = entry.dot3ad_agg_port_selected_agg_id;
        return (u_char *) & long_return;
      case DOT3ADAGGPORTATTACHEDAGGID:
        long_return = entry.dot3ad_agg_port_attached_agg_id;
        return (u_char *) & long_return;
      case DOT3ADAGGPORTACTORPORT:
        long_return = entry.dot3ad_agg_port_actor_port;
        return (u_char *) & long_return;
      case DOT3ADAGGPORTACTORPORTPRIORITY:
        *write_method = write_dot3adAggPortActorPortPriority;
        long_return = entry.dot3ad_agg_port_actor_port_priority;
        return (u_char *) & long_return;
      case DOT3ADAGGPORTPARTNERADMINPORT:
        *write_method = write_dot3adAggPortPartnerAdminPort;
        long_return = entry.dot3ad_agg_port_partner_admin_port;
        return (u_char *) & long_return;
      case DOT3ADAGGPORTPARTNEROPERPORT:
        long_return = entry.dot3ad_agg_port_partner_oper_port;
        return (u_char *) & long_return;
      case DOT3ADAGGPORTPARTNERADMINPORTPRIORITY:
        *write_method = write_dot3adAggPortPartnerAdminPortPriority;
        long_return = entry.dot3ad_agg_port_partner_admin_port_priority;
        return (u_char *) & long_return;
      case DOT3ADAGGPORTPARTNEROPERPORTPRIORITY:
        long_return = entry.dot3ad_agg_port_partner_oper_port_priority;
        return (u_char *) & long_return;
      case DOT3ADAGGPORTACTORADMINSTATE:
        *write_method = write_dot3adAggPortActorAdminState;
         memcpy( return_buf, &entry.dot3ad_agg_port_actor_admin_state,1);
       *var_len = 1;
        return (u_char*) return_buf;
      case DOT3ADAGGPORTACTOROPERSTATE:
        memcpy( return_buf, &entry.dot3ad_agg_port_actor_oper_state,1);
       *var_len = 1;
        return (u_char*) return_buf;
      case DOT3ADAGGPORTPARTNERADMINSTATE:
        *write_method = write_dot3adAggPortPartnerAdminState;
         memcpy( return_buf, &entry.dot3ad_agg_port_partner_admin_state,1);
       *var_len = 1;
        return (u_char*) return_buf;
      case DOT3ADAGGPORTPARTNEROPERSTATE:
         memcpy( return_buf, &entry.dot3ad_agg_port_partner_oper_state,1);
       *var_len = 1;
        return (u_char*) return_buf;
      case DOT3ADAGGPORTAGGREGATEORINDIVIDUAL:
        long_return = entry.dot3ad_agg_port_aggregate_or_individual;
        return (u_char *) & long_return;
    default:
        ERROR_MSG("");
    }
    return NULL;
}


int
write_dot3adAggPortActorSystemPriority(int action,
                                       u_char * var_val,
                                       u_char var_val_type,
                                       size_t var_val_len,
                                       u_char * statP,
                                       oid * name, size_t name_len)
{
    long value;
    int size;


    UI32_T  dot3adAggPortActorSystemPriority;

    if ((char) name[10] != DOT3ADAGGPORTACTORSYSTEMPRIORITY)
     {
        return SNMP_ERR_NOTWRITABLE;
    }
    if (name_len!=  12)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    dot3adAggPortActorSystemPriority = *(long *)var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }

            if ((dot3adAggPortActorSystemPriority < MIN_dot3adAggPortActorSystemPriority)
                  || (dot3adAggPortActorSystemPriority > MAX_dot3adAggPortActorSystemPriority))
         {
            return SNMP_ERR_WRONGVALUE;
         }

          break;


        case RESERVE2:
          size  = var_val_len;
          value = * (long *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:

                if (LACP_PMGR_SetDot3adAggPortActorSystemPriority(name[11], dot3adAggPortActorSystemPriority) != LACP_RETURN_SUCCESS)

       return SNMP_ERR_COMMITFAILED;
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot3adAggPortActorAdminKey(int action,
                                 u_char * var_val,
                                 u_char var_val_type,
                                 size_t var_val_len,
                                 u_char * statP,
                                 oid * name, size_t name_len)
{
    long value;
    int size;


    UI32_T  dot3adAggPortActorAdminKey;

    if ((char) name[10] != DOT3ADAGGPORTACTORADMINKEY)
     {
        return SNMP_ERR_NOTWRITABLE;
    }
    if (name_len!=  12)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    dot3adAggPortActorAdminKey = *(long *)var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }

          if ((dot3adAggPortActorAdminKey < MIN_dot3adAggPortActorAdminKey)
                || (dot3adAggPortActorAdminKey > MAX_dot3adAggPortActorAdminKey))
          {
              return SNMP_ERR_WRONGVALUE;
          }
          break;


        case RESERVE2:
          size  = var_val_len;
          value = * (long *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:

                if (LACP_PMGR_SetDot3adAggPortActorAdminKey(name[11], dot3adAggPortActorAdminKey) != LACP_RETURN_SUCCESS)

       return SNMP_ERR_COMMITFAILED;
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot3adAggPortActorOperKey(int action,
                                u_char * var_val,
                                u_char var_val_type,
                                size_t var_val_len,
                                u_char * statP,
                                oid * name, size_t name_len)
{
    long value;
    int size;


    UI32_T  dot3adAggPortActorOperKey;

    if ((char) name[10] != DOT3ADAGGPORTACTOROPERKEY)
     {
        return SNMP_ERR_NOTWRITABLE;
    }
    if (name_len!=  12)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    dot3adAggPortActorOperKey = *(long *)var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }

          if ((dot3adAggPortActorOperKey < MIN_dot3adAggPortActorOperKey)
                 || (dot3adAggPortActorOperKey > MAX_dot3adAggPortActorOperKey))
          {
              return SNMP_ERR_WRONGVALUE;
          }
          break;


        case RESERVE2:
          size  = var_val_len;
          value = * (long *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:

                if (LACP_PMGR_SetDot3adAggPortActorOperKey(name[11], dot3adAggPortActorOperKey) != LACP_RETURN_SUCCESS)

       return SNMP_ERR_COMMITFAILED;
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot3adAggPortPartnerAdminSystemPriority(int action,
                                              u_char * var_val,
                                              u_char var_val_type,
                                              size_t var_val_len,
                                              u_char * statP,
                                              oid * name, size_t name_len)
{
    long value;
    int size;


    UI32_T  dot3adAggPortPartnerAdminSystemPriority;

    if ((char) name[10] != DOT3ADAGGPORTPARTNERADMINSYSTEMPRIORITY)
     {
        return SNMP_ERR_NOTWRITABLE;
    }
    if (name_len!=  12)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    dot3adAggPortPartnerAdminSystemPriority = *(long *)var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }

          if ((dot3adAggPortPartnerAdminSystemPriority < MIN_dot3adAggPortPartnerAdminSystemPriority)
                || (dot3adAggPortPartnerAdminSystemPriority > MAX_dot3adAggPortPartnerAdminSystemPriority))
          {
              return SNMP_ERR_WRONGVALUE;
          }
          break;


        case RESERVE2:
          size  = var_val_len;
          value = * (long *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:

                if (LACP_PMGR_SetDot3adAggPortPartnerAdminSystemPriority(name[11], dot3adAggPortPartnerAdminSystemPriority) != LACP_RETURN_SUCCESS)

       return SNMP_ERR_COMMITFAILED;
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot3adAggPortPartnerAdminSystemID(int action,
                                        u_char * var_val,
                                        u_char var_val_type,
                                        size_t var_val_len,
                                        u_char * statP,
                                        oid * name, size_t name_len)
{
    char value;
    int size;
  UI8_T dot3adAggPortPartnerAdminSystemID[SIZE_dot3adAggPortPartnerAdminSystemID];


      if ((char) name[10] != DOT3ADAGGPORTPARTNERADMINSYSTEMID)
     {
        return SNMP_ERR_NOTWRITABLE;
    }

    if (name_len!=  12)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len !=(SIZE_dot3adAggPortPartnerAdminSystemID)* sizeof(char)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          size  = var_val_len;
          value = * (char *) var_val;


          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             memcpy ( dot3adAggPortPartnerAdminSystemID, var_val, var_val_len);

            if (LACP_PMGR_SetDot3adAggPortPartnerAdminSystemId (name[11], dot3adAggPortPartnerAdminSystemID) != LACP_RETURN_SUCCESS)
               return SNMP_ERR_COMMITFAILED;
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot3adAggPortPartnerAdminKey(int action,
                                   u_char * var_val,
                                   u_char var_val_type,
                                   size_t var_val_len,
                                   u_char * statP,
                                   oid * name, size_t name_len)
{
    long value;
    int size;


    UI32_T  dot3adAggPortPartnerAdminKey;

    if ((char) name[10] != DOT3ADAGGPORTPARTNERADMINKEY)
     {
        return SNMP_ERR_NOTWRITABLE;
    }
    if (name_len!=  12)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    dot3adAggPortPartnerAdminKey = *(long *)var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }

          if ((dot3adAggPortPartnerAdminKey < MIN_dot3adAggPortPartnerAdminKey)
                || (dot3adAggPortPartnerAdminKey > MAX_dot3adAggPortPartnerAdminKey))
          {
              return SNMP_ERR_WRONGVALUE;
          }
          break;


        case RESERVE2:
          size  = var_val_len;
          value = * (long *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:

                if (LACP_PMGR_SetDot3adAggPortPartnerAdminKey(name[11], dot3adAggPortPartnerAdminKey) != LACP_RETURN_SUCCESS)

       return SNMP_ERR_COMMITFAILED;
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot3adAggPortActorPortPriority(int action,
                                     u_char * var_val,
                                     u_char var_val_type,
                                     size_t var_val_len,
                                     u_char * statP,
                                     oid * name, size_t name_len)
{
    long value;
    int size;


    UI32_T  dot3adAggPortActorPortPriority;

    if ((char) name[10] != DOT3ADAGGPORTACTORPORTPRIORITY)
     {
        return SNMP_ERR_NOTWRITABLE;
    }
    if (name_len!=  12)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    dot3adAggPortActorPortPriority = *(long *)var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }

          if ((dot3adAggPortActorPortPriority < MIN_dot3adAggPortActorPortPriority)
                || (dot3adAggPortActorPortPriority > MAX_dot3adAggPortActorPortPriority))
          {
              return SNMP_ERR_WRONGVALUE;
          }
          break;


        case RESERVE2:
          size  = var_val_len;
          value = * (long *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:

                if (LACP_PMGR_SetDot3adAggPortActorPortPriority(name[11], dot3adAggPortActorPortPriority) != LACP_RETURN_SUCCESS)

       return SNMP_ERR_COMMITFAILED;
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot3adAggPortPartnerAdminPort(int action,
                                    u_char * var_val,
                                    u_char var_val_type,
                                    size_t var_val_len,
                                    u_char * statP,
                                    oid * name, size_t name_len)
{
    long value;
    int size;


    UI32_T  dot3adAggPortPartnerAdminPort;

    if ((char) name[10] != DOT3ADAGGPORTPARTNERADMINPORT)
     {
        return SNMP_ERR_NOTWRITABLE;
    }
    if (name_len!=  12)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    dot3adAggPortPartnerAdminPort = *(long *)var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }

          if ((dot3adAggPortPartnerAdminPort < MIN_dot3adAggPortPartnerAdminPort)
                || (dot3adAggPortPartnerAdminPort > MAX_dot3adAggPortPartnerAdminPort))
          {
              return SNMP_ERR_WRONGVALUE;
          }
          break;


        case RESERVE2:
          size  = var_val_len;
          value = * (long *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:

                if (LACP_PMGR_SetDot3adAggPortPartnerAdminPort(name[11], dot3adAggPortPartnerAdminPort) != LACP_RETURN_SUCCESS)

       return SNMP_ERR_COMMITFAILED;
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot3adAggPortPartnerAdminPortPriority(int action,
                                            u_char * var_val,
                                            u_char var_val_type,
                                            size_t var_val_len,
                                            u_char * statP,
                                            oid * name, size_t name_len)
{
    long value;
    int size;


    UI32_T  dot3adAggPortPartnerAdminPortPriority;

    if ((char) name[10] != DOT3ADAGGPORTPARTNERADMINPORTPRIORITY)
     {
        return SNMP_ERR_NOTWRITABLE;
    }
    if (name_len!=  12)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    dot3adAggPortPartnerAdminPortPriority = *(long *)var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }

          if ((dot3adAggPortPartnerAdminPortPriority < MIN_dot3adAggPortPartnerAdminPortPriority)
                || (dot3adAggPortPartnerAdminPortPriority > MAX_dot3adAggPortPartnerAdminPortPriority))
          {
              return SNMP_ERR_WRONGVALUE;
          }
          break;


        case RESERVE2:
          size  = var_val_len;
          value = * (long *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:

                if (LACP_PMGR_SetDot3adAggPortPartnerAdminPortPriority(name[11], dot3adAggPortPartnerAdminPortPriority) != LACP_RETURN_SUCCESS)

       return SNMP_ERR_COMMITFAILED;
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot3adAggPortActorAdminState(int action,
                                   u_char * var_val,
                                   u_char var_val_type,
                                   size_t var_val_len,
                                   u_char * statP,
                                   oid * name, size_t name_len)
{
    char value;
    int size;
  UI8_T dot3adAggPortActorAdminState;


      if ((char) name[10] != DOT3ADAGGPORTACTORADMINSTATE)
     {
        return SNMP_ERR_NOTWRITABLE;
    }
    if (name_len!=  12)
    {
        return SNMP_ERR_WRONGLENGTH;
    }


    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              return SNMP_ERR_WRONGTYPE;
          }

          break;

        case RESERVE2:
          size  = var_val_len;
          value = * (char *) var_val;


          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             memcpy ( &dot3adAggPortActorAdminState, var_val, 1);

            if (LACP_PMGR_SetDot3adAggPortActorAdminState (name[11], dot3adAggPortActorAdminState) != LACP_RETURN_SUCCESS)
               return SNMP_ERR_COMMITFAILED;
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot3adAggPortPartnerAdminState(int action,
                                     u_char * var_val,
                                     u_char var_val_type,
                                     size_t var_val_len,
                                     u_char * statP,
                                     oid * name, size_t name_len)
{
    char value;
    int size;
  UI8_T dot3adAggPortPartnerAdminState;


      if ((char) name[10] != DOT3ADAGGPORTPARTNERADMINSTATE)
     {
        return SNMP_ERR_NOTWRITABLE;
    }

    if (name_len!=  12)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              return SNMP_ERR_WRONGTYPE;
          }

          break;

        case RESERVE2:
          size  = var_val_len;
          value = * (char *) var_val;


          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             memcpy ( &dot3adAggPortPartnerAdminState, var_val, 1);

            if (LACP_PMGR_SetDot3adAggPortPartnerAdminState (name[11], dot3adAggPortPartnerAdminState) != LACP_RETURN_SUCCESS)
               return SNMP_ERR_COMMITFAILED;
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

/*
 * dot3adAggPortStatsTable_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid             dot3adAggPortStatsTable_variables_oid[] =
    { 1, 2, 840, 10006, 300, 43, 1, 2 };

/*
 * variable3 dot3adAggPortStatsTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */

struct variable3 dot3adAggPortStatsTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */

#define DOT3ADAGGPORTSTATSLACPDUSRX		1
    {DOT3ADAGGPORTSTATSLACPDUSRX, ASN_COUNTER, RONLY,
     var_dot3adAggPortStatsTable, 3, {2, 1, 1}},
#define DOT3ADAGGPORTSTATSMARKERPDUSRX		2
    {DOT3ADAGGPORTSTATSMARKERPDUSRX, ASN_COUNTER, RONLY,
     var_dot3adAggPortStatsTable, 3, {2, 1, 2}},
#define DOT3ADAGGPORTSTATSMARKERRESPONSEPDUSRX		3
    {DOT3ADAGGPORTSTATSMARKERRESPONSEPDUSRX, ASN_COUNTER, RONLY,
     var_dot3adAggPortStatsTable, 3, {2, 1, 3}},
#define DOT3ADAGGPORTSTATSUNKNOWNRX		4
    {DOT3ADAGGPORTSTATSUNKNOWNRX, ASN_COUNTER, RONLY,
     var_dot3adAggPortStatsTable, 3, {2, 1, 4}},
#define DOT3ADAGGPORTSTATSILLEGALRX		5
    {DOT3ADAGGPORTSTATSILLEGALRX, ASN_COUNTER, RONLY,
     var_dot3adAggPortStatsTable, 3, {2, 1, 5}},
#define DOT3ADAGGPORTSTATSLACPDUSTX		6
    {DOT3ADAGGPORTSTATSLACPDUSTX, ASN_COUNTER, RONLY,
     var_dot3adAggPortStatsTable, 3, {2, 1, 6}},
#define DOT3ADAGGPORTSTATSMARKERPDUSTX		7
    {DOT3ADAGGPORTSTATSMARKERPDUSTX, ASN_COUNTER, RONLY,
     var_dot3adAggPortStatsTable, 3, {2, 1, 7}},
#define DOT3ADAGGPORTSTATSMARKERRESPONSEPDUSTX		8
    {DOT3ADAGGPORTSTATSMARKERRESPONSEPDUSTX, ASN_COUNTER, RONLY,
     var_dot3adAggPortStatsTable, 3, {2, 1, 8}},
};
/*
 * (L = length of the oidsuffix)
 */


/** Initializes the dot3adAggPortStatsTable module */
void
init_dot3adAggPortStatsTable(void)
{

    DEBUGMSGTL(("dot3adAggPortStatsTable", "Initializing\n"));

    /*
     * register ourselves with the agent to handle our mib tree
     */
    REGISTER_MIB("dot3adAggPortStatsTable",
                 dot3adAggPortStatsTable_variables, variable3,
                 dot3adAggPortStatsTable_variables_oid);

    /*
     * place any other initialization junk you need here
     */
}

static int
header_dot3adAggPortStatsTable(struct variable *vp,
               oid * name,
               size_t * length,
               int exact, size_t * var_len, WriteMethod ** write_method,
               LACP_MGR_Dot3adAggPortStatsEntry_T *entry)
{

     unsigned int  ifIndex = 0;


     if(!entry || l_snmp_index_get(vp,name,length,&ifIndex,exact) < 0 )
          return MATCH_FAILED;

     entry->dot3ad_agg_port_index = ifIndex;
     if(!exact){
       if (LACP_PMGR_GetNextDot3adAggPortStatsEntry(entry)!= TRUE)
        return MATCH_FAILED;

     l_snmp_index_set(vp,name,length,entry->dot3ad_agg_port_index);
    }
    else
    {
        if(LACP_PMGR_GetDot3adAggPortStatsEntry(entry)!=TRUE)
            return MATCH_FAILED;

    }


    *write_method = 0;
    *var_len = sizeof(long);    /* default to 'long' results */

    return entry->dot3ad_agg_port_index;

}

/*
 * var_dot3adAggPortStatsTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_dot3adAggPortStatsTable(struct variable *vp,
                            oid * name,
                            size_t * length,
                            int exact,
                            size_t * var_len, WriteMethod ** write_method)
{

    LACP_MGR_Dot3adAggPortStatsEntry_T entry;


    memset( &entry, 0, sizeof(entry));

    if( MATCH_FAILED == header_dot3adAggPortStatsTable(vp, name, length, exact, var_len, write_method,&entry))
        return NULL;

    /*
     * * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
      case DOT3ADAGGPORTSTATSLACPDUSRX:
        long_return = entry.dot3ad_agg_port_stats_lac_pdus_rx;
        return (u_char *) & long_return;
      case DOT3ADAGGPORTSTATSMARKERPDUSRX:
        long_return = entry.dot3ad_agg_port_stats_marker_pdus_rx;
        return (u_char *) & long_return;
      case DOT3ADAGGPORTSTATSMARKERRESPONSEPDUSRX:
        long_return = entry.dot3ad_agg_port_stats_marker_response_pdus_rx;
        return (u_char *) & long_return;
      case DOT3ADAGGPORTSTATSUNKNOWNRX:
        long_return = entry.dot3ad_agg_port_stats_unknown_rx;
        return (u_char *) & long_return;
      case DOT3ADAGGPORTSTATSILLEGALRX:
        long_return = entry.dot3ad_agg_port_stats_illegal_rx;
        return (u_char *) & long_return;
      case DOT3ADAGGPORTSTATSLACPDUSTX:
        long_return = entry.dot3ad_agg_port_stats_lac_pdus_tx;
        return (u_char *) & long_return;
      case DOT3ADAGGPORTSTATSMARKERPDUSTX:
        long_return = entry.dot3ad_agg_port_stats_marker_pdus_tx;
        return (u_char *) & long_return;
      case DOT3ADAGGPORTSTATSMARKERRESPONSEPDUSTX:
        long_return = entry.dot3ad_agg_port_stats_marker_response_pdus_tx;
        return (u_char *) & long_return;
    default:
        ERROR_MSG("");
    }
    return NULL;
}

/*
 * dot3adAggPortDebugTable_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid             dot3adAggPortDebugTable_variables_oid[] =
    { 1, 2, 840, 10006, 300, 43, 1, 2 };

/*
 * variable4 dot3adAggPortDebugTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */

struct variable3 dot3adAggPortDebugTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */

#define DOT3ADAGGPORTDEBUGRXSTATE		1
    {DOT3ADAGGPORTDEBUGRXSTATE, ASN_INTEGER, RONLY,
     var_dot3adAggPortDebugTable, 3, {3, 1, 1}},
#define DOT3ADAGGPORTDEBUGLASTRXTIME		2
    {DOT3ADAGGPORTDEBUGLASTRXTIME, ASN_TIMETICKS, RONLY,
     var_dot3adAggPortDebugTable, 3, {3, 1, 2}},
#define DOT3ADAGGPORTDEBUGMUXSTATE		3
    {DOT3ADAGGPORTDEBUGMUXSTATE, ASN_INTEGER, RONLY,
     var_dot3adAggPortDebugTable, 3, {3, 1, 3}},
#define DOT3ADAGGPORTDEBUGMUXREASON		4
    {DOT3ADAGGPORTDEBUGMUXREASON, ASN_OCTET_STR, RONLY,
     var_dot3adAggPortDebugTable, 3, {3, 1, 4}},
#define DOT3ADAGGPORTDEBUGACTORCHURNSTATE		5
    {DOT3ADAGGPORTDEBUGACTORCHURNSTATE, ASN_INTEGER, RONLY,
     var_dot3adAggPortDebugTable, 3, {3, 1, 5}},
#define DOT3ADAGGPORTDEBUGPARTNERCHURNSTATE		6
    {DOT3ADAGGPORTDEBUGPARTNERCHURNSTATE, ASN_INTEGER, RONLY,
     var_dot3adAggPortDebugTable, 3, {3, 1, 6}},
#define DOT3ADAGGPORTDEBUGACTORCHURNCOUNT		7
    {DOT3ADAGGPORTDEBUGACTORCHURNCOUNT, ASN_COUNTER, RONLY,
     var_dot3adAggPortDebugTable, 3, {3, 1, 7}},
#define DOT3ADAGGPORTDEBUGPARTNERCHURNCOUNT		8
    {DOT3ADAGGPORTDEBUGPARTNERCHURNCOUNT, ASN_COUNTER, RONLY,
     var_dot3adAggPortDebugTable, 3, {3, 1, 8}},
#define DOT3ADAGGPORTDEBUGACTORSYNCTRANSITIONCOUNT		9
    {DOT3ADAGGPORTDEBUGACTORSYNCTRANSITIONCOUNT, ASN_COUNTER, RONLY,
     var_dot3adAggPortDebugTable, 3, {3, 1, 9}},
#define DOT3ADAGGPORTDEBUGPARTNERSYNCTRANSITIONCOUNT		10
    {DOT3ADAGGPORTDEBUGPARTNERSYNCTRANSITIONCOUNT, ASN_COUNTER, RONLY,
     var_dot3adAggPortDebugTable, 3, {3, 1, 10}},
#define DOT3ADAGGPORTDEBUGACTORCHANGECOUNT		11
    {DOT3ADAGGPORTDEBUGACTORCHANGECOUNT, ASN_COUNTER, RONLY,
     var_dot3adAggPortDebugTable, 3, {3, 1, 11}},
#define DOT3ADAGGPORTDEBUGPARTNERCHANGECOUNT		12
    {DOT3ADAGGPORTDEBUGPARTNERCHANGECOUNT, ASN_COUNTER, RONLY,
     var_dot3adAggPortDebugTable, 3, {3, 1, 12}},
};
/*
 * (L = length of the oidsuffix)
 */


/** Initializes the dot3adAggPortDebugTable module */
void
init_dot3adAggPortDebugTable(void)
{

    DEBUGMSGTL(("dot3adAggPortDebugTable", "Initializing\n"));

    /*
     * register ourselves with the agent to handle our mib tree
     */
    REGISTER_MIB("dot3adAggPortDebugTable",
                 dot3adAggPortDebugTable_variables, variable3,
                 dot3adAggPortDebugTable_variables_oid);

    /*
     * place any other initialization junk you need here
     */
}

static int
header_dot3adAggPortDebugTable(struct variable *vp,
               oid * name,
               size_t * length,
               int exact, size_t * var_len, WriteMethod ** write_method,
               LACP_MGR_Dot3adAggPortDebugEntry_T *entry)
{
    unsigned int  ifIndex = 0;


    if(!entry || l_snmp_index_get(vp,name,length,&ifIndex,exact) < 0 )
         return MATCH_FAILED;

    entry->dot3ad_agg_port_index = ifIndex;

    if(!exact){
      if (LACP_PMGR_GetNextDot3adAggPortDebugEntry(entry) != TRUE)
        return MATCH_FAILED;

      l_snmp_index_set(vp,name,length,entry->dot3ad_agg_port_index);
    }
    else
    {
        if(LACP_PMGR_GetDot3adAggPortDebugEntry(entry)!=TRUE)
            return MATCH_FAILED;

    }


    *write_method = 0;
    *var_len = sizeof(long);    /* default to 'long' results */

    return entry->dot3ad_agg_port_index;

}


/*
 * var_dot3adAggPortDebugTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_dot3adAggPortDebugTable(struct variable *vp,
                            oid * name,
                            size_t * length,
                            int exact,
                            size_t * var_len, WriteMethod ** write_method)
{

    LACP_MGR_Dot3adAggPortDebugEntry_T entry;

    memset( &entry, 0, sizeof(entry));

    if( MATCH_FAILED == header_dot3adAggPortDebugTable(vp, name, length, exact, var_len, write_method,&entry))
        return NULL;

    /*
     * * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
      case DOT3ADAGGPORTDEBUGRXSTATE:
       long_return = entry.dot3ad_agg_port_debug_rx_state;
        return (u_char *) & long_return;
      case DOT3ADAGGPORTDEBUGLASTRXTIME:
        long_return = entry.dot3ad_agg_port_debug_last_rx_time;
        return (u_char *) & long_return;
      case DOT3ADAGGPORTDEBUGMUXSTATE:
        long_return = entry.dot3ad_agg_port_debug_mux_state;
        return (u_char *) & long_return;
      case DOT3ADAGGPORTDEBUGMUXREASON:
        memcpy(return_buf,entry.dot3ad_agg_port_debug_mux_reason, MAXSIZE_dot3adAggPortDebugMuxReason);
        return (u_char *) return_buf;
      case DOT3ADAGGPORTDEBUGACTORCHURNSTATE:
        long_return = entry.dot3ad_agg_port_debug_actor_churn_state;
        return (u_char *) & long_return;
      case DOT3ADAGGPORTDEBUGPARTNERCHURNSTATE:
        long_return = entry.dot3ad_agg_port_debug_partner_churn_state;
        return (u_char *) & long_return;
      case DOT3ADAGGPORTDEBUGACTORCHURNCOUNT:
        long_return = entry.dot3ad_agg_port_debug_actor_churn_count;
        return (u_char *) & long_return;
      case DOT3ADAGGPORTDEBUGPARTNERCHURNCOUNT:
        long_return = entry.dot3ad_agg_port_debug_partner_churn_count;
        return (u_char *) & long_return;
      case DOT3ADAGGPORTDEBUGACTORSYNCTRANSITIONCOUNT:
        long_return = entry.dot3ad_agg_port_debug_actor_sync_transition_count;
        return (u_char *) & long_return;
      case DOT3ADAGGPORTDEBUGPARTNERSYNCTRANSITIONCOUNT:
        long_return = entry.dot3ad_agg_port_debug_partner_sync_transition_count;
        return (u_char *) & long_return;
      case DOT3ADAGGPORTDEBUGACTORCHANGECOUNT:
        long_return = entry.dot3ad_agg_port_debug_actor_change_count;
        return (u_char *) & long_return;
      case DOT3ADAGGPORTDEBUGPARTNERCHANGECOUNT:
        long_return = entry.dot3ad_agg_port_debug_partner_change_count;
        return (u_char *) & long_return;
    default:
        ERROR_MSG("");
    }
    return NULL;
}

/** Initializes the lagMIBObjects module */
void
init_lagMIBObjects(void)
{
    static oid      dot3adTablesLastChanged_oid[] =
        { 1, 2, 840, 10006, 300, 43, 1, 3, 0 };

    DEBUGMSGTL(("lagMIBObjects", "Initializing\n"));

    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("dot3adTablesLastChanged",
                                         get_dot3adTablesLastChanged,
                                         dot3adTablesLastChanged_oid,
                                         OID_LENGTH
                                         (dot3adTablesLastChanged_oid),
                                         HANDLER_CAN_RONLY));
}

int
get_dot3adTablesLastChanged(netsnmp_mib_handler *handler,
                            netsnmp_handler_registration *reginfo,
                            netsnmp_agent_request_info *reqinfo,
                            netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
           {

                LACP_MGR_LagMibObjects_T entry;


	        if (LACP_PMGR_GetDot3adLagMibObjects(&entry) != TRUE)
	           return SNMP_ERR_GENERR;

      	        long_return =  entry.dot3ad_tables_last_changed;
                snmp_set_var_typed_value(requests->requestvb, ASN_TIMETICKS, (u_char *)&long_return, sizeof(long_return));
            }
            break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
#endif
