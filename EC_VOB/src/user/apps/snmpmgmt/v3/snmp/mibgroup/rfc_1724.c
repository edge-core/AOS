/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.scalar.conf,v 1.5 2002/07/18 14:18:52 dts12 Exp $
 */

#include "sys_cpnt.h"

#if (SYS_CPNT_RIP == TRUE)

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "sysORTable.h"
#include "rfc_1724.h"
#include "sys_type.h"
#include "snmp_mgr.h"
#include "netcfg_type.h"
#include "netcfg_pmgr_rip.h"
#include "vlan_lib.h"
#include "rip_pmgr.h"
#include "ip_lib.h"
#include "netcfg_pom_ip.h"
#include "l_charset.h"

#define rip2IfStatEntry_INSTANCE_LEN 4
#define rip2IfStatEntry_OID_NAME_LEN 10
#define rip2IfConfEntry_INSTANCE_LEN 4
#define rip2IfConfEntry_OID_NAME_LEN 10
#define rip2PeerEntry_INSTANCE_LEN 6
#define rip2PeerEntry_OID_NAME_LEN 10
#define rip2GLOBALROUTECHANGES  0
#define rip2GLOBALQUERIES       0


#define VID_TO_VLANNAME(dev_name, vid)    sprintf(dev_name, "vlan%d",vid)

static BOOL_T ifindexToIfname(UI32_T ifindex,char *ifname);

static BOOL_T
rip2IfConfTable_get(int    compc,
                    oid    *compl,
                    Rip2IfConfEntry_T    *data);
static BOOL_T
rip2IfConfTable_next(int   compc,
                     oid   *compl,
                     Rip2IfConfEntry_T   *data);

static BOOL_T
rip2IfStatTable_get(int    compc,
                    oid    *compl,
                    Rip2IfStatEntry_T    *data);
static BOOL_T
rip2IfStatTable_next(int   compc,
                     oid   *compl,
                     Rip2IfStatEntry_T   *data);
static BOOL_T
rip2IfConfTable_get(int    compc,
                    oid    *compl,
                    Rip2IfConfEntry_T    *data);
static BOOL_T
rip2IfConfTable_next(int   compc,
                     oid   *compl,
                     Rip2IfConfEntry_T   *data);



static BOOL_T ifindexToIfname(UI32_T ifindex,char *ifname)
{
    UI32_T vid;
    if(VLAN_OM_ConvertFromIfindex(ifindex, &vid) != TRUE)
    {
        return FALSE;
    }
    VID_TO_VLANNAME(ifname, (int)vid);
    return TRUE ;
}

/*wei.zhang modify start*/
/** Initializes the rip2GlobalRouteChanges module */
void
init_rip2GlobalRouteChanges(void)
{
    static oid      rip2GlobalRouteChanges_oid[] =
        { 1, 3, 6, 1, 2, 1, 23, 1, 1, 0 };
    DEBUGMSGTL(("rip2GlobalRouteChanges", "Initializing\n"));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("rip2GlobalRouteChanges",
                                         get_rip2GlobalRouteChanges,
                                         rip2GlobalRouteChanges_oid,
                                         OID_LENGTH
                                         (rip2GlobalRouteChanges_oid),
                                         HANDLER_CAN_RONLY));
}

int
get_rip2GlobalRouteChanges(netsnmp_mib_handler *handler,
                           netsnmp_handler_registration *reginfo,
                           netsnmp_agent_request_info *reqinfo,
                           netsnmp_request_info *requests)
{
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one.
     */
    switch (reqinfo->mode) {

    case MODE_GET:
        {
            NETCFG_TYPE_RIP_Global_Statistics_T stat;
            if ( NETCFG_PMGR_RIP_GetGlobalStatistics(&stat) != TRUE)
            {
                long_return = rip2GLOBALROUTECHANGES;
            }
            else
            {
                long_return = stat.global_route_changes;
            }
            snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *)&long_return, sizeof(long_return));
            break;
        }
        break;
    default:
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

/** Initializes the rip2GlobalQueries module */
void
init_rip2GlobalQueries(void)
{
    static oid rip2GlobalQueries_oid[] =
        { 1, 3, 6, 1, 2, 1, 23, 1, 2, 0 };

    DEBUGMSGTL(("rip2GlobalQueries", "Initializing\n"));

    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("rip2GlobalQueries",
                                         get_rip2GlobalQueries,
                                         rip2GlobalQueries_oid,
                                         OID_LENGTH(rip2GlobalQueries_oid),
                                         HANDLER_CAN_RONLY));
}

int
get_rip2GlobalQueries(netsnmp_mib_handler *handler,
                      netsnmp_handler_registration *reginfo,
                      netsnmp_agent_request_info *reqinfo,
                      netsnmp_request_info *requests)
{
    switch (reqinfo->mode)
    {
        case MODE_GET:
        {
            NETCFG_TYPE_RIP_Global_Statistics_T stat;
            if (NETCFG_PMGR_RIP_GetGlobalStatistics(&stat) != TRUE)
            {
                long_return = rip2GLOBALQUERIES;
            }
            else
                long_return = stat.global_queries;
            snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *)&long_return, sizeof(long_return));
            break;
        }
            break;
        default:
            return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}

/*
 * rip2IfStatTable_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid rip2IfStatTable_variables_oid[] =
    { 1, 3, 6, 1, 2, 1, 23 };

/*
 * variable3 rip2IfStatTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */

struct variable3 rip2IfStatTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */

#define RIP2IFSTATADDRESS       1
    {RIP2IFSTATADDRESS, ASN_IPADDRESS, RONLY, var_rip2IfStatTable, 3,
    {2, 1, 1}},
#define RIP2IFSTATRCVBADPACKETS     2
    {RIP2IFSTATRCVBADPACKETS, ASN_COUNTER, RONLY, var_rip2IfStatTable, 3,
    {2, 1, 2}},
#define RIP2IFSTATRCVBADROUTES      3
    {RIP2IFSTATRCVBADROUTES, ASN_COUNTER, RONLY, var_rip2IfStatTable, 3,
    {2, 1, 3}},
#define RIP2IFSTATSENTUPDATES       4
    {RIP2IFSTATSENTUPDATES, ASN_COUNTER, RONLY, var_rip2IfStatTable, 3,
    {2, 1, 4}},
#define RIP2IFSTATSTATUS        5
    {RIP2IFSTATSTATUS, ASN_INTEGER, RWRITE, var_rip2IfStatTable, 3,
    {2, 1, 5}},
};
/*
 * (L = length of the oidsuffix)
 */

void
    /** Initializes the rip2IfStatTable module */
init_rip2IfStatTable(void)
{
    static oid      rip2StdMIB_module_oid[] =
        { 1, 3, 6, 1, 2, 1, 23 };

    DEBUGMSGTL(("rip2IfStatTable", "Initializing\n"));

    /*
     * register ourselves with the agent to handle our mib tree
     */
    REGISTER_MIB("rip2IfStatTable", rip2IfStatTable_variables, variable3,
        rip2IfStatTable_variables_oid);
    /*
     * place any other initialization junk you need here
     */
    REGISTER_SYSOR_ENTRY(rip2StdMIB_module_oid,
        "The MIB module to describe the RIP2 Version 2 Protocol.");
}
#define SYS_DFLT_VR_ID 0
#define SYS_DFLT_VRF_ID 0
static BOOL_T
rip2IfStatTable_get(int    compc,
                    oid    *compl,
                    Rip2IfStatEntry_T    *data)
{
    UI32_T   vr_id = SYS_DFLT_VR_ID;
    UI32_T   vrf_id = SYS_DFLT_VRF_ID;

    if (compc != rip2IfStatEntry_INSTANCE_LEN)
    {
        return FALSE;
    }
    data->rip2_if_stat_address = ((compl[0]<<24)|(compl[1]<<16)|(compl[2]<<8)|(compl[3]));

    if(RIP_PMGR_GetRip2IfStatTable(vr_id, vrf_id, data) != TRUE)
        return FALSE;

    return TRUE;
}

static BOOL_T
rip2IfStatTable_next(int   compc,
                     oid   *compl,
                     Rip2IfStatEntry_T   *data)
{
    UI32_T   vr_id = SYS_DFLT_VR_ID;
    UI32_T   vrf_id = SYS_DFLT_VRF_ID;

    data->rip2_if_stat_address = ((compl[0]<<24)|(compl[1]<<16)|(compl[2]<<8)|(compl[3]));


    if(RIP_PMGR_GetNextRip2IfStatTable(vr_id, vrf_id, data) != TRUE)
        return FALSE;

    return TRUE;
}

/*
 * var_rip2IfStatTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_rip2IfStatTable(struct variable *vp,
                    oid * name,
                    size_t * length,
                    int exact,
                    size_t * var_len, WriteMethod ** write_method)
{
    UI32_T compc = 0;
    oid compl[rip2IfStatEntry_INSTANCE_LEN];
    oid best_inst[rip2IfStatEntry_INSTANCE_LEN];
    Rip2IfStatEntry_T data;
    memset(&data,0,sizeof(Rip2IfStatEntry_T));
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl, rip2IfStatEntry_INSTANCE_LEN);
    /*check compc, retrive compl*/
    if (exact)/* get, set */
    {
        if (!rip2IfStatTable_get(compc, compl, &data))
            return NULL;
    }
    else/* getnext */
    {
        if (!rip2IfStatTable_next(compc, compl, &data))
        {
            return NULL;
        }
    }
    memcpy(name, vp->name, vp->namelen*sizeof(oid));
    SNMP_MGR_BindIpInstance(data.rip2_if_stat_address, 0, best_inst);
    memcpy(name + vp->namelen, best_inst, rip2IfStatEntry_INSTANCE_LEN*sizeof(oid));
    *length = vp->namelen + rip2IfStatEntry_INSTANCE_LEN;
    *var_len = sizeof(long_return);
    *write_method = 0;
   /*Since this table allow for entry that does not exist, (creation). we need to know the write method first*/
    switch (vp->magic) {
        case RIP2IFSTATSTATUS:
            *write_method = write_rip2IfStatStatus;
            break;
        default:
            *write_method = NULL;
            break;
    }
    /*
     * * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
        case RIP2IFSTATADDRESS:
            *var_len = sizeof(ipaddr_return);
            ipaddr_return = data.rip2_if_stat_address;
            return (u_char *) &ipaddr_return;
        case RIP2IFSTATRCVBADPACKETS:
            long_return = data.rip2_if_stat_rcv_bad_packets;
            return (u_char *) &long_return;
        case RIP2IFSTATRCVBADROUTES:
            long_return = data.rip2_if_stat_rcv_bad_routes;
            return (u_char *) &long_return;
        case RIP2IFSTATSENTUPDATES:
            long_return = data.rip2_if_stat_sent_updates;
            return (u_char *) &long_return;
        case RIP2IFSTATSTATUS:
            long_return = data.rip2_if_stat_status;
            return (u_char *) &long_return;
        default:
            break;
    }
    return NULL;
}

int
write_rip2IfStatStatus(int action,
                       u_char * var_val,
                       u_char var_val_type,
                       size_t var_val_len,
                       u_char * statP, oid * name, size_t name_len)
{
    long            value;
    Rip2IfStatEntry_T    rip2Entry;
    memset(&rip2Entry, 0, sizeof(rip2Entry));
    NETCFG_TYPE_InetRifConfig_T rif_config;

    SNMP_MGR_ReadIpFromCompl(name, rip2IfStatEntry_OID_NAME_LEN, &rip2Entry.rip2_if_stat_address);
    IP_LIB_UI32toArray(rip2Entry.rip2_if_stat_address, rif_config.addr.addr);
    if(NETCFG_POM_IP_GetRifConfig(&rif_config) != NETCFG_TYPE_OK)
    {
        return SNMP_ERR_COMMITFAILED;
    }

    switch (action) {
    case RESERVE1:
        if (name_len != rip2IfStatEntry_OID_NAME_LEN + rip2IfStatEntry_INSTANCE_LEN)
        {
            return SNMP_ERR_WRONGLENGTH;
        }
        if (var_val_type != ASN_INTEGER) {
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            return SNMP_ERR_WRONGLENGTH;
        }
        break;
    case RESERVE2:
        value = *(long *)var_val;
        switch(value)
        {
            case VAL_rip2IfStatStatus_active:

            case VAL_rip2IfStatStatus_notInService:
            case VAL_rip2IfStatStatus_notReady:
            case VAL_rip2IfStatStatus_createAndGo:
            case VAL_rip2IfStatStatus_createAndWait:
            case VAL_rip2IfStatStatus_destroy:

                break;
            default:
                return SNMP_ERR_WRONGVALUE;
                break;
        }
        break;
    case FREE:
        /*
         * Release any resources that have been allocated
         */
        break;
    case ACTION:
    {
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*lower layer not support*/



        break;
    }
    case UNDO:
        /*
         * Back out any changes made in the ACTION case
         */
        break;
    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

/*
 * rip2IfConfTable_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid             rip2IfConfTable_variables_oid[] =
    { 1, 3, 6, 1, 2, 1, 23 };

/*
 * variable3 rip2IfConfTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */

struct variable3 rip2IfConfTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */
#define RIP2IFCONFADDRESS       1
    {RIP2IFCONFADDRESS, ASN_IPADDRESS, RONLY, var_rip2IfConfTable, 3,
    {3, 1, 1}},
#define RIP2IFCONFDOMAIN        2
    {RIP2IFCONFDOMAIN, ASN_OCTET_STR, RWRITE, var_rip2IfConfTable, 3,
    {3, 1, 2}},
#define RIP2IFCONFAUTHTYPE      3
    {RIP2IFCONFAUTHTYPE, ASN_INTEGER, RWRITE, var_rip2IfConfTable, 3,
    {3, 1, 3}},
#define RIP2IFCONFAUTHKEY       4
    {RIP2IFCONFAUTHKEY, ASN_OCTET_STR, RWRITE, var_rip2IfConfTable, 3,
    {3, 1, 4}},
#define RIP2IFCONFSEND      5
    {RIP2IFCONFSEND, ASN_INTEGER, RWRITE, var_rip2IfConfTable, 3,
    {3, 1, 5}},
#define RIP2IFCONFRECEIVE       6
    {RIP2IFCONFRECEIVE, ASN_INTEGER, RWRITE, var_rip2IfConfTable, 3,
    {3, 1, 6}},
#define RIP2IFCONFDEFAULTMETRIC     7
    {RIP2IFCONFDEFAULTMETRIC, ASN_INTEGER, RWRITE, var_rip2IfConfTable, 3,
    {3, 1, 7}},
#define RIP2IFCONFSTATUS        8
    {RIP2IFCONFSTATUS, ASN_INTEGER, RWRITE, var_rip2IfConfTable, 3,
    {3, 1, 8}},
#define RIP2IFCONFSRCADDRESS        9
    {RIP2IFCONFSRCADDRESS, ASN_IPADDRESS, RWRITE, var_rip2IfConfTable, 3,
    {3, 1, 9}},
};
/*
 * (L = length of the oidsuffix)
 */
/** Initializes the rip2IfConfTable module */
void
init_rip2IfConfTable(void)
{

    DEBUGMSGTL(("rip2IfConfTable", "Initializing\n"));

    /*
     * register ourselves with the agent to handle our mib tree
     */
    REGISTER_MIB("rip2IfConfTable", rip2IfConfTable_variables, variable3,
                 rip2IfConfTable_variables_oid);

    /*
     * place any other initialization junk you need here
     */
}
static BOOL_T
rip2IfConfTable_get(int    compc,
                    oid    *compl,
                    Rip2IfConfEntry_T    *data)
{
    UI32_T   vr_id = SYS_DFLT_VR_ID;
    UI32_T   vrf_id = SYS_DFLT_VRF_ID;

    if (compc != rip2IfStatEntry_INSTANCE_LEN)
    {
        return FALSE;
    }
    data->rip2_if_conf_address = ((compl[0]<<24)|(compl[1]<<16)|(compl[2]<<8)|(compl[3]));

    if(RIP_PMGR_GetRip2IfConfTable(vr_id, vrf_id, data) != TRUE)
        return FALSE;

    return TRUE;
}

static BOOL_T
rip2IfConfTable_next(int   compc,
                     oid   *compl,
                     Rip2IfConfEntry_T   *data)
{
    UI32_T   vr_id = SYS_DFLT_VR_ID;
    UI32_T   vrf_id = SYS_DFLT_VRF_ID;

    data->rip2_if_conf_address = ((compl[0]<<24)|(compl[1]<<16)|(compl[2]<<8)|(compl[3]));


    if(RIP_PMGR_GetNextRip2IfConfTable(vr_id, vrf_id, data) != TRUE)
        return FALSE;

    return TRUE;
}
/*
 * var_rip2IfConfTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *
var_rip2IfConfTable(struct variable *vp,
                    oid * name,
                    size_t * length,
                    int exact,
                    size_t * var_len, WriteMethod ** write_method)
{
    UI32_T compc = 0;
    oid compl[rip2IfConfEntry_INSTANCE_LEN] = {0};
    oid best_inst[rip2IfConfEntry_INSTANCE_LEN] = {0};
    Rip2IfConfEntry_T data;
    memset(&data,0,sizeof(Rip2IfConfEntry_T));

    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl, rip2IfConfEntry_INSTANCE_LEN);

    switch (vp->magic)
    {
        case RIP2IFCONFDOMAIN:
            *write_method = write_rip2IfConfDomain;
            break;
        case RIP2IFCONFAUTHTYPE:
            *write_method = write_rip2IfConfAuthType;
            break;
        case RIP2IFCONFAUTHKEY:
            *write_method = write_rip2IfConfAuthKey;
            break;
        case RIP2IFCONFSEND:
            *write_method = write_rip2IfConfSend;
            break;
        case RIP2IFCONFRECEIVE:
            *write_method = write_rip2IfConfReceive;
            break;
        case RIP2IFCONFDEFAULTMETRIC:
            *write_method = write_rip2IfConfDefaultMetric;
            break;
        case RIP2IFCONFSTATUS:
            *write_method = write_rip2IfConfStatus;
            break;
        case RIP2IFCONFSRCADDRESS:
            *write_method = write_rip2IfConfSrcAddress;
            break;
        default:
            *write_method = 0;
            break;
    }
    /*
     * * this is where we do the value assignments for the mib results.
     */
    if (exact)/* get*/
    {
        if (!rip2IfConfTable_get(compc, compl, &data))
            return NULL;
    }
    else/* getnext */
    {
        if (!rip2IfConfTable_next(compc, compl, &data))
            return NULL;
    }
    memcpy(name, vp->name, vp->namelen*sizeof(oid));
    SNMP_MGR_BindIpInstance(data.rip2_if_conf_address, 0, best_inst);
    memcpy(name + vp->namelen, best_inst, rip2IfConfEntry_INSTANCE_LEN*sizeof(oid));
    *length = vp->namelen + rip2IfConfEntry_INSTANCE_LEN;
    *var_len = sizeof(long_return);


   /*Since this table allow for entry that does not exist, (creation). we need to know the write method first*/
    switch (vp->magic) {
        case RIP2IFCONFADDRESS:
            *var_len = sizeof(ipaddr_return);
            ipaddr_return = data.rip2_if_conf_address;
            return (u_char *) &ipaddr_return;
        case RIP2IFCONFDOMAIN:
            memcpy(return_buf, &data.rip2_if_conf_domain, sizeof(data.rip2_if_conf_domain));
            *var_len=sizeof(data.rip2_if_conf_domain);
            return (u_char*) return_buf;
        case RIP2IFCONFAUTHTYPE:
            long_return = data.rip2_if_conf_auth_type;
            return (u_char *) &long_return;
        case RIP2IFCONFAUTHKEY:
            memcpy(return_buf, &data.rip2_if_conf_auth_key, sizeof(data.rip2_if_conf_auth_key));
            *var_len=strlen(data.rip2_if_conf_auth_key);
            return (u_char*) return_buf;
        case RIP2IFCONFSEND:
            long_return = data.rip2_if_conf_send;
            return (u_char *) &long_return;
        case RIP2IFCONFRECEIVE:
            long_return = data.rip2_if_conf_receive;
            return (u_char *) &long_return;
        case RIP2IFCONFDEFAULTMETRIC:
            long_return = data.rip2_if_conf_default_metric;
            return (u_char *) &long_return;
        case RIP2IFCONFSTATUS:
            long_return = 1;
            return (u_char *) &long_return;
        case RIP2IFCONFSRCADDRESS:
            *var_len = sizeof(ipaddr_return);
            ipaddr_return = data.rip2_if_conf_src_address;
            return (u_char *) &ipaddr_return;
        default:
            break;
    }
    return NULL;
}

int
write_rip2IfConfDomain(int action,
                       u_char * var_val,
                       u_char var_val_type,
                       size_t var_val_len,
                       u_char * statP, oid * name, size_t name_len)
{
    return SNMP_ERR_COMMITFAILED;
}
int
write_rip2IfConfAuthType(int action,
                         u_char * var_val,
                         u_char var_val_type,
                         size_t var_val_len,
                         u_char * statP, oid * name, size_t name_len)
{
    long            value;
    UI32_T          type = 0;
    Rip2IfConfEntry_T    rip2Entry;
    NETCFG_TYPE_InetRifConfig_T rif_config;

    memset(&rip2Entry, 0, sizeof(rip2Entry));

    SNMP_MGR_ReadIpFromCompl(name, rip2IfConfEntry_OID_NAME_LEN, &rip2Entry.rip2_if_conf_address);
    memset(&rif_config, 0, sizeof(rif_config));
    rif_config.addr.type = L_INET_ADDR_TYPE_IPV4;
    IP_LIB_UI32toArray(rip2Entry.rip2_if_conf_address, rif_config.addr.addr);
    if(NETCFG_POM_IP_GetRifFromIp(&rif_config) != NETCFG_TYPE_OK)
    {
        return SNMP_ERR_COMMITFAILED;
    }

    switch (action) {
    case RESERVE1:
        if (name_len != rip2IfConfEntry_OID_NAME_LEN + rip2IfConfEntry_INSTANCE_LEN)
        {
            return SNMP_ERR_WRONGLENGTH;
        }
        if (var_val_type != ASN_INTEGER)
        {
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long))
        {
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        /* 2004/May/24 kelin added. not auto-generated */
        value = *(long *)var_val;
        switch(value)
        {
            case VAL_rip2IfConfAuthType_noAuthentication:
            case VAL_rip2IfConfAuthType_simplePassword:
            case VAL_rip2IfConfAuthType_md5:
                break;
            default:
                return SNMP_ERR_WRONGVALUE;
                break;
        }
        break;
    case FREE:
        /*
         * Release any resources that have been allocated
         */
        break;
    case ACTION:
    {
        value = *(long *)var_val;
        if(value == 1)
        {
            if (NETCFG_PMGR_RIP_AuthModeUnset(rif_config.ifindex) != NETCFG_TYPE_OK)
            {
                return SNMP_ERR_COMMITFAILED;
            }
        }
        else if(value == 2)
            type = 2;
        else if(value == 3)
            type = 3;


        if (NETCFG_PMGR_RIP_AuthModeSet(rif_config.ifindex,type) != NETCFG_TYPE_OK)
        {
            return SNMP_ERR_COMMITFAILED;
        }
    }
    break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_rip2IfConfAuthKey(int action,
                        u_char * var_val,
                        u_char var_val_type,
                        size_t var_val_len,
                        u_char * statP, oid * name, size_t name_len)
{
    int             size;
    Rip2IfConfEntry_T    rip2Entry;
    NETCFG_TYPE_InetRifConfig_T rif_config;

    memset(&rip2Entry, 0, sizeof(rip2Entry));
    SNMP_MGR_ReadIpFromCompl(name, rip2IfConfEntry_OID_NAME_LEN, &rip2Entry.rip2_if_conf_address);

    memset(&rif_config, 0, sizeof(rif_config));
    rif_config.addr.type = L_INET_ADDR_TYPE_IPV4;
    IP_LIB_UI32toArray(rip2Entry.rip2_if_conf_address, rif_config.addr.addr);
    if(NETCFG_POM_IP_GetRifFromIp(&rif_config) != NETCFG_TYPE_OK)
    {
        return SNMP_ERR_COMMITFAILED;
    }

    switch (action) {
    case RESERVE1:
        if (name_len != rip2IfConfEntry_OID_NAME_LEN + rip2IfConfEntry_INSTANCE_LEN)
        {
            return SNMP_ERR_WRONGLENGTH;
        }
        if (var_val_type != ASN_OCTET_STR) {
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > MAXSIZE_rip2IfConfAuthKey) {
            return SNMP_ERR_WRONGLENGTH;
        }
        break;
    case RESERVE2:
        size  = var_val_len;
        if (!((size >= MINSIZE_rip2IfConfAuthKey) &&
            (size <= MAXSIZE_rip2IfConfAuthKey)))
        {
            return SNMP_ERR_WRONGVALUE;
            break;
        }
        break;
    case FREE:
        /*
         * Release any resources that have been allocated
         */
        break;
    case ACTION:
    {
        char stringBuffer[MAXSIZE_rip2IfConfAuthKey + 1] = {0};
        if(var_val_len != 0)
        {
            strncpy(stringBuffer, (char *)var_val, var_val_len);
            stringBuffer[var_val_len] = 0;

            if (!L_CHARSET_IsValidGenericString(stringBuffer))
                return SNMP_ERR_COMMITFAILED;

            if (NETCFG_PMGR_RIP_AuthStringSet(rif_config.ifindex,stringBuffer) != NETCFG_TYPE_OK)
            {
                return SNMP_ERR_COMMITFAILED;
            }
        }
        else
        {

            if (NETCFG_PMGR_RIP_AuthStringUnset(rif_config.ifindex) != NETCFG_TYPE_OK)
            {
                return SNMP_ERR_COMMITFAILED;
            }
        }
    }
    break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_rip2IfConfSend(int action,
                     u_char * var_val,
                     u_char var_val_type,
                     size_t var_val_len,
                     u_char * statP, oid * name, size_t name_len)
{
    long            value;
    UI32_T          type;
    UI32_T          ip_address;
    NETCFG_TYPE_InetRifConfig_T rif_config;

    SNMP_MGR_ReadIpFromCompl(name, rip2IfConfEntry_OID_NAME_LEN, &ip_address);

    memset(&rif_config, 0, sizeof(rif_config));
    rif_config.addr.type = L_INET_ADDR_TYPE_IPV4;
    IP_LIB_UI32toArray(ip_address, rif_config.addr.addr);
    if(NETCFG_POM_IP_GetRifFromIp(&rif_config) != NETCFG_TYPE_OK)
    {
        return SNMP_ERR_COMMITFAILED;
    }

    switch (action) {
    case RESERVE1:
        if (name_len != rip2IfConfEntry_OID_NAME_LEN + rip2IfConfEntry_INSTANCE_LEN)
        {
            return SNMP_ERR_WRONGLENGTH;
        }
        if (var_val_type != ASN_INTEGER) {
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            return SNMP_ERR_WRONGLENGTH;
        }
        break;
    case RESERVE2:
        value = *(long *)var_val;
        switch(value)
        {
            case VAL_rip2IfConfSend_doNotSend:
            case VAL_rip2IfConfSend_ripVersion1:
            case VAL_rip2IfConfSend_rip1Compatible:
            case VAL_rip2IfConfSend_ripVersion2:
                break;
            case VAL_rip2IfConfSend_ripV1Demand:
            case VAL_rip2IfConfSend_ripV2Demand:
            default:
                return SNMP_ERR_WRONGVALUE;
                break;
        }
        break;
    case FREE:
        /*
         * Release any resources that have been allocated
         */
        break;
    case ACTION:
    {
        value = *(long *)var_val;
        if(value == 1 )
        {
            if (NETCFG_PMGR_RIP_SendPacketUnset(rif_config.ifindex) != NETCFG_TYPE_OK)
            {
                return SNMP_ERR_COMMITFAILED;
            }
        }
        else
        {
            if(value == 2 )
                type = 1;
            else if (value == 3)
                type = 4;
            else if(value == 4)
                type = 2;
            else
                return SNMP_ERR_WRONGVALUE;
            if (NETCFG_PMGR_RIP_SendPacketSet(rif_config.ifindex) == NETCFG_TYPE_OK)
            {
                if (NETCFG_PMGR_RIP_SendVersionTypeSet(rif_config.ifindex, type) != NETCFG_TYPE_OK)
                {
                    /*if(!entry.send_packet)
                    {
                        NETCFG_PMGR_RIP_SendPacketUnset(entry.ifindex);
                    }*/
                    return SNMP_ERR_COMMITFAILED;
                }
            }
            else
            {
                return SNMP_ERR_COMMITFAILED;
            }

        }
    }
    break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_rip2IfConfReceive(int action,
                        u_char * var_val,
                        u_char var_val_type,
                        size_t var_val_len,
                        u_char * statP, oid * name, size_t name_len)
{
    long            value;
    UI32_T          type;
    UI32_T          ip_address;
    NETCFG_TYPE_InetRifConfig_T rif_config;

    SNMP_MGR_ReadIpFromCompl(name, rip2IfConfEntry_OID_NAME_LEN, &ip_address);

    memset(&rif_config, 0, sizeof(rif_config));
    rif_config.addr.type = L_INET_ADDR_TYPE_IPV4;
    IP_LIB_UI32toArray(ip_address, rif_config.addr.addr);
    if(NETCFG_POM_IP_GetRifFromIp(&rif_config) != NETCFG_TYPE_OK)
    {
        return SNMP_ERR_COMMITFAILED;
    }

    switch (action) {
    case RESERVE1:
        if (name_len != rip2IfConfEntry_OID_NAME_LEN + rip2IfConfEntry_INSTANCE_LEN)
        {
            return SNMP_ERR_WRONGLENGTH;
        }
        if (var_val_type != ASN_INTEGER) {
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        value = *(long *)var_val;
        switch(value)
        {
            case VAL_rip2IfConfReceive_rip1:
            case VAL_rip2IfConfReceive_rip2:
            case VAL_rip2IfConfReceive_rip1OrRip2:
            case VAL_rip2IfConfReceive_doNotRecieve:
                break;
            default:
                return SNMP_ERR_WRONGVALUE;
                break;
        }
        break;
    case FREE:
        /*
         * Release any resources that have been allocated
         */
        break;
    case ACTION:
    {
        value = *(long *)var_val;

        if(value == 4 )
        {
            if (NETCFG_PMGR_RIP_RecvPacketUnset(rif_config.ifindex) != NETCFG_TYPE_OK)
            {
                return SNMP_ERR_COMMITFAILED;
            }
        }
        else
        {
            if(value == 1 )
                type = 1;
            else if (value == 2)
                type = 2;
            else if(value == 3)
                type = 3;
            else
                return SNMP_ERR_WRONGVALUE;
            //printf("%s,%d,ifindex:%d,type:%d\n",__FUNCTION__,__LINE__,entry.ifindex,type);

            if (NETCFG_PMGR_RIP_RecvPacketSet(rif_config.ifindex) == NETCFG_TYPE_OK)
            {
                if (NETCFG_PMGR_RIP_RecvVersionTypeSet(rif_config.ifindex, type) != NETCFG_TYPE_OK)
                {
                    /*if(!entry.recv_packet)
                    {
                        NETCFG_PMGR_RIP_RecvPacketUnset(entry.ifindex);
                    }*/
                    return SNMP_ERR_COMMITFAILED;
                }
            }
            else
            {
                return SNMP_ERR_COMMITFAILED;
            }
        }
    }
    break;
    case UNDO:
        /*
         * Back out any changes made in the ACTION case
         */
        break;
    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_rip2IfConfDefaultMetric(int action,
                              u_char * var_val,
                              u_char var_val_type,
                              size_t var_val_len,
                              u_char * statP, oid * name, size_t name_len)
{
    return SNMP_ERR_COMMITFAILED;
}

int
write_rip2IfConfStatus(int action,
                       u_char * var_val,
                       u_char var_val_type,
                       size_t var_val_len,
                       u_char * statP, oid * name, size_t name_len)
{
    long            value;
    UI32_T          ip_address;
    char            ifname[SYS_ADPT_MAX_VLAN_NAME_LEN+1] = {0};
    NETCFG_TYPE_InetRifConfig_T rif_config;

    SNMP_MGR_ReadIpFromCompl(name, rip2IfConfEntry_OID_NAME_LEN, &ip_address);

    memset(&rif_config, 0, sizeof(rif_config));
    rif_config.addr.type = L_INET_ADDR_TYPE_IPV4;
    IP_LIB_UI32toArray(ip_address, rif_config.addr.addr);
    if(NETCFG_POM_IP_GetRifFromIp(&rif_config) != NETCFG_TYPE_OK)
    {
        return SNMP_ERR_COMMITFAILED;
    }

    ifindexToIfname(rif_config.ifindex,ifname);

    switch (action) {
    case RESERVE1:
        if (name_len != rip2IfConfEntry_OID_NAME_LEN + rip2IfConfEntry_INSTANCE_LEN)
        {
            return SNMP_ERR_WRONGLENGTH;
        }
        if (var_val_type != ASN_INTEGER) {
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        /* 2004/May/24 kelin added. not auto-generated */
        value = *(long *)var_val;
        switch(value)
        {
            case VAL_rip2IfConfStatus_active:
            case VAL_rip2IfConfStatus_createAndGo:
            case VAL_rip2IfConfStatus_destroy:
                break;
            case VAL_rip2IfConfStatus_notInService:
            case VAL_rip2IfConfStatus_notReady:
            case VAL_rip2IfConfStatus_createAndWait:
            default:
                return SNMP_ERR_WRONGVALUE;
                break;
        }
        break;

    case FREE:
        /*
         * Release any resources that have been allocated
         */
        break;

    case ACTION:
        /*
          It is supportted in private MIB.
        */
    break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_rip2IfConfSrcAddress(int action,
                           u_char * var_val,
                           u_char var_val_type,
                           size_t var_val_len,
                           u_char * statP, oid * name, size_t name_len)
{
    long            value;
    UI32_T          ip_address;
    NETCFG_TYPE_InetRifConfig_T rif_config;

    SNMP_MGR_ReadIpFromCompl(name, rip2IfConfEntry_OID_NAME_LEN, &ip_address);

    memset(&rif_config,0, sizeof(rif_config));
    rif_config.addr.type = L_INET_ADDR_TYPE_IPV4;
    IP_LIB_UI32toArray(ip_address, rif_config.addr.addr);
    if(NETCFG_POM_IP_GetRifFromIp(&rif_config) != NETCFG_TYPE_OK)
    {
        return SNMP_ERR_COMMITFAILED;
    }

    switch (action) {
    case RESERVE1:
        if (name_len != rip2IfConfEntry_OID_NAME_LEN + rip2IfConfEntry_INSTANCE_LEN)
        {
            return SNMP_ERR_WRONGLENGTH;
        }
        if (var_val_type != ASN_IPADDRESS) {
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len != SYS_TYPE_IPV4_ADDR_LEN) {
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:

        break;

    case FREE:
        /*
         * Release any resources that have been allocated
         */
        break;

    case ACTION:
    {
        memcpy(&value, var_val, var_val_len);
        if(value != ip_address)
            return SNMP_ERR_COMMITFAILED;
    }
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case
         */
        break;
    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

/*
 * rip2PeerTable_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid             rip2PeerTable_variables_oid[] =
    { 1, 3, 6, 1, 2, 1, 23 };

/*
 * variable3 rip2PeerTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */

struct variable3 rip2PeerTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */

#define RIP2PEERADDRESS     1
    {RIP2PEERADDRESS, ASN_IPADDRESS, RONLY, var_rip2PeerTable, 3,
    {4, 1, 1}},
#define RIP2PEERDOMAIN      2
    {RIP2PEERDOMAIN, ASN_OCTET_STR, RONLY, var_rip2PeerTable, 3,
    {4, 1, 2}},
#define RIP2PEERLASTUPDATE      3
    {RIP2PEERLASTUPDATE, ASN_TIMETICKS, RONLY, var_rip2PeerTable, 3,
    {4, 1, 3}},
#define RIP2PEERVERSION     4
    {RIP2PEERVERSION, ASN_INTEGER, RONLY, var_rip2PeerTable, 3, {4, 1, 4}},
#define RIP2PEERRCVBADPACKETS       5
    {RIP2PEERRCVBADPACKETS, ASN_COUNTER, RONLY, var_rip2PeerTable, 3,
    {4, 1, 5}},
#define RIP2PEERRCVBADROUTES        6
    {RIP2PEERRCVBADROUTES, ASN_COUNTER, RONLY, var_rip2PeerTable, 3,
    {4, 1, 6}},
};
/*
 * (L = length of the oidsuffix)
 */


/** Initializes the rip2PeerTable module */
void
init_rip2PeerTable(void)
{

    DEBUGMSGTL(("rip2PeerTable", "Initializing\n"));

    /*
     * register ourselves with the agent to handle our mib tree
     */
    REGISTER_MIB("rip2PeerTable", rip2PeerTable_variables, variable3,
                 rip2PeerTable_variables_oid);

    /*
     * place any other initialization junk you need here
     */
}
static BOOL_T
rip2PeerTable_get(int    compc,
                  oid    *compl,
                  Rip2PeerEntry_T    *data)
{
    if (compc != rip2PeerEntry_INSTANCE_LEN)
    {
        return FALSE;
    }
    NETCFG_TYPE_RIP_Peer_Entry_T entry;
    memset(&entry, 0, sizeof(NETCFG_TYPE_RIP_Peer_Entry_T));

    SNMP_MGR_ReadIpFromCompl(compl, 0, &data->rip2_peer_address);
    data->rip2_peer_domain[0] = compl[4];
    data->rip2_peer_domain[1] = compl[5];
    entry.peer_addr = data->rip2_peer_address;
    if (NETCFG_PMGR_RIP_GetPeerEntry(&entry) != TRUE)
    {
        return FALSE;
    }
    else
    {
        data->rip2_peer_address = entry.peer_addr;
        data->rip2_peer_rcv_bad_packets = entry.recv_badpackets;
        data->rip2_peer_rcv_bad_routes = entry.recv_badroutes;
        data->rip2_peer_version = entry.version;
        data->rip2_peer_last_update = entry.uptime;
        return TRUE;
    } /*End of if */
}

/* 2004/May/24 kelin added. not auto-generated */
static BOOL_T
rip2PeerTable_next(int   compc,
                   oid   *compl,
                   Rip2PeerEntry_T   *data)
{
    oid tmp_compl[rip2PeerEntry_INSTANCE_LEN];
    NETCFG_TYPE_RIP_Peer_Entry_T entry;

    memset(&entry, 0, sizeof(NETCFG_TYPE_RIP_Peer_Entry_T));
    /* Generate the instance of each table entry and find the
     * smallest instance that's larger than compc/compl.
     *
     * Step 1: Verify and extract the input key from "compc" and "compl"
     * Note: The number of input key is defined by "compc".
     *       The key for the specified instance is defined in compl.
     */
    memcpy(tmp_compl, compl, sizeof(tmp_compl));
    SNMP_MGR_checkCompl(0, 3, tmp_compl, 255);
    SNMP_MGR_ConvertRemainToZero(compc, rip2PeerEntry_INSTANCE_LEN, tmp_compl);
    SNMP_MGR_ReadIpFromCompl(compl, 0, &data->rip2_peer_address);
    data->rip2_peer_domain[0] = tmp_compl[4];
    data->rip2_peer_domain[1] = tmp_compl[5];
    entry.peer_addr = data->rip2_peer_address;

    if (NETCFG_PMGR_RIP_GetNextPeerEntry(&entry) != TRUE)
    {
        return FALSE;
    }

    data->rip2_peer_address = entry.peer_addr;
    data->rip2_peer_rcv_bad_packets = entry.recv_badpackets;
    data->rip2_peer_rcv_bad_routes = entry.recv_badroutes;
    data->rip2_peer_version = entry.version;
    data->rip2_peer_last_update = entry.uptime;

    return TRUE;
}

/*
 * var_rip2PeerTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_rip2PeerTable(struct variable *vp,
                  oid * name,
                  size_t * length,
                  int exact, size_t * var_len, WriteMethod ** write_method)
{
    UI32_T compc = 0;
    oid compl[rip2PeerEntry_INSTANCE_LEN];
    oid best_inst[rip2PeerEntry_INSTANCE_LEN];
    Rip2PeerEntry_T data;
    memset(&data,0,sizeof(Rip2PeerEntry_T));
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl, rip2PeerEntry_INSTANCE_LEN);
    /*check compc, retrive compl*/
    if (exact)/* get, set */
    {
        if (!rip2PeerTable_get(compc, compl, &data))
            return NULL;
    }
    else/* getnext */
    {
        if (!rip2PeerTable_next(compc, compl, &data))
        {
            return NULL;
        }
    }
    memcpy(name, vp->name, vp->namelen*sizeof(oid));
    SNMP_MGR_BindIpInstance(data.rip2_peer_address, 0, best_inst);
    best_inst[4] = data.rip2_peer_domain[0];
    best_inst[5] = data.rip2_peer_domain[1];
    memcpy(name + vp->namelen, best_inst, rip2PeerEntry_INSTANCE_LEN*sizeof(oid));
    *length = vp->namelen + rip2PeerEntry_INSTANCE_LEN;

    *var_len = sizeof(long_return);

    /*
     * * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
        case RIP2PEERADDRESS:
            *var_len = sizeof(ipaddr_return);
            ipaddr_return = data.rip2_peer_address;
            return (u_char *) &ipaddr_return;
        case RIP2PEERDOMAIN:
            memcpy(return_buf, &data.rip2_peer_domain, sizeof(data.rip2_peer_domain));
            *var_len=sizeof(data.rip2_peer_domain);
            return (u_char*) return_buf;
        case RIP2PEERLASTUPDATE:
            long_return = data.rip2_peer_last_update;
            return (u_char *) &long_return;
        case RIP2PEERVERSION:
            long_return = data.rip2_peer_version;
            return (u_char *) &long_return;
        case RIP2PEERRCVBADPACKETS:
            long_return = data.rip2_peer_rcv_bad_packets;
            return (u_char *) &long_return;
        case RIP2PEERRCVBADROUTES:
            long_return = data.rip2_peer_rcv_bad_routes;
            return (u_char *) &long_return;
        default:
            break;
    }
    return NULL;
}

#endif
