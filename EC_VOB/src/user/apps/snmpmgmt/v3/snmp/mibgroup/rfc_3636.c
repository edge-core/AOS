/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.old-api.conf,v 1.3 2002/10/17 09:40:46 dts12 Exp $
 */
#include "sys_cpnt.h"
#if (SYS_CPNT_MAU_MIB == TRUE)
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "rfc_3636.h"
#include "leaf_3636.h"
#include "swctrl.h"
#include "swctrl_pom.h"
#include "swctrl_pmgr.h"
#include "sysORTable.h"
#include "snmp_mgr.h"

/*
 * ifMauTable_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid             ifMauTable_variables_oid[] =
    { 1, 3, 6, 1, 2, 1, 26, 2};

 oid             mau_mib_module_oid[] = { SNMP_OID_MIB2, 26  };

/*
 * variable4 ifMauTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */

struct variable3 ifMauTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */

#define IFMAUIFINDEX		1
    {IFMAUIFINDEX, ASN_INTEGER, RONLY, var_ifMauTable, 3, {1, 1, 1}},
#define IFMAUINDEX		2
    {IFMAUINDEX, ASN_INTEGER, RONLY, var_ifMauTable, 3, {1, 1, 2}},
#define IFMAUTYPE		3
    {IFMAUTYPE, ASN_OBJECT_ID, RONLY, var_ifMauTable, 3, {1, 1, 3}},
#define IFMAUSTATUS		4
    {IFMAUSTATUS, ASN_INTEGER, RWRITE, var_ifMauTable, 3, {1, 1, 4}},
#define IFMAUMEDIAAVAILABLE		5
    {IFMAUMEDIAAVAILABLE, ASN_INTEGER, RONLY, var_ifMauTable, 3,
     {1, 1, 5}},
#define IFMAUMEDIAAVAILABLESTATEEXITS		6
    {IFMAUMEDIAAVAILABLESTATEEXITS, ASN_COUNTER, RONLY, var_ifMauTable, 3,
     {1, 1, 6}},
#define IFMAUJABBERSTATE		7
    {IFMAUJABBERSTATE, ASN_INTEGER, RONLY, var_ifMauTable, 3, {1, 1, 7}},
#define IFMAUJABBERINGSTATEENTERS		8
    {IFMAUJABBERINGSTATEENTERS, ASN_COUNTER, RONLY, var_ifMauTable, 3,
     {1, 1, 8}},
#define IFMAUFALSECARRIERS		9
    {IFMAUFALSECARRIERS, ASN_COUNTER, RONLY, var_ifMauTable, 3, {1, 1, 9}},
 #if 0 /*THIS OBJECT IS DEPRECATED */
#define IFMAUTYPELIST		10
    {IFMAUTYPELIST, ASN_INTEGER, RONLY, var_ifMauTable, 3, {1, 1, 10}},
#endif
#define IFMAUDEFAULTTYPE		11
    {IFMAUDEFAULTTYPE, ASN_OBJECT_ID, RWRITE, var_ifMauTable, 3,
     {1, 1, 11}},
#define IFMAUAUTONEGSUPPORTED		12
    {IFMAUAUTONEGSUPPORTED, ASN_INTEGER, RONLY, var_ifMauTable, 3,
     {1, 1, 12}},

#define IFMAUTYPELISTBITS		13
    {IFMAUTYPELISTBITS,ASN_OCTET_STR, RONLY, var_ifMauTable, 3, {1, 1, 13}},

#define IFMAUHCFALSECARRIERS		14
    {IFMAUHCFALSECARRIERS, ASN_COUNTER64, RONLY, var_ifMauTable, 3,
     {1, 1, 14}},
};
/*
 * (L = length of the oidsuffix)
 */


/** Initializes the ifMauTable module */
void
init_ifMauTable(void)
{

    DEBUGMSGTL(("ifMauTable", "Initializing\n"));

    /*
     * register ourselves with the agent to handle our mib tree
     */
    REGISTER_MIB("ifMauTable", ifMauTable_variables, variable3,
                 ifMauTable_variables_oid);

    /*
     * place any other initialization junk you need here
     */
     REGISTER_SYSOR_ENTRY(mau_mib_module_oid,
                         "The Rfc 3636 MAU MIB.");

}

#define IFMAUTABLE_INSTANCE_LEN  2

BOOL_T ifMauTable_oid_index_to_data(UI32_T exact, UI32_T compc,
            oid * compl , SWCTRL_IfMauEntry_T *entry)
{

    /* get or write
     */
    if(exact)
    {

        /* check the index length
         */
        if(compc != IFMAUTABLE_INSTANCE_LEN) /* the constant size index*/
        {
            return FALSE;
        }
    }

    /* assign the index to data
     */
    entry->ifMauIfIndex=compl[0];
    entry->ifMauIndex=compl[1];

    return TRUE;
}

/*
 * var_ifMauTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_ifMauTable(struct variable *vp,
               oid * name,
               size_t * length,
               int exact, size_t * var_len, WriteMethod ** write_method)
{
    /* variables we may use later */
    UI32_T compc=0;
    oid compl[IFMAUTABLE_INSTANCE_LEN];
    oid best_inst[IFMAUTABLE_INSTANCE_LEN];
    SWCTRL_IfMauEntry_T  entry;

   /*Since this table allow for entry that does not exist, (creation). we need to know the write method first*/
    switch(vp->magic)
     {
     case IFMAUSTATUS:
        *write_method = write_ifMauStatus;
     break;
     case IFMAUDEFAULTTYPE:
        *write_method = write_ifMauDefaultType;
     break;
    }

    /*check compc, retrive compl*/
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,compl, IFMAUTABLE_INSTANCE_LEN);

    memset(&entry, 0, sizeof(entry));

    if (exact)/*get,set*/
    {

        if(ifMauTable_oid_index_to_data(exact,compc,compl,&entry)==FALSE)
        {
            return NULL;
        }

        /*get data
         */
        if (SWCTRL_PMGR_GetIfMauEntry( &entry)!=TRUE)
        {
            return NULL;
        }
    }
    else/*getnext*/
    {

        ifMauTable_oid_index_to_data(exact,compc,compl,&entry);

        /* check the length of inputing index,if <1 we should try get {0.0.0.0.0...}
         */
        if (compc< IFMAUTABLE_INSTANCE_LEN)
        {

            if ( SWCTRL_PMGR_GetIfMauEntry(&entry)!=TRUE)
            {

                /*get next data*/
                if ( SWCTRL_PMGR_GetNextIfMauEntry(&entry)!=TRUE)
                {
                    return NULL;
                }
            }
        }
        else
        {

            /*get next data*/
            if ( SWCTRL_PMGR_GetNextIfMauEntry(&entry)!=TRUE)
            {
                return NULL;
            }
        }
    }

    memcpy(name, vp->name, vp->namelen*sizeof(oid));
    /* assign data to the oid index
     */

    best_inst[0] = entry.ifMauIfIndex;
    best_inst[1] = entry.ifMauIndex;
    memcpy(name + vp->namelen, best_inst, IFMAUTABLE_INSTANCE_LEN*sizeof(oid));
    *length = vp->namelen +IFMAUTABLE_INSTANCE_LEN;
    *var_len = sizeof(long_return);

    /*
     * * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
      case IFMAUIFINDEX:
        long_return = entry.ifMauIfIndex;
        return (u_char*) &long_return;
      case IFMAUINDEX:
        long_return = entry.ifMauIndex;
        return (u_char*) &long_return;
      case IFMAUTYPE:
       {
       	oid if_mau_type[9]={1,3,6,1,2,1,26,4,0};

        *var_len = 9* sizeof(oid);
        if_mau_type[8] = entry.ifMauType;
        memcpy( oid_return, if_mau_type, *var_len);
        }
        return (u_char*) oid_return;
      case IFMAUSTATUS:
        long_return = entry.ifMauStatus;
        return (u_char*) &long_return;
      case IFMAUMEDIAAVAILABLE:
        long_return = entry.ifMauMediaAvailable;
        return (u_char*) &long_return;
      case IFMAUMEDIAAVAILABLESTATEEXITS:
        long_return = entry.ifMauMediaAvailableStateExits;
        return (u_char*) &long_return;
      case IFMAUJABBERSTATE:
        long_return = entry.ifMauJabberState;
        return (u_char*) &long_return;
      case IFMAUJABBERINGSTATEENTERS:
        long_return = entry.ifMauJabberingStateEnters;
        return (u_char*) &long_return;
      case IFMAUFALSECARRIERS:
        long_return = entry.ifMauFalseCarriers;
        return (u_char*) &long_return;
#if 0 /*THIS OBJECT IS DEPRECATED */
      case IFMAUTYPELIST:
        /* not supprted*/
        long_return = 0;
        return (u_char*) &long_return;
 #endif
      case IFMAUDEFAULTTYPE:
      {
          oid if_mau_default_type[9]={1,3,6,1,2,1,26,4,0};

          *var_len = 9* sizeof(oid);
          if_mau_default_type[8] = entry.ifMauDefaultType;
          memcpy( oid_return, if_mau_default_type, *var_len);
      }
        return (u_char*) oid_return;
      case IFMAUAUTONEGSUPPORTED:
        long_return = entry.ifMauAutoNegSupported;
        return (u_char*) &long_return;
      case IFMAUTYPELISTBITS:
        memcpy(return_buf, &entry.ifMauTypeListBits, 6);
        *var_len = 6;
        return (u_char*) return_buf;
      case IFMAUHCFALSECARRIERS:
        *var_len = sizeof(long64_return);
        memset(&long64_return,0,8);
        return (u_char*) &long64_return;
    default:
        ERROR_MSG("");
    }
    return NULL;
}


int
write_ifMauStatus(int action,
                  u_char * var_val,
                  u_char var_val_type,
                  size_t var_val_len,
                  u_char * statP, oid * name, size_t name_len)
{
    UI32_T  ifMauStatus;

    if ((char) name[10] != IFMAUSTATUS)
     {
        return SNMP_ERR_NOTWRITABLE;
    }
    if (name_len!=  13)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    ifMauStatus = *(long *)var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }

            if ((ifMauStatus <VAL_ifMauStatus_other) ||(ifMauStatus >VAL_ifMauStatus_reset))
          {
            return SNMP_ERR_WRONGVALUE;
          }
        break;


        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:

            if (SWCTRL_PMGR_SetIfMauStatus(name[11], name[12], ifMauStatus) != TRUE)
                return SNMP_ERR_COMMITFAILED;
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_ifMauDefaultType(int action,
                       u_char * var_val,
                       u_char var_val_type,
                       size_t var_val_len,
                       u_char * statP, oid * name, size_t name_len)
{

    UI32_T  oid[9]={0};

    if ((char) name[10] != IFMAUDEFAULTTYPE)
     {
        return SNMP_ERR_NOTWRITABLE;
    }
    if (name_len!=  13)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch ( action )
    {

        case RESERVE1:
          if (var_val_type != ASN_OBJECT_ID) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len != sizeof(oid)*9) {
              return SNMP_ERR_WRONGLENGTH;
          }

          memcpy(oid, var_val, var_val_len);

          if ((oid[0]!= 1) || (oid[1]!=3) || (oid[2]!=6) || (oid[3]!=1) || (oid[4] !=2)
             || (oid[5] !=1) || (oid[6] != 26) || (oid[7]!=4) || (oid[8] >= 32))
          {
            //snmp_log(LOG_ERR, "not supported admin state\n");
            return SNMP_ERR_WRONGVALUE;
          }
        break;


        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:

            if (SWCTRL_PMGR_SetIfMauDefaultType(name[11], name[12], oid[8]) != TRUE)
                return SNMP_ERR_COMMITFAILED;
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

static int
header_ifJackTable(struct variable *vp,
               oid * name,
               size_t * length,
               int exact, size_t * var_len, WriteMethod ** write_method,
               UI32_T *index1, UI32_T *index2, UI32_T *index3);

/*
 * ifJackTable_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid             ifJackTable_variables_oid[] =
    { 1, 3, 6, 1, 2, 1, 26, 2 };

/*
 * variable4 ifJackTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */

struct variable3 ifJackTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */


#define IFJACKTYPE		2
    {IFJACKTYPE, ASN_INTEGER, RONLY, var_ifJackTable, 3, {2, 1, 2}},
};
/*
 * (L = length of the oidsuffix)
 */


/** Initializes the ifJackTable module */
void
init_ifJackTable(void)
{

    DEBUGMSGTL(("ifJackTable", "Initializing\n"));

    /*
     * register ourselves with the agent to handle our mib tree
     */
    REGISTER_MIB("ifJackTable", ifJackTable_variables, variable3,
                 ifJackTable_variables_oid);

    /*
     * place any other initialization junk you need here
     */
}

static int
header_ifJackTable(struct variable *vp,
               oid * name,
               size_t * length,
               int exact, size_t * var_len, WriteMethod ** write_method,
               UI32_T *index1, UI32_T *index2, UI32_T *index3)
{
#define OID_NAME_LENGTH	11
    oid             newname[MAX_OID_LEN];
    int             result;
   SWCTRL_IfJackEntry_T  entry;
   BOOL_T return_val;
   oid  next_inst[3];


     memcpy((char *) newname, (char *) vp->name,
           (int) vp->namelen * sizeof(oid));
    /*
     * find "next" interface
     */
    memset(  &entry, 0 , sizeof(entry));

    /*
     * find "next" interface
     */

  while (  (return_val= SWCTRL_PMGR_GetNextIfJackEntry( &entry))==TRUE)
     {
       next_inst[0] = entry.ifMauIfIndex;
       next_inst[1] = entry.ifMauIndex;
       next_inst[2] = entry.ifJackIndex;

        memcpy( (char*)&newname[OID_NAME_LENGTH], (char*) next_inst,  3*sizeof(oid));
        result =
            snmp_oid_compare(name, *length, newname,
                             (int) vp->namelen +3);
        if ((exact && (result == 0)) || (!exact && (result < 0)))
            break;
    }
    if (!return_val ) {
        DEBUGMSGTL(("mau MIB", "... index out of range\n"));
        return MATCH_FAILED;
    }
    memcpy((char *) name, (char *) newname,
           ((int) vp->namelen + 3) * sizeof(oid));
    *length = vp->namelen + 3;
    *var_len = sizeof(long);    /* default to 'long' results */
    *index1 = next_inst[0];
    *index2 = next_inst[1];
    *index3 = next_inst[2];
    return TRUE;

}


/*
 * var_ifJackTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_ifJackTable(struct variable *vp,
                oid * name,
                size_t * length,
                int exact, size_t * var_len, WriteMethod ** write_method)
{
    /* variables we may use later */

    UI32_T index1 = 0, index2 = 0, index3 = 0,retval;

    SWCTRL_IfJackEntry_T  entry;



    memset( &entry, 0, sizeof(entry));

     retval  = header_ifJackTable(vp, name, length, exact, var_len, write_method,  &index1,& index2, &index3);

    if (retval == MATCH_FAILED)
        return NULL;


  entry.ifMauIfIndex= index1;
  entry.ifMauIndex = index2;
  entry.ifJackIndex= index3;

   if (SWCTRL_PMGR_GetIfJackEntry(&entry)!= TRUE)
            return NULL;

    /*
     * * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {

      case IFJACKTYPE:
        long_return = entry.ifJackType;
        return (u_char*) &long_return;
    default:
        ERROR_MSG("");
    }
    return NULL;
}

/*
 * ifMauAutoNegTable_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid             ifMauAutoNegTable_variables_oid[] =
    { 1, 3, 6, 1, 2, 1, 26, 5 };

/*
 * variable4 ifMauAutoNegTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */

struct variable3 ifMauAutoNegTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */

#define IFMAUAUTONEGADMINSTATUS		1
    {IFMAUAUTONEGADMINSTATUS, ASN_INTEGER, RWRITE, var_ifMauAutoNegTable,
     3, {1, 1, 1}},
#define IFMAUAUTONEGREMOTESIGNALING		2
    {IFMAUAUTONEGREMOTESIGNALING, ASN_INTEGER, RONLY,
     var_ifMauAutoNegTable, 3, {1, 1, 2}},
#define IFMAUAUTONEGCONFIG		4
    {IFMAUAUTONEGCONFIG, ASN_INTEGER, RONLY, var_ifMauAutoNegTable, 3,
     {1, 1, 4}},
 #if 0 /*THIS OBJECT IS DEPRECATED */
#define IFMAUAUTONEGCAPABILITY		5
    {IFMAUAUTONEGCAPABILITY, ASN_INTEGER, RONLY, var_ifMauAutoNegTable, 3,
     {1, 1, 5}},
#define IFMAUAUTONEGCAPADVERTISED		6
    {IFMAUAUTONEGCAPADVERTISED, ASN_INTEGER, RWRITE, var_ifMauAutoNegTable,
     3, {1, 1, 6}},
#define IFMAUAUTONEGCAPRECEIVED		7
    {IFMAUAUTONEGCAPRECEIVED, ASN_INTEGER, RONLY, var_ifMauAutoNegTable, 3,
     {1, 1, 7}},
#endif
#define IFMAUAUTONEGRESTART		8
    {IFMAUAUTONEGRESTART, ASN_INTEGER, RWRITE, var_ifMauAutoNegTable, 3,
     {1, 1, 8}},
#define IFMAUAUTONEGCAPABILITYBITS		9
    {IFMAUAUTONEGCAPABILITYBITS,ASN_OCTET_STR, RONLY, var_ifMauAutoNegTable, 3,
     {1, 1, 9}},
#define IFMAUAUTONEGCAPADVERTISEDBITS		10
    {IFMAUAUTONEGCAPADVERTISEDBITS,ASN_OCTET_STR, RWRITE, var_ifMauAutoNegTable, 3,
     {1, 1, 10}},
#define IFMAUAUTONEGCAPRECEIVEDBITS		11
    {IFMAUAUTONEGCAPRECEIVEDBITS,ASN_OCTET_STR, RONLY, var_ifMauAutoNegTable, 3,
     {1, 1, 11}},
#define IFMAUAUTONEGREMOTEFAULTADVERTISED		12
    {IFMAUAUTONEGREMOTEFAULTADVERTISED, ASN_INTEGER, RWRITE,
     var_ifMauAutoNegTable, 3, {1, 1, 12}},
#define IFMAUAUTONEGREMOTEFAULTRECEIVED		13
    {IFMAUAUTONEGREMOTEFAULTRECEIVED, ASN_INTEGER, RONLY,
     var_ifMauAutoNegTable, 3, {1, 1, 13}},
};
/*
 * (L = length of the oidsuffix)
 */


/** Initializes the ifMauAutoNegTable module */
void
init_ifMauAutoNegTable(void)
{

    DEBUGMSGTL(("ifMauAutoNegTable", "Initializing\n"));

    /*
     * register ourselves with the agent to handle our mib tree
     */
    REGISTER_MIB("ifMauAutoNegTable", ifMauAutoNegTable_variables,
                 variable3, ifMauAutoNegTable_variables_oid);

    /*
     * place any other initialization junk you need here
     */
}

#define IFMAUAUTONEGTABLE_INSTANCE_LEN  2

BOOL_T ifMauAutoNegTable_oid_index_to_data(UI32_T exact, UI32_T compc,
            oid * compl , UI32_T *index1, UI32_T *index2)
{

    /* get or write     */
    if(exact)
    {

        /* check the index length   */
        if(compc != IFMAUAUTONEGTABLE_INSTANCE_LEN) /* the constant size index*/
        {
            return FALSE;
        }
    }

    /* assign the index to data    */
    if(compc == IFMAUAUTONEGTABLE_INSTANCE_LEN)
    {
    	*index1=compl[0];
    	*index2=compl[1];
    }
	else
	{
		*index1 = 0;
    	*index2 = 0;
	}

    return TRUE;
}

/*
 * var_ifMauAutoNegTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_ifMauAutoNegTable(struct variable *vp,
                      oid * name,
                      size_t * length,
                      int exact,
                      size_t * var_len, WriteMethod ** write_method)
{
    /* variables we may use later */
    UI32_T compc=0;
    oid compl[IFMAUAUTONEGTABLE_INSTANCE_LEN];
    oid best_inst[IFMAUAUTONEGTABLE_INSTANCE_LEN];
    SWCTRL_IfMauAutoNegEntry_T  entry;

    /*check compc, retrive compl*/
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,compl, IFMAUAUTONEGTABLE_INSTANCE_LEN);

    memset(&entry, 0, sizeof(entry));

    if (exact)/*get,set*/
    {

        if(ifMauAutoNegTable_oid_index_to_data(exact,compc,compl,&entry.ifMauIfIndex,&entry.ifMauIndex)==FALSE)
        {
            return NULL;
        }

        /*get data
         */
        if (SWCTRL_PMGR_GetIfMauAutoNegEntry( &entry)!=TRUE)
        {
            return NULL;
        }
    }
    else/*getnext*/
    {

        ifMauAutoNegTable_oid_index_to_data(exact,compc,compl,&entry.ifMauIfIndex,&entry.ifMauIndex);

        /* check the length of inputing index,if <1 we should try get {0.0.0.0.0...}
         */
        if (compc< IFMAUAUTONEGTABLE_INSTANCE_LEN)
        {

            if ( SWCTRL_PMGR_GetIfMauAutoNegEntry(&entry)!=TRUE)
            {

                /*get next data*/
                if ( SWCTRL_PMGR_GetNextIfMauAutoNegEntry(&entry)!=TRUE)
                {
                    return NULL;
                }
            }
        }
        else
        {

            /*get next data*/
            if ( SWCTRL_PMGR_GetNextIfMauAutoNegEntry(&entry)!=TRUE)
            {
                return NULL;
            }
        }
    }

    memcpy(name, vp->name, vp->namelen*sizeof(oid));
    /* assign data to the oid index
     */

    best_inst[0] =entry.ifMauIfIndex;
    best_inst[1] =entry.ifMauIndex;
    memcpy(name + vp->namelen, best_inst, IFMAUAUTONEGTABLE_INSTANCE_LEN*sizeof(oid));
    *length = vp->namelen +IFMAUAUTONEGTABLE_INSTANCE_LEN;
    *var_len = sizeof(long_return);

    /*
     * * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
      case IFMAUAUTONEGADMINSTATUS:
        *write_method = write_ifMauAutoNegAdminStatus;
        long_return = entry.ifMauAutoNegAdminStatus;
        return (u_char*) &long_return;
      case IFMAUAUTONEGREMOTESIGNALING:
        long_return = entry.ifMauAutoNegRemoteSignaling;
        return (u_char*) &long_return;
      case IFMAUAUTONEGCONFIG:
        long_return = entry.ifMauAutoNegConfig;
        return (u_char*) &long_return;
 #if 0 /*THIS OBJECT IS DEPRECATED */
      case IFMAUAUTONEGCAPABILITY:
        long_return = 0;
        return (u_char*) &long_return;
      case IFMAUAUTONEGCAPADVERTISED:
        *write_method = write_ifMauAutoNegCapAdvertised;
        long_return = 0;
        return (u_char*) &long_return;
      case IFMAUAUTONEGCAPRECEIVED:
        long_return = 0;
        return (u_char*) &long_return;
  #endif
      case IFMAUAUTONEGRESTART:
        *write_method = write_ifMauAutoNegRestart;
        long_return = entry.ifMauAutoNegRestart;
        return (u_char*) &long_return;
      case IFMAUAUTONEGCAPABILITYBITS:
        long_return = L_STDLIB_Hton32(entry.ifMauAutoNegCapabilityBits);
        *var_len = sizeof(long_return);
        return (u_char*) &long_return;
      case IFMAUAUTONEGCAPADVERTISEDBITS:
        *write_method = write_ifMauAutoNegCapAdvertisedBits;
         long_return = L_STDLIB_Hton32(entry.ifMauAutoNegCapAdvertisedBits);
        *var_len = sizeof(long_return);
        return (u_char*) &long_return;
      case IFMAUAUTONEGCAPRECEIVEDBITS:
         long_return = L_STDLIB_Hton32(entry.ifMauAutoNegCapReceivedBits);
        *var_len = sizeof(long_return);
        return (u_char*) &long_return;
      case IFMAUAUTONEGREMOTEFAULTADVERTISED:
        *write_method = write_ifMauAutoNegRemoteFaultAdvertised;
        long_return = entry.ifMauAutoNegRemoteFaultAdvertised;
        return (u_char*) &long_return;
      case IFMAUAUTONEGREMOTEFAULTRECEIVED:
        long_return = entry.ifMauAutoNegRemoteFaultReceived;
        return (u_char*) &long_return;
    default:
        ERROR_MSG("");
    }
    return NULL;
}


int
write_ifMauAutoNegAdminStatus(int action,
                              u_char * var_val,
                              u_char var_val_type,
                              size_t var_val_len,
                              u_char * statP, oid * name, size_t name_len)
{
    UI32_T  ifMauAutoNegAdminStatus;

    if ((char) name[10] != IFMAUAUTONEGADMINSTATUS)
     {
        return SNMP_ERR_NOTWRITABLE;
    }
    if (name_len!=  13)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    ifMauAutoNegAdminStatus = *(long *)var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }

            if ((ifMauAutoNegAdminStatus != VAL_ifMauAutoNegAdminStatus_enabled) &&(ifMauAutoNegAdminStatus != VAL_ifMauAutoNegAdminStatus_disabled))
         {
            return SNMP_ERR_WRONGVALUE;
        }
        break;


        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:

            if (SWCTRL_PMGR_SetIfMauAutoNegAdminStatus(name[11], name[12], ifMauAutoNegAdminStatus) != TRUE)
                return SNMP_ERR_COMMITFAILED;
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
 #if 0 /*THIS OBJECT IS DEPRECATED */
int
write_ifMauAutoNegCapAdvertised(int action,
                                u_char * var_val,
                                u_char var_val_type,
                                size_t var_val_len,
                                u_char * statP,
                                oid * name, size_t name_len)
{
    UI32_T  ifMauAutoNegCapAdvertised;

    if ((char) name[10] != IFMAUAUTONEGCAPADVERTISED)
     {
        return SNMP_ERR_NOTWRITABLE;
    }
    if (name_len!=  13)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    ifMauAutoNegCapAdvertised = *(long *)var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;



        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
          /* not supported*/
                return SNMP_ERR_COMMITFAILED;
         break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
#endif
int
write_ifMauAutoNegRestart(int action,
                          u_char * var_val,
                          u_char var_val_type,
                          size_t var_val_len,
                          u_char * statP, oid * name, size_t name_len)
{
    UI32_T  ifMauAutoNegRestart;

    if ((char) name[10] != IFMAUAUTONEGRESTART)
     {
        return SNMP_ERR_NOTWRITABLE;
    }
    if (name_len!=  13)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    ifMauAutoNegRestart = *(long *)var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }

            if ((ifMauAutoNegRestart != VAL_ifMauAutoNegRestart_restart) &&(ifMauAutoNegRestart != VAL_ifMauAutoNegRestart_norestart))
         {
            return SNMP_ERR_WRONGVALUE;
        }
        break;


        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:

            if (SWCTRL_PMGR_SetIfMauAutoNegRestart(name[11], name[12], ifMauAutoNegRestart) != TRUE)
                return SNMP_ERR_COMMITFAILED;
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_ifMauAutoNegCapAdvertisedBits(int action,
                                    u_char * var_val,
                                    u_char var_val_type,
                                    size_t var_val_len,
                                    u_char * statP,
                                    oid * name, size_t name_len)
{
    UI32_T IfMauAutoNegCapAdvertisedBits;

    if (name_len!=  13)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch (action) {
    case RESERVE1:
        if (var_val_type !=ASN_OCTET_STR) {
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(oid)) {
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:

        break;

    case FREE:
        /*
         * Release any resources that have been allocated
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        memset( &IfMauAutoNegCapAdvertisedBits, 0, sizeof(UI32_T));
    	memcpy(&IfMauAutoNegCapAdvertisedBits, var_val, var_val_len);
        IfMauAutoNegCapAdvertisedBits = L_STDLIB_Ntoh32(IfMauAutoNegCapAdvertisedBits);
         if (SWCTRL_PMGR_SetIfMauAutoNegCapAdvertisedBits(name[11], name[12], IfMauAutoNegCapAdvertisedBits) != TRUE)
                return SNMP_ERR_COMMITFAILED;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_ifMauAutoNegRemoteFaultAdvertised(int action,
                                        u_char * var_val,
                                        u_char var_val_type,
                                        size_t var_val_len,
                                        u_char * statP,
                                        oid * name, size_t name_len)
{
    UI32_T  ifMauAutoNegRemoteFaultAdvertised;

    if ((char) name[10] != IFMAUAUTONEGREMOTEFAULTADVERTISED)
     {
        return SNMP_ERR_NOTWRITABLE;
    }
    if (name_len!=  13)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    ifMauAutoNegRemoteFaultAdvertised = *(long *)var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }

            if ((ifMauAutoNegRemoteFaultAdvertised <VAL_ifMauAutoNegRemoteFaultAdvertised_noError) ||(ifMauAutoNegRemoteFaultAdvertised >VAL_ifMauAutoNegRemoteFaultAdvertised_autoNegError))
         {
            return SNMP_ERR_WRONGVALUE;
        }
        break;


        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:

            if (SWCTRL_PMGR_SetIfMauAutoNegRemoteFaultAdvertised(name[11], name[12], ifMauAutoNegRemoteFaultAdvertised) != TRUE)
                return SNMP_ERR_COMMITFAILED;
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
#endif

