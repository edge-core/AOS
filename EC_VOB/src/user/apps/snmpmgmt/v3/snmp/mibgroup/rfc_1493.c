/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.scalar.conf,v 1.5 2002/07/18 14:18:52 dts12 Exp $
 */
#include "sys_cpnt.h"

#if (SYS_CPNT_BRIDGE == TRUE)
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "rfc_1493.h"
#include "sysORTable.h"
#include "sys_type.h"
#include "amtr_mgr.h"
#include "nmtr_mgr.h"
#include "swctrl.h"
#include "leaf_1493.h"
#include "snmp_mgr.h"
#include "l_snmp.h"

#if (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_RSTP) || (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_MSTP)
   #include "xstp_mgr.h"
#else
   #include "sta_mgr.h"
#endif
#include "l_stdlib.h"


#include "xstp_om.h"
#include "xstp_pom.h"
#include "amtr_pmgr.h"
#include "nmtr_pmgr.h"
#include "xstp_pmgr.h"
#include "cmgr.h"


/** Initializes the dot1dBase module */
void
init_dot1dBase(void)
{
    oid            dot1dBridge_module_oid[] = { SNMP_OID_MIB2, 17 };

    static oid dot1dBaseType_oid[] = { 1,3,6,1,2,1,17,1,3, 0 };
    static oid dot1dBaseBridgeAddress_oid[] = { 1,3,6,1,2,1,17,1,1, 0 };
    static oid dot1dBaseNumPorts_oid[] = { 1,3,6,1,2,1,17,1,2, 0 };

  DEBUGMSGTL(("dot1dBase", "Initializing\n"));

    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("dot1dBaseType",
                                         get_dot1dBaseType,
                                         dot1dBaseType_oid,
                                         OID_LENGTH(dot1dBaseType_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("dot1dBaseBridgeAddress",
                                         get_dot1dBaseBridgeAddress,
                                         dot1dBaseBridgeAddress_oid,
                                         OID_LENGTH(dot1dBaseBridgeAddress_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("dot1dBaseNumPorts",
                                         get_dot1dBaseNumPorts,
                                         dot1dBaseNumPorts_oid,
                                         OID_LENGTH(dot1dBaseNumPorts_oid),
                                         HANDLER_CAN_RONLY));

     REGISTER_SYSOR_ENTRY(dot1dBridge_module_oid,
                         "The MIB module to Configure  Bridge MIB.");
}

int
get_dot1dBaseType(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

   #if (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_RSTP) || (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_MSTP)
         XSTP_MGR_Dot1dBaseEntry_T entry;
   #else
         STA_MGR_Dot1dBaseEntry_T entry;
   #endif

    memset( &entry, 0, sizeof(entry));

   #if (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_RSTP) || (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_MSTP)
        if (XSTP_PMGR_GetDot1dBaseEntry(&entry)!= TRUE)
   #else
        if (STA_MGR_GetDot1dBaseEntry(&entry)!= TRUE)
      #endif
        return SNMP_ERR_GENERR;

    long_return = entry.dot1d_base_type;

    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
            break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_dot1dBaseBridgeAddress(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

   #if (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_RSTP) || (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_MSTP)
         XSTP_MGR_Dot1dBaseEntry_T entry;
   #else
         STA_MGR_Dot1dBaseEntry_T entry;
   #endif

    memset( &entry, 0, sizeof(entry));

   #if (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_RSTP) || (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_MSTP)
        if (XSTP_PMGR_GetDot1dBaseEntry(&entry)!= TRUE)
   #else
        if (STA_MGR_GetDot1dBaseEntry(&entry)!= TRUE)
      #endif
        return SNMP_ERR_GENERR;

    switch(reqinfo->mode) {

        case MODE_GET:

            memcpy(return_buf, entry.dot1d_base_bridge_address, 6);
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, (u_char *) return_buf, 6);
            break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_dot1dBaseNumPorts(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

   #if (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_RSTP) || (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_MSTP)
         XSTP_MGR_Dot1dBaseEntry_T entry;
   #else
         STA_MGR_Dot1dBaseEntry_T entry;
   #endif

    memset( &entry, 0, sizeof(entry));

   #if (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_RSTP) || (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_MSTP)
        if (XSTP_PMGR_GetDot1dBaseEntry(&entry)!= TRUE)
   #else
        if (STA_MGR_GetDot1dBaseEntry(&entry)!= TRUE)
      #endif
        return SNMP_ERR_GENERR;

    long_return = entry.dot1d_base_num_ports;

    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return));
            break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

/*
 * dot1dBasePortTable_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid dot1dBasePortTable_variables_oid[] = { 1,3,6,1,2,1,17,1};

/*
 * variable4 dot1dBasePortTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */

struct variable3 dot1dBasePortTable_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */

#define DOT1DBASEPORT		1
{DOT1DBASEPORT,  ASN_INTEGER,  RONLY,   var_dot1dBasePortTable, 3,  { 4, 1, 1 }},
#define DOT1DBASEPORTIFINDEX		2
{DOT1DBASEPORTIFINDEX,  ASN_INTEGER,  RONLY,   var_dot1dBasePortTable, 3,  { 4, 1, 2 }},
#define DOT1DBASEPORTCIRCUIT		3
{DOT1DBASEPORTCIRCUIT,  ASN_OBJECT_ID,  RONLY,   var_dot1dBasePortTable, 3,  { 4, 1, 3 }},
#define DOT1DBASEPORTDELAYEXCEEDEDDISCARDS		4
{DOT1DBASEPORTDELAYEXCEEDEDDISCARDS,  ASN_COUNTER,  RONLY,   var_dot1dBasePortTable, 3,  { 4, 1, 4 }},
#define DOT1DBASEPORTMTUEXCEEDEDDISCARDS		5
{DOT1DBASEPORTMTUEXCEEDEDDISCARDS,  ASN_COUNTER,  RONLY,   var_dot1dBasePortTable, 3,  { 4, 1, 5 }},
};
/*    (L = length of the oidsuffix) */


/** Initializes the dot1dBasePortTable module */
void
init_dot1dBasePortTable(void)
{

    DEBUGMSGTL(("dot1dBasePortTable", "Initializing\n"));

    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("dot1dBasePortTable", dot1dBasePortTable_variables, variable3,
               dot1dBasePortTable_variables_oid);

    /* place any other initialization junk you need here */
}


#if (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_RSTP) || (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_MSTP)

static int
header_dot1dBasePortTable(struct variable *vp,
               oid * name,
               size_t * length,
               int exact, size_t * var_len, WriteMethod ** write_method,
               XSTP_MGR_Dot1dBasePortEntry_T *entry)
#else
static int
header_dot1dBasePortTable(struct variable *vp,
               oid * name,
               size_t * length,
               int exact, size_t * var_len, WriteMethod ** write_method,
               STA_MGR_Dot1dBasePortEntry_T *entry)

#endif
{
     unsigned int ifIndex = 0;

    if(!entry || l_snmp_index_get(vp,name,length,&ifIndex,exact) < 0 )
      return MATCH_FAILED;

    entry->dot1d_base_port = ifIndex;
    if(!exact)
     {
#if (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_RSTP) || (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_MSTP)
        if(XSTP_PMGR_GetNextDot1dBasePortEntry(entry)!=TRUE)
#else
        if(STA_MGR_GetNextDot1dBasePortEntry(entry)!=TRUE)
#endif
         return MATCH_FAILED;

        l_snmp_index_set(vp,name,length,entry->dot1d_base_port);

     }
    else
    {
#if (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_RSTP) || (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_MSTP)
      if(XSTP_PMGR_GetDot1dBasePortEntry(entry)!=TRUE)
#else
      if(STA_MGR_GetDot1dBasePortEntry(entry)!=TRUE)
#endif
            return MATCH_FAILED;
    }


    *write_method = 0;
    *var_len = sizeof(long);    /* default to 'long' results */

    return entry->dot1d_base_port;

}




/*
 * var_dot1dBasePortTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *
var_dot1dBasePortTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{

#if (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_RSTP) || (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_MSTP)
                               XSTP_MGR_Dot1dBasePortEntry_T entry;

#else
                               STA_MGR_Dot1dBasePortEntry_T entry;

#endif

   memset( &entry, 0, sizeof(entry));
   if(MATCH_FAILED == header_dot1dBasePortTable(vp, name, length, exact, var_len, write_method,&entry))
       return NULL;

    /*
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
    case DOT1DBASEPORT:
        long_return =(UI32_T) entry.dot1d_base_port;
        return (u_char *) & long_return;
    case DOT1DBASEPORTIFINDEX:
        long_return =(UI32_T)entry.dot1d_base_port_if_index;
        return (u_char *) & long_return;
    case DOT1DBASEPORTCIRCUIT:
    {
      static  oid oidreturn[2];

       memcpy( oidreturn,  entry.dot1d_base_port_circuit, sizeof(UI32_T)*2);
       *var_len = sizeof(UI32_T)*2;
        return (u_char *) oidreturn;
    }
    case DOT1DBASEPORTDELAYEXCEEDEDDISCARDS:
        long_return = entry.dot1d_base_port_delay_exceeded_discards;
        return (u_char *) & long_return;
    case DOT1DBASEPORTMTUEXCEEDEDDISCARDS:
        long_return = entry.dot1d_base_port_mtu_exceeded_discards;
        return (u_char *) & long_return;
    default:
      ERROR_MSG("");
    }
    return NULL;
}

/** Initializes the dot1dStp module */
void
init_dot1dStp(void)
{
    static oid dot1dStpRootCost_oid[] = { 1,3,6,1,2,1,17,2,6, 0 };
    static oid dot1dStpBridgeMaxAge_oid[] = { 1,3,6,1,2,1,17,2,12, 0 };
    static oid dot1dStpBridgeHelloTime_oid[] = { 1,3,6,1,2,1,17,2,13, 0 };
    static oid dot1dStpBridgeForwardDelay_oid[] = { 1,3,6,1,2,1,17,2,14, 0 };
    static oid dot1dStpPriority_oid[] = { 1,3,6,1,2,1,17,2,2, 0 };
    static oid dot1dStpProtocolSpecification_oid[] = { 1,3,6,1,2,1,17,2,1, 0 };
    static oid dot1dStpMaxAge_oid[] = { 1,3,6,1,2,1,17,2,8, 0 };
    static oid dot1dStpHelloTime_oid[] = { 1,3,6,1,2,1,17,2,9, 0 };
    static oid dot1dStpTimeSinceTopologyChange_oid[] = { 1,3,6,1,2,1,17,2,3, 0 };
    static oid dot1dStpForwardDelay_oid[] = { 1,3,6,1,2,1,17,2,11, 0 };
    static oid dot1dStpHoldTime_oid[] = { 1,3,6,1,2,1,17,2,10, 0 };
    static oid dot1dStpRootPort_oid[] = { 1,3,6,1,2,1,17,2,7, 0 };
    static oid dot1dStpTopChanges_oid[] = { 1,3,6,1,2,1,17,2,4, 0 };
    static oid dot1dStpDesignatedRoot_oid[] = { 1,3,6,1,2,1,17,2,5, 0 };

  DEBUGMSGTL(("dot1dStp", "Initializing\n"));

    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("dot1dStpRootCost",
                                         get_dot1dStpRootCost,
                                         dot1dStpRootCost_oid,
                                         OID_LENGTH(dot1dStpRootCost_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("dot1dStpBridgeMaxAge",
                               do_dot1dStpBridgeMaxAge,
                               dot1dStpBridgeMaxAge_oid,
                               OID_LENGTH(dot1dStpBridgeMaxAge_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("dot1dStpBridgeHelloTime",
                               do_dot1dStpBridgeHelloTime,
                               dot1dStpBridgeHelloTime_oid,
                               OID_LENGTH(dot1dStpBridgeHelloTime_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("dot1dStpBridgeForwardDelay",
                               do_dot1dStpBridgeForwardDelay,
                               dot1dStpBridgeForwardDelay_oid,
                               OID_LENGTH(dot1dStpBridgeForwardDelay_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("dot1dStpPriority",
                               do_dot1dStpPriority,
                               dot1dStpPriority_oid,
                               OID_LENGTH(dot1dStpPriority_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("dot1dStpProtocolSpecification",
                                         get_dot1dStpProtocolSpecification,
                                         dot1dStpProtocolSpecification_oid,
                                         OID_LENGTH(dot1dStpProtocolSpecification_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("dot1dStpMaxAge",
                                         get_dot1dStpMaxAge,
                                         dot1dStpMaxAge_oid,
                                         OID_LENGTH(dot1dStpMaxAge_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("dot1dStpHelloTime",
                                         get_dot1dStpHelloTime,
                                         dot1dStpHelloTime_oid,
                                         OID_LENGTH(dot1dStpHelloTime_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("dot1dStpTimeSinceTopologyChange",
                                         get_dot1dStpTimeSinceTopologyChange,
                                         dot1dStpTimeSinceTopologyChange_oid,
                                         OID_LENGTH(dot1dStpTimeSinceTopologyChange_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("dot1dStpForwardDelay",
                                         get_dot1dStpForwardDelay,
                                         dot1dStpForwardDelay_oid,
                                         OID_LENGTH(dot1dStpForwardDelay_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("dot1dStpHoldTime",
                                         get_dot1dStpHoldTime,
                                         dot1dStpHoldTime_oid,
                                         OID_LENGTH(dot1dStpHoldTime_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("dot1dStpRootPort",
                                         get_dot1dStpRootPort,
                                         dot1dStpRootPort_oid,
                                         OID_LENGTH(dot1dStpRootPort_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("dot1dStpTopChanges",
                                         get_dot1dStpTopChanges,
                                         dot1dStpTopChanges_oid,
                                         OID_LENGTH(dot1dStpTopChanges_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("dot1dStpDesignatedRoot",
                                         get_dot1dStpDesignatedRoot,
                                         dot1dStpDesignatedRoot_oid,
                                         OID_LENGTH(dot1dStpDesignatedRoot_oid),
                                         HANDLER_CAN_RONLY));
}

int
get_dot1dStpRootCost(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
#if (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_RSTP) || (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_MSTP)
  XSTP_MGR_Dot1dStpEntry_T entry;
#else
  STA_MGR_Dot1dStpEntry_T entry;
#endif

  memset(&entry, 0, sizeof(entry));
#if (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_RSTP) || (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_MSTP)
  if (XSTP_PMGR_GetDot1dMstEntry(0,  &entry)!= TRUE)
#else
   if (STA_MGR_GetDot1dStpEntry(&entry)!= TRUE)
#endif
     return SNMP_ERR_GENERR;

    long_return = entry.dot1d_stp_root_cost;

    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *)&long_return, sizeof(long_return));
            break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_dot1dStpBridgeMaxAge(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
            {
            #if (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_RSTP) || (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_MSTP)
                 XSTP_MGR_Dot1dStpEntry_T entry;
            #else
                  STA_MGR_Dot1dStpEntry_T entry;
            #endif

           memset(&entry, 0, sizeof(entry));
          #if (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_RSTP) || (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_MSTP)
               if (XSTP_PMGR_GetDot1dMstEntry(0,  &entry)!= TRUE)
          #else
              if (STA_MGR_GetDot1dStpEntry(&entry)!= TRUE)
         #endif
             return SNMP_ERR_GENERR;

            long_return = entry.dot1d_stp_bridge_max_age;

            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return) );

            }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
            }
            break;

        case MODE_SET_RESERVE2:

            if (*requests->requestvb->val.integer < MIN_dot1dStpBridgeMaxAge ||
                *requests->requestvb->val.integer > MAX_dot1dStpBridgeMaxAge)
            {
               netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
          {
       	UI32_T dot1d_stp_bridge_max_age;
       	dot1d_stp_bridge_max_age = (*requests->requestvb->val.integer);

                #if (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_RSTP) || (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_MSTP)
                     if (XSTP_PMGR_SetMaxAge( dot1d_stp_bridge_max_age) != XSTP_TYPE_RETURN_OK)
                #else
                     if (STA_MGR_SetDot1dStpBridgeMaxAge( dot1d_stp_bridge_max_age) != STA_RETURN_OK)
               #endif
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
         }
            break;

        case MODE_SET_COMMIT:

            break;

        case MODE_SET_UNDO:

            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}


int
do_dot1dStpBridgeHelloTime(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
             {
            #if (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_RSTP) || (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_MSTP)
                 XSTP_MGR_Dot1dStpEntry_T entry;
            #else
                  STA_MGR_Dot1dStpEntry_T entry;
            #endif

           memset(&entry, 0, sizeof(entry));
          #if (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_RSTP) || (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_MSTP)
               if (XSTP_PMGR_GetDot1dMstEntry(0,  &entry)!= TRUE)
          #else
              if (STA_MGR_GetDot1dStpEntry(&entry)!= TRUE)
         #endif
             return SNMP_ERR_GENERR;

            long_return = entry.dot1d_stp_bridge_hello_time;

            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return) );

            }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
            }
            break;

        case MODE_SET_RESERVE2:

            if (*requests->requestvb->val.integer < MIN_dot1dStpBridgeHelloTime ||
                *requests->requestvb->val.integer > MAX_dot1dStpBridgeHelloTime)
            {
               netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
              {
       	UI32_T dot1d_stp_bridge_hello_time;
       	dot1d_stp_bridge_hello_time = (*requests->requestvb->val.integer);

                 #if (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_RSTP) || (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_MSTP)
                     if (XSTP_PMGR_SetHelloTime(dot1d_stp_bridge_hello_time) != XSTP_TYPE_RETURN_OK)
                 #else
                     if (STA_MGR_SetDot1dStpBridgeHelloTime(dot1d_stp_bridge_hello_time) != STA_RETURN_OK)
                #endif
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
         }
            break;

        case MODE_SET_COMMIT:

            break;

        case MODE_SET_UNDO:

            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}


int
do_dot1dStpBridgeForwardDelay(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
           {
            #if (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_RSTP) || (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_MSTP)
                 XSTP_MGR_Dot1dStpEntry_T entry;
            #else
                  STA_MGR_Dot1dStpEntry_T entry;
            #endif

           memset(&entry, 0, sizeof(entry));
         #if (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_RSTP) || (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_MSTP)
               if (XSTP_PMGR_GetDot1dMstEntry(0,  &entry)!= TRUE)
          #else
              if (STA_MGR_GetDot1dStpEntry(&entry)!= TRUE)
         #endif
             return SNMP_ERR_GENERR;

            long_return = entry.dot1d_stp_bridge_forward_delay;

            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return , sizeof(long_return) );

            }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
            }
            break;

        case MODE_SET_RESERVE2:

            if (*requests->requestvb->val.integer < MIN_dot1dStpBridgeForwardDelay ||
                *requests->requestvb->val.integer > MAX_dot1dStpBridgeForwardDelay)
            {
               netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
              {
       	UI32_T dot1dStpBridgeForwardDelay;
       	dot1dStpBridgeForwardDelay = (*requests->requestvb->val.integer);

               #if (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_RSTP) || (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_MSTP)
                      if (XSTP_PMGR_SetForwardDelay(dot1dStpBridgeForwardDelay) != XSTP_TYPE_RETURN_OK)
                #else
                      if (STA_MGR_SetDot1dStpBridgeForwardDelay(dot1dStpBridgeForwardDelay) != STA_RETURN_OK)
               #endif
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
         }
            break;

        case MODE_SET_COMMIT:

            break;

        case MODE_SET_UNDO:

            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}



int
do_dot1dStpPriority(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
                  {
            #if (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_RSTP) || (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_MSTP)
                 XSTP_MGR_Dot1dStpEntry_T entry;
            #else
                  STA_MGR_Dot1dStpEntry_T entry;
            #endif

           memset(&entry, 0, sizeof(entry));
         #if (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_RSTP) || (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_MSTP)
               if (XSTP_PMGR_GetDot1dMstEntry(0,  &entry)!= TRUE)
          #else
              if (STA_MGR_GetDot1dStpEntry(&entry)!= TRUE)
         #endif
             return SNMP_ERR_GENERR;

            long_return = entry.dot1d_stp_priority;

            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return , sizeof(long_return) );

            }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
            }
            break;

        case MODE_SET_RESERVE2:

            if (*requests->requestvb->val.integer < MIN_dot1dStpPriority ||
                *requests->requestvb->val.integer > MAX_dot1dStpPriority)
            {
               netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
              {
       	UI32_T dot1d_stp_priority;
       	dot1d_stp_priority = (*requests->requestvb->val.integer);

               #if (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_RSTP) || (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_MSTP)
                      if (XSTP_PMGR_SetSystemBridgePriority(dot1d_stp_priority) != XSTP_TYPE_RETURN_OK)
               #else
                      if (STA_MGR_SetDot1dStpPriority(dot1d_stp_priority) != STA_RETURN_OK)
               #endif
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
         }
            break;

        case MODE_SET_COMMIT:

            break;

        case MODE_SET_UNDO:

            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}


int
get_dot1dStpProtocolSpecification(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
#if (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_RSTP) || (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_MSTP)
  XSTP_MGR_Dot1dStpEntry_T entry;
#else
  STA_MGR_Dot1dStpEntry_T entry;
#endif

  memset(&entry, 0, sizeof(entry));
#if (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_RSTP) || (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_MSTP)
  if (XSTP_PMGR_GetDot1dMstEntry(0,  &entry)!= TRUE)
#else
   if (STA_MGR_GetDot1dStpEntry(&entry)!= TRUE)
#endif
     return SNMP_ERR_GENERR;

    long_return = entry.dot1d_stp_protocol_specification;

    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *)&long_return, sizeof(long_return));
            break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_dot1dStpMaxAge(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
#if (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_RSTP) || (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_MSTP)
  XSTP_MGR_Dot1dStpEntry_T entry;
#else
  STA_MGR_Dot1dStpEntry_T entry;
#endif

  memset(&entry, 0, sizeof(entry));
#if (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_RSTP) || (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_MSTP)
  if (XSTP_PMGR_GetDot1dMstEntry(0,  &entry)!= TRUE)
#else
   if (STA_MGR_GetDot1dStpEntry(&entry)!= TRUE)
#endif
     return SNMP_ERR_GENERR;

    long_return = entry.dot1d_stp_max_age;

    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *)&long_return, sizeof(long_return));
            break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_dot1dStpHelloTime(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
#if (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_RSTP) || (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_MSTP)
  XSTP_MGR_Dot1dStpEntry_T entry;
#else
  STA_MGR_Dot1dStpEntry_T entry;
#endif

  memset(&entry, 0, sizeof(entry));
#if (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_RSTP) || (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_MSTP)
  if (XSTP_PMGR_GetDot1dMstEntry(0,  &entry)!= TRUE)
#else
   if (STA_MGR_GetDot1dStpEntry(&entry)!= TRUE)
#endif
     return SNMP_ERR_GENERR;

    long_return = entry.dot1d_stp_hello_time;

    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *)&long_return, sizeof(long_return));
            break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_dot1dStpTimeSinceTopologyChange(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
#if (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_RSTP) || (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_MSTP)
  XSTP_MGR_Dot1dStpEntry_T entry;
#else
  STA_MGR_Dot1dStpEntry_T entry;
#endif

  memset(&entry, 0, sizeof(entry));
#if (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_RSTP) || (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_MSTP)
  if (XSTP_PMGR_GetDot1dMstEntry(0,  &entry)!= TRUE)
#else
   if (STA_MGR_GetDot1dStpEntry(&entry)!= TRUE)
#endif
     return SNMP_ERR_GENERR;

    long_return = entry.dot1d_stp_time_since_topology_change;

    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_TIMETICKS, (u_char *)&long_return, sizeof(long_return));
            break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}


int
get_dot1dStpForwardDelay(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
#if (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_RSTP) || (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_MSTP)
  XSTP_MGR_Dot1dStpEntry_T entry;
#else
  STA_MGR_Dot1dStpEntry_T entry;
#endif

  memset(&entry, 0, sizeof(entry));
#if (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_RSTP) || (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_MSTP)
  if (XSTP_PMGR_GetDot1dMstEntry(0,  &entry)!= TRUE)
#else
   if (STA_MGR_GetDot1dStpEntry(&entry)!= TRUE)
#endif
     return SNMP_ERR_GENERR;

    long_return = entry.dot1d_stp_forward_delay;

    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *)&long_return, sizeof(long_return));
            break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_dot1dStpHoldTime(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
#if (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_RSTP) || (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_MSTP)
  XSTP_MGR_Dot1dStpEntry_T entry;
#else
  STA_MGR_Dot1dStpEntry_T entry;
#endif

  memset(&entry, 0, sizeof(entry));
#if (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_RSTP) || (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_MSTP)
  if (XSTP_PMGR_GetDot1dMstEntry(0,  &entry)!= TRUE)
#else
   if (STA_MGR_GetDot1dStpEntry(&entry)!= TRUE)
#endif
     return SNMP_ERR_GENERR;

    long_return = entry.dot1d_stp_hold_time;

    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *)&long_return, sizeof(long_return));
            break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_dot1dStpRootPort(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
#if (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_RSTP) || (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_MSTP)
  XSTP_MGR_Dot1dStpEntry_T entry;
#else
  STA_MGR_Dot1dStpEntry_T entry;
#endif

  memset(&entry, 0, sizeof(entry));
#if (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_RSTP) || (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_MSTP)
  if (XSTP_PMGR_GetDot1dMstEntry(0,  &entry)!= TRUE)
#else
   if (STA_MGR_GetDot1dStpEntry(&entry)!= TRUE)
#endif
     return SNMP_ERR_GENERR;

    long_return = entry.dot1d_stp_root_port;

    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *)&long_return, sizeof(long_return));
            break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_dot1dStpTopChanges(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
#if (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_RSTP) || (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_MSTP)
  XSTP_MGR_Dot1dStpEntry_T entry;
#else
  STA_MGR_Dot1dStpEntry_T entry;
#endif

  memset(&entry, 0, sizeof(entry));
#if (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_RSTP) || (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_MSTP)
  if (XSTP_PMGR_GetDot1dMstEntry(0,  &entry)!= TRUE)
#else
   if (STA_MGR_GetDot1dStpEntry(&entry)!= TRUE)
#endif
     return SNMP_ERR_GENERR;

    long_return = entry.dot1d_stp_top_changes;

    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *)&long_return, sizeof(long_return));
            break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
get_dot1dStpDesignatedRoot(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
#if (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_RSTP) || (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_MSTP)
  XSTP_MGR_Dot1dStpEntry_T entry;
#else
  STA_MGR_Dot1dStpEntry_T entry;
#endif
 UI8_T  dot1d_stp_designated_root[8];

  memset(&entry, 0, sizeof(entry));
#if (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_RSTP) || (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_MSTP)
  if (XSTP_PMGR_GetDot1dMstEntry(0,  &entry)!= TRUE)
#else
   if (STA_MGR_GetDot1dStpEntry(&entry)!= TRUE)
#endif
     return SNMP_ERR_GENERR;

    entry.dot1d_stp_designated_root.bridge_id_priority.bridge_priority =
        L_STDLIB_Hton16(entry.dot1d_stp_designated_root.bridge_id_priority.bridge_priority);

    memcpy(dot1d_stp_designated_root, (UI8_T*)&entry.dot1d_stp_designated_root, 8);

    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, (u_char *)dot1d_stp_designated_root, 8);
            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

/*
 * dot1dStpPortTable_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid dot1dStpPortTable_variables_oid[] = { 1,3,6,1,2,1,17,2};

/*
 * variable4 dot1dStpPortTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */

struct variable3 dot1dStpPortTable_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */

#define DOT1DSTPPORT		1
{DOT1DSTPPORT,  ASN_INTEGER,  RONLY,   var_dot1dStpPortTable, 3,  { 15, 1, 1 }},
#define DOT1DSTPPORTPRIORITY		2
{DOT1DSTPPORTPRIORITY,  ASN_INTEGER,  RWRITE,  var_dot1dStpPortTable, 3,  { 15, 1, 2 }},
#define DOT1DSTPPORTSTATE		3
{DOT1DSTPPORTSTATE,  ASN_INTEGER,  RONLY,   var_dot1dStpPortTable, 3,  { 15, 1, 3 }},
#define DOT1DSTPPORTENABLE		4
{DOT1DSTPPORTENABLE,  ASN_INTEGER,  RWRITE,  var_dot1dStpPortTable, 3,  { 15, 1, 4 }},
#define DOT1DSTPPORTPATHCOST		5
{DOT1DSTPPORTPATHCOST,  ASN_INTEGER,  RWRITE,  var_dot1dStpPortTable, 3,  { 15, 1, 5 }},
#define DOT1DSTPPORTDESIGNATEDROOT		6
{DOT1DSTPPORTDESIGNATEDROOT,  ASN_OCTET_STR,  RONLY,   var_dot1dStpPortTable, 3,  { 15, 1, 6 }},
#define DOT1DSTPPORTDESIGNATEDCOST		7
{DOT1DSTPPORTDESIGNATEDCOST,  ASN_INTEGER,  RONLY,   var_dot1dStpPortTable, 3,  { 15, 1, 7 }},
#define DOT1DSTPPORTDESIGNATEDBRIDGE		8
{DOT1DSTPPORTDESIGNATEDBRIDGE,  ASN_OCTET_STR,  RONLY,   var_dot1dStpPortTable, 3,  { 15, 1, 8 }},
#define DOT1DSTPPORTDESIGNATEDPORT		9
{DOT1DSTPPORTDESIGNATEDPORT,  ASN_OCTET_STR,  RONLY,   var_dot1dStpPortTable, 3,  { 15, 1, 9 }},
#define DOT1DSTPPORTFORWARDTRANSITIONS		10
{DOT1DSTPPORTFORWARDTRANSITIONS,  ASN_COUNTER,  RONLY,   var_dot1dStpPortTable, 3,  { 15, 1, 10 }},
};
/*    (L = length of the oidsuffix) */


/** Initializes the dot1dStpPortTable module */
void
init_dot1dStpPortTable(void)
{

    DEBUGMSGTL(("dot1dStpPortTable", "Initializing\n"));

    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("dot1dStpPortTable", dot1dStpPortTable_variables, variable3,
               dot1dStpPortTable_variables_oid);

    /* place any other initialization junk you need here */
}


static int
header_dot1dStpPortTable(struct variable *vp,
               oid * name,
               size_t * length,
               int exact, size_t * var_len, WriteMethod ** write_method)
{
#define ENTRY_NAME_LENGTH	11
    oid             newname[MAX_OID_LEN];
    int    interface;
    int             result;
#if (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_RSTP) || (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_MSTP)
                               XSTP_MGR_Dot1dStpPortEntry_T entry;

#else
                               STA_MGR_Dot1dStpPortEntry_T entry;

#endif

   int ifIndex = 0;
   UI32_T msid = 0;
   BOOL_T return_val;


    memcpy((char *) newname, (char *) vp->name,
           (int) vp->namelen * sizeof(oid));
    /*
     * find "next" interface
     */

       entry.dot1d_stp_port = ifIndex;
    #if (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_RSTP) || (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_MSTP)
         msid = XSTP_TYPE_CISTID;
     while (  (return_val= XSTP_POM_GetNextDot1dMstPortEntry(&msid, &entry))==TRUE)
    #else
      while (  (return_val= STA_MGR_GetNextDot1dStpPortEntry( &entry))==TRUE)
     #endif
     {

        ifIndex = entry.dot1d_stp_port;
        newname[ENTRY_NAME_LENGTH] = (oid) ifIndex;
        result =
            snmp_oid_compare(name, *length, newname,
                             (int) vp->namelen + 1);
        if ((exact && (result == 0)) || (!exact && (result < 0)))
            break;
    }
    if (!return_val ) {
        return MATCH_FAILED;
    }


    memcpy((char *) name, (char *) newname,
           ((int) vp->namelen + 1) * sizeof(oid));
    *length = vp->namelen + 1;
    *write_method = 0;
    *var_len = sizeof(long);    /* default to 'long' results */
    interface = newname[ENTRY_NAME_LENGTH];


    return interface;
}


/*
 * var_dot1dStpPortTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *
var_dot1dStpPortTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{


#if (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_RSTP) || (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_MSTP)
      XSTP_MGR_Dot1dStpPortEntry_T entry;
#else
      STA_MGR_Dot1dStpPortEntry_T entry;
#endif

    int             interface;

   memset( &entry, 0, sizeof(entry));
    interface =
        header_dot1dStpPortTable(vp, name, length, exact, var_len, write_method);
    if (interface == MATCH_FAILED)
        return NULL;


  entry.dot1d_stp_port =interface;

        #if (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_RSTP) || (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_MSTP)
	if (!XSTP_POM_GetDot1dMstPortEntry(0,&entry) )
         #else
       	if (!STA_MGR_GetDot1dStpPortEntry(&entry))
         #endif
            return NULL;

    /*
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic)
    {
    case DOT1DSTPPORT:
        long_return = entry.dot1d_stp_port;
        return (u_char *) & long_return;
    case DOT1DSTPPORTPRIORITY:
        *write_method = write_dot1dStpPortPriority;
       long_return = entry.dot1d_stp_port_priority;
        return (u_char *) & long_return;
    case DOT1DSTPPORTSTATE:
        long_return = entry.dot1d_stp_port_state;
        return (u_char *) & long_return;
    case DOT1DSTPPORTENABLE:
        *write_method = write_dot1dStpPortEnable;
        long_return = entry.dot1d_stp_port_enable;
        return (u_char *) & long_return;
    case DOT1DSTPPORTPATHCOST:
        *write_method = write_dot1dStpPortPathCost;
         long_return = entry.dot1d_stp_port_path_cost;
        if (long_return > 65535/*65535*/)
        {
     	  long_return = 65535;
        }
        return (u_char *) & long_return;
    case DOT1DSTPPORTDESIGNATEDROOT:
        entry.dot1d_stp_port_designated_root.bridge_id_priority.bridge_priority =
            L_STDLIB_Hton16(entry.dot1d_stp_port_designated_root.bridge_id_priority.bridge_priority);
        memcpy(return_buf, (UI8_T*)&entry.dot1d_stp_port_designated_root, 8);
        *var_len = 8;
        return (u_char *) return_buf;
    case DOT1DSTPPORTDESIGNATEDCOST:
        long_return = entry.dot1d_stp_port_designated_cost;
        return (u_char *) & long_return;
    case DOT1DSTPPORTDESIGNATEDBRIDGE:
        entry.dot1d_stp_port_designated_bridge.bridge_id_priority.bridge_priority =
            L_STDLIB_Hton16(entry.dot1d_stp_port_designated_bridge.bridge_id_priority.bridge_priority);
        memcpy(return_buf, (UI8_T*)&entry.dot1d_stp_port_designated_bridge, 8);
        *var_len = 8;
        return (u_char *) return_buf;
    case DOT1DSTPPORTDESIGNATEDPORT:
        *(UI16_T *)return_buf = L_STDLIB_Hton16(entry.dot1d_stp_port_designated_port.port_id);
        *var_len = 2;
        return (u_char *) return_buf;
    case DOT1DSTPPORTFORWARDTRANSITIONS:
        long_return = entry.dot1d_stp_port_forward_transitions;
        return (u_char *) & long_return;
    default:
        ERROR_MSG("");
    }
    return NULL;
}


int
write_dot1dStpPortPriority(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
     UI32_T  dot1dportPriority;

    if ((char) name[10] != DOT1DSTPPORTPRIORITY)
     {
        return SNMP_ERR_NOTWRITABLE;
    }
    if (name_len!=  12)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    dot1dportPriority = *(long *)var_val;


    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }

           if ((dot1dportPriority< 0)||(dot1dportPriority >255))
          {
              return SNMP_ERR_WRONGVALUE;
          }
        break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
         #if (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_RSTP) || (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_MSTP)
              if (XSTP_PMGR_SetPortPriority(name[11], dot1dportPriority) != XSTP_TYPE_RETURN_OK)
         #else
              if (STA_MGR_SetDot1dStpPortPriority(name[11], dot1dportPriority) != STA_RETURN_OK)
       #endif
             return SNMP_ERR_COMMITFAILED;

          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_dot1dStpPortEnable(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
      UI32_T  dot1dportEnable;

    if ((char) name[10] != DOT1DSTPPORTENABLE)
     {
        return SNMP_ERR_NOTWRITABLE;
    }
    if (name_len!=  12)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    dot1dportEnable = *(long *)var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }

          if ((dot1dportEnable != 1) &&( dot1dportEnable != 2))
          {
              return SNMP_ERR_WRONGVALUE;
          }
        break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
            if (CMGR_SetPortAdminStatus(name[11], dot1dportEnable)!= TRUE)
                  return SNMP_ERR_COMMITFAILED;
	     break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_dot1dStpPortPathCost(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    UI32_T  dot1dStpPortPathCost;

    if ((char) name[10] != DOT1DSTPPORTPATHCOST)
     {
        return SNMP_ERR_NOTWRITABLE;
    }
    if (name_len!=  12)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    dot1dStpPortPathCost = *(long *)var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }

          if ((dot1dStpPortPathCost< 1) || (dot1dStpPortPathCost >65535))
          {
             return SNMP_ERR_WRONGVALUE;
          }
        break;


        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
            #if (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_RSTP) || (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_MSTP)
                 if (XSTP_PMGR_SetPortPathCost(name[11], dot1dStpPortPathCost) != XSTP_TYPE_RETURN_OK)
            #else
                if (STA_MGR_SetDot1dStpPortPathCost(name[11], dot1dStpPortPathCost) != STA_RETURN_OK)
           #endif
       return SNMP_ERR_COMMITFAILED;
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

/** Initializes the dot1dTp module */
void
init_dot1dTp(void)
{
    static oid dot1dTpLearnedEntryDiscards_oid[] = { 1,3,6,1,2,1,17,4,1, 0 };
    static oid dot1dTpAgingTime_oid[] = { 1,3,6,1,2,1,17,4,2, 0 };

  DEBUGMSGTL(("dot1dTp", "Initializing\n"));

    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("dot1dTpLearnedEntryDiscards",
                                         get_dot1dTpLearnedEntryDiscards,
                                         dot1dTpLearnedEntryDiscards_oid,
                                         OID_LENGTH(dot1dTpLearnedEntryDiscards_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("dot1dTpAgingTime",
                               do_dot1dTpAgingTime,
                               dot1dTpAgingTime_oid,
                               OID_LENGTH(dot1dTpAgingTime_oid),
                               HANDLER_CAN_RWRITE));
}

int
get_dot1dTpLearnedEntryDiscards(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
   UI32_T dot1dTpLearnedEntryDiscards=0;

   /* NO API, always return 0 */

    long_return = dot1dTpLearnedEntryDiscards;

    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *) &long_return , sizeof(long_return) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_dot1dTpAgingTime(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode) {

        case MODE_GET:
             {
             UI32_T dot1dTpAgingTime;


           if (AMTR_PMGR_GetDot1dTpAgingTime(&dot1dTpAgingTime) != TRUE)
                 return SNMP_ERR_GENERR;

            long_return = dot1dTpAgingTime;

            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, sizeof(long_return) );

            }
            break;


        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            if (requests->requestvb->type != ASN_INTEGER)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
            }
            break;

        case MODE_SET_RESERVE2:

            if (*requests->requestvb->val.integer < MIN_dot1dTpAgingTime ||
                *requests->requestvb->val.integer > MAX_dot1dTpAgingTime)
            {
               netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
               {
            /* XXX: perform the value change here */
              UI32_T dot1dTpAgingTime;
              dot1dTpAgingTime = *requests->requestvb->val.integer;

             if (AMTR_PMGR_SetDot1dTpAgingTime(dot1dTpAgingTime) != TRUE)
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);


        }
           break;

        case MODE_SET_COMMIT:
            break;


        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */

            break;

        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

/********************
*dot1dTpFdbTable
*********************/
/*
 * dot1dTpFdbTable_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid dot1dTpFdbTable_variables_oid[] = { 1,3,6,1,2,1,17,4 };
#define dot1dTpFdbEntry_INSTANCE_LEN 6
/*
 * variable4 dot1dTpFdbTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */

struct variable3 dot1dTpFdbTable_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */

#define DOT1DTPFDBADDRESS		1
{DOT1DTPFDBADDRESS,  ASN_OCTET_STR,  RONLY,   var_dot1dTpFdbTable, 3,  { 3, 1, 1 }},
#define DOT1DTPFDBPORT		2
{DOT1DTPFDBPORT,  ASN_INTEGER,  RONLY,   var_dot1dTpFdbTable, 3,  { 3, 1, 2 }},
#define DOT1DTPFDBSTATUS		3
{DOT1DTPFDBSTATUS,  ASN_INTEGER,  RONLY,   var_dot1dTpFdbTable, 3,  { 3, 1, 3 }},
};
/*    (L = length of the oidsuffix) */

static BOOL_T dot1dTpFdbTable_get(int      compc,
                                oid     *compl,
                                AMTR_MGR_Dot1dTpFdbEntry_T   *data)
{
    if (compc !=dot1dTpFdbEntry_INSTANCE_LEN)
    {
 	    return FALSE;
    }
    SNMP_MGR_ReadOctetFromCompl(compl, 0, 5, data->dot1d_tp_fdb_address);

    if(SNMP_MGR_IsDebugMode())
    {
        int i;
        for (i=0; i<6; i++)
            printf("dot1dTpFdbTable_get:data->dot1d_tp_fdb_address[%d]=%d\n", i, data->dot1d_tp_fdb_address[i]);
    }

	if (!AMTR_PMGR_GetDot1dTpFdbEntry(data))
	{
	    if(SNMP_MGR_IsDebugMode())
	        printf("dot1dTpFdbTable_get:AMTR_PMGR_GetDot1dTpFdbEntry return false\n");
		return FALSE;
	}
	else
	{
		return TRUE;
	} /*End of if */
}

static BOOL_T dot1dTpFdbTable_next(int      compc,
                                 oid     *compl,
                                 AMTR_MGR_Dot1dTpFdbEntry_T    *data)
{
  	oid tmp_compl[dot1dTpFdbEntry_INSTANCE_LEN];

 	/* Generate the instance of each table entry and find the
	 * smallest instance that's larger than compc/compl.
	 *
	 * Step 1: Verify and extract the input key from "compc" and "compl"
	 * Note: The number of input key is defined by "compc".
	 *       The key for the specified instance is defined in compl.
	 */

	memcpy(tmp_compl, compl, sizeof(tmp_compl));
	SNMP_MGR_ConvertRemainToZero(compc,dot1dTpFdbEntry_INSTANCE_LEN, tmp_compl);
	SNMP_MGR_ReadOctetFromCompl(tmp_compl, 0, 5, data->dot1d_tp_fdb_address);

	if(SNMP_MGR_IsDebugMode())
    {
        int i;
        for (i=0; i<6; i++)
            printf("dot1dTpFdbTable_next:data->dot1d_tp_fdb_address[%d]=%d\n", i, data->dot1d_tp_fdb_address[i]);
    }

	if (compc<dot1dTpFdbEntry_INSTANCE_LEN)
	{
		if (!AMTR_PMGR_GetDot1dTpFdbEntry(data))
        {
            if (!AMTR_PMGR_GetNextDot1dTpFdbEntry(data))
   	        {
   	            if(SNMP_MGR_IsDebugMode())
   	                printf("dot1dTpFdbTable_next: get & genext return false\n");
   		        return FALSE;
   		    }
        }
	}
	else
	{
		if (!AMTR_PMGR_GetNextDot1dTpFdbEntry(data))
		{
		    if(SNMP_MGR_IsDebugMode())
   	            printf("dot1dTpFdbTable_next: getnext return false\n");
			return FALSE;
		}
	}
	return TRUE;
}

/** Initializes the dot1dTpFdbTable module */
void
init_dot1dTpFdbTable(void)
{

    DEBUGMSGTL(("dot1dTpFdbTable", "Initializing\n"));

    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("dot1dTpFdbTable", dot1dTpFdbTable_variables, variable3,
               dot1dTpFdbTable_variables_oid);

    /* place any other initialization junk you need here */
}


/*
 * var_dot1dTpFdbTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *
var_dot1dTpFdbTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{
    UI32_T compc=0;
    oid compl[dot1dTpFdbEntry_INSTANCE_LEN];
    oid best_inst[dot1dTpFdbEntry_INSTANCE_LEN];
    AMTR_MGR_Dot1dTpFdbEntry_T data;

    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl, dot1dTpFdbEntry_INSTANCE_LEN);

     /*check compc, retrive compl*/
    if (exact)/*get,set*/
    {
        if (!dot1dTpFdbTable_get(compc, compl, &data))
            return NULL;
    }
    else/*getnext*/
    {
        if (!dot1dTpFdbTable_next(compc, compl, &data))
            return NULL;
    }
    memcpy(name, vp->name, vp->namelen*sizeof(oid));
    SNMP_MGR_BindOctetInstance(data.dot1d_tp_fdb_address, 0, 5, best_inst);

    memcpy(name + vp->namelen, best_inst, dot1dTpFdbEntry_INSTANCE_LEN*sizeof(oid));
    *length = vp->namelen +dot1dTpFdbEntry_INSTANCE_LEN;

    *var_len = sizeof(long_return);

    /*
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
    case DOT1DTPFDBADDRESS:
    {
        *var_len = 6;
        memcpy( return_buf, data.dot1d_tp_fdb_address, 6);
         return (u_char*)return_buf;
    }
    case DOT1DTPFDBPORT:
         long_return  = data.dot1d_tp_fdb_port;
        return (u_char*) &long_return;
    case DOT1DTPFDBSTATUS:
        long_return  = data.dot1d_tp_fdb_status;
        return (u_char*) &long_return;
    default:
      ERROR_MSG("");
    }
    return NULL;
}

/*
 * dot1dTpPortTable_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid dot1dTpPortTable_variables_oid[] = { 1,3,6,1,2,1,17,4 };

/*
 * variable4 dot1dTpPortTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */

struct variable3 dot1dTpPortTable_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */

#define DOT1DTPPORT		1
{DOT1DTPPORT,  ASN_INTEGER,  RONLY,   var_dot1dTpPortTable, 3,  { 4, 1, 1 }},
#define DOT1DTPPORTMAXINFO		2
{DOT1DTPPORTMAXINFO,  ASN_INTEGER,  RONLY,   var_dot1dTpPortTable, 3,  { 4, 1, 2 }},
#define DOT1DTPPORTINFRAMES		3
{DOT1DTPPORTINFRAMES,  ASN_COUNTER,  RONLY,   var_dot1dTpPortTable, 3,  { 4, 1, 3 }},
#define DOT1DTPPORTOUTFRAMES		4
{DOT1DTPPORTOUTFRAMES,  ASN_COUNTER,  RONLY,   var_dot1dTpPortTable, 3,  { 4, 1, 4 }},
#define DOT1DTPPORTINDISCARDS		5
{DOT1DTPPORTINDISCARDS,  ASN_COUNTER,  RONLY,   var_dot1dTpPortTable, 3,  { 4, 1, 5 }},
};
/*    (L = length of the oidsuffix) */


/** Initializes the dot1dTpPortTable module */
void
init_dot1dTpPortTable(void)
{

    DEBUGMSGTL(("dot1dTpPortTable", "Initializing\n"));

    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("dot1dTpPortTable", dot1dTpPortTable_variables, variable3,
               dot1dTpPortTable_variables_oid);

    /* place any other initialization junk you need here */
}


static int
header_dot1dTpPortTable(struct variable *vp,
               oid * name,
               size_t * length,
               int exact, size_t * var_len, WriteMethod ** write_method,
               NMTR_MGR_Dot1dTpPortEntry_T *entry)
{
     unsigned int ifIndex = 0;

    if(!entry || l_snmp_index_get(vp,name,length,&ifIndex,exact) < 0 )
      return MATCH_FAILED;

    entry->dot1d_tp_port = ifIndex;
    if(!exact)
     {
        if(NMTR_PMGR_GetNextDot1dTpPortEntry(entry)!=TRUE)
         return MATCH_FAILED;

        l_snmp_index_set(vp,name,length,entry->dot1d_tp_port);

     }
    else
    {
      if(NMTR_PMGR_GetDot1dTpPortEntry(entry)!=TRUE)
            return MATCH_FAILED;
    }


    *write_method = 0;
    *var_len = sizeof(long);    /* default to 'long' results */

    return entry->dot1d_tp_port;

}

/*
 * var_dot1dTpPortTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *
var_dot1dTpPortTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{


   NMTR_MGR_Dot1dTpPortEntry_T entry;

   memset( &entry, 0, sizeof(entry));
   if(MATCH_FAILED == header_dot1dTpPortTable(vp, name, length, exact, var_len, write_method,&entry))
       return NULL;

    /*
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
    case DOT1DTPPORT:
         long_return = entry.dot1d_tp_port;
        return (u_char *) & long_return;
    case DOT1DTPPORTMAXINFO:
         long_return = entry.dot1d_tp_port_max_info;
        return (u_char *) & long_return;
    case DOT1DTPPORTINFRAMES:
         long_return = entry.dot1d_tp_port_in_frames;
        return (u_char *) & long_return;
    case DOT1DTPPORTOUTFRAMES:
        long_return =entry.dot1d_tp_port_out_frames;
        return (u_char *) & long_return;
   case  DOT1DTPPORTINDISCARDS:
         long_return =entry.dot1d_tp_port_in_discards;
        return (u_char *) & long_return;
    default:
      ERROR_MSG("");
    }
    return NULL;
}

/*
 * dot1dStaticTable_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid dot1dStaticTable_variables_oid[] = { 1,3,6,1,2,1,17,5 };

WriteMethod  write_dot1dStaticAddress, write_dot1dStaticReceivePort, write_dot1dStaticAllowedToGoTo, write_dot1dStaticStatus;
/*
 * variable4 dot1dStaticTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */

struct variable3 dot1dStaticTable_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */

#define DOT1DSTATICADDRESS		1
{DOT1DSTATICADDRESS,  ASN_OCTET_STR,  RWRITE,  var_dot1dStaticTable, 3,  { 1, 1, 1 }},
#define DOT1DSTATICRECEIVEPORT		2
{DOT1DSTATICRECEIVEPORT,  ASN_INTEGER,  RWRITE,  var_dot1dStaticTable, 3,  { 1, 1, 2 }},
#define DOT1DSTATICALLOWEDTOGOTO		3
{DOT1DSTATICALLOWEDTOGOTO,  ASN_OCTET_STR,  RWRITE,  var_dot1dStaticTable, 3,  { 1, 1, 3 }},
#define DOT1DSTATICSTATUS		4
{DOT1DSTATICSTATUS,  ASN_INTEGER,  RWRITE,  var_dot1dStaticTable, 3,  { 1, 1, 4 }},
};
/*    (L = length of the oidsuffix) */


/** Initializes the dot1dStaticTable module */
void
init_dot1dStaticTable(void)
{

    DEBUGMSGTL(("dot1dStaticTable", "Initializing\n"));

    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("dot1dStaticTable", dot1dStaticTable_variables, variable3,
               dot1dStaticTable_variables_oid);

    /* place any other initialization junk you need here */
}

#define DOT1DSTATICENTRY_INSTANCE_LEN  7

BOOL_T dot1dStaticTable_oid_index_to_data(UI32_T exact, UI32_T compc,
            oid * compl ,AMTR_MGR_Dot1dStaticEntry_T *entry)
{
    UI32_T i;
    /* get or write
     */
    if(exact)
    {

        /* check the index length
         */
        if(compc != DOT1DSTATICENTRY_INSTANCE_LEN) /* the constant size index*/
        {
            return FALSE;
        }

    }

    /* assign the index to data
     */
    for( i=0;i< 6;i++)
    {
        entry->dot1d_static_address[i]=(UI8_T)compl[i];
    }
    entry->dot1d_static_receive_port=compl[6];

    return TRUE;
}

/*
 * var_dot1dStaticTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char *
var_dot1dStaticTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{
    /* variables we may use later */
    UI32_T compc=0;
    oid compl[DOT1DSTATICENTRY_INSTANCE_LEN];
    oid best_inst[DOT1DSTATICENTRY_INSTANCE_LEN];
    AMTR_MGR_Dot1dStaticEntry_T  entry;
    UI32_T i;

     /* Since may be row creation, we should specific the write function first, kinghong*/
 switch(vp->magic) {
    case DOT1DSTATICADDRESS:
        *write_method = write_dot1dStaticAddress;
        break;
    case DOT1DSTATICRECEIVEPORT:
        *write_method = write_dot1dStaticReceivePort;
        break;
    case DOT1DSTATICALLOWEDTOGOTO:
        *write_method = write_dot1dStaticAllowedToGoTo;
        break;
    case DOT1DSTATICSTATUS:
        *write_method = write_dot1dStaticStatus;
         break;
      }


    /*check compc, retrive compl*/
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,compl, DOT1DSTATICENTRY_INSTANCE_LEN);
    memset(&entry, 0, sizeof(entry));

    if (exact)/*get,set*/
    {

        if(dot1dStaticTable_oid_index_to_data(exact,compc,compl,&entry)==FALSE)
        {
            return NULL;
        }

        /*get data
         */
        if (AMTR_PMGR_GetDot1dStaticEntry( &entry)!=TRUE)
        {
            return NULL;
        }
    }
    else/*getnext*/
    {

        dot1dStaticTable_oid_index_to_data(exact,compc,compl,&entry);

        /* check the length of inputing index,if <1 we should try get {0.0.0.0.0...}
         */
        if (compc< DOT1DSTATICENTRY_INSTANCE_LEN)
        {

            if ( AMTR_PMGR_GetDot1dStaticEntry( &entry)!=TRUE)
            {

                /*get next data*/
                if ( AMTR_PMGR_GetNextDot1dStaticEntry(&entry)!=TRUE)
                {
                    return NULL;
                }
            }
        }
        else
        {

            /*get next data*/
            if ( AMTR_PMGR_GetNextDot1dStaticEntry(&entry)!=TRUE)
            {
                return NULL;
            }
        }
    }

    memcpy(name, vp->name, vp->namelen*sizeof(oid));
    /* assign data to the oid index
     */

    for( i=0;i< 6;i++)
    {
        best_inst[i]=entry.dot1d_static_address[i];
    }
    best_inst[6] = entry.dot1d_static_receive_port;
    memcpy(name + vp->namelen, best_inst, DOT1DSTATICENTRY_INSTANCE_LEN*sizeof(oid));
    *length = vp->namelen +DOT1DSTATICENTRY_INSTANCE_LEN;
    *var_len = sizeof(long_return);
    /*
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
    case DOT1DSTATICADDRESS:
         *var_len = 6;
         memcpy(return_buf, entry.dot1d_static_address, 6);
         return (u_char*) return_buf;
    case DOT1DSTATICRECEIVEPORT:
        long_return  = entry.dot1d_static_receive_port;
        return (u_char*) &long_return;
    case DOT1DSTATICALLOWEDTOGOTO:
          *var_len = SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST;
          memcpy(return_buf, entry.dot1d_static_allowed_to_go_to, *var_len);
        return (u_char*) return_buf;
    case DOT1DSTATICSTATUS:
          long_return  = entry.dot1d_static_status;
        return (u_char*) &long_return;
    default:
      ERROR_MSG("");
    }
    return NULL;
}

int
write_dot1dStaticAddress(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    int i;

     UI8_T   newAddress[6], oldAddress[6];

    if ((char) name[10] != DOT1DSTATICADDRESS)
     {
        return SNMP_ERR_NOTWRITABLE;
    }
    if (name_len!=  18)
    {
        return SNMP_ERR_WRONGLENGTH;
    }



    memcpy (newAddress, var_val,  6);


    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(char)*6) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:

           for (i = 0; i<6; i++)
           {
                 oldAddress[i] = (UI8_T)name[11+i];
           }

           if (AMTR_PMGR_SetDot1dStaticAddress(oldAddress, newAddress)!=TRUE)

              return SNMP_ERR_COMMITFAILED;

          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_dot1dStaticReceivePort(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    int i;
   UI32_T dot1dStaticReceivePort;
   UI8_T oldAddress[6];

    if ((char) name[10] != DOT1DSTATICRECEIVEPORT)
     {
        return SNMP_ERR_NOTWRITABLE;
    }
    if (name_len!=  18)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    dot1dStaticReceivePort = *(long *)var_val;


    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
              for (i = 0; i<6; i++)
              {
                 oldAddress[i] = (UI8_T)name[11+i];
              }

          if (AMTR_PMGR_SetDot1dStaticReceivePort(oldAddress,dot1dStaticReceivePort)!= TRUE)

              return SNMP_ERR_COMMITFAILED;
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_dot1dStaticAllowedToGoTo(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    int i;

     UI8_T  dot1dStaticAllowedToGoTo[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST];
     UI8_T oldAddress[6];

    if ((char) name[10] != DOT1DSTATICALLOWEDTOGOTO)
     {
        return SNMP_ERR_NOTWRITABLE;
    }
    if (name_len!=  18)
    {
        return SNMP_ERR_WRONGLENGTH;
    }


    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(char)*SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
                   memcpy(dot1dStaticAllowedToGoTo, var_val, var_val_len);
              for (i = var_val_len; i<SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST ; i ++)
                     dot1dStaticAllowedToGoTo[i] = 0;
              for (i = 0; i<6; i++)
              {
                 oldAddress[i] = (UI8_T)name[11+i];
              }
          if (AMTR_PMGR_SetDot1dStaticAllowedToGoTo(oldAddress,dot1dStaticAllowedToGoTo)!= TRUE)
              return SNMP_ERR_COMMITFAILED;
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_dot1dStaticStatus(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    int i;


    UI32_T dot1dStaticStatus;
   UI8_T oldAddress[6];

    if ((char) name[10] != DOT1DSTATICSTATUS)
     {
        return SNMP_ERR_NOTWRITABLE;
    }
    if (name_len!=  18)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    dot1dStaticStatus = *(long *)var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:

              if (dot1dStaticStatus == VAL_dot1dStaticStatus_other || dot1dStaticStatus > VAL_dot1dStaticStatus_deleteOnTimeout)
                  return SNMP_ERR_WRONGVALUE;

             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
              for ( i = 0; i<6; i++)
              {
                  oldAddress[i] = (UI8_T)name[11+i];
              }
              if (AMTR_PMGR_SetDot1dStaticStatus(oldAddress,dot1dStaticStatus)!= TRUE)
                   return SNMP_ERR_COMMITFAILED;
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
#endif
