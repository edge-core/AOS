/* Project Name: Mercury
 * Module Name : snmp_mgr.c
 * Abstract    : This file is used to change the operation in snmptask
 * Purpose     : to change the snmp opearion mode
 *
 * 2001/10/16    : James Chien     Create this file
 *
 * Copyright(C)      Accton Corporation, 1999, 2000
 *
 * Note    :
 */

/* INCLUDE FILE DECLARATIONS
 */

/* system
 */
#include "sys_type.h"
#include "sys_cpnt.h"
#include "sys_adpt.h"
#include "sys_bld.h"
#include "sys_dflt.h"
#include "sys_module.h"
#include "leaf_2576.h"
#include "leaf_3411.h"
#include "leaf_sys.h"
#include "leaf_2021.h"
#include "leaf_4001.h"

#if (SYS_CPNT_EFM_OAM == TRUE)
#include "leaf_4878.h"
#endif  /* #if (SYS_CPNT_EFM_OAM == TRUE) */

/* net-snmp-5.0.6 header file
 */
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/types.h>
#include <net-snmp/library/snmp_secmod.h>
#include <net-snmp/library/callback.h>
#include <net-snmp/library/transform_oids.h>
#include <net-snmp/library/snmpv3.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include <notification/snmpNotifyTable.h>
#include <notification/snmpNotifyFilterProfileTable.h>
#include <notification/snmpNotifyFilterTable.h>
#include <target/snmpTargetAddrEntry.h>
#include <target/snmpTargetParamsEntry.h>
#include "agent_callbacks.h"
#include "tools.h"
#include "snmpusm.h"
#include "vacm.h"
#include "snmpUDPDomain.h"
#include "vacm_vars.h"
#include "header_complex.h"
#include "history.h"
#include "transform_oids.h"
#include "snmp_agent.h"

#define USE_GALAXY_IPV6_SNMPAGENT 1
#if USE_GALAXY_IPV6_SNMPAGENT
#include "snmpUDPIPv6Domain.h"
#endif

#include "statistics.h"
#include "alarm.h"
#include "event.h"

/* common library
 */
#include <limits.h>
#include "sysfun.h"
#include "l_inet.h"
#include "l_stdlib.h"
#include "l_mm.h"
#include "l_ipcio.h"

/* CSC's
 */
#include "sys_pmgr.h"
#include "ip_lib.h"
#include "ipal_types.h"
#include "ipal_route.h"
#include "netcfg_type.h"
#include "stktplg_mgr.h"
#include "mib2_pmgr.h"
#include "swctrl_pom.h"

#if (SYS_CPNT_CLUSTER == TRUE)
#include "cluster_type.h"
#include "cluster_om.h"
#include "snmp_cluster.h"
#include "cluster_mgr.h"
#endif  /*end of #if(SYS_CPNT_CLUSTER == TRUE) */

#include "syslog_mgr.h"
#include "syslog_type.h"
#include "backdoor_mgr.h"
#include "cli_mgr.h"
#include "stktplg_pom.h"
#include "vlan_lib.h"
#include "syslog_pmgr.h"
#include "sys_time.h"

#if (SYS_CPNT_CFM == TRUE)
#include "cfm_type.h"
#endif  /* #if (SYS_CPNT_CFM == TRUE) */

#if (SYS_CPNT_CFGDB == TRUE)
#include "cfgdb_mgr.h"
#endif

#if (SYS_CPNT_EH == TRUE)
#include "eh_type.h"
#include "eh_mgr.h"
#include "syslog_mgr.h"
#include "sys_module.h"
#include "syslog_type.h"
#endif  /* end of #if (SYS_CPNT_EH == TRUE)*/

#include "if_pmgr.h"
#include "trk_lib.h"

#if (SYS_CPNT_SW_WATCHDOG_TIMER == TRUE)
#include "sw_watchdog_mgr.h"
#endif

/* SNMP itself
 */
#include "netsnmp_port.h"
#include "snmp_mgr.h"
#include "snmp_task.h"
#include "snmp_type.h"
#include "snmp_proc_comm.h"
#include "trap_mgr.h"
#include "trap_event.h"

#if (SYS_CPNT_NOTIFICATIONLOG_MIB == TRUE)
/* Notification Log MIB -- Meiling Hou 2008.04.15 */
#include "nlm_mgr.h"
#endif  /* #if (SYS_CPNT_NOTIFICATIONLOG_MIB == TRUE) */

#if (SYS_CPNT_BGP == TRUE)
#include "bgp_type.h"
#endif

#if(SYS_CPNT_SYNCE == TRUE)
#include "sync_e_type.h"
#endif

/*  declare variables used for Transition mode  */
SYSFUN_DECLARE_CSC;

/* NAMING CONSTANT DECLARARTIONS
 */
#define  TARGET_MAX_TAGS 8
#define SNMP_MGR_SPRINT_MAX_LEN 100

#if (SYS_CPNT_CFGDB == TRUE)
#if (SYS_CPNT_SNMP_COMMUNITY_IN_CFGDB == TRUE)
#define SNMP_MGR_CFGDB_SECTION_ID_SNMP_COMMUNITY    CFGDB_MGR_SECTION_ID_SNMP_1
#endif
#define SNMP_MGR_CFGDB_SECTION_ID_SNMPV3_ENGINE_INFO CFGDB_MGR_SECTION_ID_SNMP_2

#if (SYS_CPNT_SNMP_COMMUNITY_IN_CFGDB == TRUE)
#define SNMP_MGR_CFGDB_SECTION_ID_SNMPV3_USER        CFGDB_MGR_SECTION_ID_SNMP_3
#endif  /* end of #if (SYS_CPNT_SNMP_COMMUNITY_IN_CFGDB == TRUE) */

#endif /* end of #if (SYS_CPNT_CFGDB == TRUE)*/

#define TRAP_DEBUG_MODE_PRINT(fmt, args...)   \
    if (trap_debug_mode)             \
    {                                \
        printf(fmt, ##args);                 \
    }

#ifndef ASSERT
#define ASSERT(eq)
#endif /* ASSERT */

#if (SYS_CPNT_BGP == TRUE)
struct message
{
    int  key;
    char *str;
};

const char *
mes_lookup (const struct message *meslist, int max, int index, const char *none)
{
    int pos = index - meslist[0].key;

    /* first check for best case: index is in range and matches the key
     * value in that slot.
     * NB: key numbering might be offset from 0. E.g. protocol constants
     * often start at 1.
     */
    if ((pos >= 0) && (pos < max)
        && (meslist[pos].key == index))
        return meslist[pos].str;

    /* fall back to linear search */
    {
        int i;

        for (i = 0; i < max; i++, meslist++)
        {
            if (meslist->key == index)
            {
                const char *str = (meslist->str ? meslist->str : none);
                return str;
            }
        }
    }

    return none;
}
#define LOOKUP(x, y) mes_lookup(x, x ## _max, y, "(invalid)")

/* messages for BGP-4 status */
const struct message bgp_status_msg[] =
{
    { BGP_TYPE_STATUS_IDLE,         "Idle"          },
    { BGP_TYPE_STATUS_CONNECT,      "Connect"       },
    { BGP_TYPE_STATUS_ACTIVE,       "Active"        },
    { BGP_TYPE_STATUS_OPENSENT,     "OpenSent"      },
    { BGP_TYPE_STATUS_OPENCONFIRM,  "OpenConfirm"   },
    { BGP_TYPE_STATUS_ESTABLISHED,  "Established"   },
    { BGP_TYPE_STATUS_CLEARING,     "Clearing"      },
    { BGP_TYPE_STATUS_DELETED,      "Deleted"       },
};
const int bgp_status_msg_max = BGP_TYPE_STATUS_MAX;

#endif

#define SNMP_MGR_CHECK_OPER_MODE(RET_VAL)        \
    if (SYSFUN_GET_CSC_OPERATING_MODE() != SYS_TYPE_STACKING_MASTER_MODE)      \
    {  \
        return RET_VAL; \
    }

#define SNMP_MGR_CHECK_OPER_MODE_NO_RETURN()                               \
    if (SYSFUN_GET_CSC_OPERATING_MODE() != SYS_TYPE_STACKING_MASTER_MODE)  \
    {                                                                      \
        return;                                                            \
    }

/*------------------------------------------------------------------------
 * LOCAL VARIABLE DEFINITIONS
 *-----------------------------------------------------------------------*/
/* for patched netsnmp5.1 memory leak issue*/
static BOOL_T  snmp_mgr_patch_netsnmp_parse_err_flag= FALSE;

static BOOL_T  snmp_mgr_rmon_init_flag= FALSE;
static BOOL_T  snmp_mgr_netsnmp_init_flag=FALSE;
static UI32_T  snmp_mgr_sem_id;
static UI32_T  snmp_mgr_comm_count;
static UI32_T  snmp_mgr_user_count;
static UI32_T  snmp_mgr_security_to_group_count;
static UI32_T  snmp_mgr_group_count;
static UI32_T  snmp_mgr_view_count;
static UI32_T  snmp_mgr_target_addr_count;
static UI32_T  snmp_mgr_target_params_count;
static UI32_T  snmp_mgr_notify_count;
static UI32_T  snmp_mgr_notify_filter_profile_count;
static UI32_T  snmp_mgr_notify_filter_count;
static BOOL_T  snmp_mgr_agent_status = TRUE;
static SNMP_MGR_SnmpCommunityEntry_T  snmp_mgr_comm_entry[SYS_ADPT_MAX_NBR_OF_SNMP_COMMUNITY_STRING];
static SNMP_MGR_SnmpV3UserEntry_T  snmp_mgr_remote_user_entry[SNMP_MGR_MAX_NBR_OF_REMOTE_USER];
static SNMP_MGR_SnmpRemoteEngineID_T snmp_mgr_remote_engineID_entry[SNMP_MGR_MAX_NBR_OF_REMOTE_ENGINEID];
static BOOL_T boot_trap_is_sent=FALSE;

#if (SYS_CPNT_SNMP_COMMUNITY_IN_CFGDB == TRUE)
static SNMP_MGR_SnmpV3UserEntry_T snmp_mgr_v3_user_entry[SNMP_MGR_MAX_NBR_OF_SNMPV3_USER];
#endif

/* numeric-index table for trap receivers
 */
static SNMP_MGR_TrapDestByIndexEntry_T     snmp_mgr_trap_receiver[SYS_ADPT_MAX_NBR_OF_TRAP_RECEIVER];

#if (SYS_CPNT_SNMP_CONTIGUOUS_TRAP_DEST_TABLE == TRUE)
/* total number of occupied entries in the numeric-index table
 */
UI32_T snmp_mgr_trap_receiver_total = 0;
#endif


#if (SYS_CPNT_CFGDB == TRUE)
#if (SYS_CPNT_SNMP_COMMUNITY_IN_CFGDB == TRUE)
static BOOL_T   snmp_mgr_init_comm_for_cfgdb= FALSE;
static UI32_T   snmp_community_session_handler;
#endif
static UI32_T   snmp_mgr_engine_info_session_handler;

#if (SYS_CPNT_SNMP_COMMUNITY_IN_CFGDB == TRUE)
static UI32_T   snmp_mgr_v3_user_session_handler;
#endif

static SNMP_MGR_SnmpEngineInfo_T snmp_mgr_engine_info;
static UI8_T    snmp_default_engine_id[MAXSIZE_snmpEngineID];
static UI32_T   snmp_default_engine_id_len;
#endif /* end of #if (SYS_CPNT_CFGDB == TRUE) */

#if (SYS_CPNT_SNMPV3_DEFAULT_USER == TRUE)
static SNMP_MGR_SnmpV3UserEntry_T defaultuser1;
static SNMP_MGR_SnmpV3UserEntry_T defaultuser2;

#if (SYS_CPNT_USERAUTH_MANAGER_STYLE == SYS_CPNT_USERAUTH_MANAGER_STYLE_3COM)
static SNMP_MGR_SnmpV3UserEntry_T defaultuser3;
#endif
#endif

#if (SYS_CPNT_DBSYNC_TXT == TRUE)
/* for 3 com autosave*/
static BOOL_T snmp_mgr_tmp_dirty=FALSE;
#endif

/*for snmp backdoor*/
static BOOL_T       debug_mode=FALSE, EHMsgEnable=FALSE, trap_debug_mode = FALSE;
/* LOCAL FUNCTION DECLARATIONS
 */
static void SNMP_MGR_InitNetSnmpAgent();
static void SNMP_MGR_InitDefaultSetting();
static void SNMP_MGR_InitUsmUserEntry();
static void SNMP_MGR_InitVacmSecurityToGroupEntry();
static void SNMP_MGR_InitVacmAccessEntry();
static void SNMP_MGR_InitVacmViewTreeFamilyEntry();
static void SNMP_MGR_InitSnmpCommunityEntry();
static void SNMP_MGR_InitSnmpTargetAddrEntry();
static void SNMP_MGR_InitSnmpTargetParamsEntry();
static void SNMP_MGR_InitSnmpNotifyEntry();
static void SNMP_MGR_InitSnmpNotifyFilterEntry();
static void SNMP_MGR_InitSnmpNotifyFilterProfileEntry();
static BOOL_T SNMP_MGR_sOidToiOid(char *sOid, oid *iOid, int *lenOid);

static BOOL_T SNMP_MGR_initSysObjectID(void);

static BOOL_T SNMP_MGR_OidCpy(oid *Oid1, UI32_T lenOid1, oid *Oid2, UI32_T lenOid2);
static BOOL_T SNMP_MGR_initTrapEs3626a(void);

static BOOL_T SNMP_MGR_ObjectIDToString(oid *oid_P,  I8_T *text_p, UI32_T obj_length);
static UI32_T SNMP_MGR_AtoUl(char *s, int radix);
static BOOL_T CONVERT_BinaryStrTo32BitValue(char *str, UI32_T *value);
static BOOL_T SNMP_MGR_Transform_TreeToWildCard(UI8_T  *wildcard,   UI8_T *subtree,  UI8_T *mask, UI32_T SubtreeLen);
static BOOL_T SNMP_MGR_Transform_ViewWildcardToTree(char  *wildcard,   char *subtree,  char *mask);
static UI32_T SNMP_MGR_DeleteSecurityToGroupEntry(SNMP_MGR_Snmpv3_Model_T  security_model, char *snmpv3_user_name);
static UI32_T SNMP_MGR_DeleteUsmUserEntry( char * snmpv3_user_name);
static UI32_T SNMP_MGR_GetSecurityToGroupTable( SNMP_MGR_SnmpV3UserEntry_T  *entry);
static UI32_T SNMP_MGR_InsertCom2SecList(const char *security_name_p, const char *community_p, SNMP_MGR_Snmp_Comm_Access_Right_T access_right);
static void   SNMP_MGR_DeleteCom2SecList(const char *community_p);
static UI32_T SNMP_MGR_GetUsmUserEntry( SNMP_MGR_SnmpV3UserEntry_T  *entry);
static UI32_T SNMP_MGR_CheckSecurityToGroupTable( SNMP_MGR_SnmpV3UserEntry_T  *entry);
static UI32_T SNMP_MGR_CheckSnmpCommunity(SNMP_MGR_SnmpCommunity_T *comm_entry);
static int    SNMP_MGR_CompareTrapEntryAddr(SNMP_MGR_TrapDestEntry_T *elem1, SNMP_MGR_TrapDestEntry_T *elem2);
static void   SNMP_MGR_CheckDefaultCommunityView();
//static void   SNMP_MGR_CheckAndCreateDefaultCommunityGroup();
static UI32_T SNMP_MGR_CheckGroupExist( SNMP_MGR_SnmpV3GroupEntry_T  *entry);
static UI32_T SNMP_MGR_CheckViewExist(SNMP_MGR_SnmpV3ViewEntry_T  *entry);
static UI32_T SNMP_MGR_DeleteAllSnmpV3User();
static BOOL_T SNMP_MGR_CheckValidOIDSring(UI8_T *text_P);
static UI32_T SNMP_MGR_DeleteTargetTrapReceiverDB( L_INET_AddrIp_T *ip_addr);
static UI32_T SNMP_MGR_CreateTargetTrapReceiverDB(UI32_T snmp_index, SNMP_MGR_TrapDestEntry_T *entry);
static void   SNMP_MGR_VerifyAndDeleteProbeConfigDB(void);
static UI32_T SNMP_MGR_CreateProbeConfigTrapReceiverDB(L_INET_AddrIp_T *address, UI32_T port);
static BOOL_T SNMP_MGR_IsProbeConfigTrapReceiverDBExist(L_INET_AddrIp_T *address);
static BOOL_T SNMP_MGR_GetDefaultIpAddress(L_INET_AddrIp_T *ip);

static UI32_T SNMP_MGR_CreateSnmpV3User(SNMP_MGR_SnmpV3UserEntry_T *entry, BOOL_T is_auto_create);
static UI32_T SNMP_MGR_CreateSnmpV3Group(SNMP_MGR_SnmpV3GroupEntry_T *entry, BOOL_T is_auto_create);

/* implentation of target MIB and Notify MIB*/
static UI32_T SNMP_MGR_CreateSnmpTargetParamsTable(SNMP_MGR_SnmpTargetParamsEntry_T *entry);
static UI32_T SNMP_MGR_GetSnmpTargetParamsTable(SNMP_MGR_SnmpTargetParamsEntry_T *entry);
static UI32_T SNMP_MGR_GetNextSnmpTargetParamsTable(SNMP_MGR_SnmpTargetParamsEntry_T *entry);
static UI32_T SNMP_MGR_DeleteSnmpTargetParamsTable(char  *snmp_target_params_name);
static UI32_T SNMP_MGR_CreateSnmpTargetAddrTable(SNMP_MGR_SnmpTargetAddrEntry_T *entry);

#if (SYS_CPNT_NOTIFICATIONLOG_MIB == TRUE)
/* Notification Log MIB -- Meiling Hou 2008.04.15 */
UI32_T SNMP_MGR_GetSnmpTargetAddrTable(SNMP_MGR_SnmpTargetAddrEntry_T *entry);
#else
static UI32_T SNMP_MGR_GetSnmpTargetAddrTable(SNMP_MGR_SnmpTargetAddrEntry_T *entry);
#endif

static UI32_T SNMP_MGR_DeleteSnmpTargetAddrTable(char *entry);
static UI32_T SNMP_MGR_CreateSnmpNotifyTable(SNMP_MGR_SnmpNotifyEntry_T *entry);
static UI32_T SNMP_MGR_GetSnmpNotifyTable(SNMP_MGR_SnmpNotifyEntry_T *entry);
static UI32_T SNMP_MGR_GetNextSnmpNotifyTable(SNMP_MGR_SnmpNotifyEntry_T *entry);
static UI32_T SNMP_MGR_DeleteSnmpNotifyTable( UI8_T  *snmp_notify_name);
static UI32_T SNMP_MGR_ModifySnmpCommunityStatus(char *comm_string_name, UI32_T status);
static UI32_T SNMP_MGR_DeleteSnmpNotifyFilterProfileTable(SNMP_MGR_SnmpNotifyFilterProfileEntry_T *entry);
static UI32_T SNMP_MGR_GetNextSnmpNotifyFilterProfileTable(SNMP_MGR_SnmpNotifyFilterProfileEntry_T *entry);
static UI32_T SNMP_MGR_GetSnmpNotifyFilterProfileTable(SNMP_MGR_SnmpNotifyFilterProfileEntry_T *entry);
static UI32_T SNMP_MGR_CreateSnmpNotifyFilterProfileTable(SNMP_MGR_SnmpNotifyFilterProfileEntry_T *entry);
static UI32_T SNMP_MGR_DeleteSnmpNotifyFilterTable( char  *snmp_notify_filter_profile_name, oid *snmp_notify_filter_subtree, UI32_T snmp_notify_filter_subtree_len);
static UI32_T SNMP_MGR_GetNextSnmpNotifyFilterTable(SNMP_MGR_SnmpNotifyFilterEntry_T *entry);

static BOOL_T SNMP_MGR_GetRmonAlarmTable(SNMP_MGR_RmonAlarmEntry_T *entry_p);
static BOOL_T SNMP_MGR_GetNextRmonAlarmTable(SNMP_MGR_RmonAlarmEntry_T *entry_p);
static BOOL_T SNMP_MGR_CreateRmonAlarmEntry(SNMP_MGR_RmonAlarmEntry_T *entry_p);
static BOOL_T SNMP_MGR_DeleteRmonAlarmEntry(UI32_T index);
static BOOL_T SNMP_MGR_ModifyRmonAlarmEntry(SNMP_MGR_RmonAlarmEntry_T *entry_p);
static UI32_T SNMP_MGR_GetNextRunningRmonAlarmTable(SNMP_MGR_RmonAlarmEntry_T *entry_p);
static UI32_T SNMP_MGR_GetNextRunningRmonAlarmDeletedDefaultEntry(SNMP_MGR_RmonAlarmEntry_T *entry_p);

static BOOL_T SNMP_MGR_GetRmonEventTable(SNMP_MGR_RmonEventEntry_T *entry_p);
static BOOL_T SNMP_MGR_GetNextRmonEventTable(SNMP_MGR_RmonEventEntry_T *entry_p);
static BOOL_T SNMP_MGR_CreateRmonEventEntry(SNMP_MGR_RmonEventEntry_T *entry_p);
static BOOL_T SNMP_MGR_DeleteRmonEventEntry(UI32_T index);
static BOOL_T SNMP_MGR_ModifyRmonEventEntry(SNMP_MGR_RmonEventEntry_T *entry_p);
static UI32_T SNMP_MGR_GetNextRunningRmonEventTable(SNMP_MGR_RmonEventEntry_T *entry_p);

static BOOL_T SNMP_MGR_GetRmonStatisticsTable(SNMP_MGR_RmonStatisticsEntry_T *entry_p);
static BOOL_T SNMP_MGR_GetNextRmonStatisticsTable(SNMP_MGR_RmonStatisticsEntry_T *entry_p);
static BOOL_T SNMP_MGR_GetNextRmonStatisticsTableByLport(UI32_T lport, SNMP_MGR_RmonStatisticsEntry_T *entry_p);
static BOOL_T SNMP_MGR_CreateRmonStatisticsEntry(SNMP_MGR_RmonStatisticsEntry_T *entry_p);
static BOOL_T SNMP_MGR_DeleteRmonStatisticsEntryByLport(UI32_T if_index, UI32_T index);
static BOOL_T SNMP_MGR_ModifyRmonStatisticsEntry(SNMP_MGR_RmonStatisticsEntry_T *entry_p);
static UI32_T SNMP_MGR_GetNextRunningRmonStatisticsTableByLport(UI32_T lport, SNMP_MGR_RmonStatisticsEntry_T *entry_p);
static UI32_T SNMP_MGR_GetNextRunningRmonStatisticsDeletedDefaultEntryByLport(UI32_T lport, SNMP_MGR_RmonStatisticsEntry_T *entry_p);

static BOOL_T SNMP_MGR_GetRmonHistoryControlTable(SNMP_MGR_RmonHistoryControlEntry_T *entry_p);
static BOOL_T SNMP_MGR_GetNextRmonHistoryControlTable(SNMP_MGR_RmonHistoryControlEntry_T *entry_p);
static BOOL_T SNMP_MGR_GetNextRmonHistoryControlTableByLport(UI32_T lport, SNMP_MGR_RmonHistoryControlEntry_T *entry_p);
static BOOL_T SNMP_MGR_CreateRmonHistoryControlEntry(SNMP_MGR_RmonHistoryControlEntry_T *entry_p);
static BOOL_T SNMP_MGR_DeleteRmonHistoryControlEntryByLport(UI32_T if_index, UI32_T index);
static BOOL_T SNMP_MGR_ModifyRmonHistoryControlEntry(SNMP_MGR_RmonHistoryControlEntry_T *entry_p);
static UI32_T SNMP_MGR_GetNextRunningRmonHistoryControlTableByLport(UI32_T lport, SNMP_MGR_RmonHistoryControlEntry_T *entry_p);
static UI32_T SNMP_MGR_GetNextRunningRmonHistoryControlDeletedDefaultEntryByLport(UI32_T lport, SNMP_MGR_RmonHistoryControlEntry_T *entry_p);
static BOOL_T SNMP_MGR_GetNextRmonHistoryTableByControlIndex(SNMP_MGR_RmonHistoryEntry_T *entry_p);

static UI32_T SNMP_MGR_GetSnmpNotifyFilterTable(SNMP_MGR_SnmpNotifyFilterEntry_T *entry);
static UI32_T SNMP_MGR_CreateSnmpNotifyFilterTable(SNMP_MGR_SnmpNotifyFilterEntry_T *entry);
static UI32_T SNMP_MGR_AppendNotifyView(SNMP_MGR_SnmpV3GroupEntry_T *group_entry);
static UI32_T SNMP_MGR_DeleteUsmUserEntryWithEngineID(UI8_T *engineID, UI32_T engineID_len, UI8_T * snmpv3_user_name);
static void   SNMP_MGR_InitSnmpRemoteEngineIDEntry();
static void   SNMP_MGR_InitSnmpRemoteUserEntry();

/* implentation of Community MIB.*/
static UI32_T SNMP_MGR_CreateSnmpCommunityEntry(SNMP_MGR_SnmpCommunityEntry_T *entry);

#if (SYS_CPNT_CFGDB == TRUE)
#if (SYS_CPNT_SNMP_COMMUNITY_IN_CFGDB == TRUE)
static void SNMP_MGR_InitSnmpCommunityFromCfgDB();
#endif
static void SNMP_MGR_InitSnmpEngineBoot();
#endif

static UI32_T SNMP_MGR_SendEventToSnmpTask(UI32_T event);
static BOOL_T SNMP_MGR_HasRouteToTrapServer();

#if (SYS_CPNT_CLUSTER == TRUE)
static BOOL_T SNMP_MGR_HasRouteToClusterCommander();
#endif /* #if (SYS_CPNT_CLUSTER == TRUE) */

static BOOL_T SNMP_MGR_IsNotifyFilterAllowToSendTrap(char *targetparamsname, oid *trap_oid, UI32_T trap_oid_len);
static BOOL_T SNMP_MGR_IsVacmOrUsmAllowToSendTrap(netsnmp_session *sess, oid *trap_oid, UI32_T trap_oid_len, UI32_T pdu_type);

static BOOL_T SNMP_MGR_IsAutoDestroyUser(char *username_p);
static BOOL_T SNMP_MGR_IsAutoDestroySecurityToGroup(SNMP_MGR_Snmpv3_Model_T security_model, char *security_name_p);
static BOOL_T SNMP_MGR_IsAutoDestroyAccess(char *group_name_p, SNMP_MGR_Snmpv3_Model_T group_model, UI32_T group_security_level);
static BOOL_T SNMP_MGR_IsCommunitySharedByTrapReceiver(char *community_p, SNMP_MGR_Snmpv3_Model_T version, L_INET_AddrIp_T *skip_ip_address);
static BOOL_T SNMP_MGR_ConvertTAddressToLinetAddr(char *tAddr, L_INET_AddrIp_T *ip_addr, UI16_T addr_len);
static BOOL_T SNMP_MGR_GetIpandPortfromTaddress(SNMP_MGR_SnmpTargetAddrEntry_T target_addr_entry, L_INET_AddrIp_T  *ipaddr, UI16_T *udp_port_p);
static BOOL_T SNMP_MGR_SetIpandPort2Taddress(L_INET_AddrIp_T  ip_addr, UI16_T port, SNMP_MGR_SnmpTargetAddrEntry_T *target_addr_entry);

/* added for Snmpv3 AES authentication
 */
static BOOL_T
SNMP_MGR_Extend_PrviKey(
    const oid * authProtocol,
    size_t authProtocol_len,
    UI32_T priv_type,
    UI8_T *engine_id_p,
    UI32_T engineIDLen,
    UI8_T *org_privkey_p,
    size_t org_privkey_len,
    size_t extended_len,
    UI8_T  *new_privkey_p,
    size_t *new_privkey_len
    );

/*-------------------------------------------------------------------------
 * FUNCTION NAME - SNMP_MGR_IsValidTrapReceiverIp
 *-------------------------------------------------------------------------
 * PURPOSE  : check receiver IP address is valid or not
 * INPUT    : ip_p -- IP address
 * OUTPUT   : None
 * RETUEN   : TRUE/FALSE
 * NOTES    : Not support L_INET_ADDR_TYPE_IPV4Z
 * ------------------------------------------------------------------------
 */
static BOOL_T
SNMP_MGR_IsValidTrapReceiverIp(
    const L_INET_AddrIp_T *ip_p
);

/*-------------------------------------------------------------------------
 * FUNCTION NAME - SNMP_MGR_LocalGetSecurityName
 *-------------------------------------------------------------------------
 * PURPOSE  : Get security name from snmpCommunityTable or usmUserTable
 * INPUT    : version           -- SNMP version
 *            user_name_p       -- user name
 *            cb_security_name  -- Count of bytes of security name
 * OUTPUT   : security_name_p   -- security name
 * RETUEN   : SNMP_MGR_ERROR_OK/SNMP_MGR_ERROR_FAIL
 * NOTES    : None
 * ------------------------------------------------------------------------
 */
static UI32_T
SNMP_MGR_LocalGetSecurityName(
    SNMP_MGR_Snmpv3_Model_T version,
    char *user_name_p,
    char *security_name_p,
    UI32_T cb_security_name
);

/*-------------------------------------------------------------------------
 * FUNCTION NAME - SNMP_MGR_LocalAutoCreateUserByVersion
 *-------------------------------------------------------------------------
 * PURPOSE  : Auto create user by version
 * INPUT    : version           -- SNMP version
 *            user_name_p       -- user name
 *            security_name_p   -- security name
 * OUTPUT   : None
 * RETUEN   : SNMP_MGR_ERROR_OK/SNMP_MGR_ERROR_FAIL
 * NOTES    : None
 * ------------------------------------------------------------------------
 */
static UI32_T
SNMP_MGR_LocalAutoCreateUserByVersion(
    SNMP_MGR_Snmpv3_Model_T version,
    char *user_name_p,
    char *security_name_p
);

/*-------------------------------------------------------------------------
 * FUNCTION NAME - SNMP_MGR_LocalIsAutoDestroyUserByVersion
 *-------------------------------------------------------------------------
 * PURPOSE  : Check the user need to be destroyed automatically or not by version
 * INPUT    : version           -- SNMP version
 *            user_name_p       -- user name
 * OUTPUT   : None
 * RETUEN   : TRUE/FALSE
 * NOTES    : None
 * ------------------------------------------------------------------------
 */
static UI32_T
SNMP_MGR_LocalIsAutoDestroyUserByVersion(
    SNMP_MGR_Snmpv3_Model_T version,
    char *user_name_p
);

/*---------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_LocalIsUserSharedByTrapReceiver
 *---------------------------------------------------------------------------
 * PURPOSE : The function will check the user is shared by any trap
 *           receiver or not.
 * INPUT   : user_name_p        -- user name
 *           skip_ip_p          -- skip IP address
 * OUTPUT  : None.
 * RETURN  : TRUE/FALSE
 * NOTE    : If skip_ip_address is zero, it will check all trap receivers.
 *           Or, it will skip the trap receiver whose IP address is same as this
 *           IP address.
 *---------------------------------------------------------------------------
 */
static BOOL_T
SNMP_MGR_LocalIsUserSharedByTrapReceiver(
    char *user_name_p,
    L_INET_AddrIp_T *skip_ip_p
);

/*---------------------------------------------------------------------------
* ROUTINE NAME - SNMP_MGR_LocalIsSecurityToGroupSharedByTrapReceiver
*---------------------------------------------------------------------------
* PURPOSE : The function will check the vacmSecurityToGroupTable is shared by any trap
*           receiver or not.
* INPUT   : version            -- SNMP version
*           security_name_p    -- security name
*           skip_ip_p          -- skip IP address
* OUTPUT  : None.
* RETURN  : TRUE/FALSE
* NOTE    : If skip_ip_address is zero, it will check all trap receivers.
*           Or, it will skip the trap receiver whose IP address is same as this
*           IP address.
*---------------------------------------------------------------------------
*/
static BOOL_T
SNMP_MGR_LocalIsSecurityToGroupSharedByTrapReceiver(
    SNMP_MGR_Snmpv3_Model_T version,
    char *security_name_p,
    L_INET_AddrIp_T *skip_ip_p
);

/*---------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_LocalIsAccessSharedByTrapReceiver
 *---------------------------------------------------------------------------
 * PURPOSE : The function will check the access is shared by any trap
 *           receiver or not.
 * INPUT   : version            -- SNMP version
 *           access_name_p      -- Access name
 *           skip_ip_p          -- skip IP address
 * OUTPUT  : None.
 * RETURN  : TRUE/FALSE
 * NOTE    : If skip_ip_address is zero, it will check all trap receivers.
 *           Or, it will skip the trap receiver whose IP address is same as this
 *           IP address.
 *---------------------------------------------------------------------------
 */
static BOOL_T
SNMP_MGR_LocalIsAccessSharedByTrapReceiver(
    SNMP_MGR_Snmpv3_Model_T version, char *access_name_p,
    L_INET_AddrIp_T *skip_ip_p);

/*---------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_LocalIsAccessSharedByCommunity
 *---------------------------------------------------------------------------
 * PURPOSE : The function will check the access is shared by any community
 *           receiver or not.
 * INPUT   : version        -- Version
 *           security_level -- Security level
 *           access_name_p  -- Access name
 * OUTPUT  : None.
 * RETURN  : TRUE/FALSE
 * NOTE    : None.
 *---------------------------------------------------------------------------
 */
static BOOL_T
SNMP_MGR_LocalIsAccessSharedByCommunity(
    SNMP_MGR_Snmpv3_Model_T version,
    UI32_T security_level,
    char *access_name_p);

/* ---------------------------------------------------------------------
 * ROUTINE NAME  - SNMP_MGR_GetAccessRightOfCommunity2SecurityEntry
 * ---------------------------------------------------------------------
 * PURPOSE: This function is used to get access right of the specified
 *          community to security entry.
 * INPUT:   com2SecEntry - The community to security entry.
 * OUTPUT:  access_right - SNMP_MGR_ACCESS_RIGHT_GROUP_SPECIFIC
 *                        SNMP_MGR_ACCESS_RIGHT_READ_ONLY
 *                        SNMP_MGR_ACCESS_RIGHT_READ_WRITE
 * RETURN:  1. success:   SNMP_MGR_ERROR_OK
 *          2. failure:   SNMP_MGR_ERROR_FAIL
 * NOTES:
 * ---------------------------------------------------------------------
 */
static UI32_T SNMP_MGR_GetAccessRightOfCommunity2SecurityEntry(struct _com2SecEntry *com2SecEntry, SNMP_MGR_Snmp_Comm_Access_Right_T *access_right);

/*--------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_DeleteAccess
 *---------------------------------------------------------------------------
 * PURPOSE: This function will delete a SNMP V3 access.
 * INPUT:   access_name_p, security_model, security_level
 * OUTPUT:  None.
 * RETURN:  1. success:    SNMP_MGR_ERROR_OK
 *          2. failure:    SNMP_MGR_ERROR_FAIL
 * NOTE:    None.
 *---------------------------------------------------------------------------
 */
static UI32_T SNMP_MGR_DeleteAccess(char *access_name_p, UI8_T security_model, UI8_T security_level);

/*--------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_ClearAccessNotifyView
 *---------------------------------------------------------------------------
 * PURPOSE: This function will clear notify view of the SNMP V3 access.
 * INPUT:   access_name_p, security_model, security_level
 * OUTPUT:  None.
 * RETURN:  1. success:    SNMP_MGR_ERROR_OK
 *          2. failure:    SNMP_MGR_ERROR_FAIL
 * NOTE:    None.
 *---------------------------------------------------------------------------
 */
static UI32_T SNMP_MGR_ClearAccessNotifyView(char *access_name_p, UI8_T security_model, UI8_T security_level);

/*for snmp backdoor*/
//static  void   SNMP_MGR_BackdoorInfo_CallBack(void);
//static void SNMP_MGR_Print_BackdoorHelp(void);


/* The below is portted form trap_mgr.c, where in SNMPV3 agent, trap need to
 * portted in.
 */

/* NAMING CONSTANT DECLARATIONS
 */
#define SNMP_MGR_FUNCTION_NUMBER            1
#define SNMP_MGR_ERROR_NUMBER               1
#define SNMP_MGR_MAX_QUE_CNT                (SYS_ADPT_TOTAL_NBR_OF_LPORT * 2 + SYS_ADPT_MAX_NBR_OF_VLAN)
#define SNMP_MGR_EVENT_TRAP_ARRIVAL         BIT_0
#define SNMP_MGR_EVENT_ENTER_TRANSITION     BIT_1
#define SNMP_MGR_EVENT_STA_STATE_CHANGED    BIT_2
#define SNMP_MGR_EVENT_RIF_UP               BIT_3
#define SNMP_MGR_EVENT_RIF_DOWN             BIT_4
#define SNMP_MGR_NUMBER_OF_GENERIC_TRAP     10
#define SNMP_MGR_MAX_INDIVIDUAL_EVENT       32
//#define SNMP_MGR_MAX_SEND_TRAP_RETRY_TIMES   10
#define SNMP_MGR_DEFAULT_COMMUNITY  "public"

/* here we define the trap oid for non-private trap*/
static oid      snmp_mgr_cold_start_oid[] = { 1, 3, 6, 1, 6, 3, 1, 1, 5, 1 };   /* SNMPv2-MIB */
static UI32_T   len_snmp_mgr_cold_start_oid = OID_LENGTH(snmp_mgr_cold_start_oid);
static oid      snmp_mgr_warm_start_oid[] = { 1, 3, 6, 1, 6, 3, 1, 1, 5, 2 };   /* SNMPv2-MIB */
static UI32_T   len_snmp_mgr_warm_start_oid = OID_LENGTH(snmp_mgr_warm_start_oid);
static oid      snmp_mgr_link_down_oid[] = { 1, 3, 6, 1, 6, 3, 1, 1, 5, 3 };    /* IF-MIB */
static UI32_T   len_snmp_mgr_link_down_oid = OID_LENGTH(snmp_mgr_link_down_oid);
static oid      snmp_mgr_link_up_oid[] = { 1, 3, 6, 1, 6, 3, 1, 1, 5, 4 };      /* IF-MIB */
static UI32_T   len_snmp_mgr_link_up_oid = OID_LENGTH(snmp_mgr_link_up_oid);
static oid      snmp_mgr_auth_fail_oid[] = { 1, 3, 6, 1, 6, 3, 1, 1, 5, 5 };    /* SNMPv2-MIB */
static UI32_T   len_snmp_mgr_auth_fail_oid = OID_LENGTH(snmp_mgr_auth_fail_oid);

static oid      snmp_mgr_bridge_mib_oid[] = { 1, 3, 6, 1, 2, 1, 17 };
static UI32_T   len_snmp_mgr_bridge_mib_oid = OID_LENGTH(snmp_mgr_bridge_mib_oid);
static oid      snmp_mgr_rmon_mib_oid[] = { 1, 3, 6, 1, 2, 1, 16 };
static UI32_T   len_snmp_mgr_rmon_mib_oid = OID_LENGTH(snmp_mgr_rmon_mib_oid);

#if (SYS_CPNT_LLDP == TRUE)
static oid      snmp_mgr_lldp_mib_oid[] = { 1, 0, 8802, 1, 1, 2, 0 };
static UI32_T   len_snmp_mgr_lldp_mib_oid = OID_LENGTH(snmp_mgr_lldp_mib_oid);
#endif /* #if (SYS_CPNT_LLDP == TRUE) */

#if 0
#if (SYS_CPNT_LLDP_MED == TRUE)
static oid     snmp_mgr_lldp_med_topology_change_oid[] ={1,0,8802,1,1,2,1,5,4795,0,1};
static UI32_T  len_snmp_mgr_lldp_med_topology_change_oid = OID_LENGTH(snmp_mgr_lldp_med_topology_change_oid);
#endif
#endif

#if (SYS_CPNT_LLDP_MED == TRUE)
static oid ID_lldpRemChassisIdSubtype[] = { 1, 0, 8802, 1, 1, 2, 1, 4, 1, 1, 4, 0, 0, 0} ;
static int len_lldpRemChassisIdSubtype = 11;
static oid ID_lldpRemChassisId[] = { 1, 0, 8802, 1, 1, 2, 1, 4, 1, 1, 5, 0, 0, 0} ;
static int len_lldpRemChassisId = 11;
static oid ID_lldpMedRemDeviceClass[] = { 1, 0, 8802, 1, 1, 2, 1, 5, 4795, 1, 3, 1, 1, 3, 0, 0, 0} ;
static int len_lldpMedRemDeviceClass = 14;
#endif

#if (SYS_CPNT_EFM_OAM == TRUE)
static oid      snmp_mgr_dot3_oam_mib_oid[] = { 1, 3, 6, 1, 2, 1, 158 };
static UI32_T   len_snmp_mgr_dot3_oam_mib_oid = OID_LENGTH(snmp_mgr_dot3_oam_mib_oid);
#endif /* #if (SYS_CPNT_EFM_OAM == TRUE) */

#if (SYS_CPNT_CFM == TRUE)
static oid      snmp_mgr_cfm_mib_oid[] = { 1, 3, 111, 2, 802, 1, 1, 8 };  /* { 1, 0, 8802, 1, 1, 3 }; */
static UI32_T   len_snmp_mgr_cfm_mib_oid = OID_LENGTH(snmp_mgr_cfm_mib_oid);
#endif /* #if (SYS_CPNT_CFM == TRUE) */

#if (SYS_CPNT_POE == TRUE)
/* RFC 3621, Power Ethernet */
static oid      snmp_mgr_poe_mib_oid[] = { 1, 3, 6, 1, 2, 1, 105 };
static UI32_T   len_snmp_mgr_poe_mib_oid = OID_LENGTH(snmp_mgr_poe_mib_oid);
#endif /* #if (SYS_CPNT_POE == TRUE) */

#if (SYS_CPNT_LLDP_MED == TRUE)
static oid     snmp_mgr_lldp_med_mib_oid[] ={ 1, 0, 8802, 1, 1, 2, 1, 5, 4795 };
static UI32_T  len_snmp_mgr_lldp_med_mib_oid = OID_LENGTH(snmp_mgr_lldp_med_mib_oid);
#endif /* #if (SYS_CPNT_LLDP_MED == TRUE) */

#if (SYS_CPNT_BGP == TRUE)
/* RFC 4273, The MIB module for the BGP-4 protocol */
static oid      snmp_mgr_bgp_mib_oid[] = { 1, 3, 6, 1, 2, 1, 15};
static UI32_T   len_snmp_mgr_bgp_mib_oid = OID_LENGTH(snmp_mgr_bgp_mib_oid);
#endif

/* enterprise value for Six Early Traps: coldStart, linkUp, etc.
 */
static oid ID_sysObjectID_value[SYS_ADPT_MAX_OID_COUNT];
static int len_sysObjectID_value;

/* below define the variable binding list's oid*/

/*
 * Rfc1215 StandTrap
 */

/* cold start */
/* total binding variables = 0*/

/* warm start */
/* total binding variables = 0*/

/* link down, link up */
/* total binding variables = 3*/

static oid ID_ifIndex[] = { 1, 3, 6, 1, 2, 1, 2, 2, 1, 1, 0 };
static int len_ifIndex = 10;

static oid ID_ifAdminStatus[] = { 1, 3, 6, 1, 2, 1, 2, 2, 1, 7, 0 };
static int len_ifAdminStatus = 10;

static oid ID_ifOperStatus[] = { 1, 3, 6, 1, 2, 1, 2, 2, 1, 8, 0 };
static int len_ifOperStatus = 10;

/* authentication failure*/
/* total binding variables = 0*/

/*
 * Rfc1493 Bridge MIB Trap
 */

/* new root */
/* total binding variables = 0*/

/* topology change*/
/* total binding variables = 0*/

/*
 * Rfc2819 RMON Trap
 */

/* rising alarm, falling alarm*/
/* total binding variables = 5*/

static oid ID_alarmIndex[] = { 1, 3, 6, 1, 2, 1, 16, 3, 1, 1, 1, 0 };
static int len_alarmIndex = 11;

static oid ID_alarmVariable[] = { 1, 3, 6, 1, 2, 1, 16, 3, 1, 1, 3, 0 };
static int len_alarmVariable = 11;

static oid ID_alarmSampleType[] = { 1, 3, 6, 1, 2, 1, 16, 3, 1, 1, 4, 0 };
static int len_alarmSampleType = 11;

static oid ID_alarmValue[] = { 1, 3, 6, 1, 2, 1, 16, 3, 1, 1, 5, 0 };
static int len_alarmValue = 11;

static oid ID_alarmRisingThreshold[] = { 1, 3, 6, 1, 2, 1, 16, 3, 1, 1, 7, 0 };
static int len_alarmRisingThreshold = 11;

static oid ID_alarmFallingThreshold[] = { 1, 3, 6, 1, 2, 1, 16, 3, 1, 1, 8, 0 };
static int len_alarmFallingThreshold = 11;

/* LLDP remote tables changed trap */
#if (SYS_CPNT_LLDP == TRUE)
static oid ID_lldpStatsRemTablesInserts[] = { 1, 0, 8802, 1, 1, 2, 1, 2, 2, 0 };
static int len_lldpStatsRemTablesInserts = OID_LENGTH(ID_lldpStatsRemTablesInserts);
static oid ID_lldpStatsRemTablesDeletes[] = { 1, 0, 8802, 1, 1, 2, 1, 2, 3, 0 };
static int len_lldpStatsRemTablesDeletes = OID_LENGTH(ID_lldpStatsRemTablesDeletes);
static oid ID_lldpStatsRemTablesDrops[] = { 1, 0, 8802, 1, 1, 2, 1, 2, 4, 0 };
static int len_lldpStatsRemTablesDrops = OID_LENGTH(ID_lldpStatsRemTablesDrops);
static oid ID_lldpStatsRemTablesAgeouts[] = { 1, 0, 8802, 1, 1, 2, 1, 2, 5, 0 };
static int len_lldpStatsRemTablesAgeouts = OID_LENGTH(ID_lldpStatsRemTablesAgeouts);
#endif

#if (SYS_CPNT_EFM_OAM == TRUE)
/*
 * dot3 Oam Threshold Trap
 */
/* dot3OamEventLog */
static oid ID_dot3_oam_event_timestamp[] = { 1, 3, 6, 1, 2, 1, 158, 1, 6, 1, 2, 0, 0 };
static int len_dot3_oam_event_timestamp = 11;
static int lenidx_dot3_oam_event_timestamp = 2;

static oid ID_dot3_oam_event_oui[] = { 1, 3, 6, 1, 2, 1, 158, 1, 6, 1, 3, 0, 0 };
static int len_dot3_oam_event_oui = 11;
static int lenidx_dot3_oam_event_oui = 2;

static oid ID_dot3_oam_event_type[] = { 1, 3, 6, 1, 2, 1, 158, 1, 6, 1, 4, 0, 0 };
static int len_dot3_oam_event_type = 11;
static int lenidx_dot3_oam_event_type = 2;

static oid ID_dot3_oam_event_location[] = { 1, 3, 6, 1, 2, 1, 158, 1, 6, 1, 5, 0, 0 };
static int len_dot3_oam_event_location = 11;
static int lenidx_dot3_oam_event_location = 2;

static oid ID_dot3_oam_event_window_hi[] = { 1, 3, 6, 1, 2, 1, 158, 1, 6, 1, 6, 0, 0 };
static int len_dot3_oam_event_window_hi = 11;
static int lenidx_dot3_oam_event_window_hi = 2;

static oid ID_dot3_oam_event_window_low[] = { 1, 3, 6, 1, 2, 1, 158, 1, 6, 1, 7, 0, 0 };
static int len_dot3_oam_event_window_low = 11;
static int lenidx_dot3_oam_event_window_low = 2;

static oid ID_dot3_oam_event_threshold_hi[] = { 1, 3, 6, 1, 2, 1, 158, 1, 6, 1, 8, 0, 0 };
static int len_dot3_oam_event_threshold_hi = 11;
static int lenidx_dot3_oam_event_threshold_hi = 2;

static oid ID_dot3_oam_event_threshold_low[] = { 1, 3, 6, 1, 2, 1, 158, 1, 6, 1, 9, 0, 0 };
static int len_dot3_oam_event_threshold_low = 11;
static int lenidx_dot3_oam_event_threshold_low = 2;

static oid ID_dot3_oam_event_value[] = { 1, 3, 6, 1, 2, 1, 158, 1, 6, 1, 10, 0, 0 };
static int len_dot3_oam_event_value = 11;
static int lenidx_dot3_oam_event_value = 2;

static oid ID_dot3_oam_event_running_total[] = { 1, 3, 6, 1, 2, 1, 158, 1, 6, 1, 11, 0, 0 };
static int len_dot3_oam_event_running_total = 11;
static int lenidx_dot3_oam_event_running_total = 2;

static oid ID_dot3_oam_event_event_total[] = { 1, 3, 6, 1, 2, 1, 158, 1, 6, 1, 12, 0, 0 };
static int len_dot3_oam_event_event_total = 11;
static int lenidx_dot3_oam_event_event_total = 2;
#endif  /* #if (SYS_CPNT_EFM_OAM == TRUE) */

#if (SYS_CPNT_CFM == TRUE)
/*
 * IEEE P802.1ag Trap
 */
/* cfm highest priority defect */
/* total binding variables = 1*/
static oid ID_dot1agCfmMepHighestPrDefect[] = { 1,3,111,2,802,1,1,8, 1, 7, 1, 1, 13, 0, 0, 0 };  /* { 1, 0, 8802, 1, 1, 3, 1, 7, 1, 1, 13, 0, 0, 0 }; */
static int lenIdx_dot1agCfmMepHighestPrDefect=3;
static int len_dot1agCfmMepHighestPrDefect = 13;  /* 11; */

/*dot1agCfmMaIndex*/
static oid ID_dot1agCfmMaIndex[]={1,3,111,2,802,1,1,8, 1, 6, 1, 1, 1, 0, 0};  /* {1, 0, 8802, 1, 1, 3, 1, 6, 3, 1, 1,0,0}; */
static int lenIdx_dot1agCfmMaIndex=2;
static int len_dot1agCfmMaIndex=12;  /* 11; */

/*dot1agCfmMepIdentifier*/
static oid ID_dot1agCfmMepIdentifier[]={1,3,111,2,802,1,1,8, 1, 7, 1, 1, 1, 0, 0, 0};  /* {1, 0, 8802, 1, 1, 3, 1, 7, 1, 1, 1,0,0,0}; */
static int lenIdx_dot1agCfmMepIdentifier=3;
static int len_dot1agCfmMepIdentifier=13;  /* 11; */
#endif /* #if (SYS_CPNT_CFM == TRUE) */

#if (SYS_CPNT_POE == TRUE)
/* RFC 3621, POE traps */

/* pethPsePortOnOffNotification */
/* total binding variables = 1 */
/* pethPsePortDetectionStatus */
static oid  ID_pethPsePortDetectionStatus[] = { 1, 3, 6, 1, 2, 1, 105, 1, 1, 1, 6, 0, 0 };
static int  len_pethPsePortDetectionStatus = 11;
static int  lenIdx_pethPsePortDetectionStatus = 2;

/* pethMainPseConsumptionPower, pethMainPowerUsageOffNotification */
/* total binding variables = 1 */
/* pethMainPseConsumptionPower */
static oid  ID_pethMainPseConsumptionPower[] = { 1, 3, 6, 1, 2, 1, 105, 1, 3, 1, 1, 4, 0 };
static int  len_pethMainPseConsumptionPower = 12;
static int  lenIdx_pethMainPseConsumptionPower = 1;
#endif

#if (SYS_CPNT_BGP == TRUE)
/* RFC 4273, BGP traps */
/* bgpEstablishedNotification, bgpBackwardTransNotification */
/* total binding variables = 3 */
/* bgpPeerRemoteAddr, bgpPeerLastError, bgpPeerState */

static oid  ID_bgpPeerRemoteAddr[] = { 1, 3, 6, 1, 2, 1, 15, 3, 1, 7, 0, 0, 0, 0};
static int  len_bgpPeerRemoteAddr = 10;
static int  lenIdx_bgpPeerRemoteAddr = 4;

static oid  ID_bgpPeerLastError[] = { 1, 3, 6, 1, 2, 1, 15, 3, 1, 14, 0, 0, 0, 0};
static int  len_bgpPeerLastError = 10;
static int  lenIdx_bgpPeerLastError = 4;

static oid  ID_bgpPeerState[] = { 1, 3, 6, 1, 2, 1, 15, 3, 1, 2, 0, 0, 0, 0};
static int  len_bgpPeerState = 10;
static int  lenIdx_bgpPeerState = 4;

#endif

/*
 * Private MIB Trap
 */

/* below define the private MIB trap */

  /*es3626aMIB*/
    static oid ID_es3626aMIB[SYS_ADPT_MAX_OID_COUNT];
    static int len_es3626aMIB;

    static oid ID_es3626aTrap[SYS_ADPT_MAX_OID_COUNT];
    static int len_es3626aTrap;
    /*sysUpTime*/
    //static oid ID_sysUpTime[] = { 1, 3, 6, 1, 2, 1, 1, 3, 0 };
    //static int len_sysUpTime = 9;
    //static oid ID_snmpTrapOID[] = { 1, 3, 6, 1, 6, 3, 1, 1, 4, 1, 0 };
    //static int len_snmpTrapOID = 11;

/* general trap variables */

    static oid SubID_trapVarMacAddr[] = {1, 14, 2, 10};
    static int lenSubID_trapVarMacAddr = OID_LENGTH(SubID_trapVarMacAddr);
    static int lenIdx_trapVarMacAddr = 1;
    static oid ID_trapVarMacAddr[SYS_ADPT_MAX_OID_COUNT];
    static int len_trapVarMacAddr;

    /* trapIfIndex */
    static oid SubID_trapIfIndex[] = {1, 14, 2, 30};
    static int lenSubID_trapIfIndex = 4;
    static int lenIdx_trapIfIndex = 1;
    static oid ID_trapIfIndex[SYS_ADPT_MAX_OID_COUNT];
    static int len_trapIfIndex;

    /* trapVlanId */
    static oid SubID_trapVlanId[] = {1, 14, 2, 31};
    static int lenSubID_trapVlanId = 4;
    static int lenIdx_trapVlanId = 1;
    static oid ID_trapVlanId[SYS_ADPT_MAX_OID_COUNT];
    static int len_trapVlanId;

/* power status change Trap*/
/* total binding variables = 3*/

    /*swIndivPowerUnitIndex*/
    static oid SubID_swIndivPowerUnitIndex[] = {1, 1, 6, 1, 1};
    static int lenSubID_swIndivPowerUnitIndex=5;
    static int lenIdx_swIndivPowerUnitIndex=2;
    static oid ID_swIndivPowerUnitIndex[SYS_ADPT_MAX_OID_COUNT];
    static int len_swIndivPowerUnitIndex;

    /*swIndivPowerIndex*/
    static oid SubID_swIndivPowerIndex[] = {1, 1, 6, 1, 2};
    static int lenSubID_swIndivPowerIndex = 5;
    static int lenIdx_swIndivPowerIndex=2;
    static oid ID_swIndivPowerIndex[SYS_ADPT_MAX_OID_COUNT];
    static int len_swIndivPowerIndex;

    /*swIndivPowerStatus*/
    static oid SubID_swIndivPowerStatus[] = {1, 1, 6, 1, 3};
    static int lenSubID_swIndivPowerStatus = 5;
    static int lenIdx_swIndivPowerStatus=2;
    static oid ID_swIndivPowerStatus[SYS_ADPT_MAX_OID_COUNT];
    static int len_swIndivPowerStatus;

/* port security trap*/
#if (SYS_CPNT_INTRUSION_MSG_TRAP == TRUE)
/* total binding variables = 1*/
/* The same as ID_ifIndex[] in Rfc1215 trap*/
    static oid SubID_trapPortSecurityIntrusionMac[] = {1, 14, 2, 29};
    static int lenSubID_trapPortSecurityIntrusionMac = OID_LENGTH(SubID_trapPortSecurityIntrusionMac);
    static int lenIdx_trapPortSecurityIntrusionMac = 1;
    static oid ID_trapPortSecurityIntrusionMac[SYS_ADPT_MAX_OID_COUNT];
    static int len_trapPortSecurityIntrusionMac;
#endif /* #if (SYS_CPNT_INTRUSION_MSG_TRAP == TRUE) */

/* fan failure & fan recover*/
#if (SYS_CPNT_STKTPLG_FAN_DETECT == TRUE)
/* total binding variables = 2*/
    /*switchUnitIndex*/
    static oid SubID_switchUnitIndex[] = {1, 1, 9, 1, 1};
    static int lenSubID_switchUnitIndex=5;
    static int lenIdx_switchUnitIndex=2;
    static oid ID_switchUnitIndex[SYS_ADPT_MAX_OID_COUNT];
    static int len_switchUnitIndex;
    /*switchFanIndex*/
    static oid SubID_switchFanIndex[] = {1, 1, 9, 1, 2};
    static int lenSubID_switchFanIndex=5;
    static int lenIdx_switchFanIndex=2;
    static oid ID_switchFanIndex[SYS_ADPT_MAX_OID_COUNT] ;
    static int len_switchFanIndex;
#endif

/* ip filter trap*/
#if (SYS_CPNT_MGMT_IP_FLT == TRUE)
/* total binding variables = 2*/
    /*trapIpFilterRejectMode*/
    static oid SubID_trapIpFilterRejectMode[] = {1, 14, 2, 6};
    static int lenSubID_trapIpFilterRejectMode=4;
    static int lenIdx_trapIpFilterRejectMode=1;
    static oid ID_trapIpFilterRejectMode[SYS_ADPT_MAX_OID_COUNT];
    static int len_trapIpFilterRejectMode;
    /*trapIpFilterRejectIp*/
    static oid SubID_trapIpFilterRejectIp[] = {1, 14, 2, 7};
    static int lenSubID_trapIpFilterRejectIp=4;
    static int lenIdx_trapIpFilterRejectIp=1;
    static oid ID_trapIpFilterRejectIp[SYS_ADPT_MAX_OID_COUNT];
    static int len_trapIpFilterRejectIp;
    /*trapIpFilterRejectInetAddressType*/
    static oid SubID_trapIpFilterRejectInetAddressType[] = {1, 14, 2, 17};
    static int lenSubID_trapIpFilterRejectInetAddressType=4;
    static int lenIdx_trapIpFilterRejectInetAddressType=1;
    static oid ID_trapIpFilterRejectInetAddressType[SYS_ADPT_MAX_OID_COUNT];
    static int len_trapIpFilterRejectInetAddressType;
    /*trapIpFilterRejectInetAddress*/
    static oid SubID_trapIpFilterRejectInetAddress[] = {1, 14, 2, 18};
    static int lenSubID_trapIpFilterRejectInetAddress=4;
    static int lenIdx_trapIpFilterRejectInetAddress=1;
    static oid ID_trapIpFilterRejectInetAddress[SYS_ADPT_MAX_OID_COUNT];
    static int len_trapIpFilterRejectInetAddress;
#endif

/* smtp conn failure trap*/
#if (SYS_CPNT_SMTP == TRUE)
/* total binding variables = 1*/
    /*smtpServerIp*/
    static oid SubID_smtpServerIp[] = {1, 19, 7, 4, 1, 1};
    static int lenSubID_smtpServerIp=6;
    static int lenIdx_smtpServerIp=4;
    static oid ID_smtpServerIp[SYS_ADPT_MAX_OID_COUNT];
    static int len_smtpServerIp;
#endif

#if (SYS_CPNT_3COM_LOOPBACK_TEST == TRUE)
    //switchLoopbackTestFailurePorts
    static oid SubID_switchLoopbackTestFailurePorts[] = {1, 1, 10, 0};
    static int lenSubID_switchLoopbackTestFailurePorts=4;
    static int lenIdx_switchLoopbackTestFailurePorts=0;
    static oid ID_switchLoopbackTestFailurePorts[SYS_ADPT_MAX_OID_COUNT];
    static int len_switchLoopbackTestFailurePorts;
#endif

    /*swPowerStatusChangeTrap*/
    static oid SubID_swPowerStatusChangeTrap[] = {2, 1, 0, 1};
    static int lenSubID_swPowerStatusChangeTrap=4;
    static int lenIdx_swPowerStatusChangeTrap=0;
    static oid ID_swPowerStatusChangeTrap[SYS_ADPT_MAX_OID_COUNT];
    static int len_swPowerStatusChangeTrap;

#if (SYS_CPNT_STKTPLG_FAN_DETECT == TRUE)
    /*swFanFailureTrap*/
    static oid SubID_swFanFailureTrap[] = {2, 1, 0, 17};
    static int lenSubID_swFanFailureTrap=4;
    static int lenIdx_swFanFailureTrap=0;
    static oid ID_swFanFailureTrap[SYS_ADPT_MAX_OID_COUNT];
    static int len_swFanFailureTrap;
    /*swFanRecoverTrap*/
    static oid SubID_swFanRecoverTrap[] = {2, 1, 0, 18};
    static int lenSubID_swFanRecoverTrap=4;
    static int lenIdx_swFanRecoverTrap=0;
    static oid ID_swFanRecoverTrap[SYS_ADPT_MAX_OID_COUNT];
    static int len_swFanRecoverTrap;
#endif

#if (SYS_CPNT_INTRUSION_MSG_TRAP == TRUE)
    /*swPortSecurityTrap*/
    static oid SubID_swPortSecurityTrap[] = {2, 1, 0, 36};
    static int lenSubID_swPortSecurityTrap=4;
    static int lenIdx_swPortSecurityTrap=0;
    static oid ID_swPortSecurityTrap[SYS_ADPT_MAX_OID_COUNT];
    static int len_swPortSecurityTrap;
#endif

#if (SYS_CPNT_MGMT_IP_FLT == TRUE)
    /*swIpFilterRejectTrap*/
    static oid SubID_swIpFilterRejectTrap[] = {2, 1, 0, 40};
    static int lenSubID_swIpFilterRejectTrap=4;
    static int lenIdx_swIpFilterRejectTrap=0;
    static oid ID_swIpFilterRejectTrap[SYS_ADPT_MAX_OID_COUNT];
    static int len_swIpFilterRejectTrap;
    /*swIpFilterInetRejectTrap*/
    static oid SubID_swIpFilterInetRejectTrap[] = {2, 1, 0, 111};
    static int lenSubID_swIpFilterInetRejectTrap=4;
    static int lenIdx_swIpFilterInetRejectTrap=0;
    static oid ID_swIpFilterInetRejectTrap[SYS_ADPT_MAX_OID_COUNT];
    static int len_swIpFilterInetRejectTrap;
#endif

#if (SYS_CPNT_SMTP == TRUE)
    /* swSmtpConnFailureTrap(41)
     */
    static oid SubID_swSmtpConnFailureTrap[] = {2, 1, 0, 41};
    static int lenSubID_swSmtpConnFailureTrap=4;
    static int lenIdx_swSmtpConnFailureTrap=0;
    static oid ID_swSmtpConnFailureTrap[SYS_ADPT_MAX_OID_COUNT];
    static int len_swSmtpConnFailureTrap;
#endif

#if (SYS_CPNT_THERMAL_DETECT == TRUE)
/* swThermalRisingNotification(58),
 * swThermalFallingNotification(59):
 * total binding variables = 1
 */
    /* switchThermalTempValue
     */
    static oid SubID_switchThermalTempValue[] = {1, 1, 11, 1, 3};
    static int lenSubID_switchThermalTempValue = 5;
    static int lenIdx_switchThermalTempValue = 2;
    static oid ID_switchThermalTempValue[SYS_ADPT_MAX_OID_COUNT];
    static int len_switchThermalTempValue;

    /* switchThermalActionRisingThreshold
     */
    static oid SubID_switchThermalActionRisingThreshold[] = {1, 1, 12, 1, 4};
    static int lenSubID_switchThermalActionRisingThreshold = 5;
    static int lenIdx_switchThermalActionRisingThreshold = 3;
    static oid ID_switchThermalActionRisingThreshold[SYS_ADPT_MAX_OID_COUNT];
    static int len_switchThermalActionRisingThreshold;

    /* switchThermalActionFallingThreshold
     */
    static oid SubID_switchThermalActionFallingThreshold[] = {1, 1, 12, 1, 5};
    static int lenSubID_switchThermalActionFallingThreshold = 5;
    static int lenIdx_switchThermalActionFallingThreshold = 3;
    static oid ID_switchThermalActionFallingThreshold[SYS_ADPT_MAX_OID_COUNT];
    static int len_switchThermalActionFallingThreshold;
#endif

#if (SYS_CPNT_CFM == TRUE)
    /*dot1agCfmMepUp*/
    static oid SubID_dot1agCfmMepUp[] = {2, 1, 0, 97};
    static int lenSubID_dot1agCfmMepUp=4;
    static int lenIdx_dot1agCfmMepUp=0;
    static oid ID_dot1agCfmMepUp[SYS_ADPT_MAX_OID_COUNT];
    static int len_dot1agCfmMepUp;

    /*dot1agCfmMepDown*/
    static oid SubID_dot1agCfmMepDown[] = {2, 1, 0, 98};
    static int lenSubID_dot1agCfmMepDown=4;
    static int lenIdx_dot1agCfmMepDown=0;
    static oid ID_dot1agCfmMepDown[SYS_ADPT_MAX_OID_COUNT];
    static int len_dot1agCfmMepDown;

    /*dot1agCfmConfigFail*/
    static oid SubID_dot1agCfmConfigFail[] = {2, 1, 0, 99};
    static int lenSubID_dot1agCfmConfigFail=4;
    static int lenIdx_dot1agCfmConfigFail=0;
    static oid ID_dot1agCfmConfigFail[SYS_ADPT_MAX_OID_COUNT];
    static int len_dot1agCfmConfigFail;

    /*dot1agCfmLoopFind*/
    static oid SubID_dot1agCfmLoopFind[] = {2, 1, 0, 100};
    static int lenSubID_dot1agCfmLoopFind=4;
    static int lenIdx_dot1agCfmLoopFind=0;
    static oid ID_dot1agCfmLoopFind[SYS_ADPT_MAX_OID_COUNT];
    static int len_dot1agCfmLoopFind;

    /*dot1agCfmMepUnknown*/
    static oid SubID_dot1agCfmMepUnknown[] = {2, 1, 0, 101};
    static int lenSubID_dot1agCfmMepUnknown=4;
    static int lenIdx_dot1agCfmMepUnknown=0;
    static oid ID_dot1agCfmMepUnknown[SYS_ADPT_MAX_OID_COUNT];
    static int len_dot1agCfmMepUnknown;

    /*dot1agCfmMepMissing*/
    static oid SubID_dot1agCfmMepMissing[] = {2, 1, 0, 102};
    static int lenSubID_dot1agCfmMepMissing=4;
    static int lenIdx_dot1agCfmMepMissing=0;
    static oid ID_dot1agCfmMepMissing[SYS_ADPT_MAX_OID_COUNT];
    static int len_dot1agCfmMepMissing;

    /*dot1agCfmMaUp*/
    static oid SubID_dot1agCfmMaUp[] = {2, 1, 0, 103};
    static int lenSubID_dot1agCfmMaUp=4;
    static int lenIdx_dot1agCfmMaUp=0;
    static oid ID_dot1agCfmMaUp[SYS_ADPT_MAX_OID_COUNT];
    static int len_dot1agCfmMaUp;
#endif  /* #if(SYS_CPNT_CFM==TRUE) */

#if (SYS_CPNT_SNMP_MIB_STYLE == SYS_CPNT_SNMP_MIB_STYLE_32)
    /*2004-12-1 Eric Huang added for 3com*/
    /*secureAddrRowStatus*/
    static oid ID_secureAddrRowStatus[] = {1,3,6,1,4,1,43,10,22,2,1,4,0,0,0,0,0,0,0,0};
    static int len_secureAddrRowStatus = 12;
    static int lenidx_secureAddrRowStatus = 8;

    /*dot1xAuthSessionUserName*/
    static oid ID_dot1xAuthSessionUserName[] = {1,0,8802,1,1,1,1,2,4,1,9,0};
    static int len_dot1xAuthSessionUserName = 11;

    /*dot1xAuthSessionAuthenticMethod*/
    static oid ID_dot1xAuthSessionAuthenticMethod[] = {1,0,8802,1,1,1,1,2,4,1,6,0};
    static int len_dot1xAuthSessionAuthenticMethod = 11;

    /*securePortVlanMembershipList*/
    static oid ID_securePortVlanMembershipList[] = {1,3,6,1,4,1,43,10,22,6,0};
    static int len_securePortVlanMembershipList = 10;

    /*dot1xAuthSessionTerminateCause*/
    static oid ID_dot1xAuthSessionTerminateCause[] = {1,0,8802,1,1,1,1,2,4,1,8,0};
    static int len_dot1xAuthSessionTerminateCause = 11;
#endif  /* (SYS_CPNT_SNMP_MIB_STYLE == SYS_CPNT_SNMP_MIB_STYLE_32) */

#if (SYS_CPNT_STP_BPDU_GUARD == TRUE)
    /* stpBpduGuardPortShutdownTrap */
    static oid SubID_stpBpduGuardPortShutdown[] = {2, 1, 0, 91};
    static int lenSubID_stpBpduGuardPortShutdown = 4;
    static int lenIdx_stpBpduGuardPortShutdown = 1;
    static oid ID_stpBpduGuardPortShutdown[SYS_ADPT_MAX_OID_COUNT];
    static int len_stpBpduGuardPortShutdown;
#endif

#if (SYS_CPNT_NETACCESS_LINK_DETECTION == TRUE)
    /*networkAccessPortLinkDetectionTrap*/
    static oid SubID_networkAccessPortLinkDetectionTrap[] = {2, 1, 0, 96};
    static int lenSubID_networkAccessPortLinkDetectionTrap=4;
    static int lenIdx_networkAccessPortLinkDetectionTrap=0;
    static oid ID_networkAccessPortLinkDetectionTrap[SYS_ADPT_MAX_OID_COUNT];
    static int len_networkAccessPortLinkDetectionTrap;

    /* networkAccessPortLinkDetection */
    static oid SubID_networkAccessPortLinkDetectionMode[] = {1, 17, 13, 2, 1, 8};
    static int lenSubID_networkAccessPortLinkDetectionMode=6;
    static int lenIdx_networkAccessPortLinkDetectionMode=1;
    static oid ID_networkAccessPortLinkDetectionMode[SYS_ADPT_MAX_OID_COUNT];
    static int len_networkAccessPortLinkDetectionMode;

    /* networkAccessPortLinkDetectionAction */
    static oid SubID_networkAccessPortLinkDetectionAction[] = {1, 17, 13, 2, 1, 9};
    static int lenSubID_networkAccessPortLinkDetectionAction=6;
    static int lenIdx_networkAccessPortLinkDetectionAction=1;
    static oid ID_networkAccessPortLinkDetectionAction[SYS_ADPT_MAX_OID_COUNT];
    static int len_networkAccessPortLinkDetectionAction;
#endif  /* #if(SYS_CPNT_NETACCESS_LINK_DETECTION == TRUE) */

#if (SYS_CPNT_SNMP_MIB_STYLE == SYS_CPNT_SNMP_MIB_STYLE_32)
    /*Test Trap for 3com*/
    static oid ID_testTrap[] = {1,3,6,1,4,1,43,47,2,1,0,64};
    //static int len_testTrap = 12;

    /*Ip Forwarding Changed By Mstp Trap*/
    static oid ID_swIpForwardingChangedByMstpTrap[]= {1,3,6,1,4,1,43,47,2,1,0,65};
    //static int len_swIpForwardingChangedByMstpTrap = 12;
#endif  /* (SYS_CPNT_SNMP_MIB_STYLE == SYS_CPNT_SNMP_MIB_STYLE_32) */

#if (SYS_CPNT_MODULE_WITH_CPU == TRUE)
    /*Module Insertion Notificaiton*/
    static oid ID_swModuleInsertionNotificaiton[] ={1,3,6,1,4,1,43,47,2,1,0,60};
    //static int len_swModuleInsertionNotificaiton = 12;

    /*Module Removal Notificaiton*/
    static oid ID_swModuleRemovalNotificaiton[] = {1,3,6,1,4,1,43,47,2,1,0,61};
    //static int len_swModuleRemovalNotificaiton = 12;
#endif

    static oid SubID_swModuleOpCodeVer[] = {1, 1, 13, 1, 7};
    static int lenSubID_swModuleOpCodeVer=5;
    static int lenIdx_swModuleOpCodeVer=2;
    static oid ID_swModuleOpCodeVer[SYS_ADPT_MAX_OID_COUNT];
    static int len_swModuleOpCodeVer;

    static oid SubID_swOpCodeVer[] = {1, 1, 3, 1, 6};
    static int lenSubID_swOpCodeVer=5;
    static int lenIdx_swOpCodeVer=1;
    static oid ID_swOpCodeVer[SYS_ADPT_MAX_OID_COUNT];
    static int len_swOpCodeVer;

    static oid SubID_swExpectedModuleOpCodeVer[] = {1, 1, 3, 1, 16};
    static int lenSubID_swExpectedModuleOpCodeVer=5;
    static int lenIdx_swExpectedModuleOpCodeVer=1;
    static oid ID_swExpectedModuleOpCodeVer[SYS_ADPT_MAX_OID_COUNT];
    static int len_swExpectedModuleOpCodeVer;

    /*TCN reason*/
    static oid ID_trapVarTcnReason[] = {1,3,6,1,4,1,43,47,1,14,2,9,0};
    static int len_trapVarTcnReason = 12;

#if (SYS_CPNT_XFER_AUTO_UPGRADE == TRUE)
    /*Auto Upgrade trap*/
    static oid SubID_autoUpgradeTrap[] = {2,1,0,104};
    static int lenSubID_autoUpgradeTrap = 4;
    static int lenIdx_autoUpgradeTrap=1;
    static oid ID_autoUpgradeTrap[SYS_ADPT_MAX_OID_COUNT];
    static int len_autoUpgradeTrap;

    /*Result*/
    static oid SubID_trapAutoUpgradeResult[] = {1,14,2,22};
    static int lenSubID_trapAutoUpgradeResult = 4;
    static int lenIdx_trapAutoUpgradeResult=1;
    static oid ID_trapAutoUpgradeResult[SYS_ADPT_MAX_OID_COUNT];
    static int len_trapAutoUpgradeResult;

    /*NewVer*/
    static oid SubID_trapAutoUpgradeNewVer[] = {1,14,2,23};
    static int lenSubID_trapAutoUpgradeNewVer = 4;
    static int lenIdx_trapAutoUpgradeNewVer=1;
    static oid ID_trapAutoUpgradeNewVer[SYS_ADPT_MAX_OID_COUNT];
    static int len_trapAutoUpgradeNewVer;
#endif  /* (SYS_CPNT_XFER_AUTO_UPGRADE == TRUE) */

#if (SYS_CPNT_ATC_STORM == TRUE)
    /*atcBcastStormTcApplyTime*/
    static oid SubID_atcBcastStormTcApplyTime[] = {1, 33, 5, 1};
    static int lenSubID_atcBcastStormTcApplyTime=4;
    static int lenIdx_atcBcastStormTcApplyTime=1;
    static oid ID_atcBcastStormTcApplyTime[SYS_ADPT_MAX_OID_COUNT];
    static int len_atcBcastStormTcApplyTime;

    /*atcBcastStormTcReleaseTime*/
    static oid SubID_atcBcastStormTcReleaseTime[] = {1, 33, 5, 2};
    static int lenSubID_atcBcastStormTcReleaseTime=4;
    static int lenIdx_atcBcastStormTcReleaseTime=1;
    static oid ID_atcBcastStormTcReleaseTime[SYS_ADPT_MAX_OID_COUNT];
    static int len_atcBcastStormTcReleaseTime;

    /*atcMcastStormTcApplyTime*/
    static oid SubID_atcMcastStormTcApplyTime[] = {1, 33, 5, 4};
    static int lenSubID_atcMcastStormTcApplyTime=4;
    static int lenIdx_atcMcastStormTcApplyTime=1;
    static oid ID_atcMcastStormTcApplyTime[SYS_ADPT_MAX_OID_COUNT];
    static int len_atcMcastStormTcApplyTime;

    /*atcMcastStormTcReleaseTime*/
    static oid SubID_atcMcastStormTcReleaseTime[] = {1, 33, 5, 5};
    static int lenSubID_atcMcastStormTcReleaseTime=4;
    static int lenIdx_atcMcastStormTcReleaseTime=1;
    static oid ID_atcMcastStormTcReleaseTime[SYS_ADPT_MAX_OID_COUNT];
    static int len_atcMcastStormTcReleaseTime;

   static oid SubID_atcBcastStormIfIndex[] = {1,33,5,3,1,1};
   static int lenSubID_atcBcastStormIfIndex = 6;
   static int lenIdx_atcBcastStormIfIndex = 1;
   static oid ID_atcBcastStormIfIndex[SYS_ADPT_MAX_OID_COUNT];
   static int len_atcBcastStormIfIndex;

   static oid SubID_atcBcastStormSampleType[] = {1,33,5,3,1,4};
   static int lenSubID_atcBcastStormSampleType = 6;
   static int lenIdx_atcBcastStormSampleType = 1;
   static oid ID_atcBcastStormSampleType[SYS_ADPT_MAX_OID_COUNT];
   static int len_atcBcastStormSampleType;

   static oid SubID_atcBcastStormCurrentTrafficRate[] = {1,33,5,3,1,5};
   static int lenSubID_atcBcastStormCurrentTrafficRate = 6;
   static int lenIdx_atcBcastStormCurrentTrafficRate = 1;
   static oid ID_atcBcastStormCurrentTrafficRate[SYS_ADPT_MAX_OID_COUNT];
   static int len_atcBcastStormCurrentTrafficRate;

   static oid SubID_atcBcastStormAlarmThreshold[] = {1,33,5,3,1,6};
   static int lenSubID_atcBcastStormAlarmThreshold = 6;
   static int lenIdx_atcBcastStormAlarmThreshold = 1;
   static oid ID_atcBcastStormAlarmThreshold[SYS_ADPT_MAX_OID_COUNT];
   static int len_atcBcastStormAlarmThreshold;

   static oid SubID_atcBcastStormClearThreshold[] = {1,33,5,3,1,7};
   static int lenSubID_atcBcastStormClearThreshold = 6;
   static int lenIdx_atcBcastStormClearThreshold = 1;
   static oid ID_atcBcastStormClearThreshold[SYS_ADPT_MAX_OID_COUNT];
   static int len_atcBcastStormClearThreshold;

   static oid SubID_atcBcastStormTcAction[] = {1,33,5,3,1,8};
   static int lenSubID_atcBcastStormTcAction = 6;
   static int lenIdx_atcBcastStormTcAction = 1;
   static oid ID_atcBcastStormTcAction[SYS_ADPT_MAX_OID_COUNT];
   static int len_atcBcastStormTcAction;

   static oid SubID_atcMcastStormIfIndex[] = {1,33,5,6,1,1};
   static int lenSubID_atcMcastStormIfIndex = 6;
   static int lenIdx_atcMcastStormIfIndex = 1;
   static oid ID_atcMcastStormIfIndex[SYS_ADPT_MAX_OID_COUNT];
   static int len_atcMcastStormIfIndex;

   static oid SubID_atcMcastStormSampleType[] = {1,33,5,6,1,4};
   static int lenSubID_atcMcastStormSampleType = 6;
   static int lenIdx_atcMcastStormSampleType = 1;
   static oid ID_atcMcastStormSampleType[SYS_ADPT_MAX_OID_COUNT];
   static int len_atcMcastStormSampleType;

   static oid SubID_atcMcastStormCurrentTrafficRate[] = {1,33,5,6,1,5};
   static int lenSubID_atcMcastStormCurrentTrafficRate = 6;
   static int lenIdx_atcMcastStormCurrentTrafficRate = 1;
   static oid ID_atcMcastStormCurrentTrafficRate[SYS_ADPT_MAX_OID_COUNT];
   static int len_atcMcastStormCurrentTrafficRate;

   static oid SubID_atcMcastStormAlarmThreshold[] = {1,33,5,6,1,6};
   static int lenSubID_atcMcastStormAlarmThreshold = 6;
   static int lenIdx_atcMcastStormAlarmThreshold = 1;
   static oid ID_atcMcastStormAlarmThreshold[SYS_ADPT_MAX_OID_COUNT];
   static int len_atcMcastStormAlarmThreshold;

   static oid SubID_atcMcastStormClearThreshold[] = {1,33,5,6,1,7};
   static int lenSubID_atcMcastStormClearThreshold = 6;
   static int lenIdx_atcMcastStormClearThreshold = 1;
   static oid ID_atcMcastStormClearThreshold[SYS_ADPT_MAX_OID_COUNT];
   static int len_atcMcastStormClearThreshold;

   static oid SubID_atcMcastStormTcAction[] = {1,33,5,6,1,8};
   static int lenSubID_atcMcastStormTcAction= 6;
   static int lenIdx_atcMcastStormTcAction = 1;
   static oid ID_atcMcastStormTcAction[SYS_ADPT_MAX_OID_COUNT];
   static int len_atcMcastStormTcAction;
#endif  /*  (SYS_CPNT_ATC_STORM == TRUE) */

#if (SYS_CPNT_SYSMGMT_RESMIB == TRUE)
    /*cpuUtiExceedRaiseThresholdNotification*/
    static oid SubID_swCpuUtiRisingNotification[] = {2, 1, 0, 107};
    static int lenSubID_swCpuUtiRisingNotification=4;
    static int lenIdx_swCpuUtiRisingNotification=0;
    static oid ID_swCpuUtiRisingNotification[SYS_ADPT_MAX_OID_COUNT];
    static int len_swCpuUtiRisingNotification;

    /*cpuUtiBelowFallingThresholdNotification*/
    static oid SubID_swCpuUtiFallingNotification[] = {2, 1, 0, 108};
    static int lenSubID_swCpuUtiFallingNotification=4;
    static int lenIdx_swCpuUtiFallingNotification=0;
    static oid ID_swCpuUtiFallingNotification[SYS_ADPT_MAX_OID_COUNT];
    static int len_swCpuUtiFallingNotification;

    /*memoryUtiExceedRaiseThresholdNotification*/
    static oid SubID_swMemoryUtiRisingThresholdNotification[] = {2, 1, 0, 109};
    static int lenSubID_swMemoryUtiRisingThresholdNotification=4;
    static int lenIdx_swMemoryUtiRisingThresholdNotification=0;
    static oid ID_swMemoryUtiRisingThresholdNotification[SYS_ADPT_MAX_OID_COUNT];
    static int len_swMemoryUtiRisingThresholdNotification;

    /*memoryUtiBelowFallingThresholdNotification*/
    static oid SubID_swMemoryUtiFallingThresholdNotification[] = {2, 1, 0, 110};
    static int lenSubID_swMemoryUtiFallingThresholdNotification=4;
    static int lenIdx_swMemoryUtiFallingThresholdNotification=0;
    static oid ID_swMemoryUtiFallingThresholdNotification[SYS_ADPT_MAX_OID_COUNT];
    static int len_swMemoryUtiFallingThresholdNotification;
#endif  /* #if (SYS_CPNT_SYSMGMT_RESMIB == TRUE) */

#if (SYS_CPNT_SYSMGMT_CPU_GUARD == TRUE)
    /* cpuGuardControlTrap */
    static oid SubID_cpuGuardControlTrap[] = {2, 1, 0, 213};
    static int lenSubID_cpuGuardControlTrap = 4;
    static int lenIdx_cpuGuardControlTrap = 0;
    static oid ID_cpuGuardControlTrap[SYS_ADPT_MAX_OID_COUNT];
    static int len_cpuGuardControlTrap;

    /* cpuGuardReleaseTrap */
    static oid SubID_cpuGuardReleaseTrap[] = {2, 1, 0, 214};
    static int lenSubID_cpuGuardReleaseTrap = 4;
    static int lenIdx_cpuGuardReleaseTrap = 0;
    static oid ID_cpuGuardReleaseTrap[SYS_ADPT_MAX_OID_COUNT];
    static int len_cpuGuardReleaseTrap;

#endif

    /* DHCP client sends a trap when receiving a packet from a rogue server. */
    /* dhcpRogueServerAttackTrap */
    static oid SubID_dhcpRogueServerAttackTrap[] = {2, 1, 0, 114};
    static int lenSubID_dhcpRogueServerAttackTrap = 4;
    static int lenIdx_dhcpRogueServerAttackTrap = 0;
    static oid ID_dhcpRogueServerAttackTrap[SYS_ADPT_MAX_OID_COUNT];
    static int len_dhcpRogueServerAttackTrap;

    /* DHCP Client Port IfIndex */
    static oid SubID_dhcpClientPortIfIndex[] = {1, 14, 2, 62};
    static int lenSubID_dhcpClientPortIfIndex = 4;
    static int lenIdx_dhcpClientPortIfIndex = 0;
    static oid ID_dhcpClientPortIfIndex[SYS_ADPT_MAX_OID_COUNT];
    static int len_dhcpClientPortIfIndex;

    /* DHCP Server IP Address */
    static oid SubID_dhcpServerIpAddress[] = {1, 14, 2, 63};
    static int lenSubID_dhcpServerIpAddress = 4;
    static int lenIdx_dhcpServerIpAddress = 0;
    static oid ID_dhcpServerIpAddress[SYS_ADPT_MAX_OID_COUNT];
    static int len_dhcpServerIpAddress;

    /* DHCP Server Mac Address */
    static oid SubID_dhcpServerMacAddress[] = {1, 14, 2, 67};
    static int lenSubID_dhcpServerMacAddress = 4;
    static int lenIdx_dhcpServerMacAddress = 0;
    static oid ID_dhcpServerMacAddress[SYS_ADPT_MAX_OID_COUNT];
    static int len_dhcpServerMacAddress;

#if (SYS_CPNT_SFP_DDM_ALARMWARN_TRAP==TRUE)
    /* This trap is sent when the sfp's A/D quantity is not within alarm/warning thresholds. */
    /* sfpThresholdAlarmWarnTrap */
    static oid SubID_sfpThresholdAlarmWarnTrap[] = {2, 1, 0, 189};
    static int lenSubID_sfpThresholdAlarmWarnTrap = 4;
    static int lenIdx_sfpThresholdAlarmWarnTrap = 0;
    static oid ID_sfpThresholdAlarmWarnTrap[SYS_ADPT_MAX_OID_COUNT];
    static int len_sfpThresholdAlarmWarnTrap;

    /* sfpThresholdAlarmWarn IfIndex */
    static oid SubID_trapSfpThresholdAlarmWarnIfIndex[] = {1, 14, 2, 64, 0};
    static int lenSubID_trapSfpThresholdAlarmWarnIfIndex = OID_LENGTH(SubID_trapSfpThresholdAlarmWarnIfIndex);
    static int lenIdx_sfpThresholdAlarmWarnIfIndex = 0;
    static oid ID_sfpThresholdAlarmWarnIfIndex[SYS_ADPT_MAX_OID_COUNT];
    static int len_sfpThresholdAlarmWarnIfIndex;

    /* sfpThresholdAlarmWarnType */
    static oid SubID_trapSfpThresholdAlarmWarnType[] = {1, 14, 2, 65, 0};
    static int lenSubID_trapSfpThresholdAlarmWarnType = OID_LENGTH(SubID_trapSfpThresholdAlarmWarnType);
    static int lenIdx_sfpThresholdAlarmWarnType = 0;
    static oid ID_sfpThresholdAlarmWarnType[SYS_ADPT_MAX_OID_COUNT];
    static int len_sfpThresholdAlarmWarnType;
#endif

#if (SYS_CPNT_ALARM_INPUT_DETECT == TRUE)
    /*swAlarmUnitIndex*/
    static oid SubID_swAlarmUnitIndex[] = {1, 1, 19, 1, 1};
    static int lenSubID_swAlarmUnitIndex=5;
    static int lenIdx_swAlarmUnitIndex=2;
    static oid ID_swAlarmUnitIndex[SYS_ADPT_MAX_OID_COUNT];
    static int len_swAlarmUnitIndex;

    /*swAlarmInputType*/
    static oid SubID_swAlarmInputType[] = {1, 1, 19, 1, 2};
    static int lenSubID_swAlarmInputType= 5;
    static int lenIdx_swAlarmInputType=2;
    static oid ID_swAlarmInputType[SYS_ADPT_MAX_OID_COUNT];
    static int len_swAlarmInputType;

    /*swAlarmInputName*/
    static oid SubID_swAlarmInputName[] = {1, 1, 19, 1, 4};
    static int lenSubID_swAlarmInputName= 5;
    static int lenIdx_swAlarmInputName=2;
    static oid ID_swAlarmInputName[SYS_ADPT_MAX_OID_COUNT];
    static int len_swAlarmInputName;

    /*Alarm Input*/
    static oid SubID_swAlarmInput[] = {1, 14, 5, 7};
    static int lenSubID_swAlarmInput=4;
    static int lenIdx_swAlarmInput=1;
    static oid ID_swAlarmInput[SYS_ADPT_MAX_OID_COUNT];
    static int len_swAlarmInput;

#endif

#if (SYS_CPNT_ALARM_DETECT == TRUE)
    /*Major Alarm*/
    static oid SubID_MajorAlarmOutput[] = {1, 14, 5, 1};
    static int lenSubID_MajorAlarmOutput=4;
    static int lenIdx_MajorAlarmOutput=1;
    static oid ID_MajorAlarmOutput[SYS_ADPT_MAX_OID_COUNT];
    static int len_MajorAlarmOutput;

    /*Major Alarm Recovery*/
    static oid SubID_MajorAlarmOutputRecovery[] = {1, 14, 5, 5};
    static int lenSubID_MajorAlarmOutputRecovery=4;
    static int lenIdx_MajorAlarmOutputRecovery=1;
    static oid ID_MajorAlarmOutputRecovery[SYS_ADPT_MAX_OID_COUNT];
    static int len_MajorAlarmOutputRecovery;

    /*Minor Alarm*/
    static oid SubID_MinorAlarmOutput[] = {1, 14,5,3};
    static int lenSubID_MinorAlarmOutput=4;
    static int lenIdx_MinorAlarmOutput=1;
    static oid ID_MinorAlarmOutput[SYS_ADPT_MAX_OID_COUNT];
    static int len_MinorAlarmOutput;
#endif

#if (SYS_CPNT_AMTR_MAC_NOTIFY == TRUE)
    /* MacNotificationTrap */
    static oid SubID_macNotificationTrap[] = {2, 1, 0, TRAP_EVENT_MAC_NOTIFY/*138*/};
    static int lenSubID_macNotificationTrap = 4;
    static int lenIdx_macNotificationTrap = 1;
    static oid ID_macNotificationTrap[SYS_ADPT_MAX_OID_COUNT];
    static int len_macNotificationTrap;

    /* MacNotificationTrap Action */
    static oid SubID_trapMacNotifyAction[] = {1, 14, 2, 68};
    static int lenSubID_trapMacNotifyAction = 4;
    static int lenIdx_trapMacNotifyAction = 1;
    static oid ID_trapMacNotifyAction[SYS_ADPT_MAX_OID_COUNT];
    static int len_trapMacNotifyAction;
#endif /* #if (SYS_CPNT_AMTR_MAC_NOTIFY == TRUE) */

#if(SYS_CPNT_SYNCE == TRUE)
    /*syncEReceiveSSMTrap*/
    static oid SubID_synceRxSsmTrap[]={2, 1, 0, TRAP_EVENT_SYNCE_SSM_RX};
    static int lenSubID_synceRxSsmTrap = 4;
    static int lenIdx_synceRxSsmTrap = 1;
    static oid ID_synceRxSsmTrap[SYS_ADPT_MAX_OID_COUNT];
    static int len_synceRxSsmTrap;

    /*syncELockedClockSource*/
    static oid SubID_synceClkSrcTrap[]={2, 1, 0, TRAP_EVENT_SYNCE_CLOCK_SRC};
    static int lenSubID_synceClkSrcTrap = 4;
    static int lenIdx_synceClkSrcTrap = 1;
    static oid ID_synceClkSrcTrap[SYS_ADPT_MAX_OID_COUNT];
    static int len_synceClkSrcTrap;

    /*syncEPortIndex*/
    static oid SubID_syncePortIndex[]={1, 72, 9, 1, 1};
    static int lenSubID_syncePortIndex = 5;
    static int lenIdx_syncePortIndex = 1;
    static oid ID_syncePortIndex[SYS_ADPT_MAX_OID_COUNT];
    static int len_syncePortIndex;

    /*syncEPortStatus*/
    static oid SubID_syncePortStatus[]={1, 72, 9, 1, 2};
    static int lenSubID_syncePortStatus = 5;
    static int lenIdx_syncePortStatus = 1;
    static oid ID_syncePortStatus[SYS_ADPT_MAX_OID_COUNT];
    static int len_syncePortStatus;

    /*syncEPortSsmStatus*/
    static oid SubID_syncePortSsmStatus[]={1, 72, 9, 1, 3};
    static int lenSubID_syncePortSsmStatus = 5;
    static int lenIdx_syncePortSsmStatus = 1;
    static oid ID_syncePortSsmStatus[SYS_ADPT_MAX_OID_COUNT];
    static int len_syncePortSsmStatus;
#endif /*#if(SYS_CPNT_SYNCE == TRUE)*/

    /* trapVarLoginUserName
     */
    static oid SubID_trapVarLoginUserName[] = {1, 14, 2, 11};
    static int lenSubID_trapVarLoginUserName = 4;
    static int lenIdx_trapVarLoginUserName = 1;
    static oid ID_trapVarLoginUserName[SYS_ADPT_MAX_OID_COUNT];
    static int len_trapVarLoginUserName;

    /* trapVarSessionType
     */
    static oid SubID_trapVarSessionType[] = {1, 14, 2, 12};
    static int lenSubID_trapVarSessionType = 4;
    static int lenIdx_trapVarSessionType = 1;
    static oid ID_trapVarSessionType[SYS_ADPT_MAX_OID_COUNT];
    static int len_trapVarSessionType;

    /* trapVarLoginInetAddressType
     */
    static oid SubID_trapVarLoginInetAddressType[] = {1, 14, 2, 15};
    static int lenSubID_trapVarLoginInetAddressType = 4;
    static int lenIdx_trapVarLoginInetAddressType = 1;
    static oid ID_trapVarLoginInetAddressType[SYS_ADPT_MAX_OID_COUNT];
    static int len_trapVarLoginInetAddressType;

    /* trapVarLoginInetAddress
     */
    static oid SubID_trapVarLoginInetAddress[] = {1, 14, 2, 16};
    static int lenSubID_trapVarLoginInetAddress = 4;
    static int lenIdx_trapVarLoginInetAddress = 1;
    static oid ID_trapVarLoginInetAddress[SYS_ADPT_MAX_OID_COUNT];
    static int len_trapVarLoginInetAddress;

    /* userAuthenticationFailureTrap
     */
    static oid SubID_userAuthenticationFailureTrap[] = {2, 1, 0, 199};
    static int lenSubID_userAuthenticationFailureTrap = 4;
    static int lenIdx_userAuthenticationFailureTrap = 0;
    static oid ID_userAuthenticationFailureTrap[SYS_ADPT_MAX_OID_COUNT];
    static int len_userAuthenticationFailureTrap;

    /* userAuthenticationSuccessTrap
     */
    static oid SubID_userAuthenticationSuccessTrap[] = {2, 1, 0, 200};
    static int lenSubID_userAuthenticationSuccessTrap = 4;
    static int lenIdx_userAuthenticationSuccessTrap = 0;
    static oid ID_userAuthenticationSuccessTrap[SYS_ADPT_MAX_OID_COUNT];
    static int len_userAuthenticationSuccessTrap;

    /* loginTrap
     */
    static oid SubID_loginTrap[] = {2, 1, 0, 201};
    static int lenSubID_loginTrap = 4;
    static int lenIdx_loginTrap = 0;
    static oid ID_loginTrap[SYS_ADPT_MAX_OID_COUNT];
    static int len_loginTrap;

    /* logoutTrap
     */
    static oid SubID_logoutTrap[] = {2, 1, 0, 202};
    static int lenSubID_logoutTrap = 4;
    static int lenIdx_logoutTrap = 0;
    static oid ID_logoutTrap[SYS_ADPT_MAX_OID_COUNT];
    static int len_logoutTrap;

    /* fileCopySrcOperType
     */
    static oid SubID_fileCopySrcOperType[] = {1, 24, 1, 1};
    static int lenSubID_fileCopySrcOperType = 4;
    static int lenIdx_fileCopySrcOperType = 1;
    static oid ID_fileCopySrcOperType[SYS_ADPT_MAX_OID_COUNT];
    static int len_fileCopySrcOperType;

    /* fileCopySrcFileName
     */
    static oid SubID_fileCopySrcFileName[] = {1, 24, 1, 2};
    static int lenSubID_fileCopySrcFileName = 4;
    static int lenIdx_fileCopySrcFileName = 1;
    static oid ID_fileCopySrcFileName[SYS_ADPT_MAX_OID_COUNT];
    static int len_fileCopySrcFileName;

    /* fileCopyDestOperType
     */
    static oid SubID_fileCopyDestOperType[] = {1, 24, 1, 3};
    static int lenSubID_fileCopyDestOperType = 4;
    static int lenIdx_fileCopyDestOperType = 1;
    static oid ID_fileCopyDestOperType[SYS_ADPT_MAX_OID_COUNT];
    static int len_fileCopyDestOperType;

    /* fileCopyDestFileName
     */
    static oid SubID_fileCopyDestFileName[] = {1, 24, 1, 4};
    static int lenSubID_fileCopyDestFileName = 4;
    static int lenIdx_fileCopyDestFileName = 1;
    static oid ID_fileCopyDestFileName[SYS_ADPT_MAX_OID_COUNT];
    static int len_fileCopyDestFileName;

    /* fileCopyFileType
     */
    static oid SubID_fileCopyFileType[] = {1, 24, 1, 5};
    static int lenSubID_fileCopyFileType = 4;
    static int lenIdx_fileCopyFileType = 1;
    static oid ID_fileCopyFileType[SYS_ADPT_MAX_OID_COUNT];
    static int len_fileCopyFileType;

    /* fileCopyUnitId
     */
    static oid SubID_fileCopyUnitId[] = {1, 24, 1, 7};
    static int lenSubID_fileCopyUnitId = 4;
    static int lenIdx_fileCopyUnitId = 1;
    static oid ID_fileCopyUnitId[SYS_ADPT_MAX_OID_COUNT];
    static int len_fileCopyUnitId;

    /* fileCopyStatus
     */
    static oid SubID_fileCopyStatus[] = {1, 24, 1, 9};
    static int lenSubID_fileCopyStatus = 4;
    static int lenIdx_fileCopyStatus = 1;
    static oid ID_fileCopyStatus[SYS_ADPT_MAX_OID_COUNT];
    static int len_fileCopyStatus;

    /* fileCopyServerInetAddressType
     */
    static oid SubID_fileCopyServerInetAddressType[] = {1, 24, 1, 20};
    static int lenSubID_fileCopyServerInetAddressType = 4;
    static int lenIdx_fileCopyServerInetAddressType = 1;
    static oid ID_fileCopyServerInetAddressType[SYS_ADPT_MAX_OID_COUNT];
    static int len_fileCopyServerInetAddressType;

    /* fileCopyServerInetAddress
     */
    static oid SubID_fileCopyServerInetAddress[] = {1, 24, 1, 21};
    static int lenSubID_fileCopyServerInetAddress = 4;
    static int lenIdx_fileCopyServerInetAddress = 1;
    static oid ID_fileCopyServerInetAddress[SYS_ADPT_MAX_OID_COUNT];
    static int len_fileCopyServerInetAddress;

    /* userauthCreateUserTrap
     */
    static oid SubID_userauthCreateUserTrap[] = {2, 1, 0, 209};
    static int lenSubID_userauthCreateUserTrap = 4;
    static int lenIdx_userauthCreateUserTrap = 0;
    static oid ID_userauthCreateUserTrap[SYS_ADPT_MAX_OID_COUNT];
    static int len_userauthCreateUserTrap;

    /* userauthDeleteUserTrap
     */
    static oid SubID_userauthDeleteUserTrap[] = {2, 1, 0, 210};
    static int lenSubID_userauthDeleteUserTrap = 4;
    static int lenIdx_userauthDeleteUserTrap = 0;
    static oid ID_userauthDeleteUserTrap[SYS_ADPT_MAX_OID_COUNT];
    static int len_userauthDeleteUserTrap;

    /* userauthModifyUserPrivilegeTrap
     */
    static oid SubID_userauthModifyUserPrivilegeTrap[] = {2, 1, 0, 211};
    static int lenSubID_userauthModifyUserPrivilegeTrap = 4;
    static int lenIdx_userauthModifyUserPrivilegeTrap = 0;
    static oid ID_userauthModifyUserPrivilegeTrap[SYS_ADPT_MAX_OID_COUNT];
    static int len_userauthModifyUserPrivilegeTrap;

    /* userAuthUserName
     */
    static oid SubID_userAuthUserName[] = {1, 17, 1, 0, 5, 1, 1};
    static int lenSubID_userAuthUserName = 7;
    static int lenIdx_userAuthUserName = 0;
    static oid ID_userAuthUserName[SYS_ADPT_MAX_OID_COUNT];
    static int len_userAuthUserName;

    /* userAuthPrivilege
     */
    static oid SubID_userAuthPrivilege[] = {1, 17, 1, 0, 5, 1, 3};
    static int lenSubID_userAuthPrivilege = 7;
    static int lenIdx_userAuthPrivilege = 0;
    static oid ID_userAuthPrivilege[SYS_ADPT_MAX_OID_COUNT];
    static int len_userAuthPrivilege;

#if 0  /* not used in Linux "shared memory queue" implementation */
typedef struct
{
    I32_T               que_elements_cnt;
    TRAP_EVENT_TrapQueueData_T     *front;
    TRAP_EVENT_TrapQueueData_T     *rear;
} SNMP_MGR_Queue_T;
#endif  /* 0 */

typedef int (*SNMP_MGR_COMP_TRAP_ENTRY_FUNC) (const void * ,  const void *);

/* LOCAL SUBPROGRAM DECLARATIONS
 */


static void SNMP_MGR_InitDefaultSetting(void);
// static TRAP_EVENT_TrapQueueData_T *SNMP_MGR_QueueDequeue(SNMP_MGR_Queue_T *trap_queue);
// static BOOL_T SNMP_MGR_QueueEnqueue (TRAP_EVENT_TrapQueueData_T *qData, SNMP_MGR_Queue_T *q);

#if (SYS_CPNT_DYING_GASP == TRUE)
BOOL_T SNMP_MGR_SendTrap (TRAP_EVENT_TrapData_T *trap_data_p);
#else
static BOOL_T SNMP_MGR_SendTrap (TRAP_EVENT_TrapData_T *trap_data_p);
#endif

static void SNMP_MGR_SendColdStartTrap(void);
static void SNMP_MGR_SendWarmStartTrap(void);
static UI32_T SNMP_MGR_HandleTrapQueue(UI32_T trap_num);
static void SNMP_MGR_LogLinkUpDownTrap(UI32_T trap_type, UI32_T ifindex,
    UI32_T admin_status, UI32_T oper_status);
static BOOL_T SNMP_MGR_LogLinkStateTrap(
    TRAP_EVENT_TrapData_T *link_state_trap_p);
static BOOL_T SNMP_MGR_GenerateALinkUpDownTrapFromLinkStateTrap(
    TRAP_EVENT_TrapData_T *link_state_trap_p,
    TRAP_EVENT_TrapData_T *link_up_down_trap_p);
static BOOL_T SNMP_MGR_IsLinkStateTrapEmpty(
    TRAP_EVENT_TrapData_T *trap_data_p);

static void SNMP_MGR_TrapLog(TRAP_EVENT_TrapData_T  *trap_data);
static void SNMP_MGR_TrapALog(TRAP_EVENT_TrapData_T  *trap_data);
static int  SNMP_MGR_LogTraps(void);


// static void SNMP_MGR_RifUp_CallBack(UI32_T ip_address, UI32_T ip_mask);
// static void SNMP_MGR_RifDown_CallBack(UI32_T ip_address, UI32_T ip_mask);
static void SNMP_MGR_ClearTrapQueue(void);
// static TRAP_EVENT_TrapQueueData_T *SNMP_MGR_BuildQueueData(void *trapData);
// static void SNMP_MGR_free(void *ptr);
// static void* SNMP_MGR_malloc(size_t size);
static void SNMP_BACKDOOR_Main(void);

/* STATIC VARIABLE DECLARATIONS
 */
#if 0  /* not used in Linux "shared memory queue" implementation */
static SNMP_MGR_Queue_T             trap_queue;
#endif  /* 0 */

static BOOL_T                       is_spanning_tree_stable;
static BOOL_T                       is_prov_complete;

static UI32_T time_to_send_trap_from_spanning_tree;
static UI32_T time_to_send_trap_from_prov_complete;

static UI8_T                        snmp_mgr_snmp_enable_authen_traps;
static UI8_T                        snmp_mgr_snmp_enable_link_up_down_traps;


static I32_T                        up_rif_cnt=0;
// static UI32_T                       memory_used=0;/*max:257552*/
// static UI32_T                       trapDataInQCnt=0;/*max:524*/
static BOOL_T                       flush_trap_queue_done_flag=FALSE;

static SNMP_MGR_SHM_TRAP_QUEUE_T *  shm_trap_queue = NULL;
// #include "snmp_trap_queue.c"

#if (SYS_CPNT_SW_WATCHDOG_TIMER!=TRUE)
#define SNMP_MGR_CheckSoftwareWatchdogEvent()
#endif

/* ---------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_ConvertOidToStr
 * ---------------------------------------------------------------------
 * PURPOSE : Convert object id to string.
 * INPUT   : src_p
 *           src_len
 *           dst_len
 * OUTPUT  : dst_p
 * RETURN  : TRUE/FALSE
 * NOTES   : None.
 * ---------------------------------------------------------------------
 */
BOOL_T SNMP_MGR_ConvertOidToStr(UI32_T *src_p, UI32_T src_len, char *dst_p, UI32_T dst_len)
{
    UI32_T char_printed;
    char buf[11]; /* max length of 2^32 */

    if (   (NULL == src_p)
        || (NULL == dst_p))
    {
        return FALSE;
    }

    *dst_p = '\0';

    if (0 == src_len)
    {
        return TRUE;
    }

    char_printed = 0;

    while (src_len > 0)
    {
        char_printed += sprintf(buf, "%lu.", (unsigned long)*src_p);

        /* current outputed string is equal or larger than dst_len
         * (cannot place '\0'), so that the convert operation is fail.
         */
        if (char_printed >= dst_len)
        {
            return FALSE;
        }

        strcat(dst_p, buf);

        src_p++;
        src_len--;
    }

    /* remove the last '.'
     */
    dst_p[char_printed - 1] = '\0';

    return TRUE;
}

/* ---------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_ConvertStrToOid
 * ---------------------------------------------------------------------
 * PURPOSE : Convert string to object id.
 * INPUT   : src_p
 *           dst_p
 *           dst_max_len
 * OUTPUT  : dst_len_p
 * RETURN  : TRUE/FALSE
 * NOTES   : None.
 * ---------------------------------------------------------------------
 */
BOOL_T SNMP_MGR_ConvertStrToOid(char *src_p, UI32_T *dst_p, UI32_T dst_max_len, UI32_T *dst_len_p)
{
    char *tmp_src_p;
    char *next_digit_p;
    UI32_T length;
    char previous_char = '\0';

    if (   (NULL == src_p)
        || (NULL == dst_p)
        || (NULL == dst_len_p)
        || (0 == dst_max_len))
    {
        return FALSE;
    }

    tmp_src_p = next_digit_p = src_p;
    length = 0;

    while (1)
    {
        if (   (*tmp_src_p < '0' || *tmp_src_p > '9')
            && (*tmp_src_p != '.')
            && (*tmp_src_p != '\0'))
        {
            return FALSE;
        }

        if (   (   ('.' == previous_char)
                && ('.' == *tmp_src_p))
            || (   ('\0' == previous_char)
                && ('.' == *tmp_src_p))
            )
        {
            return FALSE;
        }

        if (   ('\0' == *tmp_src_p)
            || ('.' == *tmp_src_p))
        {
            dst_p[length] = atoi(next_digit_p);
            length++;
            dst_max_len--;

            if ('\0' == *tmp_src_p)
            {
                break;
            }

            if (0 == dst_max_len)
            {
                return FALSE;
            }

            next_digit_p = tmp_src_p + 1;
        }

        previous_char = *tmp_src_p;
        tmp_src_p++;
    }

    *dst_len_p = length;
    return TRUE;
}

/* ---------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_ConvertLInetAddrToInetAddrAndType
 * ---------------------------------------------------------------------
 * PURPOSE : Convert L_INET_Addr_T to InetAddressType/InetAddress pair
 *           and prefix length.
 *
 * INPUT   : in_addr_str_p          - pointer to virtual type L_INET_Addr_T
 *           out_inet_type_p        - pointer to get InetAddressType
 *           out_inet_addr_len_p    - pointer to get length of InetAddress
 *           out_inet_addr_ar_p     - pointer to array to get InetAddress
 *           out_preflen_p          - pointer to get prefix length
 *
 * OUTPUT  : *out_inet_type_p       - InetAddressType
 *           *out_inet_addr_len_p   - length of InetAddress
 *           out_inet_addr_ar_p     - buffer content will get InetAddress
 *           *out_preflen_p         - prefix length
 *
 * RETURN  : TRUE/FALSE
 *
 * NOTE    : 1. Because this is not an export function, buffer size
 *              check is not performed.  The caller must ensure that
 *              input and output buffers have the proper sizes.
 *
 *           2. The output *inet_type_p is the same as L_INET_Addr_T.type.
 *              So, if you only need to get the type, you don't need to
 *              call this function.
 *
 *           3. For IP addresses, input L_INET_AddrIp_T.preflen is
 *              converted to the output.  For DNS, this is ignored.
 *
 *           4. For DNS, the output InetAddress is an octet string,
 *              not a NUL-terminated C-language text string.
 *
 *           5. If this function returns FALSE, some output variables
 *              may already have been modified.  Don't expect them to
 *              remain the same as before calling this function.
 * ---------------------------------------------------------------------
 */
BOOL_T SNMP_MGR_ConvertLInetAddrToInetAddrAndType(L_INET_Addr_T *in_addr_str_p,
    UI32_T *out_inet_type_p,
    UI32_T *out_inet_addr_len_p, UI8_T *out_inet_addr_ar_p, UI32_T *out_preflen_p)
{
    BOOL_T ret = TRUE;  /* assume success; if failed, change to failure */

    /* copy address type:
     *
     * L_INET_ADDR_TYPE_.. values are the same as in RFC 4001.
     */
    *out_inet_type_p = (UI32_T) in_addr_str_p->type;

    /* fill output array length and content based on address type
     */
    switch (in_addr_str_p->type)
    {
        /* unknown(0): convert to unknown(0) for user; give zero-length content
         */
        case L_INET_ADDR_TYPE_UNKNOWN:
            *out_inet_addr_len_p = 0;
            break;

        /* ipv4(1)
         */
        case L_INET_ADDR_TYPE_IPV4:
        {
            L_INET_AddrIp_T *ipaddr_str_p = (L_INET_AddrIp_T *) in_addr_str_p;

            /* InetAddress
             */
            *out_inet_addr_len_p = SYS_TYPE_IPV4_ADDR_LEN;
            memcpy(out_inet_addr_ar_p, ipaddr_str_p->addr, SYS_TYPE_IPV4_ADDR_LEN);

            /* prefix length
             */
            *out_preflen_p = ipaddr_str_p->preflen;
            break;
        }

        /* ipv6(2)
         */
        case L_INET_ADDR_TYPE_IPV6:
        {
            L_INET_AddrIp_T *ipaddr_str_p = (L_INET_AddrIp_T *) in_addr_str_p;

            /* InetAddress
             */
            *out_inet_addr_len_p = SYS_TYPE_IPV6_ADDR_LEN;
            memcpy(out_inet_addr_ar_p, ipaddr_str_p->addr, SYS_TYPE_IPV6_ADDR_LEN);

            /* prefix length
             */
            *out_preflen_p = ipaddr_str_p->preflen;
            break;
        }

        /* ipv4z(3)
         */
        case L_INET_ADDR_TYPE_IPV4Z:
        {
            L_INET_AddrIp_T *ipaddr_str_p = (L_INET_AddrIp_T *) in_addr_str_p;
            UI32_T zone_id_network_order;

            /* InetAddress
             */
            *out_inet_addr_len_p = SYS_TYPE_IPV4Z_ADDR_LEN;
            memcpy(out_inet_addr_ar_p, ipaddr_str_p->addr, SYS_TYPE_IPV4_ADDR_LEN);  /* without zone ID */

            /* zone ID
             */
            zone_id_network_order = L_STDLIB_Hton32(ipaddr_str_p->zoneid);
            memcpy(out_inet_addr_ar_p + SYS_TYPE_IPV4_ADDR_LEN, &zone_id_network_order,
                sizeof(UI32_T));

            /* prefix length
             */
            *out_preflen_p = ipaddr_str_p->preflen;
            break;
        }

        /* ipv6z(4)
         */
        case L_INET_ADDR_TYPE_IPV6Z:
        {
            L_INET_AddrIp_T *ipaddr_str_p = (L_INET_AddrIp_T *) in_addr_str_p;
            UI32_T zone_id_network_order;

            /* InetAddress
             */
            *out_inet_addr_len_p = SYS_TYPE_IPV6Z_ADDR_LEN;
            memcpy(out_inet_addr_ar_p, ipaddr_str_p->addr, SYS_TYPE_IPV6_ADDR_LEN);  /* without zone ID */

            /* zone ID
             */
            zone_id_network_order = L_STDLIB_Hton32(ipaddr_str_p->zoneid);
            memcpy(out_inet_addr_ar_p + SYS_TYPE_IPV6_ADDR_LEN, &zone_id_network_order,
                sizeof(UI32_T));

            /* prefix length
             */
            *out_preflen_p = ipaddr_str_p->preflen;
            break;
        }

        /* dns(16)
         */
        case L_INET_ADDR_TYPE_DNS:
        {
            L_INET_AddrDns_T *dnsaddr_str_p = (L_INET_AddrDns_T *) in_addr_str_p;

            /* InetAddress
             */
            *out_inet_addr_len_p = dnsaddr_str_p->addrlen;
            memcpy(out_inet_addr_ar_p, dnsaddr_str_p->addr, dnsaddr_str_p->addrlen);  /* not NUL-terminated */
            break;
        }

        /* unrecognised
         */
        default:
            ret = FALSE;
            break;
    }

    /* return; single exit point
     */
    return ret;
}

/* ---------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_ConvertInetAddrAndTypeToLInetAddr
 * ---------------------------------------------------------------------
 * PURPOSE : Convert InetAddressType/InetAddress pair and prefix length
 *           to L_INET_Addr_T.
 *
 * INPUT   : in_inet_type       - InetAddressType
 *           in_inet_addr_len   - length of InetAddress
 *           in_inet_addr_ar_p  - pointer to array with InetAddress
 *           in_preflen         - prefix length
 *           out_addr_str_p     - pointer to virtual type L_INET_Addr_T
 *                                to get output
 *
 * OUTPUT  : *out_addr_str_p    - cast pointer of virtual type to real type
 *                                to get output structure
 *
 * RETURN  : TRUE/FALSE
 *
 * NOTE    : 1. Because this is not an export function, buffer size
 *              check is not performed.  The caller must ensure that
 *              input and output buffers have the proper sizes.
 *
 *           2. If "in_preflen" is not needed, fill 0.
 *
 *           3. For DNS, the input InetAddress is an octet string,
 *              C-language text string NUL-termination is not needed.
 *
 *           4. If this function returns FALSE, some output variables
 *              may already have been modified.  Don't expect them to
 *              remain the same as before calling this function.
 * ---------------------------------------------------------------------
 */
BOOL_T SNMP_MGR_ConvertInetAddrAndTypeToLInetAddr(UI32_T in_inet_type,
    UI32_T in_inet_addr_len, UI8_T *in_inet_addr_ar_p, UI32_T in_preflen,
    L_INET_Addr_T *out_addr_str_p)
{
    BOOL_T ret = TRUE;  /* assume success */

    /* fill output structure based on address type
     */
    switch (in_inet_type)
    {
        /* unknown(0): convert to unknown(0) for core layer to get first
         */
        case L_INET_ADDR_TYPE_UNKNOWN:
            out_addr_str_p->type = (UI16_T) in_inet_type;
            break;

        /* ipv4(1)
         */
        case L_INET_ADDR_TYPE_IPV4:
        {
            L_INET_AddrIp_T *ipaddr_str_p = (L_INET_AddrIp_T *) out_addr_str_p;

            /* clear structure of real type
             */
            memset(ipaddr_str_p, 0, sizeof(L_INET_AddrIp_T));

            /* copy address type; L_INET_ADDR_TYPE_.. same as RFC 4001
             */
            ipaddr_str_p->type = (UI16_T) in_inet_type;

            /* copy address length and content
             */
            ipaddr_str_p->addrlen = SYS_TYPE_IPV4_ADDR_LEN;
            memcpy(ipaddr_str_p->addr, in_inet_addr_ar_p, SYS_TYPE_IPV4_ADDR_LEN);

            /* copy prefix length
             */
            ipaddr_str_p->preflen = in_preflen;
            break;
        }

        /* ipv6(2)
         */
        case L_INET_ADDR_TYPE_IPV6:
        {
            L_INET_AddrIp_T *ipaddr_str_p = (L_INET_AddrIp_T *) out_addr_str_p;

            /* clear structure of real type
             */
            memset(ipaddr_str_p, 0, sizeof(L_INET_AddrIp_T));

            /* copy address type; L_INET_ADDR_TYPE_.. same as RFC 4001
             */
            ipaddr_str_p->type = (UI16_T) in_inet_type;

            /* copy address length and content
             */
            ipaddr_str_p->addrlen = SYS_TYPE_IPV6_ADDR_LEN;
            memcpy(ipaddr_str_p->addr, in_inet_addr_ar_p, SYS_TYPE_IPV6_ADDR_LEN);

            /* copy prefix length
             */
            ipaddr_str_p->preflen = in_preflen;
            break;
        }

        /* ipv4z(3)
         */
        case L_INET_ADDR_TYPE_IPV4Z:
        {
            L_INET_AddrIp_T *ipaddr_str_p = (L_INET_AddrIp_T *) out_addr_str_p;
            UI32_T zone_id_network_order;

            /* clear structure of real type
             */
            memset(ipaddr_str_p, 0, sizeof(L_INET_AddrIp_T));

            /* copy address type; L_INET_ADDR_TYPE_.. same as RFC 4001
             */
            ipaddr_str_p->type = (UI16_T) in_inet_type;

            /* copy address length and content without zone ID
             */
            ipaddr_str_p->addrlen = SYS_TYPE_IPV4_ADDR_LEN;
            memcpy(ipaddr_str_p->addr, in_inet_addr_ar_p, SYS_TYPE_IPV4_ADDR_LEN);

            /* copy zone ID
             */
            memcpy(&zone_id_network_order, in_inet_addr_ar_p + SYS_TYPE_IPV4_ADDR_LEN,
                sizeof(UI32_T));
            ipaddr_str_p->zoneid = L_STDLIB_Ntoh32(zone_id_network_order);

            /* copy prefix length
             */
            ipaddr_str_p->preflen = in_preflen;
            break;
        }

        /* ipv6z(4)
         */
        case L_INET_ADDR_TYPE_IPV6Z:
        {
            L_INET_AddrIp_T *ipaddr_str_p = (L_INET_AddrIp_T *) out_addr_str_p;
            UI32_T zone_id_network_order;

            /* clear structure of real type
             */
            memset(ipaddr_str_p, 0, sizeof(L_INET_AddrIp_T));

            /* copy address type; L_INET_ADDR_TYPE_.. same as RFC 4001
             */
            ipaddr_str_p->type = (UI16_T) in_inet_type;

            /* copy address length and content without zone ID
             */
            ipaddr_str_p->addrlen = SYS_TYPE_IPV6_ADDR_LEN;
            memcpy(ipaddr_str_p->addr, in_inet_addr_ar_p, SYS_TYPE_IPV6_ADDR_LEN);

            /* copy zone ID
             */
            memcpy(&zone_id_network_order, in_inet_addr_ar_p + SYS_TYPE_IPV6_ADDR_LEN,
                sizeof(UI32_T));
            ipaddr_str_p->zoneid = L_STDLIB_Ntoh32(zone_id_network_order);

            /* copy prefix length
             */
            ipaddr_str_p->preflen = in_preflen;
            break;
        }

        /* dns(16)
         */
        case L_INET_ADDR_TYPE_DNS:
        {
            L_INET_AddrIp_T *dnsaddr_str_p = (L_INET_AddrIp_T *) out_addr_str_p;

            /* copy address length and content
             */
            dnsaddr_str_p->addrlen = in_inet_addr_len;
            memcpy(dnsaddr_str_p->addr, in_inet_addr_ar_p, in_inet_addr_len);
            dnsaddr_str_p->addr[dnsaddr_str_p->addrlen] = '\0';  /* make NUL-terminated C-string */
            break;
        }

        /* unrecognised
         */
        default:
            ret = FALSE;
            break;
    }

    /* return; single exit point
     */
    return ret;
}

#if (SNMP_MGR_DEBUG_CONTROL == TRUE)

static BOOL_T SNMP_MGR_Debug_Flage = FALSE;
/* ---------------------------------------------------------------------
 * ROUTINE NAME  - SNMP_MGR_Debug
 * ---------------------------------------------------------------------
 * PURPOSE: It is used to print debug message.
 * INPUT: str,type,value,length
 * OUTPUT:
 * RETURN:
 * NOTES: type = m: print message
 *        type = s: print string
 *        type = i: print integer
 *        type = o: oid wite length
 *        type = v: octect wite length
 *        type = t: time
 *        If SNMP_MGR_Debug_Flage = FALSE , it do not show message.
 * ---------------------------------------------------------------------
 */
void SNMP_MGR_Debug(I8_T *str,I8_T type ,I8_T *value, UI32_T length)
{
    oid *oid_value;
    UI32_T i;

    if(SNMP_MGR_Debug_Flage == FALSE)
        return;

    switch(type)
    {
    case 'm':
        printf("\n %s= ",str );
        break;
    case 's':
        printf("\n %s= ",str );
        printf("%s",value);
        break;
    case 'i':
        printf("\n %s= ",str );
        printf("%d", *((int *)value));
        break;
    case 'o':
        printf("\n %s= ",str );
        oid_value =(oid *)value;
        for(i=0;i<length;i++)
        {
            printf("%lu.",(unsigned long)oid_value[i]);
        }
        break;
    case 'f':
        printf("\n%s:%ld", str, *((long *)value));
        break;
    case 't':
        SYS_TIME_GetSystemUpTimeByTick(&i);
        printf("\n%s:time= %lu", str, (unsigned long)i);
        break;
    default:
        printf("\n %s=  ",str );
        for(i=0;i<length;i++)
        {
            printf("%2x ",value[i]);
        }
        break;
    }
}
#endif

/*--trap end--*/
/* EPR ID:
 *  ASF4526B-FLF-P5-00130
 * Problem Description:
 *  IPv6-MGMT-SNMP:It is failed to get related SNMP response through IPv6 address.
 * RootCause:
 *  snmp refine snprintf by wrong API
 * Solution:
 *  use linux lib snprintf
 * Attachments:
 *  snmp_mgr.c agutil.c

int snprintf( char *str, size_t size, const char *format, ...)
{
    return  SYSFUN_Sprintf( str, format);
}*/


/* EXPORTED SUBPROGRAM BODIES
 */

/* FUNCTION	NAME : SNMP_MGR_GetOperationMode
 * PURPOSE:
 *		Get current dhcp operation mode (master / slave / transition).
 *
 * INPUT:
 *		None.
 *
 * OUTPUT:
 *		None.
 *
 * RETURN:
 *		operation_mode
 *
 * NOTES:
 *		None.
 */
SYS_TYPE_Stacking_Mode_T SNMP_MGR_GetOperationMode(void)
{
    return SYSFUN_GET_CSC_OPERATING_MODE();
}

/* Function Name: SNMP_MGR_CheckCompl
 * Purpose      : This function is used to check Octet 's type index, eg IP, Mac Address index
 *                if the data is exceed 255, we will convert it to 255(MAX) and the remain byte will
 *                also set to 255(MAX). This function is for getNext index check issue.
 *                For example, if input index is 10.7.4294967295.5(compl[0]=10, compl[1]=7, compl[2]=
 *                4294967295, compl[3]=5, we will convert it to 10.7.255.255(compl[0]=10, compl[1]=7,
 *                compl[2] = 255, compl[3]=255). Then we can get the right index from GetNext Operation.
 *
 *
 * Input        : begin (The first byte of the compl want to check)
 *              : end   (The End byte of the compl that want to check)
 *              : compl
 *              : max_value (The max value of this index)
 *
 * Output       : compl
 * Return       : None
 * Note         : This fuction is only for SNMP agent internal use only
 * First Created: James, 2002/6/20
 */
void SNMP_MGR_checkCompl(int begin, int end, oid *compl, UI32_T max_value)
{
    int i,j;

    for (i=begin; i<=end; i++)
    {
        if ( compl[i] > max_value)
        {
            for (j=i; j<=end; j++)
            {
                compl[j] = max_value;
            }
        }
    }
    return;
}


/* Function Name: SNMP_MGR_ConvertRemainToZero
 * Purpose      : This function is used to convert the remaing index to zero, if
 *                the compl is not given enough to the number or index, This was
 *                use to solve getnext issue of index that is not enough.
 *
 *
 * Input        : compc  The number of index binding into agent.
 *              : exact  The desired number of index of this table
 *              : compl  The data in which the index store in.
 *
 * Output       : compl
 * Return       : None
 * Note         : This fuction is only for SNMP agent internal use only
 * First Created: James, 2002/6/20
 */
void SNMP_MGR_ConvertRemainToZero(int compc, int exact, oid *compl)
{
    int i;

    for (i= compc; i<exact; i++)
    {
        compl[i]=0;
    }

    return;
}

/* Function Name: SNMP_MGR_ReadStrFromCompl
 * Purpose      : This function is used to convert string that store in an integer Array,
 *					to a Normal form of string
 *				  here is an example of what is a string store in integer Array:
 *					//ip: abcd store in iStr:
 *					UI32_T iStr[4];
 *					iIp[0]=97;//a
 *					iIP[1]=98;//b
 *					iIp[2]=99;//c
 *					iIp[3]=100;//d
 *
 * Output       : result:the result string in normal form that after the conversion
 * Return       : TRUE/FALSE
 * Note         : This fuction is only for SNMP agent internal use only
 * First Created: Phoebe, 2003/1/05
 */
BOOL_T SNMP_MGR_ReadStrFromCompl(oid* compl,UI32_T start, UI32_T end, UI8_T* result)
{
    UI32_T i,idx;
    idx=0;

    if ((start < 0) || (end < 0) || (start > end) || (result==0))
    {

        return FALSE;
    }

    for(i=start; i<=end; i++)
    {
        result[idx]=compl[i];
        idx=idx+1;
    }
    result[idx]=0;

    return TRUE;
}

/* Function Name: SNMP_MGR_ReadOctetFromCompl
 * Purpose      : This function is used to convert string that store in an integer Array,
 *					to a Normal form of string
 *				  here is an example of what is a string store in integer Array:
 *					//ip: abcd store in iStr:
 *					UI32_T iStr[4];
 *					iIp[0]=97;//a
 *					iIP[1]=98;//b
 *					iIp[2]=99;//c
 *					iIp[3]=100;//d
 *
 * Output       : result:the result string in normal form that after the conversion
 * Return       : TRUE/FALSE
 * Note         : This fuction is only for SNMP agent internal use only
 * First Created: Phoebe, 2003/1/05
 */
BOOL_T SNMP_MGR_ReadOctetFromCompl(oid* compl,UI32_T start, UI32_T end, UI8_T* result)
{
    UI32_T i,idx;
    idx=0;

    if ((start < 0) || (end < 0) || (start > end) || (result==0))
    {

        return FALSE;
    }

    for(i=start; i<=end; i++)
    {
        result[idx]=compl[i];
        idx=idx+1;
    }

    return TRUE;
}

/* Function Name: SNMP_MGR_ReadIpFromCompl
 * Purpose      : This function is used to convert ip that store in an integer Array,
 *					to a UI32_T form of IP
 *				  here is an example of what is Ip store in integer Array:
 *					//ip: 10.2.48.55 store in iIp:
 *					UI32_T iIp[4];
 *					iIp[0]=10;
 *					iIP[1]=2;
 *					iIp[2]=48;
 *					iIp[3]=55;
 *
 * Output       : result:the ip in UI32_T form that after the convertion
 * Return       : TRUE/FALSE
 * Note         : This fuction is only for SNMP agent internal use only
 * First Created: Phoebe, 2003/1/05
 */
BOOL_T SNMP_MGR_ReadIpFromCompl(oid* compl,UI32_T start, UI32_T *result)
{
    UI32_T  i;
    char    sIp[15+1];	/*len of "255.255.255.255"=15*/

    if ((start < 0))
    {
        return FALSE;
    }

    for (i = 0; i < SYS_ADPT_IPV4_ADDR_LEN; i++)
    {
        if (compl[start+i] > 255)
        {
            return FALSE;
        }
    }

    sprintf(sIp,"%u.%u.%u.%u",(UI8_T)compl[start],(UI8_T)compl[start+1],(UI8_T)compl[start+2],(UI8_T)compl[start+3]);

    if (!L_INET_Aton((UI8_T *)sIp,result))
    {
        return FALSE;
    }

    return TRUE;
}

/* Function Name: SNMP_MGR_BindIpInstance
 * Purpose      : This function is used to bind the Ip instance back to the agent
 *
 *
 * Return       : TRUE/FALSE
 * Note         : This fuction is only for SNMP agent internal use only
 * First Created: Phoebe, 2003/1/05
 */
BOOL_T SNMP_MGR_BindIpInstance( UI32_T ip, UI32_T start, oid* inst)
{
    UI8_T *p;

    SNMP_MGR_CHECK_OPER_MODE(FALSE);

    if (start<0)
    {

        return FALSE;
    }
    p = (UI8_T *)&ip;
    inst[start] = p[0];
    inst[start+1] = p[1];
    inst[start+2] = p[2];
    inst[start+3] = p[3];

    return TRUE;
}

/* Function Name: SNMP_MGR_BindStrInstance
 * Purpose      : This function is used to bind the string instance back to the agent
 *
 *

 * Return       : TRUE/FALSE
 * Note         : This fuction is only for SNMP agent internal use only
 * First Created: Phoebe, 2003/1/05
 */
BOOL_T SNMP_MGR_BindStrInstance( char* str, UI32_T start, oid* inst)
{
    UI32_T i,idx=0;

    SNMP_MGR_CHECK_OPER_MODE(FALSE);

    if ((start<0)||(str==0))
    {

        return FALSE;
    }
    for(i=start; i<=start+strlen(str)-1; i++)
    {
        inst[i]=str[idx];
        idx=idx+1;
    }

    return TRUE;
}

/* Function Name: SNMP_MGR_BindOctetInstance
 * Purpose      : This function is used to bind the string instance back to the agent
 *
 *

 * Return       : TRUE/FALSE
 * Note         : This fuction is only for SNMP agent internal use only
 * First Created: Phoebe, 2003/1/05
 */
BOOL_T SNMP_MGR_BindOctetInstance( UI8_T* str, UI32_T start, UI32_T end, oid* inst)
{
    UI32_T i,idx=0;

    SNMP_MGR_CHECK_OPER_MODE(FALSE);

    if ((start<0)||(str==0))
    {

         return FALSE;
    }
    for(i=start; i<=end; i++)
    {
        inst[i]=str[idx];
        idx=idx+1;
    }

    return TRUE;
}

/* Function Name: SNMP_MGR_RetrieveCompl
 * Purpose      : This function is used to retreive the compc and compl for Net-SNMP
 *                agent.
 *
 * Input        : *actual_name  It stand for the actually oid of the MIB varible that we desired to get.
 *              : actual_name_length The length of the *actual_name.
 *              : *name   The originally oid(plus index) of the variable in which we press Get/GetNext
 *                        from the SNMP browser.
 *              : *length The length of the *name.
 *              : *compc  Output, we will return the length of the compl for output.
 *              : *compl  Output, the compl pointer that we use for output.
 *              : instance_len  The total length of the compl, for example, if a table have three index
 *                              of UI32_T, then this instance_len will be 3*4 = 12;
 *
 * Output       : compc, compl
 * Return       : None
 * Note         : This fuction is only for NET-SNMP agent only.
 * First Created: James, 2003/11/28
 */
void SNMP_MGR_RetrieveCompl(oid    *actual_name,
                            UI32_T actual_name_length,
                            oid    *name,
                            UI32_T length,
                            UI32_T *compc,
                            oid    *compl,
                            UI32_T instance_len)
{
    SNMP_MGR_CHECK_OPER_MODE_NO_RETURN();

    /* shumin.wang modified for ES4827G-FLF-ZZ-00193 */
    if (length >actual_name_length + instance_len)
    {
        length = actual_name_length + instance_len;
    }
    memset(compl, 0, instance_len * sizeof(UI32_T));
    if (length > actual_name_length)
    {
        if (memcmp(name, actual_name, actual_name_length * sizeof(UI32_T))==0)
        {
            *compc=length-actual_name_length;
            memcpy(compl, name+ actual_name_length, *compc * sizeof(UI32_T));
        }
     }

     return;
}

/*
for debug used only
*/
/*--------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_Print_snmpoid
 *---------------------------------------------------------------------------
 * PURPOSE:  This function use to print out the snmp oid.
 * INPUT:   *snmpoid
 * OUTPUT:  *snmpoid
 * RETURN:  none.
 *
 * NOTE:    none.
 *---------------------------------------------------------------------------
 */
void SNMP_MGR_print_snmpoid(SNMP_TYPE_Oid_T *snmpoid)
{
    int i;
    if (snmpoid->oid_len>0)
    {
        SYSFUN_Debug_Printf("print_snmpoid:");
    }
    for (i=0; i<=snmpoid->oid_len; i++)
    {
        SYSFUN_Debug_Printf("%lu",snmpoid->oid[i]);
        if (i<snmpoid->oid_len)
        {
            SYSFUN_Debug_Printf(".");
        }
        else
        {
            SYSFUN_Debug_Printf("\n");
        }
    }
}



#if   (SYS_CPNT_DBSYNC_TXT == TRUE)
/* 3 com auto save */
/* FUNCTION	NAME : SNMP_MGR_GetTmpDirty
 * PURPOSE:
 *		Get current tmp_dirty flag.
 *
 * INPUT:
 *		*tmp_dirty
 *
 * OUTPUT:
 *		*tmp_dirty
 *
 * RETURN:
 *		TRUE/FALSE
 *
 * NOTES:
 *		None.
 */
BOOL_T  SNMP_MGR_GetTmpDirty(BOOL_T  *tmp_dirty)
{
    UI32_T orig_priority;

    SNMP_MGR_CHECK_OPER_MODE(FALSE);


    *tmp_dirty = snmp_mgr_tmp_dirty;



    return TRUE;
}

/* FUNCTION	NAME : SNMP_MGR_SetTmpDirty
 * PURPOSE:
 *		Get current tmp_dirty flag.
 *
 * INPUT:
 *		*tmp_dirty
 *
 * OUTPUT:
 *		*tmp_dirty
 *
 * RETURN:
 *		TRUE/FALSE
 *
 * NOTES:
 *		None.
 */
BOOL_T  SNMP_MGR_SetTmpDirty(BOOL_T  tmp_dirty)
{
    UI32_T orig_priority;

    SNMP_MGR_CHECK_OPER_MODE(FALSE);


    snmp_mgr_tmp_dirty= tmp_dirty;


    return TRUE;

}
#endif

/*---------------------------------------------------------------------------------
 * Routine Name : SNMP_MGR_StringToObejctID
 *---------------------------------------------------------------------------
 * Purpose :      This function will transform the string to a ObjectID
 * Input    :       text_p
 * Output   :     oid_P, obj_length
 * Return   :      TRUE/FALSE
 * Note     :       None
 *---------------------------------------------------------------------------*/
BOOL_T  SNMP_MGR_StringToObejctID(oid *oid_P, I8_T *text_p, UI32_T *obj_length)
{
    char    *tp;
    UI32_T  no;

    if ( oid_P == NULL )
        return FALSE;

    for ( tp = (char *)text_p, no = 0; ;tp++)
    {
        if ( *tp == '.' || *tp==0)
        {
            oid_P[no++] =  SNMP_MGR_AtoUl((char *)text_p, 10);
            if ( *tp==0 ) break;
            text_p= (I8_T *)(tp+1);
        }
    }
    *obj_length = no;
    return TRUE;
}  /* end of SNMP_MGR_StringToObejctID() */

/*--------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_GetRmonInitFlag
 *---------------------------------------------------------------------------
 * PURPOSE:  This function will get the RMON init flag.
 * INPUT:    flag.
 * OUTPUT:   flag
 * RETURN:   True/False
 * NOTE:     None
 *---------------------------------------------------------------------------
 */
BOOL_T SNMP_MGR_GetRmonInitFlag(BOOL_T *flag)
{
    UI32_T orig_priority;

    *flag = snmp_mgr_rmon_init_flag;

    return TRUE;
}

/*--------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_SetRmonInitFlag
 *---------------------------------------------------------------------------
 * PURPOSE:  This function will set the RMON init flag.
 * INPUT:    flag.
 * OUTPUT:   none
 * RETURN:   True/False
 * NOTE:     None
 *---------------------------------------------------------------------------
 */
BOOL_T SNMP_MGR_SetRmonInitFlag(BOOL_T flag)
{
    UI32_T orig_priority;

    snmp_mgr_rmon_init_flag = flag;

    return TRUE;
}


/*--------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_GetNetSnmpInitFlag
 *---------------------------------------------------------------------------
 * PURPOSE:  This function will get the NetSnmp init flag.
 * INPUT:    flag.
 * OUTPUT:   flag
 * RETURN:   True/False
 * NOTE:     None
 *---------------------------------------------------------------------------
 */
BOOL_T SNMP_MGR_GetNetSnmpInitFlag(BOOL_T *flag)
{
    UI32_T orig_priority;

    *flag = snmp_mgr_netsnmp_init_flag;

    return TRUE;
}


/*--------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_SetNetSnmpInitFlag
 *---------------------------------------------------------------------------
 * PURPOSE:  This function will set the RMON init flag.
 * INPUT:    flag.
 * OUTPUT:   none
 * RETURN:   True/False
 * NOTE:     None
 *---------------------------------------------------------------------------
 */
BOOL_T SNMP_MGR_SetNetSnmpInitFlag(BOOL_T flag)
{
    UI32_T orig_priority;

    snmp_mgr_netsnmp_init_flag = flag;

    return TRUE;
}

/*--------------------------------------------------------------------------
 * FUNCTION NAME - SNMP_MGR_Init
 *--------------------------------------------------------------------------
 * PURPOSE  : Initialize SNMP 's semapore.
 * INPUT    : none
 * OUTPUT   : none
 * RETURN   : none
 * NOTES    : none
 *--------------------------------------------------------------------------*/
void  SNMP_MGR_Init(void)
{

    if (SYSFUN_CreateSem(SYSFUN_SEMKEY_PRIVATE, 1, SYSFUN_SEM_FIFO,
            &snmp_mgr_sem_id) != SYSFUN_OK)
    {
        #if (SYS_CPNT_EH == TRUE)
        EH_MGR_Get_Exception_Info (&module_id, &function_no, &msg_flag, ehmsg, sizeof(ehmsg));
        SYSFUN_Debug_Printf("EHMsg:moduleId=[%lu],funNo=[%lu]:%s",module_id,function_no,ehmsg);
        #endif
        SYSFUN_Debug_Printf(" SNMP_MGR create sempoare fail\n");
        return;
    }

    snmp_mgr_comm_count=0;
    snmp_mgr_user_count=0;
    snmp_mgr_security_to_group_count=0;
    snmp_mgr_group_count=0;
    snmp_mgr_view_count=0;
    snmp_mgr_target_addr_count=0;
    snmp_mgr_target_params_count=0;
    snmp_mgr_notify_count=0;
    snmp_mgr_notify_filter_profile_count = 0;
    snmp_mgr_notify_filter_count = 0;

    /*trap*/
    is_spanning_tree_stable = TRUE;
    is_prov_complete = FALSE;
    time_to_send_trap_from_spanning_tree = 0;
    time_to_send_trap_from_prov_complete = 0;

#if 0  /* not used in Linux "shared memory queue" implementation */
    /* Initialize the trap queue
     */
    trap_queue.front = (TRAP_EVENT_TrapQueueData_T *)NULL;
    trap_queue.rear  = (TRAP_EVENT_TrapQueueData_T *)NULL;
    trap_queue.que_elements_cnt = 0;
#endif  /* 0 */

    return;
} /* end of SNMP_MGR_Init() */

/*--------------------------------------------------------------------------
 * FUNCTION NAME - SNMP_MGR_Create_InterCSC_Relation
 *--------------------------------------------------------------------------
 * PURPOSE  : This function initializes all function pointer registration operations.
 * INPUT    : none
 * OUTPUT   : none
 * RETURN   : none
 * NOTES    : none
 *--------------------------------------------------------------------------*/
void SNMP_MGR_Create_InterCSC_Relation(void)
{

    BACKDOOR_MGR_Register_SubsysBackdoorFunc_CallBack("SNMP",
                                                      SYS_BLD_SNMP_GROUP_IPCMSGQ_KEY,
                                                      SNMP_BACKDOOR_Main);
#if 0
    NETCFG_MGR_RegisterRifUp_CallBack(SNMP_MGR_RifUp_CallBack);
    NETCFG_MGR_RegisterRifDown_CallBack(SNMP_MGR_RifDown_CallBack);
#endif

} /* end of SNMP_MGR_Create_InterCSC_Relation */

/*--------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_IsDebugMode
 *---------------------------------------------------------------------------
 * PURPOSE:  Check if it is in debug mode now
 * INPUT:    None.
 * OUTPUT:
 * RETURN:   True/False
 * NOTE:
 *---------------------------------------------------------------------------
 */
 BOOL_T SNMP_MGR_IsDebugMode(void)
{
    return debug_mode;
}

/*--------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_IsEHMsgEnable
 *---------------------------------------------------------------------------
 * PURPOSE:  Check if the EH message is enable now
 * INPUT:    None.
 * OUTPUT:
 * RETURN:   True/False
 * NOTE:
 *---------------------------------------------------------------------------
 */
BOOL_T SNMP_MGR_IsEHMsgEnable(void)
{
    return EHMsgEnable;
}

/*--------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_GetSnmpCommunityEntry
 *---------------------------------------------------------------------------
 * PURPOSE:  The Get function of  the Rfc2576 CommunityEntry.
 * INPUT:    comm_entry.
 * OUTPUT:   comm_entry
 * RETURN:   SNMP_MGR_ERROR_OK/SNMP_MGR_ERROR_FAIL
 * NOTE:     For SNMP Use only.
 *---------------------------------------------------------------------------
 */
UI32_T SNMP_MGR_GetSnmpCommunityEntry (SNMP_MGR_SnmpCommunityEntry_T *comm_entry)
{
    UI32_T  i;
    UI32_T orig_priority;

    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);



    /* find community string
     */
    for (i=0; i<SYS_ADPT_MAX_NBR_OF_SNMP_COMMUNITY_STRING; i++)
    {
        /* invalid entry
         */
        if (snmp_mgr_comm_entry[i].snmp_community_status == VAL_snmpCommunityStatus_destroy)
            continue;

        /* valid entry
         */
        if (strcmp(comm_entry->snmp_community_index, snmp_mgr_comm_entry[i].snmp_community_index) == 0)
            break;
    }

    if (i == SYS_ADPT_MAX_NBR_OF_SNMP_COMMUNITY_STRING)
    {


        #if (SYS_CPNT_EH == TRUE)
        EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                 0,
                                 EH_TYPE_MSG_NOT_EXIST,
                                (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));
        #endif
        return SNMP_MGR_ERROR_FAIL;
    }

    *comm_entry = snmp_mgr_comm_entry[i];



    return SNMP_MGR_ERROR_OK;
}

/*--------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_GetNextSnmpCommunityEntry
 *---------------------------------------------------------------------------
 * PURPOSE:  The GetNext function of the Rfc2576 CommunityEntry.
 * INPUT:    comm_entry.
 * OUTPUT:   comm_entry
 * RETURN:   SNMP_MGR_ERROR_OK/SNMP_MGR_ERROR_FAIL
 * NOTE:     For SNMP Use only.
 *---------------------------------------------------------------------------
 */
UI32_T SNMP_MGR_GetNextSnmpCommunityEntry( SNMP_MGR_SnmpCommunityEntry_T *comm_entry)
{
    SNMP_MGR_SnmpCommunityEntry_T    tmp_entry;
    UI32_T                      i;
    BOOL_T                      found=FALSE;
    UI32_T orig_priority;

    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);

    if (strlen(comm_entry->snmp_community_index) > SYS_ADPT_MAX_COMM_STR_NAME_LEN)
    {

        #if (SYS_CPNT_EH == TRUE)
         EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                  0,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                 (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));
        #endif
        return SNMP_MGR_ERROR_FAIL;
    }



    /* find community string
     */
    for (i=0; i<SYS_ADPT_MAX_NBR_OF_SNMP_COMMUNITY_STRING; i++)
    {
        /* invalid entry
         */
        if (snmp_mgr_comm_entry[i].snmp_community_status == VAL_snmpCommunityStatus_destroy)
        {
            continue;
        }

        /* valid entry
         */
        if (strcmp(snmp_mgr_comm_entry[i].snmp_community_index, comm_entry->snmp_community_index) > 0)
        {
            if (found == FALSE)
            {
                found = TRUE;
                tmp_entry = snmp_mgr_comm_entry[i];
            }

            if ((strcmp(snmp_mgr_comm_entry[i].snmp_community_index, tmp_entry.snmp_community_index) < 0) &&
                (strcmp(snmp_mgr_comm_entry[i].snmp_community_index, comm_entry->snmp_community_index) > 0))
            {
                tmp_entry = snmp_mgr_comm_entry[i];
            }
        }
    }


    if (found == TRUE)
    {
        *comm_entry = tmp_entry;

        return SNMP_MGR_ERROR_OK;
    }

    #if (SYS_CPNT_EH == TRUE)
    EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                             0,
                             EH_TYPE_MSG_NOT_EXIST,
                            (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));
    #endif

    return SNMP_MGR_ERROR_FAIL;
}

/*--------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_SetSnmpCommunitySecurityName
 *---------------------------------------------------------------------------
 * PURPOSE:  The Set function of the Rfc2576 MIB communuitSecurityName.
 * INPUT:    comm_string_name, sec_name
 * OUTPUT:   none.
 * RETURN:   SNMP_MGR_ERROR_OK/SNMP_MGR_ERROR_FAIL.
 * NOTE:     For SNMP Use only.
 *---------------------------------------------------------------------------
 */
UI32_T SNMP_MGR_SetSnmpCommunitySecurityName(char  *comm_string_name,  char *sec_name)
{
    return SNMP_MGR_ERROR_FAIL;
} /* end of SNMP_MGR_SetSnmpCommunitySecurityName() */

/*--------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_SetSnmpCommunityName
 *---------------------------------------------------------------------------
 * PURPOSE:  The Set function of the Rfc2576 MIB communuitName.
 * INPUT:    comm_string_name, sec_name
 * OUTPUT:   none.
 * RETURN:   SNMP_MGR_ERROR_OK/SNMP_MGR_ERROR_FAIL.
 * NOTE:     For SNMP Use only.
 *---------------------------------------------------------------------------
 */
UI32_T SNMP_MGR_SetSnmpCommunityName(char  *comm_string_name,  char *com_name)
{
    return SNMP_MGR_ERROR_FAIL;
} /* end of SNMP_MGR_SetSnmpCommunityName() */

/*--------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_SetSnmpCommunityStatus
 *---------------------------------------------------------------------------
 * PURPOSE:  The funtion to set the Rfc2576 Community MIB status.
 * INPUT:    comm_string_name, sec_name
 * OUTPUT:   none.
 * RETURN:   SNMP_MGR_ERROR_OK/SNMP_MGR_ERROR_FAIL.
 * NOTE:     For SNMP Use only.
 *---------------------------------------------------------------------------
 */
UI32_T SNMP_MGR_SetSnmpCommunityStatus(char *comm_name, UI32_T row_status)
{
    UI32_T return_val = SNMP_MGR_ERROR_FAIL;
    SNMP_MGR_SnmpCommunityEntry_T comm_entry;
    UI32_T orig_priority;

    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);

    if (strlen(comm_name) > SYS_ADPT_MAX_COMM_STR_NAME_LEN)
    {
         #if (SYS_CPNT_EH == TRUE)
        EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                 0,
                                 EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));
        #endif


        return SNMP_MGR_ERROR_FAIL;
    }
    /* initialize the comm_entry*/
    memset( &comm_entry, 0, sizeof(comm_entry));
    strcpy( comm_entry.snmp_community_index, comm_name);

    switch (row_status)
    {
        case VAL_snmpCommunityStatus_active:
            if (SNMP_MGR_ERROR_OK == SNMP_MGR_GetSnmpCommunityEntry(&comm_entry))
            {
                /*just return ok*/
                if (comm_entry.snmp_community_status == VAL_snmpCommunityStatus_active)
                {
                    return_val = SNMP_MGR_ERROR_OK;
                }
                /*Active the entry, and create the corresponding entry to netsnmp */
                else if (comm_entry.snmp_community_status == VAL_snmpCommunityStatus_notInService)
                {
                    /* if (strcmp(comm_entry.snmp_community_security_name, "DefaultROSecName") ==0)*/
                     if (comm_entry.snmp_community_access_right == SNMP_MGR_ACCESS_RIGHT_READ_ONLY)
                     {

                        return_val = SNMP_MGR_InsertCom2SecList(comm_entry.snmp_community_security_name,
                            comm_entry.snmp_community_name, SNMP_MGR_ACCESS_RIGHT_READ_ONLY);


                         #if (SYS_CPNT_EH == TRUE)
                         if (return_val != SNMP_MGR_ERROR_OK)
                         {
                             EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                                      0,
                                                      EH_TYPE_MSG_FAILED_TO_ADD,
                                                     (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));
                         }
                         #endif
                     }
                     /*else if (strcmp(comm_entry.snmp_community_security_name, "DefaultRWSecName") ==0)*/
                     else if (comm_entry.snmp_community_access_right == SNMP_MGR_ACCESS_RIGHT_READ_WRITE)
                     {

                        return_val = SNMP_MGR_InsertCom2SecList(comm_entry.snmp_community_security_name,
                            comm_entry.snmp_community_name, SNMP_MGR_ACCESS_RIGHT_READ_WRITE);


                         #if (SYS_CPNT_EH == TRUE)
                         if (return_val != SNMP_MGR_ERROR_OK)
                         {
                             EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                                      0,
                                                      EH_TYPE_MSG_FAILED_TO_ADD,
                                                     (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));
                         }
                         #endif
                     }
                     /* for the group specific case, need to check if the corresponding
                        entry already exist in SecurityToGroup Table, if so, need to create
                        a user*/
                     else
                     {
                          SNMP_MGR_SnmpV3UserEntry_T entry;
                         struct  usmUser *newuser;
                         UI8_T   localEngineID[MAXSIZE_snmpEngineID];
                         UI32_T  engineIDLen=0;
                         oid     zerodotzero[2]= { 0 , 0};
                          memset(&entry, 0, sizeof(entry));

                          /*Check V2 model*/
                          entry.snmpv3_user_security_model = SNMP_MGR_SNMPV3_MODEL_V1;
                          strcpy(entry.snmpv3_user_name, comm_entry.snmp_community_name);
                          if (SNMP_MGR_ERROR_OK == SNMP_MGR_GetSecurityToGroupTable(&entry))
                          {
                              if (SNMP_MGR_CheckUsmUserEntry(&entry)!= SNMP_MGR_ERROR_OK)
                              {

                                 newuser = usm_create_user();

                                 if (newuser == NULL)
                                 {
                                 /* just marked cannot create user, here
                                  * don't need to do anything*/
                                 }
                                 else
                                 {

                                     engineIDLen = snmpv3_get_engineID( localEngineID, MAXSIZE_snmpEngineID);
                                     memdup((u_char **)& newuser->engineID, (u_char *)localEngineID,engineIDLen);
                                     newuser->engineIDLen = engineIDLen;
                                     memdup((u_char **)&newuser->cloneFrom,(u_char *)zerodotzero,8);
                                     newuser->cloneFromLen =2;
                                     newuser->secName = strdup (entry.snmpv3_user_name);
                                     newuser->name = strdup (entry.snmpv3_user_name);
                                     newuser->groupName = strdup(entry.snmpv3_user_group_name);
                                     newuser->userModel = entry.snmpv3_user_security_model;
                                     newuser->authType = entry.snmpv3_user_auth_type;
                                     newuser->privType = entry.snmpv3_user_priv_type;
                                     newuser->authPasswd = NULL;
                                     newuser->privPasswd = NULL;
                                      entry.snmpv3_user_security_level = VAL_vacmAccessSecurityLevel_noAuthNoPriv;
                                     newuser->userSecLevel = entry. snmpv3_user_security_level;
                                     usm_add_user(newuser);


                                 }
                             }
                         }

                         /*Check V2 model*/
                         entry.snmpv3_user_security_model = SNMP_MGR_SNMPV3_MODEL_V2C;
                          strcpy(entry.snmpv3_user_name, comm_entry.snmp_community_name);
                          if (SNMP_MGR_ERROR_OK == SNMP_MGR_GetSecurityToGroupTable(&entry))
                          {
                              if (SNMP_MGR_CheckUsmUserEntry(&entry)!= SNMP_MGR_ERROR_OK)
                              {

                                 newuser = usm_create_user();

                                 if (newuser == NULL)
                                 {
                                 /* just marked cannot create user, here
                                  * don't need to do anything*/
                                 }
                                 else
                                 {

                                     snmpv3_get_engineID( localEngineID, MAXSIZE_snmpEngineID);
                                     memdup((u_char **)& newuser->engineID,(u_char *) localEngineID,MAXSIZE_snmpEngineID);
                                     newuser->engineIDLen = engineIDLen;
                                     memdup((u_char **)&newuser->cloneFrom,(u_char *)zerodotzero,8);
                                     newuser->cloneFromLen =2;
                                     newuser->secName = strdup (entry.snmpv3_user_name);
                                     newuser->name = strdup (entry.snmpv3_user_name);
                                     newuser->groupName = strdup(entry.snmpv3_user_group_name);
                                     newuser->userModel = entry.snmpv3_user_security_model;
                                     newuser->authType = entry.snmpv3_user_auth_type;
                                     newuser->privType = entry.snmpv3_user_priv_type;
                                     newuser->authPasswd = NULL;
                                     newuser->privPasswd = NULL;
                                      entry.snmpv3_user_security_level = VAL_vacmAccessSecurityLevel_noAuthNoPriv;
                                     newuser->userSecLevel = entry. snmpv3_user_security_level;
                                     usm_add_user(newuser);


                                 }
                             }
                         }


                        return_val = SNMP_MGR_InsertCom2SecList(comm_entry.snmp_community_security_name,
                            comm_entry.snmp_community_name, SNMP_MGR_ACCESS_RIGHT_GROUP_SPECIFIC);


                         #if (SYS_CPNT_EH == TRUE)
                         if (return_val != SNMP_MGR_ERROR_OK)
                         {
                             EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                                      0,
                                                      EH_TYPE_MSG_FAILED_TO_ADD,
                                                     (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));
                         }
                         #endif
                     }
                     if (return_val == SNMP_MGR_ERROR_OK)
                     {
                         SNMP_MGR_ModifySnmpCommunityStatus(comm_entry.snmp_community_index, VAL_snmpCommunityStatus_active);
                     }
                }
                else
                {
                     #if (SYS_CPNT_EH == TRUE)
                     EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                              0,
                                              EH_TYPE_MSG_INVALID_VALUE,
                                             (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));

                     #endif
                     return_val = SNMP_MGR_ERROR_FAIL;
                }
            }
        break;

        case VAL_snmpCommunityStatus_notInService:
           if (SNMP_MGR_ERROR_OK == SNMP_MGR_GetSnmpCommunityEntry(&comm_entry))
           {
              /*just return ok*/
                if (comm_entry.snmp_community_status == VAL_snmpCommunityStatus_notInService)
                {
                    return_val = SNMP_MGR_ERROR_OK;
                }
                /*Deactive the entry, and destroy the corresponding entry from netsnmp */
                else if (comm_entry.snmp_community_status == VAL_snmpCommunityStatus_active)
                {
                     SNMP_MGR_ModifySnmpCommunityStatus(comm_entry.snmp_community_index, VAL_snmpCommunityStatus_notInService);

                     SNMP_MGR_DeleteCom2SecList(comm_entry.snmp_community_name);

                     return_val = SNMP_MGR_ERROR_OK;
                }
            }
        break;

        case VAL_snmpCommunityStatus_notReady:
        /*  not ready cannot set by user*/
            #if (SYS_CPNT_EH == TRUE)
            EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                     0,
                                     EH_TYPE_MSG_INVALID_VALUE,
                                     (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));

            #endif
            return_val = SNMP_MGR_ERROR_FAIL;

        break;
        case VAL_snmpCommunityStatus_createAndGo:
        case VAL_snmpCommunityStatus_createAndWait:
        /* only when the original entry not exist will take action, otherwise
         * return SNMP_MGR_ERROR_FAIL.
         */
            if (SNMP_MGR_ERROR_OK != SNMP_MGR_GetSnmpCommunityEntry(&comm_entry))
            {
                return_val = SNMP_MGR_CreateSnmpCommunityEntry(&comm_entry);
                #if (SYS_CPNT_EH == TRUE)
                if (return_val != SNMP_MGR_ERROR_OK)
                {
                    EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                             0,
                                             EH_TYPE_MSG_FAILED_TO_ADD,
                                            (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));
                }
               #endif
            }
        break;

        case VAL_snmpCommunityStatus_destroy:
        /* destroy the snmpCommunityEntry database from SNMP_MGR and remove the
         * corresponding entry from netsnmp.
         */
            if (SNMP_MGR_ERROR_OK == SNMP_MGR_GetSnmpCommunityEntry(&comm_entry))
            {
               return_val = SNMP_MGR_ModifySnmpCommunityStatus(comm_entry.snmp_community_index, VAL_snmpCommunityStatus_destroy);
               #if (SYS_CPNT_EH == TRUE)
               if (return_val != SNMP_MGR_ERROR_OK)
               EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                        0,
                                        EH_TYPE_MSG_FAILED_TO_DELETE,
                                       (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));

               #endif
               if (return_val == SNMP_MGR_ERROR_OK)
               {

                   SNMP_MGR_DeleteCom2SecList(comm_entry.snmp_community_name);

               }
            }
        break;
        default:
            #if (SYS_CPNT_EH == TRUE)
            EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                     0,
                                     EH_TYPE_MSG_INVALID_VALUE,
                                    (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));

            #endif
            return_val = SNMP_MGR_ERROR_FAIL;
            break;
    } /* end of switch (row_status)*/

    return return_val;
}

/*--------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_SetSnmpCommunityContextEngineID
 *---------------------------------------------------------------------------
 * PURPOSE:  This function will set the Rfc2576 Community MIB EngineID
 * INPUT:    comm_name, engineID
 * OUTPUT:   none.
 * RETURN:   SNMP_MGR_ERROR_OK/SNMP_MGR_ERROR_FAIL
 * NOTES:    we not support to set engineID in present.
 *---------------------------------------------------------------------------
 */
UI32_T SNMP_MGR_SetSnmpCommunityContextEngineID(char *comm_name, UI8_T *engineID)
{
    return SNMP_MGR_ERROR_FAIL;
}

/*--------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_SetSnmpCommunityContextName
 *---------------------------------------------------------------------------
 * PURPOSE:  This function will set the Rfc2576 Community MIB ContextName
 * INPUT:    comm_name, context_name
 * OUTPUT:   none.
 * RETURN:   SNMP_MGR_ERROR_OK/SNMP_MGR_ERROR_FAIL
 * NOTES:    we not support to set engineID in present.
 *---------------------------------------------------------------------------
 */
UI32_T SNMP_MGR_SetSnmpCommunityContextName(char *comm_name, UI8_T *context_name)
{
    return SNMP_MGR_ERROR_FAIL;
}

/*--------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_SetSnmpCommunityTransportTag
 *---------------------------------------------------------------------------
 * PURPOSE:  This function will set the Rfc2576 Community MIB TransportTag
 * INPUT:    comm_name, transport_tag
 * OUTPUT:   none.
 * RETURN:   SNMP_MGR_ERROR_OK/SNMP_MGR_ERROR_FAIL
 * NOTES:    we not support to set engineID in present.
 *---------------------------------------------------------------------------
 */
UI32_T SNMP_MGR_SetSnmpCommunityTransportTag(char *comm_name, UI8_T *transport_tag)
{
    return SNMP_MGR_ERROR_FAIL;
}

/*--------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_SetSnmpCommunityStorageType
 *---------------------------------------------------------------------------
 * PURPOSE:  This function will set the Rfc2576 Community MIB StorageType
 * INPUT:    comm_name, storage_type
 * OUTPUT:   none.
 * RETURN:   SNMP_MGR_ERROR_OK/SNMP_MGR_ERROR_FAIL
 * NOTES:    we not support to set engineID in present.
 *---------------------------------------------------------------------------
 */
UI32_T SNMP_MGR_SetSnmpCommunityStorageType(char *comm_name, UI32_T storage_type)
{
    UI32_T  i=0;
    UI32_T  return_val = SNMP_MGR_ERROR_FAIL;
    UI32_T orig_priority;
    /* BODY */

    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);

    if( (storage_type< VAL_snmpCommunityStorageType_other)||
        (storage_type > VAL_snmpCommunityStorageType_readOnly))
    {


        return SNMP_MGR_ERROR_FAIL;
    }



    /* find community string
     */
    for (i=0; i<SYS_ADPT_MAX_NBR_OF_SNMP_COMMUNITY_STRING; i++)
    {
        /* invalid entry
         */
        if (snmp_mgr_comm_entry[i].snmp_community_status == VAL_snmpCommunityStatus_destroy)
        {
            continue;
        }

        /* valid entry
         */
        if (strcmp(comm_name, snmp_mgr_comm_entry[i].snmp_community_index) == 0)
            break;
    }


    if (i == SYS_ADPT_MAX_NBR_OF_SNMP_COMMUNITY_STRING)
    {
        /* No found, return SNMP_MGR_ERROR_FAIL
         */
         return_val = SNMP_MGR_ERROR_FAIL;
    }
    else
    {
        /* found an entry, update the value.
         */
        snmp_mgr_comm_entry[i].snmp_community_storage_type = storage_type;
        return_val = SNMP_MGR_ERROR_OK;
    }



    return return_val;
} /* end of SNMP_MGR_SetSnmpCommunityStorageType() */



/*--------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_GetDefaultSnmpCommunityEntry
 *---------------------------------------------------------------------------
 * PURPOSE:  This function will get the Default entry of SnmpCommunityEntry
 * INPUT:    comm_entry
 * OUTPUT:   comm_entry
 * RETURN:   SNMP_MGR_ERROR_OK/SNMP_MGR_ERROR_FAIL
 * NOTES:   none.
 *---------------------------------------------------------------------------
 */
UI32_T SNMP_MGR_GetDefaultSnmpCommunityEntry(SNMP_MGR_SnmpCommunityEntry_T *comm_entry)
{
    UI32_T  return_val = SNMP_MGR_ERROR_FAIL;

    /* BODY */
    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);
    comm_entry->snmp_community_index[0]=0;
    comm_entry->snmp_community_name[0]=0;
    comm_entry->snmp_community_security_name[0]=0;
    SNMP_MGR_GetEngineID(comm_entry->snmp_community_context_engine_id, &comm_entry->snmp_community_engine_id_length);
    comm_entry->snmp_community_context_name[0]=0;
    comm_entry->snmp_community_transport_tag[0]=0;
    comm_entry->snmp_community_access_right = SNMP_MGR_ACCESS_RIGHT_READ_ONLY;
    comm_entry->snmp_community_storage_type=VAL_snmpCommunityStorageType_nonVolatile;
    comm_entry->snmp_community_status= VAL_snmpCommunityStatus_notReady;


    return return_val;
} /* end of SNMP_MGR_GetDefaultSnmpCommunityEntry() */


/*--------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_SetSnmpCommunityEntry
 *---------------------------------------------------------------------------
 * PURPOSE:  This function will set the SnmpCommunityEntry by entry
 * INPUT:    comm_entry
 * OUTPUT:   comm_entry
 * RETURN:   SNMP_MGR_ERROR_OK/SNMP_MGR_ERROR_FAIL
 * NOTES:   This API only for SetbyEntry with RowStatus = 4(createAndGo) and 5(createAndWait).
 *---------------------------------------------------------------------------
 */
UI32_T SNMP_MGR_SetSnmpCommunityEntry(SNMP_MGR_SnmpCommunityEntry_T *comm_entry_ptr)
{
    UI32_T return_val = SNMP_MGR_ERROR_FAIL;
    UI32_T orig_priority;
    /* BODY */

    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);
    if ((strlen(comm_entry_ptr->snmp_community_index) > SYS_ADPT_MAX_COMM_STR_NAME_LEN)||
        (strlen(comm_entry_ptr->snmp_community_name)>SYS_ADPT_MAX_COMM_STR_NAME_LEN) ||
        (strlen(comm_entry_ptr->snmp_community_security_name)>SYS_ADPT_MAX_COMM_STR_NAME_LEN))
    {

        return SNMP_MGR_ERROR_FAIL;
    }

    if ((comm_entry_ptr->snmp_community_status< VAL_snmpCommunityStatus_createAndGo)||
        (comm_entry_ptr->snmp_community_status> VAL_snmpCommunityStatus_createAndWait))
    {

        return SNMP_MGR_ERROR_FAIL;
    }

    switch (comm_entry_ptr->snmp_community_status)
    {

        case VAL_snmpCommunityStatus_createAndWait:
        /* only when the original entry not exist will take action, otherwise
         * return SNMP_MGR_ERROR_FAIL.
         */
        if (SNMP_MGR_ERROR_OK != SNMP_MGR_GetSnmpCommunityEntry(comm_entry_ptr))
        {
            return_val = SNMP_MGR_CreateSnmpCommunityEntry(comm_entry_ptr);
        }
        break;
        case VAL_snmpCommunityStatus_createAndGo:
         /* only when the original entry not exist will take action, otherwise
         * return SNMP_MGR_ERROR_FAIL.
         */
        if (SNMP_MGR_ERROR_OK != SNMP_MGR_GetSnmpCommunityEntry(comm_entry_ptr))
        {
            if (SNMP_MGR_ERROR_FAIL == SNMP_MGR_CreateSnmpCommunityEntry(comm_entry_ptr))
            {
                return SNMP_MGR_ERROR_FAIL;
            }
        }

       /* for the group specific case, need to check if the corresponding
          entry already exist in SecurityToGroup Table, if so, need to create
          a user*/
        {
           SNMP_MGR_SnmpV3UserEntry_T entry;
           struct  usmUser *newuser;
           UI8_T   localEngineID[MAXSIZE_snmpEngineID];
           UI32_T engineIDLen;
           oid     zerodotzero[2]= { 0 , 0};
           memset(&entry, 0, sizeof(entry));

           /*Check V1 model*/
           entry.snmpv3_user_security_model = SNMP_MGR_SNMPV3_MODEL_V1;
           strcpy(entry.snmpv3_user_name, comm_entry_ptr->snmp_community_name);
           if (SNMP_MGR_ERROR_OK == SNMP_MGR_GetSecurityToGroupTable(&entry))
           {
               if (SNMP_MGR_CheckUsmUserEntry(&entry)!= SNMP_MGR_ERROR_OK)
               {

                    newuser = usm_create_user();

                    if (newuser == NULL)
                    {
                     /* just marked cannot create user, here
                      * don't need to do anything*/
                    }
                    else
                    {

                        engineIDLen = snmpv3_get_engineID( localEngineID, MAXSIZE_snmpEngineID);
                        memdup((u_char **)& newuser->engineID, (u_char *)localEngineID, engineIDLen);
                        newuser->engineIDLen = engineIDLen;
                        memdup((u_char **)&newuser->cloneFrom,(u_char *)zerodotzero,8);
                        newuser->cloneFromLen =2;
                        newuser->secName = strdup (entry.snmpv3_user_name);
                        newuser->name = strdup (entry.snmpv3_user_name);
                        newuser->groupName = strdup(entry.snmpv3_user_group_name);
                        newuser->userModel = entry.snmpv3_user_security_model;
                        newuser->authType = entry.snmpv3_user_auth_type;
                        newuser->privType = entry.snmpv3_user_priv_type;
                        newuser->authPasswd = NULL;
                        newuser->privPasswd = NULL;
                        entry.snmpv3_user_security_level = VAL_vacmAccessSecurityLevel_noAuthNoPriv;
                        newuser->userSecLevel = entry. snmpv3_user_security_level;
                        usm_add_user(newuser);

                    }
                }
            }

            /*Check V2 model*/
            entry.snmpv3_user_security_model = SNMP_MGR_SNMPV3_MODEL_V2C;
            strcpy(entry.snmpv3_user_name, comm_entry_ptr->snmp_community_name);
            if (SNMP_MGR_ERROR_OK == SNMP_MGR_GetSecurityToGroupTable(&entry))
            {
                if (SNMP_MGR_CheckUsmUserEntry(&entry)!= SNMP_MGR_ERROR_OK)
                {

                    newuser = usm_create_user();

                    if (newuser == NULL)
                    {
                        /* just marked cannot create user, here
                         * don't need to do anything*/
                    }
                    else
                    {

                        engineIDLen = snmpv3_get_engineID( localEngineID, MAXSIZE_snmpEngineID);
                        memdup((u_char **)& newuser->engineID,(u_char *) localEngineID,engineIDLen);
                        newuser->engineIDLen = engineIDLen;
                        memdup((u_char **)&newuser->cloneFrom,(u_char *)zerodotzero,8);
                        newuser->cloneFromLen =2;
                        newuser->secName = strdup (entry.snmpv3_user_name);
                        newuser->name = strdup (entry.snmpv3_user_name);
                        newuser->groupName = strdup(entry.snmpv3_user_group_name);
                        newuser->userModel = entry.snmpv3_user_security_model;
                        newuser->authType = entry.snmpv3_user_auth_type;
                        newuser->privType = entry.snmpv3_user_priv_type;
                        newuser->authPasswd = NULL;
                        newuser->privPasswd = NULL;
                        entry.snmpv3_user_security_level = VAL_vacmAccessSecurityLevel_noAuthNoPriv;
                        newuser->userSecLevel = entry. snmpv3_user_security_level;
                        usm_add_user(newuser);

                    }
                }
            }


            return_val = SNMP_MGR_InsertCom2SecList(comm_entry_ptr->snmp_community_security_name,
                comm_entry_ptr->snmp_community_name, SNMP_MGR_ACCESS_RIGHT_GROUP_SPECIFIC);

        }
        if (return_val == SNMP_MGR_ERROR_OK)
        {
            SNMP_MGR_ModifySnmpCommunityStatus(comm_entry_ptr->snmp_community_index, VAL_snmpCommunityStatus_active);
        }
        break;
        default:
            return_val = SNMP_MGR_ERROR_FAIL;
            break;
    }


    return return_val;
}

/*--------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_SetDefaultSnmpEngineID
 *---------------------------------------------------------------------------
 * PURPOSE: This function will set the SNMP engineID to default value.
 * INPUT:   None.
 * OUTPUT:  None.
 * RETURN:  1. success: SNMP_MGR_ERROR_OK
 *          2. failure: SNMP_MGR_ERROR_EXCEED_LIMIT
 *                      SNMP_MGR_ERROR_MEM_ALLOC_FAIL
 *                      SNMP_MGR_ERROR_PARAMETER_NOT_MATCH
 *                      SNMP_MGR_ERROR_FAIL
 * NOTE:    This function is called when use the no snmp-server engineID,
 *          it will restore the engineID to default.
 *---------------------------------------------------------------------------
 */
UI32_T SNMP_MGR_SetDefaultSnmpEngineID()
{
    UI32_T  orig_priority;

    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);

    SNMP_MGR_Set_EngineID(snmp_default_engine_id, snmp_default_engine_id_len);

    return SNMP_MGR_ERROR_OK;
}

/*--------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_GetSnmpStatus
 *---------------------------------------------------------------------------
 * PURPOSE:  This function will get the SNMP status .
 * INPUT:    None.
 * OUTPUT:   snmpstats
 * RETURN:   SNMP_MGR_ERROR_OK/SNMP_MGR_ERROR_FAIL
 * NOTE:     1.For CLI only. 2.SNMP_STATS_T is defined in <envoy/h/snmpstats.h>
 *---------------------------------------------------------------------------
 */
UI32_T SNMP_MGR_GetSnmpStatus( SNMP_MGR_STATS_T *snmpstats  )
{
    UI32_T orig_priority;

    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);

    if (snmpstats == NULL)
    {
        #if (SYS_CPNT_EH == TRUE)
            EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                     0,
                                     EH_TYPE_MSG_NULL_POINTER,
                                    (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));

        #endif

        return SNMP_MGR_ERROR_FAIL;
    }


    snmpstats->snmpInPkts = snmp_get_statistic(STAT_SNMP_STATS_START);
    snmpstats->snmpOutPkts =  snmp_get_statistic(STAT_SNMP_STATS_START+1);
    snmpstats->snmpInBadVersions = snmp_get_statistic(STAT_SNMP_STATS_START+2);
    snmpstats->snmpInBadCommunityNames =  snmp_get_statistic(STAT_SNMP_STATS_START+3);
    snmpstats->snmpInBadCommunityUses = snmp_get_statistic(STAT_SNMP_STATS_START+4);
    snmpstats->snmpInASNParseErrs =  snmp_get_statistic(STAT_SNMP_STATS_START+5);
    snmpstats->snmpInTooBigs = snmp_get_statistic(STAT_SNMP_STATS_START+7);
    snmpstats->snmpInNoSuchNames =  snmp_get_statistic(STAT_SNMP_STATS_START+8);
    snmpstats->snmpInBadValues = snmp_get_statistic(STAT_SNMP_STATS_START+9);
    snmpstats->snmpInReadOnlys =  snmp_get_statistic(STAT_SNMP_STATS_START+10);
    snmpstats->snmpInGenErrs = snmp_get_statistic(STAT_SNMP_STATS_START+11);
    snmpstats->snmpInTotalReqVars =  snmp_get_statistic(STAT_SNMP_STATS_START+12);
    snmpstats->snmpInTotalSetVars = snmp_get_statistic(STAT_SNMP_STATS_START+13);
    snmpstats->snmpInGetRequests = snmp_get_statistic(STAT_SNMP_STATS_START+14);
    snmpstats->snmpInGetNexts =  snmp_get_statistic(STAT_SNMP_STATS_START+15);
    snmpstats->snmpInSetRequests = snmp_get_statistic(STAT_SNMP_STATS_START+16);
    snmpstats->snmpInGetResponses =  snmp_get_statistic(STAT_SNMP_STATS_START+17);
    snmpstats->snmpInTraps = snmp_get_statistic(STAT_SNMP_STATS_START+18);
    snmpstats->snmpOutTooBigs =  snmp_get_statistic(STAT_SNMP_STATS_START+19);
    snmpstats->snmpOutNoSuchNames = snmp_get_statistic(STAT_SNMP_STATS_START+20);
    snmpstats->snmpOutBadValues =  snmp_get_statistic(STAT_SNMP_STATS_START+21);
    snmpstats->snmpOutReadOnlys =  snmp_get_statistic(STAT_SNMP_STATS_START+22);
    snmpstats->snmpOutGenErrs = snmp_get_statistic(STAT_SNMP_STATS_START+23);
    snmpstats->snmpOutGetRequests =  snmp_get_statistic(STAT_SNMP_STATS_START+24);
    snmpstats->snmpOutGetNexts = snmp_get_statistic(STAT_SNMP_STATS_START+25);
    snmpstats->snmpOutSetRequests = snmp_get_statistic(STAT_SNMP_STATS_START+26);
    snmpstats->snmpOutGetResponses =  snmp_get_statistic(STAT_SNMP_STATS_START+27);
    snmpstats->snmpOutTraps = snmp_get_statistic(STAT_SNMP_STATS_START+28);
    snmpstats->snmpSilentDrops =  snmp_get_statistic(STAT_SNMP_STATS_START+30);
    snmpstats->snmpProxyDrops = snmp_get_statistic(STAT_SNMP_STATS_START+31);


    return SNMP_MGR_ERROR_OK;
}



/*--------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_GetSnmpCommCounter
 *---------------------------------------------------------------------------
 * PURPOSE:  This function will get  the comm counter/
 * INPUT:    counter.
 * OUTPUT:   counter.
 * RETURN:   SNMP_MGR_ERROR_OK/SNMP_MGR_ERROR_FAIL
 * NOTE:     For SNMP agent internal use only.
 *---------------------------------------------------------------------------
 */
UI32_T  SNMP_MGR_GetSnmpCommCounter(UI32_T  *snmp_counter)
{
    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);
    *snmp_counter = snmp_mgr_comm_count;

    return SNMP_MGR_ERROR_OK;
}


 /*--------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_GetSnmpV3UserCounter
 *---------------------------------------------------------------------------
 * PURPOSE:  This function will get  the snmpv3 user  counter/
 * INPUT:    counter.
 * OUTPUT:   counter.
 * RETURN:   SNMP_MGR_ERROR_OK/SNMP_MGR_ERROR_FAIL
 * NOTE:     For SNMP agent internal use only.
 *---------------------------------------------------------------------------
 */
UI32_T  SNMP_MGR_GetSnmpV3UserCounter(UI32_T  *snmp_counter)
{
    *snmp_counter = 0;

    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);
    *snmp_counter = snmp_mgr_user_count;

    return SNMP_MGR_ERROR_OK;
}


 /*--------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_GetSnmpV3SecurityToGroupCounter
 *---------------------------------------------------------------------------
 * PURPOSE:  This function will get  the snmpv3 user  counter/
 * INPUT:    counter.
 * OUTPUT:   counter.
 * RETURN:   SNMP_MGR_ERROR_OK/SNMP_MGR_ERROR_FAIL
 * NOTE:     For SNMP agent internal use only.
 *---------------------------------------------------------------------------
 */
UI32_T  SNMP_MGR_GetSnmpV3SecurityToGroupCounter(UI32_T  *snmp_counter)
{
    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);

    *snmp_counter = snmp_mgr_security_to_group_count;

    return SNMP_MGR_ERROR_OK;
}


 /*--------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_GetSnmpV3GroupCounter
 *---------------------------------------------------------------------------
 * PURPOSE:  This function will get  the snmpv3 group  counter
 * INPUT:    counter.
 * OUTPUT:   counter.
 * RETURN:   SNMP_MGR_ERROR_OK/SNMP_MGR_ERROR_FAIL
 * NOTE:     For SNMP agent internal use only.
 *---------------------------------------------------------------------------
 */
UI32_T  SNMP_MGR_GetSnmpV3GroupCounter(UI32_T  *snmp_counter)
{
    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);
    *snmp_counter = snmp_mgr_group_count;

    return SNMP_MGR_ERROR_OK;
}


 /*--------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_GetSnmpV3ViewCounter
 *---------------------------------------------------------------------------
 * PURPOSE:  This function will get  the snmpv3 view counter.
 * INPUT:    counter.
 * OUTPUT:   counter.
 * RETURN:   SNMP_MGR_ERROR_OK/SNMP_MGR_ERROR_FAIL
 * NOTE:     For SNMP agent internal use only.
 *---------------------------------------------------------------------------
 */
UI32_T  SNMP_MGR_GetSnmpV3ViewCounter(UI32_T  *snmp_counter)
{
    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);
    *snmp_counter = snmp_mgr_view_count;

    return SNMP_MGR_ERROR_OK;
}


 /*--------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_GetSnmpV3TargetAddrCounter
 *---------------------------------------------------------------------------
 * PURPOSE:  This function will get  the snmpv3 target addr counter.
 * INPUT:    counter.
 * OUTPUT:   counter.
 * RETURN:   SNMP_MGR_ERROR_OK/SNMP_MGR_ERROR_FAIL
 * NOTE:     For SNMP agent internal use only.
 *---------------------------------------------------------------------------
 */
UI32_T  SNMP_MGR_GetSnmpV3TargetAddrCounter(UI32_T  *snmp_counter)
{
    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);
    *snmp_counter = snmp_mgr_target_addr_count;

    return SNMP_MGR_ERROR_OK;
}

 /*--------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_GetSnmpV3TargetParamsCounter
 *---------------------------------------------------------------------------
 * PURPOSE:  This function will get  the snmpv3 target params counter.
 * INPUT:    counter.
 * OUTPUT:   counter.
 * RETURN:   SNMP_MGR_ERROR_OK/SNMP_MGR_ERROR_FAIL
 * NOTE:     For SNMP agent internal use only.
 *---------------------------------------------------------------------------
 */
UI32_T  SNMP_MGR_GetSnmpV3TargetParamsCounter(UI32_T  *snmp_counter)
{
    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);
    *snmp_counter = snmp_mgr_target_params_count;

    return SNMP_MGR_ERROR_OK;
}

 /*--------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_GetSnmpV3NotifyCounter
 *---------------------------------------------------------------------------
 * PURPOSE:  This function will get  the snmpv3 view counter.
 * INPUT:    counter.
 * OUTPUT:   counter.
 * RETURN:   SNMP_MGR_ERROR_OK/SNMP_MGR_ERROR_FAIL
 * NOTE:     For SNMP agent internal use only.
 *---------------------------------------------------------------------------
 */
UI32_T  SNMP_MGR_GetSnmpV3NotifyCounter(UI32_T  *snmp_counter)
{
    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);
    *snmp_counter = snmp_mgr_notify_count;

    return SNMP_MGR_ERROR_OK;
}

/*--------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_GetSnmpV3NotifyFilterProfileCounter
 *---------------------------------------------------------------------------
 * PURPOSE:  This function will get  the snmpv3 notify filter profile counter.
 * INPUT:    counter.
 * OUTPUT:   counter.
 * RETURN:   None.
 * NOTE:     For SNMP agent internal use only.
 *---------------------------------------------------------------------------
 */
void  SNMP_MGR_GetSnmpV3NotifyFilterProfileCounter(UI32_T  *snmp_counter)
{
    SNMP_MGR_CHECK_OPER_MODE_NO_RETURN();
    *snmp_counter = snmp_mgr_notify_filter_profile_count;
}

 /*--------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_GetSnmpV3NotifyFilterCounter
 *---------------------------------------------------------------------------
 * PURPOSE:  This function will get  the snmpv3 notify filter counter.
 * INPUT:    counter.
 * OUTPUT:   counter.
 * RETURN:   None.
 * NOTE:     For SNMP agent internal use only.
 *---------------------------------------------------------------------------
 */
void  SNMP_MGR_GetSnmpV3NotifyFilterCounter(UI32_T  *snmp_counter)
{
    SNMP_MGR_CHECK_OPER_MODE_NO_RETURN();
    *snmp_counter = snmp_mgr_notify_filter_count;
}

 /*--------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_AdjustCommCounter
 *---------------------------------------------------------------------------
 * PURPOSE:  This function will increase the comm counter when a community  is created.
 * INPUT:    mode. (TRUE increase, FALSE descrease)
 * OUTPUT:   None.
 * RETURN:   SNMP_MGR_ERROR_OK/SNMP_MGR_ERROR_FAIL
 * NOTE:     For SNMP agent internal use only.
 *---------------------------------------------------------------------------
 */
UI32_T  SNMP_MGR_AdjustCommCounter(BOOL_T  mode)
{
    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);

    if (mode)
    {
        snmp_mgr_comm_count++;
    }
    else
    {
        snmp_mgr_comm_count--;
    }

    return SNMP_MGR_ERROR_OK;
}


 /*--------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_AdjustSnmpV3UserCounter
 *---------------------------------------------------------------------------
 * PURPOSE:  This function will increase the snmpv3 user  counter when a user  is created.
 * INPUT:    mode.
 * OUTPUT:   None.
 * RETURN:   SNMP_MGR_ERROR_OK/SNMP_MGR_ERROR_FAIL
 * NOTE:     For SNMP agent internal use only.
 *---------------------------------------------------------------------------
 */
UI32_T  SNMP_MGR_AdjustSnmpV3UserCounter(BOOL_T  mode)
{
    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);

    if (mode)
    {
        snmp_mgr_user_count++;
    }
    else
    {
        snmp_mgr_user_count--;
    }

    return SNMP_MGR_ERROR_OK;
}


 /*--------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_AdjustSnmpV3SecurityToGroupCounter
 *---------------------------------------------------------------------------
 * PURPOSE:  This function will increase the snmpv3 securityToGroup  counter when a user  is created.
 * INPUT:    mode.
 * OUTPUT:   None.
 * RETURN:   SNMP_MGR_ERROR_OK/SNMP_MGR_ERROR_FAIL
 * NOTE:     For SNMP agent internal use only.
 *---------------------------------------------------------------------------
 */
UI32_T  SNMP_MGR_AdjustSnmpV3SecurityToGroupCounter(BOOL_T  mode)
{
    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);

    if (mode)
    {
        snmp_mgr_security_to_group_count++;
    }
    else
    {
        snmp_mgr_security_to_group_count--;
    }

    return SNMP_MGR_ERROR_OK;
}


 /*--------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_AdjustSnmpV3GroupCounter
 *---------------------------------------------------------------------------
 * PURPOSE:  This function will increase the snmpv3 group  counter when a group  is created.
 * INPUT:    mode.
 * OUTPUT:   None.
 * RETURN:   SNMP_MGR_ERROR_OK/SNMP_MGR_ERROR_FAIL
 * NOTE:     For SNMP agent internal use only.
 *---------------------------------------------------------------------------
 */
UI32_T  SNMP_MGR_AdjustSnmpV3GroupCounter(BOOL_T  mode)
{
    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);

    if (mode)
    {
        snmp_mgr_group_count++;
    }
    else
    {
        snmp_mgr_group_count--;
    }

    return SNMP_MGR_ERROR_OK;
}


 /*--------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_AdjustSnmpV3ViewCounter
 *---------------------------------------------------------------------------
 * PURPOSE:  This function will increase the snmpv3 view  counter when a view  is created.
 * INPUT:    mode.
 * OUTPUT:   None.
 * RETURN:   SNMP_MGR_ERROR_OK/SNMP_MGR_ERROR_FAIL
 * NOTE:     For SNMP agent internal use only.
 *---------------------------------------------------------------------------
 */
UI32_T  SNMP_MGR_AdjustSnmpV3ViewCounter(BOOL_T  mode)
{
    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);

    if (mode)
    {
        snmp_mgr_view_count++;
    }
    else
    {
        snmp_mgr_view_count--;
    }

    return SNMP_MGR_ERROR_OK;
}

 /*--------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_AdjustSnmpV3TargetAddrCounter
 *---------------------------------------------------------------------------
 * PURPOSE:  This function will increase the snmpv3 target addr  counter when
 *           a target addr entry is created.
 * INPUT:    mode.
 * OUTPUT:   None.
 * RETURN:   SNMP_MGR_ERROR_OK/SNMP_MGR_ERROR_FAIL
 * NOTE:     For SNMP agent internal use only.
 *---------------------------------------------------------------------------
 */
UI32_T  SNMP_MGR_AdjustSnmpV3TargetAddrCounter(BOOL_T  mode)
{
   SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);

   if (mode)
   {
       snmp_mgr_target_addr_count++;
   }
   else
   {
       snmp_mgr_target_addr_count--;
   }

   return SNMP_MGR_ERROR_OK;
}

 /*--------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_AdjustSnmpV3TargetParamsCounter
 *---------------------------------------------------------------------------
 * PURPOSE:  This function will increase the snmpv3 target params  counter
 *           when a target params is created.
 * INPUT:    mode.
 * OUTPUT:   None.
 * RETURN:   SNMP_MGR_ERROR_OK/SNMP_MGR_ERROR_FAIL
 * NOTE:     For SNMP agent internal use only.
 *---------------------------------------------------------------------------
 */
UI32_T  SNMP_MGR_AdjustSnmpV3TargetParamsCounter(BOOL_T  mode)
{
    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);

    if (mode)
    {
        snmp_mgr_target_params_count++;
    }
    else
    {
        snmp_mgr_target_params_count--;
    }

    return SNMP_MGR_ERROR_OK;
}

 /*--------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_AdjustSnmpV3NotifyCounter
 *---------------------------------------------------------------------------
 * PURPOSE:  This function will increase the snmpv3 notify counter when a
 *           notify entry is created.
 * INPUT:    mode.
 * OUTPUT:   None.
 * RETURN:   SNMP_MGR_ERROR_OK/SNMP_MGR_ERROR_FAIL
 * NOTE:     For SNMP agent internal use only.
 *---------------------------------------------------------------------------
 */
UI32_T  SNMP_MGR_AdjustSnmpV3NotifyCounter(BOOL_T  mode)
{
    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);

    if (mode)
    {
        snmp_mgr_notify_count++;
    }
    else
    {
        snmp_mgr_notify_count--;
    }

    return SNMP_MGR_ERROR_OK;
}

/*--------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_AdjustSnmpV3NotifyFilterProfileCounter
 *---------------------------------------------------------------------------
 * PURPOSE:  This function will increase the snmpv3 notify counter when a
 *           notify entry is created.
 * INPUT:    mode.
 * OUTPUT:   None.
 * RETURN:   None.
 * NOTE:     For SNMP agent internal use only.
 *---------------------------------------------------------------------------
 */
void  SNMP_MGR_AdjustSnmpV3NotifyFilterProfileCounter(BOOL_T  mode)
{
    SNMP_MGR_CHECK_OPER_MODE_NO_RETURN();

    if (mode)
    {
        snmp_mgr_notify_filter_profile_count++;
    }
    else
    {
        snmp_mgr_notify_filter_profile_count--;
    }

    return;
}

 /*--------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_AdjustSnmpV3NotifyFilterCounter
 *---------------------------------------------------------------------------
 * PURPOSE:  This function will increase the snmpv3 notify counter when a
 *           notify entry is created.
 * INPUT:    mode.
 * OUTPUT:   None.
 * RETURN:   None.
 * NOTE:     For SNMP agent internal use only.
 *---------------------------------------------------------------------------
 */
void  SNMP_MGR_AdjustSnmpV3NotifyFilterCounter(BOOL_T  mode)
{
    SNMP_MGR_CHECK_OPER_MODE_NO_RETURN();

    if (mode)
    {
        snmp_mgr_notify_filter_count++;
    }
    else
    {
        snmp_mgr_notify_filter_count--;
    }

    return;
}


 /*--------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_ResetCommCounter
 *---------------------------------------------------------------------------
 * PURPOSE:  This function will increase the comm counter when a community  is created.
 * INPUT:    mode. (TRUE increase, FALSE descrease)
 * OUTPUT:   None.
 * RETURN:   SNMP_MGR_ERROR_OK/SNMP_MGR_ERROR_FAIL
 * NOTE:     For SNMP agent internal use only.
 *---------------------------------------------------------------------------
 */
UI32_T  SNMP_MGR_ResetCommCounter()
{
    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);

    snmp_mgr_comm_count=0;

    return SNMP_MGR_ERROR_OK;
}


 /*--------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_ResetSnmpV3UserCounter
 *---------------------------------------------------------------------------
 * PURPOSE:  This function will increase the snmpv3 user  counter when a user  is created.
 * INPUT:    mode.
 * OUTPUT:   None.
 * RETURN:   SNMP_MGR_ERROR_OK/SNMP_MGR_ERROR_FAIL
 * NOTE:     For SNMP agent internal use only.
 *---------------------------------------------------------------------------
 */
UI32_T  SNMP_MGR_ResetSnmpV3UserCounter()
{
    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);

    snmp_mgr_user_count=0;

    return SNMP_MGR_ERROR_OK;
}


 /*--------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_ResetSnmpV3SecurityToGroupCounter
 *---------------------------------------------------------------------------
 * PURPOSE:  This function will increase the snmpv3 securityToGroup  counter when a user  is created.
 * INPUT:    mode.
 * OUTPUT:   None.
 * RETURN:   SNMP_MGR_ERROR_OK/SNMP_MGR_ERROR_FAIL
 * NOTE:     For SNMP agent internal use only.
 *---------------------------------------------------------------------------
 */
UI32_T  SNMP_MGR_ResetSnmpV3SecurityToGroupCounter()
{
    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);
    snmp_mgr_security_to_group_count=0;

    return SNMP_MGR_ERROR_OK;
}


 /*--------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_ResetSnmpV3GroupCounter
 *---------------------------------------------------------------------------
 * PURPOSE:  This function will increase the snmpv3 group  counter when a group  is created.
 * INPUT:    mode.
 * OUTPUT:   None.
 * RETURN:   SNMP_MGR_ERROR_OK/SNMP_MGR_ERROR_FAIL
 * NOTE:     For SNMP agent internal use only.
 *---------------------------------------------------------------------------
 */
UI32_T  SNMP_MGR_ResetSnmpV3GroupCounter()
{
    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);
    snmp_mgr_group_count=0;

    return SNMP_MGR_ERROR_OK;
}

 /*--------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_ResetSnmpV3ViewCounter
 *---------------------------------------------------------------------------
 * PURPOSE:  This function will increase the snmpv3 view  counter when a view  is created.
 * INPUT:    mode.
 * OUTPUT:   None.
 * RETURN:   SNMP_MGR_ERROR_OK/SNMP_MGR_ERROR_FAIL
 * NOTE:     For SNMP agent internal use only.
 *---------------------------------------------------------------------------
 */
UI32_T  SNMP_MGR_ResetSnmpV3ViewCounter()
{
    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);
    snmp_mgr_view_count=0;

    return SNMP_MGR_ERROR_OK;
}

/*--------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_ResetSnmpV3TargetAddrCounter
 *---------------------------------------------------------------------------
 * PURPOSE:  This function will reset the target addr entry counter.
 * INPUT:    mode.
 * OUTPUT:   None.
 * RETURN:   SNMP_MGR_ERROR_OK/SNMP_MGR_ERROR_FAIL
 * NOTE:     For SNMP agent internal use only.
 *---------------------------------------------------------------------------
 */
UI32_T  SNMP_MGR_ResetSnmpV3TargetAddrCounter()
{
    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);
    snmp_mgr_target_addr_count=0;

    return SNMP_MGR_ERROR_OK;
}

 /*--------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_ResetSnmpV3TargetParamsCounter
 *---------------------------------------------------------------------------
 * PURPOSE:  This function will reset the target params counter.
 * INPUT:    mode.
 * OUTPUT:   None.
 * RETURN:   SNMP_MGR_ERROR_OK/SNMP_MGR_ERROR_FAIL.
 * NOTE:     For SNMP agent internal use only.
 *---------------------------------------------------------------------------
 */
UI32_T  SNMP_MGR_ResetSnmpV3TargetParamsCounter()
{
    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);
    snmp_mgr_target_params_count=0;

    return SNMP_MGR_ERROR_OK;
}

/*--------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_ResetSnmpV3NotifyCounter
 *---------------------------------------------------------------------------
 * PURPOSE:  This function will reset the notify counter
 * INPUT:    mode.
 * OUTPUT:   None.
 * RETURN:   SNMP_MGR_ERROR_OK/SNMP_MGR_ERROR_FAIL.
 * NOTE:     For SNMP agent internal use only.
 *---------------------------------------------------------------------------
 */
UI32_T  SNMP_MGR_ResetSnmpV3NotifyCounter()
{
    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);
    snmp_mgr_notify_count=0;

    return SNMP_MGR_ERROR_OK;
}

/*--------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_IncrementTrapSendCounter
 *---------------------------------------------------------------------------
 * PURPOSE:  This function will increase the trap_send counter when a trap is sent
 * INPUT:    None.
 * OUTPUT:   None.
 * RETURN:   SNMP_MGR_ERROR_OK/SNMP_MGR_ERROR_FAIL.
 * NOTE:     snmp_stats is an global variable that store in snmp_mgr, we need
 *           to support an API for trap_mgr to increase this counters
 *---------------------------------------------------------------------------
 */
UI32_T SNMP_MGR_IncrementTrapSendCounter()
{
    UI32_T orig_priority;
    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);

    snmp_increment_statistic(STAT_SNMPOUTPKTS);
    snmp_increment_statistic(STAT_SNMPOUTTRAPS);


    return SNMP_MGR_ERROR_OK;
}


/*--------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_EnterMasterMode
 *---------------------------------------------------------------------------
 * PURPOSE:  This function will make the Snmp 's agent enter the master mode.
 * INPUT:    None.
 * OUTPUT:   None.
 * RETURN:   None.
 * NOTE:     None.
 *---------------------------------------------------------------------------
 */
void SNMP_MGR_EnterMasterMode()
{
    SYSFUN_ENTER_MASTER_MODE();
    SNMP_MGR_InitNetSnmpAgent();
    SNMP_MGR_InitDefaultSetting();
    SNMP_MGR_initSysObjectID();
    SNMP_MGR_initTrapEs3626a();

#if(SYS_CPNT_CLUSTER==TRUE)
    SNMP_CLUSTER_InitRole();
#endif

    SNMP_MGR_SetDefaultSnmpEngineID();
}


/*--------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_EnterSlaveMode
 *---------------------------------------------------------------------------
 * PURPOSE:  This function will make the Snmp 's agent enter the Slave mode.
 * INPUT:    None.
 * OUTPUT:   None.
 * RETURN:   None.
 * NOTE:     None.
 *---------------------------------------------------------------------------
 */
void SNMP_MGR_EnterSlaveMode()
{
    snmp_mgr_agent_status= FALSE;
    SYSFUN_ENTER_SLAVE_MODE();
}


/*--------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_EnterTransitionMode
 *---------------------------------------------------------------------------
 * PURPOSE:  This function will make the Snmp 's agent enter the transition mode.
 * INPUT:    None.
 * OUTPUT:   None.
 * RETURN:   None.
 * NOTE:     None.
 *---------------------------------------------------------------------------
 */
void SNMP_MGR_EnterTransitionMode()
{
    UI32_T          i;
    UI32_T orig_priority;

    /* Clear all Entry
     */

    memset(&snmp_mgr_trap_receiver, 0, sizeof(snmp_mgr_trap_receiver));

    for (i = 0; i<SYS_ADPT_MAX_NBR_OF_TRAP_RECEIVER; i++)
    {
        snmp_mgr_trap_receiver[i].trap_dest_protocol = VAL_trapDestProtocol_ip;
        snmp_mgr_trap_receiver[i].trap_dest_status = VAL_snmpTargetAddrRowStatus_destroy;
    }



#if (SYS_CPNT_SNMP_CONTIGUOUS_TRAP_DEST_TABLE == TRUE)
    /* total number of occupied entries in the index table
     */
    snmp_mgr_trap_receiver_total = 0;
#endif

    /* BODY */
    is_spanning_tree_stable = FALSE;
    is_prov_complete = FALSE;
    up_rif_cnt=0;

    time_to_send_trap_from_spanning_tree = 0;
    time_to_send_trap_from_prov_complete = 0;
}


/* FUNCTION	NAME : SNMP_MGR_SetTransitionMode
 * PURPOSE:
 *		Set transition mode.
 *
 * INPUT:
 *		None.
 *
 * OUTPUT:
 *		None.
 *
 * RETURN:
 *		None.
 *
 * NOTES:
 *		None.
 */
void SNMP_MGR_SetTransitionMode(void)
{
    UI32_T task_id;

    SNMP_TASK_GetTaskId(&task_id);

    /*1. Set mode to transition mode, prevent new traps comes in*/
    SYSFUN_SET_TRANSITION_MODE();

    /*2. wait all csc leave*/
    SYSFUN_ENTER_TRANSITION_MODE();

    /*3. init flushqueue flag as false*/
    flush_trap_queue_done_flag=FALSE;

    /*4. send tcn event to traptask to flush trap queue*/
    if (SYSFUN_SendEvent (task_id, SNMP_MGR_EVENT_ENTER_TRANSITION)!=SYSFUN_OK)
    {
        if (debug_mode)
            printf("SNMP_MGR_SetTransitionMode:SYSFUN_SendEvent return false\n");
    }

#if 0
    /*5. raise trap priority to ensure traptask can wake up to receive the tcn event and flush trap queue successfully.*/
    if (SYSFUN_SetTaskPriority(task_id, SYS_BLD_RAISE_TO_HIGH_PRIORITY)!=SYSFUN_OK)
    {
        if (debug_mode)
            printf("SNMP_MGR_SetTransitionMode:SYSFUN_SetTaskPriority(SYS_BLD_RAISE_TO_HIGH_PRIORITY) return false\n");
    }
#endif

    /*6. wait all trap done*/
    SYSFUN_TASK_ENTER_TRANSITION_MODE(flush_trap_queue_done_flag);

#if 0
    /*7. restore trap priority*/
    if (SYSFUN_SetTaskPriority(task_id, SYS_BLD_SNMP_TASK_PRIORITY)!=SYSFUN_OK)
    {
        if (debug_mode)
            printf("SNMP_MGR_SetTransitionMode:SYSFUN_SetTaskPriority(SYS_BLD_SNMP_TASK_PRIORITY) return false\n");
    }
#endif
    return;
}

/*--------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_CreateSnmpV3UserWithCfgDB
 *---------------------------------------------------------------------------
 * PURPOSE : This function is used to create a SNMPv3 user.
 * INPUT   : entry                  -- the detail information of the user
 *           need_to_write_cfgdb    -- to write to cfgdb or not (0 or 1)
 *           is_auto_create         -- create this user is requested by
 *                                     system internal but not user.
 * OUTPUT  : None.
 * RETURN  : 1. success:    SNMP_MGR_ERROR_OK
 *           2. failure:    SNMP_MGR_ERROR_EXCEED_LIMIT
 *                          SNMP_MGR_ERROR_MEM_ALLOC_FAIL
 *                          SNMP_MGR_ERROR_PARAMETER_NOT_MATCH
 *                          SNMP_MGR_ERROR_FAIL
 *---------------------------------------------------------------------------
 */
static UI32_T
SNMP_MGR_CreateSnmpV3UserWithCfgDB(
    SNMP_MGR_SnmpV3UserEntry_T *entry,
    UI32_T need_to_write_cfgdb,
    BOOL_T is_auto_create)
{
    char    line[SNMP_MGR_SPRINT_MAX_LEN];
    struct  usmUser *newuser=NULL;
    UI8_T   localEngineID[MAXSIZE_snmpEngineID];
    UI32_T  engineIDLen;
    u_char  userKey[SNMP_MAXBUF_SMALL];
    size_t  userKeyLen = SNMP_MAXBUF_SMALL;
    /* add for aes 256
     */
    size_t  extendkey_len = 0;
    size_t  shortkey_len  = 0;
    UI32_T  ret;
    char    model[SNMP_MGR_SPRINT_MAX_LEN];
    char    community[COMMUNITY_MAX_LEN];
    char    secname[SNMP_MGR_SPRINT_MAX_LEN];
    UI32_T  retval;
    BOOL_T  createusm = TRUE;
    SNMP_MGR_SnmpCommunity_T comm_entry;
    oid     zerodotzero[2]= { 0 , 0};
    UI32_T orig_priority;

    /* Create a user will effect in create usmuser and vacmSecurityToGroup Entry in SNMPV3 Database
     * If the model is v1/v2c, then also will effect com2SecEntry in SNMPV3 Database.
     */
    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);

    /* check user name, group name is valid?
     */
    if ((strlen(entry->snmpv3_user_name) > MAXSIZE_usmUserName) ||
        (strlen(entry->snmpv3_user_name) < MINSIZE_usmUserName) ||
        (strlen(entry->snmpv3_user_group_name) > MAXSIZE_vacmGroupName) ||
        (strlen(entry->snmpv3_user_group_name) < MINSIZE_vacmGroupName))
    {
#if (SYS_CPNT_EH == TRUE)
        EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                 0,
                                 EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                 (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));
#endif

        return SNMP_MGR_ERROR_FAIL;
    }

    /* check auth password is valid ?
     * we need to check password len only
     * if (model ==3) and (pass from config == FALSE) and ( level = authNoPriv or authPriv)
     */
    if (((strlen(entry->snmpv3_user_auth_password) > MAX_SNMPV3_PASSWORD_LEN) ||
        (strlen(entry->snmpv3_user_auth_password) < MIN_SNMPV3_PASSWORD_LEN)) &&
        ((entry->password_from_config == FALSE) &&
        (entry->snmpv3_user_security_model == SNMP_MGR_SNMPV3_MODEL_V3)) &&
        ((entry->snmpv3_user_security_level == VAL_vacmAccessSecurityLevel_authNoPriv) ||
        (entry->snmpv3_user_security_level == VAL_vacmAccessSecurityLevel_authPriv)))

    {
#if (SYS_CPNT_EH == TRUE)
        EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                 0,
                                 EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                 (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));
#endif

        return SNMP_MGR_ERROR_FAIL;
    }

    /* check priv password is valid ?
     * we need to check password len only
     * if (model ==3) and (pass from config == FALSE) and ( level =  authPriv)
     */
    if (((strlen(entry->snmpv3_user_priv_password) > MAX_SNMPV3_PASSWORD_LEN) ||
        (strlen(entry->snmpv3_user_priv_password) < MIN_SNMPV3_PASSWORD_LEN)) &&
        ((entry->password_from_config == FALSE) &&
        (entry->snmpv3_user_security_model == SNMP_MGR_SNMPV3_MODEL_V3) &&
        (entry->snmpv3_user_security_level == VAL_vacmAccessSecurityLevel_authPriv)))
    {
#if (SYS_CPNT_EH == TRUE)
        EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                 0,
                                 EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                 (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));
#endif

        return SNMP_MGR_ERROR_FAIL;
    }

    /* check if have already reach the max size of usmUserEntry, vacmSecurityToGroupEntry and commEntry
     */

    /* Check user
     */
    if ((snmp_mgr_user_count >=SNMP_MGR_MAX_NBR_OF_SNMPV3_USER ) &&
        (SNMP_MGR_CheckUsmUserEntry(entry)!= SNMP_MGR_ERROR_OK))
    {
#if (SYS_CPNT_EH == TRUE)
        EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                 0,
                                 EH_TYPE_MSG_MAXIMUM_EXCEEDED,
                                 (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));
#endif

        return SNMP_MGR_ERROR_FAIL;
    }

   /* Check SecurityToGroup Entry have reach the max number or not
    */
    if ((snmp_mgr_security_to_group_count >= SNMP_MGR_MAX_NBR_OF_SNMPV3_SECURITYTOGROUP) &&
        (SNMP_MGR_CheckSecurityToGroupTable(entry) != SNMP_MGR_ERROR_OK))
    {
#if (SYS_CPNT_EH == TRUE)
        EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                 0,
                                 EH_TYPE_MSG_MAXIMUM_EXCEEDED,
                                 (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));
#endif

        return SNMP_MGR_ERROR_FAIL;
    }

    /* Check if the desired created user is already an community string if the model is v1/v2c
     */
    strcpy( comm_entry.comm_string_name, entry->snmpv3_user_name);

    if ((SNMP_MGR_CheckSnmpCommunity(&comm_entry) == SNMP_MGR_ERROR_OK) &&
        (entry->snmpv3_user_security_model != SNMP_MGR_SNMPV3_MODEL_V3) &&
        (comm_entry.access_right != SNMP_MGR_ACCESS_RIGHT_GROUP_SPECIFIC))
    {
#if (SYS_CPNT_EH == TRUE)
        EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                 0,
                                 EH_TYPE_MSG_MAXIMUM_EXCEEDED,
                                 (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));
#endif

        return SNMP_MGR_ERROR_FAIL;
    }

    /* Step 1: Analyze if there already have an existing entry:
     *         Check if the usmUserEntry entry is already exist, and delete it if it already exist.
     *         The rules of finding a usmUserEntry is :
     *         a. For V1/V2c Model, if we find an usmUserEntry exist, we should not delete it and we will
     *         set the createusm to FALSE and not create the usmUserEntry.
     *         b. For V3 Model, if we find an usmUserEntry exist, we should delete it.
     *         The rules of finding a vacmSecurityToGroupEntry is:
     *         a. delete it if an entry is matched
     */

    /* v1 or v2c model
     */
    if (( entry->snmpv3_user_security_model == SNMP_MGR_SNMPV3_MODEL_V2C) ||
        ( entry->snmpv3_user_security_model == SNMP_MGR_SNMPV3_MODEL_V1))
    {
        if (SNMP_MGR_CheckUsmUserEntry(entry) == SNMP_MGR_ERROR_OK)
        {
              createusm = FALSE;
        }

    }
    else if (entry->snmpv3_user_security_model == SNMP_MGR_SNMPV3_MODEL_V3)
    {
        if (SNMP_MGR_CheckUsmUserEntry(entry) == SNMP_MGR_ERROR_OK)
        {
            SNMP_MGR_DeleteUsmUserEntry(entry->snmpv3_user_name);
        }

        if (need_to_write_cfgdb == 1)
        {
#if (SYS_CPNT_CFGDB == TRUE)
#if (SYS_CPNT_SNMP_COMMUNITY_IN_CFGDB == TRUE)
            /* Delete the user and remove from cfgdb
             */
            for(i = 0; i < SNMP_MGR_MAX_NBR_OF_SNMPV3_USER; i ++)
            {
                if(strcmp(snmp_mgr_v3_user_entry[i].snmpv3_user_name,
                          entry->snmpv3_user_name) == 0)
                {
                    memcpy(&snmp_mgr_v3_user_entry[i],
                           0,
                           sizeof(SNMP_MGR_SnmpV3UserEntry_T));
                    snmp_mgr_v3_user_entry[i].snmpv3_user_status =
                        VAL_usmUserStatus_destroy;

                    break;
                }

            }

            CFGDB_MGR_WriteSection(snmp_mgr_v3_user_session_handler, snmp_mgr_v3_user_entry);
#endif  /* end of #if (SYS_CPNT_SNMP_COMMUNITY_IN_CFGDB == TRUE) */
#endif  /* end of #if (SYS_CPNT_CFGDB == TRUE) */
        }

    }

    if (SNMP_MGR_CheckSecurityToGroupTable(entry) == SNMP_MGR_ERROR_OK)
    {
        SNMP_MGR_DeleteSecurityToGroupEntry(entry->snmpv3_user_security_model,
                                            entry->snmpv3_user_name);
    }

    /* Step 2 Create UsmUserEntry
     */
    if (createusm)
    {

        newuser = usm_create_user();


        if (newuser == NULL)
        {
#if (SYS_CPNT_EH == TRUE)
            EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                     0,
                                     EH_TYPE_MSG_MAXIMUM_EXCEEDED,
                                     (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));
#endif

            return SNMP_MGR_ERROR_EXCEED_LIMIT;
        }


        engineIDLen = snmpv3_get_engineID( localEngineID, MAXSIZE_snmpEngineID);


        memdup((u_char **)& newuser->engineID, (u_char *) localEngineID, engineIDLen);
        newuser->engineIDLen = engineIDLen;

        memdup((u_char **)&newuser->cloneFrom, (u_char *)zerodotzero, 8);
        newuser->cloneFromLen = 2;

        newuser->secName = strdup (entry->snmpv3_user_name);
        newuser->name = strdup (entry->snmpv3_user_name);
        newuser->groupName = strdup(entry->snmpv3_user_group_name);
        newuser->userModel = entry->snmpv3_user_security_model;
        newuser->authType = entry->snmpv3_user_auth_type;
        newuser->privType = entry->snmpv3_user_priv_type;
        newuser->authPasswd = NULL;
        newuser->privPasswd = NULL;
        newuser->is_auto_destroy = is_auto_create;

        /* if the given storage type is invalid, we give a default storage type NONVOLATILE
         */
        if ((entry->snmpv3_user_storage_type < VAL_usmUserStorageType_other) ||
            (entry->snmpv3_user_storage_type > VAL_usmUserStorageType_readOnly))
        {
            newuser->userStorageType = VAL_usmUserStorageType_nonVolatile;
        }
        else
        {
            newuser->userStorageType = entry->snmpv3_user_storage_type;
        }

        /* if not v3 model, force to set security level to noauth
         */
        if (( entry->snmpv3_user_security_model == SNMP_MGR_SNMPV3_MODEL_V2C) ||
            ( entry->snmpv3_user_security_model == SNMP_MGR_SNMPV3_MODEL_V1))
        {
             entry->snmpv3_user_security_level = VAL_vacmAccessSecurityLevel_noAuthNoPriv;
        }

        newuser->userSecLevel = entry->snmpv3_user_security_level;

        /* NoAuth Type
         */
        if (entry->snmpv3_user_security_level == VAL_vacmAccessSecurityLevel_noAuthNoPriv)
        {

            usm_add_user(newuser);

        }

        /* Authentication Type
         */
        else if (entry->snmpv3_user_security_level ==
                 VAL_vacmAccessSecurityLevel_authNoPriv)
        {
            if ( entry->snmpv3_user_auth_type == SNMP_MGR_SNMPV3_AUTHTYPE_MD5)
            {
                 memcpy(newuser->authProtocol, usmHMACMD5AuthProtocol,
                 sizeof(usmHMACMD5AuthProtocol));
            }
            else if ( entry->snmpv3_user_auth_type == SNMP_MGR_SNMPV3_AUTHTYPE_SHA )
            {
                memcpy(newuser->authProtocol, usmHMACSHA1AuthProtocol,
                sizeof(usmHMACSHA1AuthProtocol));
            }
            else
            {

                usm_free_user(newuser);
#if (SYS_CPNT_EH == TRUE)
                EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                         0,
                                         EH_TYPE_MSG_INVALID_PARAMETER,
                                         (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));
#endif


                return SNMP_MGR_ERROR_PARAMETER_NOT_MATCH ; /* unknown authtype */
            }

            if ( entry->password_from_config == TRUE)
            {
                if ( entry->snmpv3_user_auth_key_len > SNMP_MGR_SNMPV3_SHA_KEY_LEN)
                {

                    usm_free_user(newuser);
#if (SYS_CPNT_EH == TRUE)
                    EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                             0,
                                             EH_TYPE_MSG_INVALID_PARAMETER,
                                             (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));
#endif


                    return SNMP_MGR_ERROR_PARAMETER_NOT_MATCH ;   /*no authentication pass phrase*/
                }

                /* auth key
                 */
                memdup((u_char **)&newuser->authKey,
                       (u_char *)entry->snmpv3_user_auth_key,
                       entry->snmpv3_user_auth_key_len);
                newuser->authKeyLen = entry->snmpv3_user_auth_key_len;
            }
            else  /* if passnot from config */
            {
                if (strcmp( entry->snmpv3_user_auth_password, "")== 0)
                {

                    usm_free_user(newuser);
#if (SYS_CPNT_EH == TRUE)
                    EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                             0,
                                             EH_TYPE_MSG_INVALID_PARAMETER,
                                             (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));
#endif


                    return SNMP_MGR_ERROR_PARAMETER_NOT_MATCH ;   /*no authentication pass phrase*/
                }

                /* And turn it into a localized key
                 */


                ret = generate_Ku(newuser->authProtocol,
                                  newuser->authProtocolLen,
                                  (u_char *)entry->snmpv3_user_auth_password,
                                  strlen( entry->snmpv3_user_auth_password),
                                  userKey,
                                  &userKeyLen);



                if (ret != SNMPERR_SUCCESS)
                {
                    config_perror("could not generate the authentication key from the "
                                  "suppiled pass phrase.");


                    usm_free_user(newuser);
#if (SYS_CPNT_EH == TRUE)
                       EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                                0,
                                                EH_TYPE_MSG_FAILED_TO_ADD,
                                                (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));
#endif


                    return SNMP_MGR_ERROR_PARAMETER_NOT_MATCH ;
                }



                newuser->authKeyLen = sc_get_properlength(newuser->authProtocol,
                                                          newuser->authProtocolLen);
                newuser->authKey = (u_char *) malloc(newuser->authKeyLen);

                ret = generate_kul(newuser->authProtocol,
                                   newuser->authProtocolLen,
                                   newuser->engineID,
                                   newuser->engineIDLen,
                                   userKey,
                                   userKeyLen,
                                   newuser->authKey,
                                   &newuser->authKeyLen);



                if (ret != SNMPERR_SUCCESS)
                {
                     config_perror("could not generate localized authentication key (Kul) "
                                   "from the master key (Ku).");


                     usm_free_user(newuser);
#if (SYS_CPNT_EH == TRUE)
                     EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                              0,
                                              EH_TYPE_MSG_FAILED_TO_ADD,
                                              (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));
#endif


                     return SNMP_MGR_ERROR_PARAMETER_NOT_MATCH ;
                }
            } /*end of if passnot from config)*/


            usm_add_user(newuser);


        } /* end of if auth type*/

        /* AuthPriv Type
         */
        else if (entry->snmpv3_user_security_level ==
                 VAL_vacmAccessSecurityLevel_authPriv)
        {
            if ( entry->snmpv3_user_auth_type == SNMP_MGR_SNMPV3_AUTHTYPE_MD5)
            {
                memcpy(newuser->authProtocol, usmHMACMD5AuthProtocol,
                    sizeof(usmHMACMD5AuthProtocol));
            }
            else if ( entry->snmpv3_user_auth_type == SNMP_MGR_SNMPV3_AUTHTYPE_SHA )
            {
                memcpy(newuser->authProtocol, usmHMACSHA1AuthProtocol,
                    sizeof(usmHMACSHA1AuthProtocol));
            }
            else
            {

                usm_free_user(newuser);
#if (SYS_CPNT_EH == TRUE)
                EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                         0,
                                         EH_TYPE_MSG_INVALID_PARAMETER,
                                         (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));
#endif


                return SNMP_MGR_ERROR_PARAMETER_NOT_MATCH ; /* unknown  authtype */
            }

         /* READ: Privacy Type
          */
         if ( entry->snmpv3_user_priv_type == SNMP_MGR_SNMPV3_PRIVTYPE_DES )
         {
             memcpy(newuser->privProtocol, usmDESPrivProtocol,
                 sizeof(usmDESPrivProtocol));
         }
         else if(entry->snmpv3_user_priv_type == SNMP_MGR_SNMPV3_PRIVTYPE_3DES)
         {
             memcpy(newuser->privProtocol, usm3DESPrivProtocol,
                 sizeof(usm3DESPrivProtocol));
         }
         else if( entry->snmpv3_user_priv_type == SNMP_MGR_SNMPV3_PRIVTYPE_AES128 )
         {
             memcpy(newuser->privProtocol, usmAES128PrivProtocol,
                 sizeof(usmAES128PrivProtocol));
         }
         else if( entry->snmpv3_user_priv_type == SNMP_MGR_SNMPV3_PRIVTYPE_AES192 )
         {
             memcpy(newuser->privProtocol, usmAES192PrivProtocol,
                 sizeof(usmAES192PrivProtocol));
         }
         else if( entry->snmpv3_user_priv_type == SNMP_MGR_SNMPV3_PRIVTYPE_AES256 )
         {
             memcpy(newuser->privProtocol, usmAES256PrivProtocol,
                 sizeof(usmAES256PrivProtocol));
         }
         else
         {
             config_perror("Unknown privacy protocol");


             usm_free_user(newuser);
#if (SYS_CPNT_EH == TRUE)
             EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                      0,
                                      EH_TYPE_MSG_INVALID_PARAMETER,
                                      (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));
#endif


             return SNMP_MGR_ERROR_PARAMETER_NOT_MATCH ; /* Unknown privacy protocol */
         }

         if ((!entry->password_from_config) &&
             (strcmp( entry->snmpv3_user_auth_password, "") == 0))
         {

             usm_free_user(newuser);
#if (SYS_CPNT_EH == TRUE)
             EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                      0,
                                      EH_TYPE_MSG_INVALID_PARAMETER,
                                      (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));
#endif


             return SNMP_MGR_ERROR_PARAMETER_NOT_MATCH ; /* no authentication pass phrase*/
            }

        /* And turn it into a localized key
         */

        /* check password is from config
         */
        if ( entry->password_from_config == TRUE)
        {
            if ((entry->snmpv3_user_auth_key_len > SNMP_MGR_SNMPV3_SHA_KEY_LEN) ||
                (entry->snmpv3_user_priv_key_len > SNMP_MGR_SNMPV3_MAX_KEY_LEN))
            {

                usm_free_user(newuser);
#if (SYS_CPNT_EH == TRUE)
                EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                         0,
                                         EH_TYPE_MSG_INVALID_PARAMETER,
                                         (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));
#endif


                return SNMP_MGR_ERROR_PARAMETER_NOT_MATCH ;
            }

            /* auth key
             */
            memdup((u_char **)&newuser->authKey, (u_char *)entry->snmpv3_user_auth_key,
                entry->snmpv3_user_auth_key_len);
            newuser->authKeyLen = entry->snmpv3_user_auth_key_len;

            /* priv key
             */
            memdup((u_char **)&newuser->privKey, (u_char *)entry->snmpv3_user_priv_key,
                entry->snmpv3_user_priv_key_len);

            switch(newuser->privType)
            {
                 case SNMP_MGR_SNMPV3_PRIVTYPE_AES192:
                 case SNMP_MGR_SNMPV3_PRIVTYPE_AES256:
                 case SNMP_MGR_SNMPV3_PRIVTYPE_3DES:
                     newuser->privKeyLen = sc_get_priv_properlength(newuser->privProtocol,
                                                                    newuser->privProtocolLen);
                     break;

                 default:
                     newuser->privKeyLen = sc_get_properlength(newuser->authProtocol,
                                                               newuser->authProtocolLen);
                     break;

            }

        }
        else
        {
            newuser->authPasswd = strdup(entry->snmpv3_user_auth_password);
            newuser->privPasswd= strdup(entry->snmpv3_user_priv_password);



            ret = generate_Ku(newuser->authProtocol,
                              newuser->authProtocolLen,
                              (u_char *) entry->snmpv3_user_auth_password,
                              strlen( entry->snmpv3_user_auth_password),
                              userKey,
                              &userKeyLen);



            if (ret != SNMPERR_SUCCESS)
            {
                config_perror("could not generate the authentication key from the "
                              "suppiled pass phrase.");


                usm_free_user(newuser);
#if (SYS_CPNT_EH == TRUE)
                EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                         0,
                                         EH_TYPE_MSG_FAILED_TO_ADD,
                                         (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));
#endif


                return SNMP_MGR_ERROR_PARAMETER_NOT_MATCH ;
            }


            newuser->authKeyLen = sc_get_properlength(newuser->authProtocol,
                                                      newuser->authProtocolLen);
            newuser->authKey = (u_char *) malloc(newuser->authKeyLen);

            ret = generate_kul(newuser->authProtocol,
                               newuser->authProtocolLen,
                               newuser->engineID,
                               newuser->engineIDLen,
                               userKey,
                               userKeyLen,
                               newuser->authKey,
                               &newuser->authKeyLen);



            if (ret != SNMPERR_SUCCESS)
            {
                config_perror("could not generate localized authentication key (Kul) "
                              "from the master key (Ku).");


                usm_free_user(newuser);
#if (SYS_CPNT_EH == TRUE)
                EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                         0,
                                         EH_TYPE_MSG_FAILED_TO_ADD,
                                         (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));
#endif


                return SNMP_MGR_ERROR_PARAMETER_NOT_MATCH ;
            }

            if (strcmp(entry->snmpv3_user_priv_password, "" ) == 0)
            {
                /* assume the same as the authentication key
                 */
                memdup((u_char **)&newuser->privKey, (u_char *)newuser->authKey, newuser->authKeyLen);
                newuser->privKeyLen = newuser->authKeyLen;
            }
            else
            {
                /* And turn it into a localized key
                 */


                ret = generate_Ku(newuser->authProtocol,
                                  newuser->authProtocolLen,
                                  (u_char *) entry->snmpv3_user_priv_password,
                                  strlen(entry->snmpv3_user_priv_password ),
                                  userKey,
                                  &userKeyLen);



                if (ret != SNMPERR_SUCCESS)
                {
                    config_perror("could not generate privacy key from the supplied "
                                  "pass phrase.");


                    usm_free_user(newuser);
#if (SYS_CPNT_EH == TRUE)
                    EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                             0,
                                             EH_TYPE_MSG_FAILED_TO_ADD,
                                             (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));
#endif


                    return SNMP_MGR_ERROR_PARAMETER_NOT_MATCH ; /*could not generate privacy key from the supplied */
                }

                /* modify for AES
                 */
                shortkey_len  = sc_get_properlength(newuser->authProtocol,
                                                    newuser->authProtocolLen);
                switch(newuser->privType)
                {
                    case SNMP_MGR_SNMPV3_PRIVTYPE_AES192:
                    case SNMP_MGR_SNMPV3_PRIVTYPE_AES256:
                    case SNMP_MGR_SNMPV3_PRIVTYPE_3DES:
                        extendkey_len = sc_get_priv_properlength(newuser->privProtocol,
                                                                 newuser->privProtocolLen);
                    break;

                    default:
                        extendkey_len = sc_get_properlength(newuser->authProtocol,
                                                            newuser->authProtocolLen);
                    break;

                }

                ret = ((shortkey_len < extendkey_len) ? extendkey_len : shortkey_len);

                if (ret < 0)
                {
                    config_perror("could not get proper key length to use for the "
                                  "privacy algorithm.");


                    usm_free_user(newuser);
#if (SYS_CPNT_EH == TRUE)
                    EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                             0,
                                             EH_TYPE_MSG_FAILED_TO_ADD,
                                             (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));
#endif


                    return SNMP_MGR_ERROR_PARAMETER_NOT_MATCH ;  /* Could not get proper key length to use for the  privacy algorithm. */
                }

                newuser->privKeyLen = ret;
                newuser->privKey = (u_char *) malloc(newuser->privKeyLen);



                ret = generate_kul(newuser->authProtocol,
                                   newuser->authProtocolLen,
                                   newuser->engineID,
                                   newuser->engineIDLen,
                                   userKey,
                                   userKeyLen,
                                   newuser->privKey,
                                   &newuser->privKeyLen);

                /* for AES 192 and 256, the key needs be extended.
                 */
                if(shortkey_len < extendkey_len)
                {
                    SNMP_MGR_Extend_PrviKey(newuser->authProtocol,
                                            newuser->authProtocolLen,
                                            newuser->privType,
                                            newuser->engineID,
                                            newuser->engineIDLen,
                                            newuser->privKey,
                                            shortkey_len,
                                            extendkey_len,
                                            newuser->privKey,
                                            &newuser->privKeyLen);
                }



                if (ret != SNMPERR_SUCCESS)
                {
                    config_perror("could not generate the localized privacy key (Kul) "
                                  "from the master key (Ku).");


                    usm_free_user(newuser);
#if (SYS_CPNT_EH == TRUE)
                    EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                             0,
                                             EH_TYPE_MSG_FAILED_TO_ADD,
                                             (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));
#endif


                    return SNMP_MGR_ERROR_PARAMETER_NOT_MATCH ;  /* could not generate the localized privacy key (Kul)*/
                }

            }  /* if password == NULL */

        }  /* password_from_config == TRUE */


        usm_add_user(newuser);


        } /* end of priv type */

        else /* Otherwise free the user */
        {

            usm_free_user(newuser);
#if (SYS_CPNT_EH == TRUE)
            EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                     0,
                                     EH_TYPE_MSG_FAILED_TO_ADD,
                                     (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));
#endif


            return SNMP_MGR_ERROR_PARAMETER_NOT_MATCH ;  /* unknow snmp Security Level */
        }



        if (need_to_write_cfgdb == 1)
        {
#if (SYS_CPNT_CFGDB == TRUE)
#if (SYS_CPNT_SNMP_COMMUNITY_IN_CFGDB == TRUE)

        /* Create the user and add to cfgdb
         */
        for(i = 0; i < SNMP_MGR_MAX_NBR_OF_SNMPV3_USER; i++)
        {
            if(snmp_mgr_v3_user_entry[i].snmpv3_user_status ==
               VAL_usmUserStatus_destroy)
            {
                memcpy(&snmp_mgr_v3_user_entry[i],
                       entry,
                       sizeof(SNMP_MGR_SnmpV3UserEntry_T));
                snmp_mgr_v3_user_entry[i].snmpv3_user_status =
                    VAL_usmUserStatus_active;
                break;
            }

        }

        CFGDB_MGR_WriteSection(snmp_mgr_v3_user_session_handler, snmp_mgr_v3_user_entry);
#endif  /* end of #if (SYS_CPNT_SNMP_COMMUNITY_IN_CFGDB == TRUE) */
#endif  /* end of #if (SYS_CPNT_CFGDB == TRUE) */
        }



    } /* end of createusm */

    /* Step 3 Create Security To Group Table
     */

    strcpy(model, "any");

    if(  entry->snmpv3_user_security_model == SNMP_MGR_SNMPV3_MODEL_V3)
    {
        /* maybe security model type
         */
        strcpy(model, "usm");

        /* sec->group mapping
         */
        /* group   anonymousGroupNameNUM
         * any     anonymousSecNameNUM
         */
        SYSFUN_Sprintf(line, "%s %s %s volatile",
                       entry->snmpv3_user_group_name, model, entry->snmpv3_user_name);


        retval = vacm_parse_group("group", line, is_auto_create);


        if (retval != SNMP_MGR_ERROR_OK)
        {
            if (createusm)
            {
                usm_remove_user(newuser);
                usm_free_user(newuser);
            }

#if (SYS_CPNT_EH == TRUE)
                EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                         0,
                                         EH_TYPE_MSG_FAILED_TO_ADD,
                                         (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));

#endif


            return SNMP_MGR_ERROR_PARAMETER_NOT_MATCH;    /* unknown  authtype */
        }

        return SNMP_MGR_ERROR_OK;
    }
    else if((entry->snmpv3_user_security_model == SNMP_MGR_SNMPV3_MODEL_V2C) ||
            (entry->snmpv3_user_security_model == SNMP_MGR_SNMPV3_MODEL_V1))
    {
        /* com2sec mapping
         */
        /*
         * com2sec anonymousSecNameNUM    ADDRESS  COMMUNITY
         */

        sprintf(secname, "%s", entry->snmpv3_user_name);
        strcpy ( community, secname);

        /* kinghong marked, since we will not allowed to create an user if the
         * community is exist, so this check is no longer necessary
         */
#if 1

        memset( &comm_entry, 0, sizeof(comm_entry));

        /* if the community already exist, remove it
         */
        strcpy( comm_entry.comm_string_name, community);

        if (SNMP_MGR_CheckSnmpCommunity(&comm_entry) == SNMP_MGR_ERROR_OK )
        {

            SNMP_MGR_DeleteCom2SecList(comm_entry.comm_string_name);

            SNMP_MGR_ModifySnmpCommunityStatus(comm_entry.comm_string_name,
                                               VAL_snmpCommunityStatus_destroy);
        }

#endif

        retval = SNMP_MGR_InsertCom2SecList(secname,
                                            community,
                                            SNMP_MGR_ACCESS_RIGHT_GROUP_SPECIFIC);


        if (retval != SNMP_MGR_ERROR_OK)
        {
#if (SYS_CPNT_EH == TRUE)
            EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                     0,
                                     EH_TYPE_MSG_FAILED_TO_ADD,
                                     (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));

#endif
            if (createusm)
            {

               usm_remove_user(newuser);
               usm_free_user(newuser);

            }

            return retval;
        }
        else
        {
            SNMP_MGR_SnmpCommunityEntry_T snmp_comm_entry;

            memset(&snmp_comm_entry,0, sizeof(snmp_comm_entry));

            strcpy(snmp_comm_entry.snmp_community_index, community);
            strcpy(snmp_comm_entry.snmp_community_name, community);
            strcpy(snmp_comm_entry.snmp_community_security_name, community);

            snmp_comm_entry.snmp_community_access_right =
                SNMP_MGR_ACCESS_RIGHT_GROUP_SPECIFIC;

            SNMP_MGR_CreateSnmpCommunityEntry(&snmp_comm_entry);
            SNMP_MGR_ModifySnmpCommunityStatus(community, VAL_snmpCommunityStatus_active);
        }

        /* sec->group mapping
         */
        /* group   anonymousGroupNameNUM
         * any     anonymousSecNameNUM
         */

        if (entry->snmpv3_user_security_model == SNMP_MGR_SNMPV3_MODEL_V2C)
        {
            SYSFUN_Sprintf(line, "%s v2c %s volatile", entry->snmpv3_user_group_name, secname );
        }
        else /* v1 */
        {
            SYSFUN_Sprintf(line, "%s v1 %s volatile", entry->snmpv3_user_group_name, secname);
        }


        retval = vacm_parse_group("group", line, is_auto_create);


        if (retval != SNMP_MGR_ERROR_OK)
        {

#if (SYS_CPNT_EH == TRUE)
            EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                     0,
                                     EH_TYPE_MSG_FAILED_TO_ADD,
                                     (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));

#endif
            if (createusm)
            {
                usm_remove_user(newuser);
                usm_free_user(newuser);
            }

            return SNMP_MGR_ERROR_PARAMETER_NOT_MATCH;    /* unknown  authtype */
        }

        return SNMP_MGR_ERROR_OK;
    }
#if (SYS_CPNT_EH == TRUE)
    EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                             0,
                             EH_TYPE_MSG_FAILED_TO_ADD,
                             (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));

#endif

    return SNMP_MGR_ERROR_PARAMETER_NOT_MATCH ;
}

/* ---------------------------------------------------------------------
 *  ROUTINE NAME  - SNMP_MGR_ProvisionComplete
 * ---------------------------------------------------------------------
 *  FUNCTION: Cold start trap must wait until provision complete before
 *            send request can be process properly.
 *  INPUT    : None.
 *  OUTPUT   : None.
 *  RETURN   : None.
 *  NOTE     : None.
 * ---------------------------------------------------------------------
 */
void SNMP_MGR_ProvisionComplete(void)
{
    UI32_T boot_reason;
    #if (SYS_CPNT_EH == TRUE)
    UI32_T module_id;
    UI32_T function_no;
    UI32_T msg_flag;
    UI8_T  ehmsg[256];
    #endif/*end of #if (SYS_CPNT_EH == TRUE)*/
    UI32_T my_unit_id;

    #if (SYS_CPNT_CFGDB == TRUE)
    {
        UI32_T engineIDBufLen=0;
        UI8_T engineIDBuf[MAXSIZE_snmpEngineID]={0};
        const UI8_T zero_engine_id[MAXSIZE_snmpEngineID]={0};

        engineIDBufLen =
        snmpv3_get_engineID(engineIDBuf, MAXSIZE_snmpEngineID);
        /*
         * set our local engineTime in the LCD timing cache
         */
        setup_engineBoots(snmp_mgr_engine_info.engine_boots);
        set_enginetime(engineIDBuf, engineIDBufLen,
                       snmpv3_local_snmpEngineBoots(),
                       snmpv3_local_snmpEngineTime(), TRUE);

        if(memcmp(snmp_mgr_engine_info.engineid, zero_engine_id, sizeof(snmp_mgr_engine_info.engineid))== 0 )
        {
            /* If engine id is all zero, that means it's first time boot, set engine boot to 1 and copy the engine id */
            snmp_mgr_engine_info.engine_boots = 1;

            memset(snmp_mgr_engine_info.engineid, 0, sizeof(snmp_mgr_engine_info.engineid));
            memcpy(snmp_mgr_engine_info.engineid, engineIDBuf, engineIDBufLen);
        }
        else
        {
            /* If generated engine id is the same as CFGDB, increase the engine boot;
             * Otherwise, it's set to new engine id, reset the engine boot to 1
             */
            if(memcmp(snmp_mgr_engine_info.engineid, engineIDBuf, engineIDBufLen)==0)
            {
                snmp_mgr_engine_info.engine_boots++;
            }
            else
            {
                snmp_mgr_engine_info.engine_boots = 1;

                memset(snmp_mgr_engine_info.engineid, 0, sizeof(snmp_mgr_engine_info.engineid));
                memcpy(snmp_mgr_engine_info.engineid, engineIDBuf, engineIDBufLen);
            }
        }

        CFGDB_MGR_WriteSection(snmp_mgr_engine_info_session_handler, &snmp_mgr_engine_info);
    }
    #endif

    if (debug_mode)
        printf("SNMP_MGR_ProvisionComplete...\n");

    if(!STKTPLG_POM_GetMyUnitID(&my_unit_id))
    {
        SYSFUN_Debug_Printf("SNMP_MGR_ProvisionComplete:STKTPLG_MGR_GetMyUnitID failure\n");
        return;
    }
    if(!STKTPLG_POM_GetUnitBootReason(my_unit_id, &boot_reason))
    {
        SYSFUN_Debug_Printf("SNMP_MGR_ProvisionComplete:STKTPLG_MGR_GetUnitBootReason failure\n");
        #if (SYS_CPNT_EH == TRUE)
        if (EHMsgEnable)
        {
            EH_MGR_Get_Exception_Info (&module_id, &function_no, &msg_flag, ehmsg, sizeof(ehmsg));
            SYSFUN_Debug_Printf("EHMsg:moduleId=[%lu],funNo=[%lu]:%s",module_id,function_no,ehmsg);
        }
        #endif/*end of #if (SYS_CPNT_EH == TRUE)*/
        return;
    }

    if(boot_trap_is_sent==FALSE)
    {
        switch (boot_reason)
        {
            case STKTPLG_OM_REBOOT_FROM_COLDSTART:
                SNMP_MGR_SendColdStartTrap();
                break;
            case STKTPLG_OM_REBOOT_FROM_WARMSTART:
                SNMP_MGR_SendWarmStartTrap();
                break;
            default:
                SYSFUN_Debug_Printf("SNMP_MGR_ProvisionComplete:STKTPLG_OM_SYSTEM_REBOOT_FROM_RUNTIME_PROVISION...\n");
                break;
        }
        boot_trap_is_sent=TRUE;
    }

#if (SYS_CPNT_SNMPV3_DEFAULT_USER == TRUE)
    {
        int i;
        BOOL_T flag1 = FALSE;  /* Default user admin exists or not */
        BOOL_T flag2 = FALSE;  /* Default user monitor exists or not */

#if (SYS_CPNT_USERAUTH_MANAGER_STYLE == SYS_CPNT_USERAUTH_MANAGER_STYLE_3COM)
        BOOL_T flag3 = FALSE;  /* Default user manager exists or not */
#endif

        /* Create users saved in cfgdb
         */
        for(i = 0; i < SNMP_MGR_MAX_NBR_OF_SNMPV3_USER; i++)
        {
            if(snmp_mgr_v3_user_entry[i].snmpv3_user_status == VAL_usmUserStatus_active)
            {
                SNMP_MGR_CreateSnmpV3UserWithCfgDB(&snmp_mgr_v3_user_entry[i], 0, FALSE);
            }

            /* Check if default user admin exist
             */
            if(!flag1 && strcmp(snmp_mgr_v3_user_entry[i].snmpv3_user_name, SYS_DFLT_SNMPV3_ADMIN_USERNAME) == 0)
            {
                /* Default user admin already exist
                 */
                flag1 = TRUE;
            }

            /* Check if default user monitor exist
             */
            if(!flag2 && strcmp(snmp_mgr_v3_user_entry[i].snmpv3_user_name, SYS_DFLT_SNMPV3_GUEST_USERNAME) == 0)
            {
                /* Default user monitor already exist
                 */
                flag2 = TRUE;
            }
#if (SYS_CPNT_USERAUTH_MANAGER_STYLE == SYS_CPNT_USERAUTH_MANAGER_STYLE_3COM)
            /* Check if default user manager exists*/
            if(!flag3 && strcmp(snmp_mgr_v3_user_entry[i].snmpv3_user_name, SYS_DFLT_SNMPV3_MANAGER_USERNAME) == 0)
            {
                /* Default user manager already exist
                 */
                flag3 = TRUE;
            }
#endif
        }

        /* Default user admin not exist
         */
        if (!flag1)
        {
            memset(&defaultuser1, 0, sizeof(SNMP_MGR_SnmpV3UserEntry_T));
            strcpy(defaultuser1.snmpv3_user_name, SYS_DFLT_SNMPV3_ADMIN_USERNAME);
            strcpy(defaultuser1.snmpv3_user_group_name, SYS_DFLT_SNMPV3_ADMIN_GROUPNAME);
            strcpy(defaultuser1.snmpv3_user_auth_password, SYS_DFLT_SNMPV3_ADMIN_AUTHPASSWORD);
            defaultuser1.snmpv3_user_auth_type = SNMP_MGR_SNMPV3_AUTHTYPE_MD5;
            defaultuser1.snmpv3_user_security_level = SYS_DFLT_SNMPV3_ADMIN_USERLEVEL;
            defaultuser1.snmpv3_user_storage_type = VAL_usmUserStorageType_nonVolatile;
            defaultuser1.snmpv3_user_security_model = SNMP_MGR_SNMPV3_MODEL_V3;
            defaultuser1.snmpv3_user_status = VAL_usmUserStatus_active;

            SNMP_MGR_CreateSnmpV3UserWithCfgDB(&defaultuser1, 1, FALSE);
        }
        /* Default user monitor not exist
         */
        if (!flag2)
        {
            memset(&defaultuser2, 0, sizeof(SNMP_MGR_SnmpV3UserEntry_T));
            strcpy(defaultuser2.snmpv3_user_name, SYS_DFLT_SNMPV3_GUEST_USERNAME );
            strcpy(defaultuser2.snmpv3_user_group_name, SYS_DFLT_SNMPV3_GUEST_GROUPNAME);
            strcpy(defaultuser2.snmpv3_user_auth_password, SYS_DFLT_SNMPV3_GUEST_AUTHPASSWORD);
            defaultuser2.snmpv3_user_auth_type = SNMP_MGR_SNMPV3_AUTHTYPE_MD5;
            defaultuser2.snmpv3_user_security_level = SYS_DFLT_SNMPV3_GUEST_USERLEVEL;
            defaultuser2.snmpv3_user_storage_type = VAL_usmUserStorageType_nonVolatile;
            defaultuser2.snmpv3_user_security_model = SNMP_MGR_SNMPV3_MODEL_V3;
            defaultuser2.snmpv3_user_status = VAL_usmUserStatus_active;

            SNMP_MGR_CreateSnmpV3UserWithCfgDB(&defaultuser2, 1, FALSE);
        }
#if (SYS_CPNT_USERAUTH_MANAGER_STYLE == SYS_CPNT_USERAUTH_MANAGER_STYLE_3COM)
        /* Default user manager not exist
         */
        if (!flag3)
        {
            memset(&defaultuser3, 0, sizeof(SNMP_MGR_SnmpV3UserEntry_T));
            strcpy(defaultuser3.snmpv3_user_name, SYS_DFLT_SNMPV3_MANAGER_USERNAME );
            strcpy(defaultuser3.snmpv3_user_group_name, SYS_DFLT_SNMPV3_MANAGER_GROUPNAME);
            strcpy(defaultuser3.snmpv3_user_auth_password, SYS_DFLT_SNMPV3_MANAGER_AUTHPASSWORD);
            defaultuser3.snmpv3_user_auth_type = SNMP_MGR_SNMPV3_AUTHTYPE_MD5;
            defaultuser3.snmpv3_user_security_level = SYS_DFLT_SNMPV3_MANAGER_USERLEVEL;
            defaultuser3.snmpv3_user_storage_type = VAL_usmUserStorageType_nonVolatile;
            defaultuser3.snmpv3_user_security_model = SNMP_MGR_SNMPV3_MODEL_V3;
            defaultuser3.snmpv3_user_status = VAL_usmUserStatus_active;

            SNMP_MGR_CreateSnmpV3UserWithCfgDB(&defaultuser3, 1, FALSE);
        }
#endif
    }
#endif

    /* set expected ready time for trap to send
     *
     * ASF4612MMS-FLF-08-00943, Zhong Qiyao <qiyao_zhong>, 2011.11.30
     * Trap/NetCfg: if the only link-up port is the craft port, it should be able to send out traps
     *
     * Root Cause:
     * SNMP Trap waited for Spanning Tree to become stable plus a "short buffer time" (10 s).
     * But if the only link-up port is the craft port, the craft port does not participate in
     * Spanning Tree and so the "Spanning Tree is stable" notification is not sent to SNMP.
     *
     * Resolution:
     * Because we want to -
     * 1. Keep the existing architecture of "wait first, and then start to send traps", instead of
     *    changing it to "separately wait for switch port and craft port" or
     *    "separately wait for each IP route or each trap receiver".
     * 2. Not wait for Spanning Tree (because in the "craft-port only" condition, there is
     *    no Spanning Tree Stable event).
     *
     * Therefore -
     * We must create another condition which can be used for both the switch port and
     * the craft port.  So, we artificially wait for the expected amount of time for Spanning
     * Tree to become stable, in case the switch port will be used to send traps.
     * In the current archetecture, Provision Complete causes SwCtrl link-up and that
     * tells STP of link-up.
     * So, add one condition: provision complete, plus the maximum possible value of STP
     * Forward Delay (30 s), plus the original "short buffer time" (10 s).
     * If either the original condition, or this new condition, is reached, we consider ready
     * to send traps.
     */
    is_prov_complete = TRUE;

    SYS_TIME_GetRealTimeBySec(&time_to_send_trap_from_prov_complete);
    time_to_send_trap_from_prov_complete
        += MAX_dot1dStpBridgeForwardDelay / 100  /* centiseconds -> seconds */
            + SNMP_MGR_SEND_TRAP_DELAY_TIME;

    return;

} /* end of SNMP_MGR_ProvisionComplete() */


UI32_T SNMP_MGR_GetSemporeID( UI32_T *sem_id)
{
    *sem_id = snmp_mgr_sem_id;
    return SNMP_MGR_ERROR_OK;
}

/*--------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_CreateSnmpV3Group
 *---------------------------------------------------------------------------
 * PURPOSE : This function is used to create a SNMPv3 group.
 * INPUT   : entry              -- the detail information of the group
 *           is_auto_create     -- create this group is requested by system
 *                                 internal but not user.
 * OUTPUT  : None.
 * RETURN  : 1. success:    SNMP_MGR_ERROR_OK
 *           2. failure:    SNMP_MGR_ERROR_EXCEED_LIMIT
 *                          SNMP_MGR_ERROR_MEM_ALLOC_FAIL
 *                          SNMP_MGR_ERROR_PARAMETER_NOT_MATCH
 *                          SNMP_MGR_ERROR_FAIL
 *---------------------------------------------------------------------------
 */
static UI32_T SNMP_MGR_CreateSnmpV3Group(SNMP_MGR_SnmpV3GroupEntry_T *entry, BOOL_T is_auto_create)
{
    char   *line = NULL;
    char   model[SNMP_MGR_SPRINT_MAX_LEN]= {0};
    char   secname[SNMP_MGR_SPRINT_MAX_LEN] = {0};
    char   authtype[SNMP_MGR_SPRINT_MAX_LEN] = {0};
    UI8_T  storageType[16]= {0};
    UI32_T retval =0;
    UI32_T total_alloc_size = 0;
    UI32_T orig_priority;

   /*
    * init
    */
    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);

    /* check the input data is valid */
    if ((strlen(entry->snmpv3_group_name) > MAXSIZE_vacmGroupName) ||
        (strlen(entry->snmpv3_group_name) < MINSIZE_vacmGroupName) ||
        (strlen(entry->snmpv3_group_readview) > MAXSIZE_vacmAccessReadViewName) ||
        (strlen(entry->snmpv3_group_writeview) > MAXSIZE_vacmAccessWriteViewName) ||
        (strlen(entry->snmpv3_group_notifyview) > MAXSIZE_vacmAccessNotifyViewName))
    {
        #if (SYS_CPNT_EH == TRUE)
            EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                     0,
                                     EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                    (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));

        #endif

        return SNMP_MGR_ERROR_FAIL;
    }

/* check if already exist */

    if (SNMP_MGR_CheckGroupExist(entry)== SNMP_MGR_ERROR_OK)
    {
        /* not allow to modify the group that is auto created before
         */
        if (TRUE == SNMP_MGR_IsAutoDestroyAccess(entry->snmpv3_group_name, entry->snmpv3_group_model, entry->snmpv3_group_security_level))
        {
            return SNMP_MGR_ERROR_FAIL;
        }

        SNMP_MGR_DeleteAccess(entry->snmpv3_group_name, entry->snmpv3_group_model, entry->snmpv3_group_security_level);
    }

    strcpy(secname, entry->snmpv3_group_name);
   /* tempory added notify view */
    //strcpy(entry.snmpv3_group_notifyview, "none");

   /*
    * community name or user name
    */

    if (entry->snmpv3_group_model == SNMP_MGR_SNMPV3_MODEL_V3)
    {
        /*
         * maybe security model type
         */
        strcpy(model, "usm");
        if ( entry->snmpv3_group_security_level == VAL_vacmAccessSecurityLevel_noAuthNoPriv)
        {
            strcpy(authtype, "noauth");
        }
        else if ( entry->snmpv3_group_security_level == VAL_vacmAccessSecurityLevel_authNoPriv)
        {
            strcpy(authtype, "auth");
        }
        else
        {
            strcpy( authtype, "authpriv");
        }

    }
    else if( entry->snmpv3_group_model == SNMP_MGR_SNMPV3_MODEL_V2C)
    {
        strcpy(model, "v2c");
        strcpy(authtype, "noauth");
    }
    else if ( entry->snmpv3_group_model == SNMP_MGR_SNMPV3_MODEL_V1)
    {
        strcpy(model, "v1");
        strcpy(authtype, "noauth");
    }
    else if ( entry->snmpv3_group_model == SNMP_MGR_SNMPV3_MODEL_ANY)
    {
        strcpy(model, "any");
        strcpy(authtype, "noauth");
    }

    /*
     * view definition
     */
    /*
     * view    anonymousViewNUM       included OID
     */
    SNMP_MGR_CheckDefaultCommunityView();

    if (entry->snmpv3_group_storage_type == VAL_vacmAccessStorageType_other)
    {
        strcpy((char *)storageType, "other");
    }
    else if (entry->snmpv3_group_storage_type == VAL_vacmAccessStorageType_volatile)
    {
        strcpy((char *)storageType, "volatile");
    }
    else if (entry->snmpv3_group_storage_type == VAL_vacmAccessStorageType_nonVolatile)
    {
        strcpy((char *)storageType, "nonvolatile");
    }
    else if (entry->snmpv3_group_storage_type == VAL_vacmAccessStorageType_permanent)
    {
        strcpy((char *)storageType, "permanent");
    }
    else if (entry->snmpv3_group_storage_type == VAL_vacmAccessStorageType_readOnly)
    {
        strcpy((char *)storageType, "readonly");
    }
    else
    {
        /*default assume storageType = nonvlatile*/
        strcpy((char *)storageType, "nonvolatile");
    }

   /*
    * map everything together
    */
   /*
    * access  anonymousGroupNameNUM  "" MODEL AUTHTYPE prefix anonymousViewNUM [none/anonymousViewNUM] [none/anonymousViewNUM]
    */
    total_alloc_size = SYSFUN_Snprintf(line, 0, "%s \"\"  %s %s prefix \"%s\" \"%s\" \"%s\" %s",
                   secname, model, authtype, entry->snmpv3_group_readview, entry->snmpv3_group_writeview, entry->snmpv3_group_notifyview, storageType);

    line = (char *)L_MM_Malloc(total_alloc_size + 1,
                              L_MM_USER_ID2(SYS_MODULE_SNMP, SNMP_TYPE_TRACE_ID_MGR_CREATEV3GROUP));

    if(NULL == line)
    {
        return SNMP_MGR_ERROR_MEM_ALLOC_FAIL;
    }

    SYSFUN_Sprintf(line, "%s \"\"  %s %s prefix \"%s\" \"%s\" \"%s\" %s",
                   secname, model, authtype, entry->snmpv3_group_readview, entry->snmpv3_group_writeview, entry->snmpv3_group_notifyview, storageType);

    retval = vacm_parse_access("access", line, is_auto_create) ;

    if (retval != SNMP_MGR_ERROR_OK)
    {
        #if (SYS_CPNT_EH == TRUE)
            EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                     0,
                                     EH_TYPE_MSG_FAILED_TO_ADD,
                                    (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));

        #endif

        L_MM_Free((void *) line);

        return retval;
    }

    L_MM_Free((void *) line);

    return SNMP_MGR_ERROR_OK;
}


/*--------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_CreateSnmpV3User
 *---------------------------------------------------------------------------
 * PURPOSE : This function is used to create a SNMPv3 user.
 * INPUT   : entry              -- the detail information of the user
 *           is_auto_create     -- create this user is requested by system
 *                                 internal but but not user.
 * OUTPUT  : None.
 * RETURN  : 1. success:    SNMP_MGR_ERROR_OK
 *           2. failure:    SNMP_MGR_ERROR_EXCEED_LIMIT
 *                          SNMP_MGR_ERROR_MEM_ALLOC_FAIL
 *                          SNMP_MGR_ERROR_PARAMETER_NOT_MATCH
 *                          SNMP_MGR_ERROR_FAIL
 *---------------------------------------------------------------------------
 */
UI32_T SNMP_MGR_CreateSnmpV3User(SNMP_MGR_SnmpV3UserEntry_T *entry, BOOL_T is_auto_create)
{
    return SNMP_MGR_CreateSnmpV3UserWithCfgDB(entry, 1, is_auto_create);
}


/*--------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_CreateSnmpV3View
 *---------------------------------------------------------------------------
 * PURPOSE:  This function will make the Snmp 's agent enter the transition mode.
 * INPUT:    entry.
 * OUTPUT:   None..
 * RETURN:  1. success:    SNMP_MGR_ERROR_OK
 *                    2. failure:      SNMP_MGR_ERROR_EXCEED_LIMIT
 *                                         SNMP_MGR_ERROR_MEM_ALLOC_FAIL
 *                                         SNMP_MGR_ERROR_PARAMETER_NOT_MATCH
 *                                         SNMP_MGR_ERROR_FAIL
 * NOTE:        The entry.snmpv3_view_subtree is in the ASCII from of an OID. and the mask is also in the ASCII from.
 *---------------------------------------------------------------------------
 */
UI32_T SNMP_MGR_CreateSnmpV3View(SNMP_MGR_SnmpV3ViewEntry_T *entry)
{
    /*The max will be 32(viewname) + 11 (' included .') +64 (view_subtree_len) + 11('FF:FF:FF:FF')
      =118, we declared the 120 here*/
    char  *line = NULL;
    UI32_T orig_priority;
    UI32_T total_alloc_size = 0;

    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);

    /* check the input data is valid */
    if ((strlen(entry->snmpv3_view_name) > MAXSIZE_vacmViewTreeFamilyViewName) ||
        (strlen(entry->snmpv3_view_name) < MINSIZE_vacmViewTreeFamilyViewName) ||
        (strlen(entry->snmpv3_view_subtree) > MAXSIZE_VIEW_SUBTREE) ||
        (strlen(entry->snmpv3_view_mask) > MAXSIZE_VIEW_MASK) ||
        (strlen(entry->snmpv3_wildcard_subtree) > MAXSIZE_VIEW_SUBTREE))
    {
        #if (SYS_CPNT_EH == TRUE)
            EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                     0,
                                     EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                    (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));

        #endif

        return SNMP_MGR_ERROR_FAIL;
    }

   /* transform the wildcard input as our subtree and mask */

    if (!SNMP_MGR_Transform_ViewWildcardToTree( entry->snmpv3_wildcard_subtree, entry->snmpv3_view_subtree,  entry->snmpv3_view_mask))
    {
        #if (SYS_CPNT_EH == TRUE)
            EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                     0,
                                     EH_TYPE_MSG_INVALID_PARAMETER,
                                    (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));

        #endif

        return SNMP_MGR_ERROR_FAIL;
    }

    /* Check if the view entry is valid */

    if (!SNMP_MGR_CheckValidOIDSring((UI8_T *)entry->snmpv3_view_subtree))
    {
        #if (SYS_CPNT_EH == TRUE)
            EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                     0,
                                     EH_TYPE_MSG_INVALID_PARAMETER,
                                    (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));

        #endif

           return SNMP_MGR_ERROR_PARAMETER_NOT_MATCH;
    }

    /* check if already exist */
    if (SNMP_MGR_CheckViewExist(entry)== SNMP_MGR_ERROR_OK )
    {
        SNMP_MGR_DeleteSnmpV3View((UI8_T *)entry->snmpv3_view_name, (UI8_T *)entry->snmpv3_wildcard_subtree);
    }

    total_alloc_size = SYSFUN_Snprintf(line, 0, "%s included .%s %s",
                                      entry->snmpv3_view_name, entry->snmpv3_view_subtree , entry->snmpv3_view_mask);

    if (entry->snmpv3_view_type== VAL_vacmViewTreeFamilyType_included)
    {

        line = (char *)L_MM_Malloc(total_alloc_size + 1, L_MM_USER_ID2(SYS_MODULE_SNMP,
                                          SNMP_TYPE_TRACE_ID_MGR_CREATEV3VIEW));

        if (NULL == line)
        {
            return SNMP_MGR_ERROR_MEM_ALLOC_FAIL;
        }

        SYSFUN_Sprintf(line, "%s included .%s %s",entry->snmpv3_view_name, entry->snmpv3_view_subtree , entry->snmpv3_view_mask);



        if (vacm_parse_view("view", line)==SNMP_MGR_ERROR_OK)
           {


               L_MM_Free((void *)line);

               return SNMP_MGR_ERROR_OK;
        }
        else
        {
            #if (SYS_CPNT_EH == TRUE)
            EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                     0,
                                     EH_TYPE_MSG_FAILED_TO_ADD,
                                    (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));

            #endif


            L_MM_Free((void *)line);

            return SNMP_MGR_ERROR_FAIL;
        }
    }
    else if ( entry->snmpv3_view_type == VAL_vacmViewTreeFamilyType_excluded)
    {

        total_alloc_size = SYSFUN_Snprintf(line, 0, "%s excluded .%s %s",
                                          entry->snmpv3_view_name, entry->snmpv3_view_subtree , entry->snmpv3_view_mask);

        line = (char *)L_MM_Malloc(total_alloc_size + 1, L_MM_USER_ID2(SYS_MODULE_SNMP,
                                          SNMP_TYPE_TRACE_ID_MGR_CREATEV3VIEW));

        if (NULL == line)
        {
            return SNMP_MGR_ERROR_MEM_ALLOC_FAIL;
        }

        SYSFUN_Sprintf( line, "%s excluded .%s %s", entry->snmpv3_view_name,  entry->snmpv3_view_subtree,  entry->snmpv3_view_mask);



        if (vacm_parse_view("view", line)== SNMP_MGR_ERROR_OK)
        {


            L_MM_Free((void *)line);

            return SNMP_MGR_ERROR_OK;
        }
        else
        {
            #if (SYS_CPNT_EH == TRUE)
            EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                     0,
                                     EH_TYPE_MSG_FAILED_TO_ADD,
                                    (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));

            #endif



            L_MM_Free((void *)line);

            return SNMP_MGR_ERROR_FAIL;
        }
    }

    return SNMP_MGR_ERROR_OK;
}


/*--------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_DeleteSnmpV3View
 *---------------------------------------------------------------------------
 * PURPOSE:  This function will delete a SNMP V3 View
 * INPUT:    snmpv3_view_name[], snmpv3_view_subtree[]
 * OUTPUT:   None.
 * RETURN:  1. success:    SNMP_MGR_ERROR_OK
 *                    2. failure:      SNMP_MGR_ERROR_EXCEED_LIMIT
 *                                         SNMP_MGR_ERROR_MEM_ALLOC_FAIL
 *                                         SNMP_MGR_ERROR_PARAMETER_NOT_MATCH
 *                                         SNMP_MGR_ERROR_FAIL
 * NOTE:     None.
 *---------------------------------------------------------------------------
 */
UI32_T SNMP_MGR_DeleteSnmpV3View(UI8_T *snmpv3_view_name, UI8_T *snmpv3_wildcard_subtree)
{
    oid tmp_subtree[MAXSIZE_VIEW_MASK],  subtree[MAXSIZE_VIEW_SUBTREE];
    UI32_T oid_len;
    char  str_view_subtree[MAXSIZE_VIEW_SUBTREE];
    UI32_T orig_priority;

    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);

    if (! SNMP_MGR_Transform_ViewWildcardToTree((char *)snmpv3_wildcard_subtree, (char *)str_view_subtree, NULL))
    {
        #if (SYS_CPNT_EH == TRUE)
            EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                     0,
                                     EH_TYPE_MSG_INVALID_PARAMETER,
                                    (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));

        #endif

         return SNMP_MGR_ERROR_FAIL;
    }
    SNMP_MGR_StringToObejctID(tmp_subtree, (I8_T *)str_view_subtree, &oid_len);
    subtree[0]= oid_len;
    memcpy( &subtree[1], tmp_subtree, sizeof(oid) * oid_len);

    vacm_destroyViewEntry((const char *)snmpv3_view_name, (oid *)subtree, (size_t)(oid_len+1));


    return SNMP_MGR_ERROR_OK;
}

/*--------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_DeleteSnmpV3ViewByName
 *---------------------------------------------------------------------------
 * PURPOSE:  This function will delete all the SNMP V3 View by a specific  view Name
 * INPUT:    snmpv3_view_name[]
 * OUTPUT:   None.
 * RETURN:  1. success:    SNMP_MGR_ERROR_OK
 *                    2. failure:      SNMP_MGR_ERROR_EXCEED_LIMIT
 *                                         SNMP_MGR_ERROR_MEM_ALLOC_FAIL
 *                                         SNMP_MGR_ERROR_PARAMETER_NOT_MATCH
 *                                         SNMP_MGR_ERROR_FAIL
 * NOTE:     None.
 *---------------------------------------------------------------------------
 */
UI32_T SNMP_MGR_DeleteSnmpV3ViewByName(UI8_T *snmpv3_view_name )
{
    SNMP_MGR_SnmpV3ViewEntry_T  entry;

    memset( &entry, 0 , sizeof(entry));

    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);

    while( SNMP_MGR_GetNextSnmpV3View( &entry)== SNMP_MGR_ERROR_OK)
    {
        if (strcmp ((char *)snmpv3_view_name,  entry.snmpv3_view_name) == 0)
        {
            if (SNMP_MGR_DeleteSnmpV3View((UI8_T *)entry.snmpv3_view_name, (UI8_T *)entry.snmpv3_wildcard_subtree)!= SNMP_MGR_ERROR_OK)
            {
                #if (SYS_CPNT_EH == TRUE)
                    EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                             0,
                                             EH_TYPE_MSG_FAILED_TO_DELETE,
                                            (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));

                #endif

                return SNMP_MGR_ERROR_FAIL;
            }
           /* if successful find a entry and delete, get back  to the first entry to seach again */
            memset( &entry, 0, sizeof(entry));
        }

    }

    return SNMP_MGR_ERROR_OK;
}


/*--------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_DeleteSnmpV3Group
 *---------------------------------------------------------------------------
 * PURPOSE: This function will delete a SNMP V3 Group that is not auto created.
 * INPUT:    snmpv3_group_name[], security_model, security_level
 * OUTPUT:   None.
 * RETURN:  1. success:    SNMP_MGR_ERROR_OK
 *          2. failure:    SNMP_MGR_ERROR_FAIL
 * NOTE:     None.
 *---------------------------------------------------------------------------
 */
UI32_T SNMP_MGR_DeleteSnmpV3Group(char *snmpv3_group_name, UI8_T  security_model ,  UI8_T security_level)
{
    struct vacm_accessEntry *aptr = NULL;
    UI32_T orig_priority;

    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);

    aptr = vacm_getExactAccessEntry(snmpv3_group_name,  "", security_model,  security_level);

    if (aptr)
    {
        /* not allow to delete the group that is auto created before
         */
        if (TRUE == SNMP_MGR_IsAutoDestroyAccess(snmpv3_group_name, security_model, security_level))
        {
            return SNMP_MGR_ERROR_FAIL;
        }

        vacm_destroyAccessEntry(snmpv3_group_name, NULL, security_model, security_level);
    }

    return SNMP_MGR_ERROR_OK;
}

/*--------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_DeleteAccess
 *---------------------------------------------------------------------------
 * PURPOSE: This function will delete a SNMP V3 access.
 * INPUT:   access_name_p, security_model, security_level
 * OUTPUT:  None.
 * RETURN:  1. success:    SNMP_MGR_ERROR_OK
 *          2. failure:    SNMP_MGR_ERROR_FAIL
 * NOTE:    None.
 *---------------------------------------------------------------------------
 */
static UI32_T SNMP_MGR_DeleteAccess(char *access_name_p, UI8_T security_model, UI8_T security_level)
{
    struct vacm_accessEntry *aptr = NULL;
    UI32_T orig_priority;

    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);

    aptr = vacm_getExactAccessEntry(access_name_p, "", security_model, security_level);

    if (aptr)
    {
        vacm_destroyAccessEntry(access_name_p, NULL, security_model, security_level);
    }

    return SNMP_MGR_ERROR_OK;
}

/*--------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_ClearAccessNotifyView
 *---------------------------------------------------------------------------
 * PURPOSE: This function will clear notify view of the SNMP V3 access.
 * INPUT:   access_name_p, security_model, security_level
 * OUTPUT:  None.
 * RETURN:  1. success:    SNMP_MGR_ERROR_OK
 *          2. failure:    SNMP_MGR_ERROR_FAIL
 * NOTE:    None.
 *---------------------------------------------------------------------------
 */
static UI32_T SNMP_MGR_ClearAccessNotifyView(char *access_name_p, UI8_T security_model, UI8_T security_level)
{
    struct vacm_accessEntry *aptr = NULL;
    UI32_T orig_priority;

    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);

    aptr = vacm_getExactAccessEntry(access_name_p, "", security_model, security_level);

    if (NULL == aptr)
    {
        return SNMP_MGR_ERROR_FAIL;
    }

    aptr->notifyView[0] = '\0';

    return SNMP_MGR_ERROR_OK;
}

/*--------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_GetEngineID
 *---------------------------------------------------------------------------
 * PURPOSE:  This function will Get the SNMP Engine ID, the Engine ID is fixed to 13 octets.
 * INPUT:    engineID.
 * OUTPUT:   engineID.
 * RETURN:  1. success:    SNMP_MGR_ERROR_OK
 *                    2. failure:      SNMP_MGR_ERROR_EXCEED_LIMIT
 *                                         SNMP_MGR_ERROR_MEM_ALLOC_FAIL
 *                                         SNMP_MGR_ERROR_PARAMETER_NOT_MATCH
 *                                         SNMP_MGR_ERROR_FAIL
 * NOTE:     None.
 *---------------------------------------------------------------------------
 */
UI32_T SNMP_MGR_GetEngineID(UI8_T *engineID, UI32_T *engineIDLen)
{

    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);

    *engineIDLen = snmpv3_get_engineID(  engineID,  MAXSIZE_snmpEngineID);

    return SNMP_MGR_ERROR_OK;
}


/*--------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_GetRunningEngineID
 *---------------------------------------------------------------------------
 * PURPOSE:  This function will Get the SNMP Engine ID, the Engine ID is fixed to 13 octets.
 * INPUT:    engineID.
 * OUTPUT:   engineID.
 * RETURN:   SYS_TYPE_GET_RUNNING_CFG_SUCCESS, SYS_TYPE_GET_RUNNING_CFG_NO_CHANGE, or
 *                     SYS_TYPE_GET_RUNNING_CFG_FAIL
 * NOTE:     None.
 *---------------------------------------------------------------------------
 */
UI32_T  SNMP_MGR_GetRunningEngineID ( UI8_T *engineID, UI32_T *engineIDLen)
{
    UI8_T current_engine_id[MAXSIZE_snmpEngineID];
    UI32_T current_engine_id_len;

    SNMP_MGR_CHECK_OPER_MODE(SYS_TYPE_GET_RUNNING_CFG_FAIL);

    memset(current_engine_id, 0, sizeof(current_engine_id));
    current_engine_id_len = snmpv3_get_engineID(current_engine_id,
        sizeof(current_engine_id));

    ASSERT((current_engine_id <= MAXSIZE_snmpEngineID)
        && (current_engine_id <= sizeof(current_engine_id)));

    if (   (snmp_default_engine_id_len == current_engine_id_len)
        && (0 == memcmp(snmp_default_engine_id, current_engine_id,
            snmp_default_engine_id_len))
        )
    {
        return SYS_TYPE_GET_RUNNING_CFG_NO_CHANGE;
    }

    memset(engineID, 0, sizeof(*engineID));
    memcpy(engineID, current_engine_id, current_engine_id_len);
    *engineIDLen = current_engine_id_len;

    return SYS_TYPE_GET_RUNNING_CFG_SUCCESS;
}

/*--------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_GetEngineBoots
 *---------------------------------------------------------------------------
 * PURPOSE:  This function will Get the SNMP Engine boots.
 * INPUT:    engineBoots.
 * OUTPUT:   engineBoots
 * RETURN:   SNMP_MGR_ERROR_OK/SNMP_MGR_ERROR_FAIL.
 * NOTE:     None.
 *---------------------------------------------------------------------------
 */
UI32_T SNMP_MGR_GetEngineBoots ( UI32_T *engineBoots)
{
    UI32_T orig_priority;

    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);

    #if (SYS_CPNT_CFGDB == TRUE)
    *engineBoots = snmp_mgr_engine_info.engine_boots;
    #else
    *engineBoots = 1;
    #endif


    return SNMP_MGR_ERROR_OK;
}


/*--------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_DeleteSnmpV3User
 *---------------------------------------------------------------------------
 * PURPOSE:  This function will delete a SNMP V3 User
 * INPUT:    secourity_model, snmpv3_user_name[].
 * OUTPUT:   None.
 * RETURN:  1. success:    SNMP_MGR_ERROR_OK
 *          2. failure:    SNMP_MGR_ERROR_EXCEED_LIMIT
 *                         SNMP_MGR_ERROR_MEM_ALLOC_FAIL
 *                         SNMP_MGR_ERROR_PARAMETER_NOT_MATCH
 *                         SNMP_MGR_ERROR_FAIL
 * NOTE:     1. None
 *---------------------------------------------------------------------------
 */
UI32_T SNMP_MGR_DeleteSnmpV3User(SNMP_MGR_Snmpv3_Model_T  security_model,  UI8_T * snmpv3_user_name)
{
    struct vacm_groupEntry *geptr= NULL, *vp= NULL;
    BOOL_T  deleteusmentry= TRUE;
    UI8_T   success=0;
    SNMP_MGR_SnmpCommunityEntry_T comm_entry;
    UI32_T orig_priority;

    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);

    if (SNMP_MGR_DeleteSecurityToGroupEntry(security_model, (char *)snmpv3_user_name)== SNMP_MGR_ERROR_OK)
    {
        success++;
    }

    geptr = vacm_get_groupList();

    /* find if there match a entry of the username*/
    for (vp = geptr; vp; vp = vp->next)
    {
        if (!strcmp(vp->securityName + 1, (char *)snmpv3_user_name))
        {
           deleteusmentry = FALSE;
           break;
        }
    }

    if (deleteusmentry)
    {
        if (SNMP_MGR_DeleteUsmUserEntry((char *)snmpv3_user_name)== SNMP_MGR_ERROR_OK)
        {
            success++;
        }

#if (SYS_CPNT_CFGDB == TRUE)
#if (SYS_CPNT_SNMP_COMMUNITY_IN_CFGDB == TRUE)
{
        /* Delete the user and remove from cfgdb
         */
        for(i = 0; i < SNMP_MGR_MAX_NBR_OF_SNMPV3_USER; i++)
        {
            if(strcmp(snmp_mgr_v3_user_entry[i].snmpv3_user_name, snmpv3_user_name) == 0)
            {
                memset(&snmp_mgr_v3_user_entry[i], 0, sizeof(SNMP_MGR_SnmpV3UserEntry_T));
                snmp_mgr_v3_user_entry[i].snmpv3_user_status = VAL_usmUserStatus_destroy;
                break;
            }
        }

        CFGDB_MGR_WriteSection(snmp_mgr_v3_user_session_handler, snmp_mgr_v3_user_entry);
}
#endif  /* end of #if (SYS_CPNT_SNMP_COMMUNITY_IN_CFGDB == TRUE) */
#endif  /* end of #if (SYS_CPNT_CFGDB == TRUE) */

    }

    if (success == 0)
    {
        #if (SYS_CPNT_EH == TRUE)
            EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                     0,
                                     EH_TYPE_MSG_FAILED_TO_DELETE,
                                    (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));

        #endif

        return SNMP_MGR_ERROR_FAIL;
    }
    else
    {
    /*
     * if delete user model is v1/v2, now want to check if need to delete
     * the reduant comm2SecEntry.
     */
        if (( security_model == SNMP_MGR_SNMPV3_MODEL_V1) || ( security_model ==SNMP_MGR_SNMPV3_MODEL_V2C))
        {
              memset(&comm_entry,0, sizeof(comm_entry));
            strcpy((char *)comm_entry.snmp_community_index , (char *) snmpv3_user_name);

            if (SNMP_MGR_GetSnmpCommunityEntry(&comm_entry)== SNMP_MGR_ERROR_OK )
            {
                /*need to check if there is remaining securityToGroup table need this
                 *community entry
                 */
                SNMP_MGR_SnmpV3UserEntry_T sec_to_group_entry;
                BOOL_T checkPass = TRUE;

                memset(&sec_to_group_entry, 0, sizeof(sec_to_group_entry));
              /* check v1 model first*/
                sec_to_group_entry.snmpv3_user_security_model = SNMP_MGR_SNMPV3_MODEL_V1;
                strcpy(sec_to_group_entry.snmpv3_user_name, comm_entry.snmp_community_index);
                if (SNMP_MGR_ERROR_OK == SNMP_MGR_CheckSecurityToGroupTable(&sec_to_group_entry))
                {
                    checkPass = FALSE;
                }
                /*check v2c model*/
                sec_to_group_entry.snmpv3_user_security_model = SNMP_MGR_SNMPV3_MODEL_V2C;
                if (SNMP_MGR_ERROR_OK == SNMP_MGR_CheckSecurityToGroupTable(&sec_to_group_entry))
                {
                    checkPass = FALSE;
                }
                if (checkPass == TRUE)
                {

                    SNMP_MGR_DeleteCom2SecList(comm_entry.snmp_community_index);

                    SNMP_MGR_ModifySnmpCommunityStatus(comm_entry.snmp_community_index, VAL_snmpCommunityStatus_destroy);
                }
            }
        }

        return SNMP_MGR_ERROR_OK;
    }
}


/*--------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_GetSnmpV3UserEngineID
 *---------------------------------------------------------------------------
 * PURPOSE:  The function will get the enginedID of the user
 * INPUT:    user_name
 * OUTPUT:   entry.
 * RETURN:  1. success:    SNMP_MGR_ERROR_OK
 *                    2. failure:      SNMP_MGR_ERROR_EXCEED_LIMIT
 *                                         SNMP_MGR_ERROR_MEM_ALLOC_FAIL
 *                                         SNMP_MGR_ERROR_PARAMETER_NOT_MATCH
 *                                         SNMP_MGR_ERROR_FAIL
 * NOTE:     None.
 *---------------------------------------------------------------------------
 */
UI32_T SNMP_MGR_GetSnmpV3UserEngineID(UI8_T   *user_name, UI8_T *engineID, UI32_T *engineID_length)
{
    UI32_T orig_priority;
    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);

    if (usm_get_engineID_from_user_name(user_name, engineID, (size_t *)engineID_length) == FALSE)
    {


        return SNMP_MGR_ERROR_FAIL;
    }


    return SNMP_MGR_ERROR_OK;
}


/*--------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_GetSnmpV3User
 *---------------------------------------------------------------------------
 * PURPOSE:  The  Get  Function of Snmp V3 user/
 * INPUT:     entry->snmpv3_user_engine_id, entry->snmpv3_user_name
 * OUTPUT:   entry.
 * RETURN:  1. success:    SNMP_MGR_ERROR_OK
 *                    2. failure:      SNMP_MGR_ERROR_EXCEED_LIMIT
 *                                         SNMP_MGR_ERROR_MEM_ALLOC_FAIL
 *                                         SNMP_MGR_ERROR_PARAMETER_NOT_MATCH
 *                                         SNMP_MGR_ERROR_FAIL
 * NOTE:     None.
 *---------------------------------------------------------------------------
 */
UI32_T
SNMP_MGR_GetSnmpV3User(
    SNMP_MGR_SnmpV3UserEntry_T  *entry)
{
    struct usmUser *uptr = NULL;
    UI32_T orig_priority;

    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);

    /* Since API will return NULL user, we block here to not allow NULL user get
     */
    if (strcmp(entry-> snmpv3_user_name, "\0")== 0)
    {
        #if (SYS_CPNT_EH == TRUE)
            EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                     0,
                                     EH_TYPE_MSG_INVALID_PARAMETER,
                                    (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));

        #endif

        return SNMP_MGR_ERROR_FAIL;
    }

    /* Now see if a user already exists with these index values.
    */

    uptr = usm_get_user(entry->snmpv3_user_engine_id,
                        entry->snmpv3_user_engineIDLen,
                        entry->snmpv3_user_name);

    if ((uptr) && (uptr->userStatus == VAL_usmUserStatus_active))
    {
        memcpy(entry->snmpv3_user_engine_id, uptr->engineID, uptr->engineIDLen);
        entry->snmpv3_user_engineIDLen = uptr->engineIDLen;
        strcpy( entry->snmpv3_user_name , uptr->name);
        entry->snmpv3_user_storage_type = uptr->userStorageType;
        memcpy( entry->snmpv3_user_auth_key, uptr->authKey, uptr->authKeyLen);
        memcpy ( entry-> snmpv3_user_priv_key, uptr->privKey, uptr->privKeyLen);
        entry-> snmpv3_user_auth_key_len = uptr->authKeyLen;
        entry-> snmpv3_user_priv_key_len = uptr->privKeyLen;
        entry->snmpv3_user_security_level= uptr->userSecLevel;
        entry->snmpv3_user_security_model = (SNMP_MGR_Snmpv3_Model_T)uptr->userModel;
        entry->snmpv3_user_status = uptr->userStatus;

       /* compare auth protocol
        */
        if (!memcmp(uptr->authProtocol,
                    usmNoAuthProtocol,
                    uptr->authProtocolLen * sizeof(oid)))
        {
            entry->snmpv3_user_auth_type = SNMP_MGR_SNMPV3_AUTHTYPE_NONE;
            entry->snmpv3_user_security_model=SNMP_MGR_SNMPV3_MODEL_V3;
            entry->snmpv3_user_security_level = VAL_vacmAccessSecurityLevel_noAuthNoPriv;
        }
        else if (!memcmp(uptr->authProtocol,
                  usmHMACMD5AuthProtocol,
                  uptr->authProtocolLen * sizeof(oid)))
        {
            entry->snmpv3_user_auth_type = SNMP_MGR_SNMPV3_AUTHTYPE_MD5;
            entry->snmpv3_user_security_model=SNMP_MGR_SNMPV3_MODEL_V3;
            entry->snmpv3_user_security_level = VAL_vacmAccessSecurityLevel_authNoPriv;
        }
        else if (!memcmp(uptr->authProtocol,
                  usmHMACSHA1AuthProtocol,
                  uptr->authProtocolLen * sizeof(oid)))
        {
            entry->snmpv3_user_auth_type = SNMP_MGR_SNMPV3_AUTHTYPE_SHA;
            entry->snmpv3_user_security_model=SNMP_MGR_SNMPV3_MODEL_V3;
            entry->snmpv3_user_security_level = VAL_vacmAccessSecurityLevel_authNoPriv;
        }

        /* compare priv protocol
         */
        if (!memcmp(uptr->privProtocol,
             usmNoPrivProtocol,
             uptr->privProtocolLen * sizeof(oid)))
        {
            entry->snmpv3_user_priv_type = SNMP_MGR_SNMPV3_PRIVTYPE_NONE;
            entry->snmpv3_user_security_model=SNMP_MGR_SNMPV3_MODEL_V3;
        }
        else if (!memcmp(uptr->privProtocol,
                         usmDESPrivProtocol,
                         uptr->privProtocolLen * sizeof(oid)))
        {
            entry->snmpv3_user_priv_type = SNMP_MGR_SNMPV3_PRIVTYPE_DES;
            entry->snmpv3_user_security_model=SNMP_MGR_SNMPV3_MODEL_V3;
            entry->snmpv3_user_security_level = VAL_vacmAccessSecurityLevel_authPriv;
        }
        else if (!memcmp(uptr->privProtocol,
                         usm3DESPrivProtocol,
                         uptr->privProtocolLen * sizeof(oid)))
        {
            entry->snmpv3_user_priv_type = SNMP_MGR_SNMPV3_PRIVTYPE_3DES;
            entry->snmpv3_user_security_model = SNMP_MGR_SNMPV3_MODEL_V3;
            entry->snmpv3_user_security_level = VAL_vacmAccessSecurityLevel_authPriv;
        }
        else if (!memcmp(uptr->privProtocol,
                         usmAES128PrivProtocol,
                         uptr->privProtocolLen * sizeof(oid)))
        {
            entry->snmpv3_user_priv_type = SNMP_MGR_SNMPV3_PRIVTYPE_AES128;
            entry->snmpv3_user_security_model= SNMP_MGR_SNMPV3_MODEL_V3;
            entry->snmpv3_user_security_level = VAL_vacmAccessSecurityLevel_authPriv;
        }
        else if (!memcmp(uptr->privProtocol,
                         usmAES192PrivProtocol,
                         uptr->privProtocolLen * sizeof(oid)))
        {
            entry->snmpv3_user_priv_type = SNMP_MGR_SNMPV3_PRIVTYPE_AES192;
            entry->snmpv3_user_security_model= SNMP_MGR_SNMPV3_MODEL_V3;
            entry->snmpv3_user_security_level = VAL_vacmAccessSecurityLevel_authPriv;
        }
        else if (!memcmp(uptr->privProtocol,
                         usmAES256PrivProtocol,
                         uptr->privProtocolLen * sizeof(oid)))
        {
            entry->snmpv3_user_priv_type = SNMP_MGR_SNMPV3_PRIVTYPE_AES256;
            entry->snmpv3_user_security_model= SNMP_MGR_SNMPV3_MODEL_V3;
            entry->snmpv3_user_security_level = VAL_vacmAccessSecurityLevel_authPriv;
        }



        return SNMP_MGR_ERROR_OK;
    }
    else
    {
        #if (SYS_CPNT_EH == TRUE)
            EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                     0,
                                     EH_TYPE_MSG_INVALID_PARAMETER,
                                    (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));

        #endif


        return SNMP_MGR_ERROR_FAIL;
    }
}

/*--------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_GetNextSnmpV3User
 *---------------------------------------------------------------------------
 * PURPOSE:  The GetNext Function of Snmp V3 user.
 * INPUT:        entry->snmpv3_user_engine_id, entry->snmpv3_user_name
 * OUTPUT:   entry.
 * RETURN:  1. success:    SNMP_MGR_ERROR_OK
 *                    2. failure:      SNMP_MGR_ERROR_EXCEED_LIMIT
 *                                         SNMP_MGR_ERROR_MEM_ALLOC_FAIL
 *                                         SNMP_MGR_ERROR_PARAMETER_NOT_MATCH
 *                                         SNMP_MGR_ERROR_FAIL
 * NOTE:        1.entry->snmpv3_user_engine_id and entry->snmpv3_user_name = "" to get the first entry.
 *---------------------------------------------------------------------------
 */
UI32_T  SNMP_MGR_GetNextSnmpV3User(SNMP_MGR_SnmpV3UserEntry_T *entry)
{
/* We first get the vacmSecurityToGroupEntry, then use the vacmSecurityToGroupEntry->SecurityName
   to search the usmUserEntry, if exist, return the informaton. */

    struct vacm_groupEntry * vacmgrouplist=NULL, *vp=NULL, *tmpvp= NULL;
    UI8_T  localEngineID[MAXSIZE_snmpEngineID];
    UI32_T engineIDLen;
    UI32_T orig_priority;

    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);


    engineIDLen = snmpv3_get_engineID( localEngineID, MAXSIZE_snmpEngineID);
    memcpy(entry->snmpv3_user_engine_id, localEngineID, engineIDLen);
    entry->snmpv3_user_engineIDLen=engineIDLen;
    vacmgrouplist = vacm_get_groupList();

   /* no entry exist at all, return no entry exist*/
    if (!vacmgrouplist)
    {
        #if (SYS_CPNT_EH == TRUE)
            EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                     0,
                                     EH_TYPE_MSG_NOT_EXIST,
                                    (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));

        #endif

        return SNMP_MGR_ERROR_NO_ENTRY_EXIST;
    }

  /* Check if want to get the first entry */
    if ((strcmp(entry->snmpv3_user_name, "" ) == 0) && (entry->snmpv3_user_security_model == 0))
  /* Get First */
    {
        for (vp = vacmgrouplist; vp; vp = vp->next)
        {
            /* only when status is valid can continue*/
            if (vp->status !=1)
            {
                continue;
            }
            strcpy(entry->snmpv3_user_name, &vp->securityName[1]);
            entry->snmpv3_user_security_model = (SNMP_MGR_Snmpv3_Model_T)vp->securityModel;
            entry->snmpv3_user_status = vp->status;
            strcpy(entry->snmpv3_user_group_name,vp->groupName);
            if (SNMP_MGR_GetSnmpV3User( entry)== SNMP_MGR_ERROR_OK)
            {
                entry->snmpv3_user_security_model = (SNMP_MGR_Snmpv3_Model_T)vp->securityModel;
                /* if model = v1 or v2c, need to check Community Table*/
                if ((entry->snmpv3_user_security_model == SNMP_MGR_SNMPV3_MODEL_V1) ||
                   (entry->snmpv3_user_security_model == SNMP_MGR_SNMPV3_MODEL_V2C))
                {
                    SNMP_MGR_SnmpCommunityEntry_T comm_entry;

                    strcpy(comm_entry.snmp_community_index, entry->snmpv3_user_name);
                    if (SNMP_MGR_GetSnmpCommunityEntry(&comm_entry)== SNMP_MGR_ERROR_OK)
                    {
                        if (comm_entry.snmp_community_status == VAL_snmpCommunityStatus_active)
                        {

                        return SNMP_MGR_ERROR_OK;
                    }
                    else
                    {
                        continue;
                    }
                }
                else
                {
                    continue;
                }
            }
            else if (entry->snmpv3_user_security_model == SNMP_MGR_SNMPV3_MODEL_V3)
            {

                 return SNMP_MGR_ERROR_OK;
            }

        }
    }
        #if (SYS_CPNT_EH == TRUE)
            EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                     0,
                                     EH_TYPE_MSG_NOT_EXIST,
                                    (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));

        #endif
       /* cannot find a entry match in usmUserEntry */

        return SNMP_MGR_ERROR_FAIL;
    }
    else
    {
   /* find the next entry*/
        for (vp = vacmgrouplist; vp; vp = vp->next)
        {
            if (vp->securityModel == entry->snmpv3_user_security_model
                && !strcmp(vp->securityName + 1, entry->snmpv3_user_name))
            break;
        }
        if ((vp) && (vp->next))
        {
            vp = vp->next;
        }
        else
        {
            #if (SYS_CPNT_EH == TRUE)
            EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                     0,
                                     EH_TYPE_MSG_NOT_EXIST,
                                    (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));

            #endif

            return SNMP_MGR_ERROR_FAIL;
        }
        for (tmpvp = vp; tmpvp; tmpvp=tmpvp->next)
        {
            if (tmpvp->status !=1)
            {
                continue;
            }
            strcpy(entry->snmpv3_user_name, &tmpvp->securityName[1]);
            entry->snmpv3_user_security_model = (SNMP_MGR_Snmpv3_Model_T)tmpvp->securityModel;
            entry->snmpv3_user_status = tmpvp->status;
            strcpy(entry->snmpv3_user_group_name,tmpvp->groupName);
            if (SNMP_MGR_GetSnmpV3User( entry)== SNMP_MGR_ERROR_OK)
            {
                entry->snmpv3_user_security_model = (SNMP_MGR_Snmpv3_Model_T)tmpvp->securityModel;
                entry->snmpv3_user_storage_type = tmpvp->storageType;

                /* if model = v1 or v2c, need to check Community Table*/
                if ((entry->snmpv3_user_security_model == SNMP_MGR_SNMPV3_MODEL_V1) ||
                   (entry->snmpv3_user_security_model == SNMP_MGR_SNMPV3_MODEL_V2C))
                {
                    SNMP_MGR_SnmpCommunityEntry_T comm_entry;

                    strcpy(comm_entry.snmp_community_index, entry->snmpv3_user_name);
                    if (SNMP_MGR_GetSnmpCommunityEntry(&comm_entry)== SNMP_MGR_ERROR_OK)
                    {
                        if (comm_entry.snmp_community_status == VAL_snmpCommunityStatus_active)
                        {

                            return SNMP_MGR_ERROR_OK;
                        }
                        else
                        {
                            continue;
                        }
                    }
                    else
                    {
                        continue;
                    }
                }
                else if (entry->snmpv3_user_security_model == SNMP_MGR_SNMPV3_MODEL_V3)
                {

                    return SNMP_MGR_ERROR_OK;
                }
            }
        }
        #if (SYS_CPNT_EH == TRUE)
            EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                     0,
                                     EH_TYPE_MSG_NOT_EXIST,
                                    (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));

        #endif

        return SNMP_MGR_ERROR_FAIL;
    }
}


/*--------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_GetNextSnmpV3UserByGroup
 *---------------------------------------------------------------------------
 * PURPOSE:  The GetNext Function of Snmp V3 user name by index of group.
 * INPUT:    group_name, group_model, group_level, user_name
 * OUTPUT:   user_name, user_model
 * RETURN:  1. success:    SNMP_MGR_ERROR_OK
 *          2. failure:    SNMP_MGR_ERROR_EXCEED_LIMIT
 *                         SNMP_MGR_ERROR_MEM_ALLOC_FAIL
 *                         SNMP_MGR_ERROR_PARAMETER_NOT_MATCH
 *                         SNMP_MGR_ERROR_FAIL
 * NOTE:   1. group_name, group_model and group_level is the primary key.
 *         2. user_name is secondary key and set it to null to get the first entry.
 *         3. After GetNext, will return the next secondary key whereas the primary key
 *            will not return the next value.
 *         4. For Web Only.
 *---------------------------------------------------------------------------
 */
UI32_T SNMP_MGR_GetNextSnmpV3UserByGroup(UI8_T *group_name,
                                         SNMP_MGR_Snmpv3_Model_T group_model,
                                         UI32_T group_level,
                                         UI8_T *user_name,
                                         SNMP_MGR_V3_Auth_Type_T *auth_type,
                                         SNMP_MGR_V3_Priv_Type_T *priv_type)
{
    SNMP_MGR_SnmpV3GroupEntry_T group_entry;
    UI32_T orig_priority;
    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);
    memset( &group_entry, 0, sizeof(group_entry));
    strcpy( group_entry.snmpv3_group_name, (char *)group_name);
    group_entry.snmpv3_group_model = group_model;
    group_entry.snmpv3_group_security_level = group_level;

      /* check if the vacmAccessEntry exist. */
    if ( SNMP_MGR_CheckGroupExist( &group_entry)== SNMP_MGR_ERROR_OK)
    {
        struct vacm_groupEntry * vacmgrouplist=NULL, *vp=NULL,*vp2= NULL;

          vacmgrouplist = vacm_get_groupList();

       /* no entry exist at all, return no entry exist*/
        if (!vacmgrouplist)
        {
            #if (SYS_CPNT_EH == TRUE)
            EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                     0,
                                     EH_TYPE_MSG_NOT_EXIST,
                                    (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));

            #endif

            return SNMP_MGR_ERROR_NO_ENTRY_EXIST;
        }
        for (vp = vacmgrouplist; vp; vp = vp->next)
        {
            if (vp->securityModel == group_model
                && !strcmp(vp->groupName , (char *)group_name))
            {
           /* if model is v1 or v2c, then search CommEntry */
                if ((group_model == SNMP_MGR_SNMPV3_MODEL_V1 ) || (group_model == SNMP_MGR_SNMPV3_MODEL_V2C))
                {
                       struct _com2SecEntry *com2SecPtr,*com2Sec2Ptr, *com2SecList = NULL;

                    *auth_type = SNMP_MGR_SNMPV3_AUTHTYPE_NONE;
                    *priv_type = SNMP_MGR_SNMPV3_PRIVTYPE_NONE;

                    com2SecList = netsnmp_udp_get_com2SecList();

                   /* no any community exist at all */

                    if (!com2SecList)
                    {
                        #if (SYS_CPNT_EH == TRUE)
                            EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                                     0,
                                                     EH_TYPE_MSG_NOT_EXIST,
                                                    (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));
                        #endif

                        return SNMP_MGR_ERROR_FAIL;
                    }

                   /* get first */
                    if (strcmp((char *) user_name, "") == 0)
                    {
                        for (com2SecPtr = com2SecList; com2SecPtr != NULL; com2SecPtr = com2SecPtr->next)
                    {
                        if (!strcmp(com2SecPtr->secName, &vp->securityName[1]))
                        {
                            strcpy((char *) user_name, com2SecPtr->community);

                            return SNMP_MGR_ERROR_OK;
                        }
                    }
                }
                else
                   /* get next*/
                {
                    for (com2SecPtr = com2SecList; com2SecPtr != NULL; com2SecPtr = com2SecPtr->next)
                    {
                        if (!strcmp(com2SecPtr->secName, &vp->securityName[1])&&
                            !strcmp(com2SecPtr->community, (char *) user_name) )
                        {
                       /* search the next entry and see if any match */
                            for (com2Sec2Ptr = com2SecPtr->next; com2Sec2Ptr != NULL; com2Sec2Ptr = com2Sec2Ptr->next)
                            {
                                    if (!strcmp(com2Sec2Ptr->secName, &vp->securityName[1]))
                                    {
                                        strcpy((char *)user_name , com2Sec2Ptr->community);

                                        return SNMP_MGR_ERROR_OK;
                                    }
                                }
                        }
                    }
                    }
                }
               /* if model is v3, then search UserEntry */
                else if (group_model == SNMP_MGR_SNMPV3_MODEL_V3)
                {
                    SNMP_MGR_SnmpV3UserEntry_T user_entry;
                       UI8_T  localEngineID[MAXSIZE_snmpEngineID];
                    UI32_T engineIDLen;
                   /* get first */

                    engineIDLen = snmpv3_get_engineID( localEngineID, MAXSIZE_snmpEngineID);

                    memcpy(user_entry.snmpv3_user_engine_id, localEngineID, engineIDLen);
                    if (strcmp((char *) user_name, "") == 0)
                    {
                        strcpy(user_entry.snmpv3_user_name, &vp->securityName[1]);
                        user_entry.snmpv3_user_security_model = SNMP_MGR_SNMPV3_MODEL_V3;
                        if (SNMP_MGR_GetSnmpV3User(&user_entry)== SNMP_MGR_ERROR_OK)
                        {
                            strcpy((char *) user_name, user_entry.snmpv3_user_name);
                            *auth_type = user_entry.snmpv3_user_auth_type;
                            *priv_type = user_entry.snmpv3_user_priv_type;

                            return SNMP_MGR_ERROR_OK;
                        }
                    }
                else
               /* get next*/
                {
                    if  (!strcmp(&vp->securityName[1], (char *)user_name))
                        {
                            if (vp->next)
                            {
                                for (vp2 = vp->next; vp2; vp2 = vp2->next)
                                {
                                    if (vp2->securityModel == group_model
                                        && !strcmp(vp2->groupName , (char *)group_name))
                                    {
                                        strcpy(user_entry.snmpv3_user_name, &vp2->securityName[1]);
                                        user_entry.snmpv3_user_security_model = SNMP_MGR_SNMPV3_MODEL_V3;
                                        if (SNMP_MGR_GetSnmpV3User(&user_entry)== SNMP_MGR_ERROR_OK)
                                        {
                                            strcpy((char *) user_name, user_entry.snmpv3_user_name);
                                            *auth_type = user_entry.snmpv3_user_auth_type;
                                            *priv_type = user_entry.snmpv3_user_priv_type;

                                            return SNMP_MGR_ERROR_OK;
                                        }
                                    }/*end of if*/
                                }/*end of for	*/
                        }
                    }
                } /*end of getnext*/
                } /* end of if model = v3*/
            }
        }/* end of for */
        #if (SYS_CPNT_EH == TRUE)
            EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                     0,
                                     EH_TYPE_MSG_NOT_EXIST,
                                    (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));
        #endif

        return SYS_TYPE_GET_RUNNING_CFG_FAIL;
    }
    else
   /* vacmAccessEntry not exist, return FAIL */
    {
        #if (SYS_CPNT_EH == TRUE)
            EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                     0,
                                     EH_TYPE_MSG_NOT_EXIST,
                                    (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));
        #endif

        return SYS_TYPE_GET_RUNNING_CFG_FAIL;
    }
}


/*--------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_GetNextRunningSnmpV3User
 *---------------------------------------------------------------------------
 * PURPOSE:  The GetNext Running Function of Snmp V3 user, to get the first entry with the key of 0.
 * INPUT:        entry->snmpv3_user_engine_id, entry->snmpv3_user_name
 * OUTPUT:   entry.
 * RETURN:   RETURN:   SYS_TYPE_GET_RUNNING_CFG_SUCCESS, SYS_TYPE_GET_RUNNING_CFG_NO_CHANGE, or
 *                     SYS_TYPE_GET_RUNNING_CFG_FAIL
 * NOTE:      1.entry->snmpv3_user_engine_id and entry->snmpv3_user_name = "" to get the first entry.
 *---------------------------------------------------------------------------
 */
UI32_T  SNMP_MGR_GetNextRunningSnmpV3User(SNMP_MGR_SnmpV3UserEntry_T *entry)
{
/* We first get the vacmSecurityToGroupEntry, then use the vacmSecurityToGroupEntry->SecurityName
   to search the usmUserEntry, if exist, return the informaton. */
    struct vacm_groupEntry * vacmgrouplist=NULL, *vp=NULL, *tmpvp= NULL;
    UI8_T  localEngineID[MAXSIZE_snmpEngineID];
    UI32_T engineIDLen;
    UI32_T orig_priority;

    SNMP_MGR_CHECK_OPER_MODE(SYS_TYPE_GET_RUNNING_CFG_FAIL);


    engineIDLen = snmpv3_get_engineID( localEngineID, MAXSIZE_snmpEngineID);
    memcpy(entry->snmpv3_user_engine_id, localEngineID, engineIDLen);
    entry->snmpv3_user_engineIDLen=engineIDLen;
    vacmgrouplist = vacm_get_groupList();


   /* no entry exist at all, return no entry exist*/
    if (!vacmgrouplist)
    {
        #if (SYS_CPNT_EH == TRUE)
            EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                     0,
                                     EH_TYPE_MSG_NOT_EXIST,
                                    (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));

        #endif

        return SYS_TYPE_GET_RUNNING_CFG_FAIL;
    }

   /* Check if want to get the first entry */
    if  ( (strcmp(entry->snmpv3_user_name, "" ) == 0) && (entry->snmpv3_user_security_model == 0))
  /* Get First */
    {
        for (vp = vacmgrouplist; vp; vp = vp->next)
        {
            if (vp->status !=1)
            {
                continue;
            }
            strcpy(entry->snmpv3_user_name, &vp->securityName[1]);
            entry->snmpv3_user_security_model = vp->securityModel;
            entry->snmpv3_user_status = vp->status;
            strcpy(entry->snmpv3_user_group_name, vp->groupName);
            if (SNMP_MGR_GetSnmpV3User( entry)== SNMP_MGR_ERROR_OK)
            {
                if (entry-> snmpv3_user_storage_type== VAL_usmUserStorageType_volatile)
                {
                    continue;
                }
                entry->snmpv3_user_security_model = vp->securityModel;
                entry->snmpv3_user_storage_type = vp->storageType;
                /* if model = v1 or v2c, need to check Community Table*/
                if ((entry->snmpv3_user_security_model == SNMP_MGR_SNMPV3_MODEL_V1) ||
                   (entry->snmpv3_user_security_model == SNMP_MGR_SNMPV3_MODEL_V2C))
                {
                    SNMP_MGR_SnmpCommunityEntry_T comm_entry;

                    strcpy(comm_entry.snmp_community_index, entry->snmpv3_user_name);
                    if (SNMP_MGR_GetSnmpCommunityEntry(&comm_entry)== SNMP_MGR_ERROR_OK)
                    {
                        if (comm_entry.snmp_community_status == VAL_snmpCommunityStatus_active)
                        {

                            return SYS_TYPE_GET_RUNNING_CFG_SUCCESS;
                        }
                        else
                        {
                            continue;
                        }
                    }
                    else
                    {
                        continue;
                    }
                }
                else if (entry->snmpv3_user_security_model == SNMP_MGR_SNMPV3_MODEL_V3)
                {

                    return SYS_TYPE_GET_RUNNING_CFG_SUCCESS;
                }
            }
        }
        #if (SYS_CPNT_EH == TRUE)
        EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                 0,
                                 EH_TYPE_MSG_NOT_EXIST,
                                (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));

        #endif
      /* cannot find a entry match in usmUserEntry */

        return SYS_TYPE_GET_RUNNING_CFG_FAIL;
    }
    else
    {
        /* find the next entry*/
        for (vp = vacmgrouplist; vp; vp = vp->next)
        {
            if (vp->securityModel == entry->snmpv3_user_security_model
                && !strcmp(vp->securityName + 1, entry->snmpv3_user_name))
            break;
        }
        if ((vp) && (vp->next))
        {
            vp = vp->next;
        }
        else
        {
            #if (SYS_CPNT_EH == TRUE)
                EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                         0,
                                         EH_TYPE_MSG_NOT_EXIST,
                                        (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));

            #endif

            return SYS_TYPE_GET_RUNNING_CFG_FAIL;
        }

        for (tmpvp = vp; tmpvp; tmpvp=tmpvp->next)
        {
            if (tmpvp->status !=1)
            {
                continue;
            }
            strcpy(entry->snmpv3_user_name, &tmpvp->securityName[1]);
            entry->snmpv3_user_security_model = tmpvp->securityModel;
            entry->snmpv3_user_status = tmpvp->status;
            strcpy(entry->snmpv3_user_group_name,tmpvp->groupName);
            if (SNMP_MGR_GetSnmpV3User( entry)== SNMP_MGR_ERROR_OK)
            {
               /*
                * [ES4649-ZZ-01429][Problem 3]
                * Sync form [ES3528MO-PoE-FLF-17-00014][Problem 3]
                * Paul_huang marked, when getnext operation is not first get,
                * it shold check that snmpv3_user_storage_type is
                * VAL_usmUserStorageType_volatile or not.
                */
                if (entry-> snmpv3_user_storage_type== VAL_usmUserStorageType_volatile)
                {
                    continue;
                }
                entry->snmpv3_user_security_model = tmpvp->securityModel;
                entry->snmpv3_user_storage_type = tmpvp->storageType;
                /* if model = v1 or v2c, need to check Community Table*/
                if ((entry->snmpv3_user_security_model == SNMP_MGR_SNMPV3_MODEL_V1) ||
                   (entry->snmpv3_user_security_model == SNMP_MGR_SNMPV3_MODEL_V2C))
                {
                    SNMP_MGR_SnmpCommunityEntry_T comm_entry;

                    strcpy(comm_entry.snmp_community_index, entry->snmpv3_user_name);
                    if (SNMP_MGR_GetSnmpCommunityEntry(&comm_entry)== SNMP_MGR_ERROR_OK)
                    {
                        if (comm_entry.snmp_community_status == VAL_snmpCommunityStatus_active)
                        {

                            return SYS_TYPE_GET_RUNNING_CFG_SUCCESS;
                        }
                        else
                        {
                            continue;
                        }
                    }
                    else
                    {
                        continue;
                    }
                }
                else if (entry->snmpv3_user_security_model == SNMP_MGR_SNMPV3_MODEL_V3)
                {

                    return SYS_TYPE_GET_RUNNING_CFG_SUCCESS;
                }
            }
        }
        #if (SYS_CPNT_EH == TRUE)
            EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                     0,
                                     EH_TYPE_MSG_NOT_EXIST,
                                    (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));

        #endif

        return SYS_TYPE_GET_RUNNING_CFG_FAIL;
    }
}

/*--------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_CheckUsmUserEntry
 *---------------------------------------------------------------------------
 * PURPOSE:  The function will check if the usmuserentry is exist
 * INPUT:      entry
 * OUTPUT:  none
 * RETURN:  1. success:    SNMP_MGR_ERROR_OK
 *                    2. failure:      SNMP_MGR_ERROR_EXCEED_LIMIT
 *                                         SNMP_MGR_ERROR_MEM_ALLOC_FAIL
 *                                         SNMP_MGR_ERROR_PARAMETER_NOT_MATCH
 *                                         SNMP_MGR_ERROR_FAIL
 * NOTE:
 *---------------------------------------------------------------------------
 */
UI32_T SNMP_MGR_CheckUsmUserEntry( SNMP_MGR_SnmpV3UserEntry_T  *entry)
{
    struct usmUser *uptr = NULL;
    UI8_T  localEngineID[MAXSIZE_snmpEngineID];
    UI32_T engineIDLen;
    UI32_T orig_priority;
    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);
   /* Since API will return NULL user, we block here to not allow NULL user get*/
    if (strcmp(entry-> snmpv3_user_name, "\0")== 0)
    {
        #if (SYS_CPNT_EH == TRUE)
            EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                     0,
                                     EH_TYPE_MSG_INVALID_PARAMETER,
                                    (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));

        #endif

        return SNMP_MGR_ERROR_FAIL;
    }
   /*
    * Now see if a user already exists with these index values.
    */

    engineIDLen = snmpv3_get_engineID( localEngineID, MAXSIZE_snmpEngineID);

    uptr = usm_get_user(localEngineID, engineIDLen, entry->snmpv3_user_name);


    if (uptr)
    {

        return SNMP_MGR_ERROR_OK;
    }
    else
    {
        #if (SYS_CPNT_EH == TRUE)
            EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                     0,
                                     EH_TYPE_MSG_NOT_EXIST,
                                    (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));

        #endif

        return SNMP_MGR_ERROR_FAIL;
    }

    return SNMP_MGR_ERROR_FAIL;
}

/*--------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_GetSnmpV3Group
 *---------------------------------------------------------------------------
 * PURPOSE:  This function will Get the Snmp V3 group
 * INPUT:    entry->snmpv3_group_name, entry->snmpv3_group_context_prefix, entry->snmpv3_group_model, entry->snmpv3_group_security_level.
 * OUTPUT:   entry.
 * RETURN:  1. success:    SNMP_MGR_ERROR_OK
 *                    2. failure:      SNMP_MGR_ERROR_EXCEED_LIMIT
 *                                         SNMP_MGR_ERROR_MEM_ALLOC_FAIL
 *                                         SNMP_MGR_ERROR_PARAMETER_NOT_MATCH
 *                                         SNMP_MGR_ERROR_FAIL
 * NOTE:     None.
 *---------------------------------------------------------------------------
 */
UI32_T  SNMP_MGR_GetSnmpV3Group( SNMP_MGR_SnmpV3GroupEntry_T  *entry)
{
    struct vacm_accessEntry *aptr = NULL;
    UI32_T orig_priority;
    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);

    aptr = vacm_getExactAccessEntry(entry->snmpv3_group_name,  "",  entry->snmpv3_group_model,  entry->snmpv3_group_security_level);

    if ( aptr)
    {
        strcpy ( entry->snmpv3_group_readview, aptr->readView);
         strcpy( entry->snmpv3_group_writeview, aptr->writeView);
         strcpy(entry->snmpv3_group_notifyview, aptr->notifyView);
        entry->snmpv3_group_status = aptr->status;
        entry->snmpv3_group_storage_type = aptr->storageType;

        return SNMP_MGR_ERROR_OK;
    }
    else
    {
        #if (SYS_CPNT_EH == TRUE)
            EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                     0,
                                     EH_TYPE_MSG_NOT_EXIST,
                                    (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));

        #endif

        return SNMP_MGR_ERROR_FAIL;
    }

        return SNMP_MGR_ERROR_OK;
}


/*--------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_GetNextSnmpV3Group
 *---------------------------------------------------------------------------
 * PURPOSE:  The GetNext Function of SNMP V3 Group.
 * INPUT:    entry->snmpv3_group_name, entry->snmpv3_group_context_prefix, entry->snmpv3_group_model, entry->snmpv3_group_security_level.
 * OUTPUT:   entry.
 * RETURN:  1. success:    SNMP_MGR_ERROR_OK
 *                    2. failure:      SNMP_MGR_ERROR_EXCEED_LIMIT
 *                                         SNMP_MGR_ERROR_MEM_ALLOC_FAIL
 *                                         SNMP_MGR_ERROR_PARAMETER_NOT_MATCH
 *                                         SNMP_MGR_ERROR_FAIL
 * NOTE:    1.To get the first entry, input all the key to 0 or NULL
 *---------------------------------------------------------------------------
 */
UI32_T SNMP_MGR_GetNextSnmpV3Group( SNMP_MGR_SnmpV3GroupEntry_T *entry)
{
    struct vacm_accessEntry *vp , * accessList = NULL;
    UI32_T orig_priority;

    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);


    accessList = vacm_get_accessList();


    if (!accessList)
    {
        #if (SYS_CPNT_EH == TRUE)
            EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                     0,
                                     EH_TYPE_MSG_NOT_EXIST,
                                    (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));

        #endif

        return SNMP_MGR_ERROR_FAIL;
    }

    if  ((strcmp((char *)entry->snmpv3_group_name, "" ) == 0)  &&(strcmp((char *)entry->snmpv3_group_context_prefix, "")== 0) &&
         (entry->snmpv3_group_model == 0) && ( entry->snmpv3_group_security_level== 0 ) )
 /* Get First */
    {
        strcpy(entry->snmpv3_group_name ,& accessList->groupName[1]);
        strcpy((char *)entry->snmpv3_group_context_prefix, (char *)&accessList->contextPrefix[1]);
        entry->snmpv3_group_model = (SNMP_MGR_Snmpv3_Model_T)accessList->securityModel;
        entry->snmpv3_group_security_level = accessList->securityLevel;
    }
    else
    {
   /* find the next entry*/
        for (vp = accessList; vp; vp = vp->next)
        {
            if (vp->securityModel == entry->snmpv3_group_model
                && vp->securityLevel ==entry-> snmpv3_group_security_level
                && !strcmp(vp->groupName + 1, entry->snmpv3_group_name)
                && !strcmp(vp->contextPrefix + 1, (char *)entry->snmpv3_group_context_prefix))
            break;
        }
        if ((vp) && (vp->next))
        {
            vp = vp->next;
            strcpy(entry->snmpv3_group_name , &vp->groupName[1]);
            strcpy((char *)entry->snmpv3_group_context_prefix, (char *)&vp->contextPrefix[1]);
            entry->snmpv3_group_model = (SNMP_MGR_Snmpv3_Model_T)vp->securityModel;
            entry->snmpv3_group_security_level = vp->securityLevel;
        }
        else
        {
            #if (SYS_CPNT_EH == TRUE)
                EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                         0,
                                         EH_TYPE_MSG_NOT_EXIST,
                                        (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));

            #endif

            return SNMP_MGR_ERROR_FAIL;
        }
    }

    if (SNMP_MGR_GetSnmpV3Group( entry)== SNMP_MGR_ERROR_OK)
    {

        return SNMP_MGR_ERROR_OK;
    }
    else
    {
        #if (SYS_CPNT_EH == TRUE)
                EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                         0,
                                         EH_TYPE_MSG_NOT_EXIST,
                                        (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));

        #endif

        return SNMP_MGR_ERROR_FAIL;
    }

    return SNMP_MGR_ERROR_FAIL;
}


/*--------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_GetNextRunningSnmpV3Group
 *---------------------------------------------------------------------------
 * PURPOSE:  The GetNext  Running Function of SNMP V3 Group.
 * INPUT:    entry->snmpv3_group_name, entry->snmpv3_group_context_prefix, entry->snmpv3_group_model, entry->snmpv3_group_security_level.
 * OUTPUT:   entry.
 * RETURN:   SYS_TYPE_GET_RUNNING_CFG_SUCCESS, SYS_TYPE_GET_RUNNING_CFG_NO_CHANGE, or
 *                     SYS_TYPE_GET_RUNNING_CFG_FAIL
 * NOTE:      1.To get the first entry, input all the key to 0 or NULL
 *---------------------------------------------------------------------------
 */
UI32_T  SNMP_MGR_GetNextRunningSnmpV3Group( SNMP_MGR_SnmpV3GroupEntry_T *entry)
{
    UI32_T ret_val;

    SNMP_MGR_CHECK_OPER_MODE(SYS_TYPE_GET_RUNNING_CFG_FAIL);

    while (1)
    {
        ret_val = SNMP_MGR_GetNextSnmpV3Group(entry);
        if ( ret_val !=  SNMP_MGR_ERROR_OK)
        {
           break;
        }
        if (entry->snmpv3_group_storage_type== VAL_vacmAccessStorageType_nonVolatile)
        {
            break;
        }
    }

    if (ret_val == SNMP_MGR_ERROR_OK)
    {

        return SYS_TYPE_GET_RUNNING_CFG_SUCCESS;
    }
    else
    {
        #if (SYS_CPNT_EH == TRUE)
                EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                         0,
                                         EH_TYPE_MSG_NOT_EXIST,
                                        (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));

        #endif

        return SYS_TYPE_GET_RUNNING_CFG_FAIL;
    }
}

/*--------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_GetSnmpV3View
 *---------------------------------------------------------------------------
 * PURPOSE:  This function will Get the SNMPV3 View
 * INPUT:    entry->snmpv3_view_name, entry->snmpv3_view_subtree
 * OUTPUT:   entry.
 * RETURN:  1. success:    SNMP_MGR_ERROR_OK
 *                    2. failure:      SNMP_MGR_ERROR_EXCEED_LIMIT
 *                                         SNMP_MGR_ERROR_MEM_ALLOC_FAIL
 *                                         SNMP_MGR_ERROR_PARAMETER_NOT_MATCH
 *                                         SNMP_MGR_ERROR_FAIL
 * NOTE:     None.
 *---------------------------------------------------------------------------
 */
UI32_T SNMP_MGR_GetSnmpV3View(SNMP_MGR_SnmpV3ViewEntry_T  *entry)
{
    oid tmp_subtree[MAXSIZE_VIEW_SUBTREE],  subtree[MAXSIZE_VIEW_SUBTREE];
    UI32_T oid_len;
    struct vacm_viewEntry  *viewentry;
    UI32_T orig_priority;
    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);
    SNMP_MGR_StringToObejctID(tmp_subtree, (I8_T *)entry->snmpv3_view_subtree, &oid_len);
    subtree[0]= oid_len;
    memcpy( &subtree[1], tmp_subtree, sizeof(oid) * oid_len);

    viewentry= vacm_getExactViewEntry(entry-> snmpv3_view_name, subtree, oid_len+1);

    if ( viewentry)
    {
        if (!SNMP_MGR_Transform_TreeToWildCard((UI8_T *) entry->snmpv3_wildcard_subtree, (UI8_T *)entry->snmpv3_view_subtree, viewentry->viewMask, (viewentry->viewSubtreeLen-1) ))
         {
             #if (SYS_CPNT_EH == TRUE)
                EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                         0,
                                         EH_TYPE_MSG_INVALID_PARAMETER,
                                        (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));

            #endif
             SYSFUN_Debug_Printf("transform to wild card error\n");

             return SNMP_MGR_ERROR_FAIL;
         }
         memcpy( entry->snmpv3_view_mask,  viewentry->viewMask, (viewentry->viewSubtreeLen + 7) / 8  );
        entry->snmpv3_view_subtree_len = viewentry->viewSubtreeLen;
         entry->snmpv3_view_type = viewentry->viewType;
         entry->snmpv3_view_storage_type = viewentry->viewStorageType;
         entry->snmpv3_view_status = viewentry->viewStatus;

           return SNMP_MGR_ERROR_OK;
    }
    else
    {
        #if (SYS_CPNT_EH == TRUE)
            EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                     0,
                                     EH_TYPE_MSG_NOT_EXIST,
                                    (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));

        #endif

           return SNMP_MGR_ERROR_FAIL;
    }
}


/*--------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_GetNextSnmpV3ViewName
 *---------------------------------------------------------------------------
 * PURPOSE:  The GetNext Function of Snmp V3 View Name.
 * INPUT:   view_name,
 * OUTPUT:  view_name
 * RETURN:  1. success:    SNMP_MGR_ERROR_OK
 *          2. failure:    SNMP_MGR_ERROR_EXCEED_LIMIT
 *                         SNMP_MGR_ERROR_MEM_ALLOC_FAIL
 *                         SNMP_MGR_ERROR_PARAMETER_NOT_MATCH
 *                         SNMP_MGR_ERROR_FAIL
 * NOTE:     1. To get the first entry with the key of 0 or null.
 *           2. For Web only.
 *---------------------------------------------------------------------------
 */
UI32_T SNMP_MGR_GetNextSnmpV3ViewName(UI8_T *view_name)
{
    struct vacm_viewEntry *vp , * viewList = NULL;
    UI32_T orig_priority;

    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);


    viewList = vacm_get_viewList();

    if (!viewList)
    {
        #if (SYS_CPNT_EH == TRUE)
            EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                     0,
                                     EH_TYPE_MSG_NOT_EXIST,
                                    (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));

        #endif

        return SNMP_MGR_ERROR_FAIL;
    }

    if  ( strcmp((char *)view_name, "" ) == 0  )
    /* Get First and return*/
    {
        strncpy((char *)view_name, (char *)&viewList->viewName[1], MAXSIZE_vacmViewTreeFamilyViewName+1 );
        view_name[MAXSIZE_vacmViewTreeFamilyViewName+1] = '\0';

        return SNMP_MGR_ERROR_OK;
    }
    else
    {
   /* find the next entry*/
        for (vp = viewList; vp; vp = vp->next)
        {
            if ( (strcmp((char *)(vp->viewName + 1), (char *) view_name) == 0))
            {
                if ((vp) && (vp->next) )
                {
                    vp=vp->next;
                    while(strcmp((char *)(vp->viewName +1), (char *)view_name) == 0)
                    {
                        vp= vp->next;
                        if(vp==NULL)
                            break;
                    }
                    if (vp)
                    {
                        strcpy((char *)view_name, (char *) &vp->viewName[1]);

                        return SNMP_MGR_ERROR_OK;
                    }
                    else
                    {
                        #if (SYS_CPNT_EH == TRUE)
                            EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                                     0,
                                                     EH_TYPE_MSG_NOT_EXIST,
                                                    (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));

                        #endif

                        return SNMP_MGR_ERROR_FAIL;
                    }
                }
                else
                {
                    #if (SYS_CPNT_EH == TRUE)
                        EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                                 0,
                                                 EH_TYPE_MSG_NOT_EXIST,
                                                (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));

                    #endif

                    return SNMP_MGR_ERROR_FAIL;
                }
            }
        }
    }
    #if (SYS_CPNT_EH == TRUE)
         EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                  0,
                                  EH_TYPE_MSG_NOT_EXIST,
                                 (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));

    #endif

    return SNMP_MGR_ERROR_FAIL;
}


/*--------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_GetNextSnmpV3View
 *---------------------------------------------------------------------------
 * PURPOSE:  The GetNext Function of Snmp V3 View
 * INPUT:      entry->snmpv3_view_name, entry->snmpv3_view_subtree
 * OUTPUT:   entry.
 * RETURN:  1. success:    SNMP_MGR_ERROR_OK
 *                    2. failure:      SNMP_MGR_ERROR_EXCEED_LIMIT
 *                                         SNMP_MGR_ERROR_MEM_ALLOC_FAIL
 *                                         SNMP_MGR_ERROR_PARAMETER_NOT_MATCH
 *                                         SNMP_MGR_ERROR_FAIL
 * NOTE:     1. To get the first entry with the key of 0 or null.
 *---------------------------------------------------------------------------
 */
UI32_T SNMP_MGR_GetNextSnmpV3View(SNMP_MGR_SnmpV3ViewEntry_T  *entry)
{
    struct vacm_viewEntry *vp , * viewList = NULL;
    oid tmp_subtree[MAXSIZE_VIEW_SUBTREE];
    UI32_T orig_priority;

    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);


    viewList = vacm_get_viewList();

    if (!viewList)
    {
        #if (SYS_CPNT_EH == TRUE)
            EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                     0,
                                     EH_TYPE_MSG_NOT_EXIST,
                                    (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));

        #endif

        return SNMP_MGR_ERROR_FAIL;
    }

    if ((strcmp(entry->snmpv3_view_name, "" ) == 0)  &&(strcmp(entry->snmpv3_view_subtree, "")== 0))
   /* Get First */
    {
        strcpy(entry->snmpv3_view_name ,& viewList->viewName[1]);
        SNMP_MGR_ObjectIDToString(&viewList->viewSubtree[1], (I8_T *)entry->snmpv3_view_subtree  ,  viewList->viewSubtreeLen-1);
    }
    else
    {
   /* find the next entry*/
        for (vp = viewList; vp; vp = vp->next)
        {
            SNMP_MGR_StringToObejctID(&tmp_subtree[1], (I8_T *)entry->snmpv3_view_subtree,  &(entry->snmpv3_view_subtree_len));
            tmp_subtree[0] = entry->snmpv3_view_subtree_len;
            entry->snmpv3_view_subtree_len = entry->snmpv3_view_subtree_len+1;
            if ((strcmp(vp->viewName + 1, entry->snmpv3_view_name) == 0)
                && (vp->viewSubtreeLen == entry->snmpv3_view_subtree_len)
                && (memcmp((char *) vp->viewSubtree, (char *) tmp_subtree,
                vp->viewSubtreeLen * sizeof(oid)) == 0) )
            break;
        }
        if ((vp) && (vp->next))
        {
            vp = vp->next;
            strcpy(entry->snmpv3_view_name , &vp->viewName[1]);
            SNMP_MGR_ObjectIDToString(    &vp->viewSubtree[1], (I8_T *)entry->snmpv3_view_subtree,  vp->viewSubtreeLen-1);
        }
        else
        {
            #if (SYS_CPNT_EH == TRUE)
                EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                         0,
                                         EH_TYPE_MSG_NOT_EXIST,
                                        (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));

            #endif

            return SNMP_MGR_ERROR_FAIL;
        }
    }
    if (SNMP_MGR_GetSnmpV3View( entry)== SNMP_MGR_ERROR_OK)
    {

        return SNMP_MGR_ERROR_OK;
    }
    else
    {
        #if (SYS_CPNT_EH == TRUE)
            EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                     0,
                                     EH_TYPE_MSG_NOT_EXIST,
                                    (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));

        #endif

        return SNMP_MGR_ERROR_FAIL;
    }
}


/*--------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_GetNextRunningSnmpV3View
 *---------------------------------------------------------------------------
 * PURPOSE:  The GetNext Ruuning Function of Snmp V3 View.
 * INPUT:      entry->snmpv3_view_name, entry->snmpv3_view_subtree
 * OUTPUT:   entry.
 * RETURN:   SYS_TYPE_GET_RUNNING_CFG_SUCCESS, SYS_TYPE_GET_RUNNING_CFG_NO_CHANGE, or
 *                     SYS_TYPE_GET_RUNNING_CFG_FAIL
 * NOTE:     1. To get the first entry with the key of 0 or null.
 *---------------------------------------------------------------------------
 */
UI32_T  SNMP_MGR_GetNextRunningSnmpV3View(SNMP_MGR_SnmpV3ViewEntry_T  *entry)
{
    UI32_T ret_val;

    SNMP_MGR_CHECK_OPER_MODE(SYS_TYPE_GET_RUNNING_CFG_FAIL);
    while (1)
    {
        ret_val = SNMP_MGR_GetNextSnmpV3View(entry);
        if ( ret_val !=  SNMP_MGR_ERROR_OK)
        {
           break;
        }
        if (entry->snmpv3_view_storage_type== VAL_vacmViewTreeFamilyStorageType_nonVolatile)
        {
            break;
        }
    }

    if (ret_val == SNMP_MGR_ERROR_OK)
    {

        return SYS_TYPE_GET_RUNNING_CFG_SUCCESS;
    }
    else
    {
        #if (SYS_CPNT_EH == TRUE)
            EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                     0,
                                     EH_TYPE_MSG_NOT_EXIST,
                                    (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));

        #endif

        return SYS_TYPE_GET_RUNNING_CFG_FAIL;
    }
}


/*--------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_Set_EngineID
 *---------------------------------------------------------------------------
 * PURPOSE:  This function will Set the SNMP V3 EngineID
 * INPUT:    newengineID..
 * OUTPUT:   None.
 * RETURN:  1. success:    SNMP_MGR_ERROR_OK
 *                    2. failure:      SNMP_MGR_ERROR_EXCEED_LIMIT
 *                                         SNMP_MGR_ERROR_MEM_ALLOC_FAIL
 *                                         SNMP_MGR_ERROR_PARAMETER_NOT_MATCH
 *                                         SNMP_MGR_ERROR_FAIL
 * NOTE:     All uiser will delete when an new engineID is set..
 *---------------------------------------------------------------------------
 */
UI32_T  SNMP_MGR_Set_EngineID(UI8_T *newengineID, UI32_T engineIDLen)
{
    UI32_T orig_priority;
    UI8_T current_engine_id[MAXSIZE_snmpEngineID];
    UI32_T current_engine_id_len;

    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);

    memset(current_engine_id, 0, sizeof(current_engine_id));
    current_engine_id_len = snmpv3_get_engineID(current_engine_id,
        sizeof(current_engine_id));

    /* Not to apply again if engine ID is unchange.
     */
    if (   (engineIDLen == current_engine_id_len)
        && (0 == memcmp(newengineID, current_engine_id, engineIDLen))
        )
    {
        return SNMP_MGR_ERROR_OK;
    }

    if (setup_engineID_byLength(newengineID, engineIDLen) == -1)
    {
        return SNMP_MGR_ERROR_FAIL;
    }

    /* set our local engineTime in the LCD timing cache
     */
    set_enginetime(newengineID, engineIDLen,
                   snmpv3_local_snmpEngineBoots(),
                   snmpv3_local_snmpEngineTime(), TRUE);

    SNMP_MGR_DeleteAllSnmpV3User();

#if (SYS_CPNT_CFGDB == TRUE)
    /* Set during provision is not user operation so that it is unnecessary to
     * reset boots counter.
     */
    if (TRUE == is_prov_complete)
    {
        snmp_mgr_engine_info.engine_boots = 1;
        memset(snmp_mgr_engine_info.engineid, 0, sizeof(snmp_mgr_engine_info.engineid));
        memcpy(snmp_mgr_engine_info.engineid, newengineID, engineIDLen);
    }

    CFGDB_MGR_WriteSection(snmp_mgr_engine_info_session_handler,
        &snmp_mgr_engine_info);
#endif

    return SNMP_MGR_ERROR_OK;
}

/* ---------------------------------------------------------------------
 * ROUTINE NAME  - SNMP_MGR_GetSnmpCommunity
 * ---------------------------------------------------------------------
 * PURPOSE: This function returns true if the specified SNMP community
 *          string can be retrieved successfully. Otherwise, false is returned.
 *
 * INPUT: comm_entry->comm_string_name - (key) to specify a unique SNMP community string
 * OUTPUT: comm_string                  - SNMP community info
 * RETURN:  1. success:    SNMP_MGR_ERROR_OK
 *                    2. failure:      SNMP_MGR_ERROR_EXCEED_LIMIT
 *                                         SNMP_MGR_ERROR_MEM_ALLOC_FAIL
 *                                         SNMP_MGR_ERROR_PARAMETER_NOT_MATCH
 *                                         SNMP_MGR_ERROR_FAIL
 * NOTES: 1. The SNMP community string can only be accessed by CLI and Web.
 *                     SNMP management station CAN NOT access the SNMP community string.
 *                2. There is no MIB to define the SNMP community string.
 *
 *
 *           Commuinty string name is an "ASCII Zero" string (char array ending with '\0').
 *
 *           Access right of community string could be
 *              - READ_ONLY(1)
 *              - READ_WRITE(2)
 *
 *        4. The total number of SNMP community string supported by the system
 *           is defined by SNMP_MGR_MAX_NBR_OF_SNMP_COMMUNITY_STRING.
 *        5. By default, two SNMM community string are configued:
 *              - "PUBLIC"      READ-ONLY       enabled
 *              - "PRIVATE"     READ-WRITE      enabled
 *        6. For any SNMP request command, all of enabled community string
 *             shall be used to authorize if this SNMP request is legal/permit.
 * ---------------------------------------------------------------------
 */
UI32_T SNMP_MGR_GetSnmpCommunity(SNMP_MGR_SnmpCommunity_T *comm_entry)
{
    struct _com2SecEntry *com2SecPtr = NULL;
    BOOL_T  checkpass = FALSE;
    UI32_T orig_priority;

    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);

    com2SecPtr = netsnmp_udp_getCom2SecEntry(comm_entry->comm_string_name);

    if ( com2SecPtr)
    {
        comm_entry->access_right = com2SecPtr->access_right;
        /* need to check if securityToGroupEntry is valid*/

        /* if this community is group specific, need to check 1. usmUserEntry,
         * 2.vacmSecurityToGroupEntry is exist
         */
        if (comm_entry->access_right == SNMP_MGR_ACCESS_RIGHT_GROUP_SPECIFIC)
        {
            SNMP_MGR_SnmpV3UserEntry_T sec_to_group_entry;
            SNMP_MGR_SnmpV3UserEntry_T usm_entry;

            memset(&sec_to_group_entry, 0, sizeof(sec_to_group_entry));
            /* check v1 model first*/
            sec_to_group_entry.snmpv3_user_security_model = SNMP_MGR_SNMPV3_MODEL_V1;
            strcpy(sec_to_group_entry.snmpv3_user_name, comm_entry->comm_string_name);
            if (SNMP_MGR_ERROR_OK == SNMP_MGR_GetSecurityToGroupTable(&sec_to_group_entry))
            {
                if (sec_to_group_entry.snmpv3_user_status == VAL_usmUserStatus_active)
                {
                    checkpass = TRUE;
                }
            }
            sec_to_group_entry.snmpv3_user_security_model = SNMP_MGR_SNMPV3_MODEL_V2C;
            if (SNMP_MGR_ERROR_OK == SNMP_MGR_GetSecurityToGroupTable(&sec_to_group_entry))
            {
                if (sec_to_group_entry.snmpv3_user_status == VAL_usmUserStatus_active)
                {
                    checkpass = TRUE;
                }
            }
            memset(&usm_entry, 0, sizeof(usm_entry));
            strcpy(usm_entry.snmpv3_user_name, comm_entry->comm_string_name);
            /* check if the community is from snmp-user command*/
            if (SNMP_MGR_ERROR_OK != SNMP_MGR_GetUsmUserEntry(&usm_entry))
            {
                checkpass = FALSE;
            }
            else if (usm_entry.snmpv3_user_status != VAL_usmUserStatus_active)
            {
                checkpass = FALSE;
            }

            if (checkpass == TRUE)
            {

                return SNMP_MGR_ERROR_OK;
            }
            else
            {
                #if (SYS_CPNT_EH == TRUE)
                    EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                             0,
                                             EH_TYPE_MSG_NOT_EXIST,
                                            (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));
                #endif

                 return SNMP_MGR_ERROR_FAIL;
            }
        }

        return SNMP_MGR_ERROR_OK;
    }
    else
    {
        #if (SYS_CPNT_EH == TRUE)
            EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                     0,
                                     EH_TYPE_MSG_NOT_EXIST,
                                    (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));
        #endif

        return SNMP_MGR_ERROR_FAIL;
    }

    return SNMP_MGR_ERROR_OK;
}

/* ---------------------------------------------------------------------
 * ROUTINE NAME  - SNMP_MGR_GetAccessRightOfCommunity2SecurityEntry
 * ---------------------------------------------------------------------
 * PURPOSE: This function is used to get access right of the specified community to security entry.
 *
 * INPUT:  com2SecEntry - The community to security entry.
 * OUTPUT: access_right - SNMP_MGR_ACCESS_RIGHT_GROUP_SPECIFIC
 *                        SNMP_MGR_ACCESS_RIGHT_READ_ONLY
 *                        SNMP_MGR_ACCESS_RIGHT_READ_WRITE
 * RETURN:  1. success:   SNMP_MGR_ERROR_OK
 *          2. failure:   SNMP_MGR_ERROR_FAIL
 * NOTES:
 * ---------------------------------------------------------------------
 */
static UI32_T SNMP_MGR_GetAccessRightOfCommunity2SecurityEntry(struct _com2SecEntry *com2SecEntry, SNMP_MGR_Snmp_Comm_Access_Right_T *access_right)
{
    struct usmUser *uptr = NULL;
    UI8_T  localEngineID[MAXSIZE_snmpEngineID];
    UI32_T engineIDLen;

    engineIDLen = snmpv3_get_engineID(localEngineID, MAXSIZE_snmpEngineID);

    uptr = usm_get_user(localEngineID, engineIDLen, com2SecEntry->community);

    if ((uptr) && (uptr->userStatus == VAL_usmUserStatus_active))
    {
        if ( (uptr->userSecLevel != SNMP_MGR_SNMPV3_MODEL_V1)
           &&(uptr->userSecLevel != SNMP_MGR_SNMPV3_MODEL_V2C))
        {
            return SNMP_MGR_ERROR_FAIL;
        }

        *access_right = SNMP_MGR_ACCESS_RIGHT_GROUP_SPECIFIC;
    }
    else
    {
        struct vacm_accessEntry *vp , *accessList = NULL;

        accessList = vacm_get_accessList();

        for (vp = accessList; vp; vp = vp->next)
        {
            if ((strcmp(vp->groupName+1, com2SecEntry->secName) == 0)
               &&(vp->status == VAL_vacmAccessStatus_active))
            {
                break;
            }
        }

        if (vp == NULL)
        {
            return SNMP_MGR_ERROR_FAIL;
        }

        if ( (vp->securityModel != SNMP_MGR_SNMPV3_MODEL_V1)
           &&(vp->securityModel != SNMP_MGR_SNMPV3_MODEL_V2C))
        {
            return SNMP_MGR_ERROR_FAIL;
        }

        if (vp->writeView[0] != '\0')
        {
            *access_right = SNMP_MGR_ACCESS_RIGHT_READ_WRITE;
        }
        else
        {
            *access_right = SNMP_MGR_ACCESS_RIGHT_READ_ONLY;
        }
    }

    return SNMP_MGR_ERROR_OK;
}

/* ---------------------------------------------------------------------
 * ROUTINE NAME  - SNMP_MGR_GetNextSnmpCommunity
 * ---------------------------------------------------------------------
 * PURPOSE: This function returns true if the next available SNMP community
 *          string can be retrieved successfully. Otherwise, false is returned.
 *
 * INPUT: comm_entry->comm_string_name - (key) to specify a unique SNMP community string
 * OUTPUT: comm_string                  - next available SNMP community info
 * RETURN: SNMP_MGR_ERROR_OK/SNMP_MGR_ERROR_FAIL
 * NOTES: 1. Commuinty string name is an "ASCII Zero" string (char array ending with '\0').
 *        2. Any invalid(0) community string will be skip duing the GetNext operation.
 */
UI32_T SNMP_MGR_GetNextSnmpCommunity(SNMP_MGR_SnmpCommunity_T *entry)
{
    struct _com2SecEntry *com2SecPtr, *com2SecList = NULL;
    UI32_T orig_priority;

    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);

    com2SecList = netsnmp_udp_get_com2SecList();


    /* no any community exist at all */
    if (!com2SecList)
    {
        #if (SYS_CPNT_EH == TRUE)
            EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                     0,
                                     EH_TYPE_MSG_NOT_EXIST,
                                    (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));
        #endif

        return SNMP_MGR_ERROR_FAIL;
    }

    if(strcmp(entry->comm_string_name, "" ) == 0)
   /* Get First */
    {
        strcpy(entry->comm_string_name , com2SecList->community);

        if (SNMP_MGR_ERROR_OK != SNMP_MGR_GetAccessRightOfCommunity2SecurityEntry(com2SecList, (SNMP_MGR_Snmp_Comm_Access_Right_T *)&entry->access_right))
        {
            goto Next;
        }
    }
    else
    {
 Next:
        for (com2SecPtr = com2SecList; com2SecPtr != NULL; com2SecPtr = com2SecPtr->next)
        {
            if (!strcmp(com2SecPtr->community, entry->comm_string_name)    )
            break;
        }
        if ((com2SecPtr) && (com2SecPtr->next))
        {
             com2SecPtr = com2SecPtr->next;
            strcpy(entry->comm_string_name , com2SecPtr->community);

            if (SNMP_MGR_ERROR_OK != SNMP_MGR_GetAccessRightOfCommunity2SecurityEntry(com2SecPtr, (SNMP_MGR_Snmp_Comm_Access_Right_T *)&entry->access_right))
            {
                goto Next;
            }
        }
        else
        {
            #if (SYS_CPNT_EH == TRUE)
                EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                         0,
                                         EH_TYPE_MSG_NOT_EXIST,
                                        (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));
            #endif

            return SNMP_MGR_ERROR_FAIL;
        }
    }

    return SNMP_MGR_ERROR_OK;
}


/* ---------------------------------------------------------------------
 * ROUTINE NAME  - SNMP_MGR_GetNextRunningSnmpCommunity
 * ---------------------------------------------------------------------
 * PURPOSE: This function returns SYS_TYPE_GET_RUNNING_CFG_SUCCESS if the
 *          next available non-default SNMP community can be retrieved
 *          successfully. Otherwise, SYS_TYPE_GET_RUNNING_CFG_FAIL
 *          or SYS_TYPE_GET_RUNNING_CFG_NO_CHANGE is returned.
 * INPUT: comm_entry->comm_string_name - (key) to specify a unique SNMP community
 * OUTPUT: snmp_comm                  - next available non-default SNMP community
 * RETURN: SYS_TYPE_GET_RUNNING_CFG_SUCCESS, SYS_TYPE_GET_RUNNING_CFG_NO_CHANGE, or
 *         SYS_TYPE_GET_RUNNING_CFG_FAIL
 * NOTES: 1. This function shall only be invoked by CLI to save the
 *           "running configuration" to local or remote files.
 *        2. Since only non-default configuration will be saved, this
 *           function shall return non-default SNMP community.
 *        3. Community string name is an "ASCII Zero" string (char array ending with '\0').
 *        4. Any invalid(0) SNMP community will be skip during the GetNext operation.
 * ---------------------------------------------------------------------
 */
UI32_T SNMP_MGR_GetNextRunningSnmpCommunity(SNMP_MGR_SnmpCommunity_T *entry)
{
    struct _com2SecEntry *com2SecPtr, *com2SecList = NULL;
    UI32_T orig_priority;

    SNMP_MGR_CHECK_OPER_MODE(SYS_TYPE_GET_RUNNING_CFG_FAIL);


    com2SecList = netsnmp_udp_get_com2SecList();


   /* no any community exist at all */
    if (!com2SecList)
    {
        #if (SYS_CPNT_EH == TRUE)
            EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                     0,
                                     EH_TYPE_MSG_NOT_EXIST,
                                    (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));
        #endif

        return SNMP_MGR_ERROR_FAIL;
    }
    if(strcmp(entry->comm_string_name, "" ) == 0)
 /* Get First */
    {
        entry->access_right = com2SecList->access_right;
        strcpy(entry->comm_string_name , com2SecList->community);
    }
    else
    {
        for (com2SecPtr = com2SecList; com2SecPtr != NULL; com2SecPtr = com2SecPtr->next)
        {
            if (!strcmp(com2SecPtr->community, entry->comm_string_name)    )
                break;
        }
        if ((com2SecPtr) && (com2SecPtr->next))
        {
            com2SecPtr = com2SecPtr->next;
            strcpy(entry->comm_string_name , com2SecPtr->community);
            entry->access_right = com2SecPtr->access_right;
        }
        else
        {
            #if (SYS_CPNT_EH == TRUE)
                EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                         0,
                                         EH_TYPE_MSG_NOT_EXIST,
                                        (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));
            #endif

            return SYS_TYPE_GET_RUNNING_CFG_FAIL;
        }
    }

    return SYS_TYPE_GET_RUNNING_CFG_SUCCESS;
}


/* ---------------------------------------------------------------------
 * ROUTINE NAME  - SNMP_MGR_CreateSnmpCommunity
 * ---------------------------------------------------------------------
 * PURPOSE: This function returns true if we  can  successfully
 *         create  the specified community string. Otherwise, false is returned.
 *
 * INPUT: comm_string_name  - (key) to specify a unique SNMP community string
 *        access_right      - the access level for this SNMP community
 * OUTPUT: None
 * RETURN: 1. success(SNMP_MGR_ERROR_OK),  2. failure (see snmp_mgr.h)
 * NOTES: 1. This function will create a new community string to the system
 *           if the specified comm_string_name does not exist, and total number
 *           of community string configured is less than
 *           SYS_ADPT_MAX_NBR_OF_SNMP_COMMUNITY_STRING.
 *        2. This function will update the access right an existed community
 *           string if the specified comm_string_name existed already.
 *        3. False is returned if total number of community string configured
 *           is greater than SYS_ADPT_MAX_NBR_OF_SNMP_COMMUNITY_STRING
 * ---------------------------------------------------------------------
 */
UI32_T  SNMP_MGR_CreateSnmpCommunity(char *comm_string_name, UI32_T access_right)
{
    SNMP_MGR_SnmpCommunityEntry_T  entry;
    SNMP_MGR_SnmpCommunity_T  c_entry;
    UI32_T  retval;
    struct vacm_groupEntry *grouplist, *gptr= NULL;
    BOOL_T  checkusmentry = TRUE;
    SNMP_MGR_SnmpV3UserEntry_T  usm_entry;
    SNMP_MGR_SnmpV3GroupEntry_T group_entry;
    struct vacm_groupEntry *geptr= NULL;
    UI8_T param1[2*SYS_ADPT_MAX_COMM_STR_NAME_LEN + 15];
    UI8_T savenotifyviewforv1[MAXSIZE_vacmViewTreeFamilyViewName+1] = {0};
    UI8_T savenotifyviewforv2[MAXSIZE_vacmViewTreeFamilyViewName+1] = {0};
    UI32_T orig_priority;
    BOOL_T is_created_by_auto = FALSE;

    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);
    memset( &group_entry, 0, sizeof(group_entry));

     /* check the input data is valid */
    if (strlen(comm_string_name) > SYS_ADPT_MAX_COMM_STR_NAME_LEN)

    {
        #if (SYS_CPNT_EH == TRUE)
            EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                     0,
                                     EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                    (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));
        #endif

        return SNMP_MGR_ERROR_FAIL;
    }

   /* check if input community is NULL */
    if (strcmp(comm_string_name, "")== 0)
    {
        return SNMP_MGR_ERROR_FAIL;
    }

    /* check if community string contains the blank character */
    if(strchr(comm_string_name, ' ') != NULL)
    {
        return SNMP_MGR_ERROR_FAIL;
    }

   /* Check if the community already exist in a user (v1/v2c) entry, if so return SNMP_MGR_ERROR_FAIL*/
    strcpy( usm_entry.snmpv3_user_name, comm_string_name);

    usm_entry.snmpv3_user_engineIDLen = snmpv3_get_engineID( usm_entry.snmpv3_user_engine_id, MAXSIZE_snmpEngineID);

   if (SNMP_MGR_GetSnmpV3User(&usm_entry) == SNMP_MGR_ERROR_OK)
   {
        if ((usm_entry.snmpv3_user_security_model == SNMP_MGR_SNMPV3_MODEL_V1)
           ||(usm_entry.snmpv3_user_security_model == SNMP_MGR_SNMPV3_MODEL_V2C))
        {
            return SNMP_MGR_ERROR_FAIL;
        }
    }

    strcpy(entry.snmp_community_index , comm_string_name);


    /* Check the corresonding entry already exist, if so, we need to save the
       notifyview for create later*/
    if (SNMP_MGR_GetSnmpCommunityEntry(&entry) == SNMP_MGR_ERROR_OK)
    {
        SNMP_MGR_SnmpV3GroupEntry_T group_entry;

        strcpy(group_entry.snmpv3_group_name, comm_string_name);
        group_entry.snmpv3_group_model = SNMP_MGR_SNMPV3_MODEL_V1;
        group_entry.snmpv3_group_security_level = VAL_vacmAccessSecurityLevel_noAuthNoPriv;
        /* get the savenotifyviewforv1*/
        if (SNMP_MGR_GetSnmpV3Group ( &group_entry) == SNMP_MGR_ERROR_OK)
        {
            strcpy((char *)savenotifyviewforv1, (char *)group_entry.snmpv3_group_notifyview);
        }

        group_entry.snmpv3_group_model = SNMP_MGR_SNMPV3_MODEL_V2C;
        /* get the savenotifyviewforv2*/
        if (SNMP_MGR_GetSnmpV3Group ( &group_entry) == SNMP_MGR_ERROR_OK)
        {
            strcpy((char *)savenotifyviewforv2, (char *) group_entry.snmpv3_group_notifyview);
        }
    }

  /* check if already exist, if already exist, remove the old one and go on to create the new one*/
    strcpy(c_entry.comm_string_name , comm_string_name);

    strcpy(c_entry.comm_string_name, entry.snmp_community_index);
    if (SNMP_MGR_CheckSnmpCommunity(&c_entry)== SNMP_MGR_ERROR_OK )
    {
        SNMP_MGR_DeleteCom2SecList(comm_string_name);

        SNMP_MGR_ModifySnmpCommunityStatus(comm_string_name, VAL_snmpCommunityStatus_destroy);
    }

    if (access_right == SNMP_MGR_ACCESS_RIGHT_READ_WRITE)
    {
        retval = SNMP_MGR_InsertCom2SecList(comm_string_name, comm_string_name, SNMP_MGR_ACCESS_RIGHT_READ_WRITE);

        if (retval != SNMP_MGR_ERROR_OK)
        {
            #if (SYS_CPNT_EH == TRUE)
                EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                         0,
                                         EH_TYPE_MSG_FAILED_TO_ADD,
                                        (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));
            #endif

            return retval;
        }
        else
        {
            SNMP_MGR_SnmpCommunityEntry_T comm_entry;
            memset(&comm_entry,0, sizeof(comm_entry));
            strcpy(comm_entry.snmp_community_index, comm_string_name);
            strcpy(comm_entry.snmp_community_name, comm_string_name);
            strcpy(comm_entry.snmp_community_security_name, comm_string_name);
            comm_entry.snmp_community_access_right = SNMP_MGR_ACCESS_RIGHT_READ_WRITE;
            SNMP_MGR_CreateSnmpCommunityEntry(&comm_entry);
            SNMP_MGR_ModifySnmpCommunityStatus(comm_string_name, VAL_snmpCommunityStatus_active);
            strcpy(group_entry.snmpv3_group_writeview, "defaultview");
        }
    }
    else if (access_right == SNMP_MGR_ACCESS_RIGHT_READ_ONLY)
    {
        retval = SNMP_MGR_InsertCom2SecList(comm_string_name, comm_string_name, SNMP_MGR_ACCESS_RIGHT_READ_ONLY);

        if (retval != SNMP_MGR_ERROR_OK)
        {
            #if (SYS_CPNT_EH == TRUE)
                EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                         0,
                                         EH_TYPE_MSG_FAILED_TO_ADD,
                                        (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));
            #endif

            return retval;
        }
        else
        {
            SNMP_MGR_SnmpCommunityEntry_T comm_entry;
            memset(&comm_entry,0, sizeof(comm_entry));
            strcpy(comm_entry.snmp_community_index, comm_string_name);
            strcpy(comm_entry.snmp_community_name, comm_string_name);
            strcpy(comm_entry.snmp_community_security_name, comm_string_name);
            comm_entry.snmp_community_access_right = SNMP_MGR_ACCESS_RIGHT_READ_ONLY;
            SNMP_MGR_CreateSnmpCommunityEntry(&comm_entry);
            SNMP_MGR_ModifySnmpCommunityStatus(comm_string_name, VAL_snmpCommunityStatus_active);
            strcpy(group_entry.snmpv3_group_writeview, "");
        }
    }
    else
    {
        return SNMP_MGR_ERROR_FAIL;
    }

    /*SNMP_MGR_CheckAndCreateDefaultCommunityGroup();*/
    /* Create vacmSecurityToGroupEntry and vacmAccessTable */


   /* Create vacmSecurityToGroupEntry, if not exist, create one */

    geptr = vacm_getGroupEntry(SNMP_MGR_SNMPV3_MODEL_V1 , comm_string_name);
    sprintf((char *)param1, "%s v1 %s volatile",   comm_string_name, comm_string_name);
    if (!geptr)
    {
	    vacm_parse_group("group", (char *)param1, TRUE);
    }
    geptr = vacm_getGroupEntry(SNMP_MGR_SNMPV3_MODEL_V2C , comm_string_name);
    sprintf((char *)param1, "%s v2c %s volatile",   comm_string_name, comm_string_name);
    if (!geptr)
    {
	    vacm_parse_group("group", (char *) param1, TRUE);
    }

    /* Create vacmAccessTable
     */
    strcpy(group_entry.snmpv3_group_name, comm_string_name);
    group_entry.snmpv3_group_model = SNMP_MGR_SNMPV3_MODEL_V1;
    group_entry.snmpv3_group_security_level = VAL_vacmAccessSecurityLevel_noAuthNoPriv;
    strcpy(group_entry.snmpv3_group_readview, "defaultview");
    strcpy((char *)group_entry.snmpv3_group_notifyview, (char *)savenotifyviewforv1);
    group_entry.snmpv3_group_storage_type = VAL_vacmAccessStorageType_volatile;

    /* Re-create the group v1 and v2 whose auto-destroy attribute inherits from
     * the old one. If it is not exist, the value will be TRUE because we create
     * it automatically.
     */
    if (SNMP_MGR_CheckGroupExist(&group_entry) != SNMP_MGR_ERROR_OK)
    {
        is_created_by_auto = TRUE;
    }
    else
    {
        is_created_by_auto = SNMP_MGR_IsAutoDestroyAccess(comm_string_name, SNMP_MGR_SNMPV3_MODEL_V1, VAL_vacmAccessSecurityLevel_noAuthNoPriv);
    }

    if (SNMP_MGR_CreateSnmpV3Group(&group_entry, is_created_by_auto) != SNMP_MGR_ERROR_OK)
    {
        return SNMP_MGR_ERROR_FAIL;
    }

    group_entry.snmpv3_group_model = SNMP_MGR_SNMPV3_MODEL_V2C;
    strcpy((char *)group_entry.snmpv3_group_notifyview, (char *)savenotifyviewforv2);

    if (SNMP_MGR_CheckGroupExist(&group_entry) != SNMP_MGR_ERROR_OK)
    {
        is_created_by_auto = TRUE;
    }
    else
    {
        is_created_by_auto = SNMP_MGR_IsAutoDestroyAccess(comm_string_name, SNMP_MGR_SNMPV3_MODEL_V2C, VAL_vacmAccessSecurityLevel_noAuthNoPriv);
    }

    if (SNMP_MGR_CreateSnmpV3Group(&group_entry, is_created_by_auto) != SNMP_MGR_ERROR_OK)
    {
        return SNMP_MGR_ERROR_FAIL;
    }

    SNMP_MGR_CheckDefaultCommunityView();

   /* Now want to check if need to delete a redutant vacmSecurityToGroupTable. We will
    * delete all v1/v2c model entry. and check if it exist a v3 model. If does not find a v3 model,
    * then need to continue to check and remove the usmUserEntry.
    */

    grouplist = vacm_get_groupList();

    for (gptr = grouplist; gptr !=NULL; gptr= gptr->next)
    {
        if (!strcmp(gptr->securityName + 1, comm_string_name))
        {
               if (( gptr->securityModel == SNMP_MGR_SNMPV3_MODEL_V1) ||
                   ( gptr->securityModel == SNMP_MGR_SNMPV3_MODEL_V2C))
               {
                  /* vacm_destroyGroupEntry(gptr->securityModel,  comm_string_name);*/
               }
               else if (gptr->securityModel == SNMP_MGR_SNMPV3_MODEL_V3)
               {
                   checkusmentry = FALSE;
               }
        }
    }

   /* now need to check if need to destroy usmEntry */

    if (TRUE == checkusmentry)
    {
        memset(&usm_entry, 0, sizeof(usm_entry));
        strcpy(usm_entry.snmpv3_user_name, comm_string_name);

        if (SNMP_MGR_CheckUsmUserEntry(&usm_entry) == SNMP_MGR_ERROR_OK)
        {
            SNMP_MGR_DeleteUsmUserEntry(usm_entry.snmpv3_user_name);
        }
    }

    return  SNMP_MGR_ERROR_OK;
}


/* ---------------------------------------------------------------------
 * ROUTINE NAME  - SNMP_MGR_RemoveSnmpCommunity
 * ---------------------------------------------------------------------
 * PURPOSE: This function returns true if we can successfully remove a Snmp community
 *
 * INPUT: comm_string_name  - (key) to specify a unique SNMP community string
 *
 * OUTPUT: None
 * RETURN: SNMP_MGR_ERROR_OK/SNMP_MGR_ERROR_FAIL
 * NOTES: 1. This function will remove a snmp community.
 * ---------------------------------------------------------------------
 */
UI32_T SNMP_MGR_RemoveSnmpCommunity(char *comm_string_name)
{
    UI32_T orig_priority;
    SNMP_MGR_SnmpCommunity_T entry;
    L_INET_AddrIp_T  skip_ip_address;
    BOOL_T is_shared_by_trap_v1 = TRUE;
    BOOL_T is_shared_by_trap_v2c = TRUE;

    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);

    memset(&entry, 0, sizeof(entry));
    memset(&skip_ip_address, 0, sizeof(skip_ip_address));
    strncpy(entry.comm_string_name, comm_string_name, sizeof(entry.comm_string_name)-1);
    entry.comm_string_name[sizeof(entry.comm_string_name)-1] = '\0';

    /* check if this community exist
     */
    if (SNMP_MGR_CheckSnmpCommunity(&entry) != SNMP_MGR_ERROR_OK)
    {
 	    return SNMP_MGR_ERROR_FAIL;
    }
    else if (entry.access_right == SNMP_MGR_ACCESS_RIGHT_GROUP_SPECIFIC)
    {
        return SNMP_MGR_ERROR_PARAMETER_NOT_MATCH;
    }

    /* Remove community and com2sec first. If it is necessary, we will create
     * group-specific community later.
     */
    SNMP_MGR_ModifySnmpCommunityStatus(comm_string_name, VAL_snmpCommunityStatus_destroy);


    SNMP_MGR_DeleteCom2SecList(comm_string_name);


    is_shared_by_trap_v1 = SNMP_MGR_IsCommunitySharedByTrapReceiver(comm_string_name, SNMP_MGR_SNMPV3_MODEL_V1, &skip_ip_address);

    if (is_shared_by_trap_v1 == FALSE)
    {
        if (SNMP_MGR_IsAutoDestroySecurityToGroup(SNMP_MGR_SNMPV3_MODEL_V1, comm_string_name) == TRUE)
        {
            SNMP_MGR_DeleteSecurityToGroupEntry(SNMP_MGR_SNMPV3_MODEL_V1, comm_string_name);
        }
        if (SNMP_MGR_IsAutoDestroyAccess(comm_string_name, SNMP_MGR_SNMPV3_MODEL_V1, VAL_vacmAccessSecurityLevel_noAuthNoPriv) == TRUE)
        {
            SNMP_MGR_DeleteAccess(comm_string_name, SNMP_MGR_SNMPV3_MODEL_V1, VAL_vacmAccessSecurityLevel_noAuthNoPriv);
        }
    }
    else
    {
        struct vacm_accessEntry *aptr = NULL;

        aptr = vacm_getExactAccessEntry(comm_string_name, "", SNMP_MGR_SNMPV3_MODEL_V1, VAL_vacmAccessSecurityLevel_noAuthNoPriv);
        if (NULL != aptr)
        {
            aptr->readView[0] = aptr->writeView[0] = '\0';
        }
    }

    is_shared_by_trap_v2c = SNMP_MGR_IsCommunitySharedByTrapReceiver(comm_string_name, SNMP_MGR_SNMPV3_MODEL_V2C, &skip_ip_address);

    if (is_shared_by_trap_v2c == FALSE)
    {
        if (SNMP_MGR_IsAutoDestroySecurityToGroup(SNMP_MGR_SNMPV3_MODEL_V2C, comm_string_name) == TRUE)
        {
            SNMP_MGR_DeleteSecurityToGroupEntry(SNMP_MGR_SNMPV3_MODEL_V2C, comm_string_name);
        }
        if (SNMP_MGR_IsAutoDestroyAccess(comm_string_name, SNMP_MGR_SNMPV3_MODEL_V2C, VAL_vacmAccessSecurityLevel_noAuthNoPriv) == TRUE)
        {
            SNMP_MGR_DeleteAccess(comm_string_name, SNMP_MGR_SNMPV3_MODEL_V2C, VAL_vacmAccessSecurityLevel_noAuthNoPriv);
        }
    }
    else
    {
        struct vacm_accessEntry *aptr = NULL;

        aptr = vacm_getExactAccessEntry(comm_string_name, "", SNMP_MGR_SNMPV3_MODEL_V2C, VAL_vacmAccessSecurityLevel_noAuthNoPriv);
        if (NULL != aptr)
        {
            aptr->readView[0] = aptr->writeView[0] = '\0';
        }
    }

    if (   (is_shared_by_trap_v1 == TRUE)
        || (is_shared_by_trap_v2c == TRUE)
        )
    {
        /* Remove read/write attribute from community and then the attribute
         * will be group-specific.
         */
        SNMP_MGR_SnmpCommunityEntry_T snmp_comm_entry;

        memset(&snmp_comm_entry, 0, sizeof(snmp_comm_entry));
        strcpy(snmp_comm_entry.snmp_community_index, comm_string_name);
        strcpy(snmp_comm_entry.snmp_community_name, comm_string_name);
        strcpy(snmp_comm_entry.snmp_community_security_name, comm_string_name);
        snmp_comm_entry.snmp_community_access_right = SNMP_MGR_ACCESS_RIGHT_GROUP_SPECIFIC;
        SNMP_MGR_CreateSnmpCommunityEntry(&snmp_comm_entry);
        SNMP_MGR_ModifySnmpCommunityStatus(comm_string_name, VAL_snmpCommunityStatus_active);


        SNMP_MGR_InsertCom2SecList(comm_string_name, comm_string_name, SNMP_MGR_ACCESS_RIGHT_GROUP_SPECIFIC);

    }

    return SNMP_MGR_ERROR_OK;
}

 /*---------------------------------------------------------------------------+
 * Routine Name : SNMP_MGR_Gen_Auth_Failure_Trap()                  +
 *---------------------------------------------------------------------------+
 * Purpose :      This function will generate a authentication failure trap   +
 * Input    :     None                                                                                 +
 * Output   :     None                                                                                 +
 * Return   :     SNMP_MGR_ERROR_FAIL/SNMP_MGR_ERROR_OK                                                                                +
 * Note     :     None                                                                                +
 *---------------------------------------------------------------------------*/
UI32_T  SNMP_MGR_Gen_Auth_Failure_Trap(void)
{
    TRAP_EVENT_TrapData_T       auth_trap;
    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);
    memset(&auth_trap, 0, sizeof(auth_trap));
    auth_trap.trap_type = TRAP_EVENT_AUTHENTICATION_FAILURE;
    auth_trap.community_specified = FALSE;
    SNMP_MGR_ReqSendTrap(&auth_trap) ;

    return SNMP_MGR_ERROR_OK;
}


/*---------------------------------------------------------------------------+
 * Routine Name : SNMP_MGR_Enable_Snmp_Agent                                 +
 *---------------------------------------------------------------------------+
 * Purpose :      This function will enable the snmp agent                   +
 * Input    :     None                                                       +
 * Output   :     None                                                       +
 * Return   :     SNMP_MGR_ERROR_FAIL/SNMP_MGR_ERROR_OK                      +
 * Note     :     None                                                       +
 *---------------------------------------------------------------------------*/
UI32_T  SNMP_MGR_Enable_Snmp_Agent(void)
{
    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);
    snmp_mgr_agent_status = TRUE;

    return SNMP_MGR_ERROR_OK;
}


/*---------------------------------------------------------------------------+
 * Routine Name : SNMP_MGR_Disable_Snmp_Agent               +
 *---------------------------------------------------------------------------  +
 * Purpose :      This function will disable the snmp agent              +
 * Input    :     None                                                                        +
 * Output   :     None                                                                        +
 * Return   :     SNMP_MGR_ERROR_FAIL/SNMP_MGR_ERROR_OK                                                                       +
 * Note     :     None                                                                       +
 *---------------------------------------------------------------------------*/
UI32_T  SNMP_MGR_Disable_Snmp_Agent(void)
{
    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);
    snmp_mgr_agent_status = FALSE;

    return SNMP_MGR_ERROR_OK;
}


/*---------------------------------------------------------------------------+
 * Routine Name : SNMP_MGR_Get_AgentStatus                                   +
 *---------------------------------------------------------------------------+
 * Purpose :      This function will get the agent status                    +
 * Input    :     status                                                     +
 * Output   :     status                                                     +
 * Return   :     True/False                                                 +
 * Note     :     none                                                       +
 *---------------------------------------------------------------------------*/
BOOL_T SNMP_MGR_Get_AgentStatus(BOOL_T *status)
{
    UI32_T orig_priority;
    SNMP_MGR_CHECK_OPER_MODE(FALSE);

    *status = snmp_mgr_agent_status;


    return TRUE;
}


/*-------------------------------------------------------------------------- +
 * Routine Name : SNMP_MGR_GetRunningSnmpAgentStatus                         +
 *---------------------------------------------------------------------------+
 * Purpose  :     This function will get the agent status                    +
 * Input    :     status                                                     +
 * Output   :     status                                                     +
 * RETURN   :     SYS_TYPE_GET_RUNNING_CFG_SUCCESS,                          +
 *                SYS_TYPE_GET_RUNNING_CFG_NO_CHANGE, or                     +
 *                SYS_TYPE_GET_RUNNING_CFG_FAIL                              +
 * Note     :     none                                                       +
 *---------------------------------------------------------------------------*/
UI32_T SNMP_MGR_GetRunningSnmpAgentStatus(BOOL_T *status)
{
    UI32_T orig_priority;
    SNMP_MGR_CHECK_OPER_MODE(SYS_TYPE_GET_RUNNING_CFG_FAIL);


    if (snmp_mgr_agent_status != SYS_DFLT_SNMP_AGENT_STATUS)
    {
        *status = snmp_mgr_agent_status;


        return SYS_TYPE_GET_RUNNING_CFG_SUCCESS;
    }


    return SYS_TYPE_GET_RUNNING_CFG_NO_CHANGE;
}


/* ---------------------------------------------------------------------
 * ROUTINE NAME  - SNMP_MGR_SetTrapReceiverCommunity
 * ---------------------------------------------------------------------
 * PURPOSE: This function returns SNMP_MGR_ERROR_OK if the community string name can be
 *          successfully set to the specified trap receiver .
 *          Otherwise, error code is returned (as defined in snmp_mgr.h).
 *
 * INPUT: ip_address - (key) to specify a unique trap receiver
 *        community      - the SNMP community string for this trap receiver
 * OUTPUT: None
 * RETURN: SNMP_MGR_ERROR_OK;SNMP_MGR_ERROR_NO_ENTRY_EXIST; SNMP_MGR_ERROR_NO_ENTRY_EXIST
 * NOTES: 1. This function will update an existed trap receiver if
 *           the specified comm_string_name existed already.
 * ---------------------------------------------------------------------
 */
UI32_T SNMP_MGR_SetTrapReceiverCommunity(L_INET_AddrIp_T *ip_address, UI8_T *community)
{
    SNMP_MGR_TrapDestEntry_T  entry;
    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);
    memset(&entry, 0, sizeof(entry));
    memcpy(&entry.trap_dest_address, ip_address, sizeof(entry.trap_dest_address));

    if (SNMP_MGR_GetTrapReceiver(&entry)!= SNMP_MGR_ERROR_OK)
    {
        #if (SYS_CPNT_EH == TRUE)
            EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                     0,
                                     EH_TYPE_MSG_NOT_EXIST,
                                    (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));
        #endif

        return SNMP_MGR_ERROR_NO_ENTRY_EXIST;
    }

    strcpy((char *)entry.trap_dest_community, (char *)community);
    SNMP_MGR_DeleteTrapReceiver(ip_address);

    if (SNMP_MGR_ERROR_OK != SNMP_MGR_SetTrapReceiver(&entry))
    {
        /* EH handler is do in SNMP_MGR_SetTrapReceiver*/

        return SNMP_MGR_ERROR_FAIL;
    }

    return SNMP_MGR_ERROR_OK;
}


/* ---------------------------------------------------------------------
 * ROUTINE NAME  - SNMP_MGR_SetTrapReceiverVersion
 * ---------------------------------------------------------------------
 * PURPOSE: This function returns SNMP_MGR_ERROR_OK if the trap version can be
 *          successfully set to the specified trap receiver .
 *          Otherwise, error code is returned (as defined in snmp_mgr.h).
 *
 * INPUT: ip_address - (key) to specify a unique trap receiver
 *        version      - the SNMP version of the trap receiver
 * OUTPUT: None
 * RETURN: SNMP_MGR_ERROR_OK;SNMP_MGR_ERROR_NO_ENTRY_EXIST; SNMP_MGR_ERROR_NO_ENTRY_EXIST
 * NOTES: 1. This function will update an existed trap receiver if
 *           the specified version existed already.
 * ---------------------------------------------------------------------
 */
UI32_T SNMP_MGR_SetTrapReceiverVersion(L_INET_AddrIp_T *ip_address, UI32_T version)
{
    SNMP_MGR_TrapDestEntry_T  entry;

    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);
    memset(&entry, 0, sizeof(entry));
    memcpy(&entry.trap_dest_address, ip_address, sizeof(entry.trap_dest_address));

    if (SNMP_MGR_GetTrapReceiver(&entry)!= SNMP_MGR_ERROR_OK)
    {
        #if (SYS_CPNT_EH == TRUE)
            EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                     0,
                                     EH_TYPE_MSG_NOT_EXIST,
                                    (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));
        #endif

        return SNMP_MGR_ERROR_NO_ENTRY_EXIST;
    }
    entry.trap_dest_version = version;
    SNMP_MGR_DeleteTrapReceiver(ip_address);
    if (SNMP_MGR_ERROR_OK !=SNMP_MGR_SetTrapReceiver(&entry) )
    {
        /* EH handler is do in SNMP_MGR_SetTrapReceiver*/

        return SNMP_MGR_ERROR_FAIL;
    }

    return SNMP_MGR_ERROR_OK;
}

/* ---------------------------------------------------------------------
 * ROUTINE NAME  - SNMP_MGR_SetTrapReceiverSecLevel
 * ---------------------------------------------------------------------
 * PURPOSE: This function returns SNMP_MGR_ERROR_OK if the security level can be
 *          successfully set to the specified trap receiver.
 *          Otherwise, error code is returned (as defined in snmp_mgr.h).
 *
 * INPUT: ip_address - (key) to specify a unique trap receiver
 *        version      - the SNMP version of the trap receiver
 * OUTPUT: None
 * RETURN: SNMP_MGR_ERROR_OK;SNMP_MGR_ERROR_NO_ENTRY_EXIST; SNMP_MGR_ERROR_NO_ENTRY_EXIST
 * NOTES: 1. This function will update an existed trap receiver if
 *           the specified version existed already.
 * ---------------------------------------------------------------------
 */
UI32_T SNMP_MGR_SetTrapReceiverSecLevel(L_INET_AddrIp_T *ip_address, UI32_T level)
{
    SNMP_MGR_TrapDestEntry_T  entry;

    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);
    memset(&entry, 0, sizeof(entry));
    memcpy(&entry.trap_dest_address, ip_address, sizeof(entry.trap_dest_address));

    if (SNMP_MGR_GetTrapReceiver(&entry)!= SNMP_MGR_ERROR_OK)
    {
        #if (SYS_CPNT_EH == TRUE)
            EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                     0,
                                     EH_TYPE_MSG_NOT_EXIST,
                                    (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));
        #endif

        return SNMP_MGR_ERROR_NO_ENTRY_EXIST;
    }
    entry.trap_dest_security_level = level;
    SNMP_MGR_DeleteTrapReceiver(ip_address);
    if (SNMP_MGR_ERROR_OK !=SNMP_MGR_SetTrapReceiver(&entry) )
    {
        /* EH handler is do in SNMP_MGR_SetTrapReceiver*/
        return SNMP_MGR_ERROR_FAIL;
    }

    return SNMP_MGR_ERROR_OK;
}

/* ---------------------------------------------------------------------
 * ROUTINE NAME  - SNMP_MGR_SetTrapReceiverPort
 * ---------------------------------------------------------------------
 * PURPOSE: This function returns SNMP_MGR_ERROR_OK if the trap port can be
 *          successfully set to the specified trap receiver .
 *          Otherwise, error code is returned.(as defined in snmp_mgr.h)
 *
 * INPUT: ip_address - (key) to specify a unique trap receiver
 *        udp_port      - the SNMP udp_port of the trap receiver
 * OUTPUT: None
 * RETURN: SNMP_MGR_ERROR_OK;SNMP_MGR_ERROR_NO_ENTRY_EXIST; SNMP_MGR_ERROR_NO_ENTRY_EXIST
 * NOTES: 1. This function will update an existed trap receiver if
 *           the specified version existed already.
 *        2. Default udp_port is 162 when the trap receiver is created.
 * ---------------------------------------------------------------------
 */
UI32_T SNMP_MGR_SetTrapReceiverPort(L_INET_AddrIp_T *ip_address, UI32_T udp_port)
{
    SNMP_MGR_TrapDestEntry_T  entry;

    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);
    memset(&entry, 0, sizeof(entry));
    memcpy(&entry.trap_dest_address, ip_address, sizeof(entry.trap_dest_address));

    if (SNMP_MGR_GetTrapReceiver(&entry)!= SNMP_MGR_ERROR_OK)
    {
        #if (SYS_CPNT_EH == TRUE)
            EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                     0,
                                     EH_TYPE_MSG_NOT_EXIST,
                                    (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));
        #endif

        return SNMP_MGR_ERROR_NO_ENTRY_EXIST;
    }

    entry.trap_dest_port = udp_port;
    SNMP_MGR_DeleteTrapReceiver(ip_address);

    if (SNMP_MGR_ERROR_OK!=SNMP_MGR_SetTrapReceiver(&entry))
    {
       /* EH handler is do in SNMP_MGR_SetTrapReceiver*/

        return SNMP_MGR_ERROR_FAIL;
    }

    return SNMP_MGR_ERROR_OK;
}


/* ---------------------------------------------------------------------
 * ROUTINE NAME  - SNMP_MGR_SetTrapReceiverType
 * ---------------------------------------------------------------------
 * PURPOSE: This function returns SNMP_MGR_ERROR_OK if the trap type can be
 *          successfully set to the specified trap receiver .
 *          Otherwise, error code is returned.(as defined in snmp_mgr.h)
 *
 * INPUT: ip_address - (key) to specify a unique trap receiver
 *        type      - the SNMP type of the trap receiver
 *                    VAL_snmpNotifyType_trap; VAL_snmpNotifyType_inform
 * OUTPUT: None
 * RETURN: SNMP_MGR_ERROR_OK;SNMP_MGR_ERROR_NO_ENTRY_EXIST; SNMP_MGR_ERROR_NO_ENTRY_EXIST
 * NOTES: 1. This function will update an existed trap receiver if
 *           the specified version existed already.
 *        2. Default type is trap when the trap receiver is created.
 * ---------------------------------------------------------------------
 */
UI32_T SNMP_MGR_SetTrapReceiverType(L_INET_AddrIp_T *ip_address, UI32_T type)
{
    SNMP_MGR_TrapDestEntry_T  entry;

    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);
    memset(&entry, 0, sizeof(entry));
    memcpy(&entry.trap_dest_address, ip_address, sizeof(entry.trap_dest_address));

    if (SNMP_MGR_ERROR_OK != SNMP_MGR_GetTrapReceiver(&entry))
    {
        #if (SYS_CPNT_EH == TRUE)
            EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                     0,
                                     EH_TYPE_MSG_NOT_EXIST,
                                    (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));
        #endif

        return SNMP_MGR_ERROR_NO_ENTRY_EXIST;
    }

    entry.trap_dest_type = type;
    SNMP_MGR_DeleteTrapReceiver(ip_address);

    if (SNMP_MGR_ERROR_OK != SNMP_MGR_SetTrapReceiver(&entry))
    {
        /* EH handler is do in SNMP_MGR_SetTrapReceiver*/

        return SNMP_MGR_ERROR_FAIL;
    }

    return SNMP_MGR_ERROR_OK;
}


/* ---------------------------------------------------------------------
 * ROUTINE NAME  - SNMP_MGR_GetNextTrapReceiverForV1V2
 * ---------------------------------------------------------------------
 * PURPOSE: This function returns SNMP_MGR_ERROR_OK if the next available v1v2 trap receiver
 *          can be retrieved successfully. Otherwise, error code is returned.
 *
 * INPUT: entry->trap_dest_address    - (key) to specify a unique trap receiver
 * OUTPUT: entry            - next available v1 v2 trap receiver info
 * RETURN: SNMP_MGR_ERROR_OK; 	SNMP_MGR_ERROR_FAIL;
 * NOTES:1.This function will return trap receiver from the smallest ip addr.
 *       2.To get the first entry, input the key as 0.
 * ---------------------------------------------------------------------
 */
UI32_T SNMP_MGR_GetNextTrapReceiverForV1V2(SNMP_MGR_TrapDestEntry_T *entry)
{
    /* SNMP_MGR_GetNextTrapReceiver() will return v1, v2, v3 trap receiver
     */
    while (SNMP_MGR_GetNextTrapReceiver(entry) == SNMP_MGR_ERROR_OK)
    {
        /* only return v1 or v2 trap receiver
         */
        if ((entry->trap_dest_version == SNMP_MGR_SNMPV3_MODEL_V1) ||
            (entry->trap_dest_version == SNMP_MGR_SNMPV3_MODEL_V2C))
        {
            return SNMP_MGR_ERROR_OK;
        }
    }

    return SNMP_MGR_ERROR_FAIL;
}


/* ---------------------------------------------------------------------
 * ROUTINE NAME  - SNMP_MGR_GetNextTrapReceiver
 * ---------------------------------------------------------------------
 * PURPOSE: This function returns SNMP_MGR_ERROR_OK if the next available trap receiver
 *          can be retrieved successfully. Otherwise, error code is returned.
 *
 * INPUT: entry->trap_dest_address    - (key) to specify a unique trap receiver
 * OUTPUT: entry            - next available trap receiver info
 * RETURN: SNMP_MGR_ERROR_OK; 	SNMP_MGR_ERROR_NO_ENTRY_EXIST; SNMP_MGR_ERROR_FAIL;
 * NOTES:1.This function will return trap receiver from the smallest ip addr.
 *       2.To get the first entry, input the key as 0.
 * ---------------------------------------------------------------------
 */
UI32_T SNMP_MGR_GetNextTrapReceiver(SNMP_MGR_TrapDestEntry_T *entry)
{
    SNMP_MGR_SnmpNotifyEntry_T  notify_entry;
    SNMP_MGR_SnmpTargetAddrEntry_T target_addr_entry;
    SNMP_MGR_SnmpTargetParamsEntry_T target_params_entry;
    char  buf[30];
    char tags[TARGET_MAX_TAGS][30], *cp;
    int  numtags = 0;
    int  i;
    SNMP_MGR_TrapDestEntry_T   valid_entry[SYS_ADPT_MAX_NBR_OF_TRAP_RECEIVER];
    UI32_T   valid_entry_count=0;
    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);
   /* Check notify table, check if "trap" or "inform" entry exist*/
    memset(&notify_entry, 0, sizeof(notify_entry));
    memset(&target_params_entry, 0, sizeof(target_params_entry));

  /* Step 1:  Collect the valid IP address entry into the valid_entry */

    while ( SNMP_MGR_ERROR_OK == SNMP_MGR_GetNextSnmpNotifyTable(&notify_entry) )
    {
        numtags=0;
        if (notify_entry.snmp_notify_row_status != VAL_snmpNotifyRowStatus_active)
        {
            continue;
        }
        if (strcmp(notify_entry.snmp_notify_tag,"")==0)
        {
            continue;
        }
        for (cp = notify_entry.snmp_notify_tag; cp && numtags < TARGET_MAX_TAGS;)
        {
            cp = copy_nword(cp, tags[numtags], sizeof(tags[numtags]));
            numtags++;
        }

        memset(&target_addr_entry, 0, sizeof(target_addr_entry));
        while (SNMP_MGR_ERROR_OK==SNMP_MGR_GetNextSnmpTargetAddrTable(&target_addr_entry))
        {
            /* Check Target Entry is valided?*/
            if (target_addr_entry.snmp_target_addr_tdomain_len == 0 ||
                target_addr_entry.snmp_target_addr_row_status != VAL_snmpTargetAddrRowStatus_active)
            {
                memset(target_addr_entry.taddr.snmp_target_addr_taddress, 0, sizeof(target_addr_entry.taddr.snmp_target_addr_taddress));
                target_addr_entry.snmp_target_addr_len = 0;
                continue;
            }

            /* Check Target Domain is suppored?*/
            if (netsnmp_tdomain_support
               (target_addr_entry.snmp_target_addr_tdomain, target_addr_entry.snmp_target_addr_tdomain_len, NULL, NULL) == 0)
            {
                continue;
            }

            if (0!= strcmp((char *)target_addr_entry.snmp_target_addr_tag_list,""))
            {

            /*
             * loop through tag list looking for requested tags
             */
                for (cp = (char *)target_addr_entry.snmp_target_addr_tag_list; cp;)
                {
                    cp = copy_nword(cp, buf, sizeof(buf));
                    for (i = 0; i < numtags; i++)
                    {
                        if (strcmp(buf, tags[i]) == 0)
                        {
                       /*
                        * found a valid target table entry
                        */
                            if (0 !=strcmp(target_addr_entry.snmp_target_addr_params,""))
                            {
                                strcpy(target_params_entry.snmp_target_params_name, target_addr_entry.snmp_target_addr_params);
                                if ( SNMP_MGR_ERROR_OK == SNMP_MGR_GetSnmpTargetParamsTable(& target_params_entry) )
                                {
                                    L_INET_AddrIp_T ipaddress;
                                    UI16_T port=0;
                                    memset(&ipaddress, 0, sizeof(ipaddress));

                                    if (target_params_entry.snmp_target_params_row_status != VAL_snmpTargetParamsRowStatus_active)
                                    {
                                        continue;
                                    }

                                    SNMP_MGR_GetIpandPortfromTaddress(target_addr_entry, &ipaddress, &port);
                                    memcpy(&valid_entry[valid_entry_count].trap_dest_address, &ipaddress, sizeof(valid_entry[valid_entry_count].trap_dest_address));
                                    strcpy(valid_entry[valid_entry_count].trap_dest_community, (char *)target_params_entry.snmp_target_params_security_name);
                                    valid_entry[valid_entry_count].trap_dest_status = VAL_snmpTargetAddrRowStatus_active;
                                    valid_entry[valid_entry_count].trap_dest_port = (UI32_T)port;
                                    valid_entry[valid_entry_count].trap_dest_security_level = target_params_entry.snmp_target_params_security_level;
                                    valid_entry[valid_entry_count].trap_dest_type = notify_entry.snmp_notify_type;
                                    valid_entry[valid_entry_count].trap_inform_request_timeout = target_addr_entry.snmp_target_addr_timeout;
                                    valid_entry[valid_entry_count].trap_inform_request_retry_cnt = target_addr_entry.snmp_target_addr_retry_count;
                                    strncpy(valid_entry[valid_entry_count].trap_dest_target_addr_name, target_addr_entry.snmp_target_addr_name,
                                        sizeof(valid_entry[valid_entry_count].trap_dest_target_addr_name)-1);
                                    valid_entry[valid_entry_count].trap_dest_target_addr_name[sizeof(valid_entry[valid_entry_count].trap_dest_target_addr_name)-1] = '\0';
                                    strncpy(valid_entry[valid_entry_count].trap_dest_target_params_name, target_addr_entry.snmp_target_addr_params,
                                        sizeof(valid_entry[valid_entry_count].trap_dest_target_params_name)-1);
                                    valid_entry[valid_entry_count].trap_dest_target_params_name[sizeof(valid_entry[valid_entry_count].trap_dest_target_params_name)-1] = '\0';

                                    switch(target_params_entry.snmp_target_params_mp_model)
                                    {
                                        case SNMP_VERSION_1:
                                             valid_entry[valid_entry_count].trap_dest_version = SNMP_MGR_SNMPV3_MODEL_V1;
                                        break;
                                        case SNMP_VERSION_2c:
                                             valid_entry[valid_entry_count].trap_dest_version = SNMP_MGR_SNMPV3_MODEL_V2C;
                                        break;
                                        case SNMP_VERSION_3:
                                             valid_entry[valid_entry_count].trap_dest_version = SNMP_MGR_SNMPV3_MODEL_V3;
                                        break;
                                        default:
                                            valid_entry[valid_entry_count].trap_dest_version = SNMP_MGR_SNMPV3_MODEL_V1;
                                    }
                                    valid_entry[valid_entry_count].trap_dest_type = notify_entry.snmp_notify_type;
                                    valid_entry_count++;
                                }
                                else
                                {
                                    continue;
                                }
                            } /*end of if  (0 !=strcmp(target_addr_entry.snmp_target_addr_params,"")) */
                            else
                            {
                                continue;
                            }
                        } /* end of if (strcmp(buf, tags[i]) == 0) */
                    } /*end of for (i = 0; i < numtags; i++) */
                } /* end of  for (cp = target_addr_entry.snmp_target_addr_tag_list; cp;)*/
            }/* end of  if (0!= strcmp(target_addr_entry.snmp_target_addr_tag_list,"")) */
        }/* end of while (SNMP_MGR_ERROR_OK==SNMP_MGR_GetNextSnmpTargetAddrTable(&target_addr_entry))*/
    }   /* end of while ( SNMP_MGR_ERROR_OK == SNMP_MGR_GetNextSnmpNotifyTable(&notify_entry) ) */

/* Step 2:  Sort the valid entry with IP address and elimite the repeat IP */
    qsort(valid_entry, valid_entry_count, sizeof(SNMP_MGR_TrapDestEntry_T),
        (SNMP_MGR_COMP_TRAP_ENTRY_FUNC)SNMP_MGR_CompareTrapEntryAddr);

/* Step 3: Get Next the entry from valid_entry */

   /* if no valid entry, return SNMP_MGR_ERROR_NO_ENTRY_EXIST*/
    if (valid_entry_count == 0)
    {
        #if (SYS_CPNT_EH == TRUE)
            EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                     0,
                                     EH_TYPE_MSG_NOT_EXIST,
                                    (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));
        #endif

        return SNMP_MGR_ERROR_NO_ENTRY_EXIST;
    }
    if (0 ==  entry->trap_dest_address.addrlen)
   /* Get First */
    {
        memcpy( entry, &valid_entry[0], sizeof(SNMP_MGR_TrapDestEntry_T));
    }
    else
    {
        for (i = 0; i<valid_entry_count-1; i++)
        {
            if (0 == L_INET_CompareInetAddr((L_INET_Addr_T *)&entry->trap_dest_address,
                (L_INET_Addr_T *)&valid_entry[i].trap_dest_address, 0))
            {
                memcpy( entry, &valid_entry[i+1], sizeof(SNMP_MGR_TrapDestEntry_T));

                return SNMP_MGR_ERROR_OK;
            }
        }
        #if (SYS_CPNT_EH == TRUE)
            EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                     0,
                                     EH_TYPE_MSG_NOT_EXIST,
                                    (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));
        #endif

        return SNMP_MGR_ERROR_FAIL;
    }

    return SNMP_MGR_ERROR_OK;
}

/* ----------------------------------------------------------------------------
 *  ROUTINE NAME  - SNMP_MGR_NotifyStaTplgChanged
 * -----------------------------------------------------------------------------
 * Purpose: This procedure notify that network topology is changed due to the
 *          STA enabled.
 * Parameter:
 * Return: None.
 * Note: When STA enabled, all the ports will go through STA algorithm to
 *       determine its operation state. During this period, the trap management
 *       shall wait until STA becomes stable. Otherwise, the trap message
 *       will be lost if the port is not in forwarding state.
 * -----------------------------------------------------------------------------
 */
void SNMP_MGR_NotifyStaTplgChanged (void)
{
    UI32_T orig_priority;
   /* BODY */
    //stacking
    if (debug_mode)
         printf("SNMP_MGR_NotifyStaTplgChanged..\n");

   SNMP_MGR_CHECK_OPER_MODE();

   is_spanning_tree_stable = FALSE;



} /* End of SNMP_MGR_NotifyStaTplgChanged() */



/* ----------------------------------------------------------------------------
 *  ROUTINE NAME  - SNMP_MGR_NotifyStaTplgStabled
 * -----------------------------------------------------------------------------
 * Purpose: This procedure notify that STA has been enabled, and at least one of the port enters
 *          forwarding state. The network topology shall be stabled after couple seconds.
 * Parameter:
 * Return: None.
 * Note: This notification only informs that at least one of STA port enters forwarding state.
 *       To make sure all the STA ports enters stable state, we shall wait for few more seconds
 *       before we can send trap messages.
 * -----------------------------------------------------------------------------
 */
void SNMP_MGR_NotifyStaTplgStabled (void)
{
    UI32_T orig_priority;

    SNMP_MGR_CHECK_OPER_MODE();

    if (! is_spanning_tree_stable)
    {
        is_spanning_tree_stable = TRUE;

        if (0 == time_to_send_trap_from_spanning_tree)
        {
            SYS_TIME_GetRealTimeBySec(&time_to_send_trap_from_spanning_tree);
            time_to_send_trap_from_spanning_tree += SNMP_MGR_SEND_TRAP_DELAY_TIME;
        }
    }
} /* End of SNMP_MGR_NotifyStaTplgStabled() */


/* ---------------------------------------------------------------------
 *  ROUTINE NAME  - SNMP_MGR_ReqSendTrap
 * ---------------------------------------------------------------------
 *  FUNCTION: Request trap manager for send trap.
 *
 *  INPUT    : Variable's instance and value that should be bound in
 *             trap PDU.
 *  OUTPUT   : None.
 *  RETURN   : None.
 *  NOTE     : This procedure shall not be invoked before SNMP_MGR_Init() is called.
 * ---------------------------------------------------------------------
 */
void
SNMP_MGR_ReqSendTrap(TRAP_EVENT_TrapData_T *trap_data_p)
{
    TRAP_DEBUG_MODE_PRINT("%s(): trap type %lu\n", __func__, (unsigned long)trap_data_p->trap_type );

    if (SYSFUN_GET_CSC_OPERATING_MODE() != SYS_TYPE_STACKING_MASTER_MODE)
    {
        TRAP_DEBUG_MODE_PRINT("%s(): not in master mode\n", __func__);

        return;
    }

    // SNMP_MGR_TrapLog(trap_data_p);
    if ((trap_data_p->trap_type == TRAP_EVENT_LINK_UP) || (trap_data_p->trap_type == TRAP_EVENT_LINK_DOWN))
    {
        if (snmp_mgr_snmp_enable_link_up_down_traps == TRAP_MGR_LINK_UP_DOWN_TRAP_DISABLED)
        {
            TRAP_DEBUG_MODE_PRINT("TRAP_MGR_ReqSendTrap:link up down trap disable, log only\n");
            SNMP_MGR_TrapLog(trap_data_p);
            return;
        }
    } /* end of if */

    if (trap_data_p->trap_type == TRAP_EVENT_AUTHENTICATION_FAILURE)
    {
        if (snmp_mgr_snmp_enable_authen_traps == VAL_snmpEnableAuthenTraps_disabled)
        {
            TRAP_DEBUG_MODE_PRINT("%s(): authentication trap disable, log only\n", __func__);
            SNMP_MGR_TrapLog(trap_data_p);
            return;
        }
    }

    trap_data_p->remainRetryTimes = SNMP_MGR_MAX_SEND_TRAP_RETRY_TIMES;
    SYS_TIME_GetSystemUpTimeByTick(&trap_data_p->trap_time);

    if (!shm_trap_queue)
    {
        shm_trap_queue = SNMP_MGR_GetShmTrapQueue();
    }

    if (shm_trap_queue)
    {
        if (SNMP_MGR_ShmTrapQueueWrite(shm_trap_queue, trap_data_p, SNMP_MGR_SHM_TRAP_QUEUE_OVER_WRITE) < 0)
        {
            TRAP_DEBUG_MODE_PRINT("%s(): SNMP_MGR_ShmTrapQueueWrite fail\n", __func__);
        }
        SNMP_MGR_SendEventToSnmpTask(SNMP_MGR_EVENT_TRAP_ARRIVAL);
    }
} /* End of SNMP_MGR_ReqSendTrap() */

/* ---------------------------------------------------------------------
 *  ROUTINE NAME  - SNMP_MGR_ReqSendTrapOptional
 * ---------------------------------------------------------------------
 *  FUNCTION: Request trap manager for send trap.
 *
 *  INPUT    : 1. trap_data_p: Variable's instance and value that should be bound in
 *                                                    trap PDU.
 *             2. flag    1:send trap and log; 0:log only, don't send trap
 *  OUTPUT   : None.
 *  RETURN   : None.
 *  NOTE     : This procedure shall not be invoked before SNMP_MGR_Init() is called.
 * ---------------------------------------------------------------------
 */
void
SNMP_MGR_ReqSendTrapOptional(TRAP_EVENT_TrapData_T *trap_data_p, TRAP_EVENT_SendTrapOption_E flag)
{
    TRAP_DEBUG_MODE_PRINT("%s(): trap type %lu\n", __func__, (unsigned long)trap_data_p->trap_type );

    if (SYSFUN_GET_CSC_OPERATING_MODE() != SYS_TYPE_STACKING_MASTER_MODE)
    {
        TRAP_DEBUG_MODE_PRINT("%s(): not in master mode\n", __func__);
        return;
    }

    if (flag==TRAP_EVENT_SEND_TRAP_OPTION_LOG_ONLY)
    {
        SNMP_MGR_TrapLog(trap_data_p);
        TRAP_DEBUG_MODE_PRINT("%s(): log trap only\n", __func__);
        return;
    }

    if (trap_data_p->trap_type == TRAP_EVENT_AUTHENTICATION_FAILURE)
    {
        if (snmp_mgr_snmp_enable_authen_traps == VAL_snmpEnableAuthenTraps_disabled)
        {
            TRAP_DEBUG_MODE_PRINT("%s(): authentication trap disable, log only\n", __func__);
            SNMP_MGR_TrapLog(trap_data_p);
            return;
        }
    }

    trap_data_p->remainRetryTimes = SNMP_MGR_MAX_SEND_TRAP_RETRY_TIMES;
    trap_data_p->flag             = flag;
    SYS_TIME_GetSystemUpTimeByTick(&trap_data_p->trap_time);

    if (!shm_trap_queue)
    {
        shm_trap_queue = SNMP_MGR_GetShmTrapQueue();
    }

    if (shm_trap_queue)
    {
        if (SNMP_MGR_ShmTrapQueueWrite(shm_trap_queue, trap_data_p, SNMP_MGR_SHM_TRAP_QUEUE_OVER_WRITE) < 0)
        {
            TRAP_DEBUG_MODE_PRINT("%s(): SNMP_MGR_ShmTrapQueueWrite fail\n", __func__);
        }
        SNMP_MGR_SendEventToSnmpTask(SNMP_MGR_EVENT_TRAP_ARRIVAL);
    }
}

/* ---------------------------------------------------------------------
 *  ROUTINE NAME  - SNMP_MGR_GetSnmpEnableAuthenTraps
 * ---------------------------------------------------------------------
 *  FUNCTION: This function returns true if the permission for SNMP process to generate trap
 *           is successfully retrieved.  Otherwise, return false.
 * INPUT   : None.
 * OUTPUT  : snmp_enable_authen_traps - VAL_snmpEnableAuthenTraps_enabled /
 *                                      VAL_snmpEnableAuthenTraps_disabled
 * RETURN  : TRUE / FALSE
 * NOTE    : It is strongly recommended that this object be stored in non-volatile memory so
 *           that it remains constant between re-initializations of the network management system.
 * ---------------------------------------------------------------------
 */
BOOL_T SNMP_MGR_GetSnmpEnableAuthenTraps(UI8_T *snmp_enable_authen_traps)
{
    UI32_T orig_priority;
    //stacking
    SNMP_MGR_CHECK_OPER_MODE(FALSE);

    *snmp_enable_authen_traps = snmp_mgr_snmp_enable_authen_traps;


    return TRUE;
} /* end of SNMP_MGR_GetSnmpEnableAuthenTraps() */


/* ---------------------------------------------------------------------
 *  ROUTINE NAME  - SNMP_MGR_SetSnmpEnableAuthenTraps
 * ---------------------------------------------------------------------
 * FUNCTION: This function returns true if the permission for SNMP process to generate trap
 *           can be successfully configured.  Otherwise, return false.
 * INPUT   : snmp_enable_authen_traps - VAL_snmpEnableAuthenTraps_enabled /
 *                                      VAL_snmpEnableAuthenTraps_disabled
 * OUTPUT  : None.
 * RETURN  : TRUE / FALSE
 * NOTE    : It is strongly recommended that this object be stored in non-volatile memory so
 *           that it remains constant between re-initializations of the network management system.
 * ---------------------------------------------------------------------
 */
BOOL_T SNMP_MGR_SetSnmpEnableAuthenTraps(UI8_T snmp_enable_authen_traps)
{
    UI32_T orig_priority;
    //stacking

    SNMP_MGR_CHECK_OPER_MODE(FALSE);

    snmp_mgr_snmp_enable_authen_traps = snmp_enable_authen_traps;


    return TRUE;

} /* end of SNMP_MGR_SetSnmpEnableAuthenTraps() */

/* ---------------------------------------------------------------------
 * ROUTINE NAME  - SNMP_MGR_GetRunningSnmpEnableAuthenTraps
 * ---------------------------------------------------------------------
 * PURPOSE: This function returns SYS_TYPE_GET_RUNNING_CFG_SUCCESS if the
 *          snmp authentication trap status can be retrive
 *          successfully. Otherwise, SYS_TYPE_GET_RUNNING_CFG_FAIL
 *          or SYS_TYPE_GET_RUNNING_CFG_NO_CHANGE is returned.
 * INPUT: none
 * OUTPUT: snmp_enable_authen_traps - VAL_snmpEnableAuthenTraps_enabled \
 *                                    VAL_snmpEnableAuthenTraps_disabled
 * RETURN: SYS_TYPE_GET_RUNNING_CFG_SUCCESS, SYS_TYPE_GET_RUNNING_CFG_NO_CHANGE, or
 *         SYS_TYPE_GET_RUNNING_CFG_FAIL
 * NOTES: 1. This function shall only be invoked by CLI to save the
 *           "running configuration" to local or remote files.
 *        2. Since only non-default configuration will be saved, this
 *           function shall return non-default trap receiver.
 * ---------------------------------------------------------------------
 */
UI32_T SNMP_MGR_GetRunningSnmpEnableAuthenTraps(UI8_T *snmp_enable_authen_traps)
{
    UI32_T orig_priority;

    /*fibi change for stacking, add new return val "SYS_TYPE_GET_RUNNING_CFG_FAIL"*/
    SNMP_MGR_CHECK_OPER_MODE(SYS_TYPE_GET_RUNNING_CFG_FAIL);

    *snmp_enable_authen_traps = snmp_mgr_snmp_enable_authen_traps;

    if (snmp_mgr_snmp_enable_authen_traps != SYS_DFLT_SNMP_ENABLE_AUTHEN_TRAPS)
    {

        return SYS_TYPE_GET_RUNNING_CFG_SUCCESS;
    }
    else
    {

        return SYS_TYPE_GET_RUNNING_CFG_NO_CHANGE;
    }

} /* end of SNMP_MGR_GetNextRunningSnmpEnableAuthenTraps() */

/* ---------------------------------------------------------------------
 *  ROUTINE NAME  - SNMP_MGR_SetSnmpEnableLinkUpDownTraps
 * ---------------------------------------------------------------------
 * FUNCTION: This function returns true if the permission for SNMP process to generate trap
 *           can be successfully configured.  Otherwise, return false.
 * INPUT   : link_up_down_traps - VAL_ifLinkUpDownTrapEnable_enabled /
 *                                      VAL_ifLinkUpDownTrapEnable_disabled
 * OUTPUT  : None.
 * RETURN  : TRUE / FALSE
 * NOTE    : It is strongly recommended that this object be stored in non-volatile memory so
 *           that it remains constant between re-initializations of the network management system.
 * ---------------------------------------------------------------------
 */
BOOL_T SNMP_MGR_SetSnmpEnableLinkUpDownTraps(UI8_T link_up_down_traps)
{
    UI32_T orig_priority;
    //stacking

    SNMP_MGR_CHECK_OPER_MODE(FALSE);

    snmp_mgr_snmp_enable_link_up_down_traps = link_up_down_traps;


    return TRUE;

} /* end of SNMP_MGR_SetSnmpEnableAuthenTraps() */

/* ---------------------------------------------------------------------
 * ROUTINE NAME  - SNMP_MGR_GetDefaultTrapDestEntry
 * ---------------------------------------------------------------------
 * PURPOSE: This function returns the default value of trap receiver
 *
 * INPUT: entry  -> the structure of trap receiver
 * OUTPUT: entry -> the default structure of trap receiver
 * RETURN: SNMP_MGR_ERROR_OK/SNMP_MGR_ERROR_FAIL
 * NOTES:   1. This function is particular design for snmpv2 row-created mechamism.
 * ---------------------------------------------------------------------
 */
UI32_T SNMP_MGR_GetDefaultTrapDestEntry(SNMP_MGR_TrapDestEntry_T *entry)
{
    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);

    entry->trap_dest_protocol = VAL_trapDestProtocol_ip;
    SNMP_MGR_GetDefaultIpAddress(&entry->trap_dest_address);
    entry->trap_dest_port = SYS_DFLT_TRAP_UDP_PORT;

    strcpy(entry->trap_dest_community, "public");

    entry->trap_dest_type = VAL_snmpNotifyType_trap;
    entry->trap_dest_version = SNMP_MGR_SNMPV3_MODEL_V1;
    entry->trap_dest_security_level = VAL_snmpTargetParamsSecurityLevel_noAuthNoPriv;

    strcpy(entry->trap_dest_owner, "");

    return SNMP_MGR_ERROR_OK;
}

#if (SYS_CPNT_SNMP_CONTIGUOUS_TRAP_DEST_TABLE == TRUE)
/* ---------------------------------------------------------------------
 * ROUTINE NAME  - SNMP_MGR_GetTotalTrapReceiverByIndex
 * ---------------------------------------------------------------------
 * PURPOSE: This function returns success if the total number of
 *          trap receivers in the numerical-index table
 *          can be retrieved successfully. Otherwise, failure is returned.
 *
 * INPUT:  None.
 * OUTPUT: *total_p - total number of trap receivers
 * RETURN: SNMP_MGR_ERROR_OK/SNMP_MGR_ERROR_FAIL
 * NOTES:
 * ---------------------------------------------------------------------
 */
UI32_T SNMP_MGR_GetTotalTrapReceiverByIndex(UI32_T *total_p)
{
    *total_p = snmp_mgr_trap_receiver_total;
    return SNMP_MGR_ERROR_OK;
}
#endif  /* (SYS_CPNT_SNMP_CONTIGUOUS_TRAP_DEST_TABLE == TRUE) */

/* ---------------------------------------------------------------------
 * ROUTINE NAME  - SNMP_MGR_GetTrapReceiverByIndex
 * ---------------------------------------------------------------------
 * PURPOSE: This function returns true if the specified trap receiver
 *          can be retrieved successfully.
 *          Otherwise, false is returned.
 * INPUT:   snmp_index          - 1-based SNMP user index
 * OUTPUT:  *trap_receiver_p    - trap receiver info
 * RETURN:  SNMP_MGR_ERROR_OK/SNMP_MGR_ERROR_FAIL
 *
 * NOTE:  1. Status of each trap receiver is defined as SNMP_MGR_Snmp_RowStatus_Type_T.
 *        2. Setting status to VAL_snmpTargetAddrRowStatus_destroy will delete/purge a trap receiver.
 *        3. Commuinty string name is an "ASCII Zero" string (char array ending with '\0').
 *        4. The total number of trap receivers supported by the system
 *           is defined by SYS_ADPT_MAX_NBR_OF_TRAP_RECEIVER.
 *        5. By default, there is no trap receiver configued in the system.
 *        6. For any trap event raised by any subsystem, a SNMP Trap shall be
 *           sent to all of the enabled trap receivers.
 * ---------------------------------------------------------------------
 */
UI32_T SNMP_MGR_GetTrapReceiverByIndex(UI32_T snmp_index, SNMP_MGR_TrapDestEntry_T *trap_receiver_p)
{
    UI32_T array_index = snmp_index - 1;  /* 0-based */
    UI32_T orig_priority;

    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);

    if ((array_index < 0) || (array_index > SYS_ADPT_MAX_NBR_OF_TRAP_RECEIVER-1))
    {
#if (SYS_CPNT_EH == TRUE)
            EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                     0,
                                     EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                    (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));
#endif

        return SNMP_MGR_ERROR_FAIL;
    }



    /* invalid entry
     */
    if (snmp_mgr_trap_receiver[array_index].trap_dest_status == VAL_snmpTargetAddrRowStatus_destroy)
    {


        return SNMP_MGR_ERROR_FAIL;
    }

    /* valid entry
     */
    else
    {
        memcpy(&trap_receiver_p->trap_dest_address, &snmp_mgr_trap_receiver[array_index].trap_dest_address, sizeof(trap_receiver_p->trap_dest_address));


        if (SNMP_MGR_GetTrapReceiver(trap_receiver_p) == SNMP_MGR_ERROR_OK)
        {
            /* If this API will be enhanced to filter away specific versions
             * or notification types (trap vs. inform), then this action
             * will be done here.
             */


            strcpy(trap_receiver_p->trap_dest_owner, snmp_mgr_trap_receiver[array_index].trap_dest_owner);
            trap_receiver_p->trap_dest_protocol = snmp_mgr_trap_receiver[array_index].trap_dest_protocol;


            return SNMP_MGR_ERROR_OK;
        }
        else
        {
#if (SYS_CPNT_EH == TRUE)
                EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                         0,
                                         EH_TYPE_MSG_NOT_EXIST,
                                        (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));
#endif

            return SNMP_MGR_ERROR_FAIL;
        }
    }
}

/* ---------------------------------------------------------------------
 * ROUTINE NAME  - SNMP_MGR_GetNextTrapReceiverByIndex
 * ---------------------------------------------------------------------
 * PURPOSE: This function returns true if the next available trap receiver
 *          can be retrieved successfully. Otherwise, false is returned.
 *
 * INPUT:   *snmp_index_p       - 1-based SNMP user index
 * OUTPUT:  *snmp_index_p       - next available 1-based SNMP user index
 *          *trap_receiver_p    - next available trap receiver info
 * RETURN:  SNMP_MGR_ERROR_OK/SNMP_MGR_ERROR_FAIL
 * NOTE:
 * ---------------------------------------------------------------------
 */
UI32_T SNMP_MGR_GetNextTrapReceiverByIndex(UI32_T *snmp_index_p, SNMP_MGR_TrapDestEntry_T *trap_receiver_p)
{
    UI32_T ret = SNMP_MGR_ERROR_OK;  /* assume OK; if fails, change to failure */
    BOOL_T found = FALSE;
    UI32_T i, start;

    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);

    /* validate input index
     */
    if ( (*snmp_index_p != 0)
        && ( (*snmp_index_p < 1)
            || (*snmp_index_p > SYS_ADPT_MAX_NBR_OF_TRAP_RECEIVER) ))
    {
#if (SYS_CPNT_EH == TRUE)
        EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                 0,
                                 EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));
#endif

        ret = SNMP_MGR_ERROR_FAIL;
    }

    /* continue to use the "next" index to try "Get"
     */
    if (ret == SNMP_MGR_ERROR_OK)
    {
        /* if less-than minimum, try first index
         */
        if (*snmp_index_p == 0)
        {
            start = 1;
        }

        /* if minimum or more, try next possible index
         */
        else
        {
            start = *snmp_index_p + 1;
        }

        /* continue trying next index
         */
        for (i = start; i <= SYS_ADPT_MAX_NBR_OF_TRAP_RECEIVER; i++)
        {
            if (SNMP_MGR_GetTrapReceiverByIndex(i, trap_receiver_p)
                 == SNMP_MGR_ERROR_OK)
            {
                *snmp_index_p = i;
                found = TRUE;
                break;
            }
        }
    }

    /* check the "found" status
     */
    if (ret == SNMP_MGR_ERROR_OK)
    {
        /* if not found, record
         */
        if (! found)
        {
#if (SYS_CPNT_EH == TRUE)
            EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                     0,
                                     EH_TYPE_MSG_NOT_EXIST,
                                    (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));
#endif

            ret = SNMP_MGR_ERROR_FAIL;
        }
    }

    /* return final result (single exit point)
     */
    return ret;
}

/* ---------------------------------------------------------------------
 * ROUTINE NAME  - SNMP_MGR_SetTrapReceiverCommStringNameByIndex
 * ---------------------------------------------------------------------
 * PURPOSE: This function returns true if the community string name can be
 *          successfully set to the specified trap receiver .
 *          Otherwise, false is returned.
 *
 * INPUT:   snmp_index          - 1-based SNMP user index
 *          comm_string_name    - the SNMP community string for this trap receiver
 * OUTPUT:  None
 * RETURN:  SNMP_MGR_ERROR_OK/SNMP_MGR_ERROR_FAIL
 * NOTE:  1. This function will create a new trap receiver to the system if
 *           the specified trap_dest_address does not exist, and total number
 *           of trap receiver configured is less than
 *           SYS_ADPT_MAX_NBR_OF_TRAP_RECEIVER.
 *           When a new trap receiver is created by this function, the
 *           status of this new trap receiver will be set to disabled(2)
 *           by default.
 *        2. This function will update an existed trap receiver if
 *           the specified comm_string_name existed already.
 *        3. False is returned if total number of trap receiver configured
 *           is greater than SYS_ADPT_MAX_NBR_OF_TRAP_RECEIVER
 * ---------------------------------------------------------------------
 */
UI32_T SNMP_MGR_SetTrapReceiverCommStringNameByIndex(UI32_T snmp_index, UI8_T *comm_string_name)
{
    UI32_T array_index = snmp_index - 1;  /* 0-based */
    UI32_T orig_priority;

    //stacking
    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);

    if (strlen((char *)comm_string_name) > SYS_ADPT_MAX_COMM_STR_NAME_LEN)
    {
        #if (SYS_CPNT_EH == TRUE)
            EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                     0,
                                     EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                    (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));
        #endif

        return SNMP_MGR_ERROR_FAIL;
    }
    if ((array_index < 0) || (array_index > SYS_ADPT_MAX_NBR_OF_TRAP_RECEIVER-1))
    {

        #if (SYS_CPNT_EH == TRUE)
            EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                     0,
                                     EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                    (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));
        #endif

        return SNMP_MGR_ERROR_FAIL;
    }



    /* invalid entry
     */
    if (snmp_mgr_trap_receiver[array_index].trap_dest_status == VAL_snmpTargetAddrRowStatus_destroy)
    {
        #if (SYS_CPNT_EH == TRUE)
            EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                     0,
                                     EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                    (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));
        #endif


        return SNMP_MGR_ERROR_FAIL;
    }



    /* valid entry
     */
    if (SNMP_MGR_SetTrapReceiverCommunity(
        &snmp_mgr_trap_receiver[array_index].trap_dest_address,
        comm_string_name) == SNMP_MGR_ERROR_OK)
    {
        return SNMP_MGR_ERROR_OK;
    }
    else
    {
        /* eh handler is done in SNMP_MGR_SetTrapReceiverCommunity
         */
        return SNMP_MGR_ERROR_FAIL;
    }
}

/* ---------------------------------------------------------------------
 * ROUTINE NAME  - SNMP_MGR_SetTrapDestProtocolByIndex
 * ---------------------------------------------------------------------
 * PURPOSE: This function returns true if the TrapDestProtocol can be
 *          successfully set to the specified trap receiver .
 *          Otherwise, false is returned.
 *
 * INPUT:   snmp_index          - 1-based SNMP user index
 *          protocol            - protocol
 * OUTPUT:  None
 * RETURN:  SNMP_MGR_ERROR_OK/SNMP_MGR_ERROR_FAIL
 * NOTE:
 * ---------------------------------------------------------------------
 */
UI32_T SNMP_MGR_SetTrapDestProtocolByIndex(UI32_T snmp_index, UI32_T protocol)
{
    UI32_T array_index = snmp_index - 1;  /* 0-based */

    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);

    if (protocol  != VAL_trapDestProtocol_ip)
    {
        #if (SYS_CPNT_EH == TRUE)
            EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                     0,
                                     EH_TYPE_MSG_INVALID_VALUE,
                                    (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));
        #endif

        return SNMP_MGR_ERROR_FAIL;
    }
    if ((array_index < 0) || (array_index > SYS_ADPT_MAX_NBR_OF_TRAP_RECEIVER-1))
    {
        #if (SYS_CPNT_EH == TRUE)
            EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                     0,
                                     EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                    (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));
        #endif

        return SNMP_MGR_ERROR_FAIL;
    }

    return SNMP_MGR_ERROR_OK;
}

/* ---------------------------------------------------------------------
 * ROUTINE NAME  - SNMP_MGR_SetTrapDestAddressByIndex
 * ---------------------------------------------------------------------
 * PURPOSE: This function returns true if the TrapDestProtocol can be
 *          successfully set to the specified trap receiver .
 *          Otherwise, false is returned.
 *
 * INPUT:   snmp_index          - 1-based SNMP user index
 *          addr                - address
 * OUTPUT:  None
 * RETURN:  SNMP_MGR_ERROR_OK/SNMP_MGR_ERROR_FAIL
 * NOTES:
 * ---------------------------------------------------------------------
 */
UI32_T SNMP_MGR_SetTrapDestAddressByIndex(UI32_T snmp_index, UI32_T port, L_INET_AddrIp_T *addr)
{
    UI32_T array_index = snmp_index - 1;  /* 0-based */
    UI32_T i;
    SNMP_MGR_TrapDestEntry_T org_entry;
    UI32_T orig_priority;

    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);

    if ((array_index < 0) || (array_index > SYS_ADPT_MAX_NBR_OF_TRAP_RECEIVER-1))
    {
        #if (SYS_CPNT_EH == TRUE)
            EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                     0,
                                     EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                    (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));
        #endif

        return SNMP_MGR_ERROR_FAIL;
    }



    /* invalid entry
     */
    if (snmp_mgr_trap_receiver[array_index].trap_dest_status == VAL_snmpTargetAddrRowStatus_destroy)
    {
        #if (SYS_CPNT_EH == TRUE)
            EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                     0,
                                     EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                    (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));
        #endif


        return SNMP_MGR_ERROR_FAIL;
    }

    memcpy(&org_entry.trap_dest_address, &snmp_mgr_trap_receiver[array_index].trap_dest_address, sizeof(org_entry.trap_dest_address));


    /* valid entry
     */
    if (SNMP_MGR_ERROR_OK!=SNMP_MGR_GetTrapReceiver(&org_entry))
    {
        #if (SYS_CPNT_EH == TRUE)
            EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                     0,
                                     EH_TYPE_MSG_NOT_EXIST,
                                    (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));
        #endif

        return SNMP_MGR_ERROR_FAIL;

    }



    //reject if this ip address already exist in the entry
    for (i=0; i<SYS_ADPT_MAX_NBR_OF_TRAP_RECEIVER; i++)
    {
        if ((i != array_index)&&(snmp_mgr_trap_receiver[i].trap_dest_status == VAL_snmpTargetAddrRowStatus_active))
        {
            if (0 == L_INET_CompareInetAddr((L_INET_Addr_T *)&snmp_mgr_trap_receiver[i].trap_dest_address,
                (L_INET_Addr_T *)addr, 0))
            {
                #if (SYS_CPNT_EH == TRUE)
                EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                         0,
                                         EH_TYPE_MSG_VALUE_OUT_OF_RANGE
                                         (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));
               #endif


                return SNMP_MGR_ERROR_FAIL;
            }
        }
    }



    /* delete the orignial one from Target MIB*/
    if (SNMP_MGR_DeleteTargetTrapReceiverDB(&snmp_mgr_trap_receiver[array_index].trap_dest_address) == SNMP_MGR_ERROR_OK)
    {
        /* use the new IP to create the new one*/
        memcpy(&org_entry.trap_dest_address, addr, sizeof(org_entry.trap_dest_address));
        org_entry.trap_dest_port = port;

        if (SNMP_MGR_CreateTargetTrapReceiverDB(snmp_index, &org_entry) == SNMP_MGR_ERROR_OK)
        {

            memcpy(&snmp_mgr_trap_receiver[array_index].trap_dest_address, addr, sizeof(snmp_mgr_trap_receiver[array_index].trap_dest_address));
            snmp_mgr_trap_receiver[array_index].trap_dest_port = port;


            return SNMP_MGR_ERROR_OK;
         }
        else
        {
            #if (SYS_CPNT_EH == TRUE)
                EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                         0,
                                         EH_TYPE_MSG_FAILED_TO_ADD,
                                        (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));
            #endif

            return SNMP_MGR_ERROR_FAIL;
        }
    }
    else
    {
        #if (SYS_CPNT_EH == TRUE)
            EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                     0,
                                     EH_TYPE_MSG_FAILED_TO_ADD,
                                        (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));
        #endif

        return SNMP_MGR_ERROR_FAIL;
    }
}

/* ---------------------------------------------------------------------
 * ROUTINE NAME  - SNMP_MGR_SetTrapReceiverVersionByIndex
 * ---------------------------------------------------------------------
 * PURPOSE: This function returns true if the community string name can be
 *          successfully set to the specified trap receiver .
 *          Otherwise, false is returned.
 *
 * INPUT:   snmp_index          - 1-based SNMP user index
 *          version             - the SNMP version for this trap receiver
 * OUTPUT:  None
 * RETURN:  SNMP_MGR_ERROR_OK/SNMP_MGR_ERROR_FAIL
 * NOTE:  1. This function will create a new trap receiver to the system if
 *           the specified trap_dest_address does not exist, and total number
 *           of trap receiver configured is less than
 *           SYS_ADPT_MAX_NBR_OF_TRAP_RECEIVER.
 *           When a new trap receiver is created by this function, the
 *           status of this new trap receiver will be set to disabled(2)
 *           by default.
 *        2. This function will update an existed trap receiver if
 *           the specified comm_string_name existed already.
 *        3. False is returned if total number of trap receiver configured
 *           is greater than SYS_ADPT_MAX_NBR_OF_TRAP_RECEIVER
 * ---------------------------------------------------------------------
 */
UI32_T SNMP_MGR_SetTrapReceiverVersionByIndex(UI32_T snmp_index, UI32_T version)
{
    UI32_T array_index = snmp_index - 1;  /* 0-based */
    UI32_T orig_priority;

    //stacking
    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);

    if ((version < SNMP_MGR_SNMPV3_MODEL_V1)
        || (version > SNMP_MGR_SNMPV3_MODEL_V3))
    {
        #if (SYS_CPNT_EH == TRUE)
            EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                     0,
                                     EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                    (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));
        #endif

        return SNMP_MGR_ERROR_FAIL;
    }
    if ((array_index < 0) || (array_index > SYS_ADPT_MAX_NBR_OF_TRAP_RECEIVER-1))
    {

        #if (SYS_CPNT_EH == TRUE)
            EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                     0,
                                     EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                    (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));
        #endif

        return SNMP_MGR_ERROR_FAIL;
    }



    /* invalid entry
     */
    if (snmp_mgr_trap_receiver[array_index].trap_dest_status == VAL_snmpTargetAddrRowStatus_destroy)
    {
        #if (SYS_CPNT_EH == TRUE)
            EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                     0,
                                     EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                    (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));
        #endif


        return SNMP_MGR_ERROR_FAIL;
    }



    /* valid entry
     */
    if (SNMP_MGR_SetTrapReceiverVersion(
        &snmp_mgr_trap_receiver[array_index].trap_dest_address,
        version) == SNMP_MGR_ERROR_OK)
    {
        return SNMP_MGR_ERROR_OK;
    }
    else
    {
        /* eh handler is done in SNMP_MGR_SetTrapReceiverVersion
         */
        return SNMP_MGR_ERROR_FAIL;
    }
}

/* ---------------------------------------------------------------------
 * ROUTINE NAME  - SNMP_MGR_SetTrapReceiverSecLevelByIndex
 * ---------------------------------------------------------------------
 * PURPOSE: This function returns true if the security level can be
 *          successfully set to the specified trap receiver.
 *          Otherwise, false is returned.
 *
 * INPUT:   snmp_index          - 1-based SNMP user index
 *          level               - the SNMP security level for this trap receiver
 * OUTPUT:  None
 * RETURN:  SNMP_MGR_ERROR_OK/SNMP_MGR_ERROR_FAIL
 * NOTES: 1. This function will create a new trap receiver to the system if
 *           the specified trap_dest_address does not exist, and total number
 *           of trap receiver configured is less than
 *           SYS_ADPT_MAX_NBR_OF_TRAP_RECEIVER.
 *           When a new trap receiver is created by this function, the
 *           status of this new trap receiver will be set to disabled(2)
 *           by default.
 *        2. This function will update an existed trap receiver if
 *           the specified comm_string_name existed already.
 *        3. False is returned if total number of trap receiver configured
 *           is greater than SYS_ADPT_MAX_NBR_OF_TRAP_RECEIVER
 * ---------------------------------------------------------------------
 */
UI32_T SNMP_MGR_SetTrapReceiverSecLevelByIndex(UI32_T snmp_index, UI32_T level)
{
    UI32_T array_index = snmp_index - 1;  /* 0-based */
    UI32_T orig_priority;

    //stacking
    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);

    if ((level < VAL_vacmAccessSecurityLevel_noAuthNoPriv)
        || (level > VAL_vacmAccessSecurityLevel_authPriv))
    {
        #if (SYS_CPNT_EH == TRUE)
            EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                     0,
                                     EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                    (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));
        #endif

        return SNMP_MGR_ERROR_FAIL;
    }
    if ((array_index < 0) || (array_index > SYS_ADPT_MAX_NBR_OF_TRAP_RECEIVER-1))
    {

        #if (SYS_CPNT_EH == TRUE)
            EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                     0,
                                     EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                    (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));
        #endif

        return SNMP_MGR_ERROR_FAIL;
    }



    /* invalid entry
     */
    if (snmp_mgr_trap_receiver[array_index].trap_dest_status == VAL_snmpTargetAddrRowStatus_destroy)
    {
        #if (SYS_CPNT_EH == TRUE)
            EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                     0,
                                     EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                    (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));
        #endif


        return SNMP_MGR_ERROR_FAIL;
    }



    /* valid entry
     */
    if (SNMP_MGR_SetTrapReceiverSecLevel(
        &snmp_mgr_trap_receiver[array_index].trap_dest_address,
        level) == SNMP_MGR_ERROR_OK)
    {
        return SNMP_MGR_ERROR_OK;
    }
    else
    {
        /* eh handler is done in SNMP_MGR_SetTrapReceiverCommunity
         */
        return SNMP_MGR_ERROR_FAIL;
    }
}

#if (SYS_CPNT_SNMP_CONTIGUOUS_TRAP_DEST_TABLE == TRUE)
/* ---------------------------------------------------------------------
 * ROUTINE NAME  - SNMP_MGR_MoveTrapReceiverByIndex
 * ---------------------------------------------------------------------
 * PURPOSE: Move trap receivers earlier by a certain distance,
 *          for a certain quantity.  This is used to maintain the
 *          the trap receiver indexes to be contiguous, i.e. without holes.
 *
 * INPUT:   start       - starting index (1-based user index)
 *          quant       - quantity of indexes to move
 *          distance    - distance to move in the early (minus) direction
 *
 * OUTPUT:  None.
 *
 * RETURN:  None.
 *
 * NOTE:    1. This is used with SNMP, not an export function.
 *
 *          2. This is called within the critical section of its
 *             caller, and manipulates the only the OM array
 *             "snmp_mgr_trap_receiver".
 *
 *          3. For performance, this function does not verify the
 *             range of parameters.  The caller must assure that the
 *             parameters are within valid range.
 * ---------------------------------------------------------------------
 */
static void SNMP_MGR_MoveTrapReceiverByIndex(UI32_T start,
    UI32_T quant, UI32_T distance)
{
    int i;  /* 1-based user index */

    /* move entries
     */
    memmove(&snmp_mgr_trap_receiver[start - distance - 1],
        &snmp_mgr_trap_receiver[start - 1],
        sizeof(SNMP_MGR_TrapDestByIndexEntry_T) * quant);

    /* clear emptied-out entries
     */
    for (i = start - distance + quant; i < start + quant; i++)
    {
        /* PATCH: This is to prevent finding an invalid entry's address,
         * and will be removed soon
         */
        memset(&snmp_mgr_trap_receiver[i - 1], 0, sizeof(SNMP_MGR_TrapDestByIndexEntry_T));

        /* set status
         */
        snmp_mgr_trap_receiver[i - 1].trap_dest_status = VAL_snmpTargetAddrRowStatus_destroy;
    }
}
#endif

/* ---------------------------------------------------------------------
 * ROUTINE NAME  - SNMP_MGR_SetTrapReceiverStatusByIndex
 * ---------------------------------------------------------------------
 * PURPOSE: This function returns true if the status can be successfully
 *          set to the specified trap receiver.
 *          Otherwise, false is returned.
 *
 * INPUT: index of trap receiver(just a seq#) -> key
 *        status                - the status for this trap receiver
 * OUTPUT: None
 * RETURN: SNMP_MGR_ERROR_OK/SNMP_MGR_ERROR_FAIL
 * NOTES: 1. This function will create a new trap receiver to the system if
 *           the specified ip_addr does not exist, and total number
 *           of trap receiver configured is less than
 *           SYS_ADPT_MAX_NBR_OF_TRAP_RECEIVER.
 *           When a new trap receiver is created by this function, the
 *           comm_string_name of this new trap receiver will be set to
 *           "DEFAULT".
 *        2. This function will update an existed trap receiver if
 *           the specified comm_string_name existed already.
 *        3. False is returned if total number of trap receiver configured
 *           is greater than SYS_ADPT_MAX_NBR_OF_TRAP_RECEIVER
 * ---------------------------------------------------------------------
 */
UI32_T SNMP_MGR_SetTrapReceiverStatusByIndex(UI32_T snmp_index, UI32_T status)
{
    UI32_T array_index = snmp_index - 1;  /* 0-based */
    UI32_T orig_priority;

    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);

    if ((status != VAL_snmpTargetAddrRowStatus_active) &&
        (status != VAL_snmpTargetAddrRowStatus_destroy) )
    {
        #if (SYS_CPNT_EH == TRUE)
            EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                     0,
                                     EH_TYPE_MSG_INVALID_VALUE,
                                    (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));
        #endif

        return SNMP_MGR_ERROR_FAIL;
    }
    if ((array_index < 0) || (array_index > SYS_ADPT_MAX_NBR_OF_TRAP_RECEIVER-1))
    {
        #if (SYS_CPNT_EH == TRUE)
            EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                     0,
                                     EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                    (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));
        #endif

        return SNMP_MGR_ERROR_FAIL;
    }

    /* check if any invalid entry due to Target/Notificaiton MIB deletion*/
    SNMP_MGR_VerifyAndDeleteProbeConfigDB();


    /* if same value, quit;
     * QUESTION: why failure and not success?
     */
    if (snmp_mgr_trap_receiver[array_index].trap_dest_status==status)
    {


        return SNMP_MGR_ERROR_FAIL;
    }



    /* destroy
     */
    if (status == VAL_snmpTargetAddrRowStatus_destroy)
    {
        if (SNMP_MGR_DeleteTargetTrapReceiverDB(&snmp_mgr_trap_receiver[array_index].trap_dest_address)==SNMP_MGR_ERROR_OK)
        {

            snmp_mgr_trap_receiver[array_index].trap_dest_status = VAL_snmpTargetAddrRowStatus_destroy;

#if (SYS_CPNT_SNMP_CONTIGUOUS_TRAP_DEST_TABLE == TRUE)
            /* if the deleted one is not the highest-index one, pack
             */
            if (snmp_index < snmp_mgr_trap_receiver_total)
            {
                /* move all subsequent entries early one position
                 */
                SNMP_MGR_MoveTrapReceiverByIndex(snmp_index + 1,
                    snmp_mgr_trap_receiver_total - snmp_index, 1);
            }

            snmp_mgr_trap_receiver_total--;
#endif



            return SNMP_MGR_ERROR_OK;
        }
        else
        {
            #if (SYS_CPNT_EH == TRUE)
                EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                         0,
                                         EH_TYPE_MSG_FAILED_TO_DELETE,
                                        (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));
            #endif

            return SNMP_MGR_ERROR_FAIL;
        }
    }

    /* active: set default value for this entry
     * QUESTION: in what operation does "active" represent "creation"?
     */
    else if (status == VAL_snmpTargetAddrRowStatus_active)
    {
        SNMP_MGR_TrapDestEntry_T entry;

        memset(&entry,0, sizeof(entry));
        SNMP_MGR_GetDefaultIpAddress(&entry.trap_dest_address);
        entry.trap_dest_port = SYS_DFLT_TRAP_UDP_PORT;
        entry.trap_dest_type = VAL_snmpNotifyType_trap;
        strcpy(entry.trap_dest_community, "public");
        entry.trap_dest_version = SNMP_MGR_SNMPV3_MODEL_V1;
        entry.trap_dest_protocol = VAL_trapDestProtocol_ip;

        /* create the new one*/
        if (SNMP_MGR_CreateTargetTrapReceiverDB(snmp_index, &entry) == SNMP_MGR_ERROR_OK)
        {


#if (SYS_CPNT_SNMP_CONTIGUOUS_TRAP_DEST_TABLE == TRUE)
            /* For contiguousness, ignore user index and force next contiguous index:
             * new "0-based array index" = total quantity before adding
             */
            array_index = snmp_mgr_trap_receiver_total;
#endif

            memcpy(&snmp_mgr_trap_receiver[array_index].trap_dest_address, &entry.trap_dest_address, sizeof(entry.trap_dest_address));
            strcpy(snmp_mgr_trap_receiver[array_index].trap_dest_owner, "public");
            snmp_mgr_trap_receiver[array_index].trap_dest_protocol=VAL_trapDestProtocol_ip;
            snmp_mgr_trap_receiver[array_index].trap_dest_status = VAL_snmpTargetAddrRowStatus_active;

#if (SYS_CPNT_SNMP_CONTIGUOUS_TRAP_DEST_TABLE == TRUE)
            /* increment total
             */
            snmp_mgr_trap_receiver_total++;
#endif



            return SNMP_MGR_ERROR_OK;
        }
        else
        {
            #if (SYS_CPNT_EH == TRUE)
                EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                         0,
                                         EH_TYPE_MSG_FAILED_TO_ADD,
                                        (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));
            #endif

            return SNMP_MGR_ERROR_FAIL;
        }
    }

    #if (SYS_CPNT_EH == TRUE)
        EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                 0,
                                 EH_TYPE_MSG_INVALID_VALUE,
                                (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));
    #endif

    return SNMP_MGR_ERROR_FAIL;
}

/* ---------------------------------------------------------------------
 * ROUTINE NAME  - SNMP_MGR_SetTrapDestOwnerByIndex
 * ---------------------------------------------------------------------
 * PURPOSE: This function returns true if the trapDestOwner can be successfully
 *          set to the specified trap receiver.
 *          Otherwise, false is returned.
 *
 * INPUT: trap_receiver_ip_addr - (key) to specify a unique trap receiver
 *        version                - the version for this trap receiver
 * OUTPUT: None
 * RETURN: SNMP_MGR_ERROR_OK/SNMP_MGR_ERROR_FAIL
 * NOTES: None
 * ---------------------------------------------------------------------
 */
UI32_T SNMP_MGR_SetTrapDestOwnerByIndex(UI32_T snmp_index, UI8_T *owner)
{
    UI32_T array_index = snmp_index - 1;  /* 0-based */

    UI32_T orig_priority;

    //stacking
    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);

    if ((strlen((char *)owner) < MINSIZE_trapDestOwner) || (strlen((char *)owner) > MAXSIZE_trapDestOwner))
    {
        #if (SYS_CPNT_EH == TRUE)
            EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                     0,
                                     EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                    (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));
        #endif

        return SNMP_MGR_ERROR_FAIL;
    }
    if ((array_index < 0) || (array_index > SYS_ADPT_MAX_NBR_OF_TRAP_RECEIVER-1))
    {
        #if (SYS_CPNT_EH == TRUE)
            EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                     0,
                                     EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                    (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));
        #endif

        return SNMP_MGR_ERROR_FAIL;
    }



    /* invalid entry
     */
    if (snmp_mgr_trap_receiver[array_index].trap_dest_status == VAL_snmpTargetAddrRowStatus_destroy )
    {
         #if (SYS_CPNT_EH == TRUE)
            EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                     0,
                                     EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                    (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));
        #endif


        return SNMP_MGR_ERROR_FAIL;
    }

    /* valid entry
     */
    strcpy(snmp_mgr_trap_receiver[array_index].trap_dest_owner, (char *)owner);


    return SNMP_MGR_ERROR_OK;
}

 /* ---------------------------------------------------------------------
 * ROUTINE NAME  - SNMP_MGR_SetTrapDestEntryByIndex
 * ---------------------------------------------------------------------
 * PURPOSE: This function returns true if the trap receiver can be created successfully
 *          Otherwise, false is returned.
 *
 * INPUT: index of trap receiver(just a seq#) -> key
 *        entry --> the structure of trapDestEntry
 * OUTPUT: None
 * RETURN: SNMP_MGR_ERROR_OK/SNMP_MGR_ERROR_FAIL
 * NOTES: 1. This function will create a new trap receiver to the system if
 *           the specified ip_addr does not exist, and total number
 *           of trap receiver configured is less than
 *           SYS_ADPT_MAX_NBR_OF_TRAP_RECEIVER.
 *           When a new trap receiver is created by this function, the
 *           comm_string_name of this new trap receiver will be set to
 *           "DEFAULT".
 *        2. This function will update an existed trap receiver if
 *           the specified comm_string_name existed already.
 *        3. False is returned if total number of trap receiver configured
 *           is greater than SYS_ADPT_MAX_NBR_OF_TRAP_RECEIVER
 *        4. This function is "Set by Record", which is particular design
 *           for snmpv2 row-created mechamism.
 * ---------------------------------------------------------------------
 */
UI32_T SNMP_MGR_SetTrapDestEntryByIndex(UI32_T snmp_index, SNMP_MGR_TrapDestEntry_T *entry)
{
    UI32_T array_index = snmp_index - 1;  /* 0-based */
    UI32_T i;
    SNMP_MGR_TrapDestEntry_T data;
    UI32_T orig_priority;

    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);



    if (entry == NULL)
    {


        return SNMP_MGR_ERROR_FAIL;
    }

    if ((array_index < 0) || (array_index > SYS_ADPT_MAX_NBR_OF_TRAP_RECEIVER - 1))
    {


        return SNMP_MGR_ERROR_FAIL;
    }

    /* check whether address already exists
     */
    for (i = 0; i < SYS_ADPT_MAX_NBR_OF_TRAP_RECEIVER; i++)
    {
        if ((i != array_index)
            && (snmp_mgr_trap_receiver[i].trap_dest_status == VAL_snmpTargetAddrRowStatus_active))
        {
            if (0 == L_INET_CompareInetAddr((L_INET_Addr_T *)&snmp_mgr_trap_receiver[i].trap_dest_address,
                (L_INET_Addr_T *)&entry->trap_dest_address, 0))
            {


                return SNMP_MGR_ERROR_FAIL;
            }
        }
    }


    SNMP_MGR_VerifyAndDeleteProbeConfigDB();


    /* if already active, cannot set entry
     */
    if (snmp_mgr_trap_receiver[array_index].trap_dest_status == VAL_snmpTargetAddrRowStatus_active)
    {


        return SNMP_MGR_ERROR_FAIL;
    }

    memset(&data, 0, sizeof(SNMP_MGR_TrapDestEntry_T));
    strcpy(data.trap_dest_community, entry->trap_dest_community);
    data.trap_dest_protocol = entry->trap_dest_protocol;
    data.trap_dest_address = entry->trap_dest_address;
    data.trap_dest_port = entry->trap_dest_port;
    strcpy(data.trap_dest_owner, entry->trap_dest_owner);
    data.trap_dest_type = entry->trap_dest_type;
    data.trap_dest_version = entry->trap_dest_version;
    data.trap_dest_security_level = entry->trap_dest_security_level;



    /* create entry
     */
    if (SNMP_MGR_CreateTargetTrapReceiverDB(snmp_index, &data) != SNMP_MGR_ERROR_OK)
    {
        return SNMP_MGR_ERROR_FAIL;
    }



#if (SYS_CPNT_SNMP_CONTIGUOUS_TRAP_DEST_TABLE == TRUE)
    /* For contiguousness, ignore user index and force next contiguous index:
     * new "0-based array index" = total quantity before adding
     */
    array_index = snmp_mgr_trap_receiver_total;
#endif

    memcpy(&snmp_mgr_trap_receiver[array_index].trap_dest_address,
        &entry->trap_dest_address, sizeof(entry->trap_dest_address));
    strcpy(snmp_mgr_trap_receiver[array_index].trap_dest_owner, entry->trap_dest_owner);
    snmp_mgr_trap_receiver[array_index].trap_dest_protocol = entry->trap_dest_protocol;
    snmp_mgr_trap_receiver[array_index].trap_dest_status = VAL_snmpTargetAddrRowStatus_active;

#if (SYS_CPNT_SNMP_CONTIGUOUS_TRAP_DEST_TABLE == TRUE)
    /* increment total
     */
    snmp_mgr_trap_receiver_total++;
#endif



    return SNMP_MGR_ERROR_OK;
}


/*--------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_VerifyAndCreateProbeConfigDB
 *---------------------------------------------------------------------------
 * PURPOSE:  This function will check every entry in Target MIB database,
 *           and will create the probe config MIB entry to if
 *           the entry is active due to target/Notificaiton MIB
 *           creation.
 * INPUT:    none
 * OUTPUT:   none.
 * RETURN:   SNMP_MGR_ERROR_OK/SNMP_MGR_ERROR_FAIL
 *
 * NOTE:    none.
 *---------------------------------------------------------------------------
 */
UI32_T SNMP_MGR_VerifyAndCreateProbeConfigDB()
{
    SNMP_MGR_TrapDestEntry_T trapEntry;
    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);
    memset(&trapEntry, 0, sizeof(trapEntry));
    while (SNMP_MGR_GetNextTrapReceiver(&trapEntry) == SNMP_MGR_ERROR_OK)
    {
        if (SNMP_MGR_IsProbeConfigTrapReceiverDBExist(&trapEntry.trap_dest_address)!= TRUE)
        {
            SNMP_MGR_CreateProbeConfigTrapReceiverDB(&trapEntry.trap_dest_address, trapEntry.trap_dest_port);
        }
    }

    return SNMP_MGR_ERROR_OK;

}


/* ---------------------------------------------------------------------
 * ROUTINE NAME  - SNMP_MGR_GetNextRunningTrapReceiver
 * ---------------------------------------------------------------------
 * PURPOSE: This function returns SYS_TYPE_GET_RUNNING_CFG_SUCCESS if the
 *          next available non-default trap receiver can be retrieved
 *          successfully. Otherwise, SYS_TYPE_GET_RUNNING_CFG_FAIL
 *          or SYS_TYPE_GET_RUNNING_CFG_NO_CHANGE is returned.
 * INPUT: entry->trap_dest_address    - (key) to specify a unique trap receiver
 * OUTPUT: entry            - next available non-default trap receiver info
 * RETURN: SYS_TYPE_GET_RUNNING_CFG_SUCCESS, SYS_TYPE_GET_RUNNING_CFG_NO_CHANGE, or
 *         SYS_TYPE_GET_RUNNING_CFG_FAIL
 * NOTES: 1. This function shall only be invoked by CLI to save the
 *           "running configuration" to local or remote files.
 *        2. Since only non-default configuration will be saved, this
 *           function shall return non-default trap receiver.
 * ---------------------------------------------------------------------
 */
UI32_T SNMP_MGR_GetNextRunningTrapReceiver(SNMP_MGR_TrapDestEntry_T *entry)
{
    SNMP_MGR_SnmpNotifyEntry_T  *notify_entry;
    SNMP_MGR_SnmpTargetAddrEntry_T *target_addr_entry;
    SNMP_MGR_SnmpTargetParamsEntry_T *target_params_entry;
    char  buf[SNMP_MGR_SPRINT_MAX_LEN];
    char  tags[TARGET_MAX_TAGS][30], *cp;
    int   numtags = 0;
    int   i = 0;
    SNMP_MGR_TrapDestEntry_T   *valid_entry;
    UI32_T   valid_entry_count=0;
    UI8_T zero_snmp_target_addr_taddress[SNMP_MGR_TADDR_IPV6LINKLOCAL_LEN];

    SNMP_MGR_CHECK_OPER_MODE(SYS_TYPE_GET_RUNNING_CFG_FAIL);

    notify_entry = (SNMP_MGR_SnmpNotifyEntry_T*) L_MM_Malloc (sizeof(SNMP_MGR_SnmpNotifyEntry_T),
                                                              L_MM_USER_ID2(SYS_MODULE_SNMP,
                                                              SNMP_TYPE_TRACE_ID_SNMP_MGR_GETNEXTRUNNINGTRAPRECEIVER_1));
    if (notify_entry == NULL)
    {
       /* cannot allocate memory*/

       return SYS_TYPE_GET_RUNNING_CFG_FAIL;
    }
    target_addr_entry = (SNMP_MGR_SnmpTargetAddrEntry_T*) L_MM_Malloc(sizeof(SNMP_MGR_SnmpTargetAddrEntry_T),
                                                                       L_MM_USER_ID2(SYS_MODULE_SNMP,
                                                                       SNMP_TYPE_TRACE_ID_SNMP_MGR_GETNEXTRUNNINGTRAPRECEIVER_2));
    if (target_addr_entry == NULL)
    {
       /* cannot allocate memory*/
       L_MM_Free(notify_entry);

       return SYS_TYPE_GET_RUNNING_CFG_FAIL;
    }
    target_params_entry = (SNMP_MGR_SnmpTargetParamsEntry_T*) L_MM_Malloc (sizeof(SNMP_MGR_SnmpTargetParamsEntry_T),
                                                                            L_MM_USER_ID2(SYS_MODULE_SNMP,
                                                                            SNMP_TYPE_TRACE_ID_SNMP_MGR_GETNEXTRUNNINGTRAPRECEIVER_3));
    if (target_params_entry == NULL)
    {
       /* cannot allocate memory*/
       L_MM_Free(notify_entry);
       L_MM_Free(target_addr_entry);

       return SYS_TYPE_GET_RUNNING_CFG_FAIL;
    }
    valid_entry = (SNMP_MGR_TrapDestEntry_T*) L_MM_Malloc (sizeof(SNMP_MGR_TrapDestEntry_T)* SYS_ADPT_MAX_NBR_OF_TRAP_RECEIVER,
                                                            L_MM_USER_ID2(SYS_MODULE_SNMP,
                                                            SNMP_TYPE_TRACE_ID_SNMP_MGR_GETNEXTRUNNINGTRAPRECEIVER_4));

    if (valid_entry == NULL)
    {
        /* cannot allocate memory*/
        L_MM_Free(notify_entry);
        L_MM_Free(target_addr_entry);
        L_MM_Free(target_params_entry);

        return SYS_TYPE_GET_RUNNING_CFG_FAIL;
    }

    /* Check notify table, check if "trap" or "inform" entry exist*/
    memset(notify_entry, 0, sizeof(SNMP_MGR_SnmpNotifyEntry_T));
    memset(target_params_entry, 0, sizeof(SNMP_MGR_SnmpTargetParamsEntry_T));

    /* Step 1:  Collect the valid IP address entry into the valid_entry */

    while (SNMP_MGR_ERROR_OK == SNMP_MGR_GetNextSnmpNotifyTable(notify_entry) )
    {
        numtags = 0;
        if (notify_entry->snmp_notify_row_status != VAL_snmpNotifyRowStatus_active)
        {
            continue;
        }
        if (strcmp(notify_entry->snmp_notify_tag,"")==0)
        {
            continue;
        }
        for (cp = notify_entry->snmp_notify_tag; cp && numtags < TARGET_MAX_TAGS;)
        {
            cp = copy_nword(cp, tags[numtags], sizeof(tags[numtags]));
            numtags++;
        }
        memset(target_addr_entry, 0, sizeof(SNMP_MGR_SnmpTargetAddrEntry_T));
        memset(zero_snmp_target_addr_taddress,0,sizeof(zero_snmp_target_addr_taddress));
        while (SNMP_MGR_ERROR_OK==SNMP_MGR_GetNextSnmpTargetAddrTable(target_addr_entry))
        {
       /* Check Target Entry is valided?*/
            if (target_addr_entry->snmp_target_addr_tdomain_len == 0 ||
                memcmp(&target_addr_entry->taddr.snmp_target_addr_taddress,zero_snmp_target_addr_taddress, sizeof(zero_snmp_target_addr_taddress))==0||
               target_addr_entry->snmp_target_addr_row_status != VAL_snmpTargetAddrRowStatus_active)
            {
                continue;
            }

           /* Check Target Domain is suppored?*/
            if (netsnmp_tdomain_support
               (target_addr_entry->snmp_target_addr_tdomain, target_addr_entry->snmp_target_addr_tdomain_len, NULL, NULL) == 0)
            {
                continue;
            }
            if (0!= strcmp((char *)target_addr_entry->snmp_target_addr_tag_list,""))
            {
           /*
            * loop through tag list looking for requested tags
            */
                for (cp = (char *)target_addr_entry->snmp_target_addr_tag_list; cp;)
                {
                    cp = copy_nword(cp, buf, sizeof(buf));
                    for (i = 0; i < numtags; i++)
                    {
                        if (strcmp(buf, tags[i]) == 0)
                        {
                       /*
                        * found a valid target table entry
                        */
                            if (0 !=strcmp(target_addr_entry->snmp_target_addr_params,""))
                            {
                                strcpy(target_params_entry->snmp_target_params_name, target_addr_entry->snmp_target_addr_params);
                                if (SNMP_MGR_ERROR_OK == SNMP_MGR_GetSnmpTargetParamsTable( target_params_entry) )
                                {
                                    L_INET_AddrIp_T ipaddress;
                                    UI16_T port = 0;

                                    memset(&ipaddress, 0, sizeof(ipaddress));

                                    if (target_params_entry->snmp_target_params_row_status != VAL_snmpTargetParamsRowStatus_active)
                                    {
                                        continue;
                                    }

                                    SNMP_MGR_GetIpandPortfromTaddress(*target_addr_entry, &ipaddress, &port);
                                    memcpy(&valid_entry[valid_entry_count].trap_dest_address, &ipaddress, sizeof(valid_entry[valid_entry_count].trap_dest_address));
                                    strcpy(valid_entry[valid_entry_count].trap_dest_community, (char *)target_params_entry->snmp_target_params_security_name);
                                    valid_entry[valid_entry_count].trap_dest_status = VAL_snmpTargetAddrRowStatus_active;
                                    valid_entry[valid_entry_count].trap_dest_port = (UI32_T)port;
                                    valid_entry[valid_entry_count].trap_dest_security_level = target_params_entry->snmp_target_params_security_level;
                                    valid_entry[valid_entry_count].trap_dest_type = notify_entry->snmp_notify_type;
                                    valid_entry[valid_entry_count].trap_inform_request_timeout = target_addr_entry->snmp_target_addr_timeout;
                                    valid_entry[valid_entry_count].trap_inform_request_retry_cnt = target_addr_entry->snmp_target_addr_retry_count;
                                    switch(target_params_entry->snmp_target_params_mp_model)
                                    {
                                        case SNMP_VERSION_1:
                                             valid_entry[valid_entry_count].trap_dest_version = SNMP_MGR_SNMPV3_MODEL_V1;
                                        break;
                                        case SNMP_VERSION_2c:
                                             valid_entry[valid_entry_count].trap_dest_version = SNMP_MGR_SNMPV3_MODEL_V2C;
                                        break;
                                        case SNMP_VERSION_3:
                                             valid_entry[valid_entry_count].trap_dest_version = SNMP_MGR_SNMPV3_MODEL_V3;
                                        break;
                                        default:
                                            valid_entry[valid_entry_count].trap_dest_version = SNMP_MGR_SNMPV3_MODEL_V1;
                                    }
                                    valid_entry[valid_entry_count].trap_dest_type = notify_entry->snmp_notify_type;
                                    valid_entry_count++;
                                }
                                else
                                {
                                    continue;
                                }
                            } /*end of if  (0 !=strcmp(target_addr_entry.snmp_target_addr_params,"")) */
                            else
                            {
                                continue;
                            }
                        } /* end of if (strcmp(buf, tags[i]) == 0) */
                    } /*end of for (i = 0; i < numtags; i++) */
                } /* end of  for (cp = target_addr_entry.snmp_target_addr_tag_list; cp;)*/
            }  /* end of  if (0!= strcmp(target_addr_entry.snmp_target_addr_tag_list,"")) */
        } /* end of while (SNMP_MGR_ERROR_OK==SNMP_MGR_GetNextSnmpTargetAddrTable(&target_addr_entry))*/
    }   /* end of while ( SNMP_MGR_ERROR_OK == SNMP_MGR_GetNextSnmpNotifyTable(&notify_entry) ) */

   /* if no valid entry, return SNMP_MGR_ERROR_NO_ENTRY_EXIST*/

    if (valid_entry_count == 0)
    {
        #if (SYS_CPNT_EH == TRUE)
            EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                     0,
                                     EH_TYPE_MSG_NOT_EXIST,
                                    (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));
        #endif
        L_MM_Free(notify_entry);
        L_MM_Free(target_addr_entry);
        L_MM_Free(target_params_entry);
        L_MM_Free(valid_entry);

        return SYS_TYPE_GET_RUNNING_CFG_FAIL;
    }

   /*Step 2:  Sort the valid entry with IP address and elimite the repeat IP */
    qsort(valid_entry, valid_entry_count, sizeof(SNMP_MGR_TrapDestEntry_T),
        (SNMP_MGR_COMP_TRAP_ENTRY_FUNC)SNMP_MGR_CompareTrapEntryAddr);

   /* Step 3: Get Next the entry from valid_entry */


    if ( entry->trap_dest_address.addrlen == 0)
   /* Get First */
    {
        memcpy( entry, &valid_entry[0], sizeof(SNMP_MGR_TrapDestEntry_T));
    }
    else
    {
        for (i = 0; i<valid_entry_count-1; i++)
        {
            if (0 == L_INET_CompareInetAddr((L_INET_Addr_T *) &entry->trap_dest_address,
                (L_INET_Addr_T *) &valid_entry[i].trap_dest_address, 0))
            {
                memcpy( entry, &valid_entry[i+1], sizeof(SNMP_MGR_TrapDestEntry_T));
                L_MM_Free(notify_entry);
                L_MM_Free(target_addr_entry);
                L_MM_Free(target_params_entry);
                L_MM_Free(valid_entry);

                return SYS_TYPE_GET_RUNNING_CFG_SUCCESS;
            }
        }
        #if (SYS_CPNT_EH == TRUE)
            EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                     0,
                                     EH_TYPE_MSG_NOT_EXIST,
                                    (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));
        #endif
        L_MM_Free(notify_entry);
        L_MM_Free(target_addr_entry);
        L_MM_Free(target_params_entry);
        L_MM_Free(valid_entry);

        return SYS_TYPE_GET_RUNNING_CFG_FAIL;
    }
    L_MM_Free(notify_entry);
    L_MM_Free(target_addr_entry);
    L_MM_Free(target_params_entry);
    L_MM_Free(valid_entry);

    return SYS_TYPE_GET_RUNNING_CFG_SUCCESS;
}


/*----------------------------------------------------------------------
 * ROUTINE NAME  - SNMP_MGR_GetTrapReceiver
 * ---------------------------------------------------------------------
 * PURPOSE: This function returns SNMP_MGR_ERROR_OK if the trap receiver
 *          can be retrieved successfully. Otherwise, error code is returned.
 *
 * INPUT: entry->trap_dest_address    - (key) to specify a unique trap receiver
 * OUTPUT: entry            - next available trap receiver info
 * RETURN: SNMP_MGR_ERROR_OK; 	SNMP_MGR_ERROR_NO_ENTRY_EXIST; SNMP_MGR_ERROR_FAIL;
 * NOTES:1.This function will return trap receiver from the smallest ip addr.
 *
 * ---------------------------------------------------------------------
 */
UI32_T SNMP_MGR_GetTrapReceiver(SNMP_MGR_TrapDestEntry_T *entry)
{
    SNMP_MGR_SnmpNotifyEntry_T  notify_entry;
    SNMP_MGR_SnmpTargetAddrEntry_T target_addr_entry;
    SNMP_MGR_SnmpTargetParamsEntry_T target_params_entry;
    char  buf[SPRINT_MAX_LEN];
    char  tags[TARGET_MAX_TAGS][30], *cp;
    int   numtags = 0;
    int   i;
    SNMP_MGR_TrapDestEntry_T   valid_entry[SYS_ADPT_MAX_NBR_OF_TRAP_RECEIVER];
    UI32_T   valid_entry_count=0;
    UI8_T zero_snmp_target_addr_taddress[SNMP_MGR_TADDR_IPV6LINKLOCAL_LEN];

    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);
   /* Check notify table, check if "trap" or "inform" entry exist*/
    memset(&notify_entry, 0, sizeof(notify_entry));
    memset(&target_params_entry, 0, sizeof(target_params_entry));
    memset(zero_snmp_target_addr_taddress,0,sizeof(zero_snmp_target_addr_taddress));
   /* Step 1:  Collect the valid IP address entry into the valid_entry */

    while (SNMP_MGR_ERROR_OK == SNMP_MGR_GetNextSnmpNotifyTable(&notify_entry) )
    {
        numtags =0;
        if (notify_entry.snmp_notify_row_status != VAL_snmpNotifyRowStatus_active)
        {
            continue;
        }
        if (strcmp(notify_entry.snmp_notify_tag,"")==0)
        {
            continue;
        }
        for (cp = notify_entry.snmp_notify_tag; cp && numtags < TARGET_MAX_TAGS;)
        {
            cp = copy_nword(cp, tags[numtags], sizeof(tags[numtags]));
            numtags++;
        }
        memset(&target_addr_entry, 0, sizeof(target_addr_entry));
        while (SNMP_MGR_ERROR_OK==SNMP_MGR_GetNextSnmpTargetAddrTable(&target_addr_entry))
        {
       /* Check Target Entry is valided?*/
            if (target_addr_entry.snmp_target_addr_tdomain_len == 0 ||
               (memcmp(target_addr_entry.taddr.snmp_target_addr_taddress, zero_snmp_target_addr_taddress, sizeof(zero_snmp_target_addr_taddress)) ==0) ||
                target_addr_entry.snmp_target_addr_row_status != VAL_snmpTargetAddrRowStatus_active)
            {
                continue;
            }
           /* Check Target Domain is suppored?*/
            if (netsnmp_tdomain_support
               (target_addr_entry.snmp_target_addr_tdomain, target_addr_entry.snmp_target_addr_tdomain_len, NULL, NULL) == 0)
            {
                continue;
            }
            if (0!= strcmp((char *)target_addr_entry.snmp_target_addr_tag_list,""))
            {
           /*
            * loop through tag list looking for requested tags
            */
                for (cp = (char *)target_addr_entry.snmp_target_addr_tag_list; cp;)
                {
                    cp = copy_nword(cp, buf, sizeof(buf));
                    for (i = 0; i < numtags; i++)
                    {
                        if (strcmp(buf, tags[i]) == 0)
                        {
                       /*
                        * found a valid target table entry
                        */
                            if (0 !=strcmp(target_addr_entry.snmp_target_addr_params,""))
                            {
                                strcpy(target_params_entry.snmp_target_params_name, target_addr_entry.snmp_target_addr_params);
                                if (SNMP_MGR_ERROR_OK == SNMP_MGR_GetSnmpTargetParamsTable(& target_params_entry) )
                                {
                                    L_INET_AddrIp_T ipaddress;
                                    UI16_T port = 0;

                                    memset(&ipaddress, 0, sizeof(ipaddress));

                                    if ( target_params_entry.snmp_target_params_row_status != VAL_snmpTargetParamsRowStatus_active)
                                    {
                                        continue;
                                    }

                                    SNMP_MGR_GetIpandPortfromTaddress(target_addr_entry, &ipaddress, &port);
                                    memcpy(&valid_entry[valid_entry_count].trap_dest_address, &ipaddress, sizeof(valid_entry[valid_entry_count].trap_dest_address));
                                    strcpy(valid_entry[valid_entry_count].trap_dest_community, (char *)target_params_entry.snmp_target_params_security_name);
                                    valid_entry[valid_entry_count].trap_dest_status = VAL_snmpTargetAddrRowStatus_active;
                                    valid_entry[valid_entry_count].trap_dest_port = (UI32_T)port;
                                    valid_entry[valid_entry_count].trap_dest_type = notify_entry.snmp_notify_type;
                                    valid_entry[valid_entry_count].trap_inform_request_timeout = target_addr_entry.snmp_target_addr_timeout;
                                    valid_entry[valid_entry_count].trap_inform_request_retry_cnt = target_addr_entry.snmp_target_addr_retry_count;
                                    valid_entry[valid_entry_count].trap_dest_security_level = target_params_entry.snmp_target_params_security_level;
                                    strncpy(valid_entry[valid_entry_count].trap_dest_target_addr_name, target_addr_entry.snmp_target_addr_name,
                                        sizeof(valid_entry[valid_entry_count].trap_dest_target_addr_name)-1);
                                    valid_entry[valid_entry_count].trap_dest_target_addr_name[sizeof(valid_entry[valid_entry_count].trap_dest_target_addr_name)-1] = '\0';
                                    strncpy(valid_entry[valid_entry_count].trap_dest_target_params_name, target_addr_entry.snmp_target_addr_params,
                                        sizeof(valid_entry[valid_entry_count].trap_dest_target_params_name)-1);
                                    valid_entry[valid_entry_count].trap_dest_target_params_name[sizeof(valid_entry[valid_entry_count].trap_dest_target_params_name)-1] = '\0';

                                    switch(target_params_entry.snmp_target_params_mp_model)
                                    {
                                        case SNMP_VERSION_1:
                                            valid_entry[valid_entry_count].trap_dest_version = SNMP_MGR_SNMPV3_MODEL_V1;
                                        break;
                                        case SNMP_VERSION_2c:
                                            valid_entry[valid_entry_count].trap_dest_version = SNMP_MGR_SNMPV3_MODEL_V2C;
                                        break;
                                        case SNMP_VERSION_3:
                                            valid_entry[valid_entry_count].trap_dest_version = SNMP_MGR_SNMPV3_MODEL_V3;
                                        break;
                                        default:
                                            valid_entry[valid_entry_count].trap_dest_version = SNMP_MGR_SNMPV3_MODEL_V1;
                                    }
                                    valid_entry[valid_entry_count].trap_dest_type = notify_entry.snmp_notify_type;
                                    valid_entry_count++;
                                }
                                else
                                {
                                    continue;
                                }
                            } /*end of if  (0 !=strcmp(target_addr_entry.snmp_target_addr_params,"")) */
                            else
                            {
                           /*
                            * parameter entry must be specified
                            */
                                continue;
                            }
                        } /* end of if (strcmp(buf, tags[i]) == 0) */
                    } /*end of for (i = 0; i < numtags; i++) */
                } /* end of  for (cp = target_addr_entry.snmp_target_addr_tag_list; cp;)*/
            }  /* end of  if (0!= strcmp(target_addr_entry.snmp_target_addr_tag_list,"")) */
        } /* end of while (SNMP_MGR_ERROR_OK==SNMP_MGR_GetNextSnmpTargetAddrTable(&target_addr_entry))*/
    }   /* end of while ( SNMP_MGR_ERROR_OK == SNMP_MGR_GetNextSnmpNotifyTable(&notify_entry) ) */

    /* if no valid entry, return SNMP_MGR_ERROR_NO_ENTRY_EXIST*/
    if (valid_entry_count == 0)
    {
        #if (SYS_CPNT_EH == TRUE)
            EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                     0,
                                     EH_TYPE_MSG_NOT_EXIST,
                                    (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));
        #endif

        return SNMP_MGR_ERROR_NO_ENTRY_EXIST;
    }

   /* Step 2:  Sort the valid entry with IP address and elimite the repeat IP */
    qsort(valid_entry, valid_entry_count, sizeof(SNMP_MGR_TrapDestEntry_T),
        (SNMP_MGR_COMP_TRAP_ENTRY_FUNC)SNMP_MGR_CompareTrapEntryAddr);

   /* Step 3: Get the entry from valid_entry */


    for (i = 0; i<valid_entry_count; i++)
    {
        if (0 == L_INET_CompareInetAddr((L_INET_Addr_T *)&entry->trap_dest_address,
            (L_INET_Addr_T *) &valid_entry[i].trap_dest_address, 0))
        {
            memcpy( entry, &valid_entry[i], sizeof(SNMP_MGR_TrapDestEntry_T));
            return SNMP_MGR_ERROR_OK;
        }
    }
    #if (SYS_CPNT_EH == TRUE)
        EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                 0,
                                 EH_TYPE_MSG_NOT_EXIST,
                                (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));
    #endif

    return SNMP_MGR_ERROR_FAIL;
}


/* ---------------------------------------------------------------------
 * ROUTINE NAME  - SNMP_MGR_DeleteTrapReceiver
 * ---------------------------------------------------------------------
 * PURPOSE: This function returns SNMP_MGR_ERROR_OK if the trap receiver
 *          can be deleted successfully. Otherwise, error code is returned.
 *
 * INPUT:   ip_addr    - (key) to specify a unique trap receiver
 * OUTPUT:  none
 * RETURN:  SNMP_MGR_ERROR_OK;SNMP_MGR_ERROR_PARAMETER_NOT_MATCH;SNMP_MGR_ERROR_FAIL;
 * NOTE:    none
 * ---------------------------------------------------------------------
 */
UI32_T SNMP_MGR_DeleteTrapReceiver(L_INET_AddrIp_T *ip_addr)
{
    SNMP_MGR_TrapDestEntry_T entry;

    memset(&entry, 0, sizeof(SNMP_MGR_TrapDestEntry_T));
    memcpy(&entry.trap_dest_address, ip_addr, sizeof(entry.trap_dest_address));

    /* get receiver with specified IP address
     */
    if (SNMP_MGR_GetTrapReceiver(&entry) != SNMP_MGR_ERROR_OK)
    {
#if (SYS_CPNT_EH == TRUE)
            EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                     0,
                                     EH_TYPE_MSG_NOT_EXIST,
                                    (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));
#endif

        return SNMP_MGR_ERROR_FAIL;
    }

    if (entry.trap_dest_type == VAL_snmpNotifyType_trap)
    {
        SNMP_MGR_DeleteTrapReceiverWithTargetAddrName(ip_addr, (UI8_T *) "traphost");
    }
    else if(entry.trap_dest_type == VAL_snmpNotifyType_inform)
    {
        SNMP_MGR_DeleteTrapReceiverWithTargetAddrName(ip_addr, (UI8_T *) "informhost");
    }
    else
    {
        return SNMP_MGR_ERROR_PARAMETER_NOT_MATCH;
    }

    return SNMP_MGR_ERROR_OK;
}


/* ---------------------------------------------------------------------
 * ROUTINE NAME  - SNMP_MGR_DeleteTrapReceiverWithTargetAddrName
 * ---------------------------------------------------------------------
 * PURPOSE: This function returns SNMP_MGR_ERROR_OK if the trap receiver
 *          can be deleted successfully. Otherwise, error code is returned.
 *
 * INPUT:   ip_addr    - (key) to specify a unique trap receiver
 *          target_addr_name
 * OUTPUT:  none
 * RETURN:  SNMP_MGR_ERROR_OK;SNMP_MGR_ERROR_PARAMETER_NOT_MATCH;SNMP_MGR_ERROR_FAIL;
 * NOTE:    none
 * ---------------------------------------------------------------------
 */
UI32_T SNMP_MGR_DeleteTrapReceiverWithTargetAddrName(L_INET_AddrIp_T *ip_addr, UI8_T *target_name)
{
    SNMP_MGR_SnmpNotifyFilterProfileEntry_T  notify_filter_profile_entry;
    SNMP_MGR_TrapDestEntry_T trap_dest_entry;
    SNMP_MGR_SnmpTargetAddrEntry_T entry;
    BOOL_T delete_notify_entry = TRUE;
    oid subtree[32];
    static struct targetAddrTable_struct *tp;
    static struct targetAddrTable_struct *target_addr_list;
    static struct targetAddrTable_struct **target_addr_list_address;
    struct vacm_groupEntry *geptr = NULL;
    L_INET_AddrIp_T target_addr_ip;
    UI32_T  i;
    I32_T   available_entry = -1;
    UI32_T orig_priority;
    L_INET_AddrIp_T skip_addr;
    char security_name[SNMP_MGR_MAX_SECURITY_NAME_LEN + 1] = {0};

    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);

    /* if we support index-based table, we should do some extra effort to maintain the
     * database for index-based table, whose index is a number
     */

    memset(&target_addr_ip, 0, sizeof(target_addr_ip));
    memset(&skip_addr, 0, sizeof(L_INET_AddrIp_T));

    /* find trap receiver
     */
    for (i = 0; i < SYS_ADPT_MAX_NBR_OF_TRAP_RECEIVER; i++)
    {
        /* invalid entry
         */
        if (snmp_mgr_trap_receiver[i].trap_dest_status == VAL_snmpTargetAddrRowStatus_destroy)
        {
            continue;
        }

        /* valid entry
         */
        /* set the specific trap receiver status */
        if (0 == L_INET_CompareInetAddr((L_INET_Addr_T *)ip_addr,
            (L_INET_Addr_T *)&snmp_mgr_trap_receiver[i].trap_dest_address, 0))
        {
            available_entry = i;
            break;
        }
    }

    /* for-loop finished; not found
     */
    if (i == SYS_ADPT_MAX_NBR_OF_TRAP_RECEIVER)
    {
        #if (SYS_CPNT_EH == TRUE)
            EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                     0,
                                     EH_TYPE_MSG_NOT_EXIST,
                                    (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));
        #endif


        return SNMP_MGR_ERROR_FAIL;
    }

    /* found existing
     */
    else
    {
        /* found an entry, update status.  By logically, it should be deleted.
         */
        snmp_mgr_trap_receiver[available_entry].trap_dest_status = VAL_snmpTargetAddrRowStatus_destroy;

#if (SYS_CPNT_SNMP_CONTIGUOUS_TRAP_DEST_TABLE == TRUE)
        /* make contiguous
         *
         * Note: This function, being an export function, always makes the table
         * contiguous after deleting an entry, e.g. by CLI.
         * For contiguous tables, modification should not be allowed.
         * If SNMP itself, in the case of modification, calls this function to delete,
         * and then immediately adds an entry, then the new entry will be added to the end.
         */

        /* if the deleted one is not the highest-index one, pack;
         * note: available_entry + 1 = the deleted entry (1-based user index)
         */
        if (available_entry + 1 < snmp_mgr_trap_receiver_total)
        {
            /* move all subsequent entries early one position (1-based user index);
             * note: available_entry + 2 = the next later entry (1-based user index)
             */
            SNMP_MGR_MoveTrapReceiverByIndex(available_entry + 2,
                snmp_mgr_trap_receiver_total - (available_entry + 1), 1);
        }

        snmp_mgr_trap_receiver_total--;
#endif
    }

    /* initilize the entry to 0 */
    memset(&trap_dest_entry, 0, sizeof(trap_dest_entry));

    /* get the concerned entry
     */
    memcpy(&trap_dest_entry.trap_dest_address, ip_addr, sizeof(trap_dest_entry.trap_dest_address));

    if (SNMP_MGR_ERROR_OK != SNMP_MGR_GetTrapReceiver(&trap_dest_entry))
    {
        #if (SYS_CPNT_EH == TRUE)
            EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                     0,
                                     EH_TYPE_MSG_NOT_EXIST,
                                    (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));
        #endif

        return SNMP_MGR_ERROR_FAIL;
    }

    /* Step 1, delete snmpNotifyFilterProfileTable
     */
    memset(&notify_filter_profile_entry, 0, sizeof(notify_filter_profile_entry));
    memcpy(&notify_filter_profile_entry.snmp_notify_filter_profile_ip,
        &trap_dest_entry.trap_dest_address, sizeof(notify_filter_profile_entry.snmp_notify_filter_profile_ip));
    SNMP_MGR_DeleteSnmpNotifyFilterProfileTable(&notify_filter_profile_entry);

    /* Step 2: delete the snmpTargetAddrTable
     */
    SNMP_MGR_DeleteSnmpTargetAddrTable(trap_dest_entry.trap_dest_target_addr_name);

    /* Step 3: delete the snmpTargetParamsTable
     */
    SNMP_MGR_DeleteSnmpTargetParamsTable(trap_dest_entry.trap_dest_target_params_name);

    /* Step 4, delete snmpNotifyTable
     */
    memset(&entry, 0, sizeof(SNMP_MGR_SnmpTargetAddrEntry_T));

    if (trap_dest_entry.trap_dest_type == VAL_snmpNotifyType_trap)
    {
        while (SNMP_MGR_GetNextSnmpTargetAddrTable(&entry) == SNMP_MGR_ERROR_OK)
        {
            if (strcmp((char *)entry.snmp_target_addr_tag_list, "trap") == 0)
            {
                delete_notify_entry = FALSE;
                break;
            }
        }

        if (delete_notify_entry == TRUE)
        {
            SNMP_MGR_DeleteSnmpNotifyTable((UI8_T *)"trap");
        }
    }
    else if (trap_dest_entry.trap_dest_type == VAL_snmpNotifyType_inform)
    {
        while (SNMP_MGR_GetNextSnmpTargetAddrTable(&entry) == SNMP_MGR_ERROR_OK)
        {
            if (strcmp((char *)entry.snmp_target_addr_tag_list, "inform") == 0)
            {
                delete_notify_entry = FALSE;
                break;
            }
        }

        if (delete_notify_entry == TRUE)
        {
            SNMP_MGR_DeleteSnmpNotifyTable((UI8_T *)"inform");
        }
    }
    else
    {
        #if (SYS_CPNT_EH == TRUE)
            EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                     0,
                                     EH_TYPE_MSG_INVALID_PARAMETER,
                                    (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));
        #endif

        return SNMP_MGR_ERROR_PARAMETER_NOT_MATCH;
    }

    /* Step 5, delete snmpNotifyFilterTable
     */
    subtree[0] = 1;
    SNMP_MGR_DeleteSnmpNotifyFilterTable(trap_dest_entry.trap_dest_target_params_name, subtree, 1);

    /* Step 6, auto delete snmpCommunityTable/usmUserTable, vacmSecurityToGroupTable and vacmAccessTable
     * which is auto created and not shared by other hosts.
     */
    if (   (   (trap_dest_entry.trap_dest_version == SNMP_MGR_SNMPV3_MODEL_V1)
            || (trap_dest_entry.trap_dest_version == SNMP_MGR_SNMPV3_MODEL_V2C)
            || (   (trap_dest_entry.trap_dest_version == SNMP_MGR_SNMPV3_MODEL_V3)
                && (trap_dest_entry.trap_dest_type == VAL_snmpNotifyType_trap)
                && (trap_dest_entry.trap_dest_security_level == VAL_snmpTargetParamsSecurityLevel_noAuthNoPriv)
                )
            )
        && (SNMP_MGR_ERROR_OK == SNMP_MGR_LocalGetSecurityName(
            trap_dest_entry.trap_dest_version,
            trap_dest_entry.trap_dest_community,
            security_name,
            sizeof(security_name)))
        && (NULL != (geptr = vacm_getGroupEntry(trap_dest_entry.trap_dest_version, security_name)))
        )
    {
        char access_name[VACMSTRINGLEN]; /* already contains space for '\0' */

        /* Save access name first to prevent the returned pointer 'geptr' is freed
         * during the following procedures.
         */
        strncpy(access_name, geptr->groupName, sizeof(access_name) - 1);
        access_name[sizeof(access_name) - 1] = '\0';

        if (   (SNMP_MGR_SNMPV3_MODEL_V1 == trap_dest_entry.trap_dest_version)
            || (SNMP_MGR_SNMPV3_MODEL_V2C == trap_dest_entry.trap_dest_version)
            )
        {
            SNMP_MGR_SnmpCommunity_T comm_entry;

            memset(&comm_entry, 0, sizeof(comm_entry));
            strncpy(comm_entry.comm_string_name, trap_dest_entry.trap_dest_community,
                sizeof(comm_entry.comm_string_name) - 1);
            comm_entry.comm_string_name[sizeof(comm_entry.comm_string_name) - 1] = '\0';

            /* Delete auto-created community/user and security-to-group.
             * Always to delete security - to - group early than community because
             * later one needs to get security name(from security - to - group)
             * for check whether share with trap receiver or not.
             */

            if (   (SNMP_MGR_ERROR_OK == SNMP_MGR_CheckSnmpCommunity(&comm_entry))
                && (SNMP_MGR_ACCESS_RIGHT_GROUP_SPECIFIC == comm_entry.access_right)
                )
            {
                /* Delete auto-created security-to-group.
                 */
                if (   (TRUE == SNMP_MGR_IsAutoDestroySecurityToGroup(
                        trap_dest_entry.trap_dest_version, security_name))
                    && (FALSE == SNMP_MGR_LocalIsSecurityToGroupSharedByTrapReceiver(
                        trap_dest_entry.trap_dest_version,
                        security_name,
                        &trap_dest_entry.trap_dest_address))
                    )
                {
                    SNMP_MGR_DeleteSecurityToGroupEntry(trap_dest_entry.trap_dest_version, security_name);
                }

                /* Delete auto-created v1 or v2c community. The community should
                 * not shared either v1 or v2c.
                 */
                if (FALSE == SNMP_MGR_IsCommunitySharedByTrapReceiver(
                    trap_dest_entry.trap_dest_community,
                    SNMP_MGR_SNMPV3_MODEL_ANY,
                    &trap_dest_entry.trap_dest_address))
                {
                    SNMP_MGR_ModifySnmpCommunityStatus(trap_dest_entry.trap_dest_community, VAL_snmpCommunityStatus_destroy);
                    SNMP_MGR_DeleteCom2SecList(trap_dest_entry.trap_dest_community);
                }
            }
        }
        else
        {
            /* Delete auto-created security-to-group.
             */
            if (   (TRUE == SNMP_MGR_IsAutoDestroySecurityToGroup(
                    trap_dest_entry.trap_dest_version, security_name))
                && (FALSE == SNMP_MGR_LocalIsSecurityToGroupSharedByTrapReceiver(
                    trap_dest_entry.trap_dest_version,
                    security_name,
                    &trap_dest_entry.trap_dest_address))
                )
            {
                SNMP_MGR_DeleteSecurityToGroupEntry(trap_dest_entry.trap_dest_version, security_name);
            }

            /* Delete auto-created v3 user.
             */
            if (   (FALSE == SNMP_MGR_LocalIsUserSharedByTrapReceiver(
                    trap_dest_entry.trap_dest_community,
                    &trap_dest_entry.trap_dest_address))
                && (TRUE == SNMP_MGR_LocalIsAutoDestroyUserByVersion(
                    trap_dest_entry.trap_dest_version,
                    trap_dest_entry.trap_dest_community))
                )
            {
                SNMP_MGR_DeleteUsmUserEntry(trap_dest_entry.trap_dest_community);
            }
        }

        /* Delete auto-created access.
         */
        if (   (FALSE == SNMP_MGR_LocalIsAccessSharedByTrapReceiver(
                trap_dest_entry.trap_dest_version,
                access_name,
                &trap_dest_entry.trap_dest_address))
            && (TRUE == SNMP_MGR_IsAutoDestroyAccess(
                access_name,
                trap_dest_entry.trap_dest_version,
                trap_dest_entry.trap_dest_security_level))
            )
        {
            if (TRUE == SNMP_MGR_LocalIsAccessSharedByCommunity(
                trap_dest_entry.trap_dest_version,
                trap_dest_entry.trap_dest_security_level,
                access_name))
            {
                SNMP_MGR_ClearAccessNotifyView(access_name,
                    trap_dest_entry.trap_dest_version,
                    trap_dest_entry.trap_dest_security_level);
            }
            else
            {
                SNMP_MGR_DeleteAccess(access_name,
                    trap_dest_entry.trap_dest_version,
                    trap_dest_entry.trap_dest_security_level);
            }
        }
    }

    /* Step 7, to delete if any entry which was create from SNMP agent
     */


    /* get the variable store in snmpTargetAddrEntry
     */
    target_addr_list = get_addrTable();
    target_addr_list_address = get_addrTableAddress();


    if (!target_addr_list)
    {
        return SNMP_MGR_ERROR_OK;
    }

    /* find the maching entry
     */
    for (tp = target_addr_list; tp; tp = tp->next)
    {
        UI32_T zone_id_network_order;

        /* deduce address type from length
         */
        /* LIMITATION:
         * The IP address type is not stored in a
         * TDomain/TAddress pair, and must to deduced
         * from the length of the address.
         * Future standards will probably use a
         * TransportDomain/TransportAddress pair.
         */
        switch (tp->tAddressLen - sizeof(UI16_T) /*port*/)
        {
            case SYS_TYPE_IPV4_ADDR_LEN:
                target_addr_ip.type = L_INET_ADDR_TYPE_IPV4;
                target_addr_ip.addrlen = SYS_TYPE_IPV4_ADDR_LEN;
                break;

            case SYS_TYPE_IPV4Z_ADDR_LEN:
                target_addr_ip.type = L_INET_ADDR_TYPE_IPV4Z;
                target_addr_ip.addrlen = SYS_TYPE_IPV4_ADDR_LEN;  /* without zone ID */
                memcpy(&zone_id_network_order, tp->tAddress + target_addr_ip.addrlen,
                    sizeof(UI32_T));
                target_addr_ip.zoneid = L_STDLIB_Ntoh32(zone_id_network_order);
                break;

            case SYS_TYPE_IPV6_ADDR_LEN:
                target_addr_ip.type = L_INET_ADDR_TYPE_IPV6;
                target_addr_ip.addrlen = SYS_TYPE_IPV6_ADDR_LEN;
                break;

            case SYS_TYPE_IPV6Z_ADDR_LEN:
                target_addr_ip.type = L_INET_ADDR_TYPE_IPV6Z;
                target_addr_ip.addrlen = SYS_TYPE_IPV6_ADDR_LEN;  /* without zone ID */
                memcpy(&zone_id_network_order, tp->tAddress + target_addr_ip.addrlen,
                    sizeof(UI32_T));
                target_addr_ip.zoneid = L_STDLIB_Ntoh32(zone_id_network_order);
                break;

            default:  /* uncognised */
                break;
        }

        /* copy address content
         */
        memcpy(&target_addr_ip.addr, tp->tAddress, target_addr_ip.addrlen);

        /* compare
         */
        if (0 == L_INET_CompareInetAddr((L_INET_Addr_T *) &target_addr_ip,
            (L_INET_Addr_T *) ip_addr, 0))
        {
            break;
        }
    }

    /* found an entry; remove it
     */
    if (tp)
    {
        snmpTargetAddrTable_remFromList(tp, (struct targetAddrTable_struct **)target_addr_list_address);
    }

    return SNMP_MGR_ERROR_OK;
}


/* ---------------------------------------------------------------------
 * ROUTINE NAME  - SNMP_MGR_SetTrapReceiver
 * ---------------------------------------------------------------------
 * PURPOSE: This function returns SNMP_MGR_ERROR_OK if the trap receiver
 *          can be created successfully. Otherwise, error code is returned.
 *
 * INPUT: entry    - (key) to specify a unique trap receiver
 * OUTPUT: none
 * RETURN: SNMP_MGR_ERROR_OK;SNMP_MGR_ERROR_PARAMETER_NOT_MATCH;SNMP_MGR_ERROR_FAIL;
 * NOTES: 1. This function will create a new trap receiver to the system if
 *           the specified ip_addr does not exist, and total number
 *           of trap receiver configured is less than
 *           SYS_ADPT_MAX_NBR_OF_TRAP_RECEIVER.
 *           When a new trap receiver is created by this function, the
 *           comm_string_name of this new trap receiver will be set to
 *           "DEFAULT".
 *         2. error code is returned if total number of trap receiver configured
 *           is greater than SYS_ADPT_MAX_NBR_OF_TRAP_RECEIVER
 *
 * ---------------------------------------------------------------------
 */
UI32_T SNMP_MGR_SetTrapReceiver(SNMP_MGR_TrapDestEntry_T *entry)
{
    if (entry->trap_dest_type == VAL_snmpNotifyType_trap)
        return SNMP_MGR_SetTrapReceiverWithTargetAddrName(entry, (UI8_T *)"traphost");
    else if (entry->trap_dest_type == VAL_snmpNotifyType_inform)
        return SNMP_MGR_SetTrapReceiverWithTargetAddrName(entry, (UI8_T *)"informhost");
    else
        return SNMP_MGR_ERROR_PARAMETER_NOT_MATCH;
}


/* ---------------------------------------------------------------------
 * ROUTINE NAME  - SNMP_MGR_SetTrapReceiverWithTargetAddressName
 * ---------------------------------------------------------------------
 * PURPOSE: This function returns SNMP_MGR_ERROR_OK if the trap receiver
 *          can be created successfully. Otherwise, error code is returned.
 *
 * INPUT: entry    - (key) to specify a unique trap receiver
 *        target_addr_name
 * OUTPUT: none
 * RETURN: SNMP_MGR_ERROR_OK;SNMP_MGR_ERROR_PARAMETER_NOT_MATCH;SNMP_MGR_ERROR_FAIL;
 * NOTES: 1. This function will create a new trap receiver to the system if
 *           the specified ip_addr does not exist, and total number
 *           of trap receiver configured is less than
 *           SYS_ADPT_MAX_NBR_OF_TRAP_RECEIVER.
 *           When a new trap receiver is created by this function, the
 *           comm_string_name of this new trap receiver will be set to
 *           "DEFAULT".
 *         2. error code is returned if total number of trap receiver configured
 *           is greater than SYS_ADPT_MAX_NBR_OF_TRAP_RECEIVER
 *
 * ---------------------------------------------------------------------
 */
UI32_T SNMP_MGR_SetTrapReceiverWithTargetAddrName(SNMP_MGR_TrapDestEntry_T *entry, UI8_T *target_name)
{
    SNMP_MGR_SnmpNotifyEntry_T notify_entry;
    SNMP_MGR_SnmpTargetAddrEntry_T  target_addr_entry;
    SNMP_MGR_SnmpTargetParamsEntry_T target_params_entry;
    SNMP_MGR_SnmpNotifyFilterProfileEntry_T notify_filter_profile_entry;
    SNMP_MGR_SnmpNotifyFilterEntry_T notify_filter_entry;
    SNMP_MGR_TrapDestEntry_T local_entry;
    SNMP_MGR_SnmpV3GroupEntry_T group_entry;
    oid  udp_domain_oid[7] = {1,3,6,1,6,1,1};
    struct _com2SecEntry *com2SecPtr = NULL;
    struct vacm_groupEntry *geptr= NULL;
    UI32_T  i;
    I32_T   available_entry = -1;
    UI32_T orig_priority;
    char security_name[SNMP_MGR_MAX_SECURITY_NAME_LEN + 1] = {0};
    char line[SNMP_MGR_SPRINT_MAX_LEN + 1] = {0};

    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);

    if (TRUE != SNMP_MGR_IsValidTrapReceiverIp(&entry->trap_dest_address))
    {
        return SNMP_MGR_ERROR_FAIL;
    }

    if ((entry->trap_dest_version == SNMP_MGR_SNMPV3_MODEL_V1) || (entry->trap_dest_version == SNMP_MGR_SNMPV3_MODEL_V2C))
    {
        entry->trap_dest_security_level = VAL_snmpTargetParamsSecurityLevel_noAuthNoPriv;

        /* if community count already reach and the desired community is not exist, return FASLE
         */

        com2SecPtr = netsnmp_udp_getCom2SecEntry(entry->trap_dest_community);


        if ( (snmp_mgr_comm_count >= SYS_ADPT_MAX_NBR_OF_SNMP_COMMUNITY_STRING) &&
              (com2SecPtr == NULL))
        {
            return SNMP_MGR_ERROR_FAIL;
        }
    }

    /* we do not allow community to be blank, so if community input is NULL, default
     * give a community = public
     */
    if (strcmp(entry->trap_dest_community, "")==0)
    {
        strcpy(entry->trap_dest_community, "public");
    }

    /* inform request only support for V2c/V3
     */
    if ((entry->trap_dest_type == VAL_snmpNotifyType_inform) && ( entry->trap_dest_version <= SNMP_MGR_SNMPV3_MODEL_V1))
    {
        return SNMP_MGR_ERROR_FAIL;
    }

    /* 3com can not set same target addr name
     */
#if (SYS_CPNT_SNMPV3_TARGET_NAME_STYLE == SYS_CPNT_SNMPV3_TARGET_NAME_STYLE_3COM)
    memcpy(target_addr_entry.snmp_target_addr_name,target_name,sizeof(target_addr_entry.snmp_target_addr_name));
    if (SNMP_MGR_GetSnmpTargetAddrTable(&target_addr_entry)==SNMP_MGR_ERROR_OK)
    {
        return SNMP_MGR_ERROR_FAIL;
    }
#endif

    /* Check inform request retry count and inform request timeout range
     */
    if (entry->trap_dest_type == VAL_snmpNotifyType_inform)
    {
        if ( (entry->trap_inform_request_retry_cnt < 0) ||
             (entry->trap_inform_request_retry_cnt >255))
        {
            return SNMP_MGR_ERROR_FAIL;
        }

        if ( (entry->trap_inform_request_timeout < SYS_ADPT_MIN_SNMP_TARGET_ADDR_TIMEOUT) ||
             (entry->trap_inform_request_timeout > SYS_ADPT_MAX_SNMP_TARGET_ADDR_TIMEOUT))
        {
            return SNMP_MGR_ERROR_FAIL;
        }
    }

    memcpy(&local_entry, entry, sizeof(local_entry));

    /* check if already exist, if so, return FALSE
     */
    if (SNMP_MGR_GetTrapReceiver (&local_entry) == SNMP_MGR_ERROR_OK)
    {
        return SNMP_MGR_ERROR_FAIL;
        //SNMP_MGR_DeleteTargetTrapReceiverDB(local_entry.trap_dest_address);
    }

    /* check for auto create
     */
    if ((entry->trap_dest_version == SNMP_MGR_SNMPV3_MODEL_V1) ||
        (entry->trap_dest_version == SNMP_MGR_SNMPV3_MODEL_V2C) ||
        ((entry->trap_dest_version == SNMP_MGR_SNMPV3_MODEL_V3) &&
         (entry->trap_dest_type == VAL_snmpNotifyType_trap) &&
         (entry->trap_dest_security_level == VAL_snmpTargetParamsSecurityLevel_noAuthNoPriv)
        )
       )
    {
        if (SNMP_MGR_ERROR_OK != SNMP_MGR_LocalGetSecurityName(entry->trap_dest_version,
                                                               entry->trap_dest_community,
                                                               security_name,
                                                               sizeof(security_name)))
        {
            if ((entry->trap_dest_version == SNMP_MGR_SNMPV3_MODEL_V1) ||
                (entry->trap_dest_version == SNMP_MGR_SNMPV3_MODEL_V2C))
            {
                /* snmpCommunityEntry not exist, check snmpCommunityEntry table is full or not
                 */
                if (snmp_mgr_comm_count >= SYS_ADPT_MAX_NBR_OF_SNMP_COMMUNITY_STRING)
                {
                    return SNMP_MGR_ERROR_FAIL;
                }
            }
            else
            {
                /* usmUserEntry not exist, check usmUserEntry table is full or not
                 */
                if (snmp_mgr_user_count >= SNMP_MGR_MAX_NBR_OF_SNMPV3_USER)
                {
                    return SNMP_MGR_ERROR_FAIL;
                }
            }

            /* use input community name as security name
             */
            strncpy(security_name, entry->trap_dest_community, sizeof(security_name)-1);
            security_name[sizeof(security_name)-1] = '\0';
        }

        memset(&group_entry, 0, sizeof(group_entry));

        /* check securityToGroupEntry exist or not
         */
        geptr = vacm_getGroupEntry(entry->trap_dest_version, security_name);

        if (NULL != geptr)
        {
            strncpy(group_entry.snmpv3_group_name, geptr->groupName,
                sizeof(group_entry.snmpv3_group_name) - 1);
            group_entry.snmpv3_group_name[sizeof(group_entry.snmpv3_group_name) - 1] = '\0';
        }
        else
        {
            /* securityToGroupEntry not exist, check securityToGroupEntry table is full or not
             */
            if (snmp_mgr_security_to_group_count >= SNMP_MGR_MAX_NBR_OF_SNMPV3_SECURITYTOGROUP)
            {
                return SNMP_MGR_ERROR_FAIL;
            }

            /* use input community name as group name
             */
            strncpy(group_entry.snmpv3_group_name, entry->trap_dest_community,
                sizeof(group_entry.snmpv3_group_name) - 1);
            group_entry.snmpv3_group_name[sizeof(group_entry.snmpv3_group_name) - 1] = '\0';
        }

        /* check vacmAccessTable exist or not
         */
        group_entry.snmpv3_group_model = entry->trap_dest_version;
        group_entry.snmpv3_group_security_level = entry->trap_dest_security_level;

        if (SNMP_MGR_ERROR_OK != SNMP_MGR_GetSnmpV3Group(&group_entry))
        {
            /* vacmAccessTable not exist, check vacmAccessTable is full or not
             */
            if (snmp_mgr_group_count >= SNMP_MGR_MAX_NBR_OF_SNMPV3_GROUP)
            {
                return SNMP_MGR_ERROR_FAIL;
            }
        }
    }

    /* if we support index-based table, we should do some extra effort to maintain the
     * database for index-based table, whose index is a number
     */
    /* verify if already some entry is lose due to Target MIB change
     */
    SNMP_MGR_VerifyAndDeleteProbeConfigDB();


    /* find trap receiver
     */
    for (i = 0; i < SYS_ADPT_MAX_NBR_OF_TRAP_RECEIVER; i++)
    {
        /* check address
         */
        /* amy add 1-24-2002 */
        /* set the specific trap receiver status */
        if (0 == L_INET_CompareInetAddr((L_INET_Addr_T *)&entry->trap_dest_address,
            (L_INET_Addr_T*) &snmp_mgr_trap_receiver[i].trap_dest_address, 0))
        {
            {
                available_entry = i;
            }
            break;
        }

        /* invalid entry
         */
        if (snmp_mgr_trap_receiver[i].trap_dest_status == VAL_snmpTargetAddrRowStatus_destroy)
        {
            /* record the first empty entry.  When the entry is not existed, this
             * entry will be updated as the input.
             */
            if (available_entry == -1)
            {
                available_entry = i;
            }
            continue;
        }

    }

    /* for-loop finished; not found
     */
    if (i == SYS_ADPT_MAX_NBR_OF_TRAP_RECEIVER)
    {
        /* Not found, create a new one, if no more available entry then return SNMP_MGR_ERROR_EXCEED_LIMIT
         */
        if (available_entry != -1)
        {
            memset(snmp_mgr_trap_receiver[available_entry].trap_dest_owner, 0, MAXSIZE_trapDestOwner+1);
            memcpy(&snmp_mgr_trap_receiver[available_entry].trap_dest_address, &entry->trap_dest_address, sizeof(entry->trap_dest_address));
            snmp_mgr_trap_receiver[available_entry].trap_dest_port = entry->trap_dest_port;

            /* we fixed the protocol type to ip type*/
            snmp_mgr_trap_receiver[available_entry].trap_dest_protocol = VAL_trapDestProtocol_ip;
            snmp_mgr_trap_receiver[available_entry].trap_dest_status = VAL_snmpTargetAddrRowStatus_active;

#if (SYS_CPNT_SNMP_CONTIGUOUS_TRAP_DEST_TABLE == TRUE)
            snmp_mgr_trap_receiver_total++;
#endif
        }
        else
        {
            #if (SYS_CPNT_EH == TRUE)
                EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                         0,
                                         EH_TYPE_MSG_MAXIMUM_EXCEEDED,
                                        (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));
            #endif
            /* return SNMP_MGR_ERROR_EXCEED_LIMIT*/


            return SNMP_MGR_ERROR_EXCEED_LIMIT;
        }
    }

    /* found existing
     */
    else
    {
        /* found an entry, update status.  By logically, it should be deleted.
         */

#if (SYS_CPNT_SNMP_CONTIGUOUS_TRAP_DEST_TABLE == TRUE)
        /* PATCH: The above "available_entry" check may find a valid entry for
         * modification or an invalid entry for revival.
         * If this is changing from invalid to valid, increment the total.
         * Otherwise, don't change.
         * This will be changed soon to check for a valid entry only.
         */
        if (snmp_mgr_trap_receiver[available_entry].trap_dest_status == VAL_snmpTargetAddrRowStatus_destroy)
        {
            snmp_mgr_trap_receiver_total++;
        }
#endif

        /* we fixed the protocol type to ip type*/
        snmp_mgr_trap_receiver[available_entry].trap_dest_protocol = VAL_trapDestProtocol_ip;
        snmp_mgr_trap_receiver[available_entry].trap_dest_status = VAL_snmpTargetAddrRowStatus_active;
    }



    /* Create Probe Config database okay, go on to create the Target MIB
     */

    /* initilize the entry to 0
     */
    memset(&notify_entry, 0, sizeof(notify_entry));
    memset(&target_addr_entry, 0, sizeof(target_addr_entry));
    memset(&target_params_entry, 0, sizeof(target_params_entry));

    /* Create the snmpNotifyTable
     */
    if (entry->trap_dest_type == VAL_snmpNotifyType_trap)
    {
        strcpy( notify_entry.snmp_notify_name, "trap");
        strcpy(notify_entry.snmp_notify_tag, "trap");
        notify_entry.snmp_notify_type = VAL_snmpNotifyType_trap;
    }
    else if (entry->trap_dest_type == VAL_snmpNotifyType_inform)
    {
        strcpy( notify_entry.snmp_notify_name, "inform");
        strcpy(notify_entry.snmp_notify_tag, "inform");
        notify_entry.snmp_notify_type = VAL_snmpNotifyType_inform;
    }
    else
    {
        #if (SYS_CPNT_EH == TRUE)
            EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                     0,
                                     EH_TYPE_MSG_INVALID_PARAMETER,
                                    (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));
        #endif

        return SNMP_MGR_ERROR_PARAMETER_NOT_MATCH;
    }

    notify_entry.snmp_notify_storage_type = VAL_snmpNotifyStorageType_nonVolatile;
    notify_entry.snmp_notify_row_status = VAL_snmpNotifyRowStatus_active;

    if (SNMP_MGR_CreateSnmpNotifyTable(&notify_entry) != SNMP_MGR_ERROR_OK)
    {
        #if (SYS_CPNT_EH == TRUE)
            EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                     0,
                                     EH_TYPE_MSG_FAILED_TO_ADD,
                                    (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));
        #endif

        return SNMP_MGR_ERROR_FAIL;
    }

    /* note: use trap receiver entry index to be target address name and parameter name,
       the maximum index string length can't over than target address name and parameter name length.
    */
    SYSFUN_Snprintf(target_addr_entry.snmp_target_addr_name,
        sizeof(target_addr_entry.snmp_target_addr_name),
        "%ld",
        (long)available_entry+1);
    target_addr_entry.snmp_target_addr_name[sizeof(target_addr_entry.snmp_target_addr_name)-1] = '\0';

    SYSFUN_Snprintf(target_addr_entry.snmp_target_addr_params,
        sizeof(target_addr_entry.snmp_target_addr_params),
        "%ld",
        (long)available_entry+1);
    target_addr_entry.snmp_target_addr_params[sizeof(target_addr_entry.snmp_target_addr_params)-1] = '\0';

    if (entry->trap_dest_type == VAL_snmpNotifyType_trap)
    {
        strcpy((char *)target_addr_entry.snmp_target_addr_tag_list, "trap");
    }
    else if (entry->trap_dest_type == VAL_snmpNotifyType_inform)
    {
        strcpy((char *)target_addr_entry.snmp_target_addr_tag_list, "inform");
    }
    else
    {
        #if (SYS_CPNT_EH == TRUE)
            EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                     0,
                                     EH_TYPE_MSG_INVALID_PARAMETER,
                                    (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));
        #endif

        return SNMP_MGR_ERROR_PARAMETER_NOT_MATCH;
    }

    memcpy(target_addr_entry.snmp_target_addr_tdomain, udp_domain_oid, 7*sizeof(oid));
    target_addr_entry.snmp_target_addr_tdomain_len = 7;

    SNMP_MGR_SetIpandPort2Taddress(entry->trap_dest_address,entry->trap_dest_port,&target_addr_entry);

    if (entry->trap_dest_type == VAL_snmpNotifyType_trap)
    {
        target_addr_entry.snmp_target_addr_timeout=SNMP_MGR_INFORM_REQUEST_TIMEOUT;
        target_addr_entry.snmp_target_addr_retry_count = SNMP_MGR_INFORM_REQUEST_RETRY_CNT;
    }
    else if (entry->trap_dest_type == VAL_snmpNotifyType_inform)
    {
        target_addr_entry.snmp_target_addr_timeout=entry->trap_inform_request_timeout;
        target_addr_entry.snmp_target_addr_retry_count = entry->trap_inform_request_retry_cnt;
    }

    target_addr_entry.snmp_target_addr_storage_type = VAL_snmpTargetAddrStorageType_nonVolatile;
    target_addr_entry.snmp_target_addr_row_status = VAL_snmpTargetAddrRowStatus_active ;

    if (SNMP_MGR_CreateSnmpTargetAddrTable(&target_addr_entry)!= SNMP_MGR_ERROR_OK)
    {
        #if (SYS_CPNT_EH == TRUE)
            EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                     0,
                                     EH_TYPE_MSG_FAILED_TO_ADD,
                                    (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));
        #endif

        return SNMP_MGR_ERROR_FAIL;
    }

    /* create the snmpTargetParamsTable
     */
    strncpy(target_params_entry.snmp_target_params_name,
        target_addr_entry.snmp_target_addr_params,
        sizeof(target_params_entry.snmp_target_params_name)-1);
    target_params_entry.snmp_target_params_name[sizeof(target_params_entry.snmp_target_params_name)-1] = '\0';

    switch(entry->trap_dest_version)
    {
        case SNMP_MGR_SNMPV3_MODEL_V1:
            target_params_entry.snmp_target_params_mp_model = SNMP_MP_MODEL_SNMPv1;
            target_params_entry.snmp_target_params_security_level = VAL_snmpTargetParamsSecurityLevel_noAuthNoPriv;
            break;
        case SNMP_MGR_SNMPV3_MODEL_V2C:
            target_params_entry.snmp_target_params_mp_model = SNMP_MP_MODEL_SNMPv2c;
            target_params_entry.snmp_target_params_security_level = VAL_snmpTargetParamsSecurityLevel_noAuthNoPriv;
            break;
        case SNMP_MGR_SNMPV3_MODEL_V3:
            target_params_entry.snmp_target_params_mp_model = SNMP_MP_MODEL_SNMPv3;
            target_params_entry.snmp_target_params_security_level = entry->trap_dest_security_level;
            break;
        default:
            target_params_entry.snmp_target_params_mp_model = SNMP_MP_MODEL_SNMPv3;
            break;
    }

    target_params_entry.snmp_target_params_security_model = SNMP_MGR_SNMPV3_MODEL_V3; /* restrict to usm model*/
    strcpy((char *)target_params_entry.snmp_target_params_security_name,  entry->trap_dest_community);
    target_params_entry.snmp_target_params_storage_type = VAL_snmpTargetParamsStorageType_nonVolatile ;
    target_params_entry.snmp_target_params_row_status = VAL_snmpTargetParamsRowStatus_active;

    if (SNMP_MGR_CreateSnmpTargetParamsTable(&target_params_entry)!= SNMP_MGR_ERROR_OK)
    {
        return SNMP_MGR_ERROR_FAIL;
    }

    /* Now enter the next step, we need to create the snmpNotifyFilterProfileTable and
       snmpNotifyFilterTable
     */

    /* create snmpNotifyFilterProfileTable
     */
    memcpy(&notify_filter_profile_entry.snmp_notify_filter_profile_ip, &entry->trap_dest_address,
        sizeof(notify_filter_profile_entry.snmp_notify_filter_profile_ip));
    strncpy(notify_filter_profile_entry.snmp_target_params_name,
        target_params_entry.snmp_target_params_name,
        sizeof(notify_filter_profile_entry.snmp_target_params_name)-1);
    notify_filter_profile_entry.snmp_target_params_name[sizeof(notify_filter_profile_entry.snmp_target_params_name)-1] = '\0';

    strncpy(notify_filter_profile_entry.snmp_notify_filter_profile_name,
        target_params_entry.snmp_target_params_name,
        sizeof(notify_filter_profile_entry.snmp_notify_filter_profile_name)-1);
    notify_filter_profile_entry.snmp_notify_filter_profile_name[sizeof(notify_filter_profile_entry.snmp_notify_filter_profile_name)-1] = '\0';

    notify_filter_profile_entry.snmp_notify_filter_profile_stor_type = VAL_snmpNotifyFilterProfileStorType_nonVolatile;
    notify_filter_profile_entry.snmp_notify_filter_profile_row_status = VAL_snmpNotifyFilterProfileRowStatus_active;

    if (SNMP_MGR_CreateSnmpNotifyFilterProfileTable(&notify_filter_profile_entry)!= SNMP_MGR_ERROR_OK)
    {
        return SNMP_MGR_ERROR_FAIL;
    }

    /* create snmpNotifyFilterTable
     */
    strncpy(notify_filter_entry.snmp_notify_filter_profile_name,
        target_params_entry.snmp_target_params_name,
        sizeof(notify_filter_entry.snmp_notify_filter_profile_name)-1);
    notify_filter_entry.snmp_notify_filter_profile_name[sizeof(notify_filter_entry.snmp_notify_filter_profile_name)-1] = '\0';

    /* we create the view as "1"
     */
    notify_filter_entry.snmp_notify_filter_subtree[0] = 1;
    notify_filter_entry.snmp_notify_filter_subtree_len = 1;
    notify_filter_entry.snmp_notify_filter_mask[0] = 0x80;
    notify_filter_entry.snmp_notify_filter_mask_len = 1;
    notify_filter_entry.snmp_notify_filter_type = VAL_snmpNotifyFilterType_included;
    notify_filter_entry.snmp_notify_filter_storage_type = VAL_snmpNotifyFilterStorageType_nonVolatile;
    notify_filter_entry.snmp_notify_filter_row_status = VAL_snmpNotifyFilterRowStatus_active;

    if (SNMP_MGR_CreateSnmpNotifyFilterTable(&notify_filter_entry)!= SNMP_MGR_ERROR_OK)
    {
        return SNMP_MGR_ERROR_FAIL;
    }

    /* auto create snmpCommunityTable/usmUserTable, vacmSecurityToGroupTable and vacmAccessTable if needed
     */
    if ((entry->trap_dest_version == SNMP_MGR_SNMPV3_MODEL_V1) ||
        (entry->trap_dest_version == SNMP_MGR_SNMPV3_MODEL_V2C) ||
        ((entry->trap_dest_version == SNMP_MGR_SNMPV3_MODEL_V3) &&
         (entry->trap_dest_type == VAL_snmpNotifyType_trap) &&
         (entry->trap_dest_security_level == VAL_snmpTargetParamsSecurityLevel_noAuthNoPriv)
         )
        )
    {
        if (SNMP_MGR_ERROR_OK != SNMP_MGR_LocalGetSecurityName(entry->trap_dest_version,
                                                               entry->trap_dest_community,
                                                               security_name,
                                                               sizeof(security_name)))
        {
            /* user not exist, create user by version
             */
            if (SNMP_MGR_ERROR_OK != SNMP_MGR_LocalAutoCreateUserByVersion(entry->trap_dest_version,
                                                                           entry->trap_dest_community,
                                                                           entry->trap_dest_community))
            {
                return SNMP_MGR_ERROR_FAIL;
            }

            /* use input community name as security name
             */
            strncpy(security_name, entry->trap_dest_community, sizeof(security_name)-1);
            security_name[sizeof(security_name)-1] = '\0';
        }

        memset(&group_entry, 0, sizeof(group_entry));

        /* check securityToGroupEntry exist or not
         */
        geptr = vacm_getGroupEntry(entry->trap_dest_version, security_name);

        if (NULL != geptr)
        {
            strncpy(group_entry.snmpv3_group_name, geptr->groupName,
                sizeof(group_entry.snmpv3_group_name) - 1);
            group_entry.snmpv3_group_name[sizeof(group_entry.snmpv3_group_name) - 1] = '\0';
        }
        else
        {
            /* create securityToGroupEntry
             */
            snprintf(line, sizeof(line), "%s %s %s volatile",
                entry->trap_dest_community,
                (SNMP_MGR_SNMPV3_MODEL_V1 == entry->trap_dest_version) ? "v1" :
                (SNMP_MGR_SNMPV3_MODEL_V2C == entry->trap_dest_version) ? "v2c" :
                (SNMP_MGR_SNMPV3_MODEL_V3 == entry->trap_dest_version) ? "usm" : "any",
                security_name);
            line[sizeof(line)-1] = '\0';

            if (SNMP_MGR_ERROR_OK != vacm_parse_group("group", line, TRUE))
            {
                return SNMP_MGR_ERROR_FAIL;
            }

            /* use input community name as group name
             */
            strncpy(group_entry.snmpv3_group_name, entry->trap_dest_community,
                sizeof(group_entry.snmpv3_group_name) - 1);
            group_entry.snmpv3_group_name[sizeof(group_entry.snmpv3_group_name) - 1] = '\0';
        }

        /* check vacmAccessTable exist or not
         */
        group_entry.snmpv3_group_model = entry->trap_dest_version;
        group_entry.snmpv3_group_security_level = entry->trap_dest_security_level;

        if (SNMP_MGR_ERROR_OK == SNMP_MGR_GetSnmpV3Group(&group_entry))
        {
            /* if notify view is empty, append "defaultview" notify view
             */
            if ('\0' == group_entry.snmpv3_group_notifyview[0])
            {
                if (SNMP_MGR_ERROR_OK != SNMP_MGR_AppendNotifyView(&group_entry))
                {
                    return SNMP_MGR_ERROR_FAIL;
                }
            }
        }
        else
        {
            /* create vacmAccessTable with "defaultview" notify view
             */
            strncpy(group_entry.snmpv3_group_notifyview, "defaultview",
                sizeof(group_entry.snmpv3_group_notifyview) - 1);
            group_entry.snmpv3_group_notifyview[sizeof(group_entry.snmpv3_group_notifyview) - 1] = '\0';
            group_entry.snmpv3_group_storage_type = VAL_vacmAccessStorageType_volatile;

            if (SNMP_MGR_ERROR_OK != SNMP_MGR_CreateSnmpV3Group(&group_entry, TRUE))
            {
                return SNMP_MGR_ERROR_FAIL;
            }
        }
    }

    return SNMP_MGR_ERROR_OK;
}


/* ---------------------------------------------------------------------
 * ROUTINE NAME  - SNMP_MGR_Get_PrivateMibRootLen
 * ---------------------------------------------------------------------
 * PURPOSE: This function is for SNMP internal use to get the private Mib Root len.
 *
 * INPUT: none
 * OUTPUT: none
 * RETURN: SNMP_MGR_ERROR_OK;SNMP_MGR_ERROR_PARAMETER_NOT_MATCH;SNMP_MGR_ERROR_FAIL;
 * NOTES:1.none
 *
 * ---------------------------------------------------------------------
 */
UI32_T SNMP_MGR_Get_PrivateMibRootLen()
{
   oid            PrivateMIB_module_oid[SYS_ADPT_MAX_OID_STRING_LEN+1];
   UI32_T         private_mib_root_len = 0;
   UI8_T          buffer[SYS_ADPT_MAX_OID_STRING_LEN+1];

   if (SYS_PMGR_GetPrivateMibRoot(SYS_VAL_LOCAL_UNIT_ID, buffer)!=TRUE)
   {
       SYSFUN_Debug_Printf("%s: Error getting Private MIB Root\r\n", __FUNCTION__);
       return 0;
   }

   SNMP_MGR_StringToObejctID(PrivateMIB_module_oid, (I8_T *)buffer, &private_mib_root_len);

   return private_mib_root_len;
}

/* ---------------------------------------------------------------------
 * ROUTINE NAME  - SNMP_MGR_CalPartialVarLen
 * ---------------------------------------------------------------------
 * PURPOSE: This function is for SNMP internal use to interpret the SSH
 *          use key from 1024 bytes to a small len and output.
 *
 * INPUT: wholeVarMaxLen   wholeVarLen.  unitLen,         unitIndex,
 * OUTPUT: start,partialVarLen
 * RETURN: TRUE/FALSE;
 * NOTES:1.none
 *
 * ---------------------------------------------------------------------
 */
BOOL_T SNMP_MGR_CalPartialVarLen(UI32_T wholeVarMaxLen, UI32_T wholeVarLen,
                                 UI32_T unitLen, UI32_T unitIndex,
                 UI32_T *start, UI32_T *partialVarLen)
{
    UI32_T emptyLen;
    if (wholeVarLen > wholeVarMaxLen)
    {
        #if (SYS_CPNT_EH == TRUE)
            EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                     0,
                                     EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                    (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));
        #endif
        return FALSE;
    }
    *start=(unitIndex-1)*unitLen + 1;
    emptyLen=wholeVarMaxLen-wholeVarLen;
    if (*start > wholeVarLen)
        *partialVarLen=0;
    else
       *partialVarLen=wholeVarLen - (unitIndex -1) * unitLen;

    if (*partialVarLen > unitLen)
        *partialVarLen=unitLen;

    return TRUE;
}

/* ---------------------------------------------------------------------
 * ROUTINE NAME  - SNMP_MGR_SetNetSnmpParseErr
 * ---------------------------------------------------------------------
 * PURPOSE: This function for patching the Netsnmp5.1 memory leak issue.
 *
 * INPUT: *flag
 * OUTPUT: *flag
 * RETURN: TRUE;FALSE;
 * NOTES:   We provided a flag in snmp_mgr, when this flag is on, we will
 *          ignore line4790, snmp_api.c, function snmp_free_pdu
 *          if (pdu->command ==0) and go on to free the pdu.
 *          Since we do not know what case  will make the pdu->command = 0,
 *          we will set this flag on in function _sess_process_packet, ln
 *          ret = snmp_parse(sessp, sp, pdu, packetptr, length)(ln4907),then
 *          when function snmp_free_pdu see this flag is true, can go on
 *          to free the pdu.
 *
 * ---------------------------------------------------------------------
 */
BOOL_T SNMP_MGR_SetNetSnmpParseErr( BOOL_T flag)
{

    SNMP_MGR_CHECK_OPER_MODE(FALSE);
    snmp_mgr_patch_netsnmp_parse_err_flag = flag;

    return TRUE;
}

/* ---------------------------------------------------------------------
 * ROUTINE NAME  - SNMP_MGR_IsNetSnmpParseErr
 * ---------------------------------------------------------------------
 * PURPOSE: This function for patching the Netsnmp5.1 memory leak issue.
 *
 * INPUT: *flag
 * OUTPUT: none.
 * RETURN: TRUE;FALSE;
 * NOTES:   We provided a flag in snmp_mgr, when this flag is on, we will
 *          ignore line4790, snmp_api.c, function snmp_free_pdu
 *          if (pdu->command ==0) and go on to free the pdu.
 *          Since we do not know what case  will make the pdu->command = 0,
 *          we will set this flag on in function _sess_process_packet, ln
 *          ret = snmp_parse(sessp, sp, pdu, packetptr, length)(ln4907),then
 *          when function snmp_free_pdu see this flag is true, can go on
 *          to free the pdu.
 *
 * ---------------------------------------------------------------------
 */
BOOL_T SNMP_MGR_IsNetSnmpParseErr()
{
    SNMP_MGR_CHECK_OPER_MODE(FALSE);
    if(snmp_mgr_patch_netsnmp_parse_err_flag)
    {

        return TRUE;
    }
    else
    {

        return FALSE;
    }
}

/* ---------------------------------------------------------------------
 * ROUTINE NAME  - SNMP_MGR_IsInetAddrLengthValid
 * ---------------------------------------------------------------------
 * PURPOSE: This function check whether an InetAddress length is valid,
 *          based on a given InetAddressType.
 *
 * INPUT:   type - InetAddressType value
 *          len  - length (bytes) of InetAddress value (octet string)
 *
 * OUTPUT:  None
 *
 * RETURN:  TRUE/FALSE
 *
 * NOTE:    1. This function checks IPv4, IPv4z, IPv6, IPv6z, and DNS.
 *
 *          2. If "type" is unknown(0), this function checks the length ranged
 *             for InetAddress, in order to support unknown but supported types in
 *             the future.
 *
 *          3. If the caller needs to specify only some of these address types,
 *             we will pass another parameter in, as a support type bitmask.
 *             However, if, before calling this function, address type check
 *             has already been done, e.g. in the corresponding InetAddressType
 *             MIB node, then bitmasking may not be needed.
 * ---------------------------------------------------------------------
 */
BOOL_T SNMP_MGR_IsInetAddrLengthValid(UI32_T type, UI32_T len)
{
    BOOL_T ret = TRUE;  /* assume success; if failed, change to failure */

    /* if invalid
     */
    if (
        /* check default type unknown(0) with zero-length address
         */
        ( (type == VAL_InetAddressType_unknown)
            && (len != 0) )

        /* check length based on address type
         */
            || ( (type == VAL_InetAddressType_ipv4)
                && (len != SYS_TYPE_IPV4_ADDR_LEN) )
            || ( (type == VAL_InetAddressType_ipv6)
                && (len != SYS_TYPE_IPV6_ADDR_LEN) )
            || ( (type == VAL_InetAddressType_ipv4z)
                && (len != SYS_TYPE_IPV4Z_ADDR_LEN) )
            || ( (type == VAL_InetAddressType_ipv6z)
                && (len != SYS_TYPE_IPV6Z_ADDR_LEN) )

        /* out of range regardless of address type
         */
            || (len < MINSIZE_InetAddress)
            || (len > MAXSIZE_InetAddress)
        )
    {
        ret = FALSE;
    }

    /* return: single exit point, good for debugging
     */
    return ret;
}

/* ---------------------------------------------------------------------
 * ROUTINE NAME  - SNMP_MGR_IsInetAddrValueValid
 * ---------------------------------------------------------------------
 * PURPOSE: This function check whether an InetAddress value is valid,
 *          based on a given InetAddressType.
 *
 * INPUT:   type        - InetAddressType value
 *          addr_ar_p   - length (bytes) of InetAddress value (octet string)
 *
 * OUTPUT:  None
 *
 * RETURN:  TRUE/FALSE
 *
 * NOTE:    1. Because this is not an export function, the length of the
 *             the buffer in "addr_ar_p" is not passed in.  The caller
 *             of this function must ensure proper length of the content.
 *
 *          1. This function checks IPv4, IPv4z, IPv6, IPv6z, and DNS.
 *
 *          2. If "type" is unknown(0), this function always return TRUE.
 *
 *          3. If the caller needs to specify only some of these address types,
 *             we will pass another parameter in, as a support type bitmask.
 *             However, if, before calling this function, address type check
 *             has already been done, e.g. in the corresponding InetAddressType
 *             MIB node, then bitmasking may not be needed.
 * ---------------------------------------------------------------------
 */
BOOL_T SNMP_MGR_IsInetAddrValueValid(UI32_T type, UI8_T *addr_ar_p)
{
    BOOL_T ret = TRUE;  /* assume success; if failed, change to failure */

    /* dispatch type
     */
    switch (type)
    {
        /* unknown(0): not checked for content; assume success
         */
        case VAL_InetAddressType_unknown:
            break;

        /* ipv4(1)
         */
        case VAL_InetAddressType_ipv4:
            if (L_INET_ADDR_IS_IPV4_LINK_LOCAL(addr_ar_p))
            {
                ret = FALSE;
            }
            break;

        /* ipv6(2)
         */
        case VAL_InetAddressType_ipv6:
            if (L_INET_ADDR_IS_IPV6_LINK_LOCAL(addr_ar_p))
            {
                ret = FALSE;
            }
            break;

        /* ipv4z(3)
         */
        case VAL_InetAddressType_ipv4z:
            if (! L_INET_ADDR_IS_IPV4_LINK_LOCAL(addr_ar_p))
            {
                ret = FALSE;
            }
            break;

        /* ipv6z(4)
         */
        case VAL_InetAddressType_ipv6z:
            if (! L_INET_ADDR_IS_IPV6_LINK_LOCAL(addr_ar_p))
            {
                ret = FALSE;
            }
            break;

        /* dns(16): not checked for content; assume success
         */
        case VAL_InetAddressType_dns:
            break;

        /* unrecognised
         */
        default:
            ret = FALSE;
            break;
    }

    /* return; single exit point
     */
    return ret;
}

/* Remote EngineID/User API*/
/* ---------------------------------------------------------------------
 * ROUTINE NAME  - SNMP_MGR_CreateSnmpRemoteUser
 * ---------------------------------------------------------------------
 * PURPOSE: This function will Create the Snmp Remote User
 * INPUT : remote ip, entry
 * OUTPUT: None
 * RETURN: SNMP_MGR_ERROR_OK/SNMP_MGR_ERROR_FAIL
 * NOTES : none
 * ---------------------------------------------------------------------
 */
UI32_T
SNMP_MGR_CreateSnmpRemoteUser(
    UI32_T remote_ip,
    SNMP_MGR_SnmpV3UserEntry_T *entry)
{
    UI32_T  i;
    I32_T   available_entry = -1;
    SNMP_MGR_SnmpRemoteEngineID_T engineID_entry;
    oid     authProtocol[10];
    UI32_T  authProtocolLen=10;
    oid     privProtocol[10];
    /* add for aes 256
     */
    UI32_T  privProtocolLen = 0;
    size_t  extendkey_len = 0;
    size_t  shortkey_len  = 0;
    oid     zerodotzero[2]= { 0 , 0};
    u_char  userKey[SNMP_MAXBUF_SMALL];
    size_t  userKeyLen = SNMP_MAXBUF_SMALL;
    int     ret;
    struct  usmUser *newuser;
    UI32_T orig_priority;

    /* BODY
     */
    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);

    /* check user name, group name is valid?
     */
    if ((strlen(entry->snmpv3_user_name) > MAXSIZE_usmUserName) ||
        (strlen(entry->snmpv3_user_name) < MINSIZE_usmUserName))
    {
        return SNMP_MGR_ERROR_FAIL;
    }

    /* Remote user is for version 3 only.
     */
    if ((entry->snmpv3_user_security_model == SNMP_MGR_SNMPV3_MODEL_V1) ||
        (entry->snmpv3_user_security_model == SNMP_MGR_SNMPV3_MODEL_V2C))
    {
        return SNMP_MGR_ERROR_FAIL;
    }

    /* check auth password is valid ?
     * we need to check password len only
     * if (model ==3) and (pass from config == FALSE) and ( level = authNoPriv or authPriv)
     */
    if (((strlen(entry->snmpv3_user_auth_password) > MAX_SNMPV3_PASSWORD_LEN) ||
        (strlen(entry->snmpv3_user_auth_password) < MIN_SNMPV3_PASSWORD_LEN)) &&
        ((entry->password_from_config == FALSE) &&
         (entry->snmpv3_user_security_model == SNMP_MGR_SNMPV3_MODEL_V3)) &&
        ((entry->snmpv3_user_security_level == VAL_vacmAccessSecurityLevel_authNoPriv) ||
         (entry->snmpv3_user_security_level == VAL_vacmAccessSecurityLevel_authPriv)))

    {
        return SNMP_MGR_ERROR_FAIL;
    }

    /* check priv password is valid ?
     * we need to check password len only
     * if (model ==3) and (pass from config == FALSE) and ( level =  authPriv)
     */
    if (((strlen(entry->snmpv3_user_priv_password) > MAX_SNMPV3_PASSWORD_LEN) ||
        (strlen(entry->snmpv3_user_priv_password) < MIN_SNMPV3_PASSWORD_LEN)) &&
        ((entry->password_from_config == FALSE) &&
         (entry->snmpv3_user_security_model == SNMP_MGR_SNMPV3_MODEL_V3) &&
         (entry->snmpv3_user_security_level == VAL_vacmAccessSecurityLevel_authPriv)))

    {

        return SNMP_MGR_ERROR_FAIL;
    }

    entry->snmpv3_user_status = VAL_usmUserStatus_active;
    engineID_entry.snmp_remote_engineID_host = remote_ip;

    if (SNMP_MGR_GetSnmpRemoteEngineIDEntry(&engineID_entry) != SNMP_MGR_ERROR_OK)
    {
        return SNMP_MGR_ERROR_FAIL;
    }



    /* find user
     */
    for (i = 0; i < SNMP_MGR_MAX_NBR_OF_REMOTE_USER; i++)
    {
        /* check user
         */
        if ( (strcmp(entry->snmpv3_user_name,
                     snmp_mgr_remote_user_entry[i].snmpv3_user_name) == 0) &&
             (memcmp(engineID_entry.snmp_remote_engineID,
                     snmp_mgr_remote_user_entry[i].snmpv3_user_engine_id,
                     engineID_entry.snmp_remote_engineIDLen) == 0))
        {
            /* if specific entry already exist, and the status already the same as u want to set now,
             * return false
             */
            if (snmp_mgr_remote_user_entry[i].snmpv3_user_status == entry->snmpv3_user_status)
            {
                i=SNMP_MGR_MAX_NBR_OF_REMOTE_USER;
                available_entry=-1;
            }
            else
            {
                available_entry = i;
            }

            break;
        }

        /* invalid entry
         */
        if (snmp_mgr_remote_user_entry[i].snmpv3_user_status == VAL_usmUserStatus_destroy)
        {
            /* record the first empty entry.  When the entry is not existed, this
             * entry will be updated as the input.
             */
            if (available_entry == -1)
                available_entry = i;

            continue;
        }

        /* check user
         */
        if ( (strcmp(entry->snmpv3_user_name,
                     snmp_mgr_remote_user_entry[i].snmpv3_user_name) == 0) &&
              (memcmp(engineID_entry.snmp_remote_engineID,
                      snmp_mgr_remote_user_entry[i].snmpv3_user_engine_id,
                      engineID_entry.snmp_remote_engineIDLen) == 0))
            break;

    }

    /* for-loop finished; not found
     */
    if (i == SNMP_MGR_MAX_NBR_OF_REMOTE_USER)
    {
        /* No found, create a new one, if no more available entry then return FALSE
         */
        if (available_entry != -1)
        {
            strcpy(snmp_mgr_remote_user_entry[available_entry].snmpv3_user_name,
                   entry->snmpv3_user_name);
            strcpy(snmp_mgr_remote_user_entry[available_entry].snmpv3_user_group_name,
                   entry->snmpv3_user_group_name);
            memcpy(snmp_mgr_remote_user_entry[available_entry].snmpv3_user_engine_id,
                   engineID_entry.snmp_remote_engineID,
                   engineID_entry.snmp_remote_engineIDLen);

            snmp_mgr_remote_user_entry[available_entry].snmpv3_user_engineIDLen =
                engineID_entry.snmp_remote_engineIDLen;
            snmp_mgr_remote_user_entry[available_entry].snmpv3_user_security_model =
                entry->snmpv3_user_security_model;
            snmp_mgr_remote_user_entry[available_entry].snmpv3_user_security_level =
                entry->snmpv3_user_security_level;

            /* copy the auth Protocol type
             */
            if ( entry->snmpv3_user_auth_type == SNMP_MGR_SNMPV3_AUTHTYPE_MD5)
            {
                snmp_mgr_remote_user_entry[available_entry].snmpv3_user_auth_type =
                    SNMP_MGR_SNMPV3_AUTHTYPE_MD5;
                memcpy(authProtocol, usmHMACMD5AuthProtocol, sizeof(usmHMACMD5AuthProtocol));
            }
            else if ( entry->snmpv3_user_auth_type == SNMP_MGR_SNMPV3_AUTHTYPE_SHA )
            {
                snmp_mgr_remote_user_entry[available_entry].snmpv3_user_auth_type =
                    SNMP_MGR_SNMPV3_AUTHTYPE_SHA;
                memcpy(authProtocol, usmHMACSHA1AuthProtocol, sizeof(usmHMACSHA1AuthProtocol));
            }
            else
            {
                snmp_mgr_remote_user_entry[available_entry].snmpv3_user_auth_type =
                    SNMP_MGR_SNMPV3_AUTHTYPE_NONE;
                memcpy(authProtocol, usmNoAuthProtocol, sizeof(usmNoAuthProtocol));
            }

            /* copy the priv Protocol type
             */
            if ( entry->snmpv3_user_priv_type == SNMP_MGR_SNMPV3_PRIVTYPE_DES)
            {
                snmp_mgr_remote_user_entry[available_entry].snmpv3_user_priv_type =
                    SNMP_MGR_SNMPV3_PRIVTYPE_DES;
                memcpy(privProtocol, usmDESPrivProtocol, sizeof(usmDESPrivProtocol));

            }
            else if (entry->snmpv3_user_priv_type == SNMP_MGR_SNMPV3_PRIVTYPE_3DES)
            {
                snmp_mgr_remote_user_entry[available_entry].snmpv3_user_priv_type =
                    SNMP_MGR_SNMPV3_PRIVTYPE_3DES;
                memcpy(privProtocol, usm3DESPrivProtocol, sizeof(usm3DESPrivProtocol));

            }
            else if ( entry->snmpv3_user_priv_type == SNMP_MGR_SNMPV3_PRIVTYPE_AES128)
            {
                snmp_mgr_remote_user_entry[available_entry].snmpv3_user_priv_type =
                    SNMP_MGR_SNMPV3_PRIVTYPE_AES128;
                memcpy(privProtocol, usmAES128PrivProtocol, sizeof(usmAES128PrivProtocol));

            }
            else if ( entry->snmpv3_user_priv_type == SNMP_MGR_SNMPV3_PRIVTYPE_AES192)
            {
                snmp_mgr_remote_user_entry[available_entry].snmpv3_user_priv_type =
                    SNMP_MGR_SNMPV3_PRIVTYPE_AES192;
                memcpy(privProtocol, usmAES192PrivProtocol, sizeof(usmAES192PrivProtocol));

            }
            else if ( entry->snmpv3_user_priv_type == SNMP_MGR_SNMPV3_PRIVTYPE_AES256)
            {
                snmp_mgr_remote_user_entry[available_entry].snmpv3_user_priv_type =
                    SNMP_MGR_SNMPV3_PRIVTYPE_AES256;
                memcpy(privProtocol, usmAES256PrivProtocol, sizeof(usmAES256PrivProtocol));

            }
            else
            {
                snmp_mgr_remote_user_entry[available_entry].snmpv3_user_priv_type =
                    SNMP_MGR_SNMPV3_PRIVTYPE_NONE;
                memcpy(privProtocol, usmNoPrivProtocol, sizeof(usmNoPrivProtocol));
            }

            /* password from config, it is easy, we just copy the auth key
             */
            if (entry->password_from_config)
            {
                memcpy(snmp_mgr_remote_user_entry[available_entry].snmpv3_user_auth_key,
                       entry->snmpv3_user_auth_key,
                       entry->snmpv3_user_auth_key_len);
                memcpy(snmp_mgr_remote_user_entry[available_entry].snmpv3_user_priv_key,
                       entry->snmpv3_user_priv_key,
                       entry->snmpv3_user_priv_key_len);

                snmp_mgr_remote_user_entry[available_entry].snmpv3_user_auth_key_len =
                    entry->snmpv3_user_auth_key_len;
                snmp_mgr_remote_user_entry[available_entry].snmpv3_user_priv_key_len =
                    entry->snmpv3_user_priv_key_len;
            }
            else
            /* password from plainPassword, we need to generate the auth key and priv key from the new EngineID
             */
            {
                strcpy(snmp_mgr_remote_user_entry[available_entry].snmpv3_user_auth_password,
                       entry->snmpv3_user_auth_password);
                strcpy(snmp_mgr_remote_user_entry[available_entry].snmpv3_user_priv_password,
                       entry->snmpv3_user_priv_password);

                if ((entry->snmpv3_user_security_level ==  VAL_vacmAccessSecurityLevel_authPriv) ||
                    (entry->snmpv3_user_security_level ==  VAL_vacmAccessSecurityLevel_authNoPriv))
                {
                    /* Auth Key generate
                     */
                    ret = generate_Ku(authProtocol,
                                      authProtocolLen,
                                      (u_char *)entry->snmpv3_user_auth_password,
                                      strlen(entry->snmpv3_user_auth_password),
                                      userKey,
                                      &userKeyLen);

                    if (ret != SNMPERR_SUCCESS)
                    {


                        return SNMP_MGR_ERROR_FAIL;
                    }

                    snmp_mgr_remote_user_entry[available_entry].snmpv3_user_auth_key_len =
                        sc_get_properlength(authProtocol,
                                            authProtocolLen);

                    ret = generate_kul(authProtocol,
                                       authProtocolLen,
                                       engineID_entry.snmp_remote_engineID,
                                       engineID_entry.snmp_remote_engineIDLen,
                                       userKey,
                                       userKeyLen,
                                       snmp_mgr_remote_user_entry[available_entry].snmpv3_user_auth_key,
                                       (size_t*)&snmp_mgr_remote_user_entry[available_entry].snmpv3_user_auth_key_len);

                    if (ret != SNMPERR_SUCCESS)
                    {


                        return SNMP_MGR_ERROR_FAIL;
                    }

                }
                else
                {
                    memset(snmp_mgr_remote_user_entry[available_entry].snmpv3_user_auth_key,
                           0,
                           SNMP_MGR_SNMPV3_SHA_KEY_LEN);
                    snmp_mgr_remote_user_entry[available_entry].snmpv3_user_auth_key_len = 0;
                }

                if ( entry->snmpv3_user_security_level == VAL_vacmAccessSecurityLevel_authPriv)
                {
                    /* Priv Key generate
                     */
                    ret = generate_Ku(authProtocol,
                                      authProtocolLen,
                                      (u_char*)entry->snmpv3_user_priv_password,
                                      strlen(entry->snmpv3_user_priv_password),
                                      userKey,
                                      &userKeyLen);

                    if (ret != SNMPERR_SUCCESS)
                    {


                        return SNMP_MGR_ERROR_FAIL;
                    }

                    snmp_mgr_remote_user_entry[available_entry].snmpv3_user_priv_key_len =
                        sc_get_properlength(authProtocol,
                                            authProtocolLen);

                    ret = generate_kul(authProtocol,
                                       authProtocolLen,
                                       engineID_entry.snmp_remote_engineID,
                                       engineID_entry.snmp_remote_engineIDLen,
                                       userKey,
                                       userKeyLen,
                                       snmp_mgr_remote_user_entry[available_entry].snmpv3_user_priv_key,
                                       (size_t*)&snmp_mgr_remote_user_entry[available_entry].snmpv3_user_priv_key_len);

                    if (ret != SNMPERR_SUCCESS)
                    {


                        return SNMP_MGR_ERROR_FAIL;
                    }

                }
                else
                {
                    memset(snmp_mgr_remote_user_entry[available_entry].snmpv3_user_priv_key,
                           0,
                           SNMP_MGR_SNMPV3_SHA_KEY_LEN);
                    snmp_mgr_remote_user_entry[available_entry].snmpv3_user_priv_key_len = 0;
                }

            }

            snmp_mgr_remote_user_entry[available_entry].snmpv3_user_status =
                VAL_usmUserStatus_active;

            ret = SNMP_MGR_ERROR_OK;
        }
        else
        {
            ret = SNMP_MGR_ERROR_FAIL;
        }

    }
    else
    {
        /* found an entry, update status.  By logically, it should be deleted.
         */
        strcpy(snmp_mgr_remote_user_entry[available_entry].snmpv3_user_name,
               entry->snmpv3_user_name);
        strcpy(snmp_mgr_remote_user_entry[available_entry].snmpv3_user_group_name,
               entry->snmpv3_user_group_name);
        memcpy(snmp_mgr_remote_user_entry[available_entry].snmpv3_user_engine_id,
               engineID_entry.snmp_remote_engineID,
               engineID_entry.snmp_remote_engineIDLen);

        snmp_mgr_remote_user_entry[available_entry].snmpv3_user_engineIDLen =
            engineID_entry.snmp_remote_engineIDLen;
        snmp_mgr_remote_user_entry[available_entry].snmpv3_user_security_model =
            entry->snmpv3_user_security_model;
        snmp_mgr_remote_user_entry[available_entry].snmpv3_user_security_level =
            entry->snmpv3_user_security_level;

        /* copy the auth Protocol type
         */
        if ( entry->snmpv3_user_auth_type == SNMP_MGR_SNMPV3_AUTHTYPE_MD5)
        {
            snmp_mgr_remote_user_entry[available_entry].snmpv3_user_auth_type =
                SNMP_MGR_SNMPV3_AUTHTYPE_MD5;
            memcpy(authProtocol, usmHMACMD5AuthProtocol, sizeof(usmHMACMD5AuthProtocol));
        }
        else if ( entry->snmpv3_user_auth_type == SNMP_MGR_SNMPV3_AUTHTYPE_SHA )
        {
            snmp_mgr_remote_user_entry[available_entry].snmpv3_user_auth_type =
                SNMP_MGR_SNMPV3_AUTHTYPE_SHA;
            memcpy(authProtocol, usmHMACSHA1AuthProtocol, sizeof(usmHMACSHA1AuthProtocol));
        }
        else
        {
            snmp_mgr_remote_user_entry[available_entry].snmpv3_user_auth_type =
                SNMP_MGR_SNMPV3_AUTHTYPE_NONE;
            memcpy(authProtocol, usmNoAuthProtocol, sizeof(usmNoAuthProtocol));
        }

        /* copy the priv Protocol type
         */
        if (entry->snmpv3_user_priv_type == SNMP_MGR_SNMPV3_PRIVTYPE_DES)
        {
            snmp_mgr_remote_user_entry[available_entry].snmpv3_user_priv_type =
                SNMP_MGR_SNMPV3_PRIVTYPE_DES;
            memcpy(privProtocol, usmDESPrivProtocol, sizeof(usmDESPrivProtocol));
        }
        if ( entry->snmpv3_user_priv_type == SNMP_MGR_SNMPV3_PRIVTYPE_3DES)
        {
            snmp_mgr_remote_user_entry[available_entry].snmpv3_user_priv_type =
                SNMP_MGR_SNMPV3_PRIVTYPE_3DES;
            memcpy(privProtocol, usm3DESPrivProtocol, sizeof(usm3DESPrivProtocol));
        }
        else if ( entry->snmpv3_user_priv_type == SNMP_MGR_SNMPV3_PRIVTYPE_AES128)
        {
            snmp_mgr_remote_user_entry[available_entry].snmpv3_user_priv_type =
                SNMP_MGR_SNMPV3_PRIVTYPE_AES128;
            memcpy(privProtocol, usmAES128PrivProtocol, sizeof(usmAES128PrivProtocol));
        }
        else if ( entry->snmpv3_user_priv_type == SNMP_MGR_SNMPV3_PRIVTYPE_AES192)
        {
            snmp_mgr_remote_user_entry[available_entry].snmpv3_user_priv_type =
                SNMP_MGR_SNMPV3_PRIVTYPE_AES192;
            memcpy(privProtocol, usmAES192PrivProtocol, sizeof(usmAES192PrivProtocol));
        }
        else if ( entry->snmpv3_user_priv_type == SNMP_MGR_SNMPV3_PRIVTYPE_AES256)
        {
            snmp_mgr_remote_user_entry[available_entry].snmpv3_user_priv_type =
                SNMP_MGR_SNMPV3_PRIVTYPE_AES256;
            memcpy(privProtocol, usmAES256PrivProtocol, sizeof(usmAES256PrivProtocol));
        }
        else
        {
            snmp_mgr_remote_user_entry[available_entry].snmpv3_user_priv_type =
                SNMP_MGR_SNMPV3_PRIVTYPE_NONE;
            memcpy(privProtocol, usmNoPrivProtocol, sizeof(usmNoPrivProtocol));
        }

        /* password from config, it is easy, we just copy the auth key
         */
        if (entry->password_from_config)
        {
            memcpy(snmp_mgr_remote_user_entry[available_entry].snmpv3_user_auth_key,
                   entry->snmpv3_user_auth_key,
                   entry->snmpv3_user_auth_key_len);
            memcpy(snmp_mgr_remote_user_entry[available_entry].snmpv3_user_priv_key,
                   entry->snmpv3_user_priv_key,
                   entry->snmpv3_user_priv_key_len);

            snmp_mgr_remote_user_entry[available_entry].snmpv3_user_auth_key_len =
                entry->snmpv3_user_auth_key_len;
            snmp_mgr_remote_user_entry[available_entry].snmpv3_user_priv_key_len =
                entry->snmpv3_user_priv_key_len;
        }
        else
        /* password from plainPassword, we need to generate the auth key and priv key from the new EngineID
         */
        {
            strcpy(snmp_mgr_remote_user_entry[available_entry].snmpv3_user_auth_password,
                   entry->snmpv3_user_auth_password);
            strcpy(snmp_mgr_remote_user_entry[available_entry].snmpv3_user_priv_password,
                   entry->snmpv3_user_priv_password);

            if (( entry->snmpv3_user_security_level ==  VAL_vacmAccessSecurityLevel_authPriv) ||
                    ( entry->snmpv3_user_security_level ==  VAL_vacmAccessSecurityLevel_authNoPriv))
            {
                /* Auth Key generate
                 */
                ret = generate_Ku(authProtocol,
                                  authProtocolLen,
                                  (u_char *)entry->snmpv3_user_auth_password,
                                  strlen(entry->snmpv3_user_auth_password),
                                  userKey,
                                  &userKeyLen);

                if (ret != SNMPERR_SUCCESS)
                {


                    return SNMP_MGR_ERROR_FAIL;
                }

                snmp_mgr_remote_user_entry[available_entry].snmpv3_user_auth_key_len =
                    sc_get_properlength(authProtocol,
                                        authProtocolLen);

                ret = generate_kul(authProtocol,
                                   authProtocolLen,
                                   engineID_entry.snmp_remote_engineID,
                                   engineID_entry.snmp_remote_engineIDLen,
                                   userKey,
                                   userKeyLen,
                                   snmp_mgr_remote_user_entry[available_entry].snmpv3_user_auth_key,
                                   (size_t*)&snmp_mgr_remote_user_entry[available_entry].snmpv3_user_auth_key_len);

                if (ret != SNMPERR_SUCCESS)
                {


                    return SNMP_MGR_ERROR_FAIL;
                }

                if ( entry->snmpv3_user_security_level ==  VAL_vacmAccessSecurityLevel_authPriv)
                {
                /* Priv Key generate
                 */
                    ret = generate_Ku(authProtocol,
                                      authProtocolLen,
                                      (u_char*)entry->snmpv3_user_priv_password,
                                      strlen(entry->snmpv3_user_priv_password),
                                      userKey,
                                      &userKeyLen);

                    if (ret != SNMPERR_SUCCESS)
                    {


                        return SNMP_MGR_ERROR_FAIL;
                    }

                    snmp_mgr_remote_user_entry[available_entry].snmpv3_user_priv_key_len =
                        sc_get_properlength(authProtocol,
                                            authProtocolLen);

                    /* modify for AES
                     */
                    shortkey_len  = sc_get_properlength(authProtocol,
                                                        authProtocolLen);

                    switch(snmp_mgr_remote_user_entry[available_entry].snmpv3_user_priv_type)
                    {
                         case SNMP_MGR_SNMPV3_PRIVTYPE_3DES:
                         case SNMP_MGR_SNMPV3_PRIVTYPE_AES192:
                         case SNMP_MGR_SNMPV3_PRIVTYPE_AES256:
                             extendkey_len = sc_get_priv_properlength(privProtocol,
                                                                      privProtocolLen);
                             break;

                         default:
                             extendkey_len = sc_get_properlength(authProtocol,
                                                                 authProtocolLen);
                             break;

                    }

                    snmp_mgr_remote_user_entry[available_entry].snmpv3_user_priv_key_len =
                        ((shortkey_len < extendkey_len) ? extendkey_len : shortkey_len);

                    ret = generate_kul(authProtocol,
                                       authProtocolLen,
                                       engineID_entry.snmp_remote_engineID,
                                       engineID_entry.snmp_remote_engineIDLen,
                                       userKey,
                                       userKeyLen,
                                       snmp_mgr_remote_user_entry[available_entry].snmpv3_user_priv_key,
                                       (size_t*)&snmp_mgr_remote_user_entry[available_entry].snmpv3_user_priv_key_len);

                    /* for AES 192 and 256, the key needs be extended.
                     */
                    if(shortkey_len < extendkey_len)
                    {
                        SNMP_MGR_Extend_PrviKey(authProtocol,
                                                authProtocolLen,
                                                snmp_mgr_remote_user_entry[available_entry].snmpv3_user_priv_type,
                                                engineID_entry.snmp_remote_engineID,
                                                engineID_entry.snmp_remote_engineIDLen,
                                                snmp_mgr_remote_user_entry[available_entry].snmpv3_user_priv_key,
                                                shortkey_len,
                                                extendkey_len,
                                                snmp_mgr_remote_user_entry[available_entry].snmpv3_user_priv_key,
                                                (size_t*)&snmp_mgr_remote_user_entry[available_entry].snmpv3_user_priv_key_len);
                    }

                    if (ret != SNMPERR_SUCCESS)
                    {


                        return SNMP_MGR_ERROR_FAIL;
                    }

                }
                else
                {
                    memset(snmp_mgr_remote_user_entry[available_entry].snmpv3_user_priv_key,
                           0,
                           SNMP_MGR_SNMPV3_SHA_KEY_LEN);
                    snmp_mgr_remote_user_entry[available_entry].snmpv3_user_priv_key_len = 0;
                }

            }

        }

        snmp_mgr_remote_user_entry[available_entry].snmpv3_user_status =
            VAL_usmUserStatus_active;

        ret = SNMP_MGR_ERROR_OK;

    }

    /* if ret = ok, we need to create the usmUserEntry
     */
    if (ret == SNMP_MGR_ERROR_OK)
    {
        newuser = usm_create_user();

        if (newuser == NULL)
        {
            snmp_mgr_remote_user_entry[available_entry].snmpv3_user_status =
                VAL_usmUserStatus_destroy;


            return SNMP_MGR_ERROR_EXCEED_LIMIT;
        }

        memdup((u_char **)& newuser->engineID,
               (u_char *) engineID_entry.snmp_remote_engineID,
               engineID_entry.snmp_remote_engineIDLen);
        newuser->engineIDLen = engineID_entry.snmp_remote_engineIDLen;

        memdup((u_char **)&newuser->cloneFrom, (u_char *)zerodotzero, 8);
        newuser->cloneFromLen = 2;

        newuser->secName = strdup (entry->snmpv3_user_name);
        newuser->name = strdup (entry->snmpv3_user_name);
        newuser->groupName = strdup(entry->snmpv3_user_group_name);
        newuser->userModel = entry->snmpv3_user_security_model;
        newuser->authType = entry->snmpv3_user_auth_type;
        newuser->privType = entry->snmpv3_user_priv_type;
        newuser->authPasswd = NULL;
        newuser->privPasswd = NULL;

        memcpy(newuser->authProtocol, authProtocol, sizeof(usmHMACMD5AuthProtocol));
        memcpy(newuser->privProtocol, privProtocol, sizeof(usmHMACSHA1AuthProtocol));

        /* if the given storage type is invalid, we give a default storage type NONVOLATILE
         */
        if ((entry->snmpv3_user_storage_type < VAL_usmUserStorageType_other) ||
            (entry->snmpv3_user_storage_type > VAL_usmUserStorageType_readOnly))
        {
            newuser->userStorageType = VAL_usmUserStorageType_nonVolatile;
            snmp_mgr_remote_user_entry[available_entry].snmpv3_user_storage_type =
                VAL_usmUserStorageType_nonVolatile;
        }
        else
        {
            newuser->userStorageType = entry->snmpv3_user_storage_type;
            snmp_mgr_remote_user_entry[available_entry].snmpv3_user_storage_type =
                entry->snmpv3_user_storage_type;
        }

        /* if the given storage type is invalid, we give a default storage type NONVOLATILE
         */
        if ((entry->snmpv3_user_storage_type < VAL_usmUserStorageType_other) ||
            (entry->snmpv3_user_storage_type > VAL_usmUserStorageType_readOnly))
        {
            newuser->userStorageType = VAL_usmUserStorageType_nonVolatile;
        }
        else
        {
            newuser->userStorageType = entry->snmpv3_user_storage_type;
        }

        newuser->userSecLevel = entry->snmpv3_user_security_level;

        /* auth key
         */
        memdup((u_char **)&newuser->authKey,
               (u_char *)snmp_mgr_remote_user_entry[available_entry].snmpv3_user_auth_key,
               snmp_mgr_remote_user_entry[available_entry].snmpv3_user_auth_key_len);
        newuser->authKeyLen = snmp_mgr_remote_user_entry[available_entry].snmpv3_user_auth_key_len;

        /* priv key
         */
        memdup((u_char **)&newuser->privKey,
               (u_char *)snmp_mgr_remote_user_entry[available_entry].snmpv3_user_priv_key,
               snmp_mgr_remote_user_entry[available_entry].snmpv3_user_priv_key_len);
        newuser->privKeyLen = snmp_mgr_remote_user_entry[available_entry].snmpv3_user_priv_key_len;
        usm_add_user(newuser);
    }



    return ret;

}

/* ---------------------------------------------------------------------
 * ROUTINE NAME  - SNMP_MGR_DeleteSnmpRemoteUser
 * ---------------------------------------------------------------------
 * PURPOSE: This function will delete the Snmp Remote User
 * INPUT : entry
 * OUTPUT: None
 * RETURN: SNMP_MGR_ERROR_OK/SNMP_MGR_ERROR_FAIL
 * NOTES : none
 * ---------------------------------------------------------------------
 */
UI32_T SNMP_MGR_DeleteSnmpRemoteUser(SNMP_MGR_SnmpV3UserEntry_T *entry)
{
    UI32_T  i;
    I32_T   available_entry = -1;
    UI32_T  return_val = FALSE;
    UI32_T orig_priority;

    /* BODY */
    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);

    entry->snmpv3_user_status = VAL_usmUserStatus_destroy;

    /* find remote user
     */
    for (i=0; i<SNMP_MGR_MAX_NBR_OF_REMOTE_USER; i++)
    {
        /* check user
         */

        if ( (strcmp(entry->snmpv3_user_name, snmp_mgr_remote_user_entry[i].snmpv3_user_name)==0)&&
             (memcmp(entry->snmpv3_user_engine_id, snmp_mgr_remote_user_entry[i].snmpv3_user_engine_id, entry->snmpv3_user_engineIDLen) == 0))
        {
            if (snmp_mgr_remote_user_entry[i].snmpv3_user_status == entry->snmpv3_user_status)//if specific entry already exist, and the status already the same as u want to set now, return false
            {
                i=SNMP_MGR_MAX_NBR_OF_REMOTE_USER;
                available_entry=-1;
            }
            else
            {
                available_entry = i;
            }
            break;
        }

        /* invalid entry
         */
        if (snmp_mgr_remote_user_entry[i].snmpv3_user_status == VAL_usmUserStatus_destroy)
        {
            /* record the first empty entry.  When the entry is not existed, this
             * entry will be updated as the input.
             */
            if (available_entry == -1)
                available_entry = i;
            continue;
        }


        /* check user
         */
        if ( (strcmp(entry->snmpv3_user_name, snmp_mgr_remote_user_entry[i].snmpv3_user_name)==0)&&
             (memcmp(entry->snmpv3_user_engine_id, snmp_mgr_remote_user_entry[i].snmpv3_user_engine_id, entry->snmpv3_user_engineIDLen) == 0))
            break;
    }

    /* for-loop finished; not found
     */
    if (i == SNMP_MGR_MAX_NBR_OF_REMOTE_USER)
    {
        /* No found, create a new one, if no more available entry then return FALSE
         */
        if (available_entry != -1)
        {
            strcpy(snmp_mgr_remote_user_entry[available_entry].snmpv3_user_name,entry->snmpv3_user_name);
            memset(snmp_mgr_remote_user_entry[available_entry].snmpv3_user_engine_id,0,MAXSIZE_snmpEngineID);
            memcpy(snmp_mgr_remote_user_entry[available_entry].snmpv3_user_engine_id,entry->snmpv3_user_engine_id,entry->snmpv3_user_engineIDLen);
            snmp_mgr_remote_user_entry[available_entry].snmpv3_user_engineIDLen=	entry->snmpv3_user_engineIDLen;
            strcpy(snmp_mgr_remote_user_entry[available_entry].snmpv3_user_auth_password,entry->snmpv3_user_auth_password);
            strcpy(snmp_mgr_remote_user_entry[available_entry].snmpv3_user_priv_password,entry->snmpv3_user_priv_password);
            snmp_mgr_remote_user_entry[available_entry].snmpv3_user_status = VAL_usmUserStatus_destroy;
            return_val = SNMP_MGR_ERROR_OK;
        }
        else
        {
            /* no available entry, can not create new entry
             */
            return_val = SNMP_MGR_ERROR_FAIL;
        }
    }

    /* found existing
     */
    else
    {
        /* found an entry, update status.  By logically, it should be deleted.
         */
        snmp_mgr_remote_user_entry[available_entry].snmpv3_user_status = VAL_usmUserStatus_destroy;

        /* default version set to 1 */
        return_val = SNMP_MGR_ERROR_OK;
    }



       /* delete the usm Entry*/
    if (return_val == SNMP_MGR_ERROR_OK)
    {

        SNMP_MGR_DeleteUsmUserEntryWithEngineID(snmp_mgr_remote_user_entry[available_entry].snmpv3_user_engine_id,
                                                snmp_mgr_remote_user_entry[available_entry].snmpv3_user_engineIDLen,
                                                (UI8_T *)snmp_mgr_remote_user_entry[available_entry].snmpv3_user_name);
    }

    return return_val;
}

/* ---------------------------------------------------------------------
 * ROUTINE NAME  - SNMP_MGR_GetSnmpRemoteUserEntry
 * ---------------------------------------------------------------------
 * PURPOSE: This function will get the Snmp Remote User entry
 * INPUT : user_entry
 * OUTPUT: user_entry
 * RETURN: SNMP_MGR_ERROR_OK/SNMP_MGR_ERROR_FAIL
 * NOTES : none
 * ---------------------------------------------------------------------
 */
UI32_T SNMP_MGR_GetSnmpRemoteUserEntry (SNMP_MGR_SnmpV3UserEntry_T *user_entry)
{
    UI32_T  i;
    UI32_T orig_priority;


    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);



    /* find remote user
     */
    for (i=0; i<SNMP_MGR_MAX_NBR_OF_REMOTE_USER; i++)
    {
        /* invalid entry
         */
        if (snmp_mgr_remote_user_entry[i].snmpv3_user_status == VAL_usmUserStatus_destroy)
            continue;

        /* valid entry
         */
        if ( (strcmp(user_entry->snmpv3_user_name, snmp_mgr_remote_user_entry[i].snmpv3_user_name)==0)&&
             (memcmp(user_entry->snmpv3_user_engine_id, snmp_mgr_remote_user_entry[i].snmpv3_user_engine_id, user_entry->snmpv3_user_engineIDLen) == 0))
            break;
    }

    if (i == SNMP_MGR_MAX_NBR_OF_REMOTE_USER)
    {


        return SNMP_MGR_ERROR_FAIL;
    }

    *user_entry = snmp_mgr_remote_user_entry[i];



    return SNMP_MGR_ERROR_OK;
}

/* ---------------------------------------------------------------------
 * ROUTINE NAME  - SNMP_MGR_GetNextSnmpRemoteUserEntry
 * ---------------------------------------------------------------------
 * PURPOSE: This function will getnext the Snmp Remote User entry
 * INPUT : user_entry
 * OUTPUT: user_entry
 * RETURN: SNMP_MGR_ERROR_OK/SNMP_MGR_ERROR_FAIL
 * NOTES : none
 * ---------------------------------------------------------------------
 */
UI32_T SNMP_MGR_GetNextSnmpRemoteUserEntry (SNMP_MGR_SnmpV3UserEntry_T *user_entry)
{
    SNMP_MGR_SnmpV3UserEntry_T     tmp_entry;
    UI32_T                      i,j;
    BOOL_T                      found=FALSE;
    oid                         oid1[MAXSIZE_snmpEngineID+MAXSIZE_usmUserName+2];
    oid                         oid2[MAXSIZE_snmpEngineID+MAXSIZE_usmUserName+2];
    oid                         oid3[MAXSIZE_snmpEngineID+MAXSIZE_usmUserName+2];
    UI32_T                      oid1Len;
    UI32_T                      oid2Len;
    UI32_T                      oid3Len;
    UI32_T orig_priority;

    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);



       /* We put oid1 as database, oid2 as input entry, oid3 as tmp entry*/
        memset(oid1, 0, sizeof(UI32_T) *MAXSIZE_snmpEngineID+MAXSIZE_usmUserName+2);
        memset(oid2, 0, sizeof(UI32_T) *MAXSIZE_snmpEngineID+MAXSIZE_usmUserName+2);
        memset(oid3, 0, sizeof(UI32_T) *MAXSIZE_snmpEngineID+MAXSIZE_usmUserName+2);
        oid1Len=0;
        oid2Len=0;
        oid3Len=0;
        /* puting oid2 start */
        oid2[0] = user_entry->snmpv3_user_engineIDLen;
        for (j = 0; j< user_entry->snmpv3_user_engineIDLen; j++)
        {
            oid2[j+1] = (UI32_T) user_entry->snmpv3_user_engine_id[j];
        }
        oid2[user_entry->snmpv3_user_engineIDLen+1]= strlen(user_entry->snmpv3_user_name);

        for (j = 0; j< strlen(user_entry->snmpv3_user_name); j++)
        {
            oid2[user_entry->snmpv3_user_engineIDLen+2+j] = (UI32_T) user_entry->snmpv3_user_name[j];
        }
        oid2Len = strlen(user_entry->snmpv3_user_name)+ user_entry->snmpv3_user_engineIDLen+2;
        /* puting oid2 end */

        /* find remote user
         */
        for (i=0; i<SNMP_MGR_MAX_NBR_OF_REMOTE_USER; i++)
        {
            /* invalid entry
             */
            if (snmp_mgr_remote_user_entry[i].snmpv3_user_status == VAL_usmUserStatus_destroy)
                continue;

            /* valid entry
             */
            /* puting oid1 start */
            oid1[0] = snmp_mgr_remote_user_entry[i].snmpv3_user_engineIDLen;
            for (j = 0; j< snmp_mgr_remote_user_entry[i].snmpv3_user_engineIDLen; j++)
            {
                oid1[j+1] = (UI32_T) snmp_mgr_remote_user_entry[i].snmpv3_user_engine_id[j];
            }
            oid1[snmp_mgr_remote_user_entry[i].snmpv3_user_engineIDLen+1]= strlen(snmp_mgr_remote_user_entry[i].snmpv3_user_name);
            for (j = 0; j< strlen(snmp_mgr_remote_user_entry[i].snmpv3_user_name); j++)
            {
                oid1[snmp_mgr_remote_user_entry[i].snmpv3_user_engineIDLen+2+j] = (UI32_T) snmp_mgr_remote_user_entry[i].snmpv3_user_name[j];
            }
            oid1Len = strlen(snmp_mgr_remote_user_entry[i].snmpv3_user_name)+ snmp_mgr_remote_user_entry[i].snmpv3_user_engineIDLen+2;
            /* puting oid1 end */

            /* We compare oid1(database) with the oid2(input entry)*/
            if (snmp_oid_compare(oid1, oid1Len, oid2, oid2Len) <= 0)
               continue;

            if (found == FALSE)
            {
                found = TRUE;
                tmp_entry = snmp_mgr_remote_user_entry[i];
                /* copying oid1 into oid3 */
                memcpy(oid3, oid1, sizeof(UI32_T)*oid1Len);
                oid3Len = oid1Len;
            }

            /* We now compare oid1 and oid3, oid1 and oid2*/
            if ((snmp_oid_compare(oid1, oid1Len, oid3, oid3Len) < 0) &&
                (snmp_oid_compare(oid1, oid1Len, oid2, oid2Len)> 0))
            {
                tmp_entry = snmp_mgr_remote_user_entry[i];
                /* copying oid1 into oid3 */
                memcpy(oid3, oid1, sizeof(UI32_T)*oid1Len);
                oid3Len = oid1Len;
            }
        }



        if (found == TRUE)
        {
            *user_entry = tmp_entry;

            return SNMP_MGR_ERROR_OK;
        }

    return SNMP_MGR_ERROR_FAIL;
}

/* ---------------------------------------------------------------------
 * ROUTINE NAME  - SNMP_MGR_GetNextRunningSnmpRemoteUserEntry
 * ---------------------------------------------------------------------
 * PURPOSE: This function will getnext  the Snmp Remote User entry for cli running config
 * INPUT : user_entry
 * OUTPUT: user_entry
 * RETURN: SYS_TYPE_GET_RUNNING_CFG_FAIL/SYS_TYPE_GET_RUNNING_CFG_SUCCESS
 * NOTES : none
 * ---------------------------------------------------------------------
 */
UI32_T SNMP_MGR_GetNextRunningSnmpRemoteUserEntry (SNMP_MGR_SnmpV3UserEntry_T *user_entry)
{
    SNMP_MGR_SnmpV3UserEntry_T     tmp_entry;
    UI32_T                      i,j;
    BOOL_T                      found=FALSE;
    oid                         oid1[MAXSIZE_snmpEngineID+MAXSIZE_usmUserName+2];
    oid                         oid2[MAXSIZE_snmpEngineID+MAXSIZE_usmUserName+2];
    oid                         oid3[MAXSIZE_snmpEngineID+MAXSIZE_usmUserName+2];
    UI32_T                      oid1Len;
    UI32_T                      oid2Len;
    UI32_T                      oid3Len;
    UI32_T orig_priority;

    SNMP_MGR_CHECK_OPER_MODE(SYS_TYPE_GET_RUNNING_CFG_FAIL);


       /* We put oid1 as database, oid2 as input entry, oid3 as tmp entry*/
        memset(oid1, 0, sizeof(UI32_T) *MAXSIZE_snmpEngineID+MAXSIZE_usmUserName+2);
        memset(oid2, 0, sizeof(UI32_T) *MAXSIZE_snmpEngineID+MAXSIZE_usmUserName+2);
        memset(oid3, 0, sizeof(UI32_T) *MAXSIZE_snmpEngineID+MAXSIZE_usmUserName+2);
        oid1Len=0;
        oid2Len=0;
        oid3Len=0;

        /* puting oid2 start */
        oid2[0] = user_entry->snmpv3_user_engineIDLen;
        for (j = 0; j< user_entry->snmpv3_user_engineIDLen; j++)
        {
            oid2[j+1] = (UI32_T) user_entry->snmpv3_user_engine_id[j];
        }
        oid2[user_entry->snmpv3_user_engineIDLen+1]= strlen(user_entry->snmpv3_user_name);

        for (j = 0; j< strlen(user_entry->snmpv3_user_name); j++)
        {
            oid2[user_entry->snmpv3_user_engineIDLen+2+j] = (UI32_T) user_entry->snmpv3_user_name[j];
        }
        oid2Len = strlen(user_entry->snmpv3_user_name)+ user_entry->snmpv3_user_engineIDLen+2;
        /* puting oid2 end */

        /* find remote user
         */
        for (i=0; i<SNMP_MGR_MAX_NBR_OF_REMOTE_USER; i++)
        {
            /* invalid entry
             */
            if (snmp_mgr_remote_user_entry[i].snmpv3_user_status == VAL_usmUserStatus_destroy)
                continue;

            /* volatile entry
             */
            if (snmp_mgr_remote_user_entry[i].snmpv3_user_storage_type == VAL_usmUserStorageType_volatile)
                continue;

            /* valid entry
             */
            /* puting oid1 start */
            oid1[0] = snmp_mgr_remote_user_entry[i].snmpv3_user_engineIDLen;
            for (j = 0; j< snmp_mgr_remote_user_entry[i].snmpv3_user_engineIDLen; j++)
            {
                oid1[j+1] = (UI32_T) snmp_mgr_remote_user_entry[i].snmpv3_user_engine_id[j];
            }
            oid1[snmp_mgr_remote_user_entry[i].snmpv3_user_engineIDLen+1]= strlen(snmp_mgr_remote_user_entry[i].snmpv3_user_name);
            for (j = 0; j< strlen(snmp_mgr_remote_user_entry[i].snmpv3_user_name); j++)
            {
                oid1[snmp_mgr_remote_user_entry[i].snmpv3_user_engineIDLen+2+j] = (UI32_T) snmp_mgr_remote_user_entry[i].snmpv3_user_name[j];
            }
            oid1Len = strlen(snmp_mgr_remote_user_entry[i].snmpv3_user_name)+ snmp_mgr_remote_user_entry[i].snmpv3_user_engineIDLen+2;
            /* puting oid1 end */

            /* We compare oid1(database) with the oid2(input entry)*/
            if (snmp_oid_compare(oid1, oid1Len, oid2, oid2Len) <= 0)
               continue;

            if (found == FALSE)
            {
                found = TRUE;
                tmp_entry = snmp_mgr_remote_user_entry[i];
                /* copying oid1 into oid3 */
                memcpy(oid3, oid1, sizeof(UI32_T)*oid1Len);
                oid3Len = oid1Len;
            }

            /* We now compare oid1 and oid3, oid1 and oid2*/
            if ((snmp_oid_compare(oid1, oid1Len, oid3, oid3Len) < 0) &&
                (snmp_oid_compare(oid1, oid1Len, oid2, oid2Len)> 0))
            {
                tmp_entry = snmp_mgr_remote_user_entry[i];
                /* copying oid1 into oid3 */
                memcpy(oid3, oid1, sizeof(UI32_T)*oid1Len);
                oid3Len = oid1Len;
            }
        }



        if (found == TRUE)
        {
            *user_entry = tmp_entry;

            return SYS_TYPE_GET_RUNNING_CFG_SUCCESS;
        }

    return SYS_TYPE_GET_RUNNING_CFG_FAIL;
}

/* ---------------------------------------------------------------------
 * ROUTINE NAME  - SNMP_MGR_CreateRemoteEngineID
 * ---------------------------------------------------------------------
 * PURPOSE: This function will create the remote engineID Entry
 * INPUT : user_entry
 * OUTPUT: none
 * RETURN: SNMP_MGR_ERROR_OK/SNMP_MGR_ERROR_FAIL
 * NOTES : none
 * ---------------------------------------------------------------------
 */
UI32_T
SNMP_MGR_CreateRemoteEngineID(
    SNMP_MGR_SnmpRemoteEngineID_T *entry)
{
    UI32_T  i;
    I32_T   available_entry = -1;
    UI32_T  return_val = SNMP_MGR_ERROR_FAIL;
    UI32_T orig_priority;

    /* BODY */
    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);

    entry->snmp_remote_engineID_status = VAL_snmpTargetAddrRowStatus_active;

    if (IP_LIB_OK != IP_LIB_IsValidForRemoteIp((UI8_T *)&entry->snmp_remote_engineID_host)
        || (entry->snmp_remote_engineIDLen < MINSIZE_snmpEngineID)
        || (entry->snmp_remote_engineIDLen > MAXSIZE_snmpEngineID))
    {


        return SNMP_MGR_ERROR_FAIL;
    }

    /* find remote engine ID
     */
    for (i=0; i<SNMP_MGR_MAX_NBR_OF_REMOTE_ENGINEID; i++)
    {
        /* check engine ID
         */
        if (entry->snmp_remote_engineID_host == snmp_mgr_remote_engineID_entry[i].snmp_remote_engineID_host)
        {
            if (snmp_mgr_remote_engineID_entry[i].snmp_remote_engineID_status == entry->snmp_remote_engineID_status)//if specific entry already exist, and the status already the same as u want to set now, return false
            {
                i=SNMP_MGR_MAX_NBR_OF_REMOTE_ENGINEID;
                available_entry=-1;
            }
            else
            {
                available_entry = i;
            }
            break;
        }

        /* invalid entry
         */
        if (snmp_mgr_remote_engineID_entry[i].snmp_remote_engineID_status == VAL_snmpTargetAddrRowStatus_destroy)
        {
            /* record the first empty entry.  When the entry is not existed, this
             * entry will be updated as the input.
             */
            if (available_entry == -1)
                available_entry = i;
            continue;
        }

        /* check engine ID
         */
        if (entry->snmp_remote_engineID_host == snmp_mgr_remote_engineID_entry[i].snmp_remote_engineID_host)
           break;
    }

    /* for-loop finished; not found
     */
    if (i == SNMP_MGR_MAX_NBR_OF_REMOTE_ENGINEID)
    {
        /* No found, create a new one, if no more available entry then return FALSE
         */
        if (available_entry != -1)
        {
            snmp_mgr_remote_engineID_entry[available_entry].snmp_remote_engineID_host= entry->snmp_remote_engineID_host;
            memcpy(snmp_mgr_remote_engineID_entry[available_entry].snmp_remote_engineID ,entry->snmp_remote_engineID, entry->snmp_remote_engineIDLen);
            snmp_mgr_remote_engineID_entry[available_entry].snmp_remote_engineIDLen= entry->snmp_remote_engineIDLen;
            snmp_mgr_remote_engineID_entry[available_entry].snmp_remote_engineID_status = VAL_snmpTargetAddrRowStatus_active;
            return_val = SNMP_MGR_ERROR_OK;
        }
        else
        {
            return_val = SNMP_MGR_ERROR_FAIL;
        }
    }

    /* found existing
     */
    else
    {
        snmp_mgr_remote_engineID_entry[available_entry].snmp_remote_engineID_host= entry->snmp_remote_engineID_host;
        memcpy(snmp_mgr_remote_engineID_entry[available_entry].snmp_remote_engineID ,entry->snmp_remote_engineID, entry->snmp_remote_engineIDLen);
        snmp_mgr_remote_engineID_entry[available_entry].snmp_remote_engineIDLen= entry->snmp_remote_engineIDLen;
        snmp_mgr_remote_engineID_entry[available_entry].snmp_remote_engineID_status = VAL_snmpTargetAddrRowStatus_active;
        return_val = SNMP_MGR_ERROR_OK;
    }



    return return_val;

} /* end of SNMP_MGR_CreateRemoteEngineID() */

/* ---------------------------------------------------------------------
 * ROUTINE NAME  - SNMP_MGR_DeleteRemoteEngineID
 * ---------------------------------------------------------------------
 * PURPOSE: This function will delete the remote engineID Entry
 * INPUT : user_entry
 * OUTPUT: none
 * RETURN: SNMP_MGR_ERROR_FAIL/SNMP_MGR_ERROR_OK
 * NOTES : remove the remote EngineID Entry and all users which engineID assoiate on it
 * ---------------------------------------------------------------------
 */
UI32_T SNMP_MGR_DeleteRemoteEngineID(SNMP_MGR_SnmpRemoteEngineID_T *entry)
{
    UI32_T  i;
    I32_T   available_entry = -1;
    UI32_T  return_val = FALSE;
    UI32_T orig_priority;

    /* BODY */
    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);

    entry->snmp_remote_engineID_status = VAL_snmpTargetAddrRowStatus_destroy;

    /* find remote engine ID
     */
    for (i=0; i<SNMP_MGR_MAX_NBR_OF_REMOTE_ENGINEID; i++)
    {
        /* check engine ID
         */
        if (entry->snmp_remote_engineID_host == snmp_mgr_remote_engineID_entry[i].snmp_remote_engineID_host)
        {
            if (snmp_mgr_remote_engineID_entry[i].snmp_remote_engineID_status == entry->snmp_remote_engineID_status)//if specific entry already exist, and the status already the same as u want to set now, return false
            {
                i=SNMP_MGR_MAX_NBR_OF_REMOTE_ENGINEID;
                available_entry=-1;
            }
            else
            {
                available_entry = i;
            }
            break;
        }

        /* invalid entry
         */
        if (snmp_mgr_remote_engineID_entry[i].snmp_remote_engineID_status == VAL_snmpTargetAddrRowStatus_destroy)
        {
            /* record the first empty entry.  When the entry is not existed, this
             * entry will be updated as the input.
             */
            if (available_entry == -1)
                available_entry = i;
            continue;
        }

        /* check engine ID
         */
        if (entry->snmp_remote_engineID_host == snmp_mgr_remote_engineID_entry[i].snmp_remote_engineID_host)
            break;
    }

    /* for-loop finished; not found
     */
    if (i == SNMP_MGR_MAX_NBR_OF_REMOTE_ENGINEID)
    {
        /* No found, create a new one, if no more available entry then return FALSE
         */
        if (available_entry != -1)
        {
            snmp_mgr_remote_engineID_entry[available_entry].snmp_remote_engineID_host= entry->snmp_remote_engineID_host;
            memcpy(snmp_mgr_remote_engineID_entry[available_entry].snmp_remote_engineID ,entry->snmp_remote_engineID, entry->snmp_remote_engineIDLen);
            snmp_mgr_remote_engineID_entry[available_entry].snmp_remote_engineID_status = VAL_snmpTargetAddrRowStatus_destroy;
            return_val = SNMP_MGR_ERROR_OK;
        }
        else
        {
            /* no available entry, can not create new entry
             */
            return_val = SNMP_MGR_ERROR_FAIL;
        }
    }

    /* found existing
     */
    else
    {
        /* found an entry, update status.  By logically, it should be deleted.
         */
        snmp_mgr_remote_engineID_entry[available_entry].snmp_remote_engineID_status = VAL_snmpTargetAddrRowStatus_destroy;
        /* default version set to 1 */
        snmp_mgr_remote_engineID_entry[available_entry].snmp_remote_engineID_host= entry->snmp_remote_engineID_host;
        memcpy(snmp_mgr_remote_engineID_entry[available_entry].snmp_remote_engineID ,entry->snmp_remote_engineID, entry->snmp_remote_engineIDLen);
        return_val = SNMP_MGR_ERROR_OK;
    }

    /* delete all users which engineID assoiate on it*/
    if (return_val == SNMP_MGR_ERROR_OK)
    {
        for (i = 0; i<= SNMP_MGR_MAX_NBR_OF_REMOTE_USER; i++)
        {
            if (memcmp(snmp_mgr_remote_user_entry[i].snmpv3_user_engine_id, snmp_mgr_remote_engineID_entry[available_entry].snmp_remote_engineID, snmp_mgr_remote_engineID_entry[available_entry].snmp_remote_engineIDLen)==0)
            {
                snmp_mgr_remote_user_entry[i].snmpv3_user_status = VAL_usmUserStatus_destroy;
            }
        }
    }



    return return_val;
}


/* ---------------------------------------------------------------------
 * ROUTINE NAME  - SNMP_MGR_DeleteRemoteEngineIDEntry
 * ---------------------------------------------------------------------
 * PURPOSE: This function will delete the remote engineID Entry
 * INPUT : user_entry
 * OUTPUT: none
 * RETURN: SNMP_MGR_ERROR_FAIL/SNMP_MGR_ERROR_OK
 * NOTES : Only remove the remote EngineID Entry
 * ---------------------------------------------------------------------
 */
UI32_T SNMP_MGR_DeleteRemoteEngineIDEntry(SNMP_MGR_SnmpRemoteEngineID_T *entry)
{
    UI32_T  i;
    I32_T   available_entry = -1;
    UI32_T  return_val = FALSE;
    UI32_T orig_priority;

    /* BODY */
    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);

    entry->snmp_remote_engineID_status = VAL_snmpTargetAddrRowStatus_destroy;

    /* find remote engine ID
     */
    for (i=0; i<SNMP_MGR_MAX_NBR_OF_REMOTE_ENGINEID; i++)
    {
        /* check engine ID
         */
        if (entry->snmp_remote_engineID_host == snmp_mgr_remote_engineID_entry[i].snmp_remote_engineID_host)
        {
            if (snmp_mgr_remote_engineID_entry[i].snmp_remote_engineID_status == entry->snmp_remote_engineID_status)//if specific entry already exist, and the status already the same as u want to set now, return false
            {
                i=SNMP_MGR_MAX_NBR_OF_REMOTE_ENGINEID;
                available_entry=-1;
            }
            else
            {
                available_entry = i;
            }
            break;
        }

        /* invalid entry
         */
        if (snmp_mgr_remote_engineID_entry[i].snmp_remote_engineID_status == VAL_snmpTargetAddrRowStatus_destroy)
        {
            /* record the first empty entry.  When the entry is not existed, this
             * entry will be updated as the input.
             */
            if (available_entry == -1)
                available_entry = i;
            continue;
        }

        /* check engine ID
         */
        if (entry->snmp_remote_engineID_host == snmp_mgr_remote_engineID_entry[i].snmp_remote_engineID_host)
            break;
    }

    /* for-loop finished; not found
     */
    if (i == SNMP_MGR_MAX_NBR_OF_REMOTE_ENGINEID)
    {
        /* No found, create a new one, if no more available entry then return FALSE
         */
        if (available_entry != -1)
        {
            snmp_mgr_remote_engineID_entry[available_entry].snmp_remote_engineID_host= entry->snmp_remote_engineID_host;
            memcpy(snmp_mgr_remote_engineID_entry[available_entry].snmp_remote_engineID ,entry->snmp_remote_engineID, entry->snmp_remote_engineIDLen);
            snmp_mgr_remote_engineID_entry[available_entry].snmp_remote_engineID_status = VAL_snmpTargetAddrRowStatus_destroy;
            return_val = SNMP_MGR_ERROR_OK;
        }
        else
        {
            /* no available entry, can not create new entry
             */
            return_val = SNMP_MGR_ERROR_FAIL;
        }
    }

    /* found existing
     */
    else
    {
        /* found an entry, update status.  By logically, it should be deleted.
         */
        snmp_mgr_remote_engineID_entry[available_entry].snmp_remote_engineID_status = VAL_snmpTargetAddrRowStatus_destroy;
        /* default version set to 1 */
        snmp_mgr_remote_engineID_entry[available_entry].snmp_remote_engineID_host= entry->snmp_remote_engineID_host;
        memcpy(snmp_mgr_remote_engineID_entry[available_entry].snmp_remote_engineID ,entry->snmp_remote_engineID, entry->snmp_remote_engineIDLen);
        return_val = SNMP_MGR_ERROR_OK;
    }



    return return_val;
}


/* ---------------------------------------------------------------------
 * ROUTINE NAME  - SNMP_MGR_GetSnmpRemoteEngineIDEntry
 * ---------------------------------------------------------------------
 * PURPOSE: This function will get the remote engineID Entry
 * INPUT : entry
 * OUTPUT: entry
 * RETURN: SNMP_MGR_ERROR_OK/SNMP_MGR_ERROR_FAIL
 * NOTES : none
 * ---------------------------------------------------------------------
 */
UI32_T SNMP_MGR_GetSnmpRemoteEngineIDEntry (SNMP_MGR_SnmpRemoteEngineID_T *entry)
{
    UI32_T  i;
    UI32_T orig_priority;
    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);


    /* find remote engine ID
     */
    for (i=0; i<SNMP_MGR_MAX_NBR_OF_REMOTE_ENGINEID; i++)
    {
        /* invalid entry
         */
        if (snmp_mgr_remote_engineID_entry[i].snmp_remote_engineID_status == VAL_snmpTargetAddrRowStatus_destroy)
            continue;

        /* valid entry
         */
        if (entry->snmp_remote_engineID_host == snmp_mgr_remote_engineID_entry[i].snmp_remote_engineID_host)
            break;
    }

    if (i == SNMP_MGR_MAX_NBR_OF_REMOTE_ENGINEID)
    {


        return SNMP_MGR_ERROR_FAIL;
    }

    *entry = snmp_mgr_remote_engineID_entry[i];


    return SNMP_MGR_ERROR_OK;
}


/*--------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_GetNextSnmpRemoteEngineIDEntry
 *---------------------------------------------------------------------------
 * PURPOSE:  The GetNext function of the Remote EngineID entry.
 * INPUT:    entry.
 * OUTPUT:   entry
 * RETURN:   SNMP_MGR_ERROR_OK/SNMP_MGR_ERROR_FAIL
 * NOTE:     For SNMP Use only.
 *---------------------------------------------------------------------------
 */
UI32_T SNMP_MGR_GetNextSnmpRemoteEngineIDEntry( SNMP_MGR_SnmpRemoteEngineID_T *entry)
{
    SNMP_MGR_SnmpRemoteEngineID_T     tmp_entry;
    UI32_T                      i;
    BOOL_T                      found=FALSE;
    UI32_T orig_priority;

    memset(&tmp_entry, 0, sizeof(tmp_entry));
    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);


    /* find remote engine ID
     */
    for (i=0; i<SNMP_MGR_MAX_NBR_OF_REMOTE_ENGINEID; i++)
    {
        /* invalid entry
         */
        if (snmp_mgr_remote_engineID_entry[i].snmp_remote_engineID_status == VAL_snmpTargetAddrRowStatus_destroy)
            continue;

        /* valid entry
         */
        if (snmp_mgr_remote_engineID_entry[i].snmp_remote_engineID_host > entry->snmp_remote_engineID_host)
        {
            if (found == FALSE)
            {
                found = TRUE;
                tmp_entry = snmp_mgr_remote_engineID_entry[i];
            }

            if ( (snmp_mgr_remote_engineID_entry[i].snmp_remote_engineID_host < tmp_entry.snmp_remote_engineID_host) &&
                 (snmp_mgr_remote_engineID_entry[i].snmp_remote_engineID_host > entry->snmp_remote_engineID_host))
            {
                tmp_entry = snmp_mgr_remote_engineID_entry[i];
            }
        }
    }



    if (found == TRUE)
    {
        *entry = tmp_entry;

        return SNMP_MGR_ERROR_OK;
    }

    return SNMP_MGR_ERROR_FAIL;
}

/* end of Remote EngineID API*/


/*--------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_GetNextRunningSnmpRemoteEngineIDEntry
 *---------------------------------------------------------------------------
 * PURPOSE:  The GetNext Running Function of Remote EngineID Entry
 * INPUT:    entry.
 * OUTPUT:   entry
 * RETURN:   SYS_TYPE_GET_RUNNING_CFG_FAIL/SYS_TYPE_GET_RUNNING_CFG_SUCCESS
 * NOTE:     For SNMP Use only.
 *---------------------------------------------------------------------------
 */
UI32_T SNMP_MGR_GetNextRunningSnmpRemoteEngineIDEntry( SNMP_MGR_SnmpRemoteEngineID_T *entry)
{
    SNMP_MGR_SnmpRemoteEngineID_T     tmp_entry;
    UI32_T                      i;
    BOOL_T                      found=FALSE;
    UI32_T orig_priority;

    memset(&tmp_entry, 0, sizeof(tmp_entry));
    SNMP_MGR_CHECK_OPER_MODE(SYS_TYPE_GET_RUNNING_CFG_FAIL);



    /* find remote engine ID
     */
    for (i=0; i<SNMP_MGR_MAX_NBR_OF_REMOTE_ENGINEID; i++)
    {
        /* invalid entry
         */
        if (snmp_mgr_remote_engineID_entry[i].snmp_remote_engineID_status == VAL_snmpTargetAddrRowStatus_destroy)
            continue;

        /* volatile entry
         */
        if (snmp_mgr_remote_engineID_entry[i].snmp_remote_storage_type == VAL_snmpTargetAddrStorageType_volatile)
            continue;

        /* invalid entry
         */
        if (snmp_mgr_remote_engineID_entry[i].snmp_remote_engineID_host > entry->snmp_remote_engineID_host)
        {
            if (found == FALSE)
            {
                found = TRUE;
                tmp_entry = snmp_mgr_remote_engineID_entry[i];
            }

            if ( (snmp_mgr_remote_engineID_entry[i].snmp_remote_engineID_host < tmp_entry.snmp_remote_engineID_host) &&
                 (snmp_mgr_remote_engineID_entry[i].snmp_remote_engineID_host > entry->snmp_remote_engineID_host))
            {
                tmp_entry = snmp_mgr_remote_engineID_entry[i];
            }
        }
    }



    if (found == TRUE)
    {
        *entry = tmp_entry;

        return SYS_TYPE_GET_RUNNING_CFG_SUCCESS;
    }

    return SYS_TYPE_GET_RUNNING_CFG_FAIL;
}

/* end of Remote EngineID API*/

/*--------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_GetNextSnmpTargetAddrTable
 *---------------------------------------------------------------------------
 * PURPOSE:  This function will retrieve the next snmpTargetAddrTable in Rfc3413 Target MIB
 * INPUT:    entry->snmp_target_addr_name
 * OUTPUT:   entry.
 * RETURN:  1. success:    SNMP_MGR_ERROR_OK
 *          2. failure:    SNMP_MGR_ERROR_NO_ENTRY_EXIST
 *                         SNMP_MGR_ERROR_FAIL
 *
 * NOTE:    none.
 *---------------------------------------------------------------------------
 */
UI32_T SNMP_MGR_GetNextSnmpTargetAddrTable(SNMP_MGR_SnmpTargetAddrEntry_T *entry)
{
    static struct targetAddrTable_struct *tp;
    static struct targetAddrTable_struct *target_addr_list;
    UI32_T orig_priority;

    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);


   /* get the variable store in snmpTargetAddrEntry*/
    target_addr_list = get_addrTable();

    if (!target_addr_list)
    {


        return SNMP_MGR_ERROR_NO_ENTRY_EXIST;
    }

    if (strcmp(entry->snmp_target_addr_name, "" ) == 0)
   /* Get First */
    {
        strcpy(entry->snmp_target_addr_name, target_addr_list->name);
        if (target_addr_list->tDomain != NULL)
        {
            memcpy(entry->snmp_target_addr_tdomain, target_addr_list->tDomain, target_addr_list->tDomainLen * sizeof(oid));
            entry->snmp_target_addr_tdomain_len = target_addr_list->tDomainLen;
        }
        else
        {
            memset(entry->snmp_target_addr_tdomain, 0, 10);
            entry->snmp_target_addr_tdomain_len = 0;
        }
        if (target_addr_list->tAddress != NULL)
        {
            memcpy(entry->taddr.snmp_target_addr_taddress, target_addr_list->tAddress, target_addr_list->tAddressLen);
            entry->snmp_target_addr_len = target_addr_list->tAddressLen;
        }
        else
        {
            memset(entry->taddr.snmp_target_addr_taddress, 0, sizeof(entry->taddr.snmp_target_addr_taddress));
            entry->snmp_target_addr_len = 0;
        }
        entry->snmp_target_addr_timeout = (UI32_T)target_addr_list->timeout;
        entry->snmp_target_addr_retry_count = (UI32_T) target_addr_list->retryCount;
        if (target_addr_list->tagList != NULL)
        {
            strcpy((char *)entry->snmp_target_addr_tag_list, (char *)target_addr_list->tagList);
        }
        else
        {
            strcpy((char *)entry->snmp_target_addr_tag_list,"");
        }
        if (target_addr_list->params != NULL)
        {
            strcpy(entry->snmp_target_addr_params , (char *)target_addr_list->params);
        }
        else
        {
            strcpy(entry->snmp_target_addr_params, "");
        }
        entry->snmp_target_addr_storage_type = target_addr_list->storageType;
        entry->snmp_target_addr_row_status = target_addr_list->rowStatus;


        return SNMP_MGR_ERROR_OK;
    }
    else
    {
   /* find the next entry*/
        for (tp = target_addr_list; tp; tp = tp->next)
        {
            if (strcmp(tp->name, entry->snmp_target_addr_name) == 0)
            {
                break;
            }
        }
        if ((tp) && (tp->next))
        {
            tp = tp->next;
            strcpy(entry->snmp_target_addr_name, tp->name);
            if (tp->tDomain != NULL)
            {
                memcpy(entry->snmp_target_addr_tdomain, tp->tDomain, tp->tDomainLen * sizeof(oid));
                entry->snmp_target_addr_tdomain_len = tp->tDomainLen;
            }
            else
            {
                memset(entry->snmp_target_addr_tdomain, 0, 10);
                entry->snmp_target_addr_tdomain_len = 0;
            }
            if (tp->tAddress != NULL)
            {
                memcpy(entry->taddr.snmp_target_addr_taddress, tp->tAddress, tp->tAddressLen);
                entry->snmp_target_addr_len = tp->tAddressLen;
            }
            else
            {
                memset(entry->taddr.snmp_target_addr_taddress, 0, sizeof(entry->taddr.snmp_target_addr_taddress));
                entry->snmp_target_addr_len = 0;
            }
            entry->snmp_target_addr_timeout = (UI32_T)tp->timeout;
            entry->snmp_target_addr_retry_count = (UI32_T) tp->retryCount;
            strcpy((char *)entry->snmp_target_addr_tag_list, (char *)tp->tagList);
            if (tp->params != NULL)
            {
                strcpy(entry->snmp_target_addr_params, (char *)tp->params);
            }
            else
            {
                strcpy(entry->snmp_target_addr_params, "");
            }
            entry->snmp_target_addr_storage_type = tp->storageType;
            entry->snmp_target_addr_row_status = tp->rowStatus;


            return SNMP_MGR_ERROR_OK;
        }
        else
        {


            return SNMP_MGR_ERROR_FAIL;
        }
    }
}

/*-------------------------------------------------------------------
  -------  STATIC SUBPROGRAM BODIES ---------------------------------
  -------------------------------------------------------------------
 */
static BOOL_T SNMP_MGR_GetDefaultIpAddress(L_INET_AddrIp_T *ip_addr_p)
{
    L_INET_AddrIp_T default_ip_addr;  /* default IP address at "trial_index" */
    UI32_T trial_index, target_index = 0;  /* 0-based */
    BOOL_T ok_flag = TRUE;
    UI32_T orig_priority;



    /* for each candidate default IP address
     */
    for (trial_index = 0;
        trial_index < SYS_ADPT_MAX_NBR_OF_TRAP_RECEIVER;
        trial_index++)
    {
        /* compose IP address (1-based host-order integer):
         * 10.1.0.(trial_index+1)
         */
        memset(&default_ip_addr, 0, sizeof(default_ip_addr));
        default_ip_addr.addrlen = SYS_ADPT_IPV4_ADDR_LEN;
        default_ip_addr.type    = VAL_remoteLogServerInetAddressType_ipv4;
        default_ip_addr.addr[0] = 0x0a;
        default_ip_addr.addr[1] = 0x01;
        default_ip_addr.addr[2] = 0x00;
        default_ip_addr.addr[3] = target_index + 1;

        /* check for collision with existing trap receivers
         */
         ok_flag = TRUE;

        for (target_index = 0;
            target_index < SYS_ADPT_MAX_NBR_OF_TRAP_RECEIVER;
            target_index++)
        {
            if (snmp_mgr_trap_receiver[target_index].trap_dest_status
                == VAL_snmpTargetAddrRowStatus_active)
            {
                /* already used
                 */
                if (0 == L_INET_CompareInetAddr((L_INET_Addr_T *)&snmp_mgr_trap_receiver[target_index].trap_dest_address,
                    (L_INET_Addr_T *)&default_ip_addr, 0))
                {
                    ok_flag = FALSE;
                    break;  /* for (target_index) */
                }
            }
        }

        /* if this default value is usable
         */
        if (ok_flag)
        {
            break;  /* for (trial_index) */
        }
    }

    /* if usable default value is found, give to caller
     */
    if (ok_flag)
    {
        *ip_addr_p = default_ip_addr;

        return TRUE;
    }
    else
    {

        return FALSE;
    }
}

static void SNMP_MGR_InitNetSnmpAgent()
{
    BOOL_T init_flag;

    SNMP_MGR_GetNetSnmpInitFlag(&init_flag);
    if (!init_flag)
    {
        init_agent("snmpd");        /* do what we need to do first. */
        init_snmp("snmpd");
        init_mib_modules();
        SNMP_MGR_SetNetSnmpInitFlag(TRUE);

        memset(snmp_default_engine_id, 0, sizeof(snmp_default_engine_id));
        snmp_default_engine_id_len = snmpv3_get_engineID(snmp_default_engine_id,
            sizeof(snmp_default_engine_id));
    }
}


/* ---------------------------------------------------------------------
 * ROUTINE NAME  - SNMP_MGR_InitDefaultSetting
 * ---------------------------------------------------------------------
 * PURPOSE: This function will set all the config values which are belongs
 *          to TRAP_MGR to default value.
 * INPUT : None
 * OUTPUT: None
 * RETURN: None
 * NOTES : This is local function and only will be implemented by
 *         SNMP_MGR_EnterMasterMode()
 * ---------------------------------------------------------------------
 */
static void SNMP_MGR_InitDefaultSetting()
{
    UI32_T orig_priority;
        /* BODY */

    snmp_mgr_agent_status= TRUE;

    SNMP_MGR_InitUsmUserEntry();
    SNMP_MGR_InitVacmSecurityToGroupEntry();
    SNMP_MGR_InitVacmAccessEntry();
    SNMP_MGR_InitVacmViewTreeFamilyEntry();

#if (SYS_CPNT_USERAUTH_MANAGER_STYLE == SYS_CPNT_USERAUTH_MANAGER_STYLE_3COM)
    SNMP_MGR_InitSnmpV3ManagerView();
#endif

#if (SYS_CPNT_SNMPV3_DEFAULT_GROUP == TRUE)
    SNMP_MGR_InitSnmpV3Group();
#endif

#if (SYS_CPNT_CFGDB == TRUE)
#if (SYS_CPNT_SNMP_COMMUNITY_IN_CFGDB == TRUE)
    SNMP_MGR_InitSnmpV3User();
    SNMP_MGR_InitSnmpV3UserFromCfgDB();
#endif
#endif

    SNMP_MGR_InitSnmpCommunityEntry();
#if (SYS_CPNT_CFGDB == TRUE)
#if (SYS_CPNT_SNMP_COMMUNITY_IN_CFGDB == TRUE)
    SNMP_MGR_InitSnmpCommunityFromCfgDB();
#endif
    SNMP_MGR_InitSnmpEngineBoot();
#endif/* end of #if (SYS_CPNT_CFGDB == TRUE)*/
    /*Set RMON init flag to FALSE*/

    snmp_mgr_rmon_init_flag = FALSE;
    snmp_mgr_snmp_enable_authen_traps = SYS_DFLT_SNMP_ENABLE_AUTHEN_TRAPS;
    snmp_mgr_patch_netsnmp_parse_err_flag = FALSE;



    SNMP_MGR_InitSnmpTargetAddrEntry();
    SNMP_MGR_InitSnmpTargetParamsEntry();
    SNMP_MGR_InitSnmpNotifyEntry();
    SNMP_MGR_InitSnmpNotifyFilterEntry();
    SNMP_MGR_InitSnmpNotifyFilterProfileEntry();
    SNMP_MGR_InitSnmpRemoteEngineIDEntry();
    SNMP_MGR_InitSnmpRemoteUserEntry();
    /*Check default view, if it is not exit,we must create it.
     */
    SNMP_MGR_CheckDefaultCommunityView();
#if (SYS_CPNT_NOTIFICATIONLOG_MIB == TRUE)
/* Notification Log MIB -- Meiling Hou 2008.04.15 */
    NLM_MGR_InitiateSystemResources();
#endif
} /* end of SNMP_MGR_InitDefaultSetting() */


/* ---------------------------------------------------------------------
 * ROUTINE NAME  - SNMP_MGR_InitUsmUserEntry
 * ---------------------------------------------------------------------
 * PURPOSE: This function will init the Rfc3414 Usm user Entry
 * INPUT : None
 * OUTPUT: None
 * RETURN: none.
 * NOTES : This is local function and only will be implemented by
 *         SNMP_MGR_EnterMasterMode()
 * ---------------------------------------------------------------------
 */
static void SNMP_MGR_InitUsmUserEntry()
{
    struct usmUser *uptr, *tuptr, *userlist = NULL;
    UI32_T orig_priority;


    userlist = usm_get_userList();
    for (uptr = userlist; uptr != NULL;)
    {
        tuptr = uptr->next;
       /* delete  usergroup Table*/
        usm_remove_user(uptr);
        usm_free_user(uptr);
        uptr = tuptr;
    }

    return;
}

/* ---------------------------------------------------------------------
 * ROUTINE NAME  - SNMP_MGR_AppendNotifyView
 * ---------------------------------------------------------------------
 * PURPOSE: This function is for append the notifyview to a speicifc view
 *
 * INPUT: group_entry
 * OUTPUT: none
 * RETURN: SNMP_MGR_ERROR_OK;SNMP_MGR_ERROR_PARAMETER_NOT_MATCH;SNMP_MGR_ERROR_FAIL;
 * NOTES:1.none
 *
 * ---------------------------------------------------------------------
 */
static UI32_T SNMP_MGR_AppendNotifyView(SNMP_MGR_SnmpV3GroupEntry_T *group_entry)
{
    struct vacm_accessEntry *aptr = NULL;
    UI32_T orig_priority;

    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);

    aptr = vacm_getExactAccessEntry(group_entry->snmpv3_group_name,  "",  group_entry->snmpv3_group_model,  group_entry->snmpv3_group_security_level);
    if ( aptr)
    {

         strcpy(aptr->notifyView, "defaultview");


        return SNMP_MGR_ERROR_OK;
    }
    else
    {


        return SNMP_MGR_ERROR_FAIL;
    }


    return SNMP_MGR_ERROR_OK;
}

/* ---------------------------------------------------------------------
 *  ROUTINE NAME  - SNMP_MGR_BackdoorInfo_CallBack
 * ---------------------------------------------------------------------
 * PURPOSE: snmp back door main
 * INPUT:    cli_msgq_handle.
 * OUTPUT:   None.
 * RETURN:   None.
 * NOTE:     None.
 * ---------------------------------------------------------------------
 */
static void SNMP_BACKDOOR_Main(void)
{
    UI32_T backdoor_continue=TRUE;
    UI32_T backdoor_member_id;
    L_THREADGRP_Handle_T tg_handle;
    char ch;

    tg_handle=SNMP_PROC_COMM_GetSnmpGroupTGHandle();

    /* Join thread group
     */

    if(L_THREADGRP_Join(tg_handle, SYS_BLD_BACKDOOR_THREAD_PRIORITY, &backdoor_member_id)==FALSE)
    {
        SYSFUN_Debug_Printf("%s: L_THREADGRP_Join fail.\n", __FUNCTION__);
        return;
    }

    while (backdoor_continue)
    {
        if (debug_mode == TRUE)
        {
            BACKDOOR_MGR_Printf("\n\tDisable Debug Mode:1");
        }
        else
        {
        BACKDOOR_MGR_Printf("\n\tEnable Debug Mode:1");
        }

        if (trap_debug_mode == TRUE)
        {
            BACKDOOR_MGR_Printf("\n\tDisable Trap Debug Mode:2");
        }
        else
        {
            BACKDOOR_MGR_Printf("\n\tEnable Trap Debug Mode:2");
        }

        if (EHMsgEnable == TRUE)
        {
            BACKDOOR_MGR_Printf("\n\tDisable EH Message:3");
        }
        else
        {
        BACKDOOR_MGR_Printf("\n\tEnable EH Message:3");
        }

        BACKDOOR_MGR_Printf("\n\tQuit:Q\n");

        ch=(char)BACKDOOR_MGR_GetChar();

        switch (ch)
        {
            case '1':
                debug_mode = (debug_mode == TRUE)? FALSE: TRUE;

                if (debug_mode == TRUE)
                {
                    BACKDOOR_MGR_Printf("\n Debug mode is enable");
                }
                else
                {
                    BACKDOOR_MGR_Printf("\n Debug mode is disable");
                }

                break;
            case '2':
                trap_debug_mode = (trap_debug_mode == TRUE)? FALSE: TRUE;

                if (trap_debug_mode == TRUE)
                {
                    BACKDOOR_MGR_Printf("\n Trap Debug mode is enable");
                }
                else
                {
                    BACKDOOR_MGR_Printf("\n Trap Debug mode is disable");
                }

                break;
            case '3':
                EHMsgEnable = (EHMsgEnable == TRUE)? FALSE: TRUE;

                if (EHMsgEnable == TRUE)
                {
                    BACKDOOR_MGR_Printf("\n EH Message is enable");
                }
                else
                {
                    BACKDOOR_MGR_Printf("\n EH Message is disable");
                }

                break;
            case '4':
#if(SNMP_MGR_DEBUG_CONTROL==TRUE)
                if(SNMP_MGR_Debug_Flage==FALSE)
                {
                    SNMP_MGR_Debug_Flage=TRUE;
                    BACKDOOR_MGR_Printf("\n Debug_Flage is enable\n");
                }
                else
                {
                    SNMP_MGR_Debug_Flage=FALSE;
                    BACKDOOR_MGR_Printf("\n Debug_Flage is disable\n");
                }
#endif
                break;
            case 'Q':
            case 'q':
                backdoor_continue = FALSE;
                L_THREADGRP_Leave(tg_handle, backdoor_member_id);
                break;
            default:
                BACKDOOR_MGR_Printf("\n Invalid command\n");
                break;
        }
    }
}

#if 0 /* XXX steven.jiang for warnings */
/* ---------------------------------------------------------------------
 *  ROUTINE NAME  - SNMP_MGR_BackdoorInfo_CallBack
 * ---------------------------------------------------------------------
 * PURPOSE:
 * INPUT:    None.
 * OUTPUT:   None.
 * RETURN:   None.
 * NOTE:     None.
 * ---------------------------------------------------------------------
 */
static void SNMP_MGR_BackdoorInfo_CallBack(void)
{
    UI8_T ch;
    BOOL_T  backdoor_continue ;

    SYSFUN_Debug_Printf("\n Snmp Backdoor Selection");

    backdoor_continue = TRUE;

    while(backdoor_continue)
    {
        SNMP_MGR_Print_BackdoorHelp();
        ch = getchar();
        switch(ch)
        {
            case '1':
                debug_mode=TRUE;
                SYSFUN_Debug_Printf("\n Debug mode is enabled\n");
                break;
            case '2':
                debug_mode=FALSE;
                SYSFUN_Debug_Printf("\n Debug mode is disable\n");
                break;
            case '3':
                EHMsgEnable=TRUE;
                SYSFUN_Debug_Printf("\n EH Message is enabled\n");
                break;
            case '4':
                EHMsgEnable=FALSE;
                SYSFUN_Debug_Printf("\n EH Message is disable\n");
                break;
            case '5':
#if(SNMP_MGR_DEBUG_CONTROL==TRUE)
                if(SNMP_MGR_Debug_Flage==FALSE)
                {
                    SNMP_MGR_Debug_Flage=TRUE;
                    SYSFUN_Debug_Printf("\n Debug_Flage is enable\n");
                }
                else
                {
                    SNMP_MGR_Debug_Flage=FALSE;
                    SYSFUN_Debug_Printf("\n Debug_Flage is disable\n");
                }
#endif
                break;
             case 'Q':
             case 'q':
                 backdoor_continue = FALSE;
                 break;
             default:
                 SYSFUN_Debug_Printf("\n Invalid command\n");
                break;
        }
    }
    return;
}/* End of SNMP_MGR_BackdoorInfo_CallBack() */


/* ---------------------------------------------------------------------
 *  ROUTINE NAME  - SNMP_MGR_Print_BackdoorHelp
 * ---------------------------------------------------------------------
 * PURPOSE:
 * INPUT:    None.
 * OUTPUT:   None.
 * RETURN:   None.
 * NOTE:     None.
 * ---------------------------------------------------------------------
 */
static void SNMP_MGR_Print_BackdoorHelp(void)
{
    SYSFUN_Debug_Printf("\n\tEnable Debug Mode:1");
    SYSFUN_Debug_Printf("\n\tDisable Debug Mode:2");
    SYSFUN_Debug_Printf("\n\tEnable EH Message:3");
    SYSFUN_Debug_Printf("\n\tDisable EH Message:4");
    SYSFUN_Debug_Printf("\n\tDebug Flage control:5");
    SYSFUN_Debug_Printf("\n\tQuit:Q\n");
     return;
}
#endif /* 0 */

/* ---------------------------------------------------------------------
 * ROUTINE NAME  - SNMP_MGR_InitVacmSecurityToGroupEntry
 * ---------------------------------------------------------------------
 * PURPOSE: This function will init the Rfc3415 Vacm SecurityToGroup Entry
 * INPUT : None
 * OUTPUT: None
 * RETURN: none.
 * NOTES : This is local function and only will be implemented by
 *         SNMP_MGR_EnterMasterMode()
 * ---------------------------------------------------------------------
 */
static void SNMP_MGR_InitVacmSecurityToGroupEntry()
{
    UI32_T orig_priority;

    vacm_destroyAllGroupEntries();
    snmp_mgr_security_to_group_count=0;

    return;
}


/* ---------------------------------------------------------------------
 * ROUTINE NAME  - SNMP_MGR_InitVacmAccessEntry
 * ---------------------------------------------------------------------
 * PURPOSE: This function will init the Rfc3415 Vacm Access Entry
 * INPUT : None
 * OUTPUT: None
 * RETURN: none.
 * NOTES : This is local function and only will be implemented by
 *         SNMP_MGR_EnterMasterMode()
 * ---------------------------------------------------------------------
 */
static void SNMP_MGR_InitVacmAccessEntry()
{
    UI32_T orig_priority;

    vacm_destroyAllAccessEntries();
    snmp_mgr_group_count=0;

    return;
}

/* ---------------------------------------------------------------------
 * ROUTINE NAME  - SNMP_MGR_InitVacmViewTreeFamilyEntry
 * ---------------------------------------------------------------------
 * PURPOSE: This function will init the Rfc3415 Vacm Tree Family Entry
 * INPUT : None
 * OUTPUT: None
 * RETURN: none.
 * NOTES : This is local function and only will be implemented by
 *         SNMP_MGR_EnterMasterMode()
 * ---------------------------------------------------------------------
 */
static void SNMP_MGR_InitVacmViewTreeFamilyEntry()
{
    UI32_T orig_priority;

    vacm_destroyAllViewEntries();
    snmp_mgr_view_count=0;

    return;
}

/* ---------------------------------------------------------------------
 * ROUTINE NAME  - SNMP_MGR_InitSnmpTargetAddrEntry
 * ---------------------------------------------------------------------
 * PURPOSE: This function will init the Rfc3413 SnmpTargetAddrEntry.
 * INPUT : None
 * OUTPUT: None
 * RETURN: none.
 * NOTES : This is local function and only will be implemented by
 *         SNMP_MGR_EnterMasterMode()
 * ---------------------------------------------------------------------
 */
static void SNMP_MGR_InitSnmpTargetAddrEntry()
{
    SNMP_MGR_SnmpTargetAddrEntry_T  entry;
    UI32_T orig_priority;

    memset(&entry, 0, sizeof(entry));

    while (SNMP_MGR_GetNextSnmpTargetAddrTable(&entry) == SNMP_MGR_ERROR_OK)
    {
        SNMP_MGR_DeleteSnmpTargetAddrTable(entry.snmp_target_addr_name);
        memset(&entry, 0, sizeof(entry));
    }

    snmp_mgr_target_addr_count=0;

    return;
}


/* ---------------------------------------------------------------------
 * ROUTINE NAME  - SNMP_MGR_InitSnmpTargetParamsEntry
 * ---------------------------------------------------------------------
 * PURPOSE: This function will init the Rfc3413 SnmpTargetParamsEntry.
 * INPUT : None
 * OUTPUT: None
 * RETURN: none.
 * NOTES : This is local function and only will be implemented by
 *         SNMP_MGR_EnterMasterMode()
 * ---------------------------------------------------------------------
 */
static void SNMP_MGR_InitSnmpTargetParamsEntry()
{
    SNMP_MGR_SnmpTargetParamsEntry_T  entry;
    UI32_T orig_priority;

    memset(&entry, 0, sizeof(entry));

    while (SNMP_MGR_GetNextSnmpTargetParamsTable(&entry) == SNMP_MGR_ERROR_OK)
    {
        SNMP_MGR_DeleteSnmpTargetParamsTable(entry.snmp_target_params_name);
        memset(&entry, 0, sizeof(entry));
    }

    snmp_mgr_target_params_count=0;

    return;
}

/* ---------------------------------------------------------------------
 * ROUTINE NAME  - SNMP_MGR_InitSnmpNotifyEntry
 * ---------------------------------------------------------------------
 * PURPOSE: This function will init the Rfc3415 SnmpNotifyEntry.
 * INPUT : None
 * OUTPUT: None
 * RETURN: none.
 * NOTES : This is local function and only will be implemented by
 *         SNMP_MGR_EnterMasterMode()
 * ---------------------------------------------------------------------
 */
static void SNMP_MGR_InitSnmpNotifyEntry()
{
    SNMP_MGR_SnmpNotifyEntry_T  entry;
    UI32_T orig_priority;

    memset(&entry, 0, sizeof(entry));

    while (SNMP_MGR_GetNextSnmpNotifyTable(&entry) == SNMP_MGR_ERROR_OK)
    {
        SNMP_MGR_DeleteSnmpNotifyTable((UI8_T *)entry.snmp_notify_name);
        memset(&entry, 0, sizeof(entry));
    }

    snmp_mgr_notify_count=0;

    return;
}

/* ---------------------------------------------------------------------
 * ROUTINE NAME  - SNMP_MGR_InitSnmpNotifyFilterEntry
 * ---------------------------------------------------------------------
 * PURPOSE: This function will init the Rfc3415 SnmpNotifyEntry.
 * INPUT : None
 * OUTPUT: None
 * RETURN: none.
 * NOTES : This is local function and only will be implemented by
 *         SNMP_MGR_EnterMasterMode()
 * ---------------------------------------------------------------------
 */
static void SNMP_MGR_InitSnmpNotifyFilterEntry()
{
    SNMP_MGR_SnmpNotifyFilterEntry_T  entry;
    UI32_T orig_priority;

    memset(&entry, 0, sizeof(entry));

    while (SNMP_MGR_GetNextSnmpNotifyFilterTable(&entry) == SNMP_MGR_ERROR_OK)
    {
        SNMP_MGR_DeleteSnmpNotifyFilterTable(entry.snmp_notify_filter_profile_name,entry.snmp_notify_filter_subtree, entry.snmp_notify_filter_subtree_len );
        memset(&entry, 0, sizeof(entry));
    }

    snmp_mgr_notify_filter_count=0;

    return;
}

/* ---------------------------------------------------------------------
 * ROUTINE NAME  - SNMP_MGR_InitSnmpNotifyFilterProfileEntry
 * ---------------------------------------------------------------------
 * PURPOSE: This function will init the Rfc3415 SnmpNotifyEntry.
 * INPUT : None
 * OUTPUT: None
 * RETURN: none.
 * NOTES : This is local function and only will be implemented by
 *         SNMP_MGR_EnterMasterMode()
 * ---------------------------------------------------------------------
 */
static void SNMP_MGR_InitSnmpNotifyFilterProfileEntry()
{
    SNMP_MGR_SnmpNotifyFilterProfileEntry_T  entry;
    UI32_T orig_priority;

    memset(&entry, 0, sizeof(entry));

    while (SNMP_MGR_GetNextSnmpNotifyFilterProfileTable(&entry) == SNMP_MGR_ERROR_OK)
    {
        SNMP_MGR_DeleteSnmpNotifyFilterProfileTable(&entry);
        memset(&entry, 0, sizeof(entry));
    }

    snmp_mgr_notify_filter_profile_count=0;

    return;
}

/* ---------------------------------------------------------------------
 * ROUTINE NAME  - SNMP_MGR_InitSnmpCommunityEntry
 * ---------------------------------------------------------------------
 * PURPOSE: This function will init the Rfc2576 SnmpCommunityEntry.
 * INPUT : None
 * OUTPUT: None
 * RETURN: none.
 * NOTES : This is local function and only will be implemented by
 *         SNMP_MGR_EnterMasterMode()
 * ---------------------------------------------------------------------
 */
static void SNMP_MGR_InitSnmpCommunityEntry()
{
    int i;
    UI32_T orig_priority;

    for (i = 0; i<SYS_ADPT_MAX_NBR_OF_SNMP_COMMUNITY_STRING; i++)
    {
        snmp_mgr_comm_entry[i].snmp_community_status = VAL_snmpCommunityStatus_destroy;
    }

    netsnmp_udp_com2SecList_free();
    snmp_mgr_comm_count=0;

    return;
}


#if (SYS_CPNT_SNMPV3_DEFAULT_GROUP == TRUE)
/* ---------------------------------------------------------------------
 * ROUTINE NAME  - SNMP_MGR_InitSnmpV3Group
 * ---------------------------------------------------------------------
 * PURPOSE: This function will init and create 2 default groups
 * INPUT : None
 * OUTPUT: None
 * RETURN: none.
 * NOTES :
 * ---------------------------------------------------------------------
 */
static void SNMP_MGR_InitSnmpV3Group()
{
    SNMP_MGR_SnmpV3GroupEntry_T defaultgroup1;
    SNMP_MGR_SnmpV3GroupEntry_T defaultgroup2;

#if (SYS_CPNT_USERAUTH_MANAGER_STYLE == SYS_CPNT_USERAUTH_MANAGER_STYLE_3COM)
    SNMP_MGR_SnmpV3GroupEntry_T defaultgroup3;
#endif

    SNMP_MGR_SnmpV3GroupEntry_T group_noauth;
    SNMP_MGR_SnmpV3GroupEntry_T group_authnopriv;
    SNMP_MGR_SnmpV3GroupEntry_T group_authpriv;

    /* Default admin group
     */
    memset(&defaultgroup1, 0, sizeof(SNMP_MGR_SnmpV3GroupEntry_T));
    strcpy(defaultgroup1.snmpv3_group_name, SYS_DFLT_SNMPV3_ADMIN_GROUPNAME);
    defaultgroup1.snmpv3_group_model = SNMP_MGR_SNMPV3_MODEL_V3;
    defaultgroup1.snmpv3_group_security_level = SYS_DFLT_SNMPV3_ADMIN_GROUPLEVEL;
    strcpy(defaultgroup1.snmpv3_group_readview, "defaultview");
    strcpy(defaultgroup1.snmpv3_group_writeview, "defaultview");
    strcpy(defaultgroup1.snmpv3_group_notifyview, "defaultview");
    defaultgroup1.snmpv3_group_storage_type = VAL_vacmAccessStorageType_permanent;
    defaultgroup1.snmpv3_group_status = VAL_vacmAccessStatus_active;

    /* Default guest group
     */
    memset(&defaultgroup2, 0, sizeof(SNMP_MGR_SnmpV3GroupEntry_T));
    strcpy(defaultgroup2.snmpv3_group_name, SYS_DFLT_SNMPV3_GUEST_GROUPNAME);
    defaultgroup2.snmpv3_group_model = SNMP_MGR_SNMPV3_MODEL_V3;
    defaultgroup2.snmpv3_group_security_level = SYS_DFLT_SNMPV3_GUEST_GROUPLEVEL;
    strcpy(defaultgroup2.snmpv3_group_readview, "defaultview");
    strcpy(defaultgroup2.snmpv3_group_writeview, "");
    strcpy(defaultgroup2.snmpv3_group_notifyview, "");
    defaultgroup2.snmpv3_group_storage_type = VAL_vacmAccessStorageType_permanent;
    defaultgroup2.snmpv3_group_status = VAL_vacmAccessStatus_active;

    /* Default manager group
     */
#if (SYS_CPNT_USERAUTH_MANAGER_STYLE == SYS_CPNT_USERAUTH_MANAGER_STYLE_3COM)
    memset(&defaultgroup3, 0, sizeof(SNMP_MGR_SnmpV3GroupEntry_T));
    strcpy(defaultgroup3.snmpv3_group_name, SYS_DFLT_SNMPV3_MANAGER_GROUPNAME);
    defaultgroup3.snmpv3_group_model = SNMP_MGR_SNMPV3_MODEL_V3;
    defaultgroup3.snmpv3_group_security_level = SYS_DFLT_SNMPV3_MANAGER_GROUPLEVEL;
    strcpy(defaultgroup3.snmpv3_group_readview, "defaultview");
    strcpy(defaultgroup3.snmpv3_group_writeview, "managerwirteview");
    strcpy(defaultgroup3.snmpv3_group_notifyview, "defaultview");
    defaultgroup3.snmpv3_group_storage_type = VAL_vacmAccessStorageType_permanent;
    defaultgroup3.snmpv3_group_status = VAL_vacmAccessStatus_active;
#endif

    SNMP_MGR_CreateSnmpV3Group(&defaultgroup1, FALSE);
    SNMP_MGR_CreateSnmpV3Group(&defaultgroup2, FALSE);

#if (SYS_CPNT_USERAUTH_MANAGER_STYLE == SYS_CPNT_USERAUTH_MANAGER_STYLE_3COM)
    SNMP_MGR_CreateSnmpV3Group(&defaultgroup3, FALSE);
#endif

}
#endif

#if (SYS_CPNT_USERAUTH_MANAGER_STYLE == SYS_CPNT_USERAUTH_MANAGER_STYLE_3COM)
/* ---------------------------------------------------------------------
 * ROUTINE NAME  - SNMP_MGR_InitSnmpV3ManagerView
 * ---------------------------------------------------------------------
 * PURPOSE: This function is used to initalize SNMPv3 manager view for 3Com
 * INPUT : None
 * OUTPUT: None
 * RETURN: none.
 * NOTES :
 * ---------------------------------------------------------------------
 */
static void SNMP_MGR_InitSnmpV3ManagerView()
{
    int i;
    UI8_T   sys_adpt_privatemib_root[] = {SYS_ADPT_PRIVATEMIB_OID};
    UI8_T   *defaultview[] = {"defaultview included .1 80 volatile",
                              "end"};
    UI8_T   *managerwirteview[] = {"managerwirteview included .1 80 volatile" ,           /* main tree */
                              "managerwirteview excluded .1.3.6.1.2.1.31.1.1.1.14 FF:E0 volatile",   /* ifLinkUpDownTrapEnable */
                              "managerwirteview excluded .1.3.6.1.2.1.23.3 FF volatile",             /* rip2IfConfTable */
                              "managerwirteview excluded .1.3.6.1.2.1.67 FE volatile",               /* radiusMIB */
                              "end"};
    UI8_T   private_mib_view[SYS_ADPT_MAX_OID_STRING_LEN] = {0};
    UI8_T   result_str[SYS_ADPT_MAX_OID_STRING_LEN], tmpstr[128] = {0};
    UI32_T orig_priority;




    /* Create managerwirteview */
    for(i = 0; strcmp(managerwirteview[i], "end") != 0; i++)
    {
        if(vacm_parse_view("view", managerwirteview[i]))
        {
            puts("vacm_parse_view_error");
        }
    }

    /* managerwirteview excluded for specify tree node */
    sprintf(private_mib_view, "managerwirteview excluded ");
    for(i = 0; i < sizeof(sys_adpt_privatemib_root); i++)
    {
        strcat(private_mib_view, ".");
        sprintf(tmpstr, "%d", sys_adpt_privatemib_root[i]);
        strcat(private_mib_view, tmpstr);
    }

    /* exclude sshHostkeyGenAction, sshHostkeySaveAction, sshHostkeyDelAction*/
    for(i = 0; i < 5; i++)
    {
        memset(result_str, 0, SYS_ADPT_MAX_OID_STRING_LEN);
        sprintf(result_str, "%s.1.17.6.%d FF:F0 volatile", private_mib_view, (24+i));
        vacm_parse_view("view", result_str);
    }

    /* exclude sshUserKeyDelAction */
    memset(result_str, 0, SYS_ADPT_MAX_OID_STRING_LEN);
    sprintf(result_str, "%s.1.17.6.29.1.18 FF:FC volatile", private_mib_view);
    vacm_parse_view("view", result_str);

    /* exclude ipFilterMgt */
    memset(result_str, 0, SYS_ADPT_MAX_OID_STRING_LEN);
    sprintf(result_str, "%s.1.17.9 FF:E0 volatile", private_mib_view);
    vacm_parse_view("view", result_str);

    /* exclude aclMgt */
    memset(result_str, 0, SYS_ADPT_MAX_OID_STRING_LEN);
    sprintf(result_str, "%s.1.17.7 FF:E0 volatile", private_mib_view);
    vacm_parse_view("view", result_str);

    /* exclude radiusMgt */
    memset(result_str, 0, SYS_ADPT_MAX_OID_STRING_LEN);
    sprintf(result_str, "%s.1.17.4 FF:E0 volatile", private_mib_view);
    vacm_parse_view("view", result_str);

    /* exlude portSecurityMgt */
    memset(result_str, 0, SYS_ADPT_MAX_OID_STRING_LEN);
    sprintf(result_str, "%s.1.17.2 FF:E0 volatile", private_mib_view);
    vacm_parse_view("view", result_str);

    /* exclude cosMgt */
    memset(result_str, 0, SYS_ADPT_MAX_OID_STRING_LEN);
    sprintf(result_str, "%s.1.16.3 FF:E0 volatile", private_mib_view);
    vacm_parse_view("view", result_str);

    /* exclude rateLimitMgt */
    memset(result_str, 0, SYS_ADPT_MAX_OID_STRING_LEN);
    sprintf(result_str, "%s.1.16.1 FF:E0 volatile", private_mib_view);
    vacm_parse_view("view", result_str);

    /* exclude priorityMgt */
    memset(result_str, 0, SYS_ADPT_MAX_OID_STRING_LEN);
    sprintf(result_str, "%s.1.13.10 FF:E0 volatile", private_mib_view);
    vacm_parse_view("view", result_str);


}
#endif

#if (SYS_CPNT_CFGDB == TRUE)
#if (SYS_CPNT_SNMP_COMMUNITY_IN_CFGDB == TRUE)
/* ---------------------------------------------------------------------
 * ROUTINE NAME  - SNMP_MGR_InitSnmpV3User
 * ---------------------------------------------------------------------
 * PURPOSE: This function will init snmpv3 users
 * INPUT : None
 * OUTPUT: None
 * RETURN: none.
 * NOTES :
 * ---------------------------------------------------------------------
 */
static void SNMP_MGR_InitSnmpV3User()
{
    int i;

    for(i = 0; i < SNMP_MGR_MAX_NBR_OF_SNMPV3_USER; i++)
    {
        memset(&snmp_mgr_v3_user_entry[i], 0, sizeof(SNMP_MGR_SnmpV3UserEntry_T));
        snmp_mgr_v3_user_entry[i].snmpv3_user_status = VAL_usmUserStatus_destroy;
    }
}
#endif  /* end of #if (SYS_CPNT_SNMP_COMMUNITY_IN_CFGDB == TRUE) */
#endif  /* end of #if (SYS_CPNT_CFGDB == TRUE) */


/* ---------------------------------------------------------------------
 * ROUTINE NAME  - SNMP_MGR_InitSnmpRemoteEngineIDEntry
 * ---------------------------------------------------------------------
 * PURPOSE: This function will init the remote engineID Entry.
 * INPUT : None
 * OUTPUT: None
 * RETURN: none.
 * NOTES : This is local function and only will be implemented by
 *         SNMP_MGR_EnterMasterMode()
 * ---------------------------------------------------------------------
 */
static void SNMP_MGR_InitSnmpRemoteEngineIDEntry()
{
    int i;
    UI32_T orig_priority;



    for (i = 0; i<SNMP_MGR_MAX_NBR_OF_REMOTE_ENGINEID; i++)
    snmp_mgr_remote_engineID_entry[i].snmp_remote_engineID_status=VAL_snmpTargetAddrRowStatus_destroy;

    return;
}

/* ---------------------------------------------------------------------
 * ROUTINE NAME  - SNMP_MGR_InitSnmpRemoteUserEntry
 * ---------------------------------------------------------------------
 * PURPOSE: This function will init the remote user entry.
 * INPUT : None
 * OUTPUT: None
 * RETURN: none.
 * NOTES : This is local function and only will be implemented by
 *         SNMP_MGR_EnterMasterMode()
 * ---------------------------------------------------------------------
 */
static void SNMP_MGR_InitSnmpRemoteUserEntry()
{
    int i;
    UI32_T orig_priority;


    for (i = 0; i<SNMP_MGR_MAX_NBR_OF_REMOTE_USER; i++)
    snmp_mgr_remote_user_entry[i].snmpv3_user_status=VAL_usmUserStatus_destroy;

    return;
}


#if (SYS_CPNT_CFGDB == TRUE)
#if (SYS_CPNT_SNMP_COMMUNITY_IN_CFGDB == TRUE)
/* ---------------------------------------------------------------------
 * ROUTINE NAME  - SNMP_MGR_InitSnmpV3UserFromCfgDB
 * ---------------------------------------------------------------------
 * PURPOSE: This function will init the usmUserEntry.
 * INPUT : None
 * OUTPUT: None
 * RETURN: none.
 * NOTES : This is local function and only will be implemented by
 *         SNMP_MGR_EnterMasterMode()
 * ---------------------------------------------------------------------
 */
static void SNMP_MGR_InitSnmpV3UserFromCfgDB()
{
    BOOL_T need_to_sync;

    CFGDB_MGR_Open(SNMP_MGR_CFGDB_SECTION_ID_SNMPV3_USER,
                   sizeof(SNMP_MGR_SnmpV3UserEntry_T),
                   SNMP_MGR_MAX_NBR_OF_SNMPV3_USER,
                   &snmp_mgr_v3_user_session_handler,
                   CFGDB_MGR_SECTION_TYPE_EXTERNAL_AND_GLOBAL,
                   &need_to_sync);

    if (need_to_sync)
    {
        CFGDB_MGR_SyncSection(snmp_mgr_v3_user_session_handler, snmp_mgr_v3_user_entry);
    }

    else
    {
        CFGDB_MGR_ReadSection(snmp_mgr_v3_user_session_handler, snmp_mgr_v3_user_entry);
    }
}


/* ---------------------------------------------------------------------
 * ROUTINE NAME  - SNMP_MGR_InitSnmpCommunityFromCfgDB
 * ---------------------------------------------------------------------
 * PURPOSE: This function will init the Rfc2576 SnmpCommunityEntry.
 * INPUT : None
 * OUTPUT: None
 * RETURN: none.
 * NOTES : This is local function and only will be implemented by
 *         SNMP_MGR_EnterMasterMode()
 * ---------------------------------------------------------------------
 */
static void SNMP_MGR_InitSnmpCommunityFromCfgDB()
{

    int i;
    BOOL_T need_to_sync;
    UI32_T orig_priority;
     /* Init SNMP Community String to default
      */
    SNMP_MGR_SnmpCommunityEntryForCfgdb_T community_entrys_in_cfgdb[SYS_ADPT_MAX_NBR_OF_SNMP_COMMUNITY_STRING];
    UI8_T local_snmp_community_context_engine_id[MAXSIZE_snmpEngineID]={0};
    UI32_T local_snmp_community_engine_id_length=0;

    snmp_mgr_init_comm_for_cfgdb = FALSE;
    /* Set Default RO community "public" first*/
    strcpy(snmp_mgr_comm_entry[0].snmp_community_index, "public");
    strcpy(snmp_mgr_comm_entry[0].snmp_community_name, "public");
    strcpy(snmp_mgr_comm_entry[0].snmp_community_security_name, "public");
    snmp_mgr_comm_entry[0].snmp_community_access_right = SNMP_MGR_ACCESS_RIGHT_READ_ONLY;

    SNMP_MGR_GetEngineID(snmp_mgr_comm_entry[0].snmp_community_context_engine_id, &snmp_mgr_comm_entry[0].snmp_community_engine_id_length);

    strcpy(snmp_mgr_comm_entry[0].snmp_community_context_name,"");
    strcpy(snmp_mgr_comm_entry[0].snmp_community_transport_tag,"");
    snmp_mgr_comm_entry[0].snmp_community_storage_type = VAL_snmpCommunityStorageType_nonVolatile;
    snmp_mgr_comm_entry[0].snmp_community_status = VAL_snmpCommunityStatus_active;
    /* Set Default RW community "private"*/
    strcpy(snmp_mgr_comm_entry[1].snmp_community_index, "private");
    strcpy(snmp_mgr_comm_entry[1].snmp_community_name, "private");
    strcpy(snmp_mgr_comm_entry[1].snmp_community_security_name, "private");
    snmp_mgr_comm_entry[1].snmp_community_access_right = SNMP_MGR_ACCESS_RIGHT_READ_WRITE;

    SNMP_MGR_GetEngineID(snmp_mgr_comm_entry[1].snmp_community_context_engine_id, &snmp_mgr_comm_entry[1].snmp_community_engine_id_length);

    strcpy(snmp_mgr_comm_entry[1].snmp_community_context_name,"");
    strcpy(snmp_mgr_comm_entry[1].snmp_community_transport_tag,"");
    snmp_mgr_comm_entry[1].snmp_community_storage_type = VAL_snmpCommunityStorageType_nonVolatile;
    snmp_mgr_comm_entry[1].snmp_community_status = VAL_snmpCommunityStatus_active;
    /* eli,we use SNMP_MGR_SnmpCommunityEntryForCfgdb_T in cfgdb for compatibility
      */
    CFGDB_MGR_Open(SNMP_MGR_CFGDB_SECTION_ID_SNMP_COMMUNITY,
                   sizeof(SNMP_MGR_SnmpCommunityEntryForCfgdb_T),
                   SYS_ADPT_MAX_NBR_OF_SNMP_COMMUNITY_STRING,
                   &snmp_community_session_handler,
                   CFGDB_MGR_SECTION_TYPE_EXTERNAL_AND_GLOBAL,
                   &need_to_sync);

    SNMP_MGR_GetEngineID(local_snmp_community_context_engine_id,&local_snmp_community_engine_id_length);

    if (need_to_sync)
    {
        /* eli,we should convert community structure between snmp agent and cfgdb for compatibility
         */
        for(i=0;i<SYS_ADPT_MAX_NBR_OF_SNMP_COMMUNITY_STRING;i++)
        {
            memcpy(community_entrys_in_cfgdb[i].snmp_community_index,snmp_mgr_comm_entry[i].snmp_community_index,SYS_ADPT_MAX_COMM_STR_NAME_LEN + 1);
            memcpy(community_entrys_in_cfgdb[i].snmp_community_name,snmp_mgr_comm_entry[i].snmp_community_name,SYS_ADPT_MAX_COMM_STR_NAME_LEN + 1);
            memcpy(community_entrys_in_cfgdb[i].snmp_community_security_name,snmp_mgr_comm_entry[i].snmp_community_security_name,SYS_ADPT_MAX_COMM_STR_NAME_LEN + 1);
            /* eli,we use local engine_id as the engine_id of all community for compatibility.
             * So, the engine_id of community of cfgdb is not effect.
             */
            memset(community_entrys_in_cfgdb[i].snmp_community_context_engine_id,0,MAXSIZE_SNMPV3_ENGINE_ID_LEN);
            memcpy(community_entrys_in_cfgdb[i].snmp_community_context_name,snmp_mgr_comm_entry[i].snmp_community_context_name,MAXSIZE_snmpCommunityContextName+1);
            memcpy(community_entrys_in_cfgdb[i].snmp_community_transport_tag,snmp_mgr_comm_entry[i].snmp_community_transport_tag,MAXSIZE_snmpCommunityTransportTag+1);
            memcpy(&community_entrys_in_cfgdb[i].snmp_community_access_right,&snmp_mgr_comm_entry[i].snmp_community_access_right,sizeof(UI32_T));
            memcpy(&community_entrys_in_cfgdb[i].snmp_community_storage_type,&snmp_mgr_comm_entry[i].snmp_community_storage_type,sizeof(UI32_T));
            memcpy(&community_entrys_in_cfgdb[i].snmp_community_status,&snmp_mgr_comm_entry[i].snmp_community_status,sizeof(UI32_T));
        }
        CFGDB_MGR_SyncSection(snmp_community_session_handler,community_entrys_in_cfgdb );
        /* eli,we should convert community structure between snmp agent and cfgdb for compatibility
         */
        for(i=0;i<SYS_ADPT_MAX_NBR_OF_SNMP_COMMUNITY_STRING;i++)
        {
            memcpy(snmp_mgr_comm_entry[i].snmp_community_index,community_entrys_in_cfgdb[i].snmp_community_index,SYS_ADPT_MAX_COMM_STR_NAME_LEN + 1);
            memcpy(snmp_mgr_comm_entry[i].snmp_community_name,community_entrys_in_cfgdb[i].snmp_community_name,SYS_ADPT_MAX_COMM_STR_NAME_LEN + 1);
            memcpy(snmp_mgr_comm_entry[i].snmp_community_security_name,community_entrys_in_cfgdb[i].snmp_community_security_name,SYS_ADPT_MAX_COMM_STR_NAME_LEN + 1);
            /* eli,we use local engine_id as the engine_id of all community for compatibility.
             */
            memcpy(snmp_mgr_comm_entry[i].snmp_community_context_engine_id,local_snmp_community_context_engine_id,MAXSIZE_snmpEngineID);
            memcpy(&snmp_mgr_comm_entry[i].snmp_community_engine_id_length,&local_snmp_community_engine_id_length,sizeof(UI32_T));
            memcpy(snmp_mgr_comm_entry[i].snmp_community_context_name,community_entrys_in_cfgdb[i].snmp_community_context_name,MAXSIZE_snmpCommunityContextName+1);
            memcpy(snmp_mgr_comm_entry[i].snmp_community_transport_tag,community_entrys_in_cfgdb[i].snmp_community_transport_tag,MAXSIZE_snmpCommunityTransportTag+1);
            memcpy(&snmp_mgr_comm_entry[i].snmp_community_access_right,&community_entrys_in_cfgdb[i].snmp_community_access_right,sizeof(UI32_T));
            memcpy(&snmp_mgr_comm_entry[i].snmp_community_storage_type,&community_entrys_in_cfgdb[i].snmp_community_storage_type,sizeof(UI32_T));
            memcpy(&snmp_mgr_comm_entry[i].snmp_community_status,&community_entrys_in_cfgdb[i].snmp_community_status,sizeof(UI32_T));
        }
    }
    else
    {

        CFGDB_MGR_ReadSection(snmp_community_session_handler, community_entrys_in_cfgdb);
        /* eli,we should convert community structure between snmp agent and cfgdb for compatibility
         */
        for(i=0;i<SYS_ADPT_MAX_NBR_OF_SNMP_COMMUNITY_STRING;i++)
        {
            memcpy(snmp_mgr_comm_entry[i].snmp_community_index,community_entrys_in_cfgdb[i].snmp_community_index,SYS_ADPT_MAX_COMM_STR_NAME_LEN + 1);
            memcpy(snmp_mgr_comm_entry[i].snmp_community_name,community_entrys_in_cfgdb[i].snmp_community_name,SYS_ADPT_MAX_COMM_STR_NAME_LEN + 1);
            memcpy(snmp_mgr_comm_entry[i].snmp_community_security_name,community_entrys_in_cfgdb[i].snmp_community_security_name,SYS_ADPT_MAX_COMM_STR_NAME_LEN + 1);
            /* eli,we use local engine_id as the engine_id of all community for compatibility.
             */
            memcpy(snmp_mgr_comm_entry[i].snmp_community_context_engine_id,local_snmp_community_context_engine_id,MAXSIZE_snmpEngineID);
            memcpy(&snmp_mgr_comm_entry[i].snmp_community_engine_id_length,&local_snmp_community_engine_id_length,sizeof(UI32_T));
            memcpy(snmp_mgr_comm_entry[i].snmp_community_context_name,community_entrys_in_cfgdb[i].snmp_community_context_name,MAXSIZE_snmpCommunityContextName+1);
            memcpy(snmp_mgr_comm_entry[i].snmp_community_transport_tag,community_entrys_in_cfgdb[i].snmp_community_transport_tag,MAXSIZE_snmpCommunityTransportTag+1);
            memcpy(&snmp_mgr_comm_entry[i].snmp_community_access_right,&community_entrys_in_cfgdb[i].snmp_community_access_right,sizeof(UI32_T));
            memcpy(&snmp_mgr_comm_entry[i].snmp_community_storage_type,&community_entrys_in_cfgdb[i].snmp_community_storage_type,sizeof(UI32_T));
            memcpy(&snmp_mgr_comm_entry[i].snmp_community_status,&community_entrys_in_cfgdb[i].snmp_community_status,sizeof(UI32_T));
        }
    }

    for (i = 0; i<SYS_ADPT_MAX_NBR_OF_SNMP_COMMUNITY_STRING; i++)
    {
        if (snmp_mgr_comm_entry[i].snmp_community_status == VAL_snmpCommunityStatus_active)
        {
            UI8_T comm_name[SYS_ADPT_MAX_COMM_STR_NAME_LEN+1];
            UI32_T access_right;

            strcpy(comm_name, snmp_mgr_comm_entry[i].snmp_community_name);
            if (snmp_mgr_comm_entry[i].snmp_community_access_right == SNMP_MGR_ACCESS_RIGHT_READ_ONLY)
            {
                access_right = SNMP_MGR_ACCESS_RIGHT_READ_ONLY;
            }
            else if (snmp_mgr_comm_entry[i].snmp_community_access_right == SNMP_MGR_ACCESS_RIGHT_READ_WRITE)
            {
                access_right = SNMP_MGR_ACCESS_RIGHT_READ_WRITE;
            }
            else
            {
                continue;
            }
            if (SNMP_MGR_CreateSnmpCommunity( comm_name, access_right)!= SNMP_MGR_ERROR_OK)
            {
                SYSFUN_Debug_Printf(" error to init community\n");
            }
        }
    }
    snmp_mgr_init_comm_for_cfgdb = TRUE;
    return;
}
#endif

static void SNMP_MGR_InitSnmpEngineBoot()
{
    BOOL_T need_to_sync;
    memset(&snmp_mgr_engine_info, 0, sizeof(snmp_mgr_engine_info));
    CFGDB_MGR_Open(SNMP_MGR_CFGDB_SECTION_ID_SNMPV3_ENGINE_INFO,
                   sizeof(SNMP_MGR_SnmpEngineInfo_T),
                   1,
                   &snmp_mgr_engine_info_session_handler,
                   CFGDB_MGR_SECTION_TYPE_EXTERNAL_AND_GLOBAL,
                   &need_to_sync);
    if (need_to_sync)
    {
        CFGDB_MGR_SyncSection(snmp_mgr_engine_info_session_handler, &snmp_mgr_engine_info );
    }
    else
    {
        CFGDB_MGR_ReadSection(snmp_mgr_engine_info_session_handler, &snmp_mgr_engine_info);
    }
}
#endif /* end of #if (SYS_CPNT_CFGDB == TRUE)*/

/*--------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_DeleteSecurityToGroupEntry
 *---------------------------------------------------------------------------
 * PURPOSE:  This function will remove the securityToGroupEntry
 * INPUT:     entry->snmpv3_user_name
 * OUTPUT:    None
 * RETURN:  1. success:    SNMP_MGR_ERROR_OK
 *          2. failure:    SNMP_MGR_ERROR_EXCEED_LIMIT
 *                         SNMP_MGR_ERROR_MEM_ALLOC_FAIL
 *                         SNMP_MGR_ERROR_PARAMETER_NOT_MATCH
 *                         SNMP_MGR_ERROR_FAIL
 * NOTE:     None.
 *---------------------------------------------------------------------------
 */
static UI32_T  SNMP_MGR_DeleteSecurityToGroupEntry(SNMP_MGR_Snmpv3_Model_T  security_model, char *snmpv3_user_name)
{
    struct vacm_groupEntry *geptr= NULL;
    UI32_T orig_priority;
    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);

    geptr = vacm_getGroupEntry(security_model , (const char *)snmpv3_user_name);

    if (geptr == NULL)
    {
        return SNMP_MGR_ERROR_FAIL;
    }
   /* delete  securityToGroup Table*/
    vacm_destroyGroupEntry(security_model, (const char *)snmpv3_user_name);

    return SNMP_MGR_ERROR_OK;
}

/*--------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_DeleteUsmUserEntry
 *---------------------------------------------------------------------------
 * PURPOSE:  This function will remove the UsmUserEntry
 * INPUT:     entry->snmpv3_user_name
 * OUTPUT:    None
 * RETURN:  1. success:    SNMP_MGR_ERROR_OK
 *          2. failure:    SNMP_MGR_ERROR_EXCEED_LIMIT
 *                         SNMP_MGR_ERROR_MEM_ALLOC_FAIL
 *                         SNMP_MGR_ERROR_PARAMETER_NOT_MATCH
 *                         SNMP_MGR_ERROR_FAIL
 * NOTE:     None.
 *---------------------------------------------------------------------------
 */
static UI32_T  SNMP_MGR_DeleteUsmUserEntry( char * snmpv3_user_name)
{
    struct usmUser *uptr = NULL;
    UI8_T           *engineID;
    UI32_T          length;
    UI32_T orig_priority;

    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);

    engineID = (u_char *) malloc(MAXSIZE_snmpEngineID);
    length = snmpv3_get_engineID(  engineID, MAXSIZE_snmpEngineID);
    if (length == 0)
    {
        SNMP_FREE(engineID);
        engineID = NULL;

        return SNMP_MGR_ERROR_FAIL;
    }
   /*
    * Now see if a user already exists with these index values.
    */
    uptr = usm_get_user(engineID, length,  snmpv3_user_name);

    if (uptr == NULL)
    {
        SNMP_FREE(engineID);
        engineID = NULL;

        return SNMP_MGR_ERROR_FAIL;
    }
    /* delete  usergroup Table*/
    usm_remove_user(uptr);
    usm_free_user(uptr);
    SNMP_FREE(engineID);
    engineID = NULL;

    return SNMP_MGR_ERROR_OK;
}

/*--------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_DeleteUsmUserEntryWithEngineID
 *---------------------------------------------------------------------------
 * PURPOSE:  This function will remove the UsmUserEntry by key engineID and name
 * INPUT:     engineID, engineID len entry->snmpv3_user_name
 * OUTPUT:    None
 * RETURN:  1. success:    SNMP_MGR_ERROR_OK
 *          2. failure:    SNMP_MGR_ERROR_EXCEED_LIMIT
 *                         SNMP_MGR_ERROR_MEM_ALLOC_FAIL
 *                         SNMP_MGR_ERROR_PARAMETER_NOT_MATCH
 *                         SNMP_MGR_ERROR_FAIL
 * NOTE:     None.
 *---------------------------------------------------------------------------
 */
static UI32_T  SNMP_MGR_DeleteUsmUserEntryWithEngineID(UI8_T *engineID, UI32_T engineID_len, UI8_T * snmpv3_user_name)
{
    struct usmUser *uptr = NULL;
    UI32_T orig_priority;

    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);

   /*
    * Now see if a user already exists with these index values.
    */
    uptr = usm_get_user(engineID, engineID_len, (char *)snmpv3_user_name);

    if (uptr == NULL)
    {
        return SNMP_MGR_ERROR_FAIL;
    }
    /* delete  usergroup Table*/
    usm_remove_user(uptr);
    usm_free_user(uptr);

    return SNMP_MGR_ERROR_OK;
}

/* ---------------------------------------------------------------------
 * ROUTINE NAME  - SNMP_MGR_CompareTrapEntryAddr
 * ---------------------------------------------------------------------
 * PURPOSE: This function will compare the destination address of trap_entry.
 * INPUT:   elem1, elem2  -  SNMP_MGR_TrapDestEntry_T structure pointer
 * OUTPUT:  none
 * Return:  < 0   -- elem1 destination address is less (earlier) than elem2 destination address.
 *          == 0  -- elem1 destination address is equal to elem2 destination address.
 *          > 0   -- elem1 destination address is greater (later) than elem2 destination address.
 * NOTES:
 * ---------------------------------------------------------------------
 */
static int SNMP_MGR_CompareTrapEntryAddr(SNMP_MGR_TrapDestEntry_T *elem1, SNMP_MGR_TrapDestEntry_T *elem2)
{
   return L_INET_CompareInetAddr((L_INET_Addr_T *)&elem1->trap_dest_address,
      (L_INET_Addr_T *)&elem2->trap_dest_address, 0);
}

/*--------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_CheckSnmpCommunity
 *---------------------------------------------------------------------------
 * PURPOSE:  The function will check if the snmp communtity entry is exist
 * INPUT:      entry
 * OUTPUT:  none
 * RETURN:  1. success:    SNMP_MGR_ERROR_OK
 *                    2. failure:      SNMP_MGR_ERROR_EXCEED_LIMIT
 *                                         SNMP_MGR_ERROR_MEM_ALLOC_FAIL
 *                                         SNMP_MGR_ERROR_PARAMETER_NOT_MATCH
 *                                         SNMP_MGR_ERROR_FAIL
 * NOTE:
 *---------------------------------------------------------------------------
 */

static UI32_T SNMP_MGR_CheckSnmpCommunity(SNMP_MGR_SnmpCommunity_T *comm_entry)
{
    struct _com2SecEntry *com2SecPtr = NULL;
    UI32_T orig_priority;

    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);

    com2SecPtr = netsnmp_udp_getCom2SecEntry(comm_entry->comm_string_name);
    if (com2SecPtr)
    {
        comm_entry->access_right = com2SecPtr->access_right;
        return SNMP_MGR_ERROR_OK;
    }
    else
    {
        return SNMP_MGR_ERROR_FAIL;
    }

    return SNMP_MGR_ERROR_OK;
}

/*--------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_CheckGroupExist
 *---------------------------------------------------------------------------
 * PURPOSE:  The function will check if the group  is exist
 * INPUT:      entry
 * OUTPUT:  none
 * RETURN:  1. success:    SNMP_MGR_ERROR_OK
 *                    2. failure:      SNMP_MGR_ERROR_EXCEED_LIMIT
 *                                         SNMP_MGR_ERROR_MEM_ALLOC_FAIL
 *                                         SNMP_MGR_ERROR_PARAMETER_NOT_MATCH
 *                                         SNMP_MGR_ERROR_FAIL
 * NOTE:
 *---------------------------------------------------------------------------
 */
static UI32_T  SNMP_MGR_CheckGroupExist( SNMP_MGR_SnmpV3GroupEntry_T  *entry)
{
    struct vacm_accessEntry *aptr = NULL;
    UI32_T orig_priority;

    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);

    aptr = vacm_getExactAccessEntry(entry->snmpv3_group_name,  "",  entry->snmpv3_group_model,  entry->snmpv3_group_security_level);

    if (aptr)
    {
        return SNMP_MGR_ERROR_OK;
    }
    else
    {
        return SNMP_MGR_ERROR_FAIL;
    }

    return SNMP_MGR_ERROR_OK;
}

/*--------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_CheckViewExist
 *---------------------------------------------------------------------------
 * PURPOSE:  The function will check if the view is exist
 * INPUT:      entry
 * OUTPUT:  none
 * RETURN:  1. success:    SNMP_MGR_ERROR_OK
 *                    2. failure:      SNMP_MGR_ERROR_EXCEED_LIMIT
 *                                         SNMP_MGR_ERROR_MEM_ALLOC_FAIL
 *                                         SNMP_MGR_ERROR_PARAMETER_NOT_MATCH
 *                                         SNMP_MGR_ERROR_FAIL
 * NOTE:
 *---------------------------------------------------------------------------
 */
static UI32_T SNMP_MGR_CheckViewExist(SNMP_MGR_SnmpV3ViewEntry_T  *entry)
{
    oid tmp_subtree[MAXSIZE_VIEW_SUBTREE],  subtree[MAXSIZE_VIEW_SUBTREE];
    UI32_T oid_len;
    struct vacm_viewEntry  *viewentry;
    UI32_T orig_priority;

    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);
    SNMP_MGR_StringToObejctID(tmp_subtree, (I8_T *)entry->snmpv3_view_subtree, &oid_len);
    subtree[0]= oid_len;
    memcpy( &subtree[1], tmp_subtree, sizeof(oid) * oid_len);

    viewentry= vacm_getExactViewEntry(entry-> snmpv3_view_name,   subtree, oid_len+1);
    if (viewentry)
    {
        return SNMP_MGR_ERROR_OK;
    }
    else
    {
        return SNMP_MGR_ERROR_FAIL;
    }
}

/*--------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_DeleteAllSnmpV3User
 *---------------------------------------------------------------------------
 * PURPOSE:  This function use to delete all SNMP V3 user.
 * INPUT:    None.
 * OUTPUT:   None.
 * RETURN:  1. success:    SNMP_MGR_ERROR_OK
 *                    2. failure:      SNMP_MGR_ERROR_EXCEED_LIMIT
 *                                         SNMP_MGR_ERROR_MEM_ALLOC_FAIL
 *                                         SNMP_MGR_ERROR_PARAMETER_NOT_MATCH
 *                                         SNMP_MGR_ERROR_FAIL
 * NOTE:     None.
 *---------------------------------------------------------------------------
 */
static UI32_T SNMP_MGR_DeleteAllSnmpV3User()
{
    struct usmUser *uptr, *tuptr, *userlist = NULL;
    struct vacm_groupEntry *grouplist, *gptr= NULL,*temp_gptr=NULL;
    UI32_T orig_priority;
    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);

    userlist = usm_get_userList();

    for (uptr = userlist; uptr != NULL;)
    {
        tuptr = uptr->next;
       /* delete  usergroup Table*/
        usm_remove_user(uptr);
        usm_free_user(uptr);
        uptr = tuptr;
    }


    SNMP_MGR_ResetSnmpV3UserCounter();
   /* delete  securityToGroup Table*/

    grouplist = vacm_get_groupList();
    for (gptr = grouplist; gptr !=NULL;)
    {
        if (gptr ->securityModel == 3)
         {
            temp_gptr=gptr->next;
               vacm_destroyGroupEntry(3,  &gptr->securityName[1]);
            gptr=temp_gptr;
          }
        else
        {
            gptr= gptr->next;
          }
    }


    return SNMP_MGR_ERROR_OK;
}

/* ---------------------------------------------------------------------
 * ROUTINE NAME  - SNMP_MGR_CheckDefaultCommunityView
 * ---------------------------------------------------------------------
 * PURPOSE: This function will check if we have a default entry of view
 *
 *
 * INPUT:none
 *
 * OUTPUT: None
 * RETURN: None
 * NOTES: 1. if the entry does not exist, it will create the deafult entry.
 * ---------------------------------------------------------------------
 */
static void SNMP_MGR_CheckDefaultCommunityView()
{
    struct vacm_viewEntry  *viewentry;
    oid subtree[MAXSIZE_VIEW_SUBTREE];
    UI8_T defaultviewparam[50] = "defaultview included .1 80 volatile";
    UI32_T orig_priority;

   /* Step1:  Check Default view entry, if not exist, create one */
    subtree[0] = 1;
    subtree[1] = 1;

    viewentry= vacm_getExactViewEntry("defaultview",   subtree, 2);

    if (!viewentry)
    {
        vacm_parse_view("view", (char *)defaultviewparam);
    }

}

#if 0 /* XXX steven.jiang for warnings */
/* ---------------------------------------------------------------------
 * ROUTINE NAME  - SNMP_MGR_CheckAndCreateDefaultCommunityGroup
 * ---------------------------------------------------------------------
 * PURPOSE: This function will check if we have a default entry of group which mapping the community to group.
 *
 *
 * INPUT:none
 *
 * OUTPUT: None
 * RETURN: None
 * NOTES: 1. if the entry does not exist, it will create the deafult entry.
 * ---------------------------------------------------------------------
 */
static void SNMP_MGR_CheckAndCreateDefaultCommunityGroup()
{
    struct vacm_groupEntry *geptr= NULL;
    struct vacm_accessEntry *aptr = NULL;
    char  line[SNMP_MGR_SPRINT_MAX_LEN];
    UI8_T param1[40]= "DefaultRWGroup v2c DefaultRWSecName";
    UI8_T param2[40]= "DefaultRWGroup v1 DefaultRWSecName";
    UI8_T param3[40]= "DefaultROGroup v2c DefaultROSecName";
    UI8_T param4[40]= "DefaultROGroup v1 DefaultROSecName";
    UI32_T orig_priority;


   /* Step1:  Check Default SecurityToGroup Entry, if not exist, create one */
    geptr = vacm_getGroupEntry(SNMP_MGR_SNMPV3_MODEL_V2C , "DefaultRWSecName");

    if (!geptr)
    {
        vacm_parse_group("group", (char *)param1);
    }

    geptr = vacm_getGroupEntry(SNMP_MGR_SNMPV3_MODEL_V1 , "DefaultRWSecName");

    if (!geptr)
    {
        vacm_parse_group("group", (char *)param2);
    }
    geptr = vacm_getGroupEntry(SNMP_MGR_SNMPV3_MODEL_V2C , "DefaultROSecName");
    if (!geptr)
    {
        vacm_parse_group("group", (char *)param3);
    }
    geptr = vacm_getGroupEntry(SNMP_MGR_SNMPV3_MODEL_V1 , "DefaultROSecName");
    if (!geptr)
    {
        vacm_parse_group("group", (char *)param4);
    }

   /* Step2:  Check Default AccessEntry, if not exist, create one */

    aptr = vacm_getExactAccessEntry( "DefaultROGroup",  "",  SNMP_MGR_SNMPV3_MODEL_V1,  VAL_vacmAccessSecurityLevel_noAuthNoPriv);

    if (!aptr)
    {
         SYSFUN_Sprintf(line, "%s \"\"  %s %s prefix \"%s\" \"%s\" \"%s\"",
                "DefaultROGroup", "v1", "noauth", "defaultview", "", "");
                vacm_parse_access("access", line);
    }

    aptr = vacm_getExactAccessEntry( "DefaultROGroup",  "",  SNMP_MGR_SNMPV3_MODEL_V2C,  VAL_vacmAccessSecurityLevel_noAuthNoPriv);

    if (!aptr)
    {
         SYSFUN_Sprintf(line, "%s \"\"  %s %s prefix \"%s\" \"%s\" \"%s\"",
                "DefaultROGroup", "v2c", "noauth", "defaultview", "", "");
                vacm_parse_access("access", line);
    }

    aptr = vacm_getExactAccessEntry( "DefaultRWGroup",  "",  SNMP_MGR_SNMPV3_MODEL_V1,  VAL_vacmAccessSecurityLevel_noAuthNoPriv);

    if (!aptr)
    {
          SYSFUN_Sprintf(line, "%s \"\"  %s %s prefix \"%s\" \"%s\" \"%s\"",
                " DefaultRWGroup", "v1", "noauth", "defaultview", "defaultview", "");
                vacm_parse_access("access", line);
    }

    aptr = vacm_getExactAccessEntry( "DefaultRWGroup",  "",  SNMP_MGR_SNMPV3_MODEL_V2C,  VAL_vacmAccessSecurityLevel_noAuthNoPriv);

    if (!aptr)
    {
        SYSFUN_Sprintf(line, "%s \"\"  %s %s prefix \"%s\" \"%s\" \"%s\"",
                " DefaultRWGroup", "v2c", "noauth", "defaultview", "defaultview", "");
                vacm_parse_access("access", line);
    }

}
#endif /* 0 */

/*--------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_CreateSnmpTargetParamsTable
 *---------------------------------------------------------------------------
 * PURPOSE:  This function will create snmpTargetParamsTable in Rfc3413 Target MIB
 * INPUT:    entry
 * OUTPUT:   entry.
 * RETURN:  1. success:    SNMP_MGR_ERROR_OK
 *          2. failure:    SNMP_MGR_ERROR_EXCEED_LIMIT
 *                         SNMP_MGR_ERROR_MEM_ALLOC_FAIL
 *
 * NOTE:   The max number of targetParams Entry is SNMP_MGR_MAX_NBR_OF_TARGET_ADDR_PARAMS_ENTRY,
 *         the entry will not created if it already reached it max.
 *---------------------------------------------------------------------------
 */
static UI32_T SNMP_MGR_CreateSnmpTargetParamsTable(SNMP_MGR_SnmpTargetParamsEntry_T *entry)
{
    struct targetParamTable_struct *newEntry=NULL;
    struct targetParamTable_struct **entry_addr=NULL;
    UI32_T orig_priority;

    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);
    /* Check if the original entry exist, if so, remove it*/
    if (SNMP_MGR_GetSnmpTargetParamsTable (entry) == SNMP_MGR_ERROR_OK)
    {
        SNMP_MGR_DeleteSnmpTargetParamsTable(entry->snmp_target_params_name);
    }


    newEntry = (struct targetParamTable_struct *)
               malloc(sizeof(struct targetParamTable_struct));

    if (newEntry)
    {
        newEntry->paramName = strdup( entry->snmp_target_params_name);
        newEntry->mpModel = entry->snmp_target_params_mp_model;
        newEntry->secModel = entry->snmp_target_params_security_model;
        newEntry->secName = strdup((char *)entry->snmp_target_params_security_name);
        newEntry->secLevel = entry->snmp_target_params_security_level;
        newEntry->storageType = entry->snmp_target_params_storage_type;
        newEntry->rowStatus = entry->snmp_target_params_row_status;
        newEntry->updateTime = 0;
        newEntry->next = 0;
     }
     else
     {


        return SNMP_MGR_ERROR_MEM_ALLOC_FAIL;
     }
     entry_addr = get_aPTableAddress();
     snmpTargetParamTable_addToList( newEntry, entry_addr);


     return SNMP_MGR_ERROR_OK;
}



/*--------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_GetSnmpTargetParamsTable
 *---------------------------------------------------------------------------
 * PURPOSE:  This function will retrieve the snmpTargetParamsTable in Rfc3413 Target MIB
 * INPUT:    entry->snmp_target_params_name
 * OUTPUT:   entry.
 * RETURN:  1. success:    SNMP_MGR_ERROR_OK
 *          2. failure:    SNMP_MGR_ERROR_NO_ENTRY_EXIST
 *                         SNMP_MGR_ERROR_FAIL
 *
 * NOTE:    none.
 *---------------------------------------------------------------------------
 */
static UI32_T SNMP_MGR_GetSnmpTargetParamsTable(SNMP_MGR_SnmpTargetParamsEntry_T *entry)
{
    static struct targetParamTable_struct *tp;
    static struct targetParamTable_struct *target_params_list;
    UI32_T orig_priority;

    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);

   /* get the variable store in snmpTargetParamsEntry*/
    target_params_list = get_aPTable();
    if (!target_params_list)
    {


        return SNMP_MGR_ERROR_NO_ENTRY_EXIST;
    }
   /* find the next entry*/
    for (tp = target_params_list; tp; tp = tp->next)
    {
        if (strcmp(tp->paramName, entry->snmp_target_params_name) == 0)
        {
            break;
        }
    }
    if (tp)
    {
        strcpy(entry->snmp_target_params_name, tp->paramName);
        entry->snmp_target_params_mp_model = (UI32_T)tp->mpModel;
        entry->snmp_target_params_security_model = (SNMP_MGR_Snmpv3_Model_T)tp->secModel;
    if (tp->secName != NULL)
    {
        strcpy((char *)entry->snmp_target_params_security_name , tp->secName);
    }
    else
    {
        strcpy((char *)entry->snmp_target_params_security_name , "");
    }
        entry->snmp_target_params_security_level= tp->secLevel;
        entry->snmp_target_params_storage_type = tp->storageType;
        entry->snmp_target_params_row_status = tp->rowStatus;


        return SNMP_MGR_ERROR_OK;
    }
    else
    {


        return SNMP_MGR_ERROR_FAIL;
    }
}


/*--------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_GetNextSnmpTargetParamsTable
 *---------------------------------------------------------------------------
 * PURPOSE:  This function will retrieve the next snmpTargetParamsTable in Rfc3413 Target MIB
 * INPUT:    entry->snmp_target_params_name
 * OUTPUT:   entry.
 * RETURN:  1. success:    SNMP_MGR_ERROR_OK
 *          2. failure:    SNMP_MGR_ERROR_NO_ENTRY_EXIST
 *                         SNMP_MGR_ERROR_FAIL
 *
 * NOTE:    none.
 *---------------------------------------------------------------------------
 */
static UI32_T SNMP_MGR_GetNextSnmpTargetParamsTable(SNMP_MGR_SnmpTargetParamsEntry_T *entry)
{
    static struct targetParamTable_struct *tp;
    static struct targetParamTable_struct *target_params_list;
    UI32_T orig_priority;

    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);


   /* get the variable store in snmpTargetAddrEntry*/
    target_params_list = get_aPTable();
    if (!target_params_list)
    {


        return SNMP_MGR_ERROR_NO_ENTRY_EXIST;
    }

    if (strcmp(entry->snmp_target_params_name, "" ) == 0)
   /* Get First */
    {
        strcpy(entry->snmp_target_params_name, target_params_list->paramName);
               entry->snmp_target_params_mp_model = (UI32_T)target_params_list->mpModel;
               entry->snmp_target_params_security_model = (SNMP_MGR_Snmpv3_Model_T)target_params_list->secModel;
        if (target_params_list->secName != NULL)
        {
            strcpy((char *)entry->snmp_target_params_security_name , target_params_list->secName);
        }
        else
        {
            strcpy((char *)entry->snmp_target_params_security_name , "");
        }
        entry->snmp_target_params_security_level= target_params_list->secLevel;
        entry->snmp_target_params_storage_type = target_params_list->storageType;
        entry->snmp_target_params_row_status = target_params_list->rowStatus;


        return SNMP_MGR_ERROR_OK;
    }
    else
    {
       /* find the next entry*/
        for (tp = target_params_list; tp; tp = tp->next)
        {
            if (strcmp(tp->paramName, entry->snmp_target_params_name) == 0)
            {
                break;
            }
        }
        if ((tp) && (tp->next))
        {
            tp = tp->next;
            strcpy(entry->snmp_target_params_name, tp->paramName);
            entry->snmp_target_params_mp_model = (UI32_T)tp->mpModel;
            entry->snmp_target_params_security_model = (SNMP_MGR_Snmpv3_Model_T)tp->secModel;
            if (tp->secName != NULL)
            {
                strcpy((char *)entry->snmp_target_params_security_name , tp->secName);
            }
            else
            {
                strcpy((char *)entry->snmp_target_params_security_name , "");
            }
            entry->snmp_target_params_security_level= tp->secLevel;
            entry->snmp_target_params_storage_type = tp->storageType;
            entry->snmp_target_params_row_status = tp->rowStatus;


            return SNMP_MGR_ERROR_OK;
        }
        else
        {


            return SNMP_MGR_ERROR_FAIL;
        }
    }
}


/*--------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_DeleteSnmpTargetParamsTable
 *---------------------------------------------------------------------------
 * PURPOSE:  This function will delete the snmpTargetParamsTable in Rfc3413 Target MIB
 * INPUT:    snmp_target_params_name
 * OUTPUT:   entry.
 * RETURN:  1. success:    SNMP_MGR_ERROR_OK
 *          2. failure:    SNMP_MGR_ERROR_NO_ENTRY_EXIST
 *                         SNMP_MGR_ERROR_FAIL
 *
 * NOTE:    none.
 *---------------------------------------------------------------------------
 */
static UI32_T SNMP_MGR_DeleteSnmpTargetParamsTable(char  *snmp_target_params_name)
{
    static struct targetParamTable_struct *tp;
    static struct targetParamTable_struct *target_params_list;
    static struct targetParamTable_struct **target_params_list_address;
   /* get the variable store in snmpTargetAddrEntry*/
    UI32_T orig_priority;
    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);


    target_params_list = get_aPTable();
    target_params_list_address = get_aPTableAddress();

    if (!target_params_list)
    {


        return SNMP_MGR_ERROR_NO_ENTRY_EXIST;
    }
   /* find the next entry*/
    for (tp = target_params_list; tp; tp = tp->next)
    {
        if (strcmp(tp->paramName, (char *)snmp_target_params_name) == 0)
        {
            break;
        }
    }
   /* find an entry, remove it */
    if (tp)
    {
        snmpTargetParamTable_remFromList(tp, (struct targetParamTable_struct **)target_params_list_address);


        return SNMP_MGR_ERROR_OK;
    }
    else
    {


        return SNMP_MGR_ERROR_FAIL;
    }
}


/*--------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_CreateSnmpTargetAddrTable
 *---------------------------------------------------------------------------
 * PURPOSE:  This function will create snmpTargetAddrTable in Rfc3413 Target MIB
 * INPUT:    entry
 * OUTPUT:   entry.
 * RETURN:  1. success:    SNMP_MGR_ERROR_OK
 *          2. failure:    SNMP_MGR_ERROR_EXCEED_LIMIT
 *                         SNMP_MGR_ERROR_MEM_ALLOC_FAIL
 *
 * NOTE:   The max number of targetAddr entry is SNMP_MGR_MAX_NBR_OF_TARGET_ADDR_ENTRY,
 *         the entry will not created if it already reached it max.
 *---------------------------------------------------------------------------
 */
static UI32_T SNMP_MGR_CreateSnmpTargetAddrTable(SNMP_MGR_SnmpTargetAddrEntry_T *entry)
{
    struct targetAddrTable_struct *newEntry=NULL;
    struct targetAddrTable_struct **entry_addr=NULL;
    UI32_T orig_priority;

    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);
    /* Check if the original entry exist, if so, remove it*/
    if (SNMP_MGR_GetSnmpTargetAddrTable (entry) == SNMP_MGR_ERROR_OK)
    {
        SNMP_MGR_DeleteSnmpTargetAddrTable(entry->snmp_target_addr_name);
    }



    newEntry = (struct targetAddrTable_struct *)
               malloc(sizeof(struct targetAddrTable_struct));

    if (newEntry)
    {
        newEntry->name = strdup( entry->snmp_target_addr_name);
        memcpy(newEntry->tDomain, entry->snmp_target_addr_tdomain, entry->snmp_target_addr_tdomain_len*sizeof(oid) );
        newEntry->tDomainLen = entry->snmp_target_addr_tdomain_len;
        newEntry->tAddress = (u_char *) malloc(entry->snmp_target_addr_len);
        newEntry->tAddressLen = entry->snmp_target_addr_len;
        memcpy(newEntry->tAddress, entry->taddr.snmp_target_addr_taddress, entry->snmp_target_addr_len);
        newEntry->timeout = entry->snmp_target_addr_timeout;
        newEntry->retryCount = entry->snmp_target_addr_retry_count;
        newEntry->tagList = strdup((char *)entry->snmp_target_addr_tag_list);
        newEntry->params = strdup(entry->snmp_target_addr_params);
        newEntry->storageType = entry->snmp_target_addr_storage_type;
        newEntry->rowStatus = entry->snmp_target_addr_row_status;
        newEntry->sess = (netsnmp_session *) NULL;
        newEntry->sessionCreationTime= 0;
        newEntry->next = 0;
    }
    entry_addr = get_addrTableAddress();
    if (snmpTargetAddrTable_addToList( newEntry, entry_addr))
    {


        return SNMP_MGR_ERROR_OK;
    }
    else
    {


         return SNMP_MGR_ERROR_FAIL;
    }
}


/*--------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_GetSnmpTargetAddrTable
 *---------------------------------------------------------------------------
 * PURPOSE:  This function will retrieve the snmpTargetAddrTable in Rfc3413 Target MIB
 * INPUT:    entry->snmp_target_addr_name
 * OUTPUT:   entry.
 * RETURN:  1. success:    SNMP_MGR_ERROR_OK
 *          2. failure:    SNMP_MGR_ERROR_NO_ENTRY_EXIST
 *                         SNMP_MGR_ERROR_FAIL
 *
 * NOTE:    none.
 *---------------------------------------------------------------------------
 */
UI32_T SNMP_MGR_GetSnmpTargetAddrTable(SNMP_MGR_SnmpTargetAddrEntry_T *entry)
{
    static struct targetAddrTable_struct *tp;
    static struct targetAddrTable_struct *target_addr_list;
    UI32_T orig_priority;

    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);

   /* get the variable store in snmpTargetAddrEntry*/
    target_addr_list = get_addrTable();
    if (!target_addr_list)
    {


        return SNMP_MGR_ERROR_NO_ENTRY_EXIST;
    }

   /* find the next entry*/
    for (tp = target_addr_list; tp; tp = tp->next)
    {
        if (strcmp(tp->name, entry->snmp_target_addr_name) == 0)
        {
            break;
        }
    }
    if (tp)
    {
        strcpy(entry->snmp_target_addr_name, tp->name);
        if (tp->tDomain != NULL)
        {
            memcpy(entry->snmp_target_addr_tdomain, tp->tDomain, tp->tDomainLen * sizeof(oid));
            entry->snmp_target_addr_tdomain_len = tp->tDomainLen;
        }
        else
        {
            memset(entry->snmp_target_addr_tdomain, 0, 10);
            entry->snmp_target_addr_tdomain_len = 0;
        }
        if (tp->tAddress != NULL)
        {
            memcpy(entry->taddr.snmp_target_addr_taddress, tp->tAddress, tp->tAddressLen);
            entry->snmp_target_addr_len = tp->tAddressLen;
        }
        else
        {
            memset(entry->taddr.snmp_target_addr_taddress, 0, sizeof(entry->taddr.snmp_target_addr_taddress));
            entry->snmp_target_addr_len = 0;
        }
        entry->snmp_target_addr_timeout = (UI32_T)tp->timeout;
        entry->snmp_target_addr_retry_count = (UI32_T) tp->retryCount;
        strcpy((char *)entry->snmp_target_addr_tag_list, tp->tagList);
        if (tp->params != NULL)
        {
            strcpy(entry->snmp_target_addr_params , tp->params);
        }
        else
        {
            strcpy(entry->snmp_target_addr_params, "");
        }
        entry->snmp_target_addr_storage_type = tp->storageType;
        entry->snmp_target_addr_row_status = tp->rowStatus;


        return SNMP_MGR_ERROR_OK;
    }
    else
    {


        return SNMP_MGR_ERROR_FAIL;
    }
}

/*--------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_DeleteSnmpTargetAddrTable
 *---------------------------------------------------------------------------
 * PURPOSE:  This function will delete the snmpTargetAddrTable in Rfc3413 Target MIB
 * INPUT:    snmp_target_addr_name
 * OUTPUT:   entry.
 * RETURN:  1. success:    SNMP_MGR_ERROR_OK
 *          2. failure:    SNMP_MGR_ERROR_NO_ENTRY_EXIST
 *                         SNMP_MGR_ERROR_FAIL
 *
 * NOTE:    none.
 *---------------------------------------------------------------------------
 */
static UI32_T SNMP_MGR_DeleteSnmpTargetAddrTable(char  *snmp_target_addr_name)
{
    static struct targetAddrTable_struct *tp;
    static struct targetAddrTable_struct *target_addr_list;
    static struct targetAddrTable_struct **target_addr_list_address;
    UI32_T orig_priority;

    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);

   /* get the variable store in snmpTargetAddrEntry*/
    target_addr_list = get_addrTable();
    target_addr_list_address = get_addrTableAddress();

    if (!target_addr_list)
    {


        return SNMP_MGR_ERROR_NO_ENTRY_EXIST;
    }
   /* find the next entry*/
    for (tp = target_addr_list; tp; tp = tp->next)
    {
        if (strcmp(tp->name, (char *)snmp_target_addr_name) == 0)
        {
            break;
        }
    }
   /* find an entry, remove it */
    if (tp)
    {
        snmpTargetAddrTable_remFromList(tp, (struct targetAddrTable_struct **)target_addr_list_address);


        return SNMP_MGR_ERROR_OK;
    }
    else
    {


        return SNMP_MGR_ERROR_FAIL;
    }
}


/*--------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_CreateSnmpNotifyTable
 *---------------------------------------------------------------------------
 * PURPOSE:  This function will create snmpNotify in Rfc3413 Notify MIB
 * INPUT:    entry
 * OUTPUT:   entry.
 * RETURN:  1. success:    SNMP_MGR_ERROR_OK
 *          2. failure:    SNMP_MGR_ERROR_EXCEED_LIMIT
 *                         SNMP_MGR_ERROR_MEM_ALLOC_FAIL
 *
 * NOTE:   The max number of targetAddr entry is SNMP_MGR_MAX_NBR_OF_NOTIFY_ENTRY,
 *         the entry will not created if it already reached it max.
 *---------------------------------------------------------------------------
 */
static UI32_T SNMP_MGR_CreateSnmpNotifyTable(SNMP_MGR_SnmpNotifyEntry_T *entry)
{
    struct snmpNotifyTable_data     *snmp_vm_notify_ptr;
    SNMP_MGR_SnmpNotifyEntry_T      local_entry;
    UI32_T orig_priority;
    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);
    snmp_vm_notify_ptr = SNMP_MALLOC_STRUCT(snmpNotifyTable_data);

    if (snmp_vm_notify_ptr == NULL)
    {

        return SNMP_MGR_ERROR_MEM_ALLOC_FAIL;
    }

    memcpy( &local_entry, entry, sizeof(local_entry));
    /* check if the entry exist, if exist, delete it */
    if (SNMP_MGR_GetSnmpNotifyTable(&local_entry)== SNMP_MGR_ERROR_OK)
    {
        if (SNMP_MGR_DeleteSnmpNotifyTable((UI8_T *)local_entry.snmp_notify_name)!= SNMP_MGR_ERROR_OK)
        {

            return SNMP_MGR_ERROR_FAIL;
        }
    }

    snmp_vm_notify_ptr->snmpNotifyName = strdup(entry->snmp_notify_name);
    snmp_vm_notify_ptr->snmpNotifyNameLen = strlen(entry->snmp_notify_name);
    snmp_vm_notify_ptr->snmpNotifyTag = strdup(entry->snmp_notify_tag);
    snmp_vm_notify_ptr->snmpNotifyTagLen = strlen(entry->snmp_notify_tag);
    snmp_vm_notify_ptr->snmpNotifyType = entry->snmp_notify_type;
    snmp_vm_notify_ptr->snmpNotifyStorageType = entry->snmp_notify_storage_type;
    snmp_vm_notify_ptr->snmpNotifyRowStatus = entry->snmp_notify_row_status;
    snmpNotifyTable_add(snmp_vm_notify_ptr);


    return SNMP_MGR_ERROR_OK;
}

/*--------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_GetSnmpNotifyTable
 *---------------------------------------------------------------------------
 * PURPOSE:  This function will retrieve the snmpNotifyTable in Rfc3413 Notify MIB
 * INPUT:    entry->snmp_notify_name
 * OUTPUT:   entry.
 * RETURN:  1. success:    SNMP_MGR_ERROR_OK
 *          2. failure:    SNMP_MGR_ERROR_PARAMETER_NOT_MATCH
 *                         SNMP_MGR_ERROR_FAIL
 *
 * NOTE:    none.
 *---------------------------------------------------------------------------
 */
static UI32_T SNMP_MGR_GetSnmpNotifyTable(SNMP_MGR_SnmpNotifyEntry_T *entry)
{
    struct snmpNotifyTable_data *StorageTmp = NULL;
    struct header_complex_index* snmpNotifyTableStorage=NULL;
    size_t newlen;
    oid    name[MAXSIZE_snmpNotifyName+1];
    int i;
    UI32_T orig_priority;
    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);


    newlen = strlen(entry->snmp_notify_name);
    snmpNotifyTableStorage = SNMP_NOTIFY_TABLE_GetNotifyList();

   /* check if input len is exceed the maximum len*/
    if (newlen >= MAXSIZE_snmpNotifyName)
    {


        return SNMP_MGR_ERROR_PARAMETER_NOT_MATCH;
    }
   /* copy the notify name into the oid array */
    for (i = 0; i < newlen; i++)
    {
        name[i]= (oid) entry->snmp_notify_name[i];
    }
    if ((StorageTmp = (struct snmpNotifyTable_data *)
        header_complex((struct header_complex_index *)
        snmpNotifyTableStorage, NULL,
        name, &newlen, 1, NULL,
        NULL)) == NULL)
    {


        return SNMP_MGR_ERROR_FAIL;
    }
    else
    {
        strncpy(entry->snmp_notify_name, StorageTmp->snmpNotifyName, StorageTmp->snmpNotifyNameLen);
        entry->snmp_notify_name[StorageTmp->snmpNotifyNameLen] = '\0';
        strncpy(entry->snmp_notify_tag, StorageTmp->snmpNotifyTag, StorageTmp->snmpNotifyTagLen);
        entry->snmp_notify_tag[StorageTmp->snmpNotifyTagLen] = '\0';
        entry->snmp_notify_type = StorageTmp->snmpNotifyType;
        entry->snmp_notify_storage_type = StorageTmp->snmpNotifyStorageType;
        entry->snmp_notify_row_status = StorageTmp->snmpNotifyRowStatus;


        return SNMP_MGR_ERROR_OK;
    }
}


/*--------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_GetNextSnmpNotifyTable
 *---------------------------------------------------------------------------
 * PURPOSE:  This function will retrieve the next snmNotifyTable in Rfc3413 notify MIB
 * INPUT:    snmp_notify_name
 * OUTPUT:   entry.
 * RETURN:  1. success:    SNMP_MGR_ERROR_OK
 *          2. failure:    SNMP_MGR_ERROR_PARAMETER_NOT_MATCH
 *                         SNMP_MGR_ERROR_FAIL
 *
 * NOTE:    none.
 *---------------------------------------------------------------------------
 */
static UI32_T SNMP_MGR_GetNextSnmpNotifyTable(SNMP_MGR_SnmpNotifyEntry_T *entry)
{
    struct snmpNotifyTable_data *StorageTmp = NULL;
    struct header_complex_index* snmpNotifyTableStorage=NULL;
    size_t newlen;
    oid    name[MAXSIZE_snmpNotifyName+1];
    int i;
    UI32_T orig_priority;

    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);

    newlen = strlen(entry->snmp_notify_name);

    snmpNotifyTableStorage = SNMP_NOTIFY_TABLE_GetNotifyList();

   /* check if input len is exceed the maximum len*/
    if (newlen >= MAXSIZE_snmpNotifyName)
    {


        return SNMP_MGR_ERROR_PARAMETER_NOT_MATCH;
    }

   /* copy the notify name into the oid array */
    for (i = 0; i < newlen; i++)
    {
        name[i]= (oid) entry->snmp_notify_name[i];
    }
    if ((StorageTmp = (struct snmpNotifyTable_data *)
        header_complex((struct header_complex_index *)
        snmpNotifyTableStorage, NULL,
        name, &newlen, 0, NULL,
        NULL)) == NULL)
    {


        return SNMP_MGR_ERROR_FAIL;
    }
    else
    {
        strncpy(entry->snmp_notify_name, StorageTmp->snmpNotifyName, StorageTmp->snmpNotifyNameLen);
        entry->snmp_notify_name[StorageTmp->snmpNotifyNameLen] = '\0';
        strncpy(entry->snmp_notify_tag, StorageTmp->snmpNotifyTag, StorageTmp->snmpNotifyTagLen);
        entry->snmp_notify_tag[StorageTmp->snmpNotifyTagLen] = '\0';
        entry->snmp_notify_type = StorageTmp->snmpNotifyType;
        entry->snmp_notify_storage_type = StorageTmp->snmpNotifyStorageType;
        entry->snmp_notify_row_status = StorageTmp->snmpNotifyRowStatus;


        return SNMP_MGR_ERROR_OK;
    }
}


/*--------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_DeleteSnmpNotifyTable
 *---------------------------------------------------------------------------
 * PURPOSE:  This function will delete the snmNotifyTable in Rfc3413 notify MIB
 * INPUT:    snmp_notify_name
 * OUTPUT:   entry.
 * RETURN:  1. success:    SNMP_MGR_ERROR_OK
 *          2. failure:    SNMP_MGR_ERROR_NO_ENTRY_EXIST
 *                         SNMP_MGR_ERROR_FAIL
 *                         SNMP_MGR_ERROR_PARAMETER_NOT_MATCH
 *
 * NOTE:    none.
 *---------------------------------------------------------------------------
 */
static UI32_T SNMP_MGR_DeleteSnmpNotifyTable( UI8_T  *snmp_notify_name)
{
    struct snmpNotifyTable_data *StorageTmp = NULL, *StorageDel= NULL;
    struct header_complex_index* snmpNotifyTableStorage=NULL, *hciptr= NULL;
    struct header_complex_index** snmpNotifyTableStorageAddr=NULL;
    SNMP_MGR_SnmpNotifyEntry_T entry;
    size_t newlen;
    oid  name[MAXSIZE_snmpNotifyName+1];
    int i;
    UI32_T orig_priority;

    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);
   /* Step 1:  Check if the entry is exist, if not, return SNMP_MGR_ERROR_NO_ENTRY_EXIST*/

    memset(&entry, 0, sizeof(entry));
    strcpy( entry.snmp_notify_name, (char *)snmp_notify_name);
    if (SNMP_MGR_GetSnmpNotifyTable(&entry) != SNMP_MGR_ERROR_OK)
    {

        return SNMP_MGR_ERROR_NO_ENTRY_EXIST;
    }
   /* Step 2:  Begin to fetch the value and remove it*/


    newlen = (size_t)strlen((char *)snmp_notify_name);

    snmpNotifyTableStorage = SNMP_NOTIFY_TABLE_GetNotifyList();
    snmpNotifyTableStorageAddr = SNMP_NOTIFY_TABLE_GetNotifyListAddr();
   /* check if input len is exceed the maximum len*/
    if (newlen >= MAXSIZE_snmpNotifyName)
    {


        return SNMP_MGR_ERROR_PARAMETER_NOT_MATCH;
    }

   /* copy the notify name into the oid array */
    for (i = 0; i < newlen; i++)
    {
       name[i]= (oid)snmp_notify_name[i];
    }
    if ((StorageTmp = (struct snmpNotifyTable_data *)
        header_complex((struct header_complex_index *)
        snmpNotifyTableStorage, NULL,
        name, &newlen, 1, NULL,
        NULL)) == NULL)
    {


        return SNMP_MGR_ERROR_FAIL;
    }
    hciptr = header_complex_find_entry(snmpNotifyTableStorage,StorageTmp);
    StorageDel = (struct snmpNotifyTable_data *)
                 header_complex_extract_entry((struct header_complex_index **)
                 snmpNotifyTableStorageAddr, hciptr);
    if (StorageTmp->snmpNotifyName)
    {
        free(StorageTmp->snmpNotifyName);
    }
    if (StorageTmp->snmpNotifyTag )
    {
         free(StorageTmp->snmpNotifyTag );
    }
    free(StorageTmp);

    SNMP_MGR_AdjustSnmpV3NotifyCounter(FALSE);

    return SNMP_MGR_ERROR_OK;
}


/* snmpNotifyFilterProfileTable */

/*--------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_CreateSnmpNotifyFilterProfileTable
 *---------------------------------------------------------------------------
 * PURPOSE:  This function will create snmpNotifyFilterProfileTable in Rfc3413 Notify MIB
 * INPUT:    entry
 * OUTPUT:   entry.
 * RETURN:  1. success:    SNMP_MGR_ERROR_OK
 *          2. failure:    SNMP_MGR_ERROR_EXCEED_LIMIT
 *                         SNMP_MGR_ERROR_MEM_ALLOC_FAIL
 *
 * NOTE:   The max number of targetAddr entry is SNMP_MGR_MAX_NBR_OF_NOTIFY_FILTER_PROFILE_ENTRY,
 *         the entry will not created if it already reached it max.
 *---------------------------------------------------------------------------
 */
static UI32_T SNMP_MGR_CreateSnmpNotifyFilterProfileTable(SNMP_MGR_SnmpNotifyFilterProfileEntry_T *entry)
{
    struct snmpNotifyFilterProfileTable_data *snmp_vm_notify_filter_profile_ptr;
    SNMP_MGR_SnmpNotifyFilterProfileEntry_T  local_entry;
    UI32_T orig_priority;

    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);
    snmp_vm_notify_filter_profile_ptr = SNMP_MALLOC_STRUCT(snmpNotifyFilterProfileTable_data);

    if (snmp_vm_notify_filter_profile_ptr == NULL)
    {
        return SNMP_MGR_ERROR_MEM_ALLOC_FAIL;
    }

    /* check if the entry exist, if exist, delete it
     */
    memset(&local_entry, 0, sizeof(local_entry));
    memcpy(&local_entry.snmp_notify_filter_profile_ip, &entry->snmp_notify_filter_profile_ip,
        sizeof(local_entry.snmp_notify_filter_profile_ip));

    if (SNMP_MGR_GetSnmpNotifyFilterProfileTable(&local_entry)== SNMP_MGR_ERROR_OK)
    {
        if (SNMP_MGR_DeleteSnmpNotifyFilterProfileTable(&local_entry)!= SNMP_MGR_ERROR_OK)
        {
            return SNMP_MGR_ERROR_FAIL;
        }
    }


    snmp_vm_notify_filter_profile_ptr->snmpTargetParamsName = strdup(entry->snmp_target_params_name);
    snmp_vm_notify_filter_profile_ptr->snmpTargetParamsNameLen = strlen(entry->snmp_target_params_name);
    snmp_vm_notify_filter_profile_ptr->snmpNotifyFilterProfileName = strdup(entry->snmp_notify_filter_profile_name);
    snmp_vm_notify_filter_profile_ptr->snmpNotifyFilterProfileNameLen = strlen(entry->snmp_notify_filter_profile_name);
    snmp_vm_notify_filter_profile_ptr->snmpNotifyFilterProfileStorType = entry->snmp_notify_filter_profile_stor_type;
    snmp_vm_notify_filter_profile_ptr->snmpNotifyFilterProfileRowStatus = entry->snmp_notify_filter_profile_row_status;
    snmpNotifyFilterProfileTable_add(snmp_vm_notify_filter_profile_ptr);

    return SNMP_MGR_ERROR_OK;
}

/*--------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_GetSnmpNotifyFilterProfileTable
 *---------------------------------------------------------------------------
 * PURPOSE:  This function will retrieve the snmpNotifyFilterProfileTable in Rfc3413 Notify MIB
 * INPUT:    entry->snmp_notify_filter_profile_ip - to specify a taget host ip.
 * OUTPUT:   entry.
 * RETURN:  1. success:    SNMP_MGR_ERROR_OK
 *          2. failure:    SNMP_MGR_ERROR_PARAMETER_NOT_MATCH
 *                         SNMP_MGR_ERROR_FAIL
 *
 * NOTE:    none.
 *---------------------------------------------------------------------------
 */
static UI32_T SNMP_MGR_GetSnmpNotifyFilterProfileTable(SNMP_MGR_SnmpNotifyFilterProfileEntry_T *entry)
{
    SNMP_MGR_TrapDestEntry_T local_entry;
    struct snmpNotifyFilterProfileTable_data *StorageTmp = NULL;
    struct header_complex_index* snmpNotifyFilterProfileTableStorage=NULL;
    size_t newlen;
    oid    name[MAXSIZE_snmpTargetParamsName+1];
    int i;
    UI32_T orig_priority;

    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);

    /* check host ip exist and get params name
     */
    memset(&local_entry, 0, sizeof(local_entry));
    memcpy(&local_entry.trap_dest_address, &entry->snmp_notify_filter_profile_ip,
        sizeof(local_entry.trap_dest_address));

    if (SNMP_MGR_GetTrapReceiver(&local_entry) != SNMP_MGR_ERROR_OK)
    {
        return SNMP_MGR_ERROR_PARAMETER_NOT_MATCH;
    }


    newlen = strlen(local_entry.trap_dest_target_params_name);

    /* copy the notify params name into the oid array
     */
    for (i = 0; i < newlen; i++)
    {
        name[i]= (oid) local_entry.trap_dest_target_params_name[i];
    }

    snmpNotifyFilterProfileTableStorage = SNMP_NOTIFY_FILTER_PROFILE_TABLE_GetNotifyFilterProfileList();

    if ((StorageTmp = (struct snmpNotifyFilterProfileTable_data  *)
        header_complex((struct header_complex_index *)
        snmpNotifyFilterProfileTableStorage, NULL,
        name, &newlen, 1, NULL,
        NULL)) == NULL)
    {

        return SNMP_MGR_ERROR_FAIL;
    }
    else
    {
        strncpy(entry->snmp_target_params_name, StorageTmp->snmpTargetParamsName, StorageTmp->snmpTargetParamsNameLen);
        entry->snmp_target_params_name[StorageTmp->snmpTargetParamsNameLen] = '\0';
        strncpy(entry->snmp_notify_filter_profile_name, StorageTmp->snmpNotifyFilterProfileName, StorageTmp->snmpNotifyFilterProfileNameLen);
        entry->snmp_notify_filter_profile_name[StorageTmp->snmpNotifyFilterProfileNameLen] = '\0';
        entry->snmp_notify_filter_profile_stor_type = StorageTmp->snmpNotifyFilterProfileStorType;
        entry->snmp_notify_filter_profile_row_status = StorageTmp->snmpNotifyFilterProfileRowStatus;

        return SNMP_MGR_ERROR_OK;
    }
}


/*--------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_GetNextSnmpNotifyFilterProfileTable
 *---------------------------------------------------------------------------
 * PURPOSE:  This function will retrieve the next SnmpNotifyFilterProfileTable in Rfc3413 notify MIB
 * INPUT:    entry->snmp_notify_filter_profile_ip - to specify a taget host ip.
 * OUTPUT:   entry.
 * RETURN:  1. success:    SNMP_MGR_ERROR_OK
 *          2. failure:    SNMP_MGR_ERROR_PARAMETER_NOT_MATCH
 *                         SNMP_MGR_ERROR_FAIL
 *
 * NOTE:    none.
 *---------------------------------------------------------------------------
 */
static UI32_T SNMP_MGR_GetNextSnmpNotifyFilterProfileTable(SNMP_MGR_SnmpNotifyFilterProfileEntry_T *entry)
{
    SNMP_MGR_TrapDestEntry_T local_entry;
    struct snmpNotifyFilterProfileTable_data *StorageTmp = NULL;
    struct header_complex_index* snmpNotifyFilterProfileTableStorage=NULL;
    size_t newlen;
    oid    name[MAXSIZE_snmpTargetParamsName+1];
    int i;
    UI32_T orig_priority;

    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);

    /* check host ip exist and get params name
     */
    memset(&local_entry, 0, sizeof(local_entry));
    memcpy(&local_entry.trap_dest_address, &entry->snmp_notify_filter_profile_ip,
        sizeof(local_entry.trap_dest_address));

    while (SNMP_MGR_GetNextTrapReceiver(&local_entry) == SNMP_MGR_ERROR_OK)
    {
        newlen = strlen(local_entry.trap_dest_target_params_name);

        /* copy the notify params name into the oid array
         */
        for (i = 0; i < newlen; i++)
        {
            name[i]= (oid) local_entry.trap_dest_target_params_name[i];
        }

        snmpNotifyFilterProfileTableStorage = SNMP_NOTIFY_FILTER_PROFILE_TABLE_GetNotifyFilterProfileList();

        if ((StorageTmp = (struct snmpNotifyFilterProfileTable_data *)
            header_complex((struct header_complex_index *)
            snmpNotifyFilterProfileTableStorage, NULL,
            name, &newlen, 1, NULL,
            NULL)) != NULL)
        {

            memcpy(&entry->snmp_notify_filter_profile_ip, &local_entry.trap_dest_address, sizeof(entry->snmp_notify_filter_profile_ip));
            strncpy(entry->snmp_target_params_name, StorageTmp->snmpTargetParamsName, StorageTmp->snmpTargetParamsNameLen);
            entry->snmp_target_params_name[StorageTmp->snmpTargetParamsNameLen] = '\0';
            strncpy(entry->snmp_notify_filter_profile_name, StorageTmp->snmpNotifyFilterProfileName, StorageTmp->snmpNotifyFilterProfileNameLen);
            entry->snmp_notify_filter_profile_name[StorageTmp->snmpNotifyFilterProfileNameLen] = '\0';
            entry->snmp_notify_filter_profile_stor_type = StorageTmp->snmpNotifyFilterProfileStorType;
            entry->snmp_notify_filter_profile_row_status = StorageTmp->snmpNotifyFilterProfileRowStatus;

            return SNMP_MGR_ERROR_OK;
        }
    }

    return SNMP_MGR_ERROR_PARAMETER_NOT_MATCH;
}


/*--------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_DeleteSnmpNotifyFilterProfileTable
 *---------------------------------------------------------------------------
 * PURPOSE:  This function will delete the snmNotifyFilterProfileTable in Rfc3413 notify MIB
 * INPUT:    entry->snmp_notify_filter_profile_ip - to specify a taget host ip.
 * OUTPUT:   entry.
 * RETURN:  1. success:    SNMP_MGR_ERROR_OK
 *          2. failure:    SNMP_MGR_ERROR_NO_ENTRY_EXIST
 *                         SNMP_MGR_ERROR_FAIL
 *                         SNMP_MGR_ERROR_PARAMETER_NOT_MATCH
 *
 * NOTE:    none.
 *---------------------------------------------------------------------------
 */
static UI32_T SNMP_MGR_DeleteSnmpNotifyFilterProfileTable(SNMP_MGR_SnmpNotifyFilterProfileEntry_T *entry)
{
    struct snmpNotifyFilterProfileTable_data *StorageTmp = NULL, *StorageDel= NULL;
    struct header_complex_index* snmpNotifyFilterProfileTableStorage=NULL, *hciptr= NULL;
    struct header_complex_index** snmpNotifyFilterProfileTableStorageAddr=NULL;
    SNMP_MGR_SnmpNotifyFilterProfileEntry_T local_entry;
    size_t newlen;
    oid  name[MAXSIZE_snmpTargetParamsName+1];
    int i;
    UI32_T orig_priority;

    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);

    /* Step 1:  Check if the entry is exist, if not, return SNMP_MGR_ERROR_NO_ENTRY_EXIST
     */
    memset(&local_entry, 0, sizeof(local_entry));
    memcpy(&local_entry.snmp_notify_filter_profile_ip, &entry->snmp_notify_filter_profile_ip,
        sizeof(local_entry.snmp_notify_filter_profile_ip));

    if (SNMP_MGR_GetSnmpNotifyFilterProfileTable(&local_entry) != SNMP_MGR_ERROR_OK)
    {
        return SNMP_MGR_ERROR_NO_ENTRY_EXIST;
    }

    /* Step 2:  Begin to fetch the value and remove it
     */

    newlen = (size_t)strlen(local_entry.snmp_target_params_name);

    /* copy the notify params name into the oid array
     */
    for (i = 0; i < newlen; i++)
    {
       name[i]= (oid)local_entry.snmp_target_params_name[i];
    }

    snmpNotifyFilterProfileTableStorage = SNMP_NOTIFY_FILTER_PROFILE_TABLE_GetNotifyFilterProfileList();
    snmpNotifyFilterProfileTableStorageAddr = SNMP_NOTIFY_FILTER_PROFILE_TABLE_GetNotifyFilterProfileListAddr();

    if ((StorageTmp = (struct snmpNotifyFilterProfileTable_data *)
        header_complex((struct header_complex_index *)
        snmpNotifyFilterProfileTableStorage, NULL,
        name, &newlen, 1, NULL,
        NULL)) == NULL)
    {

        return SNMP_MGR_ERROR_FAIL;
    }

    hciptr = header_complex_find_entry(snmpNotifyFilterProfileTableStorage,StorageTmp);
    StorageDel = (struct snmpNotifyFilterProfileTable_data *)
                 header_complex_extract_entry((struct header_complex_index **)
                 snmpNotifyFilterProfileTableStorageAddr, hciptr);
    SNMP_MGR_AdjustSnmpV3NotifyFilterProfileCounter(FALSE);

    if (StorageTmp->snmpTargetParamsName)
    {
        free(StorageTmp->snmpTargetParamsName);
    }

    if (StorageTmp->snmpNotifyFilterProfileName)
    {
        free(StorageTmp->snmpNotifyFilterProfileName);
    }

    free(StorageTmp);

    return SNMP_MGR_ERROR_OK;
}



/*--------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_CreateSnmpNotifyFilterTable
 *---------------------------------------------------------------------------
 * PURPOSE:  This function will create snmpNotifyFilterTable in Rfc3413 Notify MIB
 * INPUT:    entry
 * OUTPUT:   entry.
 * RETURN:  1. success:    SNMP_MGR_ERROR_OK
 *          2. failure:    SNMP_MGR_ERROR_EXCEED_LIMIT
 *                         SNMP_MGR_ERROR_MEM_ALLOC_FAIL
 *
 * NOTE:   The max number of targetAddr entry is SNMP_MGR_MAX_NBR_OF_NOTIFY_FILTER_PROFILE_ENTRY,
 *         the entry will not created if it already reached it max.
 *---------------------------------------------------------------------------
 */
static UI32_T SNMP_MGR_CreateSnmpNotifyFilterTable(SNMP_MGR_SnmpNotifyFilterEntry_T *entry)
{
    struct snmpNotifyFilterTable_data *snmp_vm_notify_filter_ptr;
    SNMP_MGR_SnmpNotifyFilterEntry_T      local_entry;
    UI32_T orig_priority;
    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);
    snmp_vm_notify_filter_ptr = SNMP_MALLOC_STRUCT(snmpNotifyFilterTable_data);

    if (snmp_vm_notify_filter_ptr == NULL)
    {

        return SNMP_MGR_ERROR_MEM_ALLOC_FAIL;
    }

    memcpy( &local_entry, entry, sizeof(local_entry));
    /* check if the entry exist, if exist, delete it */
    if (SNMP_MGR_GetSnmpNotifyFilterTable(&local_entry)== SNMP_MGR_ERROR_OK)
    {
        if (SNMP_MGR_DeleteSnmpNotifyFilterTable(local_entry.snmp_notify_filter_profile_name, local_entry.snmp_notify_filter_subtree, local_entry.snmp_notify_filter_subtree_len)!= SNMP_MGR_ERROR_OK)
        {

            return SNMP_MGR_ERROR_FAIL;
        }
    }

    snmp_vm_notify_filter_ptr->snmpNotifyFilterProfileName = strdup(entry->snmp_notify_filter_profile_name);
    snmp_vm_notify_filter_ptr->snmpNotifyFilterProfileNameLen = strlen(entry->snmp_notify_filter_profile_name);
    memdup((u_char**)&snmp_vm_notify_filter_ptr->snmpNotifyFilterSubtree, (u_char*)&entry->snmp_notify_filter_subtree, entry->snmp_notify_filter_subtree_len*sizeof(oid));
    snmp_vm_notify_filter_ptr->snmpNotifyFilterSubtreeLen =entry->snmp_notify_filter_subtree_len;
    memdup((u_char**)& snmp_vm_notify_filter_ptr->snmpNotifyFilterMask, (u_char*)&entry->snmp_notify_filter_mask, entry->snmp_notify_filter_mask_len);
    snmp_vm_notify_filter_ptr->snmpNotifyFilterMaskLen = entry->snmp_notify_filter_mask_len;
    snmp_vm_notify_filter_ptr->snmpNotifyFilterType = entry->snmp_notify_filter_type;
    snmp_vm_notify_filter_ptr->snmpNotifyFilterStorageType = entry->snmp_notify_filter_storage_type;
    snmp_vm_notify_filter_ptr->snmpNotifyFilterRowStatus = entry->snmp_notify_filter_row_status;
    snmpNotifyFilterTable_add(snmp_vm_notify_filter_ptr);


    return SNMP_MGR_ERROR_OK;
}

/*--------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_GetSnmpNotifyFilterTable
 *---------------------------------------------------------------------------
 * PURPOSE:  This function will retrieve the snmpNotifyFilterTable in Rfc3413 Notify MIB
 * INPUT:    entry->snmp_target_params_name
 * OUTPUT:   entry.
 * RETURN:  1. success:    SNMP_MGR_ERROR_OK
 *          2. failure:    SNMP_MGR_ERROR_PARAMETER_NOT_MATCH
 *                         SNMP_MGR_ERROR_FAIL
 *
 * NOTE:    none.
 *---------------------------------------------------------------------------
 */
static UI32_T SNMP_MGR_GetSnmpNotifyFilterTable(SNMP_MGR_SnmpNotifyFilterEntry_T *entry)
{
    struct snmpNotifyFilterTable_data *StorageTmp = NULL;
    struct header_complex_index* snmpNotifyFilterTableStorage=NULL;
    size_t newlen, newlen1, newlen2;
    oid    name[MAXSIZE_snmpNotifyFilterProfileName+MAXSIZE_VIEW_SUBTREE+2];
    int i;
    UI32_T orig_priority;
    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);


    newlen1 = strlen(entry->snmp_notify_filter_profile_name);
    newlen2 = entry->snmp_notify_filter_subtree_len;
    snmpNotifyFilterTableStorage = SNMP_NOTIFY_FILTER_TABLE_GetNotifyFilterList();

   /* check if input len is exceed the maximum len*/
    if ((newlen1 > MAXSIZE_snmpNotifyFilterProfileName) || (newlen2> MAXSIZE_VIEW_SUBTREE))
    {


        return SNMP_MGR_ERROR_PARAMETER_NOT_MATCH;
    }
    newlen = newlen1+newlen2+1;
   /* copy the notify name into the oid array */
    name[0] = strlen(entry->snmp_notify_filter_profile_name);
    for (i = 0; i < newlen1; i++)
    {
        name[i+1]= (oid) entry->snmp_notify_filter_profile_name[i];
    }
    //name[newlen1+1]= entry->snmp_notify_filter_subtree_len;
    for (i = 0; i< newlen2; i++)
    {
        name[newlen1+1+i]= (oid) entry->snmp_notify_filter_subtree[i];
    }

    if ((StorageTmp = (struct snmpNotifyFilterTable_data  *)
        header_complex((struct header_complex_index *)
        snmpNotifyFilterTableStorage, NULL,
        name, &newlen, 1, NULL,
        NULL)) == NULL)
    {


        return SNMP_MGR_ERROR_FAIL;
    }
    else
    {
        strncpy(entry->snmp_notify_filter_profile_name, StorageTmp->snmpNotifyFilterProfileName, StorageTmp->snmpNotifyFilterProfileNameLen);
        entry->snmp_notify_filter_profile_name[StorageTmp->snmpNotifyFilterProfileNameLen] = '\0';
        memcpy(&entry->snmp_notify_filter_subtree, StorageTmp->snmpNotifyFilterSubtree, StorageTmp->snmpNotifyFilterSubtreeLen*sizeof(oid));
        entry->snmp_notify_filter_subtree_len = StorageTmp->snmpNotifyFilterSubtreeLen;
        memcpy(&entry->snmp_notify_filter_mask, StorageTmp->snmpNotifyFilterMask, StorageTmp->snmpNotifyFilterMaskLen);
        entry->snmp_notify_filter_mask_len = StorageTmp->snmpNotifyFilterMaskLen;
        entry->snmp_notify_filter_type = StorageTmp->snmpNotifyFilterType;
        entry->snmp_notify_filter_storage_type = StorageTmp->snmpNotifyFilterStorageType;
        entry->snmp_notify_filter_row_status = StorageTmp->snmpNotifyFilterRowStatus;


        return SNMP_MGR_ERROR_OK;
    }
}


/*--------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_GetNextSnmpNotifyFilterTable
 *---------------------------------------------------------------------------
 * PURPOSE:  This function will retrieve the next SnmpNotifyFilterTable in Rfc3413 notify MIB
 * INPUT:    snmp_target_params_name
 * OUTPUT:   entry.
 * RETURN:  1. success:    SNMP_MGR_ERROR_OK
 *          2. failure:    SNMP_MGR_ERROR_PARAMETER_NOT_MATCH
 *                         SNMP_MGR_ERROR_FAIL
 *
 * NOTE:    none.
 *---------------------------------------------------------------------------
 */
static UI32_T SNMP_MGR_GetNextSnmpNotifyFilterTable(SNMP_MGR_SnmpNotifyFilterEntry_T *entry)
{
    struct snmpNotifyFilterTable_data *StorageTmp = NULL;
    struct header_complex_index* snmpNotifyFilterTableStorage=NULL;
    size_t newlen, newlen1, newlen2;
    oid    name[MAXSIZE_snmpNotifyFilterProfileName+MAXSIZE_VIEW_SUBTREE+2];
    int i;
    UI32_T orig_priority;
    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);


    newlen1 = strlen(entry->snmp_notify_filter_profile_name);
    newlen2 = entry->snmp_notify_filter_subtree_len;
    snmpNotifyFilterTableStorage = SNMP_NOTIFY_FILTER_TABLE_GetNotifyFilterList();

   /* check if input len is exceed the maximum len*/
    if ((newlen1 > MAXSIZE_snmpNotifyFilterProfileName) || (newlen2> MAXSIZE_VIEW_SUBTREE))
    {


        return SNMP_MGR_ERROR_PARAMETER_NOT_MATCH;
    }
    newlen = newlen1+newlen2+1;
   /* copy the notify name into the oid array */
    name[0] = strlen(entry->snmp_notify_filter_profile_name);
    for (i = 0; i < newlen1; i++)
    {
        name[i+1]= (oid) entry->snmp_notify_filter_profile_name[i];
    }
    for (i = 0; i< newlen2; i++)
    {
        name[newlen1+1+i]= (oid) entry->snmp_notify_filter_subtree[i];
    }

    if ((StorageTmp = (struct snmpNotifyFilterTable_data  *)
        header_complex((struct header_complex_index *)
        snmpNotifyFilterTableStorage, NULL,
        name, &newlen, 0, NULL,
        NULL)) == NULL)
    {


        return SNMP_MGR_ERROR_FAIL;
    }
    else
    {
        strncpy(entry->snmp_notify_filter_profile_name, StorageTmp->snmpNotifyFilterProfileName, StorageTmp->snmpNotifyFilterProfileNameLen);
        entry->snmp_notify_filter_profile_name[StorageTmp->snmpNotifyFilterProfileNameLen] = '\0';
        memcpy(&entry->snmp_notify_filter_subtree, StorageTmp->snmpNotifyFilterSubtree, StorageTmp->snmpNotifyFilterSubtreeLen*sizeof(oid));
        entry->snmp_notify_filter_subtree_len = StorageTmp->snmpNotifyFilterSubtreeLen;
        memcpy(&entry->snmp_notify_filter_mask, StorageTmp->snmpNotifyFilterMask, StorageTmp->snmpNotifyFilterMaskLen);
        entry->snmp_notify_filter_mask_len = StorageTmp->snmpNotifyFilterMaskLen;
        entry->snmp_notify_filter_type = StorageTmp->snmpNotifyFilterType;
        entry->snmp_notify_filter_storage_type = StorageTmp->snmpNotifyFilterStorageType;
        entry->snmp_notify_filter_row_status = StorageTmp->snmpNotifyFilterRowStatus;


        return SNMP_MGR_ERROR_OK;
    }
}


/*--------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_DeleteSnmpNotifyFilterTable
 *---------------------------------------------------------------------------
 * PURPOSE:  This function will delete the snmNotifyFilterTable in Rfc3413 notify MIB
 * INPUT:    snmp_target_params_name
 * OUTPUT:   entry.
 * RETURN:  1. success:    SNMP_MGR_ERROR_OK
 *          2. failure:    SNMP_MGR_ERROR_NO_ENTRY_EXIST
 *                         SNMP_MGR_ERROR_FAIL
 *                         SNMP_MGR_ERROR_PARAMETER_NOT_MATCH
 *
 * NOTE:    none.
 *---------------------------------------------------------------------------
 */
static UI32_T SNMP_MGR_DeleteSnmpNotifyFilterTable( char  *snmp_notify_filter_profile_name, oid *snmp_notify_filter_subtree, UI32_T snmp_notify_filter_subtree_len)
{
    struct snmpNotifyFilterTable_data *StorageTmp = NULL, *StorageDel= NULL;
    struct header_complex_index* snmpNotifyFilterTableStorage=NULL, *hciptr= NULL;
    struct header_complex_index** snmpNotifyFilterTableStorageAddr=NULL;
    SNMP_MGR_SnmpNotifyFilterEntry_T entry;
    size_t newlen, newlen1, newlen2;
    oid  name[MAXSIZE_snmpTargetParamsName+MAXSIZE_VIEW_SUBTREE+2];
    int i;
    UI32_T orig_priority;
    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);
   /* Step 1:  Check if the entry is exist, if not, return SNMP_MGR_ERROR_NO_ENTRY_EXIST*/

    memset(&entry, 0, sizeof(entry));
    strcpy( entry.snmp_notify_filter_profile_name, snmp_notify_filter_profile_name);
    entry.snmp_notify_filter_subtree_len = snmp_notify_filter_subtree_len;
    memcpy( &entry.snmp_notify_filter_subtree, snmp_notify_filter_subtree, snmp_notify_filter_subtree_len*sizeof(oid));

    if (SNMP_MGR_GetSnmpNotifyFilterTable(&entry) != SNMP_MGR_ERROR_OK)
    {

        return SNMP_MGR_ERROR_NO_ENTRY_EXIST;
    }
   /* Step 2:  Begin to fetch the value and remove it*/


    newlen1 = (size_t)strlen(snmp_notify_filter_profile_name);
    newlen2 = snmp_notify_filter_subtree_len;

    snmpNotifyFilterTableStorage = SNMP_NOTIFY_FILTER_TABLE_GetNotifyFilterList();
    snmpNotifyFilterTableStorageAddr = SNMP_NOTIFY_FILTER_TABLE_GetNotifyFilterListAddr();
   /* check if input len is exceed the maximum len*/
    if ((newlen1 > strlen(snmp_notify_filter_profile_name)) || (newlen2 >MAXSIZE_VIEW_SUBTREE))
    {


        return SNMP_MGR_ERROR_PARAMETER_NOT_MATCH;
    }

    newlen = newlen1+newlen2+1;

    /* copy the notify name into the oid array */
    name[0] = strlen(snmp_notify_filter_profile_name);
    for (i = 0; i < newlen1; i++)
    {
        name[i+1]= (oid) snmp_notify_filter_profile_name[i];
    }
   // name[newlen1+1]= snmp_notify_filter_subtree_len;
    for (i = 0; i< newlen2; i++)
    {
        name[newlen1+1+i]= (oid) snmp_notify_filter_subtree[i];
    }
    if ((StorageTmp = (struct snmpNotifyFilterTable_data *)
        header_complex((struct header_complex_index *)
        snmpNotifyFilterTableStorage, NULL,
        name, &newlen, 1, NULL,
        NULL)) == NULL)
    {


        return SNMP_MGR_ERROR_FAIL;
    }
    hciptr = header_complex_find_entry(snmpNotifyFilterTableStorage,StorageTmp);
    StorageDel = (struct snmpNotifyFilterTable_data *)
                 header_complex_extract_entry((struct header_complex_index **)
                 snmpNotifyFilterTableStorageAddr, hciptr);
    if (StorageTmp->snmpNotifyFilterProfileName)
    {
        free(StorageTmp->snmpNotifyFilterProfileName);
    }
    if (StorageTmp->snmpNotifyFilterSubtree)
    {
        free(StorageTmp->snmpNotifyFilterSubtree);
    }
    if (StorageTmp->snmpNotifyFilterMask)
    {
        free(StorageTmp->snmpNotifyFilterMask);
    }
    free(StorageTmp);
    SNMP_MGR_AdjustSnmpV3NotifyFilterCounter(FALSE);


    return SNMP_MGR_ERROR_OK;
}


/*---------------------------------------------------------------------------------
 * Routine Name : SNMP_MGR_Transform_ViewWildcardToTree
 *---------------------------------------------------------------------------
 * Purpose :      This function will transform the wildcard view to subtree and mask
 * Input    :       wildcard
 * Output   :     subtree, mask
 * Return   :      TRUE/FALSE
 * Note     :       None
 *---------------------------------------------------------------------------*/
static BOOL_T  SNMP_MGR_Transform_ViewWildcardToTree(char  *wildcard,   char *subtree,  char *mask)
{
    char   *tp;
    UI32_T i,j ,k;
    UI32_T no;
    UI8_T  mask_bit[MAXSIZE_VIEW_MASK];
    UI32_T value = 0;
    BOOL_T jumpmask= TRUE;

    i=0;
    j=0;
   /* check if input len is larger than our desclared len*/
    if (strlen( wildcard) >  MAXSIZE_VIEW_SUBTREE)
        return FALSE;

    if (subtree == NULL )
    {
        return FALSE;
    }
   /* check the first character, it should be 1-9 or '*' */
    switch(*wildcard)
    {
     /* 49 -57 represent ASCII 1-9 */
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
        case 42:
            break;
        default:
            return FALSE;
    }

    for ( tp=wildcard, no = 0; ;tp++)
    {
   /*
    *  check vaild character, valid chararcter is 0-9, and * represent wildcard
    */
        switch (*tp)
        {
            case 0:
                break;
           /* 48 -57 represent ASCII 0-9,   0 represent NULL */
            case 48:
            case 49:
            case 50:
            case 51:
            case 52:
            case 53:
            case 54:
            case 55:
            case 56:
            case 57:
           /* 1. check if the next character is '1' to '9' or '.' or ''\0' if not, return FALSE
            * 2. if the next character is '1' to '9', mask need not to jump.
            */
                tp++;
                if (((*tp >= '0') && (*tp<= '9')) || (*tp == '.')|| (*tp == '\0'))
                {
                    if (( *tp == '.' ) ||  (*tp == '\0'))
                    {
                        jumpmask = TRUE;
                    }
                    else
                    {
                        jumpmask = FALSE;
                    }
                    tp--;
                    break;
                }
                else
                {
                    return FALSE;
                }
               /* to avoid continuous '* ' */
            case 42: /*    '*'  */
                tp ++;
                if (*tp == '*')
                {
                    return FALSE;
                }
                else
                {
                    tp--;
                }
                break;
               /* to avoid continuous '. ' */
            case 46: /*     '.'   */
                tp ++;
                if( (*tp == '.') || (*tp == '\0'))
                {
                    return FALSE;
                }
                else
                {
                    tp--;
                }
                break;

            default:
            return FALSE;
        }
        if (*tp == '*' )
        {
            strcpy(&subtree[i], "0");
            mask_bit[j++] =48;
        }
        else
        {
            if ((*tp != '.') && (*tp != '\0') && jumpmask)
            {
                mask_bit[j++]=49;
            }
            memcpy(&subtree[i], tp,1);
        }
        if ( *tp==0 )
        {
            break;
        }
        i++;
    }
    k =8-j %8;
    /* if k not equal to the multiple of 8, we need to append "0" at the end */
    if (k != 8)
    {
        for ( ;;)
        {
            mask_bit[j++]= 48;
            k --;
            if (k == 0)
            break;
        }
    }
    mask_bit[j] = '\0';

    if (!CONVERT_BinaryStrTo32BitValue((char *)mask_bit, &value))
        return FALSE;

    if (mask != NULL)
    {
        if (value <= 0xFF)
            SYSFUN_Sprintf(mask, "%X", ((int)value >>0 & 0x000000FF) );
        else if ( value<=0xFFFF)
            SYSFUN_Sprintf(mask, "%X:%X",((int) value >>8 & 0x000000FF), ((int)value >>0 &0x000000FF) );
        else if (value <=0xFFFFFF)
            SYSFUN_Sprintf(mask, "%X:%X:%X", ((int)value >>16 & 0x000000ff), ((int) value >>8 & 0x000000FF), ((int)value >>0 &0x000000FF) );
        else if (value <=0xFFFFFFFF)
            SYSFUN_Sprintf( mask, "%X:%X:%X:%X", ((int)value>>24), ((int)value >>16 & 0x000000ff), ((int)value>>8 & 0x000000FF), ((int)value >>0  & 0x000000FF) );
    }
    return TRUE;
} /* end of SNMP_MGR_Transform_ViewWildcardToTree() */


/*---------------------------------------------------------------------------------
 * Routine Name : SNMP_MGR_Transform_TreeToWildCard
 *---------------------------------------------------------------------------
 * Purpose :      This function will transform the subree and mask  to wildcard view
 * Input    :       wildcard
 * Output   :     subtree, mask, subtreeLen
 * Return   :      TRUE/FALSE
 * Note     :       None
 *---------------------------------------------------------------------------*/
static  BOOL_T  SNMP_MGR_Transform_TreeToWildCard(UI8_T  *wildcard,   UI8_T *subtree,  UI8_T *mask, UI32_T SubtreeLen)
{
    UI8_T  *tp;
    UI32_T i,j ,k;
    UI32_T no;
    UI8_T  mask_bit[MAXSIZE_VIEW_MASK];

    i = 0;
    j = 0;

    for ( k = 0; k<= SubtreeLen ; k++)
    {
        mask_bit [k] = mask[k/8] >>(7-k%8) & 1;
    }

   /* check if input len is larger than our desclared len*/
    if (strlen((char *)subtree) >  MAXSIZE_VIEW_SUBTREE)
    {
        return FALSE;
    }
    if (wildcard == NULL )
    {
        return FALSE;
    }
   /* check the first character, it should be 0-9 */
    switch(*subtree)
    {
   /* 48 -57 represent ASCII 0-9 */
        case 48:
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
            break;
        default:
            return FALSE;
    }

    for ( tp=subtree, no = 0; ;tp++)
    {
   /*
    *  check vaild character, valid chararcter is 0-9, and * represent wildcard
    */
        switch (*tp)
        {
            case 0:
                break;
           /* 48 -57 represent ASCII 0-9,   0 represent NULL */
            case 48:
            case 49:
            case 50:
            case 51:
            case 52:
            case 53:
            case 54:
            case 55:
            case 56:
            case 57:
           /* 1.  check if the next character is '0' to '9' , '.' or '\0' if not, return FALSE
            */
                tp++;
                if ( ((*tp >= '0') && (*tp<= '9')) || (*tp == '.')|| (*tp == '\0'))
                {
                    tp--;
                    break;
                }
                else
                {
                    return FALSE;
                }
           /* to avoid continuous '. ' or null after a '.' */
            case 46: /*     '.'   */
                tp ++;
                if ((*tp == '.')  || (*tp == '\0'))
                {
                    return FALSE;
                }
                else
                {
                    tp--;
                }
                break;
            default:
                return FALSE;
        }

        if (*tp == '\0')
        {
            break;
        }

        if (*tp == '.')
        {
            strcpy((char *)&wildcard[i], ".");
        }
        else
        {
       /* may be character '0' to '9' , if only mask bit =1 need to copy, otherwise copy a '*' to it */

       /* check if next character is a '.', if so, increase mask_Bit counter(j) by 1.*/

            tp++;
            if (( *tp == '.') || (*tp=='\0'))
            {
                tp--;
                if (mask_bit[j++])
                {
                    memcpy( &wildcard[i], tp, 1);
                }
                else
                {
                    strcpy((char *)&wildcard[i], "*");
                }
            }
            else
            {
                tp--;
                memcpy( &wildcard[i], tp, 1);
            }
        }
        i++;
    }   /* end of for */
    strcpy((char *)&wildcard[i], "\0");
    return TRUE;
} /* end of SNMP_MGR_Transform_ViewWildcardToTree() */


/*---------------------------------------------------------------------------------
 * Routine Name : CONVERT_BinaryStrTo32BitValue
 *---------------------------------------------------------------------------
 * Purpose :      This function will transform the binary string to a 32 bit value.
 * Input    :       str
 * Output   :     value
 * Return   :      TRUE/FALSE
 * Note     :       None
 *---------------------------------------------------------------------------*/

static BOOL_T  CONVERT_BinaryStrTo32BitValue(char *str, UI32_T *value)
{
    char   *local_str_ptr;
    UI32_T temp_value;

    local_str_ptr = str;
    temp_value    = 0;

    for(;;)
    {
        if (*local_str_ptr>='0' && *local_str_ptr<='1' )
        {
            temp_value*=2;
            temp_value += (*local_str_ptr - '0');
        }
        else if (*local_str_ptr == 0)
        {
            break;
        }
        else
        {
            return FALSE;
        }

        local_str_ptr++;
    }
    *value = temp_value;
    return TRUE;
}


/*---------------------------------------------------------------------------------
 * Routine Name : SNMP_MGR_ObjectIDToString
 *---------------------------------------------------------------------------
 * Purpose :      This function will transform the object ID to a string
 * Input    :       oid_P,obj_length
 * Output   :     text_p
 * Return   :      TRUE/FALSE
 * Note     :       None
 *---------------------------------------------------------------------------*/
static BOOL_T  SNMP_MGR_ObjectIDToString(oid *oid_P,  I8_T *text_p, UI32_T obj_length)
{
    UI32_T  i=0;
    UI32_T  j=0;
    char tmp_str[11];
    UI32_T tmp_str_len;

    if (text_p == NULL)
    {
        return FALSE;
    }
    for ( j = 0; j< obj_length;j++)
    {
        SYSFUN_Sprintf( tmp_str, "%lu.", (unsigned long)oid_P[j]);
        tmp_str_len =  strlen(tmp_str);
        memcpy(&text_p[i], tmp_str,tmp_str_len);
        i= i+tmp_str_len;
    }
    text_p[i-1]= '\0';
    return TRUE;
}


/*****************************************/
/* Convert string 's' to unsigned long,  */
/* with 'radix' as base.                 */
/* copy from CLI tempory, may need to    */
/* discuss should moved to CmnLib or not */
/*****************************************/

static UI32_T SNMP_MGR_AtoUl(char *s, int radix)
{
    int i;
    unsigned long n=0;

    for (i = 0; s[i] == ' ' || s[i] == '\n' || s[i] == '\t'; i++)
    {
        ;
    }
      /* skip white space */

    if (s[i] == '+' || s[i] == '-')
    {
        i++;    /* skip sign */
    }

    if (radix == 10)
    {
        for (n = 0; s[i] >= '0' && s[i] <= '9'; i++)
        {
            n = 10 * n + s[i] - '0';
        }
    }
    else if (radix == 16)
    {
        if ( (s[i] == '0') && (s[i+1] == 'x' || s[i+1] == 'X') ) // Charles,
        {
            i=i+2;                                                // To skip the "0x" or "0X"
        }
        for (n = 0;
            (s[i] >= '0' && s[i] <= '9') ||
            (s[i] >= 'A' && s[i] <= 'F') ||
            (s[i] >= 'a' && s[i] <= 'f');
            i++)
        {
            if (s[i] >= '0' && s[i] <= '9')
            {
                n = 16 * n + s[i] - '0';
            }
            else if (s[i] >= 'A' && s[i] <= 'F')
            {
                n = 16 * n + s[i] - 'A'+ 10;
            }
            else if (s[i] >= 'a' && s[i] <= 'f')
            {
                n = 16 * n + s[i] - 'a'+ 10;
            }
        }
    }
    return (n);
}

/*---------------------------------------------------------------------------------
 * Routine Name : SNMP_MGR_CheckValidOIDSring
 *---------------------------------------------------------------------------
 * Purpose :      This function will check if the OID string is valid
 * Input    :     text_p
 * Output   :     none
 * Return   :     TRUE/FALSE
 * Note     :     None
 *---------------------------------------------------------------------------*/
static BOOL_T SNMP_MGR_CheckValidOIDSring(UI8_T *text_p)
{
    UI8_T   *tp;
    UI32_T  no;
    UI32_T  oid[32];
    UI8_T   tmp_str[64];

    for ( tp=text_p, no = 0; ;tp++)
    {
        if ( *tp == '.' || *tp==0)
        {
            oid[no++] =  SNMP_MGR_AtoUl((char *)text_p, 10);
            SYSFUN_Sprintf((char *)tmp_str, "%lu%s", (unsigned long)oid[no-1],tp);
            if (strcmp((char *)tmp_str, (char *)text_p) !=0)
            {
                return FALSE;
            }
            if ( *tp==0 )
            {
                break;
            }
            text_p= tp+1;
        }
    }
    return TRUE;
}

/*---------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_InsertCom2SecList
 *---------------------------------------------------------------------------
 * PURPOSE: Inserts an entry into com2sec list
 * INPUT:   security_name   - security name string
 *          community_p     - community string
 *          access_right    - access right of the community
 * OUTPUT:  none
 * RETURN:  SNMP_MGR_ERROR_OK, if sucessed. Other values, if failed.
 * NOTE:
 *---------------------------------------------------------------------------
 */
static UI32_T SNMP_MGR_InsertCom2SecList(const char *security_name_p, const char *community_p, SNMP_MGR_Snmp_Comm_Access_Right_T access_right)
{
    UI32_T  ret;
    char    line[SNMP_MGR_SPRINT_MAX_LEN];

    sprintf(line, "%s %s %s", security_name_p, "default", community_p);

    ret = netsnmp_udp_parse_security("com2sec", line, access_right);

#if USE_GALAXY_IPV6_SNMPAGENT
    if (ret == SNMP_MGR_ERROR_OK)
    {
        sprintf(line, "%s %s %s", security_name_p, "default", community_p);
        ret = netsnmp_udp6_parse_security_with_access_right("com2sec6", line, (int)access_right);
    }
#endif

    return ret;
}

/*--------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_DeleteCom2SecList
 *---------------------------------------------------------------------------
 * PURPOSE: Removes an entry from com2sec list
 * INPUT:   community_p     - community string
 * OUTPUT:  none
 * RETURN:  SNMP_MGR_ERROR_OK, if sucessed. Other values, if failed.
 * NOTE:
 *---------------------------------------------------------------------------
 */
static void SNMP_MGR_DeleteCom2SecList(const char *community_p)
{
    netsnmp_udp_destroyViewEntry(community_p);

#if USE_GALAXY_IPV6_SNMPAGENT
    netsnmp_udp6_com2Sec6List_delete(community_p);
#endif
}

/*--------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_GetUsmUserEntry
 *---------------------------------------------------------------------------
 * PURPOSE:  The function will get the usmuserentry is exist
 * INPUT:      entry
 * OUTPUT:  none
 * RETURN:  1. success:    SNMP_MGR_ERROR_OK
 *                    2. failure:      SNMP_MGR_ERROR_EXCEED_LIMIT
 *                                         SNMP_MGR_ERROR_MEM_ALLOC_FAIL
 *                                         SNMP_MGR_ERROR_PARAMETER_NOT_MATCH
 *                                         SNMP_MGR_ERROR_FAIL
 * NOTE:
 *---------------------------------------------------------------------------
 */
static UI32_T SNMP_MGR_GetUsmUserEntry( SNMP_MGR_SnmpV3UserEntry_T  *entry)
{
    struct usmUser *uptr = NULL;
    UI8_T  localEngineID[MAXSIZE_snmpEngineID];
    UI32_T engineIDLen;
    UI32_T orig_priority;
    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);
   /* Since API will return NULL user, we block here to not allow NULL user get*/
    if (strcmp(entry-> snmpv3_user_name, "")== 0)
    {

        return SNMP_MGR_ERROR_FAIL;
    }
   /*
    * Now see if a user already exists with these index values.
    */

    engineIDLen = snmpv3_get_engineID( localEngineID, MAXSIZE_snmpEngineID);

    uptr = usm_get_user(localEngineID, engineIDLen, entry->snmpv3_user_name);

    if (uptr)
    {
        /* tempory get status only*/
        entry->snmpv3_user_status = uptr->userStatus;


        return SNMP_MGR_ERROR_OK;
    }
    else
    {


        return SNMP_MGR_ERROR_FAIL;
    }


    return SNMP_MGR_ERROR_FAIL;
}


/*--------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_CheckSecurityToGroupTable
 *---------------------------------------------------------------------------
 * PURPOSE:  The function will check if the vacmsecurityToGroupEntry is exist
 * INPUT:      entry
 * OUTPUT:  none
 * RETURN:  1. success:    SNMP_MGR_ERROR_OK
 *                    2. failure:      SNMP_MGR_ERROR_EXCEED_LIMIT
 *                                         SNMP_MGR_ERROR_MEM_ALLOC_FAIL
 *                                         SNMP_MGR_ERROR_PARAMETER_NOT_MATCH
 *                                         SNMP_MGR_ERROR_FAIL
 * NOTE:
 *---------------------------------------------------------------------------
 */
static UI32_T   SNMP_MGR_CheckSecurityToGroupTable( SNMP_MGR_SnmpV3UserEntry_T  *entry)
{
    struct vacm_groupEntry * vacmgrouplist=NULL, *vp=NULL;
    UI32_T orig_priority;

    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);

    vacmgrouplist = vacm_get_groupList();

   /* no entry exist at all, return no entry exist*/
    if (!vacmgrouplist)
    {


        return SNMP_MGR_ERROR_NO_ENTRY_EXIST;
    }
   /* find the next entry*/
    for (vp = vacmgrouplist; vp; vp = vp->next)
    {
        if (vp->securityModel == entry->snmpv3_user_security_model
            && !strcmp(vp->securityName + 1, entry->snmpv3_user_name))
        {


            return SNMP_MGR_ERROR_OK;
        }
    }


    return SNMP_MGR_ERROR_FAIL;
}

/*--------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_GetSecurityToGroupTable
 *---------------------------------------------------------------------------
 * PURPOSE:  The function will get  the vacmsecurityToGroupEntry.
 * INPUT:   entry
 * OUTPUT:  entry
 * RETURN:  1. success:    SNMP_MGR_ERROR_OK
 *                    2. failure:      SNMP_MGR_ERROR_EXCEED_LIMIT
 *                                         SNMP_MGR_ERROR_MEM_ALLOC_FAIL
 *                                         SNMP_MGR_ERROR_PARAMETER_NOT_MATCH
 *                                         SNMP_MGR_ERROR_FAIL
 * NOTE:
 *---------------------------------------------------------------------------
 */
static UI32_T   SNMP_MGR_GetSecurityToGroupTable( SNMP_MGR_SnmpV3UserEntry_T  *entry)
{
    struct vacm_groupEntry * vacmgrouplist=NULL, *vp=NULL;
    UI32_T orig_priority;
    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);

    vacmgrouplist = vacm_get_groupList();

   /* no entry exist at all, return no entry exist*/
    if (!vacmgrouplist)
    {


        return SNMP_MGR_ERROR_NO_ENTRY_EXIST;
    }
   /* find the next entry*/
    for (vp = vacmgrouplist; vp; vp = vp->next)
    {
        if (vp->securityModel == entry->snmpv3_user_security_model
            && !strcmp(vp->securityName + 1, entry->snmpv3_user_name))
        {
            strcpy(entry->snmpv3_user_group_name, vp->groupName);
            entry->snmpv3_user_storage_type = vp->storageType;
            entry->snmpv3_user_status = vp->status;


            return SNMP_MGR_ERROR_OK;
        }
    }


    return SNMP_MGR_ERROR_FAIL;
}

/*--------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_ModifySnmpCommunityStatus
 *---------------------------------------------------------------------------
 * PURPOSE:  The funtion to modify the Rfc2576 Community MIB status.
 * INPUT:    comm_string_name, sec_name
 * OUTPUT:   none.
 * RETURN:   SNMP_ERR_CODE.
 * NOTE:     For SNMP Use only.
 *---------------------------------------------------------------------------
 */
static UI32_T SNMP_MGR_ModifySnmpCommunityStatus(char *comm_string_name, UI32_T status)
{
    UI32_T  i;
    UI32_T  return_val = SNMP_MGR_ERROR_FAIL;
    UI32_T orig_priority;
    /* BODY */
    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);
    if (strlen(comm_string_name) > SYS_ADPT_MAX_COMM_STR_NAME_LEN)
    {
        /* we leave EH handler to implement later*/
        #if (SYS_CPNT_EH == TRUE)
        EH_MGR_Handle_Exception1(SYS_MODULE_SNMP,
                                 0,
                                 EH_TYPE_MSG_INVALID_PARAMETER,
                                 SYSLOG_LEVEL_ERR,
                                 "community too long");
        #endif


        return SNMP_MGR_ERROR_FAIL;
    }



    /* find community string
     */
    for (i=0; i<SYS_ADPT_MAX_NBR_OF_SNMP_COMMUNITY_STRING; i++)
    {
        /* invalid entry
         */
        if (snmp_mgr_comm_entry[i].snmp_community_status == VAL_snmpCommunityStatus_destroy)
        {
            continue;
        }

        /* valid entry
         */
        if (strcmp(comm_string_name, snmp_mgr_comm_entry[i].snmp_community_index) == 0)
            break;
    }


    if (i == SYS_ADPT_MAX_NBR_OF_SNMP_COMMUNITY_STRING)
    {
        /* No found, return SNMP_MGR_ERROR_FAIL
         */
         return_val = SNMP_MGR_ERROR_FAIL;
    }
    else
    {
        /* found an entry, update status.  By logically, it should be deleted.
         */
       snmp_mgr_comm_entry[i].snmp_community_status = status;
       return_val = SNMP_MGR_ERROR_OK;
    }
#if (SYS_CPNT_SNMP_COMMUNITY_IN_CFGDB == TRUE)
    if (snmp_mgr_init_comm_for_cfgdb == TRUE)
    {
        SNMP_MGR_SnmpCommunityEntryForCfgdb_T community_entrys_in_cfgdb[SYS_ADPT_MAX_NBR_OF_SNMP_COMMUNITY_STRING];
        if (return_val == SNMP_MGR_ERROR_OK)
        {
            /* eli,we should convert community structure between snmp agent and cfgdb for compatibility
             */
            for(i=0;i<SYS_ADPT_MAX_NBR_OF_SNMP_COMMUNITY_STRING;i++)
            {
                memcpy(community_entrys_in_cfgdb[i].snmp_community_index,snmp_mgr_comm_entry[i].snmp_community_index,SYS_ADPT_MAX_COMM_STR_NAME_LEN + 1);
                memcpy(community_entrys_in_cfgdb[i].snmp_community_name,snmp_mgr_comm_entry[i].snmp_community_name,SYS_ADPT_MAX_COMM_STR_NAME_LEN + 1);
                memcpy(community_entrys_in_cfgdb[i].snmp_community_security_name,snmp_mgr_comm_entry[i].snmp_community_security_name,SYS_ADPT_MAX_COMM_STR_NAME_LEN + 1);
                /* eli,we use local engine_id as the engine_id of all community for compatibility.
                 * So, the engine_id of community of cfgdb is not effect.
                 */
                memset(community_entrys_in_cfgdb[i].snmp_community_context_engine_id,0,MAXSIZE_SNMPV3_ENGINE_ID_LEN);
                memcpy(community_entrys_in_cfgdb[i].snmp_community_context_name,snmp_mgr_comm_entry[i].snmp_community_context_name,MAXSIZE_snmpCommunityContextName+1);
                memcpy(community_entrys_in_cfgdb[i].snmp_community_transport_tag,snmp_mgr_comm_entry[i].snmp_community_transport_tag,MAXSIZE_snmpCommunityTransportTag+1);
                memcpy(&community_entrys_in_cfgdb[i].snmp_community_access_right,&snmp_mgr_comm_entry[i].snmp_community_access_right,sizeof(UI32_T));
                memcpy(&community_entrys_in_cfgdb[i].snmp_community_storage_type,&snmp_mgr_comm_entry[i].snmp_community_storage_type,sizeof(UI32_T));
                memcpy(&community_entrys_in_cfgdb[i].snmp_community_status,&snmp_mgr_comm_entry[i].snmp_community_status,sizeof(UI32_T));
            }
            CFGDB_MGR_WriteSection(snmp_community_session_handler, community_entrys_in_cfgdb);
        }
    }
 #endif


    return return_val;
} /* end of SNMP_MGR_ActiveSnmpCommunityStatus() */


/*--------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_CreateSnmpCommunityEntry
 *---------------------------------------------------------------------------
 * PURPOSE:  The funtion to create the Rfc2576 Community MIB status.
 * INPUT:    comm_string_name, sec_name
 * OUTPUT:   none.
 * RETURN:   SNMP_ERR_CODE.
 * NOTE:     For SNMP Use only.
 *---------------------------------------------------------------------------
 */
static UI32_T SNMP_MGR_CreateSnmpCommunityEntry(SNMP_MGR_SnmpCommunityEntry_T *entry)
{
    UI32_T  i;
    I32_T   available_entry = -1;
    UI32_T  return_val = SNMP_MGR_ERROR_FAIL;
    UI32_T orig_priority;

    /* BODY */
    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);

    /* check the input data is valid */
    if ((strlen(entry->snmp_community_index) > SYS_ADPT_MAX_COMM_STR_NAME_LEN) ||
        (strlen(entry->snmp_community_name) > SYS_ADPT_MAX_COMM_STR_NAME_LEN) ||
        (strlen(entry->snmp_community_security_name) > SYS_ADPT_MAX_COMM_STR_NAME_LEN))
    {
        return SNMP_MGR_ERROR_FAIL;
    }

    /* Ensure the index is identical to both the community name and the security
     * name.
     */
    if (   (0 != strncmp(entry->snmp_community_index,
            entry->snmp_community_name, sizeof(entry->snmp_community_index)))
        || (0 != strncmp(entry->snmp_community_index,
            entry->snmp_community_security_name,
            sizeof(entry->snmp_community_index)))
        )
    {
        return SNMP_MGR_ERROR_FAIL;
    }

    for (i=0; i<SYS_ADPT_MAX_NBR_OF_SNMP_COMMUNITY_STRING; i++)
    {
        if (strcmp(entry->snmp_community_index, snmp_mgr_comm_entry[i].snmp_community_index)==0)
        {
            if (snmp_mgr_comm_entry[i].snmp_community_status == entry->snmp_community_status)//if specific entry already exist, and the status already the same as u want to set now, return false
            {
                i=SYS_ADPT_MAX_NBR_OF_SNMP_COMMUNITY_STRING;
                available_entry=-1;
            }
            else
            {
                available_entry = i;
            }
            break;
        }

        if (snmp_mgr_comm_entry[i].snmp_community_status == VAL_snmpCommunityStatus_destroy)
        {
            /* record the first empty entry.  When the entry is not existed, this
             * entry will be updated as the input.
             */
            if (available_entry == -1)
                available_entry = i;
            continue;
        }

        if (strcmp(entry->snmp_community_index, snmp_mgr_comm_entry[i].snmp_community_index)==0)
            break;
    }

    if (i == SYS_ADPT_MAX_NBR_OF_SNMP_COMMUNITY_STRING)
    {
        /* No found, create a new one, if no more available entry then return FALSE
         */
        if (available_entry != -1)
        {
            strcpy(snmp_mgr_comm_entry[available_entry].snmp_community_index,entry->snmp_community_index);
            strcpy(snmp_mgr_comm_entry[available_entry].snmp_community_name,entry->snmp_community_name);
           // memset(snmp_mgr_comm_entry[available_entry].snmp_community_security_name, 0, SYS_ADPT_MAX_COMM_STR_NAME_LEN+1);
            strcpy(snmp_mgr_comm_entry[available_entry].snmp_community_security_name, entry->snmp_community_security_name);
            snmp_mgr_comm_entry[available_entry].snmp_community_access_right = entry->snmp_community_access_right;
            SNMP_MGR_GetEngineID(snmp_mgr_comm_entry[available_entry].snmp_community_context_engine_id, &snmp_mgr_comm_entry[available_entry].snmp_community_engine_id_length);
            strcpy((char *)snmp_mgr_comm_entry[available_entry].snmp_community_context_name,"");
            strcpy((char *)snmp_mgr_comm_entry[available_entry].snmp_community_transport_tag,"");

            if (SNMP_MGR_ACCESS_RIGHT_GROUP_SPECIFIC == entry->snmp_community_access_right)
            {
                snmp_mgr_comm_entry[available_entry].snmp_community_storage_type = VAL_snmpCommunityStorageType_volatile;
            }
            else
            {
                snmp_mgr_comm_entry[available_entry].snmp_community_storage_type = VAL_snmpCommunityStorageType_nonVolatile;
            }

            snmp_mgr_comm_entry[available_entry].snmp_community_status = VAL_snmpCommunityStatus_notReady;
            return_val = SNMP_MGR_ERROR_OK;
        }
        else
        {
            /* no available entry, can not create new entry
             */
            #if (SYS_CPNT_EH == TRUE)
            EH_MGR_Handle_Exception1(SYS_MODULE_SNMP,
                                 0,
                                 EH_TYPE_MSG_FAILED_TO_ADD,
                                 SYSLOG_LEVEL_ERR,
                                 ":no available entry");
            #endif
            return_val = SNMP_MGR_ERROR_FAIL;
        }
    }
    else
    {
        /* found an entry, update status.  By logically, it should be deleted.
         */
        snmp_mgr_comm_entry[available_entry].snmp_community_status = VAL_snmpCommunityStatus_notReady;
        /* default version set to 1 */
        strcpy(snmp_mgr_comm_entry[available_entry].snmp_community_name,entry->snmp_community_index);
        //memset(snmp_mgr_comm_entry[available_entry].snmp_community_security_name, 0, SYS_ADPT_MAX_COMM_STR_NAME_LEN+1);
        snmp_mgr_comm_entry[available_entry].snmp_community_access_right = entry->snmp_community_access_right;
        strcpy(snmp_mgr_comm_entry[available_entry].snmp_community_security_name, entry->snmp_community_security_name);
        SNMP_MGR_GetEngineID(snmp_mgr_comm_entry[available_entry].snmp_community_context_engine_id, &snmp_mgr_comm_entry[available_entry].snmp_community_engine_id_length);
        strcpy((char *)snmp_mgr_comm_entry[available_entry].snmp_community_context_name,"");
        strcpy((char *)snmp_mgr_comm_entry[available_entry].snmp_community_transport_tag,"");
        snmp_mgr_comm_entry[available_entry].snmp_community_storage_type = VAL_snmpCommunityStorageType_nonVolatile;
        return_val = SNMP_MGR_ERROR_OK;
    }



    return return_val;

} /* end of SNMP_MGR_CreateSnmpCommunityEntry() */

/* ---------------------------------------------------------------------
 * ROUTINE NAME  - SNMP_MGR_DeleteTargetTrapReceiverDB
 * ---------------------------------------------------------------------
 * PURPOSE: This function returns SNMP_MGR_ERROR_OK if the trap receiver
 *          can be deleted successfully. Otherwise, error code is returned.
 *
 * INPUT: ip_addr    - (key) to specify a unique trap receiver
 * OUTPUT: none
 * RETURN: SNMP_MGR_ERROR_OK;SNMP_MGR_ERROR_PARAMETER_NOT_MATCH;SNMP_MGR_ERROR_FAIL;
 * NOTES:1.none
 *
 * ---------------------------------------------------------------------
 */
static UI32_T SNMP_MGR_DeleteTargetTrapReceiverDB( L_INET_AddrIp_T *ip_addr)
{
    SNMP_MGR_SnmpNotifyFilterProfileEntry_T  notify_filter_profile_entry;
    SNMP_MGR_TrapDestEntry_T trap_dest_entry;
    SNMP_MGR_SnmpTargetAddrEntry_T entry;
    BOOL_T delete_notify_entry = TRUE;
    static struct targetAddrTable_struct *tp;
    static struct targetAddrTable_struct *target_addr_list;
    static struct targetAddrTable_struct **target_addr_list_address;
    L_INET_AddrIp_T target_addr_ip;
    oid subtree[32];
    UI32_T orig_priority;
    L_INET_AddrIp_T skip_addr;

    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);
   /* initilize the entry to 0 */
    memset(&trap_dest_entry, 0, sizeof(trap_dest_entry));
    memset(&target_addr_ip, 0, sizeof(target_addr_ip));
    memset(&skip_addr, 0, sizeof(skip_addr));
    memcpy(&trap_dest_entry.trap_dest_address, ip_addr, sizeof(trap_dest_entry.trap_dest_address));

    if (SNMP_MGR_ERROR_OK != SNMP_MGR_GetTrapReceiver(&trap_dest_entry))
    {

        return SNMP_MGR_ERROR_FAIL;
    }

    /* Step 1, delete snmpNotifyFilterProfileTable
     */
    memset(&notify_filter_profile_entry, 0, sizeof(notify_filter_profile_entry));
    memcpy(&notify_filter_profile_entry.snmp_notify_filter_profile_ip,
        &ip_addr, sizeof(notify_filter_profile_entry.snmp_notify_filter_profile_ip));
    SNMP_MGR_DeleteSnmpNotifyFilterProfileTable(&notify_filter_profile_entry);

    /* Step 2: delete the snmpTargetAddrTable
     */
    SNMP_MGR_DeleteSnmpTargetAddrTable(trap_dest_entry.trap_dest_target_addr_name);

    /* Step 3: delete the snmpTargetParamsTable
     */
    SNMP_MGR_DeleteSnmpTargetParamsTable(trap_dest_entry.trap_dest_target_params_name);

    memset(&entry, 0, sizeof(SNMP_MGR_SnmpTargetAddrEntry_T));

    /* Step 4, delete snmpNotifyTable
     */
    if (trap_dest_entry.trap_dest_type == VAL_snmpNotifyType_trap)
    {
        while (SNMP_MGR_GetNextSnmpTargetAddrTable(&entry) == SNMP_MGR_ERROR_OK)
        {
            if (strcmp((char *)entry.snmp_target_addr_tag_list, "trap") == 0)
            {
                delete_notify_entry = FALSE;
                break;
            }
        }

        if (delete_notify_entry == TRUE)
        {
            SNMP_MGR_DeleteSnmpNotifyTable((UI8_T *)"trap");
        }
    }

    else if (trap_dest_entry.trap_dest_type == VAL_snmpNotifyType_inform)
    {
        while (SNMP_MGR_GetNextSnmpTargetAddrTable(&entry) == SNMP_MGR_ERROR_OK)
        {
            if (strcmp((char *)entry.snmp_target_addr_tag_list, "inform") == 0)
            {
                delete_notify_entry = FALSE;
                break;
            }
        }

        if (delete_notify_entry == TRUE)
        {
            SNMP_MGR_DeleteSnmpNotifyTable((UI8_T *)"inform");
        }
    }

    else
    {
        #if (SYS_CPNT_EH == TRUE)
            EH_MGR_Handle_Exception (SYS_MODULE_SNMP,
                                     0,
                                     EH_TYPE_MSG_INVALID_PARAMETER,
                                    (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));
        #endif

        return SNMP_MGR_ERROR_PARAMETER_NOT_MATCH;
    }

    /* Step 5, delete snmpNotifyFilterTable
     */
    subtree[0] = 1;
    SNMP_MGR_DeleteSnmpNotifyFilterTable(trap_dest_entry.trap_dest_target_params_name, subtree, 1);

    /* Step 6, delete the entry from usmUserTable, vacmSecurityToGroupTable,
     * vacmAccessTable and snmpCommunityTable if they are not shared by others.
     */
    if (SNMP_MGR_IsCommunitySharedByTrapReceiver(
        trap_dest_entry.trap_dest_community,
        trap_dest_entry.trap_dest_version,
        &trap_dest_entry.trap_dest_address) == FALSE)
    {
        if (trap_dest_entry.trap_dest_version == SNMP_MGR_SNMPV3_MODEL_V3)
        {
            if (SNMP_MGR_IsAutoDestroyUser(trap_dest_entry.trap_dest_community) == TRUE)
            {
                SNMP_MGR_DeleteUsmUserEntry(trap_dest_entry.trap_dest_community);
            }

            if (SNMP_MGR_IsAutoDestroySecurityToGroup(trap_dest_entry.trap_dest_version, trap_dest_entry.trap_dest_community) == TRUE)
            {
                SNMP_MGR_DeleteSecurityToGroupEntry(trap_dest_entry.trap_dest_version, trap_dest_entry.trap_dest_community);
            }

            if (SNMP_MGR_IsAutoDestroyAccess(trap_dest_entry.trap_dest_community, trap_dest_entry.trap_dest_version, trap_dest_entry.trap_dest_security_level) == TRUE)
            {
                SNMP_MGR_DeleteAccess(trap_dest_entry.trap_dest_community, trap_dest_entry.trap_dest_version, trap_dest_entry.trap_dest_security_level);
            }
        }
        else
        {
            SNMP_MGR_SnmpCommunity_T comm_entry;

            memset(&comm_entry, 0, sizeof(comm_entry));
            snprintf(comm_entry.comm_string_name, sizeof(comm_entry.comm_string_name), "%s", trap_dest_entry.trap_dest_community);
            if (   (SNMP_MGR_CheckSnmpCommunity(&comm_entry) != SNMP_MGR_ERROR_OK)
                || (comm_entry.access_right == SNMP_MGR_ACCESS_RIGHT_GROUP_SPECIFIC)
                )
            {
                /* No community is shared with this group and access now. Delete
                 * them if they are created automatically.
                 */
                if (SNMP_MGR_IsAutoDestroySecurityToGroup(trap_dest_entry.trap_dest_version, trap_dest_entry.trap_dest_community) == TRUE)
                {
                    SNMP_MGR_DeleteSecurityToGroupEntry(trap_dest_entry.trap_dest_version, trap_dest_entry.trap_dest_community);
                }

                if (SNMP_MGR_IsAutoDestroyAccess(trap_dest_entry.trap_dest_community, trap_dest_entry.trap_dest_version, trap_dest_entry.trap_dest_security_level) == TRUE)
                {
                    SNMP_MGR_DeleteAccess(trap_dest_entry.trap_dest_community, trap_dest_entry.trap_dest_version, trap_dest_entry.trap_dest_security_level);
                }
            }

            if (comm_entry.access_right == SNMP_MGR_ACCESS_RIGHT_GROUP_SPECIFIC)
            {
                if (   (   (trap_dest_entry.trap_dest_version == SNMP_MGR_SNMPV3_MODEL_V1)
                        && (SNMP_MGR_IsCommunitySharedByTrapReceiver(trap_dest_entry.trap_dest_community, SNMP_MGR_SNMPV3_MODEL_V2C, &skip_addr) == FALSE)
                        )
                    || (   (trap_dest_entry.trap_dest_version == SNMP_MGR_SNMPV3_MODEL_V2C)
                        && (SNMP_MGR_IsCommunitySharedByTrapReceiver(trap_dest_entry.trap_dest_community, SNMP_MGR_SNMPV3_MODEL_V1, &skip_addr) == FALSE)
                        )
                    )
                {
                    /* No any trap receiver uses the same community with the another
                     * version (only consider v1 and v2c) so that we can delete this
                     * community.
                     */
                    SNMP_MGR_ModifySnmpCommunityStatus(trap_dest_entry.trap_dest_community, VAL_snmpCommunityStatus_destroy);


                    SNMP_MGR_DeleteCom2SecList(trap_dest_entry.trap_dest_community);

                }
            }
        }
    }

   /* Step 7, to delete if any entry which was create from SNMP agent */

   /* get the variable store in snmpTargetAddrEntry*/

    target_addr_list = get_addrTable();
    target_addr_list_address = get_addrTableAddress();
    if (!target_addr_list)
    {


        return SNMP_MGR_ERROR_OK;
    }

   /* find the next entry*/
    for (tp = target_addr_list; tp; tp = tp->next)
    {
        if(tp->tAddressLen == SNMP_MGR_TADDR_IPV6LINKLOCAL_LEN)
        {
            memcpy( &target_addr_ip, tp->tAddress, (tp->tAddressLen - 6));
        }
        else
        {
            memcpy( &target_addr_ip, tp->tAddress, (tp->tAddressLen - 2));
        }

        if (0 == L_INET_CompareInetAddr((L_INET_Addr_T *)&target_addr_ip,
            (L_INET_Addr_T *) ip_addr, 0))
        {
            break;
        }
    }

    /* find an entry, remove it */
    if (tp)
    {
        snmpTargetAddrTable_remFromList(tp, (struct targetAddrTable_struct **)target_addr_list_address);
    }



    return SNMP_MGR_ERROR_OK;
}

/* ---------------------------------------------------------------------
 * ROUTINE NAME  - SNMP_MGR_CreateTargetTrapReceiverDB
 * ---------------------------------------------------------------------
 * PURPOSE: This function returns SNMP_MGR_ERROR_OK if the trap receiver
 *          can be created successfully. Otherwise, error code is returned.
 *
 * INPUT: entry    - (key) to specify a unique trap receiver
 * OUTPUT: none
 * RETURN: SNMP_MGR_ERROR_OK;SNMP_MGR_ERROR_PARAMETER_NOT_MATCH;SNMP_MGR_ERROR_FAIL;
 * NOTES: 1. This function will create a new trap receiver to the system if
 *           the specified ip_addr does not exist, and total number
 *           of trap receiver configured is less than
 *           SYS_ADPT_MAX_NBR_OF_TRAP_RECEIVER.
 *           When a new trap receiver is created by this function, the
 *           comm_string_name of this new trap receiver will be set to
 *           "DEFAULT".
 *         2. error code is returned if total number of trap receiver configured
 *           is greater than SYS_ADPT_MAX_NBR_OF_TRAP_RECEIVER
 *
 * ---------------------------------------------------------------------
 */
static UI32_T SNMP_MGR_CreateTargetTrapReceiverDB(UI32_T snmp_index, SNMP_MGR_TrapDestEntry_T *entry)
{
    SNMP_MGR_SnmpNotifyEntry_T notify_entry;
    SNMP_MGR_SnmpTargetAddrEntry_T  target_addr_entry;
    SNMP_MGR_SnmpTargetParamsEntry_T target_params_entry;
    SNMP_MGR_TrapDestEntry_T local_entry;
    oid  udp_domain_oid[7] = {1,3,6,1,6,1,1};
    struct vacm_groupEntry *geptr= NULL;
    SNMP_MGR_SnmpNotifyFilterEntry_T notify_filter_entry;
    SNMP_MGR_SnmpNotifyFilterProfileEntry_T notify_filter_profile_entry;
    UI32_T orig_priority;




    if (SYSFUN_GET_CSC_OPERATING_MODE() == SYS_TYPE_STACKING_SLAVE_MODE)
    {

        return SNMP_MGR_ERROR_FAIL;
    }

    if (TRUE != SNMP_MGR_IsValidTrapReceiverIp(&entry->trap_dest_address))
    {
        return SNMP_MGR_ERROR_FAIL;
    }

/* Create Probe Config database okay, go on to create the Target MIB*/

   /* initilize the entry to 0 */
    memset(&notify_entry, 0, sizeof(notify_entry));
    memset(&target_addr_entry, 0, sizeof(target_addr_entry));
    memset(&target_params_entry, 0, sizeof(target_params_entry));
    memcpy(&local_entry, entry, sizeof(local_entry));

   /* check if already exist, if so, remove the old one */
    if (SNMP_MGR_GetTrapReceiver (&local_entry) == SNMP_MGR_ERROR_OK)
    {
        SNMP_MGR_DeleteTrapReceiver(&local_entry.trap_dest_address);
    }

   /* Create the snmpNotifyTable*/
    if (entry->trap_dest_type == VAL_snmpNotifyType_trap)
    {
        strcpy( notify_entry.snmp_notify_name, "trap");
        strcpy(notify_entry.snmp_notify_tag, "trap");
        notify_entry.snmp_notify_type = VAL_snmpNotifyType_trap;
    }
    else if (entry->trap_dest_type == VAL_snmpNotifyType_inform)
    {
        strcpy( notify_entry.snmp_notify_name, "inform");
        strcpy(notify_entry.snmp_notify_tag, "inform");
        notify_entry.snmp_notify_type = VAL_snmpNotifyType_inform;
    }
    else
    {
        return SNMP_MGR_ERROR_PARAMETER_NOT_MATCH;
    }
    notify_entry.snmp_notify_storage_type = VAL_snmpNotifyStorageType_nonVolatile;
    notify_entry.snmp_notify_row_status = 1;
    if (SNMP_MGR_CreateSnmpNotifyTable(&notify_entry) != SNMP_MGR_ERROR_OK)
    {
        return SNMP_MGR_ERROR_FAIL;
    }

    /* note: use trap receiver entry index to be target address name and parameter name,
       the maximum index string length can't over than target address name and parameter name length.
    */
    SYSFUN_Snprintf(target_addr_entry.snmp_target_addr_name,
        sizeof(target_addr_entry.snmp_target_addr_name),
        "%lu",
        (unsigned long)snmp_index);
    target_addr_entry.snmp_target_addr_name[sizeof(target_addr_entry.snmp_target_addr_name)-1] = '\0';

    SYSFUN_Snprintf(target_addr_entry.snmp_target_addr_params,
        sizeof(target_addr_entry.snmp_target_addr_params),
        "%lu",
        (unsigned long)snmp_index);
    target_addr_entry.snmp_target_addr_params[sizeof(target_addr_entry.snmp_target_addr_params)-1] = '\0';

    memcpy(target_addr_entry.snmp_target_addr_tdomain, udp_domain_oid, 7*sizeof(oid));
    target_addr_entry.snmp_target_addr_tdomain_len = 7;

    SNMP_MGR_SetIpandPort2Taddress(entry->trap_dest_address,entry->trap_dest_port,&target_addr_entry);

    target_addr_entry.snmp_target_addr_timeout=1500;
    target_addr_entry.snmp_target_addr_retry_count = 0;
    target_addr_entry.snmp_target_addr_storage_type = VAL_snmpTargetAddrStorageType_nonVolatile;
    target_addr_entry.snmp_target_addr_row_status = VAL_snmpTargetAddrRowStatus_active ;
    if (SNMP_MGR_CreateSnmpTargetAddrTable(&target_addr_entry)!= SNMP_MGR_ERROR_OK)
    {
        return SNMP_MGR_ERROR_FAIL;
    }

    /* create the snmpTargetParamsTable
    */
    strncpy(target_params_entry.snmp_target_params_name,
        target_addr_entry.snmp_target_addr_params,
        sizeof(target_params_entry.snmp_target_params_name)-1);
    target_params_entry.snmp_target_params_name[sizeof(target_params_entry.snmp_target_params_name)-1] = '\0';

    switch(entry->trap_dest_version)
    {
        case SNMP_MGR_SNMPV3_MODEL_V1:
            target_params_entry.snmp_target_params_mp_model = SNMP_MP_MODEL_SNMPv1;
            target_params_entry.snmp_target_params_security_level = VAL_snmpTargetParamsSecurityLevel_noAuthNoPriv;
            break;
        case SNMP_MGR_SNMPV3_MODEL_V2C:
            target_params_entry.snmp_target_params_mp_model = SNMP_MP_MODEL_SNMPv2c;
            target_params_entry.snmp_target_params_security_level = VAL_snmpTargetParamsSecurityLevel_noAuthNoPriv;
            break;
        case SNMP_MGR_SNMPV3_MODEL_V3:
            target_params_entry.snmp_target_params_mp_model = SNMP_MP_MODEL_SNMPv3;
            target_params_entry.snmp_target_params_security_level = entry->trap_dest_security_level;
            break;
        default:
            target_params_entry.snmp_target_params_mp_model = SNMP_MP_MODEL_SNMPv3;
            break;
    }
    target_params_entry.snmp_target_params_security_model = SNMP_MGR_SNMPV3_MODEL_V3; /* restrict to usm model*/
    strcpy((char *)target_params_entry.snmp_target_params_security_name,  entry->trap_dest_community);
    target_params_entry.snmp_target_params_storage_type = VAL_snmpTargetParamsStorageType_nonVolatile ;
    target_params_entry.snmp_target_params_row_status = VAL_snmpTargetParamsRowStatus_active;
    if (SNMP_MGR_CreateSnmpTargetParamsTable(&target_params_entry)!= SNMP_MGR_ERROR_OK)
    {
        return SNMP_MGR_ERROR_FAIL;
    }

    /* The next step is to append the notify view to the vacmAccessTable(group)*/

    /* If version is v1/v2c, we need to check if there exist such a snmpcommunityEntry, if exists,
       append the notifyview to the group that the communtiy is resided, otherwise, create a new
       communityEntry , and create a group with name equal to community with  notify view=defaultview,
       readview and writeview both none. */

    if ((entry->trap_dest_version == SNMP_MGR_SNMPV3_MODEL_V1) ||
        (entry->trap_dest_version == SNMP_MGR_SNMPV3_MODEL_V2C))
    {
        SNMP_MGR_SnmpCommunityEntry_T comm_entry;
        SNMP_MGR_SnmpV3GroupEntry_T group_entry;
        struct vacm_accessEntry *ap=NULL;

        strcpy( comm_entry.snmp_community_index, entry->trap_dest_community);
         /* v1 and v2 model, we need to use community to check the read view and write view*/
        if (SNMP_MGR_GetSnmpCommunityEntry(&comm_entry)== SNMP_MGR_ERROR_OK)
        {
            /*Check securityToGroupTable to fetch the group name*/

            geptr = vacm_getGroupEntry(entry->trap_dest_version , comm_entry.snmp_community_security_name);

            if (geptr)
            {
                ap = vacm_getExactAccessEntry(geptr->groupName, "", geptr->securityModel,VAL_vacmAccessSecurityLevel_noAuthNoPriv );
                if (ap)
                {
                    strcpy(group_entry.snmpv3_group_name, geptr->groupName);
                    group_entry.snmpv3_group_model = entry->trap_dest_version;
                    /* v1/v2 model, security level should be VAL_vacmAccessSecurityLevel_noAuthNoPriv*/
                    group_entry.snmpv3_group_security_level = VAL_vacmAccessSecurityLevel_noAuthNoPriv;
                    /*find an entry, append the notify view to the group entry*/
                    if (SNMP_MGR_AppendNotifyView(&group_entry) != SNMP_MGR_ERROR_OK)
                    {
                        return SNMP_MGR_ERROR_FAIL;
                    }
                }
                else
                {
                    strcpy(group_entry.snmpv3_group_name, geptr->groupName);
                    strcpy( group_entry.snmpv3_group_readview, "");
                    strcpy(group_entry.snmpv3_group_writeview, "");
                    strcpy(group_entry.snmpv3_group_notifyview, "defaultview");
                    group_entry.snmpv3_group_storage_type = VAL_vacmAccessStorageType_volatile;
                    if (SNMP_MGR_CreateSnmpV3Group(&group_entry, TRUE) != SNMP_MGR_ERROR_OK)
                    {
                        return SNMP_MGR_ERROR_FAIL;
                    }
                }
            }
            else /* This only happen when a comm2secEntry exist, but no securityToGroup exist*/
            {
                /* we only found communityEntry, so need to create securityToGroupEntry
                   and vacmAccessEntry*/
                char  line[SNMP_MGR_SPRINT_MAX_LEN];

                if (entry->trap_dest_version == SNMP_MGR_SNMPV3_MODEL_V1)
                {
                    sprintf(line, "%s v1 %s volatile",   geptr->groupName, geptr->groupName);
                }
                else
                {
                    sprintf(line, "%s v2c %s volatile",   geptr->groupName, geptr->groupName);
                }

                vacm_parse_group("group", line, TRUE);


                /* Then create the group*/
                strcpy(group_entry.snmpv3_group_name, entry->trap_dest_community);
                group_entry.snmpv3_group_model = entry->trap_dest_version;
                group_entry.snmpv3_group_security_level = entry->trap_dest_security_level;
                if (SNMP_MGR_CheckGroupExist( &group_entry)== SNMP_MGR_ERROR_OK)
                {
                    /*find an entry, append the notify view to the group entry*/
                    if (SNMP_MGR_AppendNotifyView(&group_entry) != SNMP_MGR_ERROR_OK)
                    {
                        return SNMP_MGR_ERROR_FAIL;
                    }
                }
                else
                {
                    strcpy( group_entry.snmpv3_group_readview, "");
                    strcpy(group_entry.snmpv3_group_writeview, "");
                    strcpy(group_entry.snmpv3_group_notifyview, "defaultview");
                    group_entry.snmpv3_group_storage_type = VAL_vacmAccessStorageType_volatile;
                    if (SNMP_MGR_CreateSnmpV3Group(&group_entry, TRUE) != SNMP_MGR_ERROR_OK)
                    {

                        return SNMP_MGR_ERROR_FAIL;
                    }
                }
            }/* end of else if (geptr)*/
        }/* end of if (SNMP_MGR_GetSnmpCommunityEntry(&comm_entry)== SNMP_MGR_ERROR_OK)*/
        else
        {
            char  line[SNMP_MGR_SPRINT_MAX_LEN];

            /* create the snmpCommunityEntry*/
            memset(&comm_entry,0, sizeof(comm_entry));
            strcpy(comm_entry.snmp_community_index, entry->trap_dest_community);
             strcpy(comm_entry.snmp_community_name, entry->trap_dest_community);
            strcpy(comm_entry.snmp_community_security_name, entry->trap_dest_community);


            SNMP_MGR_InsertCom2SecList(comm_entry.snmp_community_security_name, comm_entry.snmp_community_index,
                SNMP_MGR_ACCESS_RIGHT_GROUP_SPECIFIC);


            SNMP_MGR_CreateSnmpCommunityEntry(&comm_entry);
            SNMP_MGR_ModifySnmpCommunityStatus(entry->trap_dest_community, VAL_snmpCommunityStatus_active);

            /* Here we need to create the SecurityToGroup Table */

            geptr = vacm_getGroupEntry(entry->trap_dest_version , comm_entry.snmp_community_index);

            if (entry->trap_dest_version == SNMP_MGR_SNMPV3_MODEL_V1)
            {
                sprintf(line, "%s v1 %s volatile",   comm_entry.snmp_community_index, comm_entry.snmp_community_index);
            }
            else
            {
                sprintf(line, "%s v2c %s volatile",   comm_entry.snmp_community_index, comm_entry.snmp_community_index);
            }

            if (!geptr)
            {

                vacm_parse_group("group", line, TRUE);

            }

            /* Then create the group*/
            strcpy(group_entry.snmpv3_group_name, entry->trap_dest_community);
            group_entry.snmpv3_group_model = entry->trap_dest_version;
            group_entry.snmpv3_group_security_level = entry->trap_dest_security_level;
            if (SNMP_MGR_CheckGroupExist( &group_entry)== SNMP_MGR_ERROR_OK)
            {
               /*find an entry, append the notify view to the group entry*/
               if (SNMP_MGR_AppendNotifyView(&group_entry) != SNMP_MGR_ERROR_OK)
               {

                    return SNMP_MGR_ERROR_FAIL;
                 }
               }
               else
               {

                strcpy( group_entry.snmpv3_group_readview, "");
                  strcpy(group_entry.snmpv3_group_writeview, "");
                   strcpy(group_entry.snmpv3_group_notifyview, "defaultview");
                   group_entry.snmpv3_group_storage_type = VAL_vacmAccessStorageType_volatile;
                  if (SNMP_MGR_CreateSnmpV3Group(&group_entry, TRUE) != SNMP_MGR_ERROR_OK)
                   {

                      return SNMP_MGR_ERROR_FAIL;
                  }
               }
        }
    }
    /* If the version is v3,we need to check if the user exist, if the user exist, we need to
       append the notifyview to the group that the user is resided, if the user do not exist,
       we need to create a new user for this.*/
    else if (entry->trap_dest_version == SNMP_MGR_SNMPV3_MODEL_V3)
    {
        SNMP_MGR_SnmpV3UserEntry_T user_entry;
        SNMP_MGR_SnmpV3GroupEntry_T group_entry;
        struct vacm_accessEntry *ap=NULL;
        UI32_T engineIDLen;

        /* check the user if already exist, if already exist, append to the notify
           view to the group in which the user belonging to otherwise, create the user*/

        strcpy( user_entry.snmpv3_user_name, entry->trap_dest_community);

          engineIDLen = snmpv3_get_engineID( user_entry.snmpv3_user_engine_id, MAXSIZE_snmpEngineID);


        if (SNMP_MGR_GetSnmpV3User(&user_entry) == SNMP_MGR_ERROR_OK)
        {
            /*Check securityToGroupTable to fetch the group name*/

            geptr = vacm_getGroupEntry(SNMP_MGR_SNMPV3_MODEL_V3 , user_entry.snmpv3_user_name);

            group_entry.snmpv3_group_model = user_entry.snmpv3_user_security_model;
            group_entry.snmpv3_group_security_level = entry->trap_dest_security_level;
            if (geptr)
            {
                strcpy(group_entry.snmpv3_group_name, geptr->groupName);
                /* check if a vacmAccessTable exist*/

                ap = vacm_getExactAccessEntry(group_entry.snmpv3_group_name, "", SNMP_MGR_SNMPV3_MODEL_V3,group_entry.snmpv3_group_security_level );

                /* if such vacmAccessTable exist, we append the notify view to it*/
                if (ap)
                {
                    /*find an entry, append the notify view to the group entry*/
                     if (SNMP_MGR_AppendNotifyView(&group_entry) != SNMP_MGR_ERROR_OK)
                     {

                          return SNMP_MGR_ERROR_FAIL;
                       }
                  }
                  /* don't exist, we create a notify view for it*/
                  else
                   {
                    strcpy( group_entry.snmpv3_group_readview, "");
                      strcpy(group_entry.snmpv3_group_writeview, "");
                       strcpy(group_entry.snmpv3_group_notifyview, "defaultview");
                       group_entry.snmpv3_group_storage_type = VAL_vacmAccessStorageType_volatile;
                      if (SNMP_MGR_CreateSnmpV3Group(&group_entry, TRUE) != SNMP_MGR_ERROR_OK)
                       {

                          return SNMP_MGR_ERROR_FAIL;
                      }
                   }
               }
               else
               {
                   strcpy(group_entry.snmpv3_group_name, entry->trap_dest_community);
                strcpy( group_entry.snmpv3_group_readview, "");
                  strcpy(group_entry.snmpv3_group_writeview, "");
                   strcpy(group_entry.snmpv3_group_notifyview, "defaultview");
                   group_entry.snmpv3_group_storage_type = VAL_vacmAccessStorageType_volatile;
                  if (SNMP_MGR_CreateSnmpV3Group(&group_entry, TRUE) != SNMP_MGR_ERROR_OK)
                   {

                      return SNMP_MGR_ERROR_FAIL;
                  }
               }
           }
           else
           {
              memset( &user_entry, 0, sizeof(user_entry));
              strcpy( user_entry.snmpv3_user_name, entry->trap_dest_community);
              strcpy(user_entry.snmpv3_user_group_name, entry->trap_dest_community);
               strcpy(user_entry.snmpv3_user_auth_password, "");
               strcpy(user_entry.snmpv3_user_priv_password, "");
               user_entry.snmpv3_user_security_model = SNMP_MGR_SNMPV3_MODEL_V3;
               user_entry.snmpv3_user_security_level=VAL_vacmAccessSecurityLevel_noAuthNoPriv;
               user_entry.snmpv3_user_auth_type = SNMP_MGR_SNMPV3_AUTHTYPE_NONE;
               user_entry.snmpv3_user_priv_type = SNMP_MGR_SNMPV3_PRIVTYPE_NONE;
               user_entry.password_from_config = FALSE;
               user_entry.snmpv3_user_storage_type = VAL_usmUserStorageType_volatile;
               if (SNMP_MGR_CreateSnmpV3User(&user_entry, TRUE) != SNMP_MGR_ERROR_OK)
            {

                return SNMP_MGR_ERROR_FAIL;
            }

            /* Then create the group*/
            strcpy(group_entry.snmpv3_group_name, entry->trap_dest_community);
            group_entry.snmpv3_group_model = entry->trap_dest_version;
            group_entry.snmpv3_group_security_level = entry->trap_dest_security_level;
            if (SNMP_MGR_CheckGroupExist( &group_entry)== SNMP_MGR_ERROR_OK)
            {
               /*find an entry, append the notify view to the group entry*/
               if (SNMP_MGR_AppendNotifyView(&group_entry) != SNMP_MGR_ERROR_OK)
               {

                    return SNMP_MGR_ERROR_FAIL;
                 }
               }
               else
               {
                strcpy( group_entry.snmpv3_group_readview, "");
                  strcpy(group_entry.snmpv3_group_writeview, "");
                   strcpy(group_entry.snmpv3_group_notifyview, "defaultview");
                   group_entry.snmpv3_group_storage_type = VAL_vacmAccessStorageType_volatile;
                  if (SNMP_MGR_CreateSnmpV3Group(&group_entry, TRUE) != SNMP_MGR_ERROR_OK)
                   {

                      return SNMP_MGR_ERROR_FAIL;
                  }
               }
        }
    }

    /* Now enter the next step, we need to create the snmpNotifyFilterProfileTable and
       snmpNotifyFilterTable*/

    /* create snmpNotifyFilterProfileTable
     */
    memcpy(&notify_filter_profile_entry.snmp_notify_filter_profile_ip, &entry->trap_dest_address,
        sizeof(notify_filter_profile_entry.snmp_notify_filter_profile_ip));
    strncpy(notify_filter_profile_entry.snmp_target_params_name,
        target_params_entry.snmp_target_params_name,
        sizeof(notify_filter_profile_entry.snmp_target_params_name)-1);
    notify_filter_profile_entry.snmp_target_params_name[sizeof(notify_filter_profile_entry.snmp_target_params_name)-1] = '\0';
    notify_filter_profile_entry.snmp_notify_filter_profile_stor_type = VAL_snmpNotifyFilterProfileStorType_nonVolatile;
    notify_filter_profile_entry.snmp_notify_filter_profile_row_status = VAL_snmpNotifyFilterProfileRowStatus_active ;

    if (SNMP_MGR_CreateSnmpNotifyFilterProfileTable(&notify_filter_profile_entry)!= SNMP_MGR_ERROR_OK)
    {
        return SNMP_MGR_ERROR_FAIL;
    }

    /* create snmpNotifyFilterTable
     */
    strncpy(notify_filter_entry.snmp_notify_filter_profile_name,
        target_params_entry.snmp_target_params_name,
        sizeof(notify_filter_entry.snmp_notify_filter_profile_name)-1);
    notify_filter_entry.snmp_notify_filter_profile_name[sizeof(notify_filter_entry.snmp_notify_filter_profile_name)-1] = '\0';

    /* we create the view as "1" */
    notify_filter_entry.snmp_notify_filter_subtree[0] = 1;
    notify_filter_entry.snmp_notify_filter_subtree_len = 1;
    notify_filter_entry.snmp_notify_filter_mask[0] = 0x80;
    notify_filter_entry.snmp_notify_filter_mask_len = 1;
    notify_filter_entry.snmp_notify_filter_type = VAL_snmpNotifyFilterType_included;
    notify_filter_entry.snmp_notify_filter_storage_type = VAL_snmpNotifyFilterStorageType_nonVolatile;
    notify_filter_entry.snmp_notify_filter_row_status = VAL_snmpNotifyFilterRowStatus_active ;

    if (SNMP_MGR_CreateSnmpNotifyFilterTable(&notify_filter_entry)!= SNMP_MGR_ERROR_OK)
    {
        return SNMP_MGR_ERROR_FAIL;
    }

    return SNMP_MGR_ERROR_OK;
}

/*--------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_VerifyAndDeleteProbeConfigDB
 *---------------------------------------------------------------------------
 * PURPOSE:  This function will check every entry in probe config database (
 *           (snmp_mgr_trap_receiver), and will set the entry to invalid if
 *           the entry is not valid due to target/Notificaiton MIB
 *           deletion.
 * INPUT:    none
 * OUTPUT:   none.
 * RETURN:  none
 *
 * NOTE:    none.
 *---------------------------------------------------------------------------
 */
static void SNMP_MGR_VerifyAndDeleteProbeConfigDB(void)
{
    UI32_T i;
    SNMP_MGR_TrapDestEntry_T entry;
    UI32_T orig_priority;

    SNMP_MGR_CHECK_OPER_MODE_NO_RETURN();
    /* Check if already some entry is invalid, updated the database to invalid*/
    for (i=0; i<SYS_ADPT_MAX_NBR_OF_TRAP_RECEIVER; i++)
    {
        /* for each record in the index array
         */
        if (snmp_mgr_trap_receiver[i].trap_dest_status == VAL_snmpTargetAddrRowStatus_active)
        {
            memcpy(&entry.trap_dest_address,
                   &snmp_mgr_trap_receiver[i].trap_dest_address,
                   sizeof(snmp_mgr_trap_receiver[i].trap_dest_address));

            /* if this does not exist in the actual receiver list,
             * delete it from the index-array
             */
            if (SNMP_MGR_GetTrapReceiver(&entry) != SNMP_MGR_ERROR_OK)
            {

                snmp_mgr_trap_receiver[i].trap_dest_status = VAL_snmpTargetAddrRowStatus_destroy;

#if (SYS_CPNT_SNMP_CONTIGUOUS_TRAP_DEST_TABLE == TRUE)
                /* if this is not the highest-index entry to be deleted, pack;
                 * note: i + 1 is the 1-based user index
                 */
                if (i + 1 < snmp_mgr_trap_receiver_total)
                {
                    /* move all subsequent entries early one position (1-based user index);
                     * note: i + 2 = the next later entry (1-based user index)
                     */
                    SNMP_MGR_MoveTrapReceiverByIndex(i + 2, snmp_mgr_trap_receiver_total - (i + 1), 1);
                }

                /* decrement total
                 */
                snmp_mgr_trap_receiver_total--;
#endif


            }
        }
    }

    return;
}

static BOOL_T SNMP_MGR_IsProbeConfigTrapReceiverDBExist(L_INET_AddrIp_T *address)
{
    UI32_T i;
    UI32_T orig_priority;

    for (i=0; i<SYS_ADPT_MAX_NBR_OF_TRAP_RECEIVER; i++)
    {
        if (snmp_mgr_trap_receiver[i].trap_dest_status == VAL_snmpTargetAddrRowStatus_active)
        {
            if (0 == L_INET_CompareInetAddr((L_INET_Addr_T *) &snmp_mgr_trap_receiver[i].trap_dest_address,
               (L_INET_Addr_T *) address, 0))
            {

                return TRUE;
            }
    }
    }

    return FALSE;

}

static UI32_T SNMP_MGR_CreateProbeConfigTrapReceiverDB(L_INET_AddrIp_T *address, UI32_T port)
{
    UI32_T  i;
    I32_T   available_entry = -1;
    UI32_T  return_val = SNMP_MGR_ERROR_FAIL;
    UI32_T orig_priority;
    SNMP_MGR_CHECK_OPER_MODE(SNMP_MGR_ERROR_FAIL);

    if (VAL_remoteLogServerInetAddressType_ipv4 == address->type)
    {
        if (IP_LIB_OK != IP_LIB_IsValidForRemoteIp((UI8_T *)&address->addr))
        {
            return SNMP_MGR_ERROR_FAIL;
        }
    }

    if ((port < 0) || (port>65535))
    {

        return SNMP_MGR_ERROR_FAIL;
    }


    /* find trap receiver
     */
    for (i=0; i<SYS_ADPT_MAX_NBR_OF_TRAP_RECEIVER; i++)
    {
        /* check address
         */
        /* amy add 1-24-2002 */
        /* set the specific trap receiver status */
        if (0 == L_INET_CompareInetAddr((L_INET_Addr_T *)address,
            (L_INET_Addr_T *) &snmp_mgr_trap_receiver[i].trap_dest_address, 0))
        {
            if (snmp_mgr_trap_receiver[i].trap_dest_status == VAL_snmpTargetAddrRowStatus_active)
            {
                i=SYS_ADPT_MAX_NBR_OF_TRAP_RECEIVER;
                available_entry=-1;
            }
            else
            {
                available_entry = i;
            }
            break;
        }

        /* invalid entry
         */
        if (snmp_mgr_trap_receiver[i].trap_dest_status == VAL_snmpTargetAddrRowStatus_destroy)
        {
            /* record the first empty entry.  When the entry is not existed, this
             * entry will be updated as the input.
             */
            if (available_entry == -1)
                available_entry = i;
            continue;
        }

        /* check address
         */
        if (0 == L_INET_CompareInetAddr((L_INET_Addr_T *) address,
            (L_INET_Addr_T *) &snmp_mgr_trap_receiver[i].trap_dest_address, 0))
        {
            break;
        }
    }

    /* for-loop finished; not found
     */
    if (i == SYS_ADPT_MAX_NBR_OF_TRAP_RECEIVER)
    {
        /* No found, create a new one, if no more available entry then return SNMP_MGR_ERROR_FAIL
         */
        if (available_entry != -1)
        {
            memset(snmp_mgr_trap_receiver[available_entry].trap_dest_owner, 0, MAXSIZE_trapDestOwner+1);
            memcpy(&snmp_mgr_trap_receiver[available_entry].trap_dest_address, address, sizeof(snmp_mgr_trap_receiver[available_entry].trap_dest_address));
            snmp_mgr_trap_receiver[available_entry].trap_dest_port = port;

            /* we fixed the protocol type to ip type*/
            snmp_mgr_trap_receiver[available_entry].trap_dest_protocol = VAL_trapDestProtocol_ip;
            snmp_mgr_trap_receiver[available_entry].trap_dest_status = VAL_snmpTargetAddrRowStatus_active;

#if (SYS_CPNT_SNMP_CONTIGUOUS_TRAP_DEST_TABLE == TRUE)
            /* increment total
             */
            snmp_mgr_trap_receiver_total++;
#endif

            return_val = SNMP_MGR_ERROR_OK;
        }
        else
        {
            return_val = SNMP_MGR_ERROR_FAIL;
        }
    }

    /* found existing
     */
    else
    {
        /* found an entry, update status.  By logically, it should be deleted.
         */

#if (SYS_CPNT_SNMP_CONTIGUOUS_TRAP_DEST_TABLE == TRUE)
        /* PATCH: The above "available_entry" check may find a valid entry for
         * modification or an invalid entry for revival.
         * If this is changing from invalid to valid, increment the total.
         * Otherwise, don't change.
         * This will be changed soon to check for a valid entry only.
         */
        if (snmp_mgr_trap_receiver[available_entry].trap_dest_status == VAL_snmpTargetAddrRowStatus_destroy)
        {
            snmp_mgr_trap_receiver_total++;
        }
#endif

        snmp_mgr_trap_receiver[available_entry].trap_dest_status = VAL_snmpTargetAddrRowStatus_active;
        return_val = TRUE;
    }


    return return_val;

}

/* ------------------------------------------------------------------------
 * FUNCTION NAME - SNMP_MGR_SendTrap
 * ------------------------------------------------------------------------
 * PURPOSE  : Sends a trap.
 * INPUT    : trap_data_p   - pointer to trap data structure
 * OUTPUT   : none
 * RETURN   : TRUE/FALSE    - success/failure
 * NOTES    : none
 * ------------------------------------------------------------------------
 */
#if (SYS_CPNT_DYING_GASP == TRUE)
BOOL_T SNMP_MGR_SendTrap(TRAP_EVENT_TrapData_T *trap_data_p)
#else
static BOOL_T SNMP_MGR_SendTrap(TRAP_EVENT_TrapData_T *trap_data_p)
#endif
{
    netsnmp_variable_list *vars = NULL;
    UI32_T specific = 0;
    UI32_T trap_type = 0;
    UI32_T enterprise_length = 0;
    oid enterprise[SYS_ADPT_MAX_OID_COUNT] = {0};

    /* if log only, no trap
     */
    if (trap_data_p->flag == TRAP_EVENT_SEND_TRAP_OPTION_LOG_ONLY)
    {
        TRAP_DEBUG_MODE_PRINT("%s(): log only\n", __func__);

        return TRUE;
    }

    TRAP_DEBUG_MODE_PRINT("%s(): send trap, type = %lu, time = %lu\n",
                          __func__, (unsigned long)trap_data_p->trap_type,(unsigned long)trap_data_p->trap_time);

    /* The first step we need to define a OID to the trap_type and specific_type*/
    switch (trap_data_p->trap_type)
    {
        /* five of the Six Early Traps (no enterprise)
         */
        case TRAP_EVENT_COLD_START:
            memcpy(enterprise, ID_sysObjectID_value, len_sysObjectID_value * sizeof(oid));
            enterprise_length = len_sysObjectID_value;
            trap_type = SNMP_TRAP_COLDSTART;
            specific = 0;
            /* this trap have no variables binding*/
            vars = NULL;
            break;

        case TRAP_EVENT_WARM_START:
            memcpy(enterprise, ID_sysObjectID_value, len_sysObjectID_value * sizeof(oid));
            enterprise_length = len_sysObjectID_value;
            trap_type = SNMP_TRAP_WARMSTART;
            specific = 0;
            /* this trap have no variables binding*/
            vars = NULL;
            break;

#if (SYS_CPNT_ALARM_DETECT == TRUE)
        /* swMajorAlarm(78)
         */
        case TRAP_EVENT_MAJOR_ALARM:
        {
           TRAP_EVENT_alarmMgt_T *pDynamicData = & trap_data_p->u.alarmMgt;

           /* override the enterprise ID with private MIB */
           memcpy(enterprise, ID_es3626aTrap, len_es3626aTrap * sizeof(oid));
           enterprise_length = len_es3626aTrap;
           trap_type = SNMP_TRAP_ENTERPRISESPECIFIC;
           specific = LEAF_swMajorAlarm;
           vars = NULL;
           /* binding major object type*/
           if (!snmp_varlist_add_variable( &vars, ID_MajorAlarmOutput, len_MajorAlarmOutput,
                                           ASN_INTEGER,
                                           (u_char*)&(pDynamicData->alarmObjectType),
                                           sizeof(pDynamicData->alarmObjectType)))
           {
               snmp_free_varbind(vars);
               return FALSE;
           }

           break;
        }

        /* swEqpAlarmRecovery(85)
         */
        case TRAP_EVENT_MAJOR_ALARM_RECOVERY:
        {
            TRAP_EVENT_MajorAlarmRecovery_T *pDynamicData = & trap_data_p->u.alarm_recovery;

           /* override the enterprise ID with private MIB */
           memcpy(enterprise, ID_es3626aTrap, len_es3626aTrap * sizeof(oid));
           enterprise_length = len_es3626aTrap;
           trap_type = SNMP_TRAP_ENTERPRISESPECIFIC;
           specific = LEAF_swEqpAlarmRecovery;
           vars = NULL;
           /* binding major object type*/
           if (!snmp_varlist_add_variable( &vars, ID_MajorAlarmOutputRecovery, len_MajorAlarmOutputRecovery,
                                           ASN_INTEGER,
                                           (u_char*)&(pDynamicData->alarmRecoveryObjectType),
                                           sizeof(pDynamicData->alarmRecoveryObjectType)))
           {
               snmp_free_varbind(vars);
               return FALSE;
           }

           break;
        }

        /* swMinorAlarm(79)
         */
        case TRAP_EVENT_MINOR_ALARM:
        {
           TRAP_EVENT_alarmMgt_T *pDynamicData = & trap_data_p->u.alarmMgt;

           /* override the enterprise ID with private MIB */
           memcpy(enterprise, ID_es3626aTrap, len_es3626aTrap * sizeof(oid));
           enterprise_length = len_es3626aTrap;
           trap_type = SNMP_TRAP_ENTERPRISESPECIFIC;
           specific = LEAF_swMinorAlarm;
           vars = NULL;

           /* binding major object type*/
           if (!snmp_varlist_add_variable( &vars, ID_MinorAlarmOutput, len_MinorAlarmOutput,
                                           ASN_INTEGER,
                                           (u_char*)&(pDynamicData->alarmObjectType),
                                           sizeof(pDynamicData->alarmObjectType)))
           {
               snmp_free_varbind(vars);
               return FALSE;
           }

           break;
        }
#endif  /* (SYS_CPNT_ALARM_DETECT == TRUE) */

        /* five of the Six Early Traps (no enterprise)
         */
        case TRAP_EVENT_LINK_DOWN:
        {
            UI32_T ILifIndex;
            UI32_T ILifAdminStatus;
            UI32_T ILifOperStatus;
            TRAP_EVENT_LinkTrap_T *pDynamicData = & trap_data_p->u.link_up;

            memcpy(enterprise, ID_sysObjectID_value, len_sysObjectID_value * sizeof(oid));
            enterprise_length = len_sysObjectID_value;

            trap_type = SNMP_TRAP_LINKDOWN;
            specific = 0;
            vars = NULL;

            /* binding ifIndex*/
            memcpy((char*)(ID_ifIndex + len_ifIndex), (char*)&pDynamicData->instance_ifindex, 1 * sizeof(oid));
            ILifIndex = len_ifIndex+1;
            if (!snmp_varlist_add_variable( &vars, ID_ifIndex, ILifIndex,
                                            ASN_INTEGER,
                                            (u_char*)&(pDynamicData->ifindex),
                                            sizeof(pDynamicData->ifindex)))
            {
                snmp_free_varbind(vars);

                return FALSE;
            }

            /* binding ifAdminStatus */
            memcpy((char*)(ID_ifAdminStatus + len_ifAdminStatus), (char*)&pDynamicData->instance_adminstatus, 1 * sizeof(oid));
            ILifAdminStatus= len_ifAdminStatus+1;
            if (!snmp_varlist_add_variable( &vars, ID_ifAdminStatus, ILifAdminStatus,
                                            ASN_INTEGER,
                                            (u_char*)&(pDynamicData->adminstatus),
                                            sizeof(pDynamicData->adminstatus)))
            {
                snmp_free_varbind(vars);

                return FALSE;
            }

            /* binding ifOperStatus */
            memcpy((char*)(ID_ifOperStatus + len_ifOperStatus), (char*)&pDynamicData->instance_operstatus, 1 * sizeof(oid));
            ILifOperStatus= len_ifOperStatus+1;
            if (!snmp_varlist_add_variable( &vars, ID_ifOperStatus, ILifOperStatus,
                                            ASN_INTEGER,
                                            (u_char*)&(pDynamicData->operstatus),
                                            sizeof(pDynamicData->operstatus)))
            {
                snmp_free_varbind(vars);

                return FALSE;
            }

            break;
        }

        case TRAP_EVENT_LINK_UP:
        {
            UI32_T ILifIndex;
            UI32_T ILifAdminStatus;
            UI32_T ILifOperStatus;
            TRAP_EVENT_LinkTrap_T *pDynamicData = & trap_data_p->u.link_up;

            memcpy(enterprise, ID_sysObjectID_value, len_sysObjectID_value * sizeof(oid));
            enterprise_length = len_sysObjectID_value;

            trap_type = SNMP_TRAP_LINKUP;
            specific = 0;
            vars = NULL;

            /* binding ifIndex*/
            memcpy((char*)(ID_ifIndex + len_ifIndex), (char*)&pDynamicData->instance_ifindex, 1 * sizeof(oid));
            ILifIndex= len_ifIndex+1;
            if (!snmp_varlist_add_variable( &vars, ID_ifIndex, ILifIndex,
                                            ASN_INTEGER,
                                            (u_char*)&(pDynamicData->ifindex),
                                            sizeof(pDynamicData->ifindex)))
            {
                snmp_free_varbind(vars);

                return FALSE;
            }

            /* binding ifAdminStatus */
            memcpy((char*)(ID_ifAdminStatus + len_ifAdminStatus), (char*)&pDynamicData->instance_adminstatus, 1 * sizeof(oid));
            ILifAdminStatus= len_ifAdminStatus+1;
            if (!snmp_varlist_add_variable( &vars, ID_ifAdminStatus, ILifAdminStatus,
                                            ASN_INTEGER,
                                            (u_char*)&(pDynamicData->adminstatus),
                                            sizeof(pDynamicData->adminstatus)))
            {
                snmp_free_varbind(vars);

                return FALSE;
            }

            /* binding ifOperStatus */
            memcpy((char*)(ID_ifOperStatus + len_ifOperStatus), (char*)&pDynamicData->instance_operstatus, 1 * sizeof(oid));
            ILifOperStatus= len_ifOperStatus+1;
            if (!snmp_varlist_add_variable( &vars, ID_ifOperStatus, ILifOperStatus,
                                            ASN_INTEGER,
                                            (u_char*)&(pDynamicData->operstatus),
                                            sizeof(pDynamicData->operstatus)))
            {
                snmp_free_varbind(vars);

                return FALSE;
            }

            break;
        }

#if (SYS_CPNT_CRAFT_PORT == TRUE)
        case TRAP_EVENT_CRAFT_PORT_LINK_UP:
            memcpy(enterprise, ID_es3626aTrap, len_es3626aTrap * sizeof(oid));
            enterprise_length = len_es3626aTrap;
            trap_type = SNMP_TRAP_ENTERPRISESPECIFIC;
            specific = LEAF_craftPortLinkUp;
            vars = NULL;
            break;

        case TRAP_EVENT_CRAFT_PORT_LINK_DOWN:
            memcpy(enterprise, ID_es3626aTrap, len_es3626aTrap * sizeof(oid));
            enterprise_length = len_es3626aTrap;
            trap_type = SNMP_TRAP_ENTERPRISESPECIFIC;
            specific = LEAF_craftPortLinkDown;
            vars = NULL;
            break;
#endif

        case TRAP_EVENT_AUTHENTICATION_FAILURE:
            memcpy(enterprise, ID_sysObjectID_value, len_sysObjectID_value * sizeof(oid));
            enterprise_length = len_sysObjectID_value;
            trap_type = SNMP_TRAP_AUTHFAIL;
            specific = 0;
            vars = NULL;
            break;

        /* Spanning Tree Protocol MIB
         */
        case TRAP_EVENT_NEW_ROOT:
            memcpy(enterprise, snmp_mgr_bridge_mib_oid, len_snmp_mgr_bridge_mib_oid * sizeof(oid));
            enterprise_length = len_snmp_mgr_bridge_mib_oid;
            trap_type = SNMP_TRAP_ENTERPRISESPECIFIC;
            specific = 1;
            vars = NULL;
            break;

        case TRAP_EVENT_TOPOLOGY_CHANGE:
            memcpy(enterprise, snmp_mgr_bridge_mib_oid, len_snmp_mgr_bridge_mib_oid * sizeof(oid));
            enterprise_length = len_snmp_mgr_bridge_mib_oid;
            trap_type = SNMP_TRAP_ENTERPRISESPECIFIC;
            specific = 2;
            vars = NULL;
            break;

        /* RMON MIB
         */
        case TRAP_EVENT_RISING_ALARM:
        {
           UI32_T		ILalarmIndex;
           UI32_T		ILalarmVariable;
           UI32_T		ILalarmSampleType;
           UI32_T		ILalarmValue;
           UI32_T		ILalarmRisingThreshold;
           UI32_T       variable_len;

           TRAP_EVENT_RisingFallingAlarmTrap_T *pDynamicData = & trap_data_p->u.rising_alarm;

           memcpy(enterprise, snmp_mgr_rmon_mib_oid, len_snmp_mgr_rmon_mib_oid * sizeof(oid));
           enterprise_length = len_snmp_mgr_rmon_mib_oid;
           trap_type = SNMP_TRAP_ENTERPRISESPECIFIC;
           specific = 1;
           vars = NULL;

            /* binding alarmIndex*/
           memcpy((char*)(ID_alarmIndex + len_alarmIndex), (char*)&pDynamicData->instance_alarm_index, 1 * sizeof(oid));
           ILalarmIndex= len_alarmIndex+1;
           if (!snmp_varlist_add_variable( &vars, ID_alarmIndex, ILalarmIndex,
                                           ASN_INTEGER,
                                           (u_char*)&(pDynamicData->alarm_index),
                                           sizeof(pDynamicData->alarm_index)))
           {
               snmp_free_varbind(vars);

               return FALSE;
           }

           /* binding alarmVariable */
           memcpy((char*)(ID_alarmVariable + len_alarmVariable), (char*)&pDynamicData->instance_alarm_variable, 1 * sizeof(oid));
           ILalarmVariable= len_alarmVariable+1;
           /*eli,use memcpy to solve aligned issue for pDynamicData->alarm_variable_len in arm*/
           memcpy(&variable_len,&pDynamicData->alarm_variable_len,4);
           variable_len=variable_len*sizeof(oid);
           if (!snmp_varlist_add_variable( &vars, ID_alarmVariable, ILalarmVariable,
                                           ASN_OBJECT_ID,
                                           (u_char*) pDynamicData->alarm_variable,
                                            variable_len))
           {
               snmp_free_varbind(vars);

               return FALSE;
           }

           /* binding alarmSampleType */
           memcpy((char*)(ID_alarmSampleType + len_alarmSampleType), (char*)&pDynamicData->instance_alarm_sample_type, 1 * sizeof(oid));
           ILalarmSampleType= len_alarmSampleType+1;
           if (!snmp_varlist_add_variable( &vars, ID_alarmSampleType, ILalarmSampleType,
                                           ASN_INTEGER,
                                           (u_char*)&(pDynamicData->alarm_sample_type),
                                           sizeof(pDynamicData->alarm_sample_type)))
           {
               snmp_free_varbind(vars);

               return FALSE;
           }

           /* binding alarmValue */
           memcpy((char*)(ID_alarmValue + len_alarmValue), (char*)&pDynamicData->instance_alarm_value, 1 * sizeof(oid));
           ILalarmValue= len_alarmValue+1;
           if (!snmp_varlist_add_variable( &vars, ID_alarmValue, ILalarmValue,
                                           ASN_INTEGER,
                                           (u_char*)&(pDynamicData->alarm_value),
                                           sizeof(pDynamicData->alarm_value)))
           {
               snmp_free_varbind(vars);

               return FALSE;
           }

           /* binding alarmRisingFallingThreshold */
           memcpy((char*)(ID_alarmRisingThreshold + len_alarmRisingThreshold), (char*)&pDynamicData->instance_alarm_rising_falling_threshold, 1 * sizeof(oid));
           ILalarmRisingThreshold= len_alarmRisingThreshold+1;
           if (!snmp_varlist_add_variable( &vars, ID_alarmRisingThreshold, ILalarmRisingThreshold,
                                           ASN_INTEGER,
                                           (u_char*)&(pDynamicData->alarm_rising_falling_threshold),
                                           sizeof(pDynamicData->alarm_rising_falling_threshold)))
           {
               snmp_free_varbind(vars);

               return FALSE;
           }

           break;
        }

        case TRAP_EVENT_FALLING_ALARM:
          {
           UI32_T		ILalarmIndex;
           UI32_T		ILalarmVariable;
           UI32_T		ILalarmSampleType;
           UI32_T		ILalarmValue;
           UI32_T		ILalarmFallingThreshold;
           UI32_T         variable_len;
           TRAP_EVENT_RisingFallingAlarmTrap_T *pDynamicData = & trap_data_p->u.falling_alarm;

           memcpy(enterprise, snmp_mgr_rmon_mib_oid, len_snmp_mgr_rmon_mib_oid * sizeof(oid));
           enterprise_length = len_snmp_mgr_rmon_mib_oid;
           trap_type = SNMP_TRAP_ENTERPRISESPECIFIC;
           specific = 2;
           vars = NULL;

            /* binding alarmIndex*/
           memcpy((char*)(ID_alarmIndex + len_alarmIndex), (char*)&pDynamicData->instance_alarm_index, 1 * sizeof(oid));
           ILalarmIndex= len_alarmIndex+1;
           if (!snmp_varlist_add_variable( &vars, ID_alarmIndex, ILalarmIndex,
                                           ASN_INTEGER,
                                           (u_char*)&(pDynamicData->alarm_index),
                                           sizeof(pDynamicData->alarm_index)))
           {
               snmp_free_varbind(vars);

               return FALSE;
           }

           /* binding alarmVariable */
           memcpy((char*)(ID_alarmVariable + len_alarmVariable), (char*)&pDynamicData->instance_alarm_variable, 1 * sizeof(oid));
           ILalarmVariable= len_alarmVariable+1;
           /*eli,use memcpy to solve aligned issue for pDynamicData->alarm_variable_len in arm*/
           memcpy(&variable_len,&pDynamicData->alarm_variable_len,4);
           variable_len=variable_len*sizeof(oid);
           if (!snmp_varlist_add_variable( &vars, ID_alarmVariable, ILalarmVariable,
                                           ASN_OBJECT_ID,
                                           (u_char*) pDynamicData->alarm_variable,
                                           variable_len ))
           {
               snmp_free_varbind(vars);

               return FALSE;
           }

           /* binding alarmSampleType */
           memcpy((char*)(ID_alarmSampleType + len_alarmSampleType), (char*)&pDynamicData->instance_alarm_sample_type, 1 * sizeof(oid));
           ILalarmSampleType= len_alarmSampleType+1;
           if (!snmp_varlist_add_variable( &vars, ID_alarmSampleType, ILalarmSampleType,
                                           ASN_INTEGER,
                                           (u_char*)&(pDynamicData->alarm_sample_type),
                                           sizeof(pDynamicData->alarm_sample_type)))
           {
               snmp_free_varbind(vars);

               return FALSE;
           }

           /* binding alarmValue */
           memcpy((char*)(ID_alarmValue + len_alarmValue), (char*)&pDynamicData->instance_alarm_value, 1 * sizeof(oid));
           ILalarmValue= len_alarmValue+1;
           if (!snmp_varlist_add_variable( &vars, ID_alarmValue, ILalarmValue,
                                           ASN_INTEGER,
                                           (u_char*)&(pDynamicData->alarm_value),
                                           sizeof(pDynamicData->alarm_value)))
           {
               snmp_free_varbind(vars);

               return FALSE;
           }

           /* binding alarmRisingFallingThreshold */
           memcpy((char*)(ID_alarmFallingThreshold + len_alarmRisingThreshold), (char*)&pDynamicData->instance_alarm_rising_falling_threshold, 1 * sizeof(oid));
           ILalarmFallingThreshold= len_alarmFallingThreshold+1;
           if (!snmp_varlist_add_variable( &vars, ID_alarmFallingThreshold, ILalarmFallingThreshold,
                                           ASN_INTEGER,
                                           (u_char*)&(pDynamicData->alarm_rising_falling_threshold),
                                           sizeof(pDynamicData->alarm_rising_falling_threshold)))
           {
               snmp_free_varbind(vars);

               return FALSE;
           }

           break;
        }

#if (SYS_CPNT_POWER_DETECT == TRUE)
        /* swPowerStatusChangeTrap(1)
         */
        case TRAP_EVENT_SW_POWER_STATUS_CHANGE_TRAP:
        {

           UI32_T       ILswIndivPowerUnitIndex;
           UI32_T       ILswIndivPowerIndex;
           UI32_T		ILswIndivPowerStatus;
           TRAP_EVENT_PowerStatusChangeTrap_T *pDynamicData = & trap_data_p->u.sw_power_status_change_trap;

           /* override the enterprise ID with private MIB */
           memcpy(enterprise, ID_es3626aTrap, len_es3626aTrap * sizeof(oid));
           enterprise_length = len_es3626aTrap;
           trap_type = SNMP_TRAP_ENTERPRISESPECIFIC;
           specific = LEAF_swPowerStatusChangeTrap;
           vars = NULL;

            /* binding swIndivPowerUnitIndex*/
           memcpy((char*)(ID_swIndivPowerUnitIndex + len_swIndivPowerUnitIndex), (char*)pDynamicData->instance_sw_indiv_power_unit_index, lenIdx_swIndivPowerIndex * sizeof(oid));
           ILswIndivPowerUnitIndex= len_swIndivPowerUnitIndex+lenIdx_swIndivPowerIndex;
           if (!snmp_varlist_add_variable( &vars, ID_swIndivPowerUnitIndex, ILswIndivPowerUnitIndex,
                                           ASN_INTEGER,
                                           (u_char*)&(pDynamicData->sw_indiv_power_unit_index),
                                           sizeof(pDynamicData->sw_indiv_power_unit_index)))
           {
               snmp_free_varbind(vars);

               return FALSE;
           }


           /* binding swIndivPowerIndex */
           memcpy((char*)(ID_swIndivPowerIndex + len_swIndivPowerIndex), (char*)pDynamicData->instance_sw_indiv_power_index, lenIdx_swIndivPowerIndex * sizeof(oid));
           ILswIndivPowerIndex= len_swIndivPowerIndex+lenIdx_swIndivPowerIndex;
           if (!snmp_varlist_add_variable( &vars, ID_swIndivPowerIndex, ILswIndivPowerIndex,
                                           ASN_INTEGER,
                                           (u_char*)&(pDynamicData->sw_indiv_power_index),
                                           sizeof(pDynamicData->sw_indiv_power_index)))
           {
               snmp_free_varbind(vars);

               return FALSE;
           }


           /* binding swIndivPowerStatus */
           memcpy((char*)(ID_swIndivPowerStatus + len_swIndivPowerStatus), (char*)pDynamicData->instance_sw_indiv_power_status, lenIdx_swIndivPowerIndex * sizeof(oid));
           ILswIndivPowerStatus= len_swIndivPowerStatus+lenIdx_swIndivPowerIndex;
           if (!snmp_varlist_add_variable( &vars, ID_swIndivPowerStatus, ILswIndivPowerStatus,
                                           ASN_INTEGER,
                                           (u_char*)&(pDynamicData->sw_indiv_power_status),
                                           sizeof(pDynamicData->sw_indiv_power_status)))
           {
               snmp_free_varbind(vars);

               return FALSE;
           }

           break;
        }
        /* swActivePowerChangeTrap(198)
         */
        case TRAP_EVENT_SW_ACTIVE_POWER_CHANGE_TRAP:
        {

           UI32_T       ILswIndivPowerUnitIndex;
           UI32_T       ILswIndivPowerIndex;
           TRAP_EVENT_ActivePowerChangeTrap_T *pDynamicData = & trap_data_p->u.sw_active_power_change_trap;

           /* override the enterprise ID with private MIB */
           memcpy(enterprise, ID_es3626aTrap, len_es3626aTrap * sizeof(oid));
           enterprise_length = len_es3626aTrap;
           trap_type = SNMP_TRAP_ENTERPRISESPECIFIC;
           specific = LEAF_swActivePowerChangeTrap;
           vars = NULL;

           /* binding swIndivPowerUnitIndex*/
           memcpy((char*)(ID_swIndivPowerUnitIndex + len_swIndivPowerUnitIndex), (char*)pDynamicData->instance_sw_indiv_power_unit_index, lenIdx_swIndivPowerIndex * sizeof(oid));
           ILswIndivPowerUnitIndex= len_swIndivPowerUnitIndex+lenIdx_swIndivPowerIndex;
           if (!snmp_varlist_add_variable( &vars, ID_swIndivPowerUnitIndex, ILswIndivPowerUnitIndex,
                                           ASN_INTEGER,
                                           (u_char*)&(pDynamicData->sw_indiv_power_unit_index),
                                           sizeof(pDynamicData->sw_indiv_power_unit_index)))
           {
               snmp_free_varbind(vars);

               return FALSE;
           }


           /* binding swIndivPowerIndex */
           memcpy((char*)(ID_swIndivPowerIndex + len_swIndivPowerIndex), (char*)pDynamicData->instance_sw_indiv_power_index, lenIdx_swIndivPowerIndex * sizeof(oid));
           ILswIndivPowerIndex= len_swIndivPowerIndex+lenIdx_swIndivPowerIndex;
           if (!snmp_varlist_add_variable( &vars, ID_swIndivPowerIndex, ILswIndivPowerIndex,
                                           ASN_INTEGER,
                                           (u_char*)&(pDynamicData->sw_indiv_power_index),
                                           sizeof(pDynamicData->sw_indiv_power_index)))
           {
               snmp_free_varbind(vars);

               return FALSE;
           }

           break;
        }
#endif

#if (SYS_CPNT_INTRUSION_MSG_TRAP == TRUE)
        /* swPortSecurityTrap(36)
         */
        case TRAP_EVENT_PORT_SECURITY_TRAP:
        {
           UI32_T ILifIndex;
           TRAP_EVENT_PortSecurityTrap_T *pDynamicData = & trap_data_p->u.port_security_trap;

           /* override the enterprise ID with private MIB */
           memcpy(enterprise, ID_es3626aTrap, len_es3626aTrap * sizeof(oid));
           enterprise_length = len_es3626aTrap;
           trap_type = SNMP_TRAP_ENTERPRISESPECIFIC;
           specific = LEAF_swPortSecurityTrap;
           vars = NULL;

           /* binding ifIndex*/
           memcpy((char*)(ID_ifIndex + len_ifIndex), (char*)&pDynamicData->instance_ifindex, 1 * sizeof(oid));
           ILifIndex= len_ifIndex+1;
           if (!snmp_varlist_add_variable( &vars, ID_ifIndex, ILifIndex,
                                           ASN_INTEGER,
                                           (u_char*)&(pDynamicData->ifindex),
                                           sizeof(pDynamicData->ifindex)))
           {
               snmp_free_varbind(vars);

               return FALSE;
           }

           /* binding trapPortSecurityIntrusionMac
            */
           if (!snmp_varlist_add_variable(&vars, ID_trapPortSecurityIntrusionMac, len_trapPortSecurityIntrusionMac + lenIdx_trapPortSecurityIntrusionMac,
                                          ASN_OCTET_STR,
                                          (u_char*)&(pDynamicData->mac),
                                          sizeof(pDynamicData->mac)))
           {
               snmp_free_varbind(vars);
               return FALSE;
           }

           break;
        }
#endif

#if (SYS_CPNT_STKTPLG_FAN_DETECT == TRUE)
        /* swFanFailureTrap(17)
         */
        case TRAP_EVENT_FAN_FAILURE:
        {
           UI32_T ILswitchUnitIndex;
           UI32_T ILswitchFanIndex;
           TRAP_EVENT_FanTrap_T *pDynamicData = & trap_data_p->u.fan_trap;

           /* override the enterprise ID with private MIB */
           memcpy(enterprise, ID_es3626aTrap, len_es3626aTrap * sizeof(oid));
           enterprise_length = len_es3626aTrap;
           trap_type = SNMP_TRAP_ENTERPRISESPECIFIC;
           specific = LEAF_swFanFailureTrap;
           vars = NULL;

           /* binding switchUnitIndex*/
           memcpy((char*)(ID_switchUnitIndex + len_switchUnitIndex), (char*)pDynamicData->instance_trap_unit_index, lenIdx_switchUnitIndex * sizeof(oid));
           ILswitchUnitIndex= len_switchUnitIndex+lenIdx_switchUnitIndex;
           if (!snmp_varlist_add_variable( &vars, ID_switchUnitIndex, ILswitchUnitIndex,
                                           ASN_INTEGER,
                                           (u_char*)&(pDynamicData->trap_unit_index),
                                           sizeof(pDynamicData->trap_unit_index)))
           {
               snmp_free_varbind(vars);

               return FALSE;
           }

           /* binding switchFanIndex*/
           memcpy((char*)(ID_switchFanIndex + len_switchFanIndex), (char*)pDynamicData->instance_trap_fan_index, lenIdx_switchFanIndex * sizeof(oid));
           ILswitchFanIndex= len_switchFanIndex+lenIdx_switchFanIndex;
           if (!snmp_varlist_add_variable( &vars, ID_switchFanIndex, ILswitchFanIndex,
                                           ASN_INTEGER,
                                           (u_char*)&(pDynamicData->trap_fan_index),
                                           sizeof(pDynamicData->trap_fan_index)))
           {
               snmp_free_varbind(vars);

               return FALSE;
           }

            break;
        }

        /* swFanRecoverTrap(18)
         */
        case TRAP_EVENT_FAN_RECOVER:
        {
           UI32_T ILswitchUnitIndex;
           UI32_T ILswitchFanIndex;

           TRAP_EVENT_FanTrap_T *pDynamicData = & trap_data_p->u.fan_trap;

           /* override the enterprise ID with private MIB */
           memcpy(enterprise, ID_es3626aTrap, len_es3626aTrap * sizeof(oid));
           enterprise_length = len_es3626aTrap;
           trap_type = SNMP_TRAP_ENTERPRISESPECIFIC;
           specific = LEAF_swFanRecoverTrap;
           vars = NULL;

           /* binding switchUnitIndex*/
           memcpy((char*)(ID_switchUnitIndex + len_switchUnitIndex), (char*)pDynamicData->instance_trap_unit_index, lenIdx_switchUnitIndex * sizeof(oid));
           ILswitchUnitIndex= len_switchUnitIndex+lenIdx_switchUnitIndex;
           if (!snmp_varlist_add_variable( &vars, ID_switchUnitIndex, ILswitchUnitIndex,
                                           ASN_INTEGER,
                                           (u_char*)&(pDynamicData->trap_unit_index),
                                           sizeof(pDynamicData->trap_unit_index)))
           {
               snmp_free_varbind(vars);

               return FALSE;
           }

           /* binding switchFanIndex*/
           memcpy((char*)(ID_switchFanIndex + len_switchFanIndex), (char*)pDynamicData->instance_trap_fan_index, lenIdx_switchFanIndex * sizeof(oid));
           ILswitchFanIndex= len_switchFanIndex+lenIdx_switchFanIndex;
           if (!snmp_varlist_add_variable( &vars, ID_switchFanIndex, ILswitchFanIndex,
                                           ASN_INTEGER,
                                           (u_char*)&(pDynamicData->trap_fan_index),
                                           sizeof(pDynamicData->trap_fan_index)))
           {
               snmp_free_varbind(vars);

               return FALSE;
           }

            break;
        }
#endif

        /* River@May 8, 2008, add thermal trap */
#if (SYS_CPNT_THERMAL_DETECT == TRUE)
        /* swThermalRisingNotification(58)
         */
        case TRAP_EVENT_THERMAL_RISING:
        {
            UI32_T ILswitchThermalTempValue;
            UI32_T ILswitchThermalActionRisingThreshold;
            TRAP_EVENT_thermalRising_T *pDynamicData;

            pDynamicData = & ((TRAP_EVENT_TrapData_T *) trap_data_p)->u.thermal_rising;

            /* override the enterprise ID with private MIB
             */
            memcpy(enterprise, ID_es3626aTrap, len_es3626aTrap * sizeof(oid));
            enterprise_length = len_es3626aTrap;
            trap_type = SNMP_TRAP_ENTERPRISESPECIFIC;
            specific = LEAF_swThermalRisingNotification;
            vars = NULL;

            /* bind switchThermalTempValue
             */
            memcpy((ID_switchThermalTempValue + len_switchThermalTempValue),
                pDynamicData->instance_switchThermalTempValue,
                lenIdx_switchThermalTempValue * sizeof(oid));
            ILswitchThermalTempValue = len_switchThermalTempValue + lenIdx_switchThermalTempValue;

            if (!snmp_varlist_add_variable(&vars, ID_switchThermalTempValue,
                                           ILswitchThermalTempValue,
                                           ASN_INTEGER,
                                           (u_char *) &(pDynamicData->switchThermalTempValue),
                                           sizeof(pDynamicData->switchThermalTempValue)))
            {
                snmp_free_varbind(vars);
                return FALSE;
            }

            /* bind switchThermalActionRisingThreshold:
             * last index "switchThermalActionAction" is not supported in
             * the core layer and is hardcoded as 1
             */
            memcpy(ID_switchThermalActionRisingThreshold + len_switchThermalActionRisingThreshold,
                pDynamicData->instance_switchThermalActionRisingThreshold,
                lenIdx_switchThermalActionRisingThreshold * sizeof(oid));
            ILswitchThermalActionRisingThreshold = len_switchThermalActionRisingThreshold + lenIdx_switchThermalActionRisingThreshold;

            if (!snmp_varlist_add_variable(&vars, ID_switchThermalActionRisingThreshold,
                                           ILswitchThermalActionRisingThreshold,
                                           ASN_INTEGER,
                                           (u_char *) &(pDynamicData->switchThermalActionRisingThreshold),
                                           sizeof(pDynamicData->switchThermalActionRisingThreshold)))
            {
                snmp_free_varbind(vars);
                return FALSE;
            }

            break;
        }

        /* swThermalFallingNotification(59)
         */
        case TRAP_EVENT_THERMAL_FALLING:
        {
            UI32_T ILswitchThermalTempValue;
            UI32_T ILswitchThermalActionFallingThreshold;
            TRAP_EVENT_thermalFalling_T *pDynamicData;

            pDynamicData = & ((TRAP_EVENT_TrapData_T *) trap_data_p)->u.thermal_falling;

            /* override the enterprise ID with private MIB
             */
            memcpy(enterprise, ID_es3626aTrap, len_es3626aTrap * sizeof(oid));
            enterprise_length = len_es3626aTrap;
            trap_type = SNMP_TRAP_ENTERPRISESPECIFIC;
            specific = LEAF_swThermalFallingNotification;
            vars = NULL;

            /* bind switchThermalTempValue
             */
            memcpy((ID_switchThermalTempValue + len_switchThermalTempValue),
                pDynamicData->instance_switchThermalTempValue,
                lenIdx_switchThermalTempValue * sizeof(oid));
            ILswitchThermalTempValue = len_switchThermalTempValue + lenIdx_switchThermalTempValue;

            if (!snmp_varlist_add_variable(&vars, ID_switchThermalTempValue,
                                           ILswitchThermalTempValue,
                                           ASN_INTEGER,
                                           (u_char *) &(pDynamicData->switchThermalTempValue),
                                           sizeof(pDynamicData->switchThermalTempValue)))
            {
                snmp_free_varbind(vars);
                return FALSE;
            }

            /* bind switchThermalActionFallingThreshold
             */
            memcpy((ID_switchThermalActionFallingThreshold + len_switchThermalActionFallingThreshold),
                pDynamicData->instance_switchThermalActionFallingThreshold,
                lenIdx_switchThermalActionFallingThreshold * sizeof(oid));
            ILswitchThermalActionFallingThreshold = len_switchThermalActionFallingThreshold + lenIdx_switchThermalActionFallingThreshold;

            if (!snmp_varlist_add_variable(&vars, ID_switchThermalActionFallingThreshold,
                                           ILswitchThermalActionFallingThreshold,
                                           ASN_INTEGER,
                                           (u_char *) &(pDynamicData->switchThermalActionFallingThreshold),
                                           sizeof(pDynamicData->switchThermalActionFallingThreshold)))
            {
                snmp_free_varbind(vars);
                return FALSE;
            }

            break;
        }
#endif  /* (SYS_CPNT_THERMAL_DETECT == TRUE) */

#if (SYS_CPNT_MGMT_IP_FLT == TRUE)
        /* swIpFilterRejectTrap(40)
         */
        case TRAP_EVENT_IPFILTER_REJECT_TRAP:
         {
           TRAP_EVENT_IpFilterRejectTrap_T *pDynamicData = & trap_data_p->u.ipFilter_reject_trap;

          /* override the enterprise ID with private MIB */
           memcpy(enterprise, ID_es3626aTrap, len_es3626aTrap * sizeof(oid));
           enterprise_length = len_es3626aTrap;
           trap_type = SNMP_TRAP_ENTERPRISESPECIFIC;
           specific = LEAF_swIpFilterRejectTrap;
           vars = NULL;

           /* binding trapIpFilterRejectMode*/

           if (!snmp_varlist_add_variable( &vars, ID_trapIpFilterRejectMode, len_trapIpFilterRejectMode,
                                           ASN_INTEGER,
                                           (u_char*)&(pDynamicData->mode),
                                           sizeof(pDynamicData->mode)))
           {
               snmp_free_varbind(vars);

               return FALSE;
           }

           /* binding ILtrapIpFilterRejectIp*/

           if (!snmp_varlist_add_variable( &vars, ID_trapIpFilterRejectIp, len_trapIpFilterRejectIp,
                                           ASN_IPADDRESS,
                                           (u_char*)&(pDynamicData->ip),
                                           sizeof(pDynamicData->ip)))
           {
               snmp_free_varbind(vars);

               return FALSE;
           }

            break;
        }

        /* LEAF_swIpFilterInetRejectTrap(111)
         */
        case TRAP_EVENT_IPFILTER_INET_REJECT_TRAP:
        {
            TRAP_EVENT_IpFilterInetRejectTrap_T *pDynamicData = & trap_data_p->u.ipFilterInet_reject_trap;
            UI32_T addr_type;

            /* override the enterprise ID with private MIB
             */
            memcpy(enterprise, ID_es3626aTrap, len_es3626aTrap * sizeof(oid));
            enterprise_length = len_es3626aTrap;
            trap_type = SNMP_TRAP_ENTERPRISESPECIFIC;
            specific = LEAF_swIpFilterInetRejectTrap;
            vars = NULL;

           /* binding trapIpFilterRejectMode
            */
           if (!snmp_varlist_add_variable( &vars, ID_trapIpFilterRejectMode, len_trapIpFilterRejectMode,
                                           ASN_INTEGER,
                                           (u_char*)&(pDynamicData->mode),
                                           sizeof(pDynamicData->mode)))
           {
               snmp_free_varbind(vars);
               return FALSE;
           }

           /* binding trapIpFilterRejectInetAddressType
            */
           addr_type = pDynamicData->inet_ip.type;

           if (!snmp_varlist_add_variable( &vars, ID_trapIpFilterRejectInetAddressType, len_trapIpFilterRejectInetAddressType,
                                           ASN_INTEGER,
                                           (u_char*)&addr_type,
                                           sizeof(addr_type)))
           {
               snmp_free_varbind(vars);
               return FALSE;
           }

           /* binding trapIpFilterRejectInetAddress
            */
           if (!snmp_varlist_add_variable( &vars, ID_trapIpFilterRejectInetAddress, len_trapIpFilterRejectInetAddress,
                                           ASN_OCTET_STR,
                                           (u_char*)(pDynamicData->inet_ip.addr),
                                           (pDynamicData->inet_ip.addrlen)))
           {
               snmp_free_varbind(vars);
               return FALSE;
           }

            break;
        }
#endif  /* #if (SYS_CPNT_MGMT_IP_FLT == TRUE) */

#if (SYS_CPNT_SMTP == TRUE)
        /* swSmtpConnFailureTrap(41)
         */
        case TRAP_EVENT_SMTP_CONN_FAILURE_TRAP:
        {
           UI32_T ILsmtpServerIp;

           TRAP_EVENT_swSmtpConnFailureTrap_T *pDynamicData = & trap_data_p->u.sw_smtp_conn_failure_trap;

           /* override the enterprise ID with private MIB */
           memcpy(enterprise, ID_es3626aTrap, len_es3626aTrap * sizeof(oid));
           enterprise_length = len_es3626aTrap;
           trap_type = SNMP_TRAP_ENTERPRISESPECIFIC;
           specific = LEAF_swSmtpConnFailureTrap;
           vars = NULL;

           /* binding smtpServerIp*/
           memcpy((char*)(ID_smtpServerIp + len_smtpServerIp), (char*)pDynamicData->instance_smtpServerIp, lenIdx_smtpServerIp * sizeof(oid));
           ILsmtpServerIp= len_ifIndex+lenIdx_smtpServerIp;
           if (!snmp_varlist_add_variable( &vars, ID_smtpServerIp, ILsmtpServerIp,
                                           ASN_IPADDRESS,
                                           (u_char*)&(pDynamicData->smtpServerIp),
                                           sizeof(pDynamicData->smtpServerIp)))
           {
               snmp_free_varbind(vars);

               return FALSE;
           }

            break;
        }
#endif  /* (SYS_CPNT_SMTP == TRUE) */

#if (SYS_CPNT_POE == TRUE)
        /* PoE MIB
         */
        case TRAP_EVENT_PETH_PSE_PORT_ON_OFF_TRAP:
        {
           UI32_T ILpethPsePortDetectionStatus;
           TRAP_EVENT_PethPsePortOnOffTrap_T *pDynamicData = & trap_data_p->u.peth_pse_port_on_off_trap;

           /* override the enterprise ID with POE MIB */
           memcpy(enterprise, snmp_mgr_poe_mib_oid, len_snmp_mgr_poe_mib_oid * sizeof(oid));
           enterprise_length = len_snmp_mgr_poe_mib_oid;
           trap_type = SNMP_TRAP_ENTERPRISESPECIFIC;
           specific = 1;
           vars = NULL;

           /* binding pethPsePortDetectionStatus*/
           memcpy((char*)(ID_pethPsePortDetectionStatus + len_pethPsePortDetectionStatus), (char*)pDynamicData->instance_pethPsePortDetectionStatus, lenIdx_pethPsePortDetectionStatus * sizeof(oid));
           ILpethPsePortDetectionStatus= len_pethPsePortDetectionStatus+lenIdx_pethPsePortDetectionStatus;
           if (!snmp_varlist_add_variable( &vars, ID_pethPsePortDetectionStatus, ILpethPsePortDetectionStatus,
                                           ASN_INTEGER,
                                           (u_char*)&(pDynamicData->pethPsePortDetectionStatus),
                                           sizeof(pDynamicData->pethPsePortDetectionStatus)))
           {
               snmp_free_varbind(vars);
               return FALSE;
           }

            break;
        }

        case TRAP_EVENT_PETH_MAIN_POWER_USAGE_ON_TRAP:
        {
           UI32_T ILpethMainPseConsumptionPower;
           TRAP_EVENT_PethMainPowerUsageOnTrap_T *pDynamicData = & trap_data_p->u.peth_main_power_usage_on_trap;

           /* override the enterprise ID with POE MIB */
           memcpy(enterprise, snmp_mgr_poe_mib_oid, len_snmp_mgr_poe_mib_oid * sizeof(oid));
           enterprise_length = len_snmp_mgr_poe_mib_oid;
           trap_type = SNMP_TRAP_ENTERPRISESPECIFIC;
           specific = 2;
           vars = NULL;

           /* binding pethMainPseConsumptionPower*/
           memcpy((char*)(ID_pethMainPseConsumptionPower + len_pethMainPseConsumptionPower), (char*)&(pDynamicData->instance_pethMainPseConsumptionPower), lenIdx_pethMainPseConsumptionPower * sizeof(oid));
           ILpethMainPseConsumptionPower= len_pethMainPseConsumptionPower+lenIdx_pethMainPseConsumptionPower;
           if (!snmp_varlist_add_variable( &vars, ID_pethMainPseConsumptionPower, ILpethMainPseConsumptionPower,
                                           ASN_INTEGER,
                                           (u_char*)&(pDynamicData->pethMainPseConsumptionPower),
                                           sizeof(pDynamicData->pethMainPseConsumptionPower)))
           {
               snmp_free_varbind(vars);
               return FALSE;
           }

            break;
        }

        case TRAP_EVENT_PETH_MAIN_POWER_USAGE_OFF_TRAP:
        {
           UI32_T ILpethMainPseConsumptionPower;
           TRAP_EVENT_PethMainPowerUsageOffTrap_T *pDynamicData = &(trap_data_p->u.peth_main_power_usage_off_trap);

           /* override the enterprise ID with POE MIB */
           memcpy(enterprise, snmp_mgr_poe_mib_oid, len_snmp_mgr_poe_mib_oid * sizeof(oid));
           enterprise_length = len_snmp_mgr_poe_mib_oid;
           trap_type = SNMP_TRAP_ENTERPRISESPECIFIC;
           specific = 3;
           vars = NULL;

           /* binding pethMainPseConsumptionPower*/
           memcpy((char*)(ID_pethMainPseConsumptionPower + len_pethMainPseConsumptionPower), (char*)&(pDynamicData->instance_pethMainPseConsumptionPower), lenIdx_pethMainPseConsumptionPower * sizeof(oid));
           ILpethMainPseConsumptionPower= len_pethMainPseConsumptionPower+lenIdx_pethMainPseConsumptionPower;
           if (!snmp_varlist_add_variable( &vars, ID_pethMainPseConsumptionPower, ILpethMainPseConsumptionPower,
                                           ASN_INTEGER,
                                           (u_char*)&(pDynamicData->pethMainPseConsumptionPower),
                                           sizeof(pDynamicData->pethMainPseConsumptionPower)))
           {
               snmp_free_varbind(vars);
               return FALSE;
           }

            break;
        }
#endif

#if (SYS_CPNT_SNMP_MIB_STYLE == SYS_CPNT_SNMP_MIB_STYLE_32)
        /* 3Com private MIB
         */
        /*2004-12-1 Eric Huang added for 3com*/
        /* QUESTION: "trap_event.h" comments that they are for the
         * 3Com private MIB.  So, why are the following enterprise traps
         * for Accton?  What action generates these traps?
         */
        case TRAP_EVENT_SECURE_ADDRESS_LEARNED:
        {
            TRAP_EVENT_secureAddressLearned_T *pDynamicData = & trap_data_p->u.secure_address_learned;

            /* override the enterprise ID with private MIB */
            memcpy(enterprise, ID_es3626aTrap, len_es3626aTrap * sizeof(oid));
            enterprise_length = len_es3626aTrap;
            trap_type = SNMP_TRAP_ENTERPRISESPECIFIC;
            specific = 71;
            vars = NULL;

            /* binding secureAddrRowStatus */
            {
                UI32_T ILsecureAddrRowStatus;

                memcpy((char*)(ID_secureAddrRowStatus + len_secureAddrRowStatus), (char*)&pDynamicData->instance_secureAddrRowStatus, lenidx_secureAddrRowStatus * sizeof(oid));
                ILsecureAddrRowStatus = len_secureAddrRowStatus + lenidx_secureAddrRowStatus;
                if (!snmp_varlist_add_variable(&vars, ID_secureAddrRowStatus, ILsecureAddrRowStatus,
                                               ASN_INTEGER,
                                               (u_char*)&(pDynamicData->secureAddrRowStatus),
                                               sizeof(pDynamicData->secureAddrRowStatus)))
                {
                    snmp_free_varbind(vars);
                    return FALSE;
                }
            }

            break;
        }

        case TRAP_EVENT_SECURE_VIOLATION2:
        {
            TRAP_EVENT_secureViolation2_T *pDynamicData = & trap_data_p->u.secure_violation2;

            /* override the enterprise ID with private MIB */
            memcpy(enterprise, ID_es3626aTrap, len_es3626aTrap * sizeof(oid));
            enterprise_length = len_es3626aTrap;
            trap_type = SNMP_TRAP_ENTERPRISESPECIFIC;
            specific = 85;
            vars = NULL;

            /* binding secureAddrRowStatus */
            {
                UI32_T ILsecureAddrRowStatus;

                memcpy((char*)(ID_secureAddrRowStatus + len_secureAddrRowStatus), (char*)&pDynamicData->instance_secureAddrRowStatus, lenidx_secureAddrRowStatus * sizeof(oid));
                ILsecureAddrRowStatus = len_secureAddrRowStatus + lenidx_secureAddrRowStatus;
                if (!snmp_varlist_add_variable(&vars, ID_secureAddrRowStatus, ILsecureAddrRowStatus,
                                               ASN_INTEGER,
                                               (u_char*)&(pDynamicData->secureAddrRowStatus),
                                               sizeof(pDynamicData->secureAddrRowStatus)))
                {
                    snmp_free_varbind(vars);
                    return FALSE;
                }
            }

            /* binding rptrPortAdminStatus */
            {
                UI32_T ILifAdminStatus;

                memcpy((char*)(ID_ifAdminStatus + len_ifAdminStatus), (char*)&pDynamicData->instance_adminstatus, 1 * sizeof(oid));
                ILifAdminStatus= len_ifAdminStatus+1;
                if (!snmp_varlist_add_variable( &vars, ID_ifAdminStatus, ILifAdminStatus,
                                                ASN_INTEGER,
                                                (u_char*)&(pDynamicData->rptrPortAdminStatus),
                                                sizeof(pDynamicData->rptrPortAdminStatus)))
                {
                    snmp_free_varbind(vars);

                    return FALSE;
                }
            }

            break;
        }

        case TRAP_EVENT_SECURE_LOGIN_FAILURE:
        {
            TRAP_EVENT_secureLoginFailure_T *pDynamicData = & trap_data_p->u.login_failure;

            /* override the enterprise ID with private MIB */
            memcpy(enterprise, ID_es3626aTrap, len_es3626aTrap * sizeof(oid));
            enterprise_length = len_es3626aTrap;
            trap_type = SNMP_TRAP_ENTERPRISESPECIFIC;
            specific = 91;
            vars = NULL;

            /* binding secureAddrRowStatus */
            {
                UI32_T ILsecureAddrRowStatus;

                memcpy((char*)(ID_secureAddrRowStatus + len_secureAddrRowStatus), (char*)&pDynamicData->instance_secureAddrRowStatus, lenidx_secureAddrRowStatus * sizeof(oid));
                ILsecureAddrRowStatus = len_secureAddrRowStatus + lenidx_secureAddrRowStatus;
                if (!snmp_varlist_add_variable(&vars, ID_secureAddrRowStatus, ILsecureAddrRowStatus,
                                               ASN_INTEGER,
                                               (u_char*)&(pDynamicData->secureAddrRowStatus),
                                               sizeof(pDynamicData->secureAddrRowStatus)))
                {
                    snmp_free_varbind(vars);
                    return FALSE;
                }
            }

            /* binding dot1xAuthSessionUserName */
            {
                UI32_T ILdot1xAuthSessionUserName;

                memcpy((char*)(ID_dot1xAuthSessionUserName + len_dot1xAuthSessionUserName), (char*)&pDynamicData->secureAddrPortIndex, 1 * sizeof(oid));
                ILdot1xAuthSessionUserName = len_secureAddrRowStatus + 1;

                if (!snmp_varlist_add_variable(&vars, ID_dot1xAuthSessionUserName, ILdot1xAuthSessionUserName,
                                               ASN_OCTET_STR,
                                               (u_char*)&(pDynamicData->dot1xAuthSessionUserName),
                                               sizeof(pDynamicData->dot1xAuthSessionUserName)))
                {
                    snmp_free_varbind(vars);
                    return FALSE;
                }
            }

            break;
        }

        case TRAP_EVENT_SECURE_LOGON:
        {
            TRAP_EVENT_secureLogon_T *pDynamicData = & trap_data_p->u.secure_logon;

            /* override the enterprise ID with private MIB */
            memcpy(enterprise, ID_es3626aTrap, len_es3626aTrap * sizeof(oid));
            enterprise_length = len_es3626aTrap;
            trap_type = SNMP_TRAP_ENTERPRISESPECIFIC;
            specific = 93;
            vars = NULL;

            /* binding secureAddrRowStatus */
            {
                UI32_T ILsecureAddrRowStatus;

                memcpy((char*)(ID_secureAddrRowStatus + len_secureAddrRowStatus), (char*)&pDynamicData->instance_secureAddrRowStatus, lenidx_secureAddrRowStatus * sizeof(oid));
                ILsecureAddrRowStatus = len_secureAddrRowStatus + lenidx_secureAddrRowStatus;
                if (!snmp_varlist_add_variable(&vars, ID_secureAddrRowStatus, ILsecureAddrRowStatus,
                                               ASN_INTEGER,
                                               (u_char*)&(pDynamicData->secureAddrRowStatus),
                                               sizeof(pDynamicData->secureAddrRowStatus)))
                {
                    snmp_free_varbind(vars);
                    return FALSE;
                }
            }

            /* binding dot1xAuthSessionUserName */
            {
                UI32_T ILdot1xAuthSessionUserName;

                memcpy((char*)(ID_dot1xAuthSessionUserName + len_dot1xAuthSessionUserName), (char*)&pDynamicData->secureAddrPortIndex, 1 * sizeof(oid));
                ILdot1xAuthSessionUserName = len_secureAddrRowStatus + 1;

                if (!snmp_varlist_add_variable(&vars, ID_dot1xAuthSessionUserName, ILdot1xAuthSessionUserName,
                                               ASN_OCTET_STR,
                                               (u_char*)&(pDynamicData->dot1xAuthSessionUserName),
                                               sizeof(pDynamicData->dot1xAuthSessionUserName)))
                {
                    snmp_free_varbind(vars);
                    return FALSE;
                }
            }

            /* binding dot1xAuthSessionAuthenticMethod */
            {
                UI32_T ILdot1xAuthSessionAuthenticMethod;

                memcpy((char*)(ID_dot1xAuthSessionAuthenticMethod + len_dot1xAuthSessionAuthenticMethod), (char*)&pDynamicData->secureAddrPortIndex, 1 * sizeof(oid));
                ILdot1xAuthSessionAuthenticMethod = len_dot1xAuthSessionAuthenticMethod + 1;

                if (!snmp_varlist_add_variable(&vars, ID_dot1xAuthSessionAuthenticMethod, ILdot1xAuthSessionAuthenticMethod,
                                               ASN_INTEGER,
                                               (u_char*)&(pDynamicData->dot1xAuthSessionAuthenticMethod),
                                               sizeof(pDynamicData->dot1xAuthSessionAuthenticMethod)))
                {
                    snmp_free_varbind(vars);
                    return FALSE;
                }
            }

            /* binding securePortVlanMembershipList */
            if (!snmp_varlist_add_variable(&vars, ID_securePortVlanMembershipList, len_securePortVlanMembershipList,
                                           ASN_OCTET_STR,
                                           (u_char*)&(pDynamicData->securePortVlanMembershipList),
                                           sizeof(pDynamicData->securePortVlanMembershipList)))
            {
                snmp_free_varbind(vars);
                return FALSE;
            }

            break;
        }

        case TRAP_EVENT_SECURE_LOGOFF:
        {
            TRAP_EVENT_secureLogoff_T *pDynamicData = & trap_data_p->u.secure_logoff;

            /* override the enterprise ID with private MIB */
            memcpy(enterprise, ID_es3626aTrap, len_es3626aTrap * sizeof(oid));
            enterprise_length = len_es3626aTrap;
            trap_type = SNMP_TRAP_ENTERPRISESPECIFIC;
            specific = 94;
            vars = NULL;

            /* binding secureAddrRowStatus */
            {
                UI32_T ILsecureAddrRowStatus;

                memcpy((char*)(ID_secureAddrRowStatus + len_secureAddrRowStatus), (char*)&pDynamicData->instance_secureAddrRowStatus, lenidx_secureAddrRowStatus * sizeof(oid));
                ILsecureAddrRowStatus = len_secureAddrRowStatus + lenidx_secureAddrRowStatus;
                if (!snmp_varlist_add_variable(&vars, ID_secureAddrRowStatus, ILsecureAddrRowStatus,
                                               ASN_INTEGER,
                                               (u_char*)&(pDynamicData->secureAddrRowStatus),
                                               sizeof(pDynamicData->secureAddrRowStatus)))
                {
                    snmp_free_varbind(vars);
                    return FALSE;
                }
            }

            /* binding dot1xAuthSessionUserName */
            {
                UI32_T ILdot1xAuthSessionUserName;

                memcpy((char*)(ID_dot1xAuthSessionUserName + len_dot1xAuthSessionUserName), (char*)&pDynamicData->secureAddrPortIndex, 1 * sizeof(oid));
                ILdot1xAuthSessionUserName = len_secureAddrRowStatus + 1;

                if (!snmp_varlist_add_variable(&vars, ID_dot1xAuthSessionUserName, ILdot1xAuthSessionUserName,
                                               ASN_OCTET_STR,
                                               (u_char*)&(pDynamicData->dot1xAuthSessionUserName),
                                               sizeof(pDynamicData->dot1xAuthSessionUserName)))
                {
                    snmp_free_varbind(vars);
                    return FALSE;
                }
            }

            /* binding dot1xAuthSessionTerminateCause */
            {
                UI32_T ILdot1xAuthSessionTerminateCause;

                memcpy((char*)(ID_dot1xAuthSessionTerminateCause + len_dot1xAuthSessionTerminateCause), (char*)&pDynamicData->secureAddrPortIndex, 1 * sizeof(oid));
                ILdot1xAuthSessionTerminateCause = len_dot1xAuthSessionTerminateCause + 1;

                if (!snmp_varlist_add_variable(&vars, ID_dot1xAuthSessionTerminateCause, ILdot1xAuthSessionTerminateCause,
                                               ASN_INTEGER,
                                               (u_char*)&(pDynamicData->dot1xAuthSessionTerminateCause),
                                               sizeof(pDynamicData->dot1xAuthSessionTerminateCause)))
                {
                    snmp_free_varbind(vars);
                    return FALSE;
                }
            }

            /* binding securePortVlanMembershipList */
            if (!snmp_varlist_add_variable(&vars, ID_securePortVlanMembershipList, len_securePortVlanMembershipList,
                                           ASN_OCTET_STR,
                                           (u_char*)&(pDynamicData->securePortVlanMembershipList),
                                           sizeof(pDynamicData->securePortVlanMembershipList)))
            {
                snmp_free_varbind(vars);
                return FALSE;
            }

            break;
        }
#endif  /* (SYS_CPNT_SNMP_MIB_STYLE == SYS_CPNT_SNMP_MIB_STYLE_32) */
/* End of 3Com traps which use the Accton enterprise ID for an unknown reason. */

#if (SYS_CPNT_SNMP_MIB_STYLE == SYS_CPNT_SNMP_MIB_STYLE_32)
        /* 3Com private MIB
         */
        case TRAP_EVENT_TESTTRAP:
            memcpy(enterprise, ID_testTrap, 8* sizeof(oid));
            enterprise_length = 8;
            trap_type = SNMP_TRAP_ENTERPRISESPECIFIC;
            specific = 64;
            /* this trap have no variables binding*/
            vars = NULL;
            break;

        case TRAP_EVENT_IP_FORWARDING_CHANGED_BY_MSTPTRAP:
            memcpy(enterprise, ID_swIpForwardingChangedByMstpTrap, 8* sizeof(oid));
            enterprise_length = 8;
            trap_type = SNMP_TRAP_ENTERPRISESPECIFIC;
            specific = 65;
            /* this trap have no variables binding*/
            vars = NULL;
            break;
#endif  /* (SYS_CPNT_SNMP_MIB_STYLE == SYS_CPNT_SNMP_MIB_STYLE_32) */

#if (SYS_CPNT_MODULE_WITH_CPU == TRUE)
        /* swModuleInsertionNotification(60)
         */
        case TRAP_EVENT_MODULE_INSERTION:
        {
            TRAP_EVENT_moduleInsertion_T *pDynamicData = & trap_data_p->u.module_insertion;

            memcpy(enterprise, ID_es3626aTrap, len_es3626aTrap * sizeof(oid));
            enterprise_length = len_es3626aTrap;
            trap_type = SNMP_TRAP_ENTERPRISESPECIFIC;
            specific = LEAF_swModuleInsertionNotification;
            vars = NULL;

            {
                UI32_T ILswModuleOpCodeVer;

                memcpy((char*)(ID_swModuleOpCodeVer + len_swModuleOpCodeVer), (char*)&pDynamicData->instance_swModuleOpCodeVer, lenIdx_swModuleOpCodeVer * sizeof(oid));
                ILswModuleOpCodeVer = len_swModuleOpCodeVer + lenIdx_swModuleOpCodeVer;
                if (!snmp_varlist_add_variable(&vars, ID_swModuleOpCodeVer, ILswModuleOpCodeVer,
                                               ASN_OCTET_STR,
                                               (u_char*)&(pDynamicData->swModuleOpCodeVer),
                                               sizeof(pDynamicData->swModuleOpCodeVer)))
                {
                    snmp_free_varbind(vars);
                    return FALSE;
                }
            }

            break;
        }

        /* swModuleRemovalNotification(61)
         */
        case TRAP_EVENT_MODULE_REMOVAL:
        {
            TRAP_EVENT_moduleRemoval_T *pDynamicData = & trap_data_p->u.module_removal;

            memcpy(enterprise, ID_es3626aTrap, len_es3626aTrap * sizeof(oid));
            enterprise_length = len_es3626aTrap;
            trap_type = SNMP_TRAP_ENTERPRISESPECIFIC;
            specific = LEAF_swModuleRemovalNotification;
            vars = NULL;
            {
                UI32_T ILswModuleOpCodeVer;

                memcpy((char*)(ID_swModuleOpCodeVer + len_swModuleOpCodeVer), (char*)&pDynamicData->instance_swModuleOpCodeVer, lenIdx_swModuleOpCodeVer * sizeof(oid));
                ILswModuleOpCodeVer = len_swModuleOpCodeVer + lenIdx_swModuleOpCodeVer;
                if (!snmp_varlist_add_variable(&vars, ID_swModuleOpCodeVer, ILswModuleOpCodeVer,
                                               ASN_OCTET_STR,
                                               (u_char*)&(pDynamicData->swModuleOpCodeVer),
                                               sizeof(pDynamicData->swModuleOpCodeVer)))
                {
                    snmp_free_varbind(vars);
                    return FALSE;
                }
            }

            break;
        }
#endif

        /* swMainBoardVerMismatchNotification(56)
         */
        case TRAP_EVENT_MAIN_BOARD_VER_MISMATCH:
        {
            TRAP_EVENT_mainBoardVerMismatch_T *pDynamicData = & trap_data_p->u.main_board_ver_mismatch;

            memcpy(enterprise, ID_es3626aTrap, len_es3626aTrap * sizeof(oid));
            enterprise_length = len_es3626aTrap;
            trap_type = SNMP_TRAP_ENTERPRISESPECIFIC;
            specific = LEAF_swMainBoardVerMismatchNotification;
            vars = NULL;
            {
                UI32_T ILswOpCodeVer1;

                memcpy((char*)(ID_swOpCodeVer + len_swOpCodeVer), (char*)&pDynamicData->instance_swOpCodeVerMaster, lenIdx_swOpCodeVer * sizeof(oid));
                ILswOpCodeVer1 = len_swOpCodeVer + lenIdx_swOpCodeVer;
                if (!snmp_varlist_add_variable(&vars, ID_swOpCodeVer, ILswOpCodeVer1,
                                               ASN_OCTET_STR,
                                               (u_char*)&(pDynamicData->swOpCodeVerMaster),
                                               sizeof(pDynamicData->swOpCodeVerMaster)))
                {
                    snmp_free_varbind(vars);
                    return FALSE;
                }
            }
            {
                UI32_T ILswOpCodeVer2;

                memcpy((char*)(ID_swOpCodeVer + len_swOpCodeVer), (char*)&pDynamicData->instance_swOpCodeVerSlave, lenIdx_swOpCodeVer * sizeof(oid));
                ILswOpCodeVer2 = len_swOpCodeVer + lenIdx_swOpCodeVer;
                if (!snmp_varlist_add_variable(&vars, ID_swOpCodeVer, ILswOpCodeVer2,
                                               ASN_OCTET_STR,
                                               (u_char*)&(pDynamicData->swOpCodeVerSlave),
                                               sizeof(pDynamicData->swOpCodeVerSlave)))
                {
                    snmp_free_varbind(vars);
                    return FALSE;
                }
            }

            break;
        }

#if (SYS_CPNT_MODULE_WITH_CPU == TRUE)
        /* swModuleVerMismatchNotification(57)
         */
        case TRAP_EVENT_MODULE_VER_MISMATCH:
        {
            TRAP_EVENT_moduleVerMismatch_T *pDynamicData = & trap_data_p->u.module_ver_mismatch;

            memcpy(enterprise, ID_es3626aTrap, len_es3626aTrap * sizeof(oid));
            enterprise_length = len_es3626aTrap;
            trap_type = SNMP_TRAP_ENTERPRISESPECIFIC;
            specific = LEAF_swModuleVerMismatchNotification;
            vars = NULL;
            {
                UI32_T ILswExpectedModuleOpCodeVer;

                memcpy((char*)(ID_swExpectedModuleOpCodeVer + len_swExpectedModuleOpCodeVer), (char*)&pDynamicData->instance_swModuleExpectedOpCodeVer, lenIdx_swExpectedModuleOpCodeVer * sizeof(oid));
                ILswExpectedModuleOpCodeVer = len_swExpectedModuleOpCodeVer + lenIdx_swExpectedModuleOpCodeVer;
                if (!snmp_varlist_add_variable(&vars, ID_swExpectedModuleOpCodeVer, ILswExpectedModuleOpCodeVer,
                                               ASN_OCTET_STR,
                                               (u_char*)&(pDynamicData->swModuleExpectedOpCodeVer),
                                               sizeof(pDynamicData->swModuleExpectedOpCodeVer)))
                {
                    snmp_free_varbind(vars);
                    return FALSE;
                }
            }
            {
                UI32_T ILswModuleOpCodeVer;

                memcpy((char*)(ID_swModuleOpCodeVer + len_swModuleOpCodeVer), (char*)&pDynamicData->instance_swModuleOpCodeVer, lenIdx_swModuleOpCodeVer * sizeof(oid));
                ILswModuleOpCodeVer = len_swModuleOpCodeVer + lenIdx_swModuleOpCodeVer;
                if (!snmp_varlist_add_variable(&vars, ID_swModuleOpCodeVer, ILswModuleOpCodeVer,
                                               ASN_OCTET_STR,
                                               (u_char*)&(pDynamicData->swModuleOpCodeVer),
                                               sizeof(pDynamicData->swModuleOpCodeVer)))
                {
                    snmp_free_varbind(vars);
                    return FALSE;
                }
            }

            break;
        }
#endif

        /* LEAF_tcnTrap(63)
         */
        case TRAP_EVENT_TCN:
        {
            TRAP_EVENT_tcn_T *pDynamicData = & trap_data_p->u.tcn;

            /* override the enterprise ID with private MIB */
            memcpy(enterprise, ID_es3626aTrap, len_es3626aTrap * sizeof(oid));
            enterprise_length = len_es3626aTrap;
            trap_type = SNMP_TRAP_ENTERPRISESPECIFIC;
            specific = 63;
            vars = NULL;

            /* binding trapVarTcnReason */
            if (!snmp_varlist_add_variable(&vars, ID_trapVarTcnReason, len_trapVarTcnReason,
                                           ASN_INTEGER,
                                           (u_char*)&(pDynamicData->tcnReason),
                                           sizeof(pDynamicData->tcnReason)))
            {
                snmp_free_varbind(vars);
                return FALSE;
            }

            break;
        }

#if (SYS_CPNT_3COM_LOOPBACK_TEST == TRUE)
       /* LEAF_swLoopbackTestFailureTrap(39)
        */
       case TRAP_EVENT_LOOPBACK_TEST_FAILURE_TRAP:
       {
            TRAP_EVENT_LoopBackFailureTrap_T *pDynamicData = & trap_data_p->u.loopback_failure_trap;

            memcpy(enterprise, ID_es3626aTrap, len_es3626aTrap* sizeof(oid));
            enterprise_length =len_es3626aTrap;
            trap_type = SNMP_TRAP_ENTERPRISESPECIFIC;
            specific = LEAF_swLoopbackTestFailureTrap;
            vars = NULL;

            if (!snmp_varlist_add_variable( &vars, ID_switchLoopbackTestFailurePorts, len_switchLoopbackTestFailurePorts,
                                          ASN_OCTET_STR,
                                           (u_char*)&(pDynamicData->ports),
                                           sizeof(pDynamicData->ports)))
           {
               snmp_free_varbind(vars);

               return FALSE;
           }

           break;
        }
        #endif

#if (SYS_CPNT_LLDP == TRUE)
        /* LLDP MIB
         */
        case TRAP_EVENT_LLDP_REM_TABLES_CHANGED:
        {
            TRAP_EVENT_lldpRemTablesChange_T *pDynamicData = & trap_data_p->u.lldp_rem_table_changed;

            memcpy(enterprise, snmp_mgr_lldp_mib_oid, len_snmp_mgr_lldp_mib_oid * sizeof(oid));
            enterprise_length = len_snmp_mgr_lldp_mib_oid;
            trap_type = SNMP_TRAP_ENTERPRISESPECIFIC;
            specific = 1;
            vars = NULL;
            if (!snmp_varlist_add_variable( &vars, ID_lldpStatsRemTablesInserts, len_lldpStatsRemTablesInserts,
                                          ASN_INTEGER,
                                           (u_char*)&(pDynamicData->lldpStatsRemTablesInserts),
                                           sizeof(pDynamicData->lldpStatsRemTablesInserts)))
            {
                snmp_free_varbind(vars);

                return FALSE;
            }

            if (!snmp_varlist_add_variable( &vars, ID_lldpStatsRemTablesDeletes, len_lldpStatsRemTablesDeletes,
                                          ASN_INTEGER,
                                           (u_char*)&(pDynamicData->lldpStatsRemTablesDeletes),
                                           sizeof(pDynamicData->lldpStatsRemTablesDeletes)))
            {
                snmp_free_varbind(vars);

                return FALSE;
            }

            if (!snmp_varlist_add_variable( &vars, ID_lldpStatsRemTablesDrops, len_lldpStatsRemTablesDrops,
                                          ASN_INTEGER,
                                           (u_char*)&(pDynamicData->lldpStatsRemTablesDrops),
                                           sizeof(pDynamicData->lldpStatsRemTablesDrops)))
            {
                snmp_free_varbind(vars);

                return FALSE;
            }

            if (!snmp_varlist_add_variable( &vars, ID_lldpStatsRemTablesAgeouts, len_lldpStatsRemTablesAgeouts,
                                          ASN_INTEGER,
                                           (u_char*)&(pDynamicData->lldpStatsRemTablesAgeouts),
                                           sizeof(pDynamicData->lldpStatsRemTablesAgeouts)))
            {
                snmp_free_varbind(vars);

                return FALSE;
            }

            break;
        }
#endif

#if (SYS_CPNT_LLDP_MED == TRUE)
        /* LLDP-MED MIB
         */
        case TRAP_EVENT_LLDP_MED_TOPOLOGY_CHANGE_DETECTED:
        {
            UI32_T  ILlldpRemChassisIdSubtype;
            UI32_T  ILlldpRemChassisId;
            UI32_T  ILlldpMedRemDeviceClass;
            TRAP_EVENT_lldpMedTopologyChange_T *pDynamicData = & trap_data_p->u.lldp_med_topology_change;

            memcpy(enterprise, snmp_mgr_lldp_med_mib_oid, len_snmp_mgr_lldp_med_mib_oid * sizeof(oid));
            enterprise_length = len_snmp_mgr_lldp_med_mib_oid;
            trap_type = SNMP_TRAP_ENTERPRISESPECIFIC;
            specific = 1;
            vars = NULL;

            memcpy((char*)(ID_lldpRemChassisIdSubtype + len_lldpRemChassisIdSubtype), (char*)&pDynamicData->instance_lldpRemChassisIdSubtype, 3 * sizeof(oid));
            ILlldpRemChassisIdSubtype = len_lldpRemChassisIdSubtype+3;
            if (!snmp_varlist_add_variable( &vars, ID_lldpRemChassisIdSubtype, ILlldpRemChassisIdSubtype,
                                           ASN_INTEGER,
                                           (u_char*)&(pDynamicData->lldpRemChassisIdSubtype),
                                           sizeof(pDynamicData->lldpRemChassisIdSubtype)))
            {
                snmp_free_varbind(vars);
                return FALSE;
            }

            memcpy((char*)(ID_lldpRemChassisId + len_lldpRemChassisId), (char*)&pDynamicData->instance_lldpRemChassisId, 3 * sizeof(oid));
            ILlldpRemChassisId = len_lldpRemChassisId+3;
            if (!snmp_varlist_add_variable( &vars, ID_lldpRemChassisId, ILlldpRemChassisId,
                                           ASN_OCTET_STR,
                                           (u_char*)&(pDynamicData->lldpRemChassisId[1]),
                                           pDynamicData->lldpRemChassisId[0])) /* lldpRemChassisId[0] store the size */
            {
                snmp_free_varbind(vars);
                return FALSE;
            }

            memcpy((char*)(ID_lldpMedRemDeviceClass + len_lldpMedRemDeviceClass), (char*)&pDynamicData->instance_lldpMedRemDeviceClass, 3 * sizeof(oid));
            ILlldpMedRemDeviceClass = len_lldpMedRemDeviceClass+3;
            if (!snmp_varlist_add_variable( &vars, ID_lldpMedRemDeviceClass, ILlldpMedRemDeviceClass,
                                           ASN_INTEGER,
                                           (u_char*)&(pDynamicData->lldpMedRemDeviceClass),
                                           sizeof(pDynamicData->lldpMedRemDeviceClass)))
            {
                snmp_free_varbind(vars);
                return FALSE;
            }

            break;
        }
#endif

#if (SYS_CPNT_EFM_OAM == TRUE)
        /* OAM MIB
         */
        case TRAP_EVENT_DOT3_OAM_THRESHOLD:
        {
            UI32_T  ILdot3OamEventLogTimestamp;
            UI32_T  ILdot3OamEventLogOui;
            UI32_T  ILdot3OamEventLogType;
            UI32_T  ILdot3OamEventLogLocation;
            UI32_T  ILdot3OamEventLogWindowHi;
            UI32_T  ILdot3OamEventLogWindowLo;
            UI32_T  ILdot3OamEventLogThresholdHi;
            UI32_T  ILdot3OamEventLogThresholdLo;
            UI32_T  ILdot3OamEventLogEventTotal;
            UI32_T  ILdot3OamEventLogValue;
            UI32_T  ILdot3OamEventLogRunningTotal;
            TRAP_EVENT_dot3OamThreshold_T *pDynamicData = & trap_data_p->u.dot3_oam_threshold;

            /* override the enterprise ID with OAM threshold */
            memcpy(enterprise, snmp_mgr_dot3_oam_mib_oid, len_snmp_mgr_dot3_oam_mib_oid * sizeof(oid));
            enterprise_length = len_snmp_mgr_dot3_oam_mib_oid;
            trap_type = SNMP_TRAP_ENTERPRISESPECIFIC;
            specific = 1;
            vars = NULL;

            /* binding dot3OamEventLogTimestamp*/
            ID_dot3_oam_event_timestamp[len_dot3_oam_event_timestamp] = pDynamicData->instance_dot3OamEventLogEntry[0];
            ID_dot3_oam_event_timestamp[len_dot3_oam_event_timestamp + 1] = pDynamicData->instance_dot3OamEventLogEntry[1];
            ILdot3OamEventLogTimestamp = len_dot3_oam_event_timestamp + lenidx_dot3_oam_event_timestamp;
            if (!snmp_varlist_add_variable( &vars, ID_dot3_oam_event_timestamp, ILdot3OamEventLogTimestamp,
                                           ASN_TIMETICKS,
                                           (u_char*)&(pDynamicData->dot3OamEventLogTimestamp),
                                           sizeof(pDynamicData->dot3OamEventLogTimestamp)))
            {
                snmp_free_varbind(vars);
                return FALSE;
            }
            /* binding dot3OamEventLogOui*/
            ID_dot3_oam_event_oui[len_dot3_oam_event_oui] = pDynamicData->instance_dot3OamEventLogEntry[0];
            ID_dot3_oam_event_oui[len_dot3_oam_event_oui + 1] = pDynamicData->instance_dot3OamEventLogEntry[1];
            ILdot3OamEventLogOui = len_dot3_oam_event_oui + lenidx_dot3_oam_event_oui;
            if (!snmp_varlist_add_variable( &vars, ID_dot3_oam_event_oui, ILdot3OamEventLogOui,
                                           ASN_OCTET_STR,
                                           (u_char*)&(pDynamicData->dot3OamEventLogOui),
                                           sizeof(pDynamicData->dot3OamEventLogOui)))
            {
                snmp_free_varbind(vars);
                return FALSE;
            }
            /* binding dot3OamEventLogType*/
            ID_dot3_oam_event_type[len_dot3_oam_event_type] = pDynamicData->instance_dot3OamEventLogEntry[0];
            ID_dot3_oam_event_type[len_dot3_oam_event_type + 1] = pDynamicData->instance_dot3OamEventLogEntry[1];
            ILdot3OamEventLogType = len_dot3_oam_event_type + lenidx_dot3_oam_event_type;
            if (!snmp_varlist_add_variable( &vars, ID_dot3_oam_event_type, ILdot3OamEventLogType,
                                           ASN_INTEGER,
                                           (u_char*)&(pDynamicData->dot3OamEventLogType),
                                           sizeof(pDynamicData->dot3OamEventLogType)))
            {
                snmp_free_varbind(vars);
                return FALSE;
            }
            /* binding dot3OamEventLogLocation*/
            ID_dot3_oam_event_location[len_dot3_oam_event_location] = pDynamicData->instance_dot3OamEventLogEntry[0];
            ID_dot3_oam_event_location[len_dot3_oam_event_location + 1] = pDynamicData->instance_dot3OamEventLogEntry[1];
            ILdot3OamEventLogLocation = len_dot3_oam_event_location + lenidx_dot3_oam_event_location;
            if (!snmp_varlist_add_variable( &vars, ID_dot3_oam_event_location, ILdot3OamEventLogLocation,
                                           ASN_INTEGER,
                                           (u_char*)&(pDynamicData->dot3OamEventLogLocation),
                                           sizeof(pDynamicData->dot3OamEventLogLocation)))
            {
                snmp_free_varbind(vars);
                return FALSE;
            }
            /* binding dot3OamEventLogWindowHi */
            ID_dot3_oam_event_window_hi[len_dot3_oam_event_window_hi] = pDynamicData->instance_dot3OamEventLogEntry[0];
            ID_dot3_oam_event_window_hi[len_dot3_oam_event_window_hi + 1] = pDynamicData->instance_dot3OamEventLogEntry[1];
            ILdot3OamEventLogWindowHi= len_dot3_oam_event_window_hi + lenidx_dot3_oam_event_window_hi;
            if (!snmp_varlist_add_variable( &vars, ID_dot3_oam_event_window_hi, ILdot3OamEventLogWindowHi,
                                           ASN_UNSIGNED,
                                           (u_char*)&(pDynamicData->dot3OamEventLogWindowHi),
                                           sizeof(pDynamicData->dot3OamEventLogWindowHi)))
            {
                snmp_free_varbind(vars);
                return FALSE;
            }
            /* binding dot3OamEventLogWindowLo */
            ID_dot3_oam_event_window_low[len_dot3_oam_event_window_low] = pDynamicData->instance_dot3OamEventLogEntry[0];
            ID_dot3_oam_event_window_low[len_dot3_oam_event_window_low + 1] = pDynamicData->instance_dot3OamEventLogEntry[1];
            ILdot3OamEventLogWindowLo= len_dot3_oam_event_window_low + lenidx_dot3_oam_event_window_low;
            if (!snmp_varlist_add_variable( &vars, ID_dot3_oam_event_window_low, ILdot3OamEventLogWindowLo,
                                           ASN_UNSIGNED,
                                           (u_char*)&(pDynamicData->dot3OamEventLogWindowLo),
                                           sizeof(pDynamicData->dot3OamEventLogWindowLo)))
            {
                snmp_free_varbind(vars);
                return FALSE;
            }
            /* binding dot3OamEventLogThresholdHi */
            ID_dot3_oam_event_threshold_hi[len_dot3_oam_event_threshold_hi] = pDynamicData->instance_dot3OamEventLogEntry[0];
            ID_dot3_oam_event_threshold_hi[len_dot3_oam_event_threshold_hi + 1] = pDynamicData->instance_dot3OamEventLogEntry[1];
            ILdot3OamEventLogThresholdHi= len_dot3_oam_event_threshold_hi + lenidx_dot3_oam_event_threshold_hi;
            if (!snmp_varlist_add_variable( &vars, ID_dot3_oam_event_threshold_hi, ILdot3OamEventLogThresholdHi,
                                           ASN_UNSIGNED,
                                           (u_char*)&(pDynamicData->dot3OamEventLogThresholdHi),
                                           sizeof(pDynamicData->dot3OamEventLogThresholdHi)))
            {
                snmp_free_varbind(vars);
                return FALSE;
            }
            /* binding dot3OamEventLogThresholdLo */
            ID_dot3_oam_event_threshold_low[len_dot3_oam_event_threshold_low] = pDynamicData->instance_dot3OamEventLogEntry[0];
            ID_dot3_oam_event_threshold_low[len_dot3_oam_event_threshold_low + 1] = pDynamicData->instance_dot3OamEventLogEntry[1];
            ILdot3OamEventLogThresholdLo= len_dot3_oam_event_threshold_low + lenidx_dot3_oam_event_threshold_low;
            if (!snmp_varlist_add_variable( &vars, ID_dot3_oam_event_threshold_low, ILdot3OamEventLogThresholdLo,
                                           ASN_UNSIGNED,
                                           (u_char*)&(pDynamicData->dot3OamEventLogThresholdLo),
                                           sizeof(pDynamicData->dot3OamEventLogThresholdLo)))
            {
                snmp_free_varbind(vars);
                return FALSE;
            }
            /* binding dot3OamEventLogValue */
            ID_dot3_oam_event_value[len_dot3_oam_event_value] = pDynamicData->instance_dot3OamEventLogEntry[0];
            ID_dot3_oam_event_value[len_dot3_oam_event_value + 1] = pDynamicData->instance_dot3OamEventLogEntry[1];
            ILdot3OamEventLogValue= len_dot3_oam_event_value + lenidx_dot3_oam_event_value;
            if (!snmp_varlist_add_variable( &vars, ID_dot3_oam_event_value, ILdot3OamEventLogValue,
                                           ASN_COUNTER64,
                                           (u_char*)&(pDynamicData->dot3OamEventLogValue),
                                           sizeof(pDynamicData->dot3OamEventLogValue)))
            {
                snmp_free_varbind(vars);
                return FALSE;
            }
            /* binding dot3OamEventLogRunningTotal */
            ID_dot3_oam_event_running_total[len_dot3_oam_event_running_total] = pDynamicData->instance_dot3OamEventLogEntry[0];
            ID_dot3_oam_event_running_total[len_dot3_oam_event_running_total + 1] = pDynamicData->instance_dot3OamEventLogEntry[1];
            ILdot3OamEventLogRunningTotal= len_dot3_oam_event_running_total + lenidx_dot3_oam_event_running_total;
            if (!snmp_varlist_add_variable( &vars, ID_dot3_oam_event_running_total, ILdot3OamEventLogRunningTotal,
                                           ASN_COUNTER64,
                                           (u_char*)&(pDynamicData->dot3OamEventLogRunningTotal),
                                           sizeof(pDynamicData->dot3OamEventLogRunningTotal)))
            {
                snmp_free_varbind(vars);
                return FALSE;
            }
            /* binding dot3OamEventLogEventTotal */
            ID_dot3_oam_event_event_total[len_dot3_oam_event_event_total] = pDynamicData->instance_dot3OamEventLogEntry[0];
            ID_dot3_oam_event_event_total[len_dot3_oam_event_event_total + 1] = pDynamicData->instance_dot3OamEventLogEntry[1];
            ILdot3OamEventLogEventTotal= len_dot3_oam_event_event_total + lenidx_dot3_oam_event_event_total;
            if (!snmp_varlist_add_variable( &vars, ID_dot3_oam_event_event_total, ILdot3OamEventLogEventTotal,
                                           ASN_UNSIGNED,
                                           (u_char*)&(pDynamicData->dot3OamEventLogEventTotal),
                                           sizeof(pDynamicData->dot3OamEventLogEventTotal)))
            {
                snmp_free_varbind(vars);
                return FALSE;
            }
            break;
        }

        case TRAP_EVENT_DOT3_OAM_NON_THRESHOLD:
        {
            UI32_T  ILdot3OamEventLogTimestamp;
            UI32_T  ILdot3OamEventLogOui;
            UI32_T  ILdot3OamEventLogType;
            UI32_T  ILdot3OamEventLogLocation;
            UI32_T  ILdot3OamEventLogEventTotal;
            TRAP_EVENT_dot3OamNonThreshold_T *pDynamicData = & trap_data_p->u.dot3_oam_nonthreshold;

            /* override the enterprise ID with OAM threshold */
            memcpy(enterprise, snmp_mgr_dot3_oam_mib_oid, len_snmp_mgr_dot3_oam_mib_oid * sizeof(oid));
            enterprise_length = len_snmp_mgr_dot3_oam_mib_oid;
            trap_type = SNMP_TRAP_ENTERPRISESPECIFIC;
            specific = 2;
            vars = NULL;

            /* binding dot3OamEventLogTimestamp*/
            ID_dot3_oam_event_timestamp[len_dot3_oam_event_timestamp] = pDynamicData->instance_dot3OamEventLogEntry[0];
            ID_dot3_oam_event_timestamp[len_dot3_oam_event_timestamp + 1] = pDynamicData->instance_dot3OamEventLogEntry[1];
            ILdot3OamEventLogTimestamp = len_dot3_oam_event_timestamp + lenidx_dot3_oam_event_timestamp;
            if (!snmp_varlist_add_variable( &vars, ID_dot3_oam_event_timestamp, ILdot3OamEventLogTimestamp,
                                           ASN_TIMETICKS,
                                           (u_char*)&(pDynamicData->dot3OamEventLogTimestamp),
                                           sizeof(pDynamicData->dot3OamEventLogTimestamp)))
            {
                snmp_free_varbind(vars);
                return FALSE;
            }
            /* binding dot3OamEventLogOui*/
            ID_dot3_oam_event_oui[len_dot3_oam_event_oui] = pDynamicData->instance_dot3OamEventLogEntry[0];
            ID_dot3_oam_event_oui[len_dot3_oam_event_oui + 1] = pDynamicData->instance_dot3OamEventLogEntry[1];
            ILdot3OamEventLogOui = len_dot3_oam_event_oui + lenidx_dot3_oam_event_oui;
            if (!snmp_varlist_add_variable( &vars, ID_dot3_oam_event_oui, ILdot3OamEventLogOui,
                                           ASN_OCTET_STR,
                                           (u_char*)&(pDynamicData->dot3OamEventLogOui),
                                           sizeof(pDynamicData->dot3OamEventLogOui)))
            {
                snmp_free_varbind(vars);
                return FALSE;
            }
            /* binding dot3OamEventLogType*/
            ID_dot3_oam_event_type[len_dot3_oam_event_type] = pDynamicData->instance_dot3OamEventLogEntry[0];
            ID_dot3_oam_event_type[len_dot3_oam_event_type + 1] = pDynamicData->instance_dot3OamEventLogEntry[1];
            ILdot3OamEventLogType = len_dot3_oam_event_type + lenidx_dot3_oam_event_type;
            if (!snmp_varlist_add_variable( &vars, ID_dot3_oam_event_type, ILdot3OamEventLogType,
                                           ASN_INTEGER,
                                           (u_char*)&(pDynamicData->dot3OamEventLogType),
                                           sizeof(pDynamicData->dot3OamEventLogType)))
            {
                snmp_free_varbind(vars);
                return FALSE;
            }
            /* binding dot3OamEventLogLocation*/
            ID_dot3_oam_event_location[len_dot3_oam_event_location] = pDynamicData->instance_dot3OamEventLogEntry[0];
            ID_dot3_oam_event_location[len_dot3_oam_event_location + 1] = pDynamicData->instance_dot3OamEventLogEntry[1];
            ILdot3OamEventLogLocation = len_dot3_oam_event_location + lenidx_dot3_oam_event_location;
            if (!snmp_varlist_add_variable( &vars, ID_dot3_oam_event_location, ILdot3OamEventLogLocation,
                                           ASN_INTEGER,
                                           (u_char*)&(pDynamicData->dot3OamEventLogLocation),
                                           sizeof(pDynamicData->dot3OamEventLogLocation)))
            {
                snmp_free_varbind(vars);
                return FALSE;
            }
            /* binding dot3OamEventLogEventTotal */
            ID_dot3_oam_event_event_total[len_dot3_oam_event_event_total] = pDynamicData->instance_dot3OamEventLogEntry[0];
            ID_dot3_oam_event_event_total[len_dot3_oam_event_event_total + 1] = pDynamicData->instance_dot3OamEventLogEntry[1];
            ILdot3OamEventLogEventTotal= len_dot3_oam_event_event_total + lenidx_dot3_oam_event_event_total;
            if (!snmp_varlist_add_variable( &vars, ID_dot3_oam_event_event_total, ILdot3OamEventLogEventTotal,
                                           ASN_UNSIGNED,
                                           (u_char*)&(pDynamicData->dot3OamEventLogEventTotal),
                                           sizeof(pDynamicData->dot3OamEventLogEventTotal)))
            {
                snmp_free_varbind(vars);
                return FALSE;
            }
            break;
        }
#endif /* #if (SYS_CPNT_EFM_OAM == TRUE) */

#if (SYS_CPNT_ATC_STORM == TRUE)
        /* swAtcBcastStormAlarmFireTrap(70)
         */
        case TRAP_EVENT_BCAST_STORM_ALARM_FIRE:
        {
            UI32_T ILatcBcastStormIfIndex;
            UI32_T ILatcBcastStormSampleType;
            UI32_T ILatcBcastStormCurrentTrafficRate;
            UI32_T ILatcBcastStormAlarmThreshold;

            TRAP_EVENT_BcastStormAlarmFire_T *pDynamicData = & trap_data_p->u.bstorm_alarm_fire;

            /* override the enterprise ID with private MIB */
            memcpy(enterprise, ID_es3626aTrap, len_es3626aTrap * sizeof(oid));
            enterprise_length = len_es3626aTrap;
            trap_type = SNMP_TRAP_ENTERPRISESPECIFIC;
            specific = 70;
            vars = NULL;


            /* binding ifIndex*/
            memcpy((char*)(ID_atcBcastStormIfIndex + len_atcBcastStormIfIndex), (char*)&pDynamicData->IfIndex, lenIdx_atcBcastStormIfIndex * sizeof(oid));
                ILatcBcastStormIfIndex= len_atcBcastStormIfIndex+lenIdx_atcBcastStormIfIndex;

            if (!snmp_varlist_add_variable( &vars, ID_atcBcastStormIfIndex, ILatcBcastStormIfIndex,
                                           ASN_INTEGER,
                                           (u_char*)&(pDynamicData->IfIndex),
                                           sizeof(pDynamicData->IfIndex)))
            {
               snmp_free_varbind(vars);
               return FALSE;
            }

            /* binding SampleType*/
            memcpy((char*)(ID_atcBcastStormSampleType + len_atcBcastStormSampleType), (char*)&pDynamicData->IfIndex, lenIdx_atcBcastStormSampleType * sizeof(oid));
                       ILatcBcastStormSampleType= len_atcBcastStormSampleType+lenIdx_atcBcastStormSampleType;
            if (!snmp_varlist_add_variable( &vars, ID_atcBcastStormSampleType, ILatcBcastStormSampleType,
                                            ASN_INTEGER,
                                            (u_char*)&(pDynamicData->SampleType),
                                            sizeof(pDynamicData->SampleType)))
            {
                snmp_free_varbind(vars);
                return FALSE;
            }

            /* binding CurrentTrafficRate*/
            memcpy((char*)(ID_atcBcastStormCurrentTrafficRate + len_atcBcastStormCurrentTrafficRate), (char*)&pDynamicData->IfIndex, lenIdx_atcBcastStormCurrentTrafficRate * sizeof(oid));
            ILatcBcastStormCurrentTrafficRate= len_atcBcastStormCurrentTrafficRate+lenIdx_atcBcastStormCurrentTrafficRate;
            if (!snmp_varlist_add_variable( &vars, ID_atcBcastStormCurrentTrafficRate, ILatcBcastStormCurrentTrafficRate,
                                            ASN_INTEGER,
                                            (u_char*)&(pDynamicData->CurrentTrafficRate),
                                            sizeof(pDynamicData->CurrentTrafficRate)))
            {
                snmp_free_varbind(vars);
                return FALSE;
            }

            /* binding AlarmThreshold*/
            memcpy((char*)(ID_atcBcastStormAlarmThreshold + len_atcBcastStormAlarmThreshold), (char*)&pDynamicData->IfIndex, lenIdx_atcBcastStormAlarmThreshold * sizeof(oid));
            ILatcBcastStormAlarmThreshold= len_atcBcastStormAlarmThreshold+lenIdx_atcBcastStormAlarmThreshold;
            if (!snmp_varlist_add_variable( &vars, ID_atcBcastStormAlarmThreshold, ILatcBcastStormAlarmThreshold,
                                            ASN_INTEGER,
                                            (u_char*)&(pDynamicData->AlarmThreshold),
                                            sizeof(pDynamicData->AlarmThreshold)))
            {
                snmp_free_varbind(vars);
                return FALSE;
            }

            break;
        }

        /* swAtcBcastStormAlarmClearTrap(71)
         */
        case TRAP_EVENT_BCAST_STORM_ALARM_CLEAR:
        {
            UI32_T ILatcBcastStormIfIndex;
            UI32_T ILatcBcastStormSampleType;
            UI32_T ILatcBcastStormCurrentTrafficRate;
            UI32_T ILatcBcastStormClearThreshold;

            TRAP_EVENT_BcastStormAlarmClear_T *pDynamicData = & trap_data_p->u.bstorm_alarm_clear;

            /* override the enterprise ID with private MIB */
            memcpy(enterprise, ID_es3626aTrap, len_es3626aTrap * sizeof(oid));
            enterprise_length = len_es3626aTrap;
            trap_type = SNMP_TRAP_ENTERPRISESPECIFIC;
            specific = LEAF_swAtcBcastStormAlarmClearTrap;
            vars = NULL;

            /* binding ifIndex*/
            memcpy((char*)(ID_atcBcastStormIfIndex + len_atcBcastStormIfIndex), (char*)&pDynamicData->IfIndex, lenIdx_atcBcastStormIfIndex * sizeof(oid));
            ILatcBcastStormIfIndex= len_atcBcastStormIfIndex+lenIdx_atcBcastStormIfIndex;
            if (!snmp_varlist_add_variable( &vars, ID_atcBcastStormIfIndex, ILatcBcastStormIfIndex,
                                            ASN_INTEGER,
                                            (u_char*)&(pDynamicData->IfIndex),
                                            sizeof(pDynamicData->IfIndex)))
            {
                snmp_free_varbind(vars);
                return FALSE;
            }

            /* binding SampleType*/
            memcpy((char*)(ID_atcBcastStormSampleType + len_atcBcastStormSampleType), (char*)&pDynamicData->IfIndex, lenIdx_atcBcastStormSampleType * sizeof(oid));
            ILatcBcastStormSampleType= len_atcBcastStormSampleType+lenIdx_atcBcastStormSampleType;
            if (!snmp_varlist_add_variable( &vars, ID_atcBcastStormSampleType, ILatcBcastStormSampleType,
                                            ASN_INTEGER,
                                            (u_char*)&(pDynamicData->SampleType),
                                            sizeof(pDynamicData->SampleType)))
            {
                snmp_free_varbind(vars);
                return FALSE;
            }

            /* binding CurrentTrafficRate*/
            memcpy((char*)(ID_atcBcastStormCurrentTrafficRate + len_atcBcastStormCurrentTrafficRate), (char*)&pDynamicData->IfIndex, lenIdx_atcBcastStormCurrentTrafficRate * sizeof(oid));
            ILatcBcastStormCurrentTrafficRate= len_atcBcastStormCurrentTrafficRate+lenIdx_atcBcastStormCurrentTrafficRate;
            if (!snmp_varlist_add_variable( &vars, ID_atcBcastStormCurrentTrafficRate, ILatcBcastStormCurrentTrafficRate,
                                            ASN_INTEGER,
                                            (u_char*)&(pDynamicData->CurrentTrafficRate),
                                            sizeof(pDynamicData->CurrentTrafficRate)))
            {
                snmp_free_varbind(vars);
                return FALSE;
            }

            /* binding ClearThreshold*/
            memcpy((char*)(ID_atcBcastStormClearThreshold + len_atcBcastStormClearThreshold), (char*)&pDynamicData->IfIndex, lenIdx_atcBcastStormClearThreshold * sizeof(oid));
            ILatcBcastStormClearThreshold= len_atcBcastStormClearThreshold+lenIdx_atcBcastStormClearThreshold;
            if (!snmp_varlist_add_variable( &vars, ID_atcBcastStormClearThreshold, ILatcBcastStormClearThreshold,
                                            ASN_INTEGER,
                                            (u_char*)&(pDynamicData->ClearThreshold),
                                            sizeof(pDynamicData->ClearThreshold)))
            {
                snmp_free_varbind(vars);
                return FALSE;
            }

            break;
        }

        /* swAtcBcastStormTcApplyTrap(72)
         */
        case TRAP_EVENT_BCAST_STORM_TC_APPLY:
        {
              UI32_T ILatcBcastStormIfIndex;
              UI32_T ILatcBcastStormSampleType;
              UI32_T ILatcBcastStormCurrentTrafficRate;
              UI32_T ILatcBcastStormAlarmThreshold;
              UI32_T ILatcBcastStormTcAction;

              TRAP_EVENT_BcastStormTcApply_T *pDynamicData = & trap_data_p->u.bstorm_tc_apply;

            /* override the enterprise ID with private MIB */
            memcpy(enterprise, ID_es3626aTrap, len_es3626aTrap * sizeof(oid));
            enterprise_length = len_es3626aTrap;
            trap_type = SNMP_TRAP_ENTERPRISESPECIFIC;
            specific = LEAF_swAtcBcastStormTcApplyTrap;
            vars = NULL;


            /* binding ifIndex*/
            memcpy((char*)(ID_atcBcastStormIfIndex + len_atcBcastStormIfIndex), (char*)&pDynamicData->IfIndex, lenIdx_atcBcastStormIfIndex * sizeof(oid));
         ILatcBcastStormIfIndex= len_atcBcastStormIfIndex+lenIdx_atcBcastStormIfIndex;
           if (!snmp_varlist_add_variable( &vars, ID_atcBcastStormIfIndex, ILatcBcastStormIfIndex,
                                           ASN_INTEGER,
                                           (u_char*)&(pDynamicData->IfIndex),
                                           sizeof(pDynamicData->IfIndex)))
           {
               snmp_free_varbind(vars);
               return FALSE;
           }

           /* binding SampleType*/
              memcpy((char*)(ID_atcBcastStormSampleType + len_atcBcastStormSampleType), (char*)&pDynamicData->IfIndex, lenIdx_atcBcastStormSampleType * sizeof(oid));
           ILatcBcastStormSampleType= len_atcBcastStormSampleType+lenIdx_atcBcastStormSampleType;
           if (!snmp_varlist_add_variable( &vars, ID_atcBcastStormSampleType, ILatcBcastStormSampleType,
                                           ASN_INTEGER,
                                           (u_char*)&(pDynamicData->SampleType),
                                           sizeof(pDynamicData->SampleType)))
           {
               snmp_free_varbind(vars);
               return FALSE;
           }


           /* binding CurrentTrafficRate*/
              memcpy((char*)(ID_atcBcastStormCurrentTrafficRate + len_atcBcastStormCurrentTrafficRate), (char*)&pDynamicData->IfIndex, lenIdx_atcBcastStormCurrentTrafficRate * sizeof(oid));
           ILatcBcastStormCurrentTrafficRate= len_atcBcastStormCurrentTrafficRate+lenIdx_atcBcastStormCurrentTrafficRate;
           if (!snmp_varlist_add_variable( &vars, ID_atcBcastStormCurrentTrafficRate, ILatcBcastStormCurrentTrafficRate,
                                           ASN_INTEGER,
                                           (u_char*)&(pDynamicData->CurrentTrafficRate),
                                           sizeof(pDynamicData->CurrentTrafficRate)))
           {
               snmp_free_varbind(vars);
               return FALSE;
           }

           /* binding AlarmThreshold*/
              memcpy((char*)(ID_atcBcastStormAlarmThreshold + len_atcBcastStormAlarmThreshold), (char*)&pDynamicData->IfIndex, lenIdx_atcBcastStormAlarmThreshold * sizeof(oid));
           ILatcBcastStormAlarmThreshold= len_atcBcastStormAlarmThreshold+lenIdx_atcBcastStormAlarmThreshold;
           if (!snmp_varlist_add_variable( &vars, ID_atcBcastStormAlarmThreshold, ILatcBcastStormAlarmThreshold,
                                           ASN_INTEGER,
                                           (u_char*)&(pDynamicData->AlarmThreshold),
                                           sizeof(pDynamicData->AlarmThreshold)))
           {
               snmp_free_varbind(vars);
               return FALSE;
           }

           /* binding TcAction*/
              memcpy((char*)(ID_atcBcastStormTcAction + len_atcBcastStormTcAction), (char*)&pDynamicData->IfIndex, lenIdx_atcBcastStormTcAction * sizeof(oid));
           ILatcBcastStormTcAction= len_atcBcastStormTcAction+lenIdx_atcBcastStormTcAction;


           if (!snmp_varlist_add_variable( &vars, ID_atcBcastStormTcAction, ILatcBcastStormTcAction,
                                           ASN_INTEGER,
                                           (u_char*)&(pDynamicData->TcAction),
                                           sizeof(pDynamicData->TcAction)))
           {
               snmp_free_varbind(vars);
               return FALSE;
           }


            /* binding BcastStormTcApplytime*/
           if (!snmp_varlist_add_variable( &vars, ID_atcBcastStormTcApplyTime, len_atcBcastStormTcApplyTime,
                                           ASN_INTEGER,
                                           (u_char*)&(pDynamicData->TcApplyTime),
                                           sizeof(pDynamicData->TcApplyTime)))
           {
               snmp_free_varbind(vars);
               return FALSE;
           }

           break;
        }

        /* swAtcBcastStormTcReleaseTrap(73)
         */
        case TRAP_EVENT_BCAST_STORM_TC_RELEASE:
        {
              UI32_T ILatcBcastStormIfIndex;
              UI32_T ILatcBcastStormSampleType;
              UI32_T ILatcBcastStormCurrentTrafficRate;
              UI32_T ILatcBcastStormClearThreshold;

              TRAP_EVENT_BcastStormTcRelease_T *pDynamicData = & trap_data_p->u.bstorm_tc_release;

            /* override the enterprise ID with private MIB */
            memcpy(enterprise, ID_es3626aTrap, len_es3626aTrap * sizeof(oid));
            enterprise_length = len_es3626aTrap;
            trap_type = SNMP_TRAP_ENTERPRISESPECIFIC;
            specific = LEAF_swAtcBcastStormTcReleaseTrap;
            vars = NULL;

            /* binding ifIndex*/
            memcpy((char*)(ID_atcBcastStormIfIndex + len_atcBcastStormIfIndex), (char*)&pDynamicData->IfIndex, lenIdx_atcBcastStormIfIndex * sizeof(oid));
            ILatcBcastStormIfIndex= len_atcBcastStormIfIndex+lenIdx_atcBcastStormIfIndex;
           if (!snmp_varlist_add_variable( &vars, ID_atcBcastStormIfIndex, ILatcBcastStormIfIndex,
                                           ASN_INTEGER,
                                           (u_char*)&(pDynamicData->IfIndex),
                                           sizeof(pDynamicData->IfIndex)))
           {
               snmp_free_varbind(vars);
               return FALSE;
           }

           /* binding SampleType*/
              memcpy((char*)(ID_atcBcastStormSampleType + len_atcBcastStormSampleType), (char*)&pDynamicData->IfIndex, lenIdx_atcBcastStormSampleType * sizeof(oid));
           ILatcBcastStormSampleType= len_atcBcastStormSampleType+lenIdx_atcBcastStormSampleType;
           if (!snmp_varlist_add_variable( &vars, ID_atcBcastStormSampleType, ILatcBcastStormSampleType,
                                           ASN_INTEGER,
                                           (u_char*)&(pDynamicData->SampleType),
                                           sizeof(pDynamicData->SampleType)))
           {
               snmp_free_varbind(vars);
               return FALSE;
           }


           /* binding CurrentTrafficRate*/
              memcpy((char*)(ID_atcBcastStormCurrentTrafficRate + len_atcBcastStormCurrentTrafficRate), (char*)&pDynamicData->IfIndex, lenIdx_atcBcastStormCurrentTrafficRate * sizeof(oid));
           ILatcBcastStormCurrentTrafficRate= len_atcBcastStormCurrentTrafficRate+lenIdx_atcBcastStormCurrentTrafficRate;
           if (!snmp_varlist_add_variable( &vars, ID_atcBcastStormCurrentTrafficRate, ILatcBcastStormCurrentTrafficRate,
                                           ASN_INTEGER,
                                           (u_char*)&(pDynamicData->CurrentTrafficRate),
                                           sizeof(pDynamicData->CurrentTrafficRate)))
           {
               snmp_free_varbind(vars);
               return FALSE;
           }

            /* binding ClearThreshold*/
              memcpy((char*)(ID_atcBcastStormClearThreshold + len_atcBcastStormClearThreshold), (char*)&pDynamicData->IfIndex, lenIdx_atcBcastStormClearThreshold * sizeof(oid));
           ILatcBcastStormClearThreshold= len_atcBcastStormClearThreshold+lenIdx_atcBcastStormClearThreshold;
           if (!snmp_varlist_add_variable( &vars, ID_atcBcastStormClearThreshold, ILatcBcastStormClearThreshold,
                                           ASN_INTEGER,
                                           (u_char*)&(pDynamicData->ClearThreshold),
                                           sizeof(pDynamicData->ClearThreshold)))
           {
               snmp_free_varbind(vars);
               return FALSE;
           }

        /* binding BcastStormTcReleaseTime*/

           if (!snmp_varlist_add_variable( &vars, ID_atcBcastStormTcReleaseTime, len_atcBcastStormTcReleaseTime,
                                           ASN_INTEGER,
                                           (u_char*)&(pDynamicData->TcReleaseTime),
                                           sizeof(pDynamicData->TcReleaseTime)))
           {
               snmp_free_varbind(vars);
               return FALSE;
           }

           break;
        }

        /* swAtcMcastStormAlarmFireTrap(74)
         */
        case TRAP_EVENT_MCAST_STORM_ALARM_FIRE:
        {
              UI32_T ILatcMcastStormIfIndex;
              UI32_T ILatcMcastStormSampleType;
              UI32_T ILatcMcastStormCurrentTrafficRate;
              UI32_T ILatcMcastStormAlarmThreshold;

              TRAP_EVENT_McastStormAlarmFire_T *pDynamicData = & trap_data_p->u.mstorm_alarm_fire;

             /* override the enterprise ID with private MIB */
             memcpy(enterprise, ID_es3626aTrap, len_es3626aTrap * sizeof(oid));
             enterprise_length = len_es3626aTrap;
             trap_type = SNMP_TRAP_ENTERPRISESPECIFIC;
             specific = LEAF_swAtcMcastStormAlarmFireTrap;
             vars = NULL;

             /* binding ifIndex*/
              memcpy((char*)(ID_atcMcastStormIfIndex + len_atcMcastStormIfIndex), (char*)&pDynamicData->IfIndex, lenIdx_atcMcastStormIfIndex * sizeof(oid));
           ILatcMcastStormIfIndex= len_atcBcastStormIfIndex+lenIdx_atcMcastStormIfIndex;
           if (!snmp_varlist_add_variable( &vars, ID_atcMcastStormIfIndex, ILatcMcastStormIfIndex,
                                           ASN_INTEGER,
                                           (u_char*)&(pDynamicData->IfIndex),
                                           sizeof(pDynamicData->IfIndex)))
           {
               snmp_free_varbind(vars);
               return FALSE;
           }

           /* binding SampleType*/
              memcpy((char*)(ID_atcMcastStormSampleType + len_atcMcastStormSampleType), (char*)&pDynamicData->IfIndex, lenIdx_atcMcastStormSampleType * sizeof(oid));
           ILatcMcastStormSampleType= len_atcMcastStormSampleType+lenIdx_atcMcastStormSampleType;
           if (!snmp_varlist_add_variable( &vars, ID_atcMcastStormSampleType, ILatcMcastStormSampleType,
                                           ASN_INTEGER,
                                           (u_char*)&(pDynamicData->SampleType),
                                           sizeof(pDynamicData->SampleType)))
           {
               snmp_free_varbind(vars);
               return FALSE;
           }


           /* binding CurrentTrafficRate*/
              memcpy((char*)(ID_atcMcastStormCurrentTrafficRate + len_atcMcastStormCurrentTrafficRate), (char*)&pDynamicData->IfIndex, lenIdx_atcMcastStormCurrentTrafficRate * sizeof(oid));
           ILatcMcastStormCurrentTrafficRate= len_atcMcastStormCurrentTrafficRate+lenIdx_atcMcastStormCurrentTrafficRate;
           if (!snmp_varlist_add_variable( &vars, ID_atcMcastStormCurrentTrafficRate, ILatcMcastStormCurrentTrafficRate,
                                           ASN_INTEGER,
                                           (u_char*)&(pDynamicData->CurrentTrafficRate),
                                           sizeof(pDynamicData->CurrentTrafficRate)))
           {
               snmp_free_varbind(vars);
               return FALSE;
           }

           /* binding AlarmThreshold*/
              memcpy((char*)(ID_atcMcastStormAlarmThreshold + len_atcMcastStormAlarmThreshold), (char*)&pDynamicData->IfIndex, lenIdx_atcMcastStormAlarmThreshold * sizeof(oid));
           ILatcMcastStormAlarmThreshold= len_atcMcastStormAlarmThreshold+lenIdx_atcMcastStormAlarmThreshold;
           if (!snmp_varlist_add_variable( &vars, ID_atcMcastStormAlarmThreshold, ILatcMcastStormAlarmThreshold,
                                           ASN_INTEGER,
                                           (u_char*)&(pDynamicData->AlarmThreshold),
                                           sizeof(pDynamicData->AlarmThreshold)))
           {
               snmp_free_varbind(vars);
               return FALSE;
           }

           break;
        }

       /* swAtcMcastStormAlarmClearTrap(75)
        */
        case TRAP_EVENT_MCAST_STORM_ALARM_CLEAR:
        {
             UI32_T ILatcMcastStormIfIndex;
             UI32_T ILatcMcastStormSampleType;
             UI32_T ILatcMcastStormCurrentTrafficRate;
             UI32_T ILatcMcastStormClearThreshold;

             TRAP_EVENT_McastStormAlarmClear_T *pDynamicData = & trap_data_p->u.mstorm_alarm_clear;

            /* override the enterprise ID with private MIB */
            memcpy(enterprise, ID_es3626aTrap, len_es3626aTrap * sizeof(oid));
            enterprise_length = len_es3626aTrap;
            trap_type = SNMP_TRAP_ENTERPRISESPECIFIC;
            specific = LEAF_swAtcMcastStormAlarmClearTrap;
            vars = NULL;

            /* binding ifIndex*/
            memcpy((char*)(ID_atcMcastStormIfIndex + len_atcMcastStormIfIndex), (char*)&pDynamicData->IfIndex, lenIdx_atcMcastStormIfIndex * sizeof(oid));
            ILatcMcastStormIfIndex= len_atcMcastStormIfIndex+lenIdx_atcMcastStormIfIndex;
            if (!snmp_varlist_add_variable( &vars, ID_atcMcastStormIfIndex, ILatcMcastStormIfIndex,
                                            ASN_INTEGER,
                                            (u_char*)&(pDynamicData->IfIndex),
                                            sizeof(pDynamicData->IfIndex)))
            {
                snmp_free_varbind(vars);
                return FALSE;
            }

            /* binding SampleType*/
            memcpy((char*)(ID_atcMcastStormSampleType + len_atcMcastStormSampleType), (char*)&pDynamicData->IfIndex, lenIdx_atcMcastStormSampleType * sizeof(oid));
            ILatcMcastStormSampleType= len_atcMcastStormSampleType+lenIdx_atcMcastStormSampleType;
            if (!snmp_varlist_add_variable( &vars, ID_atcMcastStormSampleType, ILatcMcastStormSampleType,
                                            ASN_INTEGER,
                                            (u_char*)&(pDynamicData->SampleType),
                                            sizeof(pDynamicData->SampleType)))
            {
                snmp_free_varbind(vars);
                return FALSE;
            }

            /* binding CurrentTrafficRate*/
            memcpy((char*)(ID_atcMcastStormCurrentTrafficRate + len_atcMcastStormCurrentTrafficRate), (char*)&pDynamicData->IfIndex, lenIdx_atcMcastStormCurrentTrafficRate * sizeof(oid));
            ILatcMcastStormCurrentTrafficRate= len_atcMcastStormCurrentTrafficRate+lenIdx_atcMcastStormCurrentTrafficRate;
            if (!snmp_varlist_add_variable( &vars, ID_atcMcastStormCurrentTrafficRate, ILatcMcastStormCurrentTrafficRate,
                                            ASN_INTEGER,
                                            (u_char*)&(pDynamicData->CurrentTrafficRate),
                                            sizeof(pDynamicData->CurrentTrafficRate)))
            {
                snmp_free_varbind(vars);
                return FALSE;
            }

            /* binding ClearThreshold*/
            memcpy((char*)(ID_atcMcastStormClearThreshold + len_atcMcastStormClearThreshold), (char*)&pDynamicData->IfIndex, lenIdx_atcMcastStormClearThreshold * sizeof(oid));
            ILatcMcastStormClearThreshold= len_atcMcastStormClearThreshold+lenIdx_atcMcastStormClearThreshold;
            if (!snmp_varlist_add_variable( &vars, ID_atcMcastStormClearThreshold, ILatcMcastStormClearThreshold,
                                            ASN_INTEGER,
                                            (u_char*)&(pDynamicData->ClearThreshold),
                                            sizeof(pDynamicData->ClearThreshold)))
            {
                snmp_free_varbind(vars);
                return FALSE;
            }

            break;
        }

        /* swAtcMcastStormTcApplyTrap(76)
         */
        case TRAP_EVENT_MCAST_STORM_TC_APPLY:
        {
            UI32_T ILatcMcastStormIfIndex;
            UI32_T ILatcMcastStormSampleType;
            UI32_T ILatcMcastStormCurrentTrafficRate;
            UI32_T ILatcMcastStormAlarmThreshold;
            UI32_T ILatcMcastStormTcAction;

            TRAP_EVENT_McastStormTcApply_T *pDynamicData = & trap_data_p->u.mstorm_tc_apply;

            /* override the enterprise ID with private MIB */
            memcpy(enterprise, ID_es3626aTrap, len_es3626aTrap * sizeof(oid));
            enterprise_length = len_es3626aTrap;
            trap_type = SNMP_TRAP_ENTERPRISESPECIFIC;
            specific = LEAF_swAtcMcastStormTcApplyTrap;
            vars = NULL;

            /* binding ifIndex*/
            memcpy((char*)(ID_atcMcastStormIfIndex + len_atcMcastStormIfIndex), (char*)&pDynamicData->IfIndex, lenIdx_atcMcastStormIfIndex * sizeof(oid));
            ILatcMcastStormIfIndex= len_atcBcastStormIfIndex+lenIdx_atcMcastStormIfIndex;
            if (!snmp_varlist_add_variable( &vars, ID_atcMcastStormIfIndex, ILatcMcastStormIfIndex,
                                            ASN_INTEGER,
                                            (u_char*)&(pDynamicData->IfIndex),
                                            sizeof(pDynamicData->IfIndex)))
            {
                snmp_free_varbind(vars);
                return FALSE;
            }

            /* binding SampleType*/
            memcpy((char*)(ID_atcMcastStormSampleType + len_atcMcastStormSampleType), (char*)&pDynamicData->IfIndex, lenIdx_atcMcastStormSampleType * sizeof(oid));
            ILatcMcastStormSampleType= len_atcMcastStormSampleType+lenIdx_atcMcastStormSampleType;
            if (!snmp_varlist_add_variable( &vars, ID_atcMcastStormSampleType, ILatcMcastStormSampleType,
                                            ASN_INTEGER,
                                            (u_char*)&(pDynamicData->SampleType),
                                            sizeof(pDynamicData->SampleType)))
            {
                snmp_free_varbind(vars);
                return FALSE;
            }

            /* binding CurrentTrafficRate*/
            memcpy((char*)(ID_atcMcastStormCurrentTrafficRate + len_atcMcastStormCurrentTrafficRate), (char*)&pDynamicData->IfIndex, lenIdx_atcMcastStormCurrentTrafficRate * sizeof(oid));
            ILatcMcastStormCurrentTrafficRate= len_atcMcastStormCurrentTrafficRate+lenIdx_atcMcastStormCurrentTrafficRate;
            if (!snmp_varlist_add_variable( &vars, ID_atcMcastStormCurrentTrafficRate, ILatcMcastStormCurrentTrafficRate,
                                            ASN_INTEGER,
                                            (u_char*)&(pDynamicData->CurrentTrafficRate),
                                            sizeof(pDynamicData->CurrentTrafficRate)))
            {
                snmp_free_varbind(vars);
                return FALSE;
            }

            /* binding AlarmThreshold*/
            memcpy((char*)(ID_atcMcastStormAlarmThreshold + len_atcMcastStormAlarmThreshold), (char*)&pDynamicData->IfIndex, lenIdx_atcMcastStormAlarmThreshold * sizeof(oid));
            ILatcMcastStormAlarmThreshold= len_atcMcastStormAlarmThreshold+lenIdx_atcMcastStormAlarmThreshold;
            if (!snmp_varlist_add_variable( &vars, ID_atcMcastStormAlarmThreshold, ILatcMcastStormAlarmThreshold,
                                            ASN_INTEGER,
                                            (u_char*)&(pDynamicData->AlarmThreshold),
                                            sizeof(pDynamicData->AlarmThreshold)))
            {
                snmp_free_varbind(vars);
                return FALSE;
            }

            /* binding TcAction*/
            memcpy((char*)(ID_atcMcastStormTcAction + len_atcMcastStormTcAction), (char*)&pDynamicData->IfIndex, lenIdx_atcMcastStormTcAction * sizeof(oid));
            ILatcMcastStormTcAction= len_atcMcastStormTcAction+lenIdx_atcMcastStormTcAction;
            if (!snmp_varlist_add_variable( &vars, ID_atcMcastStormTcAction, ILatcMcastStormTcAction,
                                            ASN_INTEGER,
                                            (u_char*)&(pDynamicData->TcAction),
                                            sizeof(pDynamicData->TcAction)))
            {
                snmp_free_varbind(vars);
                return FALSE;
            }

            /* binding McastStormTcApplytime*/
            if (!snmp_varlist_add_variable( &vars, ID_atcMcastStormTcApplyTime, len_atcMcastStormTcApplyTime,
                                            ASN_INTEGER,
                                            (u_char*)&(pDynamicData->TcApplyTime),
                                            sizeof(pDynamicData->TcApplyTime)))
            {
                snmp_free_varbind(vars);
                return FALSE;
            }

            break;
        }

        /* swAtcMcastStormTcReleaseTrap(77)
         */
        case TRAP_EVENT_MCAST_STORM_TC_RELEASE:
        {
            UI32_T ILatcMcastStormIfIndex;
            UI32_T ILatcMcastStormSampleType;
            UI32_T ILatcMcastStormCurrentTrafficRate;
            UI32_T ILatcMcastStormClearThreshold;

            TRAP_EVENT_McastStormTcRelease_T *pDynamicData = & trap_data_p->u.mstorm_tc_release;

            /* override the enterprise ID with private MIB */
            memcpy(enterprise, ID_es3626aTrap, len_es3626aTrap * sizeof(oid));
            enterprise_length = len_es3626aTrap;
            trap_type = SNMP_TRAP_ENTERPRISESPECIFIC;
            specific = LEAF_swAtcMcastStormTcReleaseTrap;
            vars = NULL;

            /* binding ifIndex*/
            memcpy((char*)(ID_atcMcastStormIfIndex + len_atcMcastStormIfIndex), (char*)&pDynamicData->IfIndex, lenIdx_atcMcastStormIfIndex * sizeof(oid));
            ILatcMcastStormIfIndex= len_atcMcastStormIfIndex+lenIdx_atcMcastStormIfIndex;
            if (!snmp_varlist_add_variable( &vars, ID_atcMcastStormIfIndex, ILatcMcastStormIfIndex,
                                            ASN_INTEGER,
                                            (u_char*)&(pDynamicData->IfIndex),
                                            sizeof(pDynamicData->IfIndex)))
            {
                snmp_free_varbind(vars);
                return FALSE;
            }

            /* binding SampleType*/
            memcpy((char*)(ID_atcMcastStormSampleType + len_atcMcastStormSampleType), (char*)&pDynamicData->IfIndex, lenIdx_atcMcastStormSampleType * sizeof(oid));
            ILatcMcastStormSampleType= len_atcMcastStormSampleType+lenIdx_atcMcastStormSampleType;
            if (!snmp_varlist_add_variable( &vars, ID_atcMcastStormSampleType, ILatcMcastStormSampleType,
                                            ASN_INTEGER,
                                            (u_char*)&(pDynamicData->SampleType),
                                            sizeof(pDynamicData->SampleType)))
            {
                snmp_free_varbind(vars);
                return FALSE;
            }

            /* binding CurrentTrafficRate*/
            memcpy((char*)(ID_atcMcastStormCurrentTrafficRate + len_atcMcastStormCurrentTrafficRate), (char*)&pDynamicData->IfIndex, lenIdx_atcMcastStormCurrentTrafficRate* sizeof(oid));
            ILatcMcastStormCurrentTrafficRate= len_atcMcastStormCurrentTrafficRate+lenIdx_atcMcastStormCurrentTrafficRate;
            if (!snmp_varlist_add_variable( &vars, ID_atcMcastStormCurrentTrafficRate, ILatcMcastStormCurrentTrafficRate,
                                            ASN_INTEGER,
                                            (u_char*)&(pDynamicData->CurrentTrafficRate),
                                            sizeof(pDynamicData->CurrentTrafficRate)))
            {
                snmp_free_varbind(vars);
                return FALSE;
            }

            /* binding ClearThreshold*/
            memcpy((char*)(ID_atcMcastStormClearThreshold + len_atcMcastStormClearThreshold), (char*)&pDynamicData->IfIndex, lenIdx_atcMcastStormClearThreshold * sizeof(oid));
            ILatcMcastStormClearThreshold= len_atcMcastStormClearThreshold+lenIdx_atcMcastStormClearThreshold;
            if (!snmp_varlist_add_variable( &vars, ID_atcMcastStormClearThreshold, ILatcMcastStormClearThreshold,
                                            ASN_INTEGER,
                                            (u_char*)&(pDynamicData->ClearThreshold),
                                            sizeof(pDynamicData->ClearThreshold)))
            {
                snmp_free_varbind(vars);
                return FALSE;
            }

            /* binding McastStormTcReleaseTime*/
            if (!snmp_varlist_add_variable( &vars, ID_atcMcastStormTcReleaseTime, len_atcMcastStormTcReleaseTime,
                                            ASN_INTEGER,
                                            (u_char*)&(pDynamicData->TcReleaseTime),
                                            sizeof(pDynamicData->TcReleaseTime)))
            {
                snmp_free_varbind(vars);
                return FALSE;
            }

            break;
        }
#endif  /* (SYS_CPNT_ATC_STORM == TRUE) */

#if (SYS_CPNT_CFM == TRUE)
        /* dot1agCfmMepUpTrap(97)
         */
        case TRAP_EVENT_CFM_MEP_UP:
        {
            UI32_T ILdot1agCfmMepIdentifier;
            TRAP_EVENT_CfmMepUp_T *pDynamicData = & trap_data_p->u.cfm_mep_up;

            /* override the enterprise ID with private MIB */
            memcpy(enterprise, ID_es3626aTrap, len_es3626aTrap * sizeof(oid));
            enterprise_length = len_es3626aTrap;
            trap_type = SNMP_TRAP_ENTERPRISESPECIFIC;
            specific = LEAF_dot1agCfmMepUpTrap;
            vars = NULL;

           /* binding dot1agCfmMepIdentifier */
           memcpy((char*)(ID_dot1agCfmMepIdentifier + len_dot1agCfmMepIdentifier), (char*)&pDynamicData->instance_dot1agCfmMepIdentifier, lenIdx_dot1agCfmMepIdentifier * sizeof(oid));
           ILdot1agCfmMepIdentifier= len_dot1agCfmMepIdentifier+lenIdx_dot1agCfmMepIdentifier;
           if (!snmp_varlist_add_variable( &vars, ID_dot1agCfmMepIdentifier, ILdot1agCfmMepIdentifier,
                                           ASN_INTEGER,
                                           (u_char*)&(pDynamicData->dot1agCfmMepDbRMepIdentifier),
                                           sizeof(pDynamicData->dot1agCfmMepDbRMepIdentifier)))
           {
               snmp_free_varbind(vars);
               return FALSE;
           }

           break;
        }

        /* dot1agCfmMepDownTrap(98)
         */
        case TRAP_EVENT_CFM_MEP_DOWN:
        {
            UI32_T ILdot1agCfmMepIdentifier;
            TRAP_EVENT_CfmMepDown_T *pDynamicData = & trap_data_p->u.cfm_mep_down;

            /* override the enterprise ID with private MIB */
            memcpy(enterprise, ID_es3626aTrap, len_es3626aTrap * sizeof(oid));
            enterprise_length = len_es3626aTrap;
            trap_type = SNMP_TRAP_ENTERPRISESPECIFIC;
            specific = LEAF_dot1agCfmMepDownTrap;
            vars = NULL;

           /* binding dot1agCfmMepIdentifier */
           memcpy((char*)(ID_dot1agCfmMepIdentifier + len_dot1agCfmMepIdentifier), (char*)&pDynamicData->instance_dot1agCfmMepIdentifier, lenIdx_dot1agCfmMepIdentifier * sizeof(oid));
           ILdot1agCfmMepIdentifier= len_dot1agCfmMepIdentifier+lenIdx_dot1agCfmMepIdentifier;
           if (!snmp_varlist_add_variable( &vars, ID_dot1agCfmMepIdentifier, ILdot1agCfmMepIdentifier,
                                           ASN_INTEGER,
                                           (u_char*)&(pDynamicData->dot1agCfmMepDbRMepIdentifier),
                                           sizeof(pDynamicData->dot1agCfmMepDbRMepIdentifier)))
           {
               snmp_free_varbind(vars);
               return FALSE;
           }

           break;
        }

        /* dot1agCfmConfigFailTrap(99)
         */
        case TRAP_EVENT_CFM_CONFIG_FAIL:
        {
            UI32_T ILdot1agCfmMepIdentifier;
            TRAP_EVENT_CfmConfigFail_T *pDynamicData = & trap_data_p->u.cfm_config_fail;

            /* override the enterprise ID with private MIB */
            memcpy(enterprise, ID_es3626aTrap, len_es3626aTrap * sizeof(oid));
            enterprise_length = len_es3626aTrap;
            trap_type = SNMP_TRAP_ENTERPRISESPECIFIC;
            specific = LEAF_dot1agCfmConfigFailTrap;
            vars = NULL;

           /* binding dot1agCfmMepIdentifier */
           memcpy((char*)(ID_dot1agCfmMepIdentifier + len_dot1agCfmMepIdentifier), (char*)&pDynamicData->instance_dot1agCfmMepIdentifier, lenIdx_dot1agCfmMepIdentifier * sizeof(oid));
           ILdot1agCfmMepIdentifier= len_dot1agCfmMepIdentifier+lenIdx_dot1agCfmMepIdentifier;
           if (!snmp_varlist_add_variable( &vars, ID_dot1agCfmMepIdentifier, ILdot1agCfmMepIdentifier,
                                           ASN_INTEGER,
                                           (u_char*)&(pDynamicData->dot1agCfmMepIdentifier),
                                           sizeof(pDynamicData->dot1agCfmMepIdentifier)))
           {
               snmp_free_varbind(vars);
               return FALSE;
           }

           break;
        }

        /* dot1agCfmLoopFindTrap(100)
         */
        case TRAP_EVENT_CFM_LOOP_FIND:
        {
            UI32_T ILdot1agCfmMepIdentifier;
            TRAP_EVENT_CfmLoopFind_T *pDynamicData = & trap_data_p->u.cfm_loop_find;

            /* override the enterprise ID with private MIB */
            memcpy(enterprise, ID_es3626aTrap, len_es3626aTrap * sizeof(oid));
            enterprise_length = len_es3626aTrap;
            trap_type = SNMP_TRAP_ENTERPRISESPECIFIC;
            specific = LEAF_dot1agCfmLoopFindTrap;
            vars = NULL;

           /* binding dot1agCfmMepIdentifier */
           memcpy((char*)(ID_dot1agCfmMepIdentifier + len_dot1agCfmMepIdentifier), (char*)&pDynamicData->instance_dot1agCfmMepIdentifier, lenIdx_dot1agCfmMepIdentifier* sizeof(oid));
           ILdot1agCfmMepIdentifier= len_dot1agCfmMepIdentifier+lenIdx_dot1agCfmMepIdentifier;
           if (!snmp_varlist_add_variable( &vars, ID_dot1agCfmMepIdentifier, ILdot1agCfmMepIdentifier,
                                           ASN_INTEGER,
                                           (u_char*)&(pDynamicData->dot1agCfmMepIdentifier),
                                           sizeof(pDynamicData->dot1agCfmMepIdentifier)))
           {
               snmp_free_varbind(vars);
               return FALSE;
           }

           break;
        }

        /* dot1agCfmMepUnknownTrap(101)
         */
        case TRAP_EVENT_CFM_MEP_UNKNOWN:
        {
            UI32_T ILdot1agCfmMepIdentifier;
            TRAP_EVENT_CfmMepUnknown_T *pDynamicData = & trap_data_p->u.cfm_mep_unknown;

            /* override the enterprise ID with private MIB */
            memcpy(enterprise, ID_es3626aTrap, len_es3626aTrap * sizeof(oid));
            enterprise_length = len_es3626aTrap;
            trap_type = SNMP_TRAP_ENTERPRISESPECIFIC;
            specific = LEAF_dot1agCfmMepUnknownTrap;
            vars = NULL;

           /* binding dot1agCfmMepIdentifier */
           memcpy((char*)(ID_dot1agCfmMepIdentifier + len_dot1agCfmMepIdentifier), (char*)&pDynamicData->instance_dot1agCfmMepIdentifier[0], lenIdx_dot1agCfmMepIdentifier * sizeof(oid));
           ILdot1agCfmMepIdentifier= len_dot1agCfmMepIdentifier+lenIdx_dot1agCfmMepIdentifier;
           if (!snmp_varlist_add_variable( &vars, ID_dot1agCfmMepIdentifier, ILdot1agCfmMepIdentifier,
                                           ASN_INTEGER,
                                           (u_char*)&(pDynamicData->dot1agCfmMepIdentifier),
                                           sizeof(pDynamicData->dot1agCfmMepIdentifier)))
           {
               snmp_free_varbind(vars);
               return FALSE;
           }

           break;
        }

        /* dot1agCfmMepMissingTrap(102)
         */
        case TRAP_EVENT_CFM_MEP_MISSING:
        {
            UI32_T ILdot1agCfmMepIdentifier;
            TRAP_EVENT_CfmMepMissing_T *pDynamicData = & trap_data_p->u.cfm_mep_missing;

            /* override the enterprise ID with private MIB */
            memcpy(enterprise, ID_es3626aTrap, len_es3626aTrap * sizeof(oid));
            enterprise_length = len_es3626aTrap;
            trap_type = SNMP_TRAP_ENTERPRISESPECIFIC;
            specific = LEAF_dot1agCfmMepMissingTrap;
            vars = NULL;

           /* binding dot1agCfmMepIdentifier */
           memcpy((char*)(ID_dot1agCfmMepIdentifier + len_dot1agCfmMepIdentifier), (char*)&pDynamicData->instance_dot1agCfmMepIdentifier, lenIdx_dot1agCfmMepIdentifier * sizeof(oid));
           ILdot1agCfmMepIdentifier= len_dot1agCfmMepIdentifier+lenIdx_dot1agCfmMepIdentifier;
           if (!snmp_varlist_add_variable( &vars, ID_dot1agCfmMepIdentifier, ILdot1agCfmMepIdentifier,
                                           ASN_INTEGER,
                                           (u_char*)&(pDynamicData->dot1agCfmMepDbRMepIdentifier),
                                           sizeof(pDynamicData->dot1agCfmMepDbRMepIdentifier)))
           {
               snmp_free_varbind(vars);
               return FALSE;
           }

           break;
        }

        /* dot1agCfmMaUpTrap(103)
         */
        case TRAP_EVENT_CFM_MA_UP:
        {
            UI32_T ILdot1agCfmMaIndex;
            TRAP_EVENT_CfmMaUp_T *pDynamicData = & trap_data_p->u.cfm_ma_up;

            /* override the enterprise ID with private MIB */
            memcpy(enterprise, ID_es3626aTrap, len_es3626aTrap * sizeof(oid));
            enterprise_length = len_es3626aTrap;
            trap_type = SNMP_TRAP_ENTERPRISESPECIFIC;
            specific = LEAF_dot1agCfmMaUpTrap;
            vars = NULL;

            /* binding dot1agCfmMaIndex*/
           memcpy((char*)(ID_dot1agCfmMaIndex + len_dot1agCfmMaIndex), (char*)&pDynamicData->instance_dot1agCfmMaIndex, lenIdx_dot1agCfmMaIndex * sizeof(oid));
           ILdot1agCfmMaIndex= len_dot1agCfmMaIndex+lenIdx_dot1agCfmMaIndex;
           if (!snmp_varlist_add_variable( &vars, ID_dot1agCfmMaIndex, ILdot1agCfmMaIndex,
                                           ASN_INTEGER,
                                           (u_char*)&(pDynamicData->dot1agCfmMaIndex),
                                           sizeof(pDynamicData->dot1agCfmMaIndex)))
           {
               snmp_free_varbind(vars);
               return FALSE;
           }

           break;
        }
#endif  /* (SYS_CPNT_CFM == TRUE) */

#if (SYS_CPNT_CFM == TRUE)
        /* CFM MIB
         */
        case TRAP_EVENT_CFM_FAULT_ALARM:
        {
            UI32_T		ILdot1agCfmMepHighestPrDefect;
            TRAP_EVENT_CfmFaultAlarm_T *pDynamicData = & trap_data_p->u.cfm_fault_alarm;

            /* override the enterprise ID with IEEE8021-CFM-MIB */
            memcpy(enterprise, snmp_mgr_cfm_mib_oid, len_snmp_mgr_cfm_mib_oid * sizeof(oid));
            enterprise_length = len_snmp_mgr_cfm_mib_oid;
            trap_type = SNMP_TRAP_ENTERPRISESPECIFIC;
            specific = 1;
            vars = NULL;

            /* binding alarmIndex*/
            memcpy((char*)(ID_dot1agCfmMepHighestPrDefect + len_dot1agCfmMepHighestPrDefect), (char*)&pDynamicData->instance_dot1agCfmMepHighestPrDefect, lenIdx_dot1agCfmMepHighestPrDefect * sizeof(oid));
            ILdot1agCfmMepHighestPrDefect= len_dot1agCfmMepHighestPrDefect+lenIdx_dot1agCfmMepHighestPrDefect;
            if (!snmp_varlist_add_variable( &vars, ID_dot1agCfmMepHighestPrDefect, ILdot1agCfmMepHighestPrDefect,
                                           ASN_INTEGER,
                                           (u_char*)&(pDynamicData->dot1agCfmMepHighestPrDefect),
                                           sizeof(pDynamicData->dot1agCfmMepHighestPrDefect)))
            {
                snmp_free_varbind(vars);
                return FALSE;
            }

            break;
        }
#endif  /* #if (SYS_CPNT_CFM == TRUE) */

#if (SYS_CPNT_ALARM_INPUT_DETECT == TRUE)
        /* Accton private MIB
         */
        /* swAlarmInput(90)
         */
        case TRAP_EVENT_SW_ALARM_INPUT:
        {
           TRAP_EVENT_alarmMgt_T *pDynamicData = & trap_data_p->u.alarmMgt;
           UI32_T ILswAlarmInputName;

           /* override the enterprise ID with private MIB */
           memcpy(enterprise, ID_es3626aTrap, len_es3626aTrap * sizeof(oid));
           enterprise_length = len_es3626aTrap;
           trap_type = SNMP_TRAP_ENTERPRISESPECIFIC;
           specific = LEAF_swAlarmInput;
           vars = NULL;

           /* binding swAlarmInputName*/
           memcpy((char*)(ID_swAlarmInputName+ len_swAlarmInputName),
                  (char*)&pDynamicData->instance_sw_alarm_unit_index_alarm_input_index,
                  lenIdx_swAlarmInputName * sizeof(oid));
           ILswAlarmInputName = len_swAlarmInputName + lenIdx_swAlarmInputName;
           if (!snmp_varlist_add_variable(&vars, ID_swAlarmInputName, ILswAlarmInputName,
                                          ASN_OCTET_STR,
                                          (u_char*)&(pDynamicData->sw_alarm_input_name),
                                          sizeof(pDynamicData->sw_alarm_input_name)))
           {
               snmp_free_varbind(vars);
               return FALSE;
           }

           break;
        }
#endif

#if (SYS_CPNT_STP_BPDU_GUARD == TRUE)
        /* stpBpduGuardPortShutdownTrap */
        case TRAP_EVENT_STP_BPDU_GUARD_PORT_SHUTDOWN_TRAP:
        {
           TRAP_EVENT_stpBpduGuardPortShutdownTrap_T *pDynamicData = &trap_data_p->u.stp_bpdu_guard_port_shutdown;

           /* override the enterprise ID with private MIB
            */
           memcpy(enterprise, ID_es3626aTrap, len_es3626aTrap * sizeof(oid));
           enterprise_length = len_es3626aTrap;
           trap_type = SNMP_TRAP_ENTERPRISESPECIFIC;
           specific = LEAF_stpBpduGuardPortShutdownTrap;
           vars = NULL;

           /* binding ifIndex
            */
           if (!snmp_varlist_add_variable(&vars, ID_stpBpduGuardPortShutdown,
                    len_stpBpduGuardPortShutdown+lenIdx_stpBpduGuardPortShutdown,
                    ASN_INTEGER, (u_char *)&(pDynamicData->ifindex),
                    sizeof(pDynamicData->ifindex)))
           {
               snmp_free_varbind(vars);
               return FALSE;
           }

           break;
        }
#endif /* #if (SYS_CPNT_STP_BPDU_GUARD == TRUE) */

#if (SYS_CPNT_NETACCESS_LINK_DETECTION == TRUE)
        /* networkAccessPortLinkDetectionTrap(96)
         */
        case TRAP_EVENT_NETWORK_ACCESS_PORT_LINK_DETECTION_TRAP:
        {
           UI32_T ILifIndex, ILifOperStatus;
           UI32_T ILnetworkAccessPortLinkDetectionMode;
           UI32_T ILnetworkAccessPortLinkDetectionAction;

           TRAP_EVENT_networkAccessPortLinkDetectionTrap_T *pDynamicData = & trap_data_p->u.network_access_port_link_detection;

           /* override the enterprise ID with private MIB */
           memcpy(enterprise, ID_es3626aTrap, len_es3626aTrap * sizeof(oid));
           enterprise_length = len_es3626aTrap;
           trap_type = SNMP_TRAP_ENTERPRISESPECIFIC;
           specific = LEAF_networkAccessPortLinkDetectionTrap;
           vars = NULL;

           /* binding ifIndex*/
           memcpy((char*)(ID_ifIndex + len_ifIndex), (char*)&pDynamicData->instance_ifindex, 1 * sizeof(oid));
           ILifIndex = len_ifIndex+1;
           if (!snmp_varlist_add_variable( &vars, ID_ifIndex, ILifIndex,
                                           ASN_INTEGER,
                                           (u_char*)&(pDynamicData->ifindex),
                                           sizeof(pDynamicData->ifindex)))
           {
               snmp_free_varbind(vars);
               return FALSE;
           }

           /* binding ifOperStatus*/
           memcpy((char*)(ID_ifOperStatus + len_ifOperStatus), (char*)&pDynamicData->instance_ifOperStatus, 1 * sizeof(oid));
           ILifOperStatus = len_ifOperStatus+1;
           if (!snmp_varlist_add_variable( &vars, ID_ifOperStatus, ILifOperStatus,
                                           ASN_INTEGER,
                                           (u_char*)&(pDynamicData->ifOperStatus),
                                           sizeof(pDynamicData->ifOperStatus)))
           {
               snmp_free_varbind(vars);
               return FALSE;
           }

           /* binding networkAccessPortLinkDetectionMode*/
           memcpy((char*)(ID_networkAccessPortLinkDetectionMode + len_networkAccessPortLinkDetectionMode), (char*)&pDynamicData->instance_networkAccessPortLinkDetectionMode, lenIdx_networkAccessPortLinkDetectionMode * sizeof(oid));
           ILnetworkAccessPortLinkDetectionMode = len_networkAccessPortLinkDetectionMode+lenIdx_networkAccessPortLinkDetectionMode;
           if (!snmp_varlist_add_variable( &vars, ID_networkAccessPortLinkDetectionMode, ILnetworkAccessPortLinkDetectionMode,
                                           ASN_INTEGER,
                                           (u_char*)&(pDynamicData->networkAccessPortLinkDetectionMode),
                                           sizeof(pDynamicData->networkAccessPortLinkDetectionMode)))
           {
               snmp_free_varbind(vars);
               return FALSE;
           }

           /* binding networkAccessPortLinkDetectionAction*/
           memcpy((char*)(ID_networkAccessPortLinkDetectionAction + len_networkAccessPortLinkDetectionAction), (char*)&pDynamicData->instance_networkAccessPortLinkDetectionAction, lenIdx_networkAccessPortLinkDetectionAction * sizeof(oid));
           ILnetworkAccessPortLinkDetectionAction = len_networkAccessPortLinkDetectionAction+lenIdx_networkAccessPortLinkDetectionAction;
           if (!snmp_varlist_add_variable( &vars, ID_networkAccessPortLinkDetectionAction, ILnetworkAccessPortLinkDetectionAction,
                                           ASN_INTEGER,
                                           (u_char*)&(pDynamicData->networkAccessPortLinkDetectionAction),
                                           sizeof(pDynamicData->networkAccessPortLinkDetectionAction)))
           {
               snmp_free_varbind(vars);
               return FALSE;
           }

           break;
        }
#endif  /* #if(SYS_CPNT_NETACCESS_LINK_DETECTION == TRUE) */

#if (SYS_CPNT_XFER_AUTO_UPGRADE == TRUE)
        /* autoUpgradeTrap(104)
         */
        case TRAP_EVENT_XFER_AUTO_UPGRADE:
        {
            UI32_T ILauotUpGradeType;
            UI32_T ILauotUpGradeResult;
            UI32_T ILauotUpGradeNewVer;
            TRAP_EVENT_xferAutoUpgrade_T *pDynamicData = & trap_data_p->u.auto_upgrade;

            /* override the enterprise ID with private MIB */
            memcpy(enterprise, ID_es3626aTrap, len_es3626aTrap * sizeof(oid));
            enterprise_length = len_es3626aTrap;
            trap_type = SNMP_TRAP_ENTERPRISESPECIFIC;
            specific = LEAF_autoUpgradeTrap;
            vars = NULL;

            /* binding auotUpGradeType*/
            memcpy((char*)(ID_fileCopyFileType + len_fileCopyFileType), (char*)&pDynamicData->instance_fileCopyFileType, lenIdx_fileCopyFileType * sizeof(oid));
            ILauotUpGradeType = len_fileCopyFileType+lenIdx_fileCopyFileType;
            if (!snmp_varlist_add_variable( &vars, ID_fileCopyFileType, ILauotUpGradeType,
                                       ASN_INTEGER,
                                       (u_char*)&(pDynamicData->fileCopyFileType),
                                       sizeof(pDynamicData->fileCopyFileType)))
            {
                snmp_free_varbind(vars);
                return FALSE;
            }

            /* binding auotUpGradeResult*/
            memcpy((char*)(ID_trapAutoUpgradeResult + len_trapAutoUpgradeResult), (char*)&pDynamicData->instance_autoUpgradeResult, lenIdx_trapAutoUpgradeResult * sizeof(oid));
            ILauotUpGradeResult= len_trapAutoUpgradeResult+lenIdx_trapAutoUpgradeResult;
            if (!snmp_varlist_add_variable( &vars, ID_trapAutoUpgradeResult, ILauotUpGradeResult,
                                       ASN_INTEGER,
                                       (u_char*)&(pDynamicData->autoUpgradeResult),
                                       sizeof(pDynamicData->autoUpgradeResult)))
            {
                snmp_free_varbind(vars);
                return FALSE;
            }

            /* binding auotUpGradeNewVer*/
            memcpy((char*)(ID_trapAutoUpgradeNewVer + len_trapAutoUpgradeNewVer), (char*)&pDynamicData->instance_autoUpgradeNewVer, lenIdx_trapAutoUpgradeNewVer * sizeof(oid));
            ILauotUpGradeNewVer= len_trapAutoUpgradeNewVer+lenIdx_trapAutoUpgradeNewVer;
            if (!snmp_varlist_add_variable( &vars, ID_trapAutoUpgradeNewVer, ILauotUpGradeNewVer,
                                       ASN_OCTET_STR,
                                       (u_char*)&(pDynamicData->autoUpgradeNewVer),
                                       sizeof(pDynamicData->autoUpgradeNewVer)))
            {
                snmp_free_varbind(vars);
                return FALSE;
            }

            break;
        }
#endif

#if (SYS_CPNT_SYSMGMT_RESMIB == TRUE)
        /* swMemoryUtiRisingThresholdNotification(109)
         */
        case TRAP_EVENT_MEM_RAISE_TRAP:
        {
            /* override the enterprise ID with private MIB */
            memcpy(enterprise, ID_es3626aTrap, len_es3626aTrap * sizeof(oid));
            enterprise_length = len_es3626aTrap;
            trap_type = SNMP_TRAP_ENTERPRISESPECIFIC;
            specific = LEAF_swMemoryUtiRisingThresholdNotification;
            vars = NULL;

            break;
        }

        /* swMemoryUtiFallingThresholdNotification(110)
         */
        case TRAP_EVENT_MEM_FALLING_TRAP:
        {
            /* override the enterprise ID with private MIB */
            memcpy(enterprise, ID_es3626aTrap, len_es3626aTrap * sizeof(oid));
            enterprise_length = len_es3626aTrap;
            trap_type = SNMP_TRAP_ENTERPRISESPECIFIC;
            specific = LEAF_swMemoryUtiFallingThresholdNotification;
            vars = NULL;

            break;
        }

        /* swCpuUtiRisingNotification(107)
         */
        case TRAP_EVENT_CPU_RAISE_TRAP:
        {
            /* override the enterprise ID with private MIB */
            memcpy(enterprise, ID_es3626aTrap, len_es3626aTrap * sizeof(oid));
            enterprise_length = len_es3626aTrap;
            trap_type = SNMP_TRAP_ENTERPRISESPECIFIC;
            specific = LEAF_swCpuUtiRisingNotification;
            vars = NULL;

            break;
        }

        /* swCpuUtiFallingNotification(108)
         */
        case TRAP_EVENT_CPU_FALLING_TRAP:
        {
            /* override the enterprise ID with private MIB */
            memcpy(enterprise, ID_es3626aTrap, len_es3626aTrap * sizeof(oid));
            enterprise_length = len_es3626aTrap;
            trap_type = SNMP_TRAP_ENTERPRISESPECIFIC;
            specific = LEAF_swCpuUtiFallingNotification;
            vars = NULL;

            break;
        }
#endif  /* #if (SYS_CPNT_SYSMGMT_RESMIB == TRUE) */

#if (SYS_CPNT_SYSMGMT_CPU_GUARD == TRUE)

        /* cpuGuardControlTrap(213)
         */
        case TRAP_EVENT_CPU_GUARD_CONTROL:
        {
            /* override the enterprise ID with private MIB */
            memcpy(enterprise, ID_es3626aTrap, len_es3626aTrap * sizeof(oid));
            enterprise_length = len_es3626aTrap;
            trap_type = SNMP_TRAP_ENTERPRISESPECIFIC;
            specific = LEAF_cpuGuardControlTrap;
            vars = NULL;
            break;
        }

        /* cpuGuardReleaseTrap(214)
         */
        case TRAP_EVENT_CPU_GUARD_RELEASE:
        {
            /* override the enterprise ID with private MIB */
            memcpy(enterprise, ID_es3626aTrap, len_es3626aTrap * sizeof(oid));
            enterprise_length = len_es3626aTrap;
            trap_type = SNMP_TRAP_ENTERPRISESPECIFIC;
            specific = LEAF_cpuGuardReleaseTrap;
            vars = NULL;
            break;
        }
#endif
        /* DHCP client sends a trap when receiving a packet from a rogue server. */
        /* dhcpRogueServerAttackTrap(114)
         */
        case TRAP_EVENT_DHCP_ROGUE_SERVER_ATTACK:
        {
            UI32_T ILdhcpClientPortIfIndex;
            UI32_T ILdhcpServerIpAddress;
            UI32_T ILdhcpServerMacAddress;

            TRAP_EVENT_DhcpRogueServerAttack_T *pDynamicData = & trap_data_p->u.dhcp_rogue_server_attack;

            /* override the enterprise ID with private MIB */
            memcpy(enterprise, ID_es3626aTrap, len_es3626aTrap* sizeof(oid));
            enterprise_length = len_es3626aTrap;
            trap_type = SNMP_TRAP_ENTERPRISESPECIFIC;
            specific = LEAF_dhcpRogueServerAttackTrap;
            vars = NULL;

            /* binding dhcpClientPortIfIndex*/
           memcpy((char*)(ID_dhcpClientPortIfIndex + len_dhcpClientPortIfIndex),
                  (char*)&pDynamicData->instance_dhcpClientPortIfIndex,
                  lenIdx_dhcpClientPortIfIndex * sizeof(oid));
           ILdhcpClientPortIfIndex = len_dhcpClientPortIfIndex + lenIdx_dhcpClientPortIfIndex;
           if (!snmp_varlist_add_variable(&vars, ID_dhcpClientPortIfIndex, ILdhcpClientPortIfIndex,
                                          ASN_INTEGER,
                                          (u_char*)&(pDynamicData->dhcpClientPortIfIndex),
                                          sizeof(pDynamicData->dhcpClientPortIfIndex)))
           {
               snmp_free_varbind(vars);

               return FALSE;
           }

            /* binding dhcpServerIpAddress*/
           memcpy((char*)(ID_dhcpServerIpAddress + len_dhcpServerIpAddress),
                  (char*)&pDynamicData->instance_dhcpServerIpAddress,
                  lenIdx_dhcpServerIpAddress * sizeof(oid));
           ILdhcpServerIpAddress = len_dhcpServerIpAddress + lenIdx_dhcpServerIpAddress;
           if (!snmp_varlist_add_variable(&vars, ID_dhcpServerIpAddress, ILdhcpServerIpAddress,
                                          ASN_OCTET_STR,
                                          (u_char*)&(pDynamicData->dhcpServerIpAddress),
                                          sizeof(pDynamicData->dhcpServerIpAddress)))
           {
               snmp_free_varbind(vars);

               return FALSE;
           }

           /* binding dhcpServerMacAddress*/
           memcpy((char *)(ID_dhcpServerMacAddress + len_dhcpServerMacAddress),
                  (char *)&pDynamicData->instance_dhcpServerMacAddress,
                  lenIdx_dhcpServerMacAddress * sizeof(oid));
           ILdhcpServerMacAddress = len_dhcpServerMacAddress + lenIdx_dhcpServerMacAddress;
           if (!snmp_varlist_add_variable(&vars, ID_dhcpServerMacAddress, ILdhcpServerMacAddress,
                                          ASN_OCTET_STR,
                                          (u_char*)&(pDynamicData->dhcpServerMacAddress),
                                          sizeof(pDynamicData->dhcpServerMacAddress)))
           {
               snmp_free_varbind(vars);

               return FALSE;
           }

           break;
        }

#if (SYS_CPNT_SFP_DDM_ALARMWARN_TRAP == TRUE)
        /* sfpThresholdAlarmWarnTrap(189)
         */
        case TRAP_EVENT_SFP_RX_POWER_HIGH_ALARM:
        case TRAP_EVENT_SFP_RX_POWER_LOW_ALARM:
        case TRAP_EVENT_SFP_RX_POWER_HIGH_WARNING:
        case TRAP_EVENT_SFP_RX_POWER_LOW_WARNING:
        case TRAP_EVENT_SFP_TX_POWER_HIGH_ALARM:
        case TRAP_EVENT_SFP_TX_POWER_LOW_ALARM:
        case TRAP_EVENT_SFP_TX_POWER_HIGH_WARNING:
        case TRAP_EVENT_SFP_TX_POWER_LOW_WARNING:
        case TRAP_EVENT_SFP_TEMP_HIGH_ALARM:
        case TRAP_EVENT_SFP_TEMP_LOW_ALARM:
        case TRAP_EVENT_SFP_TEMP_HIGH_WARNING:
        case TRAP_EVENT_SFP_TEMP_LOW_WARNING:
        case TRAP_EVENT_SFP_VOLTAGE_HIGH_ALARM:
        case TRAP_EVENT_SFP_VOLTAGE_LOW_ALARM:
        case TRAP_EVENT_SFP_VOLTAGE_HIGH_WARNING:
        case TRAP_EVENT_SFP_VOLTAGE_LOW_WARNING:
        case TRAP_EVENT_SFP_CURRENT_HIGH_ALARM:
        case TRAP_EVENT_SFP_CURRENT_LOW_ALARM:
        case TRAP_EVENT_SFP_CURRENT_HIGH_WARNING:
        case TRAP_EVENT_SFP_CURRENT_LOW_WARNING:
        case TRAP_EVENT_SFP_TEMP_ALARMWARN_CEASE:
        case TRAP_EVENT_SFP_VOLTAGE_ALARMWARN_CEASE:
        case TRAP_EVENT_SFP_CURRENT_ALARMWARN_CEASE:
        case TRAP_EVENT_SFP_TX_POWER_ALARMWARN_CEASE:
        case TRAP_EVENT_SFP_RX_POWER_ALARMWARN_CEASE:
        {
           UI32_T       ILsfpThresholdAlarmWarnIfIndex;
           UI32_T    	ILsfpThresholdAlarmWarnType;
           TRAP_EVENT_SfpThresholdAlarmWarnTrap_T *pDynamicData = & trap_data_p->u.sfp_ddm_alarmwarn_trap;

           /* override the enterprise ID with private MIB */
           memcpy(enterprise, ID_es3626aTrap, len_es3626aTrap * sizeof(oid));
           enterprise_length = len_es3626aTrap;
           trap_type = SNMP_TRAP_ENTERPRISESPECIFIC;
           specific = LEAF_sfpThresholdAlarmWarnTrap;

           vars = NULL;

           /* binding sfpThresholdAlarmWarnIfIndex */
           memcpy((char*)(ID_sfpThresholdAlarmWarnIfIndex + len_sfpThresholdAlarmWarnIfIndex),
               (char*)&pDynamicData->instance_sfp_ddm_alarmwarn_ifindex,
               lenIdx_sfpThresholdAlarmWarnIfIndex * sizeof(oid));
           ILsfpThresholdAlarmWarnIfIndex= len_sfpThresholdAlarmWarnIfIndex+lenIdx_sfpThresholdAlarmWarnIfIndex;
           if (!snmp_varlist_add_variable( &vars, ID_sfpThresholdAlarmWarnIfIndex, ILsfpThresholdAlarmWarnIfIndex,
                                           ASN_INTEGER,
                                           (u_char*)&(pDynamicData->sfp_ddm_alarmwarn_ifindex),
                                           sizeof(pDynamicData->sfp_ddm_alarmwarn_ifindex)))
           {
               snmp_free_varbind(vars);

               return FALSE;
           }

           /* binding sfpThresholdAlarmWarnType */
           memcpy((char*)(ID_sfpThresholdAlarmWarnType + len_sfpThresholdAlarmWarnType),
               (char*)&pDynamicData->instance_sfp_ddm_alarmwarn_type,
               lenIdx_sfpThresholdAlarmWarnType * sizeof(oid));
           ILsfpThresholdAlarmWarnType= len_sfpThresholdAlarmWarnType+lenIdx_sfpThresholdAlarmWarnType;
           if (!snmp_varlist_add_variable( &vars, ID_sfpThresholdAlarmWarnType, ILsfpThresholdAlarmWarnType,
                                           ASN_INTEGER,
                                           (u_char*)&(pDynamicData->sfp_ddm_alarmwarn_type),
                                           sizeof(pDynamicData->sfp_ddm_alarmwarn_type)))
           {
               snmp_free_varbind(vars);

               return FALSE;
           }

           break;
        }
#endif  /* (SYS_CPNT_SFP_DDM_ALARMWARN_TRAP == TRUE) */

#if (SYS_CPNT_DYING_GASP == TRUE)
        /* swDyingGaspTrap(190)
         */
        case TRAP_EVENT_DYING_GASP:
            /* override the enterprise ID with private MIB */
            memcpy(enterprise, ID_es3626aTrap, len_es3626aTrap * sizeof(oid));
            enterprise_length = len_es3626aTrap;
            trap_type = SNMP_TRAP_ENTERPRISESPECIFIC;
            specific = LEAF_swDyingGaspTrap;
            /* this trap have no variables binding*/
            vars = NULL;
            break;
#endif  /* (SYS_CPNT_DYING_GASP == TRUE) */
#if (SYS_CPNT_ALARM_INPUT_DETECT == TRUE)
        /* Accton private MIB
         */
        /* swAlarmInputRecover(203)
         */
        case TRAP_EVENT_SW_ALARM_INPUT_RECOVER:
        {
           TRAP_EVENT_alarmMgt_T *pDynamicData = & trap_data_p->u.alarmMgt;
           UI32_T ILswAlarmInputName;

           /* override the enterprise ID with private MIB */
           memcpy(enterprise, ID_es3626aTrap, len_es3626aTrap * sizeof(oid));
           enterprise_length = len_es3626aTrap;
           trap_type = SNMP_TRAP_ENTERPRISESPECIFIC;
           specific = LEAF_swAlarmInputRecover;
           vars = NULL;

           /* binding swAlarmInputName*/
           memcpy((char*)(ID_swAlarmInputName+ len_swAlarmInputName),
                  (char*)&pDynamicData->instance_sw_alarm_unit_index_alarm_input_index,
                  lenIdx_swAlarmInputName * sizeof(oid));
           ILswAlarmInputName = len_swAlarmInputName + lenIdx_swAlarmInputName;
           if (!snmp_varlist_add_variable(&vars, ID_swAlarmInputName, ILswAlarmInputName,
                                          ASN_OCTET_STR,
                                          (u_char*)&(pDynamicData->sw_alarm_input_name),
                                          sizeof(pDynamicData->sw_alarm_input_name)))
           {
               snmp_free_varbind(vars);
               return FALSE;
           }

           break;
        }
#endif

#if (SYS_CPNT_BGP == TRUE)
        case TRAP_EVENT_BGP_ESTABLISHED_NOTIFICATION:
        {
            UI32_T ILbgpPeerRemoteAddr;
            UI32_T ILbgpPeerLastError;
            UI32_T ILbgpPeerState;
            TRAP_EVENT_BgpEstablishedNotificationTrap_T *pDynamicData = & trap_data_p->u.bgp_established;

            /* override the enterprise ID with BGP MIB */
            memcpy(enterprise, snmp_mgr_bgp_mib_oid, len_snmp_mgr_bgp_mib_oid * sizeof(oid));
            enterprise_length = len_snmp_mgr_bgp_mib_oid;
            trap_type = SNMP_TRAP_ENTERPRISESPECIFIC;
            specific = 1;
            vars = NULL;

            /* binding bgpPeerRemoteAddr */
            memcpy((char*)(ID_bgpPeerRemoteAddr+ len_bgpPeerRemoteAddr), (char*)pDynamicData->instance, lenIdx_bgpPeerRemoteAddr*sizeof(oid));
            ILbgpPeerRemoteAddr = len_bgpPeerRemoteAddr+lenIdx_bgpPeerRemoteAddr;
            if (!snmp_varlist_add_variable( &vars, ID_bgpPeerRemoteAddr, ILbgpPeerRemoteAddr,
                                            ASN_IPADDRESS,
                                            (u_char*)pDynamicData->bgpPeerRemoteAddr,
                                            sizeof(pDynamicData->bgpPeerRemoteAddr)))
            {
                snmp_free_varbind(vars);
                return FALSE;
            }

            /* binding bgpPeerLastError */
            memcpy((char*)(ID_bgpPeerLastError+ len_bgpPeerLastError), (char*)pDynamicData->instance, lenIdx_bgpPeerLastError*sizeof(oid));
            ILbgpPeerLastError = len_bgpPeerLastError+lenIdx_bgpPeerLastError;
            if (!snmp_varlist_add_variable( &vars, ID_bgpPeerLastError, ILbgpPeerLastError,
                                            ASN_OCTET_STR,
                                            (u_char*)pDynamicData->bgpPeerLastError,
                                            sizeof(pDynamicData->bgpPeerLastError)))
            {
                snmp_free_varbind(vars);
                return FALSE;
            }

            /* binding bgpPeerState */
            memcpy((char*)(ID_bgpPeerState+ len_bgpPeerState), (char*)&(pDynamicData->instance), lenIdx_bgpPeerState*sizeof(oid));
            ILbgpPeerState = len_bgpPeerState+lenIdx_bgpPeerState;
            if (!snmp_varlist_add_variable( &vars, ID_bgpPeerState, ILbgpPeerState,
                                            ASN_INTEGER,
                                            (u_char*)&(pDynamicData->bgpPeerState),
                                            sizeof(pDynamicData->bgpPeerState)))
            {
                snmp_free_varbind(vars);
                return FALSE;
            }

            break;
        }

        case TRAP_EVENT_BGP_BACKWARD_TRANS_NOTIFICATION:
        {
            UI32_T ILbgpPeerRemoteAddr;
            UI32_T ILbgpPeerLastError;
            UI32_T ILbgpPeerState;
            TRAP_EVENT_BgpBackwardTransNotificationTrap_T *pDynamicData = & trap_data_p->u.bgp_backward_trans;

            /* override the enterprise ID with BGP MIB */
            memcpy(enterprise, snmp_mgr_bgp_mib_oid, len_snmp_mgr_bgp_mib_oid * sizeof(oid));
            enterprise_length = len_snmp_mgr_bgp_mib_oid;
            trap_type = SNMP_TRAP_ENTERPRISESPECIFIC;
            specific = 2;
            vars = NULL;

            /* binding bgpPeerRemoteAddr */
            memcpy((char*)(ID_bgpPeerRemoteAddr+ len_bgpPeerRemoteAddr), (char*)pDynamicData->instance, lenIdx_bgpPeerRemoteAddr*sizeof(oid));
            ILbgpPeerRemoteAddr = len_bgpPeerRemoteAddr+lenIdx_bgpPeerRemoteAddr;
            if (!snmp_varlist_add_variable( &vars, ID_bgpPeerRemoteAddr, ILbgpPeerRemoteAddr,
                                            ASN_IPADDRESS,
                                            (u_char*)pDynamicData->bgpPeerRemoteAddr,
                                            sizeof(pDynamicData->bgpPeerRemoteAddr)))
            {
                snmp_free_varbind(vars);
                return FALSE;
            }

            /* binding bgpPeerLastError */
            memcpy((char*)(ID_bgpPeerLastError+ len_bgpPeerLastError), (char*)pDynamicData->instance, lenIdx_bgpPeerLastError*sizeof(oid));
            ILbgpPeerLastError = len_bgpPeerLastError+lenIdx_bgpPeerLastError;
            if (!snmp_varlist_add_variable( &vars, ID_bgpPeerLastError, ILbgpPeerLastError,
                                            ASN_OCTET_STR,
                                            (u_char*)pDynamicData->bgpPeerLastError,
                                            sizeof(pDynamicData->bgpPeerLastError)))
            {
                snmp_free_varbind(vars);
                return FALSE;
            }

            /* binding bgpPeerState */
            memcpy((char*)(ID_bgpPeerState+ len_bgpPeerState), (char*)&(pDynamicData->instance), lenIdx_bgpPeerState*sizeof(oid));
            ILbgpPeerState = len_bgpPeerState+lenIdx_bgpPeerState;
            if (!snmp_varlist_add_variable( &vars, ID_bgpPeerState, ILbgpPeerState,
                                            ASN_INTEGER,
                                            (u_char*)&(pDynamicData->bgpPeerState),
                                            sizeof(pDynamicData->bgpPeerState)))
            {
                snmp_free_varbind(vars);
                return FALSE;
            }

            break;
        }
#endif

#if (SYS_CPNT_AMTR_MAC_NOTIFY == TRUE)
        case TRAP_EVENT_MAC_NOTIFY:
        {
            TRAP_EVENT_MacNotify_T *pDynamicData = & trap_data_p->u.mac_notify;

            /* override the enterprise ID with private MIB */
            memcpy(enterprise, ID_es3626aTrap, len_es3626aTrap* sizeof(oid));
            enterprise_length = len_es3626aTrap;
            trap_type = SNMP_TRAP_ENTERPRISESPECIFIC;
            specific = TRAP_EVENT_MAC_NOTIFY;
            vars = NULL;
            /* binding trapIfIndex */
            memcpy((char*)(ID_trapIfIndex + len_trapIfIndex), (char*)&pDynamicData->ifindex, 1 * sizeof(oid));
            if (!snmp_varlist_add_variable( &vars, ID_trapIfIndex, len_trapIfIndex+1,
                                           ASN_INTEGER,
                                           (u_char*)&(pDynamicData->ifindex),
                                           sizeof(pDynamicData->ifindex)))
            {
               snmp_free_varbind(vars);
               return FALSE;
            }

            /* binding trapVlanId */
            if (!snmp_varlist_add_variable( &vars, ID_trapVlanId,
                                           len_trapVlanId+lenIdx_trapVlanId,
                                           ASN_INTEGER,
                                           (u_char*)&(pDynamicData->vid),
                                           sizeof(pDynamicData->vid)))
            {
                snmp_free_varbind(vars);
                return FALSE;
            }

            /* binding trapVarMacAddr */
            if (!snmp_varlist_add_variable( &vars, ID_trapVarMacAddr,
                                            len_trapVarMacAddr+lenIdx_trapVarMacAddr,
                                            ASN_OCTET_STR,
                                            (u_char*)&(pDynamicData->src_mac),
                                            sizeof(pDynamicData->src_mac)))
            {
                snmp_free_varbind(vars);
                return FALSE;
            }

            /* binding trapMacNotifyAction */
            if (!snmp_varlist_add_variable( &vars, ID_trapMacNotifyAction,
                                            len_trapMacNotifyAction+lenIdx_trapMacNotifyAction,
                                            ASN_INTEGER,
                                            (u_char*)&(pDynamicData->action),
                                            sizeof(pDynamicData->action)))
            {
                snmp_free_varbind(vars);
                return FALSE;
            }
        }
        break;
#endif

#if (SYS_CPNT_SYNCE == TRUE)
        case TRAP_EVENT_SYNCE_SSM_RX:
        {
            TRAP_EVENT_SyncESsmRx *synce_ssm_rx_data_p = &trap_data_p->u.synce_ssm_rx;
            /* override the enterprise ID with private MIB */
            memcpy(enterprise, ID_es3626aTrap, len_es3626aTrap* sizeof(oid));
            enterprise_length = len_es3626aTrap;
            trap_type = SNMP_TRAP_ENTERPRISESPECIFIC;
            specific = LEAF_syncEReceiveSSMTrap;
            vars = NULL;
            /* binding syncEPortIndex*/
            memcpy((char*)(ID_syncePortIndex + len_syncePortIndex), (char*)&synce_ssm_rx_data_p->ifindex, 1 * sizeof(oid));
            if (!snmp_varlist_add_variable( &vars, ID_syncePortIndex, len_syncePortIndex+lenIdx_syncePortIndex,
                                           ASN_INTEGER,
                                           (u_char*)&(synce_ssm_rx_data_p->ifindex),
                                           sizeof(synce_ssm_rx_data_p->ifindex)))
            {
               snmp_free_varbind(vars);
               return FALSE;
            }

            /* binding syncEPortStatus */
            if (!snmp_varlist_add_variable( &vars, ID_syncePortStatus, len_syncePortStatus+lenIdx_syncePortStatus,
                                           ASN_INTEGER,
                                           (u_char*)&(synce_ssm_rx_data_p->status),
                                           sizeof(synce_ssm_rx_data_p->status)))
            {
                snmp_free_varbind(vars);
                return FALSE;
            }

            /* binding syncEPortSsmStatus */
            if (!snmp_varlist_add_variable( &vars, ID_syncePortSsmStatus, len_syncePortSsmStatus+lenIdx_syncePortSsmStatus,
                                           ASN_INTEGER,
                                           (u_char*)&(synce_ssm_rx_data_p->ssm_status),
                                           sizeof(synce_ssm_rx_data_p->ssm_status)))
            {
                snmp_free_varbind(vars);
                return FALSE;
            }

        }
            break;
        case TRAP_EVENT_SYNCE_CLOCK_SRC:
        {
            TRAP_EVENT_SyncEClkSrc *synce_clk_src_data_p = &trap_data_p->u.sync_clk_src;
            /* override the enterprise ID with private MIB */
            memcpy(enterprise, ID_es3626aTrap, len_es3626aTrap* sizeof(oid));
            enterprise_length = len_es3626aTrap;
            trap_type = SNMP_TRAP_ENTERPRISESPECIFIC;
            specific = LEAF_syncELockedClockSource;
            vars = NULL;
            /* binding syncEPortIndex*/
            memcpy((char*)(ID_syncePortIndex + len_syncePortIndex), (char*)&synce_clk_src_data_p->ifindex, 1 * sizeof(oid));
            if (!snmp_varlist_add_variable( &vars, ID_syncePortIndex, len_syncePortIndex+lenIdx_syncePortIndex,
                                           ASN_INTEGER,
                                           (u_char*)&(synce_clk_src_data_p->ifindex),
                                           sizeof(synce_clk_src_data_p->ifindex)))
            {
               snmp_free_varbind(vars);
               return FALSE;
            }
        }
            break;

#endif

        case TRAP_EVENT_USERAUTH_AUTHENTICATION_FAILURE:
        {
            TRAP_EVENT_UserInfo_T *pDynamicData = &trap_data_p->u.user_info;
            UI32_T addr_type;

            /* override the enterprise ID with private MIB
             */
            memcpy(enterprise, ID_es3626aTrap, len_es3626aTrap * sizeof(oid));
            enterprise_length = len_es3626aTrap;
            trap_type = SNMP_TRAP_ENTERPRISESPECIFIC;
            specific = LEAF_userAuthenticationFailureTrap;
            vars = NULL;

            /* binding trapVarLoginUserName
             */
            if (!snmp_varlist_add_variable(&vars,
                                           ID_trapVarLoginUserName,
                                           len_trapVarLoginUserName,
                                           ASN_OCTET_STR,
                                           (u_char*)&(pDynamicData->user_name),
                                           sizeof(pDynamicData->user_name)))
            {
                snmp_free_varbind(vars);
                return FALSE;
            }

            /* binding trapVarSessionType
             */
            if (!snmp_varlist_add_variable(&vars,
                                           ID_trapVarSessionType,
                                           len_trapVarSessionType,
                                           ASN_INTEGER,
                                           (u_char*)&(pDynamicData->session_type),
                                           sizeof(pDynamicData->session_type)))
            {
                snmp_free_varbind(vars);
                return FALSE;
            }

            /* binding trapVarLoginInetAddressType
             */
            addr_type = pDynamicData->user_ip.type;

            if (!snmp_varlist_add_variable(&vars,
                                           ID_trapVarLoginInetAddressType,
                                           len_trapVarLoginInetAddressType,
                                           ASN_INTEGER,
                                           (u_char*)&addr_type,
                                           sizeof(addr_type)))
            {
                snmp_free_varbind(vars);
                return FALSE;
            }

            /* binding trapVarLoginInetAddress
             */
            if (!snmp_varlist_add_variable(&vars,
                                           ID_trapVarLoginInetAddress,
                                           len_trapVarLoginInetAddress,
                                           ASN_OCTET_STR,
                                           (u_char*)&(pDynamicData->user_ip.addr),
                                           pDynamicData->user_ip.addrlen))
            {
                snmp_free_varbind(vars);
                return FALSE;
            }

            break;
        }

        case TRAP_EVENT_USERAUTH_AUTHENTICATION_SUCCESS:
        {
            TRAP_EVENT_UserInfo_T *pDynamicData = &trap_data_p->u.user_info;
            UI32_T addr_type;

            /* override the enterprise ID with private MIB
             */
            memcpy(enterprise, ID_es3626aTrap, len_es3626aTrap * sizeof(oid));
            enterprise_length = len_es3626aTrap;
            trap_type = SNMP_TRAP_ENTERPRISESPECIFIC;
            specific = LEAF_userAuthenticationSuccessTrap;
            vars = NULL;

            /* binding trapVarLoginUserName
             */
            if (!snmp_varlist_add_variable(&vars,
                                           ID_trapVarLoginUserName,
                                           len_trapVarLoginUserName,
                                           ASN_OCTET_STR,
                                           (u_char*)&(pDynamicData->user_name),
                                           sizeof(pDynamicData->user_name)))
            {
                snmp_free_varbind(vars);
                return FALSE;
            }

            /* binding trapVarSessionType
             */
            if (!snmp_varlist_add_variable(&vars,
                                           ID_trapVarSessionType,
                                           len_trapVarSessionType,
                                           ASN_INTEGER,
                                           (u_char*)&(pDynamicData->session_type),
                                           sizeof(pDynamicData->session_type)))
            {
                snmp_free_varbind(vars);
                return FALSE;
            }

            /* binding trapVarLoginInetAddressType
             */
            addr_type = pDynamicData->user_ip.type;

            if (!snmp_varlist_add_variable(&vars,
                                           ID_trapVarLoginInetAddressType,
                                           len_trapVarLoginInetAddressType,
                                           ASN_INTEGER,
                                           (u_char*)&addr_type,
                                           sizeof(addr_type)))
            {
                snmp_free_varbind(vars);
                return FALSE;
            }

            /* binding trapVarLoginInetAddress
             */
            if (!snmp_varlist_add_variable(&vars,
                                           ID_trapVarLoginInetAddress,
                                           len_trapVarLoginInetAddress,
                                           ASN_OCTET_STR,
                                           (u_char*)&(pDynamicData->user_ip.addr),
                                           pDynamicData->user_ip.addrlen))
            {
                snmp_free_varbind(vars);
                return FALSE;
            }

            break;
        }

        case TRAP_EVENT_LOGIN:
        {
            TRAP_EVENT_UserInfo_T *pDynamicData = &trap_data_p->u.user_info;
            UI32_T addr_type;

            /* override the enterprise ID with private MIB
             */
            memcpy(enterprise, ID_es3626aTrap, len_es3626aTrap * sizeof(oid));
            enterprise_length = len_es3626aTrap;
            trap_type = SNMP_TRAP_ENTERPRISESPECIFIC;
            specific = LEAF_loginTrap;
            vars = NULL;

            /* binding trapVarLoginUserName
             */
            if (!snmp_varlist_add_variable(&vars,
                                           ID_trapVarLoginUserName,
                                           len_trapVarLoginUserName,
                                           ASN_OCTET_STR,
                                           (u_char*)&(pDynamicData->user_name),
                                           sizeof(pDynamicData->user_name)))
            {
                snmp_free_varbind(vars);
                return FALSE;
            }

            /* binding trapVarSessionType
             */
            if (!snmp_varlist_add_variable(&vars,
                                           ID_trapVarSessionType,
                                           len_trapVarSessionType,
                                           ASN_INTEGER,
                                           (u_char*)&(pDynamicData->session_type),
                                           sizeof(pDynamicData->session_type)))
            {
                snmp_free_varbind(vars);
                return FALSE;
            }

            /* binding trapVarLoginInetAddressType
             */
            addr_type = pDynamicData->user_ip.type;

            if (!snmp_varlist_add_variable(&vars,
                                           ID_trapVarLoginInetAddressType,
                                           len_trapVarLoginInetAddressType,
                                           ASN_INTEGER,
                                           (u_char*)&addr_type,
                                           sizeof(addr_type)))
            {
                snmp_free_varbind(vars);
                return FALSE;
            }

            /* binding trapVarLoginInetAddress
             */
            if (!snmp_varlist_add_variable(&vars,
                                           ID_trapVarLoginInetAddress,
                                           len_trapVarLoginInetAddress,
                                           ASN_OCTET_STR,
                                           (u_char*)&(pDynamicData->user_ip.addr),
                                           pDynamicData->user_ip.addrlen))
            {
                snmp_free_varbind(vars);
                return FALSE;
            }

            break;
        }

        case TRAP_EVENT_LOGOUT:
        {
            TRAP_EVENT_UserInfo_T *pDynamicData = &trap_data_p->u.user_info;
            UI32_T addr_type;

            /* override the enterprise ID with private MIB
             */
            memcpy(enterprise, ID_es3626aTrap, len_es3626aTrap * sizeof(oid));
            enterprise_length = len_es3626aTrap;
            trap_type = SNMP_TRAP_ENTERPRISESPECIFIC;
            specific = LEAF_logoutTrap;
            vars = NULL;

            /* binding trapVarLoginUserName
             */
            if (!snmp_varlist_add_variable(&vars,
                                           ID_trapVarLoginUserName,
                                           len_trapVarLoginUserName,
                                           ASN_OCTET_STR,
                                           (u_char*)&(pDynamicData->user_name),
                                           sizeof(pDynamicData->user_name)))
            {
                snmp_free_varbind(vars);
                return FALSE;
            }

            /* binding trapVarSessionType
             */
            if (!snmp_varlist_add_variable(&vars,
                                           ID_trapVarSessionType,
                                           len_trapVarSessionType,
                                           ASN_INTEGER,
                                           (u_char*)&(pDynamicData->session_type),
                                           sizeof(pDynamicData->session_type)))
            {
                snmp_free_varbind(vars);
                return FALSE;
            }

            /* binding trapVarLoginInetAddressType
             */
            addr_type = pDynamicData->user_ip.type;

            if (!snmp_varlist_add_variable(&vars,
                                           ID_trapVarLoginInetAddressType,
                                           len_trapVarLoginInetAddressType,
                                           ASN_INTEGER,
                                           (u_char*)&addr_type,
                                           sizeof(addr_type)))
            {
                snmp_free_varbind(vars);
                return FALSE;
            }

            /* binding trapVarLoginInetAddress
             */
            if (!snmp_varlist_add_variable(&vars,
                                           ID_trapVarLoginInetAddress,
                                           len_trapVarLoginInetAddress,
                                           ASN_OCTET_STR,
                                           (u_char*)&(pDynamicData->user_ip.addr),
                                           pDynamicData->user_ip.addrlen))
            {
                snmp_free_varbind(vars);
                return FALSE;
            }

            break;
        }

        case TRAP_EVENT_FILE_COPY:
        {
            TRAP_EVENT_UserInfo_T *user_info_p = &trap_data_p->u.file_copy_entry.user_info;
            TRAP_EVENT_XferFileCopyInfo_T *file_copy_info_p = &trap_data_p->u.file_copy_entry.file_copy_info;
            UI32_T addr_type;

            /* override the enterprise ID with private MIB
             */
            memcpy(enterprise, ID_es3626aTrap, len_es3626aTrap * sizeof(oid));
            enterprise_length = len_es3626aTrap;
            trap_type = SNMP_TRAP_ENTERPRISESPECIFIC;
            specific = LEAF_fileCopyTrap;
            vars = NULL;

            /* binding trapVarLoginUserName
             */
            if (!snmp_varlist_add_variable(&vars,
                                           ID_trapVarLoginUserName,
                                           len_trapVarLoginUserName,
                                           ASN_OCTET_STR,
                                           (u_char*)&(user_info_p->user_name),
                                           sizeof(user_info_p->user_name)))
            {
                snmp_free_varbind(vars);
                return FALSE;
            }

            /* binding trapVarSessionType
             */
            if (!snmp_varlist_add_variable(&vars,
                                           ID_trapVarSessionType,
                                           len_trapVarSessionType,
                                           ASN_INTEGER,
                                           (u_char*)&(user_info_p->session_type),
                                           sizeof(user_info_p->session_type)))
            {
                snmp_free_varbind(vars);
                return FALSE;
            }

            /* binding trapVarLoginInetAddressType
             */
            addr_type = user_info_p->user_ip.type;

            if (!snmp_varlist_add_variable(&vars,
                                           ID_trapVarLoginInetAddressType,
                                           len_trapVarLoginInetAddressType,
                                           ASN_INTEGER,
                                           (u_char*)&addr_type,
                                           sizeof(addr_type)))
            {
                snmp_free_varbind(vars);
                return FALSE;
            }

            /* binding trapVarLoginInetAddress
             */
            if (!snmp_varlist_add_variable(&vars,
                                           ID_trapVarLoginInetAddress,
                                           len_trapVarLoginInetAddress,
                                           ASN_OCTET_STR,
                                           (u_char*)&(user_info_p->user_ip.addr),
                                           user_info_p->user_ip.addrlen))
            {
                snmp_free_varbind(vars);
                return FALSE;
            }

            /* binding fileCopySrcOperType
             */
            if (!snmp_varlist_add_variable(&vars,
                                           ID_fileCopySrcOperType,
                                           len_fileCopySrcOperType,
                                           ASN_INTEGER,
                                           (u_char*)&(file_copy_info_p->src_oper_type),
                                           sizeof(file_copy_info_p->src_oper_type)))
            {
                snmp_free_varbind(vars);
                return FALSE;
            }


            /* binding fileCopySrcFileName
             */
            if (!snmp_varlist_add_variable(&vars,
                                           ID_fileCopySrcFileName,
                                           len_fileCopySrcFileName,
                                           ASN_OCTET_STR,
                                           (u_char*)&(file_copy_info_p->src_file_name),
                                           sizeof(file_copy_info_p->src_file_name)))
            {
                snmp_free_varbind(vars);
                return FALSE;
            }

            /* binding fileCopyDestOperType
             */
            if (!snmp_varlist_add_variable(&vars,
                                           ID_fileCopyDestOperType,
                                           len_fileCopyDestOperType,
                                           ASN_INTEGER,
                                           (u_char*)&(file_copy_info_p->dest_oper_type),
                                           sizeof(file_copy_info_p->dest_oper_type)))
            {
                snmp_free_varbind(vars);
                return FALSE;
            }

            /* binding fileCopyDestFileName
             */
            if (!snmp_varlist_add_variable(&vars,
                                           ID_fileCopyDestFileName,
                                           len_fileCopyDestFileName,
                                           ASN_OCTET_STR,
                                           (u_char*)&(file_copy_info_p->dest_file_name),
                                           sizeof(file_copy_info_p->dest_file_name)))
            {
                snmp_free_varbind(vars);
                return FALSE;
            }

            /* binding fileCopyFileType
             */
            if (!snmp_varlist_add_variable(&vars,
                                           ID_fileCopyFileType,
                                           len_fileCopyFileType,
                                           ASN_INTEGER,
                                           (u_char*)&(file_copy_info_p->file_type),
                                           sizeof(file_copy_info_p->file_type)))
            {
                snmp_free_varbind(vars);
                return FALSE;
            }

            /* binding fileCopyUnitId
             */
            if (!snmp_varlist_add_variable(&vars,
                                           ID_fileCopyUnitId,
                                           len_fileCopyUnitId,
                                           ASN_INTEGER,
                                           (u_char*)&(file_copy_info_p->unit),
                                           sizeof(file_copy_info_p->unit)))
            {
                snmp_free_varbind(vars);
                return FALSE;
            }

           /* binding fileCopyStatus
             */
            if (!snmp_varlist_add_variable(&vars,
                                           ID_fileCopyStatus,
                                           len_fileCopyStatus,
                                           ASN_INTEGER,
                                           (u_char*)&(file_copy_info_p->status),
                                           sizeof(file_copy_info_p->status)))
            {
                snmp_free_varbind(vars);
                return FALSE;
            }

            /* binding fileCopyServerInetAddressType
             */
            addr_type = file_copy_info_p->server_address.type;

            if (!snmp_varlist_add_variable(&vars,
                                           ID_fileCopyServerInetAddressType,
                                           len_fileCopyServerInetAddressType,
                                           ASN_INTEGER,
                                           (u_char*)&addr_type,
                                           sizeof(addr_type)))
            {
                snmp_free_varbind(vars);
                return FALSE;
            }

            /* binding fileCopyServerInetAddress
             */
            if (!snmp_varlist_add_variable(&vars,
                                           ID_fileCopyServerInetAddress,
                                           len_fileCopyServerInetAddress,
                                           ASN_OCTET_STR,
                                           (u_char*)&(file_copy_info_p->server_address.addr),
                                           file_copy_info_p->server_address.addrlen))
            {
                snmp_free_varbind(vars);
                return FALSE;
            }

            break;
        }

        case TRAP_EVENT_USERAUTH_CREATE_USER:
        {
            TRAP_EVENT_UserauthAccount_T *userauth_account = &trap_data_p->u.userauth_account;

            /* override the enterprise ID with private MIB
             */
            memcpy(enterprise, ID_es3626aTrap, len_es3626aTrap * sizeof(oid));
            enterprise_length = len_es3626aTrap;
            trap_type = SNMP_TRAP_ENTERPRISESPECIFIC;
            specific = LEAF_userauthCreateUserTrap;
            vars = NULL;

            /* binding userAuthUserName
             */
            if (!snmp_varlist_add_variable(&vars,
                                           ID_userAuthUserName,
                                           len_userAuthUserName,
                                           ASN_OCTET_STR,
                                           (u_char*)&(userauth_account->user_name),
                                           sizeof(userauth_account->user_name)))
            {
                snmp_free_varbind(vars);
                return FALSE;
            }

            break;
        }

        case TRAP_EVENT_USERAUTH_DELETE_USER:
        {
            TRAP_EVENT_UserauthAccount_T *userauth_account = &trap_data_p->u.userauth_account;

            /* override the enterprise ID with private MIB
             */
            memcpy(enterprise, ID_es3626aTrap, len_es3626aTrap * sizeof(oid));
            enterprise_length = len_es3626aTrap;
            trap_type = SNMP_TRAP_ENTERPRISESPECIFIC;
            specific = LEAF_userauthDeleteUserTrap;
            vars = NULL;

            /* binding userAuthUserName
             */
            if (!snmp_varlist_add_variable(&vars,
                                           ID_userAuthUserName,
                                           len_userAuthUserName,
                                           ASN_OCTET_STR,
                                           (u_char*)&(userauth_account->user_name),
                                           sizeof(userauth_account->user_name)))
            {
                snmp_free_varbind(vars);
                return FALSE;
            }

            break;
        }

        case TRAP_EVENT_USERAUTH_MODIFY_USER_PRIVILEGE:
        {
            TRAP_EVENT_UserauthAccount_T *userauth_account = &trap_data_p->u.userauth_account;

            /* override the enterprise ID with private MIB
             */
            memcpy(enterprise, ID_es3626aTrap, len_es3626aTrap * sizeof(oid));
            enterprise_length = len_es3626aTrap;
            trap_type = SNMP_TRAP_ENTERPRISESPECIFIC;
            specific = LEAF_userauthModifyUserPrivilegeTrap;
            vars = NULL;

            /* binding userAuthUserName
             */
            if (!snmp_varlist_add_variable(&vars,
                                           ID_userAuthUserName,
                                           len_userAuthUserName,
                                           ASN_OCTET_STR,
                                           (u_char*)&(userauth_account->user_name),
                                           sizeof(userauth_account->user_name)))
            {
                snmp_free_varbind(vars);
                return FALSE;
            }

            /* binding userAuthPrivilege
             */
            if (!snmp_varlist_add_variable(&vars,
                                           ID_userAuthPrivilege,
                                           len_userAuthPrivilege,
                                           ASN_OCTET_STR,
                                           (u_char*)&(userauth_account->privilege),
                                           sizeof(userauth_account->privilege)))
            {
                snmp_free_varbind(vars);
                return FALSE;
            }

            break;
        }

        /* unrecognised event
         */
        default:
            TRAP_DEBUG_MODE_PRINT("%s(): Invalid trap type, trap_type = %lu.\n",
                                   __func__,(unsigned long)trap_data_p->trap_type);
            return FALSE;
    }

    /* send this trap
     */
    if (0 != netsnmp_send_traps(trap_type, specific, enterprise,
                                enterprise_length, vars, NULL, 0))
    {
        TRAP_DEBUG_MODE_PRINT("%s(): netsnmp_send_traps fail.\n", __func__);
    }

    snmp_free_varbind(vars);

    return TRUE;
}


#if 0
/*--------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_DeleteSnmpCommunityEntry
 *---------------------------------------------------------------------------
 * PURPOSE:  The funtion to delete the Rfc2576 Community MIB status.
 * INPUT:    comm_string_name, sec_name
 * OUTPUT:   none.
 * RETURN:   SNMP_ERR_CODE.
 * NOTE:     For SNMP Use only.
 *---------------------------------------------------------------------------
 */
static UI32_T SNMP_MGR_DeleteSnmpCommunityEntry(SNMP_MGR_SnmpCommunityEntry_T *entry)
{
    UI32_T  i;
    I32_T   available_entry = -1;
    UI32_T  return_val = FALSE;

    /* BODY */


    if (SYSFUN_GET_CSC_OPERATING_MODE() == SYS_TYPE_STACKING_SLAVE_MODE)
    {
        #if 0
        EH_MGR_Handle_Exception(SYS_MODULE_SNMP,
                                 0,
                                 EH_TYPE_MSG_NOT_IN_MASTER_MODE,
                                 (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR));
        #endif

        return SNMP_MGR_ERROR_FAIL;
    }



    for (i=0; i<SYS_ADPT_MAX_NBR_OF_SNMP_COMMUNITY_STRING; i++)
    {
        if (strcmp(entry->snmp_community_index, snmp_mgr_comm_entry[i].snmp_community_index)==0)
        {
            if (snmp_mgr_comm_entry[i].snmp_community_status == entry->snmp_community_status)//if specific entry already exist, and the status already the same as u want to set now, return false
            {
                i=SYS_ADPT_MAX_NBR_OF_SNMP_COMMUNITY_STRING;
                available_entry=-1;
            }
            else
            {
                available_entry = i;
            }
            break;
        }

        if (snmp_mgr_comm_entry[i].snmp_community_status == VAL_snmpCommunityStatus_destroy)
        {
            /* record the first empty entry.  When the entry is not existed, this
             * entry will be updated as the input.
             */
            if (available_entry == -1)
                available_entry = i;
            continue;
        }

        if (strcmp(entry->snmp_community_index, snmp_mgr_comm_entry[i].snmp_community_index)==0)
            break;
    }

    if (i == SYS_ADPT_MAX_NBR_OF_SNMP_COMMUNITY_STRING)
    {
        /* No found, create a new one, if no more available entry then return FALSE
         */
        if (available_entry != -1)
        {
            strcpy(snmp_mgr_comm_entry[available_entry].snmp_community_index,entry->snmp_community_index);
            strcpy(snmp_mgr_comm_entry[available_entry].snmp_community_name,entry->snmp_community_index);
            memset(snmp_mgr_comm_entry[available_entry].snmp_community_security_name, 0, SYS_ADPT_MAX_COMM_STR_NAME_LEN+1);
            SNMP_MGR_GetEngineID(snmp_mgr_comm_entry[available_entry].snmp_community_context_engine_id);
            strcpy(snmp_mgr_comm_entry[available_entry].snmp_community_context_name,"");
            strcpy(snmp_mgr_comm_entry[available_entry].snmp_community_transport_tag,"");
            snmp_mgr_comm_entry[available_entry].snmp_community_access_right = SNMP_MGR_ACCESS_RIGHT_READ_ONLY;
            snmp_mgr_comm_entry[available_entry].snmp_community_storage_type = VAL_snmpCommunityStorageType_nonVolatile;
            snmp_mgr_comm_entry[available_entry].snmp_community_status = VAL_snmpCommunityStatus_destroy;
            return_val = SNMP_MGR_ERROR_OK;
        }
        else
        {
            /* no available entry, can not create new entry
             */
            /*kinghong leave EH handler to implement later*/
            #if 0
            EH_MGR_Handle_Exception1(SYS_MODULE_SNMP,
                                 0,
                                 EH_TYPE_MSG_FAILED_TO_ADD,
                                 SYSLOG_LEVEL_ERR,
                                 ":no available entry");
            #endif
            return_val = SNMP_MGR_ERROR_FAIL;
        }
    }
    else
    {
        /* found an entry, update status.  By logically, it should be deleted.
         */
        snmp_mgr_comm_entry[available_entry].snmp_community_status = VAL_snmpCommunityStatus_destroy;
        /* default version set to 1 */
        strcpy(snmp_mgr_comm_entry[available_entry].snmp_community_name,entry->snmp_community_index);
        memset(snmp_mgr_comm_entry[available_entry].snmp_community_security_name, 0, SYS_ADPT_MAX_COMM_STR_NAME_LEN+1);
        SNMP_MGR_GetEngineID(snmp_mgr_comm_entry[available_entry].snmp_community_context_engine_id);
        strcpy(snmp_mgr_comm_entry[available_entry].snmp_community_context_name,"");
        strcpy(snmp_mgr_comm_entry[available_entry].snmp_community_transport_tag,"");
        snmp_mgr_comm_entry[available_entry].snmp_community_access_right = SNMP_MGR_ACCESS_RIGHT_READ_ONLY;
        snmp_mgr_comm_entry[available_entry].snmp_community_storage_type = VAL_snmpCommunityStorageType_nonVolatile;

        return_val = SNMP_MGR_ERROR_OK;
    }



    return return_val;
}
#endif

/* EXPORTED SUBPROGRAM BODIES
 */


#if 0 /* XXX steven.jiang for warnings */
/* ---------------------------------------------------------------------
 *  ROUTINE NAME  - SNMP_MGR_RifUp_CallBack
 * ---------------------------------------------------------------------
 * PURPOSE: this is a callBack function, for Rif to Notify trapmgmt when
 *          Rif get IP sucessfully
 * INPUT:    None.
 * OUTPUT:   None.
 * RETURN:   None.
 * NOTE:     None.
 * ---------------------------------------------------------------------
 */
static void SNMP_MGR_RifUp_CallBack(UI32_T ip_address, UI32_T ip_mask)
{
    UI32_T orig_priority;
    if (debug_mode)
        printf("SNMP_MGR_RifUp_CallBack..\n");

    up_rif_cnt ++;

}


/* ---------------------------------------------------------------------
 *  ROUTINE NAME  - SNMP_MGR_RifDown_CallBack
 * ---------------------------------------------------------------------
 * PURPOSE: this is a callBack function, for Rif to Notify trapmgmt when
 *          Rif get IP sucessfully
 * INPUT:    None.
 * OUTPUT:   None.
 * RETURN:   None.
 * NOTE:     None.
 * ---------------------------------------------------------------------
 */
static void SNMP_MGR_RifDown_CallBack(UI32_T ip_address, UI32_T ip_mask)
{
    UI32_T orig_priority;
    if (debug_mode)
        printf("SNMP_MGR_RifDown_CallBack..\n");


    up_rif_cnt--;

    if (up_rif_cnt < 0)
    {
        up_rif_cnt = 0;
    }


}


/* ---------------------------------------------------------------------
 *  ROUTINE NAME  - SNMP_MGR_QueueDequeue
 * ---------------------------------------------------------------------
 *  FUNCTION: remove a trap data block from queue
 *
 *  INPUT    : SNMP_MGR_Queue_T *q
 *  OUTPUT   : NONE.
 *  RETURN   : TRAP_EVENT_TrapData_T    *p  - if has element in the queue
 *             NULL             - no element in queue
 *  NOTE     : NONE.
 * ---------------------------------------------------------------------
 */
static TRAP_EVENT_TrapQueueData_T *SNMP_MGR_QueueDequeue(SNMP_MGR_Queue_T *trap_queue)
{
   /* LOCAL VARIABLE DECLARATIONS */
    TRAP_EVENT_TrapQueueData_T    *trap_data;
    UI32_T orig_priority;
    /* BODY */



    /* Queue is empty now!
     */
    if (trap_queue->front == (TRAP_EVENT_TrapQueueData_T *)NULL)
    {

        return NULL;
    }
    /* More items in the queue.
     */
    trap_data = trap_queue->front;             /* Return the first element */
    trap_queue->front = trap_data->next;        /* Move queue head to next element  */

    if (trap_queue->front == (TRAP_EVENT_TrapQueueData_T *)NULL)
    {
        trap_queue->rear = (TRAP_EVENT_TrapQueueData_T *)NULL;      /*  queue is empty */
    } /* End of if */
    trap_queue->que_elements_cnt--;
    trap_data->remainRetryTimes--;


    return trap_data;

} /* End of SNMP_MGR_QueueDequeue() */

/* ---------------------------------------------------------------------
 *  ROUTINE NAME  - SNMP_MGR_malloc
 * ---------------------------------------------------------------------
 *  FUNCTION: alloc memory
 *
 *  INPUT    : size
 *  OUTPUT   :
 *  RETURN   : pointer of allocated memory block
 *  NOTE     :
 * ---------------------------------------------------------------------
 */
static void *SNMP_MGR_malloc(size_t size)
{
    void *p;
    if ((p=L_MM_Malloc(size, L_MM_USER_ID2(SYS_MODULE_SNMP, SNMP_TYPE_TRACE_ID_SNMP_MGR_MALLOC)))!=NULL)
    {
        memory_used=memory_used+size;
        trapDataInQCnt++;
    }
    return p;
}

/* ---------------------------------------------------------------------
 *  ROUTINE NAME  - SNMP_MGR_free
 * ---------------------------------------------------------------------
 *  FUNCTION: free memory block
 *
 *  INPUT    : pointer of memory block to be free
 *  OUTPUT   :
 *  RETURN   :
 *  NOTE     :
 * ---------------------------------------------------------------------
 */
static void SNMP_MGR_free(void *ptr)
{
    memory_used = memory_used - (sizeof(TRAP_EVENT_TrapQueueData_T) + SNMP_MGR_GetDynamicDataSize(((TRAP_EVENT_TrapQueueData_T*)ptr)->trap_type));
    trapDataInQCnt--;
    L_MM_Free(ptr);
}

/* ---------------------------------------------------------------------
 *  ROUTINE NAME  - SNMP_MGR_BuildQueueData
 * ---------------------------------------------------------------------
 *  FUNCTION: alloc memory and build a trap queue data
 *
 *  INPUT    : TRAP_EVENT_TrapData_T     *p
 *  OUTPUT   :
 *  RETURN   : *TRAP_EVENT_TrapQueueData_T
 *  NOTE     :
 * ---------------------------------------------------------------------
 */
static TRAP_EVENT_TrapQueueData_T *SNMP_MGR_BuildQueueData(void *trapData)
{
    TRAP_EVENT_TrapQueueData_T                     *new_blk;
    UI32_T dynamicDataSize;

    dynamicDataSize=SNMP_MGR_GetDynamicDataSize(((TRAP_EVENT_TrapQueueData_T*)(trapData))->trap_type);
    new_blk = SNMP_MGR_malloc(sizeof(TRAP_EVENT_TrapQueueData_T)+dynamicDataSize);
    if (new_blk == NULL)
    {
        if (debug_mode)
            printf("TRAP_EVENT_TrapQueueData_T:alloc memory failure, new_blk\n");
        return NULL;
    }
    memcpy(new_blk,trapData,sizeof(TRAP_EVENT_TrapQueueData_T));//copy the fix data
    memcpy(new_blk->dynamicData,&(((TRAP_EVENT_TrapData_T*)(trapData))->u), dynamicDataSize);//copy dynamic data Part
    return new_blk;
}

/* ---------------------------------------------------------------------
 *  ROUTINE NAME  - SNMP_MGR_QueueEnqueue
 * ---------------------------------------------------------------------
 *  FUNCTION: add a trap data block to queue and send a event to trap
 *            task notify a send trap request in the queue.
 *
 *  INPUT    : TRAP_EVENT_TrapData_T     *p
 *             SNMP_MGR_Queue_T *q
 *  OUTPUT   : NONE.
 *  RETURN   : NONE.
 *  NOTE     : This procedure shall not be invoked before L_MEM_Init() is called.
 * ---------------------------------------------------------------------
 */
static BOOL_T SNMP_MGR_QueueEnqueue(TRAP_EVENT_TrapQueueData_T *qData, SNMP_MGR_Queue_T *q)
{
   /* LOCAL VARIABLE DECLARATIONS */
    UI32_T orig_priority;
   /* BODY */

    if (qData == NULL)
    {
        #if (SYS_CPNT_EH == TRUE)
                EH_MGR_Handle_Exception(SYS_MODULE_SNMP,
                                         0,
                                         EH_TYPE_MSG_NULL_POINTER,
                                         (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_CRIT));
        #endif/*end of #if (SYS_CPNT_EH == TRUE)*/

        if (debug_mode)
            printf("FUNCTION:SNMP_MGR_QueueEnqueue; DESC:qData=NULL\n");
        return FALSE;
    } /* End of if */

    if (q == NULL)
    {
        #if (SYS_CPNT_EH == TRUE)
                EH_MGR_Handle_Exception(SYS_MODULE_SNMP,
                                         0,
                                         EH_TYPE_MSG_NULL_POINTER,
                                         (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_CRIT));
        #endif/*end of #if (SYS_CPNT_EH == TRUE)*/

        if (debug_mode)
            printf("FUNCTION:SNMP_MGR_QueueEnqueue; DESC:q=NULL\n");
        return FALSE;
    } /* End of if */

    /* Should not takes up more then SNMP_MGR_MAX_QUE_CNT trap data in the dynamic queue.
       This is to prevent snmp_mgr allocate too much system memory in the future.
     */
    if (q->que_elements_cnt >= SNMP_MGR_MAX_QUE_CNT)
    {
        #if (SYS_CPNT_EH == TRUE)
                EH_MGR_Handle_Exception1(SYS_MODULE_SNMP,
                                         0,
                                         EH_TYPE_MSG_DEB_MSG,
                                         (EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR),
                                         "too many traps");
        #endif/*end of #if (SYS_CPNT_EH == TRUE)*/

        if (debug_mode)
            printf("FUNCTION:SNMP_MGR_QueueEnqueue; DESC:too many traps\n");
        SNMP_MGR_free(qData);
        return FALSE;
     }


    if(SYSFUN_SendEvent(snmp_taskId, SNMP_MGR_EVENT_TRAP_ARRIVAL)!= SYSFUN_OK)
    {
        if (debug_mode)
            printf("FUNCTION:SNMP_MGR_QueueEnqueue; DESC:SYSFUN_SendEvent failure\n");
        SNMP_MGR_free(qData);

        return FALSE;
    }

    if (q->rear == (TRAP_EVENT_TrapQueueData_T *)NULL )   /* empty queue */
    {
        q->rear = qData;
        q->front = qData;
        qData->next = (TRAP_EVENT_TrapQueueData_T *)NULL;
    }
    else
    {
        q->rear->next = qData;
        q->rear = qData;
        qData->next = (TRAP_EVENT_TrapQueueData_T *)NULL;

    } /* End of if */
    q->que_elements_cnt++;


    return TRUE;

} /* End of SNMP_MGR_QueueEnqueue() */

#endif /* 0 */

/* Suspicious architecture:
 * "SNMP_MGR_CheckTrapSend" appears in "snmp_mgr.c" but not "snmp_mgr.h".
 * Function "send_notifications" in "snmpNotifyTable.c" calls
 * "SNMP_MGR_CheckTrapSend" in "snmp_mgr.c".
 * If third-party code is not allowed to call Accton code, this
 * function will be rewritten and moved away.
 */
/* ---------------------------------------------------------------------------
 *  ROUTINE NAME  - SNMP_MGR_CheckTrapSend
 * ---------------------------------------------------------------------------
 *  FUNCTION: This function will check if the trap need to send according to the
 *            notify view. in v1/v2c model, we will use community as a group name
 *            and in v3 model, we will use the securityName as a group name.
 *            We will use the group name to associate the notifyview, and check
 *            if the notifyview need to send this trap.
 *            The second check is checking the snmpNotifyFilterEntry and see if any
 *            filter is here and passed the trap send.
 *
 *  INPUT    : *sess, trap_type, specific_type, *enterprise, enterprise_length,
 *             targetparamsname
 *  OUTPUT   : None.
 *  RETURN   : TRUE/FALSE.
 *  NOTE     : None.
 * ---------------------------------------------------------------------------
 */
BOOL_T SNMP_MGR_CheckTrapSend(netsnmp_session *sess, UI32_T trap_type, UI32_T specific_type,
    UI32_T *enterprise, UI32_T enterprise_length, char *targetparamsname, UI32_T pdu_type)
{
    oid trap_oid[SYS_ADPT_MAX_OID_COUNT];
    UI32_T trap_oid_len;

    SNMP_MGR_CHECK_OPER_MODE(FALSE);

    /* define a OID according to the trap_type and specific_type
     */
    switch (trap_type)
    {
        case SNMP_TRAP_COLDSTART:
            memcpy(trap_oid, snmp_mgr_cold_start_oid, len_snmp_mgr_cold_start_oid * sizeof(oid));
            trap_oid_len = len_snmp_mgr_cold_start_oid;
            break;

        case SNMP_TRAP_WARMSTART:
            memcpy(trap_oid, snmp_mgr_warm_start_oid, len_snmp_mgr_warm_start_oid * sizeof(oid));
            trap_oid_len = len_snmp_mgr_warm_start_oid;
            break;

        case SNMP_TRAP_LINKDOWN:
            memcpy(trap_oid, snmp_mgr_link_down_oid, len_snmp_mgr_link_down_oid * sizeof(oid));
            trap_oid_len = len_snmp_mgr_link_down_oid;
            break;

        case SNMP_TRAP_LINKUP:
            memcpy(trap_oid, snmp_mgr_link_up_oid, len_snmp_mgr_link_up_oid * sizeof(oid));
            trap_oid_len = len_snmp_mgr_link_up_oid;
            break;

        case SNMP_TRAP_AUTHFAIL:
            memcpy(trap_oid, snmp_mgr_auth_fail_oid, len_snmp_mgr_auth_fail_oid * sizeof(oid));
            trap_oid_len = len_snmp_mgr_auth_fail_oid;
            break;

        case SNMP_TRAP_ENTERPRISESPECIFIC:
            memcpy(trap_oid, enterprise, enterprise_length * sizeof(oid));

            /* The real trap OID = enterprise ID.0(xxxxTrapPrefixs).specific_type
             */
            trap_oid[enterprise_length] = 0;
            trap_oid[enterprise_length + 1]= specific_type;
            trap_oid_len = enterprise_length + 2;
            break;

        default:
            return FALSE;
    }

    /* We have 2 place to check if a trap can be send.
     *
     * Process 1: Checking the snmpNotifyFilterProfileTable, and snmpNotifyFilterProfileEntry
     * For every snmpTargetParamsTable, if no such index in snmpNotifyFilterProfileTable,
     * then no filter is perform and thus passed the check, otherwise, need to
     * check the snmpNotifyFilterTable for futher check and see if the desired
     * sent TRAP OID is within the snmpNotifyFilterTable.
     */
    if (FALSE == SNMP_MGR_IsNotifyFilterAllowToSendTrap(targetparamsname, trap_oid, trap_oid_len))
    {
        return FALSE;
    }

    /* Process 2:
     * For V1/V2c Model, we start search from snmpCommunityEntry, then SecurityToGroup Table
     * vacmAccessTable, then know the correspoing notify view, we will check if
     * the desired sent TRAP OID is within this OID.
     * For V3 Model, similar to V1/V2c Model, but start search from usmUserEntry.
     */
    if (FALSE == SNMP_MGR_IsVacmOrUsmAllowToSendTrap(sess, trap_oid, trap_oid_len, pdu_type))
    {
        return FALSE;
    }

    return TRUE;
}


/* ---------------------------------------------------------------------------
 *  ROUTINE NAME  - SNMP_MGR_Marked_Inform_Request_Socket
 * ---------------------------------------------------------------------------
 *  FUNCTION: This function is used to mark the correpsonding sock num to whether
 *            available or not.
 *
 *  INPUT    : infrom_sock_num -- socket_id;  flag--- available or not
 *  OUTPUT   : None.
 *  RETURN   : TRUE/FALSE.
 *  NOTE     : None.
 * ---------------------------------------------------------------------------
 */
BOOL_T SNMP_MGR_Marked_Inform_Request_Socket( UI32_T inform_sock_num, BOOL_T flag)
{
    SNMP_MGR_CHECK_OPER_MODE(FALSE);
    SNMP_TASK_Marked_Inform_Request_Socket(inform_sock_num, flag);

    return TRUE;
}


/* ---------------------------------------------------------------------------
 *  ROUTINE NAME  - SNMP_MGR_GetAvailableInformSocket
 * ---------------------------------------------------------------------------
 *  FUNCTION: This function is used to get the available inform/trap socket.
 *
 *  INPUT    : None.
 *  OUTPUT   : None.
 *  RETURN   : the avaialble socket id, -1 is none available.
 *  NOTE     : None.
 * ---------------------------------------------------------------------------
 */
I32_T SNMP_MGR_GetAvailableInformSocket()
{
    int ret;
    UI32_T orig_priority;
    SNMP_MGR_CHECK_OPER_MODE(-1);

    ret= SNMP_TASK_GetAvailableInformSocket();


    return ret;
}

/* ---------------------------------------------------------------------------
 *  ROUTINE NAME  - SNMP_MGR_IsTrapReadyToSend
 * ---------------------------------------------------------------------------
 *  FUNCTION : Test whether the delay time for sending trap is expired or not.
 *
 *  INPUT    : None.
 *  OUTPUT   : None.
 *  RETURN   : TRUE/FALSE.
 *  NOTE     : None.
 * ---------------------------------------------------------------------------
 */
static BOOL_T SNMP_MGR_IsTrapReadyToSend(void)
{
    UI32_T current_time = 0;

    SYS_TIME_GetRealTimeBySec(&current_time);

    return (   (   (0 < time_to_send_trap_from_spanning_tree)
                && (current_time >= time_to_send_trap_from_spanning_tree)
                )
            || (   (0 < time_to_send_trap_from_prov_complete)
                && (current_time >= time_to_send_trap_from_prov_complete)
                )
            );
}

/* ---------------------------------------------------------------------------
 *  ROUTINE NAME  - SNMP_MGR_CheckTrapEvent
 * ---------------------------------------------------------------------------
 *  FUNCTION: This function is ported from TRAP_MGR_TASK, we will check if there
 *            is any event and send the trap if any.
 *
 *  INPUT    : None.
 *  OUTPUT   : None.
 *  RETURN   : None.
 *  NOTE     : None.
 * ---------------------------------------------------------------------------
 */
void SNMP_MGR_CheckTrapEvent(void)
{
    static UI32_T keep_event = 0, ret = 0;
    UI32_T event;
    UI32_T trap_entries;
    BOOL_T status = SYS_DFLT_SNMP_AGENT_STATUS;

    trap_entries = SNMP_MGR_GetShmTrapQueueEntryCount(shm_trap_queue);

    ret = SYSFUN_ReceiveEvent((SNMP_MGR_EVENT_TRAP_ARRIVAL | SNMP_MGR_EVENT_ENTER_TRANSITION),
        SYSFUN_EVENT_WAIT_ANY, SYSFUN_TIMEOUT_NOWAIT,
        &event);

    if(ret != SYSFUN_OK)
    {
        if (debug_mode)
        {
            printf("%s: SYSFUN_ReceiveEvent:%ld != SYSFUN_OK\r\n", __FUNCTION__, (long)ret);
        }
    }

    keep_event |= event;

    SNMP_MGR_Get_AgentStatus(&status);

    if (keep_event & SNMP_MGR_EVENT_ENTER_TRANSITION)
    {
        if ((TRUE == SNMP_MGR_HasRouteToTrapServer())
            && (TRUE == status))
        {
            while (SNMP_MGR_NTRAPS == SNMP_MGR_HandleTrapQueue(SNMP_MGR_NTRAPS));
        }
        else
        {
            SNMP_MGR_ClearTrapQueue();
        }

        flush_trap_queue_done_flag = TRUE;
        keep_event ^= SNMP_MGR_EVENT_ENTER_TRANSITION;
    }


    if ((keep_event & SNMP_MGR_EVENT_TRAP_ARRIVAL) || trap_entries)
    {
#if (SYS_CPNT_CLUSTER == TRUE)
        if (SNMP_CLUSTER_GetClusterRole() == CLUSTER_TYPE_ACTIVE_MEMBER)
        {
            if (FALSE == SNMP_MGR_HasRouteToClusterCommander())
            {
                SNMP_MGR_LogTraps();
                return;
            }
        }
        else
#endif

        if (FALSE == SNMP_MGR_IsTrapReadyToSend())
        {
            SNMP_MGR_LogTraps();
            return;
        }

        if (FALSE == SNMP_MGR_HasRouteToTrapServer())
        {
            SNMP_MGR_LogTraps();
            return;
        }

        if (FALSE == status)
        {
            SNMP_MGR_LogTraps();
            return;
        }

        SNMP_MGR_HandleTrapQueue(SNMP_MGR_NTRAPS);
        if (0 >= SNMP_MGR_GetShmTrapQueueEntryCount(shm_trap_queue))
        {
            keep_event ^= SNMP_MGR_EVENT_TRAP_ARRIVAL;
        }
    }
} /* End of SNMP_MGR_CheckTrapEvent() */

#if (SYS_CPNT_SW_WATCHDOG_TIMER == TRUE)
/* ---------------------------------------------------------------------------
 *  ROUTINE NAME  - SNMP_MGR_CheckSoftwareWatchdogEvent
 * ---------------------------------------------------------------------------
 *  FUNCTION: This function is used to check and response to software watchdog
 *            event.
 *
 *  INPUT    : None.
 *  OUTPUT   : None.
 *  RETURN   : None.
 *  NOTE     : None.
 * ---------------------------------------------------------------------------
 */
void SNMP_MGR_CheckSoftwareWatchdogEvent(void)
{
    UI32_T rc;
    UI32_T event=0;

    rc=SYSFUN_ReceiveEvent(SYSFUN_SYSTEM_EVENT_SW_WATCHDOG,
        SYSFUN_EVENT_WAIT_ANY, SYSFUN_TIMEOUT_NOWAIT,
        &event);

    if(rc!=SYSFUN_OK && rc!=SYSFUN_RESULT_TIMEOUT)
    {
        if (debug_mode)
        {
            printf("%s: SYSFUN_ReceiveEvent Error (ret=%lu) \r\n", __FUNCTION__, (unsigned long)rc);
        }
    }
    if (event & SYSFUN_SYSTEM_EVENT_SW_WATCHDOG)
    {
         SW_WATCHDOG_MGR_ResetTimer(SW_WATCHDOG_SNMP);
         event ^= SYSFUN_SYSTEM_EVENT_SW_WATCHDOG;
    }
}
#endif

/* ---------------------------------------------------------------------------
 *  ROUTINE NAME  - SNMP_MGR_SendColdStartTrap
 * ---------------------------------------------------------------------------
 *  FUNCTION:
 *  INPUT    : None.
 *  OUTPUT   : None.
 *  RETURN   : None.
 *  NOTE     : None.
 * ---------------------------------------------------------------------------
 */
static void SNMP_MGR_SendColdStartTrap()
{
    /* LOCAL VARIABLE DECLARATIONS */
    TRAP_EVENT_TrapData_T       cold_start_trap;
    /* BODY */

    /* Request to send cold start trap
     * Note: This request must be sent early than any other traps!
     */
    cold_start_trap.trap_type = TRAP_EVENT_COLD_START;
    cold_start_trap.community_specified = FALSE;
    SNMP_MGR_ReqSendTrap(&cold_start_trap);
    return;

} /* end of SNMP_MGR_SendColdStartTrap() */

/* ---------------------------------------------------------------------------
 *  ROUTINE NAME  - SNMP_MGR_SendWarmStartTrap
 * ---------------------------------------------------------------------------
 *  FUNCTION:
 *  INPUT    : None.
 *  OUTPUT   : None.
 *  RETURN   : None.
 *  NOTE     : None.
 * ---------------------------------------------------------------------------
 */
static void SNMP_MGR_SendWarmStartTrap()
{
    /* LOCAL VARIABLE DECLARATIONS */
    TRAP_EVENT_TrapData_T       warm_start_trap;
    /* BODY */

    /* Request to send cold start trap
     * Note: This request must be sent early than any other traps!
     */
    warm_start_trap.trap_type = TRAP_EVENT_WARM_START;
    warm_start_trap.community_specified = FALSE;
    SNMP_MGR_ReqSendTrap(&warm_start_trap);
    return;

} /* end of SNMP_MGR_SendWarmStartTrap() */

/* ---------------------------------------------------------------------------
 *  ROUTINE NAME  - SNMP_MGR_ClearTrapQueue
 * ---------------------------------------------------------------------------
 *  FUNCTION:
 *  INPUT    : None.
 *  OUTPUT   : None.
 *  RETURN   : None.
 *  NOTE     : None.
 * ---------------------------------------------------------------------------
 */
#if 0
static void SNMP_MGR_ClearTrapQueue(void)
{
    TRAP_EVENT_TrapQueueData_T     *trap_data;
    if (debug_mode)
         printf("SNMP_MGR_ClearTrapQueue\n");
    while ((trap_data = SNMP_MGR_QueueDequeue(&trap_queue)) != NULL)
    {
        SNMP_MGR_free(trap_data);
    }
    return;
}

#else

static void
SNMP_MGR_ClearTrapQueue(void)
{
    SNMP_MGR_ShmTrapQueueReset(shm_trap_queue);
}

#endif

/* ---------------------------------------------------------------------------
 *  ROUTINE NAME  - SNMP_MGR_LogLinkUpDownTrap
 * ---------------------------------------------------------------------------
 *  FUNCTION : Log the log for a link up/down trap.
 *  INPUT    : trap_type    -- Link up/down type.
 *             ifindex      -- Ifindex.
 *             admin_status -- Admin status.
 *             oper_status  -- Operation status.
 *  OUTPUT   : None.
 *  RETURN   : None.
 *  NOTE     : None.
 * ---------------------------------------------------------------------------
 */
static void SNMP_MGR_LogLinkUpDownTrap(UI32_T trap_type, UI32_T ifindex,
    UI32_T admin_status, UI32_T oper_status)
{
    TRAP_EVENT_TrapData_T   trap_data;
    TRAP_EVENT_LinkTrap_T   *link_up_down_data_p;

    trap_data.trap_type = trap_type;
    link_up_down_data_p = (TRAP_EVENT_LinkTrap_T *)&trap_data.u;

    link_up_down_data_p->ifindex = ifindex;
    link_up_down_data_p->adminstatus = admin_status;
    link_up_down_data_p->operstatus = oper_status;
    link_up_down_data_p->instance_ifindex = ifindex;
    link_up_down_data_p->instance_adminstatus = ifindex;
    link_up_down_data_p->instance_operstatus = ifindex;

    SNMP_MGR_TrapALog(&trap_data);
}

/* ---------------------------------------------------------------------------
 *  ROUTINE NAME  - SNMP_MGR_LogLinkStateTrap
 * ---------------------------------------------------------------------------
 *  FUNCTION : Log all logs in the link-state trap.
 *  INPUT    : link_state_trap_p    -- Link-state trap.
 *  OUTPUT   : None.
 *  RETURN   : TRUE/FALSE.
 *  NOTE     : None.
 * ---------------------------------------------------------------------------
 */
static BOOL_T SNMP_MGR_LogLinkStateTrap(
    TRAP_EVENT_TrapData_T *link_state_trap_p)
{
    UI32_T                      ifindex;
    TRAP_EVENT_LinkStateTrap_T  *link_state_data_p;
    IF_BITMAP_T                 tmp_if_bitmap;
    UI32_T                      if_count;

    if (NULL == link_state_trap_p)
    {
        return FALSE;
    }

    link_state_data_p = (TRAP_EVENT_LinkStateTrap_T *)&link_state_trap_p->u;
    memcpy(&tmp_if_bitmap, &link_state_data_p->if_bitmap, sizeof(tmp_if_bitmap));

    TRAP_DEBUG_MODE_PRINT(
        "%s(): link state change, real %lu, if_start %d, if_count %d, bitmap flag %d\n",
        __func__, (unsigned long)link_state_data_p->real_type, tmp_if_bitmap.if_start,
            (int)IF_BITMAP_IFCOUNT(tmp_if_bitmap.if_count),
            (IF_BITMAP_IS_MAPPED(tmp_if_bitmap.if_count) ? 1 : 0));

    if_count = IF_BITMAP_IFCOUNT(tmp_if_bitmap.if_count);
    if (0 == tmp_if_bitmap.if_count)
    {
        return FALSE;
    }

    if (IF_BITMAP_IS_MAPPED(tmp_if_bitmap.if_count))
    {
        /* bit-mapped interfaces
         */
        UI32_T  i;
        BOOL_T  is_found = FALSE;

        for (i = 0; i < (if_count * 8); i++)
        {
            if (tmp_if_bitmap.if_array[i / 8] & (1 << (i % 8)))
            {
                ifindex = tmp_if_bitmap.if_start + i;
                SNMP_MGR_LogLinkUpDownTrap(link_state_data_p->real_type,
                    ifindex, link_state_data_p->admin_status,
                    link_state_data_p->oper_status);
            }
        }

        if (FALSE == is_found)
        {
            return FALSE;
        }
    }
    else
    {
        /* continous interfaces
         */
        UI32_T i;

        for (i = 0; i < tmp_if_bitmap.if_count; i++)
        {
            ifindex = tmp_if_bitmap.if_start + i;

            SNMP_MGR_LogLinkUpDownTrap(link_state_data_p->real_type, ifindex,
                link_state_data_p->admin_status,
                link_state_data_p->oper_status);
        }
    }

    return TRUE;
}

/* ---------------------------------------------------------------------------
 *  ROUTINE NAME  - SNMP_MGR_GenerateALinkUpDownTrapFromLinkStateTrap
 * ---------------------------------------------------------------------------
 *  FUNCTION : Extract from link-state trap and made as an link up/down trap.
 *  INPUT    : link_state_trap_p    -- Link-state trap.
 *  OUTPUT   : link_up_down_trap_p  -- Extracted link up/down trap.
 *  RETURN   : TRUE/FALSE.
 *  NOTE     : None.
 * ---------------------------------------------------------------------------
 */
static BOOL_T SNMP_MGR_GenerateALinkUpDownTrapFromLinkStateTrap(
    TRAP_EVENT_TrapData_T *link_state_trap_p,
    TRAP_EVENT_TrapData_T *link_up_down_trap_p)
{
    UI32_T                      ifindex;
    TRAP_EVENT_LinkStateTrap_T  *link_state_data_p;
    TRAP_EVENT_LinkTrap_T       *link_up_down_data_p;
    IF_BITMAP_T                 *if_bitmap_p;
    UI32_T                      if_count;

    if (   (NULL == link_state_trap_p)
        || (NULL == link_up_down_trap_p)
        )
    {
        return FALSE;
    }

    link_state_data_p = (TRAP_EVENT_LinkStateTrap_T *)&link_state_trap_p->u;
    if_bitmap_p = &link_state_data_p->if_bitmap;

    TRAP_DEBUG_MODE_PRINT(
            "%s(): link state change, real %lu, if_start %d, if_count %d, bitmap flag %d\n",
        __func__, (unsigned long)link_state_data_p->real_type, if_bitmap_p->if_start,
            (int)IF_BITMAP_IFCOUNT(if_bitmap_p->if_count),
            (IF_BITMAP_IS_MAPPED(if_bitmap_p->if_count) ? 1 : 0));

    if_count = IF_BITMAP_IFCOUNT(if_bitmap_p->if_count);
    if (0 == if_bitmap_p->if_count)
    {
        return FALSE;
    }

    if (IF_BITMAP_IS_MAPPED(if_bitmap_p->if_count))
    {
        /* bit-mapped interfaces
         */
        UI32_T  i;
        BOOL_T  is_found = FALSE;

        for (i = 0; i < (if_count * 8); i++)
        {
            if (if_bitmap_p->if_array[i / 8] & (1 << (i % 8)))
            {
                ifindex = if_bitmap_p->if_start + i;
                if_bitmap_p->if_array[i / 8] = if_bitmap_p->if_array[i / 8] &
                    ~(1 << (i % 8));

                is_found = TRUE;
                break;
            }
        }

        if (FALSE == is_found)
        {
            return FALSE;
        }
    }
    else
    {
        /* continous interfaces
         */
        ifindex = if_bitmap_p->if_start;
        if_bitmap_p->if_count--;
        if_bitmap_p->if_start++;
    }

    link_up_down_trap_p->trap_type = link_state_data_p->real_type;
    link_up_down_data_p = (TRAP_EVENT_LinkTrap_T *)&link_up_down_trap_p->u;
    link_up_down_data_p->adminstatus = link_state_data_p->admin_status;
    link_up_down_data_p->operstatus = link_state_data_p->oper_status;
    link_up_down_data_p->ifindex = ifindex;
    link_up_down_data_p->instance_ifindex = ifindex;
    link_up_down_data_p->instance_adminstatus = ifindex;
    link_up_down_data_p->instance_operstatus = ifindex;

    return TRUE;
}

/* ---------------------------------------------------------------------------
 *  ROUTINE NAME  - SNMP_MGR_IsLinkStateTrapEmpty
 * ---------------------------------------------------------------------------
 *  FUNCTION : Check whether the link state trap is empty or not.
 *  INPUT    : trap_data_p  -- Link-state trap.
 *  OUTPUT   : None.
 *  RETURN   : TRUE/FALSE.
 *  NOTE     : None.
 * ---------------------------------------------------------------------------
 */
static BOOL_T SNMP_MGR_IsLinkStateTrapEmpty(
    TRAP_EVENT_TrapData_T *trap_data_p)
{
    TRAP_EVENT_LinkStateTrap_T  *link_state_data_p;
    IF_BITMAP_T                 *if_bitmap_p;

    if (NULL == trap_data_p)
    {
        return FALSE;
    }

    link_state_data_p = (TRAP_EVENT_LinkStateTrap_T *)&trap_data_p->u;
    if_bitmap_p = &link_state_data_p->if_bitmap;

    if (IF_BITMAP_IS_MAPPED(if_bitmap_p->if_count))
    {
        /* bit-mapped interfaces
         */
        UI32_T  i;
        BOOL_T  is_found = FALSE;
        UI32_T  if_count = IF_BITMAP_IFCOUNT(if_bitmap_p->if_count);

        for (i = 0; i < (if_count * 8); i++)
        {
            if (if_bitmap_p->if_array[i / 8] & (1 << (i % 8)))
            {
                is_found = TRUE;
                break;
            }
        }

        return (FALSE == is_found);
    }
    else
    {
        return (if_bitmap_p->if_count <= 0);
    }
}

/* ---------------------------------------------------------------------------
 *  ROUTINE NAME  - SNMP_MGR_HandleTrapQueue
 * ---------------------------------------------------------------------------
 *  FUNCTION : Process specified number of traps from queue.
 *  INPUT    : trap_num -- Number of traps will to process.
 *  OUTPUT   : None.
 *  RETURN   : Number of traps be processed.
 *  NOTE     : None.
 * ---------------------------------------------------------------------------
 */
static UI32_T SNMP_MGR_HandleTrapQueue(UI32_T trap_num)
{
    TRAP_EVENT_TrapData_T   trap;
    UI32_T                  processed_trap_num = 0;

    if (!shm_trap_queue)
    {
        shm_trap_queue = SNMP_MGR_GetShmTrapQueue();
    }

    if (!SNMP_MGR_SHM_TRAP_QUEUE_IS_VALID(shm_trap_queue))
    {
        TRAP_DEBUG_MODE_PRINT("%s(): Trap queue is invalid.\n",__func__);
        return 0;
    }

    while (0 < trap_num)
    {
        int                         read_trap_num;
        TRAP_EVENT_TrapData_T       *trap_data_p;
        TRAP_EVENT_TrapData_T       link_up_down_trap;
        UI8_T                       org_trap_flag;
        UI8_T                       new_trap_flag;
        BOOL_T                      ret;
        BOOL_T                      is_enqeue_again;

        read_trap_num = SNMP_MGR_ShmTrapQueueRead(shm_trap_queue, &trap, 1, 0);

        if (0 >= read_trap_num)
        {
            break;
        }

        TRAP_DEBUG_MODE_PRINT("%s(): SNMP_MGR_ShmTrapQueueRead, read_trap_num = %d\n", __func__, read_trap_num);

        org_trap_flag = trap.flag;
        if (org_trap_flag & SNMP_MGR_SHM_TRAP_QUEUE_ENTRY_LOG_ONLY)
        {
            trap.flag = new_trap_flag = TRAP_EVENT_SEND_TRAP_OPTION_LOG_ONLY;
        }
        else if (org_trap_flag & SNMP_MGR_SHM_TRAP_QUEUE_ENTRY_LOG_AND_TRAP)
        {
            trap.flag = new_trap_flag = TRAP_EVENT_SEND_TRAP_OPTION_LOG_AND_TRAP;
        }
        else if (org_trap_flag & SNMP_MGR_SHM_TRAP_QUEUE_ENTRY_TRAP_ONLY)
        {
            trap.flag = new_trap_flag = TRAP_EVENT_SEND_TRAP_OPTION_TRAP_ONLY;
        }
        else
        {
            TRAP_DEBUG_MODE_PRINT("%s(): Wrong trap flag\n", __func__);

            return 0;
        }

        if (org_trap_flag & SNMP_MGR_SHM_TRAP_QUEUE_ENTRY_LOGGED)
        {
            new_trap_flag |= SNMP_MGR_SHM_TRAP_QUEUE_ENTRY_LOGGED;
        }

        if (TRAP_EVENT_LINK_STATE == trap.trap_type)
        {
            if (FALSE == SNMP_MGR_GenerateALinkUpDownTrapFromLinkStateTrap(
                &trap, &link_up_down_trap))
            {
                trap_num--;
                processed_trap_num++;
                continue;
            }

            /* Link-state trap represents a group of link up/down traps so that
             * we use the extracted link up/down trap to send trap/log instead
             * of link-state trap itself.
             */
            trap_data_p = &link_up_down_trap;
        }
        else
        {
            trap_data_p = &trap;
        }

        if (!(org_trap_flag & SNMP_MGR_SHM_TRAP_QUEUE_ENTRY_LOGGED))
        {
            new_trap_flag |= SNMP_MGR_SHM_TRAP_QUEUE_ENTRY_LOGGED;
            SNMP_MGR_TrapLog(trap_data_p);
        }

        ret = SNMP_MGR_SendTrap(trap_data_p);

        is_enqeue_again = FALSE;

        if (FALSE == ret)
        {
            TRAP_DEBUG_MODE_PRINT("%s(): send trap failed\n", __func__);

            if (trap.remainRetryTimes > 0)
            {
                trap.remainRetryTimes--;
                is_enqeue_again = TRUE;
            }
            else
            {
                TRAP_DEBUG_MODE_PRINT("%s(): trap (type %lu) discarded\n", __func__, (unsigned long)trap.trap_type);
            }
        }

        if (   (TRUE == ret)
            && (TRAP_EVENT_LINK_STATE == trap.trap_type)
            && (FALSE == SNMP_MGR_IsLinkStateTrapEmpty(&trap))
            )
        {
            is_enqeue_again = TRUE;
        }

        if (TRUE == is_enqeue_again)
        {
            trap.flag = new_trap_flag;
            if (SNMP_MGR_ShmTrapQueueWrite(shm_trap_queue, &trap, 0) < 0)
            {
                TRAP_DEBUG_MODE_PRINT("%s(): re-enqueue trap failed\n", __func__);
            }
        }

        processed_trap_num++;
        trap_num--;
    }

    return processed_trap_num;
}

static int
SNMP_MGR_LogTraps(void)
{
    TRAP_EVENT_TrapData_T trap_data;

    if (!shm_trap_queue) {
        shm_trap_queue = SNMP_MGR_GetShmTrapQueue();
    }

    if (0 >= SNMP_MGR_ShmTrapQueueGetUnloggedEntries(shm_trap_queue, &trap_data, 1))
    {
        return 0;
    }

    SNMP_MGR_TrapLog(&trap_data);

    /* Unnecessary to enqueue again because
     * SNMP_MGR_ShmTrapQueueGetUnloggedEntries immediately append the flag of
     * the trap with SNMP_MGR_SHM_TRAP_QUEUE_ENTRY_LOGGED already.
     */

    return 1;
}

/* ---------------------------------------------------------------------
 * ROUTINE NAME  - SNMP_MGR_TrapLog
 * ---------------------------------------------------------------------
 * PURPOSE: This function will call system log to store all trap request
 *          information to RAM before trap socket is process.
 * INPUT : None
 * OUTPUT: None
 * RETURN: None
 * NOTES : None
 * ---------------------------------------------------------------------
 */
static void SNMP_MGR_TrapLog(TRAP_EVENT_TrapData_T  *trap_data)
{
    if (TRAP_EVENT_LINK_STATE == trap_data->trap_type)
    {
        SNMP_MGR_LogLinkStateTrap(trap_data);
    }
    else
    {
        SNMP_MGR_TrapALog(trap_data);
    }
}

/* ---------------------------------------------------------------------
 * ROUTINE NAME  - SNMP_MGR_TrapALog
 * ---------------------------------------------------------------------
 * PURPOSE: This function will call system log to store all trap request
 *          information to RAM before trap socket is process.
 * INPUT : None
 * OUTPUT: None
 * RETURN: None
 * NOTES : None
 * ---------------------------------------------------------------------
 */
static void
SNMP_MGR_TrapALog(
    TRAP_EVENT_TrapData_T  *trap_data)
{
    UI32_T                          iftype, unit, port, trunk_id,vid;
    SYSLOG_OM_RecordOwnerInfo_T     owner_info;
    #if (SYS_CPNT_EH == TRUE)
        UI32_T module_id;
        UI32_T function_no;
        UI32_T msg_flag;
        UI8_T  ehmsg[256];
    #endif/*end of #if (SYS_CPNT_EH == TRUE)*/

    if(trap_data->flag == TRAP_EVENT_SEND_TRAP_OPTION_TRAP_ONLY)
    {
        TRAP_DEBUG_MODE_PRINT("%s-%d DESC:send trap only: type=[%lu]\r\n", __FUNCTION__, __LINE__, (unsigned long)trap_data->trap_type);
        return;
    }

    TRAP_DEBUG_MODE_PRINT("%s(): trap type %lu, trap time %lu\n",
                           __func__, (unsigned long)trap_data->trap_type, (unsigned long)trap_data->trap_time);

    /* BODY */
    owner_info.level = SYSLOG_LEVEL_INFO;
    owner_info.module_no = SYS_MODULE_SNMP;
    owner_info.function_no = SNMP_MGR_FUNCTION_NUMBER;
    owner_info.error_no = SNMP_MGR_ERROR_NUMBER;

    /* dispatch event
     */
    switch (trap_data->trap_type)
    {
        /* five of the Six Early Traps (no enterprise)
         */
        case TRAP_EVENT_COLD_START:
            SYSLOG_PMGR_AddFormatMsgEntry(&owner_info, SYSTEM_COLDSTART_MESSAGE_INDEX, 0, 0, 0);
            break;

        case TRAP_EVENT_WARM_START:
            SYSLOG_PMGR_AddFormatMsgEntry(&owner_info, SYSTEM_WARMSTART_MESSAGE_INDEX, 0, 0, 0);
            break;

        /* Accton private MIB
         */
#if (SYS_CPNT_ALARM_DETECT == TRUE)
        case TRAP_EVENT_MAJOR_ALARM:
            if (trap_data->u.alarmMgt.alarmObjectType == VAL_alarmMajorType_powerModuleFailure)
                SYSLOG_PMGR_AddFormatMsgEntry(&owner_info, MAJOR_ALARM_POWER_STATUS_CHANGED_INDEX,0,0,0);
            break;

       case TRAP_EVENT_MAJOR_ALARM_RECOVERY:
            if (trap_data->u.alarm_recovery.alarmRecoveryObjectType== VAL_alarmMajorRecoveryType_powerModuleRecovery)
                SYSLOG_PMGR_AddFormatMsgEntry(&owner_info, MAJOR_ALARM_POWER_STATUS_RECOVER_INDEX,0,0,0);
            break;

        case TRAP_EVENT_MINOR_ALARM:
            if (trap_data->u.alarmMgt.alarmObjectType == VAL_alarmMajorType_thermalDetectorOverHeating)
                SYSLOG_PMGR_AddFormatMsgEntry(&owner_info, MINOR_ALARM_THERMAL_OVERHEAT_INDEX,0,0,0);
            break;
#endif  /* #if (SYS_CPNT_ALARM_DETECT == TRUE) */

        /* five of the Six Early Traps (no enterprise)
         */
        case TRAP_EVENT_LINK_DOWN:
            if (IF_PMGR_GetIfType(trap_data->u.link_down.ifindex, &iftype) == FALSE)
            {
                if (debug_mode)
                {
                    printf("\r\n%s: Failed to get iftype of ifindex = %lu!\r\n",
                           __FUNCTION__, (unsigned long)trap_data->u.link_down.ifindex);
                }
                return;
            }

            if (iftype == IF_MGR_NORMAL_IFINDEX)
            {
                if (SWCTRL_POM_IfindexToUport(trap_data->u.link_down.ifindex, &unit, &port) == TRUE)
                {
                    SYSLOG_PMGR_AddFormatMsgEntry(&owner_info, NORMAL_PORT_LINK_DOWN_MESSAGE_INDEX, &unit, &port, 0);
                    return;
                }
            }
            else if (iftype == IF_MGR_TRUNK_IFINDEX)
            {
                if (TRK_OM_IfindexToTrunkId(trap_data->u.link_down.ifindex, &trunk_id) == TRUE)
                {
                    SYSLOG_PMGR_AddFormatMsgEntry(&owner_info, TRUNK_PORT_LINK_DOWN_MESSAGE_INDEX, &trunk_id, 0, 0);
                    return;
                }
            }
            else if (iftype == IF_MGR_VLAN_IFINDEX)
            {
                VLAN_IFINDEX_CONVERTTO_VID(trap_data->u.link_down.ifindex, vid);
                SYSLOG_PMGR_AddFormatMsgEntry(&owner_info, VLAN_LINK_DOWN_MESSAGE_INDEX, &vid, 0, 0);
                return;
            }

            if (debug_mode)
            {
                printf("\r\n%s: ifindex = %lu, iftype = %lu is not handled!\r\n",
                       __FUNCTION__, (unsigned long)trap_data->u.link_down.ifindex, (unsigned long)iftype);
            }
            return;

        case TRAP_EVENT_LINK_UP:
            if (IF_PMGR_GetIfType(trap_data->u.link_up.ifindex, &iftype) == FALSE)
            {
                if (debug_mode)
                {
                    printf("\r\n%s: Failed to get iftype of ifindex = %lu!\r\n",
                           __FUNCTION__, (unsigned long)trap_data->u.link_up.ifindex);
                }
                return;
            }

            if (iftype == IF_MGR_NORMAL_IFINDEX)
            {
                char *speed_duplex_str_ar[] = {
                    "",         /* VAL_portSpeedDpxCfg_reserved */
                    "10M HD",   /* VAL_portSpeedDpxCfg_halfDuplex10 */
                    "10M FD",   /* VAL_portSpeedDpxCfg_fullDuplex10 */
                    "100M HD",  /* VAL_portSpeedDpxCfg_halfDuplex100 */
                    "100M FD",  /* VAL_portSpeedDpxCfg_fullDuplex100 */
                    "1G HD",    /* VAL_portSpeedDpxCfg_halfDuplex1000 */
                    "1G FD",    /* VAL_portSpeedDpxCfg_fullDuplex1000 */
                    "10G HD",   /* VAL_portSpeedDpxCfg_halfDuplex10g */
                    "10G FD",   /* VAL_portSpeedDpxCfg_fullDuplex10g */
                    "40G HD",   /* VAL_portSpeedDpxCfg_halfDuplex40g */
                    "40G FD",   /* VAL_portSpeedDpxCfg_fullDuplex40g */
                    "100G HD",  /* VAL_portSpeedDpxCfg_halfDuplex100g */
                    "100G FD",  /* VAL_portSpeedDpxCfg_fullDuplex100g */
                    "25G FD",   /* VAL_portSpeedDpxCfg_fullDuplex25g */
                };
                char *speed_duplex_str;

                if (trap_data->u.link_up.speed_duplex > 0 &&
                    trap_data->u.link_up.speed_duplex <= sizeof(speed_duplex_str_ar)/sizeof(*speed_duplex_str_ar))
                {
                    speed_duplex_str = speed_duplex_str_ar[trap_data->u.link_up.speed_duplex-1];
                }
                else
                {
                    speed_duplex_str = speed_duplex_str_ar[0];
                }

                if (SWCTRL_POM_IfindexToUport(trap_data->u.link_up.ifindex, &unit, &port) == TRUE)
                {
                    SYSLOG_PMGR_AddFormatMsgEntry(&owner_info, NORMAL_PORT_LINK_UP_MESSAGE_INDEX, &unit, &port, speed_duplex_str);
                    return;
                }
            }
            else if (iftype == IF_MGR_TRUNK_IFINDEX)
            {
                if (TRK_OM_IfindexToTrunkId(trap_data->u.link_up.ifindex, &trunk_id) == TRUE)
                {
                    SYSLOG_PMGR_AddFormatMsgEntry(&owner_info, TRUNK_PORT_LINK_UP_MESSAGE_INDEX, &trunk_id, 0, 0);
                    return;
                }
            }
            else if (iftype == IF_MGR_VLAN_IFINDEX)
            {
                VLAN_IFINDEX_CONVERTTO_VID(trap_data->u.link_up.ifindex, vid);
                SYSLOG_PMGR_AddFormatMsgEntry(&owner_info, VLAN_LINK_UP_MESSAGE_INDEX, &vid, 0, 0);
                return;
            }

            if (debug_mode)
            {
                printf("\r\n%s: ifindex = %lu, iftype = %lu is not handled!\r\n",
                       __FUNCTION__, (unsigned long)trap_data->u.link_up.ifindex, (unsigned long)iftype);
            }
            return;

#if (SYS_CPNT_CRAFT_PORT == TRUE)
        case TRAP_EVENT_CRAFT_PORT_LINK_UP:
            SYSLOG_PMGR_AddFormatMsgEntry(&owner_info, CRAFT_PORT_LINK_UP_MESSAGE_INDEX,
                &trap_data->u.craft_link_up.unit_id, 0, 0);
            return;

        case TRAP_EVENT_CRAFT_PORT_LINK_DOWN:
            SYSLOG_PMGR_AddFormatMsgEntry(&owner_info, CRAFT_PORT_LINK_DOWN_MESSAGE_INDEX,
                &trap_data->u.craft_link_down.unit_id, 0, 0);
            return;
#endif

        case TRAP_EVENT_AUTHENTICATION_FAILURE:
            SYSLOG_PMGR_AddFormatMsgEntry(&owner_info, AUTHENTICATION_FAILURE_MESSAGE_INDEX, 0, 0, 0);
            break;

        /* Spanning Tree Protocol MIB
         */
        case TRAP_EVENT_NEW_ROOT:
            SYSLOG_PMGR_AddFormatMsgEntry(&owner_info, STA_ROOT_CHANGE_MESSAGE_INDEX, 0, 0, 0);
            break;

        case TRAP_EVENT_TOPOLOGY_CHANGE:
        {
            UI8_T temp_msg[16] = {0};

            if (IF_PMGR_GetIfType(trap_data->u.tc_cause_lport, &iftype) == FALSE)
            {
                if (debug_mode)
                {
                    printf("\r\n%s: Failed to get iftype of ifindex = %lu!\r\n",
                           __FUNCTION__, (unsigned long)trap_data->u.tc_cause_lport);
                }
                return;
            }

            switch (iftype)
            {
                case IF_MGR_NORMAL_IFINDEX:
                    SWCTRL_POM_IfindexToUport(trap_data->u.tc_cause_lport, &unit, &port);
                    sprintf((char *)temp_msg, "Eth %lu/%lu", (unsigned long)unit, (unsigned long)port);
                    break;

                case IF_MGR_TRUNK_IFINDEX:
                    TRK_OM_IfindexToTrunkId(trap_data->u.tc_cause_lport, &trunk_id);
                    sprintf((char *)temp_msg, "Trunk %lu", (unsigned long)trunk_id);
                    break;

                default:
                    sprintf((char *)temp_msg, "unknown port");
                    break;
            }

            SYSLOG_PMGR_AddFormatMsgEntry(&owner_info, STA_TOPOLOGY_CHANGE_MESSAGE_INDEX, temp_msg, 0, 0);
            break;
        }

case TRAP_EVENT_TOPOLOGY_CHANGE_RECEIVE:
        {
            UI8_T temp_msg[16] = {0};
            if (IF_PMGR_GetIfType(trap_data->u.tc.rx_lport, &iftype) == FALSE)
            {
                if (debug_mode)
                {
                    printf("\r\n%s: Failed to get iftype of ifindex = %lu!\r\n",
                           __FUNCTION__, (unsigned long)trap_data->u.tc.rx_lport);
                }
                return;
            }
            switch (iftype)
            {
                case IF_MGR_NORMAL_IFINDEX:
                    SWCTRL_POM_IfindexToUport(trap_data->u.tc.rx_lport, &unit, &port);
                    sprintf((char *)temp_msg, "Eth %lu/%lu", (unsigned long)unit, (unsigned long)port);
                    break;

                case IF_MGR_TRUNK_IFINDEX:
                    TRK_OM_IfindexToTrunkId(trap_data->u.tc.rx_lport, &trunk_id);
                    sprintf((char *)temp_msg, "Trunk %lu", (unsigned long)trunk_id);
                    break;

                default:
                    sprintf((char *)temp_msg, "unknown port");
                    break;
            }
            SYSLOG_PMGR_AddFormatMsgEntry(&owner_info, STA_TOPOLOGY_CHANGE_MESSAGE_INDEX_RECEIVE,
				          temp_msg,  trap_data->u.tc.brg_mac, 0);
            break;
        }

        /* RMON MIB
         */
        case TRAP_EVENT_RISING_ALARM:
            SYSLOG_PMGR_AddFormatMsgEntry(&owner_info,
                                         RMON_RISING_ALARM_MESSAGE_INDEX,
                                         &trap_data->u.rising_alarm.alarm_index,
                                         &trap_data->u.rising_alarm.alarm_value, 0);
            break;

        case TRAP_EVENT_FALLING_ALARM:
            SYSLOG_PMGR_AddFormatMsgEntry(&owner_info,
                                         RMON_FALLING_ALARM_MESSAGE_INDEX,
                                         &trap_data->u.falling_alarm.alarm_index,
                                         &trap_data->u.falling_alarm.alarm_value, 0);
            break;

        /* Accton private MIB
         */
        case TRAP_EVENT_SW_POWER_STATUS_CHANGE_TRAP:
            SYSLOG_PMGR_AddFormatMsgEntry(&owner_info,
                                         POWER_STATUS_CHANGE_MESSAGE_INDEX,
                                         &trap_data->u.sw_power_status_change_trap.sw_indiv_power_unit_index,
                                         &trap_data->u.sw_power_status_change_trap.sw_indiv_power_index,
                                         &trap_data->u.sw_power_status_change_trap.sw_indiv_power_status);

            break;

        case TRAP_EVENT_SW_ACTIVE_POWER_CHANGE_TRAP:
            SYSLOG_PMGR_AddFormatMsgEntry(&owner_info,
                                         ACTIVE_POWER_CHANGE_MESSAGE_INDEX,
                                         &trap_data->u.sw_active_power_change_trap.sw_indiv_power_unit_index,
                                         &trap_data->u.sw_active_power_change_trap.sw_indiv_power_index, 0);
            break;

#if (SYS_CPNT_INTRUSION_MSG_TRAP == TRUE)
        case TRAP_EVENT_PORT_SECURITY_TRAP:
            if (!SWCTRL_POM_LogicalPortExisting(trap_data->u.port_security_trap.ifindex))
            {
#if (SYS_CPNT_EH == TRUE)
                if (EHMsgEnable)
                {
                    EH_MGR_Get_Exception_Info (&module_id, &function_no, &msg_flag, ehmsg, sizeof(ehmsg));
                    printf("EHMsg:moduleId=[%lu],funNo=[%lu]:%s",(unsigned long)module_id,(unsigned long)function_no,ehmsg);
                }
#endif  /* end of #if (SYS_CPNT_EH == TRUE) */

                if (debug_mode)
                    printf("FUNCTION:SNMP_MGR_ReqSendTrap; DESC:Reject trap request, no such lport, ifindex=[%lu]\n", (unsigned long)trap_data->u.port_security_trap.ifindex);
                return;
            }

            SWCTRL_POM_IfindexToUport(trap_data->u.port_security_trap.ifindex, &unit, &port);
            SYSLOG_PMGR_AddFormatMsgEntry(&owner_info, PORT_SECURITY_TRAP_INDEX, &unit, &port, trap_data->u.port_security_trap.mac);
            break;
#endif  /* (SYS_CPNT_INTRUSION_MSG_TRAP == TRUE) */

#if (SYS_CPNT_3COM_LOOPBACK_TEST == TRUE)
        case TRAP_EVENT_LOOPBACK_TEST_FAILURE_TRAP:
            SYSLOG_PMGR_AddFormatMsgEntry(&owner_info, LOOPBACK_TEST_FAILURE_MESSAGE_INDEX, 0, 0, 0);
            break;
#endif

#if (SYS_CPNT_STKTPLG_FAN_DETECT == TRUE)
        case TRAP_EVENT_FAN_FAILURE:
            SYSLOG_PMGR_AddFormatMsgEntry(&owner_info, FAN_FAIL_MESSAGE_INDEX,
                 &trap_data->u.fan_trap.trap_unit_index, &trap_data->u.fan_trap.trap_fan_index, 0);
            break;

        case TRAP_EVENT_FAN_RECOVER:
            SYSLOG_PMGR_AddFormatMsgEntry(&owner_info, FAN_RECOVERY_MESSAGE_INDEX,
                &trap_data->u.fan_trap.trap_unit_index, &trap_data->u.fan_trap.trap_fan_index, 0);
            break;
#endif

/* River@May 8, 2008, add thermal trap log */
#if (SYS_CPNT_THERMAL_DETECT == TRUE)
        /* swThermalRisingNotification(58)
         */
        case TRAP_EVENT_THERMAL_RISING:
        {
            //"ThermalRising:%lu,%lu,%lu,%lu,%lu,%lu,%lu."
            char  msg[SYSLOG_ADPT_MESSAGE_LENGTH];
            snprintf(msg, sizeof(msg), "ThermalRising:%lu,%lu,%ld,%lu,%lu,%lu,%lu.",
                    (unsigned long)trap_data->u.thermal_rising.instance_switchThermalTempValue[0],
                    (unsigned long)trap_data->u.thermal_rising.instance_switchThermalTempValue[1],
                    (long)trap_data->u.thermal_rising.switchThermalTempValue,
                    (unsigned long)trap_data->u.thermal_rising.instance_switchThermalActionRisingThreshold[0],
                    (unsigned long)trap_data->u.thermal_rising.instance_switchThermalActionRisingThreshold[1],
                    (unsigned long)trap_data->u.thermal_rising.instance_switchThermalActionRisingThreshold[2],
                    (unsigned long)trap_data->u.thermal_rising.switchThermalActionRisingThreshold);
            msg[sizeof(msg)-1] = '\0';
            SYSLOG_PMGR_AddFormatMsgEntry(&owner_info, THERMAL_RISING_MESSAGE_INDEX,
                                msg, 0, 0);
            break;
        }

        /* swThermalRisingNotification(58)
         */
        case TRAP_EVENT_THERMAL_FALLING:
        {
            //"ThermalFalling:%lu,%lu,%lu,%lu,%lu,%lu,%lu."
            char  msg[SYSLOG_ADPT_MESSAGE_LENGTH];
            snprintf(msg, sizeof(msg), "ThermalFalling:%lu,%lu,%ld,%lu,%lu,%lu,%lu.",
                    (unsigned long)trap_data->u.thermal_falling.instance_switchThermalTempValue[0],
                    (unsigned long)trap_data->u.thermal_falling.instance_switchThermalTempValue[1],
                    (long)trap_data->u.thermal_falling.switchThermalTempValue,
                    (unsigned long)trap_data->u.thermal_falling.instance_switchThermalActionFallingThreshold[0],
                    (unsigned long)trap_data->u.thermal_falling.instance_switchThermalActionFallingThreshold[1],
                    (unsigned long)trap_data->u.thermal_falling.instance_switchThermalActionFallingThreshold[2],
                    (unsigned long)trap_data->u.thermal_falling.switchThermalActionFallingThreshold);
            msg[sizeof(msg)-1] = '\0';
            SYSLOG_PMGR_AddFormatMsgEntry(&owner_info, THERMAL_FALLING_MESSAGE_INDEX,
                msg, 0, 0);
            break;
        }
#endif

#if (SYS_CPNT_MGMT_IP_FLT == TRUE)
        case TRAP_EVENT_IPFILTER_REJECT_TRAP:
            SYSLOG_PMGR_AddFormatMsgEntry(&owner_info, MGMT_IP_FLT_REJECT_MESSAGE_INDEX,
                &trap_data->u.ipFilter_reject_trap.mode,
                &trap_data->u.ipFilter_reject_trap.ip, 0);
            break;
        case TRAP_EVENT_IPFILTER_INET_REJECT_TRAP:
            SYSLOG_PMGR_AddFormatMsgEntry(&owner_info, MGMT_IP_FLT_INET_REJECT_MESSAGE_INDEX,
                &trap_data->u.ipFilterInet_reject_trap.mode,
                &trap_data->u.ipFilterInet_reject_trap.inet_ip, 0);
            break;
#endif

#if (SYS_CPNT_SMTP == TRUE)
        case TRAP_EVENT_SMTP_CONN_FAILURE_TRAP:
            SYSLOG_PMGR_AddFormatMsgEntry(&owner_info, SMTP_CONN_FAILURE_MESSAGE_INDEX,
                                         &trap_data->u.sw_smtp_conn_failure_trap.smtpServerIp, 0, 0);
            break;
#endif

#if (SYS_CPNT_POE == TRUE)
        /* PoE MIB
         */
        case TRAP_EVENT_PETH_PSE_PORT_ON_OFF_TRAP:
        {
            SYSLOG_PMGR_AddFormatMsgEntry(&owner_info, PETH_PSE_PORT_ON_OFF_MESSAGE_INDEX,
                &trap_data->u.peth_pse_port_on_off_trap.instance_pethPsePortDetectionStatus[0],
                &trap_data->u.peth_pse_port_on_off_trap.instance_pethPsePortDetectionStatus[1],
                &trap_data->u.peth_pse_port_on_off_trap.pethPsePortDetectionStatus);
            break;
        }
        case TRAP_EVENT_PETH_MAIN_POWER_USAGE_ON_TRAP:
        {
            SYSLOG_PMGR_AddFormatMsgEntry(&owner_info, PETH_MAIN_POWER_USAGE_ON_MESSAGE_INDEX,
                &trap_data->u.peth_main_power_usage_on_trap.instance_pethMainPseConsumptionPower,
                &trap_data->u.peth_main_power_usage_on_trap.pethMainPseConsumptionPower,
                0);
            break;
        }
        case TRAP_EVENT_PETH_MAIN_POWER_USAGE_OFF_TRAP:
        {
            SYSLOG_PMGR_AddFormatMsgEntry(&owner_info, PETH_MAIN_POWER_USAGE_OFF_MESSAGE_INDEX,
                &trap_data->u.peth_main_power_usage_off_trap.instance_pethMainPseConsumptionPower,
                &trap_data->u.peth_main_power_usage_off_trap.pethMainPseConsumptionPower,
                0);
            break;
        }
#endif  /* (SYS_CPNT_POE == TRUE) */

#if (SYS_CPNT_SNMP_MIB_STYLE == SYS_CPNT_SNMP_MIB_STYLE_32)
        /* 3Com private MIB
         */
        case TRAP_EVENT_SECURE_ADDRESS_LEARNED:
            SYSLOG_PMGR_AddFormatMsgEntry(&owner_info, SECURE_ADDRESS_LEARNED_INDEX,
                &trap_data->u.secure_address_learned.secureAddrSlotIndex,
                &trap_data->u.secure_address_learned.secureAddrPortIndex,
                &trap_data->u.secure_address_learned.secureAddrMAC);
            break;

        case TRAP_EVENT_SECURE_VIOLATION2:
            SYSLOG_PMGR_AddFormatMsgEntry(&owner_info, SECURE_VIOLATION2_INDEX,
                &trap_data->u.secure_violation2.secureAddrSlotIndex,
                &trap_data->u.secure_violation2.secureAddrPortIndex,
                &trap_data->u.secure_violation2.secureAddrMAC);
            break;

        case TRAP_EVENT_SECURE_LOGIN_FAILURE:
            SYSLOG_PMGR_AddFormatMsgEntry(&owner_info, SECURE_LOGIN_FAILURE_INDEX,
                &trap_data->u.login_failure.secureAddrSlotIndex,
                &trap_data->u.login_failure.secureAddrPortIndex,
                &trap_data->u.login_failure.dot1xAuthSessionUserName);
            break;

        case TRAP_EVENT_SECURE_LOGON:
            SYSLOG_PMGR_AddFormatMsgEntry(&owner_info, SECURE_LOGON_INDEX,
                &trap_data->u.secure_logon.secureAddrSlotIndex,
                &trap_data->u.secure_logon.secureAddrPortIndex,
                &trap_data->u.secure_logon.dot1xAuthSessionUserName);
            break;

        case TRAP_EVENT_SECURE_LOGOFF:
            SYSLOG_PMGR_AddFormatMsgEntry(&owner_info, SECURE_LOGOFF_INDEX,
                &trap_data->u.secure_logoff.secureAddrSlotIndex,
                &trap_data->u.secure_logoff.secureAddrPortIndex,
                &trap_data->u.secure_logoff.dot1xAuthSessionUserName);
            break;

        case TRAP_EVENT_TESTTRAP:
            SYSLOG_PMGR_AddFormatMsgEntry(&owner_info, TEST_TRAP_INDEX , 0, 0, 0);
            break;

        case TRAP_EVENT_IP_FORWARDING_CHANGED_BY_MSTPTRAP:
            SYSLOG_PMGR_AddFormatMsgEntry(&owner_info, IP_FORWARDING_CHANGED_BY_MSTP_TRAP_INDEX , 0, 0, 0);
            break;
#endif  /* (SYS_CPNT_SNMP_MIB_STYLE == SYS_CPNT_SNMP_MIB_STYLE_32) */

        /* Accton private MIB
         */
#if (SYS_CPNT_MODULE_WITH_CPU == TRUE)
        case TRAP_EVENT_MODULE_INSERTION:
        {
            //"ModuleInsertion:%lu,%lu,%s."
            char  msg[SYSLOG_ADPT_MESSAGE_LENGTH];
            snprintf(msg, sizeof(msg), "ModuleInsertion:%lu,%lu,%s.",
                    (unsigned long)trap_data->u.module_insertion.instance_swModuleOpCodeVer[0],
                    (unsigned long)trap_data->u.module_insertion.instance_swModuleOpCodeVer[1],
                    trap_data->u.module_insertion.swModuleOpCodeVer);
            msg[sizeof(msg)-1] = '\0';
            SYSLOG_PMGR_AddFormatMsgEntry(&owner_info, MODULE_INSERTION_MESSAGE_INDEX, msg, 0, 0);
            break;
        }

        case TRAP_EVENT_MODULE_REMOVAL:
        {
            //"ModuleRemoval:%lu,%lu,%s."
            char  msg[SYSLOG_ADPT_MESSAGE_LENGTH];
            snprintf(msg, sizeof(msg), "ModuleRemoval:%lu,%lu,%s.",
                    (unsigned long)trap_data->u.module_removal.instance_swModuleOpCodeVer[0],
                    (unsigned long)trap_data->u.module_removal.instance_swModuleOpCodeVer[1],
                    trap_data->u.module_removal.swModuleOpCodeVer);
            msg[sizeof(msg)-1] = '\0';
            SYSLOG_PMGR_AddFormatMsgEntry(&owner_info, MODULE_REMOVAL_MESSAGE_INDEX, msg, 0, 0);
            break;
        }
#endif  /* (SYS_CPNT_MODULE_WITH_CPU == TRUE) */

        case TRAP_EVENT_MAIN_BOARD_VER_MISMATCH:
        {
            //"MainBoardVerMismatch:%lu,%s,%lu,%s."
            char  msg[SYSLOG_ADPT_MESSAGE_LENGTH];
            snprintf(msg, sizeof(msg), "%lu,%s,%lu,%s.",
                    (unsigned long)trap_data->u.main_board_ver_mismatch.instance_swOpCodeVerMaster[0],
                    trap_data->u.main_board_ver_mismatch.swOpCodeVerMaster,
                    (unsigned long)trap_data->u.main_board_ver_mismatch.instance_swOpCodeVerSlave[0],
                    trap_data->u.main_board_ver_mismatch.swOpCodeVerSlave);
            msg[sizeof(msg)-1] = '\0';
            SYSLOG_PMGR_AddFormatMsgEntry(&owner_info, MAIN_BOARD_VER_MISMATCH_MESSAGE_INDEX,msg, 0, 0);
            break;
        }

        case TRAP_EVENT_MODULE_VER_MISMATCH:
        {
            //"ModuleVerMismatch:%lu,%s,%lu,%lu,%s."
            char  msg[SYSLOG_ADPT_MESSAGE_LENGTH];
            snprintf(msg, sizeof(msg), "%lu,%s,%lu,%lu,%s.",
                    (unsigned long)trap_data->u.module_ver_mismatch.instance_swModuleExpectedOpCodeVer[0],
                    trap_data->u.module_ver_mismatch.swModuleExpectedOpCodeVer,
                    (unsigned long)trap_data->u.module_ver_mismatch.instance_swModuleOpCodeVer[0],
                    (unsigned long)trap_data->u.module_ver_mismatch.instance_swModuleOpCodeVer[1],
                    trap_data->u.module_ver_mismatch.swModuleOpCodeVer);
            msg[sizeof(msg)-1] = '\0';
            SYSLOG_PMGR_AddFormatMsgEntry(&owner_info, MODULE_VER_MISMATCH_MESSAGE_INDEX, msg, 0, 0);
            break;
        }

        case TRAP_EVENT_TCN:
        {
             char  msg[SYSLOG_ADPT_MESSAGE_LENGTH];

             switch(trap_data->u.tcn.tcnReason)
             {
                case VAL_trapVarTcnReason_pushButton: snprintf(msg, sizeof(msg), "pushButton(%lu)",(unsigned long)trap_data->u.tcn.tcnReason); 		break;
                case VAL_trapVarTcnReason_stackingLinkDown: snprintf(msg, sizeof(msg), "stackingLinkDown(%lu)",(unsigned long)trap_data->u.tcn.tcnReason); 	break;
                case VAL_trapVarTcnReason_stackingLinkUp: snprintf(msg, sizeof(msg), "stackingLinkUp(%lu)",(unsigned long)trap_data->u.tcn.tcnReason); 	break;
                case VAL_trapVarTcnReason_hbtTimeout: snprintf(msg, sizeof(msg), "hbtTimeout(%lu)",(unsigned long)trap_data->u.tcn.tcnReason); 		break;
                case VAL_trapVarTcnReason_hbtError: snprintf(msg, sizeof(msg), "hbtError(%lu)",(unsigned long)trap_data->u.tcn.tcnReason); 			break;
                case VAL_trapVarTcnReason_slave: snprintf(msg, sizeof(msg), "slave(%lu)",(unsigned long)trap_data->u.tcn.tcnReason); 			break;
                default: snprintf(msg, sizeof(msg), "none(%lu)",(unsigned long)trap_data->u.tcn.tcnReason);							break;
             }
             msg[sizeof(msg)-1] = '\0';
             SYSLOG_PMGR_AddFormatMsgEntry(&owner_info, TCN_MESSAGE_INDEX, msg, 0, 0);
             break;
        }

#if (SYS_CPNT_LLDP == TRUE)
        /* LLDP MIB
         */
        case TRAP_EVENT_LLDP_REM_TABLES_CHANGED:
            SYSLOG_PMGR_AddFormatMsgEntry(&owner_info, LLDP_REM_TABLE_CHANGED_INDEX, 0, 0, 0);
            break;
#endif

#if (SYS_CPNT_LLDP_MED == TRUE)
        /* LLDP-MED MIB
         */
        case TRAP_EVENT_LLDP_MED_TOPOLOGY_CHANGE_DETECTED:
            SYSLOG_PMGR_AddFormatMsgEntry(&owner_info,
                                         LLDP_MED_TOPOLOGY_CHANGE_DETECTED_INDEX,
                                         &trap_data->u.lldp_med_topology_change.lldpRemChassisIdSubtype,
                                         trap_data->u.lldp_med_topology_change.lldpRemChassisId,
                                         &trap_data->u.lldp_med_topology_change.lldpMedRemDeviceClass);
            break;
#endif

#if (SYS_CPNT_EFM_OAM == TRUE)
        /* OAM MIB
         */
        case TRAP_EVENT_DOT3_OAM_THRESHOLD:
        {
            char   temp_msg[SYSLOG_ADPT_MESSAGE_LENGTH]={0};
            //UI8_T  error_vale[20]={0};

            /* get unit/port
             */
            SWCTRL_POM_IfindexToUport(trap_data->u.dot3_oam_threshold.instance_dot3OamEventLogEntry[0], &unit, &port);

            /* dispatch event type
             */
            switch (trap_data->u.dot3_oam_threshold.dot3OamEventLogType)
            {
                /* erroredSymbolEvent(1), Errored Symbol
                 */
                case VAL_dot3OamEventLogType_erroredSymbolEvent:
                    sprintf(temp_msg, "Symbol errors");
                    break;

                /* erroredFramePeriodEvent(2), Errored Frame Period
                 */
                case VAL_dot3OamEventLogType_erroredFramePeriodEvent:
                    sprintf(temp_msg, "Frame errors");
                    break;

                /* erroredFrameEvent(3), Errored Frame
                 */
                case VAL_dot3OamEventLogType_erroredFrameEvent:
                    sprintf(temp_msg, "Frame errors");
                    break;

                /* erroredFrameSecondsEvent(4), Errored Frame Seconds
                 */
                case VAL_dot3OamEventLogType_erroredFrameSecondsEvent:
                    sprintf(temp_msg, "Frame errors");
                    break;

                default:
                    sprintf(temp_msg, "None");
                    break;
            }

#if 0
            /* Threshold crossing event has error number.
             * So convert 64bits value to string
             */
            L_STDLIB_UI64toa(trap_data->u.dot3_oam_threshold.dot3OamEventLogValue.high,
                             trap_data->u.dot3_oam_threshold.dot3OamEventLogValue.low,
                             error_vale);
            L_STDLIB_Trim_Left(error_vale, 20);
            strcat(temp_msg, error_vale);

            strcat(temp_msg, " errors");
#endif

            temp_msg[sizeof(temp_msg)-1] = '\0';

            /* add to syslog
             */
            SYSLOG_PMGR_AddFormatMsgEntry(&owner_info,
                DOT3_OAM_THRESHOLD_MESSAGE_INDEX, &unit, &port, temp_msg);

            break;
        }

        case TRAP_EVENT_DOT3_OAM_NON_THRESHOLD:
        {
            char  temp_msg[SYSLOG_ADPT_MESSAGE_LENGTH]={0};

            /* get unit/port
             */
            SWCTRL_POM_IfindexToUport(trap_data->u.dot3_oam_nonthreshold.instance_dot3OamEventLogEntry[0], &unit, &port);

            /* dispatch event type
             */
            switch (trap_data->u.dot3_oam_nonthreshold.dot3OamEventLogType)
            {
                /* linkFault(256)
                 */
                case VAL_dot3OamEventLogType_linkFault:
                    sprintf(temp_msg, "Link Fault");
                    break;

                /* dyingGaspEvent(257)
                 */
                case VAL_dot3OamEventLogType_dyingGaspEvent:
                    sprintf(temp_msg, "Dying Gasp");
                    break;

                /* criticalLinkEvent(258)
                 */
                case VAL_dot3OamEventLogType_criticalLinkEvent:
                    sprintf(temp_msg, "Critical Event");
                    break;

                default:
                    sprintf(temp_msg, "None");
                    break;
            }

            temp_msg[sizeof(temp_msg)-1] = '\0';

            /* add to syslog
             */
            SYSLOG_PMGR_AddFormatMsgEntry(&owner_info,
                DOT3_OAM_NON_THRESHOLD_MESSAGE_INDEX, &unit, &port, temp_msg);
            break;
        }
#endif  /* #if (SYS_CPNT_EFM_OAM == TRUE) */

        /* Accton private MIB
         */
#if (SYS_CPNT_ATC_STORM == TRUE)
        case TRAP_EVENT_BCAST_STORM_ALARM_FIRE:
            SYSLOG_PMGR_AddFormatMsgEntry(&owner_info, BCAST_STORM_ALARM_FIRE_INDEX,
                &trap_data->u.bstorm_alarm_fire.IfIndex,
                &trap_data->u.bstorm_alarm_fire.SampleType,
                &trap_data->u.bstorm_alarm_fire.CurrentTrafficRate);
            break;

        case TRAP_EVENT_BCAST_STORM_ALARM_CLEAR:
            SYSLOG_PMGR_AddFormatMsgEntry(&owner_info, BCAST_STORM_ALARM_CLEAR_INDEX,
                &trap_data->u.bstorm_alarm_clear.IfIndex,
                &trap_data->u.bstorm_alarm_clear.SampleType,
                &trap_data->u.bstorm_alarm_clear.CurrentTrafficRate);
            break;

        case TRAP_EVENT_BCAST_STORM_TC_APPLY :
            SYSLOG_PMGR_AddFormatMsgEntry(&owner_info, BCAST_STORM_TC_APPLY_INDEX,
                &trap_data->u.bstorm_tc_apply.IfIndex,
                &trap_data->u.bstorm_tc_apply.SampleType,
                &trap_data->u.bstorm_tc_apply.CurrentTrafficRate);

            break;

        case TRAP_EVENT_BCAST_STORM_TC_RELEASE:
            SYSLOG_PMGR_AddFormatMsgEntry(&owner_info, BCAST_STORM_TC_RELEASE_INDEX,
                &trap_data->u.bstorm_tc_release.IfIndex,
                &trap_data->u.bstorm_tc_release.SampleType,
                &trap_data->u.bstorm_tc_release.CurrentTrafficRate);

            break;

        case TRAP_EVENT_MCAST_STORM_ALARM_FIRE:
            SYSLOG_PMGR_AddFormatMsgEntry(&owner_info, MCAST_STORM_ALARM_FIRE_INDEX,
                &trap_data->u.mstorm_alarm_fire.IfIndex,
                &trap_data->u.mstorm_alarm_fire.SampleType,
                &trap_data->u.mstorm_alarm_fire.CurrentTrafficRate);

            break;

        case TRAP_EVENT_MCAST_STORM_ALARM_CLEAR:
            SYSLOG_PMGR_AddFormatMsgEntry(&owner_info, MCAST_STORM_ALARM_CLEAR_INDEX,
                &trap_data->u.mstorm_alarm_clear.IfIndex,
                &trap_data->u.mstorm_alarm_clear.SampleType,
                &trap_data->u.mstorm_alarm_clear.CurrentTrafficRate);
            break;

        case TRAP_EVENT_MCAST_STORM_TC_APPLY:
            SYSLOG_PMGR_AddFormatMsgEntry(&owner_info, MCAST_STORM_TC_APPLY_INDEX,
                &trap_data->u.mstorm_tc_apply.IfIndex,
                &trap_data->u.mstorm_tc_apply.SampleType,
                &trap_data->u.mstorm_tc_apply.CurrentTrafficRate);
            break;

        case TRAP_EVENT_MCAST_STORM_TC_RELEASE:
            SYSLOG_PMGR_AddFormatMsgEntry(&owner_info, MCAST_STORM_TC_RELEASE_INDEX,
                &trap_data->u.mstorm_tc_release.IfIndex,
                &trap_data->u.mstorm_tc_release.SampleType,
                &trap_data->u.mstorm_tc_release.CurrentTrafficRate);
            break;
#endif  /* (SYS_CPNT_ATC_STORM == TRUE) */

#if (SYS_CPNT_CFM == TRUE)
        case TRAP_EVENT_CFM_MEP_UP:
            SYSLOG_PMGR_AddFormatMsgEntry(&owner_info, CFM_MEP_UP_MESSAGE_INDEX,
                &trap_data->u.cfm_mep_up.dot1agCfmMepDbRMepIdentifier,
                &trap_data->u.cfm_mep_up.instance_dot1agCfmMepIdentifier[1],
                &trap_data->u.cfm_mep_up.instance_dot1agCfmMepIdentifier[0]);
            break;

        case TRAP_EVENT_CFM_MEP_DOWN:
            SYSLOG_PMGR_AddFormatMsgEntry(&owner_info, CFM_MEP_DOWN_MESSAGE_INDEX,
                &trap_data->u.cfm_mep_down.dot1agCfmMepDbRMepIdentifier,
                &trap_data->u.cfm_mep_down.instance_dot1agCfmMepIdentifier[1],
                &trap_data->u.cfm_mep_down.instance_dot1agCfmMepIdentifier[0]);
            break;

        case TRAP_EVENT_CFM_CONFIG_FAIL:
            SYSLOG_PMGR_AddFormatMsgEntry(&owner_info, CFM_CONFIG_FAIL_MESSAGE_INDEX,
                &trap_data->u.cfm_config_fail.dot1agCfmMepIdentifier,
                &trap_data->u.cfm_config_fail.instance_dot1agCfmMepIdentifier[1],
                &trap_data->u.cfm_config_fail.instance_dot1agCfmMepIdentifier[0]);
            break;

        case TRAP_EVENT_CFM_LOOP_FIND:
            SYSLOG_PMGR_AddFormatMsgEntry(&owner_info, CFM_LOOP_FIND_MESSAGE_INDEX,
                &trap_data->u.cfm_loop_find.dot1agCfmMepIdentifier,
                &trap_data->u.cfm_loop_find.instance_dot1agCfmMepIdentifier[1],
                &trap_data->u.cfm_loop_find.instance_dot1agCfmMepIdentifier[0]);
            break;

        case TRAP_EVENT_CFM_MEP_UNKNOWN:
            SYSLOG_PMGR_AddFormatMsgEntry(&owner_info, CFM_MEP_UNKNOWN_MESSAGE_INDEX,
                &trap_data->u.cfm_mep_unknown.dot1agCfmMepIdentifier,
                &trap_data->u.cfm_mep_unknown.instance_dot1agCfmMepIdentifier[1],
                &trap_data->u.cfm_mep_unknown.instance_dot1agCfmMepIdentifier[0]);
            break;

        case TRAP_EVENT_CFM_MEP_MISSING:
            SYSLOG_PMGR_AddFormatMsgEntry(&owner_info, CFM_MEP_MISSING_MESSAGE_INDEX,
                &trap_data->u.cfm_mep_missing.dot1agCfmMepDbRMepIdentifier,
                &trap_data->u.cfm_mep_missing.instance_dot1agCfmMepIdentifier[1],
                &trap_data->u.cfm_mep_missing.instance_dot1agCfmMepIdentifier[0]);
            break;

        case TRAP_EVENT_CFM_MA_UP:
            SYSLOG_PMGR_AddFormatMsgEntry(&owner_info, CFM_MA_UP_MESSAGE_INDEX,
                &trap_data->u.cfm_ma_up.dot1agCfmMaIndex,
                &trap_data->u.cfm_ma_up.instance_dot1agCfmMaIndex[0], 0);
            break;

        /* CFM MIB
         */
        case TRAP_EVENT_CFM_FAULT_ALARM:
        {
            char  temp_msg[SYSLOG_ADPT_MESSAGE_LENGTH]={0};

            switch(trap_data->u.cfm_fault_alarm.dot1agCfmMepHighestPrDefect)
            {
                case CFM_TYPE_FNG_HIGHEST_DEFECT_RDI_CCM:
                    snprintf((char*)temp_msg, sizeof(temp_msg), "RDI CCM");
                    break;
                case CFM_TYPE_FNG_HIGHEST_DEFECT_MAC_STATUS:
                    snprintf((char*)temp_msg, sizeof(temp_msg), "MAC status");
                    break;
                case CFM_TYPE_FNG_HIGHEST_DEFECT_REMOTE_CCM:
                    snprintf((char*)temp_msg, sizeof(temp_msg), "remote CCM");
                    break;
                case CFM_TYPE_FNG_HIGHEST_DEFECT_ERROR_CCM:
                    snprintf((char*)temp_msg, sizeof(temp_msg), "error CCM");
                    break;
                case CFM_TYPE_FNG_HIGHEST_DEFECT_XCON_CCM:
                    snprintf((char*)temp_msg, sizeof(temp_msg), "Xcon CCM");
                    break;
                default:
                    snprintf((char*)temp_msg, sizeof(temp_msg), "none");
                    break;
            }
            temp_msg[sizeof(temp_msg)-1] = '\0';
            SYSLOG_PMGR_AddFormatMsgEntry(&owner_info, CFM_FAULT_ALARM_MESSAGE_INDEX,
                &trap_data->u.cfm_fault_alarm.instance_dot1agCfmMepHighestPrDefect[2], temp_msg, 0);
            break;
        }
#endif  /* #if (SYS_CPNT_CFM == TRUE) */

        /* Accton private MIB
         */

#if (SYS_CPNT_STP_BPDU_GUARD == TRUE)
        case TRAP_EVENT_STP_BPDU_GUARD_PORT_SHUTDOWN_TRAP:
            SYSLOG_PMGR_AddFormatMsgEntry(&owner_info,
                STP_BPDU_GUARD_PORT_SHUTDOWN_MESSAGE_INDEX,
                &trap_data->u.stp_bpdu_guard_port_shutdown.ifindex, 0, 0);
            break;
#endif

#if (SYS_CPNT_NETACCESS_LINK_DETECTION == TRUE)
        case TRAP_EVENT_NETWORK_ACCESS_PORT_LINK_DETECTION_TRAP:
        {
            char  temp_msg[SYSLOG_ADPT_MESSAGE_LENGTH]={0};

            SWCTRL_POM_IfindexToUport(trap_data->u.network_access_port_link_detection.ifindex, &unit, &port);

            switch(trap_data->u.network_access_port_link_detection.networkAccessPortLinkDetectionAction)
            {
                case VAL_networkAccessPortLinkDetectionAciton_trap:
                {
                    if (VAL_ifOperStatus_up == trap_data->u.network_access_port_link_detection.ifOperStatus)
                    {
                        snprintf(temp_msg, sizeof(temp_msg), "link-detection link-up notification");
                    }
                    else
                    {
                        snprintf(temp_msg, sizeof(temp_msg), "link-detection link-down notification");
                    }
                    temp_msg[sizeof(temp_msg)-1] = '\0';
                    SYSLOG_PMGR_AddFormatMsgEntry(&owner_info, NETWORK_ACCESS_PORT_LINK_DETECTION_INDEX, &unit, &port, temp_msg);
                }
                break;

                case VAL_networkAccessPortLinkDetectionAciton_shutdown:
                {
                    if (VAL_ifOperStatus_up == trap_data->u.network_access_port_link_detection.ifOperStatus)
                    {
                        snprintf(temp_msg, sizeof(temp_msg), "link-detection link-up & shutdown");
                    }
                    else
                    {
                        snprintf(temp_msg, sizeof(temp_msg), "link-detection link-down & shutdown");
                    }
                    temp_msg[sizeof(temp_msg)-1] = '\0';
                    SYSLOG_PMGR_AddFormatMsgEntry(&owner_info, NETWORK_ACCESS_PORT_LINK_DETECTION_INDEX, &unit, &port, temp_msg);
                }
                break;

                case VAL_networkAccessPortLinkDetectionAciton_trapAndShutdown:
                {
                    if (VAL_ifOperStatus_up == trap_data->u.network_access_port_link_detection.ifOperStatus)
                    {
                        snprintf(temp_msg, sizeof(temp_msg), "link-up notification and shut down");
                    }
                    else
                    {
                        snprintf(temp_msg, sizeof(temp_msg), "link-down notification and shut down");
                    }
                    temp_msg[sizeof(temp_msg)-1] = '\0';
                    SYSLOG_PMGR_AddFormatMsgEntry(&owner_info, NETWORK_ACCESS_PORT_LINK_DETECTION_INDEX, &unit, &port, temp_msg);
                }
                break;
            }
            break;
        }
#endif  /* #if (SYS_CPNT_NETACCESS_LINK_DETECTION == TRUE) */

#if (SYS_CPNT_XFER_AUTO_UPGRADE == TRUE)
        /* autoUpgradeTrap(104)
         */
        case TRAP_EVENT_XFER_AUTO_UPGRADE:
        {
            char temp_msg[SYSLOG_ADPT_MESSAGE_LENGTH]={0};
            char upgrade_type[10]={0};
            char upgrade_result[10]={0};

            switch(trap_data ->u.auto_upgrade.fileCopyFileType)
            {
                case VAL_fileCopyFileType_opcode:
                    snprintf(upgrade_type, sizeof(upgrade_type), "opcode");
                    break;

                default:
                    break;
            }

            if(trap_data ->u.auto_upgrade.autoUpgradeResult ==VAL_trapAutoUpgradeResult_failed)
            {
                snprintf(upgrade_result, sizeof(upgrade_result), "failed");
                upgrade_result[sizeof(upgrade_result)-1] = '\0';
                SYSLOG_PMGR_AddFormatMsgEntry(&owner_info, XFER_AUTO_UPGRADE_MESSAGE_INDEX, upgrade_type, upgrade_result, 0);
            }
            else
            {
                snprintf(upgrade_result, sizeof(upgrade_result), "succeeded");
                snprintf(temp_msg, sizeof(temp_msg),"%s version %s",upgrade_type,trap_data->u.auto_upgrade.autoUpgradeNewVer);
                upgrade_result[sizeof(upgrade_result)-1] = '\0';
                temp_msg[sizeof(temp_msg)-1] = '\0';
                SYSLOG_PMGR_AddFormatMsgEntry(&owner_info, XFER_AUTO_UPGRADE_MESSAGE_INDEX, temp_msg, upgrade_result, 0);
            }
        }
        break;
#endif  /* (SYS_CPNT_XFER_AUTO_UPGRADE == TRUE) */

        /* Accton private MIB
         */
#if (SYS_CPNT_SYSMGMT_RESMIB == TRUE)
        case TRAP_EVENT_MEM_RAISE_TRAP:
            SYSLOG_PMGR_AddFormatMsgEntry(&owner_info, MEMORY_RAISE_EVENT_MESSAGE_INDEX, 0, 0, 0);
            break;

        case TRAP_EVENT_MEM_FALLING_TRAP:
            SYSLOG_PMGR_AddFormatMsgEntry(&owner_info, MEMORY_FALLING_EVENT_MESSAGE_INDEX, 0, 0, 0);
            break;

        case TRAP_EVENT_CPU_RAISE_TRAP:
            SYSLOG_PMGR_AddFormatMsgEntry(&owner_info, CPU_RAISE_MESSAGE_INDEX, 0, 0, 0);
            break;

        case TRAP_EVENT_CPU_FALLING_TRAP:
            SYSLOG_PMGR_AddFormatMsgEntry(&owner_info, CPU_FALLING_MESSAGE_INDEX, 0, 0, 0);
            break;
#endif  /* #if (SYS_CPNT_SYSMGMT_RESMIB == TRUE) */

#if (SYS_CPNT_SYSMGMT_CPU_GUARD == TRUE)
        case TRAP_EVENT_CPU_GUARD_CONTROL:
            SYSLOG_PMGR_AddFormatMsgEntry(&owner_info, CPU_GUARD_CONTROL_MESSAGE_INDEX, 0, 0, 0);
            break;

        case TRAP_EVENT_CPU_GUARD_RELEASE:
            SYSLOG_PMGR_AddFormatMsgEntry(&owner_info, CPU_GUARD_RELEASE_MESSAGE_INDEX, 0, 0, 0);
            break;
#endif

#if (SYS_CPNT_SFP_DDM_ALARMWARN_TRAP == TRUE)
        case TRAP_EVENT_SFP_TX_POWER_HIGH_ALARM:
            SYSLOG_PMGR_AddFormatMsgEntry(&owner_info, SFP_TX_POWER_HIGH_ALARM_MESSAGE_INDEX, &trap_data->u.sfp_ddm_alarmwarn_trap.sfp_ddm_alarmwarn_ifindex, 0, 0);
            break;

        case TRAP_EVENT_SFP_TX_POWER_LOW_ALARM:
            SYSLOG_PMGR_AddFormatMsgEntry(&owner_info, SFP_TX_POWER_LOW_ALARM_MESSAGE_INDEX, &trap_data->u.sfp_ddm_alarmwarn_trap.sfp_ddm_alarmwarn_ifindex, 0, 0);
            break;

        case TRAP_EVENT_SFP_TX_POWER_HIGH_WARNING:
            SYSLOG_PMGR_AddFormatMsgEntry(&owner_info, SFP_TX_POWER_HIGH_WARNING_MESSAGE_INDEX, &trap_data->u.sfp_ddm_alarmwarn_trap.sfp_ddm_alarmwarn_ifindex, 0, 0);
            break;

        case TRAP_EVENT_SFP_TX_POWER_LOW_WARNING:
            SYSLOG_PMGR_AddFormatMsgEntry(&owner_info, SFP_TX_POWER_LOW_WARNING_MESSAGE_INDEX, &trap_data->u.sfp_ddm_alarmwarn_trap.sfp_ddm_alarmwarn_ifindex, 0, 0);
            break;

        case TRAP_EVENT_SFP_TX_POWER_ALARMWARN_CEASE:
            SYSLOG_PMGR_AddFormatMsgEntry(&owner_info, SFP_TX_POWER_ALARMWARN_CEASE_MESSAGE_INDEX, &trap_data->u.sfp_ddm_alarmwarn_trap.sfp_ddm_alarmwarn_ifindex, 0, 0);
            break;

        case TRAP_EVENT_SFP_RX_POWER_HIGH_ALARM:
            SYSLOG_PMGR_AddFormatMsgEntry(&owner_info, SFP_RX_POWER_HIGH_ALARM_MESSAGE_INDEX, &trap_data->u.sfp_ddm_alarmwarn_trap.sfp_ddm_alarmwarn_ifindex, 0, 0);
            break;

        case TRAP_EVENT_SFP_RX_POWER_LOW_ALARM:
            SYSLOG_PMGR_AddFormatMsgEntry(&owner_info, SFP_RX_POWER_LOW_ALARM_MESSAGE_INDEX, &trap_data->u.sfp_ddm_alarmwarn_trap.sfp_ddm_alarmwarn_ifindex, 0, 0);
            break;

        case TRAP_EVENT_SFP_RX_POWER_HIGH_WARNING:
            SYSLOG_PMGR_AddFormatMsgEntry(&owner_info, SFP_RX_POWER_HIGH_WARNING_MESSAGE_INDEX, &trap_data->u.sfp_ddm_alarmwarn_trap.sfp_ddm_alarmwarn_ifindex, 0, 0);
            break;

        case TRAP_EVENT_SFP_RX_POWER_LOW_WARNING:
            SYSLOG_PMGR_AddFormatMsgEntry(&owner_info, SFP_RX_POWER_LOW_WARNING_MESSAGE_INDEX, &trap_data->u.sfp_ddm_alarmwarn_trap.sfp_ddm_alarmwarn_ifindex, 0, 0);
            break;

        case TRAP_EVENT_SFP_RX_POWER_ALARMWARN_CEASE:
            SYSLOG_PMGR_AddFormatMsgEntry(&owner_info, SFP_RX_POWER_ALARMWARN_CEASE_MESSAGE_INDEX, &trap_data->u.sfp_ddm_alarmwarn_trap.sfp_ddm_alarmwarn_ifindex, 0, 0);
            break;

        case TRAP_EVENT_SFP_TEMP_HIGH_ALARM:
            SYSLOG_PMGR_AddFormatMsgEntry(&owner_info, SFP_TEMP_HIGH_ALARM_MESSAGE_INDEX, &trap_data->u.sfp_ddm_alarmwarn_trap.sfp_ddm_alarmwarn_ifindex, 0, 0);
            break;

        case TRAP_EVENT_SFP_TEMP_LOW_ALARM:
            SYSLOG_PMGR_AddFormatMsgEntry(&owner_info, SFP_TEMP_LOW_ALARM_MESSAGE_INDEX, &trap_data->u.sfp_ddm_alarmwarn_trap.sfp_ddm_alarmwarn_ifindex, 0, 0);
            break;

        case TRAP_EVENT_SFP_TEMP_HIGH_WARNING:
            SYSLOG_PMGR_AddFormatMsgEntry(&owner_info, SFP_TEMP_HIGH_WARNING_MESSAGE_INDEX, &trap_data->u.sfp_ddm_alarmwarn_trap.sfp_ddm_alarmwarn_ifindex, 0, 0);
            break;

        case TRAP_EVENT_SFP_TEMP_LOW_WARNING:
            SYSLOG_PMGR_AddFormatMsgEntry(&owner_info, SFP_TEMP_LOW_WARNING_MESSAGE_INDEX, &trap_data->u.sfp_ddm_alarmwarn_trap.sfp_ddm_alarmwarn_ifindex, 0, 0);
            break;

        case TRAP_EVENT_SFP_TEMP_ALARMWARN_CEASE:
            SYSLOG_PMGR_AddFormatMsgEntry(&owner_info, SFP_TEMP_ALARMWARN_CEASE_MESSAGE_INDEX, &trap_data->u.sfp_ddm_alarmwarn_trap.sfp_ddm_alarmwarn_ifindex, 0, 0);
            break;

        case TRAP_EVENT_SFP_VOLTAGE_HIGH_ALARM:
            SYSLOG_PMGR_AddFormatMsgEntry(&owner_info, SFP_VOLTAGE_HIGH_ALARM_MESSAGE_INDEX, &trap_data->u.sfp_ddm_alarmwarn_trap.sfp_ddm_alarmwarn_ifindex, 0, 0);
            break;

        case TRAP_EVENT_SFP_VOLTAGE_LOW_ALARM:
            SYSLOG_PMGR_AddFormatMsgEntry(&owner_info, SFP_VOLTAGE_LOW_ALARM_MESSAGE_INDEX, &trap_data->u.sfp_ddm_alarmwarn_trap.sfp_ddm_alarmwarn_ifindex, 0, 0);
            break;

        case TRAP_EVENT_SFP_VOLTAGE_HIGH_WARNING:
            SYSLOG_PMGR_AddFormatMsgEntry(&owner_info, SFP_VOLTAGE_HIGH_WARNING_MESSAGE_INDEX, &trap_data->u.sfp_ddm_alarmwarn_trap.sfp_ddm_alarmwarn_ifindex, 0, 0);
            break;

        case TRAP_EVENT_SFP_VOLTAGE_LOW_WARNING:
            SYSLOG_PMGR_AddFormatMsgEntry(&owner_info, SFP_VOLTAGE_LOW_WARNING_MESSAGE_INDEX, &trap_data->u.sfp_ddm_alarmwarn_trap.sfp_ddm_alarmwarn_ifindex, 0, 0);
            break;

        case TRAP_EVENT_SFP_VOLTAGE_ALARMWARN_CEASE:
            SYSLOG_PMGR_AddFormatMsgEntry(&owner_info, SFP_VOLTAGE_ALARMWARN_CEASE_MESSAGE_INDEX, &trap_data->u.sfp_ddm_alarmwarn_trap.sfp_ddm_alarmwarn_ifindex, 0, 0);
            break;

        case TRAP_EVENT_SFP_CURRENT_HIGH_ALARM:
            SYSLOG_PMGR_AddFormatMsgEntry(&owner_info, SFP_CURRENT_HIGH_ALARM_MESSAGE_INDEX, &trap_data->u.sfp_ddm_alarmwarn_trap.sfp_ddm_alarmwarn_ifindex, 0, 0);
            break;

        case TRAP_EVENT_SFP_CURRENT_LOW_ALARM:
            SYSLOG_PMGR_AddFormatMsgEntry(&owner_info, SFP_CURRENT_LOW_ALARM_MESSAGE_INDEX, &trap_data->u.sfp_ddm_alarmwarn_trap.sfp_ddm_alarmwarn_ifindex, 0, 0);
            break;

        case TRAP_EVENT_SFP_CURRENT_HIGH_WARNING:
            SYSLOG_PMGR_AddFormatMsgEntry(&owner_info, SFP_CURRENT_HIGH_WARNING_MESSAGE_INDEX, &trap_data->u.sfp_ddm_alarmwarn_trap.sfp_ddm_alarmwarn_ifindex, 0, 0);
            break;

        case TRAP_EVENT_SFP_CURRENT_LOW_WARNING:
            SYSLOG_PMGR_AddFormatMsgEntry(&owner_info, SFP_CURRENT_LOW_WARNING_MESSAGE_INDEX, &trap_data->u.sfp_ddm_alarmwarn_trap.sfp_ddm_alarmwarn_ifindex, 0, 0);
            break;

        case TRAP_EVENT_SFP_CURRENT_ALARMWARN_CEASE:
            SYSLOG_PMGR_AddFormatMsgEntry(&owner_info, SFP_CURRENT_ALARMWARN_CEASE_MESSAGE_INDEX, &trap_data->u.sfp_ddm_alarmwarn_trap.sfp_ddm_alarmwarn_ifindex, 0, 0);
            break;
#endif  /* (SYS_CPNT_SFP_DDM_ALARMWARN_TRAP == TRUE) */

        /* dhcpRogueServerAttackTrap(114)
         * DHCP client sends a trap when receiving a packet from a rogue server.
         */
        case TRAP_EVENT_DHCP_ROGUE_SERVER_ATTACK:
        {
            char lport_msg[SYSLOG_ADPT_MESSAGE_LENGTH] = {0};
            char mac_msg[SYSLOG_ADPT_MESSAGE_LENGTH] = {0};

            if (IF_PMGR_GetIfType(trap_data->u.dhcp_rogue_server_attack.dhcpClientPortIfIndex, &iftype) == FALSE)
            {
                if (debug_mode)
                {
                    printf("\r\n%s: Failed to get iftype of ifindex = %lu!\r\n",
                           __FUNCTION__, (unsigned long)trap_data->u.dhcp_rogue_server_attack.dhcpClientPortIfIndex);
                }
                return;
            }

            switch (iftype)
            {
                case IF_MGR_NORMAL_IFINDEX:
                    SWCTRL_POM_IfindexToUport(trap_data->u.dhcp_rogue_server_attack.dhcpClientPortIfIndex, &unit, &port);
                    snprintf((char *)lport_msg, sizeof(lport_msg), "Eth %ld/%ld", (long)unit, (long)port);
                    break;

                case IF_MGR_TRUNK_IFINDEX:
                    TRK_OM_IfindexToTrunkId(trap_data->u.dhcp_rogue_server_attack.dhcpClientPortIfIndex, &trunk_id);
                    snprintf((char *)lport_msg, sizeof(lport_msg), "Trunk %ld", (long)trunk_id);
                    break;

                default:
                    snprintf((char *)lport_msg, sizeof(lport_msg), "unknown port");
                    break;
            }
            lport_msg[sizeof(lport_msg)-1] =  '\0';

            snprintf((char *)mac_msg, sizeof(mac_msg),"%02X%02X%02X%02X%02X%02X",
                trap_data->u.dhcp_rogue_server_attack.dhcpServerMacAddress[0],
                trap_data->u.dhcp_rogue_server_attack.dhcpServerMacAddress[1],
                trap_data->u.dhcp_rogue_server_attack.dhcpServerMacAddress[2],
                trap_data->u.dhcp_rogue_server_attack.dhcpServerMacAddress[3],
                trap_data->u.dhcp_rogue_server_attack.dhcpServerMacAddress[4],
                trap_data->u.dhcp_rogue_server_attack.dhcpServerMacAddress[5]);
            mac_msg[sizeof(mac_msg)-1] = '\0';

            SYSLOG_PMGR_AddFormatMsgEntry(&owner_info, DHCP_ROGUE_SERVER_ATTACK_MESSAGE_INDEX,
                                         lport_msg,
                                         &(trap_data->u.dhcp_rogue_server_attack.dhcpServerIpAddress),
                                         mac_msg);
            break;
        }

        case TRAP_EVENT_XSTP_PORT_STATE_CHANGE:
        {
            char temp_msg[SYSLOG_ADPT_MESSAGE_LENGTH] = {0};

            if (IF_PMGR_GetIfType(trap_data->u.xstp_port_state_change.lport, &iftype) == FALSE)
            {
                if (debug_mode)
                {
                    printf("\r\n%s: Failed to get iftype of ifindex = %lu!\r\n",
                           __FUNCTION__, (unsigned long)trap_data->u.xstp_port_state_change.lport);
                }
                return;
            }

            switch (iftype)
            {
                case IF_MGR_NORMAL_IFINDEX:
                    SWCTRL_POM_IfindexToUport(trap_data->u.xstp_port_state_change.lport, &unit, &port);
                    snprintf((char *)temp_msg, sizeof(temp_msg), "Eth %lu/%lu", (unsigned long)unit, (unsigned long)port);
                    break;

                case IF_MGR_TRUNK_IFINDEX:
                    TRK_OM_IfindexToTrunkId(trap_data->u.xstp_port_state_change.lport, &trunk_id);
                    snprintf((char *)temp_msg, sizeof(temp_msg), "Trunk %lu", (unsigned long)trunk_id);
                    break;

                default:
                    snprintf((char *)temp_msg, sizeof(temp_msg), "unknown port");
                    break;
            }

            if (trap_data->u.xstp_port_state_change.forwarding == TRUE)
            {
                strcat((char *)temp_msg, " becomes forwarding");
            }
            else
            {
                strcat((char *)temp_msg, " becomes non-forwarding");
            }
            temp_msg[sizeof(temp_msg)-1] =  '\0';
            SYSLOG_PMGR_AddFormatMsgEntry(&owner_info, XSTP_PORT_STATE_CHANGE_MESSAGE_INDEX,
                                          &(trap_data->u.xstp_port_state_change.mstid),
                                          temp_msg,
                                          0);
            break;
        }

        /* Accton private MIB
         */

#if (SYS_CPNT_BGP == TRUE)
        case TRAP_EVENT_BGP_ESTABLISHED_NOTIFICATION:
        {
            char  ip_str[16];
            UI8_T *data_p;

            data_p = trap_data->u.bgp_established.bgpPeerRemoteAddr;
            snprintf(ip_str, sizeof(ip_str), "%u.%u.%u.%u",*data_p,*(data_p+1),*(data_p+2),*(data_p+3));
            SYSLOG_PMGR_AddFormatMsgEntry(&owner_info, BGP_ESTABLISHED_NOTIFICATION_MESSAGE_INDEX,
                                          ip_str,
                                          trap_data->u.bgp_established.bgpPeerLastError,
                                          (char *)LOOKUP(bgp_status_msg, trap_data->u.bgp_established.bgpPeerState));
            break;
        }

        case TRAP_EVENT_BGP_BACKWARD_TRANS_NOTIFICATION:
        {
            char  ip_str[16];
            UI8_T *data_p;

            data_p = trap_data->u.bgp_backward_trans.bgpPeerRemoteAddr;
            snprintf(ip_str, sizeof(ip_str), "%u.%u.%u.%u",*data_p,*(data_p+1),*(data_p+2),*(data_p+3));
            SYSLOG_PMGR_AddFormatMsgEntry(&owner_info, BGP_BACKWARD_TRANS_NOTIFICATION_MESSAGE_INDEX,
                                          ip_str,
                                          trap_data->u.bgp_backward_trans.bgpPeerLastError,
                                          (char *)LOOKUP(bgp_status_msg, trap_data->u.bgp_established.bgpPeerState));
            break;
        }
#endif

        case TRAP_EVENT_XSTP_ROOT_BRIDGE_CHANGED:
            SYSLOG_PMGR_AddFormatMsgEntry(&owner_info,
                XSTP_ROOT_BRIDGE_CHANGED_INDEX,
                &(trap_data->u.xstp_root_bridge_changed.priority),
                &(trap_data->u.xstp_root_bridge_changed.instance_id),
                &(trap_data->u.xstp_root_bridge_changed.bridge_address));
            break;

#if(SYS_CPNT_SYNCE == TRUE)
        case TRAP_EVENT_SYNCE_SSM_RX:
        {
            char temp_msg[SYSLOG_ADPT_MESSAGE_LENGTH] = {0};
            SWCTRL_POM_IfindexToUport(trap_data->u.synce_ssm_rx.ifindex, &unit, &port);
            SYSFUN_Sprintf(temp_msg, "%lu/%lu", (unsigned long)unit, (unsigned long)port);
            SYSLOG_PMGR_AddFormatMsgEntry(&owner_info,
                SYNCE_SSM_RX_MESSAGE_INDEX,
                temp_msg,
                &(trap_data->u.synce_ssm_rx.status),
                &(trap_data->u.synce_ssm_rx.ssm_status));
        }
            break;

        case TRAP_EVENT_SYNCE_CLOCK_SRC:
        {
            char temp_msg[SYSLOG_ADPT_MESSAGE_LENGTH] = {0};
            SWCTRL_POM_IfindexToUport(trap_data->u.synce_ssm_rx.ifindex, &unit, &port);
            SYSFUN_Sprintf(temp_msg, "%lu/%lu", (unsigned long)unit, (unsigned long)port);

            SYSLOG_PMGR_AddFormatMsgEntry(&owner_info,
                SYNCE_CLOCK_SRC_MESSAGE_INDEX,
                temp_msg, NULL, NULL);
        }
            break;
#endif
        case TRAP_EVENT_USERAUTH_AUTHENTICATION_FAILURE:
        {
            SYSLOG_MGR_UserInfo_T  user_info;

            owner_info.level = SYSLOG_LEVEL_WARNING;

            memset(&user_info, 0, sizeof(user_info));
            user_info.session_type = trap_data->u.user_info.session_type;
            strncpy(user_info.user_name, trap_data->u.user_info.user_name,
                sizeof(user_info.user_name)-1);
            user_info.user_name[sizeof(user_info.user_name)-1] = '\0';
            memcpy(&user_info.user_ip, &trap_data->u.user_info.user_ip,
                sizeof(user_info.user_ip));
            memcpy(&user_info.user_mac, &trap_data->u.user_info.user_mac,
                sizeof(user_info.user_mac));

            SYSLOG_PMGR_AddFormatMsgEntry(&owner_info,
                USERAUTH_AUTHENTICATION_FAILURE_MESSAGE_INDEX, (void*)&user_info, 0, 0);
            break;
        }

        case TRAP_EVENT_USERAUTH_AUTHENTICATION_SUCCESS:
        {
            SYSLOG_MGR_UserInfo_T  user_info;

            memset(&user_info, 0, sizeof(user_info));
            user_info.session_type = trap_data->u.user_info.session_type;
            strncpy(user_info.user_name, trap_data->u.user_info.user_name,
                sizeof(user_info.user_name)-1);
            user_info.user_name[sizeof(user_info.user_name)-1] = '\0';
            memcpy(&user_info.user_ip, &trap_data->u.user_info.user_ip,
                sizeof(user_info.user_ip));
            memcpy(&user_info.user_mac, &trap_data->u.user_info.user_mac,
                sizeof(user_info.user_mac));

            SYSLOG_PMGR_AddFormatMsgEntry(&owner_info,
                USERAUTH_AUTHENTICATION_SUCCESS_MESSAGE_INDEX, (void*)&user_info, 0, 0);
            break;
        }

        case TRAP_EVENT_LOGIN:
        {
            SYSLOG_MGR_UserInfo_T  user_info;

            memset(&user_info, 0, sizeof(user_info));
            user_info.session_type = trap_data->u.user_info.session_type;
            strncpy(user_info.user_name, trap_data->u.user_info.user_name,
                sizeof(user_info.user_name)-1);
            user_info.user_name[sizeof(user_info.user_name)-1] = '\0';
            memcpy(&user_info.user_ip, &trap_data->u.user_info.user_ip,
                sizeof(user_info.user_ip));
            memcpy(&user_info.user_mac, &trap_data->u.user_info.user_mac,
                sizeof(user_info.user_mac));

            SYSLOG_PMGR_AddFormatMsgEntry(&owner_info,
                LOGIN_MESSAGE_INDEX, (void*)&user_info, 0, 0);
            break;
        }

        case TRAP_EVENT_LOGOUT:
        {
            SYSLOG_MGR_UserInfo_T  user_info;

            memset(&user_info, 0, sizeof(user_info));
            user_info.session_type = trap_data->u.user_info.session_type;
            strncpy(user_info.user_name, trap_data->u.user_info.user_name,
                sizeof(user_info.user_name)-1);
            user_info.user_name[sizeof(user_info.user_name)-1] = '\0';
            memcpy(&user_info.user_ip, &trap_data->u.user_info.user_ip,
                sizeof(user_info.user_ip));
            memcpy(&user_info.user_mac, &trap_data->u.user_info.user_mac,
                sizeof(user_info.user_mac));

            SYSLOG_PMGR_AddFormatMsgEntry(&owner_info,
                LOGOUT_MESSAGE_INDEX, (void*)&user_info, 0, 0);
            break;
        }

        case TRAP_EVENT_FILE_COPY:
        {
            if (trap_data->u.file_copy_entry.file_copy_info.status == VAL_fileCopyStatus_fileCopySuccess)
            {
                owner_info.level = SYSLOG_LEVEL_INFO;
            }
            else
            {
                owner_info.level = SYSLOG_LEVEL_WARNING;
            }

            SYSLOG_PMGR_AddFormatMsgEntry(&owner_info, XFER_FILE_COPY_MESSAGE_INDEX,
                (void*)&trap_data->u.user_info, (void*)&trap_data->u.file_copy_entry.file_copy_info, 0);

            break;
        }

        case TRAP_EVENT_USERAUTH_CREATE_USER:
        {
            owner_info.level = SYSLOG_LEVEL_DEBUG;

            SYSLOG_PMGR_AddFormatMsgEntry(&owner_info,
                                          USERAUTH_CREATE_USER_MESSAGE_INDEX,
                                          (void*)&trap_data->u.userauth_account,
                                          0,
                                          0);
            break;
        }

        case TRAP_EVENT_USERAUTH_DELETE_USER:
        {
            owner_info.level = SYSLOG_LEVEL_DEBUG;

            SYSLOG_PMGR_AddFormatMsgEntry(&owner_info,
                                          USERAUTH_DELETE_USER_MESSAGE_INDEX,
                                          (void*)&trap_data->u.userauth_account,
                                          0,
                                          0);
            break;
        }

        case TRAP_EVENT_USERAUTH_MODIFY_USER_PRIVILEGE:
        {
            owner_info.level = SYSLOG_LEVEL_DEBUG;

            SYSLOG_PMGR_AddFormatMsgEntry(&owner_info,
                                          USERAUTH_MODIFY_USER_PRIVILEGE_MESSAGE_INDEX,
                                          (void*)&trap_data->u.userauth_account,
                                          0,
                                          0);
            break;
        }

        default:
            if (debug_mode)
                printf("FUNCTION:SNMP_MGR_TrapLog; DESC:unknow trap type=[%lu]\n",(unsigned long)trap_data->trap_type);
            SYSLOG_PMGR_AddFormatMsgEntry(&owner_info, SWITCH_TO_DEFAULT_MESSAGE_INDEX, "TRAP_EVENT_TrapLog", 0, 0);
            break;
    } /* end of switch */

    return;
} /* end of SNMP_MGR_TrapLog() */

/* ---------------------------------------------------------------------
 * ROUTINE NAME  - SNMP_MGR_BuildOID
 * ---------------------------------------------------------------------
 * PURPOSE: This function will build the result OID accourding to the OID+subOID
 * INPUT : *SysOid, lenSysOid, *SubOid, lenSubOid, lenIdx
 * OUTPUT: *ResultOid, *lenResultOid
 * RETURN: TRUE/FALSE
 * NOTES : None
 * ---------------------------------------------------------------------
 */
static BOOL_T SNMP_MGR_BuildOID(oid *SysOid, UI32_T lenSysOid, oid *SubOid,
                       UI32_T lenSubOid, UI32_T lenIdx,oid *ResultOid, int *lenResultOid)
{
    oid ZeroOid[SYS_ADPT_MAX_OID_COUNT];
    memset(ZeroOid,0,sizeof(ZeroOid));
    SNMP_MGR_OidCpy(ResultOid, 0, SysOid, lenSysOid);
    SNMP_MGR_OidCpy(ResultOid, lenSysOid, SubOid, lenSubOid);
    SNMP_MGR_OidCpy(ResultOid,lenSysOid + lenSubOid, ZeroOid, lenIdx);
    *lenResultOid=lenSysOid+lenSubOid;
    return TRUE;
}

/* ---------------------------------------------------------------------
 * ROUTINE NAME  - SNMP_MGR_sOidToiOid
 * ---------------------------------------------------------------------
 * PURPOSE: This function will read a string and build the OID in array form.
 * INPUT : *sOid
 * OUTPUT: *iOid, *lenOid
 * RETURN: TRUE/FALSE
 * NOTES : None
 * ---------------------------------------------------------------------
 */
static BOOL_T SNMP_MGR_sOidToiOid(char *sOid, oid *iOid, int *lenOid)
{
    UI32_T i,idx=0;
    char *ptr;
    ptr=sOid;
    iOid[idx++]=atoi(ptr);
    for (i=0; i < strlen(sOid); i++)
    {
        if (sOid[i]=='.')
        {
            ptr=sOid+i+1;
            iOid[idx++]=atoi(ptr);
        }
    }
    *lenOid=idx;
    return TRUE;
}

/* ---------------------------------------------------------------------
 * ROUTINE NAME  - SNMP_MGR_initSysObjectID
 * ---------------------------------------------------------------------
 * PURPOSE: This function will init the sysObjectID for trap packet use.
 * INPUT : none.
 * OUTPUT: none.
 * RETURN: TRUE/FALSE
 * NOTES : None
 * ---------------------------------------------------------------------
 */
static BOOL_T SNMP_MGR_initSysObjectID(void)
{
    char sysObjectID_sz[SYS_ADPT_MAX_OID_STRING_LEN + 1];

    if (! SYS_PMGR_GetSysObjectID(SYS_VAL_LOCAL_UNIT_ID, (UI8_T *)sysObjectID_sz))
    {
        SYSFUN_Debug_Printf("%s: SYS_PMGR_GetSysObjectID return false\r\n", __FUNCTION__);
        strcpy(sysObjectID_sz, "0.0");
    }

    SNMP_MGR_sOidToiOid(sysObjectID_sz, ID_sysObjectID_value, &len_sysObjectID_value);

    return TRUE;
}

/* ---------------------------------------------------------------------
 * ROUTINE NAME  - SNMP_MGR_OidCpy
 * ---------------------------------------------------------------------
 * PURPOSE: This function will copy *Oid2 into *Oid1.
 * INPUT : *Oid2, lenOid2
 * OUTPUT: *Oid1, lenOid1
 * RETURN: TRUE/FALSE
 * NOTES : None
 * ---------------------------------------------------------------------
 */
static BOOL_T SNMP_MGR_OidCpy(oid *Oid1, UI32_T lenOid1, oid *Oid2, UI32_T lenOid2)
{
    UI32_T i;
    for(i=1; i<=lenOid2; i++)
    {
        Oid1[lenOid1+i-1]=Oid2[i-1];
    }
    return TRUE;
}

/* ---------------------------------------------------------------------
 * ROUTINE NAME  - SNMP_MGR_initTrapEs3626a
 * ---------------------------------------------------------------------
 * PURPOSE: This function will init the trap variable for trap packet use.
 * INPUT : none.
 * OUTPUT: none.
 * RETURN: TRUE/FALSE
 * NOTES : None
 * ---------------------------------------------------------------------
 */
static BOOL_T SNMP_MGR_initTrapEs3626a(void)
{
    #define DEFAULT_MIB_ROOT "1.3.6.1.4.1.259.6.10.999"
    char privateMibRoot[SYS_ADPT_MAX_OID_STRING_LEN + 1];

    if (!SYS_PMGR_GetPrivateMibRoot(SYS_VAL_LOCAL_UNIT_ID, (UI8_T *)privateMibRoot))
    {
        SYSFUN_Debug_Printf("SNMP_MGR_initTrapEs3626a:SYS_PMGR_GetPrivateMibRoot return false\n");
        strcpy(privateMibRoot, DEFAULT_MIB_ROOT);
    }

    SNMP_MGR_sOidToiOid(privateMibRoot, ID_es3626aMIB, &len_es3626aMIB);

    /* The trap ID should be private MIB root.2(xxxNotification).1(xxxxTrap)*/
    memcpy(ID_es3626aTrap, ID_es3626aMIB, len_es3626aMIB* sizeof(oid));
    ID_es3626aTrap[len_es3626aMIB] = 2;
    ID_es3626aTrap[len_es3626aMIB+1] = 1;
    len_es3626aTrap = len_es3626aMIB+2;

    SNMP_MGR_BuildOID(ID_es3626aMIB, len_es3626aMIB, SubID_trapVarMacAddr,
            lenSubID_trapVarMacAddr, lenIdx_trapVarMacAddr,
            ID_trapVarMacAddr, &len_trapVarMacAddr);

    SNMP_MGR_BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_trapIfIndex,
            lenSubID_trapIfIndex, lenIdx_trapIfIndex,
            ID_trapIfIndex, &len_trapIfIndex);
    SNMP_MGR_BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_trapVlanId,
            lenSubID_trapVlanId, lenIdx_trapVlanId,
            ID_trapVlanId, &len_trapVlanId);

    SNMP_MGR_BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_swIndivPowerUnitIndex,
            lenSubID_swIndivPowerUnitIndex, lenIdx_swIndivPowerUnitIndex,
            ID_swIndivPowerUnitIndex, &len_swIndivPowerUnitIndex);
    SNMP_MGR_BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_swIndivPowerIndex,
            lenSubID_swIndivPowerIndex, lenIdx_swIndivPowerIndex,
            ID_swIndivPowerIndex, &len_swIndivPowerIndex);
    SNMP_MGR_BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_swIndivPowerStatus,
            lenSubID_swIndivPowerStatus, lenIdx_swIndivPowerStatus,
            ID_swIndivPowerStatus, &len_swIndivPowerStatus);
    SNMP_MGR_BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_swPowerStatusChangeTrap,
            lenSubID_swPowerStatusChangeTrap, lenIdx_swPowerStatusChangeTrap,
            ID_swPowerStatusChangeTrap, &len_swPowerStatusChangeTrap);
#if (SYS_CPNT_INTRUSION_MSG_TRAP == TRUE)
    SNMP_MGR_BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_swPortSecurityTrap,
            lenSubID_swPortSecurityTrap, lenIdx_swPortSecurityTrap,
            ID_swPortSecurityTrap, &len_swPortSecurityTrap);
#endif

#if (SYS_CPNT_STKTPLG_FAN_DETECT == TRUE)
    SNMP_MGR_BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_swFanFailureTrap,
            lenSubID_swFanFailureTrap, lenIdx_swFanFailureTrap,
            ID_swFanFailureTrap, &len_swFanFailureTrap);
    SNMP_MGR_BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_swFanRecoverTrap,
            lenSubID_swFanRecoverTrap, lenIdx_swFanRecoverTrap,
            ID_swFanRecoverTrap, &len_swFanRecoverTrap);
    SNMP_MGR_BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_switchFanIndex,
            lenSubID_switchFanIndex, lenIdx_switchFanIndex,
            ID_switchFanIndex, &len_switchFanIndex);
    SNMP_MGR_BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_switchUnitIndex,
            lenSubID_switchUnitIndex, lenIdx_switchUnitIndex,
            ID_switchUnitIndex, &len_switchUnitIndex);
#endif

#if (SYS_CPNT_MGMT_IP_FLT == TRUE)
    SNMP_MGR_BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_swIpFilterRejectTrap,
            lenSubID_swIpFilterRejectTrap, lenIdx_swIpFilterRejectTrap,
            ID_swIpFilterRejectTrap, &len_swIpFilterRejectTrap);
    SNMP_MGR_BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_trapIpFilterRejectMode,
            lenSubID_trapIpFilterRejectMode, lenIdx_trapIpFilterRejectMode,
            ID_trapIpFilterRejectMode, &len_trapIpFilterRejectMode);
    SNMP_MGR_BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_trapIpFilterRejectIp,
            lenSubID_trapIpFilterRejectIp, lenIdx_trapIpFilterRejectIp,
            ID_trapIpFilterRejectIp, &len_trapIpFilterRejectIp);
    SNMP_MGR_BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_swIpFilterInetRejectTrap,
            lenSubID_swIpFilterInetRejectTrap, lenIdx_swIpFilterInetRejectTrap,
            ID_swIpFilterInetRejectTrap, &len_swIpFilterInetRejectTrap);
    SNMP_MGR_BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_trapIpFilterRejectInetAddressType,
            lenSubID_trapIpFilterRejectInetAddressType, lenIdx_trapIpFilterRejectInetAddressType,
            ID_trapIpFilterRejectInetAddressType, &len_trapIpFilterRejectInetAddressType);
    SNMP_MGR_BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_trapIpFilterRejectInetAddress,
            lenSubID_trapIpFilterRejectInetAddress, lenIdx_trapIpFilterRejectInetAddress,
            ID_trapIpFilterRejectInetAddress, &len_trapIpFilterRejectInetAddress);
#endif

#if (SYS_CPNT_SMTP == TRUE)
    SNMP_MGR_BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_swSmtpConnFailureTrap,
            lenSubID_swSmtpConnFailureTrap, lenIdx_swSmtpConnFailureTrap,
            ID_swSmtpConnFailureTrap, &len_swSmtpConnFailureTrap);
    SNMP_MGR_BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_smtpServerIp,
            lenSubID_smtpServerIp, lenIdx_smtpServerIp,
            ID_smtpServerIp, &len_smtpServerIp);
#endif

#if (SYS_CPNT_3COM_LOOPBACK_TEST == TRUE)
    SNMP_MGR_BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_switchLoopbackTestFailurePorts,
            lenSubID_switchLoopbackTestFailurePorts, lenIdx_switchLoopbackTestFailurePorts,
            ID_switchLoopbackTestFailurePorts, &len_switchLoopbackTestFailurePorts);
#endif

    /* swMainBoardVerMismatchNotificaiton(56),
     * swModuleVerMismatchNotificaiton(57)
     */
    SNMP_MGR_BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_swModuleOpCodeVer,
            lenSubID_swModuleOpCodeVer, lenIdx_swModuleOpCodeVer,
            ID_swModuleOpCodeVer, &len_swModuleOpCodeVer);
    SNMP_MGR_BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_swOpCodeVer,
            lenSubID_swOpCodeVer, lenIdx_swOpCodeVer,
            ID_swOpCodeVer, &len_swOpCodeVer);
    SNMP_MGR_BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_swExpectedModuleOpCodeVer,
            lenSubID_swExpectedModuleOpCodeVer, lenIdx_swExpectedModuleOpCodeVer,
            ID_swExpectedModuleOpCodeVer, &len_swExpectedModuleOpCodeVer);

#if (SYS_CPNT_THERMAL_DETECT == TRUE)
    /* swThermalRisingNotification(58),
     * swThermalFallingNotification(59)
     */
    SNMP_MGR_BuildOID(ID_es3626aMIB, len_es3626aMIB, SubID_switchThermalTempValue,
            lenSubID_switchThermalTempValue, lenIdx_switchThermalTempValue,
            ID_switchThermalTempValue, &len_switchThermalTempValue);

    SNMP_MGR_BuildOID(ID_es3626aMIB, len_es3626aMIB, SubID_switchThermalActionRisingThreshold,
            lenSubID_switchThermalActionRisingThreshold, lenIdx_switchThermalActionRisingThreshold,
            ID_switchThermalActionRisingThreshold, &len_switchThermalActionRisingThreshold);

    SNMP_MGR_BuildOID(ID_es3626aMIB, len_es3626aMIB, SubID_switchThermalActionFallingThreshold,
            lenSubID_switchThermalActionFallingThreshold, lenIdx_switchThermalActionFallingThreshold,
            ID_switchThermalActionFallingThreshold, &len_switchThermalActionFallingThreshold);
#endif

#if (SYS_CPNT_CFM == TRUE)
/*dot1agCfmMepUp*/
    SNMP_MGR_BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_dot1agCfmMepUp,
            lenSubID_dot1agCfmMepUp, lenIdx_dot1agCfmMepUp,
            ID_dot1agCfmMepUp, &len_dot1agCfmMepUp);

/*dot1agCfmMepDown*/
    SNMP_MGR_BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_dot1agCfmMepDown,
            lenSubID_dot1agCfmMepDown, lenIdx_dot1agCfmMepDown,
            ID_dot1agCfmMepDown, &len_dot1agCfmMepDown);

/*dot1agCfmConfigFail*/
    SNMP_MGR_BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_dot1agCfmConfigFail,
            lenSubID_dot1agCfmConfigFail, lenIdx_dot1agCfmConfigFail,
            ID_dot1agCfmConfigFail, &len_dot1agCfmConfigFail);

/*dot1agCfmLoopFind*/
    SNMP_MGR_BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_dot1agCfmLoopFind,
            lenSubID_dot1agCfmLoopFind, lenIdx_dot1agCfmLoopFind,
            ID_dot1agCfmLoopFind, &len_dot1agCfmLoopFind);

/*dot1agCfmMepUnknown*/
    SNMP_MGR_BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_dot1agCfmMepUnknown,
            lenSubID_dot1agCfmMepUnknown, lenIdx_dot1agCfmMepUnknown,
            ID_dot1agCfmMepUnknown, &len_dot1agCfmMepUnknown);

/*dot1agCfmMepMissing*/
    SNMP_MGR_BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_dot1agCfmMepMissing,
            lenSubID_dot1agCfmMepMissing, lenIdx_dot1agCfmMepMissing,
            ID_dot1agCfmMepMissing, &len_dot1agCfmMepMissing);

/*dot1agCfmMaUp*/
    SNMP_MGR_BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_dot1agCfmMaUp,
            lenSubID_dot1agCfmMaUp, lenIdx_dot1agCfmMaUp,
            ID_dot1agCfmMaUp, &len_dot1agCfmMaUp);

#endif  /* #if(SYS_CPNT_CFM==TRUE) */

#if (SYS_CPNT_ATC_STORM == TRUE)

    SNMP_MGR_BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_atcBcastStormTcApplyTime,
            lenSubID_atcBcastStormTcApplyTime, lenIdx_atcBcastStormTcApplyTime,
            ID_atcBcastStormTcApplyTime, &len_atcBcastStormTcApplyTime);
    SNMP_MGR_BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_atcBcastStormTcReleaseTime,
            lenSubID_atcBcastStormTcReleaseTime, lenIdx_atcBcastStormTcReleaseTime,
            ID_atcBcastStormTcReleaseTime, &len_atcBcastStormTcReleaseTime);
    SNMP_MGR_BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_atcMcastStormTcApplyTime,
            lenSubID_atcMcastStormTcApplyTime, lenIdx_atcMcastStormTcApplyTime,
            ID_atcMcastStormTcApplyTime, &len_atcMcastStormTcApplyTime);
    SNMP_MGR_BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_atcMcastStormTcReleaseTime,
            lenSubID_atcMcastStormTcReleaseTime, lenIdx_atcMcastStormTcReleaseTime,
            ID_atcMcastStormTcReleaseTime, &len_atcMcastStormTcReleaseTime);

   SNMP_MGR_BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_atcBcastStormIfIndex,
            lenSubID_atcBcastStormIfIndex, lenIdx_atcBcastStormIfIndex,
            ID_atcBcastStormIfIndex, &len_atcBcastStormIfIndex);
   SNMP_MGR_BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_atcBcastStormSampleType,
            lenSubID_atcBcastStormSampleType, lenIdx_atcBcastStormSampleType,
            ID_atcBcastStormSampleType, &len_atcBcastStormSampleType);
   SNMP_MGR_BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_atcBcastStormCurrentTrafficRate,
            lenSubID_atcBcastStormCurrentTrafficRate, lenIdx_atcBcastStormCurrentTrafficRate,
            ID_atcBcastStormCurrentTrafficRate, &len_atcBcastStormCurrentTrafficRate);
   SNMP_MGR_BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_atcBcastStormAlarmThreshold,
            lenSubID_atcBcastStormAlarmThreshold, lenIdx_atcBcastStormAlarmThreshold,
            ID_atcBcastStormAlarmThreshold, &len_atcBcastStormAlarmThreshold);
   SNMP_MGR_BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_atcBcastStormClearThreshold,
            lenSubID_atcBcastStormClearThreshold, lenIdx_atcBcastStormClearThreshold,
            ID_atcBcastStormClearThreshold, &len_atcBcastStormClearThreshold);
   SNMP_MGR_BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_atcBcastStormTcAction,
            lenSubID_atcBcastStormTcAction, lenIdx_atcBcastStormTcAction,
            ID_atcBcastStormTcAction, &len_atcBcastStormTcAction);

   SNMP_MGR_BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_atcMcastStormIfIndex,
            lenSubID_atcMcastStormIfIndex, lenIdx_atcMcastStormIfIndex,
            ID_atcMcastStormIfIndex, &len_atcMcastStormIfIndex);
   SNMP_MGR_BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_atcMcastStormSampleType,
            lenSubID_atcMcastStormSampleType, lenIdx_atcMcastStormSampleType,
            ID_atcMcastStormSampleType, &len_atcMcastStormSampleType);
   SNMP_MGR_BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_atcMcastStormCurrentTrafficRate,
            lenSubID_atcMcastStormCurrentTrafficRate, lenIdx_atcMcastStormCurrentTrafficRate,
            ID_atcMcastStormCurrentTrafficRate, &len_atcMcastStormCurrentTrafficRate);
   SNMP_MGR_BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_atcMcastStormAlarmThreshold,
            lenSubID_atcMcastStormAlarmThreshold, lenIdx_atcMcastStormAlarmThreshold,
            ID_atcMcastStormAlarmThreshold, &len_atcMcastStormAlarmThreshold);
   SNMP_MGR_BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_atcMcastStormClearThreshold,
            lenSubID_atcMcastStormClearThreshold, lenIdx_atcMcastStormClearThreshold,
            ID_atcMcastStormClearThreshold, &len_atcMcastStormClearThreshold);
   SNMP_MGR_BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_atcMcastStormTcAction,
            lenSubID_atcMcastStormTcAction, lenIdx_atcMcastStormTcAction,
            ID_atcMcastStormTcAction, &len_atcMcastStormTcAction);

#endif
#if (SYS_CPNT_ALARM_INPUT_DETECT == TRUE)
SNMP_MGR_BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_swAlarmInput,
            lenSubID_swAlarmInput, lenIdx_swAlarmInput,
            ID_swAlarmInput, &len_swAlarmInput);
SNMP_MGR_BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_swAlarmUnitIndex,
            lenSubID_swAlarmUnitIndex, lenIdx_swAlarmUnitIndex,
            ID_swAlarmUnitIndex, &len_swAlarmUnitIndex);
SNMP_MGR_BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_swAlarmInputType,
            lenSubID_swAlarmInputType, lenIdx_swAlarmInputType,
            ID_swAlarmInputType, &len_swAlarmInputType);
SNMP_MGR_BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_swAlarmInputName,
            lenSubID_swAlarmInputName, lenIdx_swAlarmInputName,
            ID_swAlarmInputName, &len_swAlarmInputName);
#endif
#if (SYS_CPNT_ALARM_DETECT == TRUE)
    SNMP_MGR_BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_MajorAlarmOutput,
            lenSubID_MajorAlarmOutput, lenIdx_MajorAlarmOutput,
            ID_MajorAlarmOutput, &len_MajorAlarmOutput);
    SNMP_MGR_BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_MajorAlarmOutputRecovery,
            lenSubID_MajorAlarmOutputRecovery, lenIdx_MajorAlarmOutputRecovery,
            ID_MajorAlarmOutputRecovery, &len_MajorAlarmOutputRecovery);
    SNMP_MGR_BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_MinorAlarmOutput,
            lenSubID_MinorAlarmOutput, lenIdx_MinorAlarmOutput,
            ID_MinorAlarmOutput, &len_MinorAlarmOutput);

#endif
#if (SYS_CPNT_STP_BPDU_GUARD == TRUE)
    SNMP_MGR_BuildOID(ID_es3626aMIB, len_es3626aMIB, SubID_stpBpduGuardPortShutdown,
            lenSubID_stpBpduGuardPortShutdown, lenIdx_stpBpduGuardPortShutdown,
            ID_stpBpduGuardPortShutdown, &len_stpBpduGuardPortShutdown);
#endif

#if(SYS_CPNT_NETACCESS_LINK_DETECTION == TRUE)
    /*networkAccessPortLinkDetectionTrap*/
    SNMP_MGR_BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_networkAccessPortLinkDetectionTrap,
            lenSubID_networkAccessPortLinkDetectionTrap, lenIdx_networkAccessPortLinkDetectionTrap,
            ID_networkAccessPortLinkDetectionTrap, &len_networkAccessPortLinkDetectionTrap);

    /*networkAccessPortLinkDetectionMode*/
    SNMP_MGR_BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_networkAccessPortLinkDetectionMode,
            lenSubID_networkAccessPortLinkDetectionMode, lenIdx_networkAccessPortLinkDetectionMode,
            ID_networkAccessPortLinkDetectionMode, &len_networkAccessPortLinkDetectionMode);

    /*networkAccessPortLinkDetectionAction*/
    SNMP_MGR_BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_networkAccessPortLinkDetectionAction,
            lenSubID_networkAccessPortLinkDetectionAction, lenIdx_networkAccessPortLinkDetectionAction,
            ID_networkAccessPortLinkDetectionAction, &len_networkAccessPortLinkDetectionAction);
#endif

#if(SYS_CPNT_XFER_AUTO_UPGRADE==TRUE)
    /*Auto Upgrade trap*/
    SNMP_MGR_BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_autoUpgradeTrap,
            lenSubID_autoUpgradeTrap, lenIdx_autoUpgradeTrap,
            ID_autoUpgradeTrap, &len_autoUpgradeTrap);

    /*Result*/
    SNMP_MGR_BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_trapAutoUpgradeResult,
            lenSubID_trapAutoUpgradeResult, lenIdx_trapAutoUpgradeResult,
            ID_trapAutoUpgradeResult, &len_trapAutoUpgradeResult);

    /*NewVer*/
    SNMP_MGR_BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_trapAutoUpgradeNewVer,
            lenSubID_trapAutoUpgradeNewVer, lenIdx_trapAutoUpgradeNewVer,
            ID_trapAutoUpgradeNewVer, &len_trapAutoUpgradeNewVer);

#endif

#if (SYS_CPNT_SYSMGMT_RESMIB == TRUE)
        SNMP_MGR_BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_swCpuUtiRisingNotification,
            lenSubID_swCpuUtiRisingNotification, lenIdx_swCpuUtiRisingNotification,
            ID_swCpuUtiRisingNotification, &len_swCpuUtiRisingNotification);

        SNMP_MGR_BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_swCpuUtiFallingNotification,
            lenSubID_swCpuUtiFallingNotification, lenIdx_swCpuUtiFallingNotification,
            ID_swCpuUtiFallingNotification, &len_swCpuUtiFallingNotification);

        SNMP_MGR_BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_swMemoryUtiRisingThresholdNotification,
            lenSubID_swMemoryUtiRisingThresholdNotification, lenIdx_swMemoryUtiRisingThresholdNotification,
            ID_swMemoryUtiRisingThresholdNotification, &len_swMemoryUtiRisingThresholdNotification);

        SNMP_MGR_BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_swMemoryUtiFallingThresholdNotification,
            lenSubID_swMemoryUtiFallingThresholdNotification, lenIdx_swMemoryUtiFallingThresholdNotification,
            ID_swMemoryUtiFallingThresholdNotification, &len_swMemoryUtiFallingThresholdNotification);
#endif /* #if (SYS_CPNT_SYSMGMT_RESMIB == TRUE) */

#if (SYS_CPNT_SYSMGMT_CPU_GUARD == TRUE)
        SNMP_MGR_BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_cpuGuardControlTrap,
            lenSubID_cpuGuardControlTrap, lenIdx_cpuGuardControlTrap,
            ID_cpuGuardControlTrap, &len_cpuGuardControlTrap);

        SNMP_MGR_BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_cpuGuardReleaseTrap,
            lenSubID_cpuGuardReleaseTrap, lenIdx_cpuGuardReleaseTrap,
            ID_cpuGuardReleaseTrap, &len_cpuGuardReleaseTrap);
#endif

        /* DHCP client sends a trap when receiving a packet from a rogue server. */
        /* dhcpRogueServerAttackTrap */
        SNMP_MGR_BuildOID(ID_es3626aMIB, len_es3626aMIB, SubID_dhcpRogueServerAttackTrap,
                lenSubID_dhcpRogueServerAttackTrap, lenIdx_dhcpRogueServerAttackTrap,
                ID_dhcpRogueServerAttackTrap, &len_dhcpRogueServerAttackTrap);

        /* DHCP Client Port IfIndex */
        SNMP_MGR_BuildOID(ID_es3626aMIB, len_es3626aMIB, SubID_dhcpClientPortIfIndex,
                lenSubID_dhcpClientPortIfIndex, lenIdx_dhcpClientPortIfIndex,
                ID_dhcpClientPortIfIndex, &len_dhcpClientPortIfIndex);

        /* DHCP Server IP Address */
        SNMP_MGR_BuildOID(ID_es3626aMIB, len_es3626aMIB, SubID_dhcpServerIpAddress,
                lenSubID_dhcpServerIpAddress, lenIdx_dhcpServerIpAddress,
                ID_dhcpServerIpAddress, &len_dhcpServerIpAddress);

        /* DHCP Server MAC Address */
        SNMP_MGR_BuildOID(ID_es3626aMIB, len_es3626aMIB, SubID_dhcpServerMacAddress,
                lenSubID_dhcpServerMacAddress, lenIdx_dhcpServerMacAddress,
                ID_dhcpServerMacAddress, &len_dhcpServerMacAddress);

#if (SYS_CPNT_SFP_DDM_ALARMWARN_TRAP == TRUE)
    SNMP_MGR_BuildOID(ID_es3626aMIB, len_es3626aMIB, SubID_sfpThresholdAlarmWarnTrap,
                lenSubID_sfpThresholdAlarmWarnTrap, lenIdx_sfpThresholdAlarmWarnTrap,
                ID_sfpThresholdAlarmWarnTrap, &len_sfpThresholdAlarmWarnTrap);
    SNMP_MGR_BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_trapSfpThresholdAlarmWarnIfIndex,
            lenSubID_trapSfpThresholdAlarmWarnIfIndex, lenIdx_sfpThresholdAlarmWarnIfIndex,
            ID_sfpThresholdAlarmWarnIfIndex, &len_sfpThresholdAlarmWarnIfIndex);
    SNMP_MGR_BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_trapSfpThresholdAlarmWarnType,
            lenSubID_trapSfpThresholdAlarmWarnType, lenIdx_sfpThresholdAlarmWarnType,
            ID_sfpThresholdAlarmWarnType, &len_sfpThresholdAlarmWarnType);
#endif

#if (SYS_CPNT_INTRUSION_MSG_TRAP == TRUE)
   SNMP_MGR_BuildOID(ID_es3626aMIB, len_es3626aMIB, SubID_trapPortSecurityIntrusionMac,
            lenSubID_trapPortSecurityIntrusionMac, lenIdx_trapPortSecurityIntrusionMac,
            ID_trapPortSecurityIntrusionMac, &len_trapPortSecurityIntrusionMac);
#endif /*if (SYS_CPNT_INTRUSION_MSG_TRAP == TRUE) */

#if(SYS_CPNT_SYNCE == TRUE)
    /* syncEReceiveSSMTrap */
    SNMP_MGR_BuildOID(ID_es3626aMIB, len_es3626aMIB, SubID_synceRxSsmTrap,
            lenSubID_synceRxSsmTrap, lenIdx_synceRxSsmTrap,
            ID_synceRxSsmTrap, &len_synceRxSsmTrap);

    /* syncELockedClockSource */
    SNMP_MGR_BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_synceClkSrcTrap,
             lenSubID_synceClkSrcTrap, lenIdx_synceClkSrcTrap,
             ID_synceClkSrcTrap, &len_synceClkSrcTrap);

    /* syncEPortIndex */
    SNMP_MGR_BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_syncePortIndex,
             lenSubID_syncePortIndex, lenIdx_syncePortIndex,
             ID_syncePortIndex, &len_syncePortIndex);
    /* syncEPortStatus */
    SNMP_MGR_BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_syncePortStatus,
             lenSubID_syncePortStatus, lenIdx_syncePortStatus,
             ID_syncePortStatus, &len_syncePortStatus);
    /* syncEPortSsmStatus */
    SNMP_MGR_BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_syncePortSsmStatus,
             lenSubID_syncePortSsmStatus, lenIdx_syncePortSsmStatus,
             ID_syncePortSsmStatus, &len_syncePortSsmStatus);

#endif
    SNMP_MGR_BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_trapVarLoginUserName,
            lenSubID_trapVarLoginUserName, lenIdx_trapVarLoginUserName,
            ID_trapVarLoginUserName, &len_trapVarLoginUserName);
    SNMP_MGR_BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_trapVarSessionType,
            lenSubID_trapVarSessionType, lenIdx_trapVarSessionType,
            ID_trapVarSessionType, &len_trapVarSessionType);
    SNMP_MGR_BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_trapVarLoginInetAddressType,
            lenSubID_trapVarLoginInetAddressType, lenIdx_trapVarLoginInetAddressType,
            ID_trapVarLoginInetAddressType, &len_trapVarLoginInetAddressType);
    SNMP_MGR_BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_trapVarLoginInetAddress,
            lenSubID_trapVarLoginInetAddress, lenIdx_trapVarLoginInetAddress,
            ID_trapVarLoginInetAddress, &len_trapVarLoginInetAddress);

    SNMP_MGR_BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_userAuthenticationFailureTrap,
            lenSubID_userAuthenticationFailureTrap, lenIdx_userAuthenticationFailureTrap,
            ID_userAuthenticationFailureTrap, &len_userAuthenticationFailureTrap);
    SNMP_MGR_BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_userAuthenticationSuccessTrap,
            lenSubID_userAuthenticationSuccessTrap, lenIdx_userAuthenticationSuccessTrap,
            ID_userAuthenticationSuccessTrap, &len_userAuthenticationSuccessTrap);
    SNMP_MGR_BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_loginTrap,
            lenSubID_loginTrap, lenIdx_loginTrap,
            ID_loginTrap, &len_loginTrap);
    SNMP_MGR_BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_logoutTrap,
            lenSubID_logoutTrap, lenIdx_logoutTrap,
            ID_logoutTrap, &len_logoutTrap);

    SNMP_MGR_BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_fileCopySrcOperType,
            lenSubID_fileCopySrcOperType, lenIdx_fileCopySrcOperType,
            ID_fileCopySrcOperType, &len_fileCopySrcOperType);
    SNMP_MGR_BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_fileCopySrcFileName,
            lenSubID_fileCopySrcFileName, lenIdx_fileCopySrcFileName,
            ID_fileCopySrcFileName, &len_fileCopySrcFileName);
    SNMP_MGR_BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_fileCopyDestOperType,
            lenSubID_fileCopyDestOperType, lenIdx_fileCopyDestOperType,
            ID_fileCopyDestOperType, &len_fileCopyDestOperType);
    SNMP_MGR_BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_fileCopyDestFileName,
            lenSubID_fileCopyDestFileName, lenIdx_fileCopyDestFileName,
            ID_fileCopyDestFileName, &len_fileCopyDestFileName);
    SNMP_MGR_BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_fileCopyFileType,
            lenSubID_fileCopyFileType, lenIdx_fileCopyFileType,
            ID_fileCopyFileType, &len_fileCopyFileType);
    SNMP_MGR_BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_fileCopyUnitId,
            lenSubID_fileCopyUnitId, lenIdx_fileCopyUnitId,
            ID_fileCopyUnitId, &len_fileCopyUnitId);
    SNMP_MGR_BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_fileCopyStatus,
            lenSubID_fileCopyStatus, lenIdx_fileCopyStatus,
            ID_fileCopyStatus, &len_fileCopyStatus);
    SNMP_MGR_BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_fileCopyServerInetAddressType,
            lenSubID_fileCopyServerInetAddressType, lenIdx_fileCopyServerInetAddressType,
            ID_fileCopyServerInetAddressType, &len_fileCopyServerInetAddressType);
    SNMP_MGR_BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_fileCopyServerInetAddress,
            lenSubID_fileCopyServerInetAddress, lenIdx_fileCopyServerInetAddress,
            ID_fileCopyServerInetAddress, &len_fileCopyServerInetAddress);

    SNMP_MGR_BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_userauthCreateUserTrap,
            lenSubID_userauthCreateUserTrap, lenIdx_userauthCreateUserTrap,
            ID_userauthCreateUserTrap, &len_userauthCreateUserTrap);
    SNMP_MGR_BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_userauthDeleteUserTrap,
            lenSubID_userauthDeleteUserTrap, lenIdx_userauthDeleteUserTrap,
            ID_userauthDeleteUserTrap, &len_userauthDeleteUserTrap);
    SNMP_MGR_BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_userauthModifyUserPrivilegeTrap,
            lenSubID_userauthModifyUserPrivilegeTrap, lenIdx_userauthModifyUserPrivilegeTrap,
            ID_userauthModifyUserPrivilegeTrap, &len_userauthModifyUserPrivilegeTrap);
    SNMP_MGR_BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_userAuthUserName,
            lenSubID_userAuthUserName, lenIdx_userAuthUserName,
            ID_userAuthUserName, &len_userAuthUserName);
    SNMP_MGR_BuildOID(ID_es3626aMIB,len_es3626aMIB, SubID_userAuthPrivilege,
            lenSubID_userAuthPrivilege, lenIdx_userAuthPrivilege,
            ID_userAuthPrivilege, &len_userAuthPrivilege);

#if (SYS_CPNT_AMTR_MAC_NOTIFY == TRUE)
    SNMP_MGR_BuildOID(ID_es3626aMIB, len_es3626aMIB, SubID_macNotificationTrap,
            lenSubID_macNotificationTrap, lenIdx_macNotificationTrap,
            ID_macNotificationTrap, &len_macNotificationTrap);

    /* trapMacNotifyAction */
    SNMP_MGR_BuildOID(ID_es3626aMIB, len_es3626aMIB, SubID_trapMacNotifyAction,
            lenSubID_trapMacNotifyAction, lenIdx_trapMacNotifyAction,
            ID_trapMacNotifyAction, &len_trapMacNotifyAction);
#endif
    return TRUE;
}


/*The below is move from original RmonHise3c.c, we rename all aPI to SNMP_MGR_XXXX*/

/*****************************************************************
 *RmonHise3C
 *RMON "History ethernet" API and data structures definition
 *Features for 3Com
 *****************************************************************
*/

#define interval_1h (6*600)
#define interval_6h (6*3600)

static UI32_T SNMP_MGR_part_1_6_h_interval(UI32_T unit, UI32_T port, UI32_T *value ,UI32_T item, UI32_T interval);

static UI32_T SNMP_MGR_Part1H(UI32_T unit, UI32_T port, UI32_T *value ,UI32_T item);

static UI32_T SNMP_MGR_Part6H(UI32_T unit, UI32_T port, UI32_T *value ,UI32_T item);

static void SNMP_MGR_GetRmonCounter(UI32_T item, UI32_T *value, HISTORY_DATA_ENTRY_T e_data );


/*\^? 1, ~^? 0*/
static UI32_T SNMP_MGR_part_1_6_h_interval(UI32_T unit, UI32_T port, UI32_T *value ,UI32_T item, UI32_T interval)
{
   HISTORY_CRTL_ENTRY_T c_data;
   HISTORY_DATA_ENTRY_T e_data;
   int i;
   int index,oldindex;
   int ctrl_index;
   UI32_T linear_port;
   UI32_T sample_index;
   *value=0;

   if(rmon_HiscEntryGetFirst( &ctrl_index, &c_data)==FALSE) //Get error
       return FALSE; /* Get error,*/

   if(SWCTRL_POM_UserPortToLogicalPort (unit,port,&linear_port) != TRUE)
   {
       return FALSE;
   } /* ? linear*/

   while(1)
   {
       if(linear_port==c_data.data_source.objid[c_data.data_source.length-1])
       {
           if((c_data.scrlr.data_granted * c_data.interval) ==interval)
           {
               index=ctrl_index;
               break;
           }
       }
       if(rmon_HiscEntryGetNext(&ctrl_index, &c_data)== FALSE)
       { /*if get error, return true, then will show get zero byte*/
          return TRUE; /* return true , not return error*/
       }

   }

   if(rmon_HiseEntryGetFirst(index/*n?Wlookup ?oindex*/, &sample_index, &e_data)==FALSE) /*Get error*/
        return 1;

   SNMP_MGR_GetRmonCounter(item, value, e_data);
   oldindex=index;
   for(i=1;i<c_data.scrlr.data_granted;i++)
   {
       /*int*/
       if(rmon_HiseEntryGetNext(&index, &sample_index, &e_data)==TRUE) /*get right*/
       {
          if(index==oldindex  )
          {/*  index, ?OO@?*/

              oldindex=index;
              SNMP_MGR_GetRmonCounter(item, value, e_data);
          }
       }
   }
   return 1;

}

/*\^? 1, ~^? 0*/
static UI32_T SNMP_MGR_Part6H(UI32_T unit, UI32_T port, UI32_T *value ,UI32_T item)
{

   if(SNMP_MGR_part_1_6_h_interval( unit,  port, value ,item, interval_6h) ==1)
      return 1;
   else
      return 0;

}

/*\^? 1, ~^? 0*/
static UI32_T SNMP_MGR_Part1H(UI32_T unit, UI32_T port, UI32_T *value ,UI32_T item)
{


   if(SNMP_MGR_part_1_6_h_interval( unit,  port, value ,item, interval_1h) ==1)
      return 1;
   else
      return 0;

}

static void SNMP_MGR_GetRmonCounter(UI32_T item, UI32_T *value, HISTORY_DATA_ENTRY_T e_data )
{
     switch(item)
     {
         case DATA_PKTS:
             *value+=e_data.EthData.packets;
              break;
         case DATA_OCTETS:
             *value+=e_data.EthData.octets;
              break;
         case DATA_BROADCASTPKTS:
             *value+=e_data.EthData.bcast_pkts;
              break;
         case DATA_MULTICASTPKTS:
             *value+=e_data.EthData.mcast_pkts;
              break;
         case DATA_FRAGMENTS:
             *value+=e_data.EthData.fragments;
              break;
         case DATA_COLLISIONS:
             *value+=e_data.EthData.collisions;
              break;
         case DATA_CRCALIGNERRORS:
             *value+=e_data.EthData.crc_align;
              break;
         case DATA_UNDERSIZEPKTS:
             *value+=e_data.EthData.undersize;
              break;
         case DATA_OVERSIZEPKTS:
             *value+=e_data.EthData.oversize;
              break;
         case DATA_JABBERS:
             *value+=e_data.EthData.jabbers;
              break;
         default:
              break;
     }
}


/*------------------------------------------------------------------|
 * ROUTINE NAME - SNMP_MGR_Packets1H                                    |
 * ROUTINE NAME - SNMP_MGR_Octets1H                                     |
 * ROUTINE NAME - SNMP_MGR_BCasts1H                                     |
 * ROUTINE NAME - SNMP_MGR_MCasts1H                                     |
 * ROUTINE NAME - SNMP_MGR_Fragments1H                                  |
 * ROUTINE NAME - SNMP_MGR_Collisions1H                                 |
 * ROUTINE NAME - SNMP_MGR_Errors1H                                     |
 *------------------------------------------------------------------|
 * FUNCTION: RMON history for 1 hour                                |
 *                                                                  |
 * INPUT   : UI32_T logical_unit - which unit to get                |
 *           UI32_T port         - which port to get                |
 * OUTPUT  : UI32_T *value       - value                            |
 * RETURN  : BOOL_T True : Successfully, False : Failed             |
 *------------------------------------------------------------------*/

BOOL_T SNMP_MGR_Packets1H (UI32_T unit, UI32_T port, UI32_T *value)
{

    int ret;
    ret=SNMP_MGR_Part1H(unit, port, value ,DATA_PKTS );

    if(ret==1) /* success */
      return 1;
    else     /*error*/
      goto ErrorExit;

ErrorExit:
    return 1; /* something error in CGI if we return 0 */

}

BOOL_T SNMP_MGR_Octets1H (UI32_T unit, UI32_T port, UI32_T *value)
{
    int ret;
    ret=SNMP_MGR_Part1H(unit, port, value ,DATA_OCTETS );

    if(ret==1) /* success */
      return 1;
    else     /* error */
      goto ErrorExit;

ErrorExit:
    return 1; /* something error in CGI if we return 0 */
}

BOOL_T SNMP_MGR_BCasts1H (UI32_T unit, UI32_T port, UI32_T *value)
{
    int ret;
    ret=SNMP_MGR_Part1H(unit, port, value ,DATA_BROADCASTPKTS );

    if(ret==1) /* success */
      return 1;
    else     /* error */
      goto ErrorExit;
ErrorExit:
    return 1; /* something error in CGI if we return 0 */
}

BOOL_T SNMP_MGR_MCasts1H (UI32_T unit, UI32_T port, UI32_T *value)
{
    int ret;
    ret=SNMP_MGR_Part1H(unit, port, value ,DATA_MULTICASTPKTS );

    if(ret==1) /* success */
      return 1;
    else     /* error */
      goto ErrorExit;
ErrorExit:
    return 1; /* something error in CGI if we return 0 */
}

BOOL_T SNMP_MGR_Fragments1H (UI32_T unit, UI32_T port, UI32_T *value)
{
    int ret;
    ret=SNMP_MGR_Part1H(unit, port, value ,DATA_FRAGMENTS );

    if(ret==1) /* success */
      return 1;
    else     /* error */
      goto ErrorExit;
ErrorExit:
    return 1; /* something error in CGI if we return 0 */
}

BOOL_T SNMP_MGR_Collisions1H (UI32_T unit, UI32_T port, UI32_T *value)
{
    int ret;
    ret=SNMP_MGR_Part1H(unit, port, value ,DATA_COLLISIONS );

    if(ret==1) /* success */
      return 1;
    else     /* error */
      goto ErrorExit;
ErrorExit:
    return 1; /* something error in CGI if we return 0 */
}

BOOL_T SNMP_MGR_Errors1H (UI32_T unit, UI32_T port, UI32_T *value)
{
    int ret;
    UI32_T total;
    total=0;

    ret=SNMP_MGR_Part1H(unit, port, value ,DATA_CRCALIGNERRORS );
    if(ret==1) /* success */
       total+=*value;
    else     /* error */
      goto ErrorExit;

    ret=SNMP_MGR_Part1H(unit, port, value ,DATA_UNDERSIZEPKTS );
    if(ret==1) /* success */
       total+=*value;
    else     /* error */
      goto ErrorExit;

    ret=SNMP_MGR_Part1H(unit, port, value ,DATA_OVERSIZEPKTS );
    if(ret==1) /* success */
       total+=*value;
    else     /* error */
      goto ErrorExit;

    ret=SNMP_MGR_Part1H(unit, port, value ,DATA_FRAGMENTS );
    if(ret==1) /* success */
       total+=*value;
    else     /* error */
      goto ErrorExit;

    ret=SNMP_MGR_Part1H(unit, port, value ,DATA_JABBERS );
    if(ret==1) /* success */
       total+=*value;
    else     /* error */
      goto ErrorExit;

    return 1;

ErrorExit:
    return 1; /* something error in CGI if we return 0 */
}

/*------------------------------------------------------------------|
 * ROUTINE NAME - SNMP_MGR_Packets6H                                   |
 * ROUTINE NAME - SNMP_MGR_Octets6H                                    |
 * ROUTINE NAME - SNMP_MGR_BCasts6H                                    |
 * ROUTINE NAME - SNMP_MGR_MCasts6H                                    |
 * ROUTINE NAME - SNMP_MGR_Fragments6H                                 |
 * ROUTINE NAME - SNMP_MGR_Collisions6H                                |
 * ROUTINE NAME - SNMP_MGR_Errors6H                                    |
 *------------------------------------------------------------------|
 * FUNCTION: RMON history for 6 hours                              |
 *                                                                  |
 * INPUT   : UI32_T logical_unit - which unit to get                |
 *           UI32_T port         - which port to get                |
 * OUTPUT  : UI32_T *value       - value                            |
 * RETURN  : BOOL_T True : Successfully, False : Failed             |
 *------------------------------------------------------------------*/
BOOL_T SNMP_MGR_Packets6H (UI32_T unit, UI32_T port, UI32_T *value)
{
    int ret;
    ret=SNMP_MGR_Part6H(unit, port, value ,DATA_PKTS );

    if(ret==1) /* success */
      return 1;
    else     /* error */
      goto ErrorExit;
ErrorExit:
    return 1; /* something error in CGI if we return 0 */
}

BOOL_T SNMP_MGR_Octets6H (UI32_T unit, UI32_T port, UI32_T *value)
{
    int ret;
    ret=SNMP_MGR_Part6H(unit, port, value ,DATA_OCTETS );

    if(ret==1) /* success */
      return 1;
    else     /* error */
      goto ErrorExit;
ErrorExit:
    return 1; /* something error in CGI if we return 0 */
}

BOOL_T SNMP_MGR_BCasts6H (UI32_T unit, UI32_T port, UI32_T *value)
{
    int ret;
    ret=SNMP_MGR_Part6H(unit, port, value ,DATA_BROADCASTPKTS );

    if(ret==1) /* success */
      return 1;
    else     /* error */
      goto ErrorExit;
ErrorExit:
    return 1; /* something error in CGI if we return 0 */
}

BOOL_T SNMP_MGR_MCasts6H (UI32_T unit, UI32_T port, UI32_T *value)
{
    int ret;
    ret=SNMP_MGR_Part6H(unit, port, value ,DATA_MULTICASTPKTS );

    if(ret==1) /* success */
      return 1;
    else     /* error */
      goto ErrorExit;
ErrorExit:
    return 1; /* something error in CGI if we return 0 */
}

BOOL_T SNMP_MGR_Fragments6H (UI32_T unit, UI32_T port, UI32_T *value)
{
    int ret;
    ret=SNMP_MGR_Part6H(unit, port, value ,DATA_FRAGMENTS );

    if(ret==1) /* success */
      return 1;
    else     /* error */
      goto ErrorExit;
ErrorExit:
    return 1; /* something error in CGI if we return 0 */
}

BOOL_T SNMP_MGR_Collisions6H (UI32_T unit, UI32_T port, UI32_T *value)
{
    int ret;
    ret=SNMP_MGR_Part6H(unit, port, value ,DATA_COLLISIONS );

    if(ret==1) /* success */
      return 1;
    else     /* error */
      goto ErrorExit;
ErrorExit:
    return 1; /* something error in CGI if we return 0 */

}

BOOL_T SNMP_MGR_Errors6H (UI32_T unit, UI32_T port, UI32_T *value)
{
    int ret;
    UI32_T total;
    total=0;

    ret=SNMP_MGR_Part6H(unit, port, value ,DATA_CRCALIGNERRORS );
    if(ret==1) /* success */
       total+=*value;
    else     /* error */
      goto ErrorExit;

    ret=SNMP_MGR_Part6H(unit, port, value ,DATA_UNDERSIZEPKTS );
    if(ret==1) /* success */
       total+=*value;
    else     /* error */
      goto ErrorExit;

    ret=SNMP_MGR_Part6H(unit, port, value ,DATA_OVERSIZEPKTS );
    if(ret==1) /* success */
       total+=*value;
    else     /* error */
      goto ErrorExit;

    ret=SNMP_MGR_Part6H(unit, port, value ,DATA_FRAGMENTS );
    if(ret==1) /* success */
       total+=*value;
    else     /* error */
      goto ErrorExit;

    ret=SNMP_MGR_Part6H(unit, port, value ,DATA_JABBERS );
    if(ret==1) /* success */
       total+=*value;
    else     /* error */
      goto ErrorExit;

    return 1;

ErrorExit:
    return 1; /* something error in CGI if we return 0 */
}

#if (SYS_CPNT_SNMPV3_TARGET_NAME_STYLE == SYS_CPNT_SNMPV3_TARGET_NAME_STYLE_3COM)

/* ---------------------------------------------------------------------
 * ROUTINE NAME  - SNMP_MGR_SnmpNotifyCreate
 * ---------------------------------------------------------------------
 * PURPOSE: This function create v3 inform and trap by one function.
 * INPUT:target_addr_name,notify_type,
 *             user_name, dest_ip_addres, dest_port,
 *             remote_engineID,  remote_engineIDLen,
 *             password_from_config,  auth_protocol,
 *             auth_key_len,  authentication_password,
 *             priv_protocol, priv_key_len,
 *             privacy_password,retry_interval,
 *             retry_count
 * OUTPUT: SNMP_MGR_CONFIG_ERROR_E
 * RETURN: SNMP_MGR_ERROR_OK;
 *        SNMP_MGR_CONFIG_ERROR_CREATE_REMOTE_USER,
 *        SNMP_MGR_CONFIG_ERROR_CREATE_REMOTE_ENGINEID,
 *        SNMP_MGR_CONFIG_ERROR_DEL_REMOTE_USER,
 *        SNMP_MGR_CONFIG_ERROR_DEL_REMOTE_ENGINEID,
 *        SNMP_MGR_CONFIG_ERROR_DEL_TRAP,
 *        SNMP_MGR_CONFIG_ERROR_SET_TRAP,
 *        SNMP_MGR_CONFIG_ERROR_GET_TRAP
 * NOTE:  target_addr_name , dest_ip_addres , ( remote_engineID + user_name ) is key
 * ---------------------------------------------------------------------
 */
UI32_T
SNMP_MGR_SnmpNotifyCreate(
    UI8_T *target_addr_name,
    UI32_T notify_type,
    UI8_T *user_name,
    UI32_T dest_ip_addres,
    UI32_T dest_port,
    UI8_T *remote_engineID,
    UI32_T  remote_engineIDLen,
    BOOL_T password_from_config,
    UI32_T auth_protocol,
    UI32_T auth_key_len,
    UI8_T * authentication_password,
    UI32_T  priv_protocol,
    UI32_T priv_key_len,
    UI8_T *privacy_password,
    UI32_T retry_interval,
    UI32_T retry_count)
{
    SNMP_MGR_SnmpV3UserEntry_T      user_entry;   /* Delcare SNMPv3 User Information */
    SNMP_MGR_TrapDestEntry_T        trap_entry;   /* Declare SNMPv3 Trap Destination info */
    SNMP_MGR_SnmpRemoteEngineID_T   reid_entry;   /* Declare Remote User Engine Entry */
    SNMP_MGR_SnmpV3GroupEntry_T     group_entry;  /* Declare SNMPv3 Group Entry */
    BOOL_T find_user,find_group;
    UI32_T check_user_data;

    memset(&user_entry, 0, sizeof(SNMP_MGR_SnmpV3UserEntry_T));
    memset(&trap_entry, 0, sizeof(SNMP_MGR_TrapDestEntry_T));
    memset(&reid_entry, 0, sizeof(SNMP_MGR_SnmpRemoteEngineID_T));
    memset(&group_entry, 0, sizeof(SNMP_MGR_SnmpV3GroupEntry_T));

    reid_entry.snmp_remote_engineIDLen = remote_engineIDLen;

    /* check EngineID length
     */
    if(reid_entry.snmp_remote_engineIDLen>MAXSIZE_snmpEngineID)
    {
        return SNMP_MGR_CONFIG_ERROR_CREATE_REMOTE_ENGINEID;
    }
    else
    {
        memcpy(reid_entry.snmp_remote_engineID,
               remote_engineID,
               reid_entry.snmp_remote_engineIDLen);
    }

    reid_entry.snmp_remote_engineID_host = dest_ip_addres;

    /* Create Remote EngineID and Remote User
     */
    if( notify_type == VAL_snmpNotifyType_inform )
    {

        if ( SNMP_MGR_CreateRemoteEngineID (&reid_entry) != SNMP_MGR_ERROR_OK )
        {
            return SNMP_MGR_CONFIG_ERROR_CREATE_REMOTE_ENGINEID;
        }

        if(strlen(user_name)>MAX_SNMPV3_PASSWORD_LEN)
        {
            SNMP_MGR_DeleteRemoteEngineIDEntry(&reid_entry);
            return SNMP_MGR_CONFIG_ERROR_CREATE_REMOTE_USER;
        }
        else
        {
            strcpy(user_entry.snmpv3_user_name, user_name);
        }

        user_entry.password_from_config = password_from_config;

       /* set auth passwd
        */
        switch(auth_protocol)
        {
            case  SNMP_MGR_SNMPV3_AUTHTYPE_MD5:
            case  SNMP_MGR_SNMPV3_AUTHTYPE_SHA:
                user_entry.snmpv3_user_auth_type = auth_protocol;

               /*  passwd from config
                */
                if ( password_from_config == TRUE )
                {
                    user_entry.snmpv3_user_auth_key_len = auth_key_len;

                    if(user_entry.snmpv3_user_auth_key_len > SNMP_MGR_SNMPV3_SHA_KEY_LEN ||
                       user_entry.snmpv3_user_auth_key_len < 0)
                    {
                        SNMP_MGR_DeleteRemoteEngineIDEntry(&reid_entry);

                        return SNMP_MGR_CONFIG_ERROR_CREATE_REMOTE_USER;
                    }
                    else
                    {
                        memcpy(user_entry.snmpv3_user_auth_key,
                               authentication_password,
                               user_entry.snmpv3_user_auth_key_len);
                    }

                }
                else
                {

                    if(strlen(authentication_password) > MAX_SNMPV3_PASSWORD_LEN)
                    {
                        SNMP_MGR_DeleteRemoteEngineIDEntry(&reid_entry);

                        return SNMP_MGR_CONFIG_ERROR_CREATE_REMOTE_USER;
                    }
                    else
                    {
                        strcpy(user_entry.snmpv3_user_auth_password, authentication_password);
                    }

                }

                break;

            default:
                user_entry.snmpv3_user_auth_type = SNMP_MGR_SNMPV3_AUTHTYPE_NONE;
                break;

        }

       /* set privacy passwd
        */
        switch(priv_protocol)
        {
            case  SNMP_MGR_SNMPV3_PRIVTYPE_DES:
            case  SNMP_MGR_SNMPV3_PRIVTYPE_AES128:
            case  SNMP_MGR_SNMPV3_PRIVTYPE_AES192:
            case  SNMP_MGR_SNMPV3_PRIVTYPE_AES256:
            case  SNMP_MGR_SNMPV3_PRIVTYPE_3DES:
                user_entry.snmpv3_user_priv_type = priv_protocol;

                if ( password_from_config == TRUE )
                {
                    user_entry.snmpv3_user_priv_key_len = priv_key_len;

                    if(user_entry.snmpv3_user_priv_key_len > SNMP_MGR_SNMPV3_SHA_KEY_LEN ||
                       user_entry.snmpv3_user_priv_key_len < 0)
                    {
                        SNMP_MGR_DeleteRemoteEngineIDEntry(&reid_entry);

                        return SNMP_MGR_CONFIG_ERROR_CREATE_REMOTE_USER;
                    }
                    else
                    {
                        memcpy(user_entry.snmpv3_user_priv_key,
                               privacy_password,
                               user_entry.snmpv3_user_priv_key_len );
                    }

                }
                else
                {
                    strcpy(user_entry.snmpv3_user_priv_password, privacy_password);
                }

                break;

            case SNMP_MGR_SNMPV3_PRIVTYPE_NONE:
            default:
                user_entry.snmpv3_user_priv_type = SNMP_MGR_SNMPV3_PRIVTYPE_NONE;
                break;

        }

       /* set security_level
        */
        if(user_entry.snmpv3_user_auth_type == SNMP_MGR_SNMPV3_AUTHTYPE_MD5 ||
           user_entry.snmpv3_user_auth_type == SNMP_MGR_SNMPV3_AUTHTYPE_SHA)
        {

            switch(user_entry.snmpv3_user_priv_type)
            {
                 case SNMP_MGR_SNMPV3_PRIVTYPE_DES:
                 case SNMP_MGR_SNMPV3_PRIVTYPE_3DES:
                 case SNMP_MGR_SNMPV3_PRIVTYPE_AES128:
                 case SNMP_MGR_SNMPV3_PRIVTYPE_AES192:
                 case SNMP_MGR_SNMPV3_PRIVTYPE_AES256:
                     user_entry.snmpv3_user_security_level =
                         VAL_vacmAccessSecurityLevel_authPriv;
                     break;

                 case SNMP_MGR_SNMPV3_PRIVTYPE_NONE:
                 default:
                     user_entry.snmpv3_user_security_level =
                         VAL_vacmAccessSecurityLevel_authNoPriv;
                     break;

            }
        }
        else
        {
            user_entry.snmpv3_user_security_level =
                VAL_vacmAccessSecurityLevel_noAuthNoPriv;
        }

       /* create remote user
        */
        if(SNMP_MGR_CreateSnmpRemoteUser(dest_ip_addres, &user_entry) !=
           SNMP_MGR_ERROR_OK)
        {
            SNMP_MGR_DeleteRemoteEngineIDEntry(&reid_entry);

            return SNMP_MGR_CONFIG_ERROR_CREATE_REMOTE_USER;
        }

       /* set inform
        */
        trap_entry.trap_dest_security_level = user_entry.snmpv3_user_security_level;
        trap_entry.trap_inform_request_timeout = retry_interval;
        trap_entry.trap_inform_request_retry_cnt = retry_count; /* set retry count */
    }
    else
    {
       /* for get group secuity level, we use trap user which was local user and have group
        */
        memset(&user_entry,0,sizeof(user_entry));
        find_user=FALSE;

        while (SNMP_MGR_GetNextSnmpV3User(&user_entry) == SNMP_MGR_ERROR_OK)
        {

            if ((strcmp(user_entry.snmpv3_user_name,user_name)==0) &&
                (user_entry.snmpv3_user_security_model == SNMP_MGR_SNMPV3_MODEL_V3))
            {
                find_user =TRUE;

                break;
            }

        }

        if ( find_user == FALSE )
        {
            return SNMP_MGR_CONFIG_ERROR_SET_TRAP;
        }

        /* eli,2005.10.06,[ES4649-32-01584],Get group information
         */
        memset(&group_entry, 0, sizeof(group_entry));
        find_group=FALSE;

        while (SNMP_MGR_GetNextSnmpV3Group(&group_entry) == SNMP_MGR_ERROR_OK)
        {
             if((strcmp(group_entry.snmpv3_group_name,
                        user_entry.snmpv3_user_group_name) == 0) &&
                (group_entry.snmpv3_group_model==SNMP_MGR_SNMPV3_MODEL_V3))
             {
                find_group = TRUE;

                break;
             }

        }

        if ( find_group == FALSE )
        {
            return SNMP_MGR_CONFIG_ERROR_SET_TRAP;
        }

        trap_entry.trap_dest_security_level = group_entry.snmpv3_group_security_level;
    }

    trap_entry.trap_dest_version = SNMP_MGR_SNMPV3_MODEL_V3;
    trap_entry.trap_dest_type = notify_type;
    trap_entry.trap_dest_address = dest_ip_addres;
    trap_entry.trap_dest_port = dest_port;
    strcpy(trap_entry.trap_dest_community,user_name);

    /* set notify user with target name,
     */
    if (SNMP_MGR_SetTrapReceiverWithTargetAddrName(&trap_entry,
                                                   target_addr_name) !=
        SNMP_MGR_ERROR_OK)
    {

        if( notify_type == VAL_snmpNotifyType_inform )
        {
            /* if failed to create a new remote user
             * delete the table that created before
             * ES4649-32-01570, Updated entry is point referenced. Andrew 2005-10-3
             */
            SNMP_MGR_DeleteSnmpRemoteUser(&user_entry);
            SNMP_MGR_DeleteRemoteEngineIDEntry(&reid_entry);
        }

        return SNMP_MGR_CONFIG_ERROR_SET_TRAP;
    }

    return SNMP_MGR_CONFIG_ERROR_OK;
}

/* ---------------------------------------------------------------------
 * ROUTINE NAME  - SNMP_MGR_SnmpNotifyDel
 * ---------------------------------------------------------------------
 * PURPOSE: This function del v3 inform and trap by one function.
 * INPUT:target_addr_name
 * OUTPUT: SNMP_MGR_CONFIG_ERROR_E
 * RETURN: SNMP_MGR_ERROR_OK;
 *        SNMP_MGR_CONFIG_ERROR_CREATE_REMOTE_USER,
 *        SNMP_MGR_CONFIG_ERROR_CREATE_REMOTE_ENGINEID,
 *        SNMP_MGR_CONFIG_ERROR_DEL_REMOTE_USER,
 *        SNMP_MGR_CONFIG_ERROR_DEL_REMOTE_ENGINEID,
 *        SNMP_MGR_CONFIG_ERROR_DEL_TRAP,
 *        SNMP_MGR_CONFIG_ERROR_SET_TRAP,
 *        SNMP_MGR_CONFIG_ERROR_GET_TRAP
 * NOTE:  target_addr_name , dest_ip_addres , ( remote_engineID + user_name ) is key
 * ---------------------------------------------------------------------
 */
UI32_T SNMP_MGR_SnmpNotifyDel(UI8_T *snmp_target_addr_name )
{
    SNMP_MGR_SnmpTargetAddrEntry_T        tadr_entry;
    SNMP_MGR_SnmpRemoteEngineID_T   reid_entry;  /* Declare Remote User Engine Entry */
    SNMP_MGR_SnmpV3UserEntry_T      user_entry;
    SNMP_MGR_TrapDestEntry_T trap_entry;
    UI32_T temp_ip;

    memset(&trap_entry, 0, sizeof(SNMP_MGR_TrapDestEntry_T));
    memset(&tadr_entry, 0, sizeof(SNMP_MGR_SnmpTargetAddrEntry_T));
    memset(&reid_entry, 0, sizeof(SNMP_MGR_SnmpRemoteEngineID_T));
    memset(&user_entry, 0, sizeof(SNMP_MGR_SnmpV3UserEntry_T));

    if(strlen(snmp_target_addr_name)>MAXSIZE_snmpTargetAddrName)
    {
        return SNMP_MGR_CONFIG_ERROR_DEL_TRAP;
    }
    else
    {
        strcpy (tadr_entry.snmp_target_addr_name, snmp_target_addr_name);
    }

    /* get target address */
    if ( SNMP_MGR_GetSnmpTargetAddrTable (&tadr_entry) == SNMP_MGR_ERROR_OK )
    {
        memcpy (&temp_ip , tadr_entry.taddr.snmp_target_addr_taddress, sizeof (UI32_T) );
        temp_ip = L_STDLIB_Ntoh32(temp_ip);
        trap_entry.trap_dest_address = temp_ip;
    }

   /* delete trap
    */
    if ( SNMP_MGR_GetTrapReceiver (&trap_entry) == SNMP_MGR_ERROR_OK )
    {
       SNMP_MGR_DeleteTrapReceiverWithTargetAddrName (trap_entry.trap_dest_address,snmp_target_addr_name);


       /* delete remote user only if VAL_snmpNotifyType_inform
        */
        if ( trap_entry.trap_dest_type == VAL_snmpNotifyType_inform )
        {

            reid_entry.snmp_remote_engineID_host = trap_entry.trap_dest_address;

            /* get remote engine id entry */
            if (SNMP_MGR_GetSnmpRemoteEngineIDEntry(&reid_entry) == SNMP_MGR_ERROR_OK )
            {
                SNMP_MGR_DeleteRemoteEngineIDEntry(&reid_entry);
            }

            strcpy (user_entry.snmpv3_user_name, trap_entry.trap_dest_community);
            memcpy(user_entry.snmpv3_user_engine_id, reid_entry.snmp_remote_engineID, reid_entry.snmp_remote_engineIDLen);

            /* get remote user entry fro user name
             */
            if ( SNMP_MGR_GetSnmpRemoteUserEntry(&user_entry) == SNMP_MGR_ERROR_OK )
            {
                SNMP_MGR_DeleteSnmpRemoteUser(&user_entry);
            }
        }
     }
    return SNMP_MGR_CONFIG_ERROR_OK;
}

/* ---------------------------------------------------------------------
 * ROUTINE NAME  - SNMP_MGR_SnmpNotifyModify
 * ---------------------------------------------------------------------
 * PURPOSE: This function modify v3 inform and trap by one function.
 * INPUT:target_addr_name,notify_type,
 *             user_name, dest_ip_addres, dest_port,
 *             remote_engineID,  remote_engineIDLen,
 *             password_from_config,  auth_protocol,
 *             auth_key_len,  authentication_password,
 *             priv_protocol, priv_key_len,
 *             privacy_password,retry_interval,
 *             retry_count
 * OUTPUT: SNMP_MGR_CONFIG_ERROR_E
 * RETURN: SNMP_MGR_ERROR_OK;
 *        SNMP_MGR_CONFIG_ERROR_CREATE_REMOTE_USER,
 *        SNMP_MGR_CONFIG_ERROR_CREATE_REMOTE_ENGINEID,
 *        SNMP_MGR_CONFIG_ERROR_DEL_REMOTE_USER,
 *        SNMP_MGR_CONFIG_ERROR_DEL_REMOTE_ENGINEID,
 *        SNMP_MGR_CONFIG_ERROR_DEL_TRAP,
 *        SNMP_MGR_CONFIG_ERROR_SET_TRAP,
 *        SNMP_MGR_CONFIG_ERROR_GET_TRAP
 * NOTE:  target_addr_name , dest_ip_addres , ( remote_engineID + user_name ) is key
 * ---------------------------------------------------------------------
 */
UI32_T SNMP_MGR_SnmpNotifyModify(UI8_T *target_addr_name,UI32_T notify_type,
            UI8_T *user_name, UI32_T dest_ip_addres, UI32_T dest_port,
            UI8_T *remote_engineID, UI32_T  remote_engineIDLen,
            BOOL_T password_from_config,  UI32_T auth_protocol,
            UI32_T auth_key_len, UI8_T * authentication_password,
            UI32_T  priv_protocol, UI32_T priv_key_len,
            UI8_T *privacy_password,UI32_T retry_interval,
            UI32_T retry_count )
{


    SNMP_MGR_SnmpV3UserEntry_T      temp_user_entry; /* Delcare SNMPv3 Modify User Information */
    SNMP_MGR_TrapDestEntry_T        temp_trap_entry;
    SNMP_MGR_SnmpRemoteEngineID_T   temp_reid_entry;
    SNMP_MGR_SnmpTargetAddrEntry_T  temp_tadr_entry;
    UI32_T temp_ip;
    UI32_T rel;


    memset(&temp_trap_entry, 0, sizeof(SNMP_MGR_TrapDestEntry_T));
    memset(&temp_tadr_entry, 0, sizeof(SNMP_MGR_SnmpTargetAddrEntry_T));
    memset(&temp_reid_entry, 0, sizeof(SNMP_MGR_SnmpRemoteEngineID_T));
    memset(&temp_user_entry, 0, sizeof(SNMP_MGR_SnmpV3UserEntry_T));

    strcpy (temp_tadr_entry.snmp_target_addr_name, target_addr_name);

    /* get target address */
    if ( SNMP_MGR_GetSnmpTargetAddrTable (&temp_tadr_entry) == SNMP_MGR_ERROR_OK )
    {
        memcpy ( &temp_ip,temp_tadr_entry.taddr.snmp_target_addr_taddress, sizeof (UI32_T) );
        temp_trap_entry.trap_dest_address =  L_STDLIB_Ntoh32(temp_ip);
    }
    else
    {
        return SNMP_MGR_CONFIG_ERROR_GET_TRAP;
    }

    /* get trap entry */
    if ( SNMP_MGR_GetTrapReceiver (&temp_trap_entry) == SNMP_MGR_ERROR_OK)
    {

        if ( temp_trap_entry.trap_dest_type == VAL_snmpNotifyType_inform)
        {
            strcpy (temp_user_entry.snmpv3_user_name, temp_trap_entry.trap_dest_community);
            temp_reid_entry.snmp_remote_engineID_host = temp_trap_entry.trap_dest_address;

            /* get remote engine id entry */
            if (SNMP_MGR_GetSnmpRemoteEngineIDEntry(&temp_reid_entry) != SNMP_MGR_ERROR_OK)
            {
                  return SNMP_MGR_CONFIG_ERROR_GET_TRAP ;

            }
            temp_user_entry.snmpv3_user_engineIDLen = temp_reid_entry.snmp_remote_engineIDLen;
            memcpy(temp_user_entry.snmpv3_user_engine_id, temp_reid_entry.snmp_remote_engineID,temp_user_entry.snmpv3_user_engineIDLen);

            /* get remote user entry fro user name
             */
            if ( SNMP_MGR_GetSnmpRemoteUserEntry(&temp_user_entry) != SNMP_MGR_ERROR_OK )
            {
                return SNMP_MGR_CONFIG_ERROR_GET_TRAP;
            }
        }
    }
    else
    {
        return SNMP_MGR_CONFIG_ERROR_GET_TRAP;
    }

    /*del old entry */
    SNMP_MGR_SnmpNotifyDel(target_addr_name);

    /*create new entry */
    if( (rel=SNMP_MGR_SnmpNotifyCreate(target_addr_name,notify_type,
            user_name, dest_ip_addres, dest_port,
            remote_engineID,  remote_engineIDLen,
            password_from_config,  auth_protocol,
            auth_key_len,  authentication_password,
            priv_protocol, priv_key_len,
            privacy_password,retry_interval,
            retry_count
        ) )!=SNMP_MGR_CONFIG_ERROR_OK)
    {

        /*create fail, undo old entry */
        SNMP_MGR_SnmpNotifyCreate(temp_tadr_entry.snmp_target_addr_name,temp_trap_entry.trap_dest_type,
             temp_trap_entry.trap_dest_community, temp_trap_entry.trap_dest_address, temp_trap_entry.trap_dest_port, temp_reid_entry.snmp_remote_engineID,
             temp_reid_entry.snmp_remote_engineIDLen, TRUE,  temp_user_entry.snmpv3_user_auth_type, temp_user_entry.snmpv3_user_auth_key_len,
             temp_user_entry.snmpv3_user_auth_key, temp_user_entry.snmpv3_user_priv_type, temp_user_entry.snmpv3_user_priv_key_len, temp_user_entry.snmpv3_user_priv_key,
             temp_trap_entry.trap_inform_request_timeout, temp_trap_entry.trap_inform_request_retry_cnt);
        return rel;
    }
    return rel;
}
#endif /* (SYS_CPNT_SNMPV3_TARGET_NAME_STYLE == SYS_CPNT_SNMPV3_TARGET_NAME_STYLE_3COM)            */

/* ---------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_BitsFromCoreToSnmp
 * ---------------------------------------------------------------------
 * PURPOSE: This function returns SNMP_MGR_ERROR_OK if the convert from core layer to snmp is ok.
 *          Otherwise, SNMP_MGR_ERROR_FAIL is returned.
 *
 * INPUT: core_layer_p - variable pointer
 *        snmp_p       - variable pointer
 *        var_size - memory size in bytes for core_layer_p and snmp_p
 * OUTPUT: snmp_p
 * RETURN:  1. success: SNMP_MGR_ERROR_OK
 *          2. failure: SNMP_MGR_ERROR_FAIL
 * NOTES: 1.The var_size of snmp_p must be the same as core_layer_p
 */
UI32_T SNMP_MGR_BitsFromCoreToSnmp(void *core_layer_p, UI8_T *snmp_p, UI32_T var_size)
{
    if((core_layer_p != NULL) && (snmp_p != NULL))
    {
        UI8_T *in_p, *out_p;

#if (SYS_CPNT_SNMP_BITS_FROM_LEFT == TRUE && SYS_HWCFG_LITTLE_ENDIAN_CPU == TRUE) || \
    (SYS_CPNT_SNMP_BITS_FROM_LEFT != TRUE && SYS_HWCFG_LITTLE_ENDIAN_CPU != TRUE)
        for (in_p = core_layer_p, out_p = snmp_p;
            var_size > 0;
            var_size--, in_p++, out_p++)
#else
        for (in_p = core_layer_p, out_p = snmp_p + var_size - 1;
            var_size > 0;
            var_size--, in_p++, out_p--)
#endif
        {
#if (SYS_CPNT_SNMP_BITS_FROM_LEFT == TRUE)
            *out_p = L_CVRT_ByteFlip(*in_p);
#endif
        }

        return SNMP_MGR_ERROR_OK;
    }

    return SNMP_MGR_ERROR_FAIL;
}

/* ---------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_BitsFromSnmpToCore
 * ---------------------------------------------------------------------
 * PURPOSE: This function returns SNMP_MGR_ERROR_OK if the convert from core layer to snmp is ok.
 *          Otherwise, SNMP_MGR_ERROR_FAIL is returned.
 *
 * INPUT: core_layer_p - variable pointer
 *        snmp_p       - variable pointer
 *        var_size - memory size in bytes for core_layer_p and snmp_p
 * OUTPUT: snmp_p
 * RETURN:  1. success: SNMP_MGR_ERROR_OK
 *          2. failure: SNMP_MGR_ERROR_FAIL
 * NOTES: 1.The var_size of snmp_p must be the same as core_layer_p
 */
UI32_T SNMP_MGR_BitsFromSnmpToCore(void *core_layer_p, UI8_T *snmp_p, UI32_T var_size)
{
    if((core_layer_p != NULL) && (snmp_p != NULL))
    {
        UI8_T *in_p, *out_p;

#if (SYS_CPNT_SNMP_BITS_FROM_LEFT == TRUE && SYS_HWCFG_LITTLE_ENDIAN_CPU == TRUE) || \
    (SYS_CPNT_SNMP_BITS_FROM_LEFT != TRUE && SYS_HWCFG_LITTLE_ENDIAN_CPU != TRUE)
        for (in_p = snmp_p, out_p = core_layer_p;
            var_size > 0;
            var_size--, in_p++, out_p++)
#else
        for (in_p = snmp_p, out_p = (UI8_T *)core_layer_p + var_size - 1;
            var_size > 0;
            var_size--, in_p++, out_p--)
#endif
        {
#if (SYS_CPNT_SNMP_BITS_FROM_LEFT == TRUE)
            *out_p = L_CVRT_ByteFlip(*in_p);
#endif
        }

        return SNMP_MGR_ERROR_OK;
    }

    return SNMP_MGR_ERROR_FAIL;
}

 /*------------------------------------------------------------------------------
  * ROUTINE NAME : SNMP_MGR_HandleIPCReqMsg
  *------------------------------------------------------------------------------
  * PURPOSE:
  *    Handle the ipc request message for snmp mgr.
  * INPUT:
  *    msg_p         --  the request ipc message buffer
  *    ipcmsgq_p     --  The handle of ipc message queue. The response message
  *                      will be sent through this handle.
  *
  * OUTPUT:
  *    None.
  *
  * RETURN:
  *    Need respond
  * NOTES:
  *    None.
  *------------------------------------------------------------------------------
  */

BOOL_T SNMP_MGR_HandleIPCReqMsg(SYSFUN_Msg_T* msg_p)
 {
    SNMP_MGR_IPCMsg_T *msg_data_p;
    msg_data_p=(SNMP_MGR_IPCMsg_T *)msg_p->msg_buf;
    UI32_T cmd;

    cmd = msg_data_p->type.cmd;

    /* Every ipc request will fail when operating mode is not master mode
     */
    if (SYSFUN_GET_CSC_OPERATING_MODE() == SYS_TYPE_STACKING_TRANSITION_MODE)
    {
        /* EPR_ID:None
           Problem: BT stacking hang print snmp_pmgr function error.
           Root Cause: msg_p->msg_size have not any value.
           Solution: use SNMP default msg_size to reply the sender.

           Modified files:
           src\user\apps\snmpmgmt\v3\snmp_mgr.c
           Approved by: Tian Lan, Tiger Liu
           Fixed by: Shumin.Wang
        */
        msg_p->msg_size=SNMP_MGR_MSGBUF_TYPE_SIZE;
        msg_data_p->type.result_ui32 = SNMP_MGR_ERROR_FAIL;

        /* Check sychronism or asychronism ipc.
         * If it is sychronism(need to respond)then we return true.
         */
        if(cmd < SNMP_MGR_IPCCMD_FOLLOWISASYNCHRONISMIPC)
        {
            return TRUE;
        }
        else
        {
            return FALSE;
        }
    }
    switch(cmd)
    {
        case SNMP_MGR_IPCCMD_SETSNMPCOMMUNITYSTATUS:
        {
            msg_p->msg_size=SNMP_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_ui32=SNMP_MGR_SetSnmpCommunityStatus(
                msg_data_p->data.set_snmp_community_status.comm_name,
                msg_data_p->data.set_snmp_community_status.row_status);
        }
        break;

        case SNMP_MGR_IPCCMD_SETTRAPDESTADDRESSBYINDEX:
        {
            msg_p->msg_size=SNMP_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_ui32=SNMP_MGR_SetTrapDestAddressByIndex(
                msg_data_p->data.set_trap_by_index.trap_index,
                msg_data_p->data.set_trap_by_index.port,
                &msg_data_p->data.set_trap_by_index.addr);
        }
        break;

        case SNMP_MGR_IPCCMD_SETDEFAULTSNMPENGINEID:
        {
            msg_p->msg_size=SNMP_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_ui32 = SNMP_MGR_SetDefaultSnmpEngineID();
        }
        break;

        case SNMP_MGR_IPCCMD_GETSNMPSTATUS:
        {
            /* the size of the respond size is equal the size of request message.
             * so,msg_p->msg_size do not need change.
             */
            msg_data_p->type.result_ui32=SNMP_MGR_GetSnmpStatus(
                ( SNMP_MGR_STATS_T *)&msg_data_p->data);
        }
        break;

        case SNMP_MGR_IPCCMD_CREATESNMPV3GROUP:
        {
            msg_p->msg_size=SNMP_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_ui32=SNMP_MGR_CreateSnmpV3Group(
                (SNMP_MGR_SnmpV3GroupEntry_T *)&msg_data_p->data, FALSE);
        }
        break;

        case SNMP_MGR_IPCCMD_CREATESNMPV3USER:
        {
            msg_p->msg_size=SNMP_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_ui32=SNMP_MGR_CreateSnmpV3User(
                (SNMP_MGR_SnmpV3UserEntry_T *)&msg_data_p->data, FALSE);
        }
        break;

        case SNMP_MGR_IPCCMD_CREATESNMPV3VIEW:
        {
            msg_p->msg_size=SNMP_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_ui32=SNMP_MGR_CreateSnmpV3View(
                (SNMP_MGR_SnmpV3ViewEntry_T *)&msg_data_p->data);
        }
        break;

        case SNMP_MGR_IPCCMD_DELETESNMPV3VIEW:
        {
            msg_p->msg_size=SNMP_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_ui32=SNMP_MGR_DeleteSnmpV3View(
                msg_data_p->data.delete_snmp_v3_view.snmpv3_view_name,
                msg_data_p->data.delete_snmp_v3_view.snmpv3_wildcard_subtree);
        }
        break;

        case SNMP_MGR_IPCCMD_DELETESNMPV3VIEWBYNAME:
        {
            msg_p->msg_size=SNMP_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_ui32=SNMP_MGR_DeleteSnmpV3ViewByName(
                msg_data_p->data.delete_snmp_v3_view_by_name.snmpv3_view_name);
        }
        break;

        case SNMP_MGR_IPCCMD_DELETESNMPV3GROUP:
        {
            msg_p->msg_size=SNMP_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_ui32=SNMP_MGR_DeleteSnmpV3Group(
                msg_data_p->data.delete_snmp_v3_group.snmpv3_group_name,
                msg_data_p->data.delete_snmp_v3_group.security_model,
                msg_data_p->data.delete_snmp_v3_group.security_level);
        }
        break;

        case SNMP_MGR_IPCCMD_GETENGINEID:
        {
            /* the size of the respond size is equal the size of request message.
             * so,msg_p->msg_size do not need change.
             */
            msg_data_p->type.result_ui32=SNMP_MGR_GetEngineID(
                msg_data_p->data.engine_id_with_len.engineID,
                &msg_data_p->data.engine_id_with_len.engineIDLen);
        }
        break;

        case SNMP_MGR_IPCCMD_GETRUNNINGENGINEID:
        {
            /* the size of the respond size is equal the size of request message.
             * so,msg_p->msg_size do not need change.
             */
            msg_data_p->type.result_ui32=SNMP_MGR_GetRunningEngineID(
                msg_data_p->data.engine_id_with_len.engineID,
                &msg_data_p->data.engine_id_with_len.engineIDLen);
        }
        break;

        case SNMP_MGR_IPCCMD_GETENGINEBOOTS:
        {
            /* the size of the respond size is equal the size of request message.
             * so,msg_p->msg_size do not need change.
             */
            msg_data_p->type.result_ui32=SNMP_MGR_GetEngineBoots(
                &msg_data_p->data.ui32_v);
        }
        break;

        case SNMP_MGR_IPCCMD_DELETESNMPV3USER:
        {
            msg_p->msg_size=SNMP_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_ui32=SNMP_MGR_DeleteSnmpV3User(
                msg_data_p->data.delete_snmp_v3_user.security_model,
                msg_data_p->data.delete_snmp_v3_user.snmpv3_user_name);
        }
        break;

        case SNMP_MGR_IPCCMD_GETSNMPV3USER:
        {
            /* the size of the respond size is equal the size of request message.
             * so,msg_p->msg_size do not need change.
             */
            msg_data_p->type.result_ui32=SNMP_MGR_GetSnmpV3User(
                (SNMP_MGR_SnmpV3UserEntry_T *)&msg_data_p->data);
        }
        break;

        case SNMP_MGR_IPCCMD_GETNEXTSNMPV3USER:
        {
            /* the size of the respond size is equal the size of request message.
             * so,msg_p->msg_size do not need change.
             */
            msg_data_p->type.result_ui32=SNMP_MGR_GetNextSnmpV3User(
                (SNMP_MGR_SnmpV3UserEntry_T *)&msg_data_p->data);
        }
        break;

        case SNMP_MGR_IPCCMD_GETNEXTRUNNINGSNMPV3USER:
        {
            /* the size of the respond size is equal the size of request message.
             * so,msg_p->msg_size do not need change.
             */
            msg_data_p->type.result_ui32=SNMP_MGR_GetNextRunningSnmpV3User(
                (SNMP_MGR_SnmpV3UserEntry_T *)&msg_data_p->data);
        }
        break;

        case SNMP_MGR_IPCCMD_GETNEXTSNMPV3GROUP:
        {
            /* the size of the respond size is equal the size of request message.
             * so,msg_p->msg_size do not need change.
             */
            msg_data_p->type.result_ui32=SNMP_MGR_GetNextSnmpV3Group(
                (SNMP_MGR_SnmpV3GroupEntry_T *)&msg_data_p->data);
        }
        break;

        case SNMP_MGR_IPCCMD_GETNEXTRUNNINGSNMPV3GROUP:
        {
            /* the size of the respond size is equal the size of request message.
             * so,msg_p->msg_size do not need change.
             */
            msg_data_p->type.result_ui32=SNMP_MGR_GetNextRunningSnmpV3Group(
                (SNMP_MGR_SnmpV3GroupEntry_T *)&msg_data_p->data);
        }
        break;

        case SNMP_MGR_IPCCMD_GETNEXTSNMPV3VIEWNAME:
        {
            /* the size of the respond size is equal the size of request message.
             * so,msg_p->msg_size do not need change.
             */
            msg_data_p->type.result_ui32=SNMP_MGR_GetNextSnmpV3ViewName((UI8_T *)
                msg_data_p->data.snmp_v3_view_name);
        }
        break;

        case SNMP_MGR_IPCCMD_GETNEXTSNMPV3VIEW:
        {
            /* the size of the respond size is equal the size of request message.
             * so,msg_p->msg_size do not need change.
             */
            msg_data_p->type.result_ui32=SNMP_MGR_GetNextSnmpV3View(
                (SNMP_MGR_SnmpV3ViewEntry_T *)&msg_data_p->data);
        }
        break;

        case SNMP_MGR_IPCCMD_GETNEXTRUNNINGSNMPV3VIEW:
        {
            /* the size of the respond size is equal the size of request message.
             * so,msg_p->msg_size do not need change.
             */
            msg_data_p->type.result_ui32=SNMP_MGR_GetNextRunningSnmpV3View(
                (SNMP_MGR_SnmpV3ViewEntry_T *)&msg_data_p->data);
        }
        break;

        case SNMP_MGR_IPCCMD_SET_ENGINEID:
        {
            msg_p->msg_size=SNMP_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_ui32=SNMP_MGR_Set_EngineID(
                msg_data_p->data.engine_id_with_len.engineID,
                msg_data_p->data.engine_id_with_len.engineIDLen);
        }
        break;

        case SNMP_MGR_IPCCMD_GETNEXTSNMPCOMMUNITY:
        {
            /* the size of the respond size is equal the size of request message.
             * so,msg_p->msg_size do not need change.
             */
            msg_data_p->type.result_ui32=SNMP_MGR_GetNextSnmpCommunity(
                (SNMP_MGR_SnmpCommunity_T *)&msg_data_p->data);
        }
        break;

        case SNMP_MGR_IPCCMD_GETNEXTRUNNINGSNMPCOMMUNITY:
        {
            /* the size of the respond size is equal the size of request message.
             * so,msg_p->msg_size do not need change.
             */
            msg_data_p->type.result_ui32=SNMP_MGR_GetNextRunningSnmpCommunity(
                (SNMP_MGR_SnmpCommunity_T *)&msg_data_p->data);
        }
        break;

        case SNMP_MGR_IPCCMD_CREATESNMPCOMMUNITY:
        {
            msg_p->msg_size=SNMP_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_ui32=SNMP_MGR_CreateSnmpCommunity(
                msg_data_p->data.com_with_access.comm_string_name,
                msg_data_p->data.com_with_access.access_right);
        }
        break;

        case SNMP_MGR_IPCCMD_REMOVESNMPCOMMUNITY:
        {
            msg_p->msg_size=SNMP_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_ui32=SNMP_MGR_RemoveSnmpCommunity(
                msg_data_p->data.com_with_access.comm_string_name);
        }
        break;

        case SNMP_MGR_IPCCMD_ENABLE_SNMP_AGENT:
        {
            msg_p->msg_size=SNMP_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_ui32=SNMP_MGR_Enable_Snmp_Agent();
        }
        break;

        case SNMP_MGR_IPCCMD_DISABLE_SNMP_AGENT:
        {
            msg_p->msg_size=SNMP_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_ui32=SNMP_MGR_Disable_Snmp_Agent();
        }
        break;

        case SNMP_MGR_IPCCMD_GET_AGENTSTATUS:
        {
            /* the size of the respond size is equal the size of request message.
             * so,msg_p->msg_size do not need change.
             */
            msg_data_p->type.result_bool=SNMP_MGR_Get_AgentStatus(
                &msg_data_p->data.bool_v);
        }
        break;

        case SNMP_MGR_IPCCMD_GETRUNNINGSNMPAGENTSTATUS:
        {
            /* the size of the respond size is equal the size of request message.
             * so,msg_p->msg_size do not need change.
             */
            msg_data_p->type.result_ui32=SNMP_MGR_GetRunningSnmpAgentStatus(
                &msg_data_p->data.bool_v);
        }
        break;

        case SNMP_MGR_IPCCMD_GETNEXTTRAPRECEIVER:
        {
            /* the size of the respond size is equal the size of request message.
             * so,msg_p->msg_size do not need change.
             */
            msg_data_p->type.result_ui32=SNMP_MGR_GetNextTrapReceiver(
                (SNMP_MGR_TrapDestEntry_T *)&msg_data_p->data);
        }
        break;

        case SNMP_MGR_IPCCMD_GETTRAPRECEIVERBYINDEX:
        {
            /* the size of the respond size is equal the size of request message.
             * so,msg_p->msg_size do not need change.
             */
            msg_data_p->type.result_ui32=SNMP_MGR_GetTrapReceiverByIndex(
                msg_data_p->data.tray_entry_by_index.trap_index,
                (SNMP_MGR_TrapDestEntry_T *)&msg_data_p->data.tray_entry_by_index.trap_receiver);
        }
        break;

        case SNMP_MGR_IPCCMD_SETTRAPRECEIVERCOMMSTRINGNAMEBYINDEX:
        {
            msg_p->msg_size=SNMP_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_ui32=SNMP_MGR_SetTrapReceiverCommStringNameByIndex(
                msg_data_p->data.trap_with_comm.trap_index,
                msg_data_p->data.trap_with_comm.comm_string_name);
        }
        break;

        case SNMP_MGR_IPCCMD_SETTRAPRECEIVERSTATUSBYINDEX:
        {
            msg_p->msg_size=SNMP_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_ui32=SNMP_MGR_SetTrapReceiverStatusByIndex(
                msg_data_p->data.trap_with_status.trap_index,
                msg_data_p->data.trap_with_status.status);
        }
        break;

        case SNMP_MGR_IPCCMD_GETNEXTRUNNINGTRAPRECEIVER:
        {
            /* the size of the respond size is equal the size of request message.
             * so,msg_p->msg_size do not need change.
             */
            msg_data_p->type.result_ui32=SNMP_MGR_GetNextRunningTrapReceiver(
                (SNMP_MGR_TrapDestEntry_T *)&msg_data_p->data);
        }
        break;

        case SNMP_MGR_IPCCMD_GETTRAPRECEIVER:
        {
            /* the size of the respond size is equal the size of request message.
             * so,msg_p->msg_size do not need change.
             */
            msg_data_p->type.result_ui32=SNMP_MGR_GetTrapReceiver(
                (SNMP_MGR_TrapDestEntry_T *)&msg_data_p->data);
        }
        break;

        case SNMP_MGR_IPCCMD_DELETETRAPRECEIVER:
        {
            msg_p->msg_size=SNMP_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_ui32=SNMP_MGR_DeleteTrapReceiver(
                &msg_data_p->data.ip_v);
        }
        break;

        case SNMP_MGR_IPCCMD_DELETETRAPRECEIVERWITHTARGETADDRNAME:
        {
            msg_p->msg_size=SNMP_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_ui32=SNMP_MGR_DeleteTrapReceiverWithTargetAddrName(
                &msg_data_p->data.trap_ip_with_name.ip_addr,
                msg_data_p->data.trap_ip_with_name.target_name);
        }
        break;

        case SNMP_MGR_IPCCMD_SETTRAPRECEVIER:
        {
            msg_p->msg_size=SNMP_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_ui32=SNMP_MGR_SetTrapReceiver(
                (SNMP_MGR_TrapDestEntry_T *)&msg_data_p->data);
        }
        break;

        case SNMP_MGR_IPCCMD_SETTRAPRECEIVERWITHTARGETADDRNAME:
        {
            msg_p->msg_size=SNMP_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_ui32=SNMP_MGR_SetTrapReceiverWithTargetAddrName(
                (SNMP_MGR_TrapDestEntry_T *)&msg_data_p->data.tray_entry_with_name.entry,
                msg_data_p->data.tray_entry_with_name.target_name);
        }
        break;

        case SNMP_MGR_IPCCMD_CREATESNMPREMOTEUSER:
        {
            msg_p->msg_size=SNMP_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_ui32=SNMP_MGR_CreateSnmpRemoteUser(
                msg_data_p->data.remote_user.remote_ip,
                (SNMP_MGR_SnmpV3UserEntry_T *)&msg_data_p->data.remote_user.entry);
        }
        break;

        case SNMP_MGR_IPCCMD_DELETESNMPREMOTEUSER:
        {
            msg_p->msg_size=SNMP_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_ui32=SNMP_MGR_DeleteSnmpRemoteUser(
                (SNMP_MGR_SnmpV3UserEntry_T *)&msg_data_p->data);
        }
        break;

        case SNMP_MGR_IPCCMD_GETSNMPREMOTEUSERENTRY:
        {
            /* the size of the respond size is equal the size of request message.
             * so,msg_p->msg_size do not need change.
             */
            msg_data_p->type.result_ui32=SNMP_MGR_GetSnmpRemoteUserEntry(
                (SNMP_MGR_SnmpV3UserEntry_T *)&msg_data_p->data);
        }
        break;

        case SNMP_MGR_IPCCMD_GETNEXTSNMPREMOTEUSERENTRY:
        {
            /* the size of the respond size is equal the size of request message.
             * so,msg_p->msg_size do not need change.
             */
            msg_data_p->type.result_ui32=SNMP_MGR_GetNextSnmpRemoteUserEntry(
                (SNMP_MGR_SnmpV3UserEntry_T *)&msg_data_p->data);
        }
        break;

        case SNMP_MGR_IPCCMD_GETNEXTRUNNINGSNMPREMOTEUSERENTRY:
        {
            /* the size of the respond size is equal the size of request message.
             * so,msg_p->msg_size do not need change.
             */
            msg_data_p->type.result_ui32=SNMP_MGR_GetNextRunningSnmpRemoteUserEntry(
                (SNMP_MGR_SnmpV3UserEntry_T *)&msg_data_p->data);
        }
        break;

        case SNMP_MGR_IPCCMD_CREATEREMOTEENGINEID:
        {
            msg_p->msg_size=SNMP_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_ui32=SNMP_MGR_CreateRemoteEngineID(
                (SNMP_MGR_SnmpRemoteEngineID_T *)&msg_data_p->data);
        }
        break;

        case SNMP_MGR_IPCCMD_DELETEREMOTEENGINEID:
        {
            msg_p->msg_size=SNMP_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_ui32=SNMP_MGR_DeleteRemoteEngineID(
                (SNMP_MGR_SnmpRemoteEngineID_T *)&msg_data_p->data);
        }
        break;

        case SNMP_MGR_IPCCMD_DELETEREMOTEENGINEIDENTRY:
        {
            msg_p->msg_size=SNMP_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_ui32=SNMP_MGR_DeleteRemoteEngineIDEntry(
                (SNMP_MGR_SnmpRemoteEngineID_T *)&msg_data_p->data);
        }
        break;

        case SNMP_MGR_IPCCMD_GETSNMPREMOTEENGINEIDENTRY:
        {
            /* the size of the respond size is equal the size of request message.
             * so,msg_p->msg_size do not need change.
             */
            msg_data_p->type.result_ui32=SNMP_MGR_GetSnmpRemoteEngineIDEntry(
                (SNMP_MGR_SnmpRemoteEngineID_T *)&msg_data_p->data);
        }
        break;

        case SNMP_MGR_IPCCMD_GETNEXTSNMPREMOTEENGINEIDENTRY:
        {
            /* the size of the respond size is equal the size of request message.
             * so,msg_p->msg_size do not need change.
             */
            msg_data_p->type.result_ui32=SNMP_MGR_GetNextSnmpRemoteEngineIDEntry(
                (SNMP_MGR_SnmpRemoteEngineID_T *)&msg_data_p->data);
        }
        break;

        case SNMP_MGR_IPCCMD_GETNEXTRUNNINGSNMPREMOTEENGINEIDENTRY:
        {
            /* the size of the respond size is equal the size of request message.
             * so,msg_p->msg_size do not need change.
             */
            msg_data_p->type.result_ui32=SNMP_MGR_GetNextRunningSnmpRemoteEngineIDEntry(
                (SNMP_MGR_SnmpRemoteEngineID_T *)&msg_data_p->data);
        }
        break;

        case SNMP_MGR_IPCCMD_GETNEXTSNMPTARGETADDRTABLE:
        {
            /* the size of the respond size is equal the size of request message.
             * so,msg_p->msg_size do not need change.
             */
            msg_data_p->type.result_ui32=SNMP_MGR_GetNextSnmpTargetAddrTable(
                (SNMP_MGR_SnmpTargetAddrEntry_T *)&msg_data_p->data);
        }
        break;

        case SNMP_MGR_IPCCMD_GETSNMPTARGETADDRTABLE:
        {
            /* the size of the respond size is equal the size of request message.
             * so,msg_p->msg_size do not need change.
             */
            msg_data_p->type.result_ui32=SNMP_MGR_GetSnmpTargetAddrTable(
                (SNMP_MGR_SnmpTargetAddrEntry_T *)&msg_data_p->data);
        }
        break;
        case SNMP_MGR_IPCCMD_CREATERSNMPNOTIFYPROFILEFILTERTABLE:
        {
            msg_p->msg_size=SNMP_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_ui32=SNMP_MGR_CreateSnmpNotifyFilterProfileTable(
                (SNMP_MGR_SnmpNotifyFilterProfileEntry_T *)&msg_data_p->data);
        }
        break;
        case SNMP_MGR_IPCCMD_DELETESNMPNOTIFYPROFILEFILTERTABLE:
        {
            msg_p->msg_size=SNMP_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_ui32=SNMP_MGR_DeleteSnmpNotifyFilterProfileTable(
                (SNMP_MGR_SnmpNotifyFilterProfileEntry_T *)&msg_data_p->data);
        }
        break;
        case SNMP_MGR_IPCCMD_SETLOGADMINSTATUS:
        {
            msg_p->msg_size=SNMP_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=NLM_MGR_SetConfigLogAdminStatus(
                (msg_data_p->data.nlm_log_admin_status.nlm_index)
                ,(msg_data_p->data.nlm_log_admin_status.admin_status));

        }
        break;
        case SNMP_MGR_IPCCMD_SETLOGFILTERNAME:
        {
            msg_p->msg_size=SNMP_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=NLM_MGR_SetConfigLogFilterName(
                (msg_data_p->data.nlm_log_filter_name.log_index)
                ,(msg_data_p->data.nlm_log_filter_name.log_filter_name));
        }
        break;
        case SNMP_MGR_IPCCMD_GETNEXTSNMPNOTIFYPROFILEFILTERTABLE:
        {
            /* the size of the respond size is equal the size of request message.
             * so,msg_p->msg_size do not need change.
             */
            msg_data_p->type.result_ui32=SNMP_MGR_GetNextSnmpNotifyFilterProfileTable(
                (SNMP_MGR_SnmpNotifyFilterProfileEntry_T *)&msg_data_p->data);
        }
        break;
        case SNMP_MGR_IPCCMD_GETNLMCFGLOGTABLE:
        {
            /* the size of the respond size is equal the size of request message.
             * so,msg_p->msg_size do not need change.
             */
            nlmConfigLog_T   entry;
            memset(&entry, 0, sizeof(nlmConfigLog_T));
            msg_data_p->type.result_bool = NLM_MGR_GetConfigLogEntry(&entry);
            if (TRUE == msg_data_p->type.result_bool)
            {
                msg_data_p->data.nlm_config_log_entry.oper_status = entry.oper_status;
                msg_data_p->data.nlm_config_log_entry.admin_status = entry.admin_status;
                strcpy((char *)msg_data_p->data.nlm_config_log_entry.filter_name,(char *)entry.filter_name);
            }

        }
        break;

        case SNMP_MGR_IPCCMD_GET_RMONALARMTABLE:
            msg_data_p->type.result_bool = SNMP_MGR_GetRmonAlarmTable(
                &msg_data_p->data.rmon_alarm_entry);
            break;

        case SNMP_MGR_IPCCMD_GETNEXT_RMONALARMTABLE:
            msg_data_p->type.result_bool = SNMP_MGR_GetNextRmonAlarmTable(
                &msg_data_p->data.rmon_alarm_entry);
            break;

        case SNMP_MGR_IPCCMD_CREATE_RMONALARMENTRY:
            msg_data_p->type.result_bool = SNMP_MGR_CreateRmonAlarmEntry(
                &msg_data_p->data.rmon_alarm_entry);
            break;

        case SNMP_MGR_IPCCMD_DELETE_RMONALARMENTRY:
            msg_data_p->type.result_bool = SNMP_MGR_DeleteRmonAlarmEntry(
                msg_data_p->data.ui32_v);
            break;

        case SNMP_MGR_IPCCMD_MODIFY_RMONALARMENTRY:
            msg_data_p->type.result_bool = SNMP_MGR_ModifyRmonAlarmEntry(
                &msg_data_p->data.rmon_alarm_entry);
            break;

        case SNMP_MGR_IPCCMD_GETNEXT_RUNNING_RMONALARMTABLE:
            msg_data_p->type.result_ui32 = SNMP_MGR_GetNextRunningRmonAlarmTable(
                &msg_data_p->data.rmon_alarm_entry);
            break;

        case SNMP_MGR_IPCCMD_GETNEXT_RUNNING_RMONALARMDELETEDDEFAULTENTRY:
            msg_data_p->type.result_ui32 = SNMP_MGR_GetNextRunningRmonAlarmDeletedDefaultEntry(
                &msg_data_p->data.rmon_alarm_entry);
            break;

        case SNMP_MGR_IPCCMD_GET_RMONEVENTTABLE:
            msg_data_p->type.result_bool = SNMP_MGR_GetRmonEventTable(
                &msg_data_p->data.rmon_event_entry);
            break;

        case SNMP_MGR_IPCCMD_GETNEXT_RMONEVENTTABLE:
            msg_data_p->type.result_bool = SNMP_MGR_GetNextRmonEventTable(
                &msg_data_p->data.rmon_event_entry);
            break;

        case SNMP_MGR_IPCCMD_CREATE_RMONEVENTENTRY:
            msg_data_p->type.result_bool = SNMP_MGR_CreateRmonEventEntry(
                &msg_data_p->data.rmon_event_entry);
            break;

        case SNMP_MGR_IPCCMD_DELETE_RMONEVENTENTRY:
            msg_data_p->type.result_bool = SNMP_MGR_DeleteRmonEventEntry(
                msg_data_p->data.ui32_v);
            break;

        case SNMP_MGR_IPCCMD_MODIFY_RMONEVENTENTRY:
            msg_data_p->type.result_bool = SNMP_MGR_ModifyRmonEventEntry(
                &msg_data_p->data.rmon_event_entry);
            break;

        case SNMP_MGR_IPCCMD_GETNEXT_RUNNING_RMONEVENTTABLE:
            msg_data_p->type.result_ui32 = SNMP_MGR_GetNextRunningRmonEventTable(
                &msg_data_p->data.rmon_event_entry);
            break;

        case SNMP_MGR_IPCCMD_GET_RMONSTATISTICSTABLE:
            msg_data_p->type.result_bool = SNMP_MGR_GetRmonStatisticsTable(
                &msg_data_p->data.rmon_statistics_entry);
            break;

        case SNMP_MGR_IPCCMD_GETNEXT_RMONSTATISTICSTABLE:
            msg_data_p->type.result_bool = SNMP_MGR_GetNextRmonStatisticsTable(
                &msg_data_p->data.rmon_statistics_entry);
            break;

        case SNMP_MGR_IPCCMD_GETNEXT_RMONSTATISTICSTABLE_BYLPORT:
            msg_data_p->type.result_bool = SNMP_MGR_GetNextRmonStatisticsTableByLport(
                msg_data_p->data.ui32_rmon_statistics_entry.ui32,
                &msg_data_p->data.ui32_rmon_statistics_entry.entry);
            break;

        case SNMP_MGR_IPCCMD_CREATE_RMONSTATISTICSENTRY:
            msg_data_p->type.result_bool = SNMP_MGR_CreateRmonStatisticsEntry(
                &msg_data_p->data.rmon_statistics_entry);
            break;

        case SNMP_MGR_IPCCMD_DELETE_RMONSTATISTICSENTRY:
            msg_data_p->type.result_bool = SNMP_MGR_DeleteRmonStatisticsEntryByLport(
                msg_data_p->data.ui32_ui32.ui32_1,
                msg_data_p->data.ui32_ui32.ui32_2);
            break;

        case SNMP_MGR_IPCCMD_MODIFY_RMONSTATISTICSENTRY:
            msg_data_p->type.result_bool = SNMP_MGR_ModifyRmonStatisticsEntry(
                &msg_data_p->data.rmon_statistics_entry);
            break;

        case SNMP_MGR_IPCCMD_GETNEXT_RUNNING_RMONSTATISTICSTABLE_BYLPORT:
            msg_data_p->type.result_ui32 = SNMP_MGR_GetNextRunningRmonStatisticsTableByLport(
                msg_data_p->data.ui32_rmon_statistics_entry.ui32,
                &msg_data_p->data.ui32_rmon_statistics_entry.entry);
            break;

        case SNMP_MGR_IPCCMD_GETNEXT_RUNNING_RMONSTATISTICSDELETEDDEFAULTENTRY_BYLPORT:
            msg_data_p->type.result_ui32 = SNMP_MGR_GetNextRunningRmonStatisticsDeletedDefaultEntryByLport(
                msg_data_p->data.ui32_rmon_statistics_entry.ui32,
                &msg_data_p->data.ui32_rmon_statistics_entry.entry);
            break;

        case SNMP_MGR_IPCCMD_GET_RMONHISTORYCONTROLTABLE:
            msg_data_p->type.result_bool = SNMP_MGR_GetRmonHistoryControlTable(
                &msg_data_p->data.rmon_history_control_entry);
            break;

        case SNMP_MGR_IPCCMD_GETNEXT_RMONHISTORYCONTROLTABLE:
            msg_data_p->type.result_bool = SNMP_MGR_GetNextRmonHistoryControlTable(
                &msg_data_p->data.rmon_history_control_entry);
            break;

        case SNMP_MGR_IPCCMD_GETNEXT_RMONHISTORYCONTROLTABLE_BYLPORT:
            msg_data_p->type.result_bool = SNMP_MGR_GetNextRmonHistoryControlTableByLport(
                msg_data_p->data.ui32_rmon_history_control_entry.ui32,
                &msg_data_p->data.ui32_rmon_history_control_entry.entry);
            break;

        case SNMP_MGR_IPCCMD_CREATE_RMONHISTORYCONTROLENTRY:
            msg_data_p->type.result_bool = SNMP_MGR_CreateRmonHistoryControlEntry(
                &msg_data_p->data.rmon_history_control_entry);
            break;

        case SNMP_MGR_IPCCMD_DELETE_RMONHISTORYCONTROLENTRY:
            msg_data_p->type.result_bool = SNMP_MGR_DeleteRmonHistoryControlEntryByLport(
                msg_data_p->data.ui32_ui32.ui32_1,
                msg_data_p->data.ui32_ui32.ui32_2);
            break;

        case SNMP_MGR_IPCCMD_MODIFY_RMONHISTORYCONTROLENTRY:
            msg_data_p->type.result_bool = SNMP_MGR_ModifyRmonHistoryControlEntry(
                &msg_data_p->data.rmon_history_control_entry);
            break;

        case SNMP_MGR_IPCCMD_GETNEXT_RUNNING_RMONHISTORYCONTROLTABLE_BYLPORT:
            msg_data_p->type.result_ui32 = SNMP_MGR_GetNextRunningRmonHistoryControlTableByLport(
                msg_data_p->data.ui32_rmon_history_control_entry.ui32,
                &msg_data_p->data.ui32_rmon_history_control_entry.entry);
            break;

        case SNMP_MGR_IPCCMD_GETNEXT_RUNNING_RMONHISTORYCONTROLDELETEDEFAULTENTRY_BYLPORT:
            msg_data_p->type.result_ui32 = SNMP_MGR_GetNextRunningRmonHistoryControlDeletedDefaultEntryByLport(
                msg_data_p->data.ui32_rmon_history_control_entry.ui32,
                &msg_data_p->data.ui32_rmon_history_control_entry.entry);
            break;

        case SNMP_MGR_IPCCMD_GETNEXT_RMONHISTORYTABLE_BYCONTROLINDEX:
            msg_data_p->type.result_bool = SNMP_MGR_GetNextRmonHistoryTableByControlIndex(
                &msg_data_p->data.rmon_history_entry);
            break;

        case SNMP_MGR_IPCCMD_PACKETS1H:
        {
            /* the size of the respond size is equal the size of request message.
             * so,msg_p->msg_size do not need change.
             */
            msg_data_p->type.result_bool=SNMP_MGR_Packets1H(
                msg_data_p->data.statistics.unit,
                msg_data_p->data.statistics.port,
                &msg_data_p->data.statistics.value);
        }
        break;

        case SNMP_MGR_IPCCMD_OCTETS1H:
        {
            /* the size of the respond size is equal the size of request message.
             * so,msg_p->msg_size do not need change.
             */
            msg_data_p->type.result_bool=SNMP_MGR_Octets1H(
                msg_data_p->data.statistics.unit,
                msg_data_p->data.statistics.port,
                &msg_data_p->data.statistics.value);
        }
        break;

        case SNMP_MGR_IPCCMD_BCASTS1H:
        {
            /* the size of the respond size is equal the size of request message.
             * so,msg_p->msg_size do not need change.
             */
            msg_data_p->type.result_bool=SNMP_MGR_BCasts1H(
                msg_data_p->data.statistics.unit,
                msg_data_p->data.statistics.port,
                &msg_data_p->data.statistics.value);
        }
        break;

        case SNMP_MGR_IPCCMD_MCASTS1H:
        {
            /* the size of the respond size is equal the size of request message.
             * so,msg_p->msg_size do not need change.
             */
            msg_data_p->type.result_bool=SNMP_MGR_MCasts1H(
                msg_data_p->data.statistics.unit,
                msg_data_p->data.statistics.port,
                &msg_data_p->data.statistics.value);
        }
        break;

        case SNMP_MGR_IPCCMD_FRAGMENTS1H:
        {
            /* the size of the respond size is equal the size of request message.
             * so,msg_p->msg_size do not need change.
             */
            msg_data_p->type.result_bool=SNMP_MGR_Fragments1H(
                msg_data_p->data.statistics.unit,
                msg_data_p->data.statistics.port,
                &msg_data_p->data.statistics.value);
        }
        break;

        case SNMP_MGR_IPCCMD_COLLISIONS1H:
        {
            /* the size of the respond size is equal the size of request message.
             * so,msg_p->msg_size do not need change.
             */
            msg_data_p->type.result_bool=SNMP_MGR_Collisions1H(
                msg_data_p->data.statistics.unit,
                msg_data_p->data.statistics.port,
                &msg_data_p->data.statistics.value);
        }
        break;

        case SNMP_MGR_IPCCMD_ERRORS1H:
        {
            /* the size of the respond size is equal the size of request message.
             * so,msg_p->msg_size do not need change.
             */
            msg_data_p->type.result_bool=SNMP_MGR_Errors1H(
                msg_data_p->data.statistics.unit,
                msg_data_p->data.statistics.port,
                &msg_data_p->data.statistics.value);
        }
        break;

        case SNMP_MGR_IPCCMD_PACKETS6H:
        {
            /* the size of the respond size is equal the size of request message.
             * so,msg_p->msg_size do not need change.
             */
            msg_data_p->type.result_bool=SNMP_MGR_Packets6H(
                msg_data_p->data.statistics.unit,
                msg_data_p->data.statistics.port,
                &msg_data_p->data.statistics.value);
        }
        break;

        case SNMP_MGR_IPCCMD_OCTETS6H:
        {
            /* the size of the respond size is equal the size of request message.
             * so,msg_p->msg_size do not need change.
             */
            msg_data_p->type.result_bool=SNMP_MGR_Octets6H(
                msg_data_p->data.statistics.unit,
                msg_data_p->data.statistics.port,
                &msg_data_p->data.statistics.value);
        }
        break;

        case SNMP_MGR_IPCCMD_BCASTS6H:
        {
            /* the size of the respond size is equal the size of request message.
             * so,msg_p->msg_size do not need change.
             */
            msg_data_p->type.result_bool=SNMP_MGR_BCasts6H(
                msg_data_p->data.statistics.unit,
                msg_data_p->data.statistics.port,
                &msg_data_p->data.statistics.value);
        }
        break;

        case SNMP_MGR_IPCCMD_MCASTS6H:
        {
            /* the size of the respond size is equal the size of request message.
             * so,msg_p->msg_size do not need change.
             */
            msg_data_p->type.result_bool=SNMP_MGR_MCasts6H(
                msg_data_p->data.statistics.unit,
                msg_data_p->data.statistics.port,
                &msg_data_p->data.statistics.value);
        }
        break;

        case SNMP_MGR_IPCCMD_FRAGMENTS6H:
        {
            /* the size of the respond size is equal the size of request message.
             * so,msg_p->msg_size do not need change.
             */
            msg_data_p->type.result_bool=SNMP_MGR_Fragments6H(
                msg_data_p->data.statistics.unit,
                msg_data_p->data.statistics.port,
                &msg_data_p->data.statistics.value);
        }
        break;

        case SNMP_MGR_IPCCMD_COLLISIONS6H:
        {
            /* the size of the respond size is equal the size of request message.
             * so,msg_p->msg_size do not need change.
             */
            msg_data_p->type.result_bool=SNMP_MGR_Collisions6H(
                msg_data_p->data.statistics.unit,
                msg_data_p->data.statistics.port,
                &msg_data_p->data.statistics.value);
        }
        break;

        case SNMP_MGR_IPCCMD_ERRORS6H:
        {
            /* the size of the respond size is equal the size of request message.
             * so,msg_p->msg_size do not need change.
             */
            msg_data_p->type.result_bool=SNMP_MGR_Errors6H(
                msg_data_p->data.statistics.unit,
                msg_data_p->data.statistics.port,
                &msg_data_p->data.statistics.value);
        }
        break;

#if(SYS_CPNT_SNMPV3_TARGET_NAME_STYLE == SYS_CPNT_SNMPV3_TARGET_NAME_STYLE_3COM)
        case SNMP_MGR_IPCCMD_SNMPNOTIFYCREATE:
        {
            msg_p->msg_size=SNMP_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_ui32=SNMP_MGR_SnmpNotifyCreate(
                msg_data_p->data.notify.target_addr_name,
                msg_data_p->data.notify.notify_type,
                msg_data_p->data.notify.user_name,
                msg_data_p->data.notify.dest_ip_addres,
                msg_data_p->data.notify.dest_port,
                msg_data_p->data.notify.remote_engineID,
                msg_data_p->data.notify.remote_engineIDLen,
                msg_data_p->data.notify.password_from_config,
                msg_data_p->data.notify.auth_protocol,
                msg_data_p->data.notify.auth_key_len,
                msg_data_p->data.notify.authentication_password,
                msg_data_p->data.notify.priv_protocol,
                msg_data_p->data.notify.priv_key_len,
                msg_data_p->data.notify.privacy_password,
                msg_data_p->data.notify.retry_interval,
                msg_data_p->data.notify.retry_count);
        }
        break;

        case SNMP_MGR_IPCCMD_SNMPNOTIFYDEL:
        {
            msg_p->msg_size=SNMP_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_ui32=SNMP_MGR_SnmpNotifyDel(
                msg_data_p->data.snmp_target_addr_name);
        }
        break;

        case SNMP_MGR_IPCCMD_SNMPNOTIFYMODIFY:
        {
            msg_p->msg_size=SNMP_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_ui32=SNMP_MGR_SnmpNotifyModify(
                msg_data_p->data.notify.target_addr_name,
                msg_data_p->data.notify.notify_type,
                msg_data_p->data.notify.user_name,
                msg_data_p->data.notify.dest_ip_addres,
                msg_data_p->data.notify.dest_port,
                msg_data_p->data.notify.remote_engineID,
                msg_data_p->data.notify.remote_engineIDLen,
                msg_data_p->data.notify.password_from_config,
                msg_data_p->data.notify.auth_protocol,
                msg_data_p->data.notify.auth_key_len,
                msg_data_p->data.notify.authentication_password,
                msg_data_p->data.notify.priv_protocol,
                msg_data_p->data.notify.priv_key_len,
                msg_data_p->data.notify.privacy_password,
                msg_data_p->data.notify.retry_interval,
                msg_data_p->data.notify.retry_count);
        }
        break;
#endif /* (SYS_CPNT_SNMPV3_TARGET_NAME_STYLE == SYS_CPNT_SNMPV3_TARGET_NAME_STYLE_3COM)            */

        case SNMP_MGR_IPCCMD_GETSNMPENABLEAUTHENTRAPS:
        {
            /* the size of the respond size is equal the size of request message.
             * so,msg_p->msg_size do not need change.
             */
            msg_data_p->type.result_bool=SNMP_MGR_GetSnmpEnableAuthenTraps(
                &msg_data_p->data.ui8_v);
        }
        break;

        case SNMP_MGR_IPCCMD_SETSNMPENABLEAUTHENTRAPS:
        {
            msg_p->msg_size=SNMP_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SNMP_MGR_SetSnmpEnableAuthenTraps(
                msg_data_p->data.ui8_v);
        }
        break;

        case SNMP_MGR_IPCCMD_SETSNMPENABLELINKUPDOWNTRAPS:
        {
            msg_p->msg_size=SNMP_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SNMP_MGR_SetSnmpEnableLinkUpDownTraps(
                msg_data_p->data.ui8_v);
        }
        break;

#if(SYS_CPNT_CLUSTER==TRUE)
        case SNMP_MGR_IPCCMD_SETCLUSTERROLE:
        {
            msg_p->msg_size=SNMP_MGR_MSGBUF_TYPE_SIZE;
            SNMP_MGR_SetClusterRole(msg_data_p->data.ui32_v);
        }
        break;
#endif

        case SNMP_MGR_IPCCMD_ASYN_REQSENDTRAP:
        {
            SNMP_MGR_ReqSendTrap(
                &msg_data_p->data.trap_data_entry);
        }
        break;

        case SNMP_MGR_IPCCMD_ASYN_REQSENDTRAPOPTIONAL:
        {
            SNMP_MGR_ReqSendTrapOptional(
                &msg_data_p->data.trap_event_with_flag.trap_data,
                msg_data_p->data.trap_event_with_flag.flag);
        }
        break;

        case SNMP_MGR_IPCCMD_ASYN_NOTIFYSTATPLGCHANGED:
        {
            SNMP_MGR_NotifyStaTplgChanged();
        }
        break;

        case SNMP_MGR_IPCCMD_ASYN_NOTIFYSTATPLGSTABLED:
        {
            SNMP_MGR_NotifyStaTplgStabled();
        }
        break;

        default:
            msg_data_p->type.result_ui32=0;
            msg_p->msg_size=SNMP_MGR_MSGBUF_TYPE_SIZE;
            SYSFUN_Debug_Printf("%s(): Invalid cmd.\n", __FUNCTION__);
            return TRUE;
    }

    /*Check sychronism or asychronism ipc. If it is sychronism(need to respond)then we return true.
     */
    if(cmd<SNMP_MGR_IPCCMD_FOLLOWISASYNCHRONISMIPC)
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
 }

#if(SYS_CPNT_CLUSTER==TRUE)
/*--------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_SetClusterRole
 *---------------------------------------------------------------------------
 * PURPOSE:  This function is set snmp next cluster role.
 * INPUT:    role
 * OUTPUT:
 * RETURN:
 * NOTE:
 *---------------------------------------------------------------------------
 */
void SNMP_MGR_SetClusterRole (UI32_T role)
{
    SNMP_CLUSTER_SetClusterRole (role);
    return;
}
#endif /*end of #if(SYS_CPNT_CLUSTER==TRUE)*/
#if (SYS_CPNT_NOTIFICATIONLOG_MIB == TRUE)
/* Notification Log MIB -- Meiling Hou 2008.04.15 */
BOOL_T SNMP_MGR_CheckExistNotifyFilter(UI32_T trap_type, UI32_T specific_type,
                    UI32_T *enterprise, UI32_T enterprise_length, char *filter_name)
{
    oid trap_type_oid[SYS_ADPT_MAX_OID_COUNT];
    UI32_T trap_type_len;
    SNMP_MGR_SnmpNotifyFilterEntry_T filter_entry;
    SNMP_MGR_SnmpNotifyFilterEntry_T filter_entry_pret;
    int found;
    int count=0;


    if (SYSFUN_GET_CSC_OPERATING_MODE() != SYS_TYPE_STACKING_MASTER_MODE)
    {
        return FALSE;
    }

    /* The first step we need to define a OID to the trap_type and specific_type*/
    switch (trap_type)
    {
        case SNMP_TRAP_COLDSTART:
            memcpy( trap_type_oid, snmp_mgr_cold_start_oid, len_snmp_mgr_cold_start_oid * sizeof(oid));
            trap_type_len = len_snmp_mgr_cold_start_oid;
            break;
        case SNMP_TRAP_WARMSTART:
            memcpy( trap_type_oid, snmp_mgr_warm_start_oid, len_snmp_mgr_warm_start_oid * sizeof(oid));
            trap_type_len = len_snmp_mgr_warm_start_oid;
            break;
        case SNMP_TRAP_LINKDOWN:
            memcpy( trap_type_oid, snmp_mgr_link_down_oid, len_snmp_mgr_link_down_oid * sizeof(oid));
            trap_type_len = len_snmp_mgr_link_down_oid;
            break;
        case SNMP_TRAP_LINKUP:
            memcpy( trap_type_oid, snmp_mgr_link_up_oid, len_snmp_mgr_link_up_oid * sizeof(oid));
            trap_type_len = len_snmp_mgr_link_up_oid;
            break;
        case SNMP_TRAP_AUTHFAIL:
            memcpy( trap_type_oid, snmp_mgr_auth_fail_oid, len_snmp_mgr_auth_fail_oid * sizeof(oid));
            trap_type_len = len_snmp_mgr_auth_fail_oid;
            break;

        case SNMP_TRAP_ENTERPRISESPECIFIC:
            memcpy( trap_type_oid, enterprise, enterprise_length * sizeof(oid));
            /* The really trap OID = enterprise ID.0(xxxxTrapPrefixs).specific_type*/
            trap_type_oid[enterprise_length] = 0;
            trap_type_oid[enterprise_length+1] = specific_type;
            trap_type_len = enterprise_length+2;
            break;
        default:
            return FALSE;
    }

    /* check the snmpNotifyFilterTable and see if the desired
       sent TRAP OID is within the snmpNotifyFilterTable.
       if cannot get any filter, then no filter function is perform */
    memset(&filter_entry_pret, 0, sizeof(filter_entry_pret));
    memset(&filter_entry, 0, sizeof(filter_entry));
    strncpy(filter_entry.snmp_notify_filter_profile_name, filter_name,
        sizeof(filter_entry.snmp_notify_filter_profile_name));
    filter_entry.snmp_notify_filter_profile_name[sizeof(filter_entry.snmp_notify_filter_profile_name)-1] = '\0';

    while (SNMP_MGR_GetNextSnmpNotifyFilterTable(&filter_entry) == SNMP_MGR_ERROR_OK)
    {
        if ((strcmp(filter_entry.snmp_notify_filter_profile_name, (char *)filter_name)==0)
            && (trap_type_len>= filter_entry.snmp_notify_filter_subtree_len))
            {
                int   mask = 0x80, maskpos = 0;
                int   oidpos;
                found = 1;

                for (oidpos = 0;
                     found && oidpos < (int) filter_entry.snmp_notify_filter_subtree_len ;
                     oidpos++)
                {
                    if ((maskpos >= filter_entry.snmp_notify_filter_mask_len)
                        || ((filter_entry.snmp_notify_filter_mask[maskpos] & mask) != 0))
                    {
                        if (trap_type_oid[oidpos] != filter_entry.snmp_notify_filter_subtree[oidpos])
                        {
                            found = 0;
                        }
                    }
                    if (mask == 1)
                    {
                        mask = 0x80;
                        maskpos++;
                    }
                    else
                    {
                        mask >>= 1;
                    }
                }

                if (found)
                {
                    /*
                     * match successful, keep this node if its longer than
                     * the previous or (equal and lexicographically greater
                     * than the previous).
                     */
                    count++;
                    if (( strcmp(filter_entry_pret.snmp_notify_filter_profile_name, "") == 0)
                        || filter_entry.snmp_notify_filter_subtree_len > filter_entry_pret.snmp_notify_filter_subtree_len
                        || (filter_entry.snmp_notify_filter_subtree_len == filter_entry_pret.snmp_notify_filter_subtree_len
                        && snmp_oid_compare(filter_entry.snmp_notify_filter_subtree,
                            filter_entry.snmp_notify_filter_subtree_len,
                            filter_entry_pret.snmp_notify_filter_subtree,
                            filter_entry_pret.snmp_notify_filter_subtree_len) > 0))
                    {
                        memcpy(&filter_entry_pret, &filter_entry, sizeof(filter_entry_pret));
                    }
                }
            }
        } /*end of while*/

        if ((strcmp(filter_entry_pret.snmp_notify_filter_profile_name, "") == 0) || (filter_entry_pret.snmp_notify_filter_type == VAL_snmpNotifyFilterType_excluded))
        {
            return FALSE;
        }

    /* 2006.9.25, Ruliang, Fixed bug HH33954 submitted by Ericsson -- Switch remains unreachable
    * after "copy start run" command.
    * Root cause: In normal case not release CSC.
    */
    /* end 2006.9.25, Ruliang */


    return TRUE;
}

BOOL_T SNMP_MGR_CheckNotifyFilterName(char *filter_name)
{
    SNMP_MGR_SnmpNotifyFilterProfileEntry_T entry;

    memset(&entry, 0, sizeof(SNMP_MGR_SnmpNotifyFilterProfileEntry_T));

    while (SNMP_MGR_GetNextSnmpNotifyFilterProfileTable(&entry) == SNMP_MGR_ERROR_OK)
    {
        if (strcmp(entry.snmp_notify_filter_profile_name, filter_name) == 0)
            return TRUE;
    }

    return FALSE;
}

/*-------------------------------------------------------------------------
 * FUNCTION NAME - SNMP_MGR_GetSnmpNotifyFilterProfileTableByProfileName
 *-------------------------------------------------------------------------
 * PURPOSE : Get notify filter profile entry by profile name
 * INPUT   : entry->snmp_notify_filter_profile_name -- to specify a profile name
 * OUTPUT  : entry  -- notify filter profile entry
 * RETURN  : SNMP_MGR_ERROR_OK    -- success
 *           SNMP_MGR_ERROR_FAIL  -- fail
 * NOTE    : None
 *-------------------------------------------------------------------------
 */
UI32_T
SNMP_MGR_GetSnmpNotifyFilterProfileTableByProfileName(
    SNMP_MGR_SnmpNotifyFilterProfileEntry_T *entry)
{
    SNMP_MGR_SnmpNotifyFilterProfileEntry_T local_entry;

    memset(&local_entry, 0, sizeof(local_entry));

    while (SNMP_MGR_ERROR_OK == SNMP_MGR_GetNextSnmpNotifyFilterProfileTable(&local_entry))
    {
        if (0 == strcmp(entry->snmp_notify_filter_profile_name, local_entry.snmp_notify_filter_profile_name))
        {
            memcpy(&entry->snmp_notify_filter_profile_ip,
                &local_entry.snmp_notify_filter_profile_ip,
                sizeof(entry->snmp_notify_filter_profile_ip));
            strncpy(entry->snmp_target_params_name,
                local_entry.snmp_target_params_name,
                sizeof(entry->snmp_target_params_name));
            entry->snmp_target_params_name[sizeof(entry->snmp_target_params_name)-1] = '\0';
            entry->snmp_notify_filter_profile_stor_type = local_entry.snmp_notify_filter_profile_stor_type;
            entry->snmp_notify_filter_profile_row_status = local_entry.snmp_notify_filter_profile_row_status;
            return SNMP_MGR_ERROR_OK;
        }
    }

    return SNMP_MGR_ERROR_FAIL;
}
#endif

/* rmon
 */
static BOOL_T SNMP_MGR_GetRmonAlarmTable(SNMP_MGR_RmonAlarmEntry_T *entry_p)
{
    UI32_T orig_priority;
    BOOL_T ret;

    SNMP_MGR_CHECK_OPER_MODE(SYS_TYPE_GET_RUNNING_CFG_FAIL);


    ret = ALARM_GetAlarmTable(entry_p);


    return ret;
}

static BOOL_T SNMP_MGR_GetNextRmonAlarmTable(SNMP_MGR_RmonAlarmEntry_T *entry_p)
{
    UI32_T orig_priority;
    BOOL_T ret;

    SNMP_MGR_CHECK_OPER_MODE(SYS_TYPE_GET_RUNNING_CFG_FAIL);


    ret = ALARM_GetNextAlarmTable(entry_p);


    return ret;
}

static BOOL_T SNMP_MGR_CreateRmonAlarmEntry(SNMP_MGR_RmonAlarmEntry_T *entry_p)
{
    UI32_T orig_priority;
    BOOL_T ret;

    SNMP_MGR_CHECK_OPER_MODE(SYS_TYPE_GET_RUNNING_CFG_FAIL);


    ret = ALARM_CreateAlarmEntry(entry_p);


    return ret;
}

static BOOL_T SNMP_MGR_DeleteRmonAlarmEntry(UI32_T index)
{
    UI32_T orig_priority;
    BOOL_T ret;

    SNMP_MGR_CHECK_OPER_MODE(SYS_TYPE_GET_RUNNING_CFG_FAIL);


    ret = ALARM_DeleteAlarmEntry(index);


    return ret;
}

static BOOL_T SNMP_MGR_ModifyRmonAlarmEntry(SNMP_MGR_RmonAlarmEntry_T *entry_p)
{
    UI32_T orig_priority;
    BOOL_T ret = TRUE;

    SNMP_MGR_CHECK_OPER_MODE(SYS_TYPE_GET_RUNNING_CFG_FAIL);


    ret = ALARM_DeleteAlarmEntry(entry_p->id);
    ret = ALARM_CreateAlarmEntry(entry_p);


    return ret;
}

static UI32_T SNMP_MGR_GetNextRunningRmonAlarmTable(SNMP_MGR_RmonAlarmEntry_T *entry_p)
{
    UI32_T orig_priority;
    UI32_T ret = SYS_TYPE_GET_RUNNING_CFG_NO_CHANGE;

    SNMP_MGR_CHECK_OPER_MODE(SYS_TYPE_GET_RUNNING_CFG_FAIL);



    while (TRUE == ALARM_GetNextAlarmTable(entry_p))
    {
        if (TRUE == ALARM_IsAlarmEntryModified(entry_p))
        {
            ret = SYS_TYPE_GET_RUNNING_CFG_SUCCESS;
            break;
        }
    }



    return ret;
}

static UI32_T SNMP_MGR_GetNextRunningRmonAlarmDeletedDefaultEntry(SNMP_MGR_RmonAlarmEntry_T *entry_p)
{
    UI32_T orig_priority;
    UI32_T ret = SYS_TYPE_GET_RUNNING_CFG_NO_CHANGE;

    SNMP_MGR_CHECK_OPER_MODE(SYS_TYPE_GET_RUNNING_CFG_FAIL);



    if (ALARM_GetNextDeletedDefaultEntry(entry_p) == TRUE)
    {
        ret = SYS_TYPE_GET_RUNNING_CFG_SUCCESS;
    }



    return ret;
}

static BOOL_T SNMP_MGR_GetRmonEventTable(SNMP_MGR_RmonEventEntry_T *entry_p)
{
    UI32_T orig_priority;
    BOOL_T ret;

    SNMP_MGR_CHECK_OPER_MODE(SYS_TYPE_GET_RUNNING_CFG_FAIL);


    ret = EVENT_GetEventTable(entry_p);


    return ret;
}

static BOOL_T SNMP_MGR_GetNextRmonEventTable(SNMP_MGR_RmonEventEntry_T *entry_p)
{
    UI32_T orig_priority;
    BOOL_T ret;

    SNMP_MGR_CHECK_OPER_MODE(SYS_TYPE_GET_RUNNING_CFG_FAIL);


    ret = EVENT_GetNextEventTable(entry_p);


    return ret;
}

static BOOL_T SNMP_MGR_CreateRmonEventEntry(SNMP_MGR_RmonEventEntry_T *entry_p)
{
    UI32_T orig_priority;
    BOOL_T ret;

    SNMP_MGR_CHECK_OPER_MODE(SYS_TYPE_GET_RUNNING_CFG_FAIL);



    if(0 == strlen(entry_p->community))
    {
        strncpy(entry_p->community,SNMP_MGR_DEFAULT_COMMUNITY,sizeof(entry_p->community) - 1);
        entry_p->community[sizeof(entry_p->community) - 1] = '\0';
    }

    ret = EVENT_CreateEventEntry(entry_p);


    return ret;
}

static BOOL_T SNMP_MGR_DeleteRmonEventEntry(UI32_T index)
{
    UI32_T orig_priority;
    BOOL_T ret;

    SNMP_MGR_CHECK_OPER_MODE(SYS_TYPE_GET_RUNNING_CFG_FAIL);


    ret = EVENT_DeleteEventEntry(index);


    return ret;
}

static BOOL_T SNMP_MGR_ModifyRmonEventEntry(SNMP_MGR_RmonEventEntry_T *entry_p)
{
    UI32_T orig_priority;
    BOOL_T ret = TRUE;

    SNMP_MGR_CHECK_OPER_MODE(SYS_TYPE_GET_RUNNING_CFG_FAIL);


    ret = EVENT_DeleteEventEntry(entry_p->id);
    ret = EVENT_CreateEventEntry(entry_p);


    return ret;
}

static UI32_T SNMP_MGR_GetNextRunningRmonEventTable(SNMP_MGR_RmonEventEntry_T *entry_p)
{
    UI32_T orig_priority;
    UI32_T ret = SYS_TYPE_GET_RUNNING_CFG_NO_CHANGE;

    SNMP_MGR_CHECK_OPER_MODE(SYS_TYPE_GET_RUNNING_CFG_FAIL);



    while (TRUE == EVENT_GetNextEventTable(entry_p))
    {
        if (TRUE == EVENT_IsEventEntryModified(entry_p))
        {
            ret = SYS_TYPE_GET_RUNNING_CFG_SUCCESS;
            break;
        }
    }



    return ret;
}

static BOOL_T SNMP_MGR_GetRmonStatisticsTable(SNMP_MGR_RmonStatisticsEntry_T *entry_p)
{
    UI32_T orig_priority;
    BOOL_T ret;

    SNMP_MGR_CHECK_OPER_MODE(FALSE);


    ret = STATISTICS_GetStatisticsTable(entry_p);


    return ret;
}

static BOOL_T SNMP_MGR_GetNextRmonStatisticsTable(SNMP_MGR_RmonStatisticsEntry_T *entry_p)
{
    UI32_T orig_priority;
    BOOL_T ret;

    SNMP_MGR_CHECK_OPER_MODE(FALSE);


    ret = STATISTICS_GetNextStatisticsTable(entry_p);


    return ret;
}

static BOOL_T SNMP_MGR_GetNextRmonStatisticsTableByLport(UI32_T lport, SNMP_MGR_RmonStatisticsEntry_T *entry_p)
{
    UI32_T orig_priority;
    BOOL_T ret;

    SNMP_MGR_CHECK_OPER_MODE(FALSE);


    ret = STATISTICS_GetNextStatisticsTableByLport(lport, entry_p);


    return ret;
}

static BOOL_T SNMP_MGR_CreateRmonStatisticsEntry(SNMP_MGR_RmonStatisticsEntry_T *entry_p)
{
    UI32_T orig_priority;
    BOOL_T ret;

    SNMP_MGR_CHECK_OPER_MODE(FALSE);


    ret = STATISTICS_CreateStatisticsEntry(entry_p);


    return ret;
}

static BOOL_T SNMP_MGR_DeleteRmonStatisticsEntryByLport(UI32_T if_index, UI32_T index)
{
    UI32_T orig_priority;
    BOOL_T ret;

    SNMP_MGR_CHECK_OPER_MODE(FALSE);


    ret = STATISTICS_DeleteStatisticsEntryByLport(if_index, index);


    return ret;
}

static BOOL_T SNMP_MGR_ModifyRmonStatisticsEntry(SNMP_MGR_RmonStatisticsEntry_T *entry_p)
{
    UI32_T orig_priority;
    BOOL_T ret = TRUE;

    SNMP_MGR_CHECK_OPER_MODE(FALSE);


    ret = STATISTICS_DeleteStatisticsEntryByLport(entry_p->if_index, entry_p->id);
    ret = STATISTICS_CreateStatisticsEntry(entry_p);


    return ret;
}

static UI32_T SNMP_MGR_GetNextRunningRmonStatisticsTableByLport(UI32_T lport, SNMP_MGR_RmonStatisticsEntry_T *entry_p)
{
    UI32_T orig_priority;
    UI32_T ret = SYS_TYPE_GET_RUNNING_CFG_NO_CHANGE;

    SNMP_MGR_CHECK_OPER_MODE(SYS_TYPE_GET_RUNNING_CFG_FAIL);



    while (TRUE == STATISTICS_GetNextStatisticsTableByLport(lport, entry_p))
    {
        if (TRUE == STATISTICS_IsStatisticsEntryModified(entry_p))
        {
            ret = SYS_TYPE_GET_RUNNING_CFG_SUCCESS;
            break;
        }
    }



    return ret;
}

static UI32_T SNMP_MGR_GetNextRunningRmonStatisticsDeletedDefaultEntryByLport(UI32_T lport, SNMP_MGR_RmonStatisticsEntry_T *entry_p)
{
    UI32_T orig_priority;
    UI32_T ret = SYS_TYPE_GET_RUNNING_CFG_NO_CHANGE;

    SNMP_MGR_CHECK_OPER_MODE(SYS_TYPE_GET_RUNNING_CFG_FAIL);



    if (STATISTICS_GetNextDeletedDefaultEntry(lport, entry_p) == TRUE)
    {
        ret = SYS_TYPE_GET_RUNNING_CFG_SUCCESS;
    }



    return ret;
}

static BOOL_T SNMP_MGR_GetRmonHistoryControlTable(SNMP_MGR_RmonHistoryControlEntry_T *entry_p)
{
    UI32_T orig_priority;
    BOOL_T ret;

    SNMP_MGR_CHECK_OPER_MODE(FALSE);


    ret = HISTORY_GetHistoryControlTable(entry_p);


    return ret;
}

static BOOL_T SNMP_MGR_GetNextRmonHistoryControlTable(SNMP_MGR_RmonHistoryControlEntry_T *entry_p)
{
    UI32_T orig_priority;
    BOOL_T ret;

    SNMP_MGR_CHECK_OPER_MODE(FALSE);


    ret = HISTORY_GetNextHistoryControlTable(entry_p);


    return ret;
}

static BOOL_T SNMP_MGR_GetNextRmonHistoryControlTableByLport(UI32_T lport, SNMP_MGR_RmonHistoryControlEntry_T *entry_p)
{
    UI32_T orig_priority;
    BOOL_T ret;

    SNMP_MGR_CHECK_OPER_MODE(FALSE);


    ret = HISTORY_GetNextHistoryControlTableByLport(lport, entry_p);


    return ret;
}

static BOOL_T SNMP_MGR_CreateRmonHistoryControlEntry(SNMP_MGR_RmonHistoryControlEntry_T *entry_p)
{
    UI32_T orig_priority;
    BOOL_T ret;

    SNMP_MGR_CHECK_OPER_MODE(FALSE);


    ret = HISTORY_CreateHistoryControlEntry(entry_p);


    return ret;
}

static BOOL_T SNMP_MGR_DeleteRmonHistoryControlEntryByLport(UI32_T if_index, UI32_T index)
{
    UI32_T orig_priority;
    BOOL_T ret;

    SNMP_MGR_CHECK_OPER_MODE(FALSE);


    ret = HISTORY_DeleteHistoryControlEntryByLport(if_index, index);


    return ret;
}

static BOOL_T SNMP_MGR_ModifyRmonHistoryControlEntry(SNMP_MGR_RmonHistoryControlEntry_T *entry_p)
{
    UI32_T orig_priority;
    BOOL_T ret = TRUE;

    SNMP_MGR_CHECK_OPER_MODE(FALSE);


    ret = HISTORY_DeleteHistoryControlEntryByLport(entry_p->if_index, entry_p->id);
    ret = HISTORY_CreateHistoryControlEntry(entry_p);


    return ret;
}

static UI32_T SNMP_MGR_GetNextRunningRmonHistoryControlTableByLport(UI32_T lport, SNMP_MGR_RmonHistoryControlEntry_T *entry_p)
{
    UI32_T orig_priority;
    UI32_T ret = SYS_TYPE_GET_RUNNING_CFG_NO_CHANGE;

    SNMP_MGR_CHECK_OPER_MODE(SYS_TYPE_GET_RUNNING_CFG_FAIL);



    while (TRUE == HISTORY_GetNextHistoryControlTableByLport(lport, entry_p))
    {
        if (TRUE == HISTORY_IsHistoryControlEntryModified(entry_p))
        {
            ret = SYS_TYPE_GET_RUNNING_CFG_SUCCESS;
            break;
        }
    }



    return ret;
}

static UI32_T SNMP_MGR_GetNextRunningRmonHistoryControlDeletedDefaultEntryByLport(UI32_T lport, SNMP_MGR_RmonHistoryControlEntry_T *entry_p)
{
    UI32_T orig_priority;
    UI32_T ret = SYS_TYPE_GET_RUNNING_CFG_NO_CHANGE;

    SNMP_MGR_CHECK_OPER_MODE(SYS_TYPE_GET_RUNNING_CFG_FAIL);



    if (HISTORY_GetNextDeletedDefaultEntry(lport, entry_p) == TRUE)
    {
        ret = SYS_TYPE_GET_RUNNING_CFG_SUCCESS;
    }



    return ret;
}

static BOOL_T SNMP_MGR_GetNextRmonHistoryTableByControlIndex(SNMP_MGR_RmonHistoryEntry_T *entry_p)
{
    UI32_T orig_priority;
    BOOL_T ret;

    SNMP_MGR_CHECK_OPER_MODE(FALSE);


    ret = HISTORY_GetNextHistoryTableByControlIndex(entry_p);


    return ret;
}

static BOOL_T SNMP_MGR_HasRouteToTrapServer()
{
    UI32_T  out_ifindex;
    SNMP_MGR_TrapDestEntry_T entry;
    L_INET_AddrIp_T src_ip;
    L_INET_AddrIp_T dst_ip;
    L_INET_AddrIp_T nexthop_ip;

    memset(&entry, 0x0, sizeof(entry));
    memset(&dst_ip, 0x0, sizeof(dst_ip));
    memset(&src_ip, 0x0, sizeof(src_ip));

    dst_ip.type = L_INET_ADDR_TYPE_IPV4;
    dst_ip.addrlen = SYS_ADPT_IPV4_ADDR_LEN;

    while (SNMP_MGR_ERROR_OK == SNMP_MGR_GetNextTrapReceiver(&entry))
    {
        memcpy(&dst_ip, &entry.trap_dest_address, sizeof(dst_ip));

        if (VAL_InetAddressType_ipv6z == dst_ip.type)
        {
            return TRUE;
        }

        if (IPAL_RESULT_OK == IPAL_ROUTE_RouteLookup(&dst_ip, &src_ip, &nexthop_ip, &out_ifindex))
        {
            return TRUE;
        }
    }

    return FALSE;
}

#if (SYS_CPNT_CLUSTER == TRUE)
static BOOL_T SNMP_MGR_HasRouteToClusterCommander()
{
    UI32_T ip;
    UI32_T out_ifindex;
    L_INET_AddrIp_T src_ip;
    L_INET_AddrIp_T dst_ip;
    L_INET_AddrIp_T nexthop_ip;

    SNMP_CLUSTER_GetCommanderIp((UI8_T *)&ip);
    ip = L_STDLIB_Ntoh32(ip);
    if (0 == ip)
    {
        return FALSE;
    }

    memset(&dst_ip, 0x0, sizeof(dst_ip));
    memset(&src_ip, 0x0, sizeof(src_ip));

    dst_ip.type = L_INET_ADDR_TYPE_IPV4;
    dst_ip.addrlen = SYS_ADPT_IPV4_ADDR_LEN;
    IP_LIB_UI32toArray(ip, dst_ip.addr);

    if (IPAL_RESULT_OK != IPAL_ROUTE_RouteLookup(&dst_ip, &src_ip, &nexthop_ip, &out_ifindex))
    {
        return FALSE;
    }

    return TRUE;
}
#endif /* #if (SYS_CPNT_CLUSTER == TRUE) */

static UI32_T SNMP_MGR_SendEventToSnmpTask(UI32_T event)
{
    UI32_T task_id;

    SNMP_TASK_GetTaskId(&task_id);

    return SYSFUN_SendEvent(task_id, event);
}

static BOOL_T SNMP_MGR_IsNotifyFilterAllowToSendTrap(char *targetparamsname, oid *trap_oid, UI32_T trap_oid_len)
{
    SNMP_MGR_SnmpNotifyFilterEntry_T filter_entry;
    SNMP_MGR_SnmpNotifyFilterEntry_T last_matched_entry;
    SNMP_MGR_SnmpNotifyFilterProfileEntry_T filter_profile_entry;

    memset(&filter_profile_entry, 0, sizeof(filter_profile_entry));
    strncpy(filter_profile_entry.snmp_target_params_name, targetparamsname, MAXSIZE_snmpTargetParamsName);
    filter_profile_entry.snmp_target_params_name[MAXSIZE_snmpTargetParamsName] = '\0';

    if (SNMP_MGR_ERROR_OK != SNMP_MGR_GetSnmpNotifyFilterProfileTable(&filter_profile_entry))
    {
        /* cannot get the profile filter, no filter is perform
         */
        return TRUE;
    }

    memset(&filter_entry, 0, sizeof(filter_entry));
    memset(&last_matched_entry, 0, sizeof(last_matched_entry));
    strcpy(filter_entry.snmp_notify_filter_profile_name, filter_profile_entry.snmp_target_params_name);

    while (SNMP_MGR_ERROR_OK == SNMP_MGR_GetNextSnmpNotifyFilterTable(&filter_entry))
    {
        SNMP_MGR_SnmpNotifyFilterEntry_T *matched_entry_p;
        UI32_T oid_pos;
        UI8_T mask_pos;
        UI8_T mask;
        UI8_T mask_bit;

        if (   (0 != strcmp(filter_entry.snmp_notify_filter_profile_name, filter_profile_entry.snmp_target_params_name))
            || (trap_oid_len < filter_entry.snmp_notify_filter_subtree_len))
        {
            continue;
        }

        matched_entry_p = &filter_entry;
        mask_pos = 0;
        mask_bit = 0x80;

        for (oid_pos = 0; oid_pos < filter_entry.snmp_notify_filter_subtree_len; oid_pos++)
        {
            /* According to the description of snmpNotifyFilterMask,
             * the part of the filter mask that are not specified
             * explicitly should be filled with all-1.
             *
             * mask_pos is added to 1 before to compare with
             * snmp_notify_filter_mask_len is due to mask_pos is started from 0.
             */
            mask = ((mask_pos + 1) > filter_entry.snmp_notify_filter_mask_len) ? 0xFF : filter_entry.snmp_notify_filter_mask[mask_pos];

            /* mask_bit is 0 means "don't care"
             */
            if (   (0 != (mask & mask_bit))
                && (trap_oid[oid_pos] != filter_entry.snmp_notify_filter_subtree[oid_pos]))
            {
                matched_entry_p = NULL;
                break;
            }

            mask_bit >>= 1;
            if (0 >= mask_bit)
            {
                mask_bit = 0x80;
                mask_pos++;
            }
        }

        if (NULL != matched_entry_p)
        {
            /* keep this node if:
             * 1. it is never match before, or
             * 2. it is longer than the previous one, or
             * 3. its length is equal to the previous one and lexicographically
             *    greater than the previous one.
             */
            if (   ('\0' == last_matched_entry.snmp_notify_filter_profile_name[0])
                || (matched_entry_p->snmp_notify_filter_subtree_len > last_matched_entry.snmp_notify_filter_subtree_len)
                || (   (matched_entry_p->snmp_notify_filter_subtree_len == last_matched_entry.snmp_notify_filter_subtree_len)
                    && (snmp_oid_compare(matched_entry_p->snmp_notify_filter_subtree, matched_entry_p->snmp_notify_filter_subtree_len,
                            last_matched_entry.snmp_notify_filter_subtree, last_matched_entry.snmp_notify_filter_subtree_len) > 0))
                )
            {
                memcpy(&last_matched_entry, matched_entry_p, sizeof(last_matched_entry));
            }
        }
    } /* while (SNMP_MGR_ERROR_OK == SNMP_MGR_GetNextSnmpNotifyFilterTable(&filter_entry)) */

    if (   ('\0' == last_matched_entry.snmp_notify_filter_profile_name[0])
        || (VAL_snmpNotifyFilterType_excluded == last_matched_entry.snmp_notify_filter_type))
    {
        return FALSE;
    }

    return TRUE;
}

static BOOL_T SNMP_MGR_IsVacmOrUsmAllowToSendTrap(netsnmp_session *sess, oid *trap_oid, UI32_T trap_oid_len, UI32_T pdu_type)
{
    SNMP_MGR_SnmpCommunityEntry_T comm_entry;
    SNMP_MGR_SnmpV3GroupEntry_T group_entry;
    SNMP_MGR_SnmpV3UserEntry_T user_entry;
    SNMP_MGR_SnmpV3UserEntry_T sec_to_group_entry;
    struct vacm_viewEntry *vp;
    struct vacm_accessEntry *ap;
    struct vacm_groupEntry *geptr= NULL;
    UI32_T engineIDLen;
    UI32_T orig_priority;

     /* Process 2 begin*/
     switch (sess->version)
     {
         case 0/*SNMP_VERSION_1*/:
         case 1/*SNMP_VERSION_2c*/:
             memcpy(comm_entry.snmp_community_index, sess->community, sess->community_len);
             comm_entry.snmp_community_index[sess->community_len]= 0;
         /* v1 and v2 model, we need to use community to check the notify view*/
             if (SNMP_MGR_GetSnmpCommunityEntry(&comm_entry)== SNMP_MGR_ERROR_OK)
             {
                  /* group name use community name*/
                  memcpy(group_entry.snmpv3_group_name, sess->community, sess->community_len);
                  group_entry.snmpv3_group_name[sess->community_len] = 0;
                  if (sess->version == 0/*SNMP_VERSION_1*/)
                  {
                      group_entry.snmpv3_group_model = SNMP_MGR_SNMPV3_MODEL_V1;
                  }
                  else if (sess->version == 1/*SNMP_VERSION_2*/)
                  {
                      group_entry.snmpv3_group_model = SNMP_MGR_SNMPV3_MODEL_V2C;
                  }

                 /*Check securityToGroupTable to fetch the group name*/

                  geptr = vacm_getGroupEntry(group_entry.snmpv3_group_model , comm_entry.snmp_community_security_name);

                  if (geptr)
                  {
                      ap = vacm_getExactAccessEntry(geptr->groupName, "", geptr->securityModel,VAL_vacmAccessSecurityLevel_noAuthNoPriv );
                      if (ap)
                      {

                          vp = vacm_getViewEntry(ap->notifyView, trap_oid, trap_oid_len,VACM_MODE_FIND);

                          /* not okay, the trapoid is not within the notifyview*/
                          if (vp == NULL)
                          {

                             return FALSE;
                          }
                          /*check the exclude case*/
                          else if (vp->viewType == 2)
                          {

                             return FALSE;
                          }
                          /*okay, the trap oid is in the notifyview*/
                          else
                          {

                              return TRUE;
                          }
                      }
                  }
              }

              return FALSE;

         case 2/*SNMP_VERSION_2u*/:
             /* we do not support snmpv2u and snmpv2**/

             return FALSE;
         case 3/*SNMP_VERSION_3*/:

            /* For V3 model, We need to Check if this is a inform or Trap*/
            if(pdu_type == SNMP_MSG_TRAP2)
            {
             /* v3 model, we need to use securityName to check the notify view*/
                memcpy(user_entry.snmpv3_user_name, sess->securityName, sess->securityNameLen);
                user_entry.snmpv3_user_name[sess->securityNameLen]= 0;

                engineIDLen = snmpv3_get_engineID( user_entry.snmpv3_user_engine_id, MAXSIZE_snmpEngineID);
                user_entry.snmpv3_user_engineIDLen=engineIDLen;

             /* v1 and v2 model, we need to use community to check the notify view*/
                if (SNMP_MGR_GetSnmpV3User(&user_entry)== SNMP_MGR_ERROR_OK)
                {
                    /* if security level not matched, return FALSE*/
                    if(user_entry.snmpv3_user_security_level == VAL_vacmAccessSecurityLevel_noAuthNoPriv &&
                       sess->securityLevel >= VAL_vacmAccessSecurityLevel_authNoPriv)
                    {

                        return FALSE;
                    }

                    if (user_entry.snmpv3_user_security_level ==  VAL_vacmAccessSecurityLevel_authNoPriv&&
                        sess->securityLevel > VAL_vacmAccessSecurityLevel_authNoPriv)
                    {

                        return FALSE;
                    }


                    memset(&sec_to_group_entry, 0, sizeof(sec_to_group_entry));
                    sec_to_group_entry.snmpv3_user_security_model = SNMP_MGR_SNMPV3_MODEL_V3;
                    strcpy(sec_to_group_entry.snmpv3_user_name, user_entry.snmpv3_user_name);
                    if (SNMP_MGR_ERROR_OK == SNMP_MGR_GetSecurityToGroupTable(&sec_to_group_entry))
                    {

                        /* if securityLevel = noauth, we should search for noauth, auth and priv
                           if securityLevel = auth, we should search for auth, priv.
                           if securiytLevel = priv, we should search for priv.
                         */
                        if (sess->securityLevel== VAL_vacmAccessSecurityLevel_noAuthNoPriv)
                        {
                            ap = vacm_getExactAccessEntry(sec_to_group_entry.snmpv3_user_group_name, "", SNMP_MGR_SNMPV3_MODEL_V3,VAL_vacmAccessSecurityLevel_noAuthNoPriv );
                            if (ap)
                            {
                                vp = vacm_getViewEntry(ap->notifyView, trap_oid, trap_oid_len,VACM_MODE_FIND);
                                if ((vp) && (vp->viewType == 1))
                                {


                                    return TRUE;
                                }
                            }
                            /* try second time with authNoPriv*/
                            ap = vacm_getExactAccessEntry(sec_to_group_entry.snmpv3_user_group_name, "", SNMP_MGR_SNMPV3_MODEL_V3,VAL_vacmAccessSecurityLevel_authNoPriv );
                            if (ap)
                            {
                                vp = vacm_getViewEntry(ap->notifyView, trap_oid, trap_oid_len,VACM_MODE_FIND);
                                if ((vp) && (vp->viewType == 1))
                                {


                                    return TRUE;
                                }
                            }
                            /* try third time with authPriv*/
                            ap = vacm_getExactAccessEntry(sec_to_group_entry.snmpv3_user_group_name, "", SNMP_MGR_SNMPV3_MODEL_V3,VAL_vacmAccessSecurityLevel_authPriv );
                            if (ap)
                            {
                                vp = vacm_getViewEntry(ap->notifyView, trap_oid, trap_oid_len,VACM_MODE_FIND);
                                /* not okay, the trapoid is not within the notifyview*/
                                if ((vp) && (vp->viewType == 1))
                                {


                                    return TRUE;
                                }
                            }
                            /* I have try all three, fail*/


                            return FALSE;
                        } /* end of if (sess->securityLevel== VAL_vacmAccessSecurityLevel_noAuthNoPriv)*/
                        else if (sess->securityLevel== VAL_vacmAccessSecurityLevel_authNoPriv)
                        {
                            /* try first time with authNoPriv*/
                            ap = vacm_getExactAccessEntry(sec_to_group_entry.snmpv3_user_group_name, "", SNMP_MGR_SNMPV3_MODEL_V3,VAL_vacmAccessSecurityLevel_authNoPriv );
                            if (ap)
                            {
                                vp = vacm_getViewEntry(ap->notifyView, trap_oid, trap_oid_len,VACM_MODE_FIND);
                                if ((vp) && (vp->viewType == 1))
                                {


                                    return TRUE;
                                }
                            }
                            /* try second time with authPriv*/
                            ap = vacm_getExactAccessEntry(sec_to_group_entry.snmpv3_user_group_name, "", SNMP_MGR_SNMPV3_MODEL_V3,VAL_vacmAccessSecurityLevel_authPriv );
                            if (ap)
                            {
                                vp = vacm_getViewEntry(ap->notifyView, trap_oid, trap_oid_len,VACM_MODE_FIND);
                                /* not okay, the trapoid is not within the notifyview*/
                                if ((vp) && (vp->viewType == 1))
                                {


                                    return TRUE;
                                }
                            }
                            /* I have try all, fail*/


                            return FALSE;
                        } /* end of if (sess->securityLevel== SNMP_MGR_SNMPV3_SECURITY_LEVEL_AUTHNOAUTH)*/
                        else if (sess->securityLevel== VAL_vacmAccessSecurityLevel_authPriv)
                        {
                            /* try first time with authPriv*/
                            ap = vacm_getExactAccessEntry(sec_to_group_entry.snmpv3_user_group_name, "", SNMP_MGR_SNMPV3_MODEL_V3,VAL_vacmAccessSecurityLevel_authPriv );
                            if (ap)
                            {
                                vp = vacm_getViewEntry(ap->notifyView, trap_oid, trap_oid_len,VACM_MODE_FIND);
                                /* not okay, the trapoid is not within the notifyview*/
                                if ((vp) && (vp->viewType == 1))
                                {


                                    return TRUE;
                                }
                            }
                            /* I have try all three, fail*/


                            return FALSE;
                        } /* end of if (sess->securityLevel== VAL_vacmAccessSecurityLevel_authPriv)*/

                    } /* end of if (SNMP_MGR_ERROR_OK == SNMP_MGR_GetSecurityToGroupTable(&sec_to_group_entry))*/

                } /* end of if (SNMP_MGR_GetSnmpV3User(&user_entry)== SNMP_MGR_ERROR_OK)*/

                return FALSE;
            }
            else if (pdu_type == SNMP_MSG_INFORM)
            {
                /* if it is inform request, we don't need to check any*/

                return TRUE;
            }
         break;
         default:

             return FALSE;
         }

          /* Process 2 End */

         return FALSE;
}

/*---------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_IsAutoDestroyUser
 *---------------------------------------------------------------------------
 * PURPOSE : The function returns if it needs to be destroyed automatically.
 * INPUT   : username_p -- User name.
 * OUTPUT  : None.
 * RETURN  : TRUE/FALSE
 * NOTE    : None.
 *---------------------------------------------------------------------------
 */
static BOOL_T SNMP_MGR_IsAutoDestroyUser(char *username_p)
{
    struct usmUser *user_p = NULL;
    UI8_T engine_id[MAXSIZE_snmpEngineID];
    UI32_T engine_id_len;
    UI32_T orig_priority;

    if (username_p == NULL)
    {
        return FALSE;
    }


    engine_id_len = snmpv3_get_engineID(engine_id, sizeof(engine_id));
    user_p = usm_get_user(engine_id, engine_id_len, username_p);


    if (user_p == NULL)
    {
        return FALSE;
    }

    return user_p->is_auto_destroy;
}

/*---------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_IsAutoDestroySecurityToGroup
 *---------------------------------------------------------------------------
 * PURPOSE : The function returns if it needs to be destroyed automatically.
 * INPUT   : security_model     -- Security model
 *           security_name_p    -- Security name.
 * OUTPUT  : None.
 * RETURN  : TRUE/FALSE
 * NOTE    : None.
 *---------------------------------------------------------------------------
 */
static BOOL_T SNMP_MGR_IsAutoDestroySecurityToGroup(SNMP_MGR_Snmpv3_Model_T security_model, char *security_name_p)
{
    struct vacm_groupEntry *group_p = NULL;
    UI32_T orig_priority;

    if (security_name_p == NULL)
    {
        return FALSE;
    }


    group_p = vacm_getGroupEntry(security_model, security_name_p);


    if (group_p == NULL)
    {
        return FALSE;
    }

    return group_p->is_auto_destroy;
}

/*---------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_IsAutoDestroyAccess
 *---------------------------------------------------------------------------
 * PURPOSE : The function returns if it needs to be destroyed automatically.
 * INPUT   : group_name_p       -- Group name
 *           security_model     -- Security model
 *           security_level     -- Security level
 * OUTPUT  : None.
 * RETURN  : TRUE/FALSE
 * NOTE    : None.
 *---------------------------------------------------------------------------
 */
static BOOL_T SNMP_MGR_IsAutoDestroyAccess(char *group_name_p, SNMP_MGR_Snmpv3_Model_T security_model, UI32_T security_level)
{
    struct vacm_accessEntry *access_p = NULL;
    UI32_T orig_priority;

    if (group_name_p == NULL)
    {
        return FALSE;
    }

    access_p = vacm_getExactAccessEntry(group_name_p, "", security_model, security_level);

    if (access_p == NULL)
    {
        return FALSE;
    }

    return access_p->is_auto_destroy;
}

/*---------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_IsCommunitySharedByTrapReceiver
 *---------------------------------------------------------------------------
 * PURPOSE : The function will check the community is shared by any trap
 *           receiver or not.
 * INPUT   : community_p        -- Community name.
 *           version            -- Version number.
 *           skip_ip_address    -- IP address.
 * OUTPUT  : None.
 * RETURN  : TRUE/FALSE
 * NOTE    : 1. If skip_ip_address is zero, it will check all trap receivers.
 *              Or, it will skip the trap receiver whose IP address is same as
 *              this IP address.
 *           2. Version is SNMP_MGR_SNMPV3_MODEL_ANY means not to compare with
 *              version number of trap receiver.
 *---------------------------------------------------------------------------
 */
static BOOL_T SNMP_MGR_IsCommunitySharedByTrapReceiver(char *community_p, SNMP_MGR_Snmpv3_Model_T version, L_INET_AddrIp_T *skip_ip_address)
{
    SNMP_MGR_TrapDestEntry_T entry;

    if (community_p == NULL)
    {
        return FALSE;
    }

    memset(&entry, 0, sizeof(entry));

    while (SNMP_MGR_GetNextTrapReceiver(&entry) == SNMP_MGR_ERROR_OK)
    {
        if (0 == strcmp(entry.trap_dest_community, community_p))
        {
            if (   (SNMP_MGR_SNMPV3_MODEL_ANY != version)
                && (entry.trap_dest_version != version)
                )
            {
                continue;
            }

            if (skip_ip_address->addrlen == 0)
            {
                return TRUE;
            }
            else if (0 != L_INET_CompareInetAddr((L_INET_Addr_T *)&entry.trap_dest_address,
                (L_INET_Addr_T *) skip_ip_address, 0))
            {
                return TRUE;
            }
        }
    }

    return FALSE;
}

/*---------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_ConvertTAddressToLinetAddr
 *---------------------------------------------------------------------------
 * PURPOSE : The function will covert from TAddress info to L_Inet Address
 *
 * INPUT   : tAddr         -- netsnmp TAddress array.
 *           addr_len    -- TAddress inforamtion length.
 *
 * OUTPUT  : ip_addr    -- converted L_Inet Address informaton.
 * RETURN  : TRUE/FALSE
 * NOTE    : If TAddress is null, it will return false.
 *---------------------------------------------------------------------------
 */
static BOOL_T SNMP_MGR_ConvertTAddressToLinetAddr(char *tAddr, L_INET_AddrIp_T *ip_addr, UI16_T addr_len)
{
    if (tAddr == NULL)
    {
        return FALSE;
    }

#if(SYS_CPNT_IPV6 == TRUE)
    if (SNMP_MGR_TADDR_IPV6LINKLOCAL_LEN == addr_len)
    {
        memcpy(&ip_addr->addr, tAddr, (addr_len- SNMP_MGR_TADDR_IPV6LINKLOCAL_SHIFT));
        ip_addr->addrlen = addr_len - 6;
        memcpy(&ip_addr->zoneid, (tAddr + SYS_TYPE_IPV6_ADDR_LEN),
               sizeof(ip_addr->zoneid));
        ip_addr->type = VAL_InetAddressType_ipv6z;
        return TRUE;
    }
    else if (SNMP_MGR_TADDR_IPV6_LEN == addr_len)
    {
        memcpy( &ip_addr->addr, tAddr, (addr_len - SNMP_MGR_TADDR_PORT_LEN));
        ip_addr->addrlen = addr_len - SNMP_MGR_TADDR_PORT_LEN;
        ip_addr->type    = VAL_InetAddressType_ipv6;
        return TRUE;
    }
    else if (SNMP_MGR_TADDR_IPV4_LEN == addr_len)
#else
    if (SNMP_MGR_TADDR_IPV4_LEN == addr_len)
#endif  /* #if (SYS_CPNT_IPV6 == TRUE)*/
    {
        memcpy( &ip_addr->addr, tAddr, (addr_len - SNMP_MGR_TADDR_PORT_LEN));
        ip_addr->addrlen = addr_len - SNMP_MGR_TADDR_PORT_LEN;
        ip_addr->type    = VAL_InetAddressType_ipv4;
        return TRUE;
    }

   return FALSE;
}


/*---------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_GetIpandPortfromTaddress
 *---------------------------------------------------------------------------
 * PURPOSE : SNMP_MGR_GetIpandPortfromTaddress
 *
 * INPUT   : target_addr_entry -- SNMP_MGR_SnmpTargetAddrEntry_T entry.
 *
 * OUTPUT  : *ipaddr           -- L_INET_AddrIp_T ip address.
 *         : *udp_port_p       -- udp port
 *
 * RETURN  : TRUE/FALSE
 *
 * NOTE    : If ipaddr / udp_port_p is null, it will return false.
 *---------------------------------------------------------------------------
 */
static BOOL_T SNMP_MGR_GetIpandPortfromTaddress(SNMP_MGR_SnmpTargetAddrEntry_T target_addr_entry,
        L_INET_AddrIp_T  *ipaddr,
        UI16_T *udp_port_p)
{
    UI32_T orig_priority;



    if ((ipaddr == NULL) ||
        (udp_port_p == NULL))
    {

        return FALSE;
    }

    if (SNMP_MGR_ConvertTAddressToLinetAddr(target_addr_entry.taddr.snmp_target_addr_taddress,
            ipaddr, target_addr_entry.snmp_target_addr_len) == FALSE)
    {

        return FALSE;
    }

    switch (ipaddr->type)
    {
        case VAL_InetAddressType_ipv4:
                *udp_port_p = L_STDLIB_Ntoh16(target_addr_entry.taddr.ipv4_taddr.udp_port);
                break;
        case VAL_InetAddressType_ipv6:
                *udp_port_p = L_STDLIB_Ntoh16(target_addr_entry.taddr.ipv6_taddr.udp_port);
                break;
        case VAL_InetAddressType_ipv6z:
                *udp_port_p = L_STDLIB_Ntoh16(target_addr_entry.taddr.ipv6z_taddr.udp_port);
                break;
    }


    return TRUE;
}

/*---------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_SetIpandPort2Taddress
 *---------------------------------------------------------------------------
 * PURPOSE : SNMP_MGR_SetIpandPort2Taddress
 *
 * INPUT   : ipaddr           -- L_INET_AddrIp_T ip address.
 *         : udp_port_p       -- udp port
 *
 * OUTPUT  : target_addr_entry -- SNMP_MGR_SnmpTargetAddrEntry_T entry.
 *
 * RETURN  : TRUE/FALSE
 *
 * NOTE    : If target_addr_entry is null, it will return false.
 *---------------------------------------------------------------------------
 */
static BOOL_T SNMP_MGR_SetIpandPort2Taddress(L_INET_AddrIp_T  ip_addr,
    UI16_T port,
    SNMP_MGR_SnmpTargetAddrEntry_T *target_addr_entry)
{
    UI32_T orig_priority;



    if (NULL == target_addr_entry)
    {

        return FALSE;
    }

    switch(ip_addr.type)
    {
        case VAL_InetAddressType_ipv4:
                memcpy(&target_addr_entry->taddr.ipv4_taddr.ipaddress,
                    ip_addr.addr,
                    ip_addr.addrlen);
                target_addr_entry->taddr.ipv4_taddr.udp_port = L_STDLIB_Ntoh16(port);
                target_addr_entry->snmp_target_addr_len = sizeof(target_addr_entry->taddr.ipv4_taddr);
                break;
        case VAL_InetAddressType_ipv6:
                memcpy(&target_addr_entry->taddr.ipv6_taddr.ipaddress,
                    ip_addr.addr,
                    ip_addr.addrlen);
                target_addr_entry->taddr.ipv6_taddr.udp_port = L_STDLIB_Ntoh16(port);
                target_addr_entry->snmp_target_addr_len = sizeof(target_addr_entry->taddr.ipv6_taddr);
                break;
        case VAL_InetAddressType_ipv6z:
                memcpy(&target_addr_entry->taddr.ipv6z_taddr.ipaddress,
                    ip_addr.addr,
                    ip_addr.addrlen);
                memcpy(&target_addr_entry->taddr.ipv6z_taddr.scope_id,
                    &ip_addr.zoneid,
                    sizeof(target_addr_entry->taddr.ipv6z_taddr.scope_id));
                target_addr_entry->taddr.ipv6z_taddr.udp_port = L_STDLIB_Ntoh16(port);
                target_addr_entry->snmp_target_addr_len = sizeof(target_addr_entry->taddr.ipv6z_taddr);
                break;
    }


    return TRUE;
}

/*---------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_Extend_PrviKey
 *---------------------------------------------------------------------------
 * PURPOSE : The function will extend priv key from short key length
 *           to enough key length for AES 192 and 256
 * INPUT   : authProtocol    -- the authentication protocol, that is MD5 or SHA
 *           authProtocol_len-- the authentication protocol len of  MD5 or SHA
 *           org_privkey_p   -- orginal priv key string.
 *           org_prigkey_len -- orginal priv key length.
 *           extended_len    -- the priv key need be extended length
 * OUTPUT  : new_privkey_p   -- extended priv key string.
 *           new_privkey_len -- extended priv key length.
 * RETURN  : TRUE/FALSE
 * NOTE    : If extned failed , it will return false.
 *---------------------------------------------------------------------------
 */
static BOOL_T
SNMP_MGR_Extend_PrviKey(
    const oid * authProtocol,
    size_t authProtocol_len,
    UI32_T priv_type,
    UI8_T *engine_id_p,
    UI32_T engineid_len,
    UI8_T *org_privkey_p,
    size_t org_privkey_len,
    size_t extended_len,
    UI8_T  *new_privkey_p,
    size_t *new_privkey_len)
{
    int ret_val            = 0;
    size_t  copied_len     = 0;
    size_t  hashed_key_len = org_privkey_len;
    u_char  extendkey[SNMP_MGR_MAX_AES256_KEY_LEN] = {0};
    memcpy(extendkey, org_privkey_p, org_privkey_len);

    while(org_privkey_len < extended_len)
    {
        switch(priv_type)
        {
            case SNMP_MGR_SNMPV3_PRIVTYPE_3DES:
                ret_val = generate_Ku(authProtocol,
                                      authProtocol_len,
                                      extendkey ,
                                      org_privkey_len,
                                      org_privkey_p,
                                      &org_privkey_len);

                ret_val = generate_kul(authProtocol,
                                       authProtocol_len,
                                       engine_id_p,
                                       engineid_len,
                                       org_privkey_p,
                                       org_privkey_len,
                                       org_privkey_p,
                                       &hashed_key_len);

                break;

            case SNMP_MGR_SNMPV3_PRIVTYPE_AES192:
            case SNMP_MGR_SNMPV3_PRIVTYPE_AES256:
        ret_val = sc_hash(authProtocol,
                          authProtocol_len,
                          extendkey,
                          org_privkey_len,
                          org_privkey_p,
                          (unsigned long *)&hashed_key_len);

        if(ret_val == SNMPERR_GENERR)
            return FALSE;

                break;

        }

        copied_len = extended_len - hashed_key_len;

        if(org_privkey_len < extended_len)
        {
            memcpy(extendkey + org_privkey_len, org_privkey_p, copied_len);
            org_privkey_len += copied_len;
        }

    }

    memcpy(new_privkey_p, extendkey, org_privkey_len);
    *new_privkey_len = org_privkey_len;

    return TRUE;
}

/*-------------------------------------------------------------------------
 * FUNCTION NAME - SNMP_MGR_IsValidTrapReceiverIp
 *-------------------------------------------------------------------------
 * PURPOSE  : check receiver IP address is valid or not
 * INPUT    : ip_p -- IP address
 * OUTPUT   : None
 * RETUEN   : TRUE/FALSE
 * NOTES    : Not support L_INET_ADDR_TYPE_IPV4Z
 * ------------------------------------------------------------------------
 */
static BOOL_T
SNMP_MGR_IsValidTrapReceiverIp(
    const L_INET_AddrIp_T *ip_p)
{
    if (NULL == ip_p)
    {
        return FALSE;
    }

    switch (ip_p->type)
    {
        case L_INET_ADDR_TYPE_IPV4:
        {
            UI8_T v4_addr[SYS_ADPT_IPV4_ADDR_LEN] = {0};

            memcpy(v4_addr, ip_p->addr, SYS_ADPT_IPV4_ADDR_LEN);

            if (IP_LIB_OK != IP_LIB_IsValidForRemoteIp(v4_addr))
            {
                return FALSE;
            }
        }
            break;

        case L_INET_ADDR_TYPE_IPV6:
        case L_INET_ADDR_TYPE_IPV6Z:
        {
            UI8_T v6_addr[SYS_ADPT_IPV6_ADDR_LEN] = {0};

            memcpy(v6_addr, ip_p->addr, SYS_ADPT_IPV6_ADDR_LEN);

            /* IPv6 address should not be
             * IP_LIB_INVALID_IPV6_UNSPECIFIED
             * IP_LIB_INVALID_IPV6_LOOPBACK
             * IP_LIB_INVALID_IPV6_MULTICAST
             */
            if (IP_LIB_OK != IP_LIB_CheckIPv6PrefixForInterface(v6_addr, SYS_ADPT_IPV6_ADDR_LEN))
            {
                return FALSE;
            }
        }
            break;

        default:
            return FALSE;
    }

    return TRUE;
} /* End of SNMP_MGR_IsValidTrapReceiverIp */

/*-------------------------------------------------------------------------
 * FUNCTION NAME - SNMP_MGR_LocalGetSecurityName
 *-------------------------------------------------------------------------
 * PURPOSE  : Get security name from snmpCommunityTable or usmUserTable
 * INPUT    : version           -- SNMP version
 *            user_name_p       -- user name
 *            cb_security_name  -- Count of bytes of security name
 * OUTPUT   : security_name_p   -- security name
 * RETUEN   : SNMP_MGR_ERROR_OK/SNMP_MGR_ERROR_FAIL
 * NOTES    : None
 * ------------------------------------------------------------------------
 */
static UI32_T
SNMP_MGR_LocalGetSecurityName(
    SNMP_MGR_Snmpv3_Model_T version,
    char *user_name_p,
    char *security_name_p,
    UI32_T cb_security_name)
{
    struct _com2SecEntry *com2SecPtr;
    struct usmUser *uptr;
    UI32_T engine_id_len;
    UI8_T  engine_id[MAXSIZE_snmpEngineID] = {0};

    if ((NULL == user_name_p) ||
        (NULL == security_name_p))
    {
        return SNMP_MGR_ERROR_FAIL;
    }

    if ((SNMP_MGR_SNMPV3_MODEL_V1 == version) ||
        (SNMP_MGR_SNMPV3_MODEL_V2C == version))
    {
        /* get security name from snmpCommunityTable
         */
        com2SecPtr = netsnmp_udp_getCom2SecEntry(user_name_p);

        if (NULL != com2SecPtr)
        {
            strncpy(security_name_p, com2SecPtr->secName, cb_security_name - 1);
            security_name_p[cb_security_name - 1] = '\0';
            return SNMP_MGR_ERROR_OK;
        }
    }
    else if (SNMP_MGR_SNMPV3_MODEL_V3 == version)
    {
        /* get security name from usmUserTable
         */
        engine_id_len = snmpv3_get_engineID(engine_id, sizeof(engine_id));
        uptr = usm_get_user(engine_id, engine_id_len, user_name_p);

        if (NULL != uptr)
        {
            strncpy(security_name_p, uptr->secName, cb_security_name - 1);
            security_name_p[cb_security_name - 1] = '\0';
            return SNMP_MGR_ERROR_OK;
        }
    }

    return SNMP_MGR_ERROR_FAIL;
}

/*-------------------------------------------------------------------------
 * FUNCTION NAME - SNMP_MGR_LocalAutoCreateUserByVersion
 *-------------------------------------------------------------------------
 * PURPOSE  : Auto create user by version
 * INPUT    : version           -- SNMP version
 *            user_name_p       -- user name
 *            security_name_p   -- security name
 * OUTPUT   : None
 * RETUEN   : SNMP_MGR_ERROR_OK/SNMP_MGR_ERROR_FAIL
 * NOTES    : None
 * ------------------------------------------------------------------------
 */
static UI32_T
SNMP_MGR_LocalAutoCreateUserByVersion(
    SNMP_MGR_Snmpv3_Model_T version,
    char *user_name_p,
    char *security_name_p)
{
    SNMP_MGR_SnmpCommunityEntry_T comm_entry;
    SNMP_MGR_SnmpV3UserEntry_T user_entry;

    if ((NULL == user_name_p) ||
        (NULL == security_name_p))
    {
        return SNMP_MGR_ERROR_FAIL;
    }

    if ((SNMP_MGR_SNMPV3_MODEL_V1 == version) ||
        (SNMP_MGR_SNMPV3_MODEL_V2C == version))
    {
        /* create snmpCommunityTable
         */
        memset(&comm_entry, 0, sizeof(comm_entry));
        strncpy(comm_entry.snmp_community_index, user_name_p,
            sizeof(comm_entry.snmp_community_index) - 1);
        comm_entry.snmp_community_index[sizeof(comm_entry.snmp_community_index) - 1] = '\0';
        strncpy(comm_entry.snmp_community_name, user_name_p,
            sizeof(comm_entry.snmp_community_name) - 1);
        comm_entry.snmp_community_name[sizeof(comm_entry.snmp_community_name) - 1] = '\0';
        strncpy(comm_entry.snmp_community_security_name, security_name_p,
            sizeof(comm_entry.snmp_community_security_name) - 1);
        comm_entry.snmp_community_security_name[sizeof(comm_entry.snmp_community_security_name) - 1] = '\0';
        comm_entry.snmp_community_access_right = SNMP_MGR_ACCESS_RIGHT_GROUP_SPECIFIC;

        if (SNMP_MGR_ERROR_OK != SNMP_MGR_InsertCom2SecList(comm_entry.snmp_community_security_name,
                                                            comm_entry.snmp_community_index,
                                                            SNMP_MGR_ACCESS_RIGHT_GROUP_SPECIFIC))
        {
            return SNMP_MGR_ERROR_FAIL;
        }

        if (SNMP_MGR_ERROR_OK != SNMP_MGR_CreateSnmpCommunityEntry(&comm_entry))
        {
            return SNMP_MGR_ERROR_FAIL;
        }

        if (SNMP_MGR_ERROR_OK == SNMP_MGR_ModifySnmpCommunityStatus((char *)user_name_p,
                                                                    VAL_snmpCommunityStatus_active))
        {
            return SNMP_MGR_ERROR_OK;
        }
    }
    else if (SNMP_MGR_SNMPV3_MODEL_V3 == version)
    {
        /* create usmUserTable
         */
        memset(&user_entry, 0, sizeof(user_entry));
        strncpy(user_entry.snmpv3_user_name, user_name_p, sizeof(user_entry.snmpv3_user_name) - 1);
        user_entry.snmpv3_user_name[sizeof(user_entry.snmpv3_user_name) - 1] = '\0';
        strncpy(user_entry.snmpv3_user_group_name, user_name_p, sizeof(user_entry.snmpv3_user_name) - 1);
        user_entry.snmpv3_user_name[sizeof(user_entry.snmpv3_user_name) - 1] = '\0';
        user_entry.snmpv3_user_auth_password[0] = '\0';
        user_entry.snmpv3_user_priv_password[0] = '\0';
        user_entry.snmpv3_user_security_model = SNMP_MGR_SNMPV3_MODEL_V3;
        user_entry.snmpv3_user_security_level = VAL_vacmAccessSecurityLevel_noAuthNoPriv;
        user_entry.snmpv3_user_auth_type = SNMP_MGR_SNMPV3_AUTHTYPE_NONE;
        user_entry.snmpv3_user_priv_type = SNMP_MGR_SNMPV3_PRIVTYPE_NONE;
        user_entry.password_from_config = FALSE;
        user_entry.snmpv3_user_storage_type = VAL_usmUserStorageType_volatile;

        if (SNMP_MGR_ERROR_OK == SNMP_MGR_CreateSnmpV3User(&user_entry, TRUE))
        {
            return SNMP_MGR_ERROR_OK;
        }
    }

    return SNMP_MGR_ERROR_FAIL;
}

/*-------------------------------------------------------------------------
 * FUNCTION NAME - SNMP_MGR_LocalIsAutoDestroyCommunity
 *-------------------------------------------------------------------------
 * PURPOSE  : Check the community need to be destroyed automatically or not
 * INPUT    : community_name_p  -- community name
 * OUTPUT   : None
 * RETUEN   : TRUE/FALSE
 * NOTES    : None
 * ------------------------------------------------------------------------
 */
static UI32_T
SNMP_MGR_LocalIsAutoDestroyCommunity(
    char *community_name_p)
{
    SNMP_MGR_SnmpCommunityEntry_T community_entry;

    if (NULL == community_name_p)
    {
        return FALSE;
    }

    memset(&community_entry, 0, sizeof(community_entry));
    strncpy(community_entry.snmp_community_index, community_name_p, sizeof(community_entry.snmp_community_index));
    community_entry.snmp_community_index[sizeof(community_entry.snmp_community_index) - 1] = '\0';

    if (SNMP_MGR_ERROR_OK != SNMP_MGR_GetSnmpCommunityEntry(&community_entry))
    {
        return FALSE;
    }

    return ((SNMP_MGR_ACCESS_RIGHT_GROUP_SPECIFIC == community_entry.snmp_community_access_right) ? TRUE:FALSE);
}

/*-------------------------------------------------------------------------
 * FUNCTION NAME - SNMP_MGR_LocalIsAutoDestroyUserByVersion
 *-------------------------------------------------------------------------
 * PURPOSE  : Check the user need to be destroyed automatically or not by version
 * INPUT    : version           -- SNMP version
 *            user_name_p       -- user name
 * OUTPUT   : None
 * RETUEN   : TRUE/FALSE
 * NOTES    : None
 * ------------------------------------------------------------------------
 */
static UI32_T
SNMP_MGR_LocalIsAutoDestroyUserByVersion(
    SNMP_MGR_Snmpv3_Model_T version,
    char *user_name_p)
{
    if (NULL == user_name_p)
    {
        return FALSE;
    }

    if ((SNMP_MGR_SNMPV3_MODEL_V1 == version) ||
        (SNMP_MGR_SNMPV3_MODEL_V2C == version))
    {
        return SNMP_MGR_LocalIsAutoDestroyCommunity(user_name_p);
    }
    else if (SNMP_MGR_SNMPV3_MODEL_V3 == version)
    {
        return SNMP_MGR_IsAutoDestroyUser(user_name_p);
    }

    return FALSE;
}

/*---------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_LocalIsUserSharedByTrapReceiver
 *---------------------------------------------------------------------------
 * PURPOSE : The function will check the user is shared by any trap
 *           receiver or not.
 * INPUT   : user_name_p        -- user name
 *           skip_ip_p          -- skip IP address
 * OUTPUT  : None.
 * RETURN  : TRUE/FALSE
 * NOTE    : If skip_ip_address is zero, it will check all trap receivers.
 *           Or, it will skip the trap receiver whose IP address is same as this
 *           IP address.
 *---------------------------------------------------------------------------
 */
static BOOL_T
SNMP_MGR_LocalIsUserSharedByTrapReceiver(
    char *user_name_p,
    L_INET_AddrIp_T *skip_ip_p)
{
    SNMP_MGR_TrapDestEntry_T entry;

    if ((NULL == user_name_p) ||
        (NULL == skip_ip_p))
    {
        return FALSE;
    }

    memset(&entry, 0, sizeof(entry));

    while (SNMP_MGR_ERROR_OK == SNMP_MGR_GetNextTrapReceiver(&entry))
    {
        if ((skip_ip_p->addrlen != 0) &&
            (0 == L_INET_CompareInetAddr((L_INET_Addr_T *)&entry.trap_dest_address, (L_INET_Addr_T *)skip_ip_p, 0)))
        {
            continue;
        }

        if (0 != strcmp(entry.trap_dest_community, user_name_p))
        {
            continue;
        }

        if ((SNMP_MGR_SNMPV3_MODEL_V3 == entry.trap_dest_version) &&
            (VAL_snmpNotifyType_trap == entry.trap_dest_type) &&
            (VAL_snmpTargetParamsSecurityLevel_noAuthNoPriv == entry.trap_dest_security_level))
        {
            return TRUE;
        }
    }

    return FALSE;
}

/*---------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_LocalIsSecurityToGroupSharedByTrapReceiver
 *---------------------------------------------------------------------------
 * PURPOSE : The function will check the vacmSecurityToGroupTable is shared by any trap
 *           receiver or not.
 * INPUT   : version            -- SNMP version
 *           security_name_p    -- security name
 *           skip_ip_p          -- skip IP address
 * OUTPUT  : None.
 * RETURN  : TRUE/FALSE
 * NOTE    : If skip_ip_address is zero, it will check all trap receivers.
 *           Or, it will skip the trap receiver whose IP address is same as this
 *           IP address.
 *           The function not check version 3, cause which security name is same
 *           as user name, it should use SNMP_MGR_LocalIsUserSharedByTrapReceiver
 *           to check.
 *---------------------------------------------------------------------------
 */
static BOOL_T
SNMP_MGR_LocalIsSecurityToGroupSharedByTrapReceiver(
    SNMP_MGR_Snmpv3_Model_T version,
    char *security_name_p,
    L_INET_AddrIp_T *skip_ip_p)
{
    SNMP_MGR_TrapDestEntry_T entry;
    struct vacm_groupEntry *geptr = NULL;
    char security_name[SNMP_MGR_MAX_SECURITY_NAME_LEN + 1] = {0};

    if ((NULL == security_name_p) ||
        (NULL == skip_ip_p))
    {
        return FALSE;
    }

    memset(&entry, 0, sizeof(entry));

    while (SNMP_MGR_ERROR_OK == SNMP_MGR_GetNextTrapReceiver(&entry))
    {
        if ((skip_ip_p->addrlen != 0) &&
            (0 == L_INET_CompareInetAddr((L_INET_Addr_T *)&entry.trap_dest_address, (L_INET_Addr_T *)skip_ip_p, 0)))
        {
            continue;
        }

        if (entry.trap_dest_version != version)
        {
            continue;
        }

        if (SNMP_MGR_ERROR_OK == SNMP_MGR_LocalGetSecurityName(entry.trap_dest_version,
                                                               entry.trap_dest_community,
                                                               security_name,
                                                               sizeof(security_name)))
        {
            geptr = vacm_getGroupEntry(entry.trap_dest_version, security_name);

            if (NULL != geptr)
            {
                if (0 == strcmp(security_name, security_name_p))
                {
                    return TRUE;
                }
            }
        }
    }

    return FALSE;
}

/*---------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_LocalIsAccessSharedByTrapReceiver
 *---------------------------------------------------------------------------
 * PURPOSE : The function will check the access is shared by any trap
 *           receiver or not.
 * INPUT   : version            -- SNMP version
 *           access_name_p      -- Access name
 *           skip_ip_p          -- skip IP address
 * OUTPUT  : None.
 * RETURN  : TRUE/FALSE
 * NOTE    : If skip_ip_address is zero, it will check all trap receivers.
 *           Or, it will skip the trap receiver whose IP address is same as this
 *           IP address.
 *---------------------------------------------------------------------------
 */
static BOOL_T
SNMP_MGR_LocalIsAccessSharedByTrapReceiver(
    SNMP_MGR_Snmpv3_Model_T version, char *access_name_p,
    L_INET_AddrIp_T *skip_ip_p)
{
    SNMP_MGR_TrapDestEntry_T entry;
    struct vacm_accessEntry *access_p = NULL;

    if ((NULL == access_name_p) ||
        (NULL == skip_ip_p))
    {
        return FALSE;
    }

    memset(&entry, 0, sizeof(entry));

    while (SNMP_MGR_ERROR_OK == SNMP_MGR_GetNextTrapReceiver(&entry))
    {
        if ((skip_ip_p->addrlen != 0) &&
            (0 == L_INET_CompareInetAddr((L_INET_Addr_T *)&entry.trap_dest_address, (L_INET_Addr_T *)skip_ip_p, 0)))
        {
            continue;
        }

        if (entry.trap_dest_version != version)
        {
            continue;
        }

        if (SNMP_MGR_SNMPV3_MODEL_V3 == version)
        {
            if ((VAL_snmpNotifyType_trap != entry.trap_dest_type) ||
                (VAL_snmpTargetParamsSecurityLevel_noAuthNoPriv != entry.trap_dest_security_level))
            {
                continue;
            }
        }

        access_p = vacm_getExactAccessEntry(access_name_p, "", entry.trap_dest_version, entry.trap_dest_security_level);

        if (NULL != access_p)
        {
            return TRUE;
        }
    }

    return FALSE;
}

/*---------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_LocalIsAccessSharedByCommunity
 *---------------------------------------------------------------------------
 * PURPOSE : The function will check the access is shared by any community
 *           receiver or not.
 * INPUT   : version        -- Version
 *           security_level -- Security level
 *           access_name_p  -- Access name
 * OUTPUT  : None.
 * RETURN  : TRUE/FALSE
 * NOTE    : None.
 *---------------------------------------------------------------------------
 */
static BOOL_T
SNMP_MGR_LocalIsAccessSharedByCommunity(
    SNMP_MGR_Snmpv3_Model_T version,
    UI32_T security_level,
    char *access_name_p)
{
    struct vacm_accessEntry *access_p = NULL;
    struct _com2SecEntry *com2sec_p;

    if (NULL == access_name_p)
    {
        return FALSE;
    }

    access_p = vacm_getExactAccessEntry(access_name_p, "", version, security_level);

    if (NULL == access_p)
    {
        return FALSE;
    }

    return (   ('\0' != access_p->readView[0])
            || ('\0' != access_p->writeView[0])
            );
}

#define SNMP_MGR_isdigit(c) ((c) >= '0' && (c) <= '9')

/* PURPOSE: Get a string from a line
 * INPUT:   s:     Starting address to search
 * OUTPUT:  Token: Buffer of the found token
 * RETURN:  The address that follow the got string, if 0 => no next string
 * NOTE:
 */
char *SNMP_MGR_GetToken (char *s, char *Token, char delemiters[])
{

   int  state = 0;

   for( ; *s !=0 || *s == 0x0a || *s == 0x0d ; s++)
   {
      switch ( state )
      {
         case 0:   /* skip while space */
         if ( SNMP_MGR_IsMeetDelemiter(*s, delemiters) )
         {
            continue;
         }
         else
         {
            state = 1;
            *Token++ = *s;
            break;
         }

         case 1:   /* character occures */
         if ( SNMP_MGR_IsMeetDelemiter(*s, delemiters) )
         {
            char *s_op = s + 1;
            *Token = '\0';

            for(; ; s_op++) /* search if non-space exists */
            {
               if( *s_op == '\0' || *s_op == 0x0a || *s_op == 0x0d )
                  return 0;
               else if (!SNMP_MGR_IsMeetDelemiter(*s_op, delemiters))
                  break;
            }
            return s;
         }
         else
         {
            *Token++ = *s;
            break;
         }
      }
   }
   return 0; /* if (*s == 0) occures */
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - SNMP_MGR_CheckNullStr
 *------------------------------------------------------------------------------
 * PURPOSE:  Check if input is a null str.
 * INPUT:    buff
 * OUTPUT:   None.
 * RETURN:   1               -- buff is a null string.
 *           0               -- buff is not a null string.
 * NOTE:     None.
 *------------------------------------------------------------------------------
 */
UI16_T SNMP_MGR_CheckNullStr(char *buff)
{
    while ((*buff == ' ') || (*buff == 0x09))
    {
        buff++;
    }

    if (*buff == '\0')
    {
        return 1; /* null string */
    }
    else
    {
        return 0; /* not null string */
    }
}

/* assume the format is correct
 */
BOOL_T SNMP_MGR_GetLowerUpperValue(char *buff, UI32_T *lower_val, UI32_T *upper_val, UI32_T *err_idx)
{
#define SNMP_MGR_WAIT_FOR_VALUE     65535
   UI32_T i;
   UI32_T case_val = 0;

   for(i=0; buff[i]!= 0; i++)
   {
      switch(case_val)
      {
      case 0:                  /* find lower value */
         if(SNMP_MGR_isdigit(buff[i]))
         {
            *lower_val = atoi(buff+i);
            *upper_val = atoi(buff+i);
            case_val = 1;

            for(;;i++)
            {
               if(!SNMP_MGR_isdigit(buff[i]))
               {
                  i--;
                  break;
               }
            }
         }
         else /*not digit*/
         {
            *err_idx = i;
            return FALSE;
         }
         break;


      case 1:                  /* find dash */
         if(buff[i] == '-')
         {
            case_val = 2;
            *upper_val = SNMP_MGR_WAIT_FOR_VALUE;
         }
         else
         {
            *err_idx = i; /*not dash*/
            return FALSE;
         }
         break;


      case 2:                /* find upper value */
         if(SNMP_MGR_isdigit(buff[i]))
         {
            *upper_val = atoi(buff+i);
            case_val = 3;

            for(;;i++)
            {
               if(!SNMP_MGR_isdigit(buff[i]))
               {
                  i--;
                  break;
               }
            }
         }
         else /*not digit*/
         {
            *err_idx = i;
            return FALSE;
         }
         break;

      case 3:                /* any thing else? */
         *err_idx = i;
         return FALSE;
      }
   }

   if(*upper_val == SNMP_MGR_WAIT_FOR_VALUE)
      return FALSE;
   else
   {
      if (*upper_val < *lower_val)
         return FALSE;
      else
         return TRUE;
   }
}


// TODO: Use std C library instead. -- strchr()
//       Also need to check the caller, why need this function ?
BOOL_T SNMP_MGR_IsMeetDelemiter(char c, char delemiters[])
{
   UI32_T i = 0;

   for(; delemiters[i] != 0; i ++)
   {
      if(c == delemiters[i])
         return TRUE;
   }

   return FALSE;
}


/*------------------------------------------------------------------------------
 * Function : SNMP_MGR_BitmapToString
 *------------------------------------------------------------------------------
 * Purpose: Covert bitmap format to string
 * INPUT  : bitmap      --  input bitmap
 *          bitmap_size --  bitmap size
 *          str_size    --  string buffer size
 * OUTPUT : string      --  converted string
 * RETURN : None
 * NOTES  : Covert "2-4,6,8" string form bitmap 01110101
 *------------------------------------------------------------------------------
 */
void SNMP_MGR_BitmapToString(UI8_T *bitmap, UI32_T bitmap_size, char *string, UI32_T str_size)
{
#define IS_BIT_ON(bitmap, idx) ((bitmap)[(((idx)-1)/8)] & (1 << (7 - (((idx)-1)%8))))

    UI32_T  idx = 1;
    UI32_T  last_idx = 0;
    UI32_T  count = 0;
    UI32_T  buffer_size = str_size;
    BOOL_T is_first = TRUE;

    if(NULL == bitmap || NULL == string || ((ULONG_MAX - 1)/8 < bitmap_size))
    {
        return;
    }

    while (((idx - 1) / 8) < bitmap_size)
    {
        int str_len = 0;

        str_len = strlen(string);
        buffer_size = str_size - str_len;

        if (IS_BIT_ON(bitmap, idx))
        {
            if (count == 0)
            {
                last_idx = idx;
                /* print ','
                 */
                if (!is_first)
                {
                    snprintf(string+str_len, buffer_size, ",");
                }
            }

            is_first = FALSE;
            count ++;
        }
        else
        {
            if (count == 1)
            {
                /* single bit
                 */
                snprintf(string+str_len, buffer_size, "%lu",(unsigned long)last_idx);
                count = 0;
            }
            else if (count > 1)
            {
                /* continous bits
                 */
                snprintf(string+str_len, buffer_size, "%lu-%lu", (unsigned long)last_idx, (unsigned long)(idx - 1));
                count = 0;
            }
       }

       idx++;
    }

#undef IS_BIT_ON
}

/*------------------------------------------------------------------------------
 * Function : SNMP_MGR_StringToBitmap
 *------------------------------------------------------------------------------
 * Purpose: Covert string format to bitmap
 * INPUT  : string      --  input string
 *          bitmap_size --  output bitmap size
 * OUTPUT : bitmap      --  converted bitmap
 * RETURN : None
 * NOTES  : Covert "1,3-4,5,6" string form to bitmap
 *------------------------------------------------------------------------------
 */
BOOL_T SNMP_MGR_StringToBitmap(char *string, UI8_T *bitmap, UI32_T bitmap_size)
{
#define SNMP_MGR_TOKEN_MAX_SIZE     128

    char  delemiters[2] = { 0 };
    char   *value_p;
    char   token[SNMP_MGR_TOKEN_MAX_SIZE + 1] = {0};
    UI32_T lower_val = 0, upper_val = 0;
    UI32_T err_idx=0;
    UI32_T i;

    if(NULL == string || NULL == bitmap)
    {
        return FALSE;
    }

    value_p = string;

    delemiters[0] = ',';

    while (1)
    {
        value_p =  SNMP_MGR_GetToken(value_p, token, delemiters);

        if (SNMP_MGR_CheckNullStr(token))
        {
            if (value_p == 0)
            {
                break;
            }
            else
            {
                continue;
            }
        }
        else
        {
            if (SNMP_MGR_GetLowerUpperValue(token, &lower_val, &upper_val, &err_idx) != TRUE)
            {
                return FALSE;
            }

            if (lower_val < 1)
            {
                return FALSE;
            }

            if (((upper_val - 1) / 8) >= bitmap_size)
            {
                return FALSE;
            }

            for (i = lower_val; i <= upper_val; i++)
            {
                bitmap[((i - 1) / 8)] |= (1 << (7 - ((i - 1) % 8)));
            }
        }

        if(value_p == 0)
        {
            break;
        }
        else
        {
            memset(token, 0, sizeof(token));
        }
    }
    return TRUE;
}
