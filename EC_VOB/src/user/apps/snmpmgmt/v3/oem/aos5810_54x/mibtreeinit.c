/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.scalar.conf,v 1.5 2002/07/18 14:18:52 dts12 Exp $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

#include "sys_adpt.h"
#include "sysORTable.h"
#include "sys_cpnt.h"
#include "es3626a_superset.h"
#include "mib_arp.h"/*Lin.Li, for support ARP SNMP*/
#include "leaf_sys.h"
#include "sys_mgr.h"
#include "mib_rip.h"
#include "mib_ospf.h"
#include "mib_pfc.h"
#include "mib_ets.h"
#include "acl_v2.h"
#if (SYS_CPNT_SYNCE == TRUE)
#include "mib_synce.h"
#endif
#if (SYS_CPNT_ECMP_BALANCE_MODE == TRUE)
#include "mib_ecmp.h"
#endif

/* XXX steven.jiang for warnings */
void init_prioIfClassificationModeTable(void);
void init_prioCosToDscpTable(void);
void init_prioPrecToDscpTable(void);
void init_prioDscpToDscpTable(void);
void init_prioDstPortToDscpTable(void);
void init_prioDscpToCosTable(void);
void init_prioPrioToDropPrecTable(void);
void init_prioDscpToQueueTable(void);
void init_prioDefaultPrioTable(void);
void init_dhcpSnoopBindingsTableCtlAction(void);

static void init_PrivateMibSysOrTable(void);
static BOOL_T init_PrivateMIBNodeRootOIDbySwitchBoardID(oid *node_oid);
static BOOL_T init_BoardIDStringToMIBRootOID(UI32_T *out_board_id, oid *private_mib_root_oid, UI32_T *private_mib_root_oid_length);

/* init the private MIB object*/
void
init_PrivateMib(void)
{
    /* 60 Private MIB*/
#if (SYS_CPNT_RESMIB == TRUE)
    init_sysResourceCpuTable();
    init_sysResourceTable();
#endif
#if (SYS_CPNT_ECCMIB == TRUE)
    init_etsysConfigurationChangeMIB();
#endif
    init_PrivateMibSysOrTable();
    init_switchMgt();
    init_switchInfoTable();
    init_switchIndivPowerTable();
#if (SYS_CPNT_ALARM_INPUT_DETECT == TRUE)
    init_switchAlarmInputTable();
#endif
#if (SYS_CPNT_STKTPLG_FAN_DETECT == TRUE)
    init_switchFanTable();
#endif
#if (SYS_CPNT_THERMAL_DETECT == TRUE)
    init_switchThermalTempTable();
    init_switchThermalActionTable();
#endif

#if (SYS_CPNT_MODULE_WITH_CPU == TRUE)
    init_switchModuleInfoTable();
#endif
    init_portTable();

#if (SYS_CPNT_SWCTRL_CABLE_DIAG == TRUE)
    init_cableDiagCtlAction();
    init_cableDiagResultTable();
#endif /* #if (SYS_CPNT_SWCTRL_CABLE_DIAG == TRUE) */

    init_portUtilTable();
    init_portMediaInfoTable();
    init_portOpticalMonitoringInfoTable();
    init_portTransceiverThresholdInfoTable();

#if (SYS_CPNT_NMTR_HISTORY == TRUE)
    init_portHistControlTable();
    init_portHistCurrentTable();
    init_portHistPreviousTable();
#endif

    init_trunkMgt();
    init_trunkTable();
#if (SYS_CPNT_LACP == TRUE)
    init_lacpPortTable();
#endif
    init_staMgt();
    init_staPortTable();
#if (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_RSTP) || (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_MSTP)
    init_xstMgt();
    init_xstInstanceCfgTable();
    init_xstInstancePortTable();
    init_mstInstanceEditTable();
    init_mstInstanceOperTable();
#endif

    //init_tftpMgt();
    /* shumin.wang modified for ES4827G-FLF-ZZ-00097 & ES4827G-FLF-ZZ-00256 */
    /*jingyan zheng modify for enabling restart management mib function*/
    init_restartMgt();
    init_mirrorTable();

#if (SYS_CPNT_VLAN_MIRROR == TRUE)
    init_vlanMirrorTable();
#endif

#if (SYS_CPNT_MAC_BASED_MIRROR == TRUE)
    init_macMirrorTable();
#endif

#if (SYS_CPNT_ACL_MIRROR == TRUE)
    init_aclMirrorTable();
#endif

#if (SYS_CPNT_RSPAN == TRUE)
    init_vlanStaticExtTable();
    init_rspanTable();
#endif /* end of #if (SYS_CPNT_RSPAN == TRUE) */

#if (SYS_CPNT_IGMPSNP == TRUE)
    init_igmpSnoopMgt();
    init_igmpSnoopGlobalMgt();
    init_igmpSnoopRouterCurrentTable();
    init_igmpSnoopRouterStaticTable();
    /*init_igmpSnoopMulticastCurrentTable();*/
    init_igmpSnoopMulticastStaticTable();
#if(SYS_CPNT_IGMPSNP_IMMEDIATE_LEAVE == TRUE)
    init_igmpSnoopCurrentVlanTable();
#endif
    init_igmpSnoopMulticastGroupTable();
#if (SYS_CPNT_FILTER_THROOTTLE == TRUE)
         init_igmpSnoopProfileTable();
         init_igmpSnoopProfileRangeTable();
         init_igmpSnoopFilterPortTable();
         init_igmpSnoopThrottlePortTable();
#endif

    init_igmpSnoopPortTable();

#if(SYS_CPNT_IGMPSNP_QUERY_DROP == TRUE)
    init_igmpSnoopQueryDropTable();
#endif
    init_igmpSnoopClearDynamicGroups();
    init_igmpSnoopVlanTable();
#endif /* #if (SYS_CPNT_IGMPSNP == TRUE) */

#if (SYS_CPNT_MVR == TRUE)
    init_mvrMgt();
    #if (SYS_CPNT_MVR_SUPPORT_MULTI_DOMAIN == FALSE)
    #if 0
    init_mvrGroupTable();
    #endif
    init_mvrGroupStaticTable();
    init_mvrGroupCurrentTable();
    init_mvrPortTable();
    #if (SYS_CPNT_MVR_PROFILE == FALSE)
    init_mvrGroupCtlTable();
#endif
    #else
    init_mvrDomainTable();
    init_mvrDomainPortTable();
    init_mvrDomainGroupStaticTable();
    init_mvrDomainGroupCurrentTable();
    #endif
    #if (SYS_CPNT_MVR_PROFILE == TRUE)
    init_mvrProfileCtlTable();
    init_mvrProfileGroupCtlTable();
    init_mvrDomainAssociatedProfileTable();
    #endif
    #if(SYS_CPNT_MVR_PROXY_SWITCHING == TRUE)
    init_mvrProxySwitching();
    init_mvrRobustnessValue();
    #endif
    #if(SYS_CPNT_MVR_PROXY_QUERY_INTERVAL == TRUE)
    init_mvrProxyQueryInterval();
    #endif
    #if (SYS_CPNT_MVR_SUPPORT_SOURCE_PORT_MODE == TRUE)
    init_mvrSourcePortMode();
    #endif
    init_mvrPortStatisticsTable();
    init_mvrVlanStatisticsTable();
#endif

#if (SYS_CPNT_MVR6 == TRUE)
    #if(SYS_CPNT_MVR6_SUPPORT_MULTI_DOMAIN == TRUE)
    init_mvr6DomainTable();
    init_mvr6DomainGroupStaticTable();
    init_mvr6DomainPortTable();
    init_mvr6DomainGroupCurrentTable();
    #else
    init_mvr6Status();
    init_mvr6VlanId();
    init_mvr6CurrentGroups();
    init_mvr6RunningStatus();
    init_mvr6UpstreamSourceIpAddress();
    init_mvr6GroupStaticTable();
    init_mvr6GroupCurrentTable();
    init_mvr6PortTable();
    #if (SYS_CPNT_MVR6_PROFILE == FALSE)
    init_mvr6GroupCtlTable();
    #endif
    #endif

    #if (SYS_CPNT_MVR6_PROFILE == TRUE)
    init_mvr6DomainAssociatedProfileTable();
    init_mvr6ProfileCtlTable();
    init_mvr6ProfileGroupCtlTable();
    #endif
    #if(SYS_CPNT_MVR6_PROXY_SWITCHING == TRUE)
    init_mvr6ProxySwitching();
    init_mvr6RobustnessValue();
    #endif
    #if(SYS_CPNT_MVR6_PROXY_QUERY_INTERVAL == TRUE)
    init_mvr6ProxyQueryInterval();
    #endif
    #if (SYS_CPNT_MVR6_SUPPORT_SOURCE_PORT_MODE == TRUE)
    init_mvr6SourcePortMode();
    #endif
    init_mvr6VlanStatisticsTable();
    init_mvr6PortStatisticsTable();
    #if(SYS_CPNT_MVR6_FORWARD_PRIORITY == TRUE)
    init_mvr6ForwardingPriority();
    #endif
#endif

#if(SYS_CPNT_ROUTING==TRUE)
    init_iPAddrTable();
#else
    init_netConfigTable();
#endif
    init_ipMgt();

#if (SYS_CPNT_DHCP_CLIENT == TRUE)    
    init_dhcpcInterfaceTable();
#endif

#if (SYS_CPNT_DHCP_RELAY == TRUE)
    init_dhcpRelay();
    init_dhcpRelayServerInetAddrTable();
    //init_dhcpRelayIfTable();
#endif  /* #if (SYS_CPNT_DHCP_RELAY == TRUE) */
#if(SYS_CPNT_DHCP_SERVER == TRUE)
#if 0
    init_dhcpServerMgt();
    init_dhcpPoolTable();
    init_dhcpPoolOptionTable();
    init_dhcpPoolOptionDnsSerTable();
    init_dhcpPoolOptDefaultRouterTable();
    init_dhcpPoolOptNetbiosServerTable();
    init_dhcpServerExcludedIpAddrTable();
    init_dhcpServerLeaseBindingTable();
#else
    /* shumin.wang added for inet address, 2008-12-30 */
    init_dhcpServerMgt();
    init_dhcpPoolInetTable();
    init_dhcpPoolInetOptionTable();
    init_dhcpPoolInetOptionDnsSerTable();
    init_dhcpPoolOptInetDefaultRouterTable();
    init_dhcpPoolOptInetNetbiosServerTable();
    init_dhcpServerExcludedInetAddrTable();
    init_dhcpServerInetLeaseBindingTable();
#endif
#endif

#if (SYS_CPNT_PIM == TRUE)
    init_pimMgt();
#endif /* #if (SYS_CPNT_PIM == TRUE) */

#if (SYS_CPNT_RATE_BASED_STORM_CONTROL != TRUE)

#if (SYS_CPNT_STORM_MODE & SYS_CPNT_STORM_BSTORM)
    init_bcastStormTable();
#endif /* #if (SYS_CPNT_STORM_MODE & SYS_CPNT_STORM_BSTORM) */

#if (SYS_CPNT_STORM_MODE & SYS_CPNT_STORM_MSTORM)
    init_mcastStormTable();
#endif /* #if (SYS_CPNT_STORM_MODE & SYS_CPNT_STORM_MSTORM) */

#if (SYS_CPNT_STORM_MODE & SYS_CPNT_STORM_UNKNOWN_USTORM)
    init_unknownUcastStormTable();
#endif /* #if (SYS_CPNT_STORM_MODE & SYS_CPNT_STORM_UNKNOWN_USTORM) */

#else /* else #if (SYS_CPNT_RATE_BASED_STORM_CONTROL != TRUE) */
    init_rateBasedStormTable();
#endif /* #if (SYS_CPNT_RATE_BASED_STORM_CONTROL != TRUE) */

#if (SYS_CPNT_ATC_STORM == TRUE)
         init_atcMgt();

#if (SYS_CPNT_ATC_BSTORM == TRUE)
         init_atcBcastStormTable();
#endif /* #if (SYS_CPNT_ATC_BSTORM == TRUE) */

#if (SYS_CPNT_ATC_MSTORM == TRUE)
         init_atcMcastStormTable();
#endif /* #if (SYS_CPNT_ATC_MSTORM == TRUE) */

#endif /* #if (SYS_CPNT_ATC_STORM == TRUE) */

    init_vlanTable();
    init_vlanPortTable();
#if (SYS_CPNT_ADD == TRUE)
    init_voiceVlanOuiTable();
    init_voiceVlanMgt();
    init_voiceVlanPortTable();
#endif
#if (SYS_CPNT_QINQ == TRUE)
    init_vlanDot1qTunnelGlobalConfig();
    init_vlanDot1qTunnelPortTable();

#if (SYS_CPNT_QINQ_L2PT == TRUE)
     init_vlanL2ProtocolTunnelGlobalConfig();
     init_vlanL2ProtocolTunnelPortTable();
#endif

#if (SYS_CPNT_SWCTRL_QINQ_SERVICE == TRUE)
#if (SYS_CPNT_SWCTRL_QINQ_SERVICE_SUBSCRIBE_BY_TAG_INFO == TRUE)
        init_vlanDot1qTunnelSrvCvidPortTable();
#endif
#if (SYS_CPNT_SWCTRL_QINQ_SERVICE_SUBSCRIBE_BY_DBL_TAG == TRUE)
        init_vlanDot1qTunnelSrvDTagPortTable();
#endif
#if (SYS_CPNT_SWCTRL_QINQ_DEFAULT_SERVICE == TRUE)
        init_vlanDot1qTunnelSrvDfltPortTable();
#endif
#endif /* (SYS_CPNT_SWCTRL_QINQ_SERVICE == TRUE) */
#endif /* (SYS_CPNT_QINQ == TRUE) */

    init_vlanStaticTable();

#if (SYS_CPNT_MAC_VLAN == TRUE)
    init_macVlanTable();
    init_macVlanClearAction();
#endif

#if (SYS_CPNT_IP_SUBNET_VLAN == TRUE)
    init_subnetVlanTable();
    init_subnetVlanClearAction();
#endif

#if (SYS_CPNT_COS == TRUE)
    init_priorityMgt();
    //init_prioIpPrecTable();
    //init_prioIpDscpTable();
    //init_prioIpPortTable();
#endif
#if (SYS_CPNT_WRR_Q_WEIGHT_PER_PORT_CTRL == TRUE)
    init_prioWrrPortTable();
#else
    init_prioWrrTable();
#endif
#if (SYS_CPNT_WRR_Q_MODE_PER_PORT_CTRL == TRUE)
    init_prioPortTable();
    init_prioSchedModePortTable(); /* 2008-06-04, Jinfeng.Chen: for scheduling mode */
#endif

/* use standard MIB
 */
#if 0
    init_trapDestTable();
#endif /* #if 0 */

    init_rateLimitPortTable();
#if (SYS_CPNT_QOS == SYS_CPNT_QOS_MARKER)
    init_markerTable();
#endif

#if (SYS_CPNT_COS == TRUE)

    init_prioIfClassificationModeTable();

#if (SYS_CPNT_COS_ING_COS_TO_INTER_DSCP == TRUE) && (SYS_CPNT_COS_ING_COS_TO_INTER_DSCP_PER_PORT == TRUE)
    init_prioCosToDscpTable();
#endif  /* SYS_CPNT_COS_ING_COS_TO_INTER_DSCP && SYS_CPNT_COS_ING_COS_TO_INTER_DSCP_PER_PORT */

#if (SYS_CPNT_COS_ING_IP_PRECEDENCE_TO_INTER_DSCP == TRUE) && (SYS_CPNT_COS_ING_IP_PRECEDENCE_TO_INTER_DSCP_PER_PORT == TRUE)
    init_prioPrecToDscpTable();
#endif  /* SYS_CPNT_COS_ING_IP_PRECEDENCE_TO_INTER_DSCP && SYS_CPNT_COS_ING_IP_PRECEDENCE_TO_INTER_DSCP_PER_PORT */

#if (SYS_CPNT_COS_ING_DSCP_TO_INTER_DSCP == TRUE) && (SYS_CPNT_COS_ING_DSCP_TO_INTER_DSCP_PER_PORT == TRUE)
    init_prioDscpToDscpTable();
#endif  /* SYS_CPNT_COS_ING_DSCP_TO_INTER_DSCP && SYS_CPNT_COS_ING_DSCP_TO_INTER_DSCP_PER_PORT */

#if (SYS_CPNT_COS_ING_IP_PORT_TO_INTER_DSCP == TRUE) && (SYS_CPNT_COS_ING_IP_PORT_TO_INTER_DSCP_PER_PORT == TRUE)
    init_prioDstPortToDscpTable();
#endif  /* SYS_CPNT_COS_ING_IP_PORT_TO_INTER_DSCP && SYS_CPNT_COS_ING_IP_PORT_TO_INTER_DSCP_PER_PORT */

#if (SYS_CPNT_COS_ING_INTER_DSCP_TO_COS == TRUE) && (SYS_CPNT_COS_ING_INTER_DSCP_TO_COS_PER_PORT == TRUE)
    init_prioDscpToCosTable();
#endif  /* SYS_CPNT_COS_ING_INTER_DSCP_TO_COS && SYS_CPNT_COS_ING_INTER_DSCP_TO_COS_PER_PORT */

#if (SYS_CPNT_COS_ING_INTER_DSCP_TO_COLOR == TRUE) && (SYS_CPNT_COS_ING_INTER_DSCP_TO_COLOR_PER_PORT == TRUE)
    init_prioPrioToDropPrecTable();
#endif  /* SYS_CPNT_COS_ING_INTER_DSCP_TO_COLOR && SYS_CPNT_COS_ING_INTER_DSCP_TO_COLOR_PER_PORT */

#if (SYS_CPNT_COS_ING_INTER_DSCP_TO_QUEUE == TRUE) && (SYS_CPNT_COS_ING_INTER_DSCP_TO_QUEUE_PER_PORT == TRUE)
    init_prioDscpToQueueTable();
#endif  /* SYS_CPNT_COS_ING_INTER_DSCP_TO_QUEUE && SYS_CPNT_COS_ING_INTER_DSCP_TO_QUEUE_PER_PORT */

    init_prioDefaultPrioTable();

#endif /* SYS_CPNT_COS */

#if ((SYS_CPNT_QOS == SYS_CPNT_QOS_DIFFSERV) && (SYS_CPNT_QOS_V2 != TRUE))
    init_diffServMgt();
    init_diffServClfrExtTable();
    init_diffServClassMapTable();
    init_diffServClassMapElementTable();
    init_diffServMultiFieldClfrExtTable();
    init_diffServToSMarkActTable();
    init_diffServDot1pMarkActTable();
#endif


#if (SYS_CPNT_QOS_V2 == TRUE)
    init_diffServMgt();
    init_diffServPolicyMapTable();
    init_diffServPolicyMapElementTable();
    init_diffServClassMapTable();
    init_diffServAclTable();
    init_diffServIpAceTable();
    init_diffServMacAceTable();
    init_diffServActionTable();
    init_diffServMeterTable();

#if (SYS_CPNT_ACL_IPV6 == TRUE)
    init_diffServIpv6AceTable();
#endif

#if (SYS_CPNT_DAI == TRUE)
    init_diffServArpAceTable();
    init_diffServArpTable();
#endif /* #if (SYS_CPNT_DAI == TRUE) */

#if (SYS_CPNT_ACL_COUNTER == TRUE)
    init_diffServAclHwCounterTable();
#endif /* #if (SYS_CPNT_ACL_COUNTER == TRUE) */

    init_diffServPolicyMapPortTable();
    init_diffServAccessGroupTable();
    init_diffServTcamTable();
#if (SYS_CPNT_QOS_V2_COUNTER == TRUE)
    init_diffServControlPlaneHwCounterTable();
#endif /*#if (SYS_CPNT_QOS_V2_COUNTER == TRUE)*/
#endif /* #if (SYS_CPNT_QOS_V2 == TRUE) */

#if (SYS_CPNT_COS_ING_INTER_DSCP_TO_QUEUE == TRUE)
#if (TRUE != SYS_CPNT_COS_ING_INTER_DSCP_TO_QUEUE_PER_PORT)
    init_prioGlobalDscpToQueueTable();
#endif /* (TRUE != SYS_CPNT_COS_ING_INTER_DSCP_TO_QUEUE_PER_PORT) */
#endif /* SYS_CPNT_COS_ING_INTER_DSCP_TO_QUEUE */

#if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION==TRUE)
    init_privateVlanMgt();

#if (SYS_CPNT_COMMUNITY_PRIVATE_VLAN == TRUE)
    init_privateVlanVlanTable();
    init_privateVlanPrivatePortTable();
    init_privateVlanPromPortTable();
#endif

#if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE == SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE_MULTIPLE_SESSION)
    init_privateVlanSessionTable();
    init_privateVlanUplinkToUplink();
#endif /* end of #if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE == SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE_MULTIPLE_SESSION) */

#if (SYS_DFLT_TRAFFIC_SEG_METHOD == SYS_DFLT_TRAFFIC_SEG_METHOD_PORT_PRIVATE_MODE)
    init_privateVlanEdgePortTable();
#endif
#endif /* end of #if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION == TRUE) */

#if (SYS_CPNT_PORT_SECURITY==TRUE)
    init_portSecPortTable();
    init_portSecMacAsPermanentMgt();
#endif
#if (SYS_CPNT_SSHD == TRUE || SYS_CPNT_SSH2 == TRUE)
    init_sshMgt();
    init_sshConnInfoTable();
    init_sshUserTable();
#endif

#if ((SYS_CPNT_ACL == TRUE) && (SYS_CPNT_QOS_V2 != TRUE))
    init_aclIngressMacMaskTable();
    init_aclEgressMacMaskTable();
    init_aclIngressIpMaskTable();
    init_aclEgressIpMaskTable();
#endif

#if (SYS_CPNT_MGMT_IP_FLT == TRUE)
#if (SYS_CPNT_IPV6 != TRUE)
    init_ipFilterSnmpTable();
    init_ipFilterTelnetTable();
    init_ipFilterHTTPTable();
#else
    init_ipFilterSnmpInetTable();
    init_ipFilterHttpInetTable();
    init_ipFilterTelnetInetTable();
#endif /* #if (SYS_CPNT_IPV6 == TRUE) */
    init_ipFilterAllClientCtl();
#endif /* #if (SYS_CPNT_MGMT_IP_FLT == TRUE) */

#if (SYS_CPNT_ARP == TRUE)
    init_arpMgt();
#if (SYS_CPNT_PROXY_ARP == TRUE)
    init_arpProxyArpTable();
#endif /* #if (SYS_CPNT_PROXY_ARP == TRUE) */
#endif /* #if (SYS_CPNT_ARP == TRUE) */

#if (SYS_CPNT_RIP == TRUE)
    init_ripMgt();
    init_ripInstabilityPreventingTable();
    init_ripNetworkByInterfaceTable();
    init_ripNetworkByInetAddrTable();
    init_ripPassiveInterfaceTable();
    init_ripNeighborTable();
    init_ripDistanceTable();
    init_ripRouteClearByNetworkTable();
    init_ripRedistributeTable();
#endif /* #if (SYS_CPNT_RIP == TRUE)*/

#if (SYS_CPNT_OSPF == TRUE)
    init_ospfMultiProcessNssaTable();
    init_ospfMultiProcessAreaAggregateTable();
    init_ospfMultiProcessStubAreaTable();
    init_ospfMultiProcessAreaTable();
    init_ospfMultiProcessNetworkAreaAddressTable();

    init_ospfMultiProcSummaryAddrTable();
    init_ospfMultiProcRedistTable();
    init_ospfMultiProcessVirtIfTable();
    init_ospfMultiProcessVirtNbrTable();
    init_ospfMultiProcessIfTable();
    init_ospfMultiProcessSystemTable();
    init_ospfIfParamTable();
    init_ospfMultiProcVirtIfMd5Table();
    init_ospfMultiProcessNbrTable();
    init_ospfMultiProcessLsdbTable();
    init_ospfMultiProcessExtLsdbTable();
    init_ospfMultiProcessIfAuthMd5Table();
    init_ospfMultiProcessRouteTable();
#endif /* #if (SYS_CPNT_OSPF == TRUE) */

#if (SYS_CPNT_DVMRP == TRUE)
    init_dvmrpMgt();
    init_dvmrpInterfaceTable();
    init_dvmrpNeighborTable();
    init_dvmrpRouteTable();
    init_dvmrpRouteNextHopTable();
    init_dvmrpPruneTable();
#endif
#if 0 /*These functions will be implemented in future -- xiongyu 20090112*/
#if (SYS_CPNT_OSPF == TRUE)
    init_ipCidrRouteExtTable();
#endif
#endif
#if (SYS_CPNT_NSM == TRUE)
    init_routeMultipath();
#endif /* SYS_CPNT_NSM */

#if (SYS_CPNT_RADIUS == TRUE)
    init_radiusMgt();
    init_radiusServerTable();
#endif /* #if (SYS_CPNT_RADIUS == TRUE) */

#if (SYS_CPNT_TACACS == TRUE)
    init_tacacsMgt();
    init_tacacsPlusServerTable();
#endif /* #if (SYS_CPNT_TACACS == TRUE) */

#if (SYS_CPNT_AAA == TRUE)
    init_aaaMgt();
    init_aaaMethodTable();
#if (SYS_CPNT_RADIUS_ACCOUNTING==TRUE)
    init_aaaRadiusGroupTable();
#endif
#if (SYS_CPNT_TACACS_PLUS_ACCOUNTING==TRUE)
    init_aaaTacacsPlusGroupTable();
#endif
    init_aaaAccountTable();
#if (SYS_CPNT_ACCOUNTING_COMMAND == TRUE)
    init_aaaCommandPrivilegesTable();
#endif
    init_aaaAccExecTable();
#endif /* #if (SYS_CPNT_AAA == TRUE) */

#if (SYS_CPNT_DOT1X == TRUE)
    init_dot1xAuthConfigExtTable();

#if (SYS_CPNT_DOT1X_EAPOL_PASS_THROUGH == TRUE)
        init_dot1xEapolPassThrough();
#endif
#endif /* #if (SYS_CPNT_DOT1X == TRUE) */

#if(SYS_CPNT_NETACCESS == TRUE)
    init_networkAccessMgt();
    init_networkAccessPortTable();
    init_networkAccessClearMacAddressMgt();
    init_networkAccessMacAddressTable();
    init_macAuthMgt();
    init_macAuthPortTable();
    #if(SYS_CPNT_NETACCESS_MAC_FILTER_TABLE== TRUE)
    init_networkAccessMacFilterWithMaskTable();
    #endif
#endif /* #if(SYS_CPNT_NETACCESS == TRUE) */

#if (SYS_CPNT_WEBAUTH == TRUE)
    init_webAuthMgt();
    init_webAuthReauthenticateMgt();
    init_webAuthPortConfigTable();
    init_webAuthPortInfoTable();
#endif

#if (SYS_CPNT_DOS == TRUE)
    init_dosMgt();
#endif

#if (SYS_CPNT_APP_FILTER == TRUE)
    init_appFilterPortTable();
#endif /* #if (SYS_CPNT_APP_FILTER == TRUE) */

#if (SYS_CPNT_SYSLOG == TRUE)
    init_sysLogMgt();
#endif
    init_consoleMgt();
#if (SYS_CPNT_TELNET == TRUE)
    init_telnetMgt();
#endif /* #if (SYS_CPNT_TELNET == TRUE) */
    init_vtyMgt();

#if (SYS_CPNT_REMOTELOG == TRUE)
    init_remoteLogMgt();
    init_remoteLogServerInetTable();
#endif
#if (SYS_CPNT_SMTP == TRUE)
    init_smtpMgt();
    init_smtpServerIpTable();
    init_smtpDestEMailTable();
#endif
#if (SYS_CPNT_SNTP == TRUE)
    init_sysTimeMgt();
    init_sntpServerTable();
#endif

#if (SYS_CPNT_NTP == TRUE)
    init_ntpMgt();
    init_ntpServerTable();
    init_ntpAuthKeyTable();
#endif

    init_pingMgt();
    init_pingHistoryTable();
    //init_pingProbeHistoryTable();

    init_fileCopyMgt();
    init_fileInfoTable();
    /* shumin.wang modified for ES4827G-FLF-ZZ-00097 & ES4827G-FLF-ZZ-00256 */
    //init_fileAutoDownloadResultTable();

#if(SYS_CPNT_XFER_AUTO_UPGRADE==TRUE)
    init_fileAutoUpgradeMgt();
#endif

#if (SYS_CPNT_DNS == TRUE)
    init_dnsMgt();
    init_dnsHostTable();

#if 0
    init_dnsAliasTable();
#endif

    init_dnsDomainListTable();
    init_dnsCacheTable();
    init_dnsHostAddrTable();
    init_dnsNameServerInetTable();
#endif /* #if (SYS_CPNT_DNS == TRUE) */

#if (SYS_CPNT_PFU == TRUE)
    init_pfuRuleTable();
    init_packetFilterUnitMgt();
#endif
#if (SYS_CPNT_HSRP == TRUE)
    init_hsrpMgt();
    init_cHsrpGrpTable();
    init_cHsrpExtIfTrackedTable();
    init_cHsrpExtSecAddrTable();
#endif

#if (SYS_CPNT_SYSMGMT_RESMIB == TRUE)
    init_sysResourceMgt();
#if (SYS_CPNT_SYSMGMT_MONITORING_PROCESS_CPU_PER_TASK == TRUE)
    init_taskCpuTable();
#endif
#if (SYS_CPNT_SYSMGMT_CPU_GUARD == TRUE)
    init_cpuGuard();
#endif
#endif /* #if (SYS_CPNT_SYSMGMT_RESMIB == TRUE) */

#if (SYS_CPNT_EGRESS_PACKET_BLOCK == TRUE)
#if (SYS_CPNT_EGRESS_PACKET_BLOCK_UNKNOWN_MULTICAST == TRUE)
    init_egressPacketBlockUnknownMcastTable();
#endif
#if (SYS_CPNT_EGRESS_PACKET_BLOCK_UNKNOWN_UNICAST == TRUE)
    init_egressPacketBlockUnknownUcastTable();
#endif
#if (SYS_CPNT_EGRESS_PACKET_BLOCK_BROADCAST == TRUE)
    init_egressPacketBlockBcastTable();
#endif
#endif

#if (SYS_CPNT_DHCPSNP == TRUE)
    init_dhcpSnoopEnable();
    init_dhcpSnoopVerifyMacAddressEnable();
#if (SYS_CPNT_DHCPSNP_INFORMATION_OPTION == TRUE)
    init_dhcpSnoopGlobal();
#endif
#if (SYS_CPNT_CFGDB == TRUE)
    init_dhcpSnoopBindingsTableCtlAction();
#endif
#if (SYS_CPNT_DHCPSNP_SYSTEM_RATELIMIT == TRUE)
    init_dhcpSnoopLimitRate();
#endif
    /* shumin.wang modified for ES4827G-FLF-ZZ-00097 & ES4827G-FLF-ZZ-00256 */
    init_dhcpSnoopVlanConfigTable();
    init_dhcpSnoopBindingsTable();
    init_dhcpSnoopPortConfigTable();
    init_dhcpSnoopTotalForwardedPkts();
    init_dhcpSnoopUntrustedPortDroppedPkts();
#endif

#if (SYS_CPNT_CLUSTER==TRUE)
    init_clusterMgt();
    init_clusterCandidateTable();
    init_clusterMemberTable();
#endif /*end of #if (SYS_CPNT_CLUSTER==TRUE)*/

#if (SYS_CPNT_EFM_OAM == TRUE)
    init_oamPortClearStatTable();
#endif /* end of #if (SYS_CPNT_EFM_OAM == TRUE) */

#if (SYS_CPNT_INTERNAL_LOOPBACK_TEST == TRUE)
    init_loopInternalCtlAction();
    init_loopInternalResultTable();
#endif /* end of #if (SYS_CPNT_INTERNAL_LOOPBACK_TEST == TRUE) */

#if (SYS_CPNT_VLAN_TRUNKING == TRUE)
    init_portVlanTrunkingTable();
#endif /* #if (SYS_CPNT_VLAN_TRUNKING == TRUE) */

#if (SYS_CPNT_MLDSNP == TRUE)
    init_mldSnoopStatus();
    init_mldSnoopQuerier();
    init_mldSnoopRobustness();
    init_mldSnoopQueryInterval();
    init_mldSnoopQueryMaxResponseTime();
    init_mldSnoopRouterPortExpireTime();
    init_mldSnoopVersion();
    init_mldSnoopUnknownMcastMode();
    init_mldSnoopRouterCurrentTable();
    init_mldSnoopRouterStaticTable();
    init_mldSnoopMulticastCurrentTable();
    init_mldSnoopMulticastStaticTable();
    init_mldSnoopCurrentVlanTable();
#if(SYS_CPNT_MLDSNP_PROXY == TRUE)
    init_mldSnoopProxyReporting();
    init_mldSnoopUnsolicitedReportInterval();
#endif

#if (SYS_CPNT_FILTER_THROOTTLE_MLDSNP == TRUE)
    init_mldSnoopProfileCtrlTable();
    init_mldSnoopProfileTable();
    init_mldSnoopProfileRangeTable();
    init_mldSnoopFilterPortTable();
    init_mldSnoopThrottlePortTable();
#endif
    init_mldSnoopClearDynamicGroups();
    init_mldSnoopPortTable();
    init_mldSnoopVlanTable();
#endif /* end of #if (SYS_CPNT_MLDSNP == TRUE) */
    init_enablePassword();
    init_authMethod();
    init_userauthTable();

#if (SYS_CPNT_UDP_HELPER == TRUE)
    init_udpHelperStatus();
    init_udpHelperForwardProtocolTable();
    init_udpHelperInetAddrTable();
#endif /* #if (SYS_CPNT_UDP_HELPER == TRUE) */

#if (SYS_CPNT_IGMP == TRUE)
    init_igmpProxyTable();
    init_igmpStaticGroupTable();
#endif /* #if (SYS_CPNT_IGMP == TRUE) */

#if (SYS_CPNT_DAI == TRUE)
    init_daiGlobal();
    init_daiVlanTable();
    init_daiPortTable();
    init_daiLogTable();
    init_daiStatistics();
#endif /* #if (SYS_CPNT_DAI == TRUE) */

#if (SYS_CPNT_IP_SOURCE_GUARD == TRUE)
    init_ipSrcGuardConfigTable();
    init_ipSrcGuardAclTable();
#if (SYS_CPNT_IPSG_BINDING_FILTER_SOURCE == TRUE)
    init_ipSrcGuardBindingFilterSource();
#endif /* #if (SYS_CPNT_IPSG_BINDING_FILTER_SOURCE == TRUE) */
#endif /* #if (SYS_CPNT_IP_SOURCE_GUARD == TRUE) */

#if (SYS_CPNT_ERPS == TRUE)
    init_erpsMgt();
    init_erpsDomainTable();
    init_erpsPortStatsTable();
#endif /* #if (SYS_CPNT_ERPS == TRUE) */

#if (SYS_CPNT_PPPOE_IA == TRUE)
        init_pppoeiaGlobal();
        init_pppoeiaPortTable();
        init_pppoeiaPortStatsTable();
#endif  /* SYS_CPNT_PPPOE_IA == TRUE */

#if (SYS_CPNT_IPV6_RA_GUARD == TRUE)
    init_ipv6RaGuardPortTable();
#endif /* #if (SYS_CPNT_IPV6_RA_GUARD == TRUE) */

#if (SYS_CPNT_SYNCE == TRUE)
init_syncEStatus();
init_syncESsmStatus();
init_syncEClockSourcePort();
init_syncEGoodClockSource();
init_syncEClockSourceSelect();
init_syncEAutoClockSourceRevertive();
init_syncEClockSourceLocked();
init_syncEPortTable();

#endif /*#if (SYS_CPNT_SYNCE == TRUE)*/

#if (SYS_CPNT_UDLD == TRUE)
    init_udldMgt();
    init_udldPortTable();
    init_udldPortNeighborDevTable();
#endif /* #if (SYS_CPNT_UDLD == TRUE) */

#if (SYS_CPNT_PTP == TRUE)
    init_ptpMode();
    init_ptpDomainNumber();
    init_ptpPriority1();
    init_ptpPriority2();
    init_ptpPortTable();
    init_ptpDefaultDSTable();
    init_ptpCurrentDSTable();
    init_ptpTimePropertiesDSTable();
    init_ptpParentDSTable();
    init_ptpPortDSTable();
    init_ptpTransparentClockDefaultDSTable();
    init_ptpTranaparentClockPortDSTable();
  #if(SYS_CPNT_PTP_IN_E_GRESS_LATENCY == TRUE)
    init_ptpIngressLatency();
    init_ptpEgressLatency();
  #endif
#endif

#if (SYS_CPNT_DHCPV6SNP == TRUE)
    init_dhcpv6SnoopGlobal();
    init_dhcpv6SnoopVlanConfigTable();
    init_dhcpv6SnoopPortConfigTable();
    init_dhcpv6SnoopBindingTable();
    init_dhcpv6SnoopStatistics();
#endif /* end of #if (SYS_CPNT_DHCPV6SNP == TRUE)*/

#if (SYS_CPNT_IPV6_SOURCE_GUARD == TRUE)
    init_ip6SrcGuardConfigTable();
    init_ip6SrcGuardAddrTable();
#endif

#if (SYS_CPNT_CN == TRUE)
    init_cnGlobal();
    init_cnPriTable();
    init_cnPortPriTable();
    init_cnCpTable();
#endif

#if (SYS_CPNT_DCBX == TRUE)
    init_dcbxPortTable();
#endif

#if (SYS_CPNT_PFC == TRUE)
    init_pfcMgt();
    init_pfcPortTable();
    init_pfcPortStatsTable();
#endif

#if (SYS_CPNT_ETS == TRUE)
    init_etsMgt();
    init_etsPortTable();
    init_etsPortPriorityAssignmentTable();
    init_etsPortTrafficClassWeightTable();
    init_etsPortTrafficSelectionAlgorithmTable();
#endif

#if (SYS_CPNT_LBD == TRUE)
    init_lbdGlobal();
    init_lbdPortTable();
#endif /* #if (SYS_CPNT_LBD == TRUE) */

#if (SYS_CPNT_VXLAN == TRUE)
    init_vxlanUdpDstPort();
    init_vxlanFloodTable();
    init_vxlanVlanVniMappingTable();
#endif /* #if (SYS_CPNT_VXLAN == TRUE) */

#if (SYS_CPNT_HASH_SELECTION == TRUE)
    init_hashSelTable();
#endif

#if (SYS_CPNT_ECMP_BALANCE_MODE == TRUE)
    init_ecmpMgt();
#endif

}

/********************************************
 *********init_PrivateMibSysOrTable**********
 ********************************************
 */
void
init_PrivateMibSysOrTable(void)
{
    oid      PrivateMIB_module_oid[32];/*MAX_OID_LEN*/
    char     PrivateMIBDescr[64];
    UI32_T   oidlen;
    //UI8_T    buffer[SYS_ADPT_MAX_OID_STRING_LEN+1];
    char     descr_buffer[MAXSIZE_sysDescr+1];
    UI32_T   board_id;

    init_BoardIDStringToMIBRootOID(&board_id, PrivateMIB_module_oid, &oidlen);

    switch(board_id)
    {
        case 0:
            strcpy( descr_buffer, SYS_ADPT_DEVICE_NAME_FOR_BOARD_ID0);
            break;
        case 1:
            strcpy( descr_buffer, SYS_ADPT_DEVICE_NAME_FOR_BOARD_ID1);
            break;
        case 2:
            strcpy( descr_buffer, SYS_ADPT_DEVICE_NAME_FOR_BOARD_ID2);
            break;
        case 3:
            strcpy( descr_buffer, SYS_ADPT_DEVICE_NAME_FOR_BOARD_ID3);
            break;
        case 4:
            strcpy( descr_buffer, SYS_ADPT_DEVICE_NAME_FOR_BOARD_ID4);
            break;
        case 5:
            strcpy( descr_buffer, SYS_ADPT_DEVICE_NAME_FOR_BOARD_ID5);
            break;
        case 6:
            strcpy( descr_buffer, SYS_ADPT_DEVICE_NAME_FOR_BOARD_ID6);
            break;
        case 7:
            strcpy( descr_buffer, SYS_ADPT_DEVICE_NAME_FOR_BOARD_ID7);
            break;
        default:
        strcpy( descr_buffer, SYS_ADPT_DEVICE_NAME_FOR_BOARD_ID0);
            break;
    }
    sprintf(PrivateMIBDescr, "%s Private MIB", descr_buffer);

    //  REGISTER_SYSOR_ENTRY(PrivateMIB_module_oid,
                  //    PrivateMIBDescr);
        REGISTER_SYSOR_TABLE( PrivateMIB_module_oid, oidlen, PrivateMIBDescr);
}



/********************************************
 ************init_switchMgt******************
 ********************************************
 */
void
init_switchMgt(void)
{
    static oid switchNumber_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,1,2, 0 };
    static oid swProdName_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,1,5,1, 0 };
    static oid swProdUrl_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,1,5,5, 0 };
    static oid swProdDescription_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,1,5,3, 0 };
    static oid swProdVersion_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,1,5,4, 0 };
    static oid swChassisServiceTag_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,1,5,7, 0 };
    static oid switchOperState_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,1,4, 0 };
    static oid amtrMacAddrAgingStatus_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1, 1, 8, 3, 0 };
   // static oid amtrMacAddrRisingThreshold_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,1,8,1, 0 };
   // static oid amtrMacAddrFallingThreshold_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,1,8,2, 0 };
    static oid swProdManufacturer_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,1,5,2, 0 };
    static oid swIdentifier_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,1,5,6, 0 };
    #if (SYS_CPNT_JUMBO_FRAMES == TRUE)
    static oid switchJumboFrameStatus_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,1,7, 0 };
    #endif

    static oid switchRenumberUnitID_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,1,14, 0 };

#if (SYS_CPNT_SWCTRL_MTU_CONFIG_MODE == SYS_CPNT_SWCTRL_MTU_PER_SYSTEM)
    static oid switchSystemJumboMtu_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,1,18,0 };
#endif /* #if (SYS_CPNT_SWCTRL_MTU_CONFIG_MODE == SYS_CPNT_SWCTRL_MTU_PER_SYSTEM) */

    init_PrivateMIBNodeRootOIDbySwitchBoardID(switchNumber_oid);
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("switchNumber", get_switchNumber,
                                         switchNumber_oid,
                                         OID_LENGTH(switchNumber_oid),
                                         HANDLER_CAN_RONLY));
    init_PrivateMIBNodeRootOIDbySwitchBoardID(swProdName_oid);
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("swProdName",
                                         get_swProdName,
                                         swProdName_oid,
                                         OID_LENGTH(swProdName_oid),
                                         HANDLER_CAN_RONLY));
    init_PrivateMIBNodeRootOIDbySwitchBoardID(swProdUrl_oid);
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("swProdUrl",
                                         get_swProdUrl,
                                         swProdUrl_oid,
                                         OID_LENGTH(swProdUrl_oid),
                                         HANDLER_CAN_RONLY));
    init_PrivateMIBNodeRootOIDbySwitchBoardID(swProdDescription_oid);
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("swProdDescription",
                                         get_swProdDescription,
                                         swProdDescription_oid,
                                         OID_LENGTH(swProdDescription_oid),
                                         HANDLER_CAN_RONLY));
    init_PrivateMIBNodeRootOIDbySwitchBoardID(swProdVersion_oid);
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("swProdVersion",
                                         get_swProdVersion,
                                         swProdVersion_oid,
                                         OID_LENGTH(swProdVersion_oid),
                                         HANDLER_CAN_RONLY));
    init_PrivateMIBNodeRootOIDbySwitchBoardID(swChassisServiceTag_oid);
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("swChassisServiceTag",
                                         get_swChassisServiceTag,
                                         swChassisServiceTag_oid,
                                         OID_LENGTH(swChassisServiceTag_oid),
                                         HANDLER_CAN_RONLY));
    init_PrivateMIBNodeRootOIDbySwitchBoardID(switchOperState_oid);
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("switchOperState",
                                         get_switchOperState,
                                         switchOperState_oid,
                                         OID_LENGTH(switchOperState_oid),
                                         HANDLER_CAN_RONLY));
    init_PrivateMIBNodeRootOIDbySwitchBoardID(amtrMacAddrAgingStatus_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("amtrMacAddrAgingStatus",
                               do_amtrMacAddrAgingStatus,
                               amtrMacAddrAgingStatus_oid,
                               OID_LENGTH(amtrMacAddrAgingStatus_oid),
                               HANDLER_CAN_RWRITE));
  #if 0
   init_PrivateMIBNodeRootOIDbySwitchBoardID(amtrMacAddrRisingThreshold_oid);
   netsnmp_register_instance(netsnmp_create_handler_registration
                              ("amtrMacAddrRisingThreshold",
                               do_amtrMacAddrRisingThreshold,
                               amtrMacAddrRisingThreshold_oid,
                               OID_LENGTH(amtrMacAddrRisingThreshold_oid),
                               HANDLER_CAN_RWRITE));
    init_PrivateMIBNodeRootOIDbySwitchBoardID(amtrMacAddrFallingThreshold_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("amtrMacAddrFallingThreshold",
                               do_amtrMacAddrFallingThreshold,
                               amtrMacAddrFallingThreshold_oid,
                               OID_LENGTH(amtrMacAddrFallingThreshold_oid),
                               HANDLER_CAN_RWRITE));

    #endif
    init_PrivateMIBNodeRootOIDbySwitchBoardID(swProdManufacturer_oid);
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("swProdManufacturer",
                                         get_swProdManufacturer,
                                         swProdManufacturer_oid,
                                         OID_LENGTH(swProdManufacturer_oid),
                                         HANDLER_CAN_RONLY));
    init_PrivateMIBNodeRootOIDbySwitchBoardID(swIdentifier_oid);
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("swIdentifier",
                                         get_swIdentifier,
                                         swIdentifier_oid,
                                         OID_LENGTH(swIdentifier_oid),
                                         HANDLER_CAN_RONLY));

#if (SYS_CPNT_JUMBO_FRAMES == TRUE)

    init_PrivateMIBNodeRootOIDbySwitchBoardID(switchJumboFrameStatus_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("switchJumboFrameStatus",
                               do_switchJumboFrameStatus,
                               switchJumboFrameStatus_oid,
                               OID_LENGTH(switchJumboFrameStatus_oid),
                               HANDLER_CAN_RWRITE));
#endif
    init_PrivateMIBNodeRootOIDbySwitchBoardID(switchRenumberUnitID_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("switchRenumberUnitID",
                               do_switchRenumberUnitID,
                               switchRenumberUnitID_oid,
                               OID_LENGTH(switchRenumberUnitID_oid),
                               HANDLER_CAN_RWRITE));

#if (SYS_CPNT_SWCTRL_MTU_CONFIG_MODE == SYS_CPNT_SWCTRL_MTU_PER_SYSTEM)
    netsnmp_register_instance(netsnmp_create_handler_registration
                               ("switchSystemJumboMtu",
                                do_switchSystemJumboMtu,
                                switchSystemJumboMtu_oid,
                                OID_LENGTH(switchSystemJumboMtu_oid),
                                HANDLER_CAN_RWRITE));
#endif /* #if (SYS_CPNT_SWCTRL_MTU_CONFIG_MODE == SYS_CPNT_SWCTRL_MTU_PER_SYSTEM) */
}



/********************************************
 *********   init_switchInfoTable************
 ********************************************
 */
static oid switchInfoTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID ,1,1 };

struct variable3 switchInfoTable_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */

{SWHARDWAREVER,  ASN_OCTET_STR,  RONLY,   var_switchInfoTable, 3,  { 3, 1, 2 }},
{SWMICROCODEVER,  ASN_OCTET_STR,  RONLY,   var_switchInfoTable, 3,  { 3, 1, 3 }},
{SWLOADERVER,  ASN_OCTET_STR,  RONLY,   var_switchInfoTable, 3,  { 3, 1, 4 }},
{SWBOOTROMVER,  ASN_OCTET_STR,  RONLY,   var_switchInfoTable, 3,  { 3, 1, 5 }},
{SWOPCODEVER,  ASN_OCTET_STR,  RONLY,   var_switchInfoTable, 3,  { 3, 1, 6 }},
{SWPORTNUMBER,  ASN_INTEGER,  RONLY,   var_switchInfoTable, 3,  { 3, 1, 7 }},
{SWPOWERSTATUS,  ASN_INTEGER,  RONLY,   var_switchInfoTable, 3,  { 3, 1, 8 }},
{SWROLEINSYSTEM,  ASN_INTEGER,  RONLY,   var_switchInfoTable, 3,  { 3, 1, 9 }},
{SWSERIALNUMBER,  ASN_OCTET_STR,  RONLY,   var_switchInfoTable, 3,  { 3, 1, 10 }},
{SWEXPANSIONSLOT1,  ASN_INTEGER,  RONLY,   var_switchInfoTable, 3,  { 3, 1, 11 }},
{SWEXPANSIONSLOT2,  ASN_INTEGER,  RONLY,   var_switchInfoTable, 3,  { 3, 1, 12 }},
{SWSERVICETAG,  ASN_OCTET_STR,  RONLY,   var_switchInfoTable, 3,  { 3, 1, 13 }},
{SWMODELNUMBER,  ASN_OCTET_STR,  RONLY,   var_switchInfoTable, 3,  { 3, 1, 14 }},
{SWEPLDVER, ASN_OCTET_STR, RONLY, var_switchInfoTable, 3, {3, 1, 15}},

#if (SYS_CPNT_MODULE_WITH_CPU == TRUE)
{SWEXPECTEDMODULEOPCODEVER, ASN_OCTET_STR, RONLY, var_switchInfoTable, 3, {3, 1, 16}},
#endif
};

void init_switchInfoTable(void)
{
  init_PrivateMIBNodeRootOIDbySwitchBoardID(switchInfoTable_variables_oid);
  REGISTER_MIB("switchInfoTable", switchInfoTable_variables, variable3,
               switchInfoTable_variables_oid);
}



/********************************************
 ********* init_switchIndivPowerTable********
 ********************************************
 */

oid             switchIndivPowerTable_variables_oid[] =
    { SYS_ADPT_PRIVATEMIB_OID, 1, 1 };

struct variable3 switchIndivPowerTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    {SWINDIVPOWERUNITINDEX, ASN_INTEGER, RONLY, var_switchIndivPowerTable,
     3, {6, 1, 1}},
    {SWINDIVPOWERINDEX, ASN_INTEGER, RONLY, var_switchIndivPowerTable, 3,
     {6, 1, 2}},
#endif
    {SWINDIVPOWERSTATUS, ASN_INTEGER, RONLY, var_switchIndivPowerTable, 3,
     {6, 1, 3}},
};

/** Initializes the switchIndivPowerTable module */
void
init_switchIndivPowerTable(void)
{
    /* register ourselves with the agent to handle our mib tree*/
    init_PrivateMIBNodeRootOIDbySwitchBoardID(switchIndivPowerTable_variables_oid);
    REGISTER_MIB("switchIndivPowerTable", switchIndivPowerTable_variables,
                 variable3, switchIndivPowerTable_variables_oid);
}


/********************************************
 ********* init_switchAlarmInputTable********
 ********************************************
 */
#if (SYS_CPNT_ALARM_INPUT_DETECT == TRUE)
oid switchAlarmInputTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,1 };
/* variable3 switchAlarmInputTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */
struct variable3 switchAlarmInputTable_variables[] =
{
    /* magic number, variable type, ro/rw, callback fn, L, oidsuffix
     *     (L = length of the oidsuffix)
     */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_swAlarmUnitIndex, ASN_INTEGER, RONLY, var_switchAlarmInputTable, 3, { 19, 1, 1 }},
#endif  /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_swAlarmInputType, ASN_INTEGER, RONLY, var_switchAlarmInputTable, 3, { 19, 1, 2 }},
#endif  /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

    { LEAF_swAlarmInputStatus, ASN_INTEGER, RONLY, var_switchAlarmInputTable, 3, { 19, 1, 3 }},
};

void init_switchAlarmInputTable(void)
{
    /* Register ourselves with the agent to handle our MIB tree
     */
    REGISTER_MIB("switchAlarmInputTable", switchAlarmInputTable_variables, variable3,
                 switchAlarmInputTable_variables_oid);
}
#endif

/********************************************
 ********* init_switchFanTable***************
 ********************************************
 */
#if (SYS_CPNT_STKTPLG_FAN_DETECT == TRUE)

oid             switchFanTable_variables_oid[] =
    { SYS_ADPT_PRIVATEMIB_OID, 1, 1 };

struct variable3 switchFanTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    {SWITCHUNITINDEX, ASN_INTEGER, RONLY, var_switchFanTable, 3,
     {9, 1, 1}},
    {SWITCHFANINDEX, ASN_INTEGER, RONLY, var_switchFanTable, 3, {9, 1, 2}},
#endif
    {SWITCHFANSTATUS, ASN_INTEGER, RONLY, var_switchFanTable, 3,
     {9, 1, 3}},

#if 0 /* not allow user to set and failure count is not support now */
    {SWITCHFANADMINSPEED, ASN_INTEGER, RWRITE, var_switchFanTable, 3,
     {9, 1, 4}},
    {SWITCHFANFAILURECOUNT, ASN_INTEGER, RONLY, var_switchFanTable, 3,
     {9, 1, 5}},
#endif /* #if 0 */

    {SWITCHFANOPERSPEED, ASN_INTEGER, RONLY, var_switchFanTable, 3,
     {9, 1, 6}},
};


/** Initializes the switchFanTable module */
void
init_switchFanTable(void)
{
    /* register ourselves with the agent to handle our mib tree*/
    init_PrivateMIBNodeRootOIDbySwitchBoardID(switchFanTable_variables_oid);
    REGISTER_MIB("switchFanTable", switchFanTable_variables, variable3,
                 switchFanTable_variables_oid);
}
#endif




#if (SYS_CPNT_THERMAL_DETECT == TRUE)

/********************************************
 ***********switchThermalTempTable***********
 ********************************************
 */
oid  switchThermalTempTable_variables_oid[] =
    { SYS_ADPT_PRIVATEMIB_OID, 1, 1};

struct variable3 switchThermalTempTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    {SWITCHTHERMALTEMPUNITINDEX, ASN_INTEGER, RONLY,
     var_switchThermalTempTable, 3, {11, 1, 1}},
    {SWITCHTHERMALTEMPTHERMALINDEX, ASN_INTEGER, RONLY,
     var_switchThermalTempTable, 3, {11, 1, 2}},
#endif
    {SWITCHTHERMALTEMPVALUE, ASN_INTEGER, RONLY,
     var_switchThermalTempTable, 3, {11, 1, 3}},
};

/** Initializes the switchThermalTempTable module */
void
init_switchThermalTempTable(void)
{
    /* register ourselves with the agent to handle our mib tree*/
    init_PrivateMIBNodeRootOIDbySwitchBoardID(switchThermalTempTable_variables_oid);
    REGISTER_MIB("switchThermalTempTable",
                 switchThermalTempTable_variables, variable3,
                 switchThermalTempTable_variables_oid);
}

/********************************************
 ***********switchThermalActionTable***********
 ********************************************
 */

oid             switchThermalActionTable_variables_oid[] =
    { SYS_ADPT_PRIVATEMIB_OID, 1, 1 };

struct variable3 switchThermalActionTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    {SWITCHTHERMALACTIONUNITINDEX, ASN_INTEGER, RONLY,
     var_switchThermalActionTable, 3, {12, 1, 1}},
    {SWITCHTHERMALACTIONTHERMALINDEX, ASN_INTEGER, RONLY,
     var_switchThermalActionTable, 3, {12, 1, 2}},
    {SWITCHTHERMALACTIONINDEX, ASN_INTEGER, RONLY,
     var_switchThermalActionTable, 3, {12, 1, 3}},
#endif
    {SWITCHTHERMALACTIONRISINGTHRESHOLD, ASN_INTEGER, RWRITE,
     var_switchThermalActionTable, 3, {12, 1, 4}},
    {SWITCHTHERMALACTIONFALLINGTHRESHOLD, ASN_INTEGER, RWRITE,
     var_switchThermalActionTable, 3, {12, 1, 5}},
    {SWITCHTHERMALACTIONACTION,ASN_OCTET_STR, RWRITE, var_switchThermalActionTable, 3,
     {12, 1, 6}},
    {SWITCHTHERMALACTIONSTATUS, ASN_INTEGER, RWRITE,
     var_switchThermalActionTable, 3, {12, 1, 7}},
};


/** Initializes the switchThermalActionTable module */
void
init_switchThermalActionTable(void)
{

    /*
     * register ourselves with the agent to handle our mib tree
     */
    init_PrivateMIBNodeRootOIDbySwitchBoardID(switchThermalActionTable_variables_oid);
    REGISTER_MIB("switchThermalActionTable",
                 switchThermalActionTable_variables, variable3,
                 switchThermalActionTable_variables_oid);

    /*
     * place any other initialization junk you need here
     */
}

#endif

#if (SYS_CPNT_MODULE_WITH_CPU == TRUE)
/********************************************
 ***********witchModuleInfoTable***********
 ********************************************
 */
oid             switchModuleInfoTable_variables_oid[] =
    { SYS_ADPT_PRIVATEMIB_OID, 1, 1 };

struct variable3 switchModuleInfoTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    {SWMODULEUNITINDEX, ASN_INTEGER, RONLY, var_switchModuleInfoTable, 3,
     {13, 1, 1}},
    {SWMODULEMODULEINDEX, ASN_INTEGER, RONLY, var_switchModuleInfoTable, 3,
     {13, 1, 2}},
#endif
    {SWMODULEHARDWAREVER, ASN_OCTET_STR, RONLY, var_switchModuleInfoTable,
     3, {13, 1, 3}},
    {SWMODULEMICROCODEVER, ASN_OCTET_STR, RONLY, var_switchModuleInfoTable,
     3, {13, 1, 4}},
    {SWMODULELOADERVER, ASN_OCTET_STR, RONLY, var_switchModuleInfoTable, 3,
     {13, 1, 5}},
    {SWMODULEBOOTROMVER, ASN_OCTET_STR, RONLY, var_switchModuleInfoTable,
     3, {13, 1, 6}},
    {SWMODULEOPCODEVER, ASN_OCTET_STR, RONLY, var_switchModuleInfoTable, 3,
     {13, 1, 7}},
    {SWMODULEPORTNUMBER, ASN_INTEGER, RONLY, var_switchModuleInfoTable, 3,
     {13, 1, 8}},
    {SWMODULESERIALNUMBER, ASN_OCTET_STR, RONLY, var_switchModuleInfoTable,
     3, {13, 1, 9}},
    {SWMODULETYPE, ASN_INTEGER, RONLY, var_switchModuleInfoTable, 3,
     {13, 1, 10}},
    {SWMODULEMODELNUMBER, ASN_OCTET_STR, RONLY, var_switchModuleInfoTable,
     3, {13, 1, 11}},
    {SWMODULEEPLDVER, ASN_OCTET_STR, RONLY, var_switchModuleInfoTable, 3,
     {13, 1, 12}},
    {SWMODULEDESCR, ASN_OCTET_STR, RONLY, var_switchModuleInfoTable, 3,
     {13, 1, 13}},
};

 /** Initializes the switchModuleInfoTable module */
void
init_switchModuleInfoTable(void)
{
    /*
     * register ourselves with the agent to handle our mib tree
     */
    init_PrivateMIBNodeRootOIDbySwitchBoardID(switchModuleInfoTable_variables_oid);
    REGISTER_MIB("switchModuleInfoTable", switchModuleInfoTable_variables,
                 variable3, switchModuleInfoTable_variables_oid);

    /*
     * place any other initialization junk you need here
     */
}

#endif/*end of #if (SYS_CPNT_MODULE_WITH_CPU == TRUE)*/

/********************************************
 ******************portTable*****************
 ********************************************
 */
oid portTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,2 };


struct variable3 portTable_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */

{ LEAF_portName,  ASN_OCTET_STR,  RWRITE,  var_portTable, 3,  { 1, 1, 2 }},
{ LEAF_portType,  ASN_INTEGER,  RONLY,   var_portTable, 3,  { 1, 1, 3 }},
{ LEAF_portSpeedDpxCfg,  ASN_INTEGER,  RWRITE,  var_portTable, 3,  { 1, 1, 4 }},
{ LEAF_portFlowCtrlCfg,  ASN_INTEGER,  RWRITE,  var_portTable, 3,  { 1, 1, 5 }},
{ LEAF_portCapabilities, ASN_OCTET_STR ,  RWRITE,  var_portTable, 3,  { 1, 1, 6 }},
{ LEAF_portAutonegotiation,  ASN_INTEGER,  RWRITE,  var_portTable, 3,  { 1, 1, 7 }},
{ LEAF_portSpeedDpxStatus,  ASN_INTEGER,  RONLY,   var_portTable, 3,  { 1, 1, 8 }},
{ LEAF_portFlowCtrlStatus,  ASN_INTEGER,  RONLY,   var_portTable, 3,  { 1, 1, 9 }},
{ LEAF_portTrunkIndex,  ASN_INTEGER,  RONLY,   var_portTable, 3,  { 1, 1, 10 }},

#ifdef VS2512A
{ LEAF_portEthernetType,  ASN_INTEGER,  RONLY,   var_portTable, 3,  { 1, 1, 11 }},
#endif /* #ifdef VS2512A */

#if (SYS_CPNT_COMBO_PORT_FORCE_MODE == TRUE)
{ LEAF_portComboForcedMode,  ASN_INTEGER,  RWRITE,  var_portTable, 3,  { 1, 1, 12 }},
#endif /* #if (SYS_CPNT_COMBO_PORT_FORCE_MODE == TRUE) */

#if (SYS_CPNT_SWCTRL_MDIX_CONFIG == TRUE)
{ LEAF_portMdixMode, ASN_INTEGER, RWRITE, var_portTable, 3, {1, 1, 14}},
#endif /* #if (SYS_CPNT_SWCTRL_MDIX_CONFIG == TRUE) */

#if (SYS_CPNT_SWCTRL_MTU_CONFIG_MODE == SYS_CPNT_SWCTRL_MTU_PER_PORT)
{ LEAF_portMtu,  ASN_GAUGE,  RWRITE,  var_portTable, 3,  { 1, 1, 16 }},
#endif /* #if (SYS_CPNT_SWCTRL_MTU_CONFIG_MODE == SYS_CPNT_SWCTRL_MTU_PER_PORT) */

#if (SYS_CPNT_AMTR == TRUE)
#if (SYS_CPNT_AMTR_PORT_MAC_LEARNING == TRUE)
{ LEAF_portMacAddrLearningStatus,   ASN_INTEGER, RWRITE,  var_portTable, 3,  { 1, 1, 17 }},
#endif
{ LEAF_portMacAddrLearningCount, ASN_COUNTER, RONLY,  var_portTable,  3,  { 1, 1, 18 }},
#endif /* #if (SYS_CPNT_AMTR == TRUE) */
};

/** Initializes the portTable module */
void
init_portTable(void)
{
    /* register ourselves with the agent to handle our mib tree */
    init_PrivateMIBNodeRootOIDbySwitchBoardID(portTable_variables_oid);
    REGISTER_MIB("portTable", portTable_variables, variable3,
                 portTable_variables_oid);
}

/***** cable diagnostics *****/
#if (SYS_CPNT_SWCTRL_CABLE_DIAG == TRUE)
void
init_cableDiagCtlAction(void)
{
    static oid cableDiagCtlAction_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,2,3,1,0 };

    DEBUGMSGTL(("cableDiagCtlAction", "Initializing\n"));

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("cableDiagCtlAction",
                               do_cableDiagCtlAction,
                               cableDiagCtlAction_oid,
                               OID_LENGTH(cableDiagCtlAction_oid),
                               HANDLER_CAN_RWRITE));
}

oid cableDiagResultTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,2,3 };

struct variable3 cableDiagResultTable_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
{LEAF_cableDiagResultIfIndex,  ASN_INTEGER,  RONLY,   var_cableDiagResultTable, 3,  { 2, 1, 1 }},
#endif

{LEAF_cableDiagResultStatusPairA,  ASN_INTEGER,  RONLY,   var_cableDiagResultTable, 3,  { 2, 1, 2 }},
{LEAF_cableDiagResultStatusPairB,  ASN_INTEGER,  RONLY,   var_cableDiagResultTable, 3,  { 2, 1, 3 }},

#if (SYS_CPNT_SWCTRL_CABLE_DIAG_CHIP == SYS_CPNT_SWCTRL_CABLE_DIAG_BROADCOM)
{LEAF_cableDiagResultStatusPairC,  ASN_INTEGER,  RONLY,   var_cableDiagResultTable, 3,  { 2, 1, 4 }},
{LEAF_cableDiagResultStatusPairD,  ASN_INTEGER,  RONLY,   var_cableDiagResultTable, 3,  { 2, 1, 5 }},
#endif /* #if (SYS_CPNT_SWCTRL_CABLE_DIAG_CHIP == SYS_CPNT_SWCTRL_CABLE_DIAG_BROADCOM) */

{LEAF_cableDiagResultDistancePairA,  ASN_INTEGER,  RONLY,   var_cableDiagResultTable, 3,  { 2, 1, 6 }},
{LEAF_cableDiagResultDistancePairB,  ASN_INTEGER,  RONLY,   var_cableDiagResultTable, 3,  { 2, 1, 7 }},

#if (SYS_CPNT_SWCTRL_CABLE_DIAG_CHIP == SYS_CPNT_SWCTRL_CABLE_DIAG_BROADCOM)
{LEAF_cableDiagResultDistancePairC,  ASN_INTEGER,  RONLY,   var_cableDiagResultTable, 3,  { 2, 1, 8 }},
{LEAF_cableDiagResultDistancePairD,  ASN_INTEGER,  RONLY,   var_cableDiagResultTable, 3,  { 2, 1, 9 }},
{LEAF_cableDiagResultDistanceAccuracy,  ASN_INTEGER,  RONLY,   var_cableDiagResultTable, 3,  { 2, 1, 10 }},
#endif /* #if (SYS_CPNT_SWCTRL_CABLE_DIAG_CHIP == SYS_CPNT_SWCTRL_CABLE_DIAG_BROADCOM) */

{LEAF_cableDiagResultTime,  ASN_OCTET_STR,  RONLY,   var_cableDiagResultTable, 3,  { 2, 1, 11 }},
};

/** Initializes the cableDiagResultTable module */
void
init_cableDiagResultTable(void)
{
    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("cableDiagResultTable", cableDiagResultTable_variables, variable3,
                 cableDiagResultTable_variables_oid);
}

#endif /* #if (SYS_CPNT_SWCTRL_CABLE_DIAG == TRUE) */


#if (SYS_CPNT_INTERNAL_LOOPBACK_TEST == TRUE)
void
init_loopInternalCtlAction(void)
{
    static oid loopInternalCtlAction_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,2,4,1,0 };

  DEBUGMSGTL(("loopInternalCtlAction", "Initializing\n"));

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("loopInternalCtlAction",
                               do_loopInternalCtlAction,
                               loopInternalCtlAction_oid,
                               OID_LENGTH(loopInternalCtlAction_oid),
                               HANDLER_CAN_RWRITE));
}

oid loopInternalResultTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,2,4 };
/*
 * variable3 loopInternalResultTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */
struct variable3 loopInternalResultTable_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
{LEAF_loopInternalResultIfIndex,  ASN_INTEGER,  RONLY,   var_loopInternalResultTable, 3,  { 2, 1, 1 }},
#endif

{LEAF_loopInternalResultStatus,  ASN_INTEGER,  RONLY,   var_loopInternalResultTable, 3,  { 2, 1, 2 }},
{LEAF_loopInternalResultTime,  ASN_OCTET_STR,  RONLY,   var_loopInternalResultTable, 3,  { 2, 1, 3 }},
};

/** Initializes the loopInternalResultTable module */
void
init_loopInternalResultTable(void)
{
    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("loopInternalResultTable", loopInternalResultTable_variables, variable3,
                 loopInternalResultTable_variables_oid);
}
#endif /* end of #if (SYS_CPNT_INTERNAL_LOOPBACK_TEST == TRUE) */


/***** port utilization *****/
oid portUtilTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,2 };
/*
 * variable3 portUtilTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */
struct variable3 portUtilTable_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
{LEAF_portUtilIfIndex,  ASN_INTEGER,  RONLY,   var_portUtilTable, 3,  { 6, 1, 1 }},
#endif

{LEAF_portInOctetRate,  ASN_COUNTER64,  RONLY,   var_portUtilTable, 3,  { 6, 1, 2 }},
{LEAF_portInPacketRate,  ASN_COUNTER64,  RONLY,   var_portUtilTable, 3,  { 6, 1, 3 }},
{LEAF_portInUtil,  ASN_INTEGER,  RONLY,   var_portUtilTable, 3,  { 6, 1, 4 }},
{LEAF_portOutOctetRate,  ASN_COUNTER64,  RONLY,   var_portUtilTable, 3,  { 6, 1, 5 }},
{LEAF_portOutPacketRate,  ASN_COUNTER64,  RONLY,   var_portUtilTable, 3,  { 6, 1, 6 }},
{LEAF_portOutUtil,  ASN_INTEGER,  RONLY,   var_portUtilTable, 3,  { 6, 1, 7 }},
};

/** Initializes the portUtilTable module */
void
init_portUtilTable(void)
{
    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("portUtilTable", portUtilTable_variables, variable3,
                 portUtilTable_variables_oid);
}


#if (SYS_CPNT_NMTR_HISTORY == TRUE)
/***** portHistControlTable *****/
oid portHistControlTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,2,8 };

struct variable3 portHistControlTable_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
{LEAF_portHistControlIndex,  ASN_INTEGER,  RONLY,   var_portHistControlTable, 3,  { 1, 1, 1 }},
#endif

{LEAF_portHistControlName,  ASN_OCTET_STR,  RWRITE,   var_portHistControlTable, 3,  { 1, 1, 2 }},
{LEAF_portHistControlDataSource,  ASN_INTEGER,  RWRITE,   var_portHistControlTable, 3,  { 1, 1, 3 }},
{LEAF_portHistControlInterval,  ASN_INTEGER,  RWRITE,   var_portHistControlTable, 3,  { 1, 1, 4 }},
{LEAF_portHistControlBucketsRequested,  ASN_INTEGER,  RWRITE,   var_portHistControlTable, 3,  { 1, 1, 5 }},
{LEAF_portHistControlBucketsGranted,  ASN_INTEGER,  RONLY,   var_portHistControlTable, 3,  { 1, 1, 6 }},
{LEAF_portHistControlStatus,  ASN_INTEGER,  RWRITE,   var_portHistControlTable, 3,  { 1, 1, 7 }},
};

/** Initializes the portHistControlTable module */
void
init_portHistControlTable()
{
    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("portHistControlTable", portHistControlTable_variables, variable3,
                 portHistControlTable_variables_oid);
}

/***** portHistCurrentTable *****/
oid portHistCurrentTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,2,8 };

struct variable3 portHistCurrentTable_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
{LEAF_portHistCurrentIndex,  ASN_INTEGER,  RONLY,   var_portHistCurrentTable, 3,  { 2, 1, 1 }},
#endif

{LEAF_portHistCurrentSampleIndex,  ASN_INTEGER,  RONLY,   var_portHistCurrentTable, 3,  { 2, 1, 2 }},
{LEAF_portHistCurrentIntervalStart,  ASN_TIMETICKS,  RONLY,   var_portHistCurrentTable, 3,  { 2, 1, 3 }},
{LEAF_portHistCurrentInOctets,  ASN_COUNTER64,  RONLY,   var_portHistCurrentTable, 3,  { 2, 1, 4 }},
{LEAF_portHistCurrentInUcastPkts,  ASN_COUNTER64,  RONLY,   var_portHistCurrentTable, 3,  { 2, 1, 5 }},
{LEAF_portHistCurrentInMulticastPkts,  ASN_COUNTER64,  RONLY,   var_portHistCurrentTable, 3,  { 2, 1, 6 }},
{LEAF_portHistCurrentInBroadcastPkts,  ASN_COUNTER64,  RONLY,   var_portHistCurrentTable, 3,  { 2, 1, 7 }},
{LEAF_portHistCurrentInDiscards,  ASN_COUNTER64,  RONLY,   var_portHistCurrentTable, 3,  { 2, 1, 8 }},
{LEAF_portHistCurrentInErrors,  ASN_COUNTER64,  RONLY,   var_portHistCurrentTable, 3,  { 2, 1, 9 }},
{LEAF_portHistCurrentInUnknownProtos,  ASN_COUNTER64,  RONLY,   var_portHistCurrentTable, 3,  { 2, 1, 10 }},
{LEAF_portHistCurrentOutOctets,  ASN_COUNTER64,  RONLY,   var_portHistCurrentTable, 3,  { 2, 1, 11 }},
{LEAF_portHistCurrentOutUcastPkts,  ASN_COUNTER64,  RONLY,   var_portHistCurrentTable, 3,  { 2, 1, 12 }},
{LEAF_portHistCurrentOutMulticastPkts,  ASN_COUNTER64,  RONLY,   var_portHistCurrentTable, 3,  { 2, 1, 13 }},
{LEAF_portHistCurrentOutBroadcastPkts,  ASN_COUNTER64,  RONLY,   var_portHistCurrentTable, 3,  { 2, 1, 14 }},
{LEAF_portHistCurrentOutDiscards,  ASN_COUNTER64,  RONLY,   var_portHistCurrentTable, 3,  { 2, 1, 15 }},
{LEAF_portHistCurrentOutErrors,  ASN_COUNTER64,  RONLY,   var_portHistCurrentTable, 3,  { 2, 1, 16 }},
{LEAF_portHistCurrentInUtilization,  ASN_INTEGER,  RONLY,   var_portHistCurrentTable, 3,  { 2, 1, 17 }},
{LEAF_portHistCurrentOutUtilization,  ASN_INTEGER,  RONLY,   var_portHistCurrentTable, 3,  { 2, 1, 18 }},
};

/** Initializes the portHistCurrentTable module */
void
init_portHistCurrentTable()
{
    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("portHistCurrentTable", portHistCurrentTable_variables, variable3,
                 portHistCurrentTable_variables_oid);
}

/***** portHistPreviousTable *****/
oid portHistPreviousTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,2,8 };

struct variable3 portHistPreviousTable_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
{LEAF_portHistPreviousIndex,  ASN_INTEGER,  RONLY,   var_portHistPreviousTable, 3,  { 3, 1, 1 }},
{LEAF_portHistPreviousSampleIndex,  ASN_INTEGER,  RONLY,   var_portHistPreviousTable, 3,  { 3, 1, 2 }},
#endif

{LEAF_portHistPreviousIntervalStart,  ASN_TIMETICKS,  RONLY,   var_portHistPreviousTable, 3,  { 3, 1, 3 }},
{LEAF_portHistPreviousInOctets,  ASN_COUNTER64,  RONLY,   var_portHistPreviousTable, 3,  { 3, 1, 4 }},
{LEAF_portHistPreviousInUcastPkts,  ASN_COUNTER64,  RONLY,   var_portHistPreviousTable, 3,  { 3, 1, 5 }},
{LEAF_portHistPreviousInMulticastPkts,  ASN_COUNTER64,  RONLY,   var_portHistPreviousTable, 3,  { 3, 1, 6 }},
{LEAF_portHistPreviousInBroadcastPkts,  ASN_COUNTER64,  RONLY,   var_portHistPreviousTable, 3,  { 3, 1, 7 }},
{LEAF_portHistPreviousInDiscards,  ASN_COUNTER64,  RONLY,   var_portHistPreviousTable, 3,  { 3, 1, 8 }},
{LEAF_portHistPreviousInErrors,  ASN_COUNTER64,  RONLY,   var_portHistPreviousTable, 3,  { 3, 1, 9 }},
{LEAF_portHistPreviousInUnknownProtos,  ASN_COUNTER64,  RONLY,   var_portHistPreviousTable, 3,  { 3, 1, 10 }},
{LEAF_portHistPreviousOutOctets,  ASN_COUNTER64,  RONLY,   var_portHistPreviousTable, 3,  { 3, 1, 11 }},
{LEAF_portHistPreviousOutUcastPkts,  ASN_COUNTER64,  RONLY,   var_portHistPreviousTable, 3,  { 3, 1, 12 }},
{LEAF_portHistPreviousOutMulticastPkts,  ASN_COUNTER64,  RONLY,   var_portHistPreviousTable, 3,  { 3, 1, 13 }},
{LEAF_portHistPreviousOutBroadcastPkts,  ASN_COUNTER64,  RONLY,   var_portHistPreviousTable, 3,  { 3, 1, 14 }},
{LEAF_portHistPreviousOutDiscards,  ASN_COUNTER64,  RONLY,   var_portHistPreviousTable, 3,  { 3, 1, 15 }},
{LEAF_portHistPreviousOutErrors,  ASN_COUNTER64,  RONLY,   var_portHistPreviousTable, 3,  { 3, 1, 16 }},
{LEAF_portHistPreviousInUtilization,  ASN_INTEGER,  RONLY,   var_portHistPreviousTable, 3,  { 3, 1, 17 }},
{LEAF_portHistPreviousOutUtilization,  ASN_INTEGER,  RONLY,   var_portHistPreviousTable, 3,  { 3, 1, 18 }},
};

/** Initializes the portHistPreviousTable module */
void
init_portHistPreviousTable()
{
    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("portHistPreviousTable", portHistPreviousTable_variables, variable3,
                 portHistPreviousTable_variables_oid);
}
#endif /* (SYS_CPNT_NMTR_HISTORY == TRUE) */


#if (SYS_CPNT_VLAN_TRUNKING == TRUE)
oid portVlanTrunkingTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1, 2 };
/*
 * variable3 portVlanTrunkingTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */
struct variable3 portVlanTrunkingTable_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
{LEAF_portVlanTrunkingIfIndex, ASN_INTEGER,  RONLY,   var_portVlanTrunkingTable, 3, {7, 1, 1}},
#endif

{LEAF_portVlanTrunkingStatus,  ASN_INTEGER,  RWRITE,  var_portVlanTrunkingTable, 3, {7, 1, 2}},
};

/** Initializes the portVlanTrunkingTable module */
void
init_portVlanTrunkingTable(void)
{
    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("portVlanTrunkingTable", portVlanTrunkingTable_variables, variable3,
                 portVlanTrunkingTable_variables_oid);
}
#endif /* #if (SYS_CPNT_VLAN_TRUNKING == TRUE) */

oid portMediaInfoTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,2 };

/* variable3 portMediaInfoTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */
struct variable3 portMediaInfoTable_variables[] =
{
    /* magic number, variable type, ro/rw, callback fn, L, oidsuffix
     *     (L = length of the oidsuffix)
     */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_portMediaInfoIfIndex, ASN_INTEGER, RONLY, var_portMediaInfoTable, 3, { 10, 1, 1 }},
#endif  /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

    { LEAF_portMediaInfoConnectorType, ASN_OCTET_STR, RONLY, var_portMediaInfoTable, 3, { 10, 1, 2 }},
    { LEAF_portMediaInfoFiberType, ASN_OCTET_STR, RONLY, var_portMediaInfoTable, 3, { 10, 1, 3 }},
    { LEAF_portMediaInfoEthComplianceCodes, ASN_OCTET_STR, RONLY, var_portMediaInfoTable, 3, { 10, 1, 4 }},
    { LEAF_portMediaInfoBaudRate, ASN_OCTET_STR, RONLY, var_portMediaInfoTable, 3, { 10, 1, 5 }},
    { LEAF_portMediaInfoVendorOUI, ASN_OCTET_STR, RONLY, var_portMediaInfoTable, 3, { 10, 1, 6 }},
    { LEAF_portMediaInfoVendorName, ASN_OCTET_STR, RONLY, var_portMediaInfoTable, 3, { 10, 1, 7 }},
    { LEAF_portMediaInfoPartNumber, ASN_OCTET_STR, RONLY, var_portMediaInfoTable, 3, { 10, 1, 8 }},
    { LEAF_portMediaInfoRevision, ASN_OCTET_STR, RONLY, var_portMediaInfoTable, 3, { 10, 1, 9 }},
    { LEAF_portMediaInfoSerialNumber, ASN_OCTET_STR, RONLY, var_portMediaInfoTable, 3, { 10, 1, 10 }},
    { LEAF_portMediaInfoDateCode, ASN_OCTET_STR, RONLY, var_portMediaInfoTable, 3, { 10, 1, 11 }},
};

void init_portMediaInfoTable(void)
{
    /* Register ourselves with the agent to handle our MIB tree
     */
    REGISTER_MIB("portMediaInfoTable", portMediaInfoTable_variables, variable3,
                 portMediaInfoTable_variables_oid);
}
oid portOpticalMonitoringInfoTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,2 };

/* variable3 portOpticalMonitoringInfoTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */
struct variable3 portOpticalMonitoringInfoTable_variables[] =
{
    /* magic number, variable type, ro/rw, callback fn, L, oidsuffix
     *     (L = length of the oidsuffix)
     */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_portOpticalMonitoringInfoIfIndex, ASN_INTEGER, RONLY, var_portOpticalMonitoringInfoTable, 3, { 11, 1, 1 }},
#endif  /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

    { LEAF_portOpticalMonitoringInfoTemperature, ASN_OCTET_STR, RONLY, var_portOpticalMonitoringInfoTable, 3, { 11, 1, 2 }},
    { LEAF_portOpticalMonitoringInfoVcc, ASN_OCTET_STR, RONLY, var_portOpticalMonitoringInfoTable, 3, { 11, 1, 3 }},
    { LEAF_portOpticalMonitoringInfoTxBiasCurrent, ASN_OCTET_STR, RONLY, var_portOpticalMonitoringInfoTable, 3, { 11, 1, 4 }},
    { LEAF_portOpticalMonitoringInfoTxPower, ASN_OCTET_STR, RONLY, var_portOpticalMonitoringInfoTable, 3, { 11, 1, 5 }},
    { LEAF_portOpticalMonitoringInfoRxPower, ASN_OCTET_STR, RONLY, var_portOpticalMonitoringInfoTable, 3, { 11, 1, 6 }},
};

void init_portOpticalMonitoringInfoTable(void)
{
    /* Register ourselves with the agent to handle our MIB tree
     */
    REGISTER_MIB("portOpticalMonitoringInfoTable", portOpticalMonitoringInfoTable_variables, variable3,
                 portOpticalMonitoringInfoTable_variables_oid);
}

oid portTransceiverThresholdInfoTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,2 };

/* variable3 portTransceiverThresholdInfoTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */
struct variable3 portTransceiverThresholdInfoTable_variables[] =
{
    /* magic number, variable type, ro/rw, callback fn, L, oidsuffix
     *     (L = length of the oidsuffix)
     */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_portTransceiverThresholdInfoIfIndex, ASN_INTEGER, RONLY, var_portTransceiverThresholdInfoTable, 3, { 12, 1, 1 }},
#endif  /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

    { LEAF_portTransceiverThresholdInfoTemperatureLowAlarm, ASN_INTEGER, RWRITE, var_portTransceiverThresholdInfoTable, 3, { 12, 1, 2 }},
    { LEAF_portTransceiverThresholdInfoTemperatureLowWarn, ASN_INTEGER, RWRITE, var_portTransceiverThresholdInfoTable, 3, { 12, 1, 3 }},
    { LEAF_portTransceiverThresholdInfoTemperatureHighWarn, ASN_INTEGER, RWRITE, var_portTransceiverThresholdInfoTable, 3, { 12, 1, 4 }},
    { LEAF_portTransceiverThresholdInfoTemperatureHighAlarm, ASN_INTEGER, RWRITE, var_portTransceiverThresholdInfoTable, 3, { 12, 1, 5 }},
    { LEAF_portTransceiverThresholdInfoVccLowAlarm, ASN_INTEGER, RWRITE, var_portTransceiverThresholdInfoTable, 3, { 12, 1, 6 }},
    { LEAF_portTransceiverThresholdInfoVccLowWarn, ASN_INTEGER, RWRITE, var_portTransceiverThresholdInfoTable, 3, { 12, 1, 7 }},
    { LEAF_portTransceiverThresholdInfoVccHighWarn, ASN_INTEGER, RWRITE, var_portTransceiverThresholdInfoTable, 3, { 12, 1, 8 }},
    { LEAF_portTransceiverThresholdInfoVccHighAlarm, ASN_INTEGER, RWRITE, var_portTransceiverThresholdInfoTable, 3, { 12, 1, 9 }},
    { LEAF_portTransceiverThresholdInfoTxBiasCurrentLowAlarm, ASN_INTEGER, RWRITE, var_portTransceiverThresholdInfoTable, 3, { 12, 1, 10 }},
    { LEAF_portTransceiverThresholdInfoTxBiasCurrentLowWarn, ASN_INTEGER, RWRITE, var_portTransceiverThresholdInfoTable, 3, { 12, 1, 11 }},
    { LEAF_portTransceiverThresholdInfoTxBiasCurrentHighWarn, ASN_INTEGER, RWRITE, var_portTransceiverThresholdInfoTable, 3, { 12, 1, 12 }},
    { LEAF_portTransceiverThresholdInfoTxBiasCurrentHighAlarm, ASN_INTEGER, RWRITE, var_portTransceiverThresholdInfoTable, 3, { 12, 1, 13 }},
    { LEAF_portTransceiverThresholdInfoTxPowerLowAlarm, ASN_INTEGER, RWRITE, var_portTransceiverThresholdInfoTable, 3, { 12, 1, 14 }},
    { LEAF_portTransceiverThresholdInfoTxPowerLowWarn, ASN_INTEGER, RWRITE, var_portTransceiverThresholdInfoTable, 3, { 12, 1, 15 }},
    { LEAF_portTransceiverThresholdInfoTxPowerHighWarn, ASN_INTEGER, RWRITE, var_portTransceiverThresholdInfoTable, 3, { 12, 1, 16 }},
    { LEAF_portTransceiverThresholdInfoTxPowerHighAlarm, ASN_INTEGER, RWRITE, var_portTransceiverThresholdInfoTable, 3, { 12, 1, 17 }},
    { LEAF_portTransceiverThresholdInfoRxPowerLowAlarm, ASN_INTEGER, RWRITE, var_portTransceiverThresholdInfoTable, 3, { 12, 1, 18 }},
    { LEAF_portTransceiverThresholdInfoRxPowerLowWarn, ASN_INTEGER, RWRITE, var_portTransceiverThresholdInfoTable, 3, { 12, 1, 19 }},
    { LEAF_portTransceiverThresholdInfoRxPowerHighWarn, ASN_INTEGER, RWRITE, var_portTransceiverThresholdInfoTable, 3, { 12, 1, 20 }},
    { LEAF_portTransceiverThresholdInfoRxPowerHighAlarm, ASN_INTEGER, RWRITE, var_portTransceiverThresholdInfoTable, 3, { 12, 1, 21 }},
    { LEAF_portTransceiverThresholdAutoMode, ASN_INTEGER, RWRITE, var_portTransceiverThresholdInfoTable, 3, { 12, 1, 22 }},
};

void init_portTransceiverThresholdInfoTable(void)
{
    /* Register ourselves with the agent to handle our MIB tree
     */
    REGISTER_MIB("portTransceiverThresholdInfoTable",
portTransceiverThresholdInfoTable_variables, variable3,
                 portTransceiverThresholdInfoTable_variables_oid);
}

/********************************************
 ******************trunkMgt******************
 ********************************************
 */
void
init_trunkMgt(void)
{
    static oid trunkValidNumber_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,3,2, 0 };
    static oid trunkMaxId_oid[] = {SYS_ADPT_PRIVATEMIB_OID,1,3,1, 0 };
#if (SYS_CPNT_TRUNK_BALANCE_MODE == TRUE)
    static oid trunkBalanceMode_oid[] = {SYS_ADPT_PRIVATEMIB_OID,1,3,4, 0 };
#endif

    init_PrivateMIBNodeRootOIDbySwitchBoardID(trunkValidNumber_oid);
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("trunkValidNumber",
                                         get_trunkValidNumber,
                                         trunkValidNumber_oid,
                                         OID_LENGTH(trunkValidNumber_oid),
                                         HANDLER_CAN_RONLY));
    init_PrivateMIBNodeRootOIDbySwitchBoardID(trunkMaxId_oid);
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("trunkMaxId",
                                         get_trunkMaxId,
                                         trunkMaxId_oid,
                                         OID_LENGTH(trunkMaxId_oid),
                                         HANDLER_CAN_RONLY));
#if (SYS_CPNT_TRUNK_BALANCE_MODE == TRUE)
    init_PrivateMIBNodeRootOIDbySwitchBoardID(trunkBalanceMode_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("trunkBalanceMode",
                               do_trunkBalanceMode,
                               trunkBalanceMode_oid,
                               OID_LENGTH(trunkBalanceMode_oid),
                               HANDLER_CAN_RWRITE));
#endif
}



/********************************************
 ******************trunkTable****************
 ********************************************
 */

oid trunkTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID ,1,3};

struct variable3 trunkTable_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
{TRUNKINDEX,  ASN_INTEGER,  RONLY,   var_trunkTable, 3,  { 3, 1, 1 }},
#endif

{TRUNKPORTS,  ASN_OCTET_STR,  RWRITE,  var_trunkTable, 3,  { 3, 1, 2 }},
{TRUNKCREATION,  ASN_INTEGER,  RONLY,   var_trunkTable, 3,  { 3, 1, 3 }},
{TRUNKSTATUS,  ASN_INTEGER,  RWRITE,  var_trunkTable, 3,  { 3, 1, 4 }},
#if defined(ACD)
{TRUNKGROUP,  ASN_INTEGER,  RWRITE,  var_trunkTable, 3,  { 3, 1, 5 }},
#endif
};

/** Initializes the trunkTable module */
void
init_trunkTable(void)
{
    /* register ourselves with the agent to handle our mib tree */
    init_PrivateMIBNodeRootOIDbySwitchBoardID(trunkTable_variables_oid);
    REGISTER_MIB("trunkTable", trunkTable_variables, variable3,
               trunkTable_variables_oid);
}



/********************************************
 ******************lacpPortTable*************
 ********************************************
 */
oid lacpPortTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,4 };

struct variable3 lacpPortTable_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
{LACPPORTINDEX,  ASN_INTEGER,  RONLY,   var_lacpPortTable, 3,  { 1, 1, 1 }},
#endif
{LACPPORTSTATUS,  ASN_INTEGER,  RWRITE,  var_lacpPortTable, 3,  { 1, 1, 2 }},
};

/** Initializes the lacpPortTable module */
void
init_lacpPortTable(void)
{
    /* register ourselves with the agent to handle our mib tree */
    init_PrivateMIBNodeRootOIDbySwitchBoardID(lacpPortTable_variables_oid);
    REGISTER_MIB("lacpPortTable", lacpPortTable_variables, variable3,
               lacpPortTable_variables_oid);
}



/********************************************
 *****************staMgt*********************
 ********************************************
 */
/** Initializes the staMgt module */
void
init_staMgt(void)
{
    static oid staSystemStatus_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,5,1, 0 };
 #if (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_RSTP) || (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_MSTP)
    static oid staProtocolType_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,5,3, 0 };
    static oid staTxHoldCount_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,5,4, 0 };
    static oid staPathCostMethod_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,5,5, 0 };
    #if (SYS_CPNT_XSTP_CONFIGURABLE_FLOODING == TRUE)
    static oid staSystemBPDUFlooding_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,5,9,0 };
    #endif
 #endif

    init_PrivateMIBNodeRootOIDbySwitchBoardID(staSystemStatus_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("staSystemStatus",
                               do_staSystemStatus,
                               staSystemStatus_oid,
                               OID_LENGTH(staSystemStatus_oid),
                               HANDLER_CAN_RWRITE));
  #if (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_RSTP) || (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_MSTP)

    init_PrivateMIBNodeRootOIDbySwitchBoardID(staProtocolType_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("staProtocolType",
                               do_staProtocolType,
                               staProtocolType_oid,
                               OID_LENGTH(staProtocolType_oid),
                               HANDLER_CAN_RWRITE));
    init_PrivateMIBNodeRootOIDbySwitchBoardID(staTxHoldCount_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("staTxHoldCount",
                               do_staTxHoldCount,
                               staTxHoldCount_oid,
                               OID_LENGTH(staTxHoldCount_oid),
                               HANDLER_CAN_RWRITE));
    init_PrivateMIBNodeRootOIDbySwitchBoardID(staPathCostMethod_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("staPathCostMethod",
                               do_staPathCostMethod,
                               staPathCostMethod_oid,
                               OID_LENGTH(staPathCostMethod_oid),
                               HANDLER_CAN_RWRITE));
    #if (SYS_CPNT_XSTP_CONFIGURABLE_FLOODING == TRUE)
    init_PrivateMIBNodeRootOIDbySwitchBoardID(staSystemBPDUFlooding_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("staSystemBPDUFlooding",
                               do_staSystemBPDUFlooding,
                               staSystemBPDUFlooding_oid,
                               OID_LENGTH(staSystemBPDUFlooding_oid),
                               HANDLER_CAN_RWRITE));
    #endif

   #endif
}



/********************************************
 ****************staPortTable****************
 ********************************************
 */
oid staPortTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,5 };

/* variable3 staPortTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */
struct variable3 staPortTable_variables[] =
{
/* magic number, variable type, ro/rw, callback fn, L, oidsuffix
 */
    { LEAF_staPortFastForward, ASN_INTEGER, RWRITE, var_staPortTable, 3, { 2, 1, 2 }},

#if (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_RSTP) || (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_MSTP)
    { LEAF_staPortProtocolMigration, ASN_INTEGER, RWRITE, var_staPortTable, 3, { 2, 1, 3 }},

#if (SYS_CPNT_STP_AUTO_EDGE_PORT != TRUE)
    { LEAF_staPortAdminEdgePort, ASN_INTEGER, RWRITE, var_staPortTable, 3, { 2, 1, 4 }},
#endif /* #if (SYS_CPNT_STP_AUTO_EDGE_PORT != TRUE) */

    { LEAF_staPortOperEdgePort, ASN_INTEGER, RONLY, var_staPortTable, 3, { 2, 1, 5 }},
    { LEAF_staPortAdminPointToPoint, ASN_INTEGER, RWRITE, var_staPortTable, 3, { 2, 1, 6 }},
    { LEAF_staPortOperPointToPoint, ASN_INTEGER, RONLY, var_staPortTable, 3, { 2, 1, 7 }},
    { LEAF_staPortSystemStatus, ASN_INTEGER, RWRITE, var_staPortTable, 3, { 2, 1, 9 }},
    { LEAF_staPortLongAdminPathCost, ASN_INTEGER, RWRITE, var_staPortTable, 3, { 2, 1, 10 }},
    { LEAF_staPortLongOperPathCost, ASN_INTEGER, RONLY, var_staPortTable, 3, { 2, 1, 11 }},
#if (SYS_CPNT_XSTP_CONFIGURABLE_FLOODING == TRUE)
    { LEAF_staPortBpduFlooding, ASN_INTEGER, RWRITE, var_staPortTable, 3, { 2, 1, 12 }},
#endif
#if (SYS_CPNT_STP_BPDU_GUARD == TRUE)
    { LEAF_staPortBpduGuard, ASN_INTEGER, RWRITE, var_staPortTable, 3, { 2, 1, 15 }},
#endif /* #if (SYS_CPNT_STP_BPDU_GUARD == TRUE) */

#if (SYS_CPNT_STP_AUTO_EDGE_PORT == TRUE)
    { LEAF_staPortAdminEdgePortWithAuto, ASN_INTEGER, RWRITE, var_staPortTable, 3, { 2, 1, 16 }},
#endif /* #if (SYS_CPNT_STP_AUTO_EDGE_PORT == TRUE) */

#if (SYS_CPNT_STP_BPDU_FILTER == TRUE)
    { LEAF_staPortBpduFilter, ASN_INTEGER, RWRITE, var_staPortTable, 3, { 2, 1, 17 }},
#endif /* #if (SYS_CPNT_STP_BPDU_FILTER == TRUE) */

#if (SYS_CPNT_STP_ROOT_GUARD == TRUE)
    { LEAF_staPortRootGuardStatus, ASN_INTEGER, RWRITE, var_staPortTable, 3, { 2, 1, 18 }},
#endif /* #if (SYS_CPNT_STP_ROOT_GUARD == TRUE) */

#if (SYS_CPNT_STP_BPDU_GUARD == TRUE)
    {LEAF_staPortBpduGuardAutoRecovery, ASN_INTEGER, RWRITE, var_staPortTable, 3, {2, 1, 19}},
    {LEAF_staPortBpduGuardAutoRecoveryInterval, ASN_UNSIGNED, RWRITE, var_staPortTable, 3, {2, 1, 20}},
#endif
#if(SYS_CPNT_XSTP_TC_PROP_STOP == TRUE)
    { LEAF_staPortTcPropStop, ASN_INTEGER, RWRITE, var_staPortTable, 3, { 2, 1, 21 }},
#endif
#endif /* #if (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_RSTP) || (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_MSTP) */
};

void
init_staPortTable(void)
{
    /* register ourselves with the agent to handle our mib tree */
    init_PrivateMIBNodeRootOIDbySwitchBoardID(staPortTable_variables_oid);
    REGISTER_MIB("staPortTable", staPortTable_variables, variable3,
               staPortTable_variables_oid);
}



#if (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_RSTP) || (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_MSTP)
/********************************************
 ****************xstMgt**********************
 ********************************************
 */
void
init_xstMgt(void)
{
    static oid mstRevision_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,5,6,2, 0 };
    static oid mstMaxHops_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,5,6,3, 0 };
    static oid mstName_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,5,6,1, 0 };

    init_PrivateMIBNodeRootOIDbySwitchBoardID(mstRevision_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("mstRevision",
                               do_mstRevision,
                               mstRevision_oid,
                               OID_LENGTH(mstRevision_oid),
                               HANDLER_CAN_RWRITE));
    init_PrivateMIBNodeRootOIDbySwitchBoardID(mstMaxHops_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("mstMaxHops",
                               do_mstMaxHops,
                               mstMaxHops_oid,
                               OID_LENGTH(mstMaxHops_oid),
                               HANDLER_CAN_RWRITE));
    init_PrivateMIBNodeRootOIDbySwitchBoardID(mstName_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("mstName",
                               do_mstName,
                               mstName_oid,
                               OID_LENGTH(mstName_oid),
                               HANDLER_CAN_RWRITE));
}



/********************************************
 **************xstInstanceCfgTable***********
 ********************************************
 */
oid xstInstanceCfgTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,5,6 };

struct variable3 xstInstanceCfgTable_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
{XSTINSTANCECFGINDEX,  ASN_INTEGER,  RONLY,   var_xstInstanceCfgTable, 3,  { 4, 1, 1 }},
#endif
{XSTINSTANCECFGPRIORITY,  ASN_INTEGER,  RWRITE,  var_xstInstanceCfgTable, 3,  { 4, 1, 2 }},
/* shumin.wang fix bug for ES2628BT-FLF-ZZ-00419 */
{XSTINSTANCECFGTIMESINCETOPOLOGYCHANGE,  ASN_TIMETICKS,  RONLY,   var_xstInstanceCfgTable, 3,  { 4, 1, 3 }},
{XSTINSTANCECFGTOPCHANGES,  ASN_INTEGER,  RONLY,   var_xstInstanceCfgTable, 3,  { 4, 1, 4 }},
{XSTINSTANCECFGDESIGNATEDROOT,  ASN_OCTET_STR,  RONLY,   var_xstInstanceCfgTable, 3,  { 4, 1, 5 }},
{XSTINSTANCECFGROOTCOST,  ASN_INTEGER,  RONLY,   var_xstInstanceCfgTable, 3,  { 4, 1, 6 }},
{XSTINSTANCECFGROOTPORT,  ASN_INTEGER,  RONLY,   var_xstInstanceCfgTable, 3,  { 4, 1, 7 }},
{XSTINSTANCECFGMAXAGE,  ASN_INTEGER,  RONLY,   var_xstInstanceCfgTable, 3,  { 4, 1, 8 }},
{XSTINSTANCECFGHELLOTIME,  ASN_INTEGER,  RONLY,   var_xstInstanceCfgTable, 3,  { 4, 1, 9 }},
{XSTINSTANCECFGHOLDTIME,  ASN_INTEGER,  RONLY,   var_xstInstanceCfgTable, 3,  { 4, 1, 10 }},
{XSTINSTANCECFGFORWARDDELAY,  ASN_INTEGER,  RONLY,   var_xstInstanceCfgTable, 3,  { 4, 1, 11 }},
{XSTINSTANCECFGBRIDGEMAXAGE,  ASN_INTEGER,  RONLY,   var_xstInstanceCfgTable, 3,  { 4, 1, 12 }},
{XSTINSTANCECFGBRIDGEHELLOTIME,  ASN_INTEGER,  RONLY,   var_xstInstanceCfgTable, 3,  { 4, 1, 13 }},
{XSTINSTANCECFGBRIDGEFORWARDDELAY,  ASN_INTEGER,  RONLY,   var_xstInstanceCfgTable, 3,  { 4, 1, 14 }},
{XSTINSTANCECFGTXHOLDCOUNT,  ASN_INTEGER,  RONLY,   var_xstInstanceCfgTable, 3,  { 4, 1, 15 }},
{XSTINSTANCECFGPATHCOSTMETHOD,  ASN_INTEGER,  RONLY,   var_xstInstanceCfgTable, 3,  { 4, 1, 16 }},
};

void
init_xstInstanceCfgTable(void)
{
    /* register ourselves with the agent to handle our mib tree */
    init_PrivateMIBNodeRootOIDbySwitchBoardID(xstInstanceCfgTable_variables_oid);
    REGISTER_MIB("xstInstanceCfgTable", xstInstanceCfgTable_variables, variable3,
               xstInstanceCfgTable_variables_oid);
}



/********************************************
 ***********xstInstancePortTable*************
 ********************************************
 */
oid xstInstancePortTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,5,6 };

struct variable3 xstInstancePortTable_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
{XSTINSTANCEPORTINSTANCE,  ASN_INTEGER,  RONLY,   var_xstInstancePortTable, 3,  { 5, 1, 1 }},
{XSTINSTANCEPORTPORT,  ASN_INTEGER,  RONLY,   var_xstInstancePortTable, 3,  { 5, 1, 2 }},
#endif
{XSTINSTANCEPORTPRIORITY,  ASN_INTEGER,  RWRITE,  var_xstInstancePortTable, 3,  { 5, 1, 3 }},
{XSTINSTANCEPORTSTATE,  ASN_INTEGER,  RONLY,   var_xstInstancePortTable, 3,  { 5, 1, 4 }},
{XSTINSTANCEPORTENABLE,  ASN_INTEGER,  RONLY,   var_xstInstancePortTable, 3,  { 5, 1, 5 }},
{XSTINSTANCEPORTDESIGNATEDROOT,  ASN_OCTET_STR,  RONLY,   var_xstInstancePortTable, 3,  { 5, 1, 7 }},
{XSTINSTANCEPORTDESIGNATEDCOST,  ASN_INTEGER,  RONLY,   var_xstInstancePortTable, 3,  { 5, 1, 8 }},
{XSTINSTANCEPORTDESIGNATEDBRIDGE,  ASN_OCTET_STR,  RONLY,   var_xstInstancePortTable, 3,  { 5, 1, 9 }},
{XSTINSTANCEPORTDESIGNATEDPORT,  ASN_OCTET_STR,  RONLY,   var_xstInstancePortTable, 3,  { 5, 1, 10 }},
{XSTINSTANCEPORTFORWARDTRANSITIONS,  ASN_COUNTER,  RONLY,   var_xstInstancePortTable, 3,  { 5, 1, 11 }},
{XSTINSTANCEPORTPORTROLE,  ASN_INTEGER,  RONLY,   var_xstInstancePortTable, 3,  { 5, 1, 12 }},
{XSTINSTANCEPORTADMINPATHCOST, ASN_INTEGER, RWRITE, var_xstInstancePortTable, 3, {5, 1, 13}},
{XSTINSTANCEPORTOPERPATHCOST, ASN_INTEGER, RONLY, var_xstInstancePortTable, 3, {5, 1, 14}},
};

void
init_xstInstancePortTable(void)
{
    /* register ourselves with the agent to handle our mib tree */
    init_PrivateMIBNodeRootOIDbySwitchBoardID(xstInstancePortTable_variables_oid);
    REGISTER_MIB("xstInstancePortTable", xstInstancePortTable_variables, variable3,
               xstInstancePortTable_variables_oid);
}



/********************************************
 ************mstInstanceEditTable************
 ********************************************
 */
oid             mstInstanceEditTable_variables_oid[] =
    { SYS_ADPT_PRIVATEMIB_OID, 1, 5, 6 };

struct variable3 mstInstanceEditTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    {MSTINSTANCEEDITINDEX, ASN_INTEGER, RONLY, var_mstInstanceEditTable, 3,
     {6, 1, 1}},
#endif
    {MSTINSTANCEEDITVLANSMAP, ASN_OCTET_STR, RWRITE,
     var_mstInstanceEditTable, 3, {6, 1, 2}},
    {MSTINSTANCEEDITVLANSMAP2K, ASN_OCTET_STR, RWRITE,
     var_mstInstanceEditTable, 3, {6, 1, 3}},
    {MSTINSTANCEEDITVLANSMAP3K, ASN_OCTET_STR, RWRITE,
     var_mstInstanceEditTable, 3, {6, 1, 4}},
    {MSTINSTANCEEDITVLANSMAP4K, ASN_OCTET_STR, RWRITE,
     var_mstInstanceEditTable, 3, {6, 1, 5}},
    {MSTINSTANCEEDITREMAININGHOPS, ASN_INTEGER, RONLY,
     var_mstInstanceEditTable, 3, {6, 1, 6}},
};

/** Initializes the mstInstanceEditTable module */
void
init_mstInstanceEditTable(void)
{
    /* register ourselves with the agent to handle our mib tree */
    init_PrivateMIBNodeRootOIDbySwitchBoardID(mstInstanceEditTable_variables_oid);
    REGISTER_MIB("mstInstanceEditTable", mstInstanceEditTable_variables,
                 variable3, mstInstanceEditTable_variables_oid);
}


/********************************************
 ************mstInstanceOperTable************
 ********************************************
 */
oid             mstInstanceOperTable_variables_oid[] =
    { SYS_ADPT_PRIVATEMIB_OID, 1, 5, 6};

struct variable3 mstInstanceOperTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    {MSTINSTANCEOPERINDEX, ASN_INTEGER, RONLY, var_mstInstanceOperTable, 3,
     {7, 1, 1}},
#endif
    {MSTINSTANCEOPERVLANSMAP, ASN_OCTET_STR, RONLY,
     var_mstInstanceOperTable, 3, {7, 1, 2}},
    {MSTINSTANCEOPERVLANSMAP2K, ASN_OCTET_STR, RONLY,
     var_mstInstanceOperTable, 3, {7, 1, 3}},
    {MSTINSTANCEOPERVLANSMAP3K, ASN_OCTET_STR, RONLY,
     var_mstInstanceOperTable, 3, {7, 1, 4}},
    {MSTINSTANCEOPERVLANSMAP4K, ASN_OCTET_STR, RONLY,
     var_mstInstanceOperTable, 3, {7, 1, 5}},
};


/** Initializes the mstInstanceOperTable module */
void
init_mstInstanceOperTable(void)
{

    init_PrivateMIBNodeRootOIDbySwitchBoardID(mstInstanceOperTable_variables_oid);
    REGISTER_MIB("mstInstanceOperTable", mstInstanceOperTable_variables,
                 variable3, mstInstanceOperTable_variables_oid);
}
#endif /*end of #if (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_RSTP) || (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_MSTP)*/

/********************************************
 ************tftpMgt*************************
 ********************************************
 */
void
init_tftpMgt(void)
{
    static oid tftpFileType_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,6,1, 0 };
    static oid tftpStatus_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,6,6, 0 };
    static oid tftpAction_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,6,5, 0 };
    static oid tftpServer_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,6,4, 0 };
    static oid tftpSrcFile_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,6,2, 0 };
    static oid tftpDestFile_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,6,3, 0 };

    init_PrivateMIBNodeRootOIDbySwitchBoardID(tftpFileType_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("tftpFileType",
                               do_tftpFileType,
                               tftpFileType_oid,
                               OID_LENGTH(tftpFileType_oid),
                               HANDLER_CAN_RWRITE));
    init_PrivateMIBNodeRootOIDbySwitchBoardID(tftpStatus_oid);
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("tftpStatus",
                                         get_tftpStatus,
                                         tftpStatus_oid,
                                         OID_LENGTH(tftpStatus_oid),
                                         HANDLER_CAN_RONLY));
    init_PrivateMIBNodeRootOIDbySwitchBoardID(tftpAction_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("tftpAction",
                               do_tftpAction,
                               tftpAction_oid,
                               OID_LENGTH(tftpAction_oid),
                               HANDLER_CAN_RWRITE));
    init_PrivateMIBNodeRootOIDbySwitchBoardID(tftpServer_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("tftpServer",
                               do_tftpServer,
                               tftpServer_oid,
                               OID_LENGTH(tftpServer_oid),
                               HANDLER_CAN_RWRITE));
    init_PrivateMIBNodeRootOIDbySwitchBoardID(tftpSrcFile_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("tftpSrcFile",
                               do_tftpSrcFile,
                               tftpSrcFile_oid,
                               OID_LENGTH(tftpSrcFile_oid),
                               HANDLER_CAN_RWRITE));
    init_PrivateMIBNodeRootOIDbySwitchBoardID(tftpDestFile_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("tftpDestFile",
                               do_tftpDestFile,
                               tftpDestFile_oid,
                               OID_LENGTH(tftpDestFile_oid),
                               HANDLER_CAN_RWRITE));
}



/********************************************
 ***********restartMgt***********************
 ********************************************
 */

/** Initializes the restartMgt module */
void
init_restartMgt(void)
{
    static oid restartConfigFile_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,7,2, 0 };
    static oid restartControl_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,7,3, 0 };
    static oid restartOpCodeFile_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,7,1, 0 };


    init_PrivateMIBNodeRootOIDbySwitchBoardID(restartConfigFile_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("restartConfigFile",
                               do_restartConfigFile,
                               restartConfigFile_oid,
                               OID_LENGTH(restartConfigFile_oid),
                               HANDLER_CAN_RWRITE));
    init_PrivateMIBNodeRootOIDbySwitchBoardID(restartControl_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("restartControl",
                               do_restartControl,
                               restartControl_oid,
                               OID_LENGTH(restartControl_oid),
                               HANDLER_CAN_RWRITE));
    init_PrivateMIBNodeRootOIDbySwitchBoardID(restartOpCodeFile_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("restartOpCodeFile",
                               do_restartOpCodeFile,
                               restartOpCodeFile_oid,
                               OID_LENGTH(restartOpCodeFile_oid),
                               HANDLER_CAN_RWRITE));
}

/********************************************
 ***********mirrorTable**********************
 ********************************************
 */

oid mirrorTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,8 };

struct variable3 mirrorTable_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
{MIRRORDESTINATIONPORT,  ASN_INTEGER,  RONLY,   var_mirrorTable, 3,  { 1, 1, 1 }},
{MIRRORSOURCEPORT,  ASN_INTEGER,  RONLY,   var_mirrorTable, 3,  { 1, 1, 2 }},
#endif
{MIRRORTYPE,  ASN_INTEGER,  RWRITE,  var_mirrorTable, 3,  { 1, 1, 3 }},
{MIRRORSTATUS,  ASN_INTEGER,  RWRITE,  var_mirrorTable, 3,  { 1, 1, 4 }},
};

/** Initializes the mirrorTable module */
void
init_mirrorTable(void)
{
    /* register ourselves with the agent to handle our mib tree */
    init_PrivateMIBNodeRootOIDbySwitchBoardID(mirrorTable_variables_oid);
    REGISTER_MIB("mirrorTable", mirrorTable_variables, variable3,
               mirrorTable_variables_oid);
}

#if (SYS_CPNT_VLAN_MIRROR == TRUE)
/********************************************
 ***********vlanMirrorTable******************
 ********************************************
 */

struct variable3 vlanMirrorTable_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */

#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
{LEAF_vlanMirrorDestinationPort, ASN_INTEGER, RONLY,  var_vlanMirrorTable, 3, { 2, 1, 1 }},
{LEAF_vlanMirrorSourceVlan,      ASN_INTEGER, RONLY,  var_vlanMirrorTable, 3, { 2, 1, 2 }},
#endif /* end of #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

{LEAF_vlanMirrorStatus,          ASN_INTEGER, RWRITE, var_vlanMirrorTable, 3, { 2, 1, 4 }},
};

/** Initializes the vlanMirrorTable module */
void
init_vlanMirrorTable(void)
{
    oid vlanMirrorTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1, 8 };

    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("vlanMirrorTable", vlanMirrorTable_variables, variable3,
                 vlanMirrorTable_variables_oid);
}
#endif /* end of #if (SYS_CPNT_VLAN_MIRROR == TRUE) */

#if (SYS_CPNT_MAC_BASED_MIRROR == TRUE)
/********************************************
 **********macMirrorTable********************
 ********************************************
 */
oid macMirrorTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,8 };
/*
 * variable3 macMirrorTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */
struct variable3 macMirrorTable_variables[] = {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
{LEAF_macMirrorDestinationPort,  ASN_INTEGER,  RONLY,   var_macMirrorTable, 3,  { 4, 1, 1 }},
#endif

#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
{LEAF_macMirrorSourceMacAddr,  ASN_OCTET_STR,  RONLY,   var_macMirrorTable, 3,  { 4, 1, 2 }},
#endif

{LEAF_macMirrorStatus,  ASN_INTEGER,  RWRITE,  var_macMirrorTable, 3,  { 4, 1, 3 }},
};

/** Initializes the macMirrorTable module */
void
init_macMirrorTable(void)
{
    init_PrivateMIBNodeRootOIDbySwitchBoardID(macMirrorTable_variables_oid);
    REGISTER_MIB("macMirrorTable", macMirrorTable_variables, variable3,
                 macMirrorTable_variables_oid);
}
#endif  /* #if (SYS_CPNT_MAC_BASED_MIRROR == TRUE) */

#if (SYS_CPNT_ACL_MIRROR == TRUE)
/********************************************
 ***********aclMirrorTable******************
 ********************************************
 */

struct variable3 aclMirrorTable_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */

#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
{LEAF_aclMirrorDestinationPort, ASN_INTEGER, RONLY,  var_aclMirrorTable, 3, { 6, 1, 1 }},
{LEAF_aclMirrorAccessList,      ASN_INTEGER, RONLY,  var_aclMirrorTable, 3, { 6, 1, 2 }},
{LEAF_aclMirrorType,            ASN_INTEGER, RONLY,  var_aclMirrorTable, 3, { 6, 1, 3 }},
#endif /* end of #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */
{LEAF_aclMirrorStatus,          ASN_INTEGER, RWRITE, var_aclMirrorTable, 3, { 6, 1, 4 }},
};

/** Initializes the vlanMirrorTable module */
void
init_aclMirrorTable(void)
{
    oid aclMirrorTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1, 8 };

    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("aclMirrorTable", aclMirrorTable_variables, variable3,
                 aclMirrorTable_variables_oid);
}
#endif /* end of #if (SYS_CPNT_ACL_MIRROR == TRUE) */

#if (SYS_CPNT_RSPAN == TRUE)

oid vlanStaticExtTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1, 12 };

struct variable3 vlanStaticExtTable_variables[] = {
    {LEAF_vlanStaticExtRspanStatus, ASN_INTEGER, RWRITE, var_vlanStaticExtTable, 3, { 15, 1, 1 }},
};

/** Initializes the vlanStaticExtTable module */
void
init_vlanStaticExtTable(void)
{
    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("vlanStaticExtTable", vlanStaticExtTable_variables,
                 variable3,
                 vlanStaticExtTable_variables_oid);
}

/********************************************
 ***********rspanTable***********************
 ********************************************
 */
oid rspanTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1, 8 };
/*
 * variable3 rspanTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */
struct variable3 rspanTable_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
{LEAF_rspanSessionId,    ASN_INTEGER,   RONLY,   var_rspanTable, 3,  { 3, 1, 1 }},
#endif

{LEAF_rspanSrcTxPorts,   ASN_OCTET_STR, RWRITE,  var_rspanTable, 3,  { 3, 1, 2 }},
{LEAF_rspanSrcRxPorts,   ASN_OCTET_STR, RWRITE,  var_rspanTable, 3,  { 3, 1, 3 }},
{LEAF_rspanDstPort,      ASN_INTEGER,   RWRITE,  var_rspanTable, 3,  { 3, 1, 4 }},
{LEAF_rspanDstPortTag,   ASN_INTEGER,   RWRITE,  var_rspanTable, 3,  { 3, 1, 5 }},
{LEAF_rspanSwitchRole,   ASN_INTEGER,   RWRITE,  var_rspanTable, 3,  { 3, 1, 6 }},
{LEAF_rspanRemotePorts,  ASN_OCTET_STR, RWRITE,  var_rspanTable, 3,  { 3, 1, 7 }},
{LEAF_rspanRemoteVlanId, ASN_INTEGER,   RWRITE,  var_rspanTable, 3,  { 3, 1, 8 }},
{LEAF_rspanOperStatus,   ASN_INTEGER,   RONLY,   var_rspanTable, 3,  { 3, 1, 9 }},
{LEAF_rspanStatus,       ASN_INTEGER,   RWRITE,  var_rspanTable, 3,  { 3, 1, 10 }},
};

/** Initializes the rspanTable module */
void
init_rspanTable(void)
{
    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("rspanTable", rspanTable_variables, variable3,
                 rspanTable_variables_oid);
}
#endif /* end of #if (SYS_CPNT_RSPAN == TRUE) */

#if (SYS_CPNT_IGMPSNP == TRUE)
/********************************************
 **********igmpSnoopMgt*********************
 ********************************************
 */
void
init_igmpSnoopMgt(void)
{
    static oid igmpSnoopStatus_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,9,1, 0 };
    static oid igmpSnoopQuerier_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,9,2, 0 };
    static oid igmpSnoopVersion_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,9,7, 0 };
    /*static oid igmpSnoopQueryCount_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,9,3, 0 };*/
    /*static oid igmpSnoopQueryMaxResponseTime_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,9,5, 0 };*/
    static oid igmpSnoopRouterPortExpireTime_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,9,6, 0 };
    /*static oid igmpSnoopQueryInterval_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,9,4, 0 };*/

#if (SYS_CPNT_FILTER_THROOTTLE == TRUE)
    oid igmpSnoopFilterStatus_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,9,17,0 };
    oid igmpSnoopProfileCtlId_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,9,19,1,0 };
    oid igmpSnoopProfileCtlInetAddressType_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,9,19,2,0 };
    oid igmpSnoopProfileCtlStartInetAddress_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,9,19,3,0 };
    oid igmpSnoopProfileCtlEndInetAddress_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,9,19,4,0 };
    oid igmpSnoopProfileCtlAction_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,9,19,5,0 };
#endif
    init_PrivateMIBNodeRootOIDbySwitchBoardID(igmpSnoopStatus_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("igmpSnoopStatus",
                               do_igmpSnoopStatus,
                               igmpSnoopStatus_oid,
                               OID_LENGTH(igmpSnoopStatus_oid),
                               HANDLER_CAN_RWRITE));
    init_PrivateMIBNodeRootOIDbySwitchBoardID(igmpSnoopQuerier_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("igmpSnoopQuerier",
                               do_igmpSnoopQuerier,
                               igmpSnoopQuerier_oid,
                               OID_LENGTH(igmpSnoopQuerier_oid),
                               HANDLER_CAN_RWRITE));
    init_PrivateMIBNodeRootOIDbySwitchBoardID(igmpSnoopVersion_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("igmpSnoopVersion",
                               do_igmpSnoopVersion,
                               igmpSnoopVersion_oid,
                               OID_LENGTH(igmpSnoopVersion_oid),
                               HANDLER_CAN_RWRITE));
    #if 0
    init_PrivateMIBNodeRootOIDbySwitchBoardID(igmpSnoopQueryCount_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("igmpSnoopQueryCount",
                               do_igmpSnoopQueryCount,
                               igmpSnoopQueryCount_oid,
                               OID_LENGTH(igmpSnoopQueryCount_oid),
                               HANDLER_CAN_RWRITE));
    init_PrivateMIBNodeRootOIDbySwitchBoardID(igmpSnoopQueryMaxResponseTime_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("igmpSnoopQueryMaxResponseTime",
                               do_igmpSnoopQueryMaxResponseTime,
                               igmpSnoopQueryMaxResponseTime_oid,
                               OID_LENGTH(igmpSnoopQueryMaxResponseTime_oid),
                               HANDLER_CAN_RWRITE));
    #endif
    init_PrivateMIBNodeRootOIDbySwitchBoardID(igmpSnoopRouterPortExpireTime_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("igmpSnoopRouterPortExpireTime",
                               do_igmpSnoopRouterPortExpireTime,
                               igmpSnoopRouterPortExpireTime_oid,
                               OID_LENGTH(igmpSnoopRouterPortExpireTime_oid),
                               HANDLER_CAN_RWRITE));
    #if 0
    init_PrivateMIBNodeRootOIDbySwitchBoardID(igmpSnoopQueryInterval_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("igmpSnoopQueryInterval",
                               do_igmpSnoopQueryInterval,
                               igmpSnoopQueryInterval_oid,
                               OID_LENGTH(igmpSnoopQueryInterval_oid),
                               HANDLER_CAN_RWRITE));
    #endif
    #if (SYS_CPNT_FILTER_THROOTTLE == TRUE)
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("igmpSnoopFilterStatus",
                               do_igmpSnoopFilterStatus,
                               igmpSnoopFilterStatus_oid,
                               OID_LENGTH(igmpSnoopFilterStatus_oid),
                               HANDLER_CAN_RWRITE));

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("igmpSnoopProfileCtlId",
                               do_igmpSnoopProfileCtlId,
                               igmpSnoopProfileCtlId_oid,
                               OID_LENGTH(igmpSnoopProfileCtlId_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("igmpSnoopProfileCtlInetAddressType",
                               do_igmpSnoopProfileCtlInetAddressType,
                               igmpSnoopProfileCtlInetAddressType_oid,
                               OID_LENGTH(igmpSnoopProfileCtlInetAddressType_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("igmpSnoopProfileCtlStartInetAddress",
                               do_igmpSnoopProfileCtlStartInetAddress,
                               igmpSnoopProfileCtlStartInetAddress_oid,
                               OID_LENGTH(igmpSnoopProfileCtlStartInetAddress_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("igmpSnoopProfileCtlEndInetAddress",
                               do_igmpSnoopProfileCtlEndInetAddress,
                               igmpSnoopProfileCtlEndInetAddress_oid,
                               OID_LENGTH(igmpSnoopProfileCtlEndInetAddress_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("igmpSnoopProfileCtlAction",
                               do_igmpSnoopProfileCtlAction,
                               igmpSnoopProfileCtlAction_oid,
                               OID_LENGTH(igmpSnoopProfileCtlAction_oid),
                               HANDLER_CAN_RWRITE));

#endif
    {
        oid igmpSnoopReportSuppressionStatus_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,9,16, 0 };

        netsnmp_register_instance(netsnmp_create_handler_registration
                                  ("igmpSnoopReportSuppressionStatus",
                                   do_igmpSnoopReportSuppression,
                                   igmpSnoopReportSuppressionStatus_oid,
                                   OID_LENGTH(igmpSnoopReportSuppressionStatus_oid),
                                   HANDLER_CAN_RWRITE));
    }
}

/********************************************
 **********igmpSnoopGlobalMgt*********************
 ********************************************
 */

void
init_igmpSnoopGlobalMgt(void)
{
#if(SYS_CPNT_IGMPSNP_PROXY == TRUE)
    oid igmpSnoopProxyReporting_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,9,28,1, 0 };

    init_PrivateMIBNodeRootOIDbySwitchBoardID(igmpSnoopProxyReporting_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("igmpSnoopProxyReporting",
                               do_igmpSnoopProxyReporting,
                               igmpSnoopProxyReporting_oid,
                               OID_LENGTH(igmpSnoopProxyReporting_oid),
                               HANDLER_CAN_RWRITE));
#endif
    oid igmpSnoopRouterAlertOptionCheck_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,9,28,2, 0 };

    init_PrivateMIBNodeRootOIDbySwitchBoardID(igmpSnoopRouterAlertOptionCheck_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("igmpSnoopRouterAlertOptionCheck",
                               do_igmpSnoopRouterAlertOptionCheck,
                               igmpSnoopRouterAlertOptionCheck_oid,
                               OID_LENGTH(igmpSnoopRouterAlertOptionCheck_oid),
                               HANDLER_CAN_RWRITE));

    oid igmpSnoopTcnFlood_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,9,28,3, 0 };

    init_PrivateMIBNodeRootOIDbySwitchBoardID(igmpSnoopTcnFlood_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("igmpSnoopTcnFlood",
                               do_igmpSnoopTcnFlood,
                               igmpSnoopTcnFlood_oid,
                               OID_LENGTH(igmpSnoopTcnFlood_oid),
                               HANDLER_CAN_RWRITE));


    oid igmpSnoopTcnQuerySolicit_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,9,28,4, 0 };

    init_PrivateMIBNodeRootOIDbySwitchBoardID(igmpSnoopTcnQuerySolicit_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("igmpSnoopTcnQuerySolicit",
                               do_igmpSnoopTcnQuerySolicit,
                               igmpSnoopTcnQuerySolicit_oid,
                               OID_LENGTH(igmpSnoopTcnQuerySolicit_oid),
                               HANDLER_CAN_RWRITE));

    oid igmpSnoopUnregisteredDataFlood_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,9,28,5, 0 };

    init_PrivateMIBNodeRootOIDbySwitchBoardID(igmpSnoopUnregisteredDataFlood_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("igmpSnoopUnregisteredDataFlood",
                               do_igmpSnoopUnregisteredDataFlood,
                               igmpSnoopUnregisteredDataFlood_oid,
                               OID_LENGTH(igmpSnoopUnregisteredDataFlood_oid),
                               HANDLER_CAN_RWRITE));

    oid igmpSnoopUnsolicitedReportInterval_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,9,28,6, 0 };

    init_PrivateMIBNodeRootOIDbySwitchBoardID(igmpSnoopUnsolicitedReportInterval_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("igmpSnoopUnsolicitedReportInterval",
                               do_igmpSnoopUnsolicitedReportInterval,
                               igmpSnoopUnsolicitedReportInterval_oid,
                               OID_LENGTH(igmpSnoopUnsolicitedReportInterval_oid),
                               HANDLER_CAN_RWRITE));

    oid igmpSnoopVersionExclusive_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,9,28,7, 0 };

    init_PrivateMIBNodeRootOIDbySwitchBoardID(igmpSnoopVersionExclusive_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("igmpSnoopVersionExclusive",
                               do_igmpSnoopVersionExclusive,
                               igmpSnoopVersionExclusive_oid,
                               OID_LENGTH(igmpSnoopVersionExclusive_oid),
                               HANDLER_CAN_RWRITE));

    #if (SYS_CPNT_IGMPSNP_MROUTER_PORT_PROCESS_REPORT == TRUE)
    oid igmpSnoopMrouterForwardMode_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,9,28,8, 0 };
    init_PrivateMIBNodeRootOIDbySwitchBoardID(igmpSnoopMrouterForwardMode_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("igmpSnoopMrouterForwardMode",
                               do_igmpSnoopMrouterForwardMode,
                               igmpSnoopMrouterForwardMode_oid,
                               OID_LENGTH(igmpSnoopMrouterForwardMode_oid),
                               HANDLER_CAN_RWRITE));
    #endif
    #if (SYS_CPNT_IGMPSNP_FORWARD_PRIORITY == TRUE)
    oid igmpSnoopForwardingPriority_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,9,29,0 };

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("igmpSnoopForwardingPriority",
                               do_igmpSnoopForwardingPriority,
                               igmpSnoopForwardingPriority_oid,
                               OID_LENGTH(igmpSnoopForwardingPriority_oid),
                               HANDLER_CAN_RWRITE));
    #endif
}

/********************************************
 ******igmpSnoopRouterCurrentTable***********
 ********************************************
 */
oid igmpSnoopRouterCurrentTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,9};

struct variable3 igmpSnoopRouterCurrentTable_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
{IGMPSNOOPROUTERCURRENTVLANINDEX,  ASN_UNSIGNED,  RONLY,   var_igmpSnoopRouterCurrentTable, 3,  { 8, 1, 1 }},
#endif
{IGMPSNOOPROUTERCURRENTPORTS,  ASN_OCTET_STR,  RONLY,   var_igmpSnoopRouterCurrentTable, 3,  { 8, 1, 2 }},
{IGMPSNOOPROUTERCURRENTSTATUS,  ASN_OCTET_STR,  RONLY,   var_igmpSnoopRouterCurrentTable, 3,  { 8, 1, 3 }},
};

/** Initializes the igmpSnoopRouterCurrentTable module */
void
init_igmpSnoopRouterCurrentTable(void)
{
    /* register ourselves with the agent to handle our mib tree */
    init_PrivateMIBNodeRootOIDbySwitchBoardID(igmpSnoopRouterCurrentTable_variables_oid);
    REGISTER_MIB("igmpSnoopRouterCurrentTable", igmpSnoopRouterCurrentTable_variables, variable3,
               igmpSnoopRouterCurrentTable_variables_oid);
}

/********************************************
 ******igmpSnoopRouterStaticTable************
 ********************************************
 */
oid igmpSnoopRouterStaticTable_variables_oid[] = {SYS_ADPT_PRIVATEMIB_OID,1,9 };

struct variable3 igmpSnoopRouterStaticTable_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
 #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
{IGMPSNOOPROUTERSTATICVLANINDEX,  ASN_UNSIGNED,  RONLY,   var_igmpSnoopRouterStaticTable, 3,  { 9, 1, 1 }},
#endif
{IGMPSNOOPROUTERSTATICPORTS,  ASN_OCTET_STR,  RWRITE,  var_igmpSnoopRouterStaticTable, 3,  { 9, 1, 2 }},
{IGMPSNOOPROUTERSTATICSTATUS,  ASN_INTEGER,  RWRITE,  var_igmpSnoopRouterStaticTable, 3,  { 9, 1, 3 }},
};

/** Initializes the igmpSnoopRouterStaticTable module */
void
init_igmpSnoopRouterStaticTable(void)
{
    /* register ourselves with the agent to handle our mib tree */
    init_PrivateMIBNodeRootOIDbySwitchBoardID(igmpSnoopRouterStaticTable_variables_oid);
    REGISTER_MIB("igmpSnoopRouterStaticTable", igmpSnoopRouterStaticTable_variables, variable3,
               igmpSnoopRouterStaticTable_variables_oid);
}

#if 0
/********************************************
 ******igmpSnoopMulticastCurrentTable********
 ********************************************
 */
oid igmpSnoopMulticastCurrentTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,9 };

struct variable3 igmpSnoopMulticastCurrentTable_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
{IGMPSNOOPMULTICASTCURRENTVLANINDEX,  ASN_UNSIGNED,  RONLY,   var_igmpSnoopMulticastCurrentTable, 3,  { 10, 1, 1 }},
{IGMPSNOOPMULTICASTCURRENTIPADDRESS,  ASN_IPADDRESS,  RONLY,   var_igmpSnoopMulticastCurrentTable, 3,  { 10, 1, 2 }},
#endif
{IGMPSNOOPMULTICASTCURRENTPORTS,  ASN_OCTET_STR,  RONLY,   var_igmpSnoopMulticastCurrentTable, 3,  { 10, 1, 3 }},
{IGMPSNOOPMULTICASTCURRENTSTATUS,  ASN_OCTET_STR,  RONLY,   var_igmpSnoopMulticastCurrentTable, 3,  { 10, 1, 4 }},
};

/** Initializes the igmpSnoopRouterCurrentTable module */
void
init_igmpSnoopMulticastCurrentTable(void)
{
    /* register ourselves with the agent to handle our mib tree */
    init_PrivateMIBNodeRootOIDbySwitchBoardID(igmpSnoopMulticastCurrentTable_variables_oid);
    REGISTER_MIB("igmpSnoopMulticastCurrentTable", igmpSnoopMulticastCurrentTable_variables, variable3,
              igmpSnoopMulticastCurrentTable_variables_oid);
}
#endif

/********************************************
 ******igmpSnoopMulticastStaticTable*********
 ********************************************
 */
oid igmpSnoopMulticastStaticTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,9};

struct variable3  igmpSnoopMulticastStaticTable_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
{IGMPSNOOPMULTICASTSTATICVLANINDEX,  ASN_UNSIGNED,  RONLY,   var_igmpSnoopMulticastStaticTable, 3,  { 11, 1, 1 }},
{IGMPSNOOPMULTICASTSTATICIPADDRESS,  ASN_IPADDRESS,  RONLY,   var_igmpSnoopMulticastStaticTable, 3,  { 11, 1, 2 }},
#endif
{IGMPSNOOPMULTICASTSTATICPORTS,  ASN_OCTET_STR,  RWRITE,  var_igmpSnoopMulticastStaticTable, 3,  { 11, 1, 3 }},
{IGMPSNOOPMULTICASTSTATICSTATUS,  ASN_INTEGER,  RWRITE,  var_igmpSnoopMulticastStaticTable, 3,  { 11, 1, 4 }},
};

/** Initializes the igmpSnoopMulticastStaticTable module */
void
init_igmpSnoopMulticastStaticTable(void)
{
    /* register ourselves with the agent to handle our mib tree */
    init_PrivateMIBNodeRootOIDbySwitchBoardID(igmpSnoopMulticastStaticTable_variables_oid);
    REGISTER_MIB("igmpSnoopMulticastStaticTable", igmpSnoopMulticastStaticTable_variables, variable3,
               igmpSnoopMulticastStaticTable_variables_oid);
}

/********************************************
 **********igmpSnoopCurrentVlanTable*********
 ********************************************
 */
/*
 * igmpSnoopCurrentVlanTable_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid igmpSnoopCurrentVlanTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,9 };
/*
 * variable3 igmpSnoopCurrentVlanTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */

struct variable3 igmpSnoopCurrentVlanTable_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
{LEAF_igmpSnoopCurrentVlanIndex,  ASN_UNSIGNED,  RONLY,   var_igmpSnoopCurrentVlanTable, 3,  { 14, 1, 1 }},
#endif
{LEAF_igmpSnoopCurrentVlanStatus,  ASN_INTEGER,  RWRITE,  var_igmpSnoopCurrentVlanTable, 3,  { 14, 1, 2 }},
  #if(SYS_CPNT_IGMPSNP_IMMEDIATE_LEAVE == TRUE)
{LEAF_igmpSnoopCurrentVlanImmediateLeave,  ASN_INTEGER,  RWRITE,  var_igmpSnoopCurrentVlanTable, 3,  { 14, 1, 3 }},
  #endif
{LEAF_igmpSnoopCurrentVlanGeneralQuerySuppression,  ASN_INTEGER,  RWRITE,  var_igmpSnoopCurrentVlanTable, 3,  { 14, 1, 4 }},
{LEAF_igmpSnoopCurrentVlanLastMemQueryCount,  ASN_UNSIGNED,  RWRITE,  var_igmpSnoopCurrentVlanTable, 3,  { 14, 1, 5 }},
{LEAF_igmpSnoopCurrentVlanLastMemQureyIntvl,  ASN_UNSIGNED,  RWRITE,  var_igmpSnoopCurrentVlanTable, 3,  { 14, 1, 6 }},
{LEAF_igmpSnoopCurrentVlanProxyAddress,  ASN_IPADDRESS,  RWRITE,  var_igmpSnoopCurrentVlanTable, 3,  { 14, 1, 7 }},
{LEAF_igmpSnoopCurrentVlanProxyQueryIntvl,  ASN_UNSIGNED,  RWRITE,  var_igmpSnoopCurrentVlanTable, 3,  { 14, 1, 8 }},
{LEAF_igmpSnoopCurrentVlanProxyQureyRespIntvl,  ASN_UNSIGNED,  RWRITE,  var_igmpSnoopCurrentVlanTable, 3,  { 14, 1, 9 }},
{LEAF_igmpSnoopCurrentVlanProxyReporting,  ASN_INTEGER,  RWRITE,  var_igmpSnoopCurrentVlanTable, 3,  { 14, 1, 10 }},
{LEAF_igmpSnoopCurrentVlanVersion,  ASN_UNSIGNED,  RWRITE,  var_igmpSnoopCurrentVlanTable, 3,  { 14, 1, 11 }},
{LEAF_igmpSnoopCurrentVlanVersionExclusive,  ASN_INTEGER,  RWRITE,  var_igmpSnoopCurrentVlanTable, 3,  { 14, 1, 12 }},
  { LEAF_igmpSnoopCurrentVlanReportSupression, ASN_INTEGER, RWRITE, var_igmpSnoopCurrentVlanTable, 3, { 14, 1, 13 }},
};

/*    (L = length of the oidsuffix) */

/** Initializes the igmpSnoopCurrentVlanTable module */
void
init_igmpSnoopCurrentVlanTable(void)
{

    DEBUGMSGTL(("igmpSnoopCurrentVlanTable", "Initializing\n"));

    /* register ourselves with the agent to handle our mib tree */
    init_PrivateMIBNodeRootOIDbySwitchBoardID(igmpSnoopCurrentVlanTable_variables_oid);
    REGISTER_MIB("igmpSnoopCurrentVlanTable", igmpSnoopCurrentVlanTable_variables, variable3,
               igmpSnoopCurrentVlanTable_variables_oid);

    /* place any other initialization junk you need here */
}

/********************************************
 ******igmpSnoopMulticastGroupTable********
 ********************************************
 */
oid igmpSnoopMulticastGroupTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,9 };

struct variable3 igmpSnoopMulticastGroupTable_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
{IGMPSNOOPMULTICASTGROUPVLANINDEX,  ASN_UNSIGNED,  RONLY,   var_igmpSnoopMulticastGroupTable, 3,  { 15, 1, 1 }},
{IGMPSNOOPMULTICASTGROUPIPADDRESS,  ASN_IPADDRESS,  RONLY,   var_igmpSnoopMulticastGroupTable, 3,  { 15, 1, 2 }},
{IGMPSNOOPMULTICASTGROUPSOURCEIPADDRESS,  ASN_IPADDRESS,  RONLY,   var_igmpSnoopMulticastGroupTable, 3,  { 15, 1, 3 }},
#endif
{IGMPSNOOPMULTICASTGROUPPORTS,  ASN_OCTET_STR,  RONLY,   var_igmpSnoopMulticastGroupTable, 3,  { 15, 1, 4 }},
{IGMPSNOOPMULTICASTGROUPSTATUS,  ASN_OCTET_STR,  RONLY,   var_igmpSnoopMulticastGroupTable, 3,  { 15, 1, 5 }},
};

/** Initializes the igmpSnoopRouterCurrentTable module */
void
init_igmpSnoopMulticastGroupTable(void)
{
    /* register ourselves with the agent to handle our mib tree */
    init_PrivateMIBNodeRootOIDbySwitchBoardID(igmpSnoopMulticastGroupTable_variables_oid);
    REGISTER_MIB("igmpSnoopMulticastGroupTable", igmpSnoopMulticastGroupTable_variables, variable3,
              igmpSnoopMulticastGroupTable_variables_oid);
}

#if (SYS_CPNT_FILTER_THROOTTLE == TRUE)
/********************************************
 **********igmpSnoopProfileTable*************
 ********************************************
 */
 /*
 * igmpSnoopProfileTable_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

/*
 * variable3 igmpSnoopProfileTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */

struct variable3 igmpSnoopProfileTable_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
{LEAF_igmpSnoopProfileId,  ASN_UNSIGNED,  RONLY,   var_igmpSnoopProfileTable, 3,  { 18, 1, 1 }},
#endif

{LEAF_igmpSnoopProfileAction,  ASN_INTEGER,  RWRITE,  var_igmpSnoopProfileTable, 3,  { 18, 1, 2 }},
{LEAF_igmpSnoopProfileStatus,  ASN_INTEGER,  RWRITE,  var_igmpSnoopProfileTable, 3,  { 18, 1, 3 }},
};
/*    (L = length of the oidsuffix) */

/** Initializes the igmpSnoopProfileTable module */
void
init_igmpSnoopProfileTable(void)
{
    oid igmpSnoopProfileTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,9 };

    DEBUGMSGTL(("igmpSnoopProfileTable", "Initializing\n"));

    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("igmpSnoopProfileTable", igmpSnoopProfileTable_variables, variable3,
               igmpSnoopProfileTable_variables_oid);

    /* place any other initialization junk you need here */
}

/********************************************
 ********igmpSnoopProfileRangeTable**********
 ********************************************
 */
 /*
 * igmpSnoopProfileRangeTable_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

/*
 * variable3 igmpSnoopProfileRangeTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */

struct variable3 igmpSnoopProfileRangeTable_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
{LEAF_igmpSnoopProfileRangeProfileId,  ASN_UNSIGNED,  RONLY,   var_igmpSnoopProfileRangeTable, 3,  { 20, 1, 1 }},
#endif

#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
{LEAF_igmpSnoopProfileRangeInetAddressType, ASN_INTEGER ,  RONLY,   var_igmpSnoopProfileRangeTable, 3,  { 20, 1, 2 }},
#endif

#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
{LEAF_igmpSnoopProfileRangeStartInetAddress, ASN_OCTET_STR ,  RONLY,   var_igmpSnoopProfileRangeTable, 3,  { 20, 1, 3 }},
#endif

{LEAF_igmpSnoopProfileRangeEndInetAddress, ASN_OCTET_STR,  RONLY,   var_igmpSnoopProfileRangeTable, 3,  { 20, 1, 4 }},
{LEAF_igmpSnoopProfileRangeAction,  ASN_INTEGER,  RONLY,   var_igmpSnoopProfileRangeTable, 3,  { 20, 1, 5 }},
};
/*    (L = length of the oidsuffix) */

/** Initializes the igmpSnoopProfileRangeTable module */
void
init_igmpSnoopProfileRangeTable(void)
{
    oid igmpSnoopProfileRangeTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,9 };

    DEBUGMSGTL(("igmpSnoopProfileRangeTable", "Initializing\n"));

    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("igmpSnoopProfileRangeTable", igmpSnoopProfileRangeTable_variables, variable3,
               igmpSnoopProfileRangeTable_variables_oid);

    /* place any other initialization junk you need here */
}

/********************************************
 **********igmpSnoopFilterPortTable**********
 ********************************************
 */
 /*
 * igmpSnoopFilterPortTable_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

/*
 * variable3 igmpSnoopFilterPortTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */

struct variable3 igmpSnoopFilterPortTable_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
{LEAF_igmpSnoopFilterPortIndex,  ASN_UNSIGNED,  RONLY,   var_igmpSnoopFilterPortTable, 3,  { 21, 1, 1 }},
#endif

{LEAF_igmpSnoopFilterPortProfileId,  ASN_INTEGER,  RWRITE,  var_igmpSnoopFilterPortTable, 3,  { 21, 1, 2 }},
};
/*    (L = length of the oidsuffix) */

/** Initializes the igmpSnoopFilterPortTable module */
void
init_igmpSnoopFilterPortTable(void)
{
    oid igmpSnoopFilterPortTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,9 };

    DEBUGMSGTL(("igmpSnoopFilterPortTable", "Initializing\n"));

    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("igmpSnoopFilterPortTable", igmpSnoopFilterPortTable_variables, variable3,
               igmpSnoopFilterPortTable_variables_oid);

    /* place any other initialization junk you need here */
}

/********************************************
 *********igmpSnoopThrottlePortTable*********
 ********************************************
 */
 /*
 * igmpSnoopThrottlePortTable_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

/*
 * variable3 igmpSnoopThrottlePortTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */

struct variable3 igmpSnoopThrottlePortTable_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
{LEAF_igmpSnoopThrottlePortIndex,  ASN_UNSIGNED,  RONLY,   var_igmpSnoopThrottlePortTable, 3,  { 22, 1, 1 }},
#endif

{LEAF_igmpSnoopThrottlePortRunningStatus,  ASN_INTEGER,  RONLY,   var_igmpSnoopThrottlePortTable, 3,  { 22, 1, 2 }},
{LEAF_igmpSnoopThrottlePortAction,  ASN_INTEGER,  RWRITE,  var_igmpSnoopThrottlePortTable, 3,  { 22, 1, 3 }},
{LEAF_igmpSnoopThrottlePortMaxGroups,  ASN_INTEGER,  RWRITE,  var_igmpSnoopThrottlePortTable, 3,  { 22, 1, 4 }},
{LEAF_igmpSnoopThrottlePortCurrentGroups,  ASN_INTEGER,  RONLY,   var_igmpSnoopThrottlePortTable, 3,  { 22, 1, 5 }},
};
/*    (L = length of the oidsuffix) */

/** Initializes the igmpSnoopThrottlePortTable module */
void
init_igmpSnoopThrottlePortTable(void)
{
    oid igmpSnoopThrottlePortTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,9 };

    DEBUGMSGTL(("igmpSnoopThrottlePortTable", "Initializing\n"));

    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("igmpSnoopThrottlePortTable", igmpSnoopThrottlePortTable_variables, variable3,
               igmpSnoopThrottlePortTable_variables_oid);

    /* place any other initialization junk you need here */
}
#endif

/* variable3 igmpSnoopPortTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */
struct variable3 igmpSnoopPortTable_variables[] =
{
/* magic number, variable type, ro/rw, callback fn, L, oidsuffix
 */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_igmpSnoopPortIndex, ASN_UNSIGNED, RONLY, var_igmpSnoopPortTable, 3, { 27, 1, 1 }},
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */
#if (SYS_CPNT_IGMPSNP_QUERY_DROP == TRUE)
    { LEAF_igmpSnoopQueryDrop, ASN_INTEGER , RWRITE, var_igmpSnoopPortTable, 3, { 27, 1, 3 }},
#endif
#if (SYS_CPNT_IP_MULTICAST_DATA_DROP == TRUE)
    { LEAF_igmpSnoopMulticastDataDrop, ASN_INTEGER, RWRITE, var_igmpSnoopPortTable, 3, { 27, 1, 4 }},
#endif
    { LEAF_igmpSnoopPortNumGroups, ASN_UNSIGNED, RONLY, var_igmpSnoopPortTable, 3, { 27, 1, 5 }},
    { LEAF_igmpSnoopPortNumJoinSend, ASN_UNSIGNED, RONLY, var_igmpSnoopPortTable, 3, { 27, 1, 6 }},
    { LEAF_igmpSnoopPortNumJoins, ASN_UNSIGNED, RONLY, var_igmpSnoopPortTable, 3, { 27, 1, 7 }},
    { LEAF_igmpSnoopPortNumJoinSuccess, ASN_UNSIGNED, RONLY, var_igmpSnoopPortTable, 3, { 27, 1, 8 }},
    { LEAF_igmpSnoopPortNumLeavesSend, ASN_UNSIGNED, RONLY, var_igmpSnoopPortTable, 3, { 27, 1, 9 }},
    { LEAF_igmpSnoopPortNumLeaves, ASN_UNSIGNED, RONLY, var_igmpSnoopPortTable, 3, { 27, 1, 10 }},
    { LEAF_igmpSnoopPortNumGeneralQuerySend, ASN_UNSIGNED, RONLY, var_igmpSnoopPortTable, 3, { 27, 1, 11 }},
    { LEAF_igmpSnoopPortNumGeneralQueryRecevied, ASN_UNSIGNED, RONLY, var_igmpSnoopPortTable, 3, { 27, 1, 12 }},
    { LEAF_igmpSnoopPortNumSepcificQuerySend, ASN_UNSIGNED, RONLY, var_igmpSnoopPortTable, 3, { 27, 1, 13 }},
    { LEAF_igmpSnoopPortNumSpecificQueryReceived, ASN_UNSIGNED, RONLY, var_igmpSnoopPortTable, 3, { 27, 1, 14 }},
    { LEAF_igmpSnoopPortNumInvalidReport, ASN_UNSIGNED, RONLY, var_igmpSnoopPortTable, 3, { 27, 1, 15 }},
    { LEAF_igmpSnoopPortClearStatistics, ASN_INTEGER, RWRITE, var_igmpSnoopPortTable, 3, { 27, 1, 16 }},
#if (SYS_CPNT_IGMPAUTH== TRUE)
    { LEAF_igmpSnoopAuthentication, ASN_INTEGER, RWRITE, var_igmpSnoopPortTable, 3, { 27, 1, 17 }},
#endif

};

void init_igmpSnoopPortTable(void)
{
    oid igmpSnoopPortTable_variables_oid[] = {SYS_ADPT_PRIVATEMIB_OID,1,9  };

    REGISTER_MIB("igmpSnoopPortTable", igmpSnoopPortTable_variables, variable3,
                 igmpSnoopPortTable_variables_oid);
}

#if (SYS_CPNT_IGMPSNP_QUERY_DROP == TRUE)
/* variable3 igmpSnoopQueryDropTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */
struct variable3 igmpSnoopQueryDropTable_variables[] =
{
    /* magic number, variable type, ro/rw, callback fn, L, oidsuffix
     *     (L = length of the oidsuffix)
     */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_igmpSnoopQueryDropPortIndex, ASN_UNSIGNED, RONLY, var_igmpSnoopQueryDropTable, 3, { 30, 1, 1 }},
#endif  /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

    { LEAF_igmpSnoopQueryDropVlanBitmap, ASN_OCTET_STR, RWRITE, var_igmpSnoopQueryDropTable, 3, { 30, 1, 2 }},

};


void init_igmpSnoopQueryDropTable(void)
{
    oid igmpSnoopQueryDropTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,9 };

    /* Register ourselves with the agent to handle our MIB tree
     */
    REGISTER_MIB("igmpSnoopQueryDropTable", igmpSnoopQueryDropTable_variables, variable3,
                 igmpSnoopQueryDropTable_variables_oid);
}
#endif

void init_igmpSnoopClearDynamicGroups(void)
{
    static oid igmpSnoopClearDynamicGroups_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,9,32, 0 };

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("igmpSnoopClearDynamicGroups",
                               do_igmpSnoopClearDynamicGroups,
                               igmpSnoopClearDynamicGroups_oid,
                               OID_LENGTH(igmpSnoopClearDynamicGroups_oid),
                               HANDLER_CAN_RWRITE));
}

/* variable3 igmpSnoopVlanTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */
struct variable3 igmpSnoopVlanTable_variables[] =
{
    /* magic number, variable type, ro/rw, callback fn, L, oidsuffix
     *     (L = length of the oidsuffix)
     */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_igmpSnoopVlanIndex, ASN_UNSIGNED, RONLY, var_igmpSnoopVlanTable, 3, { 33, 1, 1 }},
#endif  /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

    { LEAF_igmpSnoopVlanNumGroups, ASN_UNSIGNED, RONLY, var_igmpSnoopVlanTable, 3, { 33, 1, 2 }},
    { LEAF_igmpSnoopVlanNumJoinSend, ASN_UNSIGNED, RONLY, var_igmpSnoopVlanTable, 3, { 33, 1, 3 }},
    { LEAF_igmpSnoopVlanNumJoins, ASN_UNSIGNED, RONLY, var_igmpSnoopVlanTable, 3, { 33, 1, 4 }},
    { LEAF_igmpSnoopVlanNumJoinSuccess, ASN_UNSIGNED, RONLY, var_igmpSnoopVlanTable, 3, { 33, 1, 5 }},
    { LEAF_igmpSnoopVlanNumLeavesSend, ASN_UNSIGNED, RONLY, var_igmpSnoopVlanTable, 3, { 33, 1, 6 }},
    { LEAF_igmpSnoopVlanNumLeaves, ASN_UNSIGNED, RONLY, var_igmpSnoopVlanTable, 3, { 33, 1, 7 }},
    { LEAF_igmpSnoopVlanNumGeneralQuerySend, ASN_UNSIGNED, RONLY, var_igmpSnoopVlanTable, 3, { 33, 1, 8 }},
    { LEAF_igmpSnoopVlanNumGeneralQueryRecevied, ASN_UNSIGNED, RONLY, var_igmpSnoopVlanTable, 3, { 33, 1, 9 }},
    { LEAF_igmpSnoopVlanNumSepcificQuerySend, ASN_UNSIGNED, RONLY, var_igmpSnoopVlanTable, 3, { 33, 1, 10 }},
    { LEAF_igmpSnoopVlanNumSpecificQueryReceived, ASN_UNSIGNED, RONLY, var_igmpSnoopVlanTable, 3, { 33, 1, 11 }},
    { LEAF_igmpSnoopVlanNumInvalidReport, ASN_UNSIGNED, RONLY, var_igmpSnoopVlanTable, 3, { 33, 1, 12 }},
    { LEAF_igmpSnoopVlanClearStatistics, ASN_INTEGER, RWRITE, var_igmpSnoopVlanTable, 3, { 33, 1, 13 }},
};

void init_igmpSnoopVlanTable(void)
{
    oid igmpSnoopVlanTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,9 };

    /* Register ourselves with the agent to handle our MIB tree
     */
    REGISTER_MIB("igmpSnoopVlanTable", igmpSnoopVlanTable_variables, variable3,
                 igmpSnoopVlanTable_variables_oid);
}
#endif /* #if (SYS_CPNT_IGMPSNP == TRUE) */

#if(SYS_CPNT_ROUTING==TRUE)
/********************************************
 ****** iPAddrTable************************
 ********************************************
 */
oid iPAddrTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,10 };

struct variable3 iPAddrTable_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
{IPADDRIFINDEX,  ASN_INTEGER,  RONLY,   var_iPAddrTable, 3,  { 16, 1, 1 }},
{IPADDRIPADDRESS,  ASN_IPADDRESS,  RONLY,   var_iPAddrTable, 3,  { 16, 1, 2 }},
{IPADDRSUBNETMASK,  ASN_IPADDRESS,  RONLY,   var_iPAddrTable, 3,  { 16, 1, 3 }},
#endif
{IPADDRPRIMARYINTERFACE,  ASN_INTEGER,  RWRITE,  var_iPAddrTable, 3,  { 16, 1, 4 }},
{IPADDRUNNUMBERED,  ASN_INTEGER,  RONLY,  var_iPAddrTable, 3,  { 16, 1, 5 }},
{IPADDRSTATUS,  ASN_INTEGER,  RWRITE,  var_iPAddrTable,3,  { 16, 1, 6 }},
};

/** Initializes the iPAddrTable module */
void
init_iPAddrTable(void)
{
    /* register ourselves with the agent to handle our mib tree */
    init_PrivateMIBNodeRootOIDbySwitchBoardID(iPAddrTable_variables_oid);
    REGISTER_MIB("iPAddrTable", iPAddrTable_variables, variable3,
               iPAddrTable_variables_oid);
}
#else
/********************************************
 ******netConfigTable************************
 ********************************************
 */
oid netConfigTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,10 };

struct variable3 netConfigTable_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
{NETCONFIGIFINDEX,  ASN_INTEGER,  RONLY,   var_netConfigTable, 3,  { 1, 1, 1 }},
{NETCONFIGIPADDRESS,  ASN_IPADDRESS,  RONLY,   var_netConfigTable, 3,  { 1, 1, 2 }},
{NETCONFIGSUBNETMASK,  ASN_IPADDRESS,  RONLY,   var_netConfigTable, 3,  { 1, 1, 3 }},
#endif
{NETCONFIGPRIMARYINTERFACE,  ASN_INTEGER,  RWRITE,  var_netConfigTable, 3,  { 1, 1, 4 }},
{NETCONFIGUNNUMBERED,  ASN_INTEGER,  RONLY,  var_netConfigTable, 3,  { 1, 1, 5}},
{NETCONFIGSTATUS,  ASN_INTEGER,  RWRITE,  var_netConfigTable, 3,  { 1, 1, 6 }},
};

/** Initializes the netConfigTable module */
void
init_netConfigTable(void)
{
    /* register ourselves with the agent to handle our mib tree */
    init_PrivateMIBNodeRootOIDbySwitchBoardID(netConfigTable_variables_oid);
    REGISTER_MIB("netConfigTable", netConfigTable_variables, variable3,
               netConfigTable_variables_oid);
}
#endif

/********************************************
 ***************ipMgt************************
 ********************************************
 */
void
init_ipMgt(void)
{
#if (SYS_CPNT_HTTPS == TRUE)
    static oid ipHttpsState_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,10,6, 0 };
    static oid ipHttpsPort_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,10,7, 0 };
#endif
#if (SYS_CPNT_HTTP == TRUE)
    static oid ipHttpState_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,10,3, 0 };
    static oid ipHttpPort_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,10,4, 0 };
#endif
    static oid ipDhcpRestart_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,10,5, 0 };
    static oid netDefaultGateway_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,10,2, 0 };

#if (SYS_CPNT_HTTP == TRUE)
    init_PrivateMIBNodeRootOIDbySwitchBoardID(ipHttpPort_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("ipHttpPort",
                              do_ipHttpPort,
                              ipHttpPort_oid,
                              OID_LENGTH(ipHttpPort_oid),
                              HANDLER_CAN_RWRITE));
    init_PrivateMIBNodeRootOIDbySwitchBoardID(ipHttpState_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("ipHttpState",
                              do_ipHttpState,
                              ipHttpState_oid,
                              OID_LENGTH(ipHttpState_oid),
                              HANDLER_CAN_RWRITE));
#endif
#if (SYS_CPNT_HTTPS == TRUE)
    init_PrivateMIBNodeRootOIDbySwitchBoardID(ipHttpsPort_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("ipHttpsPort",
                              do_ipHttpsPort,
                              ipHttpsPort_oid,
                              OID_LENGTH(ipHttpsPort_oid),
                              HANDLER_CAN_RWRITE));
    init_PrivateMIBNodeRootOIDbySwitchBoardID(ipHttpsState_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("ipHttpsState",
                              do_ipHttpsState,
                              ipHttpsState_oid,
                              OID_LENGTH(ipHttpsState_oid),
                              HANDLER_CAN_RWRITE));
#endif
    init_PrivateMIBNodeRootOIDbySwitchBoardID(ipDhcpRestart_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("ipDhcpRestart",
                               do_ipDhcpRestart,
                               ipDhcpRestart_oid,
                               OID_LENGTH(ipDhcpRestart_oid),
                               HANDLER_CAN_RWRITE));
    init_PrivateMIBNodeRootOIDbySwitchBoardID(netDefaultGateway_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("netDefaultGateway",
                               do_netDefaultGateway,
                               netDefaultGateway_oid,
                               OID_LENGTH(netDefaultGateway_oid),
                               HANDLER_CAN_RWRITE));
}


/********************************************
 **************dhcpcInterfaceTable***********
 ********************************************
 */
#if (SYS_CPNT_DHCP_CLIENT == TRUE)

oid dhcpcInterfaceTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,10,11,1,1 };

struct variable3 dhcpcInterfaceTable_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
{LEAF_dhcpcIfIndex,  ASN_INTEGER,  RONLY,   var_dhcpcInterfaceTable, 3,  { 1, 1, 1 }},
#endif

/* Deprecated
 */
#if 0
{LEAF_dhcpcIfClientIdMode,  ASN_INTEGER,  RWRITE,  var_dhcpcInterfaceTable, 3,  { 1, 1, 2 }},
{LEAF_dhcpcIfClientId,  ASN_OCTET_STR,  RWRITE,  var_dhcpcInterfaceTable, 3,  { 1, 1, 3 }},
#endif
{LEAF_dhcpcIfVendorClassIdMode,  ASN_INTEGER,  RWRITE,  var_dhcpcInterfaceTable, 3,  { 1, 1, 4 }},
{LEAF_dhcpcIfVendorClassId,  ASN_OCTET_STR,  RWRITE,  var_dhcpcInterfaceTable, 3,  { 1, 1, 5 }},
};

/** Initializes the dhcpcInterfaceTable module */
void
init_dhcpcInterfaceTable(void)
{
    /* register ourselves with the agent to handle our mib tree */
    init_PrivateMIBNodeRootOIDbySwitchBoardID(dhcpcInterfaceTable_variables_oid);
    REGISTER_MIB("dhcpcInterfaceTable", dhcpcInterfaceTable_variables, variable3,
               dhcpcInterfaceTable_variables_oid);
}
#endif

#if (SYS_CPNT_DHCP_RELAY == TRUE)
/********************************************
 *******************dhcpRelay****************
 ********************************************
 */
void
init_dhcpRelay(void)
{
    static oid      dhcpRelayRestart_oid[] =
        { SYS_ADPT_PRIVATEMIB_OID, 1, 10, 11, 2, 3, 0 };

    init_PrivateMIBNodeRootOIDbySwitchBoardID(dhcpRelayRestart_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("dhcpRelayRestart",
                               do_dhcpRelayRestart,
                               dhcpRelayRestart_oid,
                               OID_LENGTH(dhcpRelayRestart_oid),
                               HANDLER_CAN_RWRITE));
}

/********************************************
 ************dhcpRelayServerAddrTable********
 ********************************************
 */
oid             dhcpRelayServerAddrTable_variables_oid[] =
    { SYS_ADPT_PRIVATEMIB_OID, 1, 10, 11, 2 };

struct variable3 dhcpRelayServerAddrTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    {DHCPRELAYSERVERADDRIFINDEX, ASN_INTEGER, RONLY,
     var_dhcpRelayServerAddrTable, 3, {2, 1, 1}},
    {DHCPRELAYSERVERADDRINDEX, ASN_INTEGER, RONLY,
     var_dhcpRelayServerAddrTable, 3, {2, 1, 2}},
#endif
    {DHCPRELAYSERVERADDRSERVERIP, ASN_IPADDRESS, RWRITE,
     var_dhcpRelayServerAddrTable, 3, {2, 1, 3}},
};

/** Initializes the dhcpRelayServerAddrTable module */
void
init_dhcpRelayServerAddrTable(void)
{

    /*
     * register ourselves with the agent to handle our mib tree
     */
    init_PrivateMIBNodeRootOIDbySwitchBoardID(dhcpRelayServerAddrTable_variables_oid);
    REGISTER_MIB("dhcpRelayServerAddrTable",
                 dhcpRelayServerAddrTable_variables, variable3,
                 dhcpRelayServerAddrTable_variables_oid);

}

/********************************************
 ************dhcpRelayServerInetAddrTable********
 ********************************************
 */
oid             dhcpRelayServerInetAddrTable_variables_oid[] =
    { SYS_ADPT_PRIVATEMIB_OID, 1, 10, 11, 2 };

struct variable3 dhcpRelayServerInetAddrTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    {DHCPRELAYSERVERINETADDRIFINDEX, ASN_INTEGER, RONLY,
     var_dhcpRelayServerAddrTable, 3, {4, 1, 1}},
    {DHCPRELAYSERVERINETADDRINDEX, ASN_INTEGER, RONLY,
     var_dhcpRelayServerAddrTable, 3, {4, 1, 2}},
#endif
    {DHCPRELAYSERVERINETADDRTYPE, ASN_INTEGER, RWRITE,
     var_dhcpRelayServerAddrTable, 3, {4, 1, 3}},
    {DHCPRELAYSERVERINETADDR, ASN_OCTET_STR, RWRITE,
     var_dhcpRelayServerAddrTable, 3, {4, 1, 4}},
};

/** Initializes the dhcpRelayServerAddrTable module */
void
init_dhcpRelayServerInetAddrTable(void)
{

    /*
     * register ourselves with the agent to handle our mib tree
     */
    init_PrivateMIBNodeRootOIDbySwitchBoardID(dhcpRelayServerInetAddrTable_variables_oid);
    REGISTER_MIB("dhcpRelayServerInetAddrTable",
                 dhcpRelayServerInetAddrTable_variables, variable3,
                 dhcpRelayServerInetAddrTable_variables_oid);

}

#endif /* end of #if (SYS_CPNT_DHCP_RELAY == TRUE)*/

#if (SYS_CPNT_DHCP_SERVER == TRUE)
/********************************************
 **************dhcpServerMgt*****************
 ********************************************
 */
void
init_dhcpServerMgt(void)
{
    static oid      dhcpServerServiceStatus_oid[] =
        { SYS_ADPT_PRIVATEMIB_OID, 1, 10, 11, 3, 8, 0 };

    init_PrivateMIBNodeRootOIDbySwitchBoardID(dhcpServerServiceStatus_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("dhcpServerServiceStatus",
                               do_dhcpServerServiceStatus,
                               dhcpServerServiceStatus_oid,
                               OID_LENGTH(dhcpServerServiceStatus_oid),
                               HANDLER_CAN_RWRITE));
}
#if 0 /* shumin.wang added for inet address, 2008-12-30 */
/********************************************
 **************dhcpPoolTable*****************
 ********************************************
 */
oid             dhcpPoolTable_variables_oid[] =
    { SYS_ADPT_PRIVATEMIB_OID, 1, 10, 11, 3};

struct variable3 dhcpPoolTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    {DHCPPOOLPOOLNAME, ASN_OCTET_STR, RONLY, var_dhcpPoolTable, 3,
     {1, 1, 1}},
#endif
    {DHCPPOOLPOOLTYPE, ASN_INTEGER, RWRITE, var_dhcpPoolTable, 3,
     {1, 1, 2}},
    {DHCPPOOLPOOLADDRESS, ASN_IPADDRESS, RWRITE, var_dhcpPoolTable, 3,
     {1, 1, 3}},
    {DHCPPOOLSUBNETMASK, ASN_IPADDRESS, RWRITE, var_dhcpPoolTable, 3,
     {1, 1, 4}},
    {DHCPPOOLHARDWARETYPE, ASN_INTEGER, RWRITE, var_dhcpPoolTable, 3,
     {1, 1, 5}},
    {DHCPPOOLMACADDRESS, ASN_OCTET_STR, RWRITE, var_dhcpPoolTable, 3,
     {1, 1, 6}},
    {DHCPPOOLSTATUS, ASN_INTEGER, RWRITE, var_dhcpPoolTable, 3, {1, 1, 7}},
};

/** Initializes the dhcpPoolTable module */
void
init_dhcpPoolTable(void)
{
    /*
     * register ourselves with the agent to handle our mib tree
     */
    init_PrivateMIBNodeRootOIDbySwitchBoardID(dhcpPoolTable_variables_oid);
    REGISTER_MIB("dhcpPoolTable", dhcpPoolTable_variables, variable3,
                 dhcpPoolTable_variables_oid);
}

/********************************************
 ********dhcpPoolOptionTable*****************
 ********************************************
 */
oid             dhcpPoolOptionTable_variables_oid[] =
    { SYS_ADPT_PRIVATEMIB_OID, 1, 10, 11, 3};


struct variable3 dhcpPoolOptionTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    {DHCPPOOLOPTIONPOOLNAME, ASN_OCTET_STR, RONLY, var_dhcpPoolOptionTable,
     3, {2, 1, 1}},
#endif
    {DHCPPOOLOPTIONNEXTSERVER, ASN_IPADDRESS, RWRITE,
     var_dhcpPoolOptionTable, 3, {2, 1, 2}},
    {DHCPPOOLOPTIONNETBIOSNODETYPE, ASN_INTEGER, RWRITE,
     var_dhcpPoolOptionTable, 3, {2, 1, 3}},
    {DHCPPOOLOPTIONDOMAINNAME, ASN_OCTET_STR, RWRITE,
     var_dhcpPoolOptionTable, 3, {2, 1, 4}},
    {DHCPPOOLOPTIONBOOTFILE, ASN_OCTET_STR, RWRITE,
     var_dhcpPoolOptionTable, 3, {2, 1, 5}},
    {DHCPPOOLOPTIONLEASETIME, ASN_INTEGER, RWRITE, var_dhcpPoolOptionTable,
     3, {2, 1, 6}},
    {DHCPPOOLOPTIONCIDMODE, ASN_INTEGER, RWRITE, var_dhcpPoolOptionTable,
     3, {2, 1, 7}},
    {DHCPPOOLOPTIONCIDBUFFER, ASN_OCTET_STR, RWRITE,
     var_dhcpPoolOptionTable, 3, {2, 1, 8}},
};

/** Initializes the dhcpPoolOptionTable module */
void
init_dhcpPoolOptionTable(void)
{
    /*
     * register ourselves with the agent to handle our mib tree
     */
    init_PrivateMIBNodeRootOIDbySwitchBoardID(dhcpPoolOptionTable_variables_oid);
    REGISTER_MIB("dhcpPoolOptionTable", dhcpPoolOptionTable_variables,
                 variable3, dhcpPoolOptionTable_variables_oid);
}

/********************************************
 ********dhcpPoolOptionDnsSerTable***********
 ********************************************
 */
oid             dhcpPoolOptionDnsSerTable_variables_oid[] =
    { SYS_ADPT_PRIVATEMIB_OID, 1, 10, 11, 3 };

struct variable3 dhcpPoolOptionDnsSerTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    {DHCPPOOLOPTIONDNSSERPOOLNAME, ASN_OCTET_STR, RONLY,
     var_dhcpPoolOptionDnsSerTable, 3, {3, 1, 1}},
    {DHCPPOOLOPTIONDNSSERINDEX, ASN_INTEGER, RONLY,
     var_dhcpPoolOptionDnsSerTable, 3, {3, 1, 2}},
#endif
    {DHCPPOOLOPTIONDNSSERIPADDRESS, ASN_IPADDRESS, RWRITE,
     var_dhcpPoolOptionDnsSerTable, 3, {3, 1, 3}},
};

/** Initializes the dhcpPoolOptionDnsSerTable module */
void
init_dhcpPoolOptionDnsSerTable(void)
{
    /*
     * register ourselves with the agent to handle our mib tree
     */
    init_PrivateMIBNodeRootOIDbySwitchBoardID(dhcpPoolOptionDnsSerTable_variables_oid);
    REGISTER_MIB("dhcpPoolOptionDnsSerTable",
                 dhcpPoolOptionDnsSerTable_variables, variable3,
                 dhcpPoolOptionDnsSerTable_variables_oid);
}

/********************************************
 ********dhcpPoolOptDefaultRouterTable*******
 ********************************************
 */
oid             dhcpPoolOptDefaultRouterTable_variables_oid[] =
    { SYS_ADPT_PRIVATEMIB_OID, 1, 10, 11, 3 };

struct variable3 dhcpPoolOptDefaultRouterTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    {DHCPPOOLOPTDEFAULTROUTERPOOLNAME, ASN_OCTET_STR, RONLY,
     var_dhcpPoolOptDefaultRouterTable, 3, {4, 1, 1}},
    {DHCPPOOLOPTDEFAULTROUTERINDEX, ASN_INTEGER, RONLY,
     var_dhcpPoolOptDefaultRouterTable, 3, {4, 1, 2}},
#endif
    {DHCPPOOLOPTDEFAULTROUTERIPADDRESS, ASN_IPADDRESS, RWRITE,
     var_dhcpPoolOptDefaultRouterTable, 3, {4, 1, 3}},
};

/** Initializes the dhcpPoolOptDefaultRouterTable module */
void
init_dhcpPoolOptDefaultRouterTable(void)
{
    /*
     * register ourselves with the agent to handle our mib tree
     */
    init_PrivateMIBNodeRootOIDbySwitchBoardID(dhcpPoolOptDefaultRouterTable_variables_oid);
    REGISTER_MIB("dhcpPoolOptDefaultRouterTable",
                 dhcpPoolOptDefaultRouterTable_variables, variable3,
                 dhcpPoolOptDefaultRouterTable_variables_oid);
}

/********************************************
 ********dhcpPoolOptNetbiosServerTable*******
 ********************************************
 */
oid             dhcpPoolOptNetbiosServerTable_variables_oid[] =
    { SYS_ADPT_PRIVATEMIB_OID, 1, 10, 11, 3 };

struct variable3 dhcpPoolOptNetbiosServerTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    {DHCPPOOLOPTNETBIOSSERVERPOOLNAME, ASN_OCTET_STR, RONLY,
     var_dhcpPoolOptNetbiosServerTable, 3, {5, 1, 1}},
    {DHCPPOOLOPTNETBIOSSERVERINDEX, ASN_INTEGER, RONLY,
     var_dhcpPoolOptNetbiosServerTable, 3, {5, 1, 2}},
#endif
    {DHCPPOOLOPTNETBIOSSERVERIPADDRESS, ASN_IPADDRESS, RWRITE,
     var_dhcpPoolOptNetbiosServerTable, 3, {5, 1, 3}},
};


/** Initializes the dhcpPoolOptNetbiosServerTable module */
void
init_dhcpPoolOptNetbiosServerTable(void)
{
    /*
     * register ourselves with the agent to handle our mib tree
     */
    init_PrivateMIBNodeRootOIDbySwitchBoardID(dhcpPoolOptNetbiosServerTable_variables_oid);
    REGISTER_MIB("dhcpPoolOptNetbiosServerTable",
                 dhcpPoolOptNetbiosServerTable_variables, variable3,
                 dhcpPoolOptNetbiosServerTable_variables_oid);
}

/********************************************
 ********dhcpServerExcludedIpAddrTable*******
 ********************************************
 */
oid             dhcpServerExcludedIpAddrTable_variables_oid[] =
    { SYS_ADPT_PRIVATEMIB_OID, 1, 10, 11, 3 };

struct variable3 dhcpServerExcludedIpAddrTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    {DHCPSERVEREXCLUDEDIPADDRLOWIP, ASN_IPADDRESS, RONLY,
     var_dhcpServerExcludedIpAddrTable, 3, {6, 1, 1}},
    {DHCPSERVEREXCLUDEDIPADDRHIIP, ASN_IPADDRESS, RONLY,
     var_dhcpServerExcludedIpAddrTable, 3, {6, 1, 2}},
#endif
    {DHCPSERVEREXCLUDEDIPADDRSTATUS, ASN_INTEGER, RWRITE,
     var_dhcpServerExcludedIpAddrTable, 3, {6, 1, 3}},
};


/** Initializes the dhcpServerExcludedIpAddrTable module */
void
init_dhcpServerExcludedIpAddrTable(void)
{
    /*
     * register ourselves with the agent to handle our mib tree
     */
    init_PrivateMIBNodeRootOIDbySwitchBoardID(dhcpServerExcludedIpAddrTable_variables_oid);
    REGISTER_MIB("dhcpServerExcludedIpAddrTable",
                 dhcpServerExcludedIpAddrTable_variables, variable3,
                 dhcpServerExcludedIpAddrTable_variables_oid);
}

/********************************************
 ********dhcpServerLeaseBindingTable*********
 ********************************************
 */
oid             dhcpServerLeaseBindingTable_variables_oid[] =
    { SYS_ADPT_PRIVATEMIB_OID, 1, 10, 11, 3 };


struct variable3 dhcpServerLeaseBindingTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    {DHCPSERVERLEASEBINDINGIP, ASN_IPADDRESS, RONLY,
     var_dhcpServerLeaseBindingTable, 3, {7, 1, 1}},
#endif
    {DHCPSERVERLEASEBINDINGMAC, ASN_OCTET_STR, RONLY,
     var_dhcpServerLeaseBindingTable, 3, {7, 1, 2}},
    {DHCPSERVERLEASEBINDINGLEASETIME, ASN_INTEGER, RONLY,
     var_dhcpServerLeaseBindingTable, 3, {7, 1, 3}},
    {DHCPSERVERLEASEBINDINGSTARTTIME, ASN_OCTET_STR, RONLY,
     var_dhcpServerLeaseBindingTable, 3, {7, 1, 4}},
    {DHCPSERVERLEASEBINDINGSTATUS, ASN_INTEGER, RWRITE,
     var_dhcpServerLeaseBindingTable, 3, {7, 1, 5}},
};


/** Initializes the dhcpServerLeaseBindingTable module */
void
init_dhcpServerLeaseBindingTable(void)
{
    /*
     * register ourselves with the agent to handle our mib tree
     */
    init_PrivateMIBNodeRootOIDbySwitchBoardID(dhcpServerLeaseBindingTable_variables_oid);
    REGISTER_MIB("dhcpServerLeaseBindingTable",
                 dhcpServerLeaseBindingTable_variables, variable3,
                 dhcpServerLeaseBindingTable_variables_oid);
}
#else
/********************************************
 **************dhcpPoolInetTable*****************
 ********************************************
 */
/* shumin.wang added for inet address, 2008-12-30 */
oid             dhcpPoolInetTable_variables_oid[] =
    { SYS_ADPT_PRIVATEMIB_OID, 1, 10, 11, 3};

struct variable3 dhcpPoolInetTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    {DHCPPOOLINETPOOLNAME, ASN_OCTET_STR, RONLY, var_dhcpPoolInetTable, 3,
     {9, 1, 1}},
#endif
    {DHCPPOOLINETPOOLTYPE, ASN_INTEGER, RWRITE, var_dhcpPoolInetTable, 3,
     {9, 1, 2}},
    {DHCPPOOLINETADDRESSTYPE, ASN_INTEGER, RWRITE, var_dhcpPoolInetTable, 3,
     {9, 1, 3}},
    {DHCPPOOLINETADDRESS, ASN_OCTET_STR, RWRITE, var_dhcpPoolInetTable, 3,
     {9, 1, 4}},
    {DHCPPOOLINETSUBNETMASKTYPE, ASN_INTEGER, RWRITE, var_dhcpPoolInetTable, 3,
     {9, 1, 5}},
    {DHCPPOOLINETSUBNETMASK, ASN_OCTET_STR, RWRITE, var_dhcpPoolInetTable, 3,
     {9, 1, 6}},
    {DHCPPOOLINETHARDWARETYPE, ASN_INTEGER, RWRITE, var_dhcpPoolInetTable, 3,
     {9, 1, 7}},
    {DHCPPOOLINETMACADDRESS, ASN_OCTET_STR, RWRITE, var_dhcpPoolInetTable, 3,
     {9, 1, 8}},
    {DHCPPOOLINETSTATUS, ASN_INTEGER, RWRITE, var_dhcpPoolInetTable, 3,
     {9, 1, 9}},
};

/** Initializes the dhcpPoolInetTable module */
void
init_dhcpPoolInetTable(void)
{
    /*
     * register ourselves with the agent to handle our mib tree
     */
    init_PrivateMIBNodeRootOIDbySwitchBoardID(dhcpPoolInetTable_variables_oid);
    REGISTER_MIB("dhcpPoolInetTable", dhcpPoolInetTable_variables, variable3,
                 dhcpPoolInetTable_variables_oid);
}

/********************************************
 ********dhcpPoolInetOptionTable*****************
 ********************************************
 */
oid             dhcpPoolInetOptionTable_variables_oid[] =
    { SYS_ADPT_PRIVATEMIB_OID, 1, 10, 11, 3};


struct variable3 dhcpPoolInetOptionTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    {DHCPPOOLINETOPTIONPOOLNAME, ASN_OCTET_STR, RONLY, var_dhcpPoolInetOptionTable,
     3, {2, 1, 1}},
#endif
    {DHCPPOOLINETOPTIONNEXTSERVERTYPE, ASN_INTEGER, RWRITE,
     var_dhcpPoolInetOptionTable, 3, {10, 1, 2}},
    {DHCPPOOLINETOPTIONNEXTSERVER, ASN_OCTET_STR, RWRITE,
     var_dhcpPoolInetOptionTable, 3, {10, 1, 3}},
    {DHCPPOOLINETOPTIONNETBIOSNODETYPE, ASN_INTEGER, RWRITE,
     var_dhcpPoolInetOptionTable, 3, {10, 1, 4}},
    {DHCPPOOLINETOPTIONDOMAINNAME, ASN_OCTET_STR, RWRITE,
     var_dhcpPoolInetOptionTable, 3, {10, 1, 5}},
    {DHCPPOOLINETOPTIONBOOTFILE, ASN_OCTET_STR, RWRITE,
     var_dhcpPoolInetOptionTable, 3, {10, 1, 6}},
    {DHCPPOOLINETOPTIONLEASETIME, ASN_INTEGER, RWRITE,
     var_dhcpPoolInetOptionTable,  3, {10, 1, 7}},
    {DHCPPOOLINETOPTIONCIDMODE, ASN_INTEGER, RWRITE,
     var_dhcpPoolInetOptionTable,  3, {10, 1, 8}},
    {DHCPPOOLINETOPTIONCIDBUFFER, ASN_OCTET_STR, RWRITE,
     var_dhcpPoolInetOptionTable, 3, {10, 1, 9}},
};

/** Initializes the dhcpPoolInetOptionTable module */
void
init_dhcpPoolInetOptionTable(void)
{
    /*
     * register ourselves with the agent to handle our mib tree
     */
    init_PrivateMIBNodeRootOIDbySwitchBoardID(dhcpPoolInetOptionTable_variables_oid);
    REGISTER_MIB("dhcpPoolOptionTable", dhcpPoolInetOptionTable_variables,
                 variable3, dhcpPoolInetOptionTable_variables_oid);
}

/********************************************
 ********dhcpPoolInetOptionDnsSerTable***********
 ********************************************
 */
oid             dhcpPoolInetOptionDnsSerTable_variables_oid[] =
    { SYS_ADPT_PRIVATEMIB_OID, 1, 10, 11, 3 };

struct variable3 dhcpPoolInetOptionDnsSerTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    {DHCPPOOLINETOPTIONDNSSERPOOLNAME, ASN_OCTET_STR, RONLY,
     var_dhcpPoolInetOptionDnsSerTable, 3, {11, 1, 1}},
    {DHCPPOOLINETOPTIONDNSSERINDEX, ASN_INTEGER, RONLY,
     var_dhcpPoolInetOptionDnsSerTable, 3, {11, 1, 2}},
#endif
    {DHCPPOOLINETOPTIONDNSSERIPADDRESSTYPE, ASN_INTEGER, RWRITE,
     var_dhcpPoolInetOptionDnsSerTable, 3, {11, 1, 3}},
    {DHCPPOOLINETOPTIONDNSSERIPADDRESS, ASN_OCTET_STR, RWRITE,
     var_dhcpPoolInetOptionDnsSerTable, 3, {11, 1, 4}},
};

/* Initializes the dhcpPoolInetOptionDnsSerTable module */
void
init_dhcpPoolInetOptionDnsSerTable(void)
{
    /*
     * register ourselves with the agent to handle our mib tree
     */
    init_PrivateMIBNodeRootOIDbySwitchBoardID(dhcpPoolInetOptionDnsSerTable_variables_oid);
    REGISTER_MIB("dhcpPoolOptionDnsSerTable",
                 dhcpPoolInetOptionDnsSerTable_variables, variable3,
                 dhcpPoolInetOptionDnsSerTable_variables_oid);
}

/********************************************
 ********dhcpPoolOptInetDefaultRouterTable*******
 ********************************************
 */
oid             dhcpPoolOptInetDefaultRouterTable_variables_oid[] =
    { SYS_ADPT_PRIVATEMIB_OID, 1, 10, 11, 3 };

struct variable3 dhcpPoolOptInetDefaultRouterTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    {DHCPPOOLOPTINETDEFAULTROUTERPOOLNAME, ASN_OCTET_STR, RONLY,
     var_dhcpPoolOptInetDefaultRouterTable, 3, {12, 1, 1}},
    {DHCPPOOLOPTINETDEFAULTROUTERINDEX, ASN_INTEGER, RONLY,
     var_dhcpPoolOptInetDefaultRouterTable, 3, {12, 1, 2}},
#endif
    {DHCPPOOLOPTINETDEFAULTROUTERIPADDRESSTYPE, ASN_INTEGER, RWRITE,
     var_dhcpPoolOptInetDefaultRouterTable, 3, {12, 1, 3}},
    {DHCPPOOLOPTINETDEFAULTROUTERIPADDRESS, ASN_OCTET_STR, RWRITE,
     var_dhcpPoolOptInetDefaultRouterTable, 3, {12, 1, 4}},
};

/** Initializes the dhcpPoolOptInetDefaultRouterTable module */
void
init_dhcpPoolOptInetDefaultRouterTable(void)
{
    /*
     * register ourselves with the agent to handle our mib tree
     */
    init_PrivateMIBNodeRootOIDbySwitchBoardID(dhcpPoolOptInetDefaultRouterTable_variables_oid);
    REGISTER_MIB("dhcpPoolOptDefaultRouterTable",
                 dhcpPoolOptInetDefaultRouterTable_variables, variable3,
                 dhcpPoolOptInetDefaultRouterTable_variables_oid);
}

/********************************************
 ********dhcpPoolOptInetNetbiosServerTable*******
 ********************************************
 */
oid             dhcpPoolOptInetNetbiosServerTable_variables_oid[] =
    { SYS_ADPT_PRIVATEMIB_OID, 1, 10, 11, 3 };

struct variable3 dhcpPoolOptInetNetbiosServerTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    {DHCPPOOLOPTINETNETBIOSSERVERPOOLNAME, ASN_OCTET_STR, RONLY,
     var_dhcpPoolOptInetNetbiosServerTable, 3, {13, 1, 1}},
    {DHCPPOOLOPTINETNETBIOSSERVERINDEX, ASN_INTEGER, RONLY,
     var_dhcpPoolOptInetNetbiosServerTable, 3, {13, 1, 2}},
#endif
    {DHCPPOOLOPTINETNETBIOSSERVERIPADDRESSTYPE, ASN_INTEGER, RWRITE,
     var_dhcpPoolOptInetNetbiosServerTable, 3, {13, 1, 3}},
    {DHCPPOOLOPTINETNETBIOSSERVERIPADDRESS, ASN_OCTET_STR, RWRITE,
     var_dhcpPoolOptInetNetbiosServerTable, 3, {13, 1, 4}},
};


/** Initializes the dhcpPoolOptInetNetbiosServerTable module */
void
init_dhcpPoolOptInetNetbiosServerTable(void)
{
    /*
     * register ourselves with the agent to handle our mib tree
     */
    init_PrivateMIBNodeRootOIDbySwitchBoardID(dhcpPoolOptInetNetbiosServerTable_variables_oid);
    REGISTER_MIB("dhcpPoolOptNetbiosServerTable",
                 dhcpPoolOptInetNetbiosServerTable_variables, variable3,
                 dhcpPoolOptInetNetbiosServerTable_variables_oid);
}

/********************************************
 ********dhcpServerExcludedInetAddrTable*******
 ********************************************
 */
oid             dhcpServerExcludedInetAddrTable_variables_oid[] =
    { SYS_ADPT_PRIVATEMIB_OID, 1, 10, 11, 3 };

struct variable3 dhcpServerExcludedInetAddrTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    {DHCPSERVEREXCLUDEDINETADDRLOWADDRTYPE, ASN_INTEGER, RONLY,
     var_dhcpServerExcludedInetAddrTable, 3, {14, 1, 1}},
    {DHCPSERVEREXCLUDEDINETADDRLOWADDR, ASN_OCTET_STR, RONLY,
     var_dhcpServerExcludedInetAddrTable, 3, {14, 1, 2}},
    {DHCPSERVEREXCLUDEDINETADDRHIGHADDRTYPE, ASN_INTEGER, RONLY,
     var_dhcpServerExcludedInetAddrTable, 3, {14, 1, 3}},
    {DHCPSERVEREXCLUDEDINETADDRHIGHADDR, ASN_OCTET_STR, RONLY,
     var_dhcpServerExcludedInetAddrTable, 3, {14, 1, 4}},
#endif
    {DHCPSERVEREXCLUDEDINETADDRSTATUS, ASN_INTEGER, RWRITE,
     var_dhcpServerExcludedInetAddrTable, 3, {14, 1, 5}},
};


/** Initializes the dhcpServerExcludedInetAddrTable module */
void
init_dhcpServerExcludedInetAddrTable(void)
{
    /*
     * register ourselves with the agent to handle our mib tree
     */
    init_PrivateMIBNodeRootOIDbySwitchBoardID(dhcpServerExcludedInetAddrTable_variables_oid);
    REGISTER_MIB("dhcpServerExcludedIpAddrTable",
                 dhcpServerExcludedInetAddrTable_variables, variable3,
                 dhcpServerExcludedInetAddrTable_variables_oid);
}

/********************************************
 ********dhcpServerInetLeaseBindingTable*********
 ********************************************
 */
oid             dhcpServerInetLeaseBindingTable_variables_oid[] =
    { SYS_ADPT_PRIVATEMIB_OID, 1, 10, 11, 3 };


struct variable3 dhcpServerInetLeaseBindingTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    {DHCPSERVERINETLEASEBINDINGADDRTYPE, ASN_INTEGER, RONLY,
     var_dhcpServerInetLeaseBindingTable, 3, {15, 1, 1}},
    {DHCPSERVERINETLEASEBINDINGADDR, ASN_OCTET_STR, RONLY,
     var_dhcpServerInetLeaseBindingTable, 3, {15, 1, 2}},
#endif
    {DHCPSERVERINETLEASEBINDINGMAC, ASN_OCTET_STR, RONLY,
     var_dhcpServerInetLeaseBindingTable, 3, {15, 1, 3}},
    {DHCPSERVERINETLEASEBINDINGLEASETIME, ASN_INTEGER, RONLY,
     var_dhcpServerInetLeaseBindingTable, 3, {15, 1, 4}},
    {DHCPSERVERINETLEASEBINDINGSTARTTIME, ASN_OCTET_STR, RONLY,
     var_dhcpServerInetLeaseBindingTable, 3, {15, 1, 5}},
    {DHCPSERVERINETLEASEBINDINGSTATUS, ASN_INTEGER, RWRITE,
     var_dhcpServerInetLeaseBindingTable, 3, {15, 1, 6}},
};


/** Initializes the dhcpServerInetLeaseBindingTable module */
void
init_dhcpServerInetLeaseBindingTable(void)
{
    /*
     * register ourselves with the agent to handle our mib tree
     */
    init_PrivateMIBNodeRootOIDbySwitchBoardID(dhcpServerInetLeaseBindingTable_variables_oid);
    REGISTER_MIB("dhcpServerLeaseBindingTable",
                 dhcpServerInetLeaseBindingTable_variables, variable3,
                 dhcpServerInetLeaseBindingTable_variables_oid);
}
#endif
#endif /* end of #if (SYS_CPNT_DHCP_SERVER == TRUE)*/

#if (SYS_CPNT_PIM == TRUE)

oid pimRpInetAddrTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,10,17 };

/* variable3 pimRpInetAddrTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */
struct variable3 pimRpInetAddrTable_variables[] =
{
/* magic number, variable type, ro/rw, callback fn, L, oidsuffix
 */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_pimRpInetAddrType, ASN_INTEGER, RONLY, var_pimRpInetAddrTable, 3, { 5, 1, 1 }},
    { LEAF_pimRpInetAddr, ASN_OCTET_STR, RONLY, var_pimRpInetAddrTable, 3, { 5, 1, 2 }},
    { LEAF_pimRpInetAddrGroupAddr, ASN_OCTET_STR, RONLY, var_pimRpInetAddrTable, 3, { 5, 1, 3 }},
    { LEAF_pimRpInetAddrGroupAddrPrefixLength, ASN_UNSIGNED, RONLY, var_pimRpInetAddrTable, 3, { 5, 1, 4 }},
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

    { LEAF_pimRpInetAddrOverride, ASN_INTEGER, RWRITE, var_pimRpInetAddrTable, 3, { 5, 1, 5 }},
    { LEAF_pimRpInetAddrStatus, ASN_INTEGER, RWRITE, var_pimRpInetAddrTable, 3, { 5, 1, 6 }},
};

oid pimInterfaceTablePrivate_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,10,17 };

/* variable3 pimInterfaceTablePrivate_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */
struct variable3 pimInterfaceTablePrivate_variables[] =
{
/* magic number, variable type, ro/rw, callback fn, L, oidsuffix
 */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_pimInterfaceIfIndex, ASN_INTEGER, RONLY, var_pimInterfaceTablePrivate, 3, { 6, 1, 1 }},
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

    { LEAF_pimInterfaceTrigHelloInterval, ASN_INTEGER, RWRITE, var_pimInterfaceTablePrivate, 3, { 6, 1, 2 }},
    { LEAF_pimInterfaceHelloHoldtime, ASN_INTEGER, RWRITE, var_pimInterfaceTablePrivate, 3, { 6, 1, 3 }},
    { LEAF_pimInterfaceJoinPruneHoldTime, ASN_INTEGER, RWRITE, var_pimInterfaceTablePrivate, 3, { 6, 1, 4 }},
    { LEAF_pimInterfaceLanPruneDelay, ASN_INTEGER, RWRITE, var_pimInterfaceTablePrivate, 3, { 6, 1, 5 }},
    { LEAF_pimInterfacePropagationDelay, ASN_INTEGER, RWRITE, var_pimInterfaceTablePrivate, 3, { 6, 1, 6 }},
    { LEAF_pimInterfaceOverrideInterval, ASN_INTEGER, RWRITE, var_pimInterfaceTablePrivate, 3, { 6, 1, 7 }},
    { LEAF_pimInterfaceDrPriority, ASN_UNSIGNED, RWRITE, var_pimInterfaceTablePrivate, 3, { 6, 1, 8 }},
    { LEAF_pimInterfaceStateRefreshOrgInterval, ASN_INTEGER, RWRITE, var_pimInterfaceTablePrivate, 3, { 6, 1, 9 }},
    { LEAF_pimInterfaceGraftRetryInterval, ASN_INTEGER, RWRITE, var_pimInterfaceTablePrivate, 3, { 6, 1, 10 }},
    { LEAF_pimInterfaceMaxGraftRetries, ASN_INTEGER, RWRITE, var_pimInterfaceTablePrivate, 3, { 6, 1, 11 }},
};

void
init_pimMgt(void)
{
    static oid pimRegisterRateLimit_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,10,17,1,0 };
    static oid pimBsrRpSetClearAction_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,10,17,2,0 };

    static oid pimSptThresholdGroupInetAddrType_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,10,17,3,1,0 };
    static oid pimSptThresholdGroupInetAddr_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,10,17,3,2,0 };
    static oid pimSptThresholdGroupInetAddrPrefixLength_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,10,17,3,3,0 };
    static oid pimSptThresholdRate_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,10,17,3,4,0 };

    static oid pimBsrCandidateIfIndex_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,10,17,4,1,0 };
    static oid pimBsrCandidateHashMaskLength_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,10,17,4,2,0 };
    static oid pimBsrCandidatePriority_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,10,17,4,3,0 };
    static oid pimBsrCandidateStatus_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,10,17,4,4,0 };

    static oid pimBsrRouterAddrType_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,10,17,7,1,0 };
    static oid pimBsrRouterAddr_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,10,17,7,2,0 };
    static oid pimBsrRouterUpTime_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,10,17,7,3,0 };
    static oid pimBsrRouterPriority_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,10,17,7,4,0 };
    static oid pimBsrRouterHashMaskLength_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,10,17,7,5,0 };
    static oid pimBsrRouterExpireTime_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,10,17,7,6,0 };
    static oid pimBsrRouterRole_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,10,17,7,7,0 };
    static oid pimBsrRouterStatus_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,10,17,7,8,0 };

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("pimRegisterRateLimit",
                               do_pimRegisterRateLimit,
                               pimRegisterRateLimit_oid,
                               OID_LENGTH(pimRegisterRateLimit_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("pimBsrRpSetClearAction",
                               do_pimBsrRpSetClearAction,
                               pimBsrRpSetClearAction_oid,
                               OID_LENGTH(pimBsrRpSetClearAction_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("pimSptThresholdGroupInetAddrType",
                               do_pimSptThresholdGroupInetAddrType,
                               pimSptThresholdGroupInetAddrType_oid,
                               OID_LENGTH(pimSptThresholdGroupInetAddrType_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("pimSptThresholdGroupInetAddr",
                               do_pimSptThresholdGroupInetAddr,
                               pimSptThresholdGroupInetAddr_oid,
                               OID_LENGTH(pimSptThresholdGroupInetAddr_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("pimSptThresholdGroupInetAddrPrefixLength",
                               do_pimSptThresholdGroupInetAddrPrefixLength,
                               pimSptThresholdGroupInetAddrPrefixLength_oid,
                               OID_LENGTH(pimSptThresholdGroupInetAddrPrefixLength_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("pimSptThresholdRate",
                               do_pimSptThresholdRate,
                               pimSptThresholdRate_oid,
                               OID_LENGTH(pimSptThresholdRate_oid),
                               HANDLER_CAN_RWRITE));

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("pimBsrCandidateIfIndex",
                               do_pimBsrCandidateIfIndex,
                               pimBsrCandidateIfIndex_oid,
                               OID_LENGTH(pimBsrCandidateIfIndex_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("pimBsrCandidateHashMaskLength",
                               do_pimBsrCandidateHashMaskLength,
                               pimBsrCandidateHashMaskLength_oid,
                               OID_LENGTH(pimBsrCandidateHashMaskLength_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("pimBsrCandidatePriority",
                               do_pimBsrCandidatePriority,
                               pimBsrCandidatePriority_oid,
                               OID_LENGTH(pimBsrCandidatePriority_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("pimBsrCandidateStatus",
                               do_pimBsrCandidateStatus,
                               pimBsrCandidateStatus_oid,
                               OID_LENGTH(pimBsrCandidateStatus_oid),
                               HANDLER_CAN_RWRITE));

    REGISTER_MIB("pimRpInetAddrTable", pimRpInetAddrTable_variables, variable3,
                 pimRpInetAddrTable_variables_oid);

    REGISTER_MIB("pimInterfaceTablePrivate", pimInterfaceTablePrivate_variables, variable3,
                 pimInterfaceTablePrivate_variables_oid);

    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("pimBsrRouterAddrType",
                                         get_pimBsrRouterAddrType,
                                         pimBsrRouterAddrType_oid,
                                         OID_LENGTH(pimBsrRouterAddrType_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("pimBsrRouterAddr",
                                         get_pimBsrRouterAddr,
                                         pimBsrRouterAddr_oid,
                                         OID_LENGTH(pimBsrRouterAddr_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("pimBsrRouterUpTime",
                                         get_pimBsrRouterUpTime,
                                         pimBsrRouterUpTime_oid,
                                         OID_LENGTH(pimBsrRouterUpTime_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("pimBsrRouterPriority",
                                         get_pimBsrRouterPriority,
                                         pimBsrRouterPriority_oid,
                                         OID_LENGTH(pimBsrRouterPriority_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("pimBsrRouterHashMaskLength",
                                         get_pimBsrRouterHashMaskLength,
                                         pimBsrRouterHashMaskLength_oid,
                                         OID_LENGTH(pimBsrRouterHashMaskLength_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("pimBsrRouterExpireTime",
                                         get_pimBsrRouterExpireTime,
                                         pimBsrRouterExpireTime_oid,
                                         OID_LENGTH(pimBsrRouterExpireTime_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("pimBsrRouterRole",
                                         get_pimBsrRouterRole,
                                         pimBsrRouterRole_oid,
                                         OID_LENGTH(pimBsrRouterRole_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("pimBsrRouterStatus",
                                         get_pimBsrRouterStatus,
                                         pimBsrRouterStatus_oid,
                                         OID_LENGTH(pimBsrRouterStatus_oid),
                                         HANDLER_CAN_RONLY));
}
#endif /* #if (SYS_CPNT_PIM == TRUE) */

/********************************************
 **************vlanTable*********************
 ********************************************
 */
oid vlanTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,12 };

struct variable3 vlanTable_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
  #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
{VLANINDEX,  ASN_UNSIGNED,  RONLY,   var_vlanTable, 3,  { 1, 1, 1 }},
#endif
{VLANADDRESSMETHOD,  ASN_INTEGER,  RWRITE,  var_vlanTable, 3,  { 1, 1, 2 }},
};

/** Initializes the vlanTable module */
void
init_vlanTable(void)
{
    /* register ourselves with the agent to handle our mib tree */
    init_PrivateMIBNodeRootOIDbySwitchBoardID(vlanTable_variables_oid);
    REGISTER_MIB("vlanTable", vlanTable_variables, variable3,
               vlanTable_variables_oid);
}



/********************************************
 *************vlanPortTable******************
 ********************************************
 */

oid vlanPortTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,12};

struct variable3 vlanPortTable_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
 #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
{VLANPORTINDEX,  ASN_INTEGER,  RONLY,   var_vlanPortTable, 3,  { 2, 1, 1 }},
#endif
{VLANPORTMODE,  ASN_INTEGER,  RWRITE,  var_vlanPortTable, 3,  { 2, 1, 2 }},
#if (SYS_CPNT_COMMUNITY_PRIVATE_VLAN == TRUE)
{VLANPORTPRIVATEVLANTYPE,  ASN_INTEGER,  RWRITE,  var_vlanPortTable, 3,  { 2, 1, 3 }},
#endif
};

/** Initializes the vlanPortTable module */
void
init_vlanPortTable(void)
{
    /* register ourselves with the agent to handle our mib tree */
    init_PrivateMIBNodeRootOIDbySwitchBoardID(vlanPortTable_variables_oid);
    REGISTER_MIB("vlanPortTable", vlanPortTable_variables, variable3,
               vlanPortTable_variables_oid);
}

#if (SYS_CPNT_MAC_VLAN == TRUE)
/********************************************
 ***************macVlanTable*****************
 ********************************************
 */

oid macVlanTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,12 };

struct variable3 macVlanTable_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
{LEAF_macVlanMacAddress,  ASN_OCTET_STR,  RONLY,   var_macVlanTable, 3,  { 11, 1, 1 }},
#endif

{LEAF_macVlanId,  ASN_INTEGER,  RWRITE,  var_macVlanTable, 3,  { 11, 1, 2 }},

#if (SYS_CPNT_MAC_VLAN_WITH_PRIORITY == TRUE)
{LEAF_macVlanPriority,  ASN_INTEGER,  RWRITE,  var_macVlanTable, 3,  { 11, 1, 3 }},
#endif

{LEAF_macVlanStatus,  ASN_INTEGER,  RWRITE,  var_macVlanTable, 3,  { 11, 1, 4 }},
};
/*    (L = length of the oidsuffix) */

/** Initializes the macVlanTable module */
void
init_macVlanTable(void)
{

    DEBUGMSGTL(("macVlanTable", "Initializing\n"));

    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("macVlanTable", macVlanTable_variables, variable3,
               macVlanTable_variables_oid);
}

/** Initializes the macVlanClearAction module */
void
init_macVlanClearAction(void)
{
    static oid macVlanClearAction_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,12,12,0 };

    DEBUGMSGTL(("macVlanClearAction", "Initializing\n"));

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("macVlanClearAction",
                               do_macVlanClearAction,
                               macVlanClearAction_oid,
                               OID_LENGTH(macVlanClearAction_oid),
                               HANDLER_CAN_RWRITE));
}
#endif /* end of #if (SYS_CPNT_MAC_VLAN == TRUE) */

#if (SYS_CPNT_IP_SUBNET_VLAN == TRUE)
/********************************************
 **************subnetVlanTable***************
 ********************************************
 */

oid subnetVlanTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,12 };
struct variable3 subnetVlanTable_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */

#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
{LEAF_subnetVlanIpAddress,  ASN_IPADDRESS,  RONLY,   var_subnetVlanTable, 3,  { 13, 1, 1 }},
{LEAF_subnetVlanMask,  ASN_IPADDRESS,  RONLY,   var_subnetVlanTable, 3,  { 13, 1, 2 }},
#endif

{LEAF_subnetVlanId,  ASN_INTEGER,  RWRITE,  var_subnetVlanTable, 3,  { 13, 1, 3 }},

#if (SYS_CPNT_IP_SUBNET_VLAN_WITH_PRIORITY == TRUE)
{LEAF_subnetVlanPriority,  ASN_INTEGER,  RWRITE,  var_subnetVlanTable, 3,  { 13, 1, 4 }},
#endif

{LEAF_subnetVlanStatus,  ASN_INTEGER,  RWRITE,  var_subnetVlanTable, 3,  { 13, 1, 5 }},
};
/*    (L = length of the oidsuffix) */

/** Initializes the subnetVlanTable module */
void
init_subnetVlanTable(void)
{

    DEBUGMSGTL(("subnetVlanTable", "Initializing\n"));

    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("subnetVlanTable", subnetVlanTable_variables, variable3,
               subnetVlanTable_variables_oid);
}

/** Initializes the subnetVlanClearAction module */
void
init_subnetVlanClearAction(void)
{
    static oid subnetVlanClearAction_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,12,14,0 };

    DEBUGMSGTL(("subnetVlanClearAction", "Initializing\n"));

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("subnetVlanClearAction",
                               do_subnetVlanClearAction,
                               subnetVlanClearAction_oid,
                               OID_LENGTH(subnetVlanClearAction_oid),
                               HANDLER_CAN_RWRITE));
}
#endif /* end of #if (SYS_CPNT_IP_SUBNET_VLAN == TRUE) */

#if (SYS_CPNT_ADD == TRUE)

oid voiceVlanOuiTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,12,6 };

struct variable3 voiceVlanOuiTable_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
{LEAF_voiceVlanOuiAddress,      ASN_OCTET_STR,  RONLY,   var_voiceVlanOuiTable, 3,  { 1, 1, 1 }},
{LEAF_voiceVlanOuiMask,         ASN_OCTET_STR,  RWRITE,  var_voiceVlanOuiTable, 3,  { 1, 1, 2 }},
{LEAF_voiceVlanOuiDescription,  ASN_OCTET_STR,  RWRITE,  var_voiceVlanOuiTable, 3,  { 1, 1, 3 }},
{LEAF_voiceVlanOuiStatus,       ASN_INTEGER,    RWRITE,  var_voiceVlanOuiTable, 3,  { 1, 1, 4 }},
};
/*    (L = length of the oidsuffix) */

/** Initializes the voiceVlanOuiTable module */
void
init_voiceVlanOuiTable(void)
{

    DEBUGMSGTL(("voiceVlanOuiTable", "Initializing\n"));

    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("voiceVlanOuiTable", voiceVlanOuiTable_variables, variable3,
               voiceVlanOuiTable_variables_oid);
}

void
init_voiceVlanMgt(void)
{
    static oid voiceVlanEnabledId_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,12,6,2,0 };
    static oid voiceVlanAgingTime_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,12,6,3,0 };

    DEBUGMSGTL(("voiceVlanMgt", "Initializing\n"));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("voiceVlanEnabledId",
                               do_voiceVlanEnabledId,
                               voiceVlanEnabledId_oid,
                               OID_LENGTH(voiceVlanEnabledId_oid),
                               HANDLER_CAN_RWRITE));

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("voiceVlanAgingTime",
                               do_voiceVlanAgingTime,
                               voiceVlanAgingTime_oid,
                               OID_LENGTH(voiceVlanAgingTime_oid),
                               HANDLER_CAN_RWRITE));
}

oid voiceVlanPortTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,12,6 };

struct variable3 voiceVlanPortTable_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
{LEAF_voiceVlanPortIfIndex,  ASN_INTEGER,  RONLY,   var_voiceVlanPortTable, 3,  { 7, 1, 1 }},
#endif

{LEAF_voiceVlanPortMode,     ASN_INTEGER,  RWRITE,  var_voiceVlanPortTable, 3,  { 7, 1, 2 }},
{LEAF_voiceVlanPortSecurity, ASN_INTEGER,  RWRITE,  var_voiceVlanPortTable, 3,  { 7, 1, 3 }},
{LEAF_voiceVlanPortPriority, ASN_INTEGER,  RWRITE,  var_voiceVlanPortTable, 3,  { 7, 1, 4 }},
{LEAF_voiceVlanPortRuleOui,  ASN_INTEGER,  RWRITE,  var_voiceVlanPortTable, 3,  { 7, 1, 5 }},
{LEAF_voiceVlanPortRuleLldp, ASN_INTEGER,  RWRITE,  var_voiceVlanPortTable, 3,  { 7, 1, 6 }},
};
/*    (L = length of the oidsuffix) */

/** Initializes the voiceVlanPortTable module */
void
init_voiceVlanPortTable(void)
{

    DEBUGMSGTL(("voiceVlanPortTable", "Initializing\n"));

    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("voiceVlanPortTable", voiceVlanPortTable_variables, variable3,
               voiceVlanPortTable_variables_oid);

}
#endif

#if (SYS_CPNT_QINQ == TRUE)
/********************************************
 ***************vlanMgt******************
 ********************************************
 */
void
init_vlanDot1qTunnelGlobalConfig(void)
{
    static oid vlanDot1qTunnelStatus_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,12,8,1,0 };
#if (SYS_CPNT_QINQ_TPID_GLOBAL_UI == TRUE)
    static oid vlanDot1qTunnelTpid_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,12,8,4,0 };
#endif

    DEBUGMSGTL(("vlanDot1qTunnelGlobalConfig", "Initializing\n"));

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("vlanDot1qTunnelStatus",
                               do_vlanDot1qTunnelStatus,
                               vlanDot1qTunnelStatus_oid,
                               OID_LENGTH(vlanDot1qTunnelStatus_oid),
                               HANDLER_CAN_RWRITE));

#if (SYS_CPNT_QINQ_TPID_GLOBAL_UI == TRUE)
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("vlanDot1qTunnelTpid",
                               do_vlanDot1qTunnelTpid,
                               vlanDot1qTunnelTpid_oid,
                               OID_LENGTH(vlanDot1qTunnelTpid_oid),
                               HANDLER_CAN_RWRITE));
#endif
}


/********************************************
 ********vlanDot1qTunnelPortTable************
 ********************************************
 */
 oid vlanDot1qTunnelPortTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,12 };
/*
 * variable3 vlanDot1qTunnelPortTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */

struct variable3 vlanDot1qTunnelPortTable_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
{LEAF_vlanDot1qTunnelPortIndex,  ASN_INTEGER,  RONLY,   var_vlanDot1qTunnelPortTable, 3,  { 9, 1, 1 }},
#endif

{LEAF_vlanDot1qTunnelPortMode,  ASN_INTEGER,  RWRITE,  var_vlanDot1qTunnelPortTable, 3,  { 9, 1, 2 }},
#if (SYS_CPNT_QINQ_TPID_GLOBAL_UI != TRUE)
{LEAF_vlanDot1qTunnelPortEtherType,  ASN_UNSIGNED,  RWRITE,  var_vlanDot1qTunnelPortTable, 3,  { 9, 1, 3 }},
#endif
#if (SYS_CPNT_SWCTRL_QINQ_PORT_PRIORITY_MAP == TRUE)
{LEAF_vlanDot1qTunnelPortPriorityMapStatus,  ASN_UNSIGNED,  RWRITE,  var_vlanDot1qTunnelPortTable, 3,  { 9, 1, 4 }},
#endif
};
/*    (L = length of the oidsuffix) */

/** Initializes the vlanDot1qTunnelPortTable module */
void
init_vlanDot1qTunnelPortTable(void)
{

    DEBUGMSGTL(("vlanDot1qTunnelPortTable", "Initializing\n"));

    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("vlanDot1qTunnelPortTable", vlanDot1qTunnelPortTable_variables, variable3,
               vlanDot1qTunnelPortTable_variables_oid);

    /* place any other initialization junk you need here */
}

#if (SYS_CPNT_QINQ_L2PT == TRUE)
/********************************************
 ********vlanL2ProtocolTunnelGlobalConfig****
 ********************************************
 */
void
init_vlanL2ProtocolTunnelGlobalConfig(void)
{
#if (SYS_CPNT_QINQ_L2PT_TUNNEL_DA_CONFIGURABLE == TRUE)
    oid vlanL2ProtocolTunnelAddress_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,12,19,1,0 };
#endif

    DEBUGMSGTL(("vlanL2ProtocolTunnelGlobalConfig", "Initializing\n"));

#if (SYS_CPNT_QINQ_L2PT_TUNNEL_DA_CONFIGURABLE == TRUE)
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("vlanL2ProtocolTunnelAddress",
                               do_vlanL2ProtocolTunnelAddress,
                               vlanL2ProtocolTunnelAddress_oid,
                               OID_LENGTH(vlanL2ProtocolTunnelAddress_oid),
                               HANDLER_CAN_RWRITE));
#endif
}

/********************************************
 ********vlanL2ProtocolTunnelPortTable*******
 ********************************************
 */
struct variable3 vlanL2ProtocolTunnelPortTable_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
{LEAF_vlanL2ptPortIndex,  ASN_INTEGER,  RONLY,   var_vlanL2ProtocolTunnelPortTable, 3,  { 16, 1, 1 }},
#endif
#if (SYS_CPNT_QINQ_L2PT_STP == TRUE)
{LEAF_vlanL2ptPortSta,    ASN_INTEGER,  RWRITE,  var_vlanL2ProtocolTunnelPortTable, 3,  { 16, 1, 2 }},
#endif
#if (SYS_CPNT_QINQ_L2PT_LLDP == TRUE)
{LEAF_vlanL2ptPortLldp,   ASN_INTEGER,  RWRITE,  var_vlanL2ProtocolTunnelPortTable, 3,  { 16, 1, 3 }},
#endif
#if (SYS_CPNT_QINQ_L2PT_CDP == TRUE)
{LEAF_vlanL2ptPortCdp,    ASN_INTEGER,  RWRITE,  var_vlanL2ProtocolTunnelPortTable, 3,  { 16, 1, 4 }},
#endif
#if (SYS_CPNT_QINQ_L2PT_VTP == TRUE)
{LEAF_vlanL2ptPortVtp,    ASN_INTEGER,  RWRITE,  var_vlanL2ProtocolTunnelPortTable, 3,  { 16, 1, 5 }},
#endif
#if (SYS_CPNT_QINQ_L2PT_PVST == TRUE)
{LEAF_vlanL2ptPortPvst,   ASN_INTEGER,  RWRITE,  var_vlanL2ProtocolTunnelPortTable, 3,  { 16, 1, 6 }},
#endif  /* #if (SYS_CPNT_QINQ_L2PT_CISCO_COMPATIBLE == TRUE) */
};

/** Initializes the vlanL2ProtocolTunnelPortTable module */
void
init_vlanL2ProtocolTunnelPortTable(void)
{
    oid vlanL2ProtocolTunnelPortTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,12 };

    DEBUGMSGTL(("vlanL2ProtocolTunnelPortTable", "Initializing\n"));

    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("vlanL2ProtocolTunnelPortTable", vlanL2ProtocolTunnelPortTable_variables, variable3,
                 vlanL2ProtocolTunnelPortTable_variables_oid);
}

#endif  /*#if (SYS_CPNT_QINQ_L2PT == TRUE)*/

#if (SYS_CPNT_SWCTRL_QINQ_SERVICE == TRUE)
#if (SYS_CPNT_SWCTRL_QINQ_SERVICE_SUBSCRIBE_BY_TAG_INFO == TRUE)
/********************************************
 ********vlanDot1qTunnelSrvCvidPortTable*****
 ********************************************
 */
oid vlanDot1qTunnelSrvCvidPortTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,12 };

struct variable3 vlanDot1qTunnelSrvCvidPortTable_variables[] = {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
{LEAF_vlanDot1qTunnelSrvCvidPortIndex,  ASN_INTEGER,  RONLY,   var_vlanDot1qTunnelSrvCvidPortTable, 3,  { 18, 1, 1 }},
#endif

#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
{LEAF_vlanDot1qTunnelSrvCvidPortCvid,  ASN_UNSIGNED,  RONLY,   var_vlanDot1qTunnelSrvCvidPortTable, 3,  { 18, 1, 2 }},
#endif

{LEAF_vlanDot1qTunnelSrvCvidPortSvid,  ASN_INTEGER,  RWRITE,  var_vlanDot1qTunnelSrvCvidPortTable, 3,  { 18, 1, 3 }},

#if (SYS_ADPT_QINQ_SERVICE_TAG_INFO_SRV_ACTION & SYS_VAL_vlanDot1qTunnelSrvAction_assignPri)
{LEAF_vlanDot1qTunnelSrvCvidPortPriority,  ASN_INTEGER,  RWRITE,  var_vlanDot1qTunnelSrvCvidPortTable, 3,  { 18, 1, 4 }},
#endif

{LEAF_vlanDot1qTunnelSrvCvidPortStatus,  ASN_INTEGER,  RWRITE,  var_vlanDot1qTunnelSrvCvidPortTable, 3,  { 18, 1, 5 }},
{LEAF_vlanDot1qTunnelSrvCvidPortAction,  ASN_OCTET_STR,  RWRITE,  var_vlanDot1qTunnelSrvCvidPortTable, 3,  { 18, 1, 6 }},
};

/** Initializes the vlanDot1qTunnelSrvCvidPortTable module */
void
init_vlanDot1qTunnelSrvCvidPortTable(void)
{
    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("vlanDot1qTunnelSrvCvidPortTable", vlanDot1qTunnelSrvCvidPortTable_variables, variable3,
                 vlanDot1qTunnelSrvCvidPortTable_variables_oid);
}
#endif /* (SYS_CPNT_SWCTRL_QINQ_SERVICE_SUBSCRIBE_BY_TAG_INFO == TRUE) */

#if (SYS_CPNT_SWCTRL_QINQ_SERVICE_SUBSCRIBE_BY_DBL_TAG == TRUE)
/********************************************
 *******vlanDot1qTunnelSrvDTagPortTable******
 ********************************************
 */
oid vlanDot1qTunnelSrvDTagPortTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,12 };

struct variable3 vlanDot1qTunnelSrvDTagPortTable_variables[] = {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
{LEAF_vlanDot1qTunnelSrvDTagPortIndex,  ASN_INTEGER,  RONLY,   var_vlanDot1qTunnelSrvDTagPortTable, 3,  { 20, 1, 1 }},
#endif

#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
{LEAF_vlanDot1qTunnelSrvDTagPortVidOut,  ASN_UNSIGNED,  RONLY,   var_vlanDot1qTunnelSrvDTagPortTable, 3,  { 20, 1, 2 }},
#endif

#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
{LEAF_vlanDot1qTunnelSrvDTagPortVidIn,  ASN_UNSIGNED,  RONLY,   var_vlanDot1qTunnelSrvDTagPortTable, 3,  { 20, 1, 3 }},
#endif

{LEAF_vlanDot1qTunnelSrvDTagPortSvid,  ASN_INTEGER,  RWRITE,  var_vlanDot1qTunnelSrvDTagPortTable, 3,  { 20, 1, 4 }},

#if (SYS_ADPT_QINQ_SERVICE_TAG_INFO_SRV_ACTION & SYS_VAL_vlanDot1qTunnelSrvAction_assignPri)
{LEAF_vlanDot1qTunnelSrvDTagPortPriority,  ASN_INTEGER,  RWRITE,  var_vlanDot1qTunnelSrvDTagPortTable, 3,  { 20, 1, 5 }},
#endif

{LEAF_vlanDot1qTunnelSrvDTagPortStatus,  ASN_INTEGER,  RWRITE,  var_vlanDot1qTunnelSrvDTagPortTable, 3,  { 20, 1, 6 }},
{LEAF_vlanDot1qTunnelSrvDTagPortAction,  ASN_OCTET_STR,  RWRITE,  var_vlanDot1qTunnelSrvDTagPortTable, 3,  { 20, 1, 7 }},
};

/** Initializes the vlanDot1qTunnelSrvDTagPortTable module */
void
init_vlanDot1qTunnelSrvDTagPortTable(void)
{
    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("vlanDot1qTunnelSrvDTagPortTable", vlanDot1qTunnelSrvDTagPortTable_variables, variable3,
                 vlanDot1qTunnelSrvDTagPortTable_variables_oid);
}
#endif /* (SYS_CPNT_SWCTRL_QINQ_SERVICE_SUBSCRIBE_BY_DBL_TAG == TRUE) */

#if (SYS_CPNT_SWCTRL_QINQ_DEFAULT_SERVICE == TRUE)
/********************************************
 ********vlanDot1qTunnelSrvDfltPortTable*****
 ********************************************
 */
oid vlanDot1qTunnelSrvDfltPortTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,12 };

struct variable3 vlanDot1qTunnelSrvDfltPortTable_variables[] = {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
{LEAF_vlanDot1qTunnelSrvDfltPortIndex,  ASN_INTEGER,  RONLY,   var_vlanDot1qTunnelSrvDfltPortTable, 3,  { 22, 1, 1 }},
#endif

{LEAF_vlanDot1qTunnelSrvDfltPortStatus,  ASN_INTEGER,  RWRITE,  var_vlanDot1qTunnelSrvDfltPortTable, 3,  { 22, 1, 2 }},
{LEAF_vlanDot1qTunnelSrvDfltPortAction,  ASN_OCTET_STR,  RWRITE,  var_vlanDot1qTunnelSrvDfltPortTable, 3,  { 22, 1, 3 }},
};

/** Initializes the vlanDot1qTunnelSrvDfltPortTable module */
void
init_vlanDot1qTunnelSrvDfltPortTable(void)
{
    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("vlanDot1qTunnelSrvDfltPortTable", vlanDot1qTunnelSrvDfltPortTable_variables, variable3,
                 vlanDot1qTunnelSrvDfltPortTable_variables_oid);
}
#endif /* (SYS_CPNT_SWCTRL_QINQ_DEFAULT_SERVICE == TRUE) */
#endif /* (SYS_CPNT_SWCTRL_QINQ_SERVICE == TRUE) */
#endif /* (SYS_CPNT_QINQ == TRUE) */



/********************************************
 ********vlanStaticTable************
 ********************************************
 */
 oid vlanStaticTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,12 };
/*
 * variable3 vlanDot1qTunnelPortTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */

struct variable3 vlanStaticTable_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
{LEAF_vlanStaticIndex,  ASN_INTEGER,  RONLY,   var_vlanStaticTable, 3,  { 17, 1, 1 }},
#endif

{LEAF_vlanStaticInterfaceType,  ASN_INTEGER,  RWRITE,  var_vlanStaticTable, 3,  { 17, 1, 2 }},
};

void init_vlanStaticTable(void)
{
    DEBUGMSGTL(("vlanStaticTable", "Initializing\n"));

    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("vlanStaticTable", vlanStaticTable_variables, variable3,
               vlanStaticTable_variables_oid);
}


/********************************************
 ***************priorityMgt******************
 ********************************************
 */
#if (SYS_CPNT_COS == TRUE)

void
init_priorityMgt(void)
{
#if 0
    static oid prioCopyIpPrec_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,13,8,1, 0 };
    static oid prioCopyIpDscp_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,13,8,2, 0 };
    static oid prioIpPortEnableStatus_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,13,6, 0 };
    static oid prioCopyIpPort_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,13,8,3, 0 };
#endif
#if (SYS_CPNT_WRR_Q_MODE_PER_PORT_CTRL == FALSE)
    static oid prioQueueMode_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,13,10, 0 };
#endif
#if 0
    static oid prioIpPrecDscpStatus_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,13,1, 0 };
    static oid prioIpPrecRestoreDefault_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,13,3, 0 };
    static oid prioIpDscpRestoreDefault_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,13,5, 0 };

    init_PrivateMIBNodeRootOIDbySwitchBoardID(prioCopyIpPrec_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("prioCopyIpPrec",
                               do_prioCopyIpPrec,
                               prioCopyIpPrec_oid,
                               OID_LENGTH(prioCopyIpPrec_oid),
                               HANDLER_CAN_RWRITE));
    init_PrivateMIBNodeRootOIDbySwitchBoardID(prioCopyIpDscp_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("prioCopyIpDscp",
                               do_prioCopyIpDscp,
                               prioCopyIpDscp_oid,
                               OID_LENGTH(prioCopyIpDscp_oid),
                               HANDLER_CAN_RWRITE));
    init_PrivateMIBNodeRootOIDbySwitchBoardID(prioIpPrecDscpStatus_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("prioIpPrecDscpStatus",
                               do_prioIpPrecDscpStatus,
                               prioIpPrecDscpStatus_oid,
                               OID_LENGTH(prioIpPrecDscpStatus_oid),
                               HANDLER_CAN_RWRITE));
    init_PrivateMIBNodeRootOIDbySwitchBoardID(prioIpPortEnableStatus_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("prioIpPortEnableStatus",
                               do_prioIpPortEnableStatus,
                               prioIpPortEnableStatus_oid,
                               OID_LENGTH(prioIpPortEnableStatus_oid),
                               HANDLER_CAN_RWRITE));
    init_PrivateMIBNodeRootOIDbySwitchBoardID(prioCopyIpPort_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("prioCopyIpPort",
                               do_prioCopyIpPort,
                               prioCopyIpPort_oid,
                               OID_LENGTH(prioCopyIpPort_oid),
                               HANDLER_CAN_RWRITE));
#endif
#if (SYS_CPNT_WRR_Q_MODE_PER_PORT_CTRL == FALSE)
    init_PrivateMIBNodeRootOIDbySwitchBoardID(prioQueueMode_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("prioQueueMode",
                               do_prioQueueMode,
                               prioQueueMode_oid,
                               OID_LENGTH(prioQueueMode_oid),
                               HANDLER_CAN_RWRITE));
#endif
#if 0
    init_PrivateMIBNodeRootOIDbySwitchBoardID(prioIpPrecRestoreDefault_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("prioIpPrecRestoreDefault",
                               do_prioIpPrecRestoreDefault,
                               prioIpPrecRestoreDefault_oid,
                               OID_LENGTH(prioIpPrecRestoreDefault_oid),
                               HANDLER_CAN_RWRITE));
    init_PrivateMIBNodeRootOIDbySwitchBoardID(prioIpDscpRestoreDefault_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("prioIpDscpRestoreDefault",
                               do_prioIpDscpRestoreDefault,
                               prioIpDscpRestoreDefault_oid,
                               OID_LENGTH(prioIpDscpRestoreDefault_oid),
                               HANDLER_CAN_RWRITE));
#endif
}

#if 0

/********************************************
 *************prioIpPrecTable****************
 ********************************************
 */
oid prioIpPrecTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,13 };

struct variable3 prioIpPrecTable_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
{PRIOIPPRECPORT,  ASN_INTEGER,  RONLY,   var_prioIpPrecTable, 3,  { 2, 1, 2 }},
{PRIOIPPRECVALUE,  ASN_INTEGER,  RONLY,   var_prioIpPrecTable, 3,  { 2, 1, 3 }},
#endif
{PRIOIPPRECCOS,  ASN_INTEGER,  RWRITE,  var_prioIpPrecTable, 3,  { 2, 1, 4 }},
};

/** Initializes the prioIpPrecTable module */
void
init_prioIpPrecTable(void)
{
    /* register ourselves with the agent to handle our mib tree */
    init_PrivateMIBNodeRootOIDbySwitchBoardID(prioIpPrecTable_variables_oid);
    REGISTER_MIB("prioIpPrecTable", prioIpPrecTable_variables, variable3,
               prioIpPrecTable_variables_oid);
}



/********************************************
 *************prioIpDscpTable****************
 ********************************************
 */
oid prioIpDscpTable_variables_oid[] = {SYS_ADPT_PRIVATEMIB_OID,1,13 };

struct variable3 prioIpDscpTable_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
{PRIOIPDSCPPORT,  ASN_INTEGER,  RONLY,   var_prioIpDscpTable, 3,  { 4, 1, 1 }},
{PRIOIPDSCPVALUE,  ASN_INTEGER,  RONLY,   var_prioIpDscpTable, 3,  { 4, 1, 2 }},
#endif
{PRIOIPDSCPCOS,  ASN_INTEGER,  RWRITE,  var_prioIpDscpTable, 3,  { 4, 1, 3 }},
};

/** Initializes the prioIpDscpTable module */
void
init_prioIpDscpTable(void)
{
    /* register ourselves with the agent to handle our mib tree */
    init_PrivateMIBNodeRootOIDbySwitchBoardID(prioIpDscpTable_variables_oid);
    REGISTER_MIB("prioIpDscpTable", prioIpDscpTable_variables, variable3,
               prioIpDscpTable_variables_oid);
}



/********************************************
 *************prioIpPortTable****************
 ********************************************
 */
oid             prioIpPortTable_variables_oid[] =
    { SYS_ADPT_PRIVATEMIB_OID, 1, 13 };

struct variable3 prioIpPortTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    {PRIOIPPORTPHYSPORT, ASN_INTEGER, RONLY, var_prioIpPortTable, 3,
     {7, 1, 1}},
#endif
    {PRIOIPPORTVALUE, ASN_INTEGER, RONLY, var_prioIpPortTable, 3,
     {7, 1, 2}},
    {PRIOIPPORTCOS, ASN_INTEGER, RWRITE, var_prioIpPortTable, 3,
     {7, 1, 3}},
    {PRIOIPPORTSTATUS, ASN_INTEGER, RWRITE, var_prioIpPortTable, 3,
     {7, 1, 4}},
};

/** Initializes the prioIpPortTable module */
void
init_prioIpPortTable(void)
{
    /* register ourselves with the agent to handle our mib tree */
    init_PrivateMIBNodeRootOIDbySwitchBoardID(prioIpPortTable_variables_oid);
    REGISTER_MIB("prioIpPortTable", prioIpPortTable_variables, variable3,
                 prioIpPortTable_variables_oid);

}
#endif
#endif


/********************************************
 *************prioWrrTable*******************
 ********************************************
 */
#if (SYS_CPNT_WRR_Q_WEIGHT_PER_PORT_CTRL == FALSE)

oid prioWrrTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,13};

struct variable3 prioWrrTable_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
{PRIOWRRTRAFFICCLASS,  ASN_INTEGER,  RONLY,   var_prioWrrTable, 3,  { 9, 1, 1 }},
#endif
{PRIOWRRWEIGHT,  ASN_INTEGER,  RWRITE,  var_prioWrrTable, 3,  { 9, 1, 2 }},
};

/** Initializes the prioWrrTable module */
void
init_prioWrrTable(void)
{
    /* register ourselves with the agent to handle our mib tree */
    init_PrivateMIBNodeRootOIDbySwitchBoardID(prioWrrTable_variables_oid);
    REGISTER_MIB("prioWrrTable", prioWrrTable_variables, variable3,
               prioWrrTable_variables_oid);
}
#endif


/********************************************
 *************prioPortTable******************
 ********************************************
 */

#if (SYS_CPNT_WRR_Q_MODE_PER_PORT_CTRL == TRUE)

oid             prioPortTable_variables_oid[] =
    { SYS_ADPT_PRIVATEMIB_OID, 1, 13};

struct variable3 prioPortTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    {PRIOPORTIFINDEX, ASN_INTEGER, RONLY, var_prioPortTable, 3,
     {11, 1, 1}},
#endif
/* 2008-06-04, Jinfeng.Chen: Moved to prioWrrPortTable_variables.
    {PRIOPORTQUEUEMODE, ASN_INTEGER, RWRITE, var_prioPortTable, 3,
     {11, 1, 2}},
 */
};

/** Initializes the prioPortTable module */
void
init_prioPortTable(void)
{
    /* register ourselves with the agent to handle our mib tree */
    init_PrivateMIBNodeRootOIDbySwitchBoardID(prioPortTable_variables_oid);
    REGISTER_MIB("prioPortTable", prioPortTable_variables, variable3,
                 prioPortTable_variables_oid);
}
#endif

/********************************************
 *************prioWrrPortTable***************
 ********************************************
 */
#if (SYS_CPNT_WRR_Q_WEIGHT_PER_PORT_CTRL == TRUE)

oid             prioWrrPortTable_variables_oid[] =
    { SYS_ADPT_PRIVATEMIB_OID, 1, 13 };

struct variable3 prioWrrPortTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)

    {PRIOWRRPORTIFINDEX, ASN_INTEGER, RONLY, var_prioWrrPortTable, 3,
     {12, 1, 1}},
    {PRIOWRRPORTTRAFFICCLASS, ASN_INTEGER, RONLY, var_prioWrrPortTable, 3,
     {12, 1, 2}},
#endif
    {PRIOWRRPORTWEIGHT, ASN_INTEGER, RWRITE, var_prioWrrPortTable, 3,
     {12, 1, 3}},
    {PRIOWRRPORTSTRICTSTATUS, ASN_INTEGER, RWRITE, var_prioWrrPortTable, 3,
     {12, 1, 4}},

};

/** Initializes the prioWrrPortTable module */
void
init_prioWrrPortTable(void)
{
    /* register ourselves with the agent to handle our mib tree */
    init_PrivateMIBNodeRootOIDbySwitchBoardID(prioWrrPortTable_variables_oid);
    REGISTER_MIB("prioWrrPortTable", prioWrrPortTable_variables, variable3,
                 prioWrrPortTable_variables_oid);
}
#endif


/********************************************2008-06-04, Jinfeng.Chen: a new node
 *************prioSchedModePortTable******************
 ********************************************
 */

#if (SYS_CPNT_WRR_Q_MODE_PER_PORT_CTRL == TRUE)
oid prioSchedModePortTable_variables_oid[] =
    { SYS_ADPT_PRIVATEMIB_OID, 1, 13};

struct variable3 prioSchedModePortTable_variables[] =
    {
    #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        {PRIOSCHEDMODEPORTINDEX, ASN_INTEGER, RONLY, var_prioSchedModePortTable, 3,
            {15, 1, 1}},
    #endif
        {PRIOSCHEDMODEPORT, ASN_INTEGER, RWRITE, var_prioSchedModePortTable, 3,
            {15, 1, 2}}
    };
void
init_prioSchedModePortTable(void)
{
    init_PrivateMIBNodeRootOIDbySwitchBoardID(prioSchedModePortTable_variables_oid);
    REGISTER_MIB("prioSchedModePortTable", prioSchedModePortTable_variables, variable3,
                 prioSchedModePortTable_variables_oid);
}
#endif


/* use standard MIB
 */
#if 0
/********************************************
 *************trapDestTable******************
 ********************************************
 */
oid trapDestTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,14 };

struct variable3 trapDestTable_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
{TRAPDESTADDRESS,  ASN_IPADDRESS,  RONLY,   var_trapDestTable, 3,  { 1, 1, 1 }},
#endif
{TRAPDESTCOMMUNITY,  ASN_OCTET_STR,  RWRITE,  var_trapDestTable, 3,  { 1, 1, 2 }},
{TRAPDESTSTATUS,  ASN_INTEGER,  RWRITE,  var_trapDestTable, 3,  { 1, 1, 3 }},
{TRAPDESTVERSION,  ASN_INTEGER,  RWRITE,  var_trapDestTable, 3,  { 1, 1, 4 }},

{TRAPDESTUDPPORT, ASN_INTEGER,  RWRITE, var_trapDestTable, 3, { 1, 1, 5 }},
};

/** Initializes the trapDestTable module */
void
init_trapDestTable(void)
{
    /* register ourselves with the agent to handle our mib tree */
    init_PrivateMIBNodeRootOIDbySwitchBoardID(trapDestTable_variables_oid);
    REGISTER_MIB("trapDestTable", trapDestTable_variables, variable3,
               trapDestTable_variables_oid);
}
#endif /* #if 0 */


/********************************************
 *************rateLimitMgt*******************
 ********************************************
 */
#if (SYS_CPNT_INGRESS_RATE_LIMIT == TRUE)
void
init_rateLimitMgt(void)
{
    static oid      rateLimitStatus_oid[] =
        { SYS_ADPT_PRIVATEMIB_OID, 1, 16, 1, 1, 0 };

    init_PrivateMIBNodeRootOIDbySwitchBoardID(rateLimitStatus_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("rateLimitStatus",
                               do_rateLimitStatus,
                               rateLimitStatus_oid,
                               OID_LENGTH(rateLimitStatus_oid),
                               HANDLER_CAN_RWRITE));
}
#endif


/********************************************
 *************rateLimitPortTable*************
 ********************************************
 */
oid  rateLimitPortTable_variables_oid[] =
    { SYS_ADPT_PRIVATEMIB_OID, 1, 16, 1 };

struct variable3 rateLimitPortTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    {RLPORTINDEX, ASN_INTEGER, RONLY, var_rateLimitPortTable, 3,
     {2, 1, 1}},
#endif
#if (SYS_CPNT_INGRESS_RATE_LIMIT == TRUE) && (!defined(SYS_ADPT_UI_RATE_LIMIT_FACTOR) || SYS_ADPT_UI_RATE_LIMIT_FACTOR == 1000)
    {RLPORTINPUTLIMIT, ASN_INTEGER, RWRITE, var_rateLimitPortTable, 3,
     {2, 1, 2}},
#endif
#if (SYS_CPNT_EGRESS_RATE_LIMIT == TRUE) && (!defined(SYS_ADPT_UI_RATE_LIMIT_FACTOR) || SYS_ADPT_UI_RATE_LIMIT_FACTOR == 1000)
    {RLPORTOUTPUTLIMIT, ASN_INTEGER, RWRITE, var_rateLimitPortTable, 3,
     {2, 1, 3}},
#endif
#if (SYS_CPNT_INGRESS_RATE_LIMIT == TRUE)
    {RLPORTINPUTSTATUS, ASN_INTEGER, RWRITE, var_rateLimitPortTable, 3,
     {2, 1, 6}},
#endif
#if (SYS_CPNT_EGRESS_RATE_LIMIT == TRUE)
    {RLPORTOUTPUTSTATUS, ASN_INTEGER, RWRITE, var_rateLimitPortTable, 3,
     {2, 1, 7}},
#endif
#if (SYS_CPNT_INGRESS_RATE_LIMIT == TRUE) && (defined(SYS_ADPT_UI_RATE_LIMIT_FACTOR) && SYS_ADPT_UI_RATE_LIMIT_FACTOR == 1)
    {RLPORTINPUTLIMITINKILO, ASN_INTEGER, RWRITE, var_rateLimitPortTable, 3,
     {2, 1, 10}},
#endif
#if (SYS_CPNT_EGRESS_RATE_LIMIT == TRUE) && (defined(SYS_ADPT_UI_RATE_LIMIT_FACTOR) && SYS_ADPT_UI_RATE_LIMIT_FACTOR == 1)
    {RLPORTOUTPUTLIMITINKILO, ASN_INTEGER, RWRITE, var_rateLimitPortTable, 3,
     {2, 1, 11}},
#endif
};

/** Initializes the rateLimitPortTable module */
void
init_rateLimitPortTable(void)
{
     /* register ourselves with the agent to handle our mib tree*/
    init_PrivateMIBNodeRootOIDbySwitchBoardID(rateLimitPortTable_variables_oid);
    REGISTER_MIB("rateLimitPortTable", rateLimitPortTable_variables,
                 variable3, rateLimitPortTable_variables_oid);
}



/********************************************
 *************markerTable********************
 ********************************************
 */
#if (SYS_CPNT_QOS == SYS_CPNT_QOS_MARKER)

oid             markerTable_variables_oid[] =
    { SYS_ADPT_PRIVATEMIB_OID, 1, 16, 2 };

struct variable3 markerTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    {MARKERIFINDEX, ASN_INTEGER, RONLY, var_markerTable, 3, {1, 1, 1}},
    {MARKERACLNAME, ASN_OCTET_STR, RONLY, var_markerTable, 3, {1, 1, 2}},
#endif
    {MARKERACTIONBITLIST,ASN_OCTET_STR, RWRITE, var_markerTable, 3, {1, 1, 3}},
    {MARKERDSCP, ASN_INTEGER, RWRITE, var_markerTable, 3, {1, 1, 4}},
    {MARKERPRECEDENCE, ASN_INTEGER, RWRITE, var_markerTable, 3, {1, 1, 5}},
    {MARKERPRIORITY, ASN_INTEGER, RWRITE, var_markerTable, 3, {1, 1, 6}},
    {MARKERSTATUS, ASN_INTEGER, RWRITE, var_markerTable, 3, {1, 1, 7}},
};

/** Initializes the markerTable module */
void
init_markerTable(void)
{
     /* register ourselves with the agent to handle our mib tree*/
    init_PrivateMIBNodeRootOIDbySwitchBoardID(markerTable_variables_oid);
    REGISTER_MIB("markerTable", markerTable_variables, variable3,
                 markerTable_variables_oid);
}
#endif


/********************************************
 *************prioAclToCosMappingTable*******
 ********************************************
 */
#if (SYS_CPNT_COS == TRUE)
//#if (SYS_CPNT_QOS == SYS_CPNT_QOS_MARKER)

oid             prioAclToCosMappingTable_variables_oid[] =
    { SYS_ADPT_PRIVATEMIB_OID, 1, 16, 3 };

oid             prioIfClassificationModeTable_variables_oid[] =
    { SYS_ADPT_PRIVATEMIB_OID, 1, 16, 3 ,2 };

oid             prioCosToDscpTable_variables_oid[] =
    { SYS_ADPT_PRIVATEMIB_OID, 1, 16, 3 ,3 };

oid             prioPrecToDscpTable_variables_oid[] =
    { SYS_ADPT_PRIVATEMIB_OID, 1, 16, 3 ,4 };


oid             prioDscpToDscpTable_variables_oid[] =
    { SYS_ADPT_PRIVATEMIB_OID, 1, 16, 3 ,5 };


oid             prioDstPortToDscpTable_variables_oid[] =
    { SYS_ADPT_PRIVATEMIB_OID, 1, 16, 3 ,6 };

oid             prioDscpToCosTable_variables_oid[] =
    { SYS_ADPT_PRIVATEMIB_OID, 1, 16, 3 ,7 };

oid             prioPrioToDropPrecTable_variables_oid[] =
    { SYS_ADPT_PRIVATEMIB_OID, 1, 16, 3 ,8 };

oid             prioDscpToQueueTable_variables_oid[] =
    { SYS_ADPT_PRIVATEMIB_OID, 1, 16, 3 ,9 };

#if 0
oid             prioDefaultPrioTable_variables_oid[] =
    { SYS_ADPT_PRIVATEMIB_OID, 1, 16, 3 ,10 };
#endif /* #if 0 */

struct variable3 prioAclToCosMappingTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    {PRIOACLTOCOSMAPPINGIFINDEX, ASN_INTEGER, RONLY,
     var_prioAclToCosMappingTable, 3, {1, 1, 1}},
    {PRIOACLTOCOSMAPPINGACLNAME, ASN_OCTET_STR, RONLY,
     var_prioAclToCosMappingTable, 3, {1, 1, 2}},
#endif
    {PRIOACLTOCOSMAPPINGCOSVALUE, ASN_INTEGER, RWRITE,
     var_prioAclToCosMappingTable, 3, {1, 1, 3}},
    {PRIOACLTOCOSMAPPINGSTATUS, ASN_INTEGER, RWRITE,
     var_prioAclToCosMappingTable, 3, {1, 1, 4}},
};

struct variable2 prioIfClassificationModeTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */
    {PRIOIFCLASSIFICATIONMODESTATUS, ASN_INTEGER, RWRITE,
     var_prioIfClassificationModeTable, 2, {1, 2}},
};

#if (SYS_CPNT_COS_ING_COS_TO_INTER_DSCP == TRUE) && (SYS_CPNT_COS_ING_COS_TO_INTER_DSCP_PER_PORT == TRUE)
struct variable2 prioCosToDscpTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */
    {PRIOCOSTODSCPPHBVALUE, ASN_INTEGER, RWRITE,
     var_prioCosToDscpTable, 2, {1, 5}},
    {PRIOCOSTODSCPCOLORVALUE, ASN_INTEGER, RWRITE,
     var_prioCosToDscpTable, 2, {1, 6}},

};

void
init_prioCosToDscpTable(void)
{
    REGISTER_MIB("prioCosToDscpTable",
                 prioCosToDscpTable_variables, variable2,
                 prioCosToDscpTable_variables_oid);
}
#endif /* SYS_CPNT_COS_ING_COS_TO_INTER_DSCP && SYS_CPNT_COS_ING_COS_TO_INTER_DSCP_PER_PORT */

#if (SYS_CPNT_COS_ING_IP_PRECEDENCE_TO_INTER_DSCP == TRUE) && (SYS_CPNT_COS_ING_IP_PRECEDENCE_TO_INTER_DSCP_PER_PORT == TRUE)
struct variable2 prioPrecToDscpTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */
    {PRIOPRECTODSCPPHBVALUE, ASN_INTEGER, RWRITE,
     var_prioPrecToDscpTable, 2, {1, 4}},
    {PRIOPRECTODSCPCOLORVALUE, ASN_INTEGER, RWRITE,
     var_prioPrecToDscpTable, 2, {1, 5}},

};

void
init_prioPrecToDscpTable(void)
{
    REGISTER_MIB("prioPrecToDscpTable",
                 prioPrecToDscpTable_variables, variable2,
                 prioPrecToDscpTable_variables_oid);
}
#endif /* SYS_CPNT_COS_ING_IP_PRECEDENCE_TO_INTER_DSCP && SYS_CPNT_COS_ING_IP_PRECEDENCE_TO_INTER_DSCP_PER_PORT */

#if (SYS_CPNT_COS_ING_DSCP_TO_INTER_DSCP == TRUE) && (SYS_CPNT_COS_ING_DSCP_TO_INTER_DSCP_PER_PORT == TRUE)
struct variable2 prioDscpToDscpTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */
    {PRIODSCPTODSCPPHBVALUE, ASN_INTEGER, RWRITE,
     var_prioDscpToDscpTable, 2, {1, 4}},
    {PRIODSCPTODSCPCOLORVALUE, ASN_INTEGER, RWRITE,
     var_prioDscpToDscpTable, 2, {1, 5}},

};

void
init_prioDscpToDscpTable()
{
    REGISTER_MIB("prioDscpToDscpTable",
                 prioDscpToDscpTable_variables, variable2,
                 prioDscpToDscpTable_variables_oid);
}
#endif /* SYS_CPNT_COS_ING_DSCP_TO_INTER_DSCP && SYS_CPNT_COS_ING_DSCP_TO_INTER_DSCP_PER_PORT */

#if (SYS_CPNT_COS_ING_IP_PORT_TO_INTER_DSCP == TRUE) && (SYS_CPNT_COS_ING_IP_PORT_TO_INTER_DSCP_PER_PORT == TRUE)
struct variable2 prioDstPortToDscpTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */
    {PRIODSTPORTTODSCPPHBVALUE, ASN_INTEGER, RWRITE,
     var_prioDstPortToDscpTable, 2, {1, 5}},
    {PRIODSTPORTTODSCPCOLORVALUE, ASN_INTEGER, RWRITE,
     var_prioDstPortToDscpTable, 2, {1, 6}},

};

void
init_prioDstPortToDscpTable()
{
    REGISTER_MIB("prioDstPortToDscpTable",
                 prioDstPortToDscpTable_variables, variable2,
                 prioDstPortToDscpTable_variables_oid);
}
#endif  /* SYS_CPNT_COS_ING_IP_PORT_TO_INTER_DSCP && SYS_CPNT_COS_ING_IP_PORT_TO_INTER_DSCP_PER_PORT */

#if (SYS_CPNT_COS_ING_INTER_DSCP_TO_COS == TRUE) && (SYS_CPNT_COS_ING_INTER_DSCP_TO_COS_PER_PORT == TRUE)
struct variable2 prioDscpToCosTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */
    {PRIODSCPTOCOSCFICOSVALUE, ASN_INTEGER, RWRITE,
     var_prioDscpToCosTable, 2, {1, 4}},

};

void
init_prioDscpToCosTable(void)
{
    REGISTER_MIB("prioDscpToCosTable",
                 prioDscpToCosTable_variables, variable2,
                 prioDscpToCosTable_variables_oid);
}
#endif /* SYS_CPNT_COS_ING_INTER_DSCP_TO_COS && SYS_CPNT_COS_ING_INTER_DSCP_TO_COS_PER_PORT */

#if (SYS_CPNT_COS_ING_INTER_DSCP_TO_COLOR == TRUE) && (SYS_CPNT_COS_ING_INTER_DSCP_TO_COLOR_PER_PORT == TRUE)
struct variable2 prioPrioToDropPrecTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */
    {PRIOPRIOTODROPPRECPRECVALUE, ASN_INTEGER, RWRITE,
     var_prioPrioToDropPrecTable, 2, {1, 3}},

};

void
init_prioPrioToDropPrecTable(void)
{
    REGISTER_MIB("prioPrioToDropPrecTable ",
                 prioPrioToDropPrecTable_variables, variable2,
                 prioPrioToDropPrecTable_variables_oid);
}
#endif  /* SYS_CPNT_COS_ING_INTER_DSCP_TO_COLOR && SYS_CPNT_COS_ING_INTER_DSCP_TO_COLOR_PER_PORT */

#if (SYS_CPNT_COS_ING_INTER_DSCP_TO_QUEUE == TRUE) && (SYS_CPNT_COS_ING_INTER_DSCP_TO_QUEUE_PER_PORT == TRUE)
struct variable2 prioDscpToQueueTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */
    {PRIODSCPTOQUEUEQUEUEVALUE, ASN_INTEGER, RWRITE,
     var_prioDscpToQueueTable, 2, {1, 3}},

};

void
init_prioDscpToQueueTable(void)
{
    REGISTER_MIB("prioDscpToQueueTable",
                 prioDscpToQueueTable_variables, variable2,
                 prioDscpToQueueTable_variables_oid);
}
#endif  /* SYS_CPNT_COS_ING_INTER_DSCP_TO_QUEUE && SYS_CPNT_COS_ING_INTER_DSCP_TO_QUEUE_PER_PORT */


#if 0
struct variable2 prioDefaultPrioTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */
    {PRIODEFAULTPRIORITYVALUE, ASN_INTEGER, RWRITE,
     var_prioDefaultPrioTable, 2, {1, 2}},

};
#endif /* #if 0 */

/** Initializes the prioAclToCosMappingTable module */
void
init_prioAclToCosMappingTable(void)
{
     /* register ourselves with the agent to handle our mib tree*/
    init_PrivateMIBNodeRootOIDbySwitchBoardID(prioAclToCosMappingTable_variables_oid);
    REGISTER_MIB("prioAclToCosMappingTable",
                 prioAclToCosMappingTable_variables, variable3,
                 prioAclToCosMappingTable_variables_oid);
}

void
init_prioIfClassificationModeTable(void)
{
    REGISTER_MIB("prioIfClassificationModeTable",
                 prioIfClassificationModeTable_variables, variable2,
                 prioIfClassificationModeTable_variables_oid);
}

void
init_prioDefaultPrioTable(void)
{
#if 0
    REGISTER_MIB("prioDefaultPriorityTable",
                 prioDefaultPrioTable_variables, variable2,
                 prioDefaultPrioTable_variables_oid);
#endif /* #if 0 */
}

//#endif /* #if (SYS_CPNT_QOS == SYS_CPNT_QOS_MARKER) */
#endif /* #if (SYS_CPNT_COS == TRUE) */


/********************************************
 ***************cosGlobalMgt******************
 ********************************************
 */
#if (TRUE == SYS_CPNT_COS_ING_INTER_DSCP_TO_QUEUE)
#if (TRUE != SYS_CPNT_COS_ING_INTER_DSCP_TO_QUEUE_PER_PORT)
oid             prioGlobalDscpToQueueTable_variables_oid[] =
    { SYS_ADPT_PRIVATEMIB_OID, 1, 16, 6 ,10 };

struct variable2 prioGlobalDscpToQueueTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */
    {PRIOGLOBALDSCPTOQUEUEQUEUEVALUE, ASN_INTEGER, RWRITE,
     var_prioGlobalDscpToQueueTable, 2, {1, 2}},

};

/** Initializes the prioGlobalDscpToQueueTable module */
void
init_prioGlobalDscpToQueueTable(void)
{
    REGISTER_MIB("prioGlobalDscpToQueueTable",
                 prioGlobalDscpToQueueTable_variables, variable2,
                 prioGlobalDscpToQueueTable_variables_oid);
}
#endif /* #if (TRUE != SYS_CPNT_COS_ING_INTER_DSCP_TO_QUEUE_PER_PORT) */
#endif /* #if (TRUE == SYS_CPNT_COS_ING_INTER_DSCP_TO_QUEUE) */

/********************************************
 ***************diffServMgt******************
 ********************************************
 */
#if ((SYS_CPNT_QOS == SYS_CPNT_QOS_DIFFSERV) && (SYS_CPNT_QOS_V2 != TRUE))

void
init_diffServMgt(void)
{
    static oid      diffServClassMapNextFree_oid[] =
        { SYS_ADPT_PRIVATEMIB_OID, 1, 16, 4, 2, 0 };
    static oid      diffServClassMapElementNextFree_oid[] =
        {SYS_ADPT_PRIVATEMIB_OID, 1, 16, 4, 4, 0 };

    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("diffServClassMapNextFree",
                                         get_diffServClassMapNextFree,
                                         diffServClassMapNextFree_oid,
                                         OID_LENGTH
                                         (diffServClassMapNextFree_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("diffServClassMapElementNextFree",
                                         get_diffServClassMapElementNextFree,
                                         diffServClassMapElementNextFree_oid,
                                         OID_LENGTH
                                         (diffServClassMapElementNextFree_oid),
                                         HANDLER_CAN_RONLY));
}


/********************************************
 *************diffServClfrExtTable***********
 ********************************************
 */

oid             diffServClfrExtTable_variables_oid[] =
    { SYS_ADPT_PRIVATEMIB_OID, 1, 16, 4 };

struct variable3 diffServClfrExtTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */

    {DIFFSERVCLFREXTNAME, ASN_OCTET_STR, RWRITE, var_diffServClfrExtTable,
     3, {1, 1, 1}},
    {DIFFSERVCLFREXTDESC, ASN_OCTET_STR, RWRITE, var_diffServClfrExtTable,
     3, {1, 1, 2}},
};
/*
 * (L = length of the oidsuffix)
 */


/** Initializes the diffServClfrExtTable module */
void
init_diffServClfrExtTable(void)
{
    /*
     * register ourselves with the agent to handle our mib tree
     */
    REGISTER_MIB("diffServClfrExtTable", diffServClfrExtTable_variables,
                 variable3, diffServClfrExtTable_variables_oid);
}


/********************************************
 *************diffServClassMapTable**********
 ********************************************
 */

oid             diffServClassMapTable_variables_oid[] =
    {SYS_ADPT_PRIVATEMIB_OID, 1, 16, 4 };


struct variable3 diffServClassMapTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    {DIFFSERVCLASSMAPID, ASN_UNSIGNED, RONLY, var_diffServClassMapTable, 3,
     {3, 1, 1}},
#endif
    {DIFFSERVCLASSMAPNAME, ASN_OCTET_STR, RWRITE,
     var_diffServClassMapTable, 3, {3, 1, 2}},
    {DIFFSERVCLASSMAPDESC, ASN_OCTET_STR, RWRITE,
     var_diffServClassMapTable, 3, {3, 1, 3}},
    {DIFFSERVCLASSMAPTYPE, ASN_INTEGER, RWRITE, var_diffServClassMapTable,
     3, {3, 1, 4}},
    {DIFFSERVCALSSMAPSTATUS, ASN_INTEGER, RWRITE,
     var_diffServClassMapTable, 3, {3, 1, 5}},
};



/** Initializes the diffServClassMapTable module */
void
init_diffServClassMapTable(void)
{
    /*
     * register ourselves with the agent to handle our mib tree
     */
    REGISTER_MIB("diffServClassMapTable", diffServClassMapTable_variables,
                 variable3, diffServClassMapTable_variables_oid);
}


/********************************************
 ******diffServClassMapElementTable**********
 ********************************************
 */
oid             diffServClassMapElementTable_variables_oid[] =
    { SYS_ADPT_PRIVATEMIB_OID, 1, 16, 4 };

struct variable3 diffServClassMapElementTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    {DIFFSERVCLASSMAPELEMENTID, ASN_UNSIGNED, RONLY,
     var_diffServClassMapElementTable, 3, {5, 1, 1}},
#endif
    {DIFFSERVCLASSMAPELEMENTSPECIFIC, ASN_OBJECT_ID, RWRITE,
     var_diffServClassMapElementTable, 3, {5, 1, 2}},
    {DIFFSERVCLASSMAPELEMENTSTATUS, ASN_INTEGER, RWRITE,
     var_diffServClassMapElementTable, 3, {5, 1, 3}},
};


/** Initializes the diffServClassMapElementTable module */
void
init_diffServClassMapElementTable(void)
{
    /*
     * register ourselves with the agent to handle our mib tree
     */
    REGISTER_MIB("diffServClassMapElementTable",
                 diffServClassMapElementTable_variables, variable3,
                 diffServClassMapElementTable_variables_oid);
}

/********************************************
 ****diffServMultiFieldClfrExtTable**********
 ********************************************
 */
oid             diffServMultiFieldClfrExtTable_variables_oid[] =
    { SYS_ADPT_PRIVATEMIB_OID, 1, 16, 4 };


struct variable3 diffServMultiFieldClfrExtTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */
    {DIFFSERVMULTIFIELDCLFREXTTYPE,ASN_OCTET_STR, RWRITE,
     var_diffServMultiFieldClfrExtTable, 3, {6, 1, 1}},
    {DIFFSERVMULTIFIELDCLFREXTVID, ASN_UNSIGNED, RWRITE,
     var_diffServMultiFieldClfrExtTable, 3, {6, 1, 2}},
    {DIFFSERVMULTIFIELDCLFREXTIPPRECEDENCE, ASN_INTEGER, RWRITE,
     var_diffServMultiFieldClfrExtTable, 3, {6, 1, 3}},
};

/** Initializes the diffServMultiFieldClfrExtTable module */
void
init_diffServMultiFieldClfrExtTable(void)
{
    /*
     * register ourselves with the agent to handle our mib tree
     */
    REGISTER_MIB("diffServMultiFieldClfrExtTable",
                 diffServMultiFieldClfrExtTable_variables, variable3,
                 diffServMultiFieldClfrExtTable_variables_oid);
}

/********************************************
 ************diffServToSMarkActTable*********
 ********************************************
 */
oid             diffServToSMarkActTable_variables_oid[] =
    { SYS_ADPT_PRIVATEMIB_OID, 1, 16, 4 };


struct variable3 diffServToSMarkActTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */

    {DIFFSERVTOSMARKACTTOS, ASN_INTEGER, RONLY,
     var_diffServToSMarkActTable, 3, {7, 1, 1}},
};


/** Initializes the diffServToSMarkActTable module */
void
init_diffServToSMarkActTable(void)
{
    /*
     * register ourselves with the agent to handle our mib tree
     */
    REGISTER_MIB("diffServToSMarkActTable",
                 diffServToSMarkActTable_variables, variable3,
                 diffServToSMarkActTable_variables_oid);
}

/********************************************
 ************diffServDot1pMarkActTable*******
 ********************************************
 */
oid             diffServDot1pMarkActTable_variables_oid[] =
    { SYS_ADPT_PRIVATEMIB_OID, 1, 16, 4 };


struct variable3 diffServDot1pMarkActTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */

    {DIFFSERVDOT1PMARKACTDOT1P, ASN_INTEGER, RONLY,
     var_diffServDot1pMarkActTable, 3, {8, 1, 1}},
};


/** Initializes the diffServDot1pMarkActTable module */
void
init_diffServDot1pMarkActTable(void)
{
    /*
     * register ourselves with the agent to handle our mib tree
     */
    REGISTER_MIB("diffServDot1pMarkActTable",
                 diffServDot1pMarkActTable_variables, variable3,
                 diffServDot1pMarkActTable_variables_oid);

}
#endif

#if (SYS_CPNT_QOS_V2==TRUE)

void
init_diffServMgt(void)
{
    static oid      diffServPolicyMapAttachCtlIndex_oid[] =
        { SYS_ADPT_PRIVATEMIB_OID, 1, 16, 4, 11, 1, 0 };
    static oid      diffServPolicyMapAttachCtlElementIndex_oid[] =
        { SYS_ADPT_PRIVATEMIB_OID, 1, 16, 4, 11, 2, 0 };
    static oid      diffServPolicyMapAttachCtlAction_oid[] =
        { SYS_ADPT_PRIVATEMIB_OID, 1, 16, 4, 11, 3, 0 };

    static oid      diffServClassMapAttachCtlIndex_oid[] =
        { SYS_ADPT_PRIVATEMIB_OID, 1, 16, 4, 14, 1, 0 };
    static oid      diffServClassMapAttachCtlElementIndexType_oid[] =
        { SYS_ADPT_PRIVATEMIB_OID, 1, 16, 4, 14, 2, 0 };
    static oid      diffServClassMapAttachCtlElementIndex_oid[] =
        { SYS_ADPT_PRIVATEMIB_OID, 1, 16, 4, 14, 3, 0 };
    static oid      diffServClassMapAttachCtlAction_oid[] =
        { SYS_ADPT_PRIVATEMIB_OID, 1, 16, 4, 14, 4, 0 };
    static oid      diffServAclAttachCtlIndex_oid[] =
        { SYS_ADPT_PRIVATEMIB_OID, 1, 16, 4, 16, 1, 0 };
    static oid      diffServAclAttachCtlAceType_oid[] =
        { SYS_ADPT_PRIVATEMIB_OID, 1, 16, 4, 16, 2, 0 };
    static oid      diffServAclAttachCtlAceIndex_oid[] =
        { SYS_ADPT_PRIVATEMIB_OID, 1, 16, 4, 16, 3, 0 };
    static oid      diffServAclAttachCtlAction_oid[] =
        { SYS_ADPT_PRIVATEMIB_OID, 1, 16, 4, 16, 4, 0 };

#if (SYS_CPNT_QOS_V2_CPU_PORT == TRUE)
    static oid      diffServPolicyMapControlPlanePolicyMapIndex_oid[] =
        { SYS_ADPT_PRIVATEMIB_OID, 1, 16, 4, 31, 1, 0 };
    static oid      diffServPolicyMapControlPlaneStatus_oid[] =
        { SYS_ADPT_PRIVATEMIB_OID, 1, 16, 4, 31, 2, 0 };
#endif


    DEBUGMSGTL(("diffServMgt", "Initializing\n"));

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("diffServPolicyMapAttachCtlIndex",
                               do_diffServPolicyMapAttachCtlIndex,
                               diffServPolicyMapAttachCtlIndex_oid,
                               OID_LENGTH
                               (diffServPolicyMapAttachCtlIndex_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("diffServPolicyMapAttachCtlElementIndex",
                               do_diffServPolicyMapAttachCtlElementIndex,
                               diffServPolicyMapAttachCtlElementIndex_oid,
                               OID_LENGTH
                               (diffServPolicyMapAttachCtlElementIndex_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("diffServPolicyMapAttachCtlAction",
                               do_diffServPolicyMapAttachCtlAction,
                               diffServPolicyMapAttachCtlAction_oid,
                               OID_LENGTH(diffServPolicyMapAttachCtlAction_oid),
                               HANDLER_CAN_RWRITE));

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("diffServClassMapAttachCtlElementIndex",
                               do_diffServClassMapAttachCtlElementIndex,
                               diffServClassMapAttachCtlElementIndex_oid,
                               OID_LENGTH
                               (diffServClassMapAttachCtlElementIndex_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("diffServClassMapAttachCtlElementIndexType",
                               do_diffServClassMapAttachCtlElementIndexType,
                               diffServClassMapAttachCtlElementIndexType_oid,
                               OID_LENGTH
                               (diffServClassMapAttachCtlElementIndexType_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("diffServClassMapAttachCtlIndex",
                               do_diffServClassMapAttachCtlIndex,
                               diffServClassMapAttachCtlIndex_oid,
                               OID_LENGTH(diffServClassMapAttachCtlIndex_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("diffServClassMapAttachCtlAction",
                               do_diffServClassMapAttachCtlAction,
                               diffServClassMapAttachCtlAction_oid,
                               OID_LENGTH(diffServClassMapAttachCtlAction_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("diffServAclAttachCtlAction",
                               do_diffServAclAttachCtlAction,
                               diffServAclAttachCtlAction_oid,
                               OID_LENGTH(diffServAclAttachCtlAction_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("diffServAclAttachCtlAceIndex",
                               do_diffServAclAttachCtlAceIndex,
                               diffServAclAttachCtlAceIndex_oid,
                               OID_LENGTH(diffServAclAttachCtlAceIndex_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("diffServAclAttachCtlIndex",
                               do_diffServAclAttachCtlIndex,
                               diffServAclAttachCtlIndex_oid,
                               OID_LENGTH(diffServAclAttachCtlIndex_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("diffServAclAttachCtlAceType",
                               do_diffServAclAttachCtlAceType,
                               diffServAclAttachCtlAceType_oid,
                               OID_LENGTH(diffServAclAttachCtlAceType_oid),
                               HANDLER_CAN_RWRITE));
#if (SYS_CPNT_QOS_V2_CPU_PORT == TRUE)
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("diffServPolicyMapControlPlanePolicyMapIndex",
                               do_diffServPolicyMapControlPlanePolicyMapIndex,
                               diffServPolicyMapControlPlanePolicyMapIndex_oid,
                               OID_LENGTH(diffServPolicyMapControlPlanePolicyMapIndex_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("diffServPolicyMapControlPlaneStatus",
                               do_diffServPolicyMapControlPlaneStatus,
                               diffServPolicyMapControlPlaneStatus_oid,
                               OID_LENGTH(diffServPolicyMapControlPlaneStatus_oid),
                               HANDLER_CAN_RWRITE));
#endif /*#if (SYS_CPNT_QOS_V2_CPU_PORT == TRUE)*/
}



oid             diffServPortTable_variables_oid[] =  { SYS_ADPT_PRIVATEMIB_OID, 1, 16, 4};

struct variable3 diffServPortTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */
    {DIFFSERVPORTIFINDEX, ASN_INTEGER, RONLY, var_diffServPortTable, 3,
     {9, 1, 1}},
    {DIFFSERVPORTPOLICYMAPINDEX, ASN_INTEGER, RWRITE, var_diffServPortTable, 3,
     {9, 1, 2}},
     #if 0
    {DIFFSERVPORTINGRESSIPACLINDEX, ASN_INTEGER, RWRITE, var_diffServPortTable,
     3, {9, 1, 3}},
    {DIFFSERVPORTINGRESSMACACLINDEX, ASN_INTEGER, RWRITE,
     var_diffServPortTable, 3, {9, 1, 4}},

#if (SYS_CPNT_ACL_IPV6 == TRUE)
    {DIFFSERVPORTINGRESSIPV6ACLINDEX, ASN_INTEGER, RWRITE,
     var_diffServPortTable, 3, {9, 1, 5}},
#endif
    #endif
};
/*
 * (L = length of the oidsuffix)
 */


/** Initializes the diffServPortTable module */
void
init_diffServPortTable(void)
{

    DEBUGMSGTL(("diffServPortTable", "Initializing\n"));

    /*
     * register ourselves with the agent to handle our mib tree
     */
    REGISTER_MIB("diffServPortTable", diffServPortTable_variables, variable3,
                 diffServPortTable_variables_oid);

    /*
     * place any other initialization junk you need here
     */
}

oid             diffServPolicyMapTable_variables_oid[] =
    { SYS_ADPT_PRIVATEMIB_OID, 1, 16, 4 };

/*
 * variable3 diffServPolicyMapTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */


struct variable3 diffServPolicyMapTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */

    {DIFFSERVPOLICYMAPINDEX, ASN_INTEGER, RONLY, var_diffServPolicyMapTable, 3,
     {10, 1, 1}},
    {DIFFSERVPOLICYMAPNAME, ASN_OCTET_STR, RWRITE, var_diffServPolicyMapTable,
     3, {10, 1, 2}},
    {DIFFSERVPOLICYMAPDESCRIPTION, ASN_OCTET_STR, RWRITE,
     var_diffServPolicyMapTable, 3, {10, 1, 3}},
    {DIFFSERVPOLICYMAPELEMENTINDEXLIST, ASN_OCTET_STR, RONLY,
     var_diffServPolicyMapTable, 3, {10, 1, 4}},
    {DIFFSERVPOLICYMAPSTATUS, ASN_INTEGER, RWRITE, var_diffServPolicyMapTable,
     3, {10, 1, 5}},
};


void
init_diffServPolicyMapTable(void)
{

    DEBUGMSGTL(("diffServPolicyMapTable", "Initializing\n"));
    REGISTER_MIB("diffServPolicyMapTable", diffServPolicyMapTable_variables,
                 variable3, diffServPolicyMapTable_variables_oid);
}

oid             diffServPolicyMapElementTable_variables_oid[] =
    { SYS_ADPT_PRIVATEMIB_OID, 1, 16, 4};

struct variable3 diffServPolicyMapElementTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */
    {DIFFSERVPOLICYMAPELEMENTINDEX, ASN_INTEGER, RONLY,
     var_diffServPolicyMapElementTable, 3, {12, 1, 1}},
    {DIFFSERVPOLICYMAPELEMENTCLASSMAPINDEX, ASN_INTEGER, RWRITE,
     var_diffServPolicyMapElementTable, 3, {12, 1, 2}},
    {DIFFSERVPOLICYMAPELEMENTMETERINDEX, ASN_INTEGER, RWRITE,
     var_diffServPolicyMapElementTable, 3, {12, 1, 3}},
    {DIFFSERVPOLICYMAPELEMENTACTIONINDEX, ASN_INTEGER, RWRITE,
     var_diffServPolicyMapElementTable, 3, {12, 1, 4}},
    {DIFFSERVPOLICYMAPELEMENTSTATUS, ASN_INTEGER, RWRITE,
     var_diffServPolicyMapElementTable, 3, {12, 1, 5}},
};

void
init_diffServPolicyMapElementTable(void)
{

    DEBUGMSGTL(("diffServPolicyMapElementTable", "Initializing\n"));
    REGISTER_MIB("diffServPolicyMapElementTable",
                 diffServPolicyMapElementTable_variables, variable3,
                 diffServPolicyMapElementTable_variables_oid);
}

oid             diffServClassMapTable_variables_oid[] =
    { SYS_ADPT_PRIVATEMIB_OID, 1, 16, 4 };

/*
 * variable3 diffServClassMapTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */

struct variable3 diffServClassMapTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */
    {DIFFSERVCLASSMAPINDEX, ASN_INTEGER, RONLY, var_diffServClassMapTable, 3,
     {13, 1, 1}},
    {DIFFSERVCLASSMAPNAME_2, ASN_OCTET_STR, RWRITE, var_diffServClassMapTable, 3,
     {13, 1, 2}},
    {DIFFSERVCLASSMAPDESCRIPTION, ASN_OCTET_STR, RWRITE,
     var_diffServClassMapTable, 3, {13, 1, 3}},
    {DIFFSERVCLASSMAPMATCHTYPE, ASN_INTEGER, RWRITE, var_diffServClassMapTable,
     3, {13, 1, 4}},
    {DIFFSERVCLASSMAPELEMENTINDEXTYPELIST, ASN_OCTET_STR, RONLY,
     var_diffServClassMapTable, 3, {13, 1, 5}},
    {DIFFSERVCLASSMAPELEMENTINDEXLIST, ASN_OCTET_STR, RONLY,
     var_diffServClassMapTable, 3, {13, 1, 6}},
    {DIFFSERVCLASSMAPSTATUS, ASN_INTEGER, RWRITE, var_diffServClassMapTable, 3,
     {13, 1, 7}},
};
void
init_diffServClassMapTable(void)
{
    DEBUGMSGTL(("diffServClassMapTable", "Initializing\n"));
    REGISTER_MIB("diffServClassMapTable", diffServClassMapTable_variables,
                 variable3, diffServClassMapTable_variables_oid);
}

oid             diffServAclTable_variables_oid[] =
    { SYS_ADPT_PRIVATEMIB_OID, 1, 16, 4 };



struct variable3 diffServAclTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */
    {DIFFSERVACLINDEX, ASN_INTEGER, RONLY, var_diffServAclTable, 3, {15, 1, 1}},
    {DIFFSERVACLNAME, ASN_OCTET_STR, RWRITE, var_diffServAclTable, 3,
     {15, 1, 2}},
    {DIFFSERVACLTYPE, ASN_INTEGER, RWRITE, var_diffServAclTable, 3,
     {15, 1, 3}},
    {DIFFSERVACLACEINDEXLIST, ASN_OCTET_STR, RONLY, var_diffServAclTable, 3,
     {15, 1, 4}},
    {DIFFSERVACLSTATUS, ASN_INTEGER, RWRITE, var_diffServAclTable, 3,
     {15, 1, 5}},
};



void
init_diffServAclTable(void)
{

    DEBUGMSGTL(("diffServAclTable", "Initializing\n"));
    REGISTER_MIB("diffServAclTable", diffServAclTable_variables, variable3,
                 diffServAclTable_variables_oid);
}

oid             diffServIpAceTable_variables_oid[] =
    { SYS_ADPT_PRIVATEMIB_OID, 1, 16, 4 };

struct variable3 diffServIpAceTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */

    {DIFFSERVIPACEINDEX, ASN_INTEGER, RONLY, var_diffServIpAceTable, 3,
     {17, 1, 1}},
    {DIFFSERVIPACETYPE, ASN_INTEGER, RWRITE, var_diffServIpAceTable, 3,
     {17, 1, 2}},
    {DIFFSERVIPACEACCESS, ASN_INTEGER, RWRITE, var_diffServIpAceTable, 3,
     {17, 1, 3}},
    {DIFFSERVIPACESOURCEIPADDR, ASN_IPADDRESS, RWRITE, var_diffServIpAceTable, 3,
     {17, 1, 4}},
    {DIFFSERVIPACESOURCEIPADDRBITMASK, ASN_IPADDRESS, RWRITE,
     var_diffServIpAceTable, 3, {17, 1, 5}},
    {DIFFSERVIPACEDESTIPADDR, ASN_IPADDRESS, RWRITE, var_diffServIpAceTable, 3,
     {17, 1, 6}},
    {DIFFSERVIPACEDESTIPADDRBITMASK, ASN_IPADDRESS, RWRITE,
     var_diffServIpAceTable, 3, {17, 1, 7}},
    {DIFFSERVIPACEPROTOCOL, ASN_INTEGER, RWRITE, var_diffServIpAceTable, 3,
     {17, 1, 8}},

#if (SYS_CPNT_ACL_IP_EXT_PREC == TRUE)
    {DIFFSERVIPACEPREC, ASN_INTEGER, RWRITE, var_diffServIpAceTable, 3,
     {17, 1, 9}},
#endif

#if (SYS_CPNT_ACL_IP_EXT_TOS == TRUE)
    {DIFFSERVIPACETOS, ASN_INTEGER, RWRITE, var_diffServIpAceTable, 3,
     {17, 1, 10}},
#endif

#if (SYS_CPNT_ACL_IP_EXT_DSCP == TRUE)
    {DIFFSERVIPACEDSCP, ASN_INTEGER, RWRITE, var_diffServIpAceTable, 3,
     {17, 1, 11}},
#endif

    {DIFFSERVIPACESOURCEPORTOP, ASN_INTEGER, RWRITE, var_diffServIpAceTable, 3,
     {17, 1, 12}},
    {DIFFSERVIPACEMINSOURCEPORT, ASN_INTEGER, RWRITE, var_diffServIpAceTable, 3,
     {17, 1, 13}},
    {DIFFSERVIPACESOURCEPORTBITMASK, ASN_INTEGER, RWRITE,
     var_diffServIpAceTable, 3, {17, 1, 15}},
    {DIFFSERVIPACEDESTPORTOP, ASN_INTEGER, RWRITE, var_diffServIpAceTable, 3,
     {17, 1, 16}},
    {DIFFSERVIPACEMINDESTPORT, ASN_INTEGER, RWRITE, var_diffServIpAceTable, 3,
     {17, 1, 17}},
    {DIFFSERVIPACEDESTPORTBITMASK, ASN_INTEGER, RWRITE, var_diffServIpAceTable,
     3, {17, 1, 19}},
    {DIFFSERVIPACECONTROLCODE, ASN_INTEGER, RWRITE, var_diffServIpAceTable, 3,
     {17, 1, 20}},
    {DIFFSERVIPACECONTROLCODEBITMASK, ASN_INTEGER, RWRITE,
     var_diffServIpAceTable, 3, {17, 1, 21}},
    {DIFFSERVIPACESTATUS, ASN_INTEGER, RWRITE, var_diffServIpAceTable, 3,
     {17, 1, 22}},
#if (SYS_CPNT_ACL_IP_EXT_ICMP == TRUE)
    {DIFFSERVIPACEICMPTYPE, ASN_INTEGER, RWRITE, var_diffServIpAceTable, 3,
     {17, 1, 25}},
#endif
};
/*
 * (L = length of the oidsuffix)
 */


/** Initializes the diffServIpAceTable module */
void
init_diffServIpAceTable(void)
{

    DEBUGMSGTL(("diffServIpAceTable", "Initializing\n"));

    /*
     * register ourselves with the agent to handle our mib tree
     */
    REGISTER_MIB("diffServIpAceTable", diffServIpAceTable_variables, variable3,
                 diffServIpAceTable_variables_oid);

    /*
     * place any other initialization junk you need here
     */
}



oid             diffServMacAceTable_variables_oid[] =
    {  SYS_ADPT_PRIVATEMIB_OID, 1, 16, 4 };

struct variable3 diffServMacAceTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */

    {DIFFSERVMACACEINDEX, ASN_INTEGER, RONLY, var_diffServMacAceTable, 3,
     {18, 1, 1}},
    {DIFFSERVMACACEACCESS, ASN_INTEGER, RWRITE, var_diffServMacAceTable, 3,
     {18, 1, 2}},
    {DIFFSERVMACACEPKTFORMAT, ASN_INTEGER, RWRITE, var_diffServMacAceTable, 3,
     {18, 1, 3}},
    {DIFFSERVMACACESOURCEMACADDR, ASN_OCTET_STR, RWRITE,
     var_diffServMacAceTable, 3, {18, 1, 4}},
    {DIFFSERVMACACESOURCEMACADDRBITMASK, ASN_OCTET_STR, RWRITE,
     var_diffServMacAceTable, 3, {18, 1, 5}},
    {DIFFSERVMACACEDESTMACADDR, ASN_OCTET_STR, RWRITE, var_diffServMacAceTable,
     3, {18, 1, 6}},
    {DIFFSERVMACACEDESTMACADDRBITMASK, ASN_OCTET_STR, RWRITE,
     var_diffServMacAceTable, 3, {18, 1, 7}},
    {DIFFSERVMACACEVIDOP, ASN_INTEGER, RWRITE, var_diffServMacAceTable, 3,
     {18, 1, 8}},
    {DIFFSERVMACACEMINVID, ASN_INTEGER, RWRITE, var_diffServMacAceTable, 3,
     {18, 1, 9}},
    {DIFFSERVMACACEVIDBITMASK, ASN_INTEGER, RWRITE, var_diffServMacAceTable, 3,
     {18, 1, 10}},
    {DIFFSERVMACACEETHERTYPEOP, ASN_INTEGER, RWRITE, var_diffServMacAceTable,
     3, {18, 1, 12}},
    {DIFFSERVMACACEETHERTYPEBITMASK, ASN_INTEGER, RWRITE,
     var_diffServMacAceTable, 3, {18, 1, 13}},
    {DIFFSERVMACACEMINETHERTYPE, ASN_INTEGER, RWRITE, var_diffServMacAceTable,
     3, {18, 1, 14}},
    {DIFFSERVMACACESTATUS, ASN_INTEGER, RWRITE, var_diffServMacAceTable, 3,
     {18, 1, 16}},
    {DIFFSERVMACACECOSOP, ASN_INTEGER, RWRITE, var_diffServMacAceTable, 3,
     {18, 1, 17}},
    {DIFFSERVMACACECOSBITMASK, ASN_INTEGER, RWRITE, var_diffServMacAceTable, 3,
     {18, 1, 18}},
    {DIFFSERVMACACEMINCOS, ASN_INTEGER, RWRITE, var_diffServMacAceTable, 3,
     {18, 1, 19}},
};
/*
 * (L = length of the oidsuffix)
 */


/** Initializes the diffServMacAceTable module */
void
init_diffServMacAceTable(void)
{
    DEBUGMSGTL(("diffServMacAceTable", "Initializing\n"));

    /*
     * register ourselves with the agent to handle our mib tree
     */
    REGISTER_MIB("diffServMacAceTable", diffServMacAceTable_variables,
                 variable3, diffServMacAceTable_variables_oid);

    /*
     * place any other initialization junk you need here
     */
}


oid             diffServActionTable_variables_oid[] =
    { SYS_ADPT_PRIVATEMIB_OID, 1, 16, 4 };


struct variable3 diffServActionTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    {LEAF_diffServActionIndex,  ASN_INTEGER,  RONLY,   var_diffServActionTable, 3,  { 19, 1, LEAF_diffServActionIndex }},
#endif

    {LEAF_diffServActionList,  ASN_OCTET_STR,  RWRITE,  var_diffServActionTable, 3,  { 19, 1, LEAF_diffServActionList }},

#if (SYS_CPNT_QOS_DIFFSERV_CLASS_SET_ACTION_MODE & SYS_CPNT_QOS_DIFFSERV_CLASS_SET_ACTION_COS)
    {LEAF_diffServActionPktNewPri,  ASN_INTEGER,  RWRITE,  var_diffServActionTable, 3,  { 19, 1, LEAF_diffServActionPktNewPri }},
#endif

#if (SYS_CPNT_QOS_DIFFSERV_CLASS_SET_ACTION_MODE & SYS_CPNT_QOS_DIFFSERV_CLASS_SET_ACTION_PHB)
    {LEAF_diffServActionPktNewPhb,  ASN_INTEGER,  RWRITE,  var_diffServActionTable, 3,  { 19, 1, LEAF_diffServActionPktNewPhb }},
#endif

    {LEAF_diffServActionGreenPktTransmit,  ASN_INTEGER,  RWRITE,   var_diffServActionTable, 3,  { 19, 1, LEAF_diffServActionGreenPktTransmit }},
    {LEAF_diffServActionGreenPktNewDscp,  ASN_INTEGER,  RWRITE,  var_diffServActionTable, 3,  { 19, 1, LEAF_diffServActionGreenPktNewDscp }},
    {LEAF_diffServActionYellowPktNewDscp,  ASN_INTEGER,  RWRITE,  var_diffServActionTable, 3,  { 19, 1, LEAF_diffServActionYellowPktNewDscp }},
    {LEAF_diffServActionYellowPktDrop,  ASN_INTEGER,  RWRITE,   var_diffServActionTable, 3,  { 19, 1, LEAF_diffServActionYellowPktDrop }},
    {LEAF_diffServActionRedPktNewDscp,  ASN_INTEGER,  RWRITE,  var_diffServActionTable, 3,  { 19, 1, LEAF_diffServActionRedPktNewDscp }},
    {LEAF_diffServActionRedPktDrop,  ASN_INTEGER,  RWRITE,   var_diffServActionTable, 3,  { 19, 1, LEAF_diffServActionRedPktDrop }},
    {LEAF_diffServActionStatus,  ASN_INTEGER,  RWRITE,  var_diffServActionTable, 3,  { 19, 1, LEAF_diffServActionStatus }},

#if (SYS_CPNT_QOS_DIFFSERV_CLASS_SET_ACTION_MODE & SYS_CPNT_QOS_DIFFSERV_CLASS_SET_ACTION_IP_PRECEDENCE)
    {LEAF_diffServActionPktNewIpPrec,  ASN_INTEGER,  RWRITE,  var_diffServActionTable, 3,  { 19, 1, LEAF_diffServActionPktNewIpPrec}},
#endif

#if (SYS_CPNT_QOS_DIFFSERV_CLASS_SET_ACTION_MODE & SYS_CPNT_QOS_DIFFSERV_CLASS_SET_ACTION_IP_DSCP)
    {LEAF_diffServActionPktNewDscp,  ASN_INTEGER,  RWRITE,  var_diffServActionTable, 3,  { 19, 1, LEAF_diffServActionPktNewDscp}},
#endif

};
/*
 * (L = length of the oidsuffix)
 */


/** Initializes the diffServActionTable module */
void
init_diffServActionTable(void)
{

    DEBUGMSGTL(("diffServActionTable", "Initializing\n"));

    /*
     * register ourselves with the agent to handle our mib tree
     */
    REGISTER_MIB("diffServActionTable", diffServActionTable_variables,
                 variable3, diffServActionTable_variables_oid);

    /*
     * place any other initialization junk you need here
     */
}



oid             diffServMeterTable_variables_oid[] =
    {  SYS_ADPT_PRIVATEMIB_OID, 1, 16, 4 };

/*
 * variable3 diffServMeterTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */

struct variable3 diffServMeterTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */

    {DIFFSERVMETERINDEX, ASN_INTEGER, RONLY, var_diffServMeterTable, 3,
     {20, 1, 1}},
    {DIFFSERVMETERMODEL, ASN_INTEGER, RWRITE, var_diffServMeterTable, 3,
     {20, 1, 2}},
    {DIFFSERVMETERRATE, ASN_INTEGER, RWRITE, var_diffServMeterTable, 3,
     {20, 1, 3}},
    {DIFFSERVMETERBURSTSIZE, ASN_INTEGER, RWRITE, var_diffServMeterTable, 3,
     {20, 1, 4}},
    {DIFFSERVMETERSTATUS, ASN_INTEGER, RWRITE, var_diffServMeterTable, 3,
     {20, 1, 6}},
     /*zhangwei add*/
    {DIFFSERVMETERPEAKRATE, ASN_INTEGER, RWRITE, var_diffServMeterTable, 3,
     {20, 1, 7}},
    {DIFFSERVMETERPEAKBURSTSIZE, ASN_INTEGER, RWRITE, var_diffServMeterTable, 3,
     {20, 1, 8}},
     /*zhangwei add end*/
};
/*
 * (L = length of the oidsuffix)
 */


/** Initializes the diffServMeterTable module */
void
init_diffServMeterTable(void)
{

    DEBUGMSGTL(("diffServMeterTable", "Initializing\n"));

    /*
     * register ourselves with the agent to handle our mib tree
     */
    REGISTER_MIB("diffServMeterTable", diffServMeterTable_variables, variable3,
                 diffServMeterTable_variables_oid);

    /*
     * place any other initialization junk you need here
     */
}

#if (SYS_CPNT_ACL_IPV6 == TRUE)
oid             diffServIpv6AceTable_variables_oid[] =
    { SYS_ADPT_PRIVATEMIB_OID, 1, 16, 4 };

/*
 * variable3 diffServIpv6AceTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */

struct variable3 diffServIpv6AceTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */

    {DIFFSERVIPV6ACEINDEX, ASN_INTEGER, RONLY, var_diffServIpv6AceTable, 3,
     {21, 1, 1}},
    {DIFFSERVIPV6ACETYPE, ASN_INTEGER, RWRITE, var_diffServIpv6AceTable,
     3, {21, 1, 2}},
    {DIFFSERVIPV6ACEACCESS, ASN_INTEGER, RWRITE, var_diffServIpv6AceTable,
     3, {21, 1, 3}},
    {DIFFSERVIPV6ACESOURCEIPADDR, ASN_OCTET_STR, RWRITE,
     var_diffServIpv6AceTable, 3, {21, 1, 4}},
    {DIFFSERVIPV6ACESOURCEIPADDRPREFIXLEN, ASN_INTEGER, RWRITE,
     var_diffServIpv6AceTable, 3, {21, 1, 5}},
    {DIFFSERVIPV6ACEDESTIPADDR, ASN_OCTET_STR, RWRITE,
     var_diffServIpv6AceTable, 3, {21, 1, 6}},
    {DIFFSERVIPV6ACEDESTIPADDRPREFIXLEN, ASN_INTEGER, RWRITE,
     var_diffServIpv6AceTable, 3, {21, 1, 7}},

#if (SYS_CPNT_ACL_IPV6_EXT_NEXT_HEADER == TRUE)
    {DIFFSERVIPV6ACENEXTHEADER, ASN_INTEGER, RWRITE,
     var_diffServIpv6AceTable, 3, {21, 1, 8}},
#endif

    {DIFFSERVIPV6ACEDSCP, ASN_INTEGER, RWRITE, var_diffServIpv6AceTable, 3,
     {21, 1, 9}},

#if (SYS_CPNT_ACL_IPV6_EXT_FLOW_LABEL == TRUE)
    {DIFFSERVIPV6ACEFLOWLABEL, ASN_INTEGER, RWRITE,
     var_diffServIpv6AceTable, 3, {21, 1, 10}},
#endif

    {DIFFSERVIPV6ACESTATUS, ASN_INTEGER, RWRITE, var_diffServIpv6AceTable,
     3, {21, 1, 11}},
};


/** Initializes the aclIpv6AceTable module */
void
init_diffServIpv6AceTable(void)
{
    DEBUGMSGTL(("aclIpv6AceTable", "Initializing\n"));

    REGISTER_MIB("aclIpv6AceTable", diffServIpv6AceTable_variables,
                 variable3, diffServIpv6AceTable_variables_oid);
}
#endif /* end of #if (SYS_CPNT_ACL_IPV6 == TRUE) */

#if (SYS_CPNT_DAI == TRUE)
oid diffServArpAceTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,16,4 };

/* variable3 diffServArpAceTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */
struct variable3 diffServArpAceTable_variables[] =
{
/* magic number, variable type, ro/rw, callback fn, L, oidsuffix
 */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_diffServArpAceIndex, ASN_INTEGER, RONLY, var_diffServArpAceTable, 3, { 23, 1, 1 }},
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

    { LEAF_diffServArpAceAction, ASN_INTEGER, RWRITE, var_diffServArpAceTable, 3, { 23, 1, 2 }},
    { LEAF_diffServArpAcePktType, ASN_INTEGER, RWRITE, var_diffServArpAceTable, 3, { 23, 1, 3 }},
    { LEAF_diffServArpAceSourceIpAddr, ASN_IPADDRESS, RWRITE, var_diffServArpAceTable, 3, { 23, 1, 4 }},
    { LEAF_diffServArpAceSourceIpAddrBitmask, ASN_IPADDRESS, RWRITE, var_diffServArpAceTable, 3, { 23, 1, 5 }},
    { LEAF_diffServArpAceDestIpAddr, ASN_IPADDRESS, RWRITE, var_diffServArpAceTable, 3, { 23, 1, 6 }},
    { LEAF_diffServArpAceDestIpAddrBitmask, ASN_IPADDRESS, RWRITE, var_diffServArpAceTable, 3, { 23, 1, 7 }},
    { LEAF_diffServArpAceSourceMacAddr, ASN_OCTET_STR, RWRITE, var_diffServArpAceTable, 3, { 23, 1, 8 }},
    { LEAF_diffServArpAceSourceMacAddrBitmask, ASN_OCTET_STR, RWRITE, var_diffServArpAceTable, 3, { 23, 1, 9 }},
    { LEAF_diffServArpAceDestMacAddr, ASN_OCTET_STR, RWRITE, var_diffServArpAceTable, 3, { 23, 1, 10 }},
    { LEAF_diffServArpAceDestMacAddrBitmask, ASN_OCTET_STR, RWRITE, var_diffServArpAceTable, 3, { 23, 1, 11 }},
    { LEAF_diffServArpAceLogStatus, ASN_INTEGER, RWRITE, var_diffServArpAceTable, 3, { 23, 1, 12 }},
    { LEAF_diffServArpAceStatus, ASN_INTEGER, RWRITE, var_diffServArpAceTable, 3, { 23, 1, 13 }},
};

void init_diffServArpAceTable(void)
{
    REGISTER_MIB("diffServArpAceTable", diffServArpAceTable_variables, variable3,
                 diffServArpAceTable_variables_oid);
}

oid diffServArpTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,16,4 };

/* variable3 diffServArpTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */
struct variable3 diffServArpTable_variables[] =
{
/* magic number, variable type, ro/rw, callback fn, L, oidsuffix
 */
    { LEAF_diffServArpAclName, ASN_OCTET_STR, RONLY, var_diffServArpTable, 3, { 24, 1, 1 }},
};

void init_diffServArpTable(void)
{
    REGISTER_MIB("diffServArpTable", diffServArpTable_variables, variable3,
                 diffServArpTable_variables_oid);
}
#endif /* #if (SYS_CPNT_DAI == TRUE) */

#if (SYS_CPNT_ACL_COUNTER == TRUE)
oid diffServAclHwCounterTable_variables_oid[] = {  SYS_ADPT_PRIVATEMIB_OID, 1, 16, 4 };

struct variable3 diffServAclHwCounterTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */
    {DIFFSERVACLHWCOUNTERIFINDEX,     ASN_INTEGER,  RONLY, var_diffServAclHwCounterTable,
     3, {26, 1, 1}},
    {DIFFSERVACLHWCOUNTERDIRECTION,   ASN_INTEGER,  RONLY, var_diffServAclHwCounterTable,
     3, {26, 1, 2}},
    {DIFFSERVACLHWCOUNTERACLINDEX,    ASN_INTEGER,  RONLY, var_diffServAclHwCounterTable,
     3, {26, 1, 3}},
    {DIFFSERVACLHWCOUNTERACEINDEX,    ASN_INTEGER,  RONLY, var_diffServAclHwCounterTable,
     3, {26, 1, 4}},
    {DIFFSERVACLHWCOUNTERACEHITCOUNT, ASN_UNSIGNED, RONLY, var_diffServAclHwCounterTable,
     3, {26, 1, 5}},
};
/*
 * (L = length of the oidsuffix)
 */

/** Initializes the diffServAclCounterTable module */
void
init_diffServAclHwCounterTable(void)
{
    DEBUGMSGTL(("diffServAclHwCounterTable", "Initializing\n"));

    /*
     * register ourselves with the agent to handle our mib tree
     */
    REGISTER_MIB("diffServAclHwCounterTable", diffServAclHwCounterTable_variables,
                 variable3, diffServAclHwCounterTable_variables_oid);

    /*
     * place any other initialization junk you need here
     */
}
#endif /* #if (SYS_CPNT_ACL_COUNTER == TRUE) */

oid diffServPolicyMapPortTable_variables_oid[] = {  SYS_ADPT_PRIVATEMIB_OID, 1, 16, 4 };

struct variable3 diffServPolicyMapPortTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    {DIFFSERVPOLICYMAPPORTIFINDEX,     ASN_INTEGER,  RONLY, var_diffServPolicyMapPortTable,
     3, {27, 1, 1}},
    {DIFFSERVPOLICYMAPPORTDIRECTION,   ASN_INTEGER,  RONLY, var_diffServPolicyMapPortTable,
     3, {27, 1, 2}},
#endif /* (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */
    {DIFFSERVPOLICYMAPPORTPOLICYMAPINDEX,    ASN_INTEGER,  RWRITE, var_diffServPolicyMapPortTable,
     3, {27, 1, 3}},
    {DIFFSERVPOLICYMAPPORTSTATUS,    ASN_INTEGER,  RWRITE, var_diffServPolicyMapPortTable,
     3, {27, 1, 4}}
};
/*
 * (L = length of the oidsuffix)
 */

/** Initializes the diffServPolicyMapPortTable module */
void
init_diffServPolicyMapPortTable(void)
{
    DEBUGMSGTL(("diffServPolicyMapPortTable", "Initializing\n"));

    /*
     * register ourselves with the agent to handle our mib tree
     */
    REGISTER_MIB("diffServPolicyMapPortTable", diffServPolicyMapPortTable_variables,
                 variable3, diffServPolicyMapPortTable_variables_oid);

    /*
     * place any other initialization junk you need here
     */
}

oid diffServAccessGroupTable_variables_oid[] = {  SYS_ADPT_PRIVATEMIB_OID, 1, 16, 4 };

struct variable3 diffServAccessGroupTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    {DIFFSERVACCESSGROUPIFINDEX,     ASN_INTEGER,  RONLY, var_diffServAccessGroupTable,
     3, {28, 1, 1}},
    {DIFFSERVACCESSGROUPDIRECTION,   ASN_INTEGER,  RONLY, var_diffServAccessGroupTable,
     3, {28, 1, 2}},
    {DIFFSERVACCESSGROUPTYPE,        ASN_INTEGER,  RONLY, var_diffServAccessGroupTable,
     3, {28, 1, 3}},
#endif /* (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */
    {DIFFSERVACCESSGROUPACLINDEX,    ASN_INTEGER,  RWRITE, var_diffServAccessGroupTable,
     3, {28, 1, 4}},
#if (SYS_CPNT_TIME_BASED_ACL == TRUE)
     {DIFFSERVACCESSGROUPTIMERANGENAME,    ASN_OCTET_STR,  RWRITE, var_diffServAccessGroupTable,
     3, {28, 1, 5}},
#endif /* (SYS_CPNT_TIME_BASED_ACL == TRUE) */
#if (SYS_CPNT_ACL_COUNTER == TRUE)
     {DIFFSERVACCESSGROUPCOUNTERSTATUS,    ASN_INTEGER,  RWRITE, var_diffServAccessGroupTable,
     3, {28, 1, 6}},
#endif /* (SYS_CPNT_ACL_COUNTER == TRUE) */
     {DIFFSERVACCESSGROUPSTATUS,     ASN_INTEGER,  RWRITE, var_diffServAccessGroupTable,
     3, {28, 1, 7}},
};
/*
 * (L = length of the oidsuffix)
 */

/** Initializes the diffServPolicyMapPortTable module */
void
init_diffServAccessGroupTable(void)
{
    DEBUGMSGTL(("diffServAccessGroupTable", "Initializing\n"));

    /*
     * register ourselves with the agent to handle our mib tree
     */
    REGISTER_MIB("diffServAccessGroupTable", diffServAccessGroupTable_variables,
                 variable3, diffServAccessGroupTable_variables_oid);

    /*
     * place any other initialization junk you need here
     */
}

oid diffServTcamTable_variables_oid[] = {  SYS_ADPT_PRIVATEMIB_OID, 1, 16, 4 };

struct variable3 diffServTcamTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    {DIFFSERVTCAMUNIT,     ASN_UNSIGNED,  RONLY, var_diffServTcamTable,
     3, {29, 1, 1}},
    {DIFFSERVTCAMDEVICE,   ASN_UNSIGNED,  RONLY, var_diffServTcamTable,
     3, {29, 1, 2}},
    {DIFFSERVTCAMPOOL,    ASN_UNSIGNED,  RONLY, var_diffServTcamTable,
     3, {29, 1, 3}},
#endif /* SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE */
    {DIFFSERVTCAMPOOLCAPABILITY,    ASN_OCTET_STR,  RONLY, var_diffServTcamTable,
     3, {29, 1, 4}},
    {DIFFSERVTCAMTOTAL, ASN_UNSIGNED, RONLY, var_diffServTcamTable,
     3, {29, 1, 5}},
    {DIFFSERVTCAMFREE, ASN_UNSIGNED, RONLY, var_diffServTcamTable,
     3, {29, 1, 6}},
    {DIFFSERVTCAMUSED, ASN_UNSIGNED, RONLY, var_diffServTcamTable,
     3, {29, 1, 7}},
};
/*
 * (L = length of the oidsuffix)
 */

/** Initializes the diffServTcamTable module */
void
init_diffServTcamTable(void)
{
    DEBUGMSGTL(("diffServTcamTable", "Initializing\n"));

    /*
     * register ourselves with the agent to handle our mib tree
     */
    REGISTER_MIB("diffServTcamTable", diffServTcamTable_variables,
                 variable3, diffServTcamTable_variables_oid);

    /*
     * place any other initialization junk you need here
     */
}

#if (SYS_CPNT_QOS_V2_COUNTER == TRUE)
oid diffServControlPlaneHwCounterTable_variables_oid[] = {  SYS_ADPT_PRIVATEMIB_OID, 1, 16, 4 };

struct variable3 diffServControlPlaneHwCounterTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */
    {DIFFSERVCONTROLPLANEHWCOUNTERCLASSMAPINDEX,     ASN_INTEGER,  RONLY,
     var_diffServControlPlaneHwCounterTable, 3, {32, 1, 1}},
    {DIFFSERVCONTROLPLANEHWCOUNTERCLASSMAPRECEIVEPACKETS,   ASN_INTEGER,  RONLY,
     var_diffServControlPlaneHwCounterTable, 3, {32, 1, 2}},
    {DIFFSERVCONTROLPLANEHWCOUNTERCLASSMAPDROPPACKETS,    ASN_INTEGER,  RONLY,
     var_diffServControlPlaneHwCounterTable, 3, {32, 1, 3}},
    {DIFFSERVCONTROLPLANEHWCOUNTERCLASSMAPCLEARACTION,    ASN_INTEGER,  RWRITE,
     var_diffServControlPlaneHwCounterTable, 3, {32, 1, 4}},
};

/** Initializes the diffServControlPlaneHwCounterTable module */
void
init_diffServControlPlaneHwCounterTable(void)
{
    DEBUGMSGTL(("diffServControlPlaneHwCounterTable", "Initializing\n"));

    /*
     * register ourselves with the agent to handle our mib tree
     */
    REGISTER_MIB("diffServControlPlaneHwCounterTable", diffServControlPlaneHwCounterTable_variables,
                 variable3, diffServControlPlaneHwCounterTable_variables_oid);

    /*
     * place any other initialization junk you need here
     */
}
#endif /* #if (SYS_CPNT_QOS_V2_COUNTER == TRUE) */


#endif /* #if (SYS_CPNT_QOS_V2 == TRUE) */

#if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION==TRUE)
/********************************************
 ************privateVlanMgt****************
 ********************************************
 */
/** Initializes the privateVlanMgt module */
void
init_privateVlanMgt(void)
{
#if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE != SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE_MULTIPLE_SESSION)
    static oid      privateVlanUplinkPorts_oid[] =
        { SYS_ADPT_PRIVATEMIB_OID, 1, 17, 1, 2, 0 };
    static oid      privateVlanDownlinkPorts_oid[] =
        { SYS_ADPT_PRIVATEMIB_OID, 1, 17, 1, 3, 0 };
#endif/* #if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE != SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE_MULTIPLE_SESSION) */
    static oid      privateVlanStatus_oid[] =
        { SYS_ADPT_PRIVATEMIB_OID, 1, 17, 1, 1, 0 };

#if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE != SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE_MULTIPLE_SESSION)
    init_PrivateMIBNodeRootOIDbySwitchBoardID(privateVlanUplinkPorts_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("privateVlanUplinkPorts",
                               do_privateVlanUplinkPorts,
                               privateVlanUplinkPorts_oid,
                               OID_LENGTH(privateVlanUplinkPorts_oid),
                               HANDLER_CAN_RWRITE));
    init_PrivateMIBNodeRootOIDbySwitchBoardID(privateVlanDownlinkPorts_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("privateVlanDownlinkPorts",
                               do_privateVlanDownlinkPorts,
                               privateVlanDownlinkPorts_oid,
                               OID_LENGTH(privateVlanDownlinkPorts_oid),
                               HANDLER_CAN_RWRITE));
#endif/* #if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE != SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE_MULTIPLE_SESSION) */
    init_PrivateMIBNodeRootOIDbySwitchBoardID(privateVlanStatus_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("privateVlanStatus", do_privateVlanStatus,
                               privateVlanStatus_oid,
                               OID_LENGTH(privateVlanStatus_oid),
                               HANDLER_CAN_RWRITE));
}

#if (SYS_CPNT_COMMUNITY_PRIVATE_VLAN == TRUE)

oid privateVlanVlanTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1, 17, 1 };

struct variable3 privateVlanVlanTable_variables[] =
{
    {PRIVATEVLANVLANINDEX, ASN_INTEGER, RONLY, var_privateVlanVlanTable, 3, {4, 1, 1}},
    {PRIVATEVLANVLANTYPE, ASN_INTEGER, RWRITE, var_privateVlanVlanTable, 3, {4, 1, 2}},
    {PRIVATEVLANASSOICATEDPRIMARYVLAN, ASN_INTEGER, RWRITE, var_privateVlanVlanTable, 3, {4, 1, 3}},
};


void init_privateVlanVlanTable(void)
{
    REGISTER_MIB("privateVlanVlanTable", privateVlanVlanTable_variables,
                 variable3, privateVlanVlanTable_variables_oid);
}


oid privateVlanPrivatePortTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1, 17, 1 };

struct variable3 privateVlanPrivatePortTable_variables[] =
{
    {PRIVATEVLANPRIVATEPORTIFINDEX, ASN_INTEGER, RONLY, var_privateVlanPrivatePortTable, 3, {5, 1, 1}},
    {PRIVATEVLANPRIVATEPORTSECONDARYVLAN, ASN_INTEGER, RWRITE, var_privateVlanPrivatePortTable, 3, {5, 1, 2}},
};


void init_privateVlanPrivatePortTable(void)
{
    REGISTER_MIB("privateVlanPrivatePortTable", privateVlanPrivatePortTable_variables,
                 variable3, privateVlanPrivatePortTable_variables_oid);
}


oid privateVlanPromPortTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1, 17, 1 };

struct variable3 privateVlanPromPortTable_variables[] =
{
    {PRIVATEVLANPROMPORTIFINDEX, ASN_INTEGER, RONLY, var_privateVlanPromPortTable, 3, {6, 1, 1}},
    {PRIVATEVLANPROMPORTPRIMARYVLANID, ASN_INTEGER, RWRITE, var_privateVlanPromPortTable, 3, {6, 1, 2}},
    {PRIVATEVLANPROMPORTSECONDARYREMAP, ASN_OCTET_STR, RONLY, var_privateVlanPromPortTable, 3, {6, 1, 3}},
    {PRIVATEVLANPROMPORTSECONDARYREMAP2K, ASN_OCTET_STR, RONLY, var_privateVlanPromPortTable, 3, {6, 1, 4}},
    {PRIVATEVLANPROMPORTSECONDARYREMAP3K, ASN_OCTET_STR, RONLY, var_privateVlanPromPortTable, 3, {6, 1, 5}},
    {PRIVATEVLANPROMPORTSECONDARYREMAP4K, ASN_OCTET_STR, RONLY, var_privateVlanPromPortTable, 3, {6, 1, 6}},
};


void init_privateVlanPromPortTable(void)
{
    REGISTER_MIB("privateVlanPromPortTable", privateVlanPromPortTable_variables,
                 variable3, privateVlanPromPortTable_variables_oid);
}
#endif  /* end of #if (SYS_CPNT_COMMUNITY_PRIVATE_VLAN == TRUE) */

#if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE == SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE_MULTIPLE_SESSION)
/********************************************
 **********privateVlanSessionTable***********
 ********************************************
 */
oid privateVlanSessionTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1, 17, 1 };

struct variable3 privateVlanSessionTable_variables[] = {

#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
{PRIVATEVLANSESSIONID,  ASN_INTEGER,  RONLY,   var_privateVlanSessionTable, 3,  { 8, 1, 1 }},
#endif

{PRIVATEVLANSESSIONUPLINKPORTS,  ASN_OCTET_STR,  RWRITE,  var_privateVlanSessionTable, 3,  { 8, 1, 2 }},
{PRIVATEVLANSESSIONDOWNLINKPORTS,  ASN_OCTET_STR,  RWRITE,  var_privateVlanSessionTable, 3,  { 8, 1, 3 }},
{PRIVATEVLANSESSIONSTATUS,  ASN_INTEGER,  RWRITE,  var_privateVlanSessionTable, 3,  { 8, 1, 4 }},
};

void
init_privateVlanSessionTable(void)
{
    REGISTER_MIB("privateVlanSessionTable", privateVlanSessionTable_variables, variable3,
                 privateVlanSessionTable_variables_oid);
}

/********************************************
 **********privateVlanUplinkToUplink*********
 ********************************************
 */
void
init_privateVlanUplinkToUplink(void)
{
    static oid privateVlanUplinkToUplink_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1, 17, 1, 9, 0 };

    DEBUGMSGTL(("privateVlanUplinkToUplink", "Initializing\n"));

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("privateVlanUplinkToUplink",
                               do_privateVlanUplinkToUplink,
                               privateVlanUplinkToUplink_oid,
                               OID_LENGTH(privateVlanUplinkToUplink_oid),
                               HANDLER_CAN_RWRITE));

}
#endif /* end of #if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE == SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE_MULTIPLE_SESSION) */

#if (SYS_DFLT_TRAFFIC_SEG_METHOD == SYS_DFLT_TRAFFIC_SEG_METHOD_PORT_PRIVATE_MODE)

oid privateVlanEdgePortTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,17,1 };

struct variable3 privateVlanEdgePortTable_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
{LEAF_pvePortIfIndex,  ASN_INTEGER,  RONLY,   var_privateVlanEdgePortTable, 3,  { 10, 1, 1 }},
#endif

{LEAF_pvePortStatus,  ASN_INTEGER,  RWRITE,  var_privateVlanEdgePortTable, 3,  { 10, 1, 2 }},
};

/** Initializes the privateVlanEdgePortTable module */
void
init_privateVlanEdgePortTable(void)
{
    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("privateVlanEdgePortTable", privateVlanEdgePortTable_variables, variable3,
                 privateVlanEdgePortTable_variables_oid);
}

#endif    /* #if (SYS_DFLT_TRAFFIC_SEG_METHOD == SYS_DFLT_TRAFFIC_SEG_METHOD_PORT_PRIVATE_MODE) */

#endif/*end of #if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION==TRUE)*/

/********************************************
 ************portSecPortTable****************
 ********************************************
 */
#if (SYS_CPNT_PORT_SECURITY==TRUE)

oid portSecPortTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,17,2 };

struct variable3 portSecPortTable_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
{PORTSECPORTINDEX,  ASN_INTEGER,  RONLY,   var_portSecPortTable, 3,  { 1, 1, 1 }},
#endif
{PORTSECPORTSTATUS,  ASN_INTEGER,  RWRITE,  var_portSecPortTable, 3,  { 1, 1, 2 }},
{PORTSECACTION,  ASN_INTEGER,  RWRITE,  var_portSecPortTable, 3,  { 1, 1, 3 }},
{PORTSECMAXMACCOUNT,  ASN_INTEGER,  RWRITE,  var_portSecPortTable, 3,  { 1, 1, 4 }},

};

/** Initializes the portSecPortTable module */
void
init_portSecPortTable(void)
{
    /* register ourselves with the agent to handle our mib tree */
    init_PrivateMIBNodeRootOIDbySwitchBoardID(portSecPortTable_variables_oid);
    REGISTER_MIB("portSecPortTable", portSecPortTable_variables, variable3,
               portSecPortTable_variables_oid);
}

/********************************************
 ***********portSecMacAsPermanentMgt*********
 ********************************************
 */

void init_portSecMacAsPermanentMgt(void)
{
    static oid portSecMacAsPermanentPortIndex_oid[] = {SYS_ADPT_PRIVATEMIB_OID, 1, 17, 2, 6, 1, 0 };
    static oid portSecMacAsPermanentAction_oid[]    = {SYS_ADPT_PRIVATEMIB_OID, 1, 17, 2, 6, 2, 0 };

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("portSecMacAsPermanentPortIndex",
                               do_portSecMacAsPermanentPortIndex,
                               portSecMacAsPermanentPortIndex_oid,
                               OID_LENGTH(portSecMacAsPermanentPortIndex_oid),
                               HANDLER_CAN_RWRITE));

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("portSecMacAsPermanentAction",
                               do_portSecMacAsPermanentAction,
                               portSecMacAsPermanentAction_oid,
                               OID_LENGTH(portSecMacAsPermanentAction_oid),
                               HANDLER_CAN_RWRITE));

}
#endif



/********************************************
 **********packetFilterUnitMgt***************
 ********************************************
 */
#if (SYS_CPNT_PFU == TRUE)
void
init_packetFilterUnitMgt(void)
{
    static oid pfuInsert_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,17,3,3, 0 };
    static oid pfuNextAvailable_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,17,3,2, 0 };

    init_PrivateMIBNodeRootOIDbySwitchBoardID(pfuInsert_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("pfuInsert",
                               do_pfuInsert,
                               pfuInsert_oid,
                               OID_LENGTH(pfuInsert_oid),
                               HANDLER_CAN_RWRITE));
    init_PrivateMIBNodeRootOIDbySwitchBoardID(pfuNextAvailable_oid);
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("pfuNextAvailable",
                                         get_pfuNextAvailable,
                                         pfuNextAvailable_oid,
                                         OID_LENGTH(pfuNextAvailable_oid),
                                         HANDLER_CAN_RONLY));
}



/********************************************
 ****************pfuRuleTable****************
 ********************************************
 */

oid pfuRuleTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,17,3 };

struct variable3 pfuRuleTable_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
{PFURULEINDEX,  ASN_INTEGER,  RONLY,   var_pfuRuleTable, 3,  { 1, 1, 1 }},
#endif
{PFURULEACTION,  ASN_INTEGER,  RWRITE,  var_pfuRuleTable, 3,  { 1, 1, 2 }},
{PFURULEPROTOCOL,  ASN_INTEGER,  RWRITE,  var_pfuRuleTable, 3,  { 1, 1, 3 }},
{PFURULESRCIPADDR,  ASN_IPADDRESS,  RWRITE,  var_pfuRuleTable, 3,  { 1, 1, 4 }},
{PFURULESRCIPBITMASK,  ASN_IPADDRESS,  RWRITE,  var_pfuRuleTable, 3,  { 1, 1, 5 }},
{PFURULESRCPORTRANGE1,  ASN_INTEGER,  RWRITE,  var_pfuRuleTable, 3,  { 1, 1, 6 }},
{PFURULESRCPORTRANGE2,  ASN_INTEGER,  RWRITE,  var_pfuRuleTable, 3,  { 1, 1, 7 }},
{PFURULEDSTIPADDR,  ASN_IPADDRESS,  RWRITE,  var_pfuRuleTable, 3,  { 1, 1, 8 }},
{PFURULEDSTIPBITMASK,  ASN_IPADDRESS,  RWRITE,  var_pfuRuleTable, 3,  { 1, 1, 9 }},
{PFURULEDSTPORTRANGE1,  ASN_INTEGER,  RWRITE,  var_pfuRuleTable, 3,  { 1, 1, 10 }},
{PFURULEDSTPORTRANGE2,  ASN_INTEGER,  RWRITE,  var_pfuRuleTable, 3,  { 1, 1, 11 }},
{PFURULETCPCODE,  ASN_INTEGER,  RWRITE,  var_pfuRuleTable, 3,  { 1, 1, 12 }},
{PFURULETCPCODEBITMASK,  ASN_INTEGER,  RWRITE,  var_pfuRuleTable, 3,  { 1, 1, 13 }},
{PFURULEFRAGMENTS,  ASN_INTEGER,  RWRITE,  var_pfuRuleTable, 3,  { 1, 1, 14 }},
{PFURULELOG,  ASN_INTEGER,  RWRITE,  var_pfuRuleTable, 3,  { 1, 1, 15 }},
{PFURULEROWSTATUS,  ASN_INTEGER,  RWRITE,  var_pfuRuleTable, 3,  { 1, 1, 16 }},
};

/** Initializes the pfuRuleTable module */
void
init_pfuRuleTable(void)
{
    /* register ourselves with the agent to handle our mib tree */
    init_PrivateMIBNodeRootOIDbySwitchBoardID(pfuRuleTable_variables_oid);
    REGISTER_MIB("pfuRuleTable", pfuRuleTable_variables, variable3,
               pfuRuleTable_variables_oid);
}
#endif


#if (SYS_CPNT_RADIUS == TRUE)
/********************************************
 *******************radiusMgt****************
 ********************************************
 */
void init_radiusMgt(void)
{
    static oid radiusServerGlobalAuthPort_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,17,4,1,0 };

#if (SYS_CPNT_RADIUS_ACCOUNTING == TRUE)
    static oid radiusServerGlobalAcctPort_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,17,4,2,0 };
#endif /* #if (SYS_CPNT_RADIUS_ACCOUNTING == TRUE) */

    static oid radiusServerGlobalKey_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,17,4,3,0 };
    static oid radiusServerGlobalRetransmit_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,17,4,4,0 };
    static oid radiusServerGlobalTimeout_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,17,4,5,0 };

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("radiusServerGlobalAuthPort",
                               do_radiusServerGlobalAuthPort,
                               radiusServerGlobalAuthPort_oid,
                               OID_LENGTH(radiusServerGlobalAuthPort_oid),
                               HANDLER_CAN_RWRITE));

#if (SYS_CPNT_RADIUS_ACCOUNTING == TRUE)
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("radiusServerGlobalAcctPort",
                               do_radiusServerGlobalAcctPort,
                               radiusServerGlobalAcctPort_oid,
                               OID_LENGTH(radiusServerGlobalAcctPort_oid),
                               HANDLER_CAN_RWRITE));
#endif /* #if (SYS_CPNT_RADIUS_ACCOUNTING == TRUE) */

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("radiusServerGlobalKey",
                               do_radiusServerGlobalKey,
                               radiusServerGlobalKey_oid,
                               OID_LENGTH(radiusServerGlobalKey_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("radiusServerGlobalRetransmit",
                               do_radiusServerGlobalRetransmit,
                               radiusServerGlobalRetransmit_oid,
                               OID_LENGTH(radiusServerGlobalRetransmit_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("radiusServerGlobalTimeout",
                               do_radiusServerGlobalTimeout,
                               radiusServerGlobalTimeout_oid,
                               OID_LENGTH(radiusServerGlobalTimeout_oid),
                               HANDLER_CAN_RWRITE));
}

oid radiusServerTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,17,4 };

/* variable3 radiusServerTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */
struct variable3 radiusServerTable_variables[] =
{
/* magic number, variable type, ro/rw, callback fn, L, oidsuffix
 */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_radiusServerIndex, ASN_INTEGER, RONLY, var_radiusServerTable, 3, { 7, 1, 1 }},
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

    { LEAF_radiusServerAddress, ASN_IPADDRESS, RWRITE, var_radiusServerTable, 3, { 7, 1, 2 }},
    { LEAF_radiusServerAuthPortNumber, ASN_INTEGER, RWRITE, var_radiusServerTable, 3, { 7, 1, 3 }},

#if (SYS_CPNT_RADIUS_ACCOUNTING == TRUE)
    { LEAF_radiusServerAcctPortNumber, ASN_INTEGER, RWRITE, var_radiusServerTable, 3, { 7, 1, 4 }},
#endif /* #if (SYS_CPNT_RADIUS_ACCOUNTING == TRUE) */

    { LEAF_radiusServerKey, ASN_OCTET_STR, RWRITE, var_radiusServerTable, 3, { 7, 1, 5 }},
    { LEAF_radiusServerRetransmit, ASN_INTEGER, RWRITE, var_radiusServerTable, 3, { 7, 1, 6 }},
    { LEAF_radiusServerTimeout, ASN_INTEGER, RWRITE, var_radiusServerTable, 3, { 7, 1, 7 }},
    { LEAF_radiusServerStatus, ASN_INTEGER, RWRITE, var_radiusServerTable, 3, { 7, 1, 8 }},
};

void init_radiusServerTable(void)
{
    REGISTER_MIB("radiusServerTable", radiusServerTable_variables, variable3,
                 radiusServerTable_variables_oid);
}
#endif /* #if (SYS_CPNT_RADIUS == TRUE) */

/********************************************
 *******************tacacsMgt****************
 ********************************************
 */
#if (SYS_CPNT_TACACS == TRUE)
void init_tacacsMgt(void)
{
    static oid tacacsPlusServerGlobalPortNumber_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,17,5,2,0 };
    static oid tacacsPlusServerGlobalKey_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,17,5,3,0 };
#if 0
    static oid tacacsPlusServerGlobalRetransmit_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,17,5,5,0 };
    static oid tacacsPlusServerGlobalTimeout_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,17,5,6,0 };
#endif

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("tacacsPlusServerGlobalPortNumber",
                               do_tacacsPlusServerGlobalPortNumber,
                               tacacsPlusServerGlobalPortNumber_oid,
                               OID_LENGTH(tacacsPlusServerGlobalPortNumber_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("tacacsPlusServerGlobalKey",
                               do_tacacsPlusServerGlobalKey,
                               tacacsPlusServerGlobalKey_oid,
                               OID_LENGTH(tacacsPlusServerGlobalKey_oid),
                               HANDLER_CAN_RWRITE));
#if 0
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("tacacsPlusServerGlobalRetransmit",
                               do_tacacsPlusServerGlobalRetransmit,
                               tacacsPlusServerGlobalRetransmit_oid,
                               OID_LENGTH(tacacsPlusServerGlobalRetransmit_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("tacacsPlusServerGlobalTimeout",
                               do_tacacsPlusServerGlobalTimeout,
                               tacacsPlusServerGlobalTimeout_oid,
                               OID_LENGTH(tacacsPlusServerGlobalTimeout_oid),
                               HANDLER_CAN_RWRITE));
#endif /* #if 0 */
}

oid tacacsPlusServerTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,17,5 };

/* variable3 tacacsPlusServerTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */
struct variable3 tacacsPlusServerTable_variables[] =
{
/* magic number, variable type, ro/rw, callback fn, L, oidsuffix
 */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_tacacsPlusServerIndex, ASN_INTEGER, RONLY, var_tacacsPlusServerTable, 3, { 4, 1, 1 }},
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

    { LEAF_tacacsPlusServerAddress, ASN_IPADDRESS, RWRITE, var_tacacsPlusServerTable, 3, { 4, 1, 2 }},
    { LEAF_tacacsPlusServerPortNumber, ASN_INTEGER, RWRITE, var_tacacsPlusServerTable, 3, { 4, 1, 3 }},
    { LEAF_tacacsPlusServerKey, ASN_OCTET_STR, RWRITE, var_tacacsPlusServerTable, 3, { 4, 1, 4 }},
    { LEAF_tacacsPlusServerStatus, ASN_INTEGER, RWRITE, var_tacacsPlusServerTable, 3, { 4, 1, 8 }},
#if 0
    { LEAF_tacacsPlusServerRetransmit, ASN_INTEGER, RWRITE, var_tacacsPlusServerTable, 3, { 4, 1, 9 }},
    { LEAF_tacacsPlusServerTimeout, ASN_INTEGER, RWRITE, var_tacacsPlusServerTable, 3, { 4, 1, 10 }},
#endif /* #if 0 */
};

void init_tacacsPlusServerTable(void)
{
    REGISTER_MIB("tacacsPlusServerTable", tacacsPlusServerTable_variables, variable3,
                 tacacsPlusServerTable_variables_oid);
}
#endif /* #if (SYS_CPNT_TACACS == TRUE) */

/********************************************
 *******************sshMgt*******************
 ********************************************
 */
#if (SYS_CPNT_SSHD == TRUE || SYS_CPNT_SSH2 == TRUE)

void
init_sshMgt(void)
{
     static oid      sshServerStatus_oid[] =
        { SYS_ADPT_PRIVATEMIB_OID, 1, 17, 6, 1, 0 };
      static oid      sshServerMajorVersion_oid[] =
        { SYS_ADPT_PRIVATEMIB_OID, 1, 17, 6, 2, 0 };
    static oid      sshServerMinorVersion_oid[] =
        { SYS_ADPT_PRIVATEMIB_OID, 1, 17, 6, 3, 0 };
     static oid      sshTimeout_oid[] =
        { SYS_ADPT_PRIVATEMIB_OID, 1, 17, 6, 4, 0 };
     static oid      sshAuthRetries_oid[] =
        { SYS_ADPT_PRIVATEMIB_OID, 1, 17, 6, 5, 0 };
#if (SYS_CPNT_SSH2 == TRUE)
    static oid      sshDsaHostKey5_oid[] =
        { SYS_ADPT_PRIVATEMIB_OID, 1, 17, 6, 20, 0 };
    static oid      sshDsaHostKey6_oid[] =
        { SYS_ADPT_PRIVATEMIB_OID, 1, 17, 6, 21, 0 };
    static oid      sshDsaHostKey7_oid[] =
        { SYS_ADPT_PRIVATEMIB_OID, 1, 17, 6, 22, 0 };
    static oid      sshDsaHostKey8_oid[] =
        { SYS_ADPT_PRIVATEMIB_OID, 1, 17, 6, 23, 0 };
    static oid      sshHostKeyGenStatus_oid[] =
        { SYS_ADPT_PRIVATEMIB_OID, 1, 17, 6, 25, 0 };
    static oid      sshHostKeySaveAction_oid[] =
        { SYS_ADPT_PRIVATEMIB_OID, 1, 17, 6, 26, 0 };

    static oid      sshHostKeySaveStatus_oid[] =
        { SYS_ADPT_PRIVATEMIB_OID, 1, 17, 6, 27, 0 };

    static oid      sshKeySize_oid[] =
        { SYS_ADPT_PRIVATEMIB_OID, 1, 17, 6, 7, 0 };
    static oid      sshHostKeyDelAction_oid[] =
        { SYS_ADPT_PRIVATEMIB_OID, 1, 17, 6, 28, 0 };
    #if 0
    static oid      sshRsaHostKeySHA1FingerPrint_oid[]=
        { SYS_ADPT_PRIVATEMIB_OID, 1, 17, 6, 30, 0 };
    static oid      sshRsaHostKeyMD5FingerPrint_oid[]=
        { SYS_ADPT_PRIVATEMIB_OID, 1, 17, 6, 31, 0 };
    static oid      sshDsaHostKeySHA1FingerPrint_oid[]=
        { SYS_ADPT_PRIVATEMIB_OID, 1, 17, 6, 32, 0 };
    static oid      sshDsaHostKeyMD5FingerPrint_oid[]=
        { SYS_ADPT_PRIVATEMIB_OID, 1, 17, 6, 33, 0 };
    #endif
    static oid      sshRsaHostKey1_oid[] =
        { SYS_ADPT_PRIVATEMIB_OID, 1, 17, 6, 8, 0 };
    static oid      sshRsaHostKey2_oid[] =
        { SYS_ADPT_PRIVATEMIB_OID, 1, 17, 6, 9, 0 };
    static oid      sshRsaHostKey3_oid[] =
        { SYS_ADPT_PRIVATEMIB_OID, 1, 17, 6, 10, 0 };
    static oid      sshRsaHostKey4_oid[] =
        { SYS_ADPT_PRIVATEMIB_OID, 1, 17, 6, 11, 0 };
    static oid      sshRsaHostKey5_oid[] =
        { SYS_ADPT_PRIVATEMIB_OID, 1, 17, 6, 12, 0 };
    static oid      sshDsaHostKey1_oid[] =
        { SYS_ADPT_PRIVATEMIB_OID, 1, 17, 6, 16, 0 };
    static oid      sshRsaHostKey6_oid[] =
        { SYS_ADPT_PRIVATEMIB_OID, 1, 17, 6, 13, 0 };
    static oid      sshHostKeyGenAction_oid[] =
        { SYS_ADPT_PRIVATEMIB_OID, 1, 17, 6, 24, 0 };
    static oid      sshDsaHostKey2_oid[] =
        { SYS_ADPT_PRIVATEMIB_OID, 1, 17, 6, 17, 0 };
    static oid      sshRsaHostKey7_oid[] =
        { SYS_ADPT_PRIVATEMIB_OID, 1, 17, 6, 14, 0 };
    static oid      sshRsaHostKey8_oid[] =
        { SYS_ADPT_PRIVATEMIB_OID, 1, 17, 6, 15, 0 };
    static oid      sshDsaHostKey3_oid[] =
        { SYS_ADPT_PRIVATEMIB_OID, 1, 17, 6, 18, 0 };

    static oid      sshDsaHostKey4_oid[] =
        { SYS_ADPT_PRIVATEMIB_OID, 1, 17, 6, 19, 0 };
#endif

    init_PrivateMIBNodeRootOIDbySwitchBoardID(sshServerStatus_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("sshServerStatus", do_sshServerStatus,
                               sshServerStatus_oid,
                               OID_LENGTH(sshServerStatus_oid),
                               HANDLER_CAN_RWRITE));
    init_PrivateMIBNodeRootOIDbySwitchBoardID(sshServerMajorVersion_oid);
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("sshServerMajorVersion",
                                         get_sshServerMajorVersion,
                                         sshServerMajorVersion_oid,
                                         OID_LENGTH
                                         (sshServerMajorVersion_oid),
                                         HANDLER_CAN_RONLY));
    init_PrivateMIBNodeRootOIDbySwitchBoardID(sshServerMinorVersion_oid);
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("sshServerMinorVersion",
                                         get_sshServerMinorVersion,
                                         sshServerMinorVersion_oid,
                                         OID_LENGTH
                                         (sshServerMinorVersion_oid),
                                         HANDLER_CAN_RONLY));
    init_PrivateMIBNodeRootOIDbySwitchBoardID(sshTimeout_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("sshTimeout", do_sshTimeout, sshTimeout_oid,
                               OID_LENGTH(sshTimeout_oid),
                               HANDLER_CAN_RWRITE));
    init_PrivateMIBNodeRootOIDbySwitchBoardID(sshAuthRetries_oid);
     netsnmp_register_instance(netsnmp_create_handler_registration
                              ("sshAuthRetries", do_sshAuthRetries,
                               sshAuthRetries_oid,
                               OID_LENGTH(sshAuthRetries_oid),
                               HANDLER_CAN_RWRITE));

#if (SYS_CPNT_SSH2 == TRUE)
    init_PrivateMIBNodeRootOIDbySwitchBoardID(sshDsaHostKey5_oid);
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("sshDsaHostKey5",
                                         get_sshDsaHostKey5,
                                         sshDsaHostKey5_oid,
                                         OID_LENGTH(sshDsaHostKey5_oid),
                                         HANDLER_CAN_RONLY));
    init_PrivateMIBNodeRootOIDbySwitchBoardID(sshDsaHostKey6_oid);
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("sshDsaHostKey6",
                                         get_sshDsaHostKey6,
                                         sshDsaHostKey6_oid,
                                         OID_LENGTH(sshDsaHostKey6_oid),
                                         HANDLER_CAN_RONLY));
    init_PrivateMIBNodeRootOIDbySwitchBoardID(sshDsaHostKey7_oid);
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("sshDsaHostKey7",
                                         get_sshDsaHostKey7,
                                         sshDsaHostKey7_oid,
                                         OID_LENGTH(sshDsaHostKey7_oid),
                                         HANDLER_CAN_RONLY));
    init_PrivateMIBNodeRootOIDbySwitchBoardID(sshDsaHostKey8_oid);
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("sshDsaHostKey8",
                                         get_sshDsaHostKey8,
                                         sshDsaHostKey8_oid,
                                         OID_LENGTH(sshDsaHostKey8_oid),
                                         HANDLER_CAN_RONLY));
    init_PrivateMIBNodeRootOIDbySwitchBoardID(sshHostKeyGenStatus_oid);
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("sshHostKeyGenStatus",
                                         get_sshHostKeyGenStatus,
                                         sshHostKeyGenStatus_oid,
                                         OID_LENGTH
                                         (sshHostKeyGenStatus_oid),
                                         HANDLER_CAN_RONLY));
    init_PrivateMIBNodeRootOIDbySwitchBoardID(sshHostKeySaveAction_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("sshHostKeySaveAction",
                               do_sshHostKeySaveAction,
                               sshHostKeySaveAction_oid,
                               OID_LENGTH(sshHostKeySaveAction_oid),
                               HANDLER_CAN_RWRITE));
    init_PrivateMIBNodeRootOIDbySwitchBoardID(sshHostKeySaveStatus_oid);
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("sshHostKeySaveStatus",
                                         get_sshHostKeySaveStatus,
                                         sshHostKeySaveStatus_oid,
                                         OID_LENGTH
                                         (sshHostKeySaveStatus_oid),
                                         HANDLER_CAN_RONLY));
    init_PrivateMIBNodeRootOIDbySwitchBoardID(sshKeySize_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("sshKeySize", do_sshKeySize, sshKeySize_oid,
                               OID_LENGTH(sshKeySize_oid),
                               HANDLER_CAN_RWRITE));
    init_PrivateMIBNodeRootOIDbySwitchBoardID(sshHostKeyDelAction_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("sshHostKeyDelAction",
                               do_sshHostKeyDelAction,
                               sshHostKeyDelAction_oid,
                               OID_LENGTH(sshHostKeyDelAction_oid),
                               HANDLER_CAN_RWRITE));
    #if 0
        init_PrivateMIBNodeRootOIDbySwitchBoardID(sshRsaHostKeySHA1FingerPrint_oid);
        netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("sshRsaHostKeySHA1FingerPrint",
                                         get_sshRsaHostKeySHA1FingerPrint,
                                         sshRsaHostKeySHA1FingerPrint_oid,
                                         OID_LENGTH
                                         (sshRsaHostKeySHA1FingerPrint_oid),
                                         HANDLER_CAN_RONLY));
    init_PrivateMIBNodeRootOIDbySwitchBoardID(sshRsaHostKeyMD5FingerPrint_oid);
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("sshRsaHostKeyMD5FingerPrint",
                                         get_sshRsaHostKeyMD5FingerPrint,
                                         sshRsaHostKeyMD5FingerPrint_oid,
                                         OID_LENGTH
                                         (sshRsaHostKeyMD5FingerPrint_oid),
                                         HANDLER_CAN_RONLY));
    init_PrivateMIBNodeRootOIDbySwitchBoardID(sshDsaHostKeySHA1FingerPrint_oid);
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("sshDsaHostKeySHA1FingerPrint",
                                         get_sshDsaHostKeySHA1FingerPrint,
                                         sshDsaHostKeySHA1FingerPrint_oid,
                                         OID_LENGTH
                                         (sshDsaHostKeySHA1FingerPrint_oid),
                                         HANDLER_CAN_RONLY));
    init_PrivateMIBNodeRootOIDbySwitchBoardID(sshDsaHostKeyMD5FingerPrint_oid);
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("sshDsaHostKeyMD5FingerPrint",
                                         get_sshDsaHostKeyMD5FingerPrint,
                                         sshDsaHostKeyMD5FingerPrint_oid,
                                         OID_LENGTH
                                         (sshDsaHostKeyMD5FingerPrint_oid),
                                         HANDLER_CAN_RONLY));
    #endif
    init_PrivateMIBNodeRootOIDbySwitchBoardID(sshRsaHostKey1_oid);
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("sshRsaHostKey1",
                                         get_sshRsaHostKey1,
                                         sshRsaHostKey1_oid,
                                         OID_LENGTH(sshRsaHostKey1_oid),
                                         HANDLER_CAN_RONLY));
    init_PrivateMIBNodeRootOIDbySwitchBoardID(sshRsaHostKey2_oid);
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("sshRsaHostKey2",
                                         get_sshRsaHostKey2,
                                         sshRsaHostKey2_oid,
                                         OID_LENGTH(sshRsaHostKey2_oid),
                                         HANDLER_CAN_RONLY));
    init_PrivateMIBNodeRootOIDbySwitchBoardID(sshRsaHostKey3_oid);
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("sshRsaHostKey3",
                                         get_sshRsaHostKey3,
                                         sshRsaHostKey3_oid,
                                         OID_LENGTH(sshRsaHostKey3_oid),
                                         HANDLER_CAN_RONLY));
    init_PrivateMIBNodeRootOIDbySwitchBoardID(sshRsaHostKey4_oid);
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("sshRsaHostKey4",
                                         get_sshRsaHostKey4,
                                         sshRsaHostKey4_oid,
                                         OID_LENGTH(sshRsaHostKey4_oid),
                                         HANDLER_CAN_RONLY));
    init_PrivateMIBNodeRootOIDbySwitchBoardID(sshRsaHostKey5_oid);
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("sshRsaHostKey5",
                                         get_sshRsaHostKey5,
                                         sshRsaHostKey5_oid,
                                         OID_LENGTH(sshRsaHostKey5_oid),
                                         HANDLER_CAN_RONLY));
    init_PrivateMIBNodeRootOIDbySwitchBoardID(sshDsaHostKey1_oid);
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("sshDsaHostKey1",
                                         get_sshDsaHostKey1,
                                         sshDsaHostKey1_oid,
                                         OID_LENGTH(sshDsaHostKey1_oid),
                                         HANDLER_CAN_RONLY));
    init_PrivateMIBNodeRootOIDbySwitchBoardID(sshRsaHostKey6_oid);
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("sshRsaHostKey6",
                                         get_sshRsaHostKey6,
                                         sshRsaHostKey6_oid,
                                         OID_LENGTH(sshRsaHostKey6_oid),
                                         HANDLER_CAN_RONLY));
    init_PrivateMIBNodeRootOIDbySwitchBoardID(sshHostKeyGenAction_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("sshHostKeyGenAction",
                               do_sshHostKeyGenAction,
                               sshHostKeyGenAction_oid,
                               OID_LENGTH(sshHostKeyGenAction_oid),
                               HANDLER_CAN_RWRITE));
    init_PrivateMIBNodeRootOIDbySwitchBoardID(sshDsaHostKey2_oid);
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("sshDsaHostKey2",
                                         get_sshDsaHostKey2,
                                         sshDsaHostKey2_oid,
                                         OID_LENGTH(sshDsaHostKey2_oid),
                                         HANDLER_CAN_RONLY));
    init_PrivateMIBNodeRootOIDbySwitchBoardID(sshRsaHostKey7_oid);
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("sshRsaHostKey7",
                                         get_sshRsaHostKey7,
                                         sshRsaHostKey7_oid,
                                         OID_LENGTH(sshRsaHostKey7_oid),
                                         HANDLER_CAN_RONLY));
    init_PrivateMIBNodeRootOIDbySwitchBoardID(sshRsaHostKey8_oid);
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("sshRsaHostKey8",
                                         get_sshRsaHostKey8,
                                         sshRsaHostKey8_oid,
                                         OID_LENGTH(sshRsaHostKey8_oid),
                                         HANDLER_CAN_RONLY));
    init_PrivateMIBNodeRootOIDbySwitchBoardID(sshDsaHostKey3_oid);
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("sshDsaHostKey3",
                                         get_sshDsaHostKey3,
                                         sshDsaHostKey3_oid,
                                         OID_LENGTH(sshDsaHostKey3_oid),
                                         HANDLER_CAN_RONLY));
    init_PrivateMIBNodeRootOIDbySwitchBoardID(sshDsaHostKey4_oid);
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("sshDsaHostKey4",
                                         get_sshDsaHostKey4,
                                         sshDsaHostKey4_oid,
                                         OID_LENGTH(sshDsaHostKey4_oid),
                                         HANDLER_CAN_RONLY));
#endif /*end of #if (SYS_CPNT_SSH2 == TRUE)*/
}



/********************************************
 **************sshConnInfoTable**************
 ********************************************
 */

oid             sshConnInfoTable_variables_oid[] =
    { SYS_ADPT_PRIVATEMIB_OID, 1, 17, 6};

struct variable3 sshConnInfoTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    {SSHCONNID, ASN_INTEGER, RONLY, var_sshConnInfoTable, 3, {6, 1, 1}},
#endif
    {SSHCONNMAJORVERSION, ASN_INTEGER, RONLY, var_sshConnInfoTable, 3,
     {6, 1, 2}},
    {SSHCONNMINORVERSION, ASN_INTEGER, RONLY, var_sshConnInfoTable, 3,
     {6, 1, 3}},
#if (SYS_CPNT_SSHD == TRUE)
    {SSHCONNENCRYPTIONTYPE, ASN_INTEGER, RONLY, var_sshConnInfoTable, 3,
     {6, 1, 4}},
#endif
    {SSHCONNSTATUS, ASN_INTEGER, RONLY, var_sshConnInfoTable, 3,
     {6, 1, 5}},
    {SSHCONNUSERNAME, ASN_OCTET_STR, RONLY, var_sshConnInfoTable, 3,
     {6, 1, 6}},
    {SSHDISCONNECT, ASN_INTEGER, RWRITE, var_sshConnInfoTable, 3,
     {6, 1, 7}},
#if (SYS_CPNT_SSH2 == TRUE)
    {SSHCONNENCRYPTIONTYPESTR, ASN_OCTET_STR, RONLY, var_sshConnInfoTable,
     3, {6, 1, 8}},
#endif
};

/** Initializes the sshConnInfoTable module */
void
init_sshConnInfoTable(void)
{
    /* register ourselves with the agent to handle our mib tree */
    init_PrivateMIBNodeRootOIDbySwitchBoardID(sshConnInfoTable_variables_oid);
    REGISTER_MIB("sshConnInfoTable", sshConnInfoTable_variables, variable3,
                 sshConnInfoTable_variables_oid);
}



/********************************************
 **************sshUserTable******************
 ********************************************
 */
oid             sshUserTable_variables_oid[] =
    { SYS_ADPT_PRIVATEMIB_OID, 1, 17, 6 };

struct variable3 sshUserTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    {SSHUSERNAME, ASN_OCTET_STR, RONLY, var_sshUserTable, 3, {29, 1, 1}},
#endif
    {SSHUSERRSAKEY1, ASN_OCTET_STR, RONLY, var_sshUserTable, 3,
     {29, 1, 2}},
    {SSHUSERRSAKEY2, ASN_OCTET_STR, RONLY, var_sshUserTable, 3,
     {29, 1, 3}},
    {SSHUSERRSAKEY3, ASN_OCTET_STR, RONLY, var_sshUserTable, 3,
     {29, 1, 4}},
    {SSHUSERRSAKEY4, ASN_OCTET_STR, RONLY, var_sshUserTable, 3,
     {29, 1, 5}},
    {SSHUSERRSAKEY5, ASN_OCTET_STR, RONLY, var_sshUserTable, 3,
     {29, 1, 6}},
    {SSHUSERRSAKEY6, ASN_OCTET_STR, RONLY, var_sshUserTable, 3,
     {29, 1, 7}},
    {SSHUSERRSAKEY7, ASN_OCTET_STR, RONLY, var_sshUserTable, 3,
     {29, 1, 8}},
    {SSHUSERRSAKEY8, ASN_OCTET_STR, RONLY, var_sshUserTable, 3,
     {29, 1, 9}},
    {SSHUSERDSAKEY1, ASN_OCTET_STR, RONLY, var_sshUserTable, 3,
     {29, 1, 10}},
    {SSHUSERDSAKEY2, ASN_OCTET_STR, RONLY, var_sshUserTable, 3,
     {29, 1, 11}},
    {SSHUSERDSAKEY3, ASN_OCTET_STR, RONLY, var_sshUserTable, 3,
     {29, 1, 12}},
    {SSHUSERDSAKEY4, ASN_OCTET_STR, RONLY, var_sshUserTable, 3,
     {29, 1, 13}},
    {SSHUSERDSAKEY5, ASN_OCTET_STR, RONLY, var_sshUserTable, 3,
     {29, 1, 14}},
    {SSHUSERDSAKEY6, ASN_OCTET_STR, RONLY, var_sshUserTable, 3,
     {29, 1, 15}},
    {SSHUSERDSAKEY7, ASN_OCTET_STR, RONLY, var_sshUserTable, 3,
     {29, 1, 16}},
    {SSHUSERDSAKEY8, ASN_OCTET_STR, RONLY, var_sshUserTable, 3,
     {29, 1, 17}},
    {SSHUSERKEYDELACTION, ASN_INTEGER, RWRITE, var_sshUserTable, 3,
     {29, 1, 18}},
};

/** Initializes the sshUserTable module */
void
init_sshUserTable(void)
{
    /* register ourselves with the agent to handle our mib tree */
    init_PrivateMIBNodeRootOIDbySwitchBoardID(sshUserTable_variables_oid);
    REGISTER_MIB("sshUserTable", sshUserTable_variables, variable3,
                 sshUserTable_variables_oid);
}
#endif


#if ((SYS_CPNT_ACL == TRUE) && (SYS_CPNT_QOS_V2 == TRUE))
void
init_aclMgt(void)
{
    static oid      aclAttachCtlIndex_oid[] =
        { SYS_ADPT_PRIVATEMIB_OID, 1, 17, 7, 13, 1, 0 };
    static oid      aclAttachCtlAceType_oid[] =
        { SYS_ADPT_PRIVATEMIB_OID, 1, 17, 7, 13, 2, 0 };
    static oid      aclAttachCtlAceIndex_oid[] =
        { SYS_ADPT_PRIVATEMIB_OID, 1, 17, 7, 13, 3, 0 };
    static oid      aclAttachCtlAction_oid[] =
        { SYS_ADPT_PRIVATEMIB_OID, 1, 17, 7, 13, 4, 0 };

    DEBUGMSGTL(("aclMgt", "Initializing\n"));

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("aclAttachCtlIndex",
                               do_aclAttachCtlIndex,
                               aclAttachCtlIndex_oid,
                               OID_LENGTH(aclAttachCtlIndex_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("aclAttachCtlAceType",
                               do_aclAttachCtlAceType,
                               aclAttachCtlAceType_oid,
                               OID_LENGTH(aclAttachCtlAceType_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("aclAttachCtlAceIndex",
                               do_aclAttachCtlAceIndex,
                               aclAttachCtlAceIndex_oid,
                               OID_LENGTH(aclAttachCtlAceIndex_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("aclAttachCtlAction",
                               do_aclAttachCtlAction,
                               aclAttachCtlAction_oid,
                               OID_LENGTH(aclAttachCtlAction_oid),
                               HANDLER_CAN_RWRITE));
}

/********************************************
 **************aclIpAceTable****************
 ********************************************
 */
oid   aclIpAceTable_variables_oid[] =
    { SYS_ADPT_PRIVATEMIB_OID, 1, 17, 7 };

struct variable3 aclIpAceTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    {ACLIPACENAME, ASN_OCTET_STR, RONLY, var_aclIpAceTable, 3, {1, 1, 1}},
    {ACLIPACEINDEX, ASN_INTEGER, RONLY, var_aclIpAceTable, 3, {1, 1, 2}},
#endif
    {ACLIPACEPRECEDENCE, ASN_INTEGER, RONLY, var_aclIpAceTable, 3,
    {1, 1, 3}},
    {ACLIPACEACTION, ASN_INTEGER, RWRITE, var_aclIpAceTable, 3, {1, 1, 4}},
    {ACLIPACESOURCEIPADDR, ASN_IPADDRESS, RWRITE, var_aclIpAceTable, 3,
     {1, 1, 5}},
    {ACLIPACESOURCEIPADDRBITMASK, ASN_IPADDRESS, RWRITE, var_aclIpAceTable,
     3, {1, 1, 6}},
    {ACLIPACEDESTIPADDR, ASN_IPADDRESS, RWRITE, var_aclIpAceTable, 3,
     {1, 1, 7}},
    {ACLIPACEDESTIPADDRBITMASK, ASN_IPADDRESS, RWRITE, var_aclIpAceTable,
     3, {1, 1, 8}},
    {ACLIPACEPROTOCOL, ASN_INTEGER, RWRITE, var_aclIpAceTable, 3,
     {1, 1, 9}},
    {ACLIPACEPREC, ASN_INTEGER, RWRITE, var_aclIpAceTable, 3, {1, 1, 10}},
    {ACLIPACETOS, ASN_INTEGER, RWRITE, var_aclIpAceTable, 3, {1, 1, 11}},
    {ACLIPACEDSCP, ASN_INTEGER, RWRITE, var_aclIpAceTable, 3, {1, 1, 12}},
    {ACLIPACESOURCEPORTOP, ASN_INTEGER, RWRITE, var_aclIpAceTable, 3,
     {1, 1, 13}},
    {ACLIPACEMINSOURCEPORT, ASN_INTEGER, RWRITE, var_aclIpAceTable, 3,
     {1, 1, 14}},
    {ACLIPACEMAXSOURCEPORT, ASN_INTEGER, RWRITE, var_aclIpAceTable, 3,
     {1, 1, 15}},
    {ACLIPACESOURCEPORTBITMASK, ASN_INTEGER, RWRITE, var_aclIpAceTable, 3,
     {1, 1, 16}},
    {ACLIPACEDESTPORTOP, ASN_INTEGER, RWRITE, var_aclIpAceTable, 3,
     {1, 1, 17}},
    {ACLIPACEMINDESTPORT, ASN_INTEGER, RWRITE, var_aclIpAceTable, 3,
     {1, 1, 18}},
    {ACLIPACEMAXDESTPORT, ASN_INTEGER, RWRITE, var_aclIpAceTable, 3,
     {1, 1, 19}},
    {ACLIPACEDESTPORTBITMASK, ASN_INTEGER, RWRITE, var_aclIpAceTable, 3,
     {1, 1, 20}},
    {ACLIPACECONTROLCODE, ASN_INTEGER, RWRITE, var_aclIpAceTable, 3,
     {1, 1, 21}},
    {ACLIPACECONTROLCODEBITMASK, ASN_INTEGER, RWRITE, var_aclIpAceTable, 3,
     {1, 1, 22}},
    {ACLIPACESTATUS, ASN_INTEGER, RWRITE, var_aclIpAceTable, 3,
     {1, 1, 23}},
};

/** Initializes the aclIpAceTable module */
void
init_aclIpAceTable(void)
{
    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("aclIpAceTable", aclIpAceTable_variables, variable3,
                 aclIpAceTable_variables_oid);
}

/********************************************
 **************aclMacAceTable****************
 ********************************************
 */
oid             aclMacAceTable_variables_oid[] =
    { SYS_ADPT_PRIVATEMIB_OID, 1, 17, 7 };


struct variable3 aclMacAceTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    {ACLMACACENAME, ASN_OCTET_STR, RONLY, var_aclMacAceTable, 3,
     {2, 1, 1}},
    {ACLMACACEINDEX, ASN_INTEGER, RONLY, var_aclMacAceTable, 3, {2, 1, 2}},
#endif
#if 0
    {ACLMACACEPRECEDENCE, ASN_INTEGER, RONLY, var_aclMacAceTable, 3,
     {2, 1, 3}},
    {ACLMACACEACTION, ASN_INTEGER, RWRITE, var_aclMacAceTable, 3,
     {2, 1, 4}},
#endif
    {ACLMACACEPKTFORMAT, ASN_INTEGER, RWRITE, var_aclMacAceTable, 3,
     {2, 1, 5}},
    {ACLMACACESOURCEMACADDR, ASN_OCTET_STR, RWRITE, var_aclMacAceTable, 3,
     {2, 1, 6}},
    {ACLMACACESOURCEMACADDRBITMASK, ASN_OCTET_STR, RWRITE,
     var_aclMacAceTable, 3, {2, 1, 7}},
    {ACLMACACEDESTMACADDR, ASN_OCTET_STR, RWRITE, var_aclMacAceTable, 3,
     {2, 1, 8}},
    {ACLMACACEDESTMACADDRBITMASK, ASN_OCTET_STR, RWRITE,
     var_aclMacAceTable, 3, {2, 1, 9}},
    {ACLMACACEVIDOP, ASN_INTEGER, RWRITE, var_aclMacAceTable, 3,
     {2, 1, 10}},
    {ACLMACACEMINVID, ASN_INTEGER, RWRITE, var_aclMacAceTable, 3,
     {2, 1, 11}},
    {ACLMACACEVIDBITMASK, ASN_INTEGER, RWRITE, var_aclMacAceTable, 3,
     {2, 1, 12}},
    {ACLMACACEMAXVID, ASN_INTEGER, RWRITE, var_aclMacAceTable, 3,
     {2, 1, 13}},
    {ACLMACACEETHERTYPEOP, ASN_INTEGER, RWRITE, var_aclMacAceTable, 3,
     {2, 1, 14}},
    {ACLMACACEETHERTYPEBITMASK, ASN_INTEGER, RWRITE, var_aclMacAceTable, 3,
     {2, 1, 15}},
    {ACLMACACEMINETHERTYPE, ASN_INTEGER, RWRITE, var_aclMacAceTable, 3,
     {2, 1, 16}},
    {ACLMACACEMAXETHERTYPE, ASN_INTEGER, RWRITE, var_aclMacAceTable, 3,
     {2, 1, 17}},
    {ACLMACACESTATUS, ASN_INTEGER, RWRITE, var_aclMacAceTable, 3,
     {2, 1, 18}},
};

/** Initializes the aclMacAceTable module */
void
init_aclMacAceTable(void)
{
    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("aclMacAceTable", aclMacAceTable_variables, variable3,
                 aclMacAceTable_variables_oid);
}

/********************************************
 **************aclAclGroupTable**************
 ********************************************
 */
oid             aclAclGroupTable_variables_oid[] =
    { SYS_ADPT_PRIVATEMIB_OID, 1, 17, 7 };

struct variable3 aclAclGroupTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    {ACLACLGROUPIFINDEX, ASN_INTEGER, RONLY, var_aclAclGroupTable, 3,
     {3, 1, 1}},
#endif
    {ACLACLGROUPINGRESSIPACL, ASN_OCTET_STR, RWRITE, var_aclAclGroupTable,
     3, {3, 1, 2}},
    {ACLACLGROUPEGRESSIPACL, ASN_OCTET_STR, RWRITE, var_aclAclGroupTable,
     3, {3, 1, 3}},
    {ACLACLGROUPINGRESSMACACL, ASN_OCTET_STR, RWRITE, var_aclAclGroupTable,
     3, {3, 1, 4}},
    {ACLACLGROUPEGRESSMACACL, ASN_OCTET_STR, RWRITE, var_aclAclGroupTable,
     3, {3, 1, 5}},
};

/** Initializes the aclAclGroupTable module */
void
init_aclAclGroupTable(void)
{
    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("aclAclGroupTable", aclAclGroupTable_variables, variable3,
                 aclAclGroupTable_variables_oid);
}

#endif

#if ((SYS_CPNT_ACL == TRUE) && (SYS_CPNT_QOS_V2 != TRUE))
/********************************************
 *************aclIngressIpMaskTable**********
 ********************************************
 */
oid             aclIngressIpMaskTable_variables_oid[] =
    { SYS_ADPT_PRIVATEMIB_OID, 1, 17, 7};

struct variable3 aclIngressIpMaskTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    {ACLINGRESSIPMASKINDEX, ASN_INTEGER, RONLY, var_aclIngressIpMaskTable,
     3, {4, 1, 1}},
#endif
    {ACLINGRESSIPMASKPRECEDENCE, ASN_INTEGER, RONLY,
     var_aclIngressIpMaskTable, 3, {4, 1, 2}},
    {ACLINGRESSIPMASKISENABLETOS, ASN_INTEGER, RWRITE,
     var_aclIngressIpMaskTable, 3, {4, 1, 3}},
    {ACLINGRESSIPMASKISENABLEDSCP, ASN_INTEGER, RWRITE,
     var_aclIngressIpMaskTable, 3, {4, 1, 4}},
    {ACLINGRESSIPMASKISENABLEPRECEDENCE, ASN_INTEGER, RWRITE,
     var_aclIngressIpMaskTable, 3, {4, 1, 5}},
    {ACLINGRESSIPMASKISENABLEPROTOCOL, ASN_INTEGER, RWRITE,
     var_aclIngressIpMaskTable, 3, {4, 1, 6}},
    {ACLINGRESSIPMASKSOURCEIPADDRBITMASK, ASN_UNSIGNED, RWRITE,
     var_aclIngressIpMaskTable, 3, {4, 1, 7}},
    {ACLINGRESSIPMASKDESTIPADDRBITMASK, ASN_UNSIGNED, RWRITE,
     var_aclIngressIpMaskTable, 3, {4, 1, 8}},
    {ACLINGRESSIPMASKSOURCEPORTBITMASK, ASN_INTEGER, RWRITE,
     var_aclIngressIpMaskTable, 3, {4, 1, 9}},
    {ACLINGRESSIPMASKDESTPORTBITMASK, ASN_INTEGER, RWRITE,
     var_aclIngressIpMaskTable, 3, {4, 1, 10}},
    {ACLINGRESSIPMASKCONTROLCODEBITMASK, ASN_INTEGER, RWRITE,
     var_aclIngressIpMaskTable, 3, {4, 1, 11}},
    {ACLINGRESSIPMASKSTATUS, ASN_INTEGER, RWRITE,
     var_aclIngressIpMaskTable, 3, {4, 1, 12}},
};

/** Initializes the aclIngressIpMaskTable module */
void
init_aclIngressIpMaskTable(void)
{
    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("aclIngressIpMaskTable", aclIngressIpMaskTable_variables,
                 variable3, aclIngressIpMaskTable_variables_oid);
}



/********************************************
 ************aclEgressIpMaskTable************
 ********************************************
 */
oid             aclEgressIpMaskTable_variables_oid[] =
    { SYS_ADPT_PRIVATEMIB_OID, 1, 17, 7 };

struct variable3 aclEgressIpMaskTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)

    {ACLEGRESSIPMASKINDEX, ASN_INTEGER, RONLY, var_aclEgressIpMaskTable, 3,
     {5, 1, 1}},
#endif
    {ACLEGRESSIPMASKPRECEDENCE, ASN_INTEGER, RONLY,
     var_aclEgressIpMaskTable, 3, {5, 1, 2}},
    {ACLEGRESSIPMASKISENABLETOS, ASN_INTEGER, RWRITE,
     var_aclEgressIpMaskTable, 3, {5, 1, 3}},
    {ACLEGRESSIPMASKISENABLEDSCP, ASN_INTEGER, RWRITE,
     var_aclEgressIpMaskTable, 3, {5, 1, 4}},
    {ACLEGRESSIPMASKISENABLEPRECEDENCE, ASN_INTEGER, RWRITE,
     var_aclEgressIpMaskTable, 3, {5, 1, 5}},
    {ACLEGRESSIPMASKISENABLEPROTOCOL, ASN_INTEGER, RWRITE,
     var_aclEgressIpMaskTable, 3, {5, 1, 6}},
    {ACLEGRESSIPMASKSOURCEIPADDRBITMASK, ASN_UNSIGNED, RWRITE,
     var_aclEgressIpMaskTable, 3, {5, 1, 7}},
    {ACLEGRESSIPMASKDESTIPADDRBITMASK, ASN_UNSIGNED, RWRITE,
     var_aclEgressIpMaskTable, 3, {5, 1, 8}},
    {ACLEGRESSIPMASKSOURCEPORTBITMASK, ASN_INTEGER, RWRITE,
     var_aclEgressIpMaskTable, 3, {5, 1, 9}},
    {ACLEGRESSIPMASKDESTPORTBITMASK, ASN_INTEGER, RWRITE,
     var_aclEgressIpMaskTable, 3, {5, 1, 10}},
    {ACLEGRESSIPMASKCONTROLCODEBITMASK, ASN_INTEGER, RWRITE,
     var_aclEgressIpMaskTable, 3, {5, 1, 11}},
    {ACLEGRESSIPMASKSTATUS, ASN_INTEGER, RWRITE, var_aclEgressIpMaskTable,
     3, {5, 1, 12}},
};

/** Initializes the aclEgressIpMaskTable module */
void
init_aclEgressIpMaskTable(void)
{
    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("aclEgressIpMaskTable", aclEgressIpMaskTable_variables,
                 variable3, aclEgressIpMaskTable_variables_oid);
}



/********************************************
 ************aclIngressMacMaskTable**********
 ********************************************
 */
oid  aclIngressMacMaskTable_variables_oid[] =
    {SYS_ADPT_PRIVATEMIB_OID, 1, 17, 7 };

struct variable3 aclIngressMacMaskTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    {ACLINGRESSMACMASKINDEX, ASN_INTEGER, RONLY,
     var_aclIngressMacMaskTable, 3, {6, 1, 1}},
#endif
    {ACLINGRESSMACMASKPRECEDENCE, ASN_INTEGER, RONLY,
     var_aclIngressMacMaskTable, 3, {6, 1, 2}},
    {ACLINGRESSMACMASKSOURCEMACADDRBITMASK, ASN_OCTET_STR, RWRITE,
     var_aclIngressMacMaskTable, 3, {6, 1, 3}},
    {ACLINGRESSMACMASKDESTMACADDRBITMASK, ASN_OCTET_STR, RWRITE,
     var_aclIngressMacMaskTable, 3, {6, 1, 4}},
    {ACLINGRESSMACMASKVIDBITMASK, ASN_INTEGER, RWRITE,
     var_aclIngressMacMaskTable, 3, {6, 1, 5}},
    {ACLINGRESSMACMASKETHERTYPEBITMASK, ASN_INTEGER, RWRITE,
     var_aclIngressMacMaskTable, 3, {6, 1, 6}},
    {ACLINGRESSMACMASKISENABLEPKTFORMAT, ASN_INTEGER, RWRITE,
     var_aclIngressMacMaskTable, 3, {6, 1, 7}},
    {ACLINGRESSMACMASKSTATUS, ASN_INTEGER, RWRITE,
     var_aclIngressMacMaskTable, 3, {6, 1, 8}},
};

/** Initializes the  module */
void
init_aclIngressMacMaskTable(void)
{
    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("",
                 aclIngressMacMaskTable_variables, variable3,
                 aclIngressMacMaskTable_variables_oid);
}



/********************************************
 ************aclEgressMacMaskTable***********
 ********************************************
 */
oid             aclEgressMacMaskTable_variables_oid[] =
    { SYS_ADPT_PRIVATEMIB_OID, 1, 17, 7 };

struct variable3 aclEgressMacMaskTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)

    {ACLEGRESSMACMASKINDEX, ASN_INTEGER, RONLY, var_aclEgressMacMaskTable,
     3, {7, 1, 1}},
#endif
    {ACLEGRESSMACMASKPRECEDENCE, ASN_INTEGER, RONLY,
     var_aclEgressMacMaskTable, 3, {7, 1, 2}},
    {ACLEGRESSMACMASKSOURCEMACADDRBITMASK, ASN_OCTET_STR, RWRITE,
     var_aclEgressMacMaskTable, 3, {7, 1, 3}},
    {ACLEGRESSMACMASKDESTMACADDRBITMASK, ASN_OCTET_STR, RWRITE,
     var_aclEgressMacMaskTable, 3, {7, 1, 4}},
    {ACLEGRESSMACMASKVIDBITMASK, ASN_INTEGER, RWRITE,
     var_aclEgressMacMaskTable, 3, {7, 1, 5}},
    {ACLEGRESSMACMASKETHERTYPEBITMASK, ASN_INTEGER, RWRITE,
     var_aclEgressMacMaskTable, 3, {7, 1, 6}},
    {ACLEGRESSMACMASKISENABLEPKTFORMAT, ASN_INTEGER, RWRITE,
     var_aclEgressMacMaskTable, 3, {7, 1, 7}},
    {ACLEGRESSMACMASKSTATUS, ASN_INTEGER, RWRITE,
     var_aclEgressMacMaskTable, 3, {7, 1, 8}},
};

/** Initializes the aclEgressMacMaskTable module */
void
init_aclEgressMacMaskTable(void)
{
    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("aclEgressMacMaskTable", aclEgressMacMaskTable_variables,
                 variable3, aclEgressMacMaskTable_variables_oid);
}
#endif

#if ((SYS_CPNT_ACL == TRUE) && (SYS_CPNT_QOS_V2 == TRUE))

/********************************************
 *******************aclTable**************
 ********************************************
 */
oid             aclTable_variables_oid[] =
    { SYS_ADPT_PRIVATEMIB_OID, 1, 17, 7};

struct variable3 aclTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)

    {ACLINDEX, ASN_INTEGER, RONLY, var_aclTable, 3, {14, 1, 1}},
#endif
    {ACLNAME, ASN_OCTET_STR, RWRITE, var_aclTable, 3, {14, 1, 2}},
    {ACLTYPE, ASN_INTEGER, RWRITE, var_aclTable, 3, {14, 1, 3}},
    {ACLACEINDEXLIST, ASN_OCTET_STR, RONLY, var_aclTable, 3, {14, 1, 4}},
    {ACLSTATUS, ASN_INTEGER, RWRITE, var_aclTable, 3, {14, 1, 5}},
};

/** Initializes the aclTable module */
void
init_aclTable(void)
{
    /*
     * register ourselves with the agent to handle our mib tree
     */
    REGISTER_MIB("aclTable", aclTable_variables, variable3,
                 aclTable_variables_oid);
}

#if (SYS_CPNT_ACL_IPV6 == TRUE)
oid             aclIpv6AceTable_variables_oid[] =
    { SYS_ADPT_PRIVATEMIB_OID, 1, 17, 7 };

/*
 * variable3 diffServIpv6AceTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */

struct variable3 aclIpv6AceTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */

    {ACLIPV6ACEINDEX, ASN_INTEGER, RONLY, var_aclIpv6AceTable, 3,
     {12, 1, 1}},
    {ACLIPV6ACETYPE, ASN_INTEGER, RWRITE, var_aclIpv6AceTable,
     3, {12, 1, 2}},
    {ACLIPV6ACEACCESS, ASN_INTEGER, RWRITE, var_aclIpv6AceTable,
     3, {12, 1, 3}},
    {ACLIPV6ACESOURCEIPADDR, ASN_OCTET_STR, RWRITE,
     var_aclIpv6AceTable, 3, {12, 1, 4}},
    {ACLIPV6ACESOURCEIPADDRPREFIXLEN, ASN_INTEGER, RWRITE,
     var_aclIpv6AceTable, 3, {12, 1, 5}},
    {ACLIPV6ACEDESTIPADDR, ASN_OCTET_STR, RWRITE,
     var_aclIpv6AceTable, 3, {12, 1, 6}},
    {ACLIPV6ACEDESTIPADDRPREFIXLEN, ASN_INTEGER, RWRITE,
     var_aclIpv6AceTable, 3, {12, 1, 7}},

#if (SYS_CPNT_ACL_IPV6_NEXT_HEADER == TRUE)
    {ACLIPV6ACENEXTHEADER, ASN_INTEGER, RWRITE,
     var_aclIpv6AceTable, 3, {12, 1, 8}},
#endif

    {ACLIPV6ACEDSCP, ASN_INTEGER, RWRITE, var_aclIpv6AceTable, 3,
     {12, 1, 9}},

#if (SYS_CPNT_ACL_IPV6_FLOW_LABEL == TRUE)
    {ACLIPV6ACEFLOWLABEL, ASN_INTEGER, RWRITE,
     var_aclIpv6AceTable, 3, {12, 1, 10}},
#endif

    {ACLIPV6ACESTATUS, ASN_INTEGER, RWRITE, var_aclIpv6AceTable,
     3, {12, 1, 11}},
};


/** Initializes the aclIpv6AceTable module */
void
init_aclIpv6AceTable(void)
{
#if 0
    DEBUGMSGTL(("aclIpv6AceTable", "Initializing\n"));

    REGISTER_MIB("aclIpv6AceTable", aclIpv6AceTable_variables,
                 variable3, aclIpv6AceTable_variables_oid);
#endif /* #if 0 */
}
#endif /* end of #if (SYS_CPNT_ACL_IPV6 == TRUE) */
#endif /* end of #if ((SYS_CPNT_ACL == TRUE) && (SYS_CPNT_QOS_V2 == TRUE))*/

/********************************************
 ************ipFilterSnmpTable***************
 ********************************************
 */
#if (SYS_CPNT_MGMT_IP_FLT == TRUE)

#if (SYS_CPNT_IPV6 != TRUE)
oid             ipFilterSnmpTable_variables_oid[] =
    { SYS_ADPT_PRIVATEMIB_OID, 1, 17, 9 };

struct variable3 ipFilterSnmpTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    {IPFILTERSNMPSTARTADDRESS, ASN_IPADDRESS, RONLY, var_ipFilterSnmpTable,
     3, {1, 1, 1}},
#endif
    {IPFILTERSNMPENDADDRESS, ASN_IPADDRESS, RWRITE, var_ipFilterSnmpTable,
     3, {1, 1, 2}},
    {IPFILTERSNMPSTATUS, ASN_INTEGER, RWRITE, var_ipFilterSnmpTable, 3,
     {1, 1, 3}},
};

/** Initializes the ipFilterSnmpTable module */
void
init_ipFilterSnmpTable(void)
{

    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("ipFilterSnmpTable", ipFilterSnmpTable_variables,
                 variable3, ipFilterSnmpTable_variables_oid);
}



/********************************************
 ************ipFilterHTTPTable***************
 ********************************************
 */
oid             ipFilterHTTPTable_variables_oid[] =
    { SYS_ADPT_PRIVATEMIB_OID, 1, 17, 9 };

struct variable3 ipFilterHTTPTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    {IPFILTERHTTPSTARTADDRESS, ASN_IPADDRESS, RONLY, var_ipFilterHTTPTable,
     3, {2, 1, 1}},
#endif
    {IPFILTERHTTPENDADDRESS, ASN_IPADDRESS, RWRITE, var_ipFilterHTTPTable,
     3, {2, 1, 2}},
    {IPFILTERHTTPSTATUS, ASN_INTEGER, RWRITE, var_ipFilterHTTPTable, 3,
     {2, 1, 3}},
};

/** Initializes the ipFilterHTTPTable module */
void
init_ipFilterHTTPTable(void)
{
    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("ipFilterHTTPTable", ipFilterHTTPTable_variables,
                 variable3, ipFilterHTTPTable_variables_oid);
}



/********************************************
 **********ipFilterTelnetTable***************
 ********************************************
 */
oid ipFilterTelnetTable_variables_oid[] =
    { SYS_ADPT_PRIVATEMIB_OID, 1, 17, 9 };

struct variable3 ipFilterTelnetTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    {IPFILTERTELNETSTARTADDRESS, ASN_IPADDRESS, RONLY,
     var_ipFilterTelnetTable, 3, {3, 1, 1}},
#endif
    {IPFILTERTELNETENDADDRESS, ASN_IPADDRESS, RWRITE,
     var_ipFilterTelnetTable, 3, {3, 1, 2}},
    {IPFILTERTELNETSTATUS, ASN_INTEGER, RWRITE, var_ipFilterTelnetTable, 3,
     {3, 1, 3}},
};

/** Initializes the ipFilterTelnetTable module */
void
init_ipFilterTelnetTable(void)
{
    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("ipFilterTelnetTable", ipFilterTelnetTable_variables,
                 variable3, ipFilterTelnetTable_variables_oid);
}

#else /* else #if (SYS_CPNT_IPV6 != TRUE) */

/********************************************
 *********ipFilterSnmpInetTable**************
 ********************************************
 */
oid ipFilterSnmpInetTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,17,9 };

struct variable3 ipFilterSnmpInetTable_variables[] = {

#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
{LEAF_ipFilterSnmpInetAddressType,  ASN_INTEGER,  RONLY,   var_ipFilterSnmpInetTable, 3,  { 12, 1, 1 }},
#endif

#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
{LEAF_ipFilterSnmpInetAddressStart,  ASN_OCTET_STR,  RONLY,   var_ipFilterSnmpInetTable, 3,  { 12, 1, 2 }},
#endif

{LEAF_ipFilterSnmpInetAddressEnd,  ASN_OCTET_STR,  RWRITE,  var_ipFilterSnmpInetTable, 3,  { 12, 1, 3 }},
{LEAF_ipFilterSnmpInetStatus,  ASN_INTEGER,  RWRITE,  var_ipFilterSnmpInetTable, 3,  { 12, 1, 4 }},
};

/** Initializes the ipFilterSnmpInetTable module */
void
init_ipFilterSnmpInetTable(void)
{
    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("ipFilterSnmpInetTable", ipFilterSnmpInetTable_variables, variable3,
                 ipFilterSnmpInetTable_variables_oid);
}

/********************************************
 *********ipFilterHttpInetTable**************
 ********************************************
 */
oid ipFilterHttpInetTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,17,9 };

struct variable3 ipFilterHttpInetTable_variables[] = {

#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
{LEAF_ipFilterHttpInetAddressType,  ASN_INTEGER,  RONLY,   var_ipFilterHttpInetTable, 3,  { 13, 1, 1 }},
#endif

#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
{LEAF_ipFilterHttpInetAddressStart,  ASN_OCTET_STR,  RONLY,   var_ipFilterHttpInetTable, 3,  { 13, 1, 2 }},
#endif

{LEAF_ipFilterHttpInetAddressEnd,  ASN_OCTET_STR,  RWRITE,  var_ipFilterHttpInetTable, 3,  { 13, 1, 3 }},
{LEAF_ipFilterHttpInetStatus,  ASN_INTEGER,  RWRITE,  var_ipFilterHttpInetTable, 3,  { 13, 1, 4 }},
};

/** Initializes the ipFilterHttpInetTable module */
void
init_ipFilterHttpInetTable(void)
{
    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("ipFilterHttpInetTable", ipFilterHttpInetTable_variables, variable3,
                 ipFilterHttpInetTable_variables_oid);
}

/********************************************
 *********ipFilterHttpInetTable**************
 ********************************************
 */
oid ipFilterTelnetInetTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,17,9 };

struct variable3 ipFilterTelnetInetTable_variables[] = {

#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
{LEAF_ipFilterTelnetInetAddressType,  ASN_INTEGER,  RONLY,   var_ipFilterTelnetInetTable, 3,  { 14, 1, 1 }},
#endif

#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
{LEAF_ipFilterTelnetInetAddressStart,  ASN_OCTET_STR,  RONLY,   var_ipFilterTelnetInetTable, 3,  { 14, 1, 2 }},
#endif

{LEAF_ipFilterTelnetInetAddressEnd,  ASN_OCTET_STR,  RWRITE,  var_ipFilterTelnetInetTable, 3,  { 14, 1, 3 }},
{LEAF_ipFilterTelnetInetStatus,  ASN_INTEGER,  RWRITE,  var_ipFilterTelnetInetTable, 3,  { 14, 1, 4 }},
};

/** Initializes the ipFilterTelnetInetTable module */
void
init_ipFilterTelnetInetTable(void)
{
    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("ipFilterTelnetInetTable", ipFilterTelnetInetTable_variables, variable3,
                 ipFilterTelnetInetTable_variables_oid);
}
#endif /* #if (SYS_CPNT_IPV6 != TRUE) */

void init_ipFilterAllClientCtl(void)
{
    static oid ipFilterAllClientCtlInetAddressType_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,17,9,15,1,0 };
    static oid ipFilterAllClientCtlInetAddressStart_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,17,9,15,2,0 };
    static oid ipFilterAllClientCtlInetAddressEnd_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,17,9,15,3,0 };
    static oid ipFilterAllClientCtlAction_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,17,9,15,4,0 };

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("ipFilterAllClientCtlInetAddressType",
                               do_ipFilterAllClientCtlInetAddressType,
                               ipFilterAllClientCtlInetAddressType_oid,
                               OID_LENGTH(ipFilterAllClientCtlInetAddressType_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("ipFilterAllClientCtlInetAddressStart",
                               do_ipFilterAllClientCtlInetAddressStart,
                               ipFilterAllClientCtlInetAddressStart_oid,
                               OID_LENGTH(ipFilterAllClientCtlInetAddressStart_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("ipFilterAllClientCtlInetAddressEnd",
                               do_ipFilterAllClientCtlInetAddressEnd,
                               ipFilterAllClientCtlInetAddressEnd_oid,
                               OID_LENGTH(ipFilterAllClientCtlInetAddressEnd_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("ipFilterAllClientCtlAction",
                               do_ipFilterAllClientCtlAction,
                               ipFilterAllClientCtlAction_oid,
                               OID_LENGTH(ipFilterAllClientCtlAction_oid),
                               HANDLER_CAN_RWRITE));
}
#endif  /* #if (SYS_CPNT_MGMT_IP_FLT == TRUE) */

#if (SYS_CPNT_ARP == TRUE)
/********************************************
 ******************init_arpMgt***************
 ********************************************
 */
/** Initializes the arpMgt module */
void
init_arpMgt(void)
{
    static oid      arpCacheTimeout_oid[] =
        { SYS_ADPT_PRIVATEMIB_OID, 1, 18, 1, 2, 0 };
    static oid      arpStatRcvRequestPackets_oid[] =
        { SYS_ADPT_PRIVATEMIB_OID, 1, 18, 1, 3, 2, 0 };
    static oid      arpStatSendReplyPackets_oid[] =
        { SYS_ADPT_PRIVATEMIB_OID, 1, 18, 1, 3, 3, 0 };
    static oid      arpStatRcvReplyPackets_oid[] =
        { SYS_ADPT_PRIVATEMIB_OID, 1, 18, 1, 3, 4, 0 };
    static oid      arpStatSendRequestPackets_oid[] =
        { SYS_ADPT_PRIVATEMIB_OID, 1, 18, 1, 3, 1, 0 };
    static oid      arpCacheDeleteAll_oid[] =
        { SYS_ADPT_PRIVATEMIB_OID, 1, 18, 1, 1, 0 };

    init_PrivateMIBNodeRootOIDbySwitchBoardID(arpCacheTimeout_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("arpCacheTimeout",
                               do_arpCacheTimeout,
                               arpCacheTimeout_oid,
                               OID_LENGTH(arpCacheTimeout_oid),
                               HANDLER_CAN_RWRITE));
    init_PrivateMIBNodeRootOIDbySwitchBoardID(arpStatRcvRequestPackets_oid);
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("arpStatRcvRequestPackets",
                                         get_arpStatRcvRequestPackets,
                                         arpStatRcvRequestPackets_oid,
                                         OID_LENGTH
                                         (arpStatRcvRequestPackets_oid),
                                         HANDLER_CAN_RONLY));
    init_PrivateMIBNodeRootOIDbySwitchBoardID(arpStatSendReplyPackets_oid);
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("arpStatSendReplyPackets",
                                         get_arpStatSendReplyPackets,
                                         arpStatSendReplyPackets_oid,
                                         OID_LENGTH
                                         (arpStatSendReplyPackets_oid),
                                         HANDLER_CAN_RONLY));
    init_PrivateMIBNodeRootOIDbySwitchBoardID(arpStatRcvReplyPackets_oid);
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("arpStatRcvReplyPackets",
                                         get_arpStatRcvReplyPackets,
                                         arpStatRcvReplyPackets_oid,
                                         OID_LENGTH
                                         (arpStatRcvReplyPackets_oid),
                                         HANDLER_CAN_RONLY));
    init_PrivateMIBNodeRootOIDbySwitchBoardID(arpStatSendRequestPackets_oid);
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("arpStatSendRequestPackets",
                                         get_arpStatSendRequestPackets,
                                         arpStatSendRequestPackets_oid,
                                         OID_LENGTH
                                         (arpStatSendRequestPackets_oid),
                                         HANDLER_CAN_RONLY));
    init_PrivateMIBNodeRootOIDbySwitchBoardID(arpCacheDeleteAll_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("arpCacheDeleteAll", do_arpCacheDeleteAll,
                               arpCacheDeleteAll_oid,
                               OID_LENGTH(arpCacheDeleteAll_oid),
                               HANDLER_CAN_RWRITE));
}

#if (SYS_CPNT_PROXY_ARP == TRUE)
/********************************************
 ************arpProxyArpTable****************
 ********************************************
 */
oid             arpProxyArpTable_variables_oid[] =
    { SYS_ADPT_PRIVATEMIB_OID, 1, 18, 1 };


struct variable3 arpProxyArpTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    {ARPPROXYARPIFINDEX, ASN_INTEGER, RONLY, var_arpProxyArpTable, 3,
     {4, 1, 1}},
#endif
    {ARPPROXYARPSTATUS, ASN_INTEGER, RWRITE, var_arpProxyArpTable, 3,
     {4, 1, 2}},
};


/** Initializes the arpProxyArpTable module */
void
init_arpProxyArpTable(void)
{
    /*
     * register ourselves with the agent to handle our mib tree
     */
    init_PrivateMIBNodeRootOIDbySwitchBoardID(arpProxyArpTable_variables_oid);
    REGISTER_MIB("arpProxyArpTable", arpProxyArpTable_variables, variable3,
                 arpProxyArpTable_variables_oid);
}
#endif /* SYS_CPNT_PROXY_ARP */
#endif /* SYS_CPNT_ARP */

#if (SYS_CPNT_RIP == TRUE)

/********************************************
 ********************ripMgt******************
 ********************************************
 */
/** Initializes the ripMgt module */
void
init_ripMgt(void)
{
    static oid      ripUpdateTime_oid[] =
        { SYS_ADPT_PRIVATEMIB_OID, 1, 18, 2, 1, 1, 0 };
    static oid      ripTimeoutTime_oid[] =
        { SYS_ADPT_PRIVATEMIB_OID, 1, 18, 2, 1, 2, 0 };
    static oid      ripGarbageCollectionTime_oid[] =
        { SYS_ADPT_PRIVATEMIB_OID, 1, 18, 2, 1, 3, 0 };
    static oid      ripRouterVersion_oid[] =
        { SYS_ADPT_PRIVATEMIB_OID, 1, 18, 2, 3, 0 };
    static oid      ripStatisticsReset_oid[] =
        { SYS_ADPT_PRIVATEMIB_OID, 1, 18, 2, 5, 0 };
    static oid      ripRoutingProcessStatus_oid[] =
        { SYS_ADPT_PRIVATEMIB_OID, 1, 18, 2, 2, 0 };
    static oid      ripDefaultMetric_oid[] =
        { SYS_ADPT_PRIVATEMIB_OID, 1, 18, 2, 9, 0 };
    static oid      ripMaxPrefix_oid[] =
        { SYS_ADPT_PRIVATEMIB_OID, 1, 18, 2, 12, 0 };
    static oid      ripDefaultInformationOriginate_oid[] =
        { SYS_ADPT_PRIVATEMIB_OID, 1, 18, 2, 14, 0 };
    static oid      ripClearByType_oid[] =
        { SYS_ADPT_PRIVATEMIB_OID, 1, 18, 2, 13, 1, 0 };
    static oid      ripDefaultDistance_oid[] =
        { SYS_ADPT_PRIVATEMIB_OID, 1, 18, 2, 15, 1, 0 };

    init_PrivateMIBNodeRootOIDbySwitchBoardID(ripUpdateTime_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("ripUpdateTime",
                               do_ripUpdateTime,
                               ripUpdateTime_oid,
                               OID_LENGTH(ripUpdateTime_oid),
                               HANDLER_CAN_RWRITE));
    init_PrivateMIBNodeRootOIDbySwitchBoardID(ripRouterVersion_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("ripRouterVersion",
                               do_ripRouterVersion,
                               ripRouterVersion_oid,
                               OID_LENGTH(ripRouterVersion_oid),
                               HANDLER_CAN_RWRITE));
   init_PrivateMIBNodeRootOIDbySwitchBoardID(ripDefaultMetric_oid);
   netsnmp_register_instance(netsnmp_create_handler_registration
                              ("ripDefaultMetric",
                               do_ripDefaultMetric,
                               ripDefaultMetric_oid,
                               OID_LENGTH(ripDefaultMetric_oid),
                               HANDLER_CAN_RWRITE));

   init_PrivateMIBNodeRootOIDbySwitchBoardID(ripMaxPrefix_oid);
   netsnmp_register_instance(netsnmp_create_handler_registration
                              ("ripMaxPrefix",
                               do_ripMaxPrefix,
                               ripMaxPrefix_oid,
                               OID_LENGTH(ripMaxPrefix_oid),
                               HANDLER_CAN_RWRITE));

   init_PrivateMIBNodeRootOIDbySwitchBoardID(ripDefaultInformationOriginate_oid);
   netsnmp_register_instance(netsnmp_create_handler_registration
                              ("ripDefaultInformationOriginate",
                               do_ripDefaultInformationOriginate,
                               ripDefaultInformationOriginate_oid,
                               OID_LENGTH(ripDefaultInformationOriginate_oid),
                               HANDLER_CAN_RWRITE));

   init_PrivateMIBNodeRootOIDbySwitchBoardID(ripDefaultDistance_oid);
   netsnmp_register_instance(netsnmp_create_handler_registration
                              ("ripDefaultDistance",
                               do_ripDefaultDistance,
                               ripDefaultDistance_oid,
                               OID_LENGTH(ripDefaultDistance_oid),
                               HANDLER_CAN_RWRITE));

   init_PrivateMIBNodeRootOIDbySwitchBoardID(ripClearByType_oid);
   netsnmp_register_instance(netsnmp_create_handler_registration
                              ("ripClearByType",
                               do_ripClearByType,
                               ripClearByType_oid,
                               OID_LENGTH(ripClearByType_oid),
                               HANDLER_CAN_RWRITE));

    init_PrivateMIBNodeRootOIDbySwitchBoardID(ripStatisticsReset_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("ripStatisticsReset",
                               do_ripStatisticsReset,
                               ripStatisticsReset_oid,
                               OID_LENGTH(ripStatisticsReset_oid),
                               HANDLER_CAN_RWRITE));

    init_PrivateMIBNodeRootOIDbySwitchBoardID(ripTimeoutTime_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                                        ("ripTimeoutTime",
                                         do_ripTimeoutTime,
                                         ripTimeoutTime_oid,
                                         OID_LENGTH(ripTimeoutTime_oid),
                                         HANDLER_CAN_RWRITE));
    init_PrivateMIBNodeRootOIDbySwitchBoardID(ripGarbageCollectionTime_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                                        ("ripGarbageCollectionTime",
                                         do_ripGarbageCollectionTime,
                                         ripGarbageCollectionTime_oid,
                                         OID_LENGTH(ripGarbageCollectionTime_oid),
                                         HANDLER_CAN_RWRITE));

    init_PrivateMIBNodeRootOIDbySwitchBoardID(ripRoutingProcessStatus_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("ripRoutingProcessStatus",
                               do_ripRoutingProcessStatus,
                               ripRoutingProcessStatus_oid,
                               OID_LENGTH(ripRoutingProcessStatus_oid),
                               HANDLER_CAN_RWRITE));

}

/********************************************
 *********ripInstabilityPreventingTable**
 ********************************************
 */
oid             ripInstabilityPreventingTable_variables_oid[] =
    { SYS_ADPT_PRIVATEMIB_OID, 1, 18, 2};

struct variable3 ripInstabilityPreventingTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    {RIPVLANINDEX, ASN_INTEGER, RONLY, var_ripInstabilityPreventingTable,
     3, {4, 1, 1}},
#endif
    {RIPSPLITHORIZONSTATUS, ASN_INTEGER, RWRITE,
     var_ripInstabilityPreventingTable, 3, {4, 1, 2}},
};

/** Initializes the ripInstabilityPreventingTable module */
void
init_ripInstabilityPreventingTable(void)
{

    /*
     * register ourselves with the agent to handle our mib tree
     */
    init_PrivateMIBNodeRootOIDbySwitchBoardID(ripInstabilityPreventingTable_variables_oid);
    REGISTER_MIB("ripInstabilityPreventingTable",
                 ripInstabilityPreventingTable_variables, variable3,
                 ripInstabilityPreventingTable_variables_oid);

}

/*******************************************
 ***********ripNetworkByInterfaceTable********
 ********************************************
 */
oid           ripNetworkByInterfaceTable_variables_oid[] =
    { SYS_ADPT_PRIVATEMIB_OID, 1, 18, 2, 6};

struct variable4 ripNetworkByInterfaceTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    {RIPNETWORKIFINDEX, ASN_INTEGER, RONLY, var_ripNetworkByInterfaceTable,
     3, {2, 1,1}},
#endif
    {RIPNETWORKADDRSTATUS, ASN_INTEGER, RWRITE, var_ripNetworkByInterfaceTable, 3,
     {2, 1,2}},
};

/** Initializes the ripNetworkAddrTable module */
void
init_ripNetworkByInterfaceTable(void)
{
    /*
     * register ourselves with the agent to handle our mib tree
     */
    init_PrivateMIBNodeRootOIDbySwitchBoardID(ripNetworkByInterfaceTable_variables_oid);
    REGISTER_MIB("ripNetworkAddrTable", ripNetworkByInterfaceTable_variables,
                 variable4, ripNetworkByInterfaceTable_variables_oid);
}
/*******************************************
 ***********ripNetworkByInetAddrTable
 ********************************************
 */
oid             ripNetworkByInetAddrTable_variables_oid[] =
    { SYS_ADPT_PRIVATEMIB_OID, 1, 18, 2, 6};
struct variable4 ripNetworkByInetAddrTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    {RIPNETWORKBYINETADDRADDRESSTYPE, ASN_INTEGER, RONLY, var_ripNetworkByInetAddrTable,
     3, {1, 1,1}},
    {RIPNETWORKBYINETADDRADDRESS, ASN_IPADDRESS, RONLY, var_ripNetworkByInetAddrTable,
     3, {1, 1,2}},
    {RIPNETWORKBYINETADDRPFXLEN, ASN_INTEGER, RONLY, var_ripNetworkByInetAddrTable,
     3, {1, 1,3}},
#endif
    {RIPNETWORKBYINETADDRSTATUS, ASN_INTEGER, RWRITE, var_ripNetworkByInetAddrTable,
    3, {1, 1,4}},
};

/** Initializes the ripNetworkAddrTable module */
void
init_ripNetworkByInetAddrTable(void)
{
    /*
     * register ourselves with the agent to handle our mib tree
     */
    init_PrivateMIBNodeRootOIDbySwitchBoardID(ripNetworkByInetAddrTable_variables_oid);
    REGISTER_MIB("ripNetworkByInetAddrTable", ripNetworkByInetAddrTable_variables,
                 variable4, ripNetworkByInetAddrTable_variables_oid);
}
/********************************************
 ***********var_ripDistanceTable****************
 ********************************************
 */
/*wei.zhang add*/
oid             ripDistanceTable_variables_oid[] =
    { SYS_ADPT_PRIVATEMIB_OID, 1, 18, 2, 15};
struct variable4 ripDistanceTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    {RIPDISTANCEINETADDRTYPE, ASN_INTEGER, RONLY, var_ripDistanceTable,
     3, {2, 1,1}},
    {RIPDISTANCEINETADDR, ASN_IPADDRESS, RONLY, var_ripDistanceTable,
     3, {2, 1,2}},
    {RIPDISTANCEPFXLEN, ASN_INTEGER, RONLY, var_ripDistanceTable,
     3, {2, 1,3}},
#endif
    {RIPDISTANCEVALUE, ASN_INTEGER, RWRITE, var_ripDistanceTable,
    3, {2, 1,4}},
     {RIPDISTANCEALISENAME, ASN_OCTET_STR, RWRITE, var_ripDistanceTable,
    3, {2, 1,5}},
     {RIPDISTANCEROWSTATUS, ASN_INTEGER, RWRITE, var_ripDistanceTable,
    3, {2, 1,6}},
};

/** Initializes the ripNetworkAddrTable module */
void
init_ripDistanceTable(void)
{
    /*
     * register ourselves with the agent to handle our mib tree
     */
    init_PrivateMIBNodeRootOIDbySwitchBoardID(ripDistanceTable_variables_oid);
    REGISTER_MIB("ripDistanceTable", ripDistanceTable_variables,
                 variable4, ripDistanceTable_variables_oid);
}



/********************************************
 *********ripPassiveInterfaceTable**
 ********************************************
 */
oid             ripPassiveInterfaceTable_variables_oid[] =
    { SYS_ADPT_PRIVATEMIB_OID, 1, 18, 2};

struct variable3 ripPassiveInterfaceTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    {RIPINTERFACEINDEX, ASN_INTEGER, RONLY, var_ripPassiveInterfaceTable,
     3, {11, 1, 1}},
#endif
    {RIPPASSIVEINTERFACESTATUS, ASN_INTEGER, RWRITE,var_ripPassiveInterfaceTable,
      3, {11, 1, 2}},
};
/** Initializes the init_ripPassiveInterfaceTable module */
void
init_ripPassiveInterfaceTable(void)
{
    /*
     * register ourselves with the agent to handle our mib tree
     */
    init_PrivateMIBNodeRootOIDbySwitchBoardID(ripPassiveInterfaceTable_variables_oid);
    REGISTER_MIB("ripPassiveInterfaceTable",
                 ripPassiveInterfaceTable_variables, variable3,
                 ripPassiveInterfaceTable_variables_oid);
}


/*******************************************
 ***********ripNeighborTable********
 ********************************************
 */
/*wei.zhang modify begin*/
oid           ripNeighborTable_variables_oid[] =
    { SYS_ADPT_PRIVATEMIB_OID, 1, 18, 2};

struct variable3 ripNeighborTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    {RIPNEIGHBORADDRESSTYPE, ASN_INTEGER, RONLY, var_ripNeighborTable,
     3, {10,1,1}},
    {RIPNEIGHBORADDRESS, ASN_IPADDRESS, RONLY, var_ripNeighborTable,
     3, {10,1,2}},
#endif
   {RIPNEIGHBORADDRESSSTATUS, ASN_INTEGER, RWRITE, var_ripNeighborTable,
     3, {10,1,3}},
};

/** Initializes the ripNeighborTable module */
void
init_ripNeighborTable(void)
{
    /*
     * register ourselves with the agent to handle our mib tree
     */
    init_PrivateMIBNodeRootOIDbySwitchBoardID(ripNeighborTable_variables_oid);
    REGISTER_MIB("ripNeighborTable",ripNeighborTable_variables,
                 variable3,ripNeighborTable_variables_oid);
}
    /*******************************************
     ***********var_ripRouteClearByNetworkTable
     ********************************************
     */
    /*wei.zhang add*/
    oid             ripRouteClearByNetworkTable_variables_oid[] =
        { SYS_ADPT_PRIVATEMIB_OID, 1, 18, 2, 13};
    struct variable3 ripRouteClearByNetworkTable_variables[] = {
        /*
         * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        {RIPROUTECLEARBYNETWORKINETADDRADDRTYPE, ASN_INTEGER, RONLY, var_ripRouteClearByNetworkTable,
         3, {2, 1,1}},
        {RIPROUTECLEARBYNETWORKINETADDRADDR, ASN_IPADDRESS, RONLY, var_ripRouteClearByNetworkTable,
         3, {2, 1,2}},
        {RIPROUTECLEARBYNETWORKPFXLEN, ASN_INTEGER, RONLY, var_ripRouteClearByNetworkTable,
         3, {2, 1,3}},
#endif
        {RIPROUTECLEARBYNETWORKSTATUS, ASN_INTEGER, RWRITE, var_ripRouteClearByNetworkTable,
        3, {2, 1,4}},
    };
   #if 1
    /** Initializes the ripNetworkAddrTable module */
    void
    init_ripRouteClearByNetworkTable(void)
    {
        /*
         * register ourselves with the agent to handle our mib tree
         */
        init_PrivateMIBNodeRootOIDbySwitchBoardID(ripRouteClearByNetworkTable_variables_oid);
        REGISTER_MIB("ripRouteClearByNetworkTable", ripRouteClearByNetworkTable_variables,
                     variable3, ripRouteClearByNetworkTable_variables_oid);
    }

#endif

    /*******************************************
     ***********var_ripRedistributeTable
     ********************************************
     */
    /*wei.zhang add*/
    oid             ripRedistributeTable_variables_oid[] =
        { SYS_ADPT_PRIVATEMIB_OID, 1, 18, 2};
    struct variable3 ripRedistributeTable_variables[] = {
        /*
         * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        {RIPREDISTRIBUTEPROTOCOL, ASN_INTEGER, RONLY, var_ripRedistribueTable,
         3, {8, 1,1}},
#endif

        {RIPREDISTRIBUTEMETRIC, ASN_INTEGER, RWRITE, var_ripRedistribueTable,
         3, {8, 1,2}},

        {RIPREDISTRIBUTESTATUS, ASN_INTEGER, RWRITE, var_ripRedistribueTable,
         3, {8, 1,3}},

#if 0
        {RIPREDISTRIBUTEREMAPNAME, ASN_OCTET_STR, RWRITE, var_ripRedistribueTable,
         3, {8, 1,4}},
#endif /* #if 0 */
    };

    /** Initializes the init_ripRedistributeTable module */
    void
    init_ripRedistributeTable(void)
    {
        /*
         * register ourselves with the agent to handle our mib tree
         */
        init_PrivateMIBNodeRootOIDbySwitchBoardID(ripRedistributeTable_variables_oid);
        REGISTER_MIB("ripRedistribueTable", ripRedistributeTable_variables,
                     variable3, ripRedistributeTable_variables_oid);
    }
#endif /* SYS_CPNT_RIP */

#if (SYS_CPNT_OSPF == TRUE)

    /********************************************
     ***********ospfRedistributeTable************
     ********************************************
     */
    oid             ospfMultiProcRedistTable_variables_oid[] =
        { SYS_ADPT_PRIVATEMIB_OID, 1, 18, 3 };

    struct variable3 ospfMultiProcRedistTable_variables[] = {
        /*
         * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
         */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        {OSPF_MULTI_PROCESS_REDISTRIBUTE_PROTOCOL,         ASN_INTEGER,     RONLY,
        var_ospfMultiProcessRedistTable,  3, {10, 1, 1}},
#endif
        {OSPF_MULTI_PROCESS_REDISTRIBUTE_METRIC_TYPE,      ASN_INTEGER,     RWRITE,
        var_ospfMultiProcessRedistTable,  3, {10, 1, 2}},
        {OSPF_MULTI_PROCESS_REDISTRIBUTE_METRIC,           ASN_INTEGER,     RWRITE,
        var_ospfMultiProcessRedistTable,  3, {10, 1, 3}},
        {OSPF_MULTI_PROCESS_REDISTRIBUTE_TAG,              ASN_GAUGE,     RWRITE,
        var_ospfMultiProcessRedistTable,  3, {10, 1, 4}},
        {OSPF_MULTI_PROCESS_REDISTRIBUTE_FILTER_LIST_NAME, ASN_OCTET_STR,   RWRITE,
        var_ospfMultiProcessRedistTable,  3, {10, 1, 5}},
        {OSPF_MULTI_PROCESS_REDISTRIBUTE_STATUS,           ASN_INTEGER,     RWRITE,
        var_ospfMultiProcessRedistTable,  3, {10, 1, 6}},
        {OSPF_MULTI_PROCESS_REDISTRIBUTE_ROUTE_MAP,        ASN_OCTET_STR,   RWRITE,
        var_ospfMultiProcessRedistTable,  3, {10, 1, 7}},
    };


    /** Initializes the ospfMultiProcessRedistributeTable module */
    void
    init_ospfMultiProcRedistTable(void)
    {
        /*
         * register ourselves with the agent to handle our mib tree
         */
        init_PrivateMIBNodeRootOIDbySwitchBoardID(ospfMultiProcRedistTable_variables_oid);
        REGISTER_MIB("ospfMultiProcessRedistributeTable", ospfMultiProcRedistTable_variables,
                     variable3, ospfMultiProcRedistTable_variables_oid);
    }
    /************************************************
     ************ospfMultiProcessSummaryAddressTable*********
     **************************************************
     */
    /*
     * ospfMultiProcessSummaryAddressTable_variables_oid:
     *   this is the top level oid that we want to register under.  This
     *   is essentially a prefix, with the suffix appearing in the
     *   variable below.
     */

    oid             ospfMultiProcSummaryAddrTable_variables_oid[] =
        { SYS_ADPT_PRIVATEMIB_OID, 1, 18, 3 };

    struct variable3 ospfMultiProcSummaryAddrTable_variables[] = {
        /*
         * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
         */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)

        {OSPFMULTIPROCSUMMARYADDRTYPE, ASN_INTEGER, RONLY, var_ospfMultiProcessSummaryAddressTable,
         3, {11, 1, 1}},
        {OSPFMULTIPROCSUMMARYADDR, ASN_IPADDRESS, RONLY, var_ospfMultiProcessSummaryAddressTable,
         3, {11, 1, 2}},
        {OSPFMULTIPROCSUMMARYPFXLEN, ASN_INTEGER, RONLY, var_ospfMultiProcessSummaryAddressTable,
         3, {11, 1, 3}},
#endif
        {OSPFMULTIPROCSUMMARYSTATUS, ASN_INTEGER, RWRITE, var_ospfMultiProcessSummaryAddressTable,
         3, {11, 1, 4}},
    };


    /** Initializes the ospfMultiProcessSummaryAddressTable module */
    void
    init_ospfMultiProcSummaryAddrTable(void)
    {
        /*
         * register ourselves with the agent to handle our mib tree
         */
        init_PrivateMIBNodeRootOIDbySwitchBoardID(ospfMultiProcSummaryAddrTable_variables_oid);
        REGISTER_MIB("ospfMultiProcessSummaryAddressTable",
                     ospfMultiProcSummaryAddrTable_variables, variable3,
                     ospfMultiProcSummaryAddrTable_variables_oid);

    }

    /************************************************
     ************ospfMultiProcessVirtIfAuthMd5Table*********
     **************************************************
     */

    oid             ospfMultiProcVirtIfAuthMd5Table_variables_oid[] =
        { SYS_ADPT_PRIVATEMIB_OID, 1, 18, 3 };

    struct variable3 ospfMultiProcVirtIfAuthMd5Table_variables[] = {
        /*
         * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
         */
        {OSPFMULTIPROCVIRTIFAUTHMD5KEY, ASN_OCTET_STR, RWRITE, var_ospfMultiProcVirtIfAuthMd5Table,
         3, {28, 1, 4}},
    };


    /** Initializes the ospfMultiProcessSummaryAddressTable module */
    void
    init_ospfMultiProcVirtIfMd5Table(void)
    {
        /*
         * register ourselves with the agent to handle our mib tree
         */
        REGISTER_MIB("ospfMultiProcVirtIfAuthMd5Table",
                     ospfMultiProcVirtIfAuthMd5Table_variables, variable3,
                     ospfMultiProcVirtIfAuthMd5Table_variables_oid);

    }

/********************************************
 ***********ospfMultiProcessVirtNbrTable***************
 ********************************************
 */
oid             ospfMultiProcessVirtNbrTable_variables_oid[] =
    { SYS_ADPT_PRIVATEMIB_OID, 1, 18, 3 };

struct variable3 ospfMultiProcessVirtNbrTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */

    {OSPFMULTIPROCESSVIRTNBRIPADDR, ASN_IPADDRESS, RONLY,
     var_ospfMultiProcessVirtNbrTable, 3, {22,1,3}},
    {OSPFMULTIPROCESSVIRTNBROPTIONS, ASN_INTEGER, RONLY,
     var_ospfMultiProcessVirtNbrTable, 3, {22,1,4}},
    {OSPFMULTIPROCESSVIRTNBRSTATE, ASN_INTEGER, RONLY,
     var_ospfMultiProcessVirtNbrTable, 3, {22,1,5}},
    {OSPFMULTIPROCESSVIRTNBREVENTS, ASN_COUNTER, RONLY,
     var_ospfMultiProcessVirtNbrTable, 3, {22,1,6}},
    {OSPFMULTIPROCESSVIRTNBRLSRETRANSQLEN, ASN_GAUGE, RONLY,
     var_ospfMultiProcessVirtNbrTable, 3, {22,1,8}},
};

/** Initializes the ospfMultiProcessVirtNbrTable module */
void
init_ospfMultiProcessVirtNbrTable(void)
{
    /*
     * register ourselves with the agent to handle our mib tree
     */
    REGISTER_MIB("ospfMultiProcessVirtNbrTable",
                 ospfMultiProcessVirtNbrTable_variables, variable3,
                 ospfMultiProcessVirtNbrTable_variables_oid);
}
/********************************************
 ***********ospfMultiProcessVirtIfTable***************
 ********************************************
 */
oid             ospfMultiProcessVirtIfTable_variables_oid[] =
    { SYS_ADPT_PRIVATEMIB_OID, 1, 18, 3 };

struct variable3 ospfMultiProcessVirtIfTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */

    {OSPFMULTIPROCESSVIRTIFTRANSITDELAY, ASN_INTEGER, RWRITE,
     var_ospfMultiProcessVirtIfTable, 3, {20,1,3}},
    {OSPFMULTIPROCESSVIRTIFRETRANSINTERVAL, ASN_INTEGER, RWRITE,
     var_ospfMultiProcessVirtIfTable, 3, {20,1,4}},
    {OSPFMULTIPROCESSVIRTIFHELLOINTERVAL, ASN_INTEGER, RWRITE,
     var_ospfMultiProcessVirtIfTable, 3, {20,1,5}},
    {OSPFMULTIPROCESSVIRTIFRTRDEADINTERVAL, ASN_INTEGER, RWRITE,
     var_ospfMultiProcessVirtIfTable, 3, {20,1,6}},
    {OSPFMULTIPROCESSVIRTIFSTATE, ASN_INTEGER, RONLY,
     var_ospfMultiProcessVirtIfTable, 3, {20,1,7}},
    {OSPFMULTIPROCESSVIRTIFEVENTS, ASN_COUNTER, RONLY,
     var_ospfMultiProcessVirtIfTable, 3, {20,1,8}},
    {OSPFMULTIPROCESSVIRTIFAUTHKEY, ASN_OCTET_STR, RWRITE,
     var_ospfMultiProcessVirtIfTable, 3, {20,1,9}},
    {OSPFMULTIPROCESSVIRTIFSTATUS, ASN_INTEGER, RWRITE,
     var_ospfMultiProcessVirtIfTable, 3, {20,1,10}},
    {OSPFMULTIPROCESSVIRTIFAUTHTYPE, ASN_INTEGER, RWRITE,
     var_ospfMultiProcessVirtIfTable, 3, {20,1,11}},
};

/** Initializes the ospfMultiProcessVirtIfTable module */
void
init_ospfMultiProcessVirtIfTable(void)
{
    /*
     * register ourselves with the agent to handle our mib tree
     */
    REGISTER_MIB("ospfMultiProcessVirtIfTable",
                 ospfMultiProcessVirtIfTable_variables, variable3,
                 ospfMultiProcessVirtIfTable_variables_oid);
}


/********************************************
 ***********ospfMultiProcessIFTable***************
 ********************************************
 */
oid             ospfMultiProcessIfTable_variables_oid[] =
    { SYS_ADPT_PRIVATEMIB_OID, 1, 18, 3 };

struct variable3 ospfMultiProcessIfTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */

    {OSPFMULTIPROCESSIFCOST, ASN_INTEGER, RWRITE,
     var_ospfMultiProcessIfTable, 3, {14,1,3}},
    {OSPFMULTIPROCESSIFMTU, ASN_INTEGER, RWRITE,
     var_ospfMultiProcessIfTable, 3, {14,1,4}},
    {OSPFMULTIPROCESSIFMTUIGNORE, ASN_INTEGER, RWRITE,
     var_ospfMultiProcessIfTable, 3, {14,1,5}},
    {OSPFMULTIPROCESSIFAREAID, ASN_IPADDRESS, RONLY,
     var_ospfMultiProcessIfTable, 3, {14,1,6}},
    {OSPFMULTIPROCESSIFRTRPRIORITY, ASN_INTEGER, RWRITE,
     var_ospfMultiProcessIfTable, 3, {14,1,7}},
    {OSPFMULTIPROCESSIFTRANSITDELAY, ASN_INTEGER, RWRITE,
     var_ospfMultiProcessIfTable, 3, {14,1,8}},
    {OSPFMULTIPROCESSIFRETRANSINTERVAL, ASN_INTEGER, RWRITE,
     var_ospfMultiProcessIfTable, 3, {14,1,9}},
    {OSPFMULTIPROCESSIFHELLOINTERVAL, ASN_INTEGER, RWRITE,
     var_ospfMultiProcessIfTable, 3, {14,1,10}},
    {OSPFMULTIPROCESSIFRTRDEADINTERVAL, ASN_INTEGER, RWRITE,
     var_ospfMultiProcessIfTable, 3, {14,1,11}},
    {OSPFMULTIPROCESSIFSTATE, ASN_INTEGER, RONLY,
     var_ospfMultiProcessIfTable, 3, {14,1,12}},
    {OSPFMULTIPROCESSIFDESIGNATEDROUTER, ASN_IPADDRESS, RONLY,
     var_ospfMultiProcessIfTable, 3, {14,1,13}},
    {OSPFMULTIPROCESSIFBACKUPDESIGNATEDROUTER, ASN_IPADDRESS, RONLY,
     var_ospfMultiProcessIfTable, 3, {14,1,14}},
    {OSPFMULTIPROCESSIFEVENTS, ASN_COUNTER, RONLY,
     var_ospfMultiProcessIfTable, 3, {14,1,15}},
    {OSPFMULTIPROCESSIFAUTHKEY, ASN_OCTET_STR, RWRITE,
     var_ospfMultiProcessIfTable, 3, {14,1,16}},
    {OSPFMULTIPROCESSIFSTATUS, ASN_INTEGER, RONLY,
     var_ospfMultiProcessIfTable, 3, {14,1,17}},
    {OSPFMULTIPROCESSIFAUTHTYPE, ASN_INTEGER, RWRITE,
     var_ospfMultiProcessIfTable, 3, {14,1,18}},
    {OSPFMULTIPROCESSIFDESIGNATEDROUTERID, ASN_IPADDRESS, RONLY,
     var_ospfMultiProcessIfTable, 3, {14,1,19}},
    {OSPFMULTIPROCESSIFBACKUPDESIGNATEDROUTERID, ASN_IPADDRESS, RONLY,
     var_ospfMultiProcessIfTable, 3, {14,1,20}},

};

/** Initializes the ospfMultiProcessIfTable module */
void
init_ospfMultiProcessIfTable(void)
{
    /*
     * register ourselves with the agent to handle our mib tree
     */
    REGISTER_MIB("ospfMultiProcessIfTable",
                 ospfMultiProcessIfTable_variables, variable3,
                 ospfMultiProcessIfTable_variables_oid);
}

/********************************************
 *****ospfMultiProcessAreaTable*****************
 ********************************************
 */
oid             ospfMultiProcessAreaTable_variables_oid[] =
    { SYS_ADPT_PRIVATEMIB_OID, 1, 18, 3 };

struct variable3 ospfMultiProcessAreaTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */
    {OSPFMULTIPROCESSIMPORTASEXTERN, ASN_INTEGER, RONLY,
     var_ospfMultiProcessAreaTable, 3, {15,1,3}},
    {OSPFMULTIPROCESSSPFRUNS, ASN_COUNTER, RONLY,
     var_ospfMultiProcessAreaTable, 3, {15,1,4}},
    {OSPFMULTIPROCESSAREABDRRTRCOUNT, ASN_GAUGE, RONLY,
     var_ospfMultiProcessAreaTable, 3, {15,1,5}},
    {OSPFMULTIPROCESSASBDRRTRCOUNT, ASN_GAUGE, RONLY,
     var_ospfMultiProcessAreaTable, 3, {15,1,6}},
    {OSPFMULTIPROCESSAREALSACOUNT, ASN_GAUGE, RONLY,
     var_ospfMultiProcessAreaTable, 3, {15,1,7}},
    {OSPFMULTIPROCESSAREALSACKSUMSUM, ASN_INTEGER, RONLY,
     var_ospfMultiProcessAreaTable, 3, {15,1,8}},
    {OSPFMULTIPROCESSAREASUMMARY, ASN_INTEGER, RWRITE,
     var_ospfMultiProcessAreaTable, 3, {15,1,9}},
    {OSPFMULTIPROCESSAREASTATUS, ASN_INTEGER, RONLY,
     var_ospfMultiProcessAreaTable, 3, {15,1,10}},
};

/** Initializes the ospfMultiProcessAreaTable module */
void
init_ospfMultiProcessAreaTable(void)
{
    /*
     * register ourselves with the agent to handle our mib tree
     */
    init_PrivateMIBNodeRootOIDbySwitchBoardID(ospfMultiProcessAreaTable_variables_oid);
    REGISTER_MIB("ospfMultiProcessAreaTable",
                 ospfMultiProcessAreaTable_variables, variable3,
                 ospfMultiProcessAreaTable_variables_oid);
}

/********************************************
 *****ospfMultiProcessStubAreaTable**************
 ********************************************
 */
oid             ospfMultiProcessStubAreaTable_variables_oid[] =
    { SYS_ADPT_PRIVATEMIB_OID, 1, 18, 3 };

struct variable3 ospfMultiProcessStubAreaTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */
    {OSPFMULTIPROCESSSTUBMETRIC, ASN_INTEGER, RWRITE,
     var_ospfMultiProcessStubAreaTable, 3, {16,1,3}},
    {OSPFMULTIPROCESSSTUBSTATUS, ASN_INTEGER, RWRITE,
     var_ospfMultiProcessStubAreaTable, 3, {16,1,4}},
};

/** Initializes the ospfMultiProcessStubAreaTable module */
void
init_ospfMultiProcessStubAreaTable(void)
{
    /*
     * register ourselves with the agent to handle our mib tree
     */
    init_PrivateMIBNodeRootOIDbySwitchBoardID(ospfMultiProcessStubAreaTable_variables_oid);
    REGISTER_MIB("ospfMultiProcessStubAreaTable",
                 ospfMultiProcessStubAreaTable_variables, variable3,
                 ospfMultiProcessStubAreaTable_variables_oid);
}

/********************************************
 *****ospfMultiProcessNetworkAreaAddressTable****
 ********************************************
 */
oid             ospfMultiProcessNetworkAreaAddressTable_variables_oid[] =
    { SYS_ADPT_PRIVATEMIB_OID, 1, 18, 3 };

struct variable3 ospfMultiProcessNetworkAreaAddressTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */
    {OSPFMULTIPROCESSNETWORKAREAAREAID, ASN_UNSIGNED, RWRITE,
     var_ospfMultiProcessNetworkAreaAddressTable, 3, {12,1,4}},
    {OSPFMULTIPROCESSNETWORKAREASTATUS, ASN_INTEGER, RWRITE,
     var_ospfMultiProcessNetworkAreaAddressTable, 3, {12,1,5}},
    {OSPFMULTIPROCESSNETWORKAREAAREAID2, ASN_IPADDRESS, RWRITE,
     var_ospfMultiProcessNetworkAreaAddressTable, 3, {12,1,6}},
};

/** Initializes the ospfMultiProcessNetworkAreaAddressTable module */
void
init_ospfMultiProcessNetworkAreaAddressTable(void)
{
    /*
     * register ourselves with the agent to handle our mib tree
     */
    init_PrivateMIBNodeRootOIDbySwitchBoardID(ospfMultiProcessNetworkAreaAddressTable_variables_oid);
    REGISTER_MIB("ospfMultiProcessNetworkAreaAddressTable",
                 ospfMultiProcessNetworkAreaAddressTable_variables, variable3,
                 ospfMultiProcessNetworkAreaAddressTable_variables_oid);
}

/********************************************
 *****ospfMultiProcessAreaAggregateTable*********
 ********************************************
 */
oid             ospfMultiProcessAreaAggregateTable_variables_oid[] =
    { SYS_ADPT_PRIVATEMIB_OID, 1, 18, 3 };

struct variable3 ospfMultiProcessAreaAggregateTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */
    {OSPFMULTIPROCESSAREAAGGREGETESTATUS, ASN_UNSIGNED, RWRITE,
     var_ospfMultiProcessAreaAggregateTable, 3, {24,1,5}},
    {OSPFMULTIPROCESSAREAAGGREGATEEFFECT, ASN_INTEGER, RWRITE,
     var_ospfMultiProcessAreaAggregateTable, 3, {24,1,6}},
};

/** Initializes the ospfMultiProcessAreaAggregateTable module */
void
init_ospfMultiProcessAreaAggregateTable(void)
{
    /*
     * register ourselves with the agent to handle our mib tree
     */
    init_PrivateMIBNodeRootOIDbySwitchBoardID(ospfMultiProcessAreaAggregateTable_variables_oid);
    REGISTER_MIB("ospfMultiProcessAreaAggregateTable",
                 ospfMultiProcessAreaAggregateTable_variables, variable3,
                 ospfMultiProcessAreaAggregateTable_variables_oid);
}

/********************************************
 *****ospfMultiProcessNssaTable*****************
 ********************************************
 */
oid             ospfMultiProcessNssaTable_variables_oid[] =
    { SYS_ADPT_PRIVATEMIB_OID, 1, 18, 3 };

struct variable3 ospfMultiProcessNssaTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */
    {OSPFMULTIPROCESSNSSATRANSLATORROLE, ASN_INTEGER, RWRITE,
     var_ospfMultiProcessNssaTable, 3, {9,1,2}},
    {OSPFMULTIPROCESSNSSAREDISTRIBUTESTATUS, ASN_INTEGER, RWRITE,
     var_ospfMultiProcessNssaTable, 3, {9,1,3}},
    {OSPFMULTIPROCESSNSSAORIGINATEDEFAULTINFOSTATUS, ASN_INTEGER, RWRITE,
     var_ospfMultiProcessNssaTable, 3, {9,1,4}},
    {OSPFMULTIPROCESSNSSAMETRICTYPE, ASN_INTEGER, RWRITE,
     var_ospfMultiProcessNssaTable, 3, {9,1,5}},
    {OSPFMULTIPROCESSNSSAMETRIC, ASN_INTEGER, RWRITE,
     var_ospfMultiProcessNssaTable, 3, {9,1,6}},
    {OSPFMULTIPROCESSNSSASTATUS, ASN_INTEGER, RWRITE,
     var_ospfMultiProcessNssaTable, 3, {9,1,7}},
    {OSPFMULTIPROCESSNSSATRANSLATORSTATE, ASN_INTEGER, RONLY,
     var_ospfMultiProcessNssaTable, 3, {9,1,8}},
};

/** Initializes the ospfMultiProcessNssaTable module */
void
init_ospfMultiProcessNssaTable(void)
{
    /*
     * register ourselves with the agent to handle our mib tree
     */
    init_PrivateMIBNodeRootOIDbySwitchBoardID(ospfMultiProcessNssaTable_variables_oid);
    REGISTER_MIB("ospfMultiProcessNssaTable",
                 ospfMultiProcessNssaTable_variables, variable3,
                 ospfMultiProcessNssaTable_variables_oid);
}

oid             ospfIfParamTable_variables_oid[] =
    { SYS_ADPT_PRIVATEMIB_OID, 1, 18, 3 };

/*
 * variable4 ospfIfParamTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */

struct variable3 ospfIfParamTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    {OSPF_IFPARAM_IFINDEX, ASN_INTEGER, RONLY, var_ospfIfParamTable, 3,
     {37, 1, 1}},
    {OSPF_IFPARAM_IPADDRESS, ASN_IPADDRESS, RONLY, var_ospfIfParamTable, 3,
     {37, 1, 2}},
    {OSPF_IFPARAM_TOS, ASN_INTEGER, RONLY, var_ospfIfParamTable, 3,
     {37, 1, 3}},
#endif
    {OSPF_IFPARAM_COST, ASN_INTEGER, RWRITE, var_ospfIfParamTable, 3,
     {37, 1, 4}},
    {OSPF_IFPARAM_STATUS, ASN_INTEGER, RWRITE, var_ospfIfParamTable, 3,
     {37, 1, 5}},
};

/** Initializes the ospfIfMetricTable module */
void init_ospfIfParamTable(void)
{
    /*
     * register ourselves with the agent to handle our mib tree
     */
    REGISTER_MIB("ospfIfParamTable", ospfIfParamTable_variables,
                 variable3, ospfIfParamTable_variables_oid);
}

oid             ospfMultiProcessSystemTable_variables_oid[] =
    { SYS_ADPT_PRIVATEMIB_OID, 1, 18, 3 };

struct variable3 ospfMultiProcessSystemTable_variables[] =
{
    /* 1 -- Private OSPF system table date. */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    {OSPF_MULTI_PROCESS_ID,                             ASN_INTEGER, NOACCESS,  var_ospfMultiProcessSystemTable,   3, {8, 1, 1}},
#endif
    {OSPF_MULTI_PROCESS_ROUTER_ID_TYPE,                 ASN_INTEGER, RONLY,     var_ospfMultiProcessSystemTable,   3, {8, 1, 2}},
    {OSPF_MULTI_PROCESS_RFC1583_COMPATIBLE_STATE,       ASN_INTEGER, RWRITE,    var_ospfMultiProcessSystemTable,   3, {8, 1, 3}},
    {OSPF_MULTI_PROCESS_AUTO_COST,                      ASN_INTEGER, RWRITE,    var_ospfMultiProcessSystemTable,   3, {8, 1, 4}},
    {OSPF_MULTI_PROCESS_ORIGINATE_DEFAULT_ROUTE,        ASN_INTEGER, RWRITE,    var_ospfMultiProcessSystemTable,   3, {8, 1, 5}},
    {OSPF_MULTI_PROCESS_ADVERTISE_DEFAULT_ROUTE,        ASN_INTEGER, RWRITE,    var_ospfMultiProcessSystemTable,   3, {8, 1, 6}},
    {OSPF_MULTI_PROCESS_EXTERNAL_METRIC_TYPE,           ASN_INTEGER, RWRITE,    var_ospfMultiProcessSystemTable,   3, {8, 1, 7}},
    {OSPF_MULTI_PROCESS_DEFAULT_EXTERNAL_METRIC,        ASN_INTEGER, RWRITE,    var_ospfMultiProcessSystemTable,   3, {8, 1, 8}},
    {OSPF_MULTI_PROCESS_SPF_HOLD_TIME,                  ASN_INTEGER, RWRITE,    var_ospfMultiProcessSystemTable,   3, {8, 1, 9}},
    {OSPF_MULTI_PROCESS_AREA_NUMBER,                    ASN_INTEGER, RONLY,     var_ospfMultiProcessSystemTable,   3, {8, 1, 10}},
    {OSPF_MULTI_PROCESS_AREA_LIMIT,                     UNSIGNED, RWRITE, var_ospfMultiProcessSystemTable,   3, {8, 1, 11}},
    {OSPF_MULTI_PROCESS_CAPABILITY_OPAQUE,              ASN_INTEGER, RWRITE,    var_ospfMultiProcessSystemTable,   3, {8, 1, 12}},
    {OSPF_MULTI_PROCESS_OVERFLOW_DATABASE_NUMBER,       UNSIGNED, RWRITE, var_ospfMultiProcessSystemTable,   3, {8, 1, 13}},
    {OSPF_MULTI_PROCESS_OVERFLOW_DATABASE_TYPE,         ASN_INTEGER, RWRITE,    var_ospfMultiProcessSystemTable,   3, {8, 1, 14}},
    {OSPF_MULTI_PROCESS_OVERFLOW_EXTERNAL_DB_MAXSIZE,   ASN_INTEGER, RWRITE,    var_ospfMultiProcessSystemTable,   3, {8, 1, 15}},
    {OSPF_MULTI_PROCESS_OVERFLOW_EXTERNAL_DB_WAITTIME,  ASN_INTEGER, RWRITE,    var_ospfMultiProcessSystemTable,   3, {8, 1, 16}},
    {OSPF_MULTI_PROCESS_SYSTEM_STATUS,                  ASN_INTEGER, RWRITE,    var_ospfMultiProcessSystemTable,   3, {8, 1, 17}},
    {OSPF_MULTI_PROCESS_ROUTER_ID,                      ASN_IPADDRESS, RWRITE,  var_ospfMultiProcessSystemTable,   3, {8, 1, 18}},
    {OSPF_MULTI_PROCESS_ADMIN_STAT,                     ASN_INTEGER, RWRITE,    var_ospfMultiProcessSystemTable,   3, {8, 1, 19}},
    {OSPF_MULTI_PROCESS_VERSION_NUMBER,                 ASN_INTEGER, RONLY,     var_ospfMultiProcessSystemTable,   3, {8, 1, 20}},
    {OSPF_MULTI_PROCESS_AREA_BDR_RTR_STATUS,            ASN_INTEGER, RONLY,     var_ospfMultiProcessSystemTable,   3, {8, 1, 21}},
    {OSPF_MULTI_PROCESS_AS_BDR_RTR_STATUS,              ASN_INTEGER, RWRITE,    var_ospfMultiProcessSystemTable,   3, {8, 1, 22}},
    {OSPF_MULTI_PROCESS_EXTERN_LSA_COUNT,               GAUGE,   RONLY,     var_ospfMultiProcessSystemTable,   3, {8, 1, 23}},
    {OSPF_MULTI_PROCESS_EXTERN_LSA_CKSUM_SUM,           ASN_INTEGER, RONLY,     var_ospfMultiProcessSystemTable,   3, {8, 1, 24}},
    {OSPF_MULTI_PROCESS_ORIGINATE_NEW_LSAS,             COUNTER, RONLY,     var_ospfMultiProcessSystemTable,   3, {8, 1, 25}},
    {OSPF_MULTI_PROCESS_RX_NEW_LSAS,                    COUNTER, RONLY,     var_ospfMultiProcessSystemTable,   3, {8, 1, 26}},
    {OSPF_MULTI_PROCESS_RESTART_SUPPORT,                ASN_INTEGER, RWRITE,    var_ospfMultiProcessSystemTable,   3, {8, 1, 27}},
    {OSPF_MULTI_PROCESS_RESTART_INTERVAL,               ASN_INTEGER, RWRITE,    var_ospfMultiProcessSystemTable,   3, {8, 1, 28}},
    {OSPF_MULTI_PROCESS_RESTART_STATUS,                 ASN_INTEGER, RONLY,     var_ospfMultiProcessSystemTable,   3, {8, 1, 29}},
    {OSPF_MULTI_PROCESS_AS_LSA_COUNT,                   GAUGE,   RONLY,     var_ospfMultiProcessSystemTable,   3, {8, 1, 30}},
    {OSPF_MULTI_PROCESS_SPF_DELAY_TIME,                 ASN_INTEGER, RWRITE,    var_ospfMultiProcessSystemTable,   3, {8, 1, 31}},
    {OSPF_MULTI_PROCESS_DEFAULT_ROUTE_MAP,              STRING,  RWRITE,    var_ospfMultiProcessSystemTable,   3, {8, 1, 32}},
    {OSPF_MULTI_PROCESS_DEFAULT_METRIC,              ASN_INTEGER,  RWRITE,    var_ospfMultiProcessSystemTable,   3, {8, 1, 33}},
};

/** Initializes the ospfMultiProcessSystemTable module */
void init_ospfMultiProcessSystemTable(void)
{
      /*
     * register ourselves with the agent to handle our mib tree
     */
    REGISTER_MIB("ospfMultiProcessSystemTable", ospfMultiProcessSystemTable_variables,
                 variable3, ospfMultiProcessSystemTable_variables_oid);
}

oid             ospfMultiProcessNbrTable_variables_oid[] =
    { SYS_ADPT_PRIVATEMIB_OID, 1, 18, 3 };

/*
 * variable3 ospfMultiProcessNbrTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */

struct variable3 ospfMultiProcessNbrTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    {OSPF_MULTI_PROCESS_NBR_IPADDR, ASN_IPADDRESS, RONLY, var_ospfMultiProcessNbrTable, 3,
     {21, 1, 1}},
#endif
    {OSPF_MULTI_PROCESS_NBR_RTR_ID, ASN_IPADDRESS, RONLY, var_ospfMultiProcessNbrTable, 3,
     {21, 1, 2}},
    {OSPF_MULTI_PROCESS_NBR_OPTIONS, ASN_INTEGER, RONLY, var_ospfMultiProcessNbrTable, 3,
     {21, 1, 3}},
    {OSPF_MULTI_PROCESS_NBR_PRIORITY, ASN_INTEGER, RONLY, var_ospfMultiProcessNbrTable, 3,
     {21, 1, 4}},
    {OSPF_MULTI_PROCESS_NBR_STATE, ASN_INTEGER, RONLY, var_ospfMultiProcessNbrTable, 3,
     {21, 1, 5}},
    {OSPF_MULTI_PROCESS_NBR_EVENTS, ASN_COUNTER, RONLY, var_ospfMultiProcessNbrTable, 3,
     {21, 1, 6}},
    {OSPF_MULTI_PROCESS_NBR_LS_RETRANS_QLEN, ASN_GAUGE, RONLY, var_ospfMultiProcessNbrTable, 3,
     {21, 1, 7}},
};

/** Initializes the ospfIfMetricTable module */
void init_ospfMultiProcessNbrTable(void)
{
    /*
     * register ourselves with the agent to handle our mib tree
     */
    REGISTER_MIB("ospfMultiProcessNbrTable", ospfMultiProcessNbrTable_variables,
                 variable3, ospfMultiProcessNbrTable_variables_oid);
}

oid             ospfMultiProcessLsdbTable_variables_oid[] =
    { SYS_ADPT_PRIVATEMIB_OID, 1, 18, 3 };

/*
 * variable3 ospfMultiProcessLsdbTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */

struct variable3 ospfMultiProcessLsdbTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    {OSPF_MULTI_PROCESS_NBR_IPADDR, ASN_IPADDRESS, RONLY, var_ospfMultiProcessLsdbTable, 3,
     {17, 1, 1}},
    {OSPF_MULTI_PROCESS_LSDB_TYPE, ASN_INTEGER, RONLY, var_ospfMultiProcessLsdbTable, 3,
     {17, 1, 2}},
    {OSPF_MULTI_PROCESS_LSDB_LSID, ASN_IPADDRESS, RONLY, var_ospfMultiProcessLsdbTable, 3,
     {17, 1, 3}},
    {OSPF_MULTI_PROCESS_LSDB_ROUTER_ID, ASN_IPADDRESS, RONLY, var_ospfMultiProcessLsdbTable, 3,
     {17, 1, 4}},
#endif
    {OSPF_MULTI_PROCESS_LSDB_SQUENCE, ASN_INTEGER, RONLY, var_ospfMultiProcessLsdbTable, 3,
     {17, 1, 5}},
    {OSPF_MULTI_PROCESS_LSDB_AGE, ASN_INTEGER, RONLY, var_ospfMultiProcessLsdbTable, 3,
     {17, 1, 6}},
    {OSPF_MULTI_PROCESS_LSDB_CHK_SUM, ASN_INTEGER, RONLY, var_ospfMultiProcessLsdbTable, 3,
     {17, 1, 7}},
    {OSPF_MULTI_PROCESS_LSDB_ADVERTISE, ASN_OCTET_STR, RONLY, var_ospfMultiProcessLsdbTable, 3,
     {17, 1, 8}},
};

/** Initializes the ospfIfMetricTable module */
void init_ospfMultiProcessLsdbTable(void)
{
    /*
     * register ourselves with the agent to handle our mib tree
     */
    REGISTER_MIB("ospfMultiProcessLsdbTable", ospfMultiProcessLsdbTable_variables,
                 variable3, ospfMultiProcessLsdbTable_variables_oid);
}

oid             ospfMultiProcessExtLsdbTable_variables_oid[] =
    { SYS_ADPT_PRIVATEMIB_OID, 1, 18, 3 };

/*
 * variable3 ospfMultiProcessExtLsdbTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */

struct variable3 ospfMultiProcessExtLsdbTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    {OSPF_MULTI_PROCESS_EXT_LSDB_TYPE, ASN_INTEGER, RONLY, var_ospfMultiProcessExtLsdbTable, 3,
     {23, 1, 1}},
    {OSPF_MULTI_PROCESS_EXT_LSDB_LSID, ASN_IPADDRESS, RONLY, var_ospfMultiProcessExtLsdbTable, 3,
     {23, 1, 2}},
    {OSPF_MULTI_PROCESS_EXT_LSDB_ROUTER_ID, ASN_IPADDRESS, RONLY, var_ospfMultiProcessExtLsdbTable, 3,
     {23, 1, 3}},
#endif
    {OSPF_MULTI_PROCESS_EXT_LSDB_SQUENCE, ASN_INTEGER, RONLY, var_ospfMultiProcessExtLsdbTable, 3,
     {23, 1, 4}},
    {OSPF_MULTI_PROCESS_EXT_LSDB_AGE, ASN_INTEGER, RONLY, var_ospfMultiProcessExtLsdbTable, 3,
     {23, 1, 5}},
    {OSPF_MULTI_PROCESS_EXT_LSDB_CHK_SUM, ASN_INTEGER, RONLY, var_ospfMultiProcessExtLsdbTable, 3,
     {23, 1, 6}},
    {OSPF_MULTI_PROCESS_EXT_LSDB_ADVERTISE, ASN_OCTET_STR, RONLY, var_ospfMultiProcessExtLsdbTable, 3,
     {23, 1, 7}},
};

/** Initializes the ospfIfMetricTable module */
void init_ospfMultiProcessExtLsdbTable(void)
{
    /*
     * register ourselves with the agent to handle our mib tree
     */
    REGISTER_MIB("ospfMultiProcessExtLsdbTable", ospfMultiProcessExtLsdbTable_variables,
                 variable3, ospfMultiProcessExtLsdbTable_variables_oid);
}

oid             ospfMultiProcessIfAuthMd5Table_variables_oid[] =
    { SYS_ADPT_PRIVATEMIB_OID, 1, 18, 3 };

/*
 * variable3 ospfMultiProcessIfAuthMd5Table_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */

struct variable3 ospfMultiProcessIfAuthMd5Table_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    {OSPF_MULTI_PROCESS_IF_AUTH_MD5_ADDRESS_TYPE, ASN_INTEGER, RONLY, var_ospfMultiProcessIfAuthMd5Table, 3,
     {27, 1, 1}},
    {OSPF_MULTI_PROCESS_IF_AUTH_MD5_ADDRESS, ASN_OCTET_STR, RONLY, var_ospfMultiProcessIfAuthMd5Table, 3,
     {27, 1, 2}},
    {OSPF_MULTI_PROCESS_IF_AUTH_MD5_KEY_ID, ASN_INTEGER, RONLY, var_ospfMultiProcessIfAuthMd5Table, 3,
     {27, 1, 3}},
#endif
    {OSPF_MULTI_PROCESS_IF_AUTH_MD5_KEY, ASN_OCTET_STR, RWRITE, var_ospfMultiProcessIfAuthMd5Table, 3,
     {27, 1, 4}},
};

/** Initializes the ospfIfMetricTable module */
void init_ospfMultiProcessIfAuthMd5Table(void)
{
    /*
     * register ourselves with the agent to handle our mib tree
     */
    REGISTER_MIB("ospfMultiProcessIfAuthMd5Table", ospfMultiProcessIfAuthMd5Table_variables,
                 variable3, ospfMultiProcessIfAuthMd5Table_variables_oid);
}

oid ospfMultiProcessRouteTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,18,3 };

/* variable3 ospfMultiProcessRouteTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */
struct variable3 ospfMultiProcessRouteTable_variables[] =
{
/* magic number, variable type, ro/rw, callback fn, L, oidsuffix
 */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_ospfMultiProcessRouteDest, ASN_IPADDRESS, RONLY, var_ospfMultiProcessRouteTable, 3, { 31, 1, 1 }},
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_ospfMultiProcessRoutePfxLen, ASN_INTEGER, RONLY, var_ospfMultiProcessRouteTable, 3, { 31, 1, 2 }},
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_ospfMultiProcessRouteNexthop, ASN_IPADDRESS, RONLY, var_ospfMultiProcessRouteTable, 3, { 31, 1, 3 }},
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

    { LEAF_ospfMultiProcessRouteInterface, ASN_OCTET_STR, RONLY, var_ospfMultiProcessRouteTable, 3, { 31, 1, 4 }},
    { LEAF_ospfMultiProcessRouteCost, ASN_UNSIGNED, RONLY, var_ospfMultiProcessRouteTable, 3, { 31, 1, 5 }},
    { LEAF_ospfMultiProcessRoutePathType, ASN_INTEGER, RONLY, var_ospfMultiProcessRouteTable, 3, { 31, 1, 6 }},
    { LEAF_ospfMultiProcessRouteAreaId, ASN_IPADDRESS, RONLY, var_ospfMultiProcessRouteTable, 3, { 31, 1, 7 }},
    { LEAF_ospfMultiProcessRouteTransitArea, ASN_INTEGER, RONLY, var_ospfMultiProcessRouteTable, 3, { 31, 1, 8 }},
};

void init_ospfMultiProcessRouteTable(void)
{
    REGISTER_MIB("ospfMultiProcessRouteTable", ospfMultiProcessRouteTable_variables, variable3,
                 ospfMultiProcessRouteTable_variables_oid);
}
#endif /*end of #if(SYS_CPNT_OSPF)*/

#if(SYS_CPNT_NETACCESS == TRUE)

void
init_networkAccessMgt(void)
{
#if(SYS_CPNT_NETACCESS_AGING_MODE == SYS_CPNT_NETACCESS_AGING_MODE_CONFIGURABLE)
        static oid networkAccessAging_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1, 17, 13, 5, 0 };

        netsnmp_register_instance(netsnmp_create_handler_registration
                              ("networkAccessAging",
                               do_networkAccessAging,
                               networkAccessAging_oid,
                               OID_LENGTH(networkAccessAging_oid),
                               HANDLER_CAN_RWRITE));
#endif
}

/********************************************
 ***********networkAccessPortTable********
 ********************************************
 */
/*
 *   networkAccessPortTable_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid             networkAccessPortTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1, 17, 13 };

/*
 *   variable4 networkAccessPortTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */

struct variable3 networkAccessPortTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */
    {NETWORKACCESSPORTINDEX, ASN_INTEGER, RONLY,  var_networkAccessPortTable, 3, {2, 1, 1}},

#if (SYS_CPNT_NETACCESS_DYNAMIC_VLAN == TRUE)
    {NETWORKACCESSPORTDYNAMICVLAN, ASN_INTEGER, RWRITE, var_networkAccessPortTable, 3, {2, 1, 2}},
#endif /* #if (SYS_CPNT_NETACCESS_DYNAMIC_VLAN == TRUE) */

#if (SYS_CPNT_NETACCESS_MACAUTH == TRUE)
    {NETWORKACCESSPORTMAXMACCOUNT, ASN_INTEGER, RWRITE, var_networkAccessPortTable, 3, {2, 1, 3}},
    {NETWORKACCESSPORTMODE, ASN_INTEGER, RWRITE, var_networkAccessPortTable, 3, {2, 1, 4}},
#endif /* #if (SYS_CPNT_NETACCESS_MACAUTH == TRUE) */

#if (SYS_CPNT_NETACCESS_MAC_FILTER_TABLE == TRUE)
    {NETWORKACCESSPORTMACFILTER, ASN_INTEGER, RWRITE, var_networkAccessPortTable, 3, {2, 1, 5}},
#endif /* SYS_CPNT_NETACCESS_MAC_FILTER_TABLE */

#if(SYS_CPNT_NETACCESS_GUEST_VLAN == TRUE)
    {NETWORKACCESSPORTGUESTVLAN, ASN_INTEGER, RWRITE, var_networkAccessPortTable, 3, {2, 1, 6}},
#endif /* #if(SYS_CPNT_NETACCESS_GUEST_VLAN == TRUE) */

#if (SYS_CPNT_NETACCESS_LINK_DETECTION == TRUE)
    {NETWORKACCESSPORTLINKDETECTIONSTATUS, ASN_INTEGER, RWRITE, var_networkAccessPortTable, 3, {2, 1, 7}},
    {NETWORKACCESSPORTLINKDETECTIONMODE, ASN_INTEGER, RWRITE, var_networkAccessPortTable, 3, {2, 1, 8}},
    {NETWORKACCESSPORTLINKDETECTIONACITON, ASN_INTEGER, RWRITE, var_networkAccessPortTable, 3, {2, 1, 9}},
#endif /* #if (SYS_CPNT_NETACCESS_LINK_DETECTION == TRUE) */

#if (SYS_CPNT_NETACCESS_DYNAMIC_QOS == TRUE)
    {NETWORKACCESSPORTLINKDYNAMICQOS, ASN_INTEGER, RWRITE, var_networkAccessPortTable, 3, {2, 1, 10}},
#endif /* #if (SYS_CPNT_NETACCESS_DYNAMIC_QOS == TRUE) */
};
/*
 * (L = length of the oidsuffix)
 */


/** Initializes the networkAccessPortTable module */
void
init_networkAccessPortTable(void)
{
    /*
     * register ourselves with the agent to handle our mib tree
     */
    REGISTER_MIB("networkAccessPortConfigTable",
                 networkAccessPortTable_variables, variable3,
                 networkAccessPortTable_variables_oid);

    /*
     * place any other initialization junk you need here
     */
}

/********************************************
 *********networkAccessClearMacAddressMgt*******
 ********************************************
 */

void init_networkAccessClearMacAddressMgt(void)
{
    static oid networkAccessClearMacAddressAttribute_oid[] =   {SYS_ADPT_PRIVATEMIB_OID, 1, 17, 13, 3, 1, 0 };
    static oid networkAccessClearMacAddressMacAddress_oid[] =  {SYS_ADPT_PRIVATEMIB_OID, 1, 17, 13, 3, 2, 0 };
    static oid networkAccessClearMacAddressPort_oid[] =        {SYS_ADPT_PRIVATEMIB_OID, 1, 17, 13, 3, 3, 0 };
    static oid networkAccessClearMacAddressClearAction_oid[] = {SYS_ADPT_PRIVATEMIB_OID, 1, 17, 13, 3, 4, 0 };

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("networkAccessClearMacAddressAttribute",
                               do_networkAccessClearMacAddressAttribute,
                               networkAccessClearMacAddressAttribute_oid,
                               OID_LENGTH(networkAccessClearMacAddressAttribute_oid),
                               HANDLER_CAN_RWRITE));

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("networkAccessClearMacAddressMacAddress",
                               do_networkAccessClearMacAddressMacAddress,
                               networkAccessClearMacAddressMacAddress_oid,
                               OID_LENGTH(networkAccessClearMacAddressMacAddress_oid),
                               HANDLER_CAN_RWRITE));

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("networkAccessClearMacAddressPort",
                               do_networkAccessClearMacAddressPort,
                               networkAccessClearMacAddressPort_oid,
                               OID_LENGTH(networkAccessClearMacAddressPort_oid),
                               HANDLER_CAN_RWRITE));

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("networkAccessClearMacAddressClearAction",
                               do_networkAccessClearMacAddressClearAction,
                               networkAccessClearMacAddressClearAction_oid,
                               OID_LENGTH(networkAccessClearMacAddressClearAction_oid),
                               HANDLER_CAN_RWRITE));

}

/********************************************
 *********networkAccessMacAddressTable********
 ********************************************
 */
/*
 *   networkAccessMacAddressTable_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid             networkAccessMacAddressTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1, 17, 13 };

/*
 * variable4 networkAccessMacAddressTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */

struct variable3 networkAccessMacAddressTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */
    {NETWORKACCESSMACADDRESSADDRESS,                 ASN_OCTET_STR, RONLY, var_networkAccessMacAddressTable, 3, {4, 1, 1}},
    {NETWORKACCESSMACADDRESSPORT,                    ASN_INTEGER,   RONLY, var_networkAccessMacAddressTable, 3, {4, 1, 2}},
    {NETWORKACCESSMACADDRESSRADIUSSERVERADDRESSTYPE, ASN_INTEGER,   RONLY, var_networkAccessMacAddressTable, 3, {4, 1, 3}},
    {NETWORKACCESSMACADDRESSRADIUSSERVERADDRESS,     ASN_IPADDRESS, RONLY, var_networkAccessMacAddressTable, 3, {4, 1, 4}},
    {NETWORKACCESSMACADDRESSTIME,                    ASN_OCTET_STR, RONLY, var_networkAccessMacAddressTable, 3, {4, 1, 5}},
    {NETWORKACCESSMACADDRESSATTRIBUTE,               ASN_INTEGER,   RONLY, var_networkAccessMacAddressTable, 3, {4, 1, 6}},
};
/*
 * (L = length of the oidsuffix)
 */


/** Initializes the networkAccessMacAddressTable module */
void
init_networkAccessMacAddressTable(void)
{
    /*
     * register ourselves with the agent to handle our mib tree
     */
    REGISTER_MIB("networkAccessMacAddressTable",
                 networkAccessMacAddressTable_variables, variable3,
                 networkAccessMacAddressTable_variables_oid);

    /*
     * place any other initialization junk you need here
     */
}

#if(SYS_CPNT_NETACCESS_MAC_FILTER_TABLE== TRUE)
/********************************************
 ****networkAccessMacFilterWithMaskTable*****
 ********************************************
 */
oid networkAccessMacFilterWithMaskTable_variables_oid[] = {SYS_ADPT_PRIVATEMIB_OID, 1, 17, 13};//{ 1,3,6,1,4,1,202,20,66,1,17,13 };
/*
 * variable3 networkAccessMacFilterWithMaskTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */
struct variable3 networkAccessMacFilterWithMaskTable_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
{NETWORKACCESSMACFILTERWITHMASKID,             ASN_INTEGER,   RONLY,  var_networkAccessMacFilterWithMaskTable, 3, { 6, 1, 1 }},
{NETWORKACCESSMACFILTERWITHMASKMACADDRESS,     ASN_OCTET_STR, RONLY,  var_networkAccessMacFilterWithMaskTable, 3, { 6, 1, 2 }},
{NETWORKACCESSMACFILTERWITHMASKMACADDRESSMASK, ASN_OCTET_STR, RONLY,  var_networkAccessMacFilterWithMaskTable, 3, { 6, 1, 3 }},
#endif

{NETWORKACCESSMACFILTERWITHMASKSTATUS,         ASN_INTEGER,   RWRITE, var_networkAccessMacFilterWithMaskTable, 3, { 6, 1, 4 }},
};

/** Initializes the networkAccessMacFilterWithMaskTable module */
void
init_networkAccessMacFilterWithMaskTable(void)
{
    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("networkAccessMacFilterWithMaskTable", networkAccessMacFilterWithMaskTable_variables, variable3,
                 networkAccessMacFilterWithMaskTable_variables_oid);
}
#endif

/********************************************
 *****************macAuthMgt****************
 ********************************************
 */

void init_macAuthMgt(void)
{
    static oid macAuthReAuthTime_oid[] =      {SYS_ADPT_PRIVATEMIB_OID, 1, 17, 14, 1, 0 };

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("macAuthReAuthTime",
                               do_macAuthReAuthTime,
                               macAuthReAuthTime_oid,
                               OID_LENGTH(macAuthReAuthTime_oid),
                               HANDLER_CAN_RWRITE));

}

#if(SYS_CPNT_NETACCESS_MACAUTH==TRUE)
/********************************************
 ****************macAuthPortTable*************
 ********************************************
 */
/*
 *   macAuthPortTable_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid             macAuthPortTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1, 17, 14 };

/*
 *   variable4 macAuthPortTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */

struct variable3 macAuthPortTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */
    {MACAUTHPORTINDEX,           ASN_INTEGER, RONLY,  var_macAuthPortTable, 3, {2, 1, 1}},
    {MACAUTHPORTMAXMACCOUNT,     ASN_INTEGER, RWRITE, var_macAuthPortTable, 3, {2, 1, 2}},
    {MACAUTHPORTINTRUSIONACTION, ASN_INTEGER, RWRITE, var_macAuthPortTable, 3, {2, 1, 3}},
};
/*
 * (L = length of the oidsuffix)
 */


/** Initializes the macAuthPortTable module */
void
init_macAuthPortTable(void)
{
    /*
     * register ourselves with the agent to handle our mib tree
     */
    REGISTER_MIB("macAuthPortTable",
                 macAuthPortTable_variables, variable3,
                 macAuthPortTable_variables_oid);

    /*
     * place any other initialization junk you need here
     */
}
#endif  /* #if(SYS_CPNT_NETACCESS_MACAUTH==TRUE) */

#endif /* end of #if(SYS_CPNT_NETACCESS == TRUE) */

/********************************************
 ********************dot1xMgt***************
 ********************************************
 */
#if (SYS_CPNT_DOT1X == TRUE)

static oid             dot1xAuthConfigExtTable_variables_oid[] =
    { SYS_ADPT_PRIVATEMIB_OID, 1, 17, 11 };

/*
 * variable3 dot1xAuthConfigExtTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */

struct variable3 dot1xAuthConfigExtTable_variables[] = {

    {DOT1XAUTHCONFIGEXTOPERMODE, ASN_INTEGER, RWRITE, var_dot1xAuthConfigExtTable, 3, {1, 1, 1}},
    {DOT1XAUTHCONFIGEXTMULTIHOSTMAXCNT, ASN_INTEGER, RWRITE, var_dot1xAuthConfigExtTable, 3, {1, 1, 2}},
#if (SYS_CPNT_NETACCESS_GUEST_VLAN == TRUE)
    {DOT1XAUTHCONFIGEXTPORTINTRUSIONACTION, ASN_INTEGER, RWRITE, var_dot1xAuthConfigExtTable, 3, {1, 1, 3}},
#endif
};
/*
 * (L = length of the oidsuffix)
 */


/** Initializes the dot1xAuthConfigExtTable module */
void
init_dot1xAuthConfigExtTable(void)
{

    REGISTER_MIB("dot1xAuthConfigExtTable",
                 dot1xAuthConfigExtTable_variables, variable3,
                 dot1xAuthConfigExtTable_variables_oid);

}

#if (SYS_CPNT_DOT1X_EAPOL_PASS_THROUGH == TRUE)
/** Initializes the dot1xEapolPassThrough module */
void
init_dot1xEapolPassThrough(void)
{
    static oid dot1xEapolPassThrough_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,17,11,3,0 };

    DEBUGMSGTL(("dot1xEapolPassThrough", "Initializing\n"));

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("dot1xEapolPassThrough",
                               do_dot1xEapolPassThrough,
                               dot1xEapolPassThrough_oid,
                               OID_LENGTH(dot1xEapolPassThrough_oid),
                               HANDLER_CAN_RWRITE));
}
#endif
#endif

#if (SYS_CPNT_DVMRP == TRUE)
/********************************************
 *************dvmrpInterfaceTable************
 ********************************************
 */
void
init_dvmrpMgt(void)
{
    static oid      dvmrpNumRoutes_oid[] =
        { SYS_ADPT_PRIVATEMIB_OID, 1, 18, 4, 1, 3, 0 };
    static oid      dvmrpVersionString_oid[] =
        { SYS_ADPT_PRIVATEMIB_OID, 1, 18, 4, 1, 1, 0 };
    static oid      dvmrpReachableRoutes_oid[] =
        { SYS_ADPT_PRIVATEMIB_OID, 1, 18, 4, 1, 4, 0 };

    init_PrivateMIBNodeRootOIDbySwitchBoardID(dvmrpNumRoutes_oid);
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("dvmrpNumRoutes",
                                         get_dvmrpNumRoutes,
                                         dvmrpNumRoutes_oid,
                                         OID_LENGTH(dvmrpNumRoutes_oid),
                                         HANDLER_CAN_RONLY));
    init_PrivateMIBNodeRootOIDbySwitchBoardID(dvmrpVersionString_oid);
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("dvmrpVersionString",
                                         get_dvmrpVersionString,
                                         dvmrpVersionString_oid,
                                         OID_LENGTH
                                         (dvmrpVersionString_oid),
                                         HANDLER_CAN_RONLY));
    init_PrivateMIBNodeRootOIDbySwitchBoardID(dvmrpReachableRoutes_oid);
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("dvmrpReachableRoutes",
                                         get_dvmrpReachableRoutes,
                                         dvmrpReachableRoutes_oid,
                                         OID_LENGTH
                                         (dvmrpReachableRoutes_oid),
                                         HANDLER_CAN_RONLY));
}

/********************************************
 *************dvmrpInterfaceTable************
 ********************************************
 */
oid             dvmrpInterfaceTable_variables_oid[] =
    { SYS_ADPT_PRIVATEMIB_OID, 1, 18, 4 };

struct variable3 dvmrpInterfaceTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    {DVMRPINTERFACEINDEX, ASN_INTEGER, RONLY, var_dvmrpInterfaceTable, 3,
     {2, 1, 1}},
#endif
    {DVMRPINTERFACELOCALADDRESS, ASN_IPADDRESS, RWRITE,
     var_dvmrpInterfaceTable, 3, {2, 1, 2}},
    {DVMRPINTERFACEMETRIC, ASN_INTEGER, RWRITE, var_dvmrpInterfaceTable, 3,
     {2, 1, 3}},
    {DVMRPINTERFACESTATUS, ASN_INTEGER, RWRITE, var_dvmrpInterfaceTable, 3,
     {2, 1, 4}},
    {DVMRPINTERFACERCVBADPKTS, ASN_COUNTER, RONLY, var_dvmrpInterfaceTable,
     3, {2, 1, 5}},
    {DVMRPINTERFACERCVBADROUTES, ASN_COUNTER, RONLY,
     var_dvmrpInterfaceTable, 3, {2, 1, 6}},
    {DVMRPINTERFACESENTROUTES, ASN_COUNTER, RONLY, var_dvmrpInterfaceTable,
     3, {2, 1, 7}},
    {DVMRPINTERFACEKEY, ASN_OCTET_STR, RWRITE, var_dvmrpInterfaceTable, 3,
     {2, 1, 8}},
    {DVMRPINTERFACEKEYVERSION, ASN_INTEGER, RWRITE,
     var_dvmrpInterfaceTable, 3, {2, 1, 9}},
    {DVMRPINTERFACEGENERATIONID, ASN_INTEGER, RONLY,
     var_dvmrpInterfaceTable, 3, {2, 1, 10}},
};


/** Initializes the dvmrpInterfaceTable module */
void
init_dvmrpInterfaceTable(void)
{
    /*
     * register ourselves with the agent to handle our mib tree
     */
    init_PrivateMIBNodeRootOIDbySwitchBoardID(dvmrpInterfaceTable_variables_oid);
    REGISTER_MIB("dvmrpInterfaceTable", dvmrpInterfaceTable_variables,
                 variable3, dvmrpInterfaceTable_variables_oid);
}

/********************************************
 *************dvmrpNeighborTable*************
 ********************************************
 */
oid             dvmrpNeighborTable_variables_oid[] =
    { SYS_ADPT_PRIVATEMIB_OID, 1, 18, 4};


struct variable3 dvmrpNeighborTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    {DVMRPNEIGHBORIFINDEX, ASN_INTEGER, RONLY, var_dvmrpNeighborTable, 3,
     {3, 1, 1}},
    {DVMRPNEIGHBORADDRESS, ASN_IPADDRESS, RONLY, var_dvmrpNeighborTable, 3,
     {3, 1, 2}},
#endif
    {DVMRPNEIGHBORUPTIME, ASN_TIMETICKS, RONLY, var_dvmrpNeighborTable, 3,
     {3, 1, 3}},
    {DVMRPNEIGHBOREXPIRYTIME, ASN_TIMETICKS, RONLY, var_dvmrpNeighborTable,
     3, {3, 1, 4}},
    {DVMRPNEIGHBORGENERATIONID, ASN_INTEGER, RONLY, var_dvmrpNeighborTable,
     3, {3, 1, 5}},
    {DVMRPNEIGHBORMAJORVERSION, ASN_INTEGER, RONLY, var_dvmrpNeighborTable,
     3, {3, 1, 6}},
    {DVMRPNEIGHBORMINORVERSION, ASN_INTEGER, RONLY, var_dvmrpNeighborTable,
     3, {3, 1, 7}},
    {DVMRPNEIGHBORCAPABILITIES,ASN_OCTET_STR, RONLY, var_dvmrpNeighborTable, 3,
     {3, 1, 8}},
    {DVMRPNEIGHBORRCVROUTES, ASN_COUNTER, RONLY, var_dvmrpNeighborTable, 3,
     {3, 1, 9}},
    {DVMRPNEIGHBORRCVBADPKTS, ASN_COUNTER, RONLY, var_dvmrpNeighborTable,
     3, {3, 1, 10}},
    {DVMRPNEIGHBORRCVBADROUTES, ASN_COUNTER, RONLY, var_dvmrpNeighborTable,
     3, {3, 1, 11}},
    {DVMRPNEIGHBORSTATE, ASN_INTEGER, RONLY, var_dvmrpNeighborTable, 3,
     {3, 1, 12}},
};


/** Initializes the dvmrpNeighborTable module */
void
init_dvmrpNeighborTable(void)
{

    /*
     * register ourselves with the agent to handle our mib tree
     */
    init_PrivateMIBNodeRootOIDbySwitchBoardID(dvmrpNeighborTable_variables_oid);
    REGISTER_MIB("dvmrpNeighborTable", dvmrpNeighborTable_variables,
                 variable3, dvmrpNeighborTable_variables_oid);

}

/********************************************
 ***************dvmrpRouteTable**************
 ********************************************
 */
oid             dvmrpRouteTable_variables_oid[] =
    { SYS_ADPT_PRIVATEMIB_OID, 1, 18, 4 };

struct variable3 dvmrpRouteTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    {DVMRPROUTESOURCE, ASN_IPADDRESS, RONLY, var_dvmrpRouteTable, 3,
     {4, 1, 1}},
    {DVMRPROUTESOURCEMASK, ASN_IPADDRESS, RONLY, var_dvmrpRouteTable, 3,
     {4, 1, 2}},
#endif
    {DVMRPROUTEUPSTREAMNEIGHBOR, ASN_IPADDRESS, RONLY, var_dvmrpRouteTable,
     3, {4, 1, 3}},
    {DVMRPROUTEIFINDEX, ASN_INTEGER, RONLY, var_dvmrpRouteTable, 3,
     {4, 1, 4}},
    {DVMRPROUTEMETRIC, ASN_INTEGER, RONLY, var_dvmrpRouteTable, 3,
     {4, 1, 5}},
    {DVMRPROUTEEXPIRYTIME, ASN_TIMETICKS, RONLY, var_dvmrpRouteTable, 3,
     {4, 1, 6}},
    {DVMRPROUTEUPTIME, ASN_TIMETICKS, RONLY, var_dvmrpRouteTable, 3,
     {4, 1, 7}},
};


/** Initializes the dvmrpRouteTable module */
void
init_dvmrpRouteTable(void)
{

    /*
     * register ourselves with the agent to handle our mib tree
     */
    init_PrivateMIBNodeRootOIDbySwitchBoardID(dvmrpRouteTable_variables_oid);
    REGISTER_MIB("dvmrpRouteTable", dvmrpRouteTable_variables, variable3,
                 dvmrpRouteTable_variables_oid);

}


/********************************************
 ********dvmrpRouteNextHopTable**************
 ********************************************
 */
oid             dvmrpRouteNextHopTable_variables_oid[] =
    { SYS_ADPT_PRIVATEMIB_OID, 1, 18, 4 };



struct variable3 dvmrpRouteNextHopTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    {DVMRPROUTENEXTHOPSOURCE, ASN_IPADDRESS, RONLY,
     var_dvmrpRouteNextHopTable, 3, {5, 1, 1}},
    {DVMRPROUTENEXTHOPSOURCEMASK, ASN_IPADDRESS, RONLY,
     var_dvmrpRouteNextHopTable, 3, {5, 1, 2}},
    {DVMRPROUTENEXTHOPIFINDEX, ASN_INTEGER, RONLY,
     var_dvmrpRouteNextHopTable, 3, {5, 1, 3}},
#endif
    {DVMRPROUTENEXTHOPTYPE, ASN_INTEGER, RONLY, var_dvmrpRouteNextHopTable,
     3, {5, 1, 4}},
};


/** Initializes the dvmrpRouteNextHopTable module */
void
init_dvmrpRouteNextHopTable(void)
{

    /*
     * register ourselves with the agent to handle our mib tree
     */
    init_PrivateMIBNodeRootOIDbySwitchBoardID(dvmrpRouteNextHopTable_variables_oid);
    REGISTER_MIB("dvmrpRouteNextHopTable",
                 dvmrpRouteNextHopTable_variables, variable3,
                 dvmrpRouteNextHopTable_variables_oid);
}

/********************************************
 ************dvmrpPruneTable*****************
 ********************************************
 */
oid             dvmrpPruneTable_variables_oid[] =
    { SYS_ADPT_PRIVATEMIB_OID, 1, 18, 4};


struct variable3 dvmrpPruneTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    {DVMRPPRUNEGROUP, ASN_IPADDRESS, RONLY, var_dvmrpPruneTable, 3,
     {6, 1, 1}},
    {DVMRPPRUNESOURCE, ASN_IPADDRESS, RONLY, var_dvmrpPruneTable, 3,
     {6, 1, 2}},
    {DVMRPPRUNESOURCEMASK, ASN_IPADDRESS, RONLY, var_dvmrpPruneTable, 3,
     {6, 1, 3}},
#endif
    {DVMRPPRUNEEXPIRYTIME, ASN_TIMETICKS, RONLY, var_dvmrpPruneTable, 3,
     {6, 1, 4}},
};


/** Initializes the dvmrpPruneTable module */
void
init_dvmrpPruneTable(void)
{
    /*
     * register ourselves with the agent to handle our mib tree
     */
    init_PrivateMIBNodeRootOIDbySwitchBoardID(dvmrpPruneTable_variables_oid);
    REGISTER_MIB("dvmrpPruneTable", dvmrpPruneTable_variables, variable3,
                 dvmrpPruneTable_variables_oid);
}
#endif /*end of #if (SYS_CPNT_DVMRP==TRUE)*/

#if 0 /*These functions will be implemented in future -- xiongyu 20090112*/
#if (SYS_CPNT_OSPF == TRUE)
/********************************************
 **************ipCidrRouteExtTable***********
 ********************************************
 */
oid             ipCidrRouteExtTable_variables_oid[] =
    { SYS_ADPT_PRIVATEMIB_OID, 1, 18, 5};

struct variable3 ipCidrRouteExtTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    {IPCIDRROUTEEXTDEST, ASN_IPADDRESS, RONLY, var_ipCidrRouteExtTable, 3,
     {2, 1, 1}},
    {IPCIDRROUTEEXTMASK, ASN_IPADDRESS, RONLY, var_ipCidrRouteExtTable, 3,
     {2, 1, 2}},
    {IPCIDRROUTEEXTTOS, ASN_INTEGER, RONLY, var_ipCidrRouteExtTable, 3,
     {2, 1, 3}},
    {IPCIDRROUTEEXTNEXTHOP, ASN_IPADDRESS, RONLY, var_ipCidrRouteExtTable,
     3, {2, 1, 4}},
#endif
    {IPCIDRROUTEEXTOSPFSUBTYPE, ASN_INTEGER, RONLY,
     var_ipCidrRouteExtTable, 3, {2, 1, 5}},
};


/** Initializes the ipCidrRouteExtTable module */
void
init_ipCidrRouteExtTable(void)
{
    /*
     * register ourselves with the agent to handle our mib tree
     */
    init_PrivateMIBNodeRootOIDbySwitchBoardID(ipCidrRouteExtTable_variables_oid);
    REGISTER_MIB("ipCidrRouteExtTable", ipCidrRouteExtTable_variables,
                 variable3, ipCidrRouteExtTable_variables_oid);
}
#endif /*end of #if (SYS_CPNT_OSPF==TRUE)*/
#endif

#if (SYS_CPNT_NSM == TRUE)
void
init_routeMultipath(void)
{
    static oid      routeMultipath_oid[] =
        { SYS_ADPT_PRIVATEMIB_OID, 1, 18, 5, 3, 0 };

    init_PrivateMIBNodeRootOIDbySwitchBoardID(routeMultipath_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("routeMultipath",
                               do_routeMultipath,
                               routeMultipath_oid,
                               OID_LENGTH(routeMultipath_oid),
                               HANDLER_CAN_RWRITE));
}
#endif /* SYS_CPNT_NSM */


/********************************************
 **************aaaMgt************************
 ********************************************
 */
#if (SYS_CPNT_AAA == TRUE)
#if (SYS_CPNT_ACCOUNTING == TRUE) /*maggie liu, 2009-03-09*/
void
init_aaaMgt(void)
{
    static oid      aaaUpdate_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1, 17, 12, 4, 0 };
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("aaaUpdate",
                               do_aaaUpdate,
                               aaaUpdate_oid,
                               OID_LENGTH(aaaUpdate_oid),
                               HANDLER_CAN_RWRITE));
}

/********************************************
 **************aaaMethodTable****************
 ********************************************
 */
oid   aaaMethodTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1, 17, 12 };

struct variable3 aaaMethodTable_variables[] = {

    {AAAMETHODINDEX,      ASN_INTEGER,   RONLY,  var_aaaMethodTable, 3, {1, 1, 1}},
    {AAAMETHODNAME,       ASN_OCTET_STR, RWRITE, var_aaaMethodTable, 3, {1, 1, 2}},
    {AAAMETHODGROUPNAME,  ASN_OCTET_STR, RWRITE, var_aaaMethodTable, 3, {1, 1, 3}},
    {AAAMETHODMODE,       ASN_INTEGER,   RWRITE, var_aaaMethodTable, 3, {1, 1, 4}},
    {AAAMETHODSTATUS,     ASN_INTEGER,   RWRITE, var_aaaMethodTable, 3, {1, 1, 5}},
    {AAAMETHODCLIENTTYPE, ASN_INTEGER,   RWRITE, var_aaaMethodTable, 3, {1, 1, 6}},
#if (SYS_CPNT_ACCOUNTING_COMMAND == TRUE)
    {AAAMETHODCOMMANDPRIVILEGESLEVEL, ASN_INTEGER,   RWRITE, var_aaaMethodTable, 3, {1, 1, 7}},
#endif /* (SYS_CPNT_ACCOUNTING_COMMAND == TRUE) */
};

void
init_aaaMethodTable(void)
{

    DEBUGMSGTL(("aaaMethodTable", "Initializing\n"));
    REGISTER_MIB("aaaMethodTable", aaaMethodTable_variables, variable3,
                 aaaMethodTable_variables_oid);
}
#if (SYS_CPNT_RADIUS_ACCOUNTING==TRUE)
/********************************************
 **************aaaRadiusGroupTable***********
 ********************************************
 */
oid   aaaRadiusGroupTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1, 17, 12 };

struct variable3 aaaRadiusGroupTable_variables[] = {

    {AAARADIUSGROUPINDEX,   ASN_INTEGER,   RONLY,  var_aaaRadiusGroupTable, 3, {2, 1, 1}},
    {AAARADIUSGROUPSERVERBITMAP,ASN_OCTET_STR, RWRITE, var_aaaRadiusGroupTable, 3, {2, 1, 2}},
    {AAARADIUSGROUPNAME,    ASN_OCTET_STR, RWRITE, var_aaaRadiusGroupTable, 3, {2, 1, 3}},
    {AAARADIUSGROUPSTATUS,  ASN_INTEGER,   RWRITE, var_aaaRadiusGroupTable, 3, {2, 1, 4}},
};

void
init_aaaRadiusGroupTable(void)
{
    DEBUGMSGTL(("aaaRadiusGroupTable", "Initializing\n"));
    REGISTER_MIB("aaaRadiusGroupTable", aaaRadiusGroupTable_variables,
                 variable3, aaaRadiusGroupTable_variables_oid);
}
#endif /*end of #if (SYS_CPNT_RADIUS_ACCOUNTING==TRUE)*/

#if (SYS_CPNT_TACACS_PLUS_ACCOUNTING==TRUE)
/********************************************
 **************aaaTacacsPlusGroupTable*******
 ********************************************
 */
oid   aaaTacacsPlusGroupTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1, 17, 12 };

struct variable3 aaaTacacsPlusGroupTable_variables[] = {

    {AAATACACSPLUSGROUPINDEX,        ASN_INTEGER,   RONLY,  var_aaaTacacsPlusGroupTable, 3, {3, 1, 1}},
    {AAATACACSPLUSGROUPSERVERBITMAP, ASN_OCTET_STR, RWRITE, var_aaaTacacsPlusGroupTable, 3, {3, 1, 2}},
    {AAATACACSPLUSGROUPNAME,         ASN_OCTET_STR, RWRITE, var_aaaTacacsPlusGroupTable, 3, {3, 1, 3}},
    {AAATACACSPLUSGROUPSTATUS,       ASN_INTEGER,   RWRITE, var_aaaTacacsPlusGroupTable, 3, {3, 1, 4}},
};

void
init_aaaTacacsPlusGroupTable(void)
{
    DEBUGMSGTL(("aaaTacacsPlusGroupTable", "Initializing\n"));
    REGISTER_MIB("aaaTacacsPlusGroupTable",
                 aaaTacacsPlusGroupTable_variables, variable3,
                 aaaTacacsPlusGroupTable_variables_oid);
}
#endif /*end of #if (SYS_CPNT_TACACS_PLUS_ACCOUNTING==TRUE)*/

#if (SYS_CPNT_ACCOUNTING == TRUE) /*maggie liu, 2009-03-09*/
/********************************************
 **************aaaAccountTable***************
 ********************************************
 */
oid  aaaAccountTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1, 17, 12 };

struct variable3 aaaAccountTable_variables[] = {

    {AAAACCOUNTIFINDEX,    ASN_INTEGER,   RONLY,  var_aaaAccountTable, 3, {5, 1, 1}},
    {AAAACCOUNTMETHODNAME, ASN_OCTET_STR, RWRITE, var_aaaAccountTable, 3, {5, 1, 2}},
    {AAAACCOUNTPROTOCOL,   ASN_INTEGER,   RONLY,  var_aaaAccountTable, 3, {5, 1, 3}},
    {AAAACCOUNTSTATUS,     ASN_INTEGER,   RWRITE, var_aaaAccountTable, 3, {5, 1, 4}},
};

void
init_aaaAccountTable(void)
{

    DEBUGMSGTL(("aaaAccountTable", "Initializing\n"));
    REGISTER_MIB("aaaAccountTable", aaaAccountTable_variables, variable3,
                 aaaAccountTable_variables_oid);
}
#endif

#if (SYS_CPNT_ACCOUNTING_COMMAND == TRUE)
/********************************************
 **********aaaCommandPrivilegesTable**********
 ********************************************
 */
oid  aaaCommandPrivilegesTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1, 17, 12 };

struct variable3 aaaCommandPrivilegesTable_variables[] = {

    {AAACOMMANDPRIVILEGESLEVELINDEX,     ASN_INTEGER,   RONLY,  var_aaaCommandPrivilegesTable, 3, {8, 1, 1}},
    {AAACOMMANDPRIVILEGESINTERFACEINDEX, ASN_INTEGER,   RONLY,  var_aaaCommandPrivilegesTable, 3, {8, 1, 2}},
    {AAACOMMANDPRIVILEGESMETHODNAME,     ASN_OCTET_STR, RWRITE, var_aaaCommandPrivilegesTable, 3, {8, 1, 3}},
};

void
init_aaaCommandPrivilegesTable(void)
{

    DEBUGMSGTL(("aaaCommandPrivilegesTable", "Initializing\n"));
    REGISTER_MIB("aaaCommandPrivilegesTable", aaaCommandPrivilegesTable_variables, variable3,
                 aaaCommandPrivilegesTable_variables_oid);
}
#endif /* end of #if (SYS_CPNT_ACCOUNTING_COMMAND == TRUE) */

/********************************************
***************aaaAccExecTable***************
 ********************************************
 */
oid  aaaAccExecTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1, 17, 12 };

struct variable3 aaaAccExecTable_variables[] = {

    {AAAACCEXECINDEX,      ASN_INTEGER,   RONLY,  var_aaaAccExecTable, 3, {9, 1, 1}},
    {AAAACCEXECMETHODNAME, ASN_OCTET_STR, RWRITE, var_aaaAccExecTable, 3, {9, 1, 2}},
};

void
init_aaaAccExecTable(void)
{

    DEBUGMSGTL(("aaaAccExecTable", "Initializing\n"));
    REGISTER_MIB("aaaAccExecTable", aaaAccExecTable_variables, variable3,
                 aaaAccExecTable_variables_oid);
}
#endif /* end of #if (SYS_CPNT_ACCOUNTING == TRUE) */
#endif /* end of #if (SYS_CPNT_AAA == TRUE) */

#if (SYS_CPNT_WEBAUTH == TRUE)
/********************************************
 *******************webAuthMgt***************
 ********************************************
 */
void
init_webAuthMgt(void)
{
    static oid webAuthSystemAuthControl_oid[] =   { SYS_ADPT_PRIVATEMIB_OID, 1, 17, 15, 1, 0 };
#if 0 /* doesn't support presently*/
    static oid webAuthLoginPageUrl_oid[] =        { SYS_ADPT_PRIVATEMIB_OID, 1, 17, 15, 2, 0 };
    static oid webAuthLoginFailPageUrl_oid[] =    { SYS_ADPT_PRIVATEMIB_OID, 1, 17, 15, 3, 0 };
    static oid webAuthLoginSuccessPageUrl_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1, 17, 15, 4, 0 };
#endif
    static oid webAuthSessionTimeout_oid[] =      { SYS_ADPT_PRIVATEMIB_OID, 1, 17, 15, 5, 0 };
    static oid webAuthQuietPeriod_oid[] =         { SYS_ADPT_PRIVATEMIB_OID, 1, 17, 15, 6, 0 };
    static oid webAuthLoginAttempts_oid[] =       { SYS_ADPT_PRIVATEMIB_OID, 1, 17, 15, 7, 0 };


    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("webAuthSystemAuthControl",
                               do_webAuthSystemAuthControl,
                               webAuthSystemAuthControl_oid,
                               OID_LENGTH(webAuthSystemAuthControl_oid),
                               HANDLER_CAN_RWRITE));
#if 0 /* doesn't support presently*/
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("webAuthLoginPageUrl",
                               do_webAuthLoginPageUrl,
                               webAuthLoginPageUrl_oid,
                               OID_LENGTH(webAuthLoginPageUrl_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("webAuthLoginFailPageUrl",
                               do_webAuthLoginFailPageUrl,
                               webAuthLoginFailPageUrl_oid,
                               OID_LENGTH(webAuthLoginFailPageUrl_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("webAuthLoginSuccessPageUrl",
                               do_webAuthLoginSuccessPageUrl,
                               webAuthLoginSuccessPageUrl_oid,
                               OID_LENGTH(webAuthLoginSuccessPageUrl_oid),
                               HANDLER_CAN_RWRITE));
#endif
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("webAuthSessionTimeout",
                               do_webAuthSessionTimeout,
                               webAuthSessionTimeout_oid,
                               OID_LENGTH(webAuthSessionTimeout_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("webAuthQuietPeriod",
                               do_webAuthQuietPeriod,
                               webAuthQuietPeriod_oid,
                               OID_LENGTH(webAuthQuietPeriod_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("webAuthLoginAttempts",
                               do_webAuthLoginAttempts,
                               webAuthLoginAttempts_oid,
                               OID_LENGTH(webAuthLoginAttempts_oid),
                               HANDLER_CAN_RWRITE));

}


/********************************************
 ***********webAuthReauthenticateMgt***********
 ********************************************
 */
void
init_webAuthReauthenticateMgt(void)
{
    static oid webAuthReauthenticatePort_oid[] =          { SYS_ADPT_PRIVATEMIB_OID, 1, 17, 15, 8, 1, 0 };
    static oid webAuthReauthenticateInetAddressType_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1, 17, 15, 8, 2, 0 };
    static oid webAuthReauthenticateInetAddress_oid[] =     { SYS_ADPT_PRIVATEMIB_OID, 1, 17, 15, 8, 3, 0 };
    static oid webAuthReauthenticateAction_oid[] =        { SYS_ADPT_PRIVATEMIB_OID, 1, 17, 15, 8, 4, 0 };

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("webAuthReauthenticatePort",
                               do_webAuthReauthenticatePort,
                               webAuthReauthenticatePort_oid,
                               OID_LENGTH(webAuthReauthenticatePort_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("webAuthReauthenticateInetAddressType",
                               do_webAuthReauthenticateInetAddressType,
                               webAuthReauthenticateInetAddressType_oid,
                               OID_LENGTH(webAuthReauthenticateInetAddressType_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("webAuthReauthenticateInetAddress",
                               do_webAuthReauthenticateInetAddress,
                               webAuthReauthenticateInetAddress_oid,
                               OID_LENGTH(webAuthReauthenticateInetAddress_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("webAuthReauthenticateAction",
                               do_webAuthReauthenticateAction,
                               webAuthReauthenticateAction_oid,
                               OID_LENGTH(webAuthReauthenticateAction_oid),
                               HANDLER_CAN_RWRITE));

}

/********************************************
 **************webAuthPortConfigTable**********
 ********************************************
 */
oid   webAuthPortConfigTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1, 17, 15 };

struct variable3 webAuthPortConfigTable_variables[] = {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    {WEBAUTHPORTCONFIGPORTINDEX,              ASN_INTEGER, RONLY,  var_webAuthPortConfigTable, 3, {9, 1, 1}},
#endif
    {WEBAUTHPORTCONFIGSTATUS,                 ASN_INTEGER, RWRITE, var_webAuthPortConfigTable, 3, {9, 1, 2}},
    {WEBAUTHPORTCONFIGAUTHENTICATEDHOSTCOUNT, ASN_INTEGER, RONLY,  var_webAuthPortConfigTable, 3, {9, 1, 3}},
};

void
init_webAuthPortConfigTable(void)
{
    DEBUGMSGTL(("webAuthPortConfigTable", "Initializing\n"));
    REGISTER_MIB("webAuthPortConfigTable",
                 webAuthPortConfigTable_variables, variable3,
                 webAuthPortConfigTable_variables_oid);
}

/********************************************
 **************webAuthPortInfoTable************
 ********************************************
 */
oid webAuthPortInfoTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,17,15 };

/* variable3 webAuthPortInfoTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */
struct variable3 webAuthPortInfoTable_variables[] =
{
/* magic number, variable type, ro/rw, callback fn, L, oidsuffix
 */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_webAuthPortInfoPortIndex, ASN_INTEGER, RONLY, var_webAuthPortInfoTable, 3, { 10, 1, 1 }},
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_webAuthPortInfoPortAuthSuccessIndex, ASN_INTEGER, RONLY, var_webAuthPortInfoTable, 3, { 10, 1, 2 }},
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

    { LEAF_webAuthPortInfoInetAddressType, ASN_INTEGER, RONLY, var_webAuthPortInfoTable, 3, { 10, 1, 3 }},
    { LEAF_webAuthPortInfoInetAddress, ASN_OCTET_STR, RONLY, var_webAuthPortInfoTable, 3, { 10, 1, 4 }},
    { LEAF_webAuthPortInfoRemainingSessiontime, ASN_INTEGER, RONLY, var_webAuthPortInfoTable, 3, { 10, 1, 5 }},
    { LEAF_webAuthPortInfoStatus, ASN_INTEGER, RONLY, var_webAuthPortInfoTable, 3, { 10, 1, 6 }},
};

void
init_webAuthPortInfoTable(void)
{
    DEBUGMSGTL(("webAuthPortInfoTable", "Initializing\n"));
    REGISTER_MIB("webAuthPortInfoTable",
                 webAuthPortInfoTable_variables, variable3,
                 webAuthPortInfoTable_variables_oid);
}

#endif /*end of #if (SYS_CPNT_WEBAUTH == TRUE)*/

#if (SYS_CPNT_DOS == TRUE)
/********************************************
 ******************dosMgt********************
 ********************************************
 */
void init_dosMgt(void)
{
    #if (SYS_CPNT_DOS_ECHO_CHARGEN == TRUE)
    {
        static oid dosEchoChargenStatus_oid[] =
            { SYS_ADPT_PRIVATEMIB_OID, 1, 17, 16, 1, 1, 1, 0 };
        static oid dosEchoChargenRateLimitInKilo_oid[] =
            { SYS_ADPT_PRIVATEMIB_OID, 1, 17, 16, 1, 1, 2, 0 };

        netsnmp_register_instance(netsnmp_create_handler_registration
                                  ("dosEchoChargenStatus",
                                   do_dosEchoChargenStatus,
                                   dosEchoChargenStatus_oid,
                                   OID_LENGTH(dosEchoChargenStatus_oid),
                                   HANDLER_CAN_RWRITE));

        netsnmp_register_instance(netsnmp_create_handler_registration
                                  ("dosEchoChargenRateLimitInKilo",
                                   do_dosEchoChargenRateLimitInKilo,
                                   dosEchoChargenRateLimitInKilo_oid,
                                   OID_LENGTH(dosEchoChargenRateLimitInKilo_oid),
                                   HANDLER_CAN_RWRITE));
    }
    #endif

    #if (SYS_CPNT_DOS_LAND == TRUE)
    {
        static oid dosLandStatus_oid[] =
            { SYS_ADPT_PRIVATEMIB_OID, 1, 17, 16, 1, 2, 1, 0 };

        netsnmp_register_instance(netsnmp_create_handler_registration
                                  ("dosLandStatus",
                                   do_dosLandStatus,
                                   dosLandStatus_oid,
                                   OID_LENGTH(dosLandStatus_oid),
                                   HANDLER_CAN_RWRITE));
    }
    #endif

    #if (SYS_CPNT_DOS_SMURF == TRUE)
    {
        static oid dosSmurfStatus_oid[] =
            { SYS_ADPT_PRIVATEMIB_OID, 1, 17, 16, 1, 3, 1, 0 };

        netsnmp_register_instance(netsnmp_create_handler_registration
                                  ("dosSmurfStatus",
                                   do_dosSmurfStatus,
                                   dosSmurfStatus_oid,
                                   OID_LENGTH(dosSmurfStatus_oid),
                                   HANDLER_CAN_RWRITE));
    }
    #endif

    #if (SYS_CPNT_DOS_TCP_FLOODING == TRUE)
    {
        static oid dosTcpFloodingStatus_oid[] =
            { SYS_ADPT_PRIVATEMIB_OID, 1, 17, 16, 1, 4, 1, 0 };
        static oid dosTcpFloodingRateLimitInKilo_oid[] =
            { SYS_ADPT_PRIVATEMIB_OID, 1, 17, 16, 1, 4, 2, 0 };

        netsnmp_register_instance(netsnmp_create_handler_registration
                                  ("dosTcpFloodingStatus",
                                   do_dosTcpFloodingStatus,
                                   dosTcpFloodingStatus_oid,
                                   OID_LENGTH(dosTcpFloodingStatus_oid),
                                   HANDLER_CAN_RWRITE));

        netsnmp_register_instance(netsnmp_create_handler_registration
                                  ("dosTcpFloodingRateLimitInKilo",
                                   do_dosTcpFloodingRateLimitInKilo,
                                   dosTcpFloodingRateLimitInKilo_oid,
                                   OID_LENGTH(dosTcpFloodingRateLimitInKilo_oid),
                                   HANDLER_CAN_RWRITE));
    }
    #endif

    #if (SYS_CPNT_DOS_TCP_NULL_SCAN == TRUE)
    {
        static oid dosTcpNullScanStatus_oid[] =
            { SYS_ADPT_PRIVATEMIB_OID, 1, 17, 16, 1, 5, 1, 0 };

        netsnmp_register_instance(netsnmp_create_handler_registration
                                  ("dosTcpNullScanStatus",
                                   do_dosTcpNullScanStatus,
                                   dosTcpNullScanStatus_oid,
                                   OID_LENGTH(dosTcpNullScanStatus_oid),
                                   HANDLER_CAN_RWRITE));
    }
    #endif

    #if (SYS_CPNT_DOS_TCP_SYN_FIN_SCAN == TRUE)
    {
        static oid dosTcpSynFinScanStatus_oid[] =
            { SYS_ADPT_PRIVATEMIB_OID, 1, 17, 16, 1, 6, 1, 0 };

        netsnmp_register_instance(netsnmp_create_handler_registration
                                  ("dosTcpSynFinScanStatus",
                                   do_dosTcpSynFinScanStatus,
                                   dosTcpSynFinScanStatus_oid,
                                   OID_LENGTH(dosTcpSynFinScanStatus_oid),
                                   HANDLER_CAN_RWRITE));
    }
    #endif

    #if (SYS_CPNT_DOS_TCP_XMAS_SCAN == TRUE)
    {
        static oid dosTcpXmasScanStatus_oid[] =
            { SYS_ADPT_PRIVATEMIB_OID, 1, 17, 16, 1, 7, 1, 0 };

        netsnmp_register_instance(netsnmp_create_handler_registration
                                  ("dosTcpXmasScanStatus",
                                   do_dosTcpXmasScanStatus,
                                   dosTcpXmasScanStatus_oid,
                                   OID_LENGTH(dosTcpXmasScanStatus_oid),
                                   HANDLER_CAN_RWRITE));
    }
    #endif

    #if (SYS_CPNT_DOS_UDP_FLOODING == TRUE)
    {
        static oid dosUdpFloodingStatus_oid[] =
            { SYS_ADPT_PRIVATEMIB_OID, 1, 17, 16, 1, 8, 1, 0 };
        static oid dosUdpFloodingRateLimitInKilo_oid[] =
            { SYS_ADPT_PRIVATEMIB_OID, 1, 17, 16, 1, 8, 2, 0 };

        netsnmp_register_instance(netsnmp_create_handler_registration
                                  ("dosUdpFloodingStatus",
                                   do_dosUdpFloodingStatus,
                                   dosUdpFloodingStatus_oid,
                                   OID_LENGTH(dosUdpFloodingStatus_oid),
                                   HANDLER_CAN_RWRITE));

        netsnmp_register_instance(netsnmp_create_handler_registration
                                  ("dosUdpFloodingRateLimitInKilo",
                                   do_dosUdpFloodingRateLimitInKilo,
                                   dosUdpFloodingRateLimitInKilo_oid,
                                   OID_LENGTH(dosUdpFloodingRateLimitInKilo_oid),
                                   HANDLER_CAN_RWRITE));
    }
    #endif

    #if (SYS_CPNT_DOS_WIN_NUKE == TRUE)
    {
        static oid dosWinNukeStatus_oid[] =
            { SYS_ADPT_PRIVATEMIB_OID, 1, 17, 16, 1, 9, 1, 0 };
        static oid dosWinNukeRateLimitInKilo_oid[] =
            { SYS_ADPT_PRIVATEMIB_OID, 1, 17, 16, 1, 9, 2, 0 };

        netsnmp_register_instance(netsnmp_create_handler_registration
                                  ("dosWinNukeStatus",
                                   do_dosWinNukeStatus,
                                   dosWinNukeStatus_oid,
                                   OID_LENGTH(dosWinNukeStatus_oid),
                                   HANDLER_CAN_RWRITE));

        netsnmp_register_instance(netsnmp_create_handler_registration
                                  ("dosWinNukeRateLimitInKilo",
                                   do_dosWinNukeRateLimitInKilo,
                                   dosWinNukeRateLimitInKilo_oid,
                                   OID_LENGTH(dosWinNukeRateLimitInKilo_oid),
                                   HANDLER_CAN_RWRITE));
    }
    #endif

    #if (SYS_CPNT_DOS_TCP_SCAN == TRUE)
    {
        static oid dosTcpScanStatus_oid[] =
            { SYS_ADPT_PRIVATEMIB_OID, 1, 17, 16, 1, 10, 1, 0 };

        netsnmp_register_instance(netsnmp_create_handler_registration
                                  ("dosTcpScanStatus",
                                   do_dosTcpScanStatus,
                                   dosTcpScanStatus_oid,
                                   OID_LENGTH(dosTcpScanStatus_oid),
                                   HANDLER_CAN_RWRITE));
    }
    #endif
}
#endif /* (SYS_CPNT_DOS == TRUE) */


#if (SYS_CPNT_APP_FILTER == TRUE)
/********************************************
 ***************appFilterMgt*****************
 ********************************************/

/********************************************
 ************appFilterPortTable**************
 ********************************************/
oid             appFilterPortTable_variables_oid[] =
    {  SYS_ADPT_PRIVATEMIB_OID, 1, 17, 17 };

struct variable3 appFilterPortTable_variables[] = {
    /*
     * magic number,   variable type,   ro/rw,            callback fn, L, oidsuffix
     */
    {APPFILTERPKTSTATUS, ASN_INTEGER,  RWRITE, var_appFilterPortTable, 3, {1, 1, 3}},
};
/*
 * (L = length of the oidsuffix)
 */

/** Initializes the appFilterPortTable module */
void
init_appFilterPortTable(void)
{
    DEBUGMSGTL(("appFilterPortTable", "Initializing\n"));

    /*
     * register ourselves with the agent to handle our mib tree
     */
    REGISTER_MIB("appFilterPortTable", appFilterPortTable_variables,
                 variable3, appFilterPortTable_variables_oid);
}
#endif /* (SYS_CPNT_APP_FILTER == TRUE) */

/********************************************
 ********************sysLogMgt***************
 ********************************************
 */
#if (SYS_CPNT_SYSLOG == TRUE)
void
init_sysLogMgt(void)
{
    static oid sysLogHistoryFlashLevel_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,19,2, 0 };
    static oid sysLogHistoryRamLevel_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,19,3, 0 };
    static oid sysLogStatus_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,19,1, 0 };
    #if 0
    static oid sysLogLoggingInterval_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,19,4, 0 };
    static oid remoteLogFacilityType_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,19,6,3, 0 };
    static oid remoteLogLevel_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,19,6,2, 0 };
    static oid sysLogLoggingCount_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,19,5, 0 };
    static oid remoteLogStatus_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,19,6,1, 0 };
    #endif

    init_PrivateMIBNodeRootOIDbySwitchBoardID(sysLogHistoryFlashLevel_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("sysLogHistoryFlashLevel",
                               do_sysLogHistoryFlashLevel,
                               sysLogHistoryFlashLevel_oid,
                               OID_LENGTH(sysLogHistoryFlashLevel_oid),
                               HANDLER_CAN_RWRITE));
    init_PrivateMIBNodeRootOIDbySwitchBoardID(sysLogHistoryRamLevel_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("sysLogHistoryRamLevel",
                               do_sysLogHistoryRamLevel,
                               sysLogHistoryRamLevel_oid,
                               OID_LENGTH(sysLogHistoryRamLevel_oid),
                               HANDLER_CAN_RWRITE));
    init_PrivateMIBNodeRootOIDbySwitchBoardID(sysLogStatus_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("sysLogStatus",
                               do_sysLogStatus,
                               sysLogStatus_oid,
                               OID_LENGTH(sysLogStatus_oid),
                               HANDLER_CAN_RWRITE));
   #if 0
    init_PrivateMIBNodeRootOIDbySwitchBoardID(sysLogLoggingCount_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("sysLogLoggingCount",
                               do_sysLogLoggingCount,
                               sysLogLoggingCount_oid,
                               OID_LENGTH(sysLogLoggingCount_oid),
                               HANDLER_CAN_RWRITE));
    init_PrivateMIBNodeRootOIDbySwitchBoardID(remoteLogStatus_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("remoteLogStatus",
                               do_remoteLogStatus,
                               remoteLogStatus_oid,
                               OID_LENGTH(remoteLogStatus_oid),
                               HANDLER_CAN_RWRITE));
    init_PrivateMIBNodeRootOIDbySwitchBoardID(sysLogLoggingInterval_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("sysLogLoggingInterval",
                               do_sysLogLoggingInterval,
                               sysLogLoggingInterval_oid,
                               OID_LENGTH(sysLogLoggingInterval_oid),
                               HANDLER_CAN_RWRITE));
    init_PrivateMIBNodeRootOIDbySwitchBoardID(remoteLogFacilityType_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("remoteLogFacilityType",
                               do_remoteLogFacilityType,
                               remoteLogFacilityType_oid,
                               OID_LENGTH(remoteLogFacilityType_oid),
                               HANDLER_CAN_RWRITE));
    init_PrivateMIBNodeRootOIDbySwitchBoardID(remoteLogLevel_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("remoteLogLevel",
                               do_remoteLogLevel,
                               remoteLogLevel_oid,
                               OID_LENGTH(remoteLogLevel_oid),
                               HANDLER_CAN_RWRITE));
       #endif
}
#endif



/********************************************
 *****************remoteLogMgt***************
 ********************************************
 */
#if (SYS_CPNT_REMOTELOG == TRUE)

void
init_remoteLogMgt(void)
{
    static oid      remoteLogStatus_oid[] =
        { SYS_ADPT_PRIVATEMIB_OID, 1, 19, 6, 1, 0 };
    static oid      remoteLogFacilityType_oid[] =
        { SYS_ADPT_PRIVATEMIB_OID, 1, 19, 6, 3, 0 };
    static oid      remoteLogLevel_oid[] =
        { SYS_ADPT_PRIVATEMIB_OID, 1, 19, 6, 2, 0 };

    init_PrivateMIBNodeRootOIDbySwitchBoardID(remoteLogStatus_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("remoteLogStatus",
                               do_remoteLogStatus,
                               remoteLogStatus_oid,
                               OID_LENGTH(remoteLogStatus_oid),
                               HANDLER_CAN_RWRITE));
    init_PrivateMIBNodeRootOIDbySwitchBoardID(remoteLogFacilityType_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("remoteLogFacilityType",
                               do_remoteLogFacilityType,
                               remoteLogFacilityType_oid,
                               OID_LENGTH(remoteLogFacilityType_oid),
                               HANDLER_CAN_RWRITE));
    init_PrivateMIBNodeRootOIDbySwitchBoardID(remoteLogLevel_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("remoteLogLevel",
                               do_remoteLogLevel,
                               remoteLogLevel_oid,
                               OID_LENGTH(remoteLogLevel_oid),
                               HANDLER_CAN_RWRITE));
}

/********************************************
 ***********remoteLogServerInetTable*********
 ********************************************
 */
oid remoteLogServerInetTable_variables_oid[] =
    { SYS_ADPT_PRIVATEMIB_OID, 1, 19, 6 };

struct variable3 remoteLogServerInetTable_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    {LEAF_remoteLogServerInetAddressType,  ASN_INTEGER,  RONLY, var_remoteLogServerInetTable, 3,  { 7, 1, 1 }},
    {LEAF_remoteLogServerInetAddress,  ASN_OCTET_STR,  RONLY, var_remoteLogServerInetTable, 3,  { 7, 1, 2 }},
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */
    {LEAF_remoteLogServerStatus,  ASN_INTEGER,  RWRITE, var_remoteLogServerInetTable, 3,  { 7, 1, 3 }},
    {LEAF_remoteLogServerUdpPort,  ASN_INTEGER, RWRITE, var_remoteLogServerInetTable, 3,  { 7, 1, 4 }},
#if (SYS_CPNT_REMOTELOG_FACILITY_LEVEL_FOR_EVERY_SERVER == TRUE)
    { LEAF_remoteLogServerFacilityType, ASN_INTEGER, RWRITE, var_remoteLogServerInetTable, 3, { 7, 1, 5 }},
    { LEAF_remoteLogServerHostLevel, ASN_UNSIGNED, RWRITE, var_remoteLogServerInetTable, 3, { 7, 1, 6 }},
#endif
};

/** Initializes the remoteLogServerInetTable module */
void
init_remoteLogServerInetTable(void)
{
    /* register ourselves with the agent to handle our mib tree */
    init_PrivateMIBNodeRootOIDbySwitchBoardID(remoteLogServerInetTable_variables_oid);
    REGISTER_MIB("remoteLogServerInetTable", remoteLogServerInetTable_variables, variable3,
                 remoteLogServerInetTable_variables_oid);
}
#endif/*(SYS_CPNT_REMOTELOG == TRUE)*/

/********************************************
 ***************smtpMgt**********************
 ********************************************
 */
#if (SYS_CPNT_SMTP == TRUE)

void
init_smtpMgt(void)
{
    static oid      smtpStatus_oid[] =
        { SYS_ADPT_PRIVATEMIB_OID, 1, 19, 7, 1, 0 };
    static oid      smtpSeverityLevel_oid[] =
        { SYS_ADPT_PRIVATEMIB_OID, 1, 19, 7, 2, 0 };
    static oid      smtpSourceEMail_oid[] =
        { SYS_ADPT_PRIVATEMIB_OID, 1, 19, 7, 3, 0 };

    init_PrivateMIBNodeRootOIDbySwitchBoardID(smtpStatus_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("smtpStatus",
                               do_smtpStatus,
                               smtpStatus_oid,
                               OID_LENGTH(smtpStatus_oid),
                               HANDLER_CAN_RWRITE));
    init_PrivateMIBNodeRootOIDbySwitchBoardID(smtpSeverityLevel_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("smtpSeverityLevel",
                               do_smtpSeverityLevel,
                               smtpSeverityLevel_oid,
                               OID_LENGTH(smtpSeverityLevel_oid),
                               HANDLER_CAN_RWRITE));
    init_PrivateMIBNodeRootOIDbySwitchBoardID(smtpSourceEMail_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("smtpSourceEMail",
                               do_smtpSourceEMail,
                               smtpSourceEMail_oid,
                               OID_LENGTH(smtpSourceEMail_oid),
                               HANDLER_CAN_RWRITE));
}



/********************************************
 ***************smtpServerIpTable************
 ********************************************
 */
oid             smtpServerIpTable_variables_oid[] =
    { SYS_ADPT_PRIVATEMIB_OID, 1, 19, 7};

struct variable3 smtpServerIpTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    {SMTPSERVERIP, ASN_IPADDRESS, RONLY, var_smtpServerIpTable, 3,
     {4, 1, 1}},
#endif
    {SMTPSERVERIPSTATUS, ASN_INTEGER, RWRITE, var_smtpServerIpTable, 3,
     {4, 1, 2}},
};

/** Initializes the smtpServerIpTable module */
void
init_smtpServerIpTable(void)
{
    /* register ourselves with the agent to handle our mib tree */
    init_PrivateMIBNodeRootOIDbySwitchBoardID(smtpServerIpTable_variables_oid);
    REGISTER_MIB("smtpServerIpTable", smtpServerIpTable_variables,
                 variable3, smtpServerIpTable_variables_oid);
}




/********************************************
 ***************smtpDestEMailTable************
 ********************************************
 */
oid             smtpDestEMailTable_variables_oid[] =
    { SYS_ADPT_PRIVATEMIB_OID, 1, 19, 7 };

struct variable3 smtpDestEMailTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    {SMTPDESTEMAIL, ASN_OCTET_STR, RONLY, var_smtpDestEMailTable, 3,
     {5, 1, 1}},
#endif
    {SMTPDESTEMAILSTATUS, ASN_INTEGER, RWRITE, var_smtpDestEMailTable, 3,
     {5, 1, 2}},
};

/** Initializes the smtpDestEMailTable module */
void
init_smtpDestEMailTable(void)
{
    /* register ourselves with the agent to handle our mib tree */
    init_PrivateMIBNodeRootOIDbySwitchBoardID(smtpDestEMailTable_variables_oid);
    REGISTER_MIB("smtpDestEMailTable", smtpDestEMailTable_variables,
                 variable3, smtpDestEMailTable_variables_oid);
}
#endif

/********************************************
 ***************ntpMgt**********************
 ********************************************
 */
#if (SYS_CPNT_NTP == TRUE)

void
init_ntpMgt(void)
{
    oid ntpStatus_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1, 23, 5, 1, 0 };
    oid ntpServiceMode_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1, 23, 5, 2, 0 };
    oid ntpPollInterval_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1, 23, 5, 3, 0 };
    oid ntpAuthenticateStatus_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1, 23, 5, 4, 0 };

    DEBUGMSGTL(("ntpMgt", "Initializing\n"));

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("ntpStatus",
                               do_ntpStatus,
                               ntpStatus_oid,
                               OID_LENGTH(ntpStatus_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("ntpServiceMode",
                               do_ntpServiceMode,
                               ntpServiceMode_oid,
                               OID_LENGTH(ntpServiceMode_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("ntpPollInterval",
                                         get_ntpPollInterval,
                                         ntpPollInterval_oid,
                                         OID_LENGTH(ntpPollInterval_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("ntpAuthenticateStatus",
                               do_ntpAuthenticateStatus,
                               ntpAuthenticateStatus_oid,
                               OID_LENGTH(ntpAuthenticateStatus_oid),
                               HANDLER_CAN_RWRITE));
}

/********************************************
 ***************ntpServerTable***************
 ********************************************
 */

struct variable3 ntpServerTable_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    {LEAF_ntpServerIpAddress,  ASN_IPADDRESS,  RONLY,   var_ntpServerTable, 3,
     { 5, 1, 1 }},
#endif

     {LEAF_ntpServerVersion,  ASN_INTEGER,  RONLY,  var_ntpServerTable, 3,
      { 5, 1, 2 }},
     {LEAF_ntpServerKeyId,  ASN_INTEGER,  RWRITE,  var_ntpServerTable, 3,
      { 5, 1, 3 }},
     {LEAF_ntpServerStatus,  ASN_INTEGER,  RWRITE,  var_ntpServerTable, 3,
      { 5, 1, 4 }},
};

//** Initializes the ntpServerTable module */
void
init_ntpServerTable(void)
{
    oid             ntpServerTable_variables_oid[] =
    { SYS_ADPT_PRIVATEMIB_OID, 1, 23, 5 };

    DEBUGMSGTL(("ntpServerTable", "Initializing\n"));

    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("ntpServerTable", ntpServerTable_variables, variable3,
               ntpServerTable_variables_oid);

}

/********************************************
 ***************ntpAuthKeyTable**************
 ********************************************
 */


struct variable3 ntpAuthKeyTable_variables[] = {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    {LEAF_ntpAuthKeyId,  ASN_INTEGER,  RONLY,   var_ntpAuthKeyTable, 3,
     { 6, 1, 1 }},
#endif

     {LEAF_ntpAuthKeyWord,  ASN_OCTET_STR,  RWRITE,  var_ntpAuthKeyTable, 3,
      { 6, 1, 2 }},
     {LEAF_ntpAuthKeyStatus,  ASN_INTEGER,  RWRITE,  var_ntpAuthKeyTable, 3,
      { 6, 1, 3 }},
};

/** Initializes the ntpAuthKeyTable module */
void
init_ntpAuthKeyTable(void)
{
    oid             ntpAuthKeyTable_variables_oid[] =
    { SYS_ADPT_PRIVATEMIB_OID, 1, 23, 5 };

    DEBUGMSGTL(("ntpAuthKeyTable", "Initializing\n"));
    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("ntpAuthKeyTable", ntpAuthKeyTable_variables, variable3,
               ntpAuthKeyTable_variables_oid);
}

#endif


/********************************************
 ***************consoleMgt*******************
 ********************************************
 */
void
init_consoleMgt(void)
{
    static oid      consoleStopBits_oid[] =
        { SYS_ADPT_PRIVATEMIB_OID, 1, 20, 1, 4, 0 };
    static oid      consoleParity_oid[] =
        { SYS_ADPT_PRIVATEMIB_OID, 1, 20, 1, 2, 0 };
    static oid      consolePasswordThreshold_oid[] =
        { SYS_ADPT_PRIVATEMIB_OID, 1, 20, 1, 6, 0 };
#if (SYS_CPNT_AUTOBAUDRATE == TRUE)
    static oid      consoleAdminBaudRate_oid[] =
        { SYS_ADPT_PRIVATEMIB_OID, 1, 20, 1, 8, 0 };
    static oid      consoleOperBaudRate_oid[] =
        { SYS_ADPT_PRIVATEMIB_OID, 1, 20, 1, 9, 0 };
#else
    static oid      consoleBaudRate_oid[] =
        { SYS_ADPT_PRIVATEMIB_OID, 1, 20, 1, 3, 0 };
#endif
    static oid      consoleDataBits_oid[] =
        { SYS_ADPT_PRIVATEMIB_OID, 1, 20, 1, 1, 0 };
    static oid      consoleExecTimeout_oid[] =
        { SYS_ADPT_PRIVATEMIB_OID, 1, 20, 1, 5, 0 };
    static oid      consoleSilentTime_oid[] =
        { SYS_ADPT_PRIVATEMIB_OID, 1, 20, 1, 7, 0 };
    static oid      consoleLoginResponseTimeout_oid[] =
        { SYS_ADPT_PRIVATEMIB_OID, 1, 20, 1, 10, 0 };

    init_PrivateMIBNodeRootOIDbySwitchBoardID(consoleStopBits_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("consoleStopBits",
                               do_consoleStopBits,
                               consoleStopBits_oid,
                               OID_LENGTH(consoleStopBits_oid),
                               HANDLER_CAN_RWRITE));
    init_PrivateMIBNodeRootOIDbySwitchBoardID(consoleParity_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("consoleParity",
                               do_consoleParity,
                               consoleParity_oid,
                               OID_LENGTH(consoleParity_oid),
                               HANDLER_CAN_RWRITE));
    init_PrivateMIBNodeRootOIDbySwitchBoardID(consolePasswordThreshold_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("consolePasswordThreshold",
                               do_consolePasswordThreshold,
                               consolePasswordThreshold_oid,
                               OID_LENGTH(consolePasswordThreshold_oid),
                               HANDLER_CAN_RWRITE));
#if (SYS_CPNT_AUTOBAUDRATE == TRUE)
    init_PrivateMIBNodeRootOIDbySwitchBoardID(consoleAdminBaudRate_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("consoleAdminBaudRate",
                               do_consoleAdminBaudRate,
                               consoleAdminBaudRate_oid,
                               OID_LENGTH(consoleAdminBaudRate_oid),
                               HANDLER_CAN_RWRITE));
    init_PrivateMIBNodeRootOIDbySwitchBoardID(consoleOperBaudRate_oid);
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                              ("consoleOperBaudRate",
                               get_consoleOperBaudRate,
                               consoleOperBaudRate_oid,
                               OID_LENGTH(consoleOperBaudRate_oid),
                               HANDLER_CAN_RONLY));
#else
    init_PrivateMIBNodeRootOIDbySwitchBoardID(consoleBaudRate_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("consoleBaudRate",
                               do_consoleBaudRate,
                               consoleBaudRate_oid,
                               OID_LENGTH(consoleBaudRate_oid),
                               HANDLER_CAN_RWRITE));
#endif
    init_PrivateMIBNodeRootOIDbySwitchBoardID(consoleDataBits_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("consoleDataBits",
                               do_consoleDataBits,
                               consoleDataBits_oid,
                               OID_LENGTH(consoleDataBits_oid),
                               HANDLER_CAN_RWRITE));
    init_PrivateMIBNodeRootOIDbySwitchBoardID(consoleExecTimeout_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("consoleExecTimeout",
                               do_consoleExecTimeout,
                               consoleExecTimeout_oid,
                               OID_LENGTH(consoleExecTimeout_oid),
                               HANDLER_CAN_RWRITE));
    init_PrivateMIBNodeRootOIDbySwitchBoardID(consoleSilentTime_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("consoleSilentTime",
                               do_consoleSilentTime,
                               consoleSilentTime_oid,
                               OID_LENGTH(consoleSilentTime_oid),
                               HANDLER_CAN_RWRITE));
    init_PrivateMIBNodeRootOIDbySwitchBoardID(consoleLoginResponseTimeout_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("consoleLoginResponseTimeout",
                               do_consoleLoginResponseTimeout,
                               consoleLoginResponseTimeout_oid,
                               OID_LENGTH(consoleLoginResponseTimeout_oid),
                               HANDLER_CAN_RWRITE));
}

#if (SYS_CPNT_TELNET == TRUE)

/********************************************
 ***************telnetMgt********************
 ********************************************
 */
void
init_telnetMgt(void)
{
    static oid telnetStatus_oid[]               = { SYS_ADPT_PRIVATEMIB_OID, 1, 20, 2, 4, 0 };
    static oid telnetPortNumber_oid[]           = { SYS_ADPT_PRIVATEMIB_OID, 1, 20, 2, 5, 0 };

    init_PrivateMIBNodeRootOIDbySwitchBoardID(telnetStatus_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("telnetStatus",
                               do_telnetStatus,
                               telnetStatus_oid,
                               OID_LENGTH(telnetStatus_oid),
                               HANDLER_CAN_RWRITE));
    init_PrivateMIBNodeRootOIDbySwitchBoardID(telnetPortNumber_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("telnetPortNumber",
                               do_telnetPortNumber,
                               telnetPortNumber_oid,
                               OID_LENGTH(telnetPortNumber_oid),
                               HANDLER_CAN_RWRITE));
}
#endif /* #if (SYS_CPNT_TELNET == TRUE) */

void init_vtyMgt(void)
{
    static oid vtyExecTimeout_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,20,3,1,0 };
    static oid vtyPasswordThreshold_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,20,3,2,0 };
    static oid vtyLoginResponseTimeout_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,20,3,3,0 };
    static oid vtyMaxSession_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,20,3,4,0 };
    static oid vtySilentTime_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,20,3,5,0 };

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("vtyExecTimeout",
                               do_vtyExecTimeout,
                               vtyExecTimeout_oid,
                               OID_LENGTH(vtyExecTimeout_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("vtyPasswordThreshold",
                               do_vtyPasswordThreshold,
                               vtyPasswordThreshold_oid,
                               OID_LENGTH(vtyPasswordThreshold_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("vtyLoginResponseTimeout",
                               do_vtyLoginResponseTimeout,
                               vtyLoginResponseTimeout_oid,
                               OID_LENGTH(vtyLoginResponseTimeout_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("vtyMaxSession",
                               do_vtyMaxSession,
                               vtyMaxSession_oid,
                               OID_LENGTH(vtyMaxSession_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("vtySilentTime",
                               do_vtySilentTime,
                               vtySilentTime_oid,
                               OID_LENGTH(vtySilentTime_oid),
                               HANDLER_CAN_RWRITE));
}

/********************************************
 ***************sysTimeMgt********************
 ********************************************
 */
#if (SYS_CPNT_SNTP == TRUE)

void
init_sysTimeMgt(void)
{
    static oid      sntpStatus_oid[] =
        { SYS_ADPT_PRIVATEMIB_OID, 1, 23, 1, 1, 0 };
    static oid      sntpServiceMode_oid[] =
        { SYS_ADPT_PRIVATEMIB_OID, 1, 23, 1, 2, 0 };
    static oid      sntpPollInterval_oid[] =
        { SYS_ADPT_PRIVATEMIB_OID, 1, 23, 1, 3, 0 };
    static oid      sysCurrentTime_oid[] =
        { SYS_ADPT_PRIVATEMIB_OID, 1, 23, 2, 0 };
    static oid      sysTimeZoneName_oid[] =
        { SYS_ADPT_PRIVATEMIB_OID, 1, 23, 4, 0 };
    static oid      sysTimeZone_oid[] =
        { SYS_ADPT_PRIVATEMIB_OID, 1, 23, 3, 0 };

    init_PrivateMIBNodeRootOIDbySwitchBoardID(sntpStatus_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("sntpStatus",
                               do_sntpStatus,
                               sntpStatus_oid,
                               OID_LENGTH(sntpStatus_oid),
                               HANDLER_CAN_RWRITE));
    init_PrivateMIBNodeRootOIDbySwitchBoardID(sntpServiceMode_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("sntpServiceMode",
                               do_sntpServiceMode,
                               sntpServiceMode_oid,
                               OID_LENGTH(sntpServiceMode_oid),
                               HANDLER_CAN_RWRITE));
    init_PrivateMIBNodeRootOIDbySwitchBoardID(sntpPollInterval_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("sntpPollInterval",
                               do_sntpPollInterval,
                               sntpPollInterval_oid,
                               OID_LENGTH(sntpPollInterval_oid),
                               HANDLER_CAN_RWRITE));
    init_PrivateMIBNodeRootOIDbySwitchBoardID(sysCurrentTime_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("sysCurrentTime",
                               do_sysCurrentTime,
                               sysCurrentTime_oid,
                               OID_LENGTH(sysCurrentTime_oid),
                               HANDLER_CAN_RWRITE));
    init_PrivateMIBNodeRootOIDbySwitchBoardID(sysTimeZoneName_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("sysTimeZoneName",
                               do_sysTimeZoneName,
                               sysTimeZoneName_oid,
                               OID_LENGTH(sysTimeZoneName_oid),
                               HANDLER_CAN_RWRITE));
    init_PrivateMIBNodeRootOIDbySwitchBoardID(sysTimeZone_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("sysTimeZone",
                               do_sysTimeZone,
                               sysTimeZone_oid,
                               OID_LENGTH(sysTimeZone_oid),
                               HANDLER_CAN_RWRITE));
}



/********************************************
 ***************sntpServerTable**************
 ********************************************
 */
oid             sntpServerTable_variables_oid[] =
    { SYS_ADPT_PRIVATEMIB_OID, 1, 23, 1 };

struct variable3 sntpServerTable_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
{LEAF_sntpServerIndex,  ASN_INTEGER,  RONLY,   var_sntpServerTable, 3,  { 4, 1, 1 }},
#endif

{LEAF_sntpServerInetAddressType,  ASN_INTEGER,  RWRITE,  var_sntpServerTable, 3,  { 4, 1, 4 }},
{LEAF_sntpServerInetAddress,  ASN_OCTET_STR,  RWRITE,  var_sntpServerTable, 3,  { 4, 1, 5 }},
{LEAF_sntpServerStatus,  ASN_INTEGER,  RWRITE,  var_sntpServerTable, 3,  { 4, 1, 6 }},
};

/** Initializes the sntpServerTable module */
void
init_sntpServerTable(void)
{
    /* register ourselves with the agent to handle our mib tree */
    init_PrivateMIBNodeRootOIDbySwitchBoardID(sntpServerTable_variables_oid);
    REGISTER_MIB("sntpServerTable", sntpServerTable_variables, variable3,
                 sntpServerTable_variables_oid);
}
#endif


/********************************************
 *****************pingMgt********************
 ********************************************
 */

void
init_pingMgt(void)
{
    static oid      pingIpAddress_oid[] =               { SYS_ADPT_PRIVATEMIB_OID, 1, 10, 15, 1, 0 };
    static oid      pingPacketSize_oid[] =              { SYS_ADPT_PRIVATEMIB_OID, 1, 10, 15, 2, 0 };
    static oid      pingCompleted_oid[] =               { SYS_ADPT_PRIVATEMIB_OID, 1, 10, 15, 4, 0 };
    static oid      pingAction_oid[] =                  { SYS_ADPT_PRIVATEMIB_OID, 1, 10, 15, 5, 0 };
    static oid      pingProbeCount_oid[] =              { SYS_ADPT_PRIVATEMIB_OID, 1, 10, 15, 6, 0 };
    static oid      pingSentPackets_oid[] =       { SYS_ADPT_PRIVATEMIB_OID, 1, 10, 15, 7, 0 };
    static oid      pingReceivedPackets_oid[] =   { SYS_ADPT_PRIVATEMIB_OID, 1, 10, 15, 8, 0 };
    static oid      pingLossRate_oid[] =          { SYS_ADPT_PRIVATEMIB_OID, 1, 10, 15, 9, 0 };

    netsnmp_register_instance(netsnmp_create_handler_registration
                                  ("pingIpAddress",
                                   do_pingIpAddress,
                                   pingIpAddress_oid,
                                   OID_LENGTH(pingIpAddress_oid),
                                   HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                                  ("pingPacketSize",
                                   do_pingPacketSize,
                                   pingPacketSize_oid,
                                   OID_LENGTH(pingPacketSize_oid),
                                   HANDLER_CAN_RWRITE));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("pingCompleted",
                                         get_pingCompleted,
                                         pingCompleted_oid,
                                         OID_LENGTH(pingCompleted_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_instance(netsnmp_create_handler_registration
                                  ("pingAction",
                                   do_pingAction,
                                   pingAction_oid,
                                   OID_LENGTH(pingAction_oid),
                                   HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                                  ("pingProbeCount",
                                   do_pingProbeCount,
                                   pingProbeCount_oid,
                                   OID_LENGTH(pingProbeCount_oid),
                                   HANDLER_CAN_RWRITE));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("pingSentPackets",
                                         get_pingSentPackets,
                                         pingSentPackets_oid,
                                         OID_LENGTH(pingSentPackets_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("pingReceivedPackets",
                                         get_pingReceivedPackets,
                                         pingReceivedPackets_oid,
                                         OID_LENGTH(pingReceivedPackets_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("pingLossRate",
                                         get_pingLossRate,
                                         pingLossRate_oid,
                                         OID_LENGTH(pingLossRate_oid),
                                         HANDLER_CAN_RONLY));

}

/********************************************
 ***********pingHistoryTable*****************
 ********************************************
 */
oid pingHistoryTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,10,15 };
/*
 * variable3 pingHistoryTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */
struct variable3 pingHistoryTable_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
{PINGHISTORYINDEX,  ASN_INTEGER,  RONLY,   var_pingHistoryTable, 3,  { 10, 1, 1 }},
#endif

{PINGHISTORYRESPONSE,  ASN_INTEGER,  RONLY,   var_pingHistoryTable, 3,  { 10, 1, 2 }},
};

/** Initializes the pingHistoryTable module */
void
init_pingHistoryTable(void)
{
    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("pingHistoryTable", pingHistoryTable_variables, variable3,
                 pingHistoryTable_variables_oid);
}

/********************************************
 ***************fileCopyMgt******************
 ********************************************
 */
void
init_fileCopyMgt(void)
{
    static oid      fileCopySrcOperType_oid[] =
        { SYS_ADPT_PRIVATEMIB_OID, 1, 24, 1, 1, 0 };
    static oid      fileCopySrcFileName_oid[] =
        { SYS_ADPT_PRIVATEMIB_OID, 1, 24, 1, 2, 0 };
    static oid      fileCopyDestOperType_oid[] =
        { SYS_ADPT_PRIVATEMIB_OID, 1, 24, 1, 3, 0 };
    static oid      fileCopyDestFileName_oid[] =
        { SYS_ADPT_PRIVATEMIB_OID, 1, 24, 1, 4, 0 };
    static oid      fileCopyFileType_oid[] =
        { SYS_ADPT_PRIVATEMIB_OID, 1, 24, 1, 5, 0 };
    static oid      fileCopyUnitId_oid[] =
        { SYS_ADPT_PRIVATEMIB_OID, 1, 24, 1, 7, 0 };
    static oid      fileCopyAction_oid[] =
        { SYS_ADPT_PRIVATEMIB_OID, 1, 24, 1, 8, 0 };
    static oid      fileCopyStatus_oid[] =
        { SYS_ADPT_PRIVATEMIB_OID, 1, 24, 1, 9, 0 };
    static oid fileCopyServerInetAddressType_oid[] =
        { SYS_ADPT_PRIVATEMIB_OID, 1, 24, 1, 20, 0 };
    static oid fileCopyServerInetAddress_oid[] =
        { SYS_ADPT_PRIVATEMIB_OID, 1, 24, 1, 21, 0 };

#if (SYS_CPNT_XFER_FTP == TRUE || SYS_CPNT_SFTP == TRUE)
    static oid fileCopyServerUserName_oid[] =
        { SYS_ADPT_PRIVATEMIB_OID, 1, 24, 1, 22, 0 };
    static oid fileCopyServerPassword_oid[] =
        { SYS_ADPT_PRIVATEMIB_OID, 1, 24, 1, 23, 0 };
#endif /* #if (SYS_CPNT_XFER_FTP == TRUE || SYS_CPNT_SFTP == TRUE) */

    init_PrivateMIBNodeRootOIDbySwitchBoardID(fileCopySrcFileName_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("fileCopySrcFileName",
                               do_fileCopySrcFileName,
                               fileCopySrcFileName_oid,
                               OID_LENGTH(fileCopySrcFileName_oid),
                               HANDLER_CAN_RWRITE));
    init_PrivateMIBNodeRootOIDbySwitchBoardID(fileCopyStatus_oid);
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("fileCopyStatus",
                                         get_fileCopyStatus,
                                         fileCopyStatus_oid,
                                         OID_LENGTH(fileCopyStatus_oid),
                                         HANDLER_CAN_RONLY));
    init_PrivateMIBNodeRootOIDbySwitchBoardID(fileCopySrcOperType_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("fileCopySrcOperType",
                               do_fileCopySrcOperType,
                               fileCopySrcOperType_oid,
                               OID_LENGTH(fileCopySrcOperType_oid),
                               HANDLER_CAN_RWRITE));
    init_PrivateMIBNodeRootOIDbySwitchBoardID(fileCopyDestFileName_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("fileCopyDestFileName",
                               do_fileCopyDestFileName,
                               fileCopyDestFileName_oid,
                               OID_LENGTH(fileCopyDestFileName_oid),
                               HANDLER_CAN_RWRITE));
    init_PrivateMIBNodeRootOIDbySwitchBoardID(fileCopyUnitId_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("fileCopyUnitId",
                               do_fileCopyUnitId,
                               fileCopyUnitId_oid,
                               OID_LENGTH(fileCopyUnitId_oid),
                               HANDLER_CAN_RWRITE));
    init_PrivateMIBNodeRootOIDbySwitchBoardID(fileCopyAction_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("fileCopyAction",
                               do_fileCopyAction,
                               fileCopyAction_oid,
                               OID_LENGTH(fileCopyAction_oid),
                               HANDLER_CAN_RWRITE));
    init_PrivateMIBNodeRootOIDbySwitchBoardID(fileCopyFileType_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("fileCopyFileType",
                               do_fileCopyFileType,
                               fileCopyFileType_oid,
                               OID_LENGTH(fileCopyFileType_oid),
                               HANDLER_CAN_RWRITE));
    init_PrivateMIBNodeRootOIDbySwitchBoardID(fileCopyDestOperType_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("fileCopyDestOperType",
                               do_fileCopyDestOperType,
                               fileCopyDestOperType_oid,
                               OID_LENGTH(fileCopyDestOperType_oid),
                               HANDLER_CAN_RWRITE));
    init_PrivateMIBNodeRootOIDbySwitchBoardID(fileCopyServerInetAddressType_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("fileCopyServerInetAddressType",
                               do_fileCopyServerInetAddressType,
                               fileCopyServerInetAddressType_oid,
                               OID_LENGTH(fileCopyServerInetAddressType_oid),
                               HANDLER_CAN_RWRITE));
    init_PrivateMIBNodeRootOIDbySwitchBoardID(fileCopyServerInetAddress_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("fileCopyServerInetAddress",
                               do_fileCopyServerInetAddress,
                               fileCopyServerInetAddress_oid,
                               OID_LENGTH(fileCopyServerInetAddress_oid),
                               HANDLER_CAN_RWRITE));

#if (SYS_CPNT_XFER_FTP == TRUE || SYS_CPNT_SFTP == TRUE)
    init_PrivateMIBNodeRootOIDbySwitchBoardID(fileCopyServerUserName_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("fileCopyServerUserName",
                               do_fileCopyServerUserName,
                               fileCopyServerUserName_oid,
                               OID_LENGTH(fileCopyServerUserName_oid),
                               HANDLER_CAN_RWRITE));
    init_PrivateMIBNodeRootOIDbySwitchBoardID(fileCopyServerPassword_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("fileCopyServerPassword",
                               do_fileCopyServerPassword,
                               fileCopyServerPassword_oid,
                               OID_LENGTH(fileCopyServerPassword_oid),
                               HANDLER_CAN_RWRITE));
#endif /* #if (SYS_CPNT_XFER_FTP == TRUE || SYS_CPNT_SFTP == TRUE) */
}



/********************************************
 **************fileInfoTable*****************
 ********************************************
 */
oid             fileInfoTable_variables_oid[] =
    {SYS_ADPT_PRIVATEMIB_OID, 1, 24, 2 };

struct variable3 fileInfoTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    {FILEINFOUNITID, ASN_INTEGER, RONLY, var_fileInfoTable, 3, {1, 1, 1}},
    {FILEINFOFILENAME, ASN_OCTET_STR, RONLY, var_fileInfoTable, 3,
     {1, 1, 2}},
#endif
    {FILEINFOFILETYPE, ASN_INTEGER, RONLY, var_fileInfoTable, 3,
     {1, 1, 3}},
    {FILEINFOISSTARTUP, ASN_INTEGER, RWRITE, var_fileInfoTable, 3,
     {1, 1, 4}},
    {FILEINFOFILESIZE, ASN_INTEGER, RONLY, var_fileInfoTable, 3,
     {1, 1, 5}},
    {FILEINFOCREATIONTIME, ASN_OCTET_STR, RONLY, var_fileInfoTable, 3,
     {1, 1, 6}},
    {FILEINFODELETE, ASN_INTEGER, RWRITE, var_fileInfoTable, 3, {1, 1, 7}},
};

/** Initializes the fileInfoTable module */
void
init_fileInfoTable(void)
{
    /* register ourselves with the agent to handle our mib tree */
    init_PrivateMIBNodeRootOIDbySwitchBoardID(fileInfoTable_variables_oid);
    REGISTER_MIB("fileInfoTable", fileInfoTable_variables, variable3,
                 fileInfoTable_variables_oid);
}

/**********************************************************
 **************fileAutoDownloadResultTable*****************
 **********************************************************
 */
oid             fileAutoDownloadResultTable_variables_oid[] =
    { SYS_ADPT_PRIVATEMIB_OID, 1, 24 };

/*
 * variable4 fileAutoDownloadResultTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */

struct variable3 fileAutoDownloadResultTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    {FILEAUTODOWNLOADRESULTUNITID, ASN_INTEGER, RONLY,
     var_fileAutoDownloadResultTable, 3, {3, 1, 1}},
#endif
    {FILEAUTODOWNLOADRESULTACTION, ASN_INTEGER, RONLY,
     var_fileAutoDownloadResultTable, 3, {3, 1, 2}},
    {FILEAUTODOWNLOADRESULTSTATUS, ASN_INTEGER, RONLY,
     var_fileAutoDownloadResultTable, 3, {3, 1, 3}},
};
/*
 * (L = length of the oidsuffix)
 */


/** Initializes the fileAutoDownloadResultTable module */
void
init_fileAutoDownloadResultTable(void)
{
    /*
     * register ourselves with the agent to handle our mib tree
     */
    init_PrivateMIBNodeRootOIDbySwitchBoardID(fileAutoDownloadResultTable_variables_oid);
    REGISTER_MIB("fileAutoDownloadResultTable",
                 fileAutoDownloadResultTable_variables, variable3,
                 fileAutoDownloadResultTable_variables_oid);

    /*
     * place any other initialization junk you need here
     */
}

/** Initializes the fileAutoUpgradeMgt module */
#if(SYS_CPNT_XFER_AUTO_UPGRADE==TRUE)
void
init_fileAutoUpgradeMgt(void)
{
    static oid fileAutoUpgradeOpCodePath_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,24,4,2,0 };
    static oid fileAutoUpgradeOpCodeStatus_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,24,4,1,0 };
    static oid fileAutoUpgradeOpCodeFileName_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,24,4,3,0 };

    DEBUGMSGTL(("fileAutoUpgradeMgt", "Initializing\n"));

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("fileAutoUpgradeOpCodePath",
                               do_fileAutoUpgradeOpCodePath,
                               fileAutoUpgradeOpCodePath_oid,
                               OID_LENGTH(fileAutoUpgradeOpCodePath_oid),
                               HANDLER_CAN_RWRITE));

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("fileAutoUpgradeOpCodeStatus",
                               do_fileAutoUpgradeOpCodeStatus,
                               fileAutoUpgradeOpCodeStatus_oid,
                               OID_LENGTH(fileAutoUpgradeOpCodeStatus_oid),
                               HANDLER_CAN_RWRITE));

    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("fileAutoUpgradeOpCodeFileName",
                                         get_fileAutoUpgradeOpCodeFileName,
                                         fileAutoUpgradeOpCodeFileName_oid,
                                         OID_LENGTH(fileAutoUpgradeOpCodeFileName_oid),
                                         HANDLER_CAN_RONLY));
}

#endif

/********************************************
 *********************dnsMgt*****************
 ********************************************
 */
#if (SYS_CPNT_DNS == TRUE)
void
init_dnsMgt(void)
{
    static oid      dnsDomainName_oid[] =
        { SYS_ADPT_PRIVATEMIB_OID, 1, 26, 2, 0 };
    static oid      dnsDomainLookup_oid[] =
        { SYS_ADPT_PRIVATEMIB_OID, 1, 26, 1, 0 };
    init_PrivateMIBNodeRootOIDbySwitchBoardID(dnsDomainName_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("dnsDomainName",
                               do_dnsDomainName,
                               dnsDomainName_oid,
                               OID_LENGTH(dnsDomainName_oid),
                               HANDLER_CAN_RWRITE));
    init_PrivateMIBNodeRootOIDbySwitchBoardID(dnsDomainLookup_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("dnsDomainLookup",
                               do_dnsDomainLookup,
                               dnsDomainLookup_oid,
                               OID_LENGTH(dnsDomainLookup_oid),
                               HANDLER_CAN_RWRITE));
}



/********************************************
 *****************dnsHostTable***************
 ********************************************
 */
oid             dnsHostTable_variables_oid[] =
    { SYS_ADPT_PRIVATEMIB_OID, 1, 26};

struct variable3 dnsHostTable_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
{LEAF_dnsHostIndex,  ASN_INTEGER,  RONLY,   var_dnsHostTable, 3,  { 8, 1, 1 }},
#endif

{LEAF_dnsHostName,  ASN_OCTET_STR,  RWRITE,  var_dnsHostTable, 3,  { 8, 1, 2 }},
{LEAF_dnsHostStatus,  ASN_INTEGER,  RWRITE,  var_dnsHostTable, 3,  { 8, 1, 3 }},
};

/** Initializes the dnsHostTable module */
void
init_dnsHostTable(void)
{
    /* register ourselves with the agent to handle our mib tree */
    init_PrivateMIBNodeRootOIDbySwitchBoardID(dnsHostTable_variables_oid);
    REGISTER_MIB("dnsHostTable", dnsHostTable_variables, variable3,
                 dnsHostTable_variables_oid);
}




/********************************************
 *****************dnsAliasTable**************
 ********************************************
 */
#if 0
oid dnsAliasTable_variables_oid[] =
    {SYS_ADPT_PRIVATEMIB_OID, 1, 26 };

struct variable3 dnsAliasTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */
    {DNSALIASNAME, ASN_OCTET_STR, RONLY, var_dnsAliasTable, 3, {4, 1, 1}},
    {DNSALIASALIAS, ASN_OCTET_STR, RONLY, var_dnsAliasTable, 3, {4, 1, 2}},
};

/** Initializes the dnsAliasTable module */
void
init_dnsAliasTable(void)
{
    /* register ourselves with the agent to handle our mib tree */
    init_PrivateMIBNodeRootOIDbySwitchBoardID(dnsAliasTable_variables_oid);
    REGISTER_MIB("dnsAliasTable", dnsAliasTable_variables, variable3,
                 dnsAliasTable_variables_oid);
}

#endif

/********************************************
 ***************dnsDomainListTable***********
 ********************************************
 */
oid             dnsDomainListTable_variables_oid[] =
    {SYS_ADPT_PRIVATEMIB_OID, 1, 26};

struct variable3 dnsDomainListTable_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
{LEAF_dnsDomainListIndex,  ASN_INTEGER,  RONLY,   var_dnsDomainListTable, 3,  { 10, 1, 1 }},
#endif

{LEAF_dnsDomainListName,  ASN_OCTET_STR,  RWRITE,  var_dnsDomainListTable, 3,  { 10, 1, 2 }},
{LEAF_dnsDomainListStatus,  ASN_INTEGER,  RWRITE,  var_dnsDomainListTable, 3,  { 10, 1, 3 }},
};

/** Initializes the dnsDomainListTable module */
void
init_dnsDomainListTable(void)
{
    /* register ourselves with the agent to handle our mib tree */
    init_PrivateMIBNodeRootOIDbySwitchBoardID(dnsDomainListTable_variables_oid);
    REGISTER_MIB("dnsDomainListTable", dnsDomainListTable_variables,
                 variable3, dnsDomainListTable_variables_oid);
}



/********************************************
 **************dnsCacheTable*****************
 ********************************************
 */
oid             dnsCacheTable_variables_oid[] =
    { SYS_ADPT_PRIVATEMIB_OID, 1, 26};

struct variable3 dnsCacheTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    {LEAF_dnsCacheIndex,  ASN_INTEGER,  RONLY,   var_dnsCacheTable, 3,  { 7, 1, 1 }},
#endif

    {LEAF_dnsCacheFlag,  ASN_INTEGER,  RONLY,   var_dnsCacheTable, 3,  { 7, 1, 2 }},
    {LEAF_dnsCacheType,  ASN_INTEGER,  RONLY,   var_dnsCacheTable, 3,  { 7, 1, 3 }},

#if(SYS_CPNT_IPV6 == FALSE)
    {LEAF_dnsCacheIp,  ASN_IPADDRESS,  RONLY,   var_dnsCacheTable, 3,  { 7, 1, 4 }},
#endif

    {LEAF_dnsCacheTtl,  ASN_INTEGER,  RONLY,   var_dnsCacheTable, 3,  { 7, 1, 5 }},
    {LEAF_dnsCacheDomain,  ASN_OCTET_STR,  RONLY,   var_dnsCacheTable, 3,  { 7, 1, 6 }},

#if(SYS_CPNT_IPV6 == TRUE)
    {LEAF_dnsCacheInetAddressType,  ASN_INTEGER,  RONLY,   var_dnsCacheTable, 3,  { 7, 1, 7 }},
    {LEAF_dnsCacheInetAddress,  ASN_OCTET_STR,  RONLY,   var_dnsCacheTable, 3,  { 7, 1, 8 }},
#endif
};

/** Initializes the dnsCacheTable module */
void
init_dnsCacheTable(void)
{
    /* register ourselves with the agent to handle our mib tree */
    init_PrivateMIBNodeRootOIDbySwitchBoardID(dnsCacheTable_variables_oid);
    REGISTER_MIB("dnsCacheTable", dnsCacheTable_variables, variable3,
                 dnsCacheTable_variables_oid);
}



/********************************************
 **************dnsHostAddrTable****************
 ********************************************
 */
oid dnsHostAddrTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,26 };

struct variable3 dnsHostAddrTable_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
{LEAF_dnsHostAddrInetAddressType,  ASN_INTEGER,  RONLY,   var_dnsHostAddrTable, 3,  { 9, 1, 1 }},
#endif

#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
{LEAF_dnsHostAddrInetAddress,  ASN_OCTET_STR,  RONLY,   var_dnsHostAddrTable, 3,  { 9, 1, 2 }},
#endif

{LEAF_dnsHostAddrStatus,  ASN_INTEGER,  RWRITE,  var_dnsHostAddrTable, 3,  { 9, 1, 3 }},
};

/** Initializes the dnsHostAddrTable module */
void
init_dnsHostAddrTable(void)
{
    /* register ourselves with the agent to handle our mib tree */
    init_PrivateMIBNodeRootOIDbySwitchBoardID(dnsHostAddrTable_variables_oid);
    REGISTER_MIB("dnsHostAddrTable", dnsHostAddrTable_variables, variable3,
                 dnsHostAddrTable_variables_oid);
}

oid dnsNameServerInetTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,26 };

/* variable3 dnsNameServerInetTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */
struct variable3 dnsNameServerInetTable_variables[] =
{
/* magic number, variable type, ro/rw, callback fn, L, oidsuffix
 */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_dnsNameServerInetAddressType, ASN_INTEGER, RONLY, var_dnsNameServerInetTable, 3, { 11, 1, 1 }},
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_dnsNameServerInetAddress, ASN_OCTET_STR, RONLY, var_dnsNameServerInetTable, 3, { 11, 1, 2 }},
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

    { LEAF_dnsNameServerInetStatus, ASN_INTEGER, RWRITE, var_dnsNameServerInetTable, 3, { 11, 1, 3 }},
};

void init_dnsNameServerInetTable(void)
{
    REGISTER_MIB("dnsNameServerInetTable", dnsNameServerInetTable_variables, variable3,
                 dnsNameServerInetTable_variables_oid);
}
#endif /* end of #if (SYS_CPNT_DNS == TRUE)*/

#if (SYS_CPNT_RATE_BASED_STORM_CONTROL != TRUE)

#if (SYS_CPNT_STORM_MODE & SYS_CPNT_STORM_MSTORM)
/********************************************
 **************mcastStormTable***************
 ********************************************
 */
oid mcastStormTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,33,1 };
struct variable3 mcastStormTable_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
{MCASTSTORMIFINDEX,  ASN_INTEGER,  RONLY,   var_mcastStormTable, 3,  { 1, 1, 1 }},
 #endif

{MCASTSTORMSTATUS,  ASN_INTEGER,  RWRITE,  var_mcastStormTable, 3,  { 1, 1, 2 }},

#if (SYS_CPNT_STORM_SAMPLE_TYPE_PACKET + SYS_CPNT_STORM_SAMPLE_TYPE_OCTET + SYS_CPNT_STORM_SAMPLE_TYPE_PERCENT > 1)
{MCASTSTORMSAMPLETYPE,  ASN_INTEGER,  RWRITE,  var_mcastStormTable, 3,  { 1, 1, 3 }},
#endif
#if (SYS_CPNT_STORM_SAMPLE_TYPE_PACKET == TRUE)
{MCASTSTORMPKTRATE,  ASN_INTEGER,  RWRITE,  var_mcastStormTable, 3,  { 1, 1, 4 }},
#endif
#if (SYS_CPNT_STORM_SAMPLE_TYPE_OCTET == TRUE)
{MCASTSTORMOCTETRATE,  ASN_INTEGER,  RWRITE,  var_mcastStormTable, 3,  { 1, 1, 5 }},
#endif
#if (SYS_CPNT_STORM_SAMPLE_TYPE_PERCENT == TRUE)
{MCASTSTORMPERCENT,  ASN_INTEGER,  RWRITE,  var_mcastStormTable, 3,  { 1, 1, 6 }},
#endif
};
/** Initializes the mcastStormTable module */
void
init_mcastStormTable(void)
{
    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("mcastStormTable", mcastStormTable_variables, variable3,
               mcastStormTable_variables_oid);
}
#endif /* #if (SYS_CPNT_STORM_MODE & SYS_CPNT_STORM_MSTORM) */

#if (SYS_CPNT_STORM_MODE & SYS_CPNT_STORM_BSTORM)
/********************************************
 **************bcastStormTable***************
 ********************************************
 */

oid bcastStormTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,33, 3};

struct variable3 bcastStormTable_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
{BCASTSTORMIFINDEX,  ASN_INTEGER,  RONLY,   var_bcastStormTable, 3,  { 1, 1, 1 }},
 #endif

{BCASTSTORMSTATUS,  ASN_INTEGER,  RWRITE,  var_bcastStormTable, 3,  { 1, 1, 2 }},

#if (SYS_CPNT_STORM_SAMPLE_TYPE_PACKET + SYS_CPNT_STORM_SAMPLE_TYPE_OCTET + SYS_CPNT_STORM_SAMPLE_TYPE_PERCENT > 1)
{BCASTSTORMSAMPLETYPE,  ASN_INTEGER,  RWRITE,  var_bcastStormTable, 3,  { 1, 1, 3 }},
#endif
#if (SYS_CPNT_STORM_SAMPLE_TYPE_PACKET == TRUE)
{BCASTSTORMPKTRATE,  ASN_INTEGER,  RWRITE,  var_bcastStormTable, 3,  { 1, 1, 4 }},
#endif
#if (SYS_CPNT_STORM_SAMPLE_TYPE_OCTET == TRUE)
{BCASTSTORMOCTETRATE,  ASN_INTEGER,  RWRITE,  var_bcastStormTable, 3,  { 1, 1, 5 }},
{BCASTSTORMPERCENT,  ASN_INTEGER,  RWRITE,  var_bcastStormTable, 3,  { 1, 1, 6 }},
#endif
};

/** Initializes the bcastStormTable module */
void
init_bcastStormTable(void)
{
    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("bcastStormTable", bcastStormTable_variables, variable3,
               bcastStormTable_variables_oid);
}
#endif /* #if (SYS_CPNT_STORM_MODE & SYS_CPNT_STORM_BSTORM) */

#if (SYS_CPNT_STORM_MODE & SYS_CPNT_STORM_UNKNOWN_USTORM)
oid unknownUcastStormTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,33,4};

struct variable3 unknownUcastStormTable_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
{LEAF_unknownUcastStormIfIndex,  ASN_INTEGER,  RONLY,   var_unknownUcastStormTable, 3,  { 1, 1, 1 }},
#endif

{LEAF_unknownUcastStormStatus,  ASN_INTEGER,  RWRITE,  var_unknownUcastStormTable, 3,  { 1, 1, 2 }},

#if (SYS_CPNT_STORM_SAMPLE_TYPE_PACKET + SYS_CPNT_STORM_SAMPLE_TYPE_OCTET + SYS_CPNT_STORM_SAMPLE_TYPE_PERCENT > 1)
{LEAF_unknownUcastStormSampleType,  ASN_INTEGER,  RWRITE,  var_unknownUcastStormTable, 3,  { 1, 1, 3 }},
#endif
#if (SYS_CPNT_STORM_SAMPLE_TYPE_PACKET == TRUE)
{LEAF_unknownUcastStormPktRate,  ASN_INTEGER,  RWRITE,  var_unknownUcastStormTable, 3,  { 1, 1, 4 }},
#endif
#if (SYS_CPNT_STORM_SAMPLE_TYPE_OCTET == TRUE)
{LEAF_unknownUcastStormOctetRate,  ASN_INTEGER,  RWRITE,  var_unknownUcastStormTable, 3,  { 1, 1, 5 }},
#endif
#if (SYS_CPNT_STORM_SAMPLE_TYPE_PERCENT == TRUE)
{LEAF_unknownUcastStormPercent,  ASN_INTEGER,  RWRITE,  var_unknownUcastStormTable, 3,  { 1, 1, 6 }},
#endif
};
/*    (L = length of the oidsuffix) */

/** Initializes the unknownUcastStormTable module */
void
init_unknownUcastStormTable(void)
{

    DEBUGMSGTL(("unknownUcastStormTable", "Initializing\n"));

    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("unknownUcastStormTable", unknownUcastStormTable_variables, variable3,
               unknownUcastStormTable_variables_oid);

    /* place any other initialization junk you need here */
}
#endif /* #if (SYS_CPNT_STORM_MODE & SYS_CPNT_STORM_UNKNOWN_USTORM) */

#else /* #if (SYS_CPNT_RATE_BASED_STORM_CONTROL != TRUE) */

oid rateBasedStormTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,33,6 };

struct variable3 rateBasedStormTable_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
{LEAF_rateBasedStormIfIndex,  ASN_INTEGER,  RONLY,   var_rateBasedStormTable, 3,  { 1, 1, 1 }},
#endif

{LEAF_rateBasedStormRate,  ASN_INTEGER,  RWRITE,  var_rateBasedStormTable, 3,  { 1, 1, 2 }},
{LEAF_rateBasedStormMode,  ASN_OCTET_STR,  RWRITE,  var_rateBasedStormTable, 3,  { 1, 1, 3 }},
};

/** Initializes the rateBasedStormTable module */
void
init_rateBasedStormTable(void)
{
    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("rateBasedStormTable", rateBasedStormTable_variables, variable3,
                 rateBasedStormTable_variables_oid);
}
#endif /* #if (SYS_CPNT_RATE_BASED_STORM_CONTROL != TRUE) */

#if (SYS_CPNT_ATC_STORM == TRUE)
void
init_atcMgt(void)
{
#if (SYS_CPNT_ATC_BSTORM == TRUE)
    static oid atcBcastStormTcApplyTime_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,33,5,1,0 };
    static oid atcBcastStormTcReleaseTime_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,33,5,2,0 };
#endif
#if (SYS_CPNT_ATC_MSTORM == TRUE)
    static oid atcMcastStormTcApplyTime_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,33,5,4,0 };
    static oid atcMcastStormTcReleaseTime_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,33,5,5,0 };
#endif

  DEBUGMSGTL(("atcMgt", "Initializing\n"));

#if (SYS_CPNT_ATC_BSTORM == TRUE)
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("atcBcastStormTcApplyTime",
                               do_atcBcastStormTcApplyTime,
                               atcBcastStormTcApplyTime_oid,
                               OID_LENGTH(atcBcastStormTcApplyTime_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("atcBcastStormTcReleaseTime",
                               do_atcBcastStormTcReleaseTime,
                               atcBcastStormTcReleaseTime_oid,
                               OID_LENGTH(atcBcastStormTcReleaseTime_oid),
                               HANDLER_CAN_RWRITE));
#endif
#if (SYS_CPNT_ATC_MSTORM == TRUE)
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("atcMcastStormTcApplyTime",
                               do_atcMcastStormTcApplyTime,
                               atcMcastStormTcApplyTime_oid,
                               OID_LENGTH(atcMcastStormTcApplyTime_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("atcMcastStormTcReleaseTime",
                               do_atcMcastStormTcReleaseTime,
                               atcMcastStormTcReleaseTime_oid,
                               OID_LENGTH(atcMcastStormTcReleaseTime_oid),
                               HANDLER_CAN_RWRITE));
#endif
}

#if (SYS_CPNT_ATC_BSTORM == TRUE)
oid atcBcastStormTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,33,5 };

struct variable3 atcBcastStormTable_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
{LEAF_atcBcastStormIfIndex,  ASN_INTEGER,  RONLY,   var_atcBcastStormTable, 3,  { 3, 1, 1 }},
#endif
{LEAF_atcBcastStormEnable,  ASN_INTEGER,  RWRITE,  var_atcBcastStormTable, 3,  { 3, 1, 2 }},
{LEAF_atcBcastStormAutoRelease,  ASN_INTEGER,  RWRITE,  var_atcBcastStormTable, 3,  { 3, 1, 3 }},
{LEAF_atcBcastStormSampleType,  ASN_INTEGER,  RWRITE,  var_atcBcastStormTable, 3,  { 3, 1, 4 }},
{LEAF_atcBcastStormCurrentTrafficRate,  ASN_INTEGER,  RONLY,   var_atcBcastStormTable, 3,  { 3, 1, 5 }},
{LEAF_atcBcastStormAlarmFireThreshold,  ASN_INTEGER,  RWRITE,  var_atcBcastStormTable, 3,  { 3, 1, 6 }},
{LEAF_atcBcastStormAlarmClearThreshold,  ASN_INTEGER,  RWRITE,  var_atcBcastStormTable, 3,  { 3, 1, 7 }},
{LEAF_atcBcastStormTcAction,  ASN_INTEGER,  RWRITE,  var_atcBcastStormTable, 3,  { 3, 1, 8 }},
{LEAF_atcBcastStormAlarmFireTrapStatus,  ASN_INTEGER,  RWRITE,  var_atcBcastStormTable, 3,  { 3, 1, 9 }},
{LEAF_atcBcastStormAlarmClearTrapStatus,  ASN_INTEGER,  RWRITE,  var_atcBcastStormTable, 3,  { 3, 1, 10 }},
{LEAF_atcBcastStormTcApplyTrapStatus,  ASN_INTEGER,  RWRITE,  var_atcBcastStormTable, 3,  { 3, 1, 11 }},
{LEAF_atcBcastStormTcReleaseTrapStatus,  ASN_INTEGER,  RWRITE,  var_atcBcastStormTable, 3,  { 3, 1, 12 }},
{LEAF_atcBcastStormControlRelease,  ASN_INTEGER,  RWRITE,  var_atcBcastStormTable, 3,  { 3, 1, 13 }},
};
/*    (L = length of the oidsuffix) */

/** Initializes the atcBcastStormTable module */
void
init_atcBcastStormTable(void)
{

    DEBUGMSGTL(("atcBcastStormTable", "Initializing\n"));

    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("atcBcastStormTable", atcBcastStormTable_variables, variable3,
               atcBcastStormTable_variables_oid);

    /* place any other initialization junk you need here */
}
#endif /* end of SYS_CPNT_ATC_BSTORM */

#if (SYS_CPNT_ATC_MSTORM == TRUE)
oid atcMcastStormTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,33,5 };

struct variable3 atcMcastStormTable_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
{LEAF_atcMcastStormIfIndex,  ASN_INTEGER,  RONLY,   var_atcMcastStormTable, 3,  { 6, 1, 1 }},
#endif
{LEAF_atcMcastStormEnable,  ASN_INTEGER,  RWRITE,  var_atcMcastStormTable, 3,  { 6, 1, 2 }},
{LEAF_atcMcastStormAutoRelease,  ASN_INTEGER,  RWRITE,  var_atcMcastStormTable, 3,  { 6, 1, 3 }},
{LEAF_atcMcastStormSampleType,  ASN_INTEGER,  RWRITE,  var_atcMcastStormTable, 3,  { 6, 1, 4 }},
{LEAF_atcMcastStormCurrentTrafficRate,  ASN_INTEGER,  RONLY,   var_atcMcastStormTable, 3,  { 6, 1, 5 }},
{LEAF_atcMcastStormAlarmFireThreshold,  ASN_INTEGER,  RWRITE,  var_atcMcastStormTable, 3,  { 6, 1, 6 }},
{LEAF_atcMcastStormAlarmClearThreshold,  ASN_INTEGER,  RWRITE,  var_atcMcastStormTable, 3,  { 6, 1, 7 }},
{LEAF_atcMcastStormTcAction,  ASN_INTEGER,  RWRITE,  var_atcMcastStormTable, 3,  { 6, 1, 8 }},
{LEAF_atcMcastStormAlarmFireTrapStatus,  ASN_INTEGER,  RWRITE,  var_atcMcastStormTable, 3,  { 6, 1, 9 }},
{LEAF_atcMcastStormAlarmClearTrapStatus,  ASN_INTEGER,  RWRITE,  var_atcMcastStormTable, 3,  { 6, 1, 10 }},
{LEAF_atcMcastStormTcApplyTrapStatus,  ASN_INTEGER,  RWRITE,  var_atcMcastStormTable, 3,  { 6, 1, 11 }},
{LEAF_atcMcastStormTcReleaseTrapStatus,  ASN_INTEGER,  RWRITE,  var_atcMcastStormTable, 3,  { 6, 1, 12 }},
{LEAF_atcMcastStormControlRelease,  ASN_INTEGER,  RWRITE,  var_atcMcastStormTable, 3,  { 6, 1, 13 }},
};
/*    (L = length of the oidsuffix) */

/** Initializes the atcMcastStormTable module */
void
init_atcMcastStormTable(void)
{

    DEBUGMSGTL(("atcMcastStormTable", "Initializing\n"));

    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("atcMcastStormTable", atcMcastStormTable_variables, variable3,
               atcMcastStormTable_variables_oid);

    /* place any other initialization junk you need here */
}
#endif /* end of SYS_CPNT_ATC_MSTORM */
#endif /* #if (SYS_CPNT_ATC_STORM == TRUE) */

/********************************************
 ********************hsrpMgt*****************
 ********************************************
 */
#if (SYS_CPNT_HSRP == TRUE)
/** Initializes the hsrpMgt module */
void
init_hsrpMgt(void)
{
    static oid      cHsrpConfigTimeout_oid[] =
        { SYS_ADPT_PRIVATEMIB_OID, 1, 29, 1, 1, 0 };

    init_PrivateMIBNodeRootOIDbySwitchBoardID(cHsrpConfigTimeout_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("cHsrpConfigTimeout",
                               do_cHsrpConfigTimeout,
                               cHsrpConfigTimeout_oid,
                               OID_LENGTH(cHsrpConfigTimeout_oid),
                               HANDLER_CAN_RWRITE));
}


/********************************************
 *************cHsrpGrpTable******************
 ********************************************
 */
oid             cHsrpGrpTable_variables_oid[] =
    { SYS_ADPT_PRIVATEMIB_OID, 1, 29, 2};


struct variable3 cHsrpGrpTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */
    #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    {CHSRPGRPNUMBER, ASN_UNSIGNED, RONLY, var_cHsrpGrpTable, 3, {1, 1, 1}},
    #endif
    {CHSRPGRPAUTH, ASN_OCTET_STR, RWRITE, var_cHsrpGrpTable, 3, {1, 1, 2}},
    {CHSRPGRPPRIORITY, ASN_UNSIGNED, RWRITE, var_cHsrpGrpTable, 3,
     {1, 1, 3}},
    {CHSRPGRPPREEMPT, ASN_INTEGER, RWRITE, var_cHsrpGrpTable, 3,
     {1, 1, 4}},
    {CHSRPGRPPREEMPTDELAY, ASN_UNSIGNED, RWRITE, var_cHsrpGrpTable, 3,
     {1, 1, 5}},
    {CHSRPGRPUSECONFIGUREDTIMERS, ASN_INTEGER, RONLY, var_cHsrpGrpTable, 3,
     {1, 1, 6}},
    {CHSRPGRPCONFIGUREDHELLOTIME, ASN_UNSIGNED, RWRITE, var_cHsrpGrpTable,
     3, {1, 1, 7}},
    {CHSRPGRPCONFIGUREDHOLDTIME, ASN_UNSIGNED, RWRITE, var_cHsrpGrpTable,
     3, {1, 1, 8}},
    {CHSRPGRPLEARNEDHELLOTIME, ASN_UNSIGNED, RONLY, var_cHsrpGrpTable, 3,
     {1, 1, 9}},
    {CHSRPGRPLEARNEDHOLDTIME, ASN_UNSIGNED, RONLY, var_cHsrpGrpTable, 3,
     {1, 1, 10}},
    {CHSRPGRPVIRTUALIPADDR, ASN_IPADDRESS, RWRITE, var_cHsrpGrpTable, 3,
     {1, 1, 11}},
    {CHSRPGRPUSECONFIGVIRTUALIPADDR, ASN_INTEGER, RONLY, var_cHsrpGrpTable,
     3, {1, 1, 12}},
    {CHSRPGRPACTIVEROUTER, ASN_IPADDRESS, RONLY, var_cHsrpGrpTable, 3,
     {1, 1, 13}},
    {CHSRPGRPSTANDBYROUTER, ASN_IPADDRESS, RONLY, var_cHsrpGrpTable, 3,
     {1, 1, 14}},
    {CHSRPGRPSTANDBYSTATE, ASN_INTEGER, RONLY, var_cHsrpGrpTable, 3,
     {1, 1, 15}},
    {CHSRPGRPVIRTUALMACADDR, ASN_OCTET_STR, RONLY, var_cHsrpGrpTable, 3,
     {1, 1, 16}},
    {CHSRPGRPENTRYROWSTATUS, ASN_INTEGER, RWRITE, var_cHsrpGrpTable, 3,
     {1, 1, 17}},
};


/** Initializes the cHsrpGrpTable module */
void
init_cHsrpGrpTable(void)
{

    /*
     * register ourselves with the agent to handle our mib tree
     */
    init_PrivateMIBNodeRootOIDbySwitchBoardID(cHsrpGrpTable_variables_oid);
    REGISTER_MIB("cHsrpGrpTable", cHsrpGrpTable_variables, variable3,
                 cHsrpGrpTable_variables_oid);

}


/********************************************
 ******cHsrpExtIfTrackedTable****************
 ********************************************
 */
oid             cHsrpExtIfTrackedTable_variables_oid[] =
    { SYS_ADPT_PRIVATEMIB_OID, 1, 29, 3};



struct variable3 cHsrpExtIfTrackedTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */
    #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    {CHSRPEXTIFTRACKED, ASN_INTEGER, RONLY, var_cHsrpExtIfTrackedTable, 3,
     {1, 1, 1}},
#endif
    {CHSRPEXTIFTRACKEDPRIORITY, ASN_UNSIGNED, RWRITE,
     var_cHsrpExtIfTrackedTable, 3, {1, 1, 2}},
    {CHSRPEXTIFTRACKEDROWSTATUS, ASN_INTEGER, RWRITE,
     var_cHsrpExtIfTrackedTable, 3, {1, 1, 3}},
};
/*
 * (L = length of the oidsuffix)
 */


/** Initializes the cHsrpExtIfTrackedTable module */
void
init_cHsrpExtIfTrackedTable(void)
{

    /*
     * register ourselves with the agent to handle our mib tree
     */
    init_PrivateMIBNodeRootOIDbySwitchBoardID(cHsrpExtIfTrackedTable_variables_oid);
    REGISTER_MIB("cHsrpExtIfTrackedTable",
                 cHsrpExtIfTrackedTable_variables, variable3,
                 cHsrpExtIfTrackedTable_variables_oid);
}


/********************************************
 ********cHsrpExtSecAddrTable****************
 ********************************************
 */
oid             cHsrpExtSecAddrTable_variables_oid[] =
    { SYS_ADPT_PRIVATEMIB_OID, 1, 29, 3};

struct variable3 cHsrpExtSecAddrTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */
 /* This is an index*/
   #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    {CHSRPEXTSECADDRADDRESS, ASN_IPADDRESS, RONLY,
     var_cHsrpExtSecAddrTable, 3, {2, 1, 1}},
    #endif
    {CHSRPEXTSECADDRROWSTATUS, ASN_INTEGER, RWRITE,
     var_cHsrpExtSecAddrTable, 3, {2, 1, 2}},
};

/** Initializes the cHsrpExtSecAddrTable module */
void
init_cHsrpExtSecAddrTable(void)
{
    /*
     * register ourselves with the agent to handle our mib tree
     */
    init_PrivateMIBNodeRootOIDbySwitchBoardID(cHsrpExtSecAddrTable_variables_oid);
    REGISTER_MIB("cHsrpExtSecAddrTable", cHsrpExtSecAddrTable_variables,
                 variable3, cHsrpExtSecAddrTable_variables_oid);
}

#endif /* end of #if (SYS_CPNT_HSRP == TRUE)*/

#if (SYS_CPNT_EGRESS_PACKET_BLOCK == TRUE)
#if (SYS_CPNT_EGRESS_PACKET_BLOCK_UNKNOWN_MULTICAST == TRUE)
/**************************************************
 ********egressPacketBlockUnknownMcastTable********
 **************************************************
 */

oid egressPacketBlockUnknownMcastTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,45 };

struct variable3 egressPacketBlockUnknownMcastTable_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
{LEAF_egressPacketBlockUnknownMcastIfIndex,  ASN_INTEGER,  RONLY,   var_egressPacketBlockUnknownMcastTable, 3,  { 1, 1, 1 }},
#endif

{LEAF_egressPacketBlockUnknownMcastStatus,  ASN_INTEGER,  RWRITE,  var_egressPacketBlockUnknownMcastTable, 3,  { 1, 1, 2 }},
};
/*    (L = length of the oidsuffix) */

/** Initializes the egressPacketBlockUnknownMcastTable module */
void
init_egressPacketBlockUnknownMcastTable(void)
{

    DEBUGMSGTL(("egressPacketBlockUnknownMcastTable", "Initializing\n"));

    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("egressPacketBlockUnknownMcastTable", egressPacketBlockUnknownMcastTable_variables, variable3,
               egressPacketBlockUnknownMcastTable_variables_oid);

    /* place any other initialization junk you need here */
}
#endif /* (SYS_CPNT_EGRESS_PACKET_BLOCK_UNKNOWN_MULTICAST == TRUE) */

#if (SYS_CPNT_EGRESS_PACKET_BLOCK_UNKNOWN_UNICAST == TRUE)
/**************************************************
 ********egressPacketBlockUnknownUcastTable********
 **************************************************
 */

oid egressPacketBlockUnknownUcastTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,45 };

struct variable3 egressPacketBlockUnknownUcastTable_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
{LEAF_egressPacketBlockUnknownUcastIfIndex,  ASN_INTEGER,  RONLY,   var_egressPacketBlockUnknownUcastTable, 3,  { 2, 1, 1 }},
#endif

{LEAF_egressPacketBlockUnknownUcastStatus,  ASN_INTEGER,  RWRITE,  var_egressPacketBlockUnknownUcastTable, 3,  { 2, 1, 2 }},
};
/*    (L = length of the oidsuffix) */

/** Initializes the egressPacketBlockUnknownUcastTable module */
void
init_egressPacketBlockUnknownUcastTable(void)
{

    DEBUGMSGTL(("egressPacketBlockUnknownUcastTable", "Initializing\n"));

    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("egressPacketBlockUnknownUcastTable", egressPacketBlockUnknownUcastTable_variables, variable3,
               egressPacketBlockUnknownUcastTable_variables_oid);

    /* place any other initialization junk you need here */
}
#endif /* (SYS_CPNT_EGRESS_PACKET_BLOCK_UNKNOWN_UNICAST == TRUE) */

#if (SYS_CPNT_EGRESS_PACKET_BLOCK_BROADCAST == TRUE)
/**************************************************
 ********egressPacketBlockBcastTable********
 **************************************************
 */

oid egressPacketBlockBcastTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,45 };

struct variable3 egressPacketBlockBcastTable_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
{LEAF_egressPacketBlockBcastIfIndex,  ASN_INTEGER,  RONLY,   var_egressPacketBlockBcastTable, 3,  { 3, 1, 1 }},
#endif

{LEAF_egressPacketBlockBcastStatus,  ASN_INTEGER,  RWRITE,  var_egressPacketBlockBcastTable, 3,  { 3, 1, 2 }},
};
/*    (L = length of the oidsuffix) */

/** Initializes the egressPacketBlockBcastTable module */
void
init_egressPacketBlockBcastTable(void)
{

    DEBUGMSGTL(("egressPacketBlockBcastTable", "Initializing\n"));

    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("egressPacketBlockBcastTable", egressPacketBlockBcastTable_variables, variable3,
               egressPacketBlockBcastTable_variables_oid);

    /* place any other initialization junk you need here */
}
#endif /* (SYS_CPNT_EGRESS_PACKET_BLOCK_BROADCAST == TRUE) */
#endif /* (SYS_CPNT_EGRESS_PACKET_BLOCK == TRUE) */

#if (SYS_CPNT_DHCPSNP == TRUE)
/** Initializes the dhcpSnoopEnable module */
void
init_dhcpSnoopEnable(void)
{
    static oid dhcpSnoopEnable_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,46,1,1,0 };

  DEBUGMSGTL(("dhcpSnoopEnable", "Initializing\n"));

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("dhcpSnoopEnable",
                               do_dhcpSnoopEnable,
                               dhcpSnoopEnable_oid,
                               OID_LENGTH(dhcpSnoopEnable_oid),
                               HANDLER_CAN_RWRITE));
}

/** Initializes the dhcpSnoopVerifyMacAddressEnable module */
void
init_dhcpSnoopVerifyMacAddressEnable(void)
{
    static oid dhcpSnoopVerifyMacAddressEnable_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,46,1,2,0 };

  DEBUGMSGTL(("dhcpSnoopVerifyMacAddressEnable", "Initializing\n"));

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("dhcpSnoopVerifyMacAddressEnable",
                               do_dhcpSnoopVerifyMacAddressEnable,
                               dhcpSnoopVerifyMacAddressEnable_oid,
                               OID_LENGTH(dhcpSnoopVerifyMacAddressEnable_oid),
                               HANDLER_CAN_RWRITE));
}

#if (SYS_CPNT_DHCPSNP_INFORMATION_OPTION == TRUE)
/** Initializes the dhcpSnoopGlobal module */
void
init_dhcpSnoopGlobal(void)
{
    static oid dhcpSnoopInformationOptionEnable_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,46,1,3,0 };
    static oid dhcpSnoopInformationOptionPolicy_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,46,1,4,0 };

  DEBUGMSGTL(("dhcpSnoopGlobal", "Initializing\n"));

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("dhcpSnoopInformationOptionEnable",
                               do_dhcpSnoopInformationOptionEnable,
                               dhcpSnoopInformationOptionEnable_oid,
                               OID_LENGTH(dhcpSnoopInformationOptionEnable_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("dhcpSnoopInformationOptionPolicy",
                               do_dhcpSnoopInformationOptionPolicy,
                               dhcpSnoopInformationOptionPolicy_oid,
                               OID_LENGTH(dhcpSnoopInformationOptionPolicy_oid),
                               HANDLER_CAN_RWRITE));
}
#endif

#if (SYS_CPNT_CFGDB == TRUE)
/** Initializes the dhcpSnoopBindingsTableCtlAction module */
void
init_dhcpSnoopBindingsTableCtlAction(void)
{
    static oid dhcpSnoopBindingsTableCtlAction_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,46,1,5,0 };

  DEBUGMSGTL(("dhcpSnoopBindingsTableCtlAction", "Initializing\n"));

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("dhcpSnoopBindingsTableCtlAction",
                               do_dhcpSnoopBindingsTableCtlAction,
                               dhcpSnoopBindingsTableCtlAction_oid,
                               OID_LENGTH(dhcpSnoopBindingsTableCtlAction_oid),
                               HANDLER_CAN_RWRITE));
}
#endif

#if (SYS_CPNT_DHCPSNP_SYSTEM_RATELIMIT == TRUE)
void init_dhcpSnoopLimitRate(void)
{
    static oid dhcpSnoopLimitRate_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,46,1,6,0 };

    DEBUGMSGTL(("dhcpSnoopLimitRate", "Initializing\n"));

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("dhcpSnoopLimitRate",
                               do_dhcpSnoopLimitRate,
                               dhcpSnoopLimitRate_oid,
                               OID_LENGTH(dhcpSnoopLimitRate_oid),
                               HANDLER_CAN_RWRITE));
}

#endif

/*
 * dhcpSnoopVlanConfigTable_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid dhcpSnoopVlanConfigTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,46,2 };

struct variable3 dhcpSnoopVlanConfigTable_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
{LEAF_dhcpSnoopVlanIndex,  ASN_UNSIGNED,  RONLY,   var_dhcpSnoopVlanConfigTable, 3,  { 1, 1, 1 }},
#endif

{LEAF_dhcpSnoopVlanEnable,  ASN_INTEGER,  RWRITE,  var_dhcpSnoopVlanConfigTable, 3,  { 1, 1, 2 }},
};
/*    (L = length of the oidsuffix) */

/** Initializes the dhcpSnoopVlanConfigTable module */
void
init_dhcpSnoopVlanConfigTable(void)
{

    DEBUGMSGTL(("dhcpSnoopVlanConfigTable", "Initializing\n"));

    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("dhcpSnoopVlanConfigTable", dhcpSnoopVlanConfigTable_variables, variable3,
               dhcpSnoopVlanConfigTable_variables_oid);

    /* place any other initialization junk you need here */
}

/*
 * dhcpSnoopPortConfigTable_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid dhcpSnoopPortConfigTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,46,3 };

struct variable3 dhcpSnoopPortConfigTable_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
{LEAF_dhcpSnoopPortIfIndex,  ASN_INTEGER,  RONLY,   var_dhcpSnoopPortConfigTable, 3,  { 1, 1, 1 }},
#endif

{LEAF_dhcpSnoopPortTrustEnable,  ASN_INTEGER,  RWRITE,  var_dhcpSnoopPortConfigTable, 3,  { 1, 1, 2 }},
};
/*    (L = length of the oidsuffix) */

/** Initializes the dhcpSnoopPortConfigTable module */
void
init_dhcpSnoopPortConfigTable(void)
{

    DEBUGMSGTL(("dhcpSnoopPortConfigTable", "Initializing\n"));

    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("dhcpSnoopPortConfigTable", dhcpSnoopPortConfigTable_variables, variable3,
               dhcpSnoopPortConfigTable_variables_oid);

    /* place any other initialization junk you need here */
}

/*
 * dhcpSnoopBindingsTable_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid dhcpSnoopBindingsTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,46,4 };

struct variable3 dhcpSnoopBindingsTable_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
{LEAF_dhcpSnoopBindingsVlanIndex,  ASN_UNSIGNED,  RONLY,   var_dhcpSnoopBindingsTable, 3,  { 1, 1, 1 }},
#endif

#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
{LEAF_dhcpSnoopBindingsMacAddress,  ASN_OCTET_STR,  RONLY,   var_dhcpSnoopBindingsTable, 3,  { 1, 1, 2 }},
#endif

{LEAF_dhcpSnoopBindingsAddrType,  ASN_INTEGER,  RONLY,  var_dhcpSnoopBindingsTable, 3,  { 1, 1, 3 }},
{LEAF_dhcpSnoopBindingsEntryType,  ASN_INTEGER,  RONLY,   var_dhcpSnoopBindingsTable, 3,  { 1, 1, 4 }},
{LEAF_dhcpSnoopBindingsIpAddress,  ASN_IPADDRESS,  RONLY,  var_dhcpSnoopBindingsTable, 3,  { 1, 1, 5 }},
{LEAF_dhcpSnoopBindingsPortIfIndex,  ASN_INTEGER,  RONLY,  var_dhcpSnoopBindingsTable, 3,  { 1, 1, 6 }},
{LEAF_dhcpSnoopBindingsLeaseTime,  ASN_UNSIGNED,  RONLY,  var_dhcpSnoopBindingsTable, 3,  { 1, 1, 7 }},
#if 0
{LEAF_dhcpSnoopBindingsStatus,  ASN_INTEGER,  RONLY,  var_dhcpSnoopBindingsTable, 3,  { 1, 1, 8 }},
#endif
};
/*    (L = length of the oidsuffix) */

/** Initializes the dhcpSnoopBindingsTable module */
void
init_dhcpSnoopBindingsTable(void)
{

    DEBUGMSGTL(("dhcpSnoopBindingsTable", "Initializing\n"));

    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("dhcpSnoopBindingsTable", dhcpSnoopBindingsTable_variables, variable3,
               dhcpSnoopBindingsTable_variables_oid);

    /* place any other initialization junk you need here */
}

/** Initializes the dhcpSnoopTotalForwardedPkts module */
void
init_dhcpSnoopTotalForwardedPkts(void)
{
    static oid dhcpSnoopTotalForwardedPkts_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,46,5,1,0 };

  DEBUGMSGTL(("dhcpSnoopTotalForwardedPkts", "Initializing\n"));

    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("dhcpSnoopTotalForwardedPkts",
                                         get_dhcpSnoopTotalForwardedPkts,
                                         dhcpSnoopTotalForwardedPkts_oid,
                                         OID_LENGTH(dhcpSnoopTotalForwardedPkts_oid),
                                         HANDLER_CAN_RONLY));
}

/** Initializes the dhcpSnoopUntrustedPortDroppedPkts module */
void
init_dhcpSnoopUntrustedPortDroppedPkts(void)
{
    static oid dhcpSnoopUntrustedPortDroppedPkts_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,46,5,3,0 };

  DEBUGMSGTL(("dhcpSnoopUntrustedPortDroppedPkts", "Initializing\n"));

    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("dhcpSnoopUntrustedPortDroppedPkts",
                                         get_dhcpSnoopUntrustedPortDroppedPkts,
                                         dhcpSnoopUntrustedPortDroppedPkts_oid,
                                         OID_LENGTH(dhcpSnoopUntrustedPortDroppedPkts_oid),
                                         HANDLER_CAN_RONLY));
}

#endif


#if (SYS_CPNT_CLUSTER==TRUE)
/** Initializes the clusterMgt module */

void
init_clusterMgt(void)
{
    static oid clusterEnable_oid[] = { SYS_ADPT_PRIVATEMIB_OID ,1,47,1,0 };
    static oid clusterCommanderEnable_oid[] = { SYS_ADPT_PRIVATEMIB_OID ,1,47,2,0 };
    static oid clusterIpPool_oid[] = { SYS_ADPT_PRIVATEMIB_OID ,1,47,4,0 };
    static oid clusterClearCandidateTable_oid[] = { SYS_ADPT_PRIVATEMIB_OID ,1,47,5,0 };
    static oid clusterRole_oid[] = { SYS_ADPT_PRIVATEMIB_OID ,1,47,6,0 };
    static oid clusterMemberCount_oid[] = { SYS_ADPT_PRIVATEMIB_OID ,1,47,7,0 };
    static oid clusterCandidateCount_oid[] = { SYS_ADPT_PRIVATEMIB_OID ,1,47,8,0 };
    static oid clusterMemberAddCtlMacAddr_oid[] = { SYS_ADPT_PRIVATEMIB_OID ,1,47,11,1,0 };
    static oid clusterMemberAddCtlId_oid[] = { SYS_ADPT_PRIVATEMIB_OID ,1,47,11,2,0 };
    static oid clusterMemberAddCtlAction_oid[] = { SYS_ADPT_PRIVATEMIB_OID ,1,47,11,5,0 };
    static oid clusterMemberRemoveCtlId_oid[] = { SYS_ADPT_PRIVATEMIB_OID ,1,47,12,1,0 };
    static oid clusterMemberRemoveCtlAction_oid[] = { SYS_ADPT_PRIVATEMIB_OID ,1,47,12,2,0 };

    DEBUGMSGTL(("clusterMgt", "Initializing\n"));

    init_PrivateMIBNodeRootOIDbySwitchBoardID(clusterEnable_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("clusterEnable",
                               do_clusterEnable,
                               clusterEnable_oid,
                               OID_LENGTH(clusterEnable_oid),
                               HANDLER_CAN_RWRITE));
    init_PrivateMIBNodeRootOIDbySwitchBoardID(clusterCommanderEnable_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("clusterCommanderEnable",
                               do_clusterCommanderEnable,
                               clusterCommanderEnable_oid,
                               OID_LENGTH(clusterCommanderEnable_oid),
                               HANDLER_CAN_RWRITE));
    init_PrivateMIBNodeRootOIDbySwitchBoardID(clusterIpPool_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("clusterIpPool",
                               do_clusterIpPool,
                               clusterIpPool_oid,
                               OID_LENGTH(clusterIpPool_oid),
                               HANDLER_CAN_RWRITE));
    init_PrivateMIBNodeRootOIDbySwitchBoardID(clusterClearCandidateTable_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("clusterClearCandidateTable",
                               do_clusterClearCandidateTable,
                               clusterClearCandidateTable_oid,
                               OID_LENGTH(clusterClearCandidateTable_oid),
                               HANDLER_CAN_RWRITE));
    init_PrivateMIBNodeRootOIDbySwitchBoardID(clusterRole_oid);
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("clusterRole",
                                         get_clusterRole,
                                         clusterRole_oid,
                                         OID_LENGTH(clusterRole_oid),
                                         HANDLER_CAN_RONLY));
    init_PrivateMIBNodeRootOIDbySwitchBoardID(clusterMemberCount_oid);
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("clusterMemberCount",
                                         get_clusterMemberCount,
                                         clusterMemberCount_oid,
                                         OID_LENGTH(clusterMemberCount_oid),
                                         HANDLER_CAN_RONLY));
    init_PrivateMIBNodeRootOIDbySwitchBoardID(clusterCandidateCount_oid);
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("clusterCandidateCount",
                                         get_clusterCandidateCount,
                                         clusterCandidateCount_oid,
                                         OID_LENGTH(clusterCandidateCount_oid),
                                         HANDLER_CAN_RONLY));
    init_PrivateMIBNodeRootOIDbySwitchBoardID(clusterMemberAddCtlMacAddr_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("clusterMemberAddCtlMacAddr",
                               do_clusterMemberAddCtlMacAddr,
                               clusterMemberAddCtlMacAddr_oid,
                               OID_LENGTH(clusterMemberAddCtlMacAddr_oid),
                               HANDLER_CAN_RWRITE));
    init_PrivateMIBNodeRootOIDbySwitchBoardID(clusterMemberAddCtlId_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("clusterMemberAddCtlId",
                               do_clusterMemberAddCtlId,
                               clusterMemberAddCtlId_oid,
                               OID_LENGTH(clusterMemberAddCtlId_oid),
                               HANDLER_CAN_RWRITE));
    init_PrivateMIBNodeRootOIDbySwitchBoardID(clusterMemberAddCtlAction_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("clusterMemberAddCtlAction",
                               do_clusterMemberAddCtlAction,
                               clusterMemberAddCtlAction_oid,
                               OID_LENGTH(clusterMemberAddCtlAction_oid),
                               HANDLER_CAN_RWRITE));
    init_PrivateMIBNodeRootOIDbySwitchBoardID(clusterMemberRemoveCtlId_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("clusterMemberRemoveCtlId",
                               do_clusterMemberRemoveCtlId,
                               clusterMemberRemoveCtlId_oid,
                               OID_LENGTH(clusterMemberRemoveCtlId_oid),
                               HANDLER_CAN_RWRITE));
    init_PrivateMIBNodeRootOIDbySwitchBoardID(clusterMemberRemoveCtlAction_oid);
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("clusterMemberRemoveCtlAction",
                               do_clusterMemberRemoveCtlAction,
                               clusterMemberRemoveCtlAction_oid,
                               OID_LENGTH(clusterMemberRemoveCtlAction_oid),
                               HANDLER_CAN_RWRITE));
}

/*
 * clusterCandidateTable_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid clusterCandidateTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID ,1,47 };
/*
 * variable3 clusterCandidateTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */

struct variable3 clusterCandidateTable_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
{LEAF_clusterCandidateMacAddr,  ASN_OCTET_STR,  RONLY,   var_clusterCandidateTable, 3,  { 9, 1, 1 }},
#endif

{LEAF_clusterCandidateDesc,  ASN_OCTET_STR,  RONLY,   var_clusterCandidateTable, 3,  { 9, 1, 3 }},
{LEAF_clusterCandidateRole,  ASN_INTEGER,  RONLY,   var_clusterCandidateTable, 3,  { 9, 1, 4 }}
};
/*    (L = length of the oidsuffix) */

/** Initializes the clusterCandidateTable module */
void
init_clusterCandidateTable(void)
{

    DEBUGMSGTL(("clusterCandidateTable", "Initializing\n"));

    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("clusterCandidateTable", clusterCandidateTable_variables, variable3,
               clusterCandidateTable_variables_oid);

    /* place any other initialization junk you need here */
}

/*
 * clusterMemberTable_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid clusterMemberTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID ,1,47 };
/*
 * variable3 clusterMemberTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */

struct variable3 clusterMemberTable_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
{LEAF_clusterMemberId,  ASN_UNSIGNED,  RONLY,   var_clusterMemberTable, 3,  { 10, 1, 1 }},
#endif

{LEAF_clusterMemberMacAddr,  ASN_OCTET_STR,  RONLY,   var_clusterMemberTable, 3,  { 10, 1, 2 }},
{LEAF_clusterMemberDesc,  ASN_OCTET_STR,  RONLY,   var_clusterMemberTable, 3,  { 10, 1, 3 }},
{LEAF_clusterMemberActive,  ASN_INTEGER,  RONLY,   var_clusterMemberTable, 3,  { 10, 1, 4 }},
};
/*    (L = length of the oidsuffix) */

/** Initializes the clusterMemberTable module */
void
init_clusterMemberTable(void)
{

    DEBUGMSGTL(("clusterMemberTable", "Initializing\n"));

    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("clusterMemberTable", clusterMemberTable_variables, variable3,
               clusterMemberTable_variables_oid);

    /* place any other initialization junk you need here */
}

#endif /*end of #if (SYS_CPNT_CLUSTER==TRUE)*/

/* ipSrcGuardMgt */
#if (SYS_CPNT_IP_SOURCE_GUARD == TRUE)
/*
 * ipSrcGuardConfigTable_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid ipSrcGuardConfigTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,48 };

struct variable3 ipSrcGuardConfigTable_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    {LEAF_ipSrcGuardPortIfIndex,  ASN_INTEGER,  RONLY,   var_ipSrcGuardConfigTable, 3,  { 1, 1, 1 }},
#endif
    {LEAF_ipSrcGuardMode,  ASN_INTEGER,  RWRITE,  var_ipSrcGuardConfigTable, 3,  { 1, 1, 2 }},
};
/*    (L = length of the oidsuffix) */

/** Initializes the ipSrcGuardConfigTable module */
void
init_ipSrcGuardConfigTable(void)
{

    DEBUGMSGTL(("ipSrcGuardConfigTable", "Initializing\n"));

    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("ipSrcGuardConfigTable", ipSrcGuardConfigTable_variables, variable3,
                 ipSrcGuardConfigTable_variables_oid);
}

/* Deprecated */
#if 0
/*
 * ipSrcGuardAddrTable_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid ipSrcGuardAddrTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,48 };

struct variable3 ipSrcGuardAddrTable_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    {LEAF_ipSrcGuardBindingsVlanIndex,  ASN_UNSIGNED,  RONLY,   var_ipSrcGuardAddrTable, 3,  { 2, 1, 1 }},
    {LEAF_ipSrcGuardBindingsMacAddress,  ASN_OCTET_STR,  RONLY,   var_ipSrcGuardAddrTable, 3,  { 2, 1, 2 }},
#endif
    {LEAF_ipSrcGuardBindingsAddrType,  ASN_INTEGER,  RWRITE,  var_ipSrcGuardAddrTable, 3,  { 2, 1, 3 }},
    {LEAF_ipSrcGuardBindingsEntryType,  ASN_INTEGER,  RONLY,   var_ipSrcGuardAddrTable, 3,  { 2, 1, 4 }},
    {LEAF_ipSrcGuardBindingsIpAddress,  ASN_IPADDRESS,  RWRITE,  var_ipSrcGuardAddrTable, 3,  { 2, 1, 5 }},
    {LEAF_ipSrcGuardBindingsPortIfIndex,  ASN_INTEGER,  RWRITE,  var_ipSrcGuardAddrTable, 3,  { 2, 1, 6 }},
    {LEAF_ipSrcGuardBindingsLeaseTime,  ASN_UNSIGNED,  RONLY,   var_ipSrcGuardAddrTable, 3,  { 2, 1, 7 }},
    {LEAF_ipSrcGuardBindingsStatus,  ASN_INTEGER,  RWRITE,  var_ipSrcGuardAddrTable, 3,  { 2, 1, 8 }},
};
/*    (L = length of the oidsuffix) */

/** Initializes the ipSrcGuardAddrTable module */
void
init_ipSrcGuardAddrTable(void)
{
    DEBUGMSGTL(("ipSrcGuardAddrTable", "Initializing\n"));

    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("ipSrcGuardAddrTable", ipSrcGuardAddrTable_variables, variable3,
                 ipSrcGuardAddrTable_variables_oid);
}
#endif

oid ipSrcGuardAclTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,48 };

struct variable3 ipSrcGuardAclTable_variables[] =
{
/* magic number, variable type, ro/rw, callback fn, L, oidsuffix
 */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_ipSrcGuardAclBindingIpAddress, ASN_IPADDRESS, RONLY, var_ipSrcGuardAclTable, 3, { 3, 1, 1 }},
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_ipSrcGuardAclBindingMacAddress, ASN_OCTET_STR, RONLY, var_ipSrcGuardAclTable, 3, { 3, 1, 2 }},
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_ipSrcGuardAclBindingEntryType, ASN_INTEGER, RONLY, var_ipSrcGuardAclTable, 3, { 3, 1, 3 }},
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

    { LEAF_ipSrcGuardAclBindingVlanIndex, ASN_UNSIGNED, RWRITE, var_ipSrcGuardAclTable, 3, { 3, 1, 4 }},
    { LEAF_ipSrcGuardAclBindingPortIfIndex, ASN_INTEGER, RWRITE, var_ipSrcGuardAclTable, 3, { 3, 1, 5 }},
    { LEAF_ipSrcGuardAclBindingStatus, ASN_INTEGER, RWRITE, var_ipSrcGuardAclTable, 3, { 3, 1, 6 }},
};

void init_ipSrcGuardAclTable(void)
{
    DEBUGMSGTL(("init_ipSrcGuardAclTable", "Initializing\n"));

    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("ipSrcGuardAclTable", ipSrcGuardAclTable_variables, variable3,
                 ipSrcGuardAclTable_variables_oid);
}

#if (SYS_CPNT_IPSG_BINDING_FILTER_SOURCE == TRUE)
/** Initializes the ipSrcGuardBindingFilterSource module */
void
init_ipSrcGuardBindingFilterSource(void)
{
    static oid ipSrcGuardBindingFilterSource_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,48,4,0};

    DEBUGMSGTL(("ipSrcGuardBindingFilterSource", "Initializing\n"));

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("ipSrcGuardBindingFilterSource",
                               do_ipSrcGuardBindingFilterSource,
                               ipSrcGuardBindingFilterSource_oid,
                               OID_LENGTH(ipSrcGuardBindingFilterSource_oid),
                               HANDLER_CAN_RWRITE));
}
#endif  /* #if (SYS_CPNT_IPSG_BINDING_FILTER_SOURCE == TRUE) */
#endif  /* #if (SYS_CPNT_IP_SOURCE_GUARD == TRUE) */


/* Modify private MIB node's root OID accroding to current switch board id */
static BOOL_T init_PrivateMIBNodeRootOIDbySwitchBoardID(oid *node_oid)
{

    oid private_mib_root_by_board_id[32]={0};/*MAX_OID_LEN*/
    UI32_T oidlen = 0;
    UI32_T board_id;

    if(node_oid != NULL)
    {

        init_BoardIDStringToMIBRootOID(&board_id, private_mib_root_by_board_id, &oidlen);

        memcpy(node_oid, private_mib_root_by_board_id, oidlen * sizeof(oid));
    }
    else
    {
        return FALSE;
    }

    return TRUE;
}

/* ---------------------------------------------------------------------
 * ROUTINE NAME  - init_BoardIDStringToMIBRootOID
 * ---------------------------------------------------------------------
 * PURPOSE: Get private MIB root oid by board id
 * INPUT:   None
 * OUTPUT:  out_board_id(used for init_PrivateMibSysOrTable function),
            private_mib_root_oid(array, maximum size = 32),
            private_mib_root_oid_length
 * RETURN:  TRUE
 * NOTES:   None
 * ---------------------------------------------------------------------
 */
static BOOL_T init_BoardIDStringToMIBRootOID(UI32_T *out_board_id, oid *private_mib_root_oid, UI32_T *private_mib_root_oid_length)
{

    UI32_T board_id;


    if (FALSE == STKTPLG_POM_GetUnitBoardID(SYS_VAL_LOCAL_UNIT_ID, &board_id))
    {
        board_id = 0;
    }

    *out_board_id = board_id;

    switch(board_id)
    {
         case 0:
            SNMP_MGR_StringToObejctID(private_mib_root_oid,(I8_T *)SYS_ADPT_PRIVATE_MIB_ROOT_FOR_BOARD_ID0,private_mib_root_oid_length);
            break;
         case 1:
            SNMP_MGR_StringToObejctID(private_mib_root_oid,(I8_T *)SYS_ADPT_PRIVATE_MIB_ROOT_FOR_BOARD_ID1,private_mib_root_oid_length);
            break;
         case 2:
            SNMP_MGR_StringToObejctID(private_mib_root_oid,(I8_T *)SYS_ADPT_PRIVATE_MIB_ROOT_FOR_BOARD_ID2,private_mib_root_oid_length);
            break;
         case 3:
            SNMP_MGR_StringToObejctID(private_mib_root_oid,(I8_T *)SYS_ADPT_PRIVATE_MIB_ROOT_FOR_BOARD_ID3,private_mib_root_oid_length);
            break;
         case 4:
            SNMP_MGR_StringToObejctID(private_mib_root_oid,(I8_T *)SYS_ADPT_PRIVATE_MIB_ROOT_FOR_BOARD_ID4,private_mib_root_oid_length);
            break;
         case 5:
            SNMP_MGR_StringToObejctID(private_mib_root_oid,(I8_T *)SYS_ADPT_PRIVATE_MIB_ROOT_FOR_BOARD_ID5,private_mib_root_oid_length);
            break;
         case 6:
            SNMP_MGR_StringToObejctID(private_mib_root_oid,(I8_T *)SYS_ADPT_PRIVATE_MIB_ROOT_FOR_BOARD_ID6,private_mib_root_oid_length);
            break;
         case 7:
            SNMP_MGR_StringToObejctID(private_mib_root_oid,(I8_T *)SYS_ADPT_PRIVATE_MIB_ROOT_FOR_BOARD_ID7,private_mib_root_oid_length);
            break;
         default:
            SNMP_MGR_StringToObejctID(private_mib_root_oid,(I8_T *)SYS_ADPT_PRIVATE_MIB_ROOT_FOR_BOARD_ID0,private_mib_root_oid_length);
            break;
      }

    return TRUE;

}

#if (SYS_CPNT_EFM_OAM == TRUE)
/********************************************
 *******   init_oamPortClearStatTable  ******
 ********************************************
 */
static oid oamPortClearStatTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,52 };

struct variable3 oamPortClearStatTable_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
{LEAF_oamPortClearStatIndex,  ASN_INTEGER,  RONLY,   var_oamPortClearStatTable, 3,  { 3, 1, 1 }},
#endif

{LEAF_oamClearStatistics,  ASN_INTEGER,  RWRITE,  var_oamPortClearStatTable, 3,  { 3, 1, 2 }},
};

void
init_oamPortClearStatTable(void)
{
    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("oamPortClearStatTable", oamPortClearStatTable_variables, variable3,
                 oamPortClearStatTable_variables_oid);
}
#endif    /* #if (SYS_CPNT_EFM_OAM == TRUE) */


#if (SYS_CPNT_MLDSNP == TRUE)

void
init_mldSnoopStatus(void)
{
    static oid mldSnoopStatus_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,54,1,0 };

    DEBUGMSGTL(("mldSnoopStatus", "Initializing\n"));

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("mldSnoopStatus",
                               do_mldSnoopStatus,
                               mldSnoopStatus_oid,
                               OID_LENGTH(mldSnoopStatus_oid),
                               HANDLER_CAN_RWRITE));
}

void
init_mldSnoopQuerier(void)
{
    static oid mldSnoopQuerier_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,54,2,0 };

    DEBUGMSGTL(("mldSnoopQuerier", "Initializing\n"));

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("mldSnoopQuerier",
                               do_mldSnoopQuerier,
                               mldSnoopQuerier_oid,
                               OID_LENGTH(mldSnoopQuerier_oid),
                               HANDLER_CAN_RWRITE));
}

void
init_mldSnoopRobustness(void)
{
    static oid mldSnoopRobustness_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,54,3,0 };

    DEBUGMSGTL(("mldSnoopRobustness", "Initializing\n"));

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("mldSnoopRobustness",
                               do_mldSnoopRobustness,
                               mldSnoopRobustness_oid,
                               OID_LENGTH(mldSnoopRobustness_oid),
                               HANDLER_CAN_RWRITE));
}

void
init_mldSnoopQueryInterval(void)
{
    static oid mldSnoopQueryInterval_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,54,4,0 };

    DEBUGMSGTL(("mldSnoopQueryInterval", "Initializing\n"));

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("mldSnoopQueryInterval",
                               do_mldSnoopQueryInterval,
                               mldSnoopQueryInterval_oid,
                               OID_LENGTH(mldSnoopQueryInterval_oid),
                               HANDLER_CAN_RWRITE));
}

void
init_mldSnoopQueryMaxResponseTime(void)
{
    static oid mldSnoopQueryMaxResponseTime_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,54,5,0 };

    DEBUGMSGTL(("mldSnoopQueryMaxResponseTime", "Initializing\n"));

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("mldSnoopQueryMaxResponseTime",
                               do_mldSnoopQueryMaxResponseTime,
                               mldSnoopQueryMaxResponseTime_oid,
                               OID_LENGTH(mldSnoopQueryMaxResponseTime_oid),
                               HANDLER_CAN_RWRITE));
}

void
init_mldSnoopRouterPortExpireTime(void)
{
    static oid mldSnoopRouterPortExpireTime_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,54,6,0 };

    DEBUGMSGTL(("mldSnoopRouterPortExpireTime", "Initializing\n"));

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("mldSnoopRouterPortExpireTime",
                               do_mldSnoopRouterPortExpireTime,
                               mldSnoopRouterPortExpireTime_oid,
                               OID_LENGTH(mldSnoopRouterPortExpireTime_oid),
                               HANDLER_CAN_RWRITE));
}

void
init_mldSnoopVersion(void)
{
    static oid mldSnoopVersion_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,54,7,0 };

    DEBUGMSGTL(("mldSnoopVersion", "Initializing\n"));

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("mldSnoopVersion",
                               do_mldSnoopVersion,
                               mldSnoopVersion_oid,
                               OID_LENGTH(mldSnoopVersion_oid),
                               HANDLER_CAN_RWRITE));
}

void
init_mldSnoopUnknownMcastMode(void)
{
    static oid mldSnoopUnknownMcastMode_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,54,8,0 };

    DEBUGMSGTL(("mldSnoopUnknownMcastMode", "Initializing\n"));

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("mldSnoopUnknownMcastMode",
                               do_mldSnoopUnknownMcastMode,
                               mldSnoopUnknownMcastMode_oid,
                               OID_LENGTH(mldSnoopUnknownMcastMode_oid),
                               HANDLER_CAN_RWRITE));
}

/********************************************
 ****** init_mldSnoopRouterCurrentTable  ****
 ********************************************
 */
oid mldSnoopRouterCurrentTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,54 };

struct variable3 mldSnoopRouterCurrentTable_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
{LEAF_mldSnoopRouterCurrentVlanIndex,  ASN_UNSIGNED,  RONLY,   var_mldSnoopRouterCurrentTable, 3,  { 9, 1, 1 }},
#endif

{LEAF_mldSnoopRouterCurrentPorts,  ASN_OCTET_STR,  RONLY,   var_mldSnoopRouterCurrentTable, 3,  { 9, 1, 2 }},
};

/** Initializes the mldSnoopRouterCurrentTable module */
void
init_mldSnoopRouterCurrentTable(void)
{
    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("mldSnoopRouterCurrentTable", mldSnoopRouterCurrentTable_variables, variable3,
                 mldSnoopRouterCurrentTable_variables_oid);
}

/********************************************
 ****** init_mldSnoopRouterCurrentTable  ****
 ********************************************
 */
oid mldSnoopRouterStaticTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,54 };

struct variable3 mldSnoopRouterStaticTable_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
{LEAF_mldSnoopRouterStaticVlanIndex,  ASN_UNSIGNED,  RONLY,   var_mldSnoopRouterStaticTable, 3,  { 10, 1, 1 }},
#endif

{LEAF_mldSnoopRouterStaticPorts,  ASN_OCTET_STR,  RWRITE,  var_mldSnoopRouterStaticTable, 3,  { 10, 1, 2 }},
//{LEAF_mldSnoopRouterStaticStatus,  ASN_INTEGER,  RWRITE,  var_mldSnoopRouterStaticTable, 3,  { 10, 1, 3 }},
};

/** Initializes the mldSnoopRouterStaticTable module */
void
init_mldSnoopRouterStaticTable(void)
{
    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("mldSnoopRouterStaticTable", mldSnoopRouterStaticTable_variables, variable3,
                 mldSnoopRouterStaticTable_variables_oid);
}

/********************************************
 ***** init_mldSnoopMulticastCurrentTable ***
 ********************************************
 */
oid mldSnoopMulticastCurrentTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,54 };

struct variable3 mldSnoopMulticastCurrentTable_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
{LEAF_mldSnoopMulticastCurrentVlanIndex,  ASN_UNSIGNED,  RONLY,   var_mldSnoopMulticastCurrentTable, 3,  { 11, 1, 1 }},
#endif

#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
{LEAF_mldSnoopMulticastCurrentIpAddress,  ASN_OCTET_STR,  RONLY,   var_mldSnoopMulticastCurrentTable, 3,  { 11, 1, 2 }},
#endif

{LEAF_mldSnoopMulticastCurrentPorts,  ASN_OCTET_STR,  RONLY,   var_mldSnoopMulticastCurrentTable, 3,  { 11, 1, 3 }},
};

/** Initializes the mldSnoopMulticastCurrentTable module */
void
init_mldSnoopMulticastCurrentTable(void)
{
    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("mldSnoopMulticastCurrentTable", mldSnoopMulticastCurrentTable_variables, variable3,
                 mldSnoopMulticastCurrentTable_variables_oid);
}

/********************************************
 ***** init_mldSnoopMulticastStaticTable ****
 ********************************************
 */
oid mldSnoopMulticastStaticTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,54 };

struct variable3 mldSnoopMulticastStaticTable_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
{LEAF_mldSnoopMulticastStaticVlanIndex,  ASN_UNSIGNED,  RONLY,   var_mldSnoopMulticastStaticTable, 3,  { 12, 1, 1 }},
#endif

#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
{LEAF_mldSnoopMulticastStaticIpAddress,  ASN_OCTET_STR,  RONLY,   var_mldSnoopMulticastStaticTable, 3,  { 12, 1, 2 }},
#endif

{LEAF_mldSnoopMulticastStaticPorts,  ASN_OCTET_STR,  RWRITE,  var_mldSnoopMulticastStaticTable, 3,  { 12, 1, 3 }},
//{LEAF_mldSnoopMulticastStaticStatus,  ASN_INTEGER,  RWRITE,  var_mldSnoopMulticastStaticTable, 3,  { 12, 1, 4 }},
};

/** Initializes the mldSnoopMulticastStaticTable module */
void
init_mldSnoopMulticastStaticTable(void)
{
    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("mldSnoopMulticastStaticTable", mldSnoopMulticastStaticTable_variables, variable3,
                 mldSnoopMulticastStaticTable_variables_oid);
}

/********************************************
 ****** init_mldSnoopCurrentVlanTable *******
 ********************************************
 */
oid mldSnoopCurrentVlanTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,54 };

struct variable3 mldSnoopCurrentVlanTable_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
{LEAF_mldSnoopCurrentVlanIndex,  ASN_UNSIGNED,  RONLY,   var_mldSnoopCurrentVlanTable, 3,  { 13, 1, 1 }},
#endif

{LEAF_mldSnoopCurrentVlanImmediateLeave,  ASN_INTEGER,  RWRITE,  var_mldSnoopCurrentVlanTable, 3,  { 13, 1, 2 }},
};

/** Initializes the mldSnoopCurrentVlanTable module */
void
init_mldSnoopCurrentVlanTable(void)
{
    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("mldSnoopCurrentVlanTable", mldSnoopCurrentVlanTable_variables, variable3,
                 mldSnoopCurrentVlanTable_variables_oid);
}

#if(SYS_CPNT_MLDSNP_PROXY == TRUE)
void init_mldSnoopProxyReporting(void)
{
    oid mldSnoopProxyReporting_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,54,14, 0 };

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("mldSnoopProxyReporting",
                               do_mldSnoopProxyReporting,
                               mldSnoopProxyReporting_oid,
                               OID_LENGTH(mldSnoopProxyReporting_oid),
                               HANDLER_CAN_RWRITE));
}

void init_mldSnoopUnsolicitedReportInterval(void)
{
    oid mldSnoopUnsolicitedReportInterval_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,54,15, 0 };

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("mldSnoopUnsolicitedReportInterval",
                               do_mldSnoopUnsolicitedReportInterval,
                               mldSnoopUnsolicitedReportInterval_oid,
                               OID_LENGTH(mldSnoopUnsolicitedReportInterval_oid),
                               HANDLER_CAN_RWRITE));
}
#endif

/* variable3 mldSnoopPortTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */
struct variable3 mldSnoopPortTable_variables[] =
{
    /* magic number, variable type, ro/rw, callback fn, L, oidsuffix
     *     (L = length of the oidsuffix)
     */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_mldSnoopPortIndex, ASN_UNSIGNED, RONLY, var_mldSnoopPortTable, 3, { 16, 1, 1 }},
#endif  /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */
#if(SYS_CPNT_MLDSNP_QUERY_DROP == TRUE)
    { LEAF_mldSnoopQueryDrop, ASN_INTEGER, RWRITE, var_mldSnoopPortTable, 3, { 16, 1, 3 }},
#endif
#if(SYS_CPNT_IPV6_MULTICAST_DATA_DROP == TRUE)
    { LEAF_mldSnoopMulticastDataDrop, ASN_INTEGER, RWRITE, var_mldSnoopPortTable, 3, { 16, 1, 4 }},
#endif
    { LEAF_mldSnoopPortNumGroups, ASN_UNSIGNED, RONLY, var_mldSnoopPortTable, 3, { 16, 1, 5 }},
    { LEAF_mldSnoopPortNumJoinSend, ASN_UNSIGNED, RONLY, var_mldSnoopPortTable, 3, { 16, 1, 6 }},
    { LEAF_mldSnoopPortNumJoins, ASN_UNSIGNED, RONLY, var_mldSnoopPortTable, 3, { 16, 1, 7 }},
    { LEAF_mldSnoopPortNumJoinSuccess, ASN_UNSIGNED, RONLY, var_mldSnoopPortTable, 3, { 16, 1, 8 }},
    { LEAF_mldSnoopPortNumLeavesSend, ASN_UNSIGNED, RONLY, var_mldSnoopPortTable, 3, { 16, 1, 9 }},
    { LEAF_mldSnoopPortNumLeaves, ASN_UNSIGNED, RONLY, var_mldSnoopPortTable, 3, { 16, 1, 10 }},
    { LEAF_mldSnoopPortNumGeneralQuerySend, ASN_UNSIGNED, RONLY, var_mldSnoopPortTable, 3, { 16, 1, 11 }},
    { LEAF_mldSnoopPortNumGeneralQueryRecevied, ASN_UNSIGNED, RONLY, var_mldSnoopPortTable, 3, { 16, 1, 12 }},
    { LEAF_mldSnoopPortNumSepcificQuerySend, ASN_UNSIGNED, RONLY, var_mldSnoopPortTable, 3, { 16, 1, 13 }},
    { LEAF_mldsnoopPortNumSpecificQueryReceived, ASN_UNSIGNED, RONLY, var_mldSnoopPortTable, 3, { 16, 1, 14 }},
    { LEAF_mldSnoopPortNumInvalidReport, ASN_UNSIGNED, RONLY, var_mldSnoopPortTable, 3, { 16, 1, 15 }},
    { LEAF_mldSnoopPortClearStatistics, ASN_INTEGER, RWRITE, var_mldSnoopPortTable, 3, { 16, 1, 16 }},

};

void init_mldSnoopPortTable(void)
{
    oid mldSnoopPortTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,54 };
    /* Register ourselves with the agent to handle our MIB tree
     */
    REGISTER_MIB("mldSnoopPortTable", mldSnoopPortTable_variables, variable3,
                 mldSnoopPortTable_variables_oid);
}


#if (SYS_CPNT_FILTER_THROOTTLE_MLDSNP == TRUE)
void
init_mldSnoopProfileCtrlTable(void)
{
    oid mldSnoopFilterStatus_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,54,17,0 };
    oid mldSnoopProfileCtlId_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,54,19,1,0 };
    oid mldSnoopProfileCtlInetAddressType_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,54,19,2,0 };
    oid mldSnoopProfileCtlStartInetAddress_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,54,19,3,0 };
    oid mldSnoopProfileCtlEndInetAddress_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,54,19,4,0 };
    oid mldSnoopProfileCtlAction_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,54,19,5,0 };

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("mldSnoopFilterStatus",
                               do_mldSnoopFilterStatus,
                               mldSnoopFilterStatus_oid,
                               OID_LENGTH(mldSnoopFilterStatus_oid),
                               HANDLER_CAN_RWRITE));

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("mldSnoopProfileCtlId",
                               do_mldSnoopProfileCtlId,
                               mldSnoopProfileCtlId_oid,
                               OID_LENGTH(mldSnoopProfileCtlId_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("mldSnoopProfileCtlInetAddressType",
                               do_mldSnoopProfileCtlInetAddressType,
                               mldSnoopProfileCtlInetAddressType_oid,
                               OID_LENGTH(mldSnoopProfileCtlInetAddressType_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("mldSnoopProfileCtlStartInetAddress",
                               do_mldSnoopProfileCtlStartInetAddress,
                               mldSnoopProfileCtlStartInetAddress_oid,
                               OID_LENGTH(mldSnoopProfileCtlStartInetAddress_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("mldSnoopProfileCtlEndInetAddress",
                               do_mldSnoopProfileCtlEndInetAddress,
                               mldSnoopProfileCtlEndInetAddress_oid,
                               OID_LENGTH(mldSnoopProfileCtlEndInetAddress_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("mldSnoopProfileCtlAction",
                               do_mldSnoopProfileCtlAction,
                               mldSnoopProfileCtlAction_oid,
                               OID_LENGTH(mldSnoopProfileCtlAction_oid),
                               HANDLER_CAN_RWRITE));
}
/********************************************
 **********mldSnoopProfileTable*************
 ********************************************
 */
 /*
 * mldSnoopProfileTable_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

/*
 * variable3 mldSnoopProfileTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */

struct variable3 mldSnoopProfileTable_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
{LEAF_mldSnoopProfileId,  ASN_UNSIGNED,  RONLY,   var_mldSnoopProfileTable, 3,  { 18, 1, 1 }},
#endif

{LEAF_mldSnoopProfileAction,  ASN_INTEGER,  RWRITE,  var_mldSnoopProfileTable, 3,  { 18, 1, 2 }},
{LEAF_mldSnoopProfileStatus,  ASN_INTEGER,  RWRITE,  var_mldSnoopProfileTable, 3,  { 18, 1, 3 }},
};
/*    (L = length of the oidsuffix) */

/** Initializes the mldSnoopProfileTable module */
void
init_mldSnoopProfileTable(void)
{
    oid mldSnoopProfileTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,54 };

    DEBUGMSGTL(("mldSnoopProfileTable", "Initializing\n"));

    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("mldSnoopProfileTable", mldSnoopProfileTable_variables, variable3,
               mldSnoopProfileTable_variables_oid);

    /* place any other initialization junk you need here */
}

/********************************************
 ********mldSnoopProfileRangeTable**********
 ********************************************
 */
 /*
 * mldSnoopProfileRangeTable_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

/*
 * variable3 mldSnoopProfileRangeTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */
struct variable3 mldSnoopProfileRangeTable_variables[] =
{
    /* magic number, variable type, ro/rw, callback fn, L, oidsuffix
     *     (L = length of the oidsuffix)
     */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_mldSnoopProfileRangeProfileId, ASN_UNSIGNED, RONLY, var_mldSnoopProfileRangeTable, 3, { 20, 1, 1 }},
#endif  /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_mldSnoopProfileRangeInetAddressType, ASN_INTEGER, RONLY, var_mldSnoopProfileRangeTable, 3, { 20, 1, 2 }},
#endif  /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_mldSnoopProfileRangeStartInetAddress, ASN_OCTET_STR, RONLY, var_mldSnoopProfileRangeTable, 3, { 20, 1, 3 }},
#endif  /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_mldSnoopProfileRangeEndInetAddress, ASN_OCTET_STR, RONLY, var_mldSnoopProfileRangeTable, 3, { 20, 1, 4 }},
#endif  /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

    { LEAF_mldSnoopProfileRangeAction, ASN_INTEGER, RONLY, var_mldSnoopProfileRangeTable, 3, { 20, 1, 5 }},
};
/*    (L = length of the oidsuffix) */

/** Initializes the mldSnoopProfileRangeTable module */
void
init_mldSnoopProfileRangeTable(void)
{
    oid mldSnoopProfileRangeTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,54 };

    DEBUGMSGTL(("mldSnoopProfileRangeTable", "Initializing\n"));

    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("mldSnoopProfileRangeTable", mldSnoopProfileRangeTable_variables, variable3,
               mldSnoopProfileRangeTable_variables_oid);

    /* place any other initialization junk you need here */
}

/********************************************
 **********mldSnoopFilterPortTable**********
 ********************************************
 */
 /*
 * mldSnoopFilterPortTable_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

/*
 * variable3 mldSnoopFilterPortTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */

struct variable3 mldSnoopFilterPortTable_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
{LEAF_mldSnoopFilterPortIndex,  ASN_UNSIGNED,  RONLY,   var_mldSnoopFilterPortTable, 3,  { 21, 1, 1 }},
#endif

{LEAF_mldSnoopFilterPortProfileId,  ASN_INTEGER,  RWRITE,  var_mldSnoopFilterPortTable, 3,  { 21, 1, 2 }},
};
/*    (L = length of the oidsuffix) */

/** Initializes the mldSnoopFilterPortTable module */
void
init_mldSnoopFilterPortTable(void)
{
    oid mldSnoopFilterPortTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,54 };

    DEBUGMSGTL(("mldSnoopFilterPortTable", "Initializing\n"));

    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("mldSnoopFilterPortTable", mldSnoopFilterPortTable_variables, variable3,
               mldSnoopFilterPortTable_variables_oid);

    /* place any other initialization junk you need here */
}

/********************************************
 *********mldSnoopThrottlePortTable*********
 ********************************************
 */
 /*
 * mldSnoopThrottlePortTable_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

/*
 * variable3 mldSnoopThrottlePortTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */

struct variable3 mldSnoopThrottlePortTable_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
{LEAF_mldSnoopThrottlePortIndex,  ASN_UNSIGNED,  RONLY,   var_mldSnoopThrottlePortTable, 3,  { 22, 1, 1 }},
#endif

{LEAF_mldSnoopThrottlePortRunningStatus,  ASN_INTEGER,  RONLY,   var_mldSnoopThrottlePortTable, 3,  { 22, 1, 2 }},
{LEAF_mldSnoopThrottlePortAction,  ASN_INTEGER,  RWRITE,  var_mldSnoopThrottlePortTable, 3,  { 22, 1, 3 }},
{LEAF_mldSnoopThrottlePortMaxGroups,  ASN_INTEGER,  RWRITE,  var_mldSnoopThrottlePortTable, 3,  { 22, 1, 4 }},
{LEAF_mldSnoopThrottlePortCurrentGroups,  ASN_INTEGER,  RONLY,   var_mldSnoopThrottlePortTable, 3,  { 22, 1, 5 }},
};
/*    (L = length of the oidsuffix) */

/** Initializes the mldSnoopThrottlePortTable module */
void
init_mldSnoopThrottlePortTable(void)
{
    oid mldSnoopThrottlePortTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,54 };

    DEBUGMSGTL(("mldSnoopThrottlePortTable", "Initializing\n"));

    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("mldSnoopThrottlePortTable", mldSnoopThrottlePortTable_variables, variable3,
               mldSnoopThrottlePortTable_variables_oid);

    /* place any other initialization junk you need here */
}
#endif


void init_mldSnoopClearDynamicGroups(void)
{
    oid mldSnoopClearDynamicGroups_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1, 54,23, 0 };

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("mldSnoopClearDynamicGroups",
                               do_mldSnoopClearDynamicGroups,
                               mldSnoopClearDynamicGroups_oid,
                               OID_LENGTH(mldSnoopClearDynamicGroups_oid),
                               HANDLER_CAN_RWRITE));
}


/* variable3 mldSnoopVlanTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */
struct variable3 mldSnoopVlanTable_variables[] =
{
    /* magic number, variable type, ro/rw, callback fn, L, oidsuffix
     *     (L = length of the oidsuffix)
     */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_mldSnoopVlanIndex, ASN_UNSIGNED, RONLY, var_mldSnoopVlanTable, 3, { 24, 1, 1 }},
#endif  /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

    { LEAF_mldSnoopVlanNumGroups, ASN_UNSIGNED, RONLY, var_mldSnoopVlanTable, 3, { 24, 1, 2 }},
    { LEAF_mldSnoopVlanNumJoinSend, ASN_UNSIGNED, RONLY, var_mldSnoopVlanTable, 3, { 24, 1, 3 }},
    { LEAF_mldSnoopVlanNumJoins, ASN_UNSIGNED, RONLY, var_mldSnoopVlanTable, 3, { 24, 1, 4 }},
    { LEAF_mldSnoopVlanNumJoinSuccess, ASN_UNSIGNED, RONLY, var_mldSnoopVlanTable, 3, { 24, 1, 5 }},
    { LEAF_mldSnoopVlanNumLeavesSend, ASN_UNSIGNED, RONLY, var_mldSnoopVlanTable, 3, { 24, 1, 6 }},
    { LEAF_mldSnoopVlanNumLeaves, ASN_UNSIGNED, RONLY, var_mldSnoopVlanTable, 3, { 24, 1, 7 }},
    { LEAF_mldSnoopVlanNumGeneralQuerySend, ASN_UNSIGNED, RONLY, var_mldSnoopVlanTable, 3, { 24, 1, 8 }},
    { LEAF_mldSnoopVlanNumGeneralQueryRecevied, ASN_UNSIGNED, RONLY, var_mldSnoopVlanTable, 3, { 24, 1, 9 }},
    { LEAF_mldSnoopVlanNumSepcificQuerySend, ASN_UNSIGNED, RONLY, var_mldSnoopVlanTable, 3, { 24, 1, 10 }},
    { LEAF_mldsnoopVlanNumSpecificQueryReceived, ASN_UNSIGNED, RONLY, var_mldSnoopVlanTable, 3, { 24, 1, 11 }},
    { LEAF_mldSnoopVlanNumInvalidReport, ASN_UNSIGNED, RONLY, var_mldSnoopVlanTable, 3, { 24, 1, 12 }},
    { LEAF_mldSnoopVlanClearStatistics, ASN_INTEGER, RWRITE, var_mldSnoopVlanTable, 3, { 24, 1, 13 }},
};

void init_mldSnoopVlanTable(void)
{
    oid mldSnoopVlanTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,54 };

    /* Register ourselves with the agent to handle our MIB tree
     */
    REGISTER_MIB("mldSnoopVlanTable", mldSnoopVlanTable_variables, variable3,
                 mldSnoopVlanTable_variables_oid);
}

#endif /* end of #if (SYS_CPNT_MLDSNP == TRUE) */
oid userauthmgt_oid [] = { SYS_ADPT_PRIVATEMIB_OID,1,17,10 };
struct variable3 userauth_mgt_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    {USERAUTHUSERNAME,          ASN_OCTET_STR, NOACCESS,      var_userAuthTable,  3, {5, 1, 1}},
#endif

    {USERAUTHPASSWORD,          ASN_OCTET_STR, RWRITE,      var_userAuthTable,  3, {5, 1, 2}},
    {USERAUTHPRIVILEGE,         ASN_INTEGER, RWRITE,        var_userAuthTable,  3, {5, 1, 3}},
    {USERAUTHPUBLICKEY,         ASN_OCTET_STR, RONLY,       var_userAuthTable,  3, {5, 1, 4}},
    {USERAUTHSTATUS,            ASN_INTEGER, RWRITE,        var_userAuthTable,  3, {5, 1, 5}}
};

void
init_enablePassword(void)
{
    static oid enablePassword_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,17,10,3,0 };

    DEBUGMSGTL(("enablePassword", "Initializing\n"));
    // printf("\ninit_enablePassword\n");
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("enablePassword",
                               do_enablePassword,
                               enablePassword_oid,
                               OID_LENGTH(enablePassword_oid),
                               HANDLER_CAN_RWRITE));
}

void
init_authMethod(void)
{
    static oid authMethod_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,17,10,4,0 };

    DEBUGMSGTL(("authMethod", "Initializing\n"));
    // printf("\ninit_authMethod\n");
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("authMethod",
                               do_authMethod,
                               authMethod_oid,
                               OID_LENGTH(authMethod_oid),
                               HANDLER_CAN_RWRITE));
}

/* Register Line Mgt private MIB. */
void init_userauthTable (void)
{
    // printf("\ninit_userauthTable\n");
    /* snmp_init (zg, imid_oid, sizeof imid_oid / sizeof (oid));*/
    REGISTER_MIB("UserAuthMgt", userauth_mgt_variables, variable3, userauthmgt_oid);
    /* snmp_start (zg);*/
}

#if (SYS_CPNT_UDP_HELPER == TRUE)
void init_udpHelperStatus(void)
{
    static oid udpHelperStatus_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,58,1,0 };

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("udpHelperStatus",
                               do_udpHelperStatus,
                               udpHelperStatus_oid,
                               OID_LENGTH(udpHelperStatus_oid),
                               HANDLER_CAN_RWRITE));
}

oid udpHelperForwardProtocolTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,58 };

/* variable3 udpHelperForwardProtocolTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */
struct variable3 udpHelperForwardProtocolTable_variables[] =
{
/* magic number, variable type, ro/rw, callback fn, L, oidsuffix
 */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_udpHelperForwardProtocolPort, ASN_INTEGER, RONLY, var_udpHelperForwardProtocolTable, 3, { 2, 1, 1 }},
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

    { LEAF_udpHelperForwardProtocolStatus, ASN_INTEGER, RWRITE, var_udpHelperForwardProtocolTable, 3, { 2, 1, 2 }},
};

void init_udpHelperForwardProtocolTable(void)
{
    REGISTER_MIB("udpHelperForwardProtocolTable", udpHelperForwardProtocolTable_variables, variable3,
                 udpHelperForwardProtocolTable_variables_oid);
}

oid udpHelperInetAddrTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,58 };

/* variable3 udpHelperInetAddrTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */
struct variable3 udpHelperInetAddrTable_variables[] =
{
/* magic number, variable type, ro/rw, callback fn, L, oidsuffix
 */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_udpHelperInetAddrIfIndex, ASN_UNSIGNED, RONLY, var_udpHelperInetAddrTable, 3, { 3, 1, 1 }},
    { LEAF_udpHelperInetAddrType, ASN_INTEGER, RONLY, var_udpHelperInetAddrTable, 3, { 3, 1, 2 }},
    { LEAF_udpHelperInetAddr, ASN_OCTET_STR, RONLY, var_udpHelperInetAddrTable, 3, { 3, 1, 3 }},
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

    { LEAF_udpHelperInetAddrStatus, ASN_INTEGER, RWRITE, var_udpHelperInetAddrTable, 3, { 3, 1, 4 }},
};

void init_udpHelperInetAddrTable(void)
{
    REGISTER_MIB("udpHelperInetAddrTable", udpHelperInetAddrTable_variables, variable3,
                 udpHelperInetAddrTable_variables_oid);
}
#endif /* #if (SYS_CPNT_UDP_HELPER == TRUE) */

#if (SYS_CPNT_SYSMGMT_RESMIB == TRUE)
void
init_sysResourceMgt(void)
{
    static oid cpuCurrentUti_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,39,2,1,0 };
    static oid cpuStatMaxUti_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,39,2,2,0 };
    static oid cpuStatAvgUti_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,39,2,3,0 };
    static oid cpuPeakTime_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,39,2,4,0 };
    static oid cpuPeakDuration_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,39,2,5,0 };
    static oid cpuUtiRisingThreshold_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,39,2,6,0 };
    static oid cpuUtiFallingThreshold_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,39,2,7,0 };
    static oid memoryTotal_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,39,3,1,0 };
    static oid memoryAllocated_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,39,3,2,0 };
    static oid memoryFreed_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,39,3,3,0 };
    static oid memoryFreedInPercent_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,39,3,4,0 };
    static oid memoryUtiRisingThreshold_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,39,3,5,0 };
    static oid memoryUtiFallingThreshold_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,39,3,6,0 };

    DEBUGMSGTL(("sysResourceMgt", "Initializing\n"));

    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("cpuCurrentUti",
                                         get_cpuCurrentUti,
                                         cpuCurrentUti_oid,
                                         OID_LENGTH(cpuCurrentUti_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("cpuStatMaxUti",
                                         get_cpuStatMaxUti,
                                         cpuStatMaxUti_oid,
                                         OID_LENGTH(cpuStatMaxUti_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("cpuStatAvgUti",
                                         get_cpuStatAvgUti,
                                         cpuStatAvgUti_oid,
                                         OID_LENGTH(cpuStatAvgUti_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("cpuPeakTime",
                                         get_cpuPeakTime,
                                         cpuPeakTime_oid,
                                         OID_LENGTH(cpuPeakTime_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("cpuPeakDuration",
                                         get_cpuPeakDuration,
                                         cpuPeakDuration_oid,
                                         OID_LENGTH(cpuPeakDuration_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("cpuUtiRisingThreshold",
                               do_cpuUtiRisingThreshold,
                               cpuUtiRisingThreshold_oid,
                               OID_LENGTH(cpuUtiRisingThreshold_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("cpuUtiFallingThreshold",
                               do_cpuUtiFallingThreshold,
                               cpuUtiFallingThreshold_oid,
                               OID_LENGTH(cpuUtiFallingThreshold_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("memoryTotal",
                                         get_memoryTotal,
                                         memoryTotal_oid,
                                         OID_LENGTH(memoryTotal_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("memoryAllocated",
                                         get_memoryAllocated,
                                         memoryAllocated_oid,
                                         OID_LENGTH(memoryAllocated_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("memoryFreed",
                                         get_memoryFreed,
                                         memoryFreed_oid,
                                         OID_LENGTH(memoryFreed_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("memoryFreedInPercent",
                                         get_memoryFreedInPercent,
                                         memoryFreedInPercent_oid,
                                         OID_LENGTH(memoryFreedInPercent_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("memoryUtiRisingThreshold",
                               do_memoryUtiRisingThreshold,
                               memoryUtiRisingThreshold_oid,
                               OID_LENGTH(memoryUtiRisingThreshold_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("memoryUtiFallingThreshold",
                               do_memoryUtiFallingThreshold,
                               memoryUtiFallingThreshold_oid,
                               OID_LENGTH(memoryUtiFallingThreshold_oid),
                               HANDLER_CAN_RWRITE));
}

#if (SYS_CPNT_SYSMGMT_MONITORING_PROCESS_CPU_PER_TASK == TRUE)
/***** taskCpuTable *****/
oid taskCpuTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,39 };

struct variable3 taskCpuTable_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
{LEAF_taskCpuName,  ASN_OCTET_STR,  RONLY,   var_taskCpuTable, 3,  { 4, 1, 1 }},
#endif
{LEAF_taskCpuCurrentUti,  ASN_INTEGER,  RWRITE,   var_taskCpuTable, 3,  { 4, 1, 2 }},
{LEAF_taskCpuStatMaxUti,  ASN_INTEGER,  RWRITE,   var_taskCpuTable, 3,  { 4, 1, 3 }},
{LEAF_taskCpuStatAvgUti,  ASN_INTEGER,  RWRITE,   var_taskCpuTable, 3,  { 4, 1, 4 }},
};

/** Initializes the taskCpuTable module */
void
init_taskCpuTable(void)
{
    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("taskCpuTable", taskCpuTable_variables, variable3,
                 taskCpuTable_variables_oid);
}
#endif /* (SYS_CPNT_SYSMGMT_MONITORING_PROCESS_CPU_PER_TASK == TRUE) */

#if (SYS_CPNT_SYSMGMT_CPU_GUARD == TRUE)
void
init_cpuGuard(void)
{
    static oid cpuGuardStatus_oid[]           = { SYS_ADPT_PRIVATEMIB_OID, 1, 39, 5, 1, 0};
    static oid cpuGuardHighWatermark_oid[]    = { SYS_ADPT_PRIVATEMIB_OID, 1, 39, 5, 2, 0};
    static oid cpuGuardLowWatermark_oid[]     = { SYS_ADPT_PRIVATEMIB_OID, 1, 39, 5, 3, 0};
    static oid cpuGuardMaxThreshold_oid[]     = { SYS_ADPT_PRIVATEMIB_OID, 1, 39, 5, 4, 0};
    static oid cpuGuardMinThreshold_oid[]     = { SYS_ADPT_PRIVATEMIB_OID, 1, 39, 5, 5, 0};
    static oid cpuGuardTrapStatus_oid[]       = { SYS_ADPT_PRIVATEMIB_OID, 1, 39, 5, 6, 0};
    static oid cpuGuardCurrentThreshold_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1, 39, 5, 7, 0};

    DEBUGMSGTL(("cpuGuard", "Initializing\n"));

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("cpuGuardStatus",
                               do_cpuGuardStatus,
                               cpuGuardStatus_oid,
                               OID_LENGTH(cpuGuardStatus_oid),
                               HANDLER_CAN_RWRITE));

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("cpuGuardHighWatermark",
                               do_cpuGuardHighWatermark,
                               cpuGuardHighWatermark_oid,
                               OID_LENGTH(cpuGuardHighWatermark_oid),
                               HANDLER_CAN_RWRITE));

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("cpuGuardLowWatermark",
                               do_cpuGuardLowWatermark,
                               cpuGuardLowWatermark_oid,
                               OID_LENGTH(cpuGuardLowWatermark_oid),
                               HANDLER_CAN_RWRITE));

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("cpuGuardMaxThreshold",
                               do_cpuGuardMaxThreshold,
                               cpuGuardMaxThreshold_oid,
                               OID_LENGTH(cpuGuardMaxThreshold_oid),
                               HANDLER_CAN_RWRITE));

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("cpuGuardMinThreshold",
                               do_cpuGuardMinThreshold,
                               cpuGuardMinThreshold_oid,
                               OID_LENGTH(cpuGuardMinThreshold_oid),
                               HANDLER_CAN_RWRITE));

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("cpuGuardTrapStatus",
                               do_cpuGuardTrapStatus,
                               cpuGuardTrapStatus_oid,
                               OID_LENGTH(cpuGuardTrapStatus_oid),
                               HANDLER_CAN_RWRITE));

    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("cpuGuardCurrentThreshold",
                                         get_cpuGuardCurrentThreshold,
                                         cpuGuardCurrentThreshold_oid,
                                         OID_LENGTH(cpuGuardCurrentThreshold_oid),
                                         HANDLER_CAN_RONLY));
}
#endif
#endif /* #if (SYS_CPNT_SYSMGMT_RESMIB == TRUE) */

#if (SYS_CPNT_IGMP == TRUE)

/* variable3 igmpProxyTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */
struct variable3 igmpProxyTable_variables[] =
{
/* magic number, variable type, ro/rw, callback fn, L, oidsuffix
 */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_igmpProxyifIndex, ASN_INTEGER, RONLY, var_igmpProxyTable, 3, { 2, 1, 1 }},
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

    { LEAF_igmpProxyUnsolicitedReportInterval, ASN_UNSIGNED, RWRITE, var_igmpProxyTable, 3, { 2, 1, 2 }},
};

void init_igmpProxyTable(void)
{
    oid igmpProxyTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,18,6 };

    REGISTER_MIB("igmpProxyTable", igmpProxyTable_variables, variable3,
                 igmpProxyTable_variables_oid);
}

/* variable3 igmpStaticGroupTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */
struct variable3 igmpStaticGroupTable_variables[] =
{
/* magic number, variable type, ro/rw, callback fn, L, oidsuffix
 */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_igmpStaticGroupIfIndex, ASN_INTEGER, RONLY, var_igmpStaticGroupTable, 3, { 3, 1, 1 }},
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_igmpStaticGroupAddress, ASN_IPADDRESS, RONLY, var_igmpStaticGroupTable, 3, { 3, 1, 2 }},
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_igmpStaticGroupSourceAddress, ASN_IPADDRESS, RONLY, var_igmpStaticGroupTable, 3, { 3, 1, 3 }},
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

    { LEAF_igmpStaticGroupEntryStatus, ASN_INTEGER, RWRITE, var_igmpStaticGroupTable, 3, { 3, 1, 4 }},
};

void init_igmpStaticGroupTable(void)
{
    oid igmpStaticGroupTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,18,6 };

    REGISTER_MIB("igmpStaticGroupTable", igmpStaticGroupTable_variables, variable3,
                 igmpStaticGroupTable_variables_oid);
}
#endif /* #if (SYS_CPNT_IGMP == TRUE) */

#if (SYS_CPNT_DAI == TRUE)
/********************************************
 ******************daiGlobal*****************
 ********************************************
 */
void
init_daiGlobal(void)
{
    static oid daiGlobalStatus_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,56,1,1,0 };
    static oid daiGlobalSrcMacValidation_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,56,1,2,0 };
    static oid daiGlobalDestMacValidation_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,56,1,3,0 };
    static oid daiGlobalIpAddrValidation_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,56,1,4,0 };
    static oid daiGlobalLogNumber_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,56,1,5,0 };
    static oid daiGlobalLogInterval_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,56,1,6,0 };
    static oid daiGlobalAdditionalValidStatus_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,56,1,7,0 };

    DEBUGMSGTL(("daiGlobal", "Initializing\n"));

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("daiGlobalStatus",
                               do_daiGlobalStatus,
                               daiGlobalStatus_oid,
                               OID_LENGTH(daiGlobalStatus_oid),
                               HANDLER_CAN_RWRITE));

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("daiGlobalSrcMacValidation",
                               do_daiGlobalSrcMacValidation,
                               daiGlobalSrcMacValidation_oid,
                               OID_LENGTH(daiGlobalSrcMacValidation_oid),
                               HANDLER_CAN_RWRITE));

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("daiGlobalDestMacValidation",
                               do_daiGlobalDestMacValidation,
                               daiGlobalDestMacValidation_oid,
                               OID_LENGTH(daiGlobalDestMacValidation_oid),
                               HANDLER_CAN_RWRITE));

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("daiGlobalIpAddrValidation",
                               do_daiGlobalIpAddrValidation,
                               daiGlobalIpAddrValidation_oid,
                               OID_LENGTH(daiGlobalIpAddrValidation_oid),
                               HANDLER_CAN_RWRITE));

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("daiGlobalLogNumber",
                               do_daiGlobalLogNumber,
                               daiGlobalLogNumber_oid,
                               OID_LENGTH(daiGlobalLogNumber_oid),
                               HANDLER_CAN_RWRITE));

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("daiGlobalLogInterval",
                               do_daiGlobalLogInterval,
                               daiGlobalLogInterval_oid,
                               OID_LENGTH(daiGlobalLogInterval_oid),
                               HANDLER_CAN_RWRITE));

    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("daiGlobalAdditionalValidStatus",
                                         get_daiGlobalAdditionalValidStatus,
                                         daiGlobalAdditionalValidStatus_oid,
                                         OID_LENGTH(daiGlobalAdditionalValidStatus_oid),
                                         HANDLER_CAN_RONLY));
}

/********************************************
 ******************daiVlanTable**************
 ********************************************
 */
oid daiVlanTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,56,2 };

struct variable3 daiVlanTable_variables[] = {

#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
{LEAF_daiVlanIndex,  ASN_UNSIGNED,  RONLY,   var_daiVlanTable, 3,  { 1, 1, 1 }},
#endif

{LEAF_daiVlanStatus,  ASN_INTEGER,  RWRITE,  var_daiVlanTable, 3,  { 1, 1, 2 }},
{LEAF_daiVlanArpAclName,  ASN_OCTET_STR,  RWRITE,  var_daiVlanTable, 3,  { 1, 1, 3 }},
{LEAF_daiVlanArpAclStatus,  ASN_INTEGER,  RWRITE,  var_daiVlanTable, 3,  { 1, 1, 4 }},
};

void
init_daiVlanTable(void)
{
    REGISTER_MIB("daiVlanTable", daiVlanTable_variables, variable3,
                 daiVlanTable_variables_oid);
}

/********************************************
 ******************daiPortTable**************
 ********************************************
 */
oid daiPortTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,56,3 };

struct variable3 daiPortTable_variables[] = {

#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
{LEAF_daiPortIfIndex,  ASN_INTEGER,  RONLY,   var_daiPortTable, 3,  { 1, 1, 1 }},
#endif

{LEAF_daiPortTrustStatus,  ASN_INTEGER,  RWRITE,  var_daiPortTable, 3,  { 1, 1, 2 }},
{LEAF_daiPortRateLimit,  ASN_UNSIGNED,  RWRITE,  var_daiPortTable, 3,  { 1, 1, 3 }},
};

void
init_daiPortTable(void)
{

    REGISTER_MIB("daiPortTable", daiPortTable_variables, variable3,
                 daiPortTable_variables_oid);
}

/********************************************
 ******************daiPortTable**************
 ********************************************
 */
oid daiLogTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,56,4 };

struct variable3 daiLogTable_variables[] = {

#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
{LEAF_daiLogIndex,  ASN_INTEGER,  RONLY,   var_daiLogTable, 3,  { 1, 1, 1 }},
#endif

{LEAF_daiLogVlan,  ASN_UNSIGNED,  RONLY,   var_daiLogTable, 3,  { 1, 1, 2 }},
{LEAF_daiLogPort,  ASN_UNSIGNED,  RONLY,   var_daiLogTable, 3,  { 1, 1, 3 }},
{LEAF_daiLogSrcIpAddress,  ASN_IPADDRESS,  RONLY,   var_daiLogTable, 3,  { 1, 1, 4 }},
{LEAF_daiLogDestIpAddress,  ASN_IPADDRESS,  RONLY,   var_daiLogTable, 3,  { 1, 1, 5 }},
{LEAF_daiLogSrcMacAddress,  ASN_OCTET_STR,  RONLY,   var_daiLogTable, 3,  { 1, 1, 6 }},
{LEAF_daiLogDestMacAddress,  ASN_OCTET_STR,  RONLY,   var_daiLogTable, 3,  { 1, 1, 7 }},
};

void
init_daiLogTable(void)
{
    REGISTER_MIB("daiLogTable", daiLogTable_variables, variable3,
                 daiLogTable_variables_oid);
}

void
init_daiStatistics(void)
{
    static oid daiTotalReceivedPkts_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,56,5,1,0 };
    static oid daiTotalDroppedPkts_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,56,5,2,0 };
    static oid daiTotalProcessedPkts_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,56,5,3,0 };
    static oid daiTotalSrcMacDroppedPkts_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,56,5,4,0 };
    static oid daiTotalDestMacDroppedPkts_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,56,5,5,0 };
    static oid daiTotalIpAddrDroppedPkts_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,56,5,6,0 };
    static oid daiTotalArpAclDroppedPkts_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,56,5,7,0 };
    static oid daiTotalDhcpSnoopingDroppedPkts_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,56,5,8,0 };

    DEBUGMSGTL(("daiTotalReceivedPkts", "Initializing\n"));

    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("daiTotalReceivedPkts",
                                         get_daiTotalReceivedPkts,
                                         daiTotalReceivedPkts_oid,
                                         OID_LENGTH(daiTotalReceivedPkts_oid),
                                         HANDLER_CAN_RONLY));

    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("daiTotalDroppedPkts",
                                         get_daiTotalDroppedPkts,
                                         daiTotalDroppedPkts_oid,
                                         OID_LENGTH(daiTotalDroppedPkts_oid),
                                         HANDLER_CAN_RONLY));

    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("daiTotalProcessedPkts",
                                         get_daiTotalProcessedPkts,
                                         daiTotalProcessedPkts_oid,
                                         OID_LENGTH(daiTotalProcessedPkts_oid),
                                         HANDLER_CAN_RONLY));

    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("daiTotalSrcMacDroppedPkts",
                                         get_daiTotalSrcMacDroppedPkts,
                                         daiTotalSrcMacDroppedPkts_oid,
                                         OID_LENGTH(daiTotalSrcMacDroppedPkts_oid),
                                         HANDLER_CAN_RONLY));

    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("daiTotalDestMacDroppedPkts",
                                         get_daiTotalDestMacDroppedPkts,
                                         daiTotalDestMacDroppedPkts_oid,
                                         OID_LENGTH(daiTotalDestMacDroppedPkts_oid),
                                         HANDLER_CAN_RONLY));

    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("daiTotalIpAddrDroppedPkts",
                                         get_daiTotalIpAddrDroppedPkts,
                                         daiTotalIpAddrDroppedPkts_oid,
                                         OID_LENGTH(daiTotalIpAddrDroppedPkts_oid),
                                         HANDLER_CAN_RONLY));

    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("daiTotalArpAclDroppedPkts",
                                         get_daiTotalArpAclDroppedPkts,
                                         daiTotalArpAclDroppedPkts_oid,
                                         OID_LENGTH(daiTotalArpAclDroppedPkts_oid),
                                         HANDLER_CAN_RONLY));

    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("daiTotalDhcpSnoopingDroppedPkts",
                                         get_daiTotalDhcpSnoopingDroppedPkts,
                                         daiTotalDhcpSnoopingDroppedPkts_oid,
                                         OID_LENGTH(daiTotalDhcpSnoopingDroppedPkts_oid),
                                         HANDLER_CAN_RONLY));
}
#endif /* #if (SYS_CPNT_DAI == TRUE) */

#if (SYS_CPNT_MVR == TRUE)
/** Initializes the mvrMgt module */
void
init_mvrMgt(void)
{
#if (SYS_CPNT_MVR_SUPPORT_MULTI_DOMAIN == FALSE)
    static oid mvrStatus_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,44,1,0 };
    static oid mvrVlanId_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,44,2,0 };
    static oid mvrMaxGroups_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,44,3,0 };
    static oid mvrCurrentGroups_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,44,4,0 };
    #if 0
    static oid mvrGroupsCtlId_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,44,5,1,0 };
    static oid mvrGroupsCtlCount_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,44,5,2,0 };
    static oid mvrGroupsCtlAction_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,44,5,3,0 };
    #endif
    static oid mvrRunningStatus_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,44,10,0 };
    static oid mvrUpstreamSourceIpAddress_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,44,19,0 };
#endif
    #if (SYS_CPNT_MVR_FORWARD_PRIORITY == TRUE)
    static oid mvrForwardingPriority_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,44,18,0 };
    #endif

    DEBUGMSGTL(("mvrMgt", "Initializing\n"));

#if (SYS_CPNT_MVR_SUPPORT_MULTI_DOMAIN == FALSE)
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("mvrStatus",
                               do_mvrStatus,
                               mvrStatus_oid,
                               OID_LENGTH(mvrStatus_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("mvrVlanId",
                               do_mvrVlanId,
                               mvrVlanId_oid,
                               OID_LENGTH(mvrVlanId_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("mvrMaxGroups",
                                         get_mvrMaxGroups,
                                         mvrMaxGroups_oid,
                                         OID_LENGTH(mvrMaxGroups_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("mvrCurrentGroups",
                                         get_mvrCurrentGroups,
                                         mvrCurrentGroups_oid,
                                         OID_LENGTH(mvrCurrentGroups_oid),
                                         HANDLER_CAN_RONLY));
    #if 0
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("mvrGroupsCtlId",
                               do_mvrGroupsCtlId,
                               mvrGroupsCtlId_oid,
                               OID_LENGTH(mvrGroupsCtlId_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("mvrGroupsCtlCount",
                               do_mvrGroupsCtlCount,
                               mvrGroupsCtlCount_oid,
                               OID_LENGTH(mvrGroupsCtlCount_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("mvrGroupsCtlAction",
                               do_mvrGroupsCtlAction,
                               mvrGroupsCtlAction_oid,
                               OID_LENGTH(mvrGroupsCtlAction_oid),
                               HANDLER_CAN_RWRITE));
    #endif
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                ("mvrRunningStatus",
                                 get_mvrRunningStatus,
                                 mvrRunningStatus_oid,
                                 OID_LENGTH(mvrRunningStatus_oid),
                                 HANDLER_CAN_RONLY));

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("mvrUpstreamSourceIpAddress",
                               do_mvrUpstreamSourceIpAddress,
                               mvrUpstreamSourceIpAddress_oid,
                               OID_LENGTH(mvrUpstreamSourceIpAddress_oid),
                               HANDLER_CAN_RWRITE));

#endif
#if (SYS_CPNT_MVR_FORWARD_PRIORITY == TRUE)
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("mvrForwardingPriority",
                               do_mvrForwardingPriority,
                               mvrForwardingPriority_oid,
                               OID_LENGTH(mvrForwardingPriority_oid),
                               HANDLER_CAN_RWRITE));
#endif
}

#if (SYS_CPNT_MVR_SUPPORT_MULTI_DOMAIN == FALSE)
/*
 * mvrGroupTable_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */


/*
 * variable3 mvrGroupTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */
#if 0
struct variable3 mvrGroupTable_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */

#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
{MVRGROUPID,  ASN_IPADDRESS,  RONLY,   var_mvrGroupTable, 3,  { 6, 1, 1 }},
#endif

{MVRGROUTACTIVE,  ASN_INTEGER,  RONLY,   var_mvrGroupTable, 3,  { 6, 1, 2 }},
{MVRGROUPSTATUS,  ASN_INTEGER,  RWRITE,  var_mvrGroupTable, 3,  { 6, 1, 3 }},
};
/*    (L = length of the oidsuffix) */

/** Initializes the mvrGroupTable module */
void
init_mvrGroupTable(void)
{
    oid mvrGroupTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1, 44 };

    DEBUGMSGTL(("mvrGroupTable", "Initializing\n"));

    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("mvrGroupTable", mvrGroupTable_variables, variable3,
               mvrGroupTable_variables_oid);

    /* place any other initialization junk you need here */
}
#endif
/*
 * mvrGroupStaticTable_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

/*
 * variable3 mvrGroupStaticTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */

struct variable3 mvrGroupStaticTable_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
{MVRGROUPSTATICADDRESS,  ASN_IPADDRESS,  RONLY,   var_mvrGroupStaticTable, 3,  { 7, 1, 1 }},
#endif

{MVRGROUPSTATICPORTS,  ASN_OCTET_STR,  RWRITE,  var_mvrGroupStaticTable, 3,  { 7, 1, 2 }},
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
{ MVRGROUPSTATICRECEIVERVLAN, ASN_INTEGER, RONLY, var_mvrGroupStaticTable, 3, { 7, 1, 4 }},
#endif
};
/*    (L = length of the oidsuffix) */

/** Initializes the mvrGroupStaticTable module */
void
init_mvrGroupStaticTable(void)
{

    DEBUGMSGTL(("mvrGroupStaticTable", "Initializing\n"));
    oid mvrGroupStaticTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID ,1, 44 };

    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("mvrGroupStaticTable", mvrGroupStaticTable_variables, variable3,
               mvrGroupStaticTable_variables_oid);

    /* place any other initialization junk you need here */
}


/*
 * mvrGroupCurrentTable_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

/*
 * variable3 mvrGroupCurrentTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */

struct variable3 mvrGroupCurrentTable_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
{MVRGROUPCURRENTADDRESS,  ASN_IPADDRESS,  RONLY,   var_mvrGroupCurrentTable, 3,  { 8, 1, 1 }},
#endif
{MVRGROUPCURRENTPORTS,  ASN_OCTET_STR,  RONLY,   var_mvrGroupCurrentTable, 3,  { 8, 1, 2 }},
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
{MVRGROUPCURRENTRECEIVERVLAN,  ASN_INTEGER,  RONLY,   var_mvrGroupCurrentTable, 3,  { 8, 1, 3 }},
#endif
};
/*    (L = length of the oidsuffix) */

/** Initializes the mvrGroupCurrentTable module */
void
init_mvrGroupCurrentTable(void)
{

    DEBUGMSGTL(("mvrGroupCurrentTable", "Initializing\n"));
    oid mvrGroupCurrentTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1, 44 };

    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("mvrGroupCurrentTable", mvrGroupCurrentTable_variables, variable3,
               mvrGroupCurrentTable_variables_oid);

    /* place any other initialization junk you need here */
}

/*
 * mvrPortTable_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

/*
 * variable3 mvrPortTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */

struct variable3 mvrPortTable_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
{MVRIFINDEX,  ASN_INTEGER,  RONLY,   var_mvrPortTable, 3,  { 9, 1, 1 }},
#endif

{MVRPORTTYPE,  ASN_INTEGER,  RWRITE,  var_mvrPortTable, 3,  { 9, 1, 2 }},
{MVRPORTIMMEDIATELEAVE,  ASN_INTEGER,  RWRITE,  var_mvrPortTable, 3,  { 9, 1, 3 }},
{MVRPORTACTIVE,  ASN_INTEGER,  RONLY,   var_mvrPortTable, 3,  { 9, 1, 4 }},
};
/*    (L = length of the oidsuffix) */

/** Initializes the mvrPortTable module */
void
init_mvrPortTable(void)
{
    oid mvrPortTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1, 44 };

    DEBUGMSGTL(("mvrPortTable", "Initializing\n"));

    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("mvrPortTable", mvrPortTable_variables, variable3,
               mvrPortTable_variables_oid);

    /* place any other initialization junk you need here */
}

#endif /* end of #if (SYS_CPNT_MVR == TRUE)*/

#if (SYS_CPNT_MVR_SUPPORT_MULTI_DOMAIN == TRUE)

/* variable3 mvrDomainTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */
struct variable3 mvrDomainTable_variables[] =
{
/* magic number, variable type, ro/rw, callback fn, L, oidsuffix
 */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_mvrDomainId, ASN_INTEGER, RONLY, var_mvrDomainTable, 3, { 20, 1, 1 }},
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

    { LEAF_mvrDomainStatus, ASN_INTEGER, RWRITE, var_mvrDomainTable, 3, { 20, 1, 2 }},
    { LEAF_mvrDomainRunningStatus, ASN_INTEGER, RONLY, var_mvrDomainTable, 3, { 20, 1, 3 }},
    { LEAF_mvrDomainVlanId, ASN_UNSIGNED, RWRITE, var_mvrDomainTable, 3, { 20, 1, 4 }},
    { LEAF_mvrDomainUpstreamSourceIp, ASN_IPADDRESS, RWRITE, var_mvrDomainTable, 3, { 20, 1, 5 }},
    { LEAF_mvrDomainClearDynamicGroups, ASN_INTEGER, RWRITE, var_mvrDomainTable, 3, { 20, 1, 6 }},
};


void init_mvrDomainTable(void)
{
    oid mvrDomainTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,44 };

    REGISTER_MIB("mvrDomainTable", mvrDomainTable_variables, variable3,
                 mvrDomainTable_variables_oid);
}

/* variable3 mvrDomainPortTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */
struct variable3 mvrDomainPortTable_variables[] =
{
/* magic number, variable type, ro/rw, callback fn, L, oidsuffix
 */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_mvrPortDomainId, ASN_INTEGER, RONLY, var_mvrDomainPortTable, 3, { 21, 1, 1 }},
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_mvrDomainIfIndex, ASN_INTEGER, RONLY, var_mvrDomainPortTable, 3, { 21, 1, 2 }},
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

    { LEAF_mvrDomainPortType, ASN_INTEGER, RWRITE, var_mvrDomainPortTable, 3, { 21, 1, 3 }},
    { LEAF_mvrDomainPortImmediateLeave, ASN_INTEGER, RWRITE, var_mvrDomainPortTable, 3, { 21, 1, 4 }},
    { LEAF_mvrDomainPortActive, ASN_INTEGER, RONLY, var_mvrDomainPortTable, 3, { 21, 1, 5 }},
};

void init_mvrDomainPortTable(void)
{
    oid mvrDomainPortTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,44 };

    REGISTER_MIB("mvrDomainPortTable", mvrDomainPortTable_variables, variable3,
                 mvrDomainPortTable_variables_oid);
}


/* variable3 mvrDomainGroupStaticTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */
struct variable3 mvrDomainGroupStaticTable_variables[] =
{
/* magic number, variable type, ro/rw, callback fn, L, oidsuffix
 */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_mvrGroupStaticDomainId, ASN_INTEGER, RONLY, var_mvrDomainGroupStaticTable, 3, { 24, 1, 1 }},
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_mvrDomainGroupStaticAddress, ASN_IPADDRESS, RONLY, var_mvrDomainGroupStaticTable, 3, { 24, 1, 2 }},
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_mvrDomainGroupStaticReceiverVlan, ASN_INTEGER, RONLY, var_mvrDomainGroupStaticTable, 3, { 24, 1, 3 }},
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

    { LEAF_mvrDomainGroupStaticPorts, ASN_OCTET_STR, RWRITE, var_mvrDomainGroupStaticTable, 3, { 24, 1, 4 }},
};

void init_mvrDomainGroupStaticTable(void)
{
    oid mvrDomainGroupStaticTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,44 };

    REGISTER_MIB("mvrDomainGroupStaticTable", mvrDomainGroupStaticTable_variables, variable3,
                 mvrDomainGroupStaticTable_variables_oid);
}

/* variable3 mvrDomainGroupCurrentTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */
struct variable3 mvrDomainGroupCurrentTable_variables[] =
{
/* magic number, variable type, ro/rw, callback fn, L, oidsuffix
 */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_mvrGroupCurrenDomainId, ASN_INTEGER, RONLY, var_mvrDomainGroupCurrentTable, 3, { 25, 1, 1 }},
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_mvrDomainGroupCurrentAddress, ASN_IPADDRESS, RONLY, var_mvrDomainGroupCurrentTable, 3, { 25, 1, 2 }},
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_mvrDomainGroupCurrentReceiverVlan, ASN_INTEGER, RONLY, var_mvrDomainGroupCurrentTable, 3, { 25, 1, 3 }},
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

    { LEAF_mvrDomainGroupCurrentPorts, ASN_OCTET_STR, RONLY, var_mvrDomainGroupCurrentTable, 3, { 25, 1, 4 }},
};


void init_mvrDomainGroupCurrentTable(void)
{
    oid mvrDomainGroupCurrentTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,44 };

    REGISTER_MIB("mvrDomainGroupCurrentTable", mvrDomainGroupCurrentTable_variables, variable3,
                 mvrDomainGroupCurrentTable_variables_oid);
}
#endif /*#if (SYS_CPNT_MVR_SUPPORT_MULTI_DOMAIN == FALSE)*/

#if (SYS_CPNT_MVR_PROFILE == TRUE)
/* variable3 mvrProfileCtlTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */
struct variable3 mvrProfileCtlTable_variables[] =
{
/* magic number, variable type, ro/rw, callback fn, L, oidsuffix
 */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_mvrProfileCtlId, ASN_INTEGER, RONLY, var_mvrProfileCtlTable, 3, { 1, 1, 1 }},
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

    { LEAF_mvrProfileName, ASN_OCTET_STR, RWRITE, var_mvrProfileCtlTable, 3, { 1, 1, 2 }},
    { LEAF_mvrProfileCtlAction, ASN_INTEGER, RWRITE, var_mvrProfileCtlTable, 3, { 1, 1, 5 }},
};

void init_mvrProfileCtlTable(void)
{
    oid mvrProfileCtlTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,44,22 };

    REGISTER_MIB("mvrProfileCtlTable", mvrProfileCtlTable_variables, variable3,
                 mvrProfileCtlTable_variables_oid);
}


/* variable3 mvrProfileGroupCtlTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */
struct variable3 mvrProfileGroupCtlTable_variables[] =
{
/* magic number, variable type, ro/rw, callback fn, L, oidsuffix
 */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_mvrProfileGropuCtlProfileId, ASN_INTEGER, RONLY, var_mvrProfileGroupCtlTable, 3, { 2, 1, 1 }},
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_mvrProfileGroupCtlId, ASN_INTEGER, RONLY, var_mvrProfileGroupCtlTable, 3, { 2, 1, 2 }},
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

    { LEAF_mvrProfileGroupStartIPAddress, ASN_IPADDRESS, RWRITE, var_mvrProfileGroupCtlTable, 3, { 2, 1, 3 }},
    { LEAF_mvrProfileGroupEndIPAddress, ASN_IPADDRESS, RWRITE, var_mvrProfileGroupCtlTable, 3, { 2, 1, 4 }},
    { LEAF_mvrProfileGroupCtlAction, ASN_INTEGER, RWRITE, var_mvrProfileGroupCtlTable, 3, { 2, 1, 5 }},
};

void init_mvrProfileGroupCtlTable(void)
{
    oid mvrProfileGroupCtlTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,44,22 };

    REGISTER_MIB("mvrProfileGroupCtlTable", mvrProfileGroupCtlTable_variables, variable3,
                 mvrProfileGroupCtlTable_variables_oid);
}

/* variable3 mvrDomainAssociatedProfileTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */
struct variable3 mvrDomainAssociatedProfileTable_variables[] =
{
/* magic number, variable type, ro/rw, callback fn, L, oidsuffix
 */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_mvrDomainId, ASN_INTEGER, RONLY, var_mvrDomainAssociatedProfileTable, 3, { 23, 1, 1 }},
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_mvrProfileId, ASN_INTEGER, RONLY, var_mvrDomainAssociatedProfileTable, 3, { 23, 1, 2 }},
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

    { LEAF_mvrProfileAction, ASN_INTEGER, RWRITE, var_mvrDomainAssociatedProfileTable, 3, { 23, 1, 3 }},
};

void init_mvrDomainAssociatedProfileTable(void)
{
    oid mvrDomainAssociatedProfileTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,44 };

    REGISTER_MIB("mvrDomainAssociatedProfileTable", mvrDomainAssociatedProfileTable_variables, variable3,
                 mvrDomainAssociatedProfileTable_variables_oid);
}
#else

struct variable3 mvrGroupCtlTable_variables[] =
{
/* magic number, variable type, ro/rw, callback fn, L, oidsuffix
 */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_mvrGroupStartIPAddress, ASN_IPADDRESS, RONLY, var_mvrGroupCtlTable, 3, { 26, 1, 1 }},
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_mvrGroupEndIPAddress, ASN_IPADDRESS, RONLY, var_mvrGroupCtlTable, 3, { 26, 1, 2 }},
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

    { LEAF_mvrGroupCtlAction, ASN_INTEGER, RWRITE, var_mvrGroupCtlTable, 3, { 26, 1, 3 }},
};

void init_mvrGroupCtlTable(void)
{
    oid mvrGroupCtlTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,44 };

    REGISTER_MIB("mvrGroupCtlTable", mvrGroupCtlTable_variables, variable3,
                 mvrGroupCtlTable_variables_oid);
}
#endif /*#if (SYS_CPNT_MVR_PROFILE == TRUE)*/

#if(SYS_CPNT_MVR_PROXY_SWITCHING == TRUE)
void init_mvrProxySwitching(void)
{
    static oid mvrProxySwitching_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,44,27, 0 };

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("mvrProxySwitching",
                               do_mvrProxySwitching,
                               mvrProxySwitching_oid,
                               OID_LENGTH(mvrProxySwitching_oid),
                               HANDLER_CAN_RWRITE));
}

void init_mvrRobustnessValue(void)
{
    static oid mvrRobustnessValue_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,44,28, 0 };

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("mvrRobustnessValue",
                               do_mvrRobustnessValue,
                               mvrRobustnessValue_oid,
                               OID_LENGTH(mvrRobustnessValue_oid),
                               HANDLER_CAN_RWRITE));
}
#endif

#if(SYS_CPNT_MVR_PROXY_QUERY_INTERVAL == TRUE)
void init_mvrProxyQueryInterval(void)
{
    oid mvrProxyQueryInterval_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,44,29,0 };

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("mvrProxyQueryInterval",
                               do_mvrProxyQueryInterval,
                               mvrProxyQueryInterval_oid,
                               OID_LENGTH(mvrProxyQueryInterval_oid),
                               HANDLER_CAN_RWRITE));
}
#endif
#if (SYS_CPNT_MVR_SUPPORT_SOURCE_PORT_MODE == TRUE)
void init_mvrSourcePortMode(void)
{
    oid mvrSourcePortMode_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,44,30,0 };

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("mvrSourcePortMode",
                               do_mvrSourcePortMode,
                               mvrSourcePortMode_oid,
                               OID_LENGTH(mvrSourcePortMode_oid),
                               HANDLER_CAN_RWRITE));
}
#endif /*#if (SYS_CPNT_MVR_SUPPORT_SOURCE_PORT_MODE == TRUE)*/

/* variable3 mvrPortTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */
struct variable3 mvrPortStatisticsTable_variables[] =
{
    /* magic number, variable type, ro/rw, callback fn, L, oidsuffix
     *     (L = length of the oidsuffix)
     */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_mvrPortStatisticsDomainId, ASN_UNSIGNED, RONLY, var_mvrPortStatisticsTable, 3, { 32, 1, 1 }},
#endif  /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_mvrPortStatisticsPortIndex, ASN_UNSIGNED, RONLY, var_mvrPortStatisticsTable, 3, { 32, 1, 2 }},
#endif  /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

    { LEAF_mvrPortStatisticsNumGroups, ASN_UNSIGNED, RONLY, var_mvrPortStatisticsTable, 3, { 32, 1, 3 }},
    { LEAF_mvrPortStatisticsNumJoinSend, ASN_UNSIGNED, RONLY, var_mvrPortStatisticsTable, 3, { 32, 1, 4 }},
    { LEAF_mvrPortStatisticsNumJoins, ASN_UNSIGNED, RONLY, var_mvrPortStatisticsTable, 3, { 32, 1, 5 }},
    { LEAF_mvrPortStatisticsNumJoinSuccess, ASN_UNSIGNED, RONLY, var_mvrPortStatisticsTable, 3, { 32, 1, 6 }},
    { LEAF_mvrPortStatisticsNumLeavesSend, ASN_UNSIGNED, RONLY, var_mvrPortStatisticsTable, 3, { 32, 1, 7 }},
    { LEAF_mvrPortStatisticsNumLeaves, ASN_UNSIGNED, RONLY, var_mvrPortStatisticsTable, 3, { 32, 1, 8 }},
    { LEAF_mvrPortStatisticsNumGeneralQuerySend, ASN_UNSIGNED, RONLY, var_mvrPortStatisticsTable, 3, { 32, 1, 9 }},
    { LEAF_mvrPortStatisticsNumGeneralQueryRecevied, ASN_UNSIGNED, RONLY, var_mvrPortStatisticsTable, 3, { 32, 1, 10 }},
    { LEAF_mvrPortStatisticsNumSepcificQuerySend, ASN_UNSIGNED, RONLY, var_mvrPortStatisticsTable, 3, { 32, 1, 11 }},
    { LEAF_mvrPortStatisticsNumSpecificQueryReceived, ASN_UNSIGNED, RONLY, var_mvrPortStatisticsTable, 3, { 32, 1, 12 }},
    { LEAF_mvrPortStatisticsNumInvalidReport, ASN_UNSIGNED, RONLY, var_mvrPortStatisticsTable, 3, { 32, 1, 13 }},
    { LEAF_mvrPortStatisticsClearStatistics, ASN_INTEGER, RWRITE, var_mvrPortStatisticsTable, 3, { 32, 1, 14 }},
};

void init_mvrPortStatisticsTable(void)
{
    oid mvrPortStatisticsTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,44 };

    /* Register ourselves with the agent to handle our MIB tree
     */
    REGISTER_MIB("mvrPortStatisticsTable", mvrPortStatisticsTable_variables, variable3,
                 mvrPortStatisticsTable_variables_oid);
}


/* variable3 mvrVlanTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */
struct variable3 mvrVlanStatisticsTable_variables[] =
{
    /* magic number, variable type, ro/rw, callback fn, L, oidsuffix
     *     (L = length of the oidsuffix)
     */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_mvrVlanStatisticsDomainId, ASN_UNSIGNED, RONLY, var_mvrVlanStatisticsTable, 3, { 33, 1, 1 }},
#endif  /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_mvrVlanStatisticsVlanId, ASN_UNSIGNED, RONLY, var_mvrVlanStatisticsTable, 3, { 33, 1, 2 }},
#endif  /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

    { LEAF_mvrVlanStatisticsNumGroups, ASN_UNSIGNED, RONLY, var_mvrVlanStatisticsTable, 3, { 33, 1, 3 }},
    { LEAF_mvrVlanStatisticsNumJoinSend, ASN_UNSIGNED, RONLY, var_mvrVlanStatisticsTable, 3, { 33, 1, 4 }},
    { LEAF_mvrVlanStatisticsNumJoins, ASN_UNSIGNED, RONLY, var_mvrVlanStatisticsTable, 3, { 33, 1, 5 }},
    { LEAF_mvrVlanStatisticsNumJoinSuccess, ASN_UNSIGNED, RONLY, var_mvrVlanStatisticsTable, 3, { 33, 1, 6 }},
    { LEAF_mvrVlanStatisticsNumLeavesSend, ASN_UNSIGNED, RONLY, var_mvrVlanStatisticsTable, 3, { 33, 1, 7 }},
    { LEAF_mvrVlanStatisticsNumLeaves, ASN_UNSIGNED, RONLY, var_mvrVlanStatisticsTable, 3, { 33, 1, 8 }},
    { LEAF_mvrVlanStatisticsNumGeneralQuerySend, ASN_UNSIGNED, RONLY, var_mvrVlanStatisticsTable, 3, { 33, 1, 9 }},
    { LEAF_mvrVlanStatisticsNumGeneralQueryRecevied, ASN_UNSIGNED, RONLY, var_mvrVlanStatisticsTable, 3, { 33, 1, 10 }},
    { LEAF_mvrVlanStatisticsNumSepcificQuerySend, ASN_UNSIGNED, RONLY, var_mvrVlanStatisticsTable, 3, { 33, 1, 11 }},
    { LEAF_mvrVlanStatisticsNumSpecificQueryReceived, ASN_UNSIGNED, RONLY, var_mvrVlanStatisticsTable, 3, { 33, 1, 12 }},
    { LEAF_mvrVlanStatisticsNumInvalidReport, ASN_UNSIGNED, RONLY, var_mvrVlanStatisticsTable, 3, { 33, 1, 13 }},
    { LEAF_mvrVlanStatisticsClearStatistics, ASN_INTEGER, RWRITE, var_mvrVlanStatisticsTable, 3, { 33, 1, 14 }},
};


void init_mvrVlanStatisticsTable(void)
{
    oid mvrVlanStatisticsTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,44 };

    /* Register ourselves with the agent to handle our MIB tree
     */
    REGISTER_MIB("mvrVlanStatisticsTable", mvrVlanStatisticsTable_variables, variable3,
                 mvrVlanStatisticsTable_variables_oid);
}
#endif /* end of #if (SYS_CPNT_MVR == TRUE)*/

#if (SYS_CPNT_MVR6 == TRUE)
#if (SYS_CPNT_MVR6_SUPPORT_MULTI_DOMAIN == TRUE)
/* variable3 mvr6DomainTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */
struct variable3 mvr6DomainTable_variables[] =
{
/* magic number, variable type, ro/rw, callback fn, L, oidsuffix
 */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_mvr6DomainId, ASN_INTEGER, RONLY, var_mvr6DomainTable, 3, { 1, 1, 1 }},
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

    { LEAF_mvr6DomainStatus, ASN_INTEGER, RWRITE, var_mvr6DomainTable, 3, { 1, 1, 2 }},
    { LEAF_mvr6DomainRunningStatus, ASN_INTEGER, RONLY, var_mvr6DomainTable, 3, { 1, 1, 3 }},
    { LEAF_mvr6DomainVlanId, ASN_UNSIGNED, RWRITE, var_mvr6DomainTable, 3, { 1, 1, 4 }},
    { LEAF_mvr6DomainUpstreamSourceIpv6, ASN_OCTET_STR, RWRITE, var_mvr6DomainTable, 3, { 1, 1, 5 }},
    { LEAF_mvr6DomainClearDynamicGroups, ASN_INTEGER, RWRITE, var_mvr6DomainTable, 3, { 1, 1, 6 }},
};

void init_mvr6DomainTable(void)
{
    oid mvr6DomainTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,66 };

    REGISTER_MIB("mvr6DomainTable", mvr6DomainTable_variables, variable3,
                 mvr6DomainTable_variables_oid);
}

/* variable3 mvr6DomainPortTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */
struct variable3 mvr6DomainPortTable_variables[] =
{
/* magic number, variable type, ro/rw, callback fn, L, oidsuffix
 */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_mvr6PortDomainId, ASN_INTEGER, RONLY, var_mvr6DomainPortTable, 3, { 2, 1, 1 }},
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_mvr6DomainIfIndex, ASN_INTEGER, RONLY, var_mvr6DomainPortTable, 3, { 2, 1, 2 }},
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

    { LEAF_mvr6DomainPortType, ASN_INTEGER, RWRITE, var_mvr6DomainPortTable, 3, { 2, 1, 3 }},
    { LEAF_mvr6DomainPortImmediateLeave, ASN_INTEGER, RWRITE, var_mvr6DomainPortTable, 3, { 2, 1, 4 }},
    { LEAF_mvr6DomainPortActive, ASN_INTEGER, RONLY, var_mvr6DomainPortTable, 3, { 2, 1, 5 }},
};

void init_mvr6DomainPortTable(void)
{
    oid mvr6DomainPortTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,66 };

    REGISTER_MIB("mvr6DomainPortTable", mvr6DomainPortTable_variables, variable3,
                 mvr6DomainPortTable_variables_oid);
}

/* variable3 mvr6DomainGroupStaticTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */
struct variable3 mvr6DomainGroupStaticTable_variables[] =
{
/* magic number, variable type, ro/rw, callback fn, L, oidsuffix
 */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_mvr6GroupStaticDomainId, ASN_INTEGER, RONLY, var_mvr6DomainGroupStaticTable, 3, { 5, 1, 1 }},
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_mvr6DomainGroupStaticAddress, ASN_OCTET_STR, RONLY, var_mvr6DomainGroupStaticTable, 3, { 5, 1, 2 }},
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_mvr6DomainGroupStaticReceiverVlan, ASN_INTEGER, RONLY, var_mvr6DomainGroupStaticTable, 3, { 5, 1, 3 }},
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

    { LEAF_mvr6DomainGroupStaticPorts, ASN_OCTET_STR, RWRITE, var_mvr6DomainGroupStaticTable, 3, { 5, 1, 4 }},
};

void init_mvr6DomainGroupStaticTable(void)
{
    oid mvr6DomainGroupStaticTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,66 };

    REGISTER_MIB("mvr6DomainGroupStaticTable", mvr6DomainGroupStaticTable_variables, variable3,
                 mvr6DomainGroupStaticTable_variables_oid);
}

/* variable3 mvr6DomainGroupCurrentTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */
struct variable3 mvr6DomainGroupCurrentTable_variables[] =
{
/* magic number, variable type, ro/rw, callback fn, L, oidsuffix
 */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_mvr6GroupCurrenDomainId, ASN_INTEGER, RONLY, var_mvr6DomainGroupCurrentTable, 3, { 6, 1, 1 }},
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_mvr6DomainGroupCurrentAddress, ASN_OCTET_STR, RONLY, var_mvr6DomainGroupCurrentTable, 3, { 6, 1, 2 }},
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_mvr6DomainGroupCurrentReceiverVlan, ASN_INTEGER, RONLY, var_mvr6DomainGroupCurrentTable, 3, { 6, 1, 3 }},
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

    { LEAF_mvr6DomainGroupCurrentPorts, ASN_OCTET_STR, RONLY, var_mvr6DomainGroupCurrentTable, 3, { 6, 1, 4 }},
};

void init_mvr6DomainGroupCurrentTable(void)
{
    oid mvr6DomainGroupCurrentTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,66 };

    REGISTER_MIB("mvr6DomainGroupCurrentTable", mvr6DomainGroupCurrentTable_variables, variable3,
                 mvr6DomainGroupCurrentTable_variables_oid);
}
#else

void init_mvr6Status(void)
{
    oid mvr6Status_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,66,7,0 };

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("mvr6Status",
                               do_mvr6Status,
                               mvr6Status_oid,
                               OID_LENGTH(mvr6Status_oid),
                               HANDLER_CAN_RWRITE));
}

void init_mvr6VlanId(void)
{
    oid mvr6VlanId_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,66,8,0 };

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("mvr6VlanId",
                               do_mvr6VlanId,
                               mvr6VlanId_oid,
                               OID_LENGTH(mvr6VlanId_oid),
                               HANDLER_CAN_RWRITE));
}

void init_mvr6RunningStatus(void)
{
    oid mvr6RunningStatus_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,66,10,0 };

    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("mvr6RunningStatus",
                                         get_mvr6RunningStatus,
                                         mvr6RunningStatus_oid,
                                         OID_LENGTH(mvr6RunningStatus_oid),
                                         HANDLER_CAN_RONLY));
}


void init_mvr6CurrentGroups(void)
{
    oid mvr6CurrentGroups_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,66,9,0 };

    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("mvr6CurrentGroups",
                                         get_mvr6CurrentGroups,
                                         mvr6CurrentGroups_oid,
                                         OID_LENGTH(mvr6CurrentGroups_oid),
                                         HANDLER_CAN_RONLY));
}


void init_mvr6UpstreamSourceIpAddress(void)
{
    oid mvr6UpstreamSourceIpAddress_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,66,11,0 };

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("mvr6UpstreamSourceIpAddress",
                               do_mvr6UpstreamSourceIpAddress,
                               mvr6UpstreamSourceIpAddress_oid,
                               OID_LENGTH(mvr6UpstreamSourceIpAddress_oid),
                               HANDLER_CAN_RWRITE));
}

/* variable3 mvr6GroupCurrentTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */
struct variable3 mvr6GroupCurrentTable_variables[] =
{
/* magic number, variable type, ro/rw, callback fn, L, oidsuffix
 */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_mvr6GroupCurrentAddress, ASN_OCTET_STR, RONLY, var_mvr6GroupCurrentTable, 3, { 13, 1, 1 }},
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_mvr6GroupCurrentReceiverVlan, ASN_INTEGER, RONLY, var_mvr6GroupCurrentTable, 3, { 13, 1, 2 }},
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

    { LEAF_mvr6GroupCurrentPorts, ASN_OCTET_STR, RONLY, var_mvr6GroupCurrentTable, 3, { 13, 1, 3 }},
};

void init_mvr6GroupCurrentTable(void)
{
    oid mvr6GroupCurrentTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,66 };

    REGISTER_MIB("mvr6GroupCurrentTable", mvr6GroupCurrentTable_variables, variable3,
                 mvr6GroupCurrentTable_variables_oid);
}


/* variable3 mvr6GroupStaticTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */
struct variable3 mvr6GroupStaticTable_variables[] =
{
/* magic number, variable type, ro/rw, callback fn, L, oidsuffix
 */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_mvr6GroupStaticAddress, ASN_OCTET_STR, RONLY, var_mvr6GroupStaticTable, 3, { 12, 1, 1 }},
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_mvr6GroupStaticReceiverVlan, ASN_INTEGER, RONLY, var_mvr6GroupStaticTable, 3, { 12, 1, 2 }},
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

    { LEAF_mvr6GroupStaticPorts, ASN_OCTET_STR, RWRITE, var_mvr6GroupStaticTable, 3, { 12, 1, 3 }},
};

void init_mvr6GroupStaticTable(void)
{
    oid mvr6GroupStaticTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,66 };

    REGISTER_MIB("mvr6GroupStaticTable", mvr6GroupStaticTable_variables, variable3,
                 mvr6GroupStaticTable_variables_oid);
}

/* variable3 mvr6PortTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */
struct variable3 mvr6PortTable_variables[] =
{
/* magic number, variable type, ro/rw, callback fn, L, oidsuffix
 */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_mvr6IfIndex, ASN_INTEGER, RONLY, var_mvr6PortTable, 3, { 14, 1, 1 }},
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

    { LEAF_mvr6PortType, ASN_INTEGER, RWRITE, var_mvr6PortTable, 3, { 14, 1, 2 }},
    { LEAF_mvr6PortImmediateLeave, ASN_INTEGER, RWRITE, var_mvr6PortTable, 3, { 14, 1, 3 }},
    { LEAF_mvr6PortActive, ASN_INTEGER, RONLY, var_mvr6PortTable, 3, { 14, 1, 4 }},
};

void init_mvr6PortTable(void)
{
    oid mvr6PortTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,66 };

    REGISTER_MIB("mvr6PortTable", mvr6PortTable_variables, variable3,
                 mvr6PortTable_variables_oid);
}

#endif /*end #if (SYS_CPNT_MVR6_SUPPORT_MULTI_DOMAIN == TRUE)*/

#if(SYS_CPNT_MVR6_PROFILE == TRUE)
/* variable3 mvr6DomainAssociatedProfileTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */
struct variable3 mvr6DomainAssociatedProfileTable_variables[] =
{
/* magic number, variable type, ro/rw, callback fn, L, oidsuffix
 */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_mvr6ProfileDomainId, ASN_INTEGER, RONLY, var_mvr6DomainAssociatedProfileTable, 3, { 4, 1, 1 }},
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_mvr6ProfileId, ASN_INTEGER, RONLY, var_mvr6DomainAssociatedProfileTable, 3, { 4, 1, 2 }},
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

    { LEAF_mvr6ProfileAction, ASN_INTEGER, RWRITE, var_mvr6DomainAssociatedProfileTable, 3, { 4, 1, 3 }},
};

void init_mvr6DomainAssociatedProfileTable(void)
{
    oid mvr6DomainAssociatedProfileTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,66 };

    REGISTER_MIB("mvr6DomainAssociatedProfileTable", mvr6DomainAssociatedProfileTable_variables, variable3,
                 mvr6DomainAssociatedProfileTable_variables_oid);
}

/* variable3 mvr6ProfileCtlTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */
struct variable3 mvr6ProfileCtlTable_variables[] =
{
/* magic number, variable type, ro/rw, callback fn, L, oidsuffix
 */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_mvr6ProfileCtlId, ASN_INTEGER, RONLY, var_mvr6ProfileCtlTable, 3, { 1, 1, 1 }},
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

    { LEAF_mvr6ProfileName, ASN_OCTET_STR, RWRITE, var_mvr6ProfileCtlTable, 3, { 1, 1, 2 }},
    { LEAF_mvr6ProfileCtlAction, ASN_INTEGER, RWRITE, var_mvr6ProfileCtlTable, 3, { 1, 1, 5 }},
};

void init_mvr6ProfileCtlTable(void)
{
    oid mvr6ProfileCtlTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,66,22 };
    REGISTER_MIB("mvr6ProfileCtlTable", mvr6ProfileCtlTable_variables, variable3,
                 mvr6ProfileCtlTable_variables_oid);
}

struct variable3 mvr6ProfileGroupCtlTable_variables[] =
{
/* magic number, variable type, ro/rw, callback fn, L, oidsuffix
*/
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_mvr6ProfileGropuCtlProfileId, ASN_INTEGER, RONLY, var_mvr6ProfileGroupCtlTable, 3, { 2, 1, 1 }},
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_mvr6ProfileGroupCtlId, ASN_INTEGER, RONLY, var_mvr6ProfileGroupCtlTable, 3, { 2, 1, 2 }},
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

    { LEAF_mvr6ProfileGroupStartIPAddress, ASN_OCTET_STR, RWRITE, var_mvr6ProfileGroupCtlTable, 3, { 2, 1, 3 }},
    { LEAF_mvr6ProfileGroupEndIPAddress, ASN_OCTET_STR, RWRITE, var_mvr6ProfileGroupCtlTable, 3, { 2, 1, 4 }},
    { LEAF_mvr6ProfileGroupCtlAction, ASN_INTEGER, RWRITE, var_mvr6ProfileGroupCtlTable, 3, { 2, 1, 5 }},
};

void init_mvr6ProfileGroupCtlTable(void)
{
    oid mvr6ProfileGroupCtlTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,66,22 };

    REGISTER_MIB("mvr6ProfileGroupCtlTable", mvr6ProfileGroupCtlTable_variables, variable3,
                 mvr6ProfileGroupCtlTable_variables_oid);
}
#else
/* variable3 mvr6GroupCtlTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */
struct variable3 mvr6GroupCtlTable_variables[] =
{
/* magic number, variable type, ro/rw, callback fn, L, oidsuffix
 */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_mvr6GroupStartIPAddress, ASN_OCTET_STR, RONLY, var_mvr6GroupCtlTable, 3, { 15, 1, 1 }},
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_mvr6GroupEndIPAddress, ASN_OCTET_STR, RONLY, var_mvr6GroupCtlTable, 3, { 15, 1, 2 }},
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

    { LEAF_mvr6GroupCtlAction, ASN_INTEGER, RWRITE, var_mvr6GroupCtlTable, 3, { 15, 1, 3 }},
};

void init_mvr6GroupCtlTable(void)
{
    oid mvr6GroupCtlTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,66 };

    REGISTER_MIB("mvr6GroupCtlTable", mvr6GroupCtlTable_variables, variable3,
                 mvr6GroupCtlTable_variables_oid);
}

#endif /*end #if(SYS_CPNT_MVR6_PROFILE == TRUE)*/
#if(SYS_CPNT_MVR6_PROXY_SWITCHING == TRUE)
void init_mvr6ProxySwitching(void)
{
    static oid mvr6ProxySwitching_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,66,16, 0 };

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("mvr6ProxySwitching",
                               do_mvr6ProxySwitching,
                               mvr6ProxySwitching_oid,
                               OID_LENGTH(mvr6ProxySwitching_oid),
                               HANDLER_CAN_RWRITE));
}
void init_mvr6RobustnessValue(void)
{
    static oid mvr6RobustnessValue_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,66,17, 0 };

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("mvr6RobustnessValue",
                               do_mvr6RobustnessValue,
                               mvr6RobustnessValue_oid,
                               OID_LENGTH(mvr6RobustnessValue_oid),
                               HANDLER_CAN_RWRITE));
}

#endif
#if(SYS_CPNT_MVR6_PROXY_QUERY_INTERVAL == TRUE)
void init_mvr6ProxyQueryInterval(void)
{
    oid mvr6ProxyQueryInterval_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,66,23,0 };

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("mvr6ProxyQueryInterval",
                               do_mvr6ProxyQueryInterval,
                               mvr6ProxyQueryInterval_oid,
                               OID_LENGTH(mvr6ProxyQueryInterval_oid),
                               HANDLER_CAN_RWRITE));
}
#endif
#if (SYS_CPNT_MVR6_SUPPORT_SOURCE_PORT_MODE == TRUE)
void init_mvr6SourcePortMode(void)
{
    oid mvr6SourcePortMode_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,66,24,0 };

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("mvr6SourcePortMode",
                               do_mvr6SourcePortMode,
                               mvr6SourcePortMode_oid,
                               OID_LENGTH(mvr6SourcePortMode_oid),
                               HANDLER_CAN_RWRITE));
}
#endif /*#if (SYS_CPNT_MVR6_SUPPORT_SOURCE_PORT_MODE == TRUE)*/

/* variable3 mvr6PortTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */
struct variable3 mvr6PortStatisticsTable_variables[] =
{
    /* magic number, variable type, ro/rw, callback fn, L, oidsuffix
     *     (L = length of the oidsuffix)
     */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_mvr6PortStatisticsDomainId, ASN_UNSIGNED, RONLY, var_mvr6PortStatisticsTable, 3, { 26, 1, 1 }},
#endif  /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_mvr6PortStatisticsPortIndex, ASN_UNSIGNED, RONLY, var_mvr6PortStatisticsTable, 3, { 26, 1, 2 }},
#endif  /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

    { LEAF_mvr6PortStatisticsNumGroups, ASN_UNSIGNED, RONLY, var_mvr6PortStatisticsTable, 3, { 26, 1, 3 }},
    { LEAF_mvr6PortStatisticsNumJoinSend, ASN_UNSIGNED, RONLY, var_mvr6PortStatisticsTable, 3, { 26, 1, 4 }},
    { LEAF_mvr6PortStatisticsNumJoins, ASN_UNSIGNED, RONLY, var_mvr6PortStatisticsTable, 3, { 26, 1, 5 }},
    { LEAF_mvr6PortStatisticsNumJoinSuccess, ASN_UNSIGNED, RONLY, var_mvr6PortStatisticsTable, 3, { 26, 1, 6 }},
    { LEAF_mvr6PortStatisticsNumLeavesSend, ASN_UNSIGNED, RONLY, var_mvr6PortStatisticsTable, 3, { 26, 1, 7 }},
    { LEAF_mvr6PortStatisticsNumLeaves, ASN_UNSIGNED, RONLY, var_mvr6PortStatisticsTable, 3, { 26, 1, 8 }},
    { LEAF_mvr6PortStatisticsNumGeneralQuerySend, ASN_UNSIGNED, RONLY, var_mvr6PortStatisticsTable, 3, { 26, 1, 9 }},
    { LEAF_mvr6PortStatisticsNumGeneralQueryRecevied, ASN_UNSIGNED, RONLY, var_mvr6PortStatisticsTable, 3, { 26, 1, 10 }},
    { LEAF_mvr6PortStatisticsNumSepcificQuerySend, ASN_UNSIGNED, RONLY, var_mvr6PortStatisticsTable, 3, { 26, 1, 11 }},
    { LEAF_mvr6PortStatisticsNumSpecificQueryReceived, ASN_UNSIGNED, RONLY, var_mvr6PortStatisticsTable, 3, { 26, 1, 12 }},
    { LEAF_mvr6PortStatisticsNumInvalidReport, ASN_UNSIGNED, RONLY, var_mvr6PortStatisticsTable, 3, { 26, 1, 13 }},
    { LEAF_mvr6PortStatisticsClearStatistics, ASN_INTEGER, RWRITE, var_mvr6PortStatisticsTable, 3, { 26, 1, 14 }},
};

void init_mvr6PortStatisticsTable(void)
{
    oid mvr6PortStatisticsTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,66 };

    /* Register ourselves with the agent to handle our MIB tree
     */
    REGISTER_MIB("mvr6PortStatisticsTable", mvr6PortStatisticsTable_variables, variable3,
                 mvr6PortStatisticsTable_variables_oid);
}


/* variable3 mvr6VlanTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */
struct variable3 mvr6VlanStatisticsTable_variables[] =
{
    /* magic number, variable type, ro/rw, callback fn, L, oidsuffix
     *     (L = length of the oidsuffix)
     */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_mvr6VlanStatisticsDomainId, ASN_UNSIGNED, RONLY, var_mvr6VlanStatisticsTable, 3, { 27, 1, 1 }},
#endif  /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_mvr6VlanStatisticsVlanId, ASN_UNSIGNED, RONLY, var_mvr6VlanStatisticsTable, 3, { 27, 1, 2 }},
#endif  /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

    { LEAF_mvr6VlanStatisticsNumGroups, ASN_UNSIGNED, RONLY, var_mvr6VlanStatisticsTable, 3, { 27, 1, 3 }},
    { LEAF_mvr6VlanStatisticsNumJoinSend, ASN_UNSIGNED, RONLY, var_mvr6VlanStatisticsTable, 3, { 27, 1, 4 }},
    { LEAF_mvr6VlanStatisticsNumJoins, ASN_UNSIGNED, RONLY, var_mvr6VlanStatisticsTable, 3, { 27, 1, 5 }},
    { LEAF_mvr6VlanStatisticsNumJoinSuccess, ASN_UNSIGNED, RONLY, var_mvr6VlanStatisticsTable, 3, { 27, 1, 6 }},
    { LEAF_mvr6VlanStatisticsNumLeavesSend, ASN_UNSIGNED, RONLY, var_mvr6VlanStatisticsTable, 3, { 27, 1, 7 }},
    { LEAF_mvr6VlanStatisticsNumLeaves, ASN_UNSIGNED, RONLY, var_mvr6VlanStatisticsTable, 3, { 27, 1, 8 }},
    { LEAF_mvr6VlanStatisticsNumGeneralQuerySend, ASN_UNSIGNED, RONLY, var_mvr6VlanStatisticsTable, 3, { 27, 1, 9 }},
    { LEAF_mvr6VlanStatisticsNumGeneralQueryRecevied, ASN_UNSIGNED, RONLY, var_mvr6VlanStatisticsTable, 3, { 27, 1, 10 }},
    { LEAF_mvr6VlanStatisticsNumSepcificQuerySend, ASN_UNSIGNED, RONLY, var_mvr6VlanStatisticsTable, 3, { 27, 1, 11 }},
    { LEAF_mvr6VlanStatisticsNumSpecificQueryReceived, ASN_UNSIGNED, RONLY, var_mvr6VlanStatisticsTable, 3, { 27, 1, 12 }},
    { LEAF_mvr6VlanStatisticsNumInvalidReport, ASN_UNSIGNED, RONLY, var_mvr6VlanStatisticsTable, 3, { 27, 1, 13 }},
    { LEAF_mvr6VlanStatisticsClearStatistics, ASN_INTEGER, RWRITE, var_mvr6VlanStatisticsTable, 3, { 27, 1, 14 }},
};

void init_mvr6VlanStatisticsTable(void)
{
    oid mvr6VlanStatisticsTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,66 };

    /* Register ourselves with the agent to handle our MIB tree
     */
    REGISTER_MIB("mvr6VlanStatisticsTable", mvr6VlanStatisticsTable_variables, variable3,
                 mvr6VlanStatisticsTable_variables_oid);
}

#if(SYS_CPNT_MVR6_FORWARD_PRIORITY == TRUE)

void init_mvr6ForwardingPriority(void)
{
    oid mvr6ForwardingPriority_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1, 66,28, 0 };

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("mvr6ForwardingPriority",
                               do_mvr6ForwardingPriority,
                               mvr6ForwardingPriority_oid,
                               OID_LENGTH(mvr6ForwardingPriority_oid),
                               HANDLER_CAN_RWRITE));
}

#endif

#endif /*end #if (SYS_CPNT_MVR6 == TRUE)*/

#if (SYS_CPNT_ERPS == TRUE)
/********************************************
 **************** erpsMgt *******************
 ********************************************
 */
void init_erpsMgt(void)
{
    static oid erpsGlobalStatus_oid[]  = { SYS_ADPT_PRIVATEMIB_OID, 1, 62, 1, 0};
    static oid erpsGlobalClearStatisticsAction_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,62,3, 0 };

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("erpsGlobalStatus",
                               do_erpsGlobalStatus,
                               erpsGlobalStatus_oid,
                               OID_LENGTH(erpsGlobalStatus_oid),
                               HANDLER_CAN_RWRITE));

    netsnmp_register_instance(netsnmp_create_handler_registration
                          ("erpsGlobalClearStatisticsAction",
                           do_erpsGlobalClearStatisticsAction,
                           erpsGlobalClearStatisticsAction_oid,
                           OID_LENGTH(erpsGlobalClearStatisticsAction_oid),
                           HANDLER_CAN_RWRITE));
}

/********************************************
 ************* erpsDomainTable **************
 ********************************************
 */
/* variable3 erpsDomainTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */
struct variable3 erpsDomainTable_variables[] =
{
/* magic number, variable type, ro/rw, callback fn, L, oidsuffix
 */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_erpsDomainIndex, ASN_INTEGER, RONLY, var_erpsDomainTable, 3, { 2, 1, 1 }},
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

    { LEAF_erpsDomainName, ASN_OCTET_STR, RWRITE, var_erpsDomainTable, 3, { 2, 1, 2 }},
    { LEAF_erpsDomainMegLevel, ASN_INTEGER, RWRITE, var_erpsDomainTable, 3, { 2, 1, 3 }},
    { LEAF_erpsDomainNodeId, ASN_OCTET_STR, RWRITE, var_erpsDomainTable, 3, { 2, 1, 4 }},
    { LEAF_erpsDomainWestRingPort, ASN_INTEGER, RWRITE, var_erpsDomainTable, 3, { 2, 1, 5 }},
    { LEAF_erpsDomainEastRingPort, ASN_INTEGER, RWRITE, var_erpsDomainTable, 3, { 2, 1, 6 }},
#if 0 /* obsoleted by LEAF_erpsDomainNodeType */
    { LEAF_erpsDomainRplOwner, ASN_INTEGER, RWRITE, var_erpsDomainTable, 3, { 2, 1, 7 }},
#endif
    { LEAF_erpsDomainRplPort, ASN_INTEGER, RONLY, var_erpsDomainTable, 3, { 2, 1, 8 }},
    { LEAF_erpsDomainGuardTimer, ASN_INTEGER, RWRITE, var_erpsDomainTable, 3, { 2, 1, 9 }},
    { LEAF_erpsDomainHoldoffTimer, ASN_INTEGER, RWRITE, var_erpsDomainTable, 3, { 2, 1, 10 }},
    { LEAF_erpsDomainWtrTimer, ASN_INTEGER, RWRITE, var_erpsDomainTable, 3, { 2, 1, 11 }},
    { LEAF_erpsDomainControlVlanID, ASN_INTEGER, RWRITE, var_erpsDomainTable, 3, { 2, 1, 12 }},
    { LEAF_erpsDomainNodeState, ASN_INTEGER, RONLY, var_erpsDomainTable, 3, { 2, 1, 13 }},
    { LEAF_erpsDomainWestRingPortState, ASN_INTEGER, RONLY, var_erpsDomainTable, 3, { 2, 1, 14 }},
    { LEAF_erpsDomainEastRingPortState, ASN_INTEGER, RONLY, var_erpsDomainTable, 3, { 2, 1, 15 }},
    { LEAF_erpsDomainRowStatus, ASN_INTEGER, RWRITE, var_erpsDomainTable, 3, { 2, 1, 16 }},
    { LEAF_erpsDomainMajorDomainIndex, ASN_INTEGER, RWRITE, var_erpsDomainTable, 3, { 2, 1, 17 }},
    { LEAF_erpsDomainPropagateTC, ASN_INTEGER, RWRITE, var_erpsDomainTable, 3, { 2, 1, 18 }},
#if (SYS_CPNT_ERPS_SEND_BPDU_TCN == TRUE)
    { LEAF_erpsDomainBpduTcnNotify, ASN_INTEGER, RWRITE, var_erpsDomainTable, 3, { 2, 1, 19 }},
#endif /* #if (SYS_CPNT_ERPS_SEND_BPDU_TCN == TRUE) */
#if (SYS_CPNT_ERPS_MEP_MONITOR == TRUE)
    { LEAF_erpsDomainWestMepId, ASN_INTEGER, RWRITE, var_erpsDomainTable, 3, { 2, 1, 20 }},
    { LEAF_erpsDomainEastMepId, ASN_INTEGER, RWRITE, var_erpsDomainTable, 3, { 2, 1, 21 }},
#endif /* #if (SYS_CPNT_ERPS_MEP_MONITOR == TRUE) */
#if (SYS_CPNT_ERPS_NON_ERPS_DEV_PROTECT == TRUE)
    { LEAF_erpsDomainNonErpsDevProtect, ASN_INTEGER, RWRITE, var_erpsDomainTable, 3, { 2, 1, 22 }},
#endif /* #if (SYS_CPNT_ERPS_NON_ERPS_DEV_PROTECT == TRUE) */

    { LEAF_erpsDomainNodeType, ASN_INTEGER, RWRITE, var_erpsDomainTable, 3, { 2, 1, 23 }},
    { LEAF_erpsDomainNonRevertive, ASN_INTEGER, RWRITE, var_erpsDomainTable, 3, { 2, 1, 24 }},
    { LEAF_erpsDomainRapsDefMac, ASN_INTEGER, RWRITE, var_erpsDomainTable, 3, { 2, 1, 25 }},
    { LEAF_erpsDomainRapsWithoutVc, ASN_INTEGER, RWRITE, var_erpsDomainTable, 3, { 2, 1, 26 }},
    { LEAF_erpsDomainVersion, ASN_INTEGER, RWRITE, var_erpsDomainTable, 3, { 2, 1, 27 }},
    { LEAF_erpsDomainForcedSwitch, ASN_INTEGER, RWRITE, var_erpsDomainTable, 3, { 2, 1, 28 }},
    { LEAF_erpsDomainManualSwitch, ASN_INTEGER, RWRITE, var_erpsDomainTable, 3, { 2, 1, 29 }},
    { LEAF_erpsDomainClear, ASN_INTEGER, RWRITE, var_erpsDomainTable, 3, { 2, 1, 30 }},
    { LEAF_erpsDomainStatsClearAction, ASN_INTEGER, RWRITE, var_erpsDomainTable, 3, { 2, 1, 31 }},
    { LEAF_erpsDomainWtbTimer, ASN_INTEGER, RONLY, var_erpsDomainTable, 3, { 2, 1, 32 }},
    { LEAF_erpsDomainWtbExpire, ASN_INTEGER, RONLY, var_erpsDomainTable, 3, { 2, 1, 33 }},
    { LEAF_erpsDomainWtrExpire, ASN_INTEGER, RONLY, var_erpsDomainTable, 3, { 2, 1, 34 }},
    { LEAF_erpsDomainWestRingPortSf, ASN_INTEGER, RONLY, var_erpsDomainTable, 3, { 2, 1, 35 }},
    { LEAF_erpsDomainEastRingPortSf, ASN_INTEGER, RONLY, var_erpsDomainTable, 3, { 2, 1, 36 }},
    { LEAF_erpsDomainMultiRplOwnerWarn, ASN_INTEGER, RONLY, var_erpsDomainTable, 3, { 2, 1, 37 }},
};

void init_erpsDomainTable(void)
{
    static oid erpsDomainTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1, 62};

    REGISTER_MIB("erpsDomainTable", erpsDomainTable_variables, variable3,
                 erpsDomainTable_variables_oid);
}

/********************************************
 ************* erpsPortStatsTable **************
 ********************************************
 */
/* variable3 erpsPortStatsTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */
struct variable3 erpsPortStatsTable_variables[] =
{
/* magic number, variable type, ro/rw, callback fn, L, oidsuffix
 */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_erpsPortStatsDomainIndex, ASN_INTEGER, RONLY, var_erpsPortStatsTable, 3, { 4, 1, 1 }},
#endif  /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_erpsPortStatsPortIndex, ASN_INTEGER, RONLY, var_erpsPortStatsTable, 3, { 4, 1, 2 }},
#endif  /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

    { LEAF_erpsPortStatsLocalSfCount, ASN_COUNTER, RONLY, var_erpsPortStatsTable, 3, { 4, 1, 3 }},
    { LEAF_erpsPortStatsLocalClrSfCount, ASN_COUNTER, RONLY, var_erpsPortStatsTable, 3, { 4, 1, 4 }},
    { LEAF_erpsPortStatsSentSfPkts, ASN_COUNTER, RONLY, var_erpsPortStatsTable, 3, { 4, 1, 5 }},
    { LEAF_erpsPortStatsSentNrPkts, ASN_COUNTER, RONLY, var_erpsPortStatsTable, 3, { 4, 1, 6 }},
    { LEAF_erpsPortStatsSentNrRbPkts, ASN_COUNTER, RONLY, var_erpsPortStatsTable, 3, { 4, 1, 7 }},
    { LEAF_erpsPortStatsSentFsPkts, ASN_COUNTER, RONLY, var_erpsPortStatsTable, 3, { 4, 1, 8 }},
    { LEAF_erpsPortStatsSentMsPkts, ASN_COUNTER, RONLY, var_erpsPortStatsTable, 3, { 4, 1, 9 }},
    { LEAF_erpsPortStatsSentEventPkts, ASN_COUNTER, RONLY, var_erpsPortStatsTable, 3, { 4, 1, 10 }},
    { LEAF_erpsPortStatsSentHealthPkts, ASN_COUNTER, RONLY, var_erpsPortStatsTable, 3, { 4, 1, 11 }},
    { LEAF_erpsPortStatsRecvSfPkts, ASN_COUNTER, RONLY, var_erpsPortStatsTable, 3, { 4, 1, 12 }},
    { LEAF_erpsPortStatsRecvNrPkts, ASN_COUNTER, RONLY, var_erpsPortStatsTable, 3, { 4, 1, 13 }},
    { LEAF_erpsPortStatsRecvNrRbPkts, ASN_COUNTER, RONLY, var_erpsPortStatsTable, 3, { 4, 1, 14 }},
    { LEAF_erpsPortStatsRecvFsPkts, ASN_COUNTER, RONLY, var_erpsPortStatsTable, 3, { 4, 1, 15 }},
    { LEAF_erpsPortStatsRecvMsPkts, ASN_COUNTER, RONLY, var_erpsPortStatsTable, 3, { 4, 1, 16 }},
    { LEAF_erpsPortStatsRecvEventPkts, ASN_COUNTER, RONLY, var_erpsPortStatsTable, 3, { 4, 1, 17 }},
    { LEAF_erpsPortStatsRecvHealthPkts, ASN_COUNTER, RONLY, var_erpsPortStatsTable, 3, { 4, 1, 18 }},
    { LEAF_erpsPortStatsIgnoreSfPkts, ASN_COUNTER, RONLY, var_erpsPortStatsTable, 3, { 4, 1, 19 }},
    { LEAF_erpsPortStatsIgnoreNrPkts, ASN_COUNTER, RONLY, var_erpsPortStatsTable, 3, { 4, 1, 20 }},
    { LEAF_erpsPortStatsIgnoreNrRbPkts, ASN_COUNTER, RONLY, var_erpsPortStatsTable, 3, { 4, 1, 21 }},
    { LEAF_erpsPortStatsIgnoreFsPkts, ASN_COUNTER, RONLY, var_erpsPortStatsTable, 3, { 4, 1, 22 }},
    { LEAF_erpsPortStatsIgnoreMsPkts, ASN_COUNTER, RONLY, var_erpsPortStatsTable, 3, { 4, 1, 23 }},
    { LEAF_erpsPortStatsIgnoreEventPkts, ASN_COUNTER, RONLY, var_erpsPortStatsTable, 3, { 4, 1, 24 }},
    { LEAF_erpsPortStatsIgnoreHealthPkts, ASN_COUNTER, RONLY, var_erpsPortStatsTable, 3, { 4, 1, 25 }},
};

void init_erpsPortStatsTable(void)
{
    static oid erpsPortStatsTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1, 62};

    REGISTER_MIB("erpsPortStatsTable", erpsPortStatsTable_variables, variable3,
                 erpsPortStatsTable_variables_oid);
}

#endif /* end of #if (SYS_CPNT_ERPS == TRUE)*/

#if (SYS_CPNT_PPPOE_IA == TRUE)
void
init_pppoeiaGlobal(void)
{
    static oid pppoeiaGlobalStatus_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,60,1,1,0 };
    static oid pppoeiaGlobalAccessNodeId_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,60,1,2,0 };
    static oid pppoeiaGlobalOperAccessNodeId_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,60,1,3,0 };
    static oid pppoeiaGlobalGenericErrorMsg_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,60,1,4,0 };
    static oid pppoeiaGlobalOperGenericErrorMsg_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,60,1,5,0 };
    static oid pppoeiaGlobalClearStatisticsAction_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,60,1,6,0 };

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("pppoeiaGlobalStatus",
                               do_pppoeiaGlobalStatus,
                               pppoeiaGlobalStatus_oid,
                               OID_LENGTH(pppoeiaGlobalStatus_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("pppoeiaGlobalAccessNodeId",
                               do_pppoeiaGlobalAccessNodeId,
                               pppoeiaGlobalAccessNodeId_oid,
                               OID_LENGTH(pppoeiaGlobalAccessNodeId_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("pppoeiaGlobalOperAccessNodeId",
                                         get_pppoeiaGlobalOperAccessNodeId,
                                         pppoeiaGlobalOperAccessNodeId_oid,
                                         OID_LENGTH(pppoeiaGlobalOperAccessNodeId_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("pppoeiaGlobalGenericErrorMsg",
                               do_pppoeiaGlobalGenericErrorMsg,
                               pppoeiaGlobalGenericErrorMsg_oid,
                               OID_LENGTH(pppoeiaGlobalGenericErrorMsg_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("pppoeiaGlobalOperGenericErrorMsg",
                                         get_pppoeiaGlobalOperGenericErrorMsg,
                                         pppoeiaGlobalOperGenericErrorMsg_oid,
                                         OID_LENGTH(pppoeiaGlobalOperGenericErrorMsg_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("pppoeiaGlobalClearStatisticsAction",
                               do_pppoeiaGlobalClearStatisticsAction,
                               pppoeiaGlobalClearStatisticsAction_oid,
                               OID_LENGTH(pppoeiaGlobalClearStatisticsAction_oid),
                               HANDLER_CAN_RWRITE));
}

/********************************************
 ********** init_pppoeiaPortTable ***********
 ********************************************
 */
oid pppoeiaPortTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,60 };
struct variable3 pppoeiaPortTable_variables[] = {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
{LEAF_pppoeiaPortIndex,  ASN_INTEGER,  RONLY,   var_pppoeiaPortTable, 3,  { 2, 1, 1 }},
#endif

{LEAF_pppoeiaPortStatus,  ASN_INTEGER,  RWRITE,  var_pppoeiaPortTable, 3,  { 2, 1, 2 }},
{LEAF_pppoeiaPortTrustStatus,  ASN_INTEGER,  RWRITE,  var_pppoeiaPortTable, 3,  { 2, 1, 3 }},
{LEAF_pppoeiaPortVendorTagStrip,  ASN_INTEGER,  RWRITE,  var_pppoeiaPortTable, 3,  { 2, 1, 4 }},
{LEAF_pppoeiaPortCircuitId,  ASN_OCTET_STR,  RWRITE,  var_pppoeiaPortTable, 3,  { 2, 1, 5 }},
{LEAF_pppoeiaPortOperCircuitId,  ASN_OCTET_STR,  RONLY,   var_pppoeiaPortTable, 3,  { 2, 1, 6 }},
{LEAF_pppoeiaPortRemoteId,  ASN_OCTET_STR,  RWRITE,  var_pppoeiaPortTable, 3,  { 2, 1, 7 }},
{LEAF_pppoeiaPortOperRemoteId,  ASN_OCTET_STR,  RONLY,   var_pppoeiaPortTable, 3,  { 2, 1, 8 }},
};

void
init_pppoeiaPortTable(void)
{
    REGISTER_MIB("pppoeiaPortTable", pppoeiaPortTable_variables, variable3,
                 pppoeiaPortTable_variables_oid);
}

/********************************************
 ********** init_pppoeiaPortTable ***********
 ********************************************
 */
oid pppoeiaPortStatsTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,60 };
struct variable3 pppoeiaPortStatsTable_variables[] = {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
{LEAF_pppoeiaPortStatsIndex,  ASN_INTEGER,  RONLY,   var_pppoeiaPortStatsTable, 3,  { 3, 1, 1 }},
#endif

{LEAF_pppoeiaPortStatsRecvPkts,  ASN_COUNTER,  RONLY,   var_pppoeiaPortStatsTable, 3,  { 3, 1, 2 }},
{LEAF_pppoeiaPortStatsRecvPadiPkts,  ASN_COUNTER,  RONLY,   var_pppoeiaPortStatsTable, 3,  { 3, 1, 3 }},
{LEAF_pppoeiaPortStatsRecvPadoPkts,  ASN_COUNTER,  RONLY,   var_pppoeiaPortStatsTable, 3,  { 3, 1, 4 }},
{LEAF_pppoeiaPortStatsRecvPadrPkts,  ASN_COUNTER,  RONLY,   var_pppoeiaPortStatsTable, 3,  { 3, 1, 5 }},
{LEAF_pppoeiaPortStatsRecvPadsPkts,  ASN_COUNTER,  RONLY,   var_pppoeiaPortStatsTable, 3,  { 3, 1, 6 }},
{LEAF_pppoeiaPortStatsRecvPadtPkts,  ASN_COUNTER,  RONLY,   var_pppoeiaPortStatsTable, 3,  { 3, 1, 7 }},
{LEAF_pppoeiaPortStatsDropUntrustRespPkts,  ASN_COUNTER,  RONLY,   var_pppoeiaPortStatsTable, 3,  { 3, 1, 8 }},
{LEAF_pppoeiaPortStatsDropUntrustReqPkts,  ASN_COUNTER,  RONLY,   var_pppoeiaPortStatsTable, 3,  { 3, 1, 9 }},
{LEAF_pppoeiaPortStatsDropMalformedPkts,  ASN_COUNTER,  RONLY,   var_pppoeiaPortStatsTable, 3,  { 3, 1, 10 }},
{LEAF_pppoeiaPortStatsClearAction,  ASN_INTEGER,  RWRITE,  var_pppoeiaPortStatsTable, 3,  { 3, 1, 11 }},
};

void
init_pppoeiaPortStatsTable(void)
{
    REGISTER_MIB("pppoeiaPortStatsTable", pppoeiaPortStatsTable_variables, variable3,
                 pppoeiaPortStatsTable_variables_oid);
}

#endif  /* SYS_CPNT_PPPOE_IA == TRUE */

#if (SYS_CPNT_IPV6_RA_GUARD == TRUE)
/********************************************
 ************* ipv6RaGuardMgt ***************
 ********************************************
 */

/********************************************
 ************* ipv6RaGuardPortTable *********
 ********************************************
 */
/* variable3 ipv6RaGuardPortTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */
struct variable3 ipv6RaGuardPortTable_variables[] =
{
/* magic number, variable type, ro/rw, callback fn, L, oidsuffix
 */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_ipv6RaGuardPortIndex, ASN_INTEGER, RONLY, var_ipv6RaGuardPortTable, 3, { 1, 1, 1 }},
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

    { LEAF_ipv6RaGuardPortStatus, ASN_INTEGER, RWRITE, var_ipv6RaGuardPortTable, 3, { 1, 1, 2 }},
};

void init_ipv6RaGuardPortTable(void)
{
    oid ipv6RaGuardPortTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1, 67};

    REGISTER_MIB("ipv6RaGuardMgt", ipv6RaGuardPortTable_variables, variable3,
                 ipv6RaGuardPortTable_variables_oid);
}

#endif /* end of #if (SYS_CPNT_IPV6_RA_GUARD == TRUE)*/

#if (SYS_CPNT_UDLD == TRUE)
/********************************************
 **************** udldMgt *******************
 ********************************************
 */
void init_udldMgt(void)
{
    static oid udldGlobalMessageInterval_oid[]   = { SYS_ADPT_PRIVATEMIB_OID, 1, 69, 1, 0 };
    static oid udldGlobalDetectionInterval_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1, 69, 4, 0 };
    static oid udldGlobalRecoveryInterval_oid[]  = { SYS_ADPT_PRIVATEMIB_OID, 1, 69, 5, 0 };
    static oid udldGlobalRecovery_oid[]          = { SYS_ADPT_PRIVATEMIB_OID, 1, 69, 6, 0 };

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("udldGlobalMessageInterval",
                               do_udldGlobalMessageInterval,
                               udldGlobalMessageInterval_oid,
                               OID_LENGTH(udldGlobalMessageInterval_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("udldGlobalDetectionInterval",
                               do_udldGlobalDetectionInterval,
                               udldGlobalDetectionInterval_oid,
                               OID_LENGTH(udldGlobalDetectionInterval_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("udldGlobalRecoveryInterval",
                               do_udldGlobalRecoveryInterval,
                               udldGlobalRecoveryInterval_oid,
                               OID_LENGTH(udldGlobalRecoveryInterval_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("udldGlobalRecovery",
                               do_udldGlobalRecovery,
                               udldGlobalRecovery_oid,
                               OID_LENGTH(udldGlobalRecovery_oid),
                               HANDLER_CAN_RWRITE));
}

/********************************************
 ************* udldPortTable   **************
 ********************************************
 */
/* variable3 udldPortTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */
struct variable3 udldPortTable_variables[] =
{
    /* magic number, variable type, ro/rw, callback fn, L, oidsuffix
     */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        { LEAF_udldPortIndex, ASN_INTEGER, RONLY, var_udldPortTable, 3, { 2, 1, 1 }},
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

        { LEAF_udldPortStatus, ASN_INTEGER, RWRITE, var_udldPortTable, 3, { 2, 1, 2 }},
        { LEAF_udldPortAggressiveStatus, ASN_INTEGER, RWRITE, var_udldPortTable, 3, { 2, 1, 3 }},
        { LEAF_udldPortOperState, ASN_INTEGER, RONLY, var_udldPortTable, 3, { 2, 1, 4 }},
        { LEAF_udldPortPortState, ASN_INTEGER, RONLY, var_udldPortTable, 3, { 2, 1, 5 }},
        { LEAF_udldPortOperMessageInterval, ASN_INTEGER, RONLY, var_udldPortTable, 3, { 2, 1, 6 }},
        { LEAF_udldPortOperTimeout, ASN_INTEGER, RONLY, var_udldPortTable, 3, { 2, 1, 7 }},
        { LEAF_udldPortNeighborDevCount, ASN_INTEGER, RONLY, var_udldPortTable, 3, { 2, 1, 8 }},
};

void init_udldPortTable(void)
{
    static oid udldPortTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1, 69};

    REGISTER_MIB("udldMgt", udldPortTable_variables, variable3,
                 udldPortTable_variables_oid);
}

/********************************************
 ************* udldPortNeighborDevTable *****
 ********************************************
 */
/* variable3 udldPortNeighborDevTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */
struct variable3 udldPortNeighborDevTable_variables[] =
{
    /* magic number, variable type, ro/rw, callback fn, L, oidsuffix
     */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        { LEAF_udldPortNeighborDevIndex, ASN_INTEGER, RONLY, var_udldPortNeighborDevTable, 3, { 3, 1, 2 }},
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

        { LEAF_udldPortNeighborDevDevID, ASN_OCTET_STR, RONLY, var_udldPortNeighborDevTable, 3, { 3, 1, 3 }},
        { LEAF_udldPortNeighborDevPortID, ASN_OCTET_STR, RONLY, var_udldPortNeighborDevTable, 3, { 3, 1, 4 }},
        { LEAF_udldPortNeighborDevDevName, ASN_OCTET_STR, RONLY, var_udldPortNeighborDevTable, 3, { 3, 1, 5 }},
        { LEAF_udldPortNeighborDevNeighborState, ASN_INTEGER, RONLY, var_udldPortNeighborDevTable, 3, { 3, 1, 6 }},
        { LEAF_udldPortNeighborDevExpire, ASN_INTEGER, RONLY, var_udldPortNeighborDevTable, 3, { 3, 1, 7 }},
        { LEAF_udldPortNeighborDevMessageInterval, ASN_INTEGER, RONLY, var_udldPortNeighborDevTable, 3, { 3, 1, 8 }},
        { LEAF_udldPortNeighborDevTimeout, ASN_INTEGER, RONLY, var_udldPortNeighborDevTable, 3, { 3, 1, 9 }},
};

void init_udldPortNeighborDevTable(void)
{
    static oid udldPortNeighborDevTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1, 69};

    REGISTER_MIB("udldMgt", udldPortNeighborDevTable_variables, variable3,
                 udldPortNeighborDevTable_variables_oid);
}

#endif /* end of #if (SYS_CPNT_UDLD == TRUE)*/

#if (SYS_CPNT_PTP == TRUE)

void init_ptpMode(void)
{
    oid ptpMode_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,70,1,0 };

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("ptpMode",
                               do_ptpMode,
                               ptpMode_oid,
                               OID_LENGTH(ptpMode_oid),
                               HANDLER_CAN_RWRITE));
}

void init_ptpDomainNumber(void)
{
    oid ptpDomainNumber_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,70,4,0 };

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("ptpDomainNumber",
                               do_ptpDomainNumber,
                               ptpDomainNumber_oid,
                               OID_LENGTH(ptpDomainNumber_oid),
                               HANDLER_CAN_RWRITE));
}

void init_ptpPriority1(void)
{
    oid ptpPriority1_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,70,2,0 };

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("ptpPriority1",
                               do_ptpPriority1,
                               ptpPriority1_oid,
                               OID_LENGTH(ptpPriority1_oid),
                               HANDLER_CAN_RWRITE));
}

void init_ptpPriority2(void)
{
    oid ptpPriority2_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,70,3,0 };

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("ptpPriority2",
                               do_ptpPriority2,
                               ptpPriority2_oid,
                               OID_LENGTH(ptpPriority2_oid),
                               HANDLER_CAN_RWRITE));
}



/* variable3 ptpPortTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */
struct variable3 ptpPortTable_variables[] =
{
/* magic number, variable type, ro/rw, callback fn, L, oidsuffix
 */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_ptpPortIfindex, ASN_INTEGER, RONLY, var_ptpPortTable, 3, { 5, 1, 1 }},
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

    { LEAF_ptpPortDelayMechanism, ASN_INTEGER, RWRITE, var_ptpPortTable, 3, { 5, 1, 2 }},
    { LEAF_ptpPortTransport, ASN_INTEGER, RWRITE, var_ptpPortTable, 3, { 5, 1, 3 }},
    { LEAF_ptpPortLogAnnouceInterval, ASN_INTEGER, RWRITE, var_ptpPortTable, 3, { 5, 1, 4 }},
    { LEAF_ptpPortAnnounceReceiptTimeout, ASN_INTEGER, RWRITE, var_ptpPortTable, 3, { 5, 1, 5 }},
    { LEAF_ptpPortLogSyncInterval, ASN_INTEGER, RWRITE, var_ptpPortTable, 3, { 5, 1, 6 }},
    { LEAF_ptpPortLogMinPdelayReqInterval, ASN_INTEGER, RWRITE, var_ptpPortTable, 3, { 5, 1, 7 }},
    { LEAF_ptpPortLogMinDelayReqInterval, ASN_INTEGER, RWRITE, var_ptpPortTable, 3, { 5, 1, 8 }},
    { LEAF_ptpPortEnable, ASN_INTEGER, RWRITE, var_ptpPortTable, 3, { 5, 1, 9 }},
    { LEAF_ptpPortRelease, ASN_INTEGER, RWRITE, var_ptpPortTable, 3, { 5, 1, 10 }}
};

void init_ptpPortTable(void)
{
    oid ptpPortTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,70 };

    REGISTER_MIB("ptpPortTable", ptpPortTable_variables, variable3,
                 ptpPortTable_variables_oid);
}

/* variable3 ptpDefaultDSTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */
struct variable3 ptpDefaultDSTable_variables[] =
{
/* magic number, variable type, ro/rw, callback fn, L, oidsuffix
 */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_ptpDefaultDsIndex, ASN_INTEGER, RONLY, var_ptpDefaultDSTable, 3, { 6, 1, 1 }},
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

    { LEAF_ptpDefaultDSTwoStepFlag, ASN_INTEGER, RONLY, var_ptpDefaultDSTable, 3, { 6, 1, 2 }},
    { LEAF_ptpDefaultDSClockIdentity, ASN_OCTET_STR, RONLY, var_ptpDefaultDSTable, 3, { 6, 1, 3 }},
    { LEAF_ptpDefaultDSNumberPorts, ASN_INTEGER, RONLY, var_ptpDefaultDSTable, 3, { 6, 1, 4 }},
    { LEAF_ptpDefaultDSClockClass, ASN_INTEGER, RONLY, var_ptpDefaultDSTable, 3, { 6, 1, 5 }},
    { LEAF_ptpDefaultDSClockAccuracy, ASN_INTEGER, RONLY, var_ptpDefaultDSTable, 3, { 6, 1, 6 }},
    { LEAF_ptpDefaultDSOffsetScaledLogVariance, ASN_INTEGER, RONLY, var_ptpDefaultDSTable, 3, { 6, 1, 7 }},
    { LEAF_ptpDefaultDSSlaveOnly, ASN_INTEGER, RONLY, var_ptpDefaultDSTable, 3, { 6, 1, 8 }},
    { LEAF_ptpDefaultDSDelayMechanism, ASN_INTEGER, RONLY, var_ptpDefaultDSTable, 3, { 6, 1, 9 }},
};


void init_ptpDefaultDSTable(void)
{
    oid ptpDefaultDSTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,70 };
    REGISTER_MIB("ptpDefaultDSTable", ptpDefaultDSTable_variables, variable3,
                 ptpDefaultDSTable_variables_oid);
}



/* variable3 ptpCurrentDSTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */
struct variable3 ptpCurrentDSTable_variables[] =
{
/* magic number, variable type, ro/rw, callback fn, L, oidsuffix
 */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_ptpCurrentDSIndex, ASN_INTEGER, RONLY, var_ptpCurrentDSTable, 3, { 7, 1, 1 }},
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

    { LEAF_ptpCurrentDSOffsetFromMaster, ASN_OCTET_STR, RONLY, var_ptpCurrentDSTable, 3, { 7, 1, 2 }},
    { LEAF_ptpCurrentDSStepsRemoved, ASN_INTEGER, RONLY, var_ptpCurrentDSTable, 3, { 7, 1, 3 }},
};

void init_ptpCurrentDSTable(void)
{
    oid ptpCurrentDSTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,70 };

    REGISTER_MIB("ptpCurrentDSTable", ptpCurrentDSTable_variables, variable3,
                 ptpCurrentDSTable_variables_oid);
}



/* variable3 ptpParentDSTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */
struct variable3 ptpParentDSTable_variables[] =
{
/* magic number, variable type, ro/rw, callback fn, L, oidsuffix
 */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_ptpParentDSIndex, ASN_INTEGER, RONLY, var_ptpParentDSTable, 3, { 8, 1, 1 }},
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

    { LEAF_ptpParentDSClockIdentify, ASN_OCTET_STR, RONLY, var_ptpParentDSTable, 3, { 8, 1, 2 }},
    { LEAF_ptpParentDSPortNumber, ASN_INTEGER, RONLY, var_ptpParentDSTable, 3, { 8, 1, 3 }},
    { LEAF_ptpParentDSGrandMasterIdentity, ASN_OCTET_STR, RONLY, var_ptpParentDSTable, 3, { 8, 1, 4 }},
    { LEAF_ptpParentDSGrandMasterClockClass, ASN_INTEGER, RONLY, var_ptpParentDSTable, 3, { 8, 1, 5 }},
    { LEAF_ptpParentDSGrandMasterClockAccuracy, ASN_INTEGER, RONLY, var_ptpParentDSTable, 3, { 8, 1, 6 }},
    { LEAF_ptpParentDSGrandMasterOffsetScaledLogVariance, ASN_INTEGER, RONLY, var_ptpParentDSTable, 3, { 8, 1, 7 }},
    { LEAF_ptpParentDSObservedParentClockPhaseChangeRate, ASN_INTEGER, RONLY, var_ptpParentDSTable, 3, { 8, 1, 8 }},
    { LEAF_ptpParentDSObservedParentOffsetScaledLogVariance, ASN_INTEGER, RONLY, var_ptpParentDSTable, 3, { 8, 1, 9 }},
    { LEAF_ptpParentDSGrandmasterPriority1, ASN_INTEGER, RONLY, var_ptpParentDSTable, 3, { 8, 1, 10 }},
    { LEAF_ptpParentDSGrandmasterPriority2, ASN_INTEGER, RONLY, var_ptpParentDSTable, 3, { 8, 1, 11 }},
    { LEAF_ptpParentDSParentStats, ASN_INTEGER, RONLY, var_ptpParentDSTable, 3, { 8, 1, 12 }},
};

void init_ptpParentDSTable(void)
{
    oid ptpParentDSTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,70 };
    REGISTER_MIB("ptpParentDSTable", ptpParentDSTable_variables, variable3,
                 ptpParentDSTable_variables_oid);
}

/* variable3 ptpTimePropertiesDSTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */
struct variable3 ptpTimePropertiesDSTable_variables[] =
{
/* magic number, variable type, ro/rw, callback fn, L, oidsuffix
 */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_ptpTimeProperTiesDSIndex, ASN_INTEGER, RONLY, var_ptpTimePropertiesDSTable, 3, { 9, 1, 1 }},
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

    { LEAF_ptpTimeProperTiesDSCurrentUTCOffset, ASN_INTEGER, RONLY, var_ptpTimePropertiesDSTable, 3, { 9, 1, 2 }},
    { LEAF_ptpTimeProperTiesDScurrentUTCOffsetValid, ASN_INTEGER, RONLY, var_ptpTimePropertiesDSTable, 3, { 9, 1, 3 }},
    { LEAF_ptpTimeProperTiesDSLeap59, ASN_INTEGER, RONLY, var_ptpTimePropertiesDSTable, 3, { 9, 1, 4 }},
    { LEAF_ptpTimeProperTiesDSLeap61, ASN_INTEGER, RONLY, var_ptpTimePropertiesDSTable, 3, { 9, 1, 5 }},
    { LEAF_ptpTimeProperTiesDSTimeTraceable, ASN_INTEGER, RONLY, var_ptpTimePropertiesDSTable, 3, { 9, 1, 6 }},
    { LEAF_ptpTimeProperTiesDSFrequencyTraceable, ASN_INTEGER, RONLY, var_ptpTimePropertiesDSTable, 3, { 9, 1, 7 }},
    { LEAF_ptpTimeProperTiesDSPtpTimescale, ASN_INTEGER, RONLY, var_ptpTimePropertiesDSTable, 3, { 9, 1, 8 }},
    { LEAF_ptpTimeProperTiesDSTimeSource, ASN_INTEGER, RONLY, var_ptpTimePropertiesDSTable, 3, { 9, 1, 9 }},
};

void init_ptpTimePropertiesDSTable(void)
{
    oid ptpTimePropertiesDSTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,70 };

    REGISTER_MIB("ptpTimePropertiesDSTable", ptpTimePropertiesDSTable_variables, variable3,
                 ptpTimePropertiesDSTable_variables_oid);
}


/* variable3 ptpPortDSTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */
struct variable3 ptpPortDSTable_variables[] =
{
/* magic number, variable type, ro/rw, callback fn, L, oidsuffix
 */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_ptpPortDSPortNumber, ASN_INTEGER, RONLY, var_ptpPortDSTable, 3, { 10, 1, 1 }},
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

    { LEAF_ptpPortDSClockIdentity, ASN_OCTET_STR, RONLY, var_ptpPortDSTable, 3, { 10, 1, 2 }},
    { LEAF_ptpPortDSPeerMeanPathDelay, ASN_OCTET_STR, RONLY, var_ptpPortDSTable, 3, { 10, 1, 3 }},
    { LEAF_ptpPortDSPortState, ASN_INTEGER, RONLY, var_ptpPortDSTable, 3, { 10, 1, 4 }},
};

void init_ptpPortDSTable(void)
{
    oid ptpPortDSTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,70 };

    REGISTER_MIB("ptpPortDSTable", ptpPortDSTable_variables, variable3,
                 ptpPortDSTable_variables_oid);
}



/* variable3 ptpTransparentClockDefaultDSTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */
struct variable3 ptpTransparentClockDefaultDSTable_variables[] =
{
/* magic number, variable type, ro/rw, callback fn, L, oidsuffix
 */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_ptpTransparentClockDefaultDSIndex, ASN_INTEGER, RONLY, var_ptpTransparentClockDefaultDSTable, 3, { 11, 1, 1 }},
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

    { LEAF_ptpTransparentClockDefaultDSClockIdentity, ASN_OCTET_STR, RONLY, var_ptpTransparentClockDefaultDSTable, 3, { 11, 1, 2 }},
    { LEAF_ptpTransparentClockDefaultDSNumberfPorts, ASN_INTEGER, RONLY, var_ptpTransparentClockDefaultDSTable, 3, { 11, 1, 3 }},
    { LEAF_ptpTransparentClockDefaultDSDelayMechanism, ASN_INTEGER, RONLY, var_ptpTransparentClockDefaultDSTable, 3, { 11, 1, 4 }},
    { LEAF_ptpTransparentClockDefaultDSPrimaryDomain, ASN_INTEGER, RONLY, var_ptpTransparentClockDefaultDSTable, 3, { 11, 1, 5 }},
};

void init_ptpTransparentClockDefaultDSTable(void)
{
    oid ptpTransparentClockDefaultDSTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,70 };

    REGISTER_MIB("ptpTransparentClockDefaultDSTable", ptpTransparentClockDefaultDSTable_variables, variable3,
                 ptpTransparentClockDefaultDSTable_variables_oid);
}

/* variable3 ptpTranaparentClockPortDSTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */
struct variable3 ptpTranaparentClockPortDSTable_variables[] =
{
/* magic number, variable type, ro/rw, callback fn, L, oidsuffix
 */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_ptpTransparentClockPortDSPortNumber, ASN_INTEGER, RONLY, var_ptpTranaparentClockPortDSTable, 3, { 12, 1, 1 }},
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

    { LEAF_ptpTransparentClockPortDSLogMinPdelayReqInterval, ASN_INTEGER, RONLY, var_ptpTranaparentClockPortDSTable, 3, { 12, 1, 2 }},
    { LEAF_ptpTransparentClockPortDSFultyFlag, ASN_INTEGER, RONLY, var_ptpTranaparentClockPortDSTable, 3, { 12, 1, 3 }},
    { LEAF_ptpTransparentClockPortDSPeerMeanPathDelay, ASN_OCTET_STR, RONLY, var_ptpTranaparentClockPortDSTable, 3, { 12, 1, 4 }},
};

void init_ptpTranaparentClockPortDSTable(void)
{
    oid ptpTranaparentClockPortDSTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,70 };

    REGISTER_MIB("ptpTranaparentClockPortDSTable", ptpTranaparentClockPortDSTable_variables, variable3,
                 ptpTranaparentClockPortDSTable_variables_oid);
}
#if(SYS_CPNT_PTP_IN_E_GRESS_LATENCY == TRUE)
void init_ptpIngressLatency(void)
{
    oid ptpIngressLatency_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,70,13, 0 };

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("ptpIngressLatency",
                               do_ptpIngressLatency,
                               ptpIngressLatency_oid,
                               OID_LENGTH(ptpIngressLatency_oid),
                               HANDLER_CAN_RWRITE));
}
void init_ptpEgressLatency(void)
{
    oid ptpEgressLatency_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,70,14, 0 };

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("ptpEgressLatency",
                               do_ptpEgressLatency,
                               ptpEgressLatency_oid,
                               OID_LENGTH(ptpEgressLatency_oid),
                               HANDLER_CAN_RWRITE));
}
#endif /*#if(SYS_CPNT_PTP_IN_E_GRESS_LATENCY == TRUE)*/
#endif /*#if (SYS_CPNT_PTP == TRUE)*/

#if(SYS_CPNT_SYNCE == TRUE)


void init_syncEStatus(void)
{
    oid syncEStatus_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,72,1, 0 };

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("syncEStatus",
                               do_syncEStatus,
                               syncEStatus_oid,
                               OID_LENGTH(syncEStatus_oid),
                               HANDLER_CAN_RWRITE));
}


void init_syncESsmStatus(void)
{
    oid syncESsmStatus_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,72,2, 0 };

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("syncESsmStatus",
                               do_syncESsmStatus,
                               syncESsmStatus_oid,
                               OID_LENGTH(syncESsmStatus_oid),
                               HANDLER_CAN_RWRITE));
}

void init_syncEClockSourcePort(void)
{
    oid syncEClockSourcePort_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,72,3, 0 };

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("syncEClockSourcePort",
                               do_syncEClockSourcePort,
                               syncEClockSourcePort_oid,
                               OID_LENGTH(syncEClockSourcePort_oid),
                               HANDLER_CAN_RWRITE));
}

void init_syncEGoodClockSource(void)
{
    oid syncEGoodClockSource_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,72,4, 0 };

    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("syncEGoodClockSource",
                                         get_syncEGoodClockSource,
                                         syncEGoodClockSource_oid,
                                         OID_LENGTH(syncEGoodClockSource_oid),
                                         HANDLER_CAN_RONLY));
}

void init_syncEClockSourceSelect(void)
{
    static oid syncEClockSourceSelect_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,72,5, 0 };

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("syncEClockSourceSelect",
                               do_syncEClockSourceSelect,
                               syncEClockSourceSelect_oid,
                               OID_LENGTH(syncEClockSourceSelect_oid),
                               HANDLER_CAN_RWRITE));
}

void init_syncEAutoClockSourceRevertive(void)
{
    oid syncEAutoClockSourceRevertive_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,72,6, 0 };

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("syncEAutoClockSourceRevertive",
                               do_syncEAutoClockSourceRevertive,
                               syncEAutoClockSourceRevertive_oid,
                               OID_LENGTH(syncEAutoClockSourceRevertive_oid),
                               HANDLER_CAN_RWRITE));
}

void init_syncEClockSourceLocked(void)
{
    static oid syncEClockSourceLocked_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,72,7, 0 };

    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("syncEClockSourceLocked",
                                         get_syncEClockSourceLocked,
                                         syncEClockSourceLocked_oid,
                                         OID_LENGTH(syncEClockSourceLocked_oid),
                                         HANDLER_CAN_RONLY));
}
/* variable3 syncEPortTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */
struct variable3 syncEPortTable_variables[] =
{
    /* magic number, variable type, ro/rw, callback fn, L, oidsuffix
     *     (L = length of the oidsuffix)
     */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_syncEPortIndex, ASN_INTEGER, RONLY, var_syncEPortTable, 3, { 9, 1, 1 }},
#endif  /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

    { LEAF_syncEPortStatus, ASN_INTEGER, RWRITE, var_syncEPortTable, 3, { 9, 1, 2 }},
    { LEAF_syncEPortSSMStatus, ASN_INTEGER, RWRITE, var_syncEPortTable, 3, { 9, 1, 3 }},
    { LEAF_syncEPortSSMPriority, ASN_INTEGER, RWRITE, var_syncEPortTable, 3, { 9, 1, 4 }},
    { LEAF_syncEPortTxQL, ASN_INTEGER, RONLY, var_syncEPortTable, 3, { 9, 1, 5 }},
    { LEAF_syncEPortRxQL, ASN_INTEGER, RONLY, var_syncEPortTable, 3, { 9, 1, 6 }},
    { LEAF_syncEPortForceClockSourceSelect, ASN_INTEGER, RWRITE, var_syncEPortTable, 3, { 9, 1, 7 }},
};

void init_syncEPortTable(void)
{
    oid syncEPortTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID, 1,72 };

    /* Register ourselves with the agent to handle our MIB tree
     */
    REGISTER_MIB("syncEPortTable", syncEPortTable_variables, variable3,
                 syncEPortTable_variables_oid);
}

#endif /*End of #if(SYS_CPNT_SYNCE == TRUE)*/

#if (SYS_CPNT_DHCPV6SNP == TRUE)
void init_dhcpv6SnoopGlobal(void)
{
    static oid dhcpv6SnoopEnable_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,71,1,1,0 };
    static oid dhcpv6SnoopBindingTableClearAction_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,71,1,2,0 };
    static oid dhcpv6SnoopStatisticsClearAction_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,71,1,3,0 };
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("dhcpv6SnoopEnable",
                               do_dhcpv6SnoopEnable,
                               dhcpv6SnoopEnable_oid,
                               OID_LENGTH(dhcpv6SnoopEnable_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("dhcpv6SnoopBindingTableClearAction",
                               do_dhcpv6SnoopBindingTableClearAction,
                               dhcpv6SnoopBindingTableClearAction_oid,
                               OID_LENGTH(dhcpv6SnoopBindingTableClearAction_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("dhcpv6SnoopStatisticsClearAction",
                               do_dhcpv6SnoopStatisticsClearAction,
                               dhcpv6SnoopStatisticsClearAction_oid,
                               OID_LENGTH(dhcpv6SnoopStatisticsClearAction_oid),
                               HANDLER_CAN_RWRITE));
}

struct variable3 dhcpv6SnoopVlanConfigTable_variables[] =
{

#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_dhcpv6SnoopVlanIndex, ASN_UNSIGNED, RONLY, var_dhcpv6SnoopVlanConfigTable, 3, { 1, 1, 1 }},
#endif  /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

    { LEAF_dhcpv6SnoopVlanEnable, ASN_INTEGER, RWRITE, var_dhcpv6SnoopVlanConfigTable, 3, { 1, 1, 2 }},
};

void init_dhcpv6SnoopVlanConfigTable(void)
{
    static oid dhcpv6SnoopVlanConfigTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,71,2 };
    /* Register ourselves with the agent to handle our MIB tree
     */
    REGISTER_MIB("dhcpv6SnoopVlanConfigTable", dhcpv6SnoopVlanConfigTable_variables, variable3,
                 dhcpv6SnoopVlanConfigTable_variables_oid);
}


struct variable3 dhcpv6SnoopBindingTable_variables[] =
{

#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_dhcpv6SnoopBindingLinkLayerAddress, ASN_OCTET_STR, RONLY, var_dhcpv6SnoopBindingTable, 3, { 1, 1, 1 }},
#endif  /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_dhcpv6SnoopBindingIaType, ASN_INTEGER, RONLY, var_dhcpv6SnoopBindingTable, 3, { 1, 1, 2 }},
#endif  /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_dhcpv6SnoopBindingIaId, ASN_UNSIGNED, RONLY, var_dhcpv6SnoopBindingTable, 3, { 1, 1, 3 }},
#endif  /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_dhcpv6SnoopBindingIpv6Address, ASN_OCTET_STR, RONLY, var_dhcpv6SnoopBindingTable, 3, { 1, 1, 4 }},
#endif  /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

    { LEAF_dhcpv6SnoopBindingVlanIndex, ASN_UNSIGNED, RONLY, var_dhcpv6SnoopBindingTable, 3, { 1, 1, 5 }},
    { LEAF_dhcpv6SnoopBindingPortIfIndex, ASN_INTEGER, RONLY, var_dhcpv6SnoopBindingTable, 3, { 1, 1, 6 }},
    { LEAF_dhcpv6SnoopBindingLifeTime, ASN_UNSIGNED, RONLY, var_dhcpv6SnoopBindingTable, 3, { 1, 1, 7 }},
};


struct variable3 dhcpv6SnoopPortConfigTable_variables[] =
{

#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_dhcpv6SnoopPortIfIndex, ASN_INTEGER, RONLY, var_dhcpv6SnoopPortConfigTable, 3, { 1, 1, 1 }},
#endif  /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

    { LEAF_dhcpv6SnoopPortTrustEnable, ASN_INTEGER, RWRITE, var_dhcpv6SnoopPortConfigTable, 3, { 1, 1, 2 }},
    { LEAF_dhcpv6SnoopPortMaxBinding, ASN_INTEGER, RWRITE, var_dhcpv6SnoopPortConfigTable, 3, { 1, 1, 3 }},
    { LEAF_dhcpv6SnoopPortCurrentBinding, ASN_INTEGER, RONLY, var_dhcpv6SnoopPortConfigTable, 3, { 1, 1, 4 }},
};

void init_dhcpv6SnoopPortConfigTable(void)
{
    static oid dhcpv6SnoopPortConfigTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,71,3 };
    /* Register ourselves with the agent to handle our MIB tree
     */
    REGISTER_MIB("dhcpv6SnoopPortConfigTable", dhcpv6SnoopPortConfigTable_variables, variable3,
                 dhcpv6SnoopPortConfigTable_variables_oid);
}


void init_dhcpv6SnoopBindingTable(void)
{

    static oid dhcpv6SnoopBindingTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,71,4 };
    /* Register ourselves with the agent to handle our MIB tree
     */
    REGISTER_MIB("dhcpv6SnoopBindingTable", dhcpv6SnoopBindingTable_variables, variable3,
                 dhcpv6SnoopBindingTable_variables_oid);
}

void init_dhcpv6SnoopStatistics(void)
{
    static oid dhcpSnoopRecvClientPkts_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,71,5,1,0 };
    static oid dhcpSnoopSentClientPkts_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,71,5,2,0 };
    static oid dhcpSnoopDroppedClientPkts_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,71,5,3,0 };
    static oid dhcpSnoopRecvServerPkts_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,71,5,4,0 };
    static oid dhcpSnoopSentServerPkts_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,71,5,5,0 };
    static oid dhcpSnoopDroppedServerPkts_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,71,5,6,0 };
    static oid dhcpSnoopRecvRelayPkts_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,71,5,7,0 };
    static oid dhcpSnoopSentRelayPkts_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,71,5,8,0 };
    static oid dhcpSnoopDroppedRelayPkts_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,71,5,9,0 };

    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("dhcpSnoopRecvClientPkts",
                                         get_dhcpSnoopRecvClientPkts,
                                         dhcpSnoopRecvClientPkts_oid,
                                         OID_LENGTH(dhcpSnoopRecvClientPkts_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("dhcpSnoopSentClientPkts",
                                         get_dhcpSnoopSentClientPkts,
                                         dhcpSnoopSentClientPkts_oid,
                                         OID_LENGTH(dhcpSnoopSentClientPkts_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("dhcpSnoopDroppedClientPkts",
                                         get_dhcpSnoopDroppedClientPkts,
                                         dhcpSnoopDroppedClientPkts_oid,
                                         OID_LENGTH(dhcpSnoopDroppedClientPkts_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("dhcpSnoopRecvServerPkts",
                                         get_dhcpSnoopRecvServerPkts,
                                         dhcpSnoopRecvServerPkts_oid,
                                         OID_LENGTH(dhcpSnoopRecvServerPkts_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("dhcpSnoopSentServerPkts",
                                         get_dhcpSnoopSentServerPkts,
                                         dhcpSnoopSentServerPkts_oid,
                                         OID_LENGTH(dhcpSnoopSentServerPkts_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("dhcpSnoopDroppedServerPkts",
                                         get_dhcpSnoopDroppedServerPkts,
                                         dhcpSnoopDroppedServerPkts_oid,
                                         OID_LENGTH(dhcpSnoopDroppedServerPkts_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("dhcpSnoopRecvRelayPkts",
                                         get_dhcpSnoopRecvRelayPkts,
                                         dhcpSnoopRecvRelayPkts_oid,
                                         OID_LENGTH(dhcpSnoopRecvRelayPkts_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("dhcpSnoopSentRelayPkts",
                                         get_dhcpSnoopSentRelayPkts,
                                         dhcpSnoopSentRelayPkts_oid,
                                         OID_LENGTH(dhcpSnoopSentRelayPkts_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("dhcpSnoopDroppedRelayPkts",
                                         get_dhcpSnoopDroppedRelayPkts,
                                         dhcpSnoopDroppedRelayPkts_oid,
                                         OID_LENGTH(dhcpSnoopDroppedRelayPkts_oid),
                                         HANDLER_CAN_RONLY));


}

#endif /* end of #if (SYS_CPNT_DHCPV6SNP == TRUE)*/


#if (SYS_CPNT_IPV6_SOURCE_GUARD == TRUE)
/* variable3 ip6SrcGuardConfigTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */
struct variable3 ip6SrcGuardConfigTable_variables[] =
{
/* magic number, variable type, ro/rw, callback fn, L, oidsuffix
 */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_ip6SrcGuardPortIfIndex, ASN_INTEGER, RONLY, var_ip6SrcGuardConfigTable, 3, { 1, 1, 1 }},
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

    { LEAF_ip6SrcGuardMode, ASN_INTEGER, RWRITE, var_ip6SrcGuardConfigTable, 3, { 1, 1, 2 }},
    { LEAF_ip6SrcGuardMaxBinding, ASN_INTEGER, RWRITE, var_ip6SrcGuardConfigTable, 3, { 1, 1, 3 }},
};

void init_ip6SrcGuardConfigTable(void)
{
    static oid ip6SrcGuardConfigTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,74};
    REGISTER_MIB("ip6SrcGuardConfigTable", ip6SrcGuardConfigTable_variables, variable3,
                 ip6SrcGuardConfigTable_variables_oid);
}

/* variable3 ip6SrcGuardAddrTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */
struct variable3 ip6SrcGuardAddrTable_variables[] =
{
/* magic number, variable type, ro/rw, callback fn, L, oidsuffix
 */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_ip6SrcGuardBindingType, ASN_INTEGER, RONLY, var_ip6SrcGuardAddrTable, 3, { 2, 1, 1 }},
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_ip6SrcGuardBindingMacAddress, ASN_OCTET_STR, RONLY, var_ip6SrcGuardAddrTable, 3, { 2, 1, 2 }},
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_ip6SrcGuardBindingIpv6Address, ASN_OCTET_STR, RONLY, var_ip6SrcGuardAddrTable, 3, { 2, 1, 3 }},
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

    { LEAF_ip6SrcGuardBindingVlanIndex, ASN_UNSIGNED, RWRITE, var_ip6SrcGuardAddrTable, 3, { 2, 1, 4 }},
    { LEAF_ip6SrcGuardBindingPortIfIndex, ASN_INTEGER, RWRITE, var_ip6SrcGuardAddrTable, 3, { 2, 1, 5 }},
    { LEAF_ip6SrcGuardBindingStatus, ASN_INTEGER, RWRITE, var_ip6SrcGuardAddrTable, 3, { 2, 1, 6 }},
};

void init_ip6SrcGuardAddrTable(void)
{
    static oid ip6SrcGuardAddrTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,74};
    REGISTER_MIB("ip6SrcGuardAddrTable", ip6SrcGuardAddrTable_variables, variable3,
                 ip6SrcGuardAddrTable_variables_oid);
}
#endif /* end of #if(SYS_CPNT_IPV6_SOURCE_GUARD == TRUE)*/

#if (SYS_CPNT_CN == TRUE)
void init_cnGlobal(void)
{
    oid cnGlobalAdminStatus_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,75,1,1,0 };
    oid cnGlobalOperStatus_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,75,1,2,0 };
    oid cnCnmTransmitPriority_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,75,1,3,0 };
    oid cnDiscardedFrames_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,75,1,4,0 };

    DEBUGMSGTL(("cnGlobal", "Initializing\n"));

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("cnGlobalAdminStatus",
                               do_cnGlobalAdminStatus,
                               cnGlobalAdminStatus_oid,
                               OID_LENGTH(cnGlobalAdminStatus_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("cnGlobalOperStatus",
                               get_cnGlobalOperStatus,
                               cnGlobalOperStatus_oid,
                               OID_LENGTH(cnGlobalOperStatus_oid),
                               HANDLER_CAN_RONLY));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("cnCnmTransmitPriority",
                               do_cnCnmTransmitPriority,
                               cnCnmTransmitPriority_oid,
                               OID_LENGTH(cnCnmTransmitPriority_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("cnDiscardedFrames",
                               get_cnDiscardedFrames,
                               cnDiscardedFrames_oid,
                               OID_LENGTH(cnDiscardedFrames_oid),
                               HANDLER_CAN_RONLY));
}

struct variable3 cnPriTable_variables[] =
{
/* magic number, variable type, ro/rw, callback fn, L, oidsuffix */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_cnPriPriority, ASN_UNSIGNED, RONLY, var_cnPriTable, 3, {2,1,1} },
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */
    { LEAF_cnPriDefenseMode, ASN_INTEGER, RWRITE, var_cnPriTable, 3, {2,1,2} },
    { LEAF_cnPriAdminAlternatePriority, ASN_UNSIGNED, RWRITE, var_cnPriTable, 3, {2,1,3} },
    { LEAF_cnPriAutoAlternatePriority, ASN_UNSIGNED, RONLY, var_cnPriTable, 3, {2,1,4} },
    { LEAF_cnPriRowStatus, ASN_INTEGER, RWRITE, var_cnPriTable, 3, {2,1,5} },
};

void init_cnPriTable(void)
{
    oid cnPriTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,75 };

    REGISTER_MIB("cnPriTable", cnPriTable_variables, variable3,
                 cnPriTable_variables_oid);
}

struct variable3 cnPortPriTable_variables[] =
{
/* magic number, variable type, ro/rw, callback fn, L, oidsuffix */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_cnPortPriPriority, ASN_UNSIGNED, RONLY, var_cnPortPriTable, 3, {3,1,1} },
    { LEAF_cnPortPriIfIndex, ASN_INTEGER, RONLY, var_cnPortPriTable, 3, {3,1,2} },
#endif
    { LEAF_cnPortPriAdminDefenseMode, ASN_INTEGER, RWRITE, var_cnPortPriTable, 3, {3,1,3} },
    { LEAF_cnPortPriOperDefenseMode, ASN_INTEGER, RONLY, var_cnPortPriTable, 3, {3,1,4} },
    { LEAF_cnPortPriAdminAlternatePriority, ASN_UNSIGNED, RWRITE, var_cnPortPriTable, 3, {3,1,5} },
    { LEAF_cnPortPriOperAlternatePriority, ASN_UNSIGNED, RONLY, var_cnPortPriTable, 3, {3,1,6} },
};

void init_cnPortPriTable(void)
{
    oid cnPortPriTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,75 };

    REGISTER_MIB("cnPortPriTable", cnPortPriTable_variables, variable3,
                 cnPortPriTable_variables_oid);
}

struct variable3 cnCpTable_variables[] =
{
/* magic number, variable type, ro/rw, callback fn, L, oidsuffix */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_cnCpIfIndex, ASN_INTEGER, RONLY, var_cnCpTable, 3, {4,1,1} },
    { LEAF_cnCpIndex, ASN_UNSIGNED, RONLY, var_cnCpTable, 3, {4,1,2} },
#endif
    { LEAF_cnCpIdentifier, ASN_OCTET_STR, RONLY, var_cnCpTable, 3, {4,1,3} },
    { LEAF_cnCpQueue, ASN_UNSIGNED, RONLY, var_cnCpTable, 3, {4,1,4} },
    { LEAF_cnCpManagedCnpvs, ASN_OCTET_STR, RONLY, var_cnCpTable, 3, {4,1,5} },
    { LEAF_cnCpMacAddress, ASN_OCTET_STR, RONLY, var_cnCpTable, 3, {4,1,6} },
    { LEAF_cnCpSetPoint, ASN_UNSIGNED, RONLY, var_cnCpTable, 3, {4,1,7} },
    { LEAF_cnCpFeedbackWeight, ASN_UNSIGNED, RONLY, var_cnCpTable, 3, {4,1,8} },
    { LEAF_cnCpMinSampleBase, ASN_UNSIGNED, RONLY, var_cnCpTable, 3, {4,1,9} },
    { LEAF_cnCpDiscardedFrames, ASN_COUNTER64, RONLY, var_cnCpTable, 3, {4,1,10} },
    { LEAF_cnCpTransmittedFrames, ASN_COUNTER64, RONLY, var_cnCpTable, 3, {4,1,11} },
    { LEAF_cnCpTransmittedCnms, ASN_COUNTER64, RONLY, var_cnCpTable, 3, {4,1,12} },
};

void init_cnCpTable(void)
{
    oid cnCpTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,75 };

    REGISTER_MIB("cnCpTable", cnCpTable_variables, variable3,
                 cnCpTable_variables_oid);
}
#endif /* #if (SYS_CPNT_CN == TRUE) */

#if (SYS_CPNT_DCBX == TRUE)
struct variable3 dcbxPortTable_variables[] =
{
/* magic number, variable type, ro/rw, callback fn, L, oidsuffix */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_dcbxPortIfIndex, ASN_INTEGER, RONLY, var_dcbxPortTable, 3, {1,1,1} },
#endif
    { LEAF_dcbxPortStatus, ASN_INTEGER, RWRITE, var_dcbxPortTable, 3, {1,1,2} },
    { LEAF_dcbxPortMode, ASN_INTEGER, RWRITE, var_dcbxPortTable, 3, {1,1,3} },
};

void init_dcbxPortTable(void)
{
    oid dcbxPortTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,76 };

    REGISTER_MIB("dcbxPortTable", dcbxPortTable_variables, variable3,
                 dcbxPortTable_variables_oid);
}
#endif /* #if (SYS_CPNT_DCBX == TRUE) */

#if (SYS_CPNT_LBD == TRUE)
void init_lbdGlobal(void)
{
    oid lbdGlobalStatus_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,63,1,1,0 };
    oid lbdTransmitInterval_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,63,1,2,0 };
    oid lbdRecoverTime_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,63,1,3,0 };
    oid lbdAction_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,63,1,5,0 };
    oid lbdTrap_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,63,1,6,0 };

    DEBUGMSGTL(("lbdGlobal", "Initializing\n"));

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("lbdGlobalStatus",
                               do_lbdGlobalStatus,
                               lbdGlobalStatus_oid,
                               OID_LENGTH(lbdGlobalStatus_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("lbdTransmitInterval",
                               do_lbdTransmitInterval,
                               lbdTransmitInterval_oid,
                               OID_LENGTH(lbdTransmitInterval_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("lbdRecoverTime",
                               do_lbdRecoverTime,
                               lbdRecoverTime_oid,
                               OID_LENGTH(lbdRecoverTime_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("lbdAction",
                               do_lbdAction,
                               lbdAction_oid,
                               OID_LENGTH(lbdAction_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("lbdTrap",
                               do_lbdTrap,
                               lbdTrap_oid,
                               OID_LENGTH(lbdTrap_oid),
                               HANDLER_CAN_RWRITE));
}

struct variable3 lbdPortTable_variables[] =
{
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_lbdPortIfIndex, ASN_INTEGER, RONLY, var_lbdPortTable, 3, { 1, 1, 1 }},
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

    { LEAF_lbdPortAdminState, ASN_INTEGER, RWRITE, var_lbdPortTable, 3, { 1, 1, 2 }},
    { LEAF_lbdPortOperState, ASN_INTEGER, RONLY, var_lbdPortTable, 3, { 1, 1, 3 }},
    { LEAF_lbdPortLoopedVlan, ASN_OCTET_STR, RONLY, var_lbdPortTable, 3, { 1, 1, 4 }},
};

void init_lbdPortTable(void)
{
    oid lbdPortTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,63,2 };

    REGISTER_MIB("lbdPortTable", lbdPortTable_variables, variable3,
                 lbdPortTable_variables_oid);
}
#endif /* #if (SYS_CPNT_LBD == TRUE) */

#if (SYS_CPNT_VXLAN == TRUE)
void init_vxlanUdpDstPort(void)
{
    static oid vxlanUdpDstPort_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,82,1,0 };

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("vxlanUdpDstPort",
                               do_vxlanUdpDstPort,
                               vxlanUdpDstPort_oid,
                               OID_LENGTH(vxlanUdpDstPort_oid),
                               HANDLER_CAN_RWRITE));
}

struct variable3 vxlanFloodTable_variables[] =
{
/* magic number, variable type, ro/rw, callback fn, L, oidsuffix
 */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_vxlanFloodVniIndex, ASN_INTEGER, RONLY, var_vxlanFloodTable, 3, { 2, 1, 1 }},
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_vxlanFloodRemoteIpAddress, ASN_IPADDRESS, RONLY, var_vxlanFloodTable, 3, { 2, 1, 2 }},
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

    { LEAF_vxlanFloodSourceIpAddress, ASN_IPADDRESS, RONLY, var_vxlanFloodTable, 3, { 2, 1, 3 }},
    { LEAF_vxlanFloodVlanIndex, ASN_INTEGER, RWRITE, var_vxlanFloodTable, 3, { 2, 1, 4 }},
    { LEAF_vxlanFloodEgressPort, ASN_INTEGER, RWRITE, var_vxlanFloodTable, 3, { 2, 1, 5 }},
    { LEAF_vxlanFloodStatus, ASN_INTEGER, RWRITE, var_vxlanFloodTable, 3, { 2, 1, 6 }},

};

void init_vxlanFloodTable(void)
{
    oid vxlanFloodTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,82 };

    REGISTER_MIB("vxlanFloodTable", vxlanFloodTable_variables, variable3,
                 vxlanFloodTable_variables_oid);
}

/* variable3 vxlanVlanVniMappingTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the  mib section
 */
struct variable3 vxlanVlanVniMappingTable_variables[] =
{
/* magic number, variable type, ro/rw, callback fn, L, oidsuffix
 */
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
    { LEAF_vxlanVlanIndex, ASN_INTEGER, RONLY, var_vxlanVlanVniMappingTable, 3, { 3, 1, 1 }},
#endif /* #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1) */

    { LEAF_vxlanVniIndex, ASN_INTEGER, RWRITE, var_vxlanVlanVniMappingTable, 3, { 3, 1, 2 }},
};

void init_vxlanVlanVniMappingTable(void)
{
    oid vxlanVlanVniMappingTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,82 };

    REGISTER_MIB("vxlanVlanVniMappingTable", vxlanVlanVniMappingTable_variables, variable3,
                 vxlanVlanVniMappingTable_variables_oid);
}

#endif /* #if (SYS_CPNT_VXLAN == TRUE) */

#if (SYS_CPNT_HASH_SELECTION == TRUE)

struct variable3 hashSelMacTable_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */
    {HASHSELMACBLOCKINDEX, ASN_INTEGER, RONLY,  var_hashSelMacTable, 3, {1, 1, 1}},
    {HASHSELMACSRCMAC,     ASN_INTEGER, RWRITE, var_hashSelMacTable, 3, {1, 1, 2}},
    {HASHSELMACDSTMAC,     ASN_INTEGER, RWRITE, var_hashSelMacTable, 3, {1, 1, 3}},
    {HASHSELMACETHERTYPE,  ASN_INTEGER, RWRITE, var_hashSelMacTable, 3, {1, 1, 4}},
    {HASHSELMACVLAN,       ASN_INTEGER, RWRITE, var_hashSelMacTable, 3, {1, 1, 5}},
};

struct variable3 hashSelIpv4Table_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */
    {HASHSELIPV4BLOCKINDEX, ASN_INTEGER, RONLY,  var_hashSelIpv4Table, 3, {2, 1, 1}},
    {HASHSELIPV4SRCIP,      ASN_INTEGER, RWRITE, var_hashSelIpv4Table, 3, {2, 1, 2}},
    {HASHSELIPV4DSTIP,      ASN_INTEGER, RWRITE, var_hashSelIpv4Table, 3, {2, 1, 3}},
    {HASHSELIPV4SRCL4PORT,  ASN_INTEGER, RWRITE, var_hashSelIpv4Table, 3, {2, 1, 4}},
    {HASHSELIPV4DSTL4PORT,  ASN_INTEGER, RWRITE, var_hashSelIpv4Table, 3, {2, 1, 5}},
    {HASHSELIPV4PROTOCOLID, ASN_INTEGER, RWRITE, var_hashSelIpv4Table, 3, {2, 1, 6}},
    {HASHSELIPV4VLAN,       ASN_INTEGER, RWRITE, var_hashSelIpv4Table, 3, {2, 1, 7}},
};

struct variable3 hashSelIpv6Table_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */
    {HASHSELIPV6BLOCKINDEX, ASN_INTEGER, RONLY,  var_hashSelIpv6Table, 3, {3, 1, 1}},
    {HASHSELIPV6SRCIP,      ASN_INTEGER, RWRITE, var_hashSelIpv6Table, 3, {3, 1, 2}},
    {HASHSELIPV6DSTIP,      ASN_INTEGER, RWRITE, var_hashSelIpv6Table, 3, {3, 1, 3}},
    {HASHSELIPV6SRCL4PORT,  ASN_INTEGER, RWRITE, var_hashSelIpv6Table, 3, {3, 1, 4}},
    {HASHSELIPV6DSTL4PORT,  ASN_INTEGER, RWRITE, var_hashSelIpv6Table, 3, {3, 1, 5}},
    {HASHSELIPV6NEXTHEADER, ASN_INTEGER, RWRITE, var_hashSelIpv6Table, 3, {3, 1, 6}},
    {HASHSELIPV6VLAN,       ASN_INTEGER, RWRITE, var_hashSelIpv6Table, 3, {3, 1, 7}},
};

void init_hashSelTable(void)
{
    oid hashSelTable_variables_oid[] = { SYS_ADPT_PRIVATEMIB_OID,1,83 };

    REGISTER_MIB("hashSelMacTable", hashSelMacTable_variables, variable3,
                 hashSelTable_variables_oid);
    REGISTER_MIB("hashSelIpv4Table", hashSelIpv4Table_variables, variable3,
                 hashSelTable_variables_oid);
    REGISTER_MIB("hashSelIpv6Table", hashSelIpv6Table_variables, variable3,
                 hashSelTable_variables_oid);
}
#endif /*#if (SYS_CPNT_HASH_SELECTION == TRUE)*/
