/* Module Name: SWCTRL.C
 * Purpose:
 *        ( 1. Whole module function and scope.                 )
 *         This file provides the hardware independent interface of switch
 *         control functions to applications.
 *        ( 2.  The domain MUST be handled by this module.      )
 *         This module includes port configuration, VLAN, port mirroring,
 *         trunking, spanning tree, IGMP, broadcast storm control, and
 *         port mapping.
 *        ( 3.  The domain would not be handled by this module. )
 *         But this module doesn't include MAC address manipulation and
 *         port statistics.
 * Notes:
 *        ( Something must be known or noticed by developer     )
 * History:
 *       Date        Modifier    Reason
 *      2001/6/1    Jimmy Lin   Create this file
 *      2001/11/1   Arthur Wu   Take over
 *      2002/03/28  Jason Hsue  Add SWCTRL_isPortLinkUp() for lan.c (patching for
 *                              Allayer chip, it can only send the trunk number up.
 *                              But for LACP we need to know the user port and it's
 *                              link status.
 *
 *
 * Copyright(C)      Accton Corporation, 1999, 2000
 */


/* INCLUDE FILE DECLARATIONS
 */

#include "sys_cpnt.h"
#include "sys_bld.h"
#include "sys_adpt.h"
#include "sys_dflt.h"
#include "sys_time.h"
#include "sys_hwcfg.h"
#include "sysfun.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include "l_math.h"
#include "l_cvrt.h"
#include "l_bitmap.h"

#include "leaf_sys.h"
#include "leaf_1493.h"
#include "leaf_2863.h"
#include "leaf_2674p.h"
#include "leaf_2674q.h"
#include "leaf_2933.h"
#include "leaf_3636.h"
#include "leaf_es3626a.h"
#include "leaf_ieee8021x.h"
#include "l_sort_lst.h"
#include "lan.h"
#include "sys_module.h"
#include "sys_callback_mgr.h"

#include "swctrl_om.h"
#include "swctrl_init.h"
#include "swctrl_task.h"
#include "swctrl.h"
#include "swctrl_backdoor.h"
#include "swctrl_group.h"

#include "stktplg_type.h"
#include "stktplg_pom.h"
#include "stktplg_om.h"

#include "swdrv.h"
#include "swdrv_lib.h"
#include "swdrv_type.h"

#ifdef NOVAL
#include "gateway/bcmdrv.h"
#endif

#include "eh_type.h"
#include "eh_mgr.h"

#include "vlan_om.h"

#include "syslog_type.h"
#include "trap_event.h"
#include "snmp_pmgr.h"

#include "xstp_type.h"
#include "xstp_om.h"

#if (SYS_CPNT_EFM_OAM == TRUE)
#include "swdrv.h"
#include "lan.h"
#endif

#if (SYS_CPNT_DOT1X == TRUE)
#include "hrdrv.h"
#endif


#if (SYS_CPNT_SYSCTRL_XOR == TRUE)
#include "sysctrl_xor_mgr.h"
#endif

#if (SYS_CPNT_SWDRVL4 == TRUE)
#include "swdrvl4.h"
#endif
#include "trk_mgr.h"
#if (SYS_CPNT_ATC_STORM == TRUE)
#include "nmtrdrv_om.h"
#include "nmtr_mgr.h"
#include "trap_mgr.h"
#endif

#if (SYS_CPNT_SYSCTRL_XOR == TRUE)
#include "sysctrl_xor_mgr.h"
#endif

#if (SYS_CPNT_RSPAN == TRUE)
#include "rspan_mgr.h"
#include "rspan_om.h"
#endif /*(SYS_CPNT_RSPAN == TRUE)*/

#if (SYS_CPNT_SFLOW == TRUE)
#include "sflow_mgr.h"
#endif

#if (SYS_CPNT_VXLAN == TRUE)
#include "vxlan_type.h"
#endif

#include "backdoor_mgr.h"

/* ATC Broadcast Storm Constant */
#define SWCTRL_ATC_BROADCAST_STORM_TC_ON_ENABLE VAL_atcBcastStormTrafficControlApply_enabled
#define SWCTRL_ATC_BROADCAST_STORM_TC_ON_DISABLE VAL_atcBcastStormTrafficControlApply_disabled
#define SWCTRL_ATC_BROADCAST_STORM_TC_RELEASE_ENABLE VAL_atcBcastStormTrafficControlRelease_enabled
#define SWCTRL_ATC_BROADCAST_STORM_TC_RELEASE_DISABLE VAL_atcBcastStormTrafficControlRelease_disabled
#define SWCTRL_ATC_BROADCAST_STORM_STATE_MACHINE_MANUAL_ENABLE 1L
#define SWCTRL_ATC_BROADCAST_STORM_STATE_MACHINE_MANUAL_DISABLE 2L

#define SWCTRL_ATC_BROADCAST_STORM_TRAPF_LOW_FLOW 1L
#define SWCTRL_ATC_BROADCAST_STORM_TRAPF_MIDDLE_FLOW 2L
#define SWCTRL_ATC_BROADCAST_STORM_TRAPF_HIGH_FLOW 3L

#define SWCTRL_ATC_BROADCAST_STORM_CTRAPF_ON 1L
#define SWCTRL_ATC_BROADCAST_STORM_CTRAPF_RELEASE 2L
#define SWCTRL_ATC_BROADCAST_STORM_ONE_THOUSAND SYS_ADPT_ATC_STORM_CONTROL_UNIT

#ifndef SYS_ADPT_MAX_NBR_OF_40GIGA_PORT_PER_TRUNK
#define SYS_ADPT_MAX_NBR_OF_40GIGA_PORT_PER_TRUNK 2
#endif

typedef enum SWCTRL_ATCBStormStateMachineState_Type_E
{
    SWCTRL_ATCBSTORM_INIT_ST = 0,
    SWCTRL_ATCBSTORM_MIDDLE_ST,
    SWCTRL_ATCBSTORM_LOW_ST,
    SWCTRL_ATCBSTORM_HIGH_ST,
    SWCTRL_ATCBSTORM_CONTROL_ST,
    SWCTRL_ATCBSTORM_CONTROLLOW_ST,
    SWCTRL_ATCBSTORM_RELEASE_ST,

    /* Internal State or Transition State
     */
    SWCTRL_ATCBSTORM_INIT_TST,
    SWCTRL_ATCBSTORM_MIDDLE_TST,
    SWCTRL_ATCBSTORM_LOW_TST,
    SWCTRL_ATCBSTORM_HIGH_TST,
    SWCTRL_ATCBSTORM_CONTROL_TST,
    SWCTRL_ATCBSTORM_CONTROLLOW_TST,
    SWCTRL_ATCBSTORM_RELEASE_TST,
    SWCTRL_ATCBSTORM_TERMINATE_TST
} SWCTRL_ATCBStormStateMachineState_Type_T;

#define SWCTRL_ATCBSTORM_NO_EV 0xFF
typedef enum SWCTRL_ATCBStormStateMachineEvent_Type_E
{
    SWCTRL_ATCBSTORM_ENTER_AUTO_EV =0,
    SWCTRL_ATCBSTORM_LOW_FLOW_EV,
    SWCTRL_ATCBSTORM_MIDDLE_FLOW_EV,
    SWCTRL_ATCBSTORM_HIGH_FLOW_EV,
    SWCTRL_ATCBSTORM_TIMER_ON_EV,
    SWCTRL_ATCBSTORM_TIMER_RELEASE_EV,
    SWCTRL_ATCBSTORM_MANUAL_EV,
    SWCTRL_ATCBSTORM_LEAVE_AUTO_EV
} SWCTRL_ATCBStormStateMachineEvent_Type_T;

#define SWCTRL_MROADCAST_STORM_ENABLE 1L
#define SWCTRL_MROADCAST_STORM_DISABLE 2L
/* ATC Multicast Storm Constant */
#define SWCTRL_ATC_MULTICAST_STORM_TC_ON_ENABLE VAL_atcMcastStormTrafficControlApply_enabled
#define SWCTRL_ATC_MULTICAST_STORM_TC_ON_DISABLE VAL_atcMcastStormTrafficControlApply_disabled
#define SWCTRL_ATC_MULTICAST_STORM_TC_RELEASE_ENABLE VAL_atcMcastStormTrafficControlRelease_enabled
#define SWCTRL_ATC_MULTICAST_STORM_TC_RELEASE_DISABLE VAL_atcMcastStormTrafficControlRelease_disabled
#define SWCTRL_ATC_MULTICAST_STORM_STATE_MACHINE_MANUAL_ENABLE 1L
#define SWCTRL_ATC_MULTICAST_STORM_STATE_MACHINE_MANUAL_DISABLE 2L

#define SWCTRL_ATC_MULTICAST_STORM_TRAPF_LOW_FLOW 1L
#define SWCTRL_ATC_MULTICAST_STORM_TRAPF_MIDDLE_FLOW 2L
#define SWCTRL_ATC_MULTICAST_STORM_TRAPF_HIGH_FLOW 3L

#define SWCTRL_ATC_MULTICAST_STORM_CTRAPF_ON 1L
#define SWCTRL_ATC_MULTICAST_STORM_CTRAPF_RELEASE 2L
#define SWCTRL_ATC_MULTICAST_STORM_ONE_THOUSAND SYS_ADPT_ATC_STORM_CONTROL_UNIT

typedef enum SWCTRL_ATCMStormStateMachineState_Type_E
{
    SWCTRL_ATCMSTORM_INIT_ST = 0,
    SWCTRL_ATCMSTORM_MIDDLE_ST,
    SWCTRL_ATCMSTORM_LOW_ST,
    SWCTRL_ATCMSTORM_HIGH_ST,
    SWCTRL_ATCMSTORM_CONTROL_ST,
    SWCTRL_ATCMSTORM_CONTROLLOW_ST,
    SWCTRL_ATCMSTORM_RELEASE_ST,

    /* Internal State or Transition State
     */
    SWCTRL_ATCMSTORM_INIT_TST,
    SWCTRL_ATCMSTORM_MIDDLE_TST,
    SWCTRL_ATCMSTORM_LOW_TST,
    SWCTRL_ATCMSTORM_HIGH_TST,
    SWCTRL_ATCMSTORM_CONTROL_TST,
    SWCTRL_ATCMSTORM_CONTROLLOW_TST,
    SWCTRL_ATCMSTORM_RELEASE_TST,
    SWCTRL_ATCMSTORM_TERMINATE_TST
} SWCTRL_ATCMStormStateMachineState_Type_T;

#define SWCTRL_ATCMSTORM_NO_EV 0xFF
typedef enum SWCTRL_ATCMStormStateMachineEvent_Type_E
{
    SWCTRL_ATCMSTORM_ENTER_AUTO_EV =0,
    SWCTRL_ATCMSTORM_LOW_FLOW_EV,
    SWCTRL_ATCMSTORM_MIDDLE_FLOW_EV,
    SWCTRL_ATCMSTORM_HIGH_FLOW_EV,
    SWCTRL_ATCMSTORM_TIMER_ON_EV,
    SWCTRL_ATCMSTORM_TIMER_RELEASE_EV,
    SWCTRL_ATCMSTORM_MANUAL_EV,
    SWCTRL_ATCMSTORM_LEAVE_AUTO_EV
} SWCTRL_ATCMStormStateMachineEvent_Type_T;

#define SWCTRL_ATC_BROADCAST_STORM_SAMPLETYPE_PKT_RATE 1L
#define SWCTRL_ATC_MROADCAST_STORM_SAMPLETYPE_PKT_RATE 1L


#if (SYS_CPNT_ATC_BSTORM == TRUE)
SWCTRL_ATCBroadcastStormTimer_T atc_broadcast_storm_timer;
#endif

#if (SYS_CPNT_ATC_MSTORM == TRUE)
SWCTRL_ATCMulticastStormTimer_T atc_multicast_storm_timer;
#endif
#if (SYS_CPNT_ATC_STORM == TRUE)
static NMTR_MGR_DiffCounter_T   swctrl_different_counter[SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK * SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT];
static NMTR_MGR_DiffCounter_T   swctrl_total_counter_last_time[SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK * SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT];
static SWDRV_IfXTableStats_T    swctrl_if_xtable_stats[SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK * SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT];
#endif
#if (SYS_CPNT_ATC_BSTORM == TRUE)
static BOOL_T SWCTRL_SetUPortATCBroadcastStormControlRateLimit (UI32_T unit, UI32_T port, UI32_T mode, UI32_T rate, UI32_T nRate);
static BOOL_T SWCTRL_SetUPortATCBroadcastStormTrafficControlOnStatus(UI32_T unit, UI32_T port, UI32_T atc_broadcast_storm_status);
static BOOL_T SWCTRL_SetUPortATCBroadcastStormTrafficControlReleaseStatus(UI32_T unit, UI32_T port, UI32_T atc_broadcast_storm_status);
static BOOL_T SWCTRL_SetATCBroadcastStormFSMTrafficControlOnStatus(UI32_T ifindex, UI32_T action, UI32_T traffic_control_on_status);
static BOOL_T SWCTRL_SetATCBroadcastStormFSMTrafficControlReleaseStatus(UI32_T ifindex, UI32_T action, UI32_T traffic_control_release_status);
static BOOL_T SWCTRL_ProcessATCBroadcastStormTrafficControlReleasePassively(UI32_T ifindex);
#endif
#if (SYS_CPNT_ATC_MSTORM == TRUE)
static BOOL_T SWCTRL_SetUPortATCMulticastStormControlRateLimit (UI32_T unit, UI32_T port, UI32_T mode, UI32_T rate, UI32_T nRate);
static BOOL_T SWCTRL_SetUPortATCMulticastStormTrafficControlOnStatus(UI32_T unit, UI32_T port, UI32_T atc_multicast_storm_status);
static BOOL_T SWCTRL_SetUPortATCMulticastStormTrafficControlReleaseStatus(UI32_T unit, UI32_T port, UI32_T atc_multicast_storm_status);
static BOOL_T SWCTRL_SetATCMulticastStormFSMTrafficControlOnStatus(UI32_T ifindex, UI32_T action, UI32_T traffic_control_on_status);
static BOOL_T SWCTRL_SetATCMulticastStormFSMTrafficControlReleaseStatus(UI32_T ifindex, UI32_T action, UI32_T traffic_control_release_status);
static BOOL_T SWCTRL_ProcessATCMulticastStormTrafficControlReleasePassively(UI32_T ifindex);
#endif
#if (SYS_CPNT_VLAN_MIRROR == TRUE)
static BOOL_T SWCTRL_VlanMirroringValidation(UI32_T vid, UI32_T ifindex_dest);
#endif

#if (SYS_CPNT_MAC_BASED_MIRROR == TRUE)
static BOOL_T SWCTRL_MacAddrMirrorValidation(UI32_T ifindex_dest, UI8_T *mac_address);
#endif

#if (SYS_CPNT_VLAN_MIRROR == TRUE) || (SYS_CPNT_MAC_BASED_MIRROR == TRUE) || (SYS_CPNT_ACL_MIRROR == TRUE)
static BOOL_T SWCTRL_CommonMirrorDestPortValidation(UI32_T ifindex_dest, SWCTRL_CommonMirrorType_T mirror_type);
#endif

#if 0
#define DBG_PRINT(format,...) printf("%s(%d): "format"\r\n",__FUNCTION__,__LINE__,##__VA_ARGS__); fflush(stdout);
#else
#define DBG_PRINT(format,...)
#endif

/* NAMING CONSTANT
 */
#if (SYS_CPNT_LLDP == TRUE)
    #define SWCTRL_NOTIFY_LLDP(ifindex) \
    SYS_CALLBACK_MGR_IfMauChangedCallback(SYS_MODULE_SWCTRL, ifindex)
#else
    #define SWCTRL_NOTIFY_LLDP(ifindex)
#endif

#define MIN_WrrWeightQueue                      0
#define MAX_WrrWeightQueue                      (SYS_ADPT_MAX_NBR_OF_PRIORITY_QUEUE)-1
#define SWCTRL_DIRTY_LATENCY_TORENCE            50 /*in tick*/

/* There are 3 states in DOT1X, but in SWCTRL view, only 2 states: enable and disable,
 * are necessary.
 * In dot1x, 3 states:
 *  1) force-unauthed -> SWCTRL_DOT1X_PORT_ENABLE
 *  2) auto           -> SWCTRL_DOT1X_PORT_ENABLE
 *  3) force-authed   -> SWCTRL_DOT1X_PORT_DISABLE
 */
#if    (SYS_DFLT_DOT1X_AUTH_CONTROLLED_PORT_CONTROL == VAL_dot1xAuthAuthControlledPortControl_forceUnauthorized)
#define SWCTRL_DOT1X_PORT_DEFAULT_STATE                SWCTRL_DOT1X_PORT_ENABLE
#elif  (SYS_DFLT_DOT1X_AUTH_CONTROLLED_PORT_CONTROL == VAL_dot1xAuthAuthControlledPortControl_auto)
#define SWCTRL_DOT1X_PORT_DEFAULT_STATE                SWCTRL_DOT1X_PORT_ENABLE
#else/*(SYS_DFLT_DOT1X_AUTH_CONTROLLED_PORT_CONTROL == VAL_dot1xAuthAuthControlledPortControl_forceAuthorized)*/
#define SWCTRL_DOT1X_PORT_DEFAULT_STATE                SWCTRL_DOT1X_PORT_DISABLE
#endif

#define SWCTRL_STORM_GRANULARITY_VALIDATION_MIN 64

#define SWCTRL_BROADCAST_STORM_ENABLE 1L
#define SWCTRL_BROADCAST_STORM_DISABLE 2L

/* definitions of sample type used for rate conversion.
 * NOTE:
 *   it assumption that all VAL_xxxStormSampleType_xxx_rate definitions are identical.
 *   ex. VAL_bcastStormSampleType_pkt_rate =
 *       VAL_mcastStormSampleType_pkt_rate =
 *       VAL_unkucastStormSampleType_pkt_rate =
 *       VAL_atcBcastStormSampleType_packet_rate =
 *       VAL_atcMcastStormSampleType_packet_rate
 */
#define SWCTRL_STORM_SAMPLE_TYPE_PKT_RATE       VAL_stormSampleType_pkt_rate
#define SWCTRL_STORM_SAMPLE_TYPE_OCTET_RATE     VAL_stormSampleType_octet_rate
#define SWCTRL_STORM_SAMPLE_TYPE_PERCENT_RATE   VAL_stormSampleType_percent
#define SWCTRL_STORM_SAMPLE_TYPE_AVERAGE_BYTE_PER_PKT   500

#if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION == TRUE)
#if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE == SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE_MULTIPLE_SESSION)
/* This patch is for traffic segmentation to work with
 * trunk more smoothly.
 * With this patch, the rule of traffic segmentation configuration
 * on trunk will be as like as other features.
 */
#define SWCTRL_PORT_TRAFFIC_SEGMENTATION_AUTO_ATTRIBUTE         TRUE

/* For new implementation, port egress block is managed by SWCTRL,
 * old style implementation will be never used.
 */
#define SWCTRL_PORT_TRAFFIC_SEGMENTATION_PORT_EGRESS_BLOCK      TRUE
#endif
#endif

/* This patch is for update port abilities from drv.
 *
 * The prior way to determine port abilities is according to
 * port type. However, port abilities might be different due
 * to various MAC/PHY even though port type is identical.
 *
 * Correct port abilities shall be according to current
 * HW (board arch/MAC/PHY/...). This patch implements
 * SWCTRL_UpdatePortAbility to retrieve current port
 * abilities from driver layer and store to
 * user_ext_port_info[].port_abililty whenever port type
 * is changed (or module type changed).
 */
#define SWCTRL_UPDATE_PORT_ABILITY              TRUE

#if (SYS_CPNT_SWCTRL_GLOBAL_STORM_SAMPLE_TYPE == TRUE)
#undef SYS_DFLT_BCAST_STORM_MODE
#undef SYS_DFLT_MCAST_STORM_MODE
#undef SYS_DFLT_UNKUCAST_STORM_MODE
#undef SYS_DFLT_BSTORM_TYPE
#undef SYS_DFLT_MSTORM_TYPE
#undef SYS_DFLT_UNKUSTORM_TYPE
#undef SYS_DFLT_ATC_BSTORM_TYPE
#undef SYS_DFLT_ATC_MSTORM_TYPE
#undef SYS_DFLT_BSTORM_RATE_LIMIT
#undef SYS_DFLT_MSTORM_RATE_LIMIT
#undef SYS_DFLT_UNKUSTORM_RATE_LIMIT
#define SYS_DFLT_BCAST_STORM_MODE       swctrl_global_storm_sample_type
#define SYS_DFLT_MCAST_STORM_MODE       swctrl_global_storm_sample_type
#define SYS_DFLT_UNKUCAST_STORM_MODE    swctrl_global_storm_sample_type
#define SYS_DFLT_BSTORM_TYPE            swctrl_global_storm_sample_type
#define SYS_DFLT_MSTORM_TYPE            swctrl_global_storm_sample_type
#define SYS_DFLT_UNKUSTORM_TYPE         swctrl_global_storm_sample_type
#define SYS_DFLT_ATC_BSTORM_TYPE        swctrl_global_storm_sample_type
#define SYS_DFLT_ATC_MSTORM_TYPE        swctrl_global_storm_sample_type
#define SYS_DFLT_BSTORM_RATE_LIMIT      swctrl_dflt_storm_rate[swctrl_global_storm_sample_type-1]
#define SYS_DFLT_MSTORM_RATE_LIMIT      swctrl_dflt_storm_rate[swctrl_global_storm_sample_type-1]
#define SYS_DFLT_UNKUSTORM_RATE_LIMIT   swctrl_dflt_storm_rate[swctrl_global_storm_sample_type-1]
#endif

/* MACRO DEFINITIONS
 */
/* define the macros about whole module
 */

#define SWCTRL_ENTER_CRITICAL_SECTION() swctrl_orig_priority=SYSFUN_OM_ENTER_CRITICAL_SECTION(swctrl_semaphore_id)
#define SWCTRL_LEAVE_CRITICAL_SECTION() SYSFUN_OM_LEAVE_CRITICAL_SECTION(swctrl_semaphore_id,swctrl_orig_priority)


#define SWCTRL_LOCK()                            SWCTRL_ENTER_CRITICAL_SECTION(); \
                                                 lock_count++;
#define SWCTRL_UNLOCK()                          SWCTRL_LEAVE_CRITICAL_SECTION(); \
                                                 unlock_count++;
#define SWCTRL_SEMLOCK(_lock_)                   if (_lock_) SWCTRL_ENTER_CRITICAL_SECTION()
#define SWCTRL_SEMUNLOCK(_lock_)                 if (_lock_) SWCTRL_LEAVE_CRITICAL_SECTION()

#define SWCTRL_CALLBACK_LOCK()                   SWCTRL_ENTER_CRITICAL_SECTION()
#define SWCTRL_CALLBACK_UNLOCK()                 SWCTRL_LEAVE_CRITICAL_SECTION()

/* SWCTRL_ENTER_XOR_CRITICAL_SECTION
 * SWCTRL_LEAVE_XOR_CRITICAL_SECTION
 *      CAN NOT be used between SWCTRL_LOCK and SWCTRL_UNLOCK
 *
 * SWCTRL_BREAK_XOR_CRITICAL_SECTION
 * SWCTRL_XOR_CHECK
 *      only allow to be used in XOR critical section.
 *      NOTE:
 *        CAN NOT be used between SWCTRL_LOCK and SWCTRL_UNLOCK.
 *        the real reason is that XOR CHECK is not allowed performed
 *        in CSC OM CS, in SWCTRL, SWCTRL_LOCK is used for both MGR CS
 *        and OM CS.
 */
#if (SYS_CPNT_SYSCTRL_XOR == TRUE)
#define _SWCTRL_XOR_LOCK()      SYSCTRL_XOR_MGR_GetSemaphore()
#define _SWCTRL_XOR_UNLOCK()    SYSCTRL_XOR_MGR_ReleaseSemaphore()
#define _SWCTRL_XOR_CHECK(check_expr)               \
    do {                                            \
        BOOL_T _xor_ret = (check_expr);             \
        if (_xor_ret_p && !_xor_ret)                \
            *_xor_ret_p = _xor_ret;                 \
        if (!_xor_ret)                              \
            goto end_of_xor_cs;                     \
    } while (0)
#else
#define _SWCTRL_XOR_LOCK()
#define _SWCTRL_XOR_UNLOCK()
#define _SWCTRL_XOR_CHECK(check_expr)
#endif

#define SWCTRL_ENTER_XOR_CRITICAL_SECTION(ret_p)    \
    _SWCTRL_XOR_LOCK();                             \
    {                                               \
        BOOL_T *_xor_ret_p = (ret_p)

#define SWCTRL_LEAVE_XOR_CRITICAL_SECTION()         \
    end_of_xor_cs:;                                 \
    }                                               \
    _SWCTRL_XOR_UNLOCK()

#define SWCTRL_BREAK_XOR_CRITICAL_SECTION(ret)      \
    do {                                            \
        if (_xor_ret_p)                             \
            *_xor_ret_p = (ret);                    \
        goto end_of_xor_cs;                         \
    } while (0)

#define SWCTRL_XOR_CHECK(check_expr)                \
    _SWCTRL_XOR_CHECK(check_expr)


#define SWCTRL_NO_USE_FUNC_NO                    0xffffffff

#define SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME()  SYS_TIME_GetSystemUpTimeByTick(&system_info.last_change_time)

#define SWCTRL_UPDATE_LINK_OPER_STATUS_LAST_CHANGE_TIME(ifindex)        SYS_TIME_GetSystemUpTimeByTick(&port_info[(ifindex)-1].link_oper_status_last_change)
#define SWCTRL_UPDATE_LINK_OPER_STATUS_LAST_UP_TIME(ifindex)     SYS_TIME_GetSystemUpTimeByTick(&port_info[(ifindex)-1].link_oper_status_last_up)


/* define the macros about the port operation state/mode
 */
#define SWCTRL_OPER_IS_LINK_UP(oper_status) ( \
            (oper_status) != VAL_ifOperStatus_notPresent && \
            (oper_status) != VAL_ifOperStatus_lowerLayerDown)
#define SWCTRL_OPER_IS_OPER_UP(oper_status) ( \
            (oper_status) == VAL_ifOperStatus_up)

#define SWCTRL_IS_LINK_UP(ifindex)      SWCTRL_OPER_IS_LINK_UP(port_info[(ifindex)-1].link_oper_status)
#define SWCTRL_IS_OPER_UP(ifindex)      SWCTRL_OPER_IS_OPER_UP(port_info[(ifindex)-1].link_oper_status)
#define SWCTRL_IS_EXIST(ifindex)        ( port_info[(ifindex)-1].link_oper_status != VAL_ifOperStatus_notPresent )
#define SWCTRL_IS_FULL_DUPLEX(ifindex)  ( port_info[(ifindex)-1].port_entry.port_speed_dpx_status == VAL_portSpeedDpxCfg_fullDuplex10   || \
                                          port_info[(ifindex)-1].port_entry.port_speed_dpx_status == VAL_portSpeedDpxCfg_fullDuplex100  || \
                                          port_info[(ifindex)-1].port_entry.port_speed_dpx_status == VAL_portSpeedDpxCfg_fullDuplex1000 || \
                                          port_info[(ifindex)-1].port_entry.port_speed_dpx_status == VAL_portSpeedDpxCfg_fullDuplex10g  || \
                                          port_info[(ifindex)-1].port_entry.port_speed_dpx_status == VAL_portSpeedDpxCfg_fullDuplex25g  || \
                                          port_info[(ifindex)-1].port_entry.port_speed_dpx_status == VAL_portSpeedDpxCfg_fullDuplex40g  || \
                                          port_info[(ifindex)-1].port_entry.port_speed_dpx_status == VAL_portSpeedDpxCfg_fullDuplex100g)

/* define the macros about the media type
 */
#define SWCTRL_IS_100TX(ifindex)        ( port_info[(ifindex)-1].port_entry.port_type == VAL_portType_hundredBaseTX )

#define SWCTRL_IS_100FIBER(ifindex)     ( port_info[(ifindex)-1].port_entry.port_type == VAL_portType_hundredBaseFX              ||  \
                                          port_info[(ifindex)-1].port_entry.port_type == VAL_portType_hundredBaseFxScSingleMode  ||  \
                                          port_info[(ifindex)-1].port_entry.port_type == VAL_portType_hundredBaseFxScMultiMode   )

#define SWCTRL_IS_1000T(ifindex)        ( port_info[(ifindex)-1].port_entry.port_type == VAL_portType_thousandBaseT )

#define SWCTRL_IS_1000FIBER(ifindex)    ( port_info[(ifindex)-1].port_entry.port_type == VAL_portType_thousandBaseSX   ||  \
                                          port_info[(ifindex)-1].port_entry.port_type == VAL_portType_thousandBaseLX   ||  \
                                          port_info[(ifindex)-1].port_entry.port_type == VAL_portType_thousandBaseGBIC ||  \
                                          port_info[(ifindex)-1].port_entry.port_type == VAL_portType_thousandBaseSfp  )

#define SWCTRL_IS_10GFIBER(ifindex)     ( port_info[(ifindex)-1].port_entry.port_type == VAL_portType_tenG          || \
                                          port_info[(ifindex)-1].port_entry.port_type == VAL_portType_tenGBaseXFP   || \
                                          port_info[(ifindex)-1].port_entry.port_type == VAL_portType_tenGBaseSFP )

#define SWCTRL_IS_10GSFP(ifindex)       ( port_info[(ifindex)-1].port_entry.port_type == VAL_portType_tenGBaseSFP )

#define SWCTRL_IS_10GCOPPER(ifindex)     ( port_info[ifindex-1].port_entry.port_type == VAL_portType_tenGBaseT )

#define SWCTRL_IS_25GFIBER(ifindex)       ( port_info[(ifindex)-1].port_entry.port_type == VAL_portType_twentyFiveGBaseSFP )

#define SWCTRL_IS_40GFIBER(ifindex)      ( port_info[ifindex-1].port_entry.port_type == VAL_portType_fortyGBaseQSFP )

#define SWCTRL_IS_100GFIBER(ifindex)      ( port_info[ifindex-1].port_entry.port_type == VAL_portType_hundredGBaseQSFP )

/* define for the port capability */
#define SWCTRL_10MB_PORT_MAX_RATE       10000    /* kbits per 10MB port */
#define SWCTRL_100MB_PORT_MAX_RATE      100000   /* kbits per 100MB port */
#define SWCTRL_1GB_PORT_MAX_RATE        1000000  /* kbits per 1G port */
#define SWCTRL_10GB_PORT_MAX_RATE       10000000 /* kbits per 10G port */
#define SWCTRL_40GB_PORT_MAX_RATE       40000000 /* kbits per 10G port */

#define SWCTRL_PORT_BANDWIDTH(speed_duplex) \
    ((speed_duplex) == VAL_portSpeedDpxCfg_halfDuplex10 ? 10000 : \
    ((speed_duplex) == VAL_portSpeedDpxCfg_fullDuplex10 ? 10000 : \
    ((speed_duplex) == VAL_portSpeedDpxCfg_halfDuplex100 ? 100000 : \
    ((speed_duplex) == VAL_portSpeedDpxCfg_fullDuplex100 ? 100000 : \
    ((speed_duplex) == VAL_portSpeedDpxCfg_halfDuplex1000 ? 1000000 : \
    ((speed_duplex) == VAL_portSpeedDpxCfg_fullDuplex1000 ? 1000000 : \
    ((speed_duplex) == VAL_portSpeedDpxCfg_halfDuplex10g ? 10000000 : \
    ((speed_duplex) == VAL_portSpeedDpxCfg_fullDuplex10g ? 10000000 : \
    ((speed_duplex) == VAL_portSpeedDpxCfg_fullDuplex25g ? 25000000 : \
    ((speed_duplex) == VAL_portSpeedDpxCfg_halfDuplex40g ? 40000000 : \
    ((speed_duplex) == VAL_portSpeedDpxCfg_fullDuplex40g ? 40000000 : \
    ((speed_duplex) == VAL_portSpeedDpxCfg_fullDuplex100g ? 100000000 : \
    0))))))))))))

/* define the macros about the port type
 */
#define SWCTRL_IS_USER_PORT(ifindex)    ( ifindex >= SYS_ADPT_ETHER_1_IF_INDEX_NUMBER &&  \
                                          ifindex <= (SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK) * (SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT) )
#define SWCTRL_IS_TRUNK(ifindex)        ( ifindex >= SYS_ADPT_TRUNK_1_IF_INDEX_NUMBER &&   \
                                          ifindex <  (SYS_ADPT_TRUNK_1_IF_INDEX_NUMBER) + (SYS_ADPT_MAX_NBR_OF_TRUNK_PER_SYSTEM) )
#define SWCTRL_IS_TRUNK_MEMBER(ifindex) ( ifindex <  SYS_ADPT_TRUNK_1_IF_INDEX_NUMBER &&  \
                                          port_info[(ifindex)-1].port_entry.port_trunk_index != 0    )
#define SWCTRL_IS_LPORT(ifindex)        ( (ifindex != 0 && ifindex <= SYS_ADPT_TOTAL_NBR_OF_LPORT) && \
                                          SWCTRL_IS_EXIST(ifindex)                                 && \
                                         !SWCTRL_IS_TRUNK_MEMBER(ifindex)                          )

#define SWCTRL_IS_FE_FAMILY_PORT_TYPE(PORT_TYPE) (( PORT_TYPE == VAL_portType_hundredBaseTX             ||              \
                                                    PORT_TYPE == VAL_portType_hundredBaseFX             ||              \
                                                    PORT_TYPE == VAL_portType_hundredBaseFxScSingleMode ||              \
                                                    PORT_TYPE == VAL_portType_hundredBaseFxScMultiMode  ) ? TRUE : FALSE)

#define SWCTRL_IS_GE_FAMILY_PORT_TYPE(PORT_TYPE) (( PORT_TYPE == VAL_portType_thousandBaseT    ||               \
                                                    PORT_TYPE == VAL_portType_thousandBaseSX   ||               \
                                                    PORT_TYPE == VAL_portType_thousandBaseLX   ||               \
                                                    PORT_TYPE == VAL_portType_thousandBaseGBIC ||               \
                                                    PORT_TYPE == VAL_portType_thousandBaseSfp  ) ? TRUE : FALSE )

#define SWCTRL_IS_10GE_FAMILY_PORT_TYPE(PORT_TYPE) (( PORT_TYPE == VAL_portType_tenG        || \
                                                      PORT_TYPE == VAL_portType_tenGBaseT   || \
                                                      PORT_TYPE == VAL_portType_tenGBaseXFP || \
                                                      PORT_TYPE == VAL_portType_tenGBaseSFP )  ? TRUE : FALSE )

#define SWCTRL_IS_25GE_FAMILY_PORT_TYPE(PORT_TYPE) (( PORT_TYPE == VAL_portType_twentyFiveGBaseSFP)  ? TRUE : FALSE )

#define SWCTRL_IS_40GE_FAMILY_PORT_TYPE(PORT_TYPE) (( PORT_TYPE == VAL_portType_fortyGBaseQSFP)  ? TRUE : FALSE )

#define SWCTRL_IS_100GE_FAMILY_PORT_TYPE(PORT_TYPE) (( PORT_TYPE == VAL_portType_hundredGBaseQSFP)  ? TRUE : FALSE )

#define SWCTRL_HIGHEST_SPD_DPX_CAPA(CAPA)                                                                                   \
  ( (CAPA & SYS_VAL_portCapabilities_portCap40gFull) ? SYS_VAL_portCapabilities_portCap40gFull :                            \
    ( (CAPA & SYS_VAL_portCapabilities_portCap40gHalf) ? SYS_VAL_portCapabilities_portCap40gHalf :                          \
      ( (CAPA & SYS_VAL_portCapabilities_portCap10gFull) ? SYS_VAL_portCapabilities_portCap10gFull :                        \
        ( (CAPA & SYS_VAL_portCapabilities_portCap10gHalf) ? SYS_VAL_portCapabilities_portCap10gHalf :                      \
          ( (CAPA & SYS_VAL_portCapabilities_portCap1000full) ? SYS_VAL_portCapabilities_portCap1000full :                  \
            ( (CAPA & SYS_VAL_portCapabilities_portCap1000half) ? SYS_VAL_portCapabilities_portCap1000half :                \
              ( (CAPA & SYS_VAL_portCapabilities_portCap100full) ? SYS_VAL_portCapabilities_portCap100full :                \
                ( (CAPA & SYS_VAL_portCapabilities_portCap100half) ? SYS_VAL_portCapabilities_portCap100half :              \
                  ( (CAPA & SYS_VAL_portCapabilities_portCap10full) ? SYS_VAL_portCapabilities_portCap10full :              \
                    ( (CAPA & SYS_VAL_portCapabilities_portCap10half) ? SYS_VAL_portCapabilities_portCap10half : 0 ))))))))))

#define SWCTRL_IS_ADMIN_ACTIVE_TRUNK_MEMBER(trunk_id, ifindex) \
    ((trunk_ext_port_info[(trunk_id)-1].admin_active_members[SWCTRL_BYTE_IN_BITMAP(ifindex)] & SWCTRL_BIT_IN_BITMAP(ifindex)) ? TRUE : FALSE)

#define SWCTRL_SET_TRUNK_MEMBER_ADMIN_ACTIVE(trunk_id, ifindex, active) do {  \
        if (active)                                                         \
            trunk_ext_port_info[(trunk_id)-1].admin_active_members[SWCTRL_BYTE_IN_BITMAP(ifindex)] |= SWCTRL_BIT_IN_BITMAP(ifindex); \
        else                                                                \
            trunk_ext_port_info[(trunk_id)-1].admin_active_members[SWCTRL_BYTE_IN_BITMAP(ifindex)] &= ~ SWCTRL_BIT_IN_BITMAP(ifindex); \
    } while (0)

#define SWCTRL_IS_OPER_ACTIVE_TRUNK_MEMBER(trunk_id, ifindex) \
    ((trunk_ext_port_info[(trunk_id)-1].oper_active_members[SWCTRL_BYTE_IN_BITMAP(ifindex)] & SWCTRL_BIT_IN_BITMAP(ifindex)) ? TRUE : FALSE)

#define SWCTRL_SET_TRUNK_MEMBER_OPER_ACTIVE(trunk_id, ifindex, active) do {  \
        if (active)                                                         \
            trunk_ext_port_info[(trunk_id)-1].oper_active_members[SWCTRL_BYTE_IN_BITMAP(ifindex)] |= SWCTRL_BIT_IN_BITMAP(ifindex); \
        else                                                                \
            trunk_ext_port_info[(trunk_id)-1].oper_active_members[SWCTRL_BYTE_IN_BITMAP(ifindex)] &= ~ SWCTRL_BIT_IN_BITMAP(ifindex); \
    } while (0)


/* define the macros about the index translation
 */
#define SWCTRL_UPORT_TO_IFINDEX(unit, port)         ( ((unit)-1) * (SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT) + (port)  )
#define SWCTRL_IFINDEX_TO_UNIT(ifindex)             ( ((UI32_T)(((ifindex)-1)/(SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT)))+1 )
#define SWCTRL_IFINDEX_TO_PORT(ifindex)             ( (ifindex) - (SWCTRL_IFINDEX_TO_UNIT(ifindex)-1)*(SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT) )


#define SWCTRL_TRUNKID_TO_IFINDEX(trunk_id)         ( (trunk_id) + (SYS_ADPT_TRUNK_1_IF_INDEX_NUMBER) - 1 )
#define SWCTRL_IFINDEX_TO_TRUNKID(ifindex)          ( (ifindex)  - (SYS_ADPT_TRUNK_1_IF_INDEX_NUMBER) + 1 )

/* The MSB of byte 0 is index 1, the LSB of byte 0 is index 8,
 * the MSB of byte 1 is index 9, the LSB of byte 1 is index 16,
 *  ...
 *  and so on.
 */
#define SWCTRL_BYTE_IN_BITMAP(INDEX)   ((int)(((INDEX)-1)/8))
#define SWCTRL_BIT_IN_BITMAP(INDEX)    (1 << (7 - (((INDEX)-1) - (SWCTRL_BYTE_IN_BITMAP((INDEX))*8))))

#define SWCTRL_USE_CSC(a)
#define SWCTRL_RELEASE_CSC()
#define SWCTRL_USE_CSC_WITHOUT_RETURN_VALUE()

#define SWCTRL_USE_CSC_CHECK_OPER_MODE(RET_VAL)                             \
  SWCTRL_USE_CSC(RET_VAL);                                                  \
  if (SYSFUN_GET_CSC_OPERATING_MODE() == SYS_TYPE_STACKING_SLAVE_MODE)  {   \
     EH_MGR_Handle_Exception (SYS_MODULE_SWCTRL,                            \
                           SWCTRL_NO_USE_FUNC_NO,                           \
                           EH_TYPE_MSG_NOT_IN_MASTER_MODE,                  \
                           EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR);  \
     SWCTRL_RELEASE_CSC();                                                  \
     return (RET_VAL);                                                      \
  }

#define SWCTRL_USE_CSC_CHECK_OPER_MODE_WITHOUT_RETURN_VALUE()                  \
  SWCTRL_USE_CSC_WITHOUT_RETURN_VALUE();                                       \
  if (SYSFUN_GET_CSC_OPERATING_MODE() == SYS_TYPE_STACKING_SLAVE_MODE)  {      \
     EH_MGR_Handle_Exception (SYS_MODULE_SWCTRL,                               \
                              SWCTRL_NO_USE_FUNC_NO,                           \
                              EH_TYPE_MSG_NOT_IN_MASTER_MODE,                  \
                              EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR);  \
    SWCTRL_RELEASE_CSC();                                                      \
    return;                                                                    \
  }

#define SWCTRL_RETURN_AND_RELEASE_CSC(RET_VAL)  {               \
    SWCTRL_RELEASE_CSC();                                       \
    return (RET_VAL);                                           \
  }

#define SWCTRL_RETURN_AND_RELEASE_CSC_WITHOUT_RETUEN_VALUE()  { \
    SWCTRL_RELEASE_CSC();                                       \
    return;                                                     \
  }

#define SWCTRL_RETURN_AND_RELEASE_CSC_AND_UNLOCK(RET_VAL)  {    \
    SWCTRL_UNLOCK();                                            \
    SWCTRL_RELEASE_CSC();                                       \
    return (RET_VAL);                                           \
  }
#define SYS_CPNT_PORT_SECURITY_TRUNK_DEBUG                       FALSE

/* define vlan mirror entries and macros */
#if (SYS_CPNT_VLAN_MIRROR == TRUE)
/* performance purpose:
 * 1) >> 3 instead of /8
 * 2) &7 instead of %8
 */
#define SWCTRL_NBR_OF_BYTE_FOR_1BIT_VLAN_LIST      ((SYS_ADPT_MAX_VLAN_ID + 7)>>3)
#define SWCTRL_IS_VLAN_MIRROR(vid)                 ((sys_vlan_mirror_info.mirror_source_vlans[(vid-1)>>3]<<((vid-1)&7))&0x80)
#define SWCTRL_IS_VLAN_DEST_PORT(dest_port)        (sys_vlan_mirror_info.mirror_dest_port == dest_port)

/* For vlan mirror lists in system */
typedef struct
{
    UI32_T system_vlan_mirror_status;  /* the vlan mirror is activated */
    UI32_T mirror_dest_port;           /* a mirroring port */
    UI8_T  mirror_source_vlans[SWCTRL_NBR_OF_BYTE_FOR_1BIT_VLAN_LIST];  /* mirrored vlans */
} SWCTRL_SystemVlanMirrorInfo_T;
#endif /* End of #if (SYS_CPNT_VLAN_MIRROR == TRUE) */

typedef enum SWCTRL_LacpStateMachineEvent_Type_E
{
    SWCTRL_HOT_SWAP_INSERT_EVENT = 0,
    SWCTRL_HOT_SWAP_REMOVE_EVENT,

    SWCTRL_LINK_UP_EVENT,
    SWCTRL_LINK_DOWN_EVENT,

    SWCTRL_DUPLEX_FULL_EVENT,
    SWCTRL_DUPLEX_HALF_EVENT,

    SWCTRL_ADMIN_ENABLE_EVENT,
    SWCTRL_ADMIN_DISABLE_EVENT,

    SWCTRL_DORMANT_ENABLE_EVENT,
    SWCTRL_DORMANT_DISABLE_EVENT,

    SWCTRL_LOOPBACK_START_EVENT,
    SWCTRL_LOOPBACK_STOP_EVENT,

    SWCTRL_LOWER_LAYER_CHANGED_EVENT,

} SWCTRL_LacpStateMachineEvent_Type_T;

#if (SYS_CPNT_SWCTRL_PORT_PENDING_LINK_UP == TRUE)
typedef enum
{
    SWCTRL_PORT_PENDING_LINKUP_OWNER__DFLT_CFG      = BIT_0,
    SWCTRL_PORT_PENDING_LINKUP_OWNER__POWER_SAVE    = BIT_1,
} SWCTRL_PortPendingLinkUp_Owner_T;
#endif

/* For system-wise information database
 */
typedef struct
{
    UI32_T  is_private_vlan_enable;         /* TRUE/FALSE */
    UI32_T  jumbo_frame_status;             /* SWCTRL_JUMBO_FRAME_DISABLE/SWCTRL_JUMBO_FRAME_ENABLE */
    UI32_T  jumbo_mtu;
    UI32_T  mtu;

#if (SYS_CPNT_ALLOW_DUMMY_MIRRORING_DEST == TRUE)
    UI32_T  dummy_mirroring_dest;           /* if this constant is TRUE, means only one eye is allowed, when
                                             * UIs set mirroring API without source argument this field will be set.
                                             */
#endif
    UI32_T  last_change_time;               /* The time of last change of every port */

#if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION == TRUE)
#if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE == SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE_MULTIPLE_SESSION)
    UI32_T  is_blocking_uplink_to_uplink_mode;  /* the traffic will be blocking or forwarding of uplink ports */
#endif /* End of #if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE == SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE_MULTIPLE_SESSION)*/
#endif /* End of #if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION == TRUE) */

    UI32_T  trunk_balance_mode;
} SWCTRL_SystemInfo_T;



/* For per port information database, include user port and logical port
 */
typedef struct
{
    SWCTRL_PortEntry_T         port_entry;
    SWCTRL_BcastStormEntry_T   bcast_storm_entry;
    SWCTRL_McastStormEntry_T   mcast_storm_entry;
#if (SYS_CPNT_STORM_MODE & SYS_CPNT_STORM_UNKNOWN_USTORM)
    SWCTRL_UnknownUcastStormEntry_T unknown_ucast_storm_entry;
#endif
    UI32_T storm_granularity;
#if (SYS_CPNT_ATC_BSTORM == TRUE)
    SWCTRL_ATCBroadcastStormEntry_T atc_broadcast_storm_entry;
#endif
#if (SYS_CPNT_ATC_MSTORM == TRUE)
    SWCTRL_ATCMulticastStormEntry_T atc_multicast_storm_entry;
#endif

    UI32_T   admin_status;                /* VAL_ifAdminStatus_up / VAL_ifAdminStatus_down */
    UI32_T   shutdown_status;             /* SWCTRL_PORT_STATUS_SET_BY_XXX */
    UI32_T   bandwidth;                   /* in kbps */
    UI32_T   link_change_trap;            /* VAL_ifLinkUpDownTrapEnable_enabled / VAL_ifLinkUpDownTrapEnable_disabled */
    UI32_T   link_oper_status_last_change;/* last sysUpTime of link up/down */
    UI32_T   link_oper_status_last_up;    /* sysUpTime that oper status is changed to VAL_ifOperStatus_up */
    UI32_T   link_oper_status;            /* operating status */
    UI32_T   link_oper_status_level;
    UI32_T   link_oper_dormant_status;    /* bitmap of SWCTRL_OperDormantLevel_T */
    UI32_T   link_oper_dormant_active;    /* bitmap of SWCTRL_OperDormantLevel_T */
#if (SYS_CPNT_SWCTRL_PORT_PENDING_LINK_UP == TRUE)
    UI32_T   link_status_pending_up_status;     /* consisted of SWCTRL_PortPendingLinkUp_Owner_T */
    UI32_T   link_status_pending_up_expired_time;
#endif

    UI32_T   ingress_rate_limit_status;   /* Ingress rate limit status */
    UI32_T   ingress_rate_limit;          /* Ingress rate limit vlaue  */
#if (SYS_CPNT_NETACCESS_DYNAMIC_QOS == TRUE)
    UI32_T   ingress_rate_limit_status_user_cfg; /* backup for user configured setting */
    UI32_T   ingress_rate_limit_user_cfg;        /* backup for user configured setting */
    BOOL_T   ingress_rate_limit_dynamic_cfg;     /* TRUE: applied by RADIUS server; FALSE: user configure */
#endif

    UI32_T   egress_rate_limit_status;    /* Egress rate limit status */
    UI32_T   egress_rate_limit;           /* Egress rate limit value  */

    UI32_T   port_security_status;        /* VAL_portSecPortStatus_disabled / VAL_portSecPortStatus_enabled*/
    UI32_T   port_security_enabled_by_who ; /*kevin*/
    UI32_T   port_security_action_status;
    UI32_T   port_security_action_trap_oper_status;    /* VAL_portSecActionTrap_disabled / VAL_portSecActionTrap_enabled*/
    UI32_T   port_security_action_trap_time_stamp;     /* cell is ticks, default is 0 */
#if (SYS_CPNT_WRR_Q_MODE_PER_PORT_CTRL == TRUE) && (SYS_CPNT_WRR_Q_WEIGHT_PER_PORT_CTRL == TRUE)
    UI32_T   egress_scheduler_method;                  /* egress port scheduler method */
    UI32_T   wrr_weight[SYS_ADPT_MAX_NBR_OF_PRIORITY_QUEUE]; /* weight of each queue */
#endif

    BOOL_T   private_vlan_uplink_port;     /* this port is private vlan uplink port or not */
    BOOL_T   private_vlan_downlink_port;   /* this port is private vlan downlink port or not */
    UI32_T   forced_1000t_mode;            /* forced 1000 base T mode */

    UI32_T   rate_based_storm_rate;
    UI32_T   rate_based_storm_mode;

/* MDIX mode */
#if (SYS_CPNT_SWCTRL_MDIX_CONFIG == TRUE)
    BOOL_T MDIX_mode;  /* MDIX mode */
#endif

#if (SYS_CPNT_RSPAN == TRUE)
    BOOL_T   rspan_frame_sz_is_modified;
#endif
    UI8_T    egr_blk_lport_list[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST];

} SWCTRL_PortInfo_T;



/* For extend user port information database,
 * i.e. the characteristics just only for user port
 */
typedef struct
{
    UI32_T  untagged_max_frame_sz;        /* max frame size for untagged frames */
    UI32_T  tagged_max_frame_sz;          /* max frame size for tagged frames */

    UI32_T  learning_disabled_status;     /* config status. ignore when security is enabled */
    BOOL_T  current_learning_status;      /* current learning status */

#if (SYS_CPNT_3COM_LOOPBACK_TEST == TRUE)
    BOOL_T  is_loopback_test_failed;      /*TRUE/FALSE*/
#endif

#if (SYS_CPNT_STATIC_TRUNK_CONFIG_ALLOWED_ON_LACP_PORT == TRUE)
    UI32_T  lacp_admin_status;            /* VAL_lacpPortStatus_enabled / VAL_lacpPortStatus_disabled */
    UI32_T  lacp_oper_status;             /* VAL_lacpPortStatus_enabled / VAL_lacpPortStatus_disabled */
#else
    UI32_T  lacp_status;                  /* VAL_lacpPortStatus_enabled / VAL_lacpPortStatus_disabled */
#endif

    UI32_T  dot1x_status;                 /* SWCTRL_DOT1X_PORT_ENABLE / SWCTRL_DOT1X_PORT_DISABLE*/
    UI32_T  mirroring_tx_dest_port;       /* the tx monitor port ifindex */
    UI32_T  mirroring_rx_dest_port;       /* the rx monitor port ifindex */

#if (SYS_CPNT_POWER_SAVE == TRUE)
    UI32_T  power_save_admin_status;      /* VAL_portPowerSave_enabled / VAL_portPowerSave_disabled */
    UI32_T  power_save_oper_status;       /* VAL_portPowerSave_enabled / VAL_portPowerSave_disabled */
    UI32_T  power_save_speed_duplex;      /* port speed duplex when power save enabled */
    UI32_T  power_save_check_ticks;
#endif

#if (SWCTRL_UPDATE_PORT_ABILITY == TRUE)
    SWCTRL_PortAbility_T port_abililty;
#endif

#if (SYS_CPNT_INTERNAL_LOOPBACK_TEST == TRUE)
    BOOL_T is_int_loopback_mode;
#endif

#if (SYS_CPNT_EFM_OAM == TRUE)
    BOOL_T is_oam_loopback_mode;
#endif

#if (SYS_CPNT_SWCTRL_FEC == TRUE)
    UI32_T port_fec_mode;
    UI32_T port_fec_status;
#endif
} SWCTRL_UserPortExtInfo_T;

typedef struct
{
    /* I. for port type change
     */
    UI32_T  changed_port_type;
    UI32_T  port_type_updated_time;
    UI32_T  port_type_dirty_time;
    UI32_T  changed_module_id;
    UI32_T  module_id_dirty_time;

    /* II. for link up/down
     */
    BOOL_T  changed_link_status;
    UI32_T  link_status_updated_time;
    UI32_T  link_status_dirty_time;
#if (SYS_CPNT_SWCTRL_PORT_PENDING_LINK_UP == TRUE)
    UI32_T  link_status_pending_up_dirty_time;
#endif

    /* III. for oper speed-duplex change
     */
    UI32_T  changed_oper_speedduplex;
    UI32_T  oper_speedduplex_updated_time;
    UI32_T  oper_speedduplex_dirty_time;

    /* IV. for oper flowcontrol change
     */
    UI32_T  changed_oper_flowctrl;
    UI32_T  oper_flowctrl_updated_time;
    UI32_T  oper_flowctrl_dirty_time;

    /* V. for sfp present status change
     */
    BOOL_T  changed_sfp_present_status;
    UI32_T  sfp_present_status_updated_time;
    UI32_T  sfp_present_status_dirty_time;

    /* VI. for sfp ddm measured info change
     */
    UI32_T  sfp_ddm_measured_info_dirty_time;

} SWCTRL_ChangedStatusInfo_T;

#if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION == TRUE)
#if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE == SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE_MULTIPLE_SESSION)

/* For extend private vlan multiple session information */
typedef struct SWCTRL_PrivateVlanExtInfo_S
{
    UI32_T session_id;
    UI8_T  private_vlan_uplink_port_list[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST];
    UI8_T  private_vlan_downlink_port_list[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST];
    BOOL_T is_valid;
} SWCTRL_PrivateVlanExtInfo_T;

typedef struct SWCTRL_PrivateVlanPortInfo_S
{
    UI32_T   port_index;                  /* port ifindex */
    UI32_T   dev_id;                      /* specific dev_id */
    UI32_T   session_id;                  /* default id is 0 */
    UI32_T   port_trunk_index;            /* default isn't trunk */
    BOOL_T   private_vlan_uplink_port;    /* is uplink port */
    BOOL_T   private_vlan_downlink_port;  /* is downlink port */
    BOOL_T   is_pvlan_trunk_index_port;   /* allow to change pvlan or not */
} SWCTRL_PrivateVlanPortInfo_T;

typedef struct SWCTRL_PrivateVlanTrunkPortExtInfo_S
{
    UI32_T   trunk_index;   /* trunk ifindex */
    UI32_T   session_id;    /* default sid is 0 */
    UI8_T    pvlan_trunk_uplink_port_list[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST];
    UI8_T    pvlan_trunk_downlink_port_list[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST];
} SWCTRL_PrivateVlanTrunkPortExtInfo_T;

#endif /* End of #if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE == SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE_MULTIPLE_SESSION)*/
#endif /* End of #if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION == TRUE) */

/* LOCAL VARIABLES
 */

/* This is operation mode, set by STKCTRL
 */
SYSFUN_DECLARE_CSC           /* trasition/master/slave */

/* Semaphore ID
 */
static UI32_T   swctrl_semaphore_id;
static UI32_T  swctrl_orig_priority;
static BOOL_T   is_provision_complete;
static UI32_T   lock_count = 0;
static UI32_T   unlock_count = 0;

/* These static varuables are database
 */
static SWCTRL_SystemInfo_T       system_info;
static SWCTRL_PortInfo_T         port_info[SYS_ADPT_TOTAL_NBR_OF_LPORT];
static SWCTRL_TrunkPortExtInfo_T trunk_ext_port_info[SYS_ADPT_MAX_NBR_OF_TRUNK_PER_SYSTEM];
static SWCTRL_UserPortExtInfo_T  user_ext_port_info [SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK *
                                                     SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT];

static SWCTRL_ChangedStatusInfo_T user_port_changed_info[SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK *
                                                         SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT];

/* Defines the ports allowed to be trunk member.
 */
#if defined(SYS_ADPT_ALLOW_TO_BE_TM_PORT_LIST)
static const UI8_T swctrl_allow_to_be_tm_port_list [SYS_ADPT_NBR_OF_BYTE_FOR_1BIT_UPORT_LIST] =
    {
        SYS_ADPT_ALLOW_TO_BE_TM_PORT_LIST
    };
#endif


/* define vlan mirror static varaiable */
#if (SYS_CPNT_VLAN_MIRROR == TRUE)
static SWCTRL_SystemVlanMirrorInfo_T  sys_vlan_mirror_info;
#endif /* End of #if (SYS_CPNT_VLAN_MIRROR == TRUE) */

#if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION == TRUE)
#if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE == SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE_MULTIPLE_SESSION)
static SWCTRL_PrivateVlanExtInfo_T           swctl_private_vlan_ext_info[SYS_ADPT_PORT_TRAFFIC_SEGMENTATION_MAX_NBR_OF_SESSIONS];
static SWCTRL_PrivateVlanPortInfo_T          swctl_private_vlan_port_info[SYS_ADPT_TOTAL_NBR_OF_LPORT];
static SWCTRL_PrivateVlanTrunkPortExtInfo_T  swctl_private_vlan_trunk_port_info[SYS_ADPT_MAX_NBR_OF_TRUNK_PER_SYSTEM];
#endif /* End of #if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE == SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE_MULTIPLE_SESSION)*/
#endif /* End of #if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION == TRUE) */

static UI32_T                    wrr_queue_default[SYS_ADPT_MAX_NBR_OF_PRIORITY_QUEUE];       /* default weight for each queue, start from 0*/
static UI32_T                    default_egress_scheduler_mode;

#if ((SYS_CPNT_SWCTRL_CABLE_DIAG == TRUE) && (SYS_CPNT_SWCTRL_CABLE_DIAG_CHIP == SYS_CPNT_SWCTRL_CABLE_DIAG_BROADCOM))
static SWCTRL_Cable_Info_T              cable_info[SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK*SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT];
#endif    /* #if (SYS_CPNT_SWCTRL_CABLE_DIAG == TRUE) */

/* This tbale is for stacking re-numbering
 */
static UI32_T re_numbering_mapping_table[SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK];
static BOOL_T device_type_validation_table[SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK];


static  SWCTRL_MTP_INFO_T mtp_info_table[SYS_ADPT_MAX_NBR_OF_MIRROR_PORT];

/*DanXie,define for mirror show*/

static L_SORT_LST_List_T  mirror_mtp_list[SYS_ADPT_MAX_NBR_OF_MIRROR_PORT];

static UI16_T swctrl_pkt_trap_status[SWCTRL_PKTTYPE_MAX];
static UI16_T swctrl_pkt_drop_status[SWCTRL_PKTTYPE_MAX];
static UI16_T swctrl_pkt_trap_status_per_port[SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK][SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT][SWCTRL_PKTTYPE_MAX];
static UI16_T swctrl_pkt_drop_status_per_port[SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK][SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT][SWCTRL_PKTTYPE_MAX];

static UI32_T swctrl_pkt_cpu_rate[SWCTRL_PKTTYPE_MAX];

#if (SWCTRL_UPDATE_PORT_ABILITY == TRUE)
#if (SYS_CPNT_EH == TRUE)
static char *swctrl_port_type_str[] = {
    [VAL_portType_hundredBaseTX]                = "100BASE-TX",
    [VAL_portType_hundredBaseFX]                = "100BASE-FX",
    [VAL_portType_thousandBaseSX]               = "1000BASE-SX",
    [VAL_portType_thousandBaseLX]               = "1000BASE-LX",
    [VAL_portType_thousandBaseT]                = "1000BASE-T",
    [VAL_portType_thousandBaseGBIC]             = "1000BASE GBIC",
    [VAL_portType_thousandBaseSfp]              = "1000BASE SFP",
    [VAL_portType_hundredBaseFxScSingleMode]    = "100BASE-FX",
    [VAL_portType_hundredBaseFxScMultiMode]     = "100BASE-FX",
    [VAL_portType_thousandBaseCX]               = "1000BASE-CX",
    [VAL_portType_tenG]                         = "10GBASE fiber",
    [VAL_portType_hundredBaseBX]                = "100BASE-BX",
    [VAL_portType_thousandBaseBX]               = "1000BASE-BX",
    [VAL_portType_tenGBaseT]                    = "10GBASE-T",
    [VAL_portType_tenGBaseXFP]                  = "10GBASE XFP",
    [VAL_portType_tenGBaseSFP]                  = "10GBASE SFP",
    [VAL_portType_twentyFiveGBaseSFP]           = "25GBASE SFP",
    [VAL_portType_fortyGBaseQSFP]               = "40GBASE QSFP",
    [VAL_portType_hundredGBaseQSFP]             = "100GBASEQSFP",
};

static char *swctrl_speed_duplex_str[] = {
    [VAL_portSpeedDpxCfg_halfDuplex10]      = "10half",
    [VAL_portSpeedDpxCfg_fullDuplex10]      = "10full",
    [VAL_portSpeedDpxCfg_halfDuplex100]     = "100half",
    [VAL_portSpeedDpxCfg_fullDuplex100]     = "100full",
    [VAL_portSpeedDpxCfg_halfDuplex1000]    = "1000half",
    [VAL_portSpeedDpxCfg_fullDuplex1000]    = "1000full",
    [VAL_portSpeedDpxCfg_halfDuplex10g]     = "10ghalf",
    [VAL_portSpeedDpxCfg_fullDuplex10g]     = "10gfull",
    [VAL_portSpeedDpxCfg_fullDuplex25g]     = "25gfull",
    [VAL_portSpeedDpxCfg_halfDuplex40g]     = "40ghalf",
    [VAL_portSpeedDpxCfg_fullDuplex40g]     = "40gfull",
    [VAL_portSpeedDpxCfg_fullDuplex100g]    = "100gfull",
};

static char *swctrl_capa_str[] = {
    [VAL_portCapabilities_portCap10half]    = "10half",
    [VAL_portCapabilities_portCap10full]    = "10full",
    [VAL_portCapabilities_portCap100half]   = "100half",
    [VAL_portCapabilities_portCap100full]   = "100full",
    [VAL_portCapabilities_portCap1000half]  = "1000half",
    [VAL_portCapabilities_portCap1000full]  = "1000full",
    [VAL_portCapabilities_portCap10gHalf]   = "10ghalf",
    [VAL_portCapabilities_portCap10gFull]   = "10gfull",
    [VAL_portCapabilities_portCap40gHalf]   = "40ghalf",
    [VAL_portCapabilities_portCap40gFull]   = "40gfull",
};
#endif
#endif /* (SWCTRL_UPDATE_PORT_ABILITY == TRUE) */

#if (SYS_CPNT_SWCTRL_GLOBAL_STORM_SAMPLE_TYPE == TRUE)
static UI32_T swctrl_global_storm_sample_type;
static UI32_T swctrl_dflt_storm_rate[] = {
    [SWCTRL_STORM_SAMPLE_TYPE_OCTET_RATE-1]     = 64,   /* kbit/s */
    [SWCTRL_STORM_SAMPLE_TYPE_PKT_RATE-1]       = 500,  /* pkt/s */
    [SWCTRL_STORM_SAMPLE_TYPE_PERCENT_RATE-1]   = 5,    /* % */
};
#endif

/* These static varuables are for callback register
 */
/* register list of tolology change
 */
static SYS_TYPE_CallBack_T *PortTypeChanged_callbacklist;
static SYS_TYPE_CallBack_T *uPortTypeChanged_callbacklist;

/* register list of trunk change
 */
static SYS_TYPE_CallBack_T *TrunkMemberAdd1st_callbacklist;
static SYS_TYPE_CallBack_T *TrunkMemberAdd_callbacklist;
static SYS_TYPE_CallBack_T *TrunkMemberDelete_callbacklist;
static SYS_TYPE_CallBack_T *TrunkMemberDeleteLst_callbacklist;

/* register list of up/down change
 */
static SYS_TYPE_CallBack_T *PortLinkUp_callbacklist;
static SYS_TYPE_CallBack_T *uPortLinkUp_callbacklist;
static SYS_TYPE_CallBack_T *uPortFastLinkUp_callbacklist;

static SYS_TYPE_CallBack_T *PortLinkDown_callbacklist;
static SYS_TYPE_CallBack_T *uPortLinkDown_callbacklist;
static SYS_TYPE_CallBack_T *uPortFastLinkDown_callbacklist;


static SYS_TYPE_CallBack_T *PortOperUp_callbacklist;
static SYS_TYPE_CallBack_T *PortNotOperUp_callbacklist;
static SYS_TYPE_CallBack_T *TrunkMemberPortOperUp_callbacklist;
static SYS_TYPE_CallBack_T *TrunkMemberPortNotOperUp_callbacklist;

/* register list of admin state change
 */
static SYS_TYPE_CallBack_T *PortAdminEnable_callbacklist;
static SYS_TYPE_CallBack_T *uPortAdminEnable_callbacklist;
static SYS_TYPE_CallBack_T *PortAdminDisable_callbacklist;
#if (SYS_CPNT_LLDP == TRUE)
static SYS_TYPE_CallBack_T *PortAdminDisableBefore_callbacklist;
#endif
static SYS_TYPE_CallBack_T *uPortAdminDisable_callbacklist;

/* register list of speed-duplex state change
 */
static SYS_TYPE_CallBack_T *PortSpeedDuplex_callbacklist;
static SYS_TYPE_CallBack_T *uPortSpeedDuplex_callbacklist;

/* register list for LACP and Dot1x
 */
static SYS_TYPE_CallBack_T *uPortLacpEffectiveOperStatusChanged_callbacklist;
static SYS_TYPE_CallBack_T *uPortDot1xEffectiveOperStatusChanged_callbacklist;

/* register list for L3 trunk failover
 */
static SYS_TYPE_CallBack_T *ForwardingUPortAddToTrunk_callbacklist;
static SYS_TYPE_CallBack_T *ForwardingTrunkMemberToNonForwarding_callbacklist;
static SYS_TYPE_CallBack_T *ForwardingTrunkMemberDelete_callbacklist;

#if (SYS_CPNT_SFP_DDM_ALARMWARN_TRAP == TRUE)
static BOOL_T pre_rx_loss[SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK][SYS_ADPT_NBR_OF_SFP_PORT_PER_UNIT];
#endif
/* LOCAL FUNCTIONS
 */
/* callback tolology change
 */
static void SWCTRL_Notify_LPortTypeChanged        (UI32_T ifindex, UI32_T port_type);
static void SWCTRL_Notify_UPortTypeChanged        (UI32_T unit, UI32_T port, UI32_T port_type);

/* callback trunk change
 */
static void SWCTRL_Notify_TrunkMemberAdd1st       (UI32_T trunk_ifindex, UI32_T member_ifindex);
static void SWCTRL_Notify_TrunkMemberAdd          (UI32_T trunk_ifindex, UI32_T member_ifindex);
static void SWCTRL_Notify_TrunkMemberDelete       (UI32_T trunk_ifindex, UI32_T member_ifindex);
static void SWCTRL_Notify_TrunkMemberDeleteLst    (UI32_T trunk_ifindex, UI32_T member_ifindex);

/* callback up/down change
 */
static void SWCTRL_Notify_PortLinkUp              (UI32_T ifindex);
static void SWCTRL_Notify_uPortLinkUp             (UI32_T unit, UI32_T port);
static void SWCTRL_Notify_uPortFastLinkUp         (UI32_T unit, UI32_T port);
static void SWCTRL_Notify_PortLinkDown            (UI32_T ifindex);
static void SWCTRL_Notify_uPortLinkDown           (UI32_T unit, UI32_T port);
static void SWCTRL_Notify_uPortFastLinkDown       (UI32_T unit, UI32_T port);
static void SWCTRL_Notify_PortOperUp              (UI32_T ifindex);
static void SWCTRL_Notify_PortNotOperUp           (UI32_T ifindex);
static void SWCTRL_Notify_TrunkMemberPortOperUp   (UI32_T trunk_ifindex, UI32_T trunk_member_port_ifindex);
static void SWCTRL_Notify_TrunkMemberPortNotOperUp(UI32_T trunk_ifindex, UI32_T trunk_member_port_ifindex);
static void SWCTRL_Notify_TrunkMemberActive(UI32_T trunk_ifindex,
                                            UI32_T trunk_member_port_ifindex);
static void SWCTRL_Notify_TrunkMemberInactive(UI32_T trunk_ifindex,
                                              UI32_T trunk_member_port_ifindex);

/* callback admin state change
 */
static void SWCTRL_Notify_PortAdminEnable         (UI32_T ifindex);
static void SWCTRL_Notify_uPortAdminEnable        (UI32_T unit, UI32_T port);
static void SWCTRL_Notify_PortAdminDisable        (UI32_T ifindex);
#if 0 /* obsolete, moved to cmgr */
#if (SYS_CPNT_LLDP == TRUE)
static void SWCTRL_Notify_PortAdminDisableBefore  (UI32_T ifindex);
#endif
#endif
static void SWCTRL_Notify_uPortAdminDisable       (UI32_T unit, UI32_T port);
static void SWCTRL_Notify_PortStatusChangedPassively(UI32_T ifindex, BOOL_T status, UI32_T changed_bmp);

/* callback operation mode change
 */
static void SWCTRL_Notify_PortSpeedDuplex         (UI32_T ifindex, UI32_T speed_duplex);
static void SWCTRL_Notify_uPortSpeedDuplex        (UI32_T unit, UI32_T port, UI32_T speed_duplex);
static void SWCTRL_Notify_uPortLacpEffectiveOperStatusChanged(UI32_T unit,       UI32_T port,
                                                              UI32_T pre_status, UI32_T current_status );
static void SWCTRL_Notify_uPortDot1xEffectiveOperStatusChanged(UI32_T unit,       UI32_T port,
                                                               UI32_T pre_status, UI32_T current_status );
static void SWCTRL_Notify_PortEffectiveOperStatusChanged(
    UI32_T ifindex,
    UI32_T pre_status,
    UI32_T current_status,
    SWCTRL_OperDormantLevel_T current_level,
    SWCTRL_OperDormantLevel_T target_level);

/* callback L3 trunk failover
 */
static void SWCTRL_Notify_ForwardingUPortAddToTrunk(UI32_T trunk_ifindex, UI32_T member_ifindex);
static void SWCTRL_Notify_ForwardingTrunkMemberDelete(UI32_T trunk_ifindex, UI32_T member_ifindex);
static void SWCTRL_Notify_ForwardingTrunkMemberToNonForwarding(UI32_T trunk_ifindex, UI32_T member_ifindex);

/* callback port learning status
 */
static void SWCTRL_Notify_PortLearningStatusChanged(UI32_T lport, BOOL_T learning);

/* Common setting user port function
 * Note: In these functions,
 *         I.   Perform SWCTRL_LOCK() and SWCTRL_UNLOCK().
 *         II.  Maintain database.
 *         III. Never perform SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME().
 */
static BOOL_T SWCTRL_SetUPortAutoNegEnable           (UI32_T unit, UI32_T port, UI32_T autoneg_state);
static BOOL_T SWCTRL_SetUPortAutoNegCapability       (UI32_T unit, UI32_T port, UI32_T capability);
#if (SYS_CPNT_SWCTRL_MDIX_CONFIG == TRUE)
static BOOL_T SWCTRL_SetUPortMDIXMode(UI32_T unit, UI32_T port, UI32_T mode);
#endif
static BOOL_T SWCTRL_SetUPortCfgFlowCtrlEnable       (UI32_T unit, UI32_T port, UI32_T flow_control_cfg);
static BOOL_T SWCTRL_SetUPortBStormControlRateLimit  (UI32_T unit, UI32_T port, UI32_T mode, UI32_T rate, UI32_T nRate);
static BOOL_T SWCTRL_SetUPortMStormControlRateLimit  (UI32_T unit, UI32_T port, UI32_T mode, UI32_T rate, UI32_T nRate);
static BOOL_T SWCTRL_SetUPortBroadcastStormStatus    (UI32_T unit, UI32_T port, UI32_T broadcast_storm_status);
static BOOL_T SWCTRL_SetUPortMulticastStormStatus    (UI32_T unit, UI32_T port, UI32_T multicast_storm_status);
#if (SYS_CPNT_STORM_MODE & SYS_CPNT_STORM_UNKNOWN_USTORM)
static BOOL_T SWCTRL_SetUPortUnknownUStormControlRateLimit(UI32_T unit, UI32_T port, UI32_T mode, UI32_T rate, UI32_T nRate);
static BOOL_T SWCTRL_SetUPortUnknownUnicastStormStatus(UI32_T unit, UI32_T port, UI32_T unknowunicast_storm_status);
#endif

#if (SYS_CPNT_INGRESS_RATELIMIT_BSTORM_MSTORM_XOR_EACH_OTHER == TRUE)
/* Aaron add new API mfor Marvell, 2006-06-06 */
static BOOL_T SWCTRL_DisableAllRateLimitAndStormsStatus(UI32_T ifindex);
#endif

#if (SYS_CPNT_SWCTRL_SINGLE_INGRESS_RATE_LIMIT == TRUE)
static BOOL_T SWCTRL_SyncRateLimitThreshold(UI32_T ifindex, UI32_T mode, UI32_T rate, UI32_T nRate, UI32_T rate_limit_group);
#if (SYS_CPNT_ATC_STORM == TRUE)
static void SWCTRL_SyncUPortATCStormControlRateLimit(UI32_T unit, UI32_T port);
#endif
#endif

static BOOL_T SWCTRL_SetUPortAdminStatus             (UI32_T unit, UI32_T port, UI32_T admin_status);
static BOOL_T SWCTRL_SetUPortCfgSpeedDuplex          (UI32_T unit, UI32_T port, UI32_T speed_duplex);

static BOOL_T SWCTRL_SetPortStatus_Local(UI32_T ifindex, BOOL_T status, UI32_T reason, BOOL_T is_forced);

static BOOL_T SWCTRL_LinkOperStateMachineChangeState (UI32_T ifindex, UI32_T event);
static BOOL_T SWCTRL_ProcessLinkOperStateMachine     (UI32_T ifindex, UI32_T event, UI32_T *old_state, UI32_T *new_state, UI32_T *old_level, UI32_T *new_level, BOOL_T lock);
static BOOL_T SWCTRL_ProcessLinkOperStateMachineForDormant(UI32_T ifindex, UI32_T event, UI32_T old_state, UI32_T *new_state, UI32_T old_level, UI32_T *new_level, UI32_T dormant_status);
static void   SWCTRL_ProcessLinkOperStatusChangeNotifying(UI32_T ifindex, UI32_T unit, UI32_T port, UI32_T event, UI32_T current_state, UI32_T next_state, UI32_T current_level, UI32_T next_level);
static void   SWCTRL_ProcessLinkOperStatusChangePostproc(UI32_T ifindex, UI32_T event, UI32_T current_state, UI32_T next_state, UI32_T current_level, UI32_T next_level, BOOL_T lock);
static void   SWCTRL_ProcessLinkOperStatusChangePostproc_ToOrFromTesting(UI32_T ifindex, UI32_T event, UI32_T current_state, UI32_T next_state);
static void   SWCTRL_ProcessLinkOperStatusChangePostproc_ForDormant(UI32_T ifindex, UI32_T event, UI32_T current_state, UI32_T next_state, UI32_T current_level, UI32_T next_level);
static UI32_T SWCTRL_CalculateTrunkOperStatus(UI32_T trunk_id);
#if (SYS_CPNT_SWCTRL_PORT_PENDING_LINK_UP == TRUE)
static void   SWCTRL_PortPendingLinkUpCheck(void *arg);
static void   SWCTRL_ProcessPortPendingLinkUp(UI32_T unit, UI32_T port);
#endif
static void   SWCTRL_MacCalculation                  (UI8_T *mac, UI32_T array_index, UI32_T added_value);
static void   SWCTRL_PrintDebugMsgIfOperStatusChanged(UI32_T ifindex, UI32_T state);
static BOOL_T SWCTRL_MirroringValidationCheck        (UI32_T ifindex_src, UI32_T ifindex_dest, UI32_T mirror_status);
static void   SWCTRL_SetServerBladePortFixAttributes (UI32_T unit, UI32_T port);
static BOOL_T SWCTRL_CheckUserPortJoinTrunkValidation(UI32_T trunk_id, SYS_TYPE_Uport_T unit_port, BOOL_T is_re_check, BOOL_T is_changed_to_active);
static void   SWCTRL_ConfigUserPortToDefaultState    (UI32_T unit, UI32_T port, UI32_T port_type, BOOL_T is_enter_master_mode);
static BOOL_T SWCTRL_LportListToActiveUportListEngine (UI32_T vid,
                                                       UI8_T  *lportlist,
                                                       UI8_T  active_uport_count_per_unit[SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK],
                                                       UI32_T *total_active_uport_count,
                                                       UI8_T  *uportlist);
#if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION == TRUE)
static void   SWCTRL_GetPrivateVlanPortList          (BOOL_T is_uplink, UI8_T port_list[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST]);
#endif
#if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION == TRUE || SYS_CPNT_ISOLATED_PRIVATE_VLAN==TRUE)
static SYS_TYPE_Uport_T    uplink_uport_list[SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK *
                                             SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT];
static SYS_TYPE_Uport_T    downlink_uport_list[SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK *
                                               SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT];
#endif
static BOOL_T SWCTRL_SetTrunkPorts                   (UI32_T trunk_id, UI32_T port_count, SYS_TYPE_Uport_T *port_member);
static BOOL_T SWCTRL_SetPortToActiveTrunkMember(UI32_T unit, UI32_T port, BOOL_T is_active_trunk_member);
static UI32_T SWCTRL_GetMaxSpeedDuplexFromActiveTrunkMember(UI32_T trunk_id);
static BOOL_T SWCTRL_GetTrunkPrimaryPort(UI32_T ifindex, UI32_T *primary_ifindex_p);
static BOOL_T SWCTRL_IsPortCfgSpeedDuplexSupported(UI32_T ifindex, UI32_T speed_duplex);
static BOOL_T SWCTRL_IsPortCfgFlowCtrlSupported(UI32_T ifindex, UI32_T flow_control_cfg);
static BOOL_T SWCTRL_IsPortAutoNegEnableSupported(UI32_T ifindex, UI32_T autoneg_state);
static BOOL_T SWCTRL_IsPortAutoNegCapabilitySupported(UI32_T ifindex, UI32_T capability);
#if (SYS_CPNT_SWCTRL_FEC == TRUE)
static BOOL_T SWCTRL_IsPortFecSupported(UI32_T ifindex, UI32_T fec_mode);
#endif
static void SWCTRL_UpdatePortSecurityActionTrapOperStatus(UI32_T ifindex);
#if 0 /* obsolete, use SWCTRL_SetPortPktTrapStatus(SWCTRL_PKTTYPE_INTRUDER) instead */
static BOOL_T SWCTRL_SetUPortSecurityActionStatus(UI32_T unit, UI32_T port, UI32_T action_status);
#endif
static BOOL_T SWCTRL_GetUPortMac(UI32_T unit, UI32_T port, UI8_T *mac);

static BOOL_T SWCTRL_SyncUPortMaxFrameSize(UI32_T unit, UI32_T port);
static BOOL_T SWCTRL_GetTrunkMaxFrameSize(UI32_T ifindex, UI32_T *untagged_max_frame_sz_p, UI32_T *tagged_max_frame_sz_p);

#if (SYS_CPNT_ALLOW_DUMMY_MIRRORING_DEST == TRUE)
static BOOL_T SWCTRL_DummyMirroringDestValidationCheck(UI32_T ifindex_dest);
#endif


#if (SYS_CPNT_MAU_MIB == TRUE)
static BOOL_T SWCTRL_GetActualIfMauEntry  (UI32_T media_type, SWCTRL_IfMauEntry_T *if_mau_entry);
static BOOL_T SWCTRL_GetDefaultIfMauEntry (UI32_T media_type, SWCTRL_IfMauEntry_T *if_mau_entry);
static BOOL_T SWCTRL_GetActualIfMauAutoNegEntry  (UI32_T media_type, SWCTRL_IfMauAutoNegEntry_T *if_mau_auto_neg_entry);
static BOOL_T SWCTRL_GetDefaultIfMauAutoNegEntry (UI32_T media_type, SWCTRL_IfMauAutoNegEntry_T *if_mau_auto_neg_entry);

static void SWCTRL_GetMauTypeByMediaTypeAndSpdDpx                   (UI32_T media_type, UI32_T speed_duplex, UI32_T *mau_type);
static void SWCTRL_GetPossibleMauTypeListBitsByMediaType            (UI32_T media_type, UI8_T *mau_type_list_bits);
static void SWCTRL_GetPossibleAutoNegCapBitsByMediaType             (UI32_T  media_type,UI32_T *capa_bits);
static void SWCTRL_GetAdvAutoNegCapBitsByMediaTypeAndCurrentCapBits (UI32_T  media_type, UI32_T currrnt_capa, UI32_T *adv_capa);
static void SWCTRL_AddBitIndexToByteArray                           (UI8_T *array, UI32_T array_size, UI32_T bit_index);
#endif

static BOOL_T SWCTRL_SetUPortLearningStatus(UI32_T unit, UI32_T port, BOOL_T learning, BOOL_T check_security_status);
static BOOL_T SWCTRL_SetPortLearningStatus_Local(UI32_T ifindex, BOOL_T learning, SWCTRL_LearningDisabledOwner_T owner);

#if (defined(ALLAYER_SWITCH) && (SYS_CPNT_DOT1X == TRUE))
static BOOL_T SWCTRL_EnableFilterAllIngressPacketAndTrapSpecialPacket(UI32_T ifindex);
#endif

#if (SYS_CPNT_TRUNK_MEMBER_AUTO_ATTRIBUTE == TRUE)
static BOOL_T SWCTRL_UserPortFollowTrunkAttributes(UI32_T uport_ifindex, UI32_T trunk_ifindex);
#endif

#if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION == TRUE)
static BOOL_T SWCTRL_SetPrivateVlan_(UI8_T uplink_port_list  [SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST],
                                     UI8_T downlink_port_list[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST]);
#endif

#if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION == TRUE)
#if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE == SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE_MULTIPLE_SESSION)
static BOOL_T SWCTRL_SetPrivateVlanBySessionId_(UI32_T session_id,
                                                UI8_T uplink_port_list  [SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST],
                                                UI8_T downlink_port_list[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST]);

static BOOL_T SWCTRL_DeletePrivateVlanPortlistBySessionId_(UI32_T session_id,
                                                           UI8_T uplink_port_list  [SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST],
                                                           UI8_T downlink_port_list[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST]);

static BOOL_T SWCTRL_IsOverlapPortlist(UI8_T user_port_list[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST],
                                       UI8_T org_port_list[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST]);

static BOOL_T SWCTRL_IsPrivateVlanMemberPort(UI8_T user_port_list[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST],
                                                  UI8_T session_port_list[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST]);

static BOOL_T SWCTRL_IsPermitPrivateVlanTrunkPort(UI32_T session_id,
                                                  UI8_T uplink_port_list[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST],
                                                  UI8_T downlink_port_list[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST]);

static BOOL_T SWCTRL_AddPrivateVlanTrunkPort(UI32_T trunk_ifindex);

#if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION == TRUE) && \
    (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE == SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE_MULTIPLE_SESSION) && \
    (SWCTRL_PORT_TRAFFIC_SEGMENTATION_AUTO_ATTRIBUTE != TRUE)
static BOOL_T SWCTRL_AddPrivateVlanTrunkMember(UI32_T trunk_ifindex, UI32_T port_ifindex);
#endif

static BOOL_T SWCTRL_DeletePrivateVlanTrunkPort(UI32_T trunk_ifindex);
static BOOL_T SWCTRL_DeletePrivateVlanTrunkMember(UI32_T trunk_ifindex, UI32_T port_ifindex);
#if (SWCTRL_PORT_TRAFFIC_SEGMENTATION_AUTO_ATTRIBUTE == TRUE)
static BOOL_T SWCTRL_PrivateVlanTrunkFollowUserPortAttributes(UI32_T trunk_ifindex, UI32_T tm_ifindex);
static BOOL_T SWCTRL_PrivateVlanUserPortFollowTrunkAttributes(UI32_T uport_ifindex, UI32_T trunk_ifindex);
#endif

#if (SWCTRL_PORT_TRAFFIC_SEGMENTATION_PORT_EGRESS_BLOCK == TRUE)
static BOOL_T SWCTRL_PortEgressBlock_EnableTrafficSegmatation();
static BOOL_T SWCTRL_PortEgressBlock_DisableTrafficSegmatation();
static BOOL_T SWCTRL_PortEgressBlock_SetPrivateVlanPortlistBySessionId(
    UI32_T session_id,
    UI8_T  *uplink_port_list,
    UI8_T  *downlink_port_list);
static BOOL_T SWCTRL_PortEgressBlock_DeletePrivateVlanPortlistBySessionId(
    UI32_T session_id,
    UI8_T  *uplink_port_list,
    UI8_T  *downlink_port_list);
static BOOL_T SWCTRL_PortEgressBlock_SetPrivateVlanUplinkToUplinkBlockingMode(
    BOOL_T enable);
static BOOL_T SWCTRL_PortEgressBlock_SetPrivateVlanTrunkMode(
    UI32_T session_id,
    UI32_T trunk_id,
    BOOL_T is_uplink,
    BOOL_T is_add);

#define SWDRV_SetPrivateVlanPortlistBySessionId(...) SWCTRL_PortEgressBlock_SetPrivateVlanPortlistBySessionId(__VA_ARGS__)
#define SWDRV_DeletePrivateVlanPortlistBySessionId(...) SWCTRL_PortEgressBlock_DeletePrivateVlanPortlistBySessionId(__VA_ARGS__)
#define SWDRV_EnablePrivateVlanUplinkToUplinkBlockingMode() SWCTRL_PortEgressBlock_SetPrivateVlanUplinkToUplinkBlockingMode(TRUE)
#define SWDRV_DisablePrivateVlanUplinkToUplinkBlockingMode() SWCTRL_PortEgressBlock_SetPrivateVlanUplinkToUplinkBlockingMode(FALSE)
#define SWDRV_SetPrivateVlanTrunkMode(...) SWCTRL_PortEgressBlock_SetPrivateVlanTrunkMode(__VA_ARGS__, TRUE)
#endif

#endif /* End of #if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE == SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE_MULTIPLE_SESSION)*/
#endif /* End of #if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION == TRUE) */

#if (SYS_CPNT_REFINE_ISC_MSG == TRUE)

static void SWCTRL_ConfigUserPortListToDefaultState(  UI32_T start_ifindex, UI32_T end_ifindex,BOOL_T is_enter_master_mode);
#endif

static void SWCTRL_PortEgressBlock_Lportlist_2_Uportlist(
    UI8_T lport_list[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST],
    UI8_T uport_list[SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK * SYS_ADPT_NBR_OF_BYTE_FOR_1BIT_UPORT_LIST]);
static BOOL_T SWCTRL_UpdateTrunkEgressBlock(UI32_T trunk_ifindex);
static BOOL_T SWCTRL_SetPortEgressBlock_Local(
    UI32_T lport,
    UI8_T egr_blk_lport_list[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST]);

/*DanXie add for mirror show*/
void SWCTRL_InitPortMirrorList(UI32_T index);
BOOL_T SWCTRL_SetPortToMirrorList(SWCTRL_MIRROR_MTP_T *port_info);
BOOL_T SWCTRL_DelPortFromMirrorList(SWCTRL_MIRROR_MTP_T *port_info);
static int SWCTRL_SortCompMirrorInfo(void *inlist_element, void *input_element);
BOOL_T SWCTRL_GetMirrorNodeIndex(UI32_T dst_port, UI32_T index,UI32_T *got_index,UI32_T *reason);
BOOL_T SWCTRL_GetNextPortFromMirrorNode(UI32_T index, UI32_T src_port, SWCTRL_MIRROR_MTP_T *get_data);
static void SWCTRL_HandleHotRemoval_ForPortMirroring(UI32_T starting_port_ifindex, UI32_T number_of_port);

static BOOL_T SWCTRL_IsSupportedStormType(UI32_T mode);
static BOOL_T SWCTRL_ConvertRateByStormType(UI32_T ifindex, UI32_T in_mode, UI32_T in_rate, UI32_T out_mode, UI32_T *out_rate_p);
#if 0 /* wakka: this API may be used for rate conversion in the future. */
static BOOL_T SWCTRL_AutoConvertRateWithStormType(UI32_T ifindex, UI32_T in_mode, UI32_T in_rate, UI32_T *out_mode_p, UI32_T *out_rate_p);
#endif



#if (SYS_CPNT_INTERNAL_LOOPBACK_TEST == TRUE)
typedef struct
{
    UI32_T result;
    UI32_T time;
}SWCTRL_InternalLoopbackResult_T;

static SWCTRL_InternalLoopbackResult_T loopback_result[SYS_ADPT_TOTAL_NBR_OF_LPORT + 1];
static UI32_T loopback_lport = 0;
static UI32_T resp_thread_id = 0;
#endif

#if (SYS_CPNT_INGRESS_RATE_LIMIT == TRUE) || (SYS_CPNT_EGRESS_RATE_LIMIT == TRUE)
static BOOL_T SWCTRL_CheckRateLimitRange(UI32_T port_type, UI32_T rate);
static UI32_T SWCTRL_ConvertUserRateLimitToPhy(UI32_T port_type, UI32_T rate);
static UI32_T SWCTRL_GetDefaultRateLimit(UI32_T port_type);
#endif

#if (SYS_CPNT_INGRESS_RATE_LIMIT == TRUE)
    #if (SYS_CPNT_NETACCESS_DYNAMIC_QOS == TRUE)
    static BOOL_T SWCTRL_LocalSetDynamicPortIngressRateLimit(UI32_T ifindex, UI32_T rate);
    #endif
#endif

#if (SYS_CPNT_SWCTRL_COMBO_PORT_CONFIG_KEEP==TRUE)
static void SWCTRL_ReInitPhyComboPortChanged(UI32_T unit, UI32_T port, UI32_T port_type);
static BOOL_T SWCTRL_IsComboPort(UI32_T unit, UI32_T port);
static void SWCTRL_ReInitCfgComboPortChanged(UI32_T unit, UI32_T port);
#if (SYS_CPNT_COMBO_PORT_FORCE_MODE == TRUE)
static void SWCTRL_ReInitPortComboForcedMode(UI32_T unit, UI32_T port);
#endif
#endif

#if (SYS_CPNT_POWER_SAVE == TRUE)
static BOOL_T SWCTRL_SetUPortPowerSave(UI32_T unit, UI32_T port, UI32_T status, BOOL_T is_forced);
static BOOL_T SWCTRL_ProcessPortLinkDownForPowerSave(UI32_T ifindex);
static BOOL_T SWCTRL_IsPortPowerSaveSupported(UI32_T ifindex);
#endif /* (SYS_CPNT_POWER_SAVE == TRUE) */

static BOOL_T SWCTRL_SetUPortPktTrapStatus(UI32_T unit, UI32_T port, SWCTRL_PktType_T pkt_type, BOOL_T to_cpu, BOOL_T drop);
static BOOL_T SWCTRL_SetPortPktTrapStatus_Local(UI32_T ifindex, SWCTRL_PktType_T pkt_type, SWCTRL_TrapPktOwner_T owner, BOOL_T to_cpu, BOOL_T drop);

#if (SWCTRL_UPDATE_PORT_ABILITY == TRUE)
static BOOL_T SWCTRL_GetPortAbilityFromDrv(UI32_T unit, UI32_T port, SWCTRL_PortAbility_T *ability_p);
static BOOL_T SWCTRL_UpdatePortAbility(UI32_T unit, UI32_T port);
static void SWCTRL_GetPortComboForcedModeDfltCfg(UI32_T unit, UI32_T port, UI32_T *forcedmode_p, UI32_T *fiber_speed_p);
static UI32_T SWCTRL_GetPortOptimumOperSpeedDuplex(UI32_T unit, UI32_T port);
static UI32_T SWCTRL_GetPortCfgSpeedDuplexDfltCfg(UI32_T unit, UI32_T port);
static UI32_T SWCTRL_GetPortCfgFlowCtrlDfltCfg(UI32_T unit, UI32_T port);
static UI32_T SWCTRL_GetPortAutoNegCapabilityDfltCfg(UI32_T unit, UI32_T port);
static UI32_T SWCTRL_GetPortAutoNegStatusDfltCfg(UI32_T unit, UI32_T port);
#if (SYS_CPNT_SWCTRL_FEC == TRUE)
static UI32_T SWCTRL_GetPortFecDfltCfg(UI32_T unit, UI32_T port);
#endif
#endif
static void SWCTRL_GetPortAbilityByPortType(UI32_T unit, UI32_T port, SWCTRL_PortAbility_T *ability_p);
static void SWCTRL_SendPortSfpDdmTrap(UI32_T unit, UI32_T sfp_index, UI32_T trap_type);

/* EXPORTED SUBPROGRAM SPECIFICATIONS
 */
/****************************************************************************/
/* Switch Initialization                                                    */
/****************************************************************************/

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_Init
 * -------------------------------------------------------------------------
 * FUNCTION: This function allocates and initiates the system resource for
 *           Switch Control module
 * INPUT   : None
 * OUTPUT  : None
 * RETURN  : None
 * NOTE    : None
 * -------------------------------------------------------------------------*/
void SWCTRL_Init(void)
{
    /* Create semaphore
     */
    if(SYSFUN_OK!=SYSFUN_CreateSem(SYSFUN_SEMKEY_PRIVATE, 1, SYSFUN_SEM_FIFO, &swctrl_semaphore_id))
    {
        SYSFUN_Debug_Printf ("\r\n SWCTL: Create semaphore failed. LOCK");
        while (1)
            ;
    }
    #if 0
    if(SYSFUN_OK!=SYSFUN_GetSem(SYS_BLD_SYS_SEMAPHORE_KEY_OM,&swctrl_semaphore_id))
    {
        SYSFUN_Debug_Printf ("\r\n SWCTL: Create semaphore failed. LOCK");
        while (1)
            ;
    }
    #endif

    /* init call back funtion pointers
     */
    PortTypeChanged_callbacklist          = 0;
    uPortTypeChanged_callbacklist         = 0;
    TrunkMemberAdd1st_callbacklist        = 0;
    TrunkMemberAdd_callbacklist           = 0;
    TrunkMemberDelete_callbacklist        = 0;
    TrunkMemberDeleteLst_callbacklist     = 0;
    PortLinkUp_callbacklist               = 0;
    uPortLinkUp_callbacklist              = 0;
    uPortFastLinkUp_callbacklist          = 0;
    PortLinkDown_callbacklist             = 0;
    uPortLinkDown_callbacklist            = 0;
    uPortFastLinkDown_callbacklist        = 0;
    PortOperUp_callbacklist               = 0;
    PortNotOperUp_callbacklist            = 0;
    TrunkMemberPortOperUp_callbacklist    = 0;
    TrunkMemberPortNotOperUp_callbacklist = 0;
    PortAdminEnable_callbacklist          = 0;
    uPortAdminEnable_callbacklist         = 0;
    PortAdminDisable_callbacklist         = 0;
#if (SYS_CPNT_LLDP == TRUE)
    PortAdminDisableBefore_callbacklist   = 0;
#endif
    uPortAdminDisable_callbacklist        = 0;
    PortSpeedDuplex_callbacklist          = 0;
    uPortSpeedDuplex_callbacklist         = 0;
    uPortLacpEffectiveOperStatusChanged_callbacklist  = 0;
    uPortDot1xEffectiveOperStatusChanged_callbacklist = 0;
    ForwardingUPortAddToTrunk_callbacklist              = 0;
    ForwardingTrunkMemberToNonForwarding_callbacklist   = 0;
    ForwardingTrunkMemberDelete_callbacklist            = 0;

    /* These are default value table, init here and never be changed.
     */
    /* default Egress Scheduler Mode
     */
    default_egress_scheduler_mode = SWCTRL_WEIGHT_ROUND_ROBIN_METHOD;

    /* defalut WRR queue initialize
     */
    wrr_queue_default[0]=SYS_DFLT_WRR_Q0_WEIGHT;
    wrr_queue_default[1]=SYS_DFLT_WRR_Q1_WEIGHT;
    wrr_queue_default[2]=SYS_DFLT_WRR_Q2_WEIGHT;
    wrr_queue_default[3]=SYS_DFLT_WRR_Q3_WEIGHT;

#if (SYS_ADPT_MAX_NBR_OF_PRIORITY_QUEUE > 4)
    wrr_queue_default[4]=SYS_DFLT_WRR_Q4_WEIGHT;
    wrr_queue_default[5]=SYS_DFLT_WRR_Q5_WEIGHT;
    wrr_queue_default[6]=SYS_DFLT_WRR_Q6_WEIGHT;
    wrr_queue_default[7]=SYS_DFLT_WRR_Q7_WEIGHT;
#endif
    SWCTRL_BACKDOOR_Init();

    return;
} /* End of SWCTRL_Init() */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_Create_InterCSC_Relation
 * -------------------------------------------------------------------------
 * FUNCTION: This function initializes all function pointer registration operations.
 * INPUT   : None
 * OUTPUT  : None
 * RETURN  : None
 * NOTE    : None
 * -------------------------------------------------------------------------*/
void SWCTRL_Create_InterCSC_Relation(void)
{
    SWCTRL_BACKDOOR_Create_InterCSC_Relation();
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetTransitionMode
 * -------------------------------------------------------------------------
 * FUNCTION: This function set transition mode flag
 * INPUT   : None
 * OUTPUT  : None
 * RETURN  : None
 * NOTE    : None
 * -------------------------------------------------------------------------*/
void SWCTRL_SetTransitionMode(void)
{
    /* set transition flag to prevent calling request
     */
    SYSFUN_SET_TRANSITION_MODE();

}   /*  end of DHCP_MGR_SetTransitionMode   */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_EnterTransitionMode
 * -------------------------------------------------------------------------
 * FUNCTION: This function will initialize the Switch Control module and
 *           free all resource to enter transition mode while stacking
 * INPUT   : None
 * OUTPUT  : None
 * RETURN  : None
 * NOTE    : None
 * -------------------------------------------------------------------------*/
void SWCTRL_EnterTransitionMode(void)
{
    UI32_T  ifindex;
    /* update operation mode variable
     */
    SYSFUN_ENTER_TRANSITION_MODE();

    is_provision_complete = FALSE;

    for(ifindex =  SYS_ADPT_ETHER_1_IF_INDEX_NUMBER;
        ifindex <= SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK*SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT;
        ifindex ++)
    {
        memset(&port_info[ifindex-1], 0, sizeof(SWCTRL_PortInfo_T));
    }

    /* SWDRV will disable all local ports admin state by itself
     * wehn SWDRV enter transition mode, so it's not necessary
     * to this here
     */
    /*SWDRV_DisableAllPortAdmin(LOCAL_HOST);
     */

    memset(swctrl_pkt_trap_status, 0, sizeof(swctrl_pkt_trap_status));
    memset(swctrl_pkt_drop_status, 0, sizeof(swctrl_pkt_drop_status));
    memset(swctrl_pkt_trap_status_per_port, 0, sizeof(swctrl_pkt_trap_status_per_port));
    memset(swctrl_pkt_drop_status_per_port, 0, sizeof(swctrl_pkt_drop_status_per_port));
    memset(swctrl_pkt_cpu_rate, 0, sizeof(swctrl_pkt_cpu_rate));
} /* End of SWCTRL_EnterTransitionMode() */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_EnterMasterMode
 * -------------------------------------------------------------------------
 * FUNCTION: This function will configurate the Switch Control module to
 *           enter master mode after stacking
 * INPUT   : None
 * OUTPUT  : None
 * RETURN  : None
 * NOTE    : This function must be invoked first before
 *           STA_Enter_Master_Mode() is called.
 * -------------------------------------------------------------------------*/
void SWCTRL_EnterMasterMode(void)
{
    UI32_T ifindex,index=0;
    UI32_T *port_type_list;
    UI32_T unit;

#if (SYS_CPNT_3COM_LOOPBACK_TEST == TRUE)
    UI8_T  test_result[SYS_ADPT_NBR_OF_BYTE_FOR_1BIT_UPORT_LIST*SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK];
#endif

    /* update operation mode variable
     */
    SYSFUN_ENTER_MASTER_MODE();
    SWCTRL_OM_ResetAll();

    /* re-numbering: init the re-numbering mapping table.
     * CLI maybe not set the MAC address table to SWCTRL, i.e. default setting
     * In the case of default setting, the mapping is i to i, for i belong to all units.
     */
    for(unit=0; unit<SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK; unit++)
    {
        re_numbering_mapping_table[unit] = unit+1;
    }

    /* device type checking: init the device type mapping table.
     * CLI maybe not set the device type mapping table to SWCTRL, i.e. default setting
     * In the case of default setting, the mapping is the same as current TPLG.
     */
    for(unit=0; unit<SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK; unit++)
    {
        device_type_validation_table[unit] = TRUE;
    }

    /* system information initialization
     */
    system_info.is_private_vlan_enable       = SYS_DFLT_PRIVATE_VLAN_STATUS;
    system_info.jumbo_frame_status           = SYS_DFLT_JUMBO_FRAME_STATUS;

#if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION == TRUE)
#if (SWCTRL_PORT_TRAFFIC_SEGMENTATION_PORT_EGRESS_BLOCK != TRUE)
    /* private vlan
     */
    if (system_info.is_private_vlan_enable == TRUE)
    {
        SWDRV_EnableTrafficSegmatation();
    }
    else
    {
        SWDRV_DisableTrafficSegmatation();
    }
#endif
#endif

#if (SYS_CPNT_JUMBO_FRAMES == TRUE)
    /* jumbo frame
     */
    if (system_info.jumbo_frame_status == SWCTRL_JUMBO_FRAME_ENABLE)
    {
        SWDRV_EnableJumboFrame();
    }
    else
    {
        SWDRV_DisableJumboFrame();
    }
#endif

    system_info.trunk_balance_mode = SYS_DFLT_TRUNK_BALANCE_MODE;

#if (SYS_CPNT_SWCTRL_GLOBAL_STORM_SAMPLE_TYPE == TRUE)
    swctrl_global_storm_sample_type = SYS_DFLT_SWCTRL_GLOBAL_STORM_SAMPLE_TYPE;
#endif

    /* config trunk load balance
     */
    SWDRV_SetTrunkBalanceMode(system_info.trunk_balance_mode);

    /* clean up database of callback processor
     */
    memset(user_port_changed_info, 0, sizeof(user_port_changed_info));

    /* port information initialization
     */
    /* user port
     */
    if (NULL == (port_type_list = calloc(SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK*SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT,
                                         sizeof(UI32_T))))
    {
        printf("SWCTRL: Failed to allocate memory for get port type list.\r\n");
        assert(0);
    }

    if (FALSE == SWDRV_GetPortTypeList(port_type_list))
    {
        printf("SWCTRL: Failed to get port type list.\r\n");
        assert(0);
    }

    /* collect loopback test result from SWDRV, and wait to be used
     */
#if (SYS_CPNT_3COM_LOOPBACK_TEST == TRUE)
    memset(test_result, 0, sizeof(test_result));
    if( FALSE == SWDRV_GetPortLoopbackTestResult(test_result))
    {
        printf("Failed to get loopback test result from SWDRV\r\n");
    }
#endif

    for(ifindex =  SYS_ADPT_ETHER_1_IF_INDEX_NUMBER;
        ifindex <= SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK*SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT;
        ifindex ++)
    {

        UI32_T unit, port;

        unit = SWCTRL_IFINDEX_TO_UNIT(ifindex);
        port = SWCTRL_IFINDEX_TO_PORT(ifindex);

        /* clean up database.
         */
        memset(&port_info[ifindex-1], 0, sizeof(port_info[ifindex-1]));

        /* port_index
         */
        port_info[ifindex-1].port_entry.port_index                 = ifindex;
        port_info[ifindex-1].bcast_storm_entry.bcast_storm_ifindex = ifindex;
        port_info[ifindex-1].mcast_storm_entry.mcast_storm_ifindex = ifindex;
#if (SYS_CPNT_STORM_MODE & SYS_CPNT_STORM_UNKNOWN_USTORM)
        port_info[ifindex-1].unknown_ucast_storm_entry.unknown_ucast_storm_ifindex = ifindex;
#endif

#if (SYS_CPNT_ATC_BSTORM == TRUE)
        port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_ifindex = ifindex;
#endif
#if (SYS_CPNT_ATC_MSTORM == TRUE)
        port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_ifindex = ifindex;
#endif
        /* port_type & link_oper_status
         */
        port_info[ifindex-1].port_entry.port_type = port_type_list[ifindex-1];

        port_info[ifindex-1].port_entry.port_mtu=SYS_DFLT_PORT_MTU;

       /*SYSTEM MTU AND JUMBO MTU*/
        system_info.mtu = SYS_DFLT_PORT_MTU;
        system_info.jumbo_mtu = SYS_DFLT_PORT_MTU;

        if (STKTPLG_PORT_TYPE_STACKING == port_info[ifindex-1].port_entry.port_type  ||
            STKTPLG_PORT_TYPE_NOT_EXIST == port_info[ifindex-1].port_entry.port_type )
        {
            port_info[ifindex-1].link_oper_status = VAL_ifOperStatus_notPresent;
            continue;
        }
        else
        {
            port_info[ifindex-1].link_oper_status = VAL_ifOperStatus_lowerLayerDown;
        }

#if (SYS_CPNT_3COM_LOOPBACK_TEST == TRUE)
        /* set database about loopback test result
         */
        if (test_result[SWCTRL_BYTE_IN_BITMAP(ifindex)]& SWCTRL_BIT_IN_BITMAP(ifindex))
        {
            /* loopback test failed port
             */
            user_ext_port_info[ifindex-1].is_loopback_test_failed = TRUE;
        }
        else
        {
            /* loopback test passed port
             */
            user_ext_port_info[ifindex-1].is_loopback_test_failed = FALSE;
        }
#endif

        #if (SYS_CPNT_SUPPORT_COMBO_PORT_NO_NEG_KEEP == TRUE)
        port_info[ifindex-1].port_entry.port_combo_copper_speed_dpx_cfg = SYS_DFLT_GE_COPPER_PORT_FORCE_MODE_SPDDPX;
        port_info[ifindex-1].port_entry.port_combo_fiber_speed_dpx_cfg = SYS_DFLT_GE_FIBER_PORT_FORCE_MODE_SPDDPX;
        port_info[ifindex-1].port_entry.port_speed_dpx_cfg = SYS_DFLT_GE_COPPER_PORT_FORCE_MODE_SPDDPX;
        #endif
        port_info[ifindex-1].port_entry.port_mtu=SYS_DFLT_PORT_MTU;

        /* config the user port to default state
         */
   #if (SYS_CPNT_REFINE_ISC_MSG != TRUE)
        SWCTRL_ConfigUserPortToDefaultState(unit, port, port_info[ifindex-1].port_entry.port_type, TRUE);
  #endif

#if (SYS_CPNT_SWCTRL_SWITCH_MODE_CONFIGURABLE == TRUE)
        port_info[ifindex-1].port_entry.switch_mode=SYS_DFLT_SWCTRL_SWITCH_MODE;
#endif
    } /* End of if (user port) */
 #if (SYS_CPNT_REFINE_ISC_MSG == TRUE)
    SWCTRL_ConfigUserPortListToDefaultState( SYS_ADPT_ETHER_1_IF_INDEX_NUMBER,
        SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK*SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT,TRUE);
 #endif
    free(port_type_list);
#if (SYS_CPNT_ATC_BSTORM == TRUE)
    atc_broadcast_storm_timer.atc_broadcast_storm_traffic_control_on_timer = SYS_DFLT_ATC_BSTORM_TC_ON_TIMER;
    atc_broadcast_storm_timer.atc_broadcast_storm_traffic_control_release_timer = SYS_DFLT_ATC_BSTORM_TC_RELEASE_TIMER;
#endif

#if (SYS_CPNT_ATC_MSTORM == TRUE)
    atc_multicast_storm_timer.atc_multicast_storm_traffic_control_on_timer = SYS_DFLT_ATC_MSTORM_TC_ON_TIMER;
    atc_multicast_storm_timer.atc_multicast_storm_traffic_control_release_timer = SYS_DFLT_ATC_MSTORM_TC_RELEASE_TIMER;
#endif

    /* trunk port information initialization
     */
    for(ifindex = SYS_ADPT_TRUNK_1_IF_INDEX_NUMBER;
        ifindex < SYS_ADPT_TRUNK_1_IF_INDEX_NUMBER+SYS_ADPT_MAX_NBR_OF_TRUNK_PER_SYSTEM;
        ifindex ++)
    {
        port_info[ifindex-1].link_oper_status = VAL_ifOperStatus_notPresent;

        port_info[ifindex-1].port_entry.port_index                 = ifindex;
        port_info[ifindex-1].bcast_storm_entry.bcast_storm_ifindex = ifindex;
        port_info[ifindex-1].mcast_storm_entry.mcast_storm_ifindex = ifindex;
#if (SYS_CPNT_STORM_MODE & SYS_CPNT_STORM_UNKNOWN_USTORM)
        port_info[ifindex-1].unknown_ucast_storm_entry.unknown_ucast_storm_ifindex = ifindex;
#endif

        #if (SYS_CPNT_SUPPORT_COMBO_PORT_NO_NEG_KEEP == TRUE)
        port_info[ifindex-1].port_entry.port_combo_copper_speed_dpx_cfg = SYS_DFLT_GE_COPPER_PORT_FORCE_MODE_SPDDPX;
        port_info[ifindex-1].port_entry.port_combo_fiber_speed_dpx_cfg = SYS_DFLT_GE_FIBER_PORT_FORCE_MODE_SPDDPX;
        port_info[ifindex-1].port_entry.port_speed_dpx_cfg = SYS_DFLT_GE_COPPER_PORT_FORCE_MODE_SPDDPX;
        #endif

        port_info[ifindex-1].port_entry.port_mtu=SYS_DFLT_PORT_MTU;

        trunk_ext_port_info[SWCTRL_IFINDEX_TO_TRUNKID(ifindex)-1].member_number    = 0;
        trunk_ext_port_info[SWCTRL_IFINDEX_TO_TRUNKID(ifindex)-1].is_static        = TRUE;
#ifdef SYS_ADPT_MAX_NBR_OF_ACTIVE_PORT_PER_TRUNK
        trunk_ext_port_info[SWCTRL_IFINDEX_TO_TRUNKID(ifindex)-1].max_num_of_active_ports = SYS_ADPT_MAX_NBR_OF_ACTIVE_PORT_PER_TRUNK;
#else
        trunk_ext_port_info[SWCTRL_IFINDEX_TO_TRUNKID(ifindex)-1].max_num_of_active_ports = SYS_ADPT_MAX_NBR_OF_PORT_PER_TRUNK;
#endif
    }

#if ((SYS_CPNT_SWCTRL_CABLE_DIAG == TRUE) && (SYS_CPNT_SWCTRL_CABLE_DIAG_CHIP == SYS_CPNT_SWCTRL_CABLE_DIAG_BROADCOM))
    /* Cable Diag database initialization */
    for(ifindex =  SYS_ADPT_ETHER_1_IF_INDEX_NUMBER;
        ifindex <= SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK*SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT;
        ifindex ++)
    {
        memset(&cable_info[ifindex-1], 0, sizeof(SWCTRL_Cable_Info_T));
        cable_info[ifindex-1].cable_status =  CABLE_NOT_TESTED_YET;
        cable_info[ifindex-1].pair_state[0] = cable_info[ifindex-1].pair_state[1] = cable_info[ifindex-1].pair_state[2] = cable_info[ifindex-1].pair_state[3] = CABLE_NOT_TESTED_YET;
    }
#endif    /* #if (SYS_CPNT_SWCTRL_CABLE_DIAG == TRUE) */

#if (SYS_CPNT_INTERNAL_LOOPBACK_TEST == TRUE)

    loopback_lport = 0;

    for(ifindex  = 0; ifindex <= SYS_ADPT_TOTAL_NBR_OF_LPORT ; ifindex ++)
    {
        loopback_result[ifindex].result = VAL_loopInternalResultStatus_notTestedYet;
        loopback_result[ifindex].time = 0;
    }

    resp_thread_id = 0;

#endif


    /*DanXie, add for mirror show*/
    for(index=0;index < SYS_ADPT_MAX_NBR_OF_MIRROR_PORT;index++)
    {
        SWCTRL_InitPortMirrorList(index);
    }

#if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION == TRUE)
#if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE == SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE_MULTIPLE_SESSION)
{
    UI32_T group_index, lport_index, trunk_index;

    /* default private vlan extend database */
    for (group_index=1; group_index<=SYS_ADPT_PORT_TRAFFIC_SEGMENTATION_MAX_NBR_OF_SESSIONS; group_index++)
    {
        memset(&swctl_private_vlan_ext_info[group_index-1], 0, sizeof(swctl_private_vlan_ext_info[group_index-1]));
        swctl_private_vlan_ext_info[group_index-1].session_id = group_index;
        swctl_private_vlan_ext_info[group_index-1].is_valid   = FALSE;
    }

     /* default private vlan port database */
    for (lport_index=0; lport_index<SYS_ADPT_TOTAL_NBR_OF_LPORT; lport_index++)
    {
        memset(&swctl_private_vlan_port_info[lport_index], 0, sizeof(swctl_private_vlan_port_info[lport_index]));
        swctl_private_vlan_port_info[lport_index].port_index = lport_index+1;
        swctl_private_vlan_port_info[lport_index].dev_id     = 0x0;
        swctl_private_vlan_port_info[lport_index].session_id = 0x0;
        swctl_private_vlan_port_info[lport_index].port_trunk_index = 0x0;
        swctl_private_vlan_port_info[lport_index].private_vlan_uplink_port   = FALSE;
        swctl_private_vlan_port_info[lport_index].private_vlan_downlink_port = FALSE;
        swctl_private_vlan_port_info[lport_index].is_pvlan_trunk_index_port  = FALSE;
    }

    /* default private vlan trunk port database */
    for (trunk_index=0; trunk_index<SYS_ADPT_MAX_NBR_OF_TRUNK_PER_SYSTEM; trunk_index++)
    {
        memset(&swctl_private_vlan_trunk_port_info[trunk_index], 0,
                sizeof(swctl_private_vlan_trunk_port_info[trunk_index]));
        swctl_private_vlan_trunk_port_info[trunk_index].trunk_index = trunk_index+1;
        swctl_private_vlan_trunk_port_info[trunk_index].session_id  = 0x0;
    }

    /* set system default uplink-to-uplink mode (blocking or forwarding */
    system_info.is_blocking_uplink_to_uplink_mode  = SYS_DFLT_TRAFFIC_SEG_UPLINK_TO_UPLINK_MODE;

    switch (system_info.is_blocking_uplink_to_uplink_mode)
    {
        case SYS_DFLT_TRAFFIC_SEG_UPLINK_TO_UPLINK_MODE_BLOCKING:
            SWDRV_EnablePrivateVlanUplinkToUplinkBlockingMode();
            break;
        case SYS_DFLT_TRAFFIC_SEG_UPLINK_TO_UPLINK_MODE_FORWARDING:
            SWDRV_DisablePrivateVlanUplinkToUplinkBlockingMode();
            break;
    }
}
#endif /* End of #if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE == SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE_MULTIPLE_SESSION)*/
#endif /* End of #if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION == TRUE) */

    SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME ();

} /* End of SWCTRL_EnterMasterMode() */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_EnterSlaveMode
 * -------------------------------------------------------------------------
 * FUNCTION: This function will disable the Switch Control services and
 *           enter slave mode after stacking
 * INPUT   : None
 * OUTPUT  : None
 * RETURN  : None
 * NOTE    : None
 * -------------------------------------------------------------------------*/
void SWCTRL_EnterSlaveMode(void)
{
    /* update operation mode variable
     */
    SYSFUN_ENTER_SLAVE_MODE();

    SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME ();

    /* TODO: send local information to master */
} /* End of SWCTRL_EnterSlaveMode() */


/*-------------------------------------------------------------------------
 * FUNCTION NAME: SWCTRL_HandleHotInsertion
 * PURPOSE  : This function will initialize the port OM of the module ports
 *            when the option module is inserted.
 * INPUT    : starting_port_ifindex -- the ifindex of the first module port
 *                                     inserted
 *            number_of_port        -- the number of ports on the inserted
 *                                     module
 *            use_default           -- the flag indicating the default
 *                                     configuration is used without further
 *                                     provision applied; TRUE if a new module
 *                                     different from the original one is
 *                                     inserted
 * OUTPUT   : None
 * RETURN   : None
 * NOTE     : Only one module is inserted at a time.

 * -------------------------------------------------------------------------*/
void SWCTRL_HandleHotInsertion(UI32_T starting_port_ifindex, UI32_T number_of_port, BOOL_T use_default)
{
    UI32_T unit;
    UI32_T port;
    UI32_T ifindex;
    UI32_T port_type;
    UI32_T trunik_ifindex;

    SWCTRL_LOCK();
#if ((SYS_HWCFG_SUPPORT_PD==TRUE) && (SYS_CPNT_SWDRV_ONLY_ALLOW_PD_PORT_LINKUP_WITH_PSE_PORT==TRUE))
    SWDRV_SetPSECheckStatus(SWCTRL_OM_GetPSECheckStatus());
#endif

#if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION == TRUE)
#if (SWCTRL_PORT_TRAFFIC_SEGMENTATION_PORT_EGRESS_BLOCK != TRUE)
    /* private vlan
     */
    if (system_info.is_private_vlan_enable == TRUE)
    {
        SWDRV_EnableTrafficSegmatation();
    }
    else
    {
        SWDRV_DisableTrafficSegmatation();
    }
#endif
#endif

#if (SYS_CPNT_JUMBO_FRAMES == TRUE)
    /* jumbo frame
     */
    if (system_info.jumbo_frame_status == SWCTRL_JUMBO_FRAME_ENABLE)
    {
        SWDRV_EnableJumboFrame();
    }
    else
    {
        SWDRV_DisableJumboFrame();
    }
#endif

    /* create trunk
     */
    for (trunik_ifindex =SYS_ADPT_TRUNK_1_IF_INDEX_NUMBER;
         trunik_ifindex<=SYS_ADPT_TRUNK_1_IF_INDEX_NUMBER+SYS_ADPT_MAX_NBR_OF_TRUNK_PER_SYSTEM-1;
         trunik_ifindex++)
    {
        if (port_info[trunik_ifindex-1].link_oper_status != VAL_ifOperStatus_notPresent)
        {
            SWDRV_CreateTrunk(SWCTRL_IFINDEX_TO_TRUNKID(trunik_ifindex));

            if(port_info[trunik_ifindex-1].link_oper_status == VAL_ifOperStatus_up)
            {
              SWCTRL_SetTrunkPorts(trunik_ifindex - SYS_ADPT_TRUNK_1_IF_INDEX_NUMBER +1,
                                   trunk_ext_port_info[trunik_ifindex - SYS_ADPT_TRUNK_1_IF_INDEX_NUMBER].member_number,
                                   trunk_ext_port_info[trunik_ifindex - SYS_ADPT_TRUNK_1_IF_INDEX_NUMBER].member_list );
            }
        }
    }

    /* config trunk load balance
     */
    SWDRV_SetTrunkBalanceMode(system_info.trunk_balance_mode);

    SWCTRL_UNLOCK();

    /* setting per-port config
     */
    for(ifindex = starting_port_ifindex;
        ifindex<= starting_port_ifindex+number_of_port-1;
        ifindex++ )
    {
        unit = SWCTRL_IFINDEX_TO_UNIT(ifindex);
        port = SWCTRL_IFINDEX_TO_PORT(ifindex);

        if (TRUE == SWDRV_GetPortType(unit, port, &port_type))
        {
            SWCTRL_LOCK();
            memset(&port_info[ifindex-1], 0, sizeof(port_info[ifindex-1]));

#if (SYS_CPNT_3COM_LOOPBACK_TEST == TRUE)
            user_ext_port_info[ifindex-1].is_loopback_test_failed = FALSE;
#endif

            /* port_index
             */
            port_info[ifindex-1].port_entry.port_index                 = ifindex;
            port_info[ifindex-1].bcast_storm_entry.bcast_storm_ifindex = ifindex;
#if (SYS_CPNT_ATC_BSTORM == TRUE)
            port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_ifindex = ifindex;
#endif
#if (SYS_CPNT_ATC_MSTORM == TRUE)
            port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_ifindex = ifindex;
#endif

            /* port_type & link_oper_status
             */
            port_info[ifindex-1].port_entry.port_type = port_type;

            /* port_index         */
            port_info[ifindex-1].mcast_storm_entry.mcast_storm_ifindex = ifindex;

            /* port_type & link_oper_status         */
            port_info[ifindex-1].port_entry.port_mtu=SYS_DFLT_PORT_MTU;

            if (STKTPLG_PORT_TYPE_STACKING == port_info[ifindex-1].port_entry.port_type  ||
                STKTPLG_PORT_TYPE_NOT_EXIST == port_info[ifindex-1].port_entry.port_type )
            {
                port_info[ifindex-1].link_oper_status = VAL_ifOperStatus_notPresent;
                SWCTRL_UNLOCK();
                continue;
            }
            else
            {
                port_info[ifindex-1].link_oper_status = VAL_ifOperStatus_lowerLayerDown;
            }

#if (SYS_CPNT_SUPPORT_COMBO_PORT_NO_NEG_KEEP == TRUE)
           port_info[ifindex-1].port_entry.port_combo_copper_speed_dpx_cfg = SYS_DFLT_GE_COPPER_PORT_FORCE_MODE_SPDDPX;
           port_info[ifindex-1].port_entry.port_combo_fiber_speed_dpx_cfg = SYS_DFLT_GE_FIBER_PORT_FORCE_MODE_SPDDPX;
           port_info[ifindex-1].port_entry.port_speed_dpx_cfg = SYS_DFLT_GE_COPPER_PORT_FORCE_MODE_SPDDPX;
#endif
            SWCTRL_UNLOCK();

            /* here has semaphore.
             */
#if (SYS_CPNT_REFINE_ISC_MSG != TRUE)
            SWCTRL_ConfigUserPortToDefaultState(unit, port, port_type, TRUE);
#endif
        }
        else
        {
            printf("SWCTRL: Faile get port type when hot swap insertion: eth %lu/%lu.\r\n", unit, port);
        }
    }
#if (SYS_CPNT_REFINE_ISC_MSG == TRUE)
  SWCTRL_ConfigUserPortListToDefaultState(starting_port_ifindex,starting_port_ifindex+number_of_port-1,TRUE);
#endif

    {
        SWCTRL_PktType_T pkt_type;

        for (pkt_type = 0; pkt_type < SWCTRL_PKTTYPE_MAX; pkt_type++)
        {
            if (swctrl_pkt_trap_status[pkt_type] ||
                swctrl_pkt_drop_status[pkt_type])
            {
                SWCTRL_SetUPortPktTrapStatus(
                    0,
                    0,
                    pkt_type,
                    !!swctrl_pkt_trap_status[pkt_type],
                    !!swctrl_pkt_drop_status[pkt_type]);
            }

            for(ifindex = starting_port_ifindex;
                ifindex<= starting_port_ifindex+number_of_port-1;
                ifindex++ )
            {
                unit = SWCTRL_IFINDEX_TO_UNIT(ifindex);
                port = SWCTRL_IFINDEX_TO_PORT(ifindex);

                if (swctrl_pkt_trap_status_per_port[unit-1][port-1][pkt_type] ||
                    swctrl_pkt_drop_status_per_port[unit-1][port-1][pkt_type])
                {
                    SWCTRL_SetUPortPktTrapStatus(
                        unit,
                        port,
                        pkt_type,
                        !!swctrl_pkt_trap_status_per_port[unit-1][port-1][pkt_type],
                        !!swctrl_pkt_drop_status_per_port[unit-1][port-1][pkt_type]);
                }
            }

            SWCTRL_SetCpuRateLimit(pkt_type, swctrl_pkt_cpu_rate[pkt_type]);
        } /* end of for (pkt_tyoe) */
    }
}


/*-------------------------------------------------------------------------
 * FUNCTION NAME: SWCTRL_HandleHotRemoval
 * PURPOSE  : This function will clear the port OM of the module ports when
 *            the option module is removed.
 * INPUT    : starting_port_ifindex -- the ifindex of the first module port
 *                                     removed
 *            number_of_port        -- the number of ports on the removed
 *                                     module
 * OUTPUT   : None
 * RETURN   : None
 * NOTE     : Only one module is removed at a time.
 * -------------------------------------------------------------------------*/
void SWCTRL_HandleHotRemoval(UI32_T starting_port_ifindex, UI32_T number_of_port)
{
    UI32_T              unit;
    UI32_T              port;
    UI32_T              ifindex, sfp_index;
    UI32_T              trunk_id;
    SYS_TYPE_Uport_T    unit_port;

    /* remove mirroring config
     */
    SWCTRL_HandleHotRemoval_ForPortMirroring(starting_port_ifindex, number_of_port);

    for(ifindex = starting_port_ifindex;
        ifindex<= starting_port_ifindex+number_of_port-1;
        ifindex++ )
    {
        unit = SWCTRL_IFINDEX_TO_UNIT(ifindex);
        port = SWCTRL_IFINDEX_TO_PORT(ifindex);

        /* check if this is trunk member
         */
        trunk_id = port_info[ifindex-1].port_entry.port_trunk_index;
        if (0 != trunk_id)
        {
            unit_port.unit = (UI16_T)unit;
            unit_port.port = (UI16_T)port;

            /* this is trunk member, and count on this API to callback all other component.
             */
            SWCTRL_DeleteTrunkMember(trunk_id, unit_port);
        }

        SWCTRL_LOCK();
        /* clean up all database
         */
        memset(&port_info[ifindex-1], 0, sizeof(SWCTRL_PortInfo_T));

        /* operational status
         */
        port_info[ifindex-1].link_oper_status = VAL_ifOperStatus_notPresent;

        /* clean up OM database
         */
        SWCTRL_OM_ResetPortInfo(ifindex);

#if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION == TRUE)
#if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE == SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE_MULTIPLE_SESSION)
        /* clear traffic segmentation
         */
        {
            UI32_T group_index, lport_index, trunk_index;
            UI32_T byte_idx;
            UI8_T bit_val;

            byte_idx = SWCTRL_BYTE_IN_BITMAP(ifindex);
            bit_val = SWCTRL_BIT_IN_BITMAP(ifindex);

            /* default private vlan extend database */
            for (group_index=1; group_index<=SYS_ADPT_PORT_TRAFFIC_SEGMENTATION_MAX_NBR_OF_SESSIONS; group_index++)
            {
                if (!swctl_private_vlan_ext_info[group_index-1].is_valid)
                {
                    continue;
                }

                swctl_private_vlan_ext_info[group_index-1].private_vlan_uplink_port_list[byte_idx] &= ~ bit_val;
                swctl_private_vlan_ext_info[group_index-1].private_vlan_downlink_port_list[byte_idx] &= ~ bit_val;
            }

            /* default private vlan port database */
            lport_index = ifindex - 1;
            memset(&swctl_private_vlan_port_info[lport_index], 0, sizeof(swctl_private_vlan_port_info[lport_index]));
            swctl_private_vlan_port_info[lport_index].port_index = lport_index+1;
            swctl_private_vlan_port_info[lport_index].dev_id     = 0x0;
            swctl_private_vlan_port_info[lport_index].session_id = 0x0;
            swctl_private_vlan_port_info[lport_index].port_trunk_index = 0x0;
            swctl_private_vlan_port_info[lport_index].private_vlan_uplink_port   = FALSE;
            swctl_private_vlan_port_info[lport_index].private_vlan_downlink_port = FALSE;
            swctl_private_vlan_port_info[lport_index].is_pvlan_trunk_index_port  = FALSE;

            /* default private vlan trunk port database */
            for (trunk_index=0; trunk_index<SYS_ADPT_MAX_NBR_OF_TRUNK_PER_SYSTEM; trunk_index++)
            {
                if (swctl_private_vlan_trunk_port_info[trunk_index-1].session_id == 0)
                {
                    continue;
                }

                swctl_private_vlan_trunk_port_info[trunk_index-1].pvlan_trunk_uplink_port_list[byte_idx] &= ~ bit_val;
                swctl_private_vlan_trunk_port_info[trunk_index-1].pvlan_trunk_downlink_port_list[byte_idx] &= ~ bit_val;
            }
        }
#endif /* End of #if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE == SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE_MULTIPLE_SESSION)*/
#endif /* End of #if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION == TRUE) */

        SWCTRL_UNLOCK();
    }

#if (SYS_CPNT_SWDRV_MONITOR_SFP_DDM == TRUE)
    unit = SWCTRL_IFINDEX_TO_UNIT(starting_port_ifindex);
    for (sfp_index = 1; sfp_index <= SYS_ADPT_NBR_OF_SFP_PORT_PER_UNIT; sfp_index++)
    {
        SWCTRL_LOCK();
        SWCTRL_OM_ResetPortSfpInfo(unit, sfp_index);
        SWCTRL_UNLOCK();
    }
#endif

}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetOperationMode
 * -------------------------------------------------------------------------
 * FUNCTION: Get current swctrl operation mode.
 * INPUT   : None
 * OUTPUT  : None
 * RETURN  : Current operation mode.
 *           1) SYS_TYPE_STACKING_TRANSITION_MODE
 *           2) SYS_TYPE_STACKING_MASTER_MODE
 *           3) SYS_TYPE_STACKING_SLAVE_MODE
 * NOTE    : None
 * -------------------------------------------------------------------------*/
SYS_TYPE_Stacking_Mode_T SWCTRL_GetOperationMode(void)
{
    return SYSFUN_GET_CSC_OPERATING_MODE();
} /* End of SWCTRL_GetOperationMode() */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_PreProvisionComplete
 * -------------------------------------------------------------------------
 * FUNCTION: This function will perform proprovision complete
 *           action
 * INPUT   : None
 * OUTPUT  : None
 * RETURN  : None
 * NOTE    : None
 * -------------------------------------------------------------------------*/
void SWCTRL_PreProvisionComplete(void)
{

} /* End of SWCTRL_ProvisionComplete() */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_ProvisionComplete
 * -------------------------------------------------------------------------
 * FUNCTION: This function will tell the Switch Control module to start
 *           action
 * INPUT   : None
 * OUTPUT  : None
 * RETURN  : None
 * NOTE    : None
 * -------------------------------------------------------------------------*/
void SWCTRL_ProvisionComplete(void)
{
    UI32_T ifindex;
    UI32_T unit, port;

    SWCTRL_USE_CSC_CHECK_OPER_MODE_WITHOUT_RETURN_VALUE();

    /* user port
     */
    for(ifindex =  SYS_ADPT_ETHER_1_IF_INDEX_NUMBER;
        ifindex <= SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK*SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT;
        ifindex ++)
    {
        /* continue if the port is not user port
         */
        if (!SWCTRL_IS_EXIST (ifindex))
            continue;

        unit = SWCTRL_IFINDEX_TO_UNIT(ifindex);
        port = SWCTRL_IFINDEX_TO_PORT(ifindex);

        /* port admin setting
         */
#if (SYS_CPNT_3COM_LOOPBACK_TEST == TRUE)
        if (TRUE == user_ext_port_info[ifindex-1].is_loopback_test_failed)
        {
            /* loopback test failed port
             */
            /* always admin shutdown
             */
            SWDRV_DisablePortAdmin(unit, port);

            if (port_info[ifindex-1].admin_status == VAL_ifAdminStatus_up)
            {
                ;
                /* default is up, the same as previous state, don't notify
                 */
            }
            else
            {
                SWCTRL_Notify_uPortAdminDisable(unit, port);

                if(!SWCTRL_IS_TRUNK_MEMBER(ifindex))
                    SWCTRL_Notify_PortAdminDisable(ifindex);
            }
        }
        else
        {
#endif
            /* loopback test passed port
             */
            if (port_info[ifindex-1].shutdown_status == 0)
            {
                SWDRV_EnablePortAdmin(unit, port);
            }

            if (port_info[ifindex-1].admin_status == VAL_ifAdminStatus_up)
            {
                /* setting driver was done according to shutdown_reason
                 */

                /* default is up, the same as previous state, don't notify
                 */
            }
            else
            {
                SWCTRL_Notify_uPortAdminDisable(unit, port);

                if(!SWCTRL_IS_TRUNK_MEMBER(ifindex))
                    SWCTRL_Notify_PortAdminDisable(ifindex);
            }
#if (SYS_CPNT_3COM_LOOPBACK_TEST == TRUE)
        }
#endif

        /* port flow control setting
         */
        if(port_info[ifindex-1].port_entry.port_autonegotiation == VAL_portAutonegotiation_enabled)
        {
            /* auto mode
             */
        }
        else
        {
            /* force mode
             */
            SWDRV_SetPortCfgFlowCtrl(unit, port, port_info[ifindex-1].port_entry.port_flow_ctrl_cfg);

            if (port_info[ifindex-1].port_entry.port_flow_ctrl_cfg == VAL_portFlowCtrlCfg_disabled)
            {
                port_info[ifindex-1].port_entry.port_flow_ctrl_status = VAL_portFlowCtrlStatus_none;
            }
        }
    }

    /* trunk port
     */
    for(ifindex = SYS_ADPT_TRUNK_1_IF_INDEX_NUMBER;
        ifindex < SYS_ADPT_TRUNK_1_IF_INDEX_NUMBER+SYS_ADPT_MAX_NBR_OF_TRUNK_PER_SYSTEM;
        ifindex ++)
    {
        if (!SWCTRL_IS_EXIST (ifindex))
            continue;

        if(port_info[ifindex-1].admin_status == VAL_ifAdminStatus_up)
        {
            /* setting driver was done in user port
             */
            /*default is up, the same as previous state, don't notify
             */
        }
        else
        {
            /* setting driver was done in user port
             */
            SWCTRL_Notify_PortAdminDisable(ifindex);
        }
    }

    /* move it to STKCTRL_TASK , arthur, 12/21/2002 04:42pm*/
    /* SWDRV_ProvisionComplete();
     */

    /* send loopback test failure trap if it is necessary
     */
#if (SYS_CPNT_3COM_LOOPBACK_TEST == TRUE)
    {
        BOOL_T                is_to_send = FALSE;
        UI32_T                i;
        UI8_T                 failure_ports[SYS_ADPT_NBR_OF_BYTE_FOR_1BIT_UPORT_LIST*SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK];

        TRAP_EVENT_TrapData_T trap_data;

        SWCTRL_GetSwitchLoopbackTestFailurePorts(failure_ports);

        for(i = 0;
            i < SYS_ADPT_NBR_OF_BYTE_FOR_1BIT_UPORT_LIST*SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK;
            i ++)
        {
            if(failure_ports[i])
            {
                is_to_send = TRUE;
                break;
            }
        }

        if (TRUE == is_to_send)
        {
            trap_data.trap_type = TRAP_EVENT_LOOPBACK_TEST_FAILURE_TRAP;
            trap_data.community_specified = FALSE;
            trap_data.flag = TRAP_EVENT_SEND_TRAP_OPTION_DEFAULT;
            memcpy(trap_data.u.loopback_failure_trap.ports, failure_ports, sizeof(failure_ports));
#if (SYS_CPNT_TRAPMGMT == TRUE)
            TRAP_MGR_ReqSendTrap(&trap_data);
#else
            SNMP_PMGR_ReqSendTrap(&trap_data);
#endif
        }
    }
#endif

    /* set this flag after completing all things
     */
    is_provision_complete = TRUE;

    SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME ();
    SWCTRL_RETURN_AND_RELEASE_CSC_WITHOUT_RETUEN_VALUE();

} /* End of SWCTRL_ProvisionComplete() */


/****************************************************************************/
/* Call Back Functions                                                      */
/****************************************************************************/
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_Register_LPortTypeChanged_CallBack
 * -------------------------------------------------------------------------
 * FUNCTION: Register the call-back function, when port type changeing is
 *           removed the registered function will be called
 * INPUT   : fun -- call back function pointer
 * OUTPUT  : none
 * RETURN  : none
 * NOTE    : 1. void *fun(UI32_T ifindex, UI32_T port_type)
 *           2. For logical port.
 * -------------------------------------------------------------------------*/
void SWCTRL_Register_LPortTypeChanged_CallBack(void (*fun)(UI32_T ifindex, UI32_T port_type))
{
    SYS_TYPE_REGISTER_CALLBACKFUN(PortTypeChanged_callbacklist);
} /* End of SWCTRL_Register_LPortTypeChanged_CallBack() */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_Register_UPortTypeChanged_CallBack
 * -------------------------------------------------------------------------
 * FUNCTION: Register the call-back function, when port type changeing is
 *           removed the registered function will be called
 * INPUT   : fun -- call back function pointer
 * OUTPUT  : none
 * RETURN  : none
 * NOTE    : 1. void *fun(UI32_T unit, UI32_T port, UI32_T port_type)
 *           2. For user port.
 * -------------------------------------------------------------------------*/
void SWCTRL_Register_UPortTypeChanged_CallBack(void (*fun)(UI32_T unit, UI32_T port, UI32_T port_type))
{
    SYS_TYPE_REGISTER_CALLBACKFUN(uPortTypeChanged_callbacklist);
} /* End of SWCTRL_Register_UPortTypeChanged_CallBack() */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_Register_TrunkMemberAdd1st_CallBack
 * -------------------------------------------------------------------------
 * FUNCTION: Register the call-back function, when the first port is added
 *           to a trunk the registered function will be called
 * INPUT   : fun -- call back function pointer
 * OUTPUT  : none
 * RETURN  : none
 * NOTE    : void *fun(UI32_T trunk_ifindex, UI32_T member_ifindex)
 *           Designed for Trunk and VLAN.
 * -------------------------------------------------------------------------*/
void SWCTRL_Register_TrunkMemberAdd1st_CallBack(void (*fun)(UI32_T trunk_ifindex,
                                                            UI32_T member_ifindex))
{
    SYS_TYPE_REGISTER_CALLBACKFUN(TrunkMemberAdd1st_callbacklist);
} /* End of SWCTRL_Register_TrunkMemberAdd1st_CallBack() */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_Register_TrunkMemberAdd_CallBack
 * -------------------------------------------------------------------------
 * FUNCTION: Register the call-back function, when a port is added to a
 *           trunk the registered function will be called
 * INPUT   : fun -- call back function pointer
 * OUTPUT  : none
 * RETURN  : none
 * NOTE    : void *fun(UI32_T trunk_ifindex, UI32_T member_ifindex)
 *           Designed for Trunk and VLAN.
 * -------------------------------------------------------------------------*/
void SWCTRL_Register_TrunkMemberAdd_CallBack(void (*fun)(UI32_T trunk_ifindex,
                                                         UI32_T member_ifindex))
{
    SYS_TYPE_REGISTER_CALLBACKFUN(TrunkMemberAdd_callbacklist);
} /* End of SWCTRL_Register_TrunkMemberAdd_CallBack() */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_Register_TrunkMemberDelete_CallBack
 * -------------------------------------------------------------------------
 * FUNCTION: Register the call-back function, when a port is deleted from a
 *           trunk the registered function will be called
 * INPUT   : fun -- call back function pointer
 * OUTPUT  : none
 * RETURN  : none
 * NOTE    : void *fun(UI32_T trunk_ifindex, UI32_T member_ifindex)
 *           Designed for Trunk and VLAN.
 * -------------------------------------------------------------------------*/
void SWCTRL_Register_TrunkMemberDelete_CallBack(void (*fun)(UI32_T trunk_ifindex,
                                                            UI32_T member_ifindex))
{
    SYS_TYPE_REGISTER_CALLBACKFUN(TrunkMemberDelete_callbacklist);
} /* End of SWCTRL_Register_TrunkMemberDelete_CallBack() */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_Register_TrunkMemberDeleteLst_CallBack
 * -------------------------------------------------------------------------
 * FUNCTION: Register the call-back function, when the last port is deleted
 *           from a trunk the registered function will be called
 * INPUT   : fun -- call back function pointer
 * OUTPUT  : none
 * RETURN  : none
 * NOTE    : void *fun(UI32_T trunk_ifindex, UI32_T member_ifindex)
 *           Designed for Trunk and VLAN.
 * -------------------------------------------------------------------------*/
void SWCTRL_Register_TrunkMemberDeleteLst_CallBack(void (*fun)(UI32_T trunk_ifindex,
                                                               UI32_T member_ifindex))
{
    SYS_TYPE_REGISTER_CALLBACKFUN(TrunkMemberDeleteLst_callbacklist);
} /* End of SWCTRL_Register_TrunkMemberDeleteLst_CallBack() */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_Register_LPortLinkUp_CallBack
 * -------------------------------------------------------------------------
 * FUNCTION: Register the call-back function, when link down to up the
 *           registered function will be called
 * INPUT   : fun -- call back function pointer
 * OUTPUT  : none
 * RETURN  : none
 * NOTE    : 1. void *fun(UI32_T ifindex)
 *           2. STA_TASK
 * -------------------------------------------------------------------------*/
void SWCTRL_Register_LPortLinkUp_CallBack(void (*fun)(UI32_T ifindex))
{
    SYS_TYPE_REGISTER_CALLBACKFUN(PortLinkUp_callbacklist);
} /* End of SWCTRL_Register_LPortLinkUp_CallBack */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_Register_LPortLinkDown_CallBack
 * -------------------------------------------------------------------------
 * FUNCTION: Register the call-back function, when link up to down the
 *           register function will be called
 * INPUT   : fun -- call back function pointer
 * OUTPUT  : none
 * RETURN  : none
 * NOTE    : 1. void *fun(UI32_T ifindex)
 *           2. STA_TASK, AMTR_TASK
 * -------------------------------------------------------------------------*/
void SWCTRL_Register_LPortLinkDown_CallBack(void (*fun)(UI32_T ifindex))
{
    SYS_TYPE_REGISTER_CALLBACKFUN(PortLinkDown_callbacklist);
} /* End of SWCTRL_Register_LPortLinkDown_CallBack() */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_Register_UPortLinkUp_CallBack
 * -------------------------------------------------------------------------
 * FUNCTION: Register the call-back function, when link down to up the
 *           registered function will be called
 * INPUT   : fun -- call back function pointer
 * OUTPUT  : none
 * RETURN  : none
 * NOTE    : 1. void *fun(UI32_T unit, UI32_T port)
 *           2. LED_MGR, LACP_TASK
 * -------------------------------------------------------------------------*/
void SWCTRL_Register_UPortLinkUp_CallBack(void (*fun)(UI32_T unit,
                                                      UI32_T port))
{
    SYS_TYPE_REGISTER_CALLBACKFUN(uPortLinkUp_callbacklist);
} /* End of SWCTRL_Register_UPortLinkUp_CallBack() */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_Register_UPortFastLinkUp_CallBack
 * -------------------------------------------------------------------------
 * FUNCTION: Register the call-back function, when link down to up the
 *           registered function will be called
 * INPUT   : fun -- call back function pointer
 * OUTPUT  : none
 * RETURN  : none
 * NOTE    : 1. void *fun(UI32_T unit, UI32_T port)
 *           2. LED_MGR
 *           3. Fast uport link up callback, this callback should be used
 *              only by LEDMGMT. SWCTRL should callbcak before all other callbacks.
 * -------------------------------------------------------------------------*/
void SWCTRL_Register_UPortFastLinkUp_CallBack(void (*fun)(UI32_T unit,
                                                          UI32_T port))
{
    SYS_TYPE_REGISTER_CALLBACKFUN(uPortFastLinkUp_callbacklist);
} /* End of SWCTRL_Register_UPortLinkUp_CallBack() */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_Register_UPortLinkDown_CallBack
 * -------------------------------------------------------------------------
 * FUNCTION: Register the call-back function, when link up to down the
 *           register function will be called
 * INPUT   : fun -- call back function pointer
 * OUTPUT  : none
 * RETURN  : none
 * NOTE    : 1. void *fun(UI32_T unit, UI32_T port)
 *           2. LED_MGR, LACP_TASK
 * -------------------------------------------------------------------------*/
void SWCTRL_Register_UPortLinkDown_CallBack(void (*fun)(UI32_T unit,
                                                        UI32_T port))
{
    SYS_TYPE_REGISTER_CALLBACKFUN(uPortLinkDown_callbacklist);
} /* End of SWCTRL_Register_UPortLinkDown_CallBack() */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_Register_UPortFastLinkDown_CallBack
 * -------------------------------------------------------------------------
 * FUNCTION: Register the call-back function, when link up to down the
 *           register function will be called
 * INPUT   : fun -- call back function pointer
 * OUTPUT  : none
 * RETURN  : none
 * NOTE    : 1. void *fun(UI32_T unit, UI32_T port)
 *           2. LED_MGR
 *           3. Fast uport link down callback, this callback should be used
 *              only by LEDMGMT. SWCTRL should callbcak before all other callbacks.
 * -------------------------------------------------------------------------*/
void SWCTRL_Register_UPortFastLinkDown_CallBack(void (*fun)(UI32_T unit,
                                                            UI32_T port))
{
    SYS_TYPE_REGISTER_CALLBACKFUN(uPortFastLinkDown_callbacklist);
} /* End of SWCTRL_Register_UPortLinkDown_CallBack() */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_Register_LPortOperUp_CallBack
 * -------------------------------------------------------------------------
 * FUNCTION: Register the call-back function, when port oper status is up
 *           the register function will be called
 * INPUT   : fun -- call back function pointer
 * OUTPUT  : none
 * RETURN  : none
 * NOTE    : 1. void *fun(UI32_T ifindex)
 *           2. VLAN_TASK, IGMPSNP_TASK
 * -------------------------------------------------------------------------*/
void SWCTRL_Register_LPortOperUp_CallBack(void (*fun)(UI32_T ifindex))
{
    SYS_TYPE_REGISTER_CALLBACKFUN(PortOperUp_callbacklist);
} /* End of SWCTRL_Register_LPortOperUp_CallBack() */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_Register_LPortNotOperUp_CallBack
 * -------------------------------------------------------------------------
 * FUNCTION: Register the call-back function, when port oper status is not up
 *           the register function will be called
 * INPUT   : fun -- call back function pointer
 * OUTPUT  : none
 * RETURN  : none
 * NOTE    : 1. void *fun(UI32_T ifindex)
 *           2. VLAN_TASK, IGMPSNP_TASK
 * -------------------------------------------------------------------------*/
void SWCTRL_Register_LPortNotOperUp_CallBack(void (*fun)(UI32_T ifindex))
{
    SYS_TYPE_REGISTER_CALLBACKFUN(PortNotOperUp_callbacklist);
} /* End of SWCTRL_Register_LPortNotOperUp_CallBack() */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_Register_TrunkMemberPortOperUp_CallBack
 * -------------------------------------------------------------------------
 * FUNCTION: Register the call-back function, when port oper status is up
 *           the register function will be called
 * INPUT   : fun -- call back function pointer
 * OUTPUT  : none
 * RETURN  : none
 * NOTE    : 1. void (*fun)(UI32_T trunk_ifindex, UI32_T trunk_member_port_ifindex)
 *           2. Trunk load balance
 * -------------------------------------------------------------------------*/
void SWCTRL_Register_TrunkMemberPortOperUp_CallBack(
                                    void (*fun)(UI32_T trunk_ifindex,
                                                UI32_T trunk_member_port_ifindex))
{
    SYS_TYPE_REGISTER_CALLBACKFUN(TrunkMemberPortOperUp_callbacklist);
} /* End of SWCTRL_Register_TrunkMemberPortOperUp_CallBack() */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_Register_TrunkMemberPortNotOperUp_CallBack
 * -------------------------------------------------------------------------
 * FUNCTION: Register the call-back function, when port oper status is not up
 *           the register function will be called
 * INPUT   : fun -- call back function pointer
 * OUTPUT  : none
 * RETURN  : none
 * NOTE    : 1. void (*fun)(UI32_T trunk_ifindex, UI32_T trunk_member_port_ifindex)
 *           2. Trunk load balance
 * -------------------------------------------------------------------------*/
void SWCTRL_Register_TrunkMemberPortNotOperUp_CallBack(
                                void (*fun)(UI32_T trunk_ifindex,
                                            UI32_T trunk_member_port_ifindex))
{
    SYS_TYPE_REGISTER_CALLBACKFUN(TrunkMemberPortNotOperUp_callbacklist);
} /* End of SWCTRL_Register_TrunkMemberPortNotOperUp_CallBack() */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_Register_LPortAdminEnable_CallBack
 * -------------------------------------------------------------------------
 * FUNCTION: Register the call-back function, when a port is enabled the
 *           registered function will be called
 * INPUT   : fun -- call back function pointer
 * OUTPUT  : none
 * RETURN  : none
 * NOTE    : 1. void *fun(UI32_T ifindex)
 *           2. STA_TASK
 * -------------------------------------------------------------------------*/
void SWCTRL_Register_LPortAdminEnable_CallBack(void (*fun)(UI32_T ifindex))
{
    SYS_TYPE_REGISTER_CALLBACKFUN(PortAdminEnable_callbacklist);
} /* End of SWCTRL_Register_LPortAdminEnable_CallBack() */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_Register_LPortAdminDisable_CallBack
 * -------------------------------------------------------------------------
 * FUNCTION: Register the call-back function, when a port is disabled the
 *           registered function will be called
 * INPUT   : fun -- call back function pointer
 * OUTPUT  : none
 * RETURN  : none
 * NOTE    : 1. void *fun(UI32_T ifindex)
 *           2. STA_TASK
 * -------------------------------------------------------------------------*/
void SWCTRL_Register_LPortAdminDisable_CallBack(void (*fun)(UI32_T ifindex))
{
    SYS_TYPE_REGISTER_CALLBACKFUN(PortAdminDisable_callbacklist);
} /* End of SWCTRL_Register_LPortAdminDisable_CallBack() */

#if (SYS_CPNT_LLDP == TRUE)
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_Register_LPortAdminDisableBefore_CallBack
 * -------------------------------------------------------------------------
 * FUNCTION: Register the call-back function, when a port is disabled the
 *           registered function will be called, before do the admin disable
 * INPUT   : fun -- call back function pointer
 * OUTPUT  : none
 * RETURN  : none
 * NOTE    : for LLDP
 * -------------------------------------------------------------------------*/
void SWCTRL_Register_LPortAdminDisableBefore_CallBack(void (*fun)(UI32_T ifindex))
{
    SYS_TYPE_REGISTER_CALLBACKFUN(PortAdminDisableBefore_callbacklist);
} /* End of SWCTRL_Register_LPortAdminDisableBefore_CallBack() */
#endif
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_Register_UPortAdminEnable_CallBack
 * -------------------------------------------------------------------------
 * FUNCTION: Register the call-back function, when a port is enabled the
 *           registered function will be called
 * INPUT   : fun -- call back function pointer
 * OUTPUT  : none
 * RETURN  : none
 * NOTE    : 1. void *fun(UI32_T unit, UI32_T port)
 *           2. LED_MGR, LACP_TASK
 * -------------------------------------------------------------------------*/
void SWCTRL_Register_UPortAdminEnable_CallBack(void (*fun)(UI32_T unit,
                                                           UI32_T port))
{
    SYS_TYPE_REGISTER_CALLBACKFUN(uPortAdminEnable_callbacklist);
} /* End of SWCTRL_Register_UPortAdminEnable_CallBack() */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_Register_UPortAdminDisable_CallBack
 * -------------------------------------------------------------------------
 * FUNCTION: Register the call-back function, when a port is disabled the
 *           registered function will be called
 * INPUT   : fun -- call back function pointer
 * OUTPUT  : none
 * RETURN  : none
 * NOTE    : 1. void *fun(UI32_T unit, UI32_T port)
 *           2. LED_MGR, LACP_TASK
 * -------------------------------------------------------------------------*/
void SWCTRL_Register_UPortAdminDisable_CallBack(void (*fun)(UI32_T unit,
                                                            UI32_T port))
{
    SYS_TYPE_REGISTER_CALLBACKFUN(uPortAdminDisable_callbacklist);
} /* End of SWCTRL_Register_UPortAdminDisable_CallBack() */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_Register_PortSpeedDuplex_CallBack
 * -------------------------------------------------------------------------
 * FUNCTION: Register the call-back function, when the speed or duplex of a
 *           port is changed the registered function will be called
 * INPUT   : fun -- call back function pointer
 * OUTPUT  : none
 * RETURN  : none
 * NOTE    : void *fun(UI32_T ifindex, UI32_T speed_duplex)
 *           Whenever speed or duplex changes, SWCTRL needs to notify
 *           1. STA
 * -------------------------------------------------------------------------*/
void SWCTRL_Register_PortSpeedDuplex_CallBack(void (*fun)(UI32_T ifindex,
                                                           UI32_T speed_duplex))
{
    SYS_TYPE_REGISTER_CALLBACKFUN(PortSpeedDuplex_callbacklist);
} /* End of SWCTRL_Register_PortSpeedDuplex_CallBack() */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_Register_UPortSpeedDuplex_CallBack
 * -------------------------------------------------------------------------
 * FUNCTION: Register the call-back function, when the speed or duplex of a
 *           port is changed the registered function will be called
 * INPUT   : fun -- call back function pointer
 * OUTPUT  : none
 * RETURN  : none
 * NOTE    : void *fun(UI32_T unit, UI32_T port, UI32_T speed_duplex)
 *           Whenever speed or duplex changes, SWCTRL needs to notify
 *           1. LED_MGMT
 *           2. STA
 *           3. IML(RFC2233)
 * -------------------------------------------------------------------------*/
void SWCTRL_Register_UPortSpeedDuplex_CallBack(void (*fun)(UI32_T unit,
                                                           UI32_T port,
                                                           UI32_T speed_duplex))
{
    SYS_TYPE_REGISTER_CALLBACKFUN(uPortSpeedDuplex_callbacklist);
} /* End of SWCTRL_Register_UPortSpeedDuplex_CallBack() */


/*Charles: swctrl_support_dot1x
 */
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_Register_UPortLacpEffectiveOperStatusChanged_CallBack
 * -------------------------------------------------------------------------
 * FUNCTION: Register the callback function, when effective oper status
 *           of some user port was changed for lacp the registered function
 *           will be called.
 * INPUT   : fun -- call back function pointer
 * OUTPUT  : none
 * RETURN  : none
 * NOTE    : I.   S'pose for lacp.
 *           II.  pre_status --- The status before change.
 *           III. current_status --- The status agter change.
 *           IV.  Definiation of precedence:
 *                    Status                                    Precedence
 *                 ----------------------------------------     ----------
 *                 1) VAL_ifOperStatus_up                       0
 *                 2) SWCTRL_PORT_DORMANT_STATUS_TYPE_LACP      1
 *                 3) SWCTRL_PORT_DORMANT_STATUS_TYPE_DOT1X     2
 *                 4) VAL_ifOperStatus_down                     3
 *                 5) VAL_ifOperStatus_lowerLayerDown           3
 *                 6) VAL_ifOperStatus_notPresent               4
 *           V.   When to callback:
 *                 1) Precedence(pre_status)     <  Precedence(current_status) &&
 *                    Precedence(current_status) >  Precedence(SWCTRL_PORT_DORMANT_STATUS_TYPE_LACP)
 *                 2) Precedence(pre_status)     >  Precedence(current_status) &&
 *                    Precedence(current_status) == Precedence(SWCTRL_PORT_DORMANT_STATUS_TYPE_LACP)
 * -------------------------------------------------------------------------*/
void SWCTRL_Register_UPortLacpEffectiveOperStatusChanged_CallBack(void (*fun)(UI32_T unit, UI32_T port,
                                                                  UI32_T pre_status, UI32_T current_status) )
{
    SYS_TYPE_REGISTER_CALLBACKFUN(uPortLacpEffectiveOperStatusChanged_callbacklist);
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_Register_UPortDot1xEffectiveOperStatusChanged_CallBack
 * -------------------------------------------------------------------------
 * FUNCTION: Register the callback function, when effective oper status
 *           of some user port was changed for dot1x the registered function
 *           will be called.
 * INPUT   : fun -- call back function pointer
 * OUTPUT  : none
 * RETURN  : none
 * NOTE    : I.   S'pose for dot1x.
 *           II.  pre_status --- The status before change.
 *           III. current_status --- The status agter change.
 *           IV.  Definiation of precedence:
 *                    Status                                    Precedence
 *                 ----------------------------------------     ----------
 *                 1) VAL_ifOperStatus_up                       0
 *                 2) SWCTRL_PORT_DORMANT_STATUS_TYPE_LACP      1
 *                 3) SWCTRL_PORT_DORMANT_STATUS_TYPE_DOT1X     2
 *                 4) VAL_ifOperStatus_down                     3
 *                 5) VAL_ifOperStatus_lowerLayerDown           3
 *                 6) VAL_ifOperStatus_notPresent               4
 *           V.   When to callback:
 *                 1) Precedence(pre_status)     <  Precedence(current_status) &&
 *                    Precedence(current_status) >  Precedence(SWCTRL_PORT_DORMANT_STATUS_TYPE_DOT1X)
 *                 2) Precedence(pre_status)     >  Precedence(current_status) &&
 *                    Precedence(current_status) == Precedence(SWCTRL_PORT_DORMANT_STATUS_TYPE_DOT1X)
 * -------------------------------------------------------------------------*/
void SWCTRL_Register_UPortDot1xEffectiveOperStatusChanged_CallBack(void (*fun)(UI32_T unit, UI32_T port,
                                                                   UI32_T pre_status, UI32_T current_status) )
{
    SYS_TYPE_REGISTER_CALLBACKFUN(uPortDot1xEffectiveOperStatusChanged_callbacklist);
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_Register_ForwardingUPortAddToTrunk_CallBack
 * -------------------------------------------------------------------------
 * FUNCTION: Register the call-back function, when a STA forwarding user port join to
 *           a trunk.
 * INPUT   : fun -- call back function pointer.
 * OUTPUT  : None.
 * RETURN  : None
 * NOTE    : Callback after this user port is added.
 * -------------------------------------------------------------------------*/
void SWCTRL_Register_ForwardingUPortAddToTrunk_CallBack(void (*fun)(UI32_T trunk_ifindex, UI32_T member_ifindex))
{
    SYS_TYPE_REGISTER_CALLBACKFUN(ForwardingUPortAddToTrunk_callbacklist);
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_Register_ForwardingTrunkMemberToNonForwarding_CallBack
 * -------------------------------------------------------------------------
 * FUNCTION: Register the call-back function, when a STA forwarding trunk member
 *           become non-forwarding.
 * INPUT   : fun -- call back function pointer.
 * OUTPUT  : None.
 * RETURN  : None
 * NOTE    : Only happens when a forwarding trunk meber link down.
 * -------------------------------------------------------------------------*/
void SWCTRL_Register_ForwardingTrunkMemberToNonForwarding_CallBack(void (*fun)(UI32_T trunk_ifindex, UI32_T member_ifindex))
{
    SYS_TYPE_REGISTER_CALLBACKFUN(ForwardingTrunkMemberToNonForwarding_callbacklist);
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_Register_ForwardingTrunkMemberDelete_CallBack
 * -------------------------------------------------------------------------
 * FUNCTION: Register the call-back function, when a STA forwarding trnuk member
 *           is removed from a trunk.
 * INPUT   : fun -- call back function pointer.
 * OUTPUT  : None.
 * RETURN  : None
 * NOTE    : Callback after this user port is deleted.
 * -------------------------------------------------------------------------*/
void SWCTRL_Register_ForwardingTrunkMemberDelete_CallBack(void (*fun)(UI32_T trunk_ifindex, UI32_T member_ifindex))
{
    SYS_TYPE_REGISTER_CALLBACKFUN(ForwardingTrunkMemberDelete_callbacklist);
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_Notify_LPortTypeChanged
 * -------------------------------------------------------------------------
 * FUNCTION: Call call-back function, when a hot swap module is removed.
 * INPUT   : ifindex   -- which logical port.
 *           port_type -- changed to which port type.
 * OUTPUT  : None
 * RETURN  : None
 * NOTE    : None
 * -------------------------------------------------------------------------*/
static void SWCTRL_Notify_LPortTypeChanged(UI32_T ifindex, UI32_T port_type)
{

    if (SWCTRL_BACKDOOR_IsDebugFlagOn (SWCTRL_BACKDOOR_DEBUG_FLAG_CALLBACK_NOTIFY))
        BACKDOOR_MGR_Printf("\r\n[ifindex = %2ld    ][port_type = %2ld   ][SWCTRL_Notify_LPortTypeChanged]",ifindex, port_type);

    SWCTRL_GROUP_LPortTypeChangedCallbackHandler(ifindex, port_type);
    SYS_CALLBACK_MGR_LPortTypeChangedCallback(SYS_MODULE_SWCTRL, ifindex, port_type);
} /* End of SWCTRL_Notify_LPortTypeChanged() */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_Notify_UPortTypeChanged
 * -------------------------------------------------------------------------
 * FUNCTION: Call call-back function, when a hot swap module is removed.
 * INPUT   : ifindex   -- which logical port.
 *           port_type -- changed to which port type.
 * OUTPUT  : None
 * RETURN  : None
 * NOTE    : None
 * -------------------------------------------------------------------------*/
static void SWCTRL_Notify_UPortTypeChanged(UI32_T unit, UI32_T port, UI32_T port_type)
{

    if (SWCTRL_BACKDOOR_IsDebugFlagOn (SWCTRL_BACKDOOR_DEBUG_FLAG_CALLBACK_NOTIFY))
        BACKDOOR_MGR_Printf("\r\n[unit = %2ld    ][port = %2ld    ][port_type = %2ld   ][SWCTRL_Notify_UPortTypeChanged]",unit, port, port_type);

    SWCTRL_GROUP_UPortTypeChangedCallbackHandler(unit, port,port_type );
    SYS_CALLBACK_MGR_UPortTypeChangedCallback(SYS_MODULE_SWCTRL, unit, port,port_type );
} /* End of SWCTRL_Notify_UPortTypeChanged() */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_Notify_TrunkMemberAdd1st
 * -------------------------------------------------------------------------
 * FUNCTION: Call call-back function, when a logical port is added to a
 *           trunk
 * INPUT   : trunk_ifindex  -- which trunk port
 *           member_ifindex -- which member port
 * OUTPUT  : None
 * RETURN  : None
 * NOTE    : None
 * -------------------------------------------------------------------------*/
static void SWCTRL_Notify_TrunkMemberAdd1st(UI32_T trunk_ifindex,
                                            UI32_T member_ifindex)
{
    if (SWCTRL_BACKDOOR_IsDebugFlagOn (SWCTRL_BACKDOOR_DEBUG_FLAG_CALLBACK_NOTIFY))
        BACKDOOR_MGR_Printf("\r\n[trunk_ifidx = %2ld][member_ifidx = %2ld][Notify_TrunkMemberAdd1st]",
                trunk_ifindex, member_ifindex);

    SWCTRL_GROUP_TrunkMemberAdd1stCallbackHandler(trunk_ifindex, member_ifindex);
    SYS_CALLBACK_MGR_TrunkMemberAdd1stCallback(SYS_MODULE_SWCTRL, trunk_ifindex, member_ifindex);
} /* End of SWCTRL_Notify_TrunkMemberAdd1st() */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_Notify_TrunkMemberAdd
 * -------------------------------------------------------------------------
 * FUNCTION: Call call-back function, when a logical port is added to a
 *           trunk
 * INPUT   : trunk_ifindex  -- which trunk port
 *           member_ifindex -- which member port
 * OUTPUT  : None
 * RETURN  : None
 * NOTE    : None
 * -------------------------------------------------------------------------*/
static void SWCTRL_Notify_TrunkMemberAdd(UI32_T trunk_ifindex,
                                         UI32_T member_ifindex)
{

    if (SWCTRL_BACKDOOR_IsDebugFlagOn (SWCTRL_BACKDOOR_DEBUG_FLAG_CALLBACK_NOTIFY))
        BACKDOOR_MGR_Printf("\r\n[trunk_ifidx = %2ld][member_ifidx = %2ld][Notify_TrunkMemberAdd]",
                trunk_ifindex, member_ifindex);

    SWCTRL_GROUP_TrunkMemberAddCallbackHandler(trunk_ifindex, member_ifindex);
    SYS_CALLBACK_MGR_TrunkMemberAddCallback(SYS_MODULE_SWCTRL, trunk_ifindex, member_ifindex);
} /* End of SWCTRL_Notify_TrunkMemberAdd() */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_Notify_TrunkMemberDelete
 * -------------------------------------------------------------------------
 * FUNCTION: Call call-back function, when a logical port is deleted from a
 *           trunk
 * INPUT   : trunk_ifindex  -- which trunk port
 *           member_ifindex -- which member port
 * OUTPUT  : None
 * RETURN  : None
 * NOTE    : None
 * -------------------------------------------------------------------------*/
static void SWCTRL_Notify_TrunkMemberDelete(UI32_T trunk_ifindex,
                                            UI32_T member_ifindex)
{
    if (SWCTRL_BACKDOOR_IsDebugFlagOn (SWCTRL_BACKDOOR_DEBUG_FLAG_CALLBACK_NOTIFY))
        BACKDOOR_MGR_Printf("\r\n[trunk_ifidx = %2ld][member_ifidx = %2ld][Notify_TrunkMemberDelete]",
                trunk_ifindex, member_ifindex);

    SWCTRL_GROUP_TrunkMemberDeleteCallbackHandler(trunk_ifindex, member_ifindex);
    SYS_CALLBACK_MGR_TrunkMemberDeleteCallback(SYS_MODULE_SWCTRL, trunk_ifindex, member_ifindex);
} /* End of SWCTRL_Notify_TrunkMemberDelete() */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_Notify_TrunkMemberDeleteLst
 * -------------------------------------------------------------------------
 * FUNCTION: Call call-back function, when a logical port is deleted from a
 *           trunk
 * INPUT   : trunk_ifindex  -- which trunk port
 *           member_ifindex -- which member port
 * OUTPUT  : None
 * RETURN  : None
 * NOTE    : None
 * -------------------------------------------------------------------------*/
static void SWCTRL_Notify_TrunkMemberDeleteLst(UI32_T trunk_ifindex,
                                               UI32_T member_ifindex)
{
    if (SWCTRL_BACKDOOR_IsDebugFlagOn (SWCTRL_BACKDOOR_DEBUG_FLAG_CALLBACK_NOTIFY))
        BACKDOOR_MGR_Printf("\r\n[trunk_ifidx = %2ld][member_ifidx = %2ld][Notify_TrunkMemberDeleteLst]",
                trunk_ifindex, member_ifindex);

    SWCTRL_GROUP_TrunkMemberDeleteLstCallbackHandler(trunk_ifindex, member_ifindex);
    SYS_CALLBACK_MGR_TrunkMemberDeleteLstCallback(SYS_MODULE_SWCTRL, trunk_ifindex, member_ifindex);
} /* End of SWCTRL_Notify_TrunkMemberDeleteLst() */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_Notify_PortLinkUp
 * -------------------------------------------------------------------------
 * FUNCTION: Call call-back function, when the link is up
 * INPUT   : ifindex -- which logical port
 * OUTPUT  : None
 * RETURN  : None
 * NOTE    : None
 * -------------------------------------------------------------------------*/
static void SWCTRL_Notify_PortLinkUp(UI32_T ifindex)
{
    if (SWCTRL_BACKDOOR_IsDebugFlagOn (SWCTRL_BACKDOOR_DEBUG_FLAG_CALLBACK_NOTIFY))
        BACKDOOR_MGR_Printf("\r\n[ifindex = %2ld    ][                 ][Notify_PortLinkUp]",ifindex);

    SWCTRL_GROUP_PortLinkUpCallbackHandler(ifindex);
    SYS_CALLBACK_MGR_PortLinkUpCallback(SYS_MODULE_SWCTRL, ifindex);
} /* End of SWCTRL_Notify_PortLinkUp() */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_Notify_uPortLinkUp
 * -------------------------------------------------------------------------
 * FUNCTION: Call call-back function, when the link is up
 * INPUT   : unit -- in which unit
 *           port -- which logical port
 * OUTPUT  : None
 * RETURN  : None
 * NOTE    : None
 * -------------------------------------------------------------------------*/
static void SWCTRL_Notify_uPortLinkUp(UI32_T unit,
                                      UI32_T port)
{
    if (SWCTRL_BACKDOOR_IsDebugFlagOn (SWCTRL_BACKDOOR_DEBUG_FLAG_CALLBACK_NOTIFY))
    {
        UI32_T days        = 0;
        UI32_T hours       = 0;
        UI32_T minutes     = 0;
        UI32_T seconds     = 0;
        UI32_T miliseconds = 0;

        BACKDOOR_MGR_Printf("\r\n[unit,port = %ld,%2ld][                 ][Notify_uPortLinkUp]",unit, port);

        SYS_TIME_GetSystemUpTime(&days,&hours,&minutes,&seconds,&miliseconds);

        /* system up time
         */
        BACKDOOR_MGR_Printf("\r\nSystem Up time: ");
        BACKDOOR_MGR_Printf("%lu days, %lu hours, %lu minutes, and", days, hours, minutes);
        BACKDOOR_MGR_Printf(" %lu.%lu seconds\r\n", seconds, miliseconds);
    }

    SWCTRL_GROUP_uPortLinkUpCallbackHandler(unit, port);
    SYS_CALLBACK_MGR_uPortLinkUpCallback(SYS_MODULE_SWCTRL, unit, port);
} /* End of SWCTRL_Notify_uPortLinkUp() */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_Notify_uPortFastLinkUp
 * -------------------------------------------------------------------------
 * FUNCTION: Call call-back function, when the link is up
 * INPUT   : unit -- in which unit
 *           port -- which logical port
 * OUTPUT  : None
 * RETURN  : None
 * NOTE    : None
 * -------------------------------------------------------------------------*/
static void SWCTRL_Notify_uPortFastLinkUp(UI32_T unit,
                                          UI32_T port)
{
    if (SWCTRL_BACKDOOR_IsDebugFlagOn (SWCTRL_BACKDOOR_DEBUG_FLAG_CALLBACK_NOTIFY))
        BACKDOOR_MGR_Printf("\r\n[unit,port = %ld,%2ld][                 ][Notify_uPortFastLinkUp]",unit, port);

    SWCTRL_GROUP_uPortFastLinkUpCallbackHandler(unit, port);
    SYS_CALLBACK_MGR_uPortFastLinkUpCallback(SYS_MODULE_SWCTRL, unit, port);
} /* End of SWCTRL_Notify_uPortLinkUp() */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_Notify_PortLinkDown
 * -------------------------------------------------------------------------
 * FUNCTION: Call call-back function, when the link is down
 * INPUT   : ifindex -- which logical port
 * OUTPUT  : None
 * RETURN  : None
 * NOTE    : None
 * -------------------------------------------------------------------------*/
static void SWCTRL_Notify_PortLinkDown(UI32_T ifindex)
{
    if (SWCTRL_BACKDOOR_IsDebugFlagOn (SWCTRL_BACKDOOR_DEBUG_FLAG_CALLBACK_NOTIFY))
        BACKDOOR_MGR_Printf("\r\n[ifindex = %2ld    ][                 ][Notify_PortLinkDown]",ifindex);

    SWCTRL_GROUP_PortLinkDownCallbackHandler(ifindex);
    SYS_CALLBACK_MGR_PortLinkDownCallback(SYS_MODULE_SWCTRL, ifindex);
} /* End of SWCTRL_Notify_PortLinkDown() */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_Notify_uPortLinkDown
 * -------------------------------------------------------------------------
 * FUNCTION: Call call-back function, when the link is down
 * INPUT   : unit -- in which unit
 *           port -- which logical port
 * OUTPUT  : None
 * RETURN  : None
 * NOTE    : None
 * -------------------------------------------------------------------------*/
static void SWCTRL_Notify_uPortLinkDown(UI32_T unit,
                                        UI32_T port)
{
    if (SWCTRL_BACKDOOR_IsDebugFlagOn (SWCTRL_BACKDOOR_DEBUG_FLAG_CALLBACK_NOTIFY))
    {
        UI32_T days        = 0;
        UI32_T hours       = 0;
        UI32_T minutes     = 0;
        UI32_T seconds     = 0;
        UI32_T miliseconds = 0;

        BACKDOOR_MGR_Printf("\r\n[unit,port = %ld,%2ld][                 ][Notify_uPortLinkDown]",unit, port);

        SYS_TIME_GetSystemUpTime(&days,&hours,&minutes,&seconds,&miliseconds);

        /* system up time
         */
        BACKDOOR_MGR_Printf(" \r\nSystem Up time: ");
        BACKDOOR_MGR_Printf("%lu days, %lu hours, %lu minutes, and", days, hours, minutes);
        BACKDOOR_MGR_Printf(" %lu.%lu seconds\r\n", seconds, miliseconds);
    }

    SWCTRL_GROUP_uPortLinkDownCallbackHandler(unit, port);
    SYS_CALLBACK_MGR_uPortLinkDownCallback(SYS_MODULE_SWCTRL, unit, port);
} /* End of SWCTRL_Notify_uPortLinkDown() */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_Notify_uPortFastLinkDown
 * -------------------------------------------------------------------------
 * FUNCTION: Call call-back function, when the link is down
 * INPUT   : unit -- in which unit
 *           port -- which logical port
 * OUTPUT  : None
 * RETURN  : None
 * NOTE    : None
 * -------------------------------------------------------------------------*/
static void SWCTRL_Notify_uPortFastLinkDown(UI32_T unit,
                                            UI32_T port)
{
    if (SWCTRL_BACKDOOR_IsDebugFlagOn (SWCTRL_BACKDOOR_DEBUG_FLAG_CALLBACK_NOTIFY))
        BACKDOOR_MGR_Printf("\r\n[unit,port = %ld,%2ld][                 ][Notify_uPortFastLinkDown]",unit, port);

    SWCTRL_GROUP_uPortFastLinkDownCallbackHandler(unit, port);
    SYS_CALLBACK_MGR_uPortFastLinkDownCallback(SYS_MODULE_SWCTRL, unit, port);
} /* End of SWCTRL_Notify_uPortLinkDown() */



/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_Notify_PortOperUp
 * -------------------------------------------------------------------------
 * FUNCTION: Call call-back function, when the oper status is up
 * INPUT   : ifindex -- which logical port
 * OUTPUT  : None
 * RETURN  : None
 * NOTE    : None
 * -------------------------------------------------------------------------*/
static void SWCTRL_Notify_PortOperUp(UI32_T ifindex)
{
    if (SWCTRL_BACKDOOR_IsDebugFlagOn (SWCTRL_BACKDOOR_DEBUG_FLAG_CALLBACK_NOTIFY))
        BACKDOOR_MGR_Printf("\r\n[ifindex = %2ld    ][                 ][Notify_PortOperUp]",ifindex);

    SWCTRL_GROUP_PortOperUpCallbackHandler(ifindex);
    SYS_CALLBACK_MGR_PortOperUpCallback(SYS_MODULE_SWCTRL, ifindex);
} /* End of SWCTRL_Notify_PortOperUp() */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_Notify_PortNotOperUP
 * -------------------------------------------------------------------------
 * FUNCTION: Call call-back function, when the oper status is not up
 * INPUT   : ifindex -- which logical port
 * OUTPUT  : None
 * RETURN  : None
 * NOTE    : None
 * -------------------------------------------------------------------------*/
static void SWCTRL_Notify_PortNotOperUp(UI32_T ifindex)
{
    if (SWCTRL_BACKDOOR_IsDebugFlagOn (SWCTRL_BACKDOOR_DEBUG_FLAG_CALLBACK_NOTIFY))
        BACKDOOR_MGR_Printf("\r\n[ifindex = %2ld    ][                 ][Notify_PortNotOperUp]",ifindex);

    SWCTRL_GROUP_PortNotOperUpCallbackHandler(ifindex);
    SYS_CALLBACK_MGR_PortNotOperUpCallback(SYS_MODULE_SWCTRL, ifindex);
} /* End of SWCTRL_Notify_PortNotOperUp() */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_Notify_TrunkMemberPortOperUp
 * -------------------------------------------------------------------------
 * FUNCTION: Call call-back function, when the oper status is up
 * INPUT   : ifindex -- which logical port
 * OUTPUT  : None
 * RETURN  : None
 * NOTE    : None
 * -------------------------------------------------------------------------*/
static void SWCTRL_Notify_TrunkMemberPortOperUp(UI32_T trunk_ifindex,
                                                UI32_T trunk_member_port_ifindex)
{
    if (SWCTRL_BACKDOOR_IsDebugFlagOn (SWCTRL_BACKDOOR_DEBUG_FLAG_CALLBACK_NOTIFY))
        BACKDOOR_MGR_Printf("\r\n[trunk_ifidx = %2ld][member_ifidx = %2ld][Notify_TrunkMemberPortOperUp]",
                trunk_ifindex, trunk_member_port_ifindex);

    SWCTRL_GROUP_TrunkMemberPortOperUpCallbackHandler(trunk_ifindex, trunk_member_port_ifindex);
    SYS_CALLBACK_MGR_TrunkMemberPortOperUpCallback(SYS_MODULE_SWCTRL, trunk_ifindex, trunk_member_port_ifindex);
} /* End of SWCTRL_Notify_TrunkMemberPortOperUp() */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_Notify_TrunkMemberPortNotOperUp
 * -------------------------------------------------------------------------
 * FUNCTION: Call call-back function, when the oper status is down
 * INPUT   : ifindex -- which logical port
 * OUTPUT  : None
 * RETURN  : None
 * NOTE    : None
 * -------------------------------------------------------------------------*/
static void SWCTRL_Notify_TrunkMemberPortNotOperUp(UI32_T trunk_ifindex,
                                                   UI32_T trunk_member_port_ifindex)
{
    if (SWCTRL_BACKDOOR_IsDebugFlagOn (SWCTRL_BACKDOOR_DEBUG_FLAG_CALLBACK_NOTIFY))
        BACKDOOR_MGR_Printf("\r\n[trunk_ifidx = %2ld][member_ifidx = %2ld][Notify_TrunkMemberPortNotOperUp]",
                trunk_ifindex, trunk_member_port_ifindex);

    SWCTRL_GROUP_TrunkMemberPortNotOperUpCallbackHandler(trunk_ifindex, trunk_member_port_ifindex);
    SYS_CALLBACK_MGR_TrunkMemberPortNotOperUpCallback(SYS_MODULE_SWCTRL, trunk_ifindex, trunk_member_port_ifindex);
} /* End of SWCTRL_Notify_TrunkMemberPortNotOperUp() */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_Notify_TrunkMemberActive
 * -------------------------------------------------------------------------
 * FUNCTION: Call call-back function, when member port is active
 * INPUT   : ifindex -- which logical port
 * OUTPUT  : None
 * RETURN  : None
 * NOTE    : None
 * -------------------------------------------------------------------------*/
static void SWCTRL_Notify_TrunkMemberActive(UI32_T trunk_ifindex,
                                            UI32_T trunk_member_port_ifindex)
{
    if (SWCTRL_BACKDOOR_IsDebugFlagOn (SWCTRL_BACKDOOR_DEBUG_FLAG_CALLBACK_NOTIFY))
        BACKDOOR_MGR_Printf("\r\n[trunk_ifidx = %2ld][member_ifidx = %2ld][Notify_TrunkMemberActive]",
                trunk_ifindex, trunk_member_port_ifindex);

    SWCTRL_GROUP_TrunkMemberActiveCallbackHandler(trunk_ifindex, trunk_member_port_ifindex);
    SYS_CALLBACK_MGR_TrunkMemberActiveCallback(SYS_MODULE_SWCTRL, trunk_ifindex, trunk_member_port_ifindex);
} /* End of SWCTRL_Notify_TrunkMemberPortNotOperUp() */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_Notify_TrunkMemberInactive
 * -------------------------------------------------------------------------
 * FUNCTION: Call call-back function, when member port is inactive
 * INPUT   : ifindex -- which logical port
 * OUTPUT  : None
 * RETURN  : None
 * NOTE    : None
 * -------------------------------------------------------------------------*/
static void SWCTRL_Notify_TrunkMemberInactive(UI32_T trunk_ifindex,
                                              UI32_T trunk_member_port_ifindex)
{
    if (SWCTRL_BACKDOOR_IsDebugFlagOn (SWCTRL_BACKDOOR_DEBUG_FLAG_CALLBACK_NOTIFY))
        BACKDOOR_MGR_Printf("\r\n[trunk_ifidx = %2ld][member_ifidx = %2ld][Notify_TrunkMemberInactive]",
                trunk_ifindex, trunk_member_port_ifindex);

    SWCTRL_GROUP_TrunkMemberInactiveCallbackHandler(trunk_ifindex, trunk_member_port_ifindex);
    SYS_CALLBACK_MGR_TrunkMemberInactiveCallback(SYS_MODULE_SWCTRL, trunk_ifindex, trunk_member_port_ifindex);
} /* End of SWCTRL_Notify_TrunkMemberPortNotOperUp() */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_Notify_PortAdminEnable
 * -------------------------------------------------------------------------
 * FUNCTION: Call call-back function, when the port is enabled
 * INPUT   : ifindex -- which logical port
 * OUTPUT  : None
 * RETURN  : None
 * NOTE    : None
 * -------------------------------------------------------------------------*/
static void SWCTRL_Notify_PortAdminEnable(UI32_T ifindex)
{
    if (SWCTRL_BACKDOOR_IsDebugFlagOn (SWCTRL_BACKDOOR_DEBUG_FLAG_CALLBACK_NOTIFY))
        BACKDOOR_MGR_Printf("\r\n[ifindex = %2ld    ][                 ][Notify_PortAdminEnable",ifindex);

    SWCTRL_GROUP_PortAdminEnableCallbackHandler(ifindex);
    SYS_CALLBACK_MGR_PortAdminEnableCallback(SYS_MODULE_SWCTRL, ifindex);
} /* End of SWCTRL_Notify_PortAdminEnable() */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_Notify_uPortAdminEnable
 * -------------------------------------------------------------------------
 * FUNCTION: Call call-back function, when the port is enabled
 * INPUT   : unit -- in which unit
 *           port -- which logical port
 * OUTPUT  : None
 * RETURN  : None
 * NOTE    : None
 * -------------------------------------------------------------------------*/
static void SWCTRL_Notify_uPortAdminEnable(UI32_T unit,
                                           UI32_T port)
{
    if (SWCTRL_BACKDOOR_IsDebugFlagOn (SWCTRL_BACKDOOR_DEBUG_FLAG_CALLBACK_NOTIFY))
        BACKDOOR_MGR_Printf("\r\n[unit,port = %ld,%2ld][                 ][Notify_uPortAdminEnable]",unit, port);

    SWCTRL_GROUP_uPortAdminEnableCallbackHandler(unit, port);
    SYS_CALLBACK_MGR_uPortAdminEnableCallback(SYS_MODULE_SWCTRL, unit, port);
} /* End of SWCTRL_Notify_uPortAdminEnable() */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_Notify_PortAdminDisable
 * -------------------------------------------------------------------------
 * FUNCTION: Call call-back function, when the port is disabled
 * INPUT   : ifindex -- which logical port
 * OUTPUT  : None
 * RETURN  : None
 * NOTE    : None
 * -------------------------------------------------------------------------*/
static void SWCTRL_Notify_PortAdminDisable(UI32_T ifindex)
{
    if (SWCTRL_BACKDOOR_IsDebugFlagOn (SWCTRL_BACKDOOR_DEBUG_FLAG_CALLBACK_NOTIFY))
        BACKDOOR_MGR_Printf("\r\n[ifindex = %2ld    ][                 ][Notify_PortAdminDisable]",ifindex);

    SWCTRL_GROUP_PortAdminDisableCallbackHandler(ifindex);
    SYS_CALLBACK_MGR_PortAdminDisableCallback(SYS_MODULE_SWCTRL, ifindex);
} /* End of SWCTRL_Notify_PortAdminDisable() */

#if 0 /* obsolete, moved to cmgr */
#if (SYS_CPNT_LLDP == TRUE)
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_Notify_PortAdminDisable
 * -------------------------------------------------------------------------
 * FUNCTION: Call call-back function, when the port is disabled
 * INPUT   : ifindex -- which logical port
 * OUTPUT  : None
 * RETURN  : None
 * NOTE    : for notify LLDP before doing shutdown port
 * -------------------------------------------------------------------------*/
static void SWCTRL_Notify_PortAdminDisableBefore(UI32_T ifindex)
{
    if (SWCTRL_BACKDOOR_IsDebugFlagOn (SWCTRL_BACKDOOR_DEBUG_FLAG_CALLBACK_NOTIFY))
        printf("\r\n[ifindex = %2ld    ][                 ][Notify_PortAdminDisableBefore]",ifindex);

    SWCTRL_GROUP_PortAdminDisableBeforeCallbackHandler(ifindex);
    SYS_CALLBACK_MGR_PortAdminDisableBeforeCallback(SYS_MODULE_SWCTRL, ifindex);
} /* End of SWCTRL_Notify_PortAdminDisableBefoer() */
#endif
#endif

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_Notify_uPortAdminDisable
 * -------------------------------------------------------------------------
 * FUNCTION: Call call-back function, when the port is disabled
 * INPUT   : unit -- in which unit
 *           port -- which logical port
 * OUTPUT  : None
 * RETURN  : None
 * NOTE    : None
 * -------------------------------------------------------------------------*/
static void SWCTRL_Notify_uPortAdminDisable(UI32_T unit,
                                            UI32_T port)
{
    if (SWCTRL_BACKDOOR_IsDebugFlagOn (SWCTRL_BACKDOOR_DEBUG_FLAG_CALLBACK_NOTIFY))
        BACKDOOR_MGR_Printf("\r\n[unit,port = %ld,%2ld][                 ][Notify_uPortAdminDisable]",unit, port);

    SWCTRL_GROUP_uPortAdminDisableCallbackHandler(unit, port);
    SYS_CALLBACK_MGR_uPortAdminDisableCallback(SYS_MODULE_SWCTRL, unit, port);
} /* End of SWCTRL_Notify_uPortAdminDisable() */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_Notify_PortStatusChangedPassively
 * -------------------------------------------------------------------------
 * FUNCTION: Call call-back function, when the port status is changed passively
 * INPUT   : ifindex -- which logical port
 *           status
 *           changed_bmp
 * OUTPUT  : None
 * RETURN  : None
 * NOTE    : None
 * -------------------------------------------------------------------------*/
static void SWCTRL_Notify_PortStatusChangedPassively(UI32_T ifindex, BOOL_T status, UI32_T changed_bmp)
{
    if (SWCTRL_BACKDOOR_IsDebugFlagOn (SWCTRL_BACKDOOR_DEBUG_FLAG_CALLBACK_NOTIFY))
        BACKDOOR_MGR_Printf("\r\n[ifindex = %2ld    ][                 ][Notify_PortStatusChangedPassively",ifindex);

    SWCTRL_GROUP_PortStatusChangedPassivelyCallbackHandler(ifindex, status, changed_bmp);
    SYS_CALLBACK_MGR_PortStatusChangedPassivelyCallback(SYS_MODULE_SWCTRL, ifindex, status, changed_bmp);
} /* End of SWCTRL_Notify_PortAdminEnable() */



/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_Notify_PortSpeedDuplex
 * -------------------------------------------------------------------------
 * FUNCTION: Call call-back function, when the speed/duplex status of a port
 *           is changed
 * INPUT   : ifindex -- which logical port
 *           speed_duplex -- new status of speed/duplex
 * OUTPUT  : None
 * RETURN  : None
 * NOTE    : None
 * -------------------------------------------------------------------------*/
static void SWCTRL_Notify_PortSpeedDuplex(UI32_T ifindex,
                                          UI32_T speed_duplex)
{
    if (SWCTRL_BACKDOOR_IsDebugFlagOn (SWCTRL_BACKDOOR_DEBUG_FLAG_CALLBACK_NOTIFY))
        BACKDOOR_MGR_Printf("\r\n[ifindex = %2ld    ][spd_dpx = %ld      ][Notify_PortSpeedDuplex]", ifindex, speed_duplex);

    SWCTRL_GROUP_PortSpeedDuplexCallbackHandler(ifindex, speed_duplex);
    SYS_CALLBACK_MGR_PortSpeedDuplexCallback(SYS_MODULE_SWCTRL, ifindex, speed_duplex);
} /* End of SWCTRL_Notify_PortSpeedDuplex() */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_Notify_uPortSpeedDuplex
 * -------------------------------------------------------------------------
 * FUNCTION: Call call-back function, when the speed/duplex status of a port
 *           is changed
 * INPUT   : unit -- in which unit
 *           port -- which logical port
 *           speed_duplex -- new status of speed/duplex
 * OUTPUT  : None
 * RETURN  : None
 * NOTE    : None
 * -------------------------------------------------------------------------*/
static void SWCTRL_Notify_uPortSpeedDuplex(UI32_T unit,
                                           UI32_T port,
                                           UI32_T speed_duplex)
{
    if (SWCTRL_BACKDOOR_IsDebugFlagOn (SWCTRL_BACKDOOR_DEBUG_FLAG_CALLBACK_NOTIFY))
        BACKDOOR_MGR_Printf("\r\n[unit,port = %ld,%2ld][spd_dpx = %ld      ][Notify_uPortSpeedDuplex]",unit, port, speed_duplex);

    SWCTRL_GROUP_uPortSpeedDuplexCallbackHandler(unit, port,speed_duplex);
    SYS_CALLBACK_MGR_uPortSpeedDuplexCallback(SYS_MODULE_SWCTRL, unit, port,speed_duplex);
} /* End of SWCTRL_Notify_uPortSpeedDuplex() */



/* Charles: swctrl_support_dot1x
 */
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_Notify_uPortLacpEffectiveOperStatusChanged
 * -------------------------------------------------------------------------
 * FUNCTION: Call call-back function, when the effective oper status change
 *           for LACP.
 *           is changed
 * INPUT   : unit           --- which unit
 *           port           --- which port
 *           pre_status     --- status before change
 *           current_status --- status after change
 * OUTPUT  : None
 * RETURN  : None
 * NOTE    : None
 * -------------------------------------------------------------------------*/
static void SWCTRL_Notify_uPortLacpEffectiveOperStatusChanged(UI32_T unit,       UI32_T port,
                                                              UI32_T pre_status, UI32_T current_status )
{
    if (SWCTRL_BACKDOOR_IsDebugFlagOn (SWCTRL_BACKDOOR_DEBUG_FLAG_CALLBACK_NOTIFY))
        BACKDOOR_MGR_Printf("\r\n[unit,port = %ld,%2ld][pre_status = %ld, current_status = %ld]\r\n[SWCTRL_Notify_uPortLacpEffectiveOperStatusChanged]",unit, port, pre_status, current_status);

    SWCTRL_GROUP_uPortLacpEffectiveOperStatusChangedCallbackHandler(unit, port,pre_status, current_status);
    SYS_CALLBACK_MGR_uPortLacpEffectiveOperStatusChangedCallback(SYS_MODULE_SWCTRL, unit, port,pre_status, current_status);
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_Notify_uPortDot1xEffectiveOperStatusChanged
 * -------------------------------------------------------------------------
 * FUNCTION: Call call-back function, when the effective oper status change
 *           for DOT1x.
 * INPUT   : unit           --- which unit
 *           port           --- which port
 *           pre_status     --- status before change
 *           current_status --- status after change
 * OUTPUT  : None
 * RETURN  : None
 * NOTE    : None
 * -------------------------------------------------------------------------*/
static void SWCTRL_Notify_uPortDot1xEffectiveOperStatusChanged(UI32_T unit,       UI32_T port,
                                                               UI32_T pre_status, UI32_T current_status )
{
    if (SWCTRL_BACKDOOR_IsDebugFlagOn (SWCTRL_BACKDOOR_DEBUG_FLAG_CALLBACK_NOTIFY))
        BACKDOOR_MGR_Printf("\r\n[unit,port = %ld,%2ld][pre_status = %ld, current_status = %ld]\r\n[SWCTRL_Notify_uPortDot1xEffectiveOperStatusChanged]",unit, port, pre_status, current_status);

    SWCTRL_GROUP_uPortDot1xEffectiveOperStatusChangedCallbackHandler(unit, port,pre_status, current_status);
    SYS_CALLBACK_MGR_uPortDot1xEffectiveOperStatusChangedCallback(SYS_MODULE_SWCTRL, unit, port,pre_status, current_status);
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_Notify_PortEffectiveOperStatusChanged
 * -------------------------------------------------------------------------
 * FUNCTION: Call call-back function, when the effective oper status change.
 * INPUT   : ifindex        --- which ifindex
 *           pre_status     --- status before change
 *           current_status --- status after change
 *           current_level  --- see SWCTRL_OperDormantLevel_T,
 *                              dormant level after change
 *           target_level   --- the dormant level is affected by this change.
 * OUTPUT  : None
 * RETURN  : None
 * NOTE    : When to callback:
 *           1) Oper status becomes effecitve.
 *              Oper status is changed from lower status to specified dormant
 *              status.
 *           2) Oper status becomes ineffecitve.
 *              Oper status is changed from specified dormant status or upper
 *              status to lower status.
 * -------------------------------------------------------------------------*/
static void SWCTRL_Notify_PortEffectiveOperStatusChanged(
    UI32_T ifindex,
    UI32_T pre_status,
    UI32_T current_status,
    SWCTRL_OperDormantLevel_T current_level,
    SWCTRL_OperDormantLevel_T target_level)
{
    UI32_T msgq_key;

    if (SWCTRL_BACKDOOR_IsDebugFlagOn (SWCTRL_BACKDOOR_DEBUG_FLAG_CALLBACK_NOTIFY))
        BACKDOOR_MGR_Printf("\r\n[ifindex = %ld][pre_status = %ld, current_status = %ld, current_level = %d, target_level = %d]\r\n[SWCTRL_Notify_PortEffectiveOperStatusChanged]", ifindex, pre_status, current_status, current_level, target_level);

    /* convert target_level to msgq_key
     */
    switch (target_level)
    {
#if (SYS_CPNT_MLAG == TRUE)
        case SWCTRL_OPER_DORMANT_LV_MLAG:
            msgq_key = SYS_BLD_MLAG_GROUP_IPCMSGQ_KEY;
            break;
#endif

        default:
            msgq_key = SYSFUN_MSGQKEY_PRIVATE;
            break;
    }

    /* notify event by msgq_key
     */
    if (msgq_key == SYS_BLD_SWCTRL_GROUP_IPCMSGQ_KEY)
    {
        SWCTRL_GROUP_PortEffectiveOperStatusChangedCallbackHandler(ifindex, pre_status, current_status, current_level);
    }
    else if (msgq_key != SYSFUN_MSGQKEY_PRIVATE)
    {
        SYS_CALLBACK_MGR_PortEffectiveOperStatusChangedCallback(SYS_MODULE_SWCTRL, msgq_key, ifindex, pre_status, current_status, current_level);
    }
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_Notify_ForwardingUPortAddToTrunk
 * -------------------------------------------------------------------------
 * FUNCTION: Call call-back function, when forwarding uport added to trunk.
 * INPUT   : trunk_ifindex  - Which trunk.
 *           member_ifindex - Which trunk member.
 * OUTPUT  : None.
 * RETURN  : None.
 * NOTE    : None.
 * -------------------------------------------------------------------------*/
static void SWCTRL_Notify_ForwardingUPortAddToTrunk(UI32_T trunk_ifindex, UI32_T member_ifindex)
{
    if (SWCTRL_BACKDOOR_IsDebugFlagOn (SWCTRL_BACKDOOR_DEBUG_FLAG_CALLBACK_NOTIFY))
        BACKDOOR_MGR_Printf("\n\r[trunk_ifindex,member_ifindex = %ld,%2ld][                 ][Notify_ForwardingUPortAddToTrunk]",trunk_ifindex, member_ifindex);

    SWCTRL_GROUP_ForwardingUPortAddToTrunkCallbackHandler(trunk_ifindex, member_ifindex);
    SYS_CALLBACK_MGR_ForwardingUPortAddToTrunkCallback(SYS_MODULE_SWCTRL, trunk_ifindex, member_ifindex);
}


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_Notify_ForwardingTrunkMemberDelete
 * -------------------------------------------------------------------------
 * FUNCTION: Call call-back function, when forwarding trunk member deleted.
 * INPUT   : trunk_ifindex  - Which trunk.
 *           member_ifindex - Which trunk member.
 * OUTPUT  : None.
 * RETURN  : None.
 * NOTE    : None.
 * -------------------------------------------------------------------------*/
static void SWCTRL_Notify_ForwardingTrunkMemberDelete(UI32_T trunk_ifindex, UI32_T member_ifindex)
{
    if (SWCTRL_BACKDOOR_IsDebugFlagOn (SWCTRL_BACKDOOR_DEBUG_FLAG_CALLBACK_NOTIFY))
        BACKDOOR_MGR_Printf("\n\r[trunk_ifindex,member_ifindex = %ld,%2ld][                 ][Notify_ForwardingTrunkMemberDelete]",trunk_ifindex, member_ifindex);

    SWCTRL_GROUP_ForwardingTrunkMemberDeleteCallbackHandler(trunk_ifindex, member_ifindex);
    SYS_CALLBACK_MGR_ForwardingTrunkMemberDeleteCallback(SYS_MODULE_SWCTRL, trunk_ifindex, member_ifindex);
}


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_Notify_ForwardingTrunkMemberToNonForwarding
 * -------------------------------------------------------------------------
 * FUNCTION: Call call-back function, when forwarding trunk member become non-forwarding.
 * INPUT   : trunk_ifindex  - Which trunk.
 *           member_ifindex - Which trunk member.
 * OUTPUT  : None.
 * RETURN  : None.
 * NOTE    : None.
 * -------------------------------------------------------------------------*/
static void SWCTRL_Notify_ForwardingTrunkMemberToNonForwarding(UI32_T trunk_ifindex, UI32_T member_ifindex)
{
    if (SWCTRL_BACKDOOR_IsDebugFlagOn (SWCTRL_BACKDOOR_DEBUG_FLAG_CALLBACK_NOTIFY))
        BACKDOOR_MGR_Printf("\n\r[trunk_ifindex,member_ifindex = %ld,%2ld][                 ][Notify_ForwardingTrunkMemberToNonForwarding]",trunk_ifindex, member_ifindex);

    SWCTRL_GROUP_ForwardingTrunkMemberToNonForwardingCallbackHandler(trunk_ifindex, member_ifindex);
    SYS_CALLBACK_MGR_ForwardingTrunkMemberToNonForwardingCallback(SYS_MODULE_SWCTRL, trunk_ifindex, member_ifindex);
}


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_Notify_PortLearningStatusChanged
 * -------------------------------------------------------------------------
 * FUNCTION: Call call-back function, when learning status is changed
 * INPUT   : trunk_ifindex  - Which trunk.
 *           member_ifindex - Which trunk member.
 * OUTPUT  : None.
 * RETURN  : None.
 * NOTE    : None.
 * -------------------------------------------------------------------------*/
static void SWCTRL_Notify_PortLearningStatusChanged(UI32_T lport, BOOL_T learning)
{
    if (SWCTRL_BACKDOOR_IsDebugFlagOn (SWCTRL_BACKDOOR_DEBUG_FLAG_CALLBACK_NOTIFY))
        BACKDOOR_MGR_Printf("\n\r[lport,learning = %ld,%2d][                 ][Notify_PortLearningStatusChanged]", lport, learning);

    SWCTRL_GROUP_PortLearningStatusChangedCallbackHandler(lport, learning);
    SYS_CALLBACK_MGR_PortLearningStatusChangedCallback(SYS_MODULE_SWCTRL, lport, learning);
}

/****************************************************************************/
/* Port Configuration                                                       */
/****************************************************************************/

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_isPortLinkUp
 * -------------------------------------------------------------------------
 * FUNCTION: This function will check the port is link up or not
 * INPUT   : ifindex   -- which port to get
 * OUTPUT  : None
 * RETURN  : TRUE: Link Up, FALSE: Link Down
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_isPortLinkUp(UI32_T ifindex)
{
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (ifindex == 0 || ifindex > SYS_ADPT_TOTAL_NBR_OF_LPORT)
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Logical Port ID (1-%d)", SYS_ADPT_TOTAL_NBR_OF_LPORT);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_LOGICAL_PORT_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (!SWCTRL_IS_EXIST (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Interface");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    SWCTRL_RETURN_AND_RELEASE_CSC( SWCTRL_IS_LINK_UP(ifindex) );
} /* End of SWCTRL_isPortLinkUp() */

#if (SYS_CPNT_PFC == TRUE)
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_isPortFlowControlEnabled
 * -------------------------------------------------------------------------
 * FUNCTION: This function will check the port is flow control enabled or not
 * INPUT   : ifindex   -- which port to get
 * OUTPUT  : None
 * RETURN  : TRUE/FALSE
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_isPortFlowControlEnabled(UI32_T ifindex)
{
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (ifindex == 0 || ifindex > SYS_ADPT_TOTAL_NBR_OF_LPORT)
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Logical Port ID (1-%d)", SYS_ADPT_TOTAL_NBR_OF_LPORT);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_LOGICAL_PORT_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (!SWCTRL_IS_EXIST (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Interface");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    {
        BOOL_T  ret = TRUE;

        if (  (VAL_portFlowCtrlCfg_disabled == port_info[ifindex-1].port_entry.port_flow_ctrl_cfg)
            &&(0 == (SYS_VAL_portCapabilities_portCapFlowCtrl & port_info[ifindex-1].port_entry.port_capabilities))
           )
        {
            ret = FALSE;
        }

        SWCTRL_RETURN_AND_RELEASE_CSC( ret );
    }
} /* End of SWCTRL_isPortFlowControlEnabled() */
#endif /* #if (SYS_CPNT_PFC == TRUE) */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetPortInfo
 * -------------------------------------------------------------------------
 * FUNCTION: This function will get all information of a port
 * INPUT   : ifindex   -- which port to get
 * OUTPUT  : p_info -- all information of this port
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_GetPortInfo(UI32_T ifindex, Port_Info_T *p_info)
{
    UI32_T unit;
    UI32_T port;
    UI32_T trunk_id;
    UI32_T local_ifindex = ifindex;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if(ifindex == 0 || ifindex > SYS_ADPT_TOTAL_NBR_OF_LPORT)
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Logical Port ID (1-%d)", SYS_ADPT_TOTAL_NBR_OF_LPORT);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_LOGICAL_PORT_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if(p_info == 0)
    {
        EH_MGR_Handle_Exception (SYS_MODULE_SWCTRL,
                                 SWCTRL_NO_USE_FUNC_NO,
                                 EH_TYPE_MSG_NULL_POINTER,
                                 EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_CRIT); /*SWCTRL_ENO_NULL_POINTER*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (!SWCTRL_IS_EXIST (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  SYSLOG_LEVEL_INFO,
                                  "Interface");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    /* port type */
    if( SWCTRL_LogicalPortToUserPort(ifindex, &unit, &port, &trunk_id) == SWCTRL_LPORT_TRUNK_PORT )
    {
        /* trunk port
         */
        if (!SWCTRL_GetTrunkPrimaryPort(ifindex, &local_ifindex))
        {
            /* This is temporary solution.
             * Need to spec change,
             * i.e
             * If a trunk has no member,
             * this API should return FALSE.
             */
            local_ifindex = ifindex;
        }

        /* port type
         */
        p_info->port_type = port_info[local_ifindex - 1].port_entry.port_type;

        /* autoneg state */
        p_info->autoneg_state = port_info[local_ifindex-1].port_entry.port_autonegotiation;

        /* autoneg capability
         */
        p_info->autoneg_capability = port_info[local_ifindex - 1].port_entry.port_capabilities;
        /* MDIX mode
         */
#if (SYS_CPNT_SWCTRL_MDIX_CONFIG == TRUE)
        p_info->port_MDIX_mode = port_info[local_ifindex - 1].port_entry.port_MDIX_mode;
#endif
        /* speed duplex oper status
         */
        p_info->speed_duplex_oper = port_info[local_ifindex - 1].port_entry.port_speed_dpx_status;

        /* flow control oper status */
        p_info->flow_control_oper = port_info[local_ifindex -1].port_entry.port_flow_ctrl_status;

        /* max frame size
         */
        SWCTRL_GetTrunkMaxFrameSize(
            ifindex,
            &p_info->untagged_max_frame_sz,
            &p_info->tagged_max_frame_sz);

#if (SYS_CPNT_SWCTRL_FEC == TRUE)
        p_info->port_fec_mode = VAL_portFecMode_invalid;
        p_info->port_fec_status = VAL_portFecMode_invalid;
#endif
    }
    else /* must be SWCTRL_LPORT_TRUNK_PORT_MEMBER or SWCTRL_LPORT_NORMAL_PORT*/
    {
        /* normal port
         */
        /* port type
         */
        p_info->port_type = port_info[ifindex - 1].port_entry.port_type;

        /* autoneg state */
        p_info->autoneg_state = port_info[ifindex-1].port_entry.port_autonegotiation;

        /* autoneg capability
         */
        p_info->autoneg_capability = port_info[ifindex - 1].port_entry.port_capabilities;
        /* MDIX mode
         */
#if (SYS_CPNT_SWCTRL_MDIX_CONFIG == TRUE)
        p_info->port_MDIX_mode = port_info[ifindex - 1].port_entry.port_MDIX_mode;
#endif

        /* speed duplex oper status
         */
        p_info->speed_duplex_oper = port_info[ifindex - 1].port_entry.port_speed_dpx_status;

        /* flow control oper status */
        p_info->flow_control_oper = port_info[ifindex-1].port_entry.port_flow_ctrl_status;

        /* max frame size
         */
        p_info->untagged_max_frame_sz = user_ext_port_info[ifindex-1].untagged_max_frame_sz;
        p_info->tagged_max_frame_sz = user_ext_port_info[ifindex-1].tagged_max_frame_sz;

#if (SYS_CPNT_SWCTRL_FEC == TRUE)
        p_info->port_fec_mode = user_ext_port_info[ifindex-1].port_fec_mode;
        p_info->port_fec_status = user_ext_port_info[ifindex-1].port_fec_status;
#endif
    }

    /* admin state */
    p_info->admin_state = port_info[ifindex-1].admin_status;

    /* bandwidth */
    p_info->bandwidth = port_info[ifindex-1].bandwidth;

#if (SYS_CPNT_SWCTRL_MDIX_CONFIG == TRUE)
    p_info->port_MDIX_mode = port_info[local_ifindex - 1].port_entry.port_MDIX_mode;
#endif

    /* speed duplex cfg */
    p_info->speed_duplex_cfg = port_info[local_ifindex-1].port_entry.port_speed_dpx_cfg;

    /* link oper status */
    p_info->link_oper_status = port_info[ifindex-1].link_oper_status;

    /* link status */
    p_info->link_status =
        SWCTRL_IS_LINK_UP(ifindex) ? SWCTRL_LINK_UP : SWCTRL_LINK_DOWN;

    p_info->shutdown_reason = port_info[ifindex-1].shutdown_status;

    /* link change trap */
    p_info->link_change_trap = port_info[ifindex-1].link_change_trap;

    /* flow control cfg */
    p_info->flow_control_cfg = port_info[local_ifindex-1].port_entry.port_flow_ctrl_cfg;

    /* last change time */
    p_info->link_oper_status_last_change = port_info[ifindex-1].link_oper_status_last_change;

    /* port up time */
    if (SWCTRL_IS_OPER_UP(ifindex))
    {
        UI32_T sys_uptime;

        SYS_TIME_GetSystemUpTimeByTick(&sys_uptime);

        p_info->uptime = sys_uptime - port_info[ifindex-1].link_oper_status_last_up;
    }
    else
    {
        p_info->uptime = 0;
    }

    /* broadcast storm control state */
    p_info->bsctrl_state = port_info[ifindex-1].bcast_storm_entry.bcast_storm_status;

    switch (port_info[ifindex-1].bcast_storm_entry.bcast_storm_sample_type)
    {
    case VAL_bcastStormSampleType_pkt_rate:
        p_info->bcast_rate_limit = port_info[ifindex-1].bcast_storm_entry.bcast_storm_pkt_rate;
        break;

    case VAL_bcastStormSampleType_octet_rate:
        p_info->bcast_rate_limit = port_info[ifindex-1].bcast_storm_entry.bcast_storm_octet_rate;
        break;

    case VAL_bcastStormSampleType_percent:
        p_info->bcast_rate_limit = port_info[ifindex-1].bcast_storm_entry.bcast_storm_percent;
        break;
    }

    /* broadcast rate mode */
    p_info->bcast_rate_mode = port_info[ifindex-1].bcast_storm_entry.bcast_storm_sample_type;

    /* multicast storm control state */
    p_info->msctrl_state = port_info[ifindex-1].mcast_storm_entry.mcast_storm_status;

    switch (port_info[ifindex-1].mcast_storm_entry.mcast_storm_sample_type)
    {
        case VAL_mcastStormSampleType_pkt_rate:
        p_info->mcast_rate_limit = port_info[ifindex-1].mcast_storm_entry.mcast_storm_pkt_rate;
        break;
        case VAL_mcastStormSampleType_octet_rate:
        p_info->mcast_rate_limit = port_info[ifindex-1].mcast_storm_entry.mcast_storm_octet_rate;
        break;
        case VAL_mcastStormSampleType_percent:
        p_info->mcast_rate_limit = port_info[ifindex-1].mcast_storm_entry.mcast_storm_percent;
        break;
    }

    /* multicast rate mode */
    p_info->mcast_rate_mode = port_info[ifindex-1].mcast_storm_entry.mcast_storm_sample_type;

#if (SYS_CPNT_STORM_MODE & SYS_CPNT_STORM_UNKNOWN_USTORM)
    /* Unknow unicast storm control state */
    p_info->unknown_usctrl_state = port_info[ifindex-1].unknown_ucast_storm_entry.unknown_ucast_storm_status;

    switch (port_info[ifindex-1].unknown_ucast_storm_entry.unknown_ucast_storm_sample_type)
    {
        case VAL_unkucastStormSampleType_pkt_rate:
        p_info->unknown_ucast_rate_limit = port_info[ifindex-1].unknown_ucast_storm_entry.unknown_ucast_storm_pkt_rate;
        break;
        case VAL_unkucastStormSampleType_octet_rate:
        p_info->unknown_ucast_rate_limit = port_info[ifindex-1].unknown_ucast_storm_entry.unknown_ucast_storm_octet_rate;
        break;
        case VAL_unkucastStormSampleType_percent:
        p_info->unknown_ucast_rate_limit = port_info[ifindex-1].unknown_ucast_storm_entry.unknown_ucast_storm_percent;
        break;
    }

    /* unknow unicast rate mode */
    p_info->unknown_ucast_rate_mode = port_info[ifindex-1].unknown_ucast_storm_entry.unknown_ucast_storm_sample_type;
#endif

#if (SYS_CPNT_INGRESS_RATE_LIMIT == TRUE)
    /* ingress rate limit */
    p_info->ingress_rate_limit = port_info[ifindex-1].ingress_rate_limit;
    p_info->ingress_rate_limit_status = port_info[ifindex-1].ingress_rate_limit_status;

    if (p_info->ingress_rate_limit == 0)
    {
        p_info->ingress_rate_limit = SWCTRL_GetDefaultRateLimit(port_info[ifindex-1].port_entry.port_type);
    }
#endif

#if (SYS_CPNT_EGRESS_RATE_LIMIT == TRUE)
    /* egress rate limit */
    p_info->egress_rate_limit_status = port_info[ifindex-1].egress_rate_limit_status;
    p_info->egress_rate_limit = port_info[ifindex-1].egress_rate_limit;

    if (p_info->egress_rate_limit == 0)
    {
        p_info->egress_rate_limit = SWCTRL_GetDefaultRateLimit(port_info[ifindex-1].port_entry.port_type);
    }
#endif

    /* port name */
    strncpy((char*)p_info->port_name, (char*)port_info[ifindex-1].port_entry.port_name, MAXSIZE_portName+1);
    /*EPR:ES4827G-FLF-ZZ-00232
     *Problem: CLI:size of vlan name different in console and mib
     *Solution: add CLI command "alias" for interface set,the
     *          alias is different from name and port descrition,so
     *          need add new command.
     *modify file: cli_cmd.c,cli_cmd.h,cli_arg.c,cli_arg.h,cli_msg.c,
     *             cli_msg.h,cli_api_vlan.c,cli_api_vlan.h,cli_api_ehternet.c
     *             cli_api_ethernet.h,cli_api_port_channel.c,cli_api_port_channel.h,
     *             cli_running.c,rfc_2863.c,swctrl.h,trk_mgr.h,trk_pmgr.h,swctrl.c
     *             swctrl_pmgr.c,trk_mgr.c,trk_pmgr.c,vlan_mgr.h,vlan_pmgr.h,
     *             vlan_type.h,vlan_mgr.c,vlan_pmgr.c,if_mgr.c
     *Approved by:Hardsun
     *Fixed by:Dan Xie
     */
    /* port alias */
    strncpy((char*)p_info->port_alias, (char*)port_info[ifindex-1].port_entry.port_alias, MAXSIZE_ifAlias+1);
    /* medium forced mode */
    p_info->medium_forced_mode = port_info[ifindex-1].port_entry.port_forced_mode;

    p_info->mtu= port_info[ifindex-1].port_entry.port_mtu;/*SWCTRL_SetPortMTU set port_info.mtu*/
#if(SYS_CPNT_AMTR_PORT_MAC_LEARNING == TRUE)/*Tony.Lei*/
    /*port mac learning,added by jinhua.wei
        */
    p_info->port_macaddr_learning = port_info[ifindex-1].port_entry.port_macaddr_learning ;

#endif
    /* 1000 base T force mode */
#if (SYS_CPNT_SUPPORT_FORCED_1000BASE_T_MODE == TRUE)
    p_info->forced_1000t_mode = port_info[ifindex-1].forced_1000t_mode;
#endif

#if (SYS_CPNT_SWCTRL_SWITCH_MODE_CONFIGURABLE == TRUE)
    p_info->switch_mode = port_info[ifindex-1].port_entry.switch_mode;
#endif

#ifdef VS2512A
    {
        UI16_T unit, port;
        if (SWCTRL_IS_TRUNK (ifindex))
        {
            if(trunk_ext_port_info[SWCTRL_IFINDEX_TO_TRUNKID(ifindex)-1].member_number == 0)
            {
                EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                          SWCTRL_NO_USE_FUNC_NO,
                                          EH_TYPE_MSG_TRUNK_CNFG_ERR,
                                          SYSLOG_LEVEL_INFO,
                                          "Trunk contains no members");  /*SWCTRL_ENO_NO_MEMBER_IN_TRUNK*/

                SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
            }

            unit = trunk_ext_port_info[SWCTRL_IFINDEX_TO_TRUNKID(ifindex)-1].member_list[0].unit;
            port = trunk_ext_port_info[SWCTRL_IFINDEX_TO_TRUNKID(ifindex)-1].member_list[0].port;
        }
        else
        {
            unit = SWCTRL_IFINDEX_TO_UNIT(ifindex);
            port = SWCTRL_IFINDEX_TO_PORT(ifindex);
        }
        STKTPLG_MGR_GetPortInterfaceType(unit, port, &(p_info->ethertype));
    }
#endif

    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
} /* End of SWCTRL_GetPortInfo() */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetNextPortInfo
 * -------------------------------------------------------------------------
 * FUNCTION: This function will get all information of a port
 * INPUT   : ifindex   -- the key to get
 * OUTPUT  : ifindex   -- the next existing port
 *           port_info -- all information of this port
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_GetNextPortInfo(UI32_T *ifindex, Port_Info_T *p_info)
{
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if( ifindex == 0 )
    {
        EH_MGR_Handle_Exception (SYS_MODULE_SWCTRL,
                                 SWCTRL_NO_USE_FUNC_NO,
                                 EH_TYPE_MSG_NULL_POINTER,
                                 EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_CRIT); /*SWCTRL_ENO_NULL_POINTER*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if( p_info == 0 )
    {
        EH_MGR_Handle_Exception (SYS_MODULE_SWCTRL,
                                 SWCTRL_NO_USE_FUNC_NO,
                                 EH_TYPE_MSG_NULL_POINTER,
                                 EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_CRIT); /*SWCTRL_ENO_NULL_POINTER*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    while( ++(*ifindex) <= SYS_ADPT_TOTAL_NBR_OF_LPORT )
    {
        if (SWCTRL_IS_EXIST (*ifindex))
        {
            SWCTRL_RETURN_AND_RELEASE_CSC( SWCTRL_GetPortInfo(*ifindex, p_info) );
        }

    }

    SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );

} /* End of SWCTRL_GetNextPortInfo() */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetRunningPortInfo
 * -------------------------------------------------------------------------
 * FUNCTION: This function will get the port info of running config
 *           a port
 * INPUT   : ifindex      -- which port to get
 * OUTPUT  : port_info    -- the port information
 * RETURN  : One of SYS_TYPE_Get_Running_Cfg_T
 * NOTE    : None
 * -------------------------------------------------------------------------*/
SYS_TYPE_Get_Running_Cfg_T SWCTRL_GetRunningPortInfo(UI32_T ifindex, Port_Info_T *p_info)
{
    UI32_T unit, port;
    UI32_T temp;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(SYS_TYPE_GET_RUNNING_CFG_FAIL);

    if( ifindex == 0 || ifindex > SYS_ADPT_TOTAL_NBR_OF_LPORT)
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Logical Port ID (1-%d)", SYS_ADPT_TOTAL_NBR_OF_LPORT);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_LOGICAL_PORT_ID*/

#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_FAIL );
    }

    memset (p_info, 0, sizeof(Port_Info_T));

    if (SWCTRL_GetPortInfo(ifindex, p_info))
    {
        if (!SWCTRL_IS_EXIST (ifindex))
        {
            EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                      SWCTRL_NO_USE_FUNC_NO,
                                      EH_TYPE_MSG_NOT_EXIST,
                                      SYSLOG_LEVEL_INFO,
                                      "Interface");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

            SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_FAIL );
        }

#if 0 /*remove the code to return FALSE, when dynamic trunk member, for 60 first*/
        if (SWCTRL_IS_TRUNK (ifindex))
        {
            /* return FALSE if the trunk is a dynamic trunk for LACP
             */
            if(trunk_ext_port_info[SWCTRL_IFINDEX_TO_TRUNKID(ifindex)-1].is_static == FALSE)
            {
                SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_FAIL );
            }
        }
#endif

        /* wakka, always save per-port config even though it is trunk member.
         */
#if 0
        if (SWCTRL_IS_TRUNK_MEMBER (ifindex))
        {
            /* Return FALSE if the trunk is a static trunk.
             * ( Dynamic trunk member must be treated as normal port
             *  if the port info want to be saved in flash.)
             */
            if(trunk_ext_port_info[SWCTRL_IFINDEX_TO_TRUNKID(ifindex)-1].is_static == TRUE)
            {
                SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_FAIL );
            }
        }
#endif

        if (SWCTRL_IS_USER_PORT(ifindex))
        {
            unit = SWCTRL_IFINDEX_TO_UNIT(ifindex);
            port = SWCTRL_IFINDEX_TO_PORT(ifindex);
        }
        else
        {
            unit = 0;
            port = 0;
        }

        /* port admin */
        if ((*p_info).admin_state != VAL_ifAdminStatus_up)
            (*p_info).admin_state_changed = TRUE;

#if (SWCTRL_UPDATE_PORT_ABILITY == TRUE)
        if (SWCTRL_IS_USER_PORT(ifindex))
        {
            if((*p_info).autoneg_state != SWCTRL_GetPortAutoNegStatusDfltCfg(unit, port))
                (*p_info).autoneg_state_changed = TRUE;

            /* port speed duplex config value -- only validates on force mode */
            if ((*p_info).autoneg_state == VAL_portAutonegotiation_disabled)
            {
                if((*p_info).speed_duplex_cfg != SWCTRL_GetPortCfgSpeedDuplexDfltCfg(unit, port))
                    (*p_info).speed_duplex_cfg_changed = TRUE;
            }

            if((*p_info).flow_control_cfg != SWCTRL_GetPortCfgFlowCtrlDfltCfg(unit, port))
                (*p_info).flow_control_cfg_changed = TRUE;

            (*p_info).autoneg_capability_changed =
                (*p_info).autoneg_capability ^ SWCTRL_GetPortAutoNegCapabilityDfltCfg(unit, port);

#if (SYS_CPNT_SWCTRL_FEC == TRUE)
            if ((*p_info).port_fec_mode != SWCTRL_GetPortFecDfltCfg(unit, port))
                (*p_info).port_fec_mode_changed = TRUE;
#endif
        }
#else /* (SWCTRL_UPDATE_PORT_ABILITY == TRUE) */
        /*port auto-negotiation */
        if (SWCTRL_IS_100FIBER (ifindex))
        {
            /* 100 Full & autonegatiation disable */
        }
        else
        {
            if((*p_info).autoneg_state != SYS_DFLT_PORT_AUTONEGOTIATION)
                (*p_info).autoneg_state_changed = TRUE;
        }

        /* port speed duplex config value -- only validates on force mode */
        if ((*p_info).autoneg_state == VAL_portAutonegotiation_disabled)
        {
            if( SWCTRL_IS_100TX(ifindex) || SWCTRL_IS_100FIBER(ifindex)|| SWCTRL_IS_1000T(ifindex) )
            {
                if((*p_info).speed_duplex_cfg != VAL_portSpeedDpxCfg_fullDuplex100)
                    (*p_info).speed_duplex_cfg_changed = TRUE;

                #if (SYS_CPNT_SUPPORT_FORCED_1000BASE_T_MODE == TRUE)
                /* check force mode
                 */
                if((*p_info).forced_1000t_mode != SYS_DFLT_FORCED_1000BASE_T_MASTER_SLAVE_MODE)
                    (*p_info).forced_1000t_mode_changed = TRUE;
                #endif

            }
            else if( SWCTRL_IS_10GFIBER(ifindex) || SWCTRL_IS_10GCOPPER(ifindex) )
            {
                if((*p_info).speed_duplex_cfg != VAL_portSpeedDpxCfg_fullDuplex10g)
                    (*p_info).speed_duplex_cfg_changed = TRUE;
            }
            else if ( SWCTRL_IS_25GFIBER(ifindex) )
            {
                if((*p_info).speed_duplex_cfg != VAL_portSpeedDpxCfg_fullDuplex25g)
                    (*p_info).speed_duplex_cfg_changed = TRUE;
            }
            else if ( SWCTRL_IS_40GFIBER(ifindex) )
            {
                if((*p_info).speed_duplex_cfg != VAL_portSpeedDpxCfg_fullDuplex40g)
                    (*p_info).speed_duplex_cfg_changed = TRUE;
            }
            else if ( SWCTRL_IS_100GFIBER(ifindex) )
            {
                if((*p_info).speed_duplex_cfg != VAL_portSpeedDpxCfg_fullDuplex100g)
                    (*p_info).speed_duplex_cfg_changed = TRUE;
            }
            else
            {
                if((*p_info).speed_duplex_cfg != VAL_portSpeedDpxCfg_fullDuplex1000)
                    (*p_info).speed_duplex_cfg_changed = TRUE;
            }
        }

        /* port flow contril configuration */
        if((*p_info).flow_control_cfg != SYS_DFLT_PORT_FLOW_CONTROL)
            (*p_info).flow_control_cfg_changed = TRUE;

        /* port capabilities */
        if (SWCTRL_IS_100TX             (ifindex))
            temp = SYS_DFLT_10_100_PORT_CAPABILITIES;
        else if (SWCTRL_IS_100FIBER     (ifindex))
            temp = SYS_DFLT_100_FIBER_PORT_CAPABILITIES;
        else if (SWCTRL_IS_1000FIBER    (ifindex))
            temp = SYS_DFLT_1000_FIBER_PORT_CAPABILITIES;
        else if (SWCTRL_IS_10GFIBER     (ifindex))
            temp = SYS_DFLT_10G_FIBER_PORT_CAPABILITIES;
        else if (SWCTRL_IS_10GCOPPER    (ifindex))
            temp = SYS_DFLT_10G_COPPER_PORT_CAPABILITIES;
        else if (SWCTRL_IS_40GFIBER     (ifindex))
            temp = SYS_DFLT_40G_FIBER_PORT_CAPABILITIES;
        else
            temp = SYS_DFLT_10_100_1000_PORT_CAPABILITIES ;

        (*p_info).autoneg_capability_changed =
            (*p_info).autoneg_capability ^ temp;
#endif /* (SWCTRL_UPDATE_PORT_ABILITY == TRUE) */

        /* MDIX mode */
#if (SYS_CPNT_SWCTRL_MDIX_CONFIG == TRUE)
        if((*p_info).port_MDIX_mode != SYS_DFLT_MDIX_MODE)
        {
            (*p_info).port_MDIX_mode_changed = TRUE;
        }
#endif

        /* port link change trap status */
        if((*p_info).link_change_trap != VAL_ifLinkUpDownTrapEnable_enabled)
            (*p_info).link_change_trap_changed = TRUE;

        /* bcast_storm_status */
        if((*p_info).bsctrl_state != SYS_DFLT_BCAST_STORM_STATUS)
            (*p_info).bsctrl_state_changed = TRUE;

        /* bcast_storm_sample_type */
        if((*p_info).bcast_rate_mode != SYS_DFLT_BSTORM_TYPE)
            (*p_info).bcast_rate_mode_changed = TRUE;

        /* bcast_rate_limit for broadcast storm control */
        if((*p_info).bcast_rate_limit != SYS_DFLT_BSTORM_RATE_LIMIT)
            (*p_info).bcast_rate_limit_changed = TRUE;

        /* mcast_storm_status */
        if((*p_info).msctrl_state != SYS_DFLT_MCAST_STORM_STATUS)
            (*p_info).msctrl_state_changed = TRUE;

        /* mcast_storm_sample_type */
        if((*p_info).mcast_rate_mode != SYS_DFLT_MSTORM_TYPE)
            (*p_info).mcast_rate_mode_changed = TRUE;

        /* mcast_rate_limit for multicast storm control */
        if((*p_info).mcast_rate_limit != SYS_DFLT_MSTORM_RATE_LIMIT)
            (*p_info).mcast_rate_limit_changed = TRUE;

#if (SYS_CPNT_STORM_MODE & SYS_CPNT_STORM_UNKNOWN_USTORM)
        /* unknown_ucast_storm_status */
        if((*p_info).unknown_usctrl_state != SYS_DFLT_UNKUCAST_STORM_STATUS)
            (*p_info).unknown_usctrl_state_changed = TRUE;

        /* unknown_ucast_storm_sample_type */
        if((*p_info).unknown_ucast_rate_mode != SYS_DFLT_UNKUSTORM_TYPE)
            (*p_info).unknown_ucast_rate_mode_changed = TRUE;

        /* unknown_ucast_rate_limit for unknowunicast storm control */
        if((*p_info).unknown_ucast_rate_limit != SYS_DFLT_UNKUSTORM_RATE_LIMIT)
            (*p_info).unknown_ucast_rate_limit_changed = TRUE;
#endif

        /* ingress rate limit */
#if (SYS_CPNT_INGRESS_RATE_LIMIT == TRUE)
    #if (SYS_CPNT_NETACCESS_DYNAMIC_QOS == TRUE)
        if (port_info[ifindex-1].ingress_rate_limit_dynamic_cfg == TRUE)
        {
            (*p_info).ingress_rate_limit_status = port_info[ifindex-1].ingress_rate_limit_status_user_cfg;
            (*p_info).ingress_rate_limit        = port_info[ifindex-1].ingress_rate_limit_user_cfg;
        }
    #endif

        if((*p_info).ingress_rate_limit_status != SYS_DFLT_INGRESS_RATE_LIMIT_STATUS)
            (*p_info).ingress_rate_limit_state_changed = TRUE;

        if((*p_info).ingress_rate_limit != SWCTRL_GetDefaultRateLimit(port_info[ifindex-1].port_entry.port_type))
            (*p_info).ingress_rate_limit_changed = TRUE;
#endif

#if (SYS_CPNT_EGRESS_RATE_LIMIT == TRUE)
        if((*p_info).egress_rate_limit_status != SYS_DFLT_EGRESS_RATE_LIMIT_STATUS)
            (*p_info).egress_rate_limit_state_changed = TRUE;

        if((*p_info).egress_rate_limit != SWCTRL_GetDefaultRateLimit(port_info[ifindex-1].port_entry.port_type))
            (*p_info).egress_rate_limit_changed = TRUE;
#endif

        /* port name */
        if(strcmp((char *)(*p_info).port_name ,SYS_DFLT_PORT_NAME) != 0)
            (*p_info).port_name_changed = TRUE;
       /*EPR:ES4827G-FLF-ZZ-00232
        *Problem: CLI:size of vlan name different in console and mib
        *Solution: add CLI command "alias" for interface set,the
        *          alias is different from name and port descrition,so
        *          need add new command.
        *modify file: cli_cmd.c,cli_cmd.h,cli_arg.c,cli_arg.h,cli_msg.c,
        *             cli_msg.h,cli_api_vlan.c,cli_api_vlan.h,cli_api_ehternet.c
        *             cli_api_ethernet.h,cli_api_port_channel.c,cli_api_port_channel.h,
        *             cli_running.c,rfc_2863.c,swctrl.h,trk_mgr.h,trk_pmgr.h,swctrl.c
        *             swctrl_pmgr.c,trk_mgr.c,trk_pmgr.c,vlan_mgr.h,vlan_pmgr.h,
        *             vlan_type.h,vlan_mgr.c,vlan_pmgr.c,if_mgr.c
        *Approved by:Hardsun
        *Fixed by:Dan Xie
        */
        if(strcmp((char *)(*p_info).port_alias,SYS_DFLT_IF_ALIAS) != 0)
            (*p_info).port_alias_changed = TRUE;
#if (SYS_CPNT_COMBO_PORT_FORCE_MODE == TRUE)
        if (SYS_TYPE_GET_RUNNING_CFG_SUCCESS == SWCTRL_GetRunningPortComboForcedMode(ifindex, &(p_info->medium_forced_mode)))
        {
            (*p_info).medium_forced_mode_changed = TRUE;
        }
        else
        {
            (*p_info).medium_forced_mode_changed = FALSE;
        }
#endif

    if((*p_info).mtu!=SYS_DFLT_PORT_MTU)
    {
        (*p_info).port_mtu_changed=TRUE;
    }
#if(SYS_CPNT_AMTR_PORT_MAC_LEARNING == TRUE)/*Tony.Lei*/
    /*mac-learning configuration added by jinhua.wei*/
    if((*p_info).port_macaddr_learning != SYS_DFLT_PORT_MAC_LEARNING){
        (*p_info).port_macaddr_learning_changed = TRUE;
    }
#endif

#if (SYS_CPNT_SWCTRL_SWITCH_MODE_CONFIGURABLE == TRUE)
        if ((*p_info).switch_mode != SYS_DFLT_SWCTRL_SWITCH_MODE)
            (*p_info).switch_mode_changed = TRUE;
#endif

        if ((*p_info).admin_state_changed              | (*p_info).speed_duplex_cfg_changed |
            (*p_info).autoneg_state_changed            | (*p_info).flow_control_cfg_changed |
            (*p_info).autoneg_capability_changed       | (*p_info).link_change_trap_changed |
#if (SYS_CPNT_SWCTRL_MDIX_CONFIG == TRUE)
            (*p_info).port_MDIX_mode_changed           |
#endif
            (*p_info).bcast_rate_limit_changed         | (*p_info).mcast_rate_limit_changed |
            (*p_info).bcast_rate_mode_changed          | (*p_info).mcast_rate_mode_changed  |
            (*p_info).bsctrl_state_changed             | (*p_info).msctrl_state_changed     |
#if (SYS_CPNT_STORM_MODE & SYS_CPNT_STORM_UNKNOWN_USTORM)
            (*p_info).unknown_ucast_rate_limit_changed |
            (*p_info).unknown_ucast_rate_mode_changed  |
            (*p_info).unknown_usctrl_state_changed     |
#endif
            (*p_info).ingress_rate_limit_state_changed | (*p_info).egress_rate_limit_state_changed|
            (*p_info).ingress_rate_limit_changed       | (*p_info).egress_rate_limit_changed|
            (*p_info).port_name_changed                | (*p_info).medium_forced_mode_changed |
            (*p_info).port_mtu_changed                 | (*p_info).port_alias_changed
#if(SYS_CPNT_AMTR_PORT_MAC_LEARNING == TRUE)/*Tony.Lei*/
            |(*p_info).port_macaddr_learning_changed
#endif
#if (SYS_CPNT_SWCTRL_SWITCH_MODE_CONFIGURABLE == TRUE)
           | (*p_info).switch_mode_changed
#endif
           )
            SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_SUCCESS )
        else
            SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_NO_CHANGE )
    } /* End of if () */

    SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_FAIL );
} /* End of SWCTRL_GetRunningPortInfo() */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetTrunkPrimaryPort
 * -------------------------------------------------------------------------
 * FUNCTION: This function will get primary ifindex to get phyical attribute
 * INPUT   : ifindex   -- which port to get
 * OUTPUT  : primary_ifindex_p
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
static BOOL_T SWCTRL_GetTrunkPrimaryPort(UI32_T ifindex, UI32_T *primary_ifindex_p)
{
    SYS_TYPE_Uport_T unit_port;
    UI32_T local_ifindex;

    if(  SWCTRL_LportToActiveUport(SYS_TYPE_IGNORE_VID_CHECK, ifindex, &unit_port) == FALSE )
    {
        if(trunk_ext_port_info[SWCTRL_IFINDEX_TO_TRUNKID(ifindex)-1].member_number == 0)
        {
            return FALSE;
        }
        else
        {
            /* no primary port, use first trunk member
             */
            unit_port.unit = trunk_ext_port_info[SWCTRL_IFINDEX_TO_TRUNKID(ifindex)-1].member_list[0].unit;
            unit_port.port = trunk_ext_port_info[SWCTRL_IFINDEX_TO_TRUNKID(ifindex)-1].member_list[0].port;

            local_ifindex = SWCTRL_UPORT_TO_IFINDEX(unit_port.unit, unit_port.port);
        }
    }
    else
    {
        /* Got primary port, use the info of this port as trunk info.
         */
        local_ifindex = SWCTRL_UPORT_TO_IFINDEX(unit_port.unit, unit_port.port);
    }

    if(local_ifindex == 0 || local_ifindex > SYS_ADPT_TOTAL_NBR_OF_LPORT)
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Logical Port ID (1-%d)", SYS_ADPT_TOTAL_NBR_OF_LPORT);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_LOGICAL_PORT_ID*/
#endif

        return FALSE;
    }

    *primary_ifindex_p = local_ifindex;

    return TRUE;
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetPortLinkStatus
 * -------------------------------------------------------------------------
 * FUNCTION: This rutine provide the information of the link status of
 *           the port.
 * INPUT   : ifindex --- The information of which port to get.
 * OUTPUT  : *port_link_status --- Link status of this port.
 *                                 1) SWCTRL_LINK_UP
 *                                 2) SWCTRL_LINK_DOWN
 * RETURN  : TRUE  --- Succefully.
 *           FALSE --- 1) ifindex is not belong to user port or logic port.
 *                     2) This port is not present.
 * NOTE    : This runtine provide subset information of SWCTRL_GetPortInfo().
 *           If some task has stack size issue, caller should use this rutine
 *           to get the operating status.
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_GetPortLinkStatus(UI32_T ifindex, UI32_T *port_link_status)
{
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    /* semantic check
     */
    if( ifindex == 0 || ifindex > SYS_ADPT_TOTAL_NBR_OF_LPORT)
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Logical Port ID (1-%d)", SYS_ADPT_TOTAL_NBR_OF_LPORT);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_LOGICAL_PORT_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if(port_link_status == 0)
    {
        EH_MGR_Handle_Exception (SYS_MODULE_SWCTRL,
                                 SWCTRL_NO_USE_FUNC_NO,
                                 EH_TYPE_MSG_NULL_POINTER,
                                 EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_CRIT); /*SWCTRL_ENO_NULL_POINTER*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (!SWCTRL_IS_EXIST (ifindex)) /*VAL_ifOperStatus_notPresent*/
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Interface");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    /* action
     */
    if (SWCTRL_IS_LINK_UP(ifindex))
    {
        *port_link_status = SWCTRL_LINK_UP;
    }
    else
    {
        *port_link_status = SWCTRL_LINK_DOWN;
    }

    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
} /*End of SWCTRL_GetPortLinkStatus() */

/*-------------------------------------------------------------------------
 * FUNCTION NAME - SWCTRL_IsPortOperationUp
 *-------------------------------------------------------------------------
 * PURPOSE  : This function ehck this port is Port operaton up
 * INPUT    : l_port - the logical port will be checked
 * OUTPUT   : None
 * RETURN   : TRUE  - this is operation up port
 *            FALSE - this is not operaton up port
 * NOTE     :
 *-------------------------------------------------------------------------
 */
BOOL_T SWCTRL_IsPortOperationUp(UI32_T l_port)
{
    UI32_T status;

    if(FALSE == SWCTRL_GetPortOperStatus(l_port,&status))
    {
        return FALSE;
    }

    if (SWCTRL_OPER_IS_OPER_UP(status))
    {
        return TRUE;
    }

    return FALSE;
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetPortOperStatus
 * -------------------------------------------------------------------------
 * FUNCTION: This rutine provide the information of the operating status of
 *           the port.
 * INPUT   : ifindex --- The information of which port to get.
 * OUTPUT  : *port_oper_status --- Operating status of this port.
 *                                 1) VAL_ifOperStatus_up
 *                                 2) VAL_ifOperStatus_down
 *                                 3) VAL_ifOperStatus_dormant
 *                                 4) VAL_ifOperStatus_lowerLayerDown
 * RETURN  : TRUE  --- Succefully.
 *           FALSE --- 1) ifindex is not belong to user port or logic port.
 *                     2) This port is not present.
 * NOTE    : This runtine provide subset information of SWCTRL_GetPortInfo().
 *           If some task has stack size issue, caller should use this rutine
 *           to get the link status.
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_GetPortOperStatus(UI32_T ifindex, UI32_T *port_oper_status)
{
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    /* semantic check
     */
    if( ifindex == 0 || ifindex > SYS_ADPT_TOTAL_NBR_OF_LPORT)
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Logical Port ID (1-%d)", SYS_ADPT_TOTAL_NBR_OF_LPORT);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_LOGICAL_PORT_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if(port_oper_status == 0)
    {
        EH_MGR_Handle_Exception (SYS_MODULE_SWCTRL,
                                 SWCTRL_NO_USE_FUNC_NO,
                                 EH_TYPE_MSG_NULL_POINTER,
                                 EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_CRIT); /*SWCTRL_ENO_NULL_POINTER*/
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (!SWCTRL_IS_EXIST (ifindex)) /*VAL_ifOperStatus_notPresent*/
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Interface");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    /* action
     */
    *port_oper_status = port_info[ifindex - 1].link_oper_status;

    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
} /*End of SWCTRL_GetPortOperStatus() */

#if (SYS_CPNT_3COM_LOOPBACK_TEST == TRUE)
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetSwitchLoopbackTestFailurePorts
 * -------------------------------------------------------------------------
 * FUNCTION: SNMP call this API the get loopback test failure ports.
 * INPUT   : None.
 * OUTPUT  : failure_ports --- If the port is loopback test failure port,
 *                            the bit is "1", otherwise the bit is "0".
 *                            The MSB of byte 0 is port 1,
 *                            the LSB of byte 0 is port 8,
 *                            the MSB of byte 1 is port 9,
 *                            the LSB of byte 1 is port 16,
 *                            ...
 *                            and so on.
 * RETURN  : TRUE  --- Succeful.
 *           FALSE --- Failed.
 * NOTE    : For user port only.
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_GetSwitchLoopbackTestFailurePorts(UI8_T failure_ports[SYS_ADPT_NBR_OF_BYTE_FOR_1BIT_UPORT_LIST*SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK])
{
    UI32_T ifindex;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    /* clean up the memory used to output
     */
    memset(failure_ports, 0, sizeof(failure_ports));

    /* action
     */
    for(ifindex = 1;
        ifindex <= SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT*SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK;
        ifindex++)
    {
        if (FALSE == SWCTRL_IS_EXIST (ifindex))
        {
            continue;
        }

        if (TRUE == user_ext_port_info[ifindex-1].is_loopback_test_failed)
        {
            /* loopback test failed port:
             * set as "1"
             */
            failure_ports[SWCTRL_BYTE_IN_BITMAP(ifindex)] |= SWCTRL_BIT_IN_BITMAP(ifindex);
        }
    }

    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
}
#endif

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetPortAdminStatus
 * -------------------------------------------------------------------------
 * FUNCTION: This function will set port administration status
 * INPUT   : ifindex        -- which port to set
 *           admin_status   -- VAL_ifAdminStatus_up/VAL_ifAdminStatus_down
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : 1. RFC2863
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetPortAdminStatus(UI32_T ifindex, UI32_T admin_status)
{
    if ( admin_status != VAL_ifAdminStatus_up   &&
         admin_status != VAL_ifAdminStatus_down )
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_INVALID_PARAMETER,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "admin status");   /*SWCTRL_ENO_INVALID_ADMIN*/

        return FALSE;
    }

    /* SWCTRL_SetPortAdminStatus is just a wrapper now.
     */
    return SWCTRL_SetPortStatus(ifindex, admin_status == VAL_ifAdminStatus_up, SWCTRL_PORT_STATUS_SET_BY_CFG);
}/* end of SWCTRL_SetPortAdminStatus () */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetPortStatus
 * -------------------------------------------------------------------------
 * FUNCTION: This function will set port administration status
 * INPUT   : ifindex        -- which port to set
 *           status         -- TRUE to be up; FALSE to be down
 *           reason         -- indicates role of caller
 *                             bitmap of SWCTRL_PORT_STATUS_SET_BY_XXX
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : 1. when set admin up with reason = SWCTRL_PORT_STATUS_SET_BY_CFG,
 *              it works like set admin up for all.
 *           2. user config will be affected only if set with SWCTRL_PORT_STATUS_SET_BY_CFG.
 *           3. Only CMGR_SetPortStatus may call SWCTRL_SetPortStatus/SWCTRL_PMGR_SetPortStatus;
 *              CSCs that is in the layer higher than CMGR may call CMGR_SetPortStatus
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetPortStatus(UI32_T ifindex, BOOL_T status, UI32_T reason)
{
    BOOL_T retval = FALSE;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

#if (SYS_CPNT_SWCTRL_SHUTDOWN_FOR_TRUNK_MEMBER == TRUE)
    if (!(ifindex != 0 && ifindex <= SYS_ADPT_TOTAL_NBR_OF_LPORT) ||
        !SWCTRL_IS_EXIST(ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a valid port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#else
    if (!SWCTRL_IS_LPORT(ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#endif

    retval = SWCTRL_SetPortStatus_Local(ifindex, status, reason, FALSE);

    SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME ();
    SWCTRL_RETURN_AND_RELEASE_CSC( retval );
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetPortStatus
 * -------------------------------------------------------------------------
 * FUNCTION: This function will get port administration status
 * INPUT   : ifindex        -- which port to set
 * OUTPUT  : shutdown_reason_p -- indicates why status is down
 *                             bitmap of SWCTRL_PORT_STATUS_SET_BY_XXX
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_GetPortStatus(UI32_T ifindex, UI32_T *shutdown_reason_p)
{
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (!(ifindex != 0 && ifindex <= SYS_ADPT_TOTAL_NBR_OF_LPORT) ||
        !SWCTRL_IS_EXIST(ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a valid port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    SWCTRL_LOCK();
    *shutdown_reason_p = port_info[ifindex-1].shutdown_status;
    SWCTRL_UNLOCK();

    SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME ();
    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetPortStatus_Local
 * -------------------------------------------------------------------------
 * FUNCTION: This function will set port administration status
 * INPUT   : ifindex        -- which port to set
 *           status         -- TRUE to be up; FALSE to be down
 *           reason         -- indicates role of caller
 *                             bitmap of SWCTRL_PORT_STATUS_SET_BY_XXX
 *           is_forced      -- always perform config regardless current config.
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : 1. when set admin up with reason = SWCTRL_PORT_STATUS_SET_BY_CFG,
 *              it works like set admin up for all.
 * -------------------------------------------------------------------------*/
static BOOL_T SWCTRL_SetPortStatus_Local(UI32_T ifindex, BOOL_T status, UI32_T reason, BOOL_T is_forced)
{
    UI32_T unit, port;
    UI32_T new_admin_status;
    UI32_T drv_admin_status_to_set;
    UI32_T old_shutdown_status, new_shutdown_status;
    UI32_T shutdown_status_to_set, shutdown_status_to_clear;
    UI32_T diff_shutdown_status;
    UI32_T shutdown_status_changed_passively;
    BOOL_T admin_status_is_changed, status_is_changed;
    BOOL_T retval = FALSE;

    /* update_shutdown_status
     *   bitmap of reason that will be updated.
     */
    shutdown_status_to_set = status ? 0 : reason;
    shutdown_status_to_clear = status ? reason : 0;

    /* if is set by user config, clear all other shutdown status.
     */
    if (!is_forced && (reason & SWCTRL_PORT_STATUS_SET_BY_CFG))
    {
        shutdown_status_to_set &= SWCTRL_PORT_STATUS_SET_BY_CFG;
        shutdown_status_to_clear |= ~(UI32_T)SWCTRL_PORT_STATUS_SET_BY_CFG;
        new_admin_status = status ? VAL_ifAdminStatus_up : VAL_ifAdminStatus_down;
    }
    else
    {
        new_admin_status = port_info[ifindex-1].admin_status;
    }

    /* SW license shouldn't been cleared by other reason
     */
    if (!(reason & SWCTRL_PORT_STATUS_SET_BY_SW_LICENSE))
    {
        shutdown_status_to_clear &= ~(UI32_T)SWCTRL_PORT_STATUS_SET_BY_SW_LICENSE;
    }

    /* calculate new_shutdown_status
     */
    old_shutdown_status = port_info[ifindex-1].shutdown_status;
    new_shutdown_status =
        (old_shutdown_status | shutdown_status_to_set) & ~shutdown_status_to_clear;
    drv_admin_status_to_set = new_shutdown_status ? VAL_ifAdminStatus_down : VAL_ifAdminStatus_up;

    diff_shutdown_status = new_shutdown_status ^ old_shutdown_status;
    shutdown_status_changed_passively = diff_shutdown_status & ~reason;

    /* perform config
     *
     * 1. status_is_changed
     *         port status is changed, MUST update driver.
     * 2. admin_status_is_changed
     *        admin status is change, MUST update driver/admin_status.
     * 3. always update shutdown_status.
     */
    status_is_changed =
        is_forced || !new_shutdown_status != !old_shutdown_status;
    admin_status_is_changed =
        ((diff_shutdown_status & SWCTRL_PORT_STATUS_SET_BY_CFG) != 0);

    /* SW_LICENSE driver setup is superseded by SWDRV_SetPortStatusForLicense
     */
    if (reason & SWCTRL_PORT_STATUS_SET_BY_SW_LICENSE)
    {
        status_is_changed = FALSE;
    }

#if 0 /* obsolete, moved to cmgr */
#if (SYS_CPNT_LLDP == TRUE)
    /*Notify LLDP, swctrl will do port admin disable*/
    if (SWCTRL_IS_LPORT(ifindex) && admin_status_is_changed)
    {
        if (new_admin_status == VAL_ifAdminStatus_down)
        {
            SWCTRL_Notify_PortAdminDisableBefore(ifindex);
        }
    }
#endif
#endif

    /* shutdown_status is updated before config driver/notify.
     * and need rollback if failure occurs.
     */
    if (!SWCTRL_IS_TRUNK (ifindex))
    {
        port_info[ifindex-1].shutdown_status = new_shutdown_status;
        retval = TRUE;

        unit = SWCTRL_IFINDEX_TO_UNIT(ifindex);
        port = SWCTRL_IFINDEX_TO_PORT(ifindex);

        if (admin_status_is_changed)
        {
            retval = SWCTRL_SetUPortAdminStatus(unit, port, drv_admin_status_to_set);

            if (retval)
            {
                if (!SWCTRL_IS_TRUNK_MEMBER(ifindex))
                {
                    if (new_admin_status == VAL_ifAdminStatus_up)
                    {
                        SWCTRL_Notify_PortAdminEnable (ifindex);
                    }
                    else /* VAL_ifAdminStatus_down*/
                    {
                        SWCTRL_Notify_PortAdminDisable(ifindex);
                    }
                }
#if (SYS_CPNT_SWCTRL_SHUTDOWN_FOR_TRUNK_MEMBER == TRUE)
                else /* SWCTRL_IS_TRUNK_MEMBER(ifindex) */
                {
                    UI32_T trunk_ifindex;

                    /* If trunk is admin status disabled, all members should
                     * be admin status down.
                     *
                     * Because member is allowed to be configure admin up
                     * severally, so shall change trunk admin status to up
                     * when configuring member admin status to up on member
                     * of a admin-down trunk.
                     */
                    trunk_ifindex = SWCTRL_TRUNKID_TO_IFINDEX(port_info[(ifindex)-1].port_entry.port_trunk_index);

                    if (!(port_info[ifindex-1].shutdown_status & SWCTRL_PORT_STATUS_SET_BY_CFG))
                    {
                        if ((port_info[trunk_ifindex-1].shutdown_status & SWCTRL_PORT_STATUS_SET_BY_CFG))
                        {
                            port_info[trunk_ifindex-1].shutdown_status &= ~ SWCTRL_PORT_STATUS_SET_BY_CFG;
                            port_info[trunk_ifindex-1].admin_status = VAL_ifAdminStatus_up;

                            SWCTRL_Notify_PortAdminEnable(trunk_ifindex);
                            SWCTRL_LinkOperStateMachineChangeState(trunk_ifindex, SWCTRL_ADMIN_ENABLE_EVENT);
                        }
                    }
                }
#endif
            }
        }
        else if (status_is_changed)
        {
            if (drv_admin_status_to_set == VAL_ifAdminStatus_up)
            {
                retval = SWDRV_EnablePortAdmin(unit, port);
            }
            else /* VAL_ifAdminStatus_down*/
            {
                retval = SWDRV_DisablePortAdmin(unit, port);
            }
        }

        if (!retval)
        {
            port_info[ifindex-1].shutdown_status = old_shutdown_status;
        }
    }
    else /* trunk */
    {
        SWCTRL_TrunkPortExtInfo_T trunk_ext_p_info;
        UI32_T tm_ifindex;
        int i;

        SWCTRL_GetTrunkPortExtInfo (ifindex, &trunk_ext_p_info);

        for(i = 0, retval = TRUE; retval && i < trunk_ext_p_info.member_number; i++)
        {
            unit = trunk_ext_p_info.member_list[i].unit;
            port = trunk_ext_p_info.member_list[i].port;
            tm_ifindex = SWCTRL_UPORT_TO_IFINDEX (unit, port);

            retval = SWCTRL_SetPortStatus_Local(tm_ifindex, status, reason, is_forced);
        }

        if (retval)
        {
            port_info[ifindex-1].shutdown_status = new_shutdown_status;

            if (admin_status_is_changed)
            {
                port_info[ifindex-1].admin_status = new_admin_status;

                if (new_admin_status == VAL_ifAdminStatus_up)
                {
                    SWCTRL_Notify_PortAdminEnable(ifindex);
                    SWCTRL_LinkOperStateMachineChangeState(ifindex, SWCTRL_ADMIN_ENABLE_EVENT);
                }
                else /* VAL_ifAdminStatus_down*/
                {
                    SWCTRL_Notify_PortAdminDisable(ifindex);
                    SWCTRL_LinkOperStateMachineChangeState(ifindex, SWCTRL_ADMIN_DISABLE_EVENT);
                }
            }
        } /* End of if () */
    } /* End of if (trunk) */

    /* notify PortStatusChangedPassively
     *
     * for current design,
     *  set_bmp is always 0;
     *  clear_bmp will be set when reason contains SWCTRL_PORT_STATUS_SET_BY_CFG.
     */
    if (retval && shutdown_status_changed_passively)
    {
        UI32_T set_bmp = shutdown_status_changed_passively & shutdown_status_to_set;
        UI32_T clear_bmp = shutdown_status_changed_passively & shutdown_status_to_clear;

        if (!SWCTRL_IS_TRUNK_MEMBER(ifindex))
        {
            if (set_bmp)
            {
                SWCTRL_Notify_PortStatusChangedPassively(ifindex, FALSE, set_bmp);
            }
            if (clear_bmp)
            {
                SWCTRL_Notify_PortStatusChangedPassively(ifindex, TRUE, clear_bmp);
            }
        }
        else
        {
            #if 0 /* not implemented */
            if (set_bmp)
            {
                SWCTRL_Notify_TrunkMemberStatusChangedPassively(ifindex, FALSE, set_bmp);
            }
            if (clear_bmp)
            {
                SWCTRL_Notify_TrunkMemberStatusChangedPassively(ifindex, TRUE, clear_bmp);
            }
            #endif
        }

#if (SYS_CPNT_ATC_STORM == TRUE)
        #if (SYS_CPNT_ATC_BSTORM == TRUE)
        if (clear_bmp & SWCTRL_PORT_STATUS_SET_BY_ATC_BSTORM)
        {
            SWCTRL_ProcessATCBroadcastStormTrafficControlReleasePassively(ifindex);
        }
        #endif

        #if (SYS_CPNT_ATC_MSTORM == TRUE)
        if (clear_bmp & SWCTRL_PORT_STATUS_SET_BY_ATC_MSTORM)
        {
            SWCTRL_ProcessATCMulticastStormTrafficControlReleasePassively(ifindex);
        }
        #endif
#endif /* (SYS_CPNT_ATC_STORM == TRUE) */
    }

    return retval;
}

#if (SYS_CPNT_SUPPORT_FORCED_1000BASE_T_MODE == TRUE)
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetPort1000BaseTForceMode
 * -------------------------------------------------------------------------
 * FUNCTION: This function will set force[master/slave] mode configuration of a port
 * INPUT   : ifindex      -- which port to set
 *           forced_mode  -- VAL_portMasterSlaveModeCfg_master / VAL_portMasterSlaveModeCfg_slave
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : 1.ES3626A
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetPort1000BaseTForceMode(UI32_T ifindex, UI32_T forced_mode)
{
    UI32_T                          unit, port, i;
    BOOL_T                          retval = FALSE;
    SWCTRL_TrunkPortExtInfo_T    trunk_ext_info;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (!SWCTRL_IS_LPORT(ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  SYSLOG_LEVEL_INFO,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (SWCTRL_IsServerBladePort (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_SRV_BLADE_PORT_CNFG,
                                  SYSLOG_LEVEL_INFO,
                                  "Configuring Forced 1000BaseT Mode");     /*SWCTRL_ENO_DENY_ON_SERVER_BLADE_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    /* only 1000TX support 1000FULL forced mode
     */
    if (SWCTRL_IS_1000T (ifindex) )
    {
        if( port_info[ifindex-1].port_entry.port_speed_dpx_status != VAL_portSpeedDpxCfg_fullDuplex1000 )
        {
            EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                      SWCTRL_NO_USE_FUNC_NO,
                                      EH_TYPE_MSG_DEB_MSG,
                                      SYSLOG_LEVEL_INFO,
                                      "Port Speed Can Not Support Force Mode");

            SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
        }
    }
    else
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  SYSLOG_LEVEL_INFO,
                                  "Port Type Can Not Support Force Mode");

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    /* Action
     */
    if (!SWCTRL_IS_TRUNK (ifindex))
    {
        /* normal port
         */
        unit = SWCTRL_IFINDEX_TO_UNIT(ifindex);
        port = SWCTRL_IFINDEX_TO_PORT(ifindex);

        /* Aaron Chuang, 2005-02-26
         * Set chipset only when the port is 1000BASE-T forced mode active.
         * Mean: no neg + speed-duplex (1000f) in copper port
         */
        if (port_info[ifindex-1].port_entry.port_type == VAL_portType_thousandBaseT &&
            port_info[ifindex-1].port_entry.port_autonegotiation == VAL_portAutonegotiation_disabled &&
            port_info[ifindex-1].port_entry.port_speed_dpx_cfg == VAL_portSpeedDpxCfg_fullDuplex1000)
            retval = SWDRV_SetPort1000BaseTForceMode (unit, port, forced_mode);
        else
            retval = TRUE; /* Aaron, keep in om only and not apply to chipset */

        if (retval)
        {
            SWCTRL_LOCK();
            port_info[ifindex-1].port_entry.port_forced_1000t_mode = forced_mode;
            port_info[ifindex-1].forced_1000t_mode = forced_mode;
            SWCTRL_UNLOCK();
        }
    }
    else
    {
        /* trunk port
         */
        SWCTRL_GetTrunkPortExtInfo (ifindex, &trunk_ext_info);

        /* Aaron Chuang, 2005-02-26
         * Set chipset only when the port is 1000BASE-T forced mode active.
         * Mean: no neg + speed-duplex (1000f) in copper port
         */
        if (port_info[ifindex-1].port_entry.port_type == VAL_portType_thousandBaseT &&
            port_info[ifindex-1].port_entry.port_autonegotiation == VAL_portAutonegotiation_disabled &&
            port_info[ifindex-1].port_entry.port_speed_dpx_cfg == VAL_portSpeedDpxCfg_fullDuplex1000)
        {
            for(i = 0; i < trunk_ext_info.member_number; i++)
            {
                unit = (UI32_T) trunk_ext_info.member_list[i].unit;
                port = (UI32_T) trunk_ext_info.member_list[i].port;

                if (!(retval = SWDRV_SetPort1000BaseTForceMode (unit, port, forced_mode)))
                {
                    break;
                }
            }
        }
        else
            retval = TRUE; /* Aaron, keep in om only and not apply to chipset */

        if (retval)
        {
            SWCTRL_LOCK();
            port_info[ifindex-1].port_entry.port_forced_1000t_mode = forced_mode;
            port_info[ifindex-1].forced_1000t_mode = forced_mode;
            SWCTRL_UNLOCK();
        }
    }

    SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME ();
    SWCTRL_RETURN_AND_RELEASE_CSC( retval );

} /* End of SWCTRL_SetPort1000BaseTForceMode() */
#endif /*#if (SYS_CPNT_SUPPORT_FORCED_1000BASE_T_MODE == TRUE)*/

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetPortCfgSpeedDuplex
 * -------------------------------------------------------------------------
 * FUNCTION: This function will set speed/duplex configuration of a port
 * INPUT   : ifindex      -- which port to set
 *           speed_duplex -- speed/duplex to set
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : 1.ES3626A
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetPortCfgSpeedDuplex(UI32_T ifindex, UI32_T speed_duplex)
{
    UI32_T                          unit, port, i;
    BOOL_T                          retval = FALSE;
    SWCTRL_TrunkPortExtInfo_T    trunk_ext_info;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (!SWCTRL_IS_LPORT(ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  SYSLOG_LEVEL_INFO,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (SWCTRL_IsServerBladePort (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_SRV_BLADE_PORT_CNFG,
                                  SYSLOG_LEVEL_INFO,
                                  "Configuring Forced Speed/Duplex Mode");     /*SWCTRL_ENO_DENY_ON_SERVER_BLADE_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    /* Action
     */
    if (!SWCTRL_IS_TRUNK (ifindex))
    {
        if (!SWCTRL_IsPortCfgSpeedDuplexSupported(ifindex, speed_duplex))
        {
            SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
        }

        if (port_info[ifindex-1].port_entry.port_speed_dpx_cfg == speed_duplex)
        {
            SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
        }

        /* normal port
         */
        unit = SWCTRL_IFINDEX_TO_UNIT(ifindex);
        port = SWCTRL_IFINDEX_TO_PORT(ifindex);

        retval = SWCTRL_SetUPortCfgSpeedDuplex (unit, port, speed_duplex);

        #if (SYS_CPNT_SUPPORT_FORCED_1000BASE_T_MODE == TRUE)
        /* Aaron Chuang, 2005-02-26
         * Set chipset only when the port is 1000BASE-T forced mode active.
         * Mean: no neg + speed-duplex (1000f) in copper port
         */
        if (port_info[ifindex-1].port_entry.port_type == VAL_portType_thousandBaseT &&
            port_info[ifindex-1].port_entry.port_autonegotiation == VAL_portAutonegotiation_disabled &&
            speed_duplex == VAL_portSpeedDpxCfg_fullDuplex1000)
            retval = SWDRV_SetPort1000BaseTForceMode (unit, port, port_info[ifindex-1].port_entry.port_forced_1000t_mode);
        else
            retval = SWDRV_SetPort1000BaseTForceMode (unit, port, VAL_portMasterSlaveModeCfg_auto); /* Aaron, keep in om only and not apply to chipset */
        #endif
    }
    else
    {
        /* trunk port
         */
        SWCTRL_GetTrunkPortExtInfo (ifindex, &trunk_ext_info);

        for(i = 0; i < trunk_ext_info.member_number; i++)
        {
            UI32_T ifindex;

            unit = (UI32_T) trunk_ext_info.member_list[i].unit;
            port = (UI32_T) trunk_ext_info.member_list[i].port;
            ifindex = SWCTRL_UPORT_TO_IFINDEX(unit, port);

            if (!SWCTRL_IsPortCfgSpeedDuplexSupported(ifindex, speed_duplex))
            {
                continue;
            }

            if (port_info[ifindex-1].port_entry.port_speed_dpx_cfg == speed_duplex)
            {
                retval = TRUE; /* set retval to TRUE when one of member port cfg ok */
                continue;
            }

            if (!SWCTRL_SetUPortCfgSpeedDuplex (unit, port, speed_duplex))
            {
                continue;
            }

            #if (SYS_CPNT_SUPPORT_FORCED_1000BASE_T_MODE == TRUE)
            /* Aaron Chuang, 2005-02-26
             * Set chipset only when the port is 1000BASE-T forced mode active.
             * Mean: no neg + speed-duplex (1000f) in copper port
             */
            if (port_info[ifindex-1].port_entry.port_type == VAL_portType_thousandBaseT &&
                port_info[ifindex-1].port_entry.port_autonegotiation == VAL_portAutonegotiation_disabled &&
                speed_duplex == VAL_portSpeedDpxCfg_fullDuplex1000)
                SWDRV_SetPort1000BaseTForceMode (unit, port, port_info[ifindex-1].port_entry.port_forced_1000t_mode);
            else
                SWDRV_SetPort1000BaseTForceMode (unit, port, VAL_portMasterSlaveModeCfg_auto); /* Aaron, keep in om only and not apply to chipset */
            #endif

            retval = TRUE; /* set retval to TRUE when one of member port cfg ok */
        }

        /* The database maintained here is just for trunk.
         * Specific user port database is set in SWCTRL_SetUPortCfgSpeedDuplex()
         */
        if (retval)
        {
            SWCTRL_LOCK();
            port_info[ifindex-1].port_entry.port_speed_dpx_cfg = speed_duplex;
            #if (SYS_CPNT_SUPPORT_COMBO_PORT_NO_NEG_KEEP == TRUE)
            if (SWCTRL_IS_1000T (ifindex))
                port_info[ifindex-1].port_entry.port_combo_copper_speed_dpx_cfg = speed_duplex;
            else
                port_info[ifindex-1].port_entry.port_combo_fiber_speed_dpx_cfg = speed_duplex;
            #endif
            SWCTRL_UNLOCK();
        }
    }

    SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME ();
    SWCTRL_RETURN_AND_RELEASE_CSC( retval );

} /* End of SWCTRL_SetPortCfgSpeedDuplex() */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_IsPortCfgSpeedDuplexSupported
 * -------------------------------------------------------------------------
 * FUNCTION: This function will check if specified speed/duplex is supported on the port
 * INPUT   : ifindex      -- uport ifindex
 *           speed_duplex -- speed/duplex
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
static BOOL_T SWCTRL_IsPortCfgSpeedDuplexSupported(UI32_T ifindex, UI32_T speed_duplex)
{
#if (SWCTRL_UPDATE_PORT_ABILITY == TRUE)
    if (port_info[ifindex-1].port_entry.port_speed_dpx_cfg != speed_duplex)
    {
        if (!(user_ext_port_info[ifindex-1].port_abililty.port_speed_duplex_supported & BIT_VALUE(speed_duplex)))
        {
#if (SYS_CPNT_EH == TRUE)
            void *arg1 = NULL, arg2 = NULL;

            if (speed_duplex < sizeof(swctrl_speed_duplex_str)/sizeof(*swctrl_speed_duplex_str))
            {
                arg1 = swctrl_speed_duplex_str[speed_duplex];
            }

            if (port_info[(ifindex)-1].port_entry.port_type < sizeof(swctrl_port_type_str)/sizeof(*swctrl_port_type_str))
            {
                arg2 = swctrl_port_type_str[port_info[(ifindex)-1].port_entry.port_type];
            }

            if (arg1 && arg2)
            {
                EH_MGR_Handle_Exception2 (SYS_MODULE_SWCTRL,  /*SWCTRL_ENO_DENY_SET_SPEED_DUPLEX_ON_FIBER_PORT*/
                                          SWCTRL_NO_USE_FUNC_NO,
                                          EH_TYPE_MSG_INVAL_F_SPD_DUP,
                                          SYSLOG_LEVEL_INFO,
                                          arg1,
                                          arg2);
            }
#endif

            return FALSE;
        }
    }
#else /* (SWCTRL_UPDATE_PORT_ABILITY == TRUE) */
    /* if the port is 100  fiber, it's force mode speed-duplex config is 100full  fixed
     */
    if ( SWCTRL_IS_100FIBER (ifindex) )
    {
        if(port_info[ifindex-1].port_entry.port_speed_dpx_cfg != speed_duplex)
        {
#if (SYS_CPNT_EH == TRUE)
            UI8_T msg_buf[10] = {0};

            switch(speed_duplex)
            {
            case VAL_portSpeedDpxCfg_halfDuplex10:
                strcpy(msg_buf, "10half");
                break;

            case VAL_portSpeedDpxCfg_fullDuplex10:
                strcpy(msg_buf, "10full");
                break;

            case VAL_portSpeedDpxCfg_halfDuplex100:
                strcpy(msg_buf, "100half");
                break;

            case VAL_portSpeedDpxCfg_fullDuplex100:
                strcpy(msg_buf, "100full");
                break;

            case VAL_portSpeedDpxCfg_fullDuplex1000:
                strcpy(msg_buf, "1000full");
                break;
            }

            EH_MGR_Handle_Exception2 (SYS_MODULE_SWCTRL,  /*SWCTRL_ENO_DENY_SET_SPEED_DUPLEX_ON_FIBER_PORT*/
                                      SWCTRL_NO_USE_FUNC_NO,
                                      EH_TYPE_MSG_INVAL_F_SPD_DUP,
                                      SYSLOG_LEVEL_INFO,
                                      msg_buf,
                                      "100 fiber");
#endif

            return FALSE;
        }
    }

    /* if the port is 1000 fiber, it's force mode speed-duplex config is 1000full fixed
     */
    if ( SWCTRL_IS_1000FIBER (ifindex) )
    {
        if(port_info[ifindex-1].port_entry.port_speed_dpx_cfg != speed_duplex)
        {
#if (SYS_CPNT_EH == TRUE)
            UI8_T msg_buf[10] = {0};

            switch(speed_duplex)
            {
            case VAL_portSpeedDpxCfg_halfDuplex10:
                strcpy(msg_buf, "10half");
                break;

            case VAL_portSpeedDpxCfg_fullDuplex10:
                strcpy(msg_buf, "10full");
                break;

            case VAL_portSpeedDpxCfg_halfDuplex100:
                strcpy(msg_buf, "100half");
                break;

            case VAL_portSpeedDpxCfg_fullDuplex100:
                strcpy(msg_buf, "100full");
                break;

            case VAL_portSpeedDpxCfg_fullDuplex1000:
                strcpy(msg_buf, "1000full");
                break;
            }

            EH_MGR_Handle_Exception2 (SYS_MODULE_SWCTRL,  /*SWCTRL_ENO_DENY_SET_SPEED_DUPLEX_ON_FIBER_PORT*/
                                      SWCTRL_NO_USE_FUNC_NO,
                                      EH_TYPE_MSG_INVAL_F_SPD_DUP,
                                      SYSLOG_LEVEL_INFO,
                                      msg_buf,
                                      "1000 fiber");
#endif

            return FALSE;
        }
    }

    /* 1000TX does not support 1000FULL forced mode
     */
    if ( SWCTRL_IS_1000T (ifindex) )
    {
        char msg_buf[10] = {0};
        strcpy(msg_buf,"");
        switch(speed_duplex)
        {
            case VAL_portSpeedDpxCfg_fullDuplex1000:
                strcpy(msg_buf, "1000full");
                #if (SYS_CPNT_SUPPORT_FORCED_1000BASE_T_MODE == FALSE)
                EH_MGR_Handle_Exception2 (SYS_MODULE_SWCTRL,  /*SWCTRL_ENO_NOT_SUPPORT_1000FULL_ON_1000TX*/
                                          SWCTRL_NO_USE_FUNC_NO,
                                          EH_TYPE_MSG_INVAL_F_SPD_DUP,
                                          SYSLOG_LEVEL_INFO,
                                          "1000full",
                                          "1000TX");

                return FALSE;
                #endif
                break;
        }
    }

    if(SWCTRL_IS_100TX (ifindex))
    {
        char msg_buf[10] = {0};
        strcpy(msg_buf,"");
        switch(speed_duplex)
        {
            case VAL_portSpeedDpxCfg_fullDuplex1000:
                strcpy(msg_buf, "1000full");
                break;
            case VAL_portSpeedDpxCfg_fullDuplex10g:
                strcpy(msg_buf, "10Gfull");
                break;
        }
        if(strcmp(msg_buf,"")!=0)
        {
            EH_MGR_Handle_Exception2 (SYS_MODULE_SWCTRL,  /*SWCTRL_ENO_NOT_SUPPORT_1000FULL_ON_100TX*/
                                          SWCTRL_NO_USE_FUNC_NO,
                                          EH_TYPE_MSG_INVAL_F_SPD_DUP,
                                          SYSLOG_LEVEL_INFO,
                                          msg_buf,
                                          "100TX");
            return FALSE;
        }
    }


    /* if the port is 10G fiber, it's force mode speed-duplex config is 10G full fixed
     */
    if ( SWCTRL_IS_10GFIBER (ifindex) || SWCTRL_IS_10GCOPPER (ifindex) )
    {
        if(port_info[ifindex-1].port_entry.port_speed_dpx_cfg != speed_duplex)
        {
#if (SYS_CPNT_EH == TRUE)
            UI8_T msg_buf[10] = {0};

            switch(speed_duplex)
            {
            case VAL_portSpeedDpxCfg_halfDuplex10:
                strcpy(msg_buf, "10half");
                break;

            case VAL_portSpeedDpxCfg_fullDuplex10:
                strcpy(msg_buf, "10full");
                break;

            case VAL_portSpeedDpxCfg_halfDuplex100:
                strcpy(msg_buf, "100half");
                break;

            case VAL_portSpeedDpxCfg_fullDuplex100:
                strcpy(msg_buf, "100full");
                break;

            case VAL_portSpeedDpxCfg_fullDuplex1000:
                strcpy(msg_buf, "1000full");
                break;
            }

            EH_MGR_Handle_Exception2 (SYS_MODULE_SWCTRL,  /*SWCTRL_ENO_DENY_SET_SPEED_DUPLEX_ON_FIBER_PORT*/
                                      SWCTRL_NO_USE_FUNC_NO,
                                      EH_TYPE_MSG_INVAL_F_SPD_DUP,
                                      SYSLOG_LEVEL_INFO,
                                      msg_buf,
                                      "10G fiber");
#endif

            return FALSE;
        }

    }

    /* if the port is 40G fiber, it's force mode speed-duplex config is 40G full fixed
     */
    if (SWCTRL_IS_40GFIBER (ifindex))
    {
        if(port_info[ifindex-1].port_entry.port_speed_dpx_cfg != speed_duplex)
        {
#if (SYS_CPNT_EH == TRUE)
            UI8_T msg_buf[10] = {0};

            switch(speed_duplex)
            {
            case VAL_portSpeedDpxCfg_halfDuplex10:
                strcpy(msg_buf, "10half");
                break;

            case VAL_portSpeedDpxCfg_fullDuplex10:
                strcpy(msg_buf, "10full");
                break;

            case VAL_portSpeedDpxCfg_halfDuplex100:
                strcpy(msg_buf, "100half");
                break;

            case VAL_portSpeedDpxCfg_fullDuplex100:
                strcpy(msg_buf, "100full");
                break;

            case VAL_portSpeedDpxCfg_fullDuplex1000:
                strcpy(msg_buf, "1000full");
                break;
            case VAL_portSpeedDpxCfg_halfDuplex10g:
                strcpy(msg_buf, "10ghalf");
                break;
            case VAL_portSpeedDpxCfg_fullDuplex10g:
                strcpy(msg_buf, "10gfull");
                break;
            }

            EH_MGR_Handle_Exception2 (SYS_MODULE_SWCTRL,  /*SWCTRL_ENO_DENY_SET_SPEED_DUPLEX_ON_FIBER_PORT*/
                                      SWCTRL_NO_USE_FUNC_NO,
                                      EH_TYPE_MSG_INVAL_F_SPD_DUP,
                                      SYSLOG_LEVEL_INFO,
                                      msg_buf,
                                      "40G fiber");
#endif

            return FALSE;
        }

    }
#endif /* (SWCTRL_UPDATE_PORT_ABILITY == TRUE) */

    return TRUE;
}


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetPortDefaultSpeedDuplex
 * -------------------------------------------------------------------------
 * FUNCTION: This function will set port speed/duplex to default value
 * INPUT   : l_port      -- which port to set
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : for CLI use
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetPortDefaultSpeedDuplex(UI32_T l_port)
{
    UI32_T default_speedduplex;
#if (SWCTRL_UPDATE_PORT_ABILITY == TRUE)
    UI32_T unit, port;
#endif

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (!SWCTRL_IS_LPORT(l_port))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

#if (SWCTRL_UPDATE_PORT_ABILITY == TRUE)
    if (SWCTRL_IS_TRUNK(l_port))
    {
        UI32_T primary_ifindex;

        if (!SWCTRL_GetTrunkPrimaryPort(l_port, &primary_ifindex))
        {
            SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
        }

        unit = SWCTRL_IFINDEX_TO_UNIT(primary_ifindex);
        port = SWCTRL_IFINDEX_TO_PORT(primary_ifindex);
    }
    else
    {
        unit = SWCTRL_IFINDEX_TO_UNIT(l_port);
        port = SWCTRL_IFINDEX_TO_PORT(l_port);
    }

    default_speedduplex = SWCTRL_GetPortCfgSpeedDuplexDfltCfg(unit, port);
#else /* (SWCTRL_UPDATE_PORT_ABILITY == TRUE) */
    if( SWCTRL_IS_100TX(l_port) )          /*FE_COPPER*/
    {
        default_speedduplex = SYS_DFLT_FE_COPPER_PORT_FORCE_MODE_SPDDPX;
    }
    else if( SWCTRL_IS_100FIBER(l_port) )  /*FE_FIBER*/
    {
        default_speedduplex = SYS_DFLT_FE_FIBER_PORT_FORCE_MODE_SPDDPX;
    }
    else if( SWCTRL_IS_1000T(l_port) )     /*GE_COPPER*/
    {
        default_speedduplex = SYS_DFLT_GE_COPPER_PORT_FORCE_MODE_SPDDPX;
    }
    else if( SWCTRL_IS_10GFIBER(l_port) )       /*10G port fiber*/
    {
        default_speedduplex = SYS_DFLT_10GE_FIBER_PORT_FORCE_MODE_SPDDPX;
    }
    else if( SWCTRL_IS_10GCOPPER (l_port) )       /*10G port copper*/
    {
        default_speedduplex = SYS_DFLT_10GE_COPPER_PORT_FORCE_MODE_SPDDPX;
    }
    else if( SWCTRL_IS_40GFIBER(l_port) )  /* 40G port fiber */
    {
        default_speedduplex = SYS_DFLT_40GE_FIBER_PORT_FORCE_MODE_SPDDPX;
    }
    else                                   /*GE_FIBER*/
    {
        default_speedduplex = SYS_DFLT_GE_FIBER_PORT_FORCE_MODE_SPDDPX;
    }
#endif /* (SWCTRL_UPDATE_PORT_ABILITY == TRUE) */

    if (!SWCTRL_SetPortCfgSpeedDuplex(l_port, default_speedduplex))
    {
        /*error code was set by SWCTRL_SetPortCfgSpeedDuplex()*/
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
} /* End of SWCTRL_SetPortDefaultSpeedDuplex () */



/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetPortAutoNegEnable
 * -------------------------------------------------------------------------
 * FUNCTION: This function will set port auto-negotiation enable state
 * INPUT   : ifindex        -- which port to set
 *           autoneg_state  -- VAL_portAutonegotiation_enabled /
 *                             VAL_portAutonegotiation_disabled
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : 1. EA3626A
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetPortAutoNegEnable(UI32_T ifindex, UI32_T autoneg_state)
{
    UI32_T                          unit, port, i;
    BOOL_T                          retval = FALSE;
    SWCTRL_TrunkPortExtInfo_T       trunk_ext_info;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (!SWCTRL_IS_LPORT(ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if( autoneg_state != VAL_portAutonegotiation_enabled  &&
        autoneg_state != VAL_portAutonegotiation_disabled )
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_INVALID_PARAMETER,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "auto-negotiation state");  /*SWCTRL_ENO_INVALID_AUTO_NEGO_STATE*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (SWCTRL_IsServerBladePort (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_SRV_BLADE_PORT_CNFG,
                                  SYSLOG_LEVEL_INFO,
                                  "Configuring Auto-Negotiation");     /*SWCTRL_ENO_DENY_ON_SERVER_BLADE_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    /* Action
     */
    if (!SWCTRL_IS_TRUNK (ifindex))
    {
        if (!SWCTRL_IsPortAutoNegEnableSupported(ifindex, autoneg_state))
        {
            SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
        }

        if (port_info[ifindex-1].port_entry.port_autonegotiation == autoneg_state)
        {
            SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
        }

        /* normal port
         */
        unit = SWCTRL_IFINDEX_TO_UNIT(ifindex);
        port = SWCTRL_IFINDEX_TO_PORT(ifindex);

        retval = SWCTRL_SetUPortAutoNegEnable (unit, port, autoneg_state);
    }
    else
    {
        /* trunk port
         */
        SWCTRL_GetTrunkPortExtInfo (ifindex, &trunk_ext_info);

#if 0 /* wakka: obsolete */
        /* Charles: These code was checked in to main brench, so it's not necessary
         *          to check in again.
         *          To recored this issue, comment somrthing here.
         */
        if (VAL_portAutonegotiation_disabled == autoneg_state)
        {
            /* If user want to config trunk as force speed-duplex mode
             * we must guarantee that the force mode speed-duplex config
             * for each user port is the same.
             * Why force mode speed-duplex config may be not the same?
             * Because we only check capabilities when auto mode, and
             * check force mode speed-duplex config when force mode.
             */

            if( trunk_ext_info.member_number != 0)
            {
                UI32_T fst_trk_mem_unit;
                UI32_T fst_trk_mem_port;
                UI32_T fst_trk_mem_ifindex;
                UI32_T fst_trk_mem_force_spddpx;

                fst_trk_mem_unit = trunk_ext_info.member_list[0].unit;
                fst_trk_mem_port = trunk_ext_info.member_list[0].port;
                fst_trk_mem_ifindex = SWCTRL_UPORT_TO_IFINDEX(fst_trk_mem_unit, fst_trk_mem_port);
                fst_trk_mem_force_spddpx = port_info[fst_trk_mem_ifindex-1].port_entry.port_speed_dpx_cfg ;

                for(i = 1; i < trunk_ext_info.member_number; i++)
                {
                    UI32_T checked_ifindex;
                    UI32_T checked_spddpx;

                    unit = (UI32_T) trunk_ext_info.member_list[i].unit;
                    port = (UI32_T) trunk_ext_info.member_list[i].port;

                    checked_ifindex = SWCTRL_UPORT_TO_IFINDEX(unit, port);
                    checked_spddpx  = port_info[checked_ifindex-1].port_entry.port_speed_dpx_cfg;

                    if(checked_spddpx != fst_trk_mem_force_spddpx)
                    {
                        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                                  SWCTRL_NO_USE_FUNC_NO,
                                                  EH_TYPE_MSG_TRUNK_CNFG_ERR,
                                                  SYSLOG_LEVEL_INFO,
                                                  "Forced Speed/Duplex Mode of Trunk members are not the same");  /*SWCTRL_ENO_NO_MEMBER_IN_TRUNK*/

                        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE);
                    }
                 }
            }
            else
            {
                EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                          SWCTRL_NO_USE_FUNC_NO,
                                          EH_TYPE_MSG_TRUNK_CNFG_ERR,
                                          SYSLOG_LEVEL_INFO,
                                          "Trunk contains no members");  /*SWCTRL_ENO_NO_MEMBER_IN_TRUNK*/

                SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
            }
        }
#endif /* wakka: obsolete */

        for(i = 0; i < trunk_ext_info.member_number; i++)
        {
            UI32_T ifindex;

            unit = (UI32_T) trunk_ext_info.member_list[i].unit;
            port = (UI32_T) trunk_ext_info.member_list[i].port;
            ifindex = SWCTRL_UPORT_TO_IFINDEX(unit, port);

            if (!SWCTRL_IsPortAutoNegEnableSupported(ifindex, autoneg_state))
            {
                continue;
            }

            if (port_info[ifindex-1].port_entry.port_autonegotiation == autoneg_state)
            {
                retval = TRUE; /* set retval to TRUE when one of member port cfg ok */
                continue;
            }

            if (!SWCTRL_SetUPortAutoNegEnable (unit, port, autoneg_state))
            {
                continue;
            }

            retval = TRUE; /* set retval to TRUE when one of member port cfg ok */
        }

        /* The database maintained here is just for trunk.
         * Specific user port database is set in SWCTRL_SetUPortAutoNegEnable()
         */
        if (retval)
        {
            SWCTRL_LOCK();
            port_info[ifindex-1].port_entry.port_autonegotiation = autoneg_state;
            SWCTRL_UNLOCK();
        }
    }

    /*macauley add for notify LLDP.2006-5-10*/
    SWCTRL_NOTIFY_LLDP(ifindex);

    SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME ();
    SWCTRL_RETURN_AND_RELEASE_CSC( retval );

} /* End of SWCTRL_SetPortAutoNegEnable() */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_IsPortAutoNegEnableSupported
 * -------------------------------------------------------------------------
 * FUNCTION: This function will check if specified autoneg status is configurable on the port
 * INPUT   : ifindex      -- uport ifindex
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
static BOOL_T SWCTRL_IsPortAutoNegEnableSupported(UI32_T ifindex, UI32_T autoneg_state)
{
#if (SWCTRL_UPDATE_PORT_ABILITY == TRUE)
    if (!(user_ext_port_info[ifindex-1].port_abililty.port_autoneg_supported & BIT_VALUE(autoneg_state)))
    {
        return FALSE;
    }
#else /* (SWCTRL_UPDATE_PORT_ABILITY == TRUE) */
    /* 100FX/10GFIBER/40GFIBER is force mode always
     */
    if ((SWCTRL_IS_100FIBER (ifindex)||SWCTRL_IS_10GFIBER (ifindex)||SWCTRL_IS_40GFIBER (ifindex))&& (autoneg_state==VAL_portAutonegotiation_enabled))
    {
        EH_MGR_Handle_Exception (SYS_MODULE_SWCTRL,
                                 SWCTRL_NO_USE_FUNC_NO,
                                 EH_TYPE_MSG_100FIBER_ERR_AUTO_NEGO,
                                 SYSLOG_LEVEL_INFO);/*SWCTRL_ENO_DENY_SET_AUTO_NEGO_ON_100_FIBER_PORT*/

        return FALSE;
    }

    /* 10GCOPPER is autoneg always
     */
    if ((SWCTRL_IS_10GCOPPER (ifindex))&& (autoneg_state==VAL_portAutonegotiation_disabled))
    {
        EH_MGR_Handle_Exception (SYS_MODULE_SWCTRL,
                                 SWCTRL_NO_USE_FUNC_NO,
                                 EH_TYPE_MSG_100FIBER_ERR_AUTO_NEGO,
                                 SYSLOG_LEVEL_INFO);

        return FALSE;
    }
#endif /* (SWCTRL_UPDATE_PORT_ABILITY == TRUE) */

    return TRUE;
}


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetPortCfgFlowCtrlEnable
 * -------------------------------------------------------------------------
 * FUNCTION: This function will enable flow control of a port or not
 * INPUT   : ifindex -- which port to set
 *           flow_contrl_cfg    -- VAL_portFlowCtrlCfg_enabled /
 *                                 VAL_portFlowCtrlCfg_disabled /
 *                                 VAL_portFlowCtrlCfg_tx /
 *                                 VAL_portFlowCtrlCfg_rx
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : 1. ES3626A
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetPortCfgFlowCtrlEnable(UI32_T ifindex, UI32_T flow_control_cfg)
{
    UI32_T                          unit, port, i;
    BOOL_T                          retval = FALSE;
    SWCTRL_TrunkPortExtInfo_T    trunk_ext_info;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

#if (SYS_CPNT_FLOW_CONTROL == FALSE)
    SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
#endif

    if (!SWCTRL_IS_LPORT(ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if((flow_control_cfg != VAL_portFlowCtrlCfg_enabled) &&
       (flow_control_cfg != VAL_portFlowCtrlCfg_disabled) &&
       (flow_control_cfg != VAL_portFlowCtrlCfg_tx) &&
       (flow_control_cfg != VAL_portFlowCtrlCfg_rx))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_INVALID_PARAMETER,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "flow control state");    /*SWCTRL_ENO_INVALID_FLOW_CTRL_STATE*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (port_info[ifindex-1].port_entry.port_flow_ctrl_cfg == flow_control_cfg)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
    }

    if (SWCTRL_IsServerBladePort (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_SRV_BLADE_PORT_CNFG,
                                  SYSLOG_LEVEL_INFO,
                                  "Configuring Forced Flow Control Mode");     /*SWCTRL_ENO_DENY_ON_SERVER_BLADE_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    SWCTRL_ENTER_XOR_CRITICAL_SECTION(&retval);

#if (SYS_CPNT_PFC == TRUE)
    SWCTRL_XOR_CHECK(
       SYSCTRL_XOR_MGR_PermitBeingSetToFcPort(ifindex));
#endif

    if (FALSE == SWCTRL_IS_TRUNK (ifindex))
    {
        /* normal port
         */
        if (FALSE == SWCTRL_IS_1000FIBER(ifindex))
        {
            /* txOn and rxOn are only used in GE port.
             * And
             * In 1000Copper case, force mode 1000Mbps is not allowable,
             * so force mode flowcontrol txOn and rxOf are not allowable.
             * In 1000Fiber case, for force mode, 1000MBps is the only speed for user to set,
             * so no problem of running in 10/1000MBps.
             */
            if (VAL_portFlowCtrlCfg_tx == flow_control_cfg ||
                VAL_portFlowCtrlCfg_rx == flow_control_cfg )
            {
                SWCTRL_BREAK_XOR_CRITICAL_SECTION(FALSE);
            }
        }

        if (!SWCTRL_IsPortCfgFlowCtrlSupported(ifindex, flow_control_cfg))
        {
            SWCTRL_BREAK_XOR_CRITICAL_SECTION(FALSE);
        }

        unit = SWCTRL_IFINDEX_TO_UNIT(ifindex);
        port = SWCTRL_IFINDEX_TO_PORT(ifindex);

        retval = SWCTRL_SetUPortCfgFlowCtrlEnable (unit, port, flow_control_cfg);
    }
    else
    {
        /* trunk port
         */
        SWCTRL_GetTrunkPortExtInfo (ifindex, &trunk_ext_info);

        SWCTRL_LOCK();
        for(i = 0; i < trunk_ext_info.member_number; i++)
        {
            unit = (UI32_T) trunk_ext_info.member_list[i].unit;
            port = (UI32_T) trunk_ext_info.member_list[i].port;

            if (FALSE == SWCTRL_IS_1000FIBER(SWCTRL_UPORT_TO_IFINDEX(unit, port)))
            {
                /* txOn and rxOn are only used in GE port.
                 * And
                 * In 1000Copper case, force mode 1000Mbps is not allowable,
                 * so force mode flowcontrol txOn and rxOf are not allowable.
                 * In 1000Fiber case, for force mode, 1000MBps is the only speed for user to set,
                 * so no problem of running in 10/1000MBps.
                 */
                if (VAL_portFlowCtrlCfg_tx == flow_control_cfg ||
                    VAL_portFlowCtrlCfg_rx == flow_control_cfg )
                {
                    SWCTRL_UNLOCK();
                    SWCTRL_BREAK_XOR_CRITICAL_SECTION(FALSE);
                }
            }
        }
        SWCTRL_UNLOCK();

        for(i = 0; i < trunk_ext_info.member_number; i++)
        {
            UI32_T ifindex;

            unit = (UI32_T) trunk_ext_info.member_list[i].unit;
            port = (UI32_T) trunk_ext_info.member_list[i].port;
            ifindex = SWCTRL_UPORT_TO_IFINDEX(unit, port);

            if (!SWCTRL_IsPortCfgFlowCtrlSupported(ifindex, flow_control_cfg))
            {
                continue;
            }

            if (!(retval = SWCTRL_SetUPortCfgFlowCtrlEnable (unit, port, flow_control_cfg)))
            {
                break;
        }
        }

        /* The database maintained here is just for trunk.
         * Specific user port database is set in SWCTRL_SetUPortCfgFlowCtrlEnable()
         */
        if (retval)
        {
            SWCTRL_LOCK();
            port_info[ifindex-1].port_entry.port_flow_ctrl_cfg = flow_control_cfg;

            if (flow_control_cfg != VAL_portFlowCtrlCfg_enabled)
            {
                port_info[ifindex-1].port_entry.port_flow_ctrl_status = VAL_portFlowCtrlStatus_none;
            }
            SWCTRL_UNLOCK();
        }
    }

    SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME ();

    SWCTRL_LEAVE_XOR_CRITICAL_SECTION();

    SWCTRL_RETURN_AND_RELEASE_CSC( retval );

} /* End of SWCTRL_SetPortCfgFlowCtrlEnable() */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_IsPortCfgFlowCtrlSupported
 * -------------------------------------------------------------------------
 * FUNCTION: This function will check if specified flow ctrl config is configurable on the port
 * INPUT   : ifindex      -- uport ifindex
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
static BOOL_T SWCTRL_IsPortCfgFlowCtrlSupported(UI32_T ifindex, UI32_T flow_control_cfg)
{
#if (SWCTRL_UPDATE_PORT_ABILITY == TRUE)
    if (!(user_ext_port_info[ifindex-1].port_abililty.port_flow_ctrl_cfg_supported & BIT_VALUE(flow_control_cfg)))
    {
        return FALSE;
    }
#endif /* (SWCTRL_UPDATE_PORT_ABILITY == TRUE) */

    return TRUE;
}


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetPortAutoNegCapability
 * -------------------------------------------------------------------------
 * FUNCTION: This function will set the capability of auto-negotiation of a
 *           port
 * INPUT   : ifindex    -- which port to get
 *           capability -- auto-negotiation capability
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : Flow control capability bit always depends on flow control mode.
 *           ie. If flow control is enabled, when enabing auto negotiation,
 *               flow control capability bit needs to be set on as well.
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetPortAutoNegCapability(UI32_T ifindex, UI32_T capability)
{
    UI32_T                       unit, port, i;
    BOOL_T                       retval = FALSE;
    SWCTRL_TrunkPortExtInfo_T    trunk_ext_info;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (    capability == 0
#if (SYS_CPNT_FLOW_CONTROL == FALSE)
        ||  capability & SYS_VAL_portCapabilities_portCapFlowCtrl
        ||  capability & SYS_VAL_portCapabilities_portCapSym
#endif
       )
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_INVALID,
                                  SYSLOG_LEVEL_INFO,
                                  "auto-negotiation capability");   /*SWCTRL_ENO_INVALID_AUTO_NEGO_CAPABILITY*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (!SWCTRL_IS_LPORT(ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (SWCTRL_IsServerBladePort (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_SRV_BLADE_PORT_CNFG,
                                  SYSLOG_LEVEL_INFO,
                                  "Configuring Auto-Negotiation capabilities");     /*SWCTRL_ENO_DENY_ON_SERVER_BLADE_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (port_info[ifindex-1].port_entry.port_capabilities == capability)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
    }

    SWCTRL_ENTER_XOR_CRITICAL_SECTION(&retval);

#if (SYS_CPNT_PFC == TRUE)
    SWCTRL_XOR_CHECK(
       SYSCTRL_XOR_MGR_PermitBeingSetToFcPort(ifindex));
#endif

    /* Action
     */
    if (!SWCTRL_IS_TRUNK (ifindex))
    {
        if (!SWCTRL_IsPortAutoNegEnableSupported(ifindex, VAL_portAutonegotiation_enabled))
        {
            SWCTRL_BREAK_XOR_CRITICAL_SECTION(FALSE);
        }

        if (!SWCTRL_IsPortAutoNegCapabilitySupported(ifindex, capability))
        {
            SWCTRL_BREAK_XOR_CRITICAL_SECTION(FALSE);
        }

        /* normal port
         */
        unit = SWCTRL_IFINDEX_TO_UNIT(ifindex);
        port = SWCTRL_IFINDEX_TO_PORT(ifindex);
        retval = SWCTRL_SetUPortAutoNegCapability(unit, port, capability);
    }
    else
    {
        UI32_T capability_to_add, capability_to_remove;
        UI32_T primary_ifindex;

        if (SWCTRL_GetTrunkPrimaryPort(ifindex, &primary_ifindex))
        {
            capability_to_add = (capability & port_info[primary_ifindex-1].port_entry.port_capabilities) ^ capability;
            capability_to_remove = (capability & port_info[primary_ifindex-1].port_entry.port_capabilities) ^ port_info[primary_ifindex-1].port_entry.port_capabilities;

            /* trunk port
             */
            SWCTRL_GetTrunkPortExtInfo (ifindex, &trunk_ext_info);

            for(i = 0; i < trunk_ext_info.member_number; i++)
            {
                UI32_T ifindex, capability;

                unit = (UI32_T) trunk_ext_info.member_list[i].unit;
                port = (UI32_T) trunk_ext_info.member_list[i].port;
                ifindex = SWCTRL_UPORT_TO_IFINDEX(unit, port);

                capability = (port_info[ifindex-1].port_entry.port_capabilities | capability_to_add) & ~ capability_to_remove;

                if (!SWCTRL_IsPortAutoNegEnableSupported(ifindex, VAL_portAutonegotiation_enabled))
                {
                    continue;
                }

                if (!SWCTRL_IsPortAutoNegCapabilitySupported(ifindex, capability))
                {
                    continue;
                }

                if (port_info[ifindex-1].port_entry.port_capabilities == capability)
                {
                    retval = TRUE; /* set retval to TRUE when one of member port cfg ok */
                    continue;
                }

                if (!SWCTRL_SetUPortAutoNegCapability (unit, port, capability))
                {
                    continue;
                }

                retval = TRUE; /* set retval to TRUE when one of member port cfg ok */
            }

            /* The database maintained here is just for trunk.
             * Specific user port database is set in SWCTRL_SetUPortAutoNegCapability()
             */
            if (retval)
            {
                SWCTRL_LOCK();
                port_info[ifindex-1].port_entry.port_capabilities = capability;
                SWCTRL_UNLOCK();
            }
        }
    }

    if (TRUE == retval)
    {
        /*macauley add for notify LLDP.2006-5-10*/
        SWCTRL_NOTIFY_LLDP(ifindex);

        SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME ();
    }

    SWCTRL_LEAVE_XOR_CRITICAL_SECTION();

    SWCTRL_RETURN_AND_RELEASE_CSC( retval );

} /* End of SWCTRL_SetPortAutoNegCapability() */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_IsPortAutoNegCapabilitySupported
 * -------------------------------------------------------------------------
 * FUNCTION: This function will check if specified autoneg capabilities is configurable on the port
 * INPUT   : ifindex      -- uport ifindex
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
static BOOL_T SWCTRL_IsPortAutoNegCapabilitySupported(UI32_T ifindex, UI32_T capability)
{
#if (SWCTRL_UPDATE_PORT_ABILITY == TRUE)
    UI32_T at_least_one_capability_in_these =
        SYS_VAL_portCapabilities_portCap10half |
        SYS_VAL_portCapabilities_portCap10full |
        SYS_VAL_portCapabilities_portCap100half |
        SYS_VAL_portCapabilities_portCap100full |
        SYS_VAL_portCapabilities_portCap1000half |
        SYS_VAL_portCapabilities_portCap1000full |
        SYS_VAL_portCapabilities_portCap10gHalf |
        SYS_VAL_portCapabilities_portCap10gFull |
        SYS_VAL_portCapabilities_portCap40gHalf |
        SYS_VAL_portCapabilities_portCap40gFull |
        SYS_VAL_portCapabilities_portCap100gFull;

    if (!(user_ext_port_info[ifindex-1].port_abililty.port_autoneg_supported & BIT_VALUE(VAL_portAutonegotiation_enabled)))
    {
        /* capa shall not be allowed to change if autoneg is not supported
         */
        return FALSE;
    }

    if (!(at_least_one_capability_in_these & capability))
    {
#if (SYS_CPNT_EH == TRUE)
        EH_MGR_Handle_Exception (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_SPD_DUPLEX_UNSET,
                                  SYSLOG_LEVEL_INFO);   /*SWCTRL_ENO_INVALID_AUTO_NEGO_CAPABILITY*/
#endif
        return FALSE;
    }

    if (~ user_ext_port_info[ifindex-1].port_abililty.port_capabilities_supported & capability)
    {
#if (SYS_CPNT_EH == TRUE)
        UI32_T invalid_capa = ~ user_ext_port_info[ifindex-1].port_abililty.port_capabilities_supported & capability;
        void *arg1 = NULL, arg2 = NULL;
        int i;

        for (i = 0; i < sizeof(invalid_capa)*8 && arg1 == NULL; i++)
        {
            if (invalid_capa & L_CVRT_SNMP_BIT_VALUE_32(i))
            {
                if (swctrl_capa_str[i] != NULL)
                {
                    arg1 = swctrl_capa_str[i];
                    break;
                }
            }
        }

        if (port_info[(ifindex)-1].port_entry.port_type < sizeof(swctrl_port_type_str)/sizeof(*swctrl_port_type_str))
        {
            arg2 = swctrl_port_type_str[port_info[(ifindex)-1].port_entry.port_type];
        }

        if (arg1 && arg2)
        {
            EH_MGR_Handle_Exception2 (SYS_MODULE_SWCTRL,
                                      SWCTRL_NO_USE_FUNC_NO,
                                      EH_TYPE_MSG_INVAL_CAPABILITY,
                                      SYSLOG_LEVEL_INFO,
                                      arg1,
                                      arg2);
        }
#endif
        return FALSE;
    }
#else /* (SWCTRL_UPDATE_PORT_ABILITY == TRUE) */
    UI32_T                       at_least_one_capability_in_these = 0;
    UI32_T                       only_these_capabilities_are_allowed = 0;

    if(SWCTRL_IS_100TX (ifindex))
    {
        at_least_one_capability_in_these   =  SYS_VAL_portCapabilities_portCap10half  |
                                              SYS_VAL_portCapabilities_portCap10full  |
                                              SYS_VAL_portCapabilities_portCap100half |
                                              SYS_VAL_portCapabilities_portCap100full ;

        only_these_capabilities_are_allowed = SYS_VAL_portCapabilities_portCap10half   |
                                              SYS_VAL_portCapabilities_portCap10full   |
                                              SYS_VAL_portCapabilities_portCap100half  |
                                              SYS_VAL_portCapabilities_portCap100full  |
                                              SYS_VAL_portCapabilities_portCapFlowCtrl ;
    }
    else if(SWCTRL_IS_100FIBER (ifindex))
    {
        at_least_one_capability_in_these    = SYS_VAL_portCapabilities_portCap100full;

        only_these_capabilities_are_allowed = SYS_VAL_portCapabilities_portCap100full;
    }
    else if(SWCTRL_IS_1000FIBER (ifindex))
    {
        at_least_one_capability_in_these    = SYS_VAL_portCapabilities_portCap1000full;

        only_these_capabilities_are_allowed = SYS_VAL_portCapabilities_portCap1000full |
                                              SYS_VAL_portCapabilities_portCapFlowCtrl |
                                              SYS_VAL_portCapabilities_portCapSym      ;
    }
    else if(SWCTRL_IS_10GFIBER(ifindex))
    {
        at_least_one_capability_in_these    = SYS_VAL_portCapabilities_portCap10gFull;

        only_these_capabilities_are_allowed = SYS_VAL_portCapabilities_portCap10gFull  |
                                              SYS_VAL_portCapabilities_portCapSym      |
                                              SYS_VAL_portCapabilities_portCapFlowCtrl ;
    }
    else if(SWCTRL_IS_10GCOPPER(ifindex))
    {
        at_least_one_capability_in_these    = SYS_VAL_portCapabilities_portCap10gFull;

        only_these_capabilities_are_allowed = SYS_VAL_portCapabilities_portCap10gFull  |
                                              SYS_VAL_portCapabilities_portCapSym      |
                                              SYS_VAL_portCapabilities_portCapFlowCtrl ;
    }
    else if(SWCTRL_IS_40GFIBER(ifindex))
    {
        at_least_one_capability_in_these    = SYS_VAL_portCapabilities_portCap40gFull;

        only_these_capabilities_are_allowed = SYS_VAL_portCapabilities_portCap40gFull  |
                                              SYS_VAL_portCapabilities_portCapSym      |
                                              SYS_VAL_portCapabilities_portCapFlowCtrl ;
    }
    else if (SWCTRL_IS_1000T (ifindex))
    {
        at_least_one_capability_in_these    = SYS_VAL_portCapabilities_portCap10half   |
                                              SYS_VAL_portCapabilities_portCap10full   |
                                              SYS_VAL_portCapabilities_portCap100half  |
                                              SYS_VAL_portCapabilities_portCap100full  |
                                              SYS_VAL_portCapabilities_portCap1000full ;

        only_these_capabilities_are_allowed = SYS_VAL_portCapabilities_portCap10half   |
                                              SYS_VAL_portCapabilities_portCap10full   |
                                              SYS_VAL_portCapabilities_portCap100half  |
                                              SYS_VAL_portCapabilities_portCap100full  |
                                              SYS_VAL_portCapabilities_portCap1000full |
                                              SYS_VAL_portCapabilities_portCapSym      |
                                              SYS_VAL_portCapabilities_portCapFlowCtrl ;
    }

    if( ! (capability & at_least_one_capability_in_these) )
    {
        EH_MGR_Handle_Exception (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_SPD_DUPLEX_UNSET,
                                  SYSLOG_LEVEL_INFO);   /*SWCTRL_ENO_INVALID_AUTO_NEGO_CAPABILITY*/

        return FALSE;
    }

    if( capability & ~only_these_capabilities_are_allowed )
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T port_type[16]    = "ERROR"; /*init to error condition*/
        UI8_T invalid_capa[16] = "ERROR"; /*init to error condition*/

        if(SWCTRL_IS_100TX (ifindex))
        {
            strcpy(port_type, "100 TX");

            /* invalid capabilities
             * 1)1000full
             * 2)Symmetric
             */
            if (capability & SYS_VAL_portCapabilities_portCap1000full)
            {
                strcpy(invalid_capa, "1000full");
            }
            else if (capability & SYS_VAL_portCapabilities_portCapSym)
            {
                strcpy(invalid_capa, "Symmetric");
            }
        }
        else if(SWCTRL_IS_100FIBER (ifindex))
        {
             strcpy(port_type, "100 fiber");

            /* invalid capabilities
             * 1) 10half
             * 2) 10full
             * 3) 100half
             * 4) 1000full
             * 5) Symmetric
             * 6) Flowcontrol
             */
            if (capability & SYS_VAL_portCapabilities_portCap10half)
            {
                strcpy(invalid_capa, "10half");
            }
            else if (capability & SYS_VAL_portCapabilities_portCap10full)
            {
                strcpy(invalid_capa, "10full");
            }
            else if (capability & SYS_VAL_portCapabilities_portCap100half)
            {
                strcpy(invalid_capa, "100half");
            }
            else if (capability & SYS_VAL_portCapabilities_portCap1000full)
            {
                strcpy(invalid_capa, "1000full");
            }
            else if (capability & SYS_VAL_portCapabilities_portCapSym)
            {
                strcpy(invalid_capa, "Symmetric");
            }
            else if (capability & SYS_VAL_portCapabilities_portCapFlowCtrl)
            {
                strcpy(invalid_capa, "Flowcontrol");
            }
        }
        else if(SWCTRL_IS_1000FIBER (ifindex))
        {
            strcpy(port_type, "1000 fiber");

            /* invalid capabilities
             * 1) 10half
             * 2) 10full
             * 3) 100half
             * 4) 100full
             */
            if (capability & SYS_VAL_portCapabilities_portCap10half)
            {
                strcpy(invalid_capa, "10half");
            }
            else if (capability & SYS_VAL_portCapabilities_portCap10full)
            {
                strcpy(invalid_capa, "10full");
            }
            else if (capability & SYS_VAL_portCapabilities_portCap100half)
            {
                strcpy(invalid_capa, "100half");
            }
            else if (capability & SYS_VAL_portCapabilities_portCap100full)
            {
                strcpy(invalid_capa, "100full");
            }
        }
        else if(SWCTRL_IS_10GFIBER (ifindex))
        {
            strcpy(port_type, "10G fiber");

            /* invalid capabilities
             * 1) 10half
             * 2) 10full
             * 3) 100half
             * 4) 100full
             * 5) 1000full
             */
            if (capability & SYS_VAL_portCapabilities_portCap10half)
            {
                strcpy(invalid_capa, "10half");
            }
            else if (capability & SYS_VAL_portCapabilities_portCap10full)
            {
                strcpy(invalid_capa, "10full");
            }
            else if (capability & SYS_VAL_portCapabilities_portCap100half)
            {
                strcpy(invalid_capa, "100half");
            }
            else if (capability & SYS_VAL_portCapabilities_portCap100full)
            {
                strcpy(invalid_capa, "100full");
            }
            else if (capability & SYS_VAL_portCapabilities_portCap1000full)
            {
                strcpy(invalid_capa, "1000full");
            }
        }
        else if(SWCTRL_IS_10GCOPPER (ifindex))
        {
            strcpy(port_type, "10G copper");

            /* invalid capabilities
             * 1) 10half
             * 2) 10full
             * 3) 100half
             * 4) 100full
             * 5) 1000full
             */
            if (capability & SYS_VAL_portCapabilities_portCap10half)
            {
                strcpy(invalid_capa, "10half");
            }
            else if (capability & SYS_VAL_portCapabilities_portCap10full)
            {
                strcpy(invalid_capa, "10full");
            }
            else if (capability & SYS_VAL_portCapabilities_portCap100half)
            {
                strcpy(invalid_capa, "100half");
            }
            else if (capability & SYS_VAL_portCapabilities_portCap100full)
            {
                strcpy(invalid_capa, "100full");
            }
            else if (capability & SYS_VAL_portCapabilities_portCap1000full)
            {
                strcpy(invalid_capa, "1000full");
            }
        }
        else if(SWCTRL_IS_40GFIBER (ifindex))
        {
            strcpy(port_type, "40G fiber");

            /* invalid capabilities
             * 1) 10half
             * 2) 10full
             * 3) 100half
             * 4) 100full
             * 5) 1000full
             * 6) 10ghalf
             * 7) 10gfull
             */
            if (capability & SYS_VAL_portCapabilities_portCap10half)
            {
                strcpy(invalid_capa, "10half");
            }
            else if (capability & SYS_VAL_portCapabilities_portCap10full)
            {
                strcpy(invalid_capa, "10full");
            }
            else if (capability & SYS_VAL_portCapabilities_portCap100half)
            {
                strcpy(invalid_capa, "100half");
            }
            else if (capability & SYS_VAL_portCapabilities_portCap100full)
            {
                strcpy(invalid_capa, "100full");
            }
            else if (capability & SYS_VAL_portCapabilities_portCap1000full)
            {
                strcpy(invalid_capa, "1000full");
            }
            else if (capability & SYS_VAL_portCapabilities_portCap10gHalf)
            {
                strcpy(invalid_capa, "10ghalf");
            }
            else if (capability & SYS_VAL_portCapabilities_portCap10gFull)
            {
                strcpy(invalid_capa, "10gfull");
            }
        }
        else  /* SWCTRL_IS_1000T (ifindex) */
        {
            strcpy(port_type, "1000 TX");

            /* all capabilities are welcome
             */
            ;
        }

        EH_MGR_Handle_Exception2 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_INVAL_CAPABILITY,
                                  SYSLOG_LEVEL_INFO,
                                  invalid_capa,
                                  port_type);
#endif

        return FALSE;
    }
#endif /* (SWCTRL_UPDATE_PORT_ABILITY == TRUE) */

    return TRUE;
}


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetPortDefaultAutoNegCapability
 * -------------------------------------------------------------------------
 * FUNCTION: This function will set the capability of auto-negotiation of a
 *           port to default value
 * INPUT   : ifindex
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : for CLI use
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetPortDefaultAutoNegCapability(UI32_T ifindex)
{
    UI32_T default_capability;
#if (SWCTRL_UPDATE_PORT_ABILITY == TRUE)
    UI32_T unit, port;
#endif

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (!SWCTRL_IS_LPORT(ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

#if (SWCTRL_UPDATE_PORT_ABILITY == TRUE)
    if (SWCTRL_IS_TRUNK(ifindex))
    {
        UI32_T primary_ifindex;

        if (!SWCTRL_GetTrunkPrimaryPort(ifindex, &primary_ifindex))
        {
            SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
        }

        unit = SWCTRL_IFINDEX_TO_UNIT(primary_ifindex);
        port = SWCTRL_IFINDEX_TO_PORT(primary_ifindex);
    }
    else
    {
        unit = SWCTRL_IFINDEX_TO_UNIT(ifindex);
        port = SWCTRL_IFINDEX_TO_PORT(ifindex);
    }

    default_capability = SWCTRL_GetPortAutoNegCapabilityDfltCfg(unit, port);
#else /* (SWCTRL_UPDATE_PORT_ABILITY == TRUE) */
    if( SWCTRL_IS_100TX(ifindex) )          /*FE_COPPER*/
    {
        default_capability = SYS_DFLT_10_100_PORT_CAPABILITIES;
    }
    else if( SWCTRL_IS_100FIBER(ifindex) )  /*FE_FIBER*/
    {
        default_capability = SYS_DFLT_100_FIBER_PORT_CAPABILITIES;
    }
    else if( SWCTRL_IS_1000T(ifindex) )     /*GE_COPPER*/
    {
        default_capability = SYS_DFLT_10_100_1000_PORT_CAPABILITIES;
    }
    else if( SWCTRL_IS_10GFIBER(ifindex) )       /*10G port fiber*/
    {
        default_capability = SYS_DFLT_10G_FIBER_PORT_CAPABILITIES;
    }
    else if( SWCTRL_IS_10GCOPPER (ifindex) )       /*10G port copper*/
    {
        default_capability = SYS_DFLT_10G_COPPER_PORT_CAPABILITIES;
    }
    else if( SWCTRL_IS_40GFIBER(ifindex) )  /* 40G port fiber */
    {
        default_capability = SYS_DFLT_40G_FIBER_PORT_CAPABILITIES;
    }
    else                                   /*GE_FIBER*/
    {
        default_capability = SYS_DFLT_1000_FIBER_PORT_CAPABILITIES;
    }
#endif /* (SWCTRL_UPDATE_PORT_ABILITY == TRUE) */

    if (!SWCTRL_SetPortAutoNegCapability(ifindex, default_capability))
    {
        /*error code was set by SWCTRL_SetPortCfgSpeedDuplex()*/
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
} /* End of SWCTRL_SetPortDefaultAutoNegCapability () */


#if (SYS_CPNT_SWCTRL_FEC == TRUE)
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetPortFec
 * -------------------------------------------------------------------------
 * FUNCTION: To enable/disable FEC
 * INPUT   : ifindex
 *           fec_mode - VAL_portFecMode_XXX
 * OUTPUT  : None
 * RETURN  : TRUE/FALSE
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetPortFec(UI32_T ifindex, UI32_T fec_mode)
{
    UI32_T unit, port;
    BOOL_T ret = TRUE;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (!SWCTRL_IS_USER_PORT(ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Interface");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (!SWCTRL_IS_EXIST (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Interface");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (!SWCTRL_IsPortFecSupported(ifindex, fec_mode))
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (user_ext_port_info[ifindex-1].port_fec_mode == fec_mode)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
    }

    SWCTRL_LOCK();

    unit = SWCTRL_IFINDEX_TO_UNIT(ifindex);
    port = SWCTRL_IFINDEX_TO_PORT(ifindex);

    if (!SWDRV_SetPortFec(unit, port, fec_mode))
    {
        ret = FALSE;
    }

    if (ret)
    {
        user_ext_port_info[ifindex-1].port_fec_mode = fec_mode;
    }

    SWDRV_GetPortFecStatus(unit, port, &user_ext_port_info[ifindex-1].port_fec_status);

    SWCTRL_UNLOCK();

    SWCTRL_RETURN_AND_RELEASE_CSC( ret );
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_IsPortFecSupported
 * -------------------------------------------------------------------------
 * FUNCTION: This function will check if specified FEC is configurable on the port
 * INPUT   : ifindex      -- uport ifindex
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
static BOOL_T SWCTRL_IsPortFecSupported(UI32_T ifindex, UI32_T fec_mode)
{
#if (SWCTRL_UPDATE_PORT_ABILITY == TRUE)
    if (!(user_ext_port_info[ifindex-1].port_abililty.port_fec_supported & BIT_VALUE(fec_mode)))
    {
        return FALSE;
    }
#else /* (SWCTRL_UPDATE_PORT_ABILITY == TRUE) */
    return FALSE;
#endif /* (SWCTRL_UPDATE_PORT_ABILITY == TRUE) */

    return TRUE;
}
#endif /* (SYS_CPNT_SWCTRL_FEC == TRUE) */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetPortLinkChangeTrapEnable
 * -------------------------------------------------------------------------
 * FUNCTION: This function will enable to send trap when port link state
 *           changes.
 * INPUT   : ifindex            -- which port to set
 *           link_change_trap   -- VAL_ifLinkUpDownTrapEnable_enabled/
                                   VAL_ifLinkUpDownTrapEnable_disabled
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : 1.RFC2863
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetPortLinkChangeTrapEnable(UI32_T ifindex, UI32_T link_change_trap)
{
    UI32_T                          unit, port, i;
    SWCTRL_TrunkPortExtInfo_T       trunk_ext_p_info;


    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (!SWCTRL_IS_LPORT(ifindex))
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Logical Port ID (1-%d)", SYS_ADPT_TOTAL_NBR_OF_LPORT);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_LOGICAL_PORT_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if((link_change_trap != VAL_ifLinkUpDownTrapEnable_enabled) &&
       (link_change_trap != VAL_ifLinkUpDownTrapEnable_disabled))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_INVALID_PARAMETER,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "link up/down trap state"); /*SWCTRL_ENO_INVALID_LINK_UP_DOWN_TRAP_STATE*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if(port_info[ifindex-1].link_change_trap == link_change_trap)
        SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );

    SWCTRL_LOCK();
    if (SWCTRL_IS_TRUNK (ifindex))
    {
        SWCTRL_GetTrunkPortExtInfo (ifindex, &trunk_ext_p_info);

        for(i = 0; i < trunk_ext_p_info.member_number; i++)
        {
            unit = (UI32_T) trunk_ext_p_info.member_list[i].unit;
            port = (UI32_T) trunk_ext_p_info.member_list[i].port;
            port_info[SWCTRL_UPORT_TO_IFINDEX(unit, port)-1].link_change_trap = link_change_trap;
        } /* End of for () */
    }
    port_info[ifindex-1].link_change_trap = link_change_trap;
    SWCTRL_UNLOCK();
    SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME ();
    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
} /* End of SWCTRL_SetPortLinkChangeTrapEnable() */

/* dot1x
 */
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetPortDot1xEnable
 * -------------------------------------------------------------------------
 * FUNCTION: This function is called by dot1x. In this way SWCTRL could know
 *           the dot1x enable/disable status of this port and then SWCTRL can
 *           make the state machine work without dot1x intervention.
 * INPUT   : ifindex            -- which port to set
 *           dot1x_port_status  -- 1) SWCTRL_DOT1X_PORT_DISABLE
 *                                 2) SWCTRL_DOT1X_PORT_ENABLE
 * OUTPUT  : None
 * RETURN  : TRUE:  Successfully.
 *           FALSE: 1) ifindex is not belong to user port.
 *                  2) This port is not present.
 *                  3) Parameter error.
 * NOTE    : For dot1x.
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetPortDot1xEnable(UI32_T ifindex, UI32_T dot1x_port_status)
{
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if( dot1x_port_status != SWCTRL_DOT1X_PORT_DISABLE &&
        dot1x_port_status != SWCTRL_DOT1X_PORT_ENABLE  )
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_INVALID_PARAMETER,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "DOT1X enable/disable state");    /*SWCTRL_ENO_INVALID_DOT1X_STATE*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (!SWCTRL_IS_EXIST (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Interface");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    /* In our design, DOT1X could not be enabled on
     * 1) trunk member port
     * 2) trunk port
     */
    if (SWCTRL_IS_TRUNK_MEMBER (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_TRUNK_MEMBER_CNFG_ERR,
                                  SYSLOG_LEVEL_INFO|EH_MGR_FOR_DEBUG_MSG_PURPOSE,
                                  "Trunk member doesn't support DOT1X");  /*SWCTRL_ENO_NOT_TRUNK_MEMBER*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if(SWCTRL_IS_TRUNK(ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_TRUNK_CNFG_ERR,
                                  SYSLOG_LEVEL_INFO|EH_MGR_FOR_DEBUG_MSG_PURPOSE,
                                  "it doesn't support DOT1X");  /*SWCTRL_ENO_NOT_TRUNK*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    /* In our design, LACP and (DOT1X || PSEC) could not be enable state at the same time
     */
#if (SYS_CPNT_STATIC_TRUNK_CONFIG_ALLOWED_ON_LACP_PORT == TRUE)
    if( user_ext_port_info[ifindex-1].lacp_admin_status == VAL_lacpPortStatus_enabled &&
        dot1x_port_status == SWCTRL_DOT1X_PORT_ENABLE                                 )
#else
    if( user_ext_port_info[ifindex-1].lacp_status == VAL_lacpPortStatus_enabled &&
        dot1x_port_status == SWCTRL_DOT1X_PORT_ENABLE                           )
#endif
    {
        EH_MGR_Handle_Exception2 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_MUTUAL_EXCLUSIVE,
                                  SYSLOG_LEVEL_INFO,
                                  "LACP", "DOT1X");  /*SWCTRL_ENO_MUTEX*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if(user_ext_port_info[ifindex-1].dot1x_status == dot1x_port_status)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
    }

    SWCTRL_LOCK();
    user_ext_port_info[ifindex-1].dot1x_status = dot1x_port_status;
    SWCTRL_UNLOCK();

    if (dot1x_port_status == SWCTRL_DOT1X_PORT_ENABLE)
    {
        SWCTRL_SetPortOperDormantStatus(ifindex, SWCTRL_OPER_DORMANT_LV_DOT1X, TRUE, FALSE);
    }
    else
    {
        SWCTRL_SetPortOperDormantStatus(ifindex, SWCTRL_OPER_DORMANT_LV_DOT1X, FALSE, FALSE);
    }

    SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME ();
    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetPortDot1xAuthState
 * -------------------------------------------------------------------------
 * FUNCTION: This function is called by dot1x. SWCTRL use this event to drive
 *           the state machine of the oper state.
 *           the dot1x enable/disable status of this port and then SWCTRL can
 *           make the state machine work without dot1x intervention.
 * INPUT   : ifindex          -- which port to set
 *           dot1x_auth_status -- 1) SWCTRL_DOT1X_PORT_AUTHORIZED
 *                                2) SWCTRL_DOT1X_PORT_UNAUTHORIZED
 * OUTPUT  : None.
 * RETURN  : TRUE:  Successfully.
 *           FALSE: 1) ifindex is not belong to user port.
 *                  2) This port is not present.
 *                  3) Parameter error.
 * NOTE    : For dot1x.
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetPortDot1xAuthState(UI32_T ifindex, UI32_T dot1x_auth_status)
{
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if( dot1x_auth_status != SWCTRL_DOT1X_PORT_UNAUTHORIZED &&
        dot1x_auth_status != SWCTRL_DOT1X_PORT_AUTHORIZED  )
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_INVALID_PARAMETER,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "DOT1X authentication state");    /*SWCTRL_ENO_INVALID_DOT1X_AUTH_STATE*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (!SWCTRL_IS_EXIST (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Interface");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    /* In our design, DOT1X could not be configured on
     * 1) trunk member port
     * 2) trunk port
     */
    if (SWCTRL_IS_TRUNK_MEMBER (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_TRUNK_MEMBER_CNFG_ERR,
                                  SYSLOG_LEVEL_INFO|EH_MGR_FOR_DEBUG_MSG_PURPOSE,
                                  "Trunk member doesn't support DOT1X");  /*SWCTRL_ENO_NOT_TRUNK_MEMBER*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if(SWCTRL_IS_TRUNK(ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_TRUNK_CNFG_ERR,
                                  SYSLOG_LEVEL_INFO,
                                  "it doesn't support DOT1X");  /*SWCTRL_ENO_NOT_TRUNK*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (dot1x_auth_status == SWCTRL_DOT1X_PORT_AUTHORIZED)
    {
        SWCTRL_TriggerPortOperDormantEvent(ifindex, SWCTRL_OPER_DORMANT_LV_DOT1X, SWCTRL_OPER_DORMANT_EV_LEAVE);
    }
    else
    {
        SWCTRL_TriggerPortOperDormantEvent(ifindex, SWCTRL_OPER_DORMANT_LV_DOT1X, SWCTRL_OPER_DORMANT_EV_ENTER);
    }

    SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME ();
    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
}

#if (SYS_CPNT_STATIC_TRUNK_CONFIG_ALLOWED_ON_LACP_PORT == TRUE)
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetPortLacpOperEnable
 * -------------------------------------------------------------------------
 * FUNCTION: This function is used to set LACP oper status.
 * INPUT   : ifindex --- Which user port.
 *           lacp_oper_state --- VAL_lacpPortStatus_enabled/
 *                               VAL_lacpPortStatus_disabled
 * OUTPUT  : None.
 * RETURN  : TRUE/FALSE
 * NOTE    : 1. For LACP only.
 *           2. User port only.
 *           3. SWCTRL use this oper status to run ifOperStatus state machine.
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetPortLacpOperEnable(UI32_T ifindex, UI32_T lacp_oper_status)
{
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (!SWCTRL_IS_EXIST(ifindex))
    {
        /*UIMSG_MGR_SetErrorCode(); */ /*SWCTRL_ENO_PORT_NOT_PRESENT*/
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if(SWCTRL_IS_TRUNK(ifindex))
    {
        /*UIMSG_MGR_SetErrorCode(); */ /*SWCTRL_ENO_NOT_TRUNK*/
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if( lacp_oper_status != VAL_lacpPortStatus_enabled  &&
        lacp_oper_status != VAL_lacpPortStatus_disabled )
    {
        /*UIMSG_MGR_SetErrorCode(); */ /*SWCTRL_ENO_INVALID_LACP_STATE*/
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if(user_ext_port_info[ifindex-1].lacp_oper_status == lacp_oper_status)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
    }

    SWCTRL_LOCK();
    user_ext_port_info[ifindex-1].lacp_oper_status = lacp_oper_status;
    SWCTRL_UNLOCK();

    if (SWCTRL_IS_TRUNK_MEMBER(ifindex))
    {
        /*UIMSG_MGR_SetErrorCode(); */ /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/
        SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
    }

    {
        BOOL_T dormant_enable;

        dormant_enable =
            (SWCTRL_IS_FULL_DUPLEX (ifindex) &&
            (lacp_oper_status == VAL_lacpPortStatus_enabled));

        SWCTRL_SetPortOperDormantStatus(ifindex, SWCTRL_OPER_DORMANT_LV_LACP, dormant_enable, FALSE);
    }

    SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME ();
    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetPortLacpAdminEnable
 * -------------------------------------------------------------------------
 * FUNCTION: This function is used to set LACP admin status.
 * INPUT   : ifindex --- Which user port.
 *           lacp_admin_status --- VAL_lacpPortStatus_enabled/
 *                                 VAL_lacpPortStatus_disabled
 * OUTPUT  : None.
 * RETURN  : TRUE/FALSE
 * NOTE    : 1. For LACP only.
 *           2. User port only.
 *           3. SWCTRL use this admin status to do mutex check with dot1x.
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetPortLacpAdminEnable(UI32_T ifindex, UI32_T lacp_admin_status)
{
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (!SWCTRL_IS_LPORT(ifindex))
    {
        /*UIMSG_MGR_SetErrorCode(); */ /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if(SWCTRL_IS_TRUNK(ifindex))
    {
        /*UIMSG_MGR_SetErrorCode(); */ /*SWCTRL_ENO_NOT_TRUNK*/
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if( lacp_admin_status != VAL_lacpPortStatus_enabled  &&
        lacp_admin_status != VAL_lacpPortStatus_disabled )
    {
        /*UIMSG_MGR_SetErrorCode(); */ /*SWCTRL_ENO_INVALID_LACP_STATE*/
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    /* In our design, LACP and (DOT1X || PSEC) could not be enable state at the same time
     */
    if( (user_ext_port_info[ifindex-1].dot1x_status == SWCTRL_DOT1X_PORT_ENABLE     ||
         port_info[ifindex-1].port_security_status  == VAL_portSecPortStatus_enabled)  &&
         lacp_admin_status == VAL_lacpPortStatus_enabled )
    {
        /*UIMSG_MGR_SetErrorCode(); */ /*xxxx*/
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if(user_ext_port_info[ifindex-1].lacp_admin_status == lacp_admin_status)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
    }

    SWCTRL_LOCK();
    user_ext_port_info[ifindex-1].lacp_admin_status = lacp_admin_status;
    SWCTRL_UNLOCK();

    SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME ();
    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
}

#else

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetPortLacpEnable
 * -------------------------------------------------------------------------
 * FUNCTION: This function will enable/disable the LACP function of a port
 * INPUT   : ifindex        -- which port to set
 *           lacp_state     -- VAL_lacpPortStatus_enabled/
                               VAL_lacpPortStatus_disabled
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : 1.802.3ad
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetPortLacpEnable(UI32_T ifindex, UI32_T lacp_state)
{
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (!SWCTRL_IS_LPORT(ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if(SWCTRL_IS_TRUNK(ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_TRUNK_CNFG_ERR,
                                  SYSLOG_LEVEL_INFO,
                                  "it doesn't support LACP");  /*SWCTRL_ENO_NOT_TRUNK*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if( lacp_state != VAL_lacpPortStatus_enabled  &&
        lacp_state != VAL_lacpPortStatus_disabled )
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_INVALID_PARAMETER,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "LACP state");    /*SWCTRL_ENO_INVALID_LACP_STATE*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    /* In our design, LACP and (DOT1X || PSEC) could not be enable state at the same time
     */
    if( (user_ext_port_info[ifindex-1].dot1x_status == SWCTRL_DOT1X_PORT_ENABLE     ||
         port_info[ifindex-1].port_security_status  == VAL_portSecPortStatus_enabled)  &&
        lacp_state == VAL_lacpPortStatus_enabled )
    {
        EH_MGR_Handle_Exception2 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_MUTUAL_EXCLUSIVE,
                                  SYSLOG_LEVEL_INFO,
                                  "LACP", "Port Security");  /*SWCTRL_ENO_MUTEX*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if(user_ext_port_info[ifindex-1].lacp_status == lacp_state)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
    }

    SWCTRL_LOCK();
    user_ext_port_info[ifindex-1].lacp_status = lacp_state;
    SWCTRL_UNLOCK();

    {
        BOOL_T dormant_enable;

        dormant_enable =
            (SWCTRL_IS_FULL_DUPLEX (ifindex) &&
            (lacp_state == VAL_lacpPortStatus_enabled));

        SWCTRL_SetPortOperDormantStatus(ifindex, SWCTRL_OPER_DORMANT_LV_LACP, dormant_enable, FALSE);
    }

    SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME ();

    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
} /* End of SWCTRL_SetPortLacpEnable () */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetLacpEnable
 * -------------------------------------------------------------------------
 * FUNCTION: This function will enable/disable the LACP function of whole system
 * INPUT   : lacp_state     -- VAL_lacpPortStatus_enabled/
 *                             VAL_lacpPortStatus_disabled
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : 1.802.3ad
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetLacpEnable(UI32_T lacp_state)
{
    UI32_T l_port;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if( lacp_state != VAL_lacpPortStatus_enabled  &&
        lacp_state != VAL_lacpPortStatus_disabled )
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_INVALID_PARAMETER,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "LACP state");    /*SWCTRL_ENO_INVALID_LACP_STATE*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    for (l_port = 1 ; l_port <= SYS_ADPT_TOTAL_NBR_OF_LPORT ; l_port++)
    {
        if(SWCTRL_IS_EXIST (l_port) && !SWCTRL_IS_TRUNK (l_port))
        {
            if (!SWCTRL_SetPortLacpEnable(l_port, lacp_state))
            {
                /*error message was set in SWCTRL_SetPortLacpEnable() */
                SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
            }
        }
    }

    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
} /* End of SWCTRL_SetLacpEnable () */
#endif /*(SYS_CPNT_STATIC_TRUNK_CONFIG_ALLOWED_ON_LACP_PORT == TRUE)*/

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetPortLacpAttach
 * -------------------------------------------------------------------------
 * FUNCTION: This function will set the LACP state to acttached or deattached
 * INPUT   : ifindex        -- which port to set
 *           lacp_attach    -- VAL_LacpAttach_attached/
 *                             VAL_LacpAttach_deattached
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : 1.802.3ad
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetPortLacpAttach(UI32_T ifindex, UI32_T lacp_attach)
{
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if( ifindex == 0 || ifindex > SYS_ADPT_TOTAL_NBR_OF_LPORT)
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Logical Port ID (1-%d)", SYS_ADPT_TOTAL_NBR_OF_LPORT);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_LOGICAL_PORT_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if( lacp_attach != VAL_LacpAttach_attached   &&
        lacp_attach != VAL_LacpAttach_deattached )
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_INVALID_PARAMETER,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "LACP attach state"); /*SWCTRL_ENO_INVALID_LACP_ATTACH_STATE*/
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (!SWCTRL_IS_EXIST (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Interface");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if(SWCTRL_IS_TRUNK (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_TRUNK_CNFG_ERR,
                                  SYSLOG_LEVEL_INFO|EH_MGR_FOR_DEBUG_MSG_PURPOSE,
                                  "it doesn't support LACP");  /*SWCTRL_ENO_NOT_TRUNK*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    SWCTRL_TriggerPortOperDormantEvent(ifindex, SWCTRL_OPER_DORMANT_LV_LACP, SWCTRL_OPER_DORMANT_EV_ENTER);

    SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME ();
    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
}/* End of SWCTRL_SetPortLacpAttach () */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetPortLacpCollecting
 * -------------------------------------------------------------------------
 * FUNCTION: This function will set the LACP state to collecting
 * INPUT   : ifindex            -- which port to set
 *           lacp_collecting    -- VAL_LacpCollecting_collecting/
 *                                 VAL_LacpCollecting_not_collecting
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : 1.802.3ad
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetPortLacpCollecting(UI32_T ifindex, UI32_T lacp_collecting)
{
    UI32_T pre_state;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if( ifindex == 0 || ifindex > SYS_ADPT_TOTAL_NBR_OF_LPORT)
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Logical Port ID (1-%d)", SYS_ADPT_TOTAL_NBR_OF_LPORT);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_LOGICAL_PORT_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if( lacp_collecting != VAL_LacpCollecting_collecting     &&
        lacp_collecting != VAL_LacpCollecting_not_collecting )
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_INVALID_PARAMETER,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "LACP collecting state");   /*SWCTRL_ENO_INVALID_LACP_COLLECT_STATE*/
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (!SWCTRL_IS_EXIST (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Interface");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if(SWCTRL_IS_TRUNK (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_TRUNK_CNFG_ERR,
                                  SYSLOG_LEVEL_INFO|EH_MGR_FOR_DEBUG_MSG_PURPOSE,
                                  "it doesn't support LACP");  /*SWCTRL_ENO_NOT_TRUNK*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    pre_state = port_info[ifindex-1].link_oper_status;

    /* the status of trunk member itself or normal port is handeled
     * in SWCTRL_LinkOperStateMachineChangeState() already.
     * the code here need to handle the action between trunk member
     * and trunk.
     */
    if( lacp_collecting == VAL_LacpCollecting_collecting )
    {
        SWCTRL_TriggerPortOperDormantEvent(ifindex, SWCTRL_OPER_DORMANT_LV_LACP, SWCTRL_OPER_DORMANT_EV_LEAVE);

        SWCTRL_LOCK();
        if (TRUE == SWCTRL_IS_TRUNK_MEMBER(ifindex))
        {
            UI32_T trunk_id;
            UI32_T trunk_ifindex;
            UI32_T old_trunk_oper_status;
            UI32_T new_trunk_oper_status;

            trunk_id = port_info[ifindex-1].port_entry.port_trunk_index;
            trunk_ifindex = SWCTRL_TRUNKID_TO_IFINDEX(trunk_id);

            /* If LACP notify "collecting" on static trunk member,
             * it should be a bug.
             */
            if (TRUE == trunk_ext_port_info[trunk_id-1].is_static)
            {
                SYSFUN_LogMsg("LACP try to notify SWCTRL [collecting] on static trunk member: %lu.\r\n", ifindex, 0, 0, 0, 0, 0);
                SWCTRL_UNLOCK();
                SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
            }

            SWCTRL_UNLOCK();
            SWCTRL_LinkOperStateMachineChangeState (trunk_ifindex, SWCTRL_LOWER_LAYER_CHANGED_EVENT);
        }
        else
        {
            /* normal port: do nothing except state machine.
             */
            SWCTRL_UNLOCK();
        }
    }
#if (SYS_CPNT_STATIC_TRUNK_CONFIG_ALLOWED_ON_LACP_PORT == TRUE)
    else if( user_ext_port_info[ifindex-1].lacp_oper_status != VAL_lacpPortStatus_disabled )
#else
    else if( user_ext_port_info[ifindex-1].lacp_status != VAL_lacpPortStatus_disabled )
#endif
    {
        /* when lacp is disabled, port should not receive event of "not collecting"
         */
        SWCTRL_TriggerPortOperDormantEvent(ifindex, SWCTRL_OPER_DORMANT_LV_LACP, SWCTRL_OPER_DORMANT_EV_ENTER);

        /* Base on LACP behavior, LACP should delete this user port from trunk,
         * then tell SWCTRL not collection.
         * If SWCTRL get "not collecting" on trunk member, it's should be a problem.
         */
        SWCTRL_LOCK();
        if (TRUE == SWCTRL_IS_TRUNK_MEMBER(ifindex))
        {
            SYSFUN_LogMsg("LACP try to notify SWCTRL [not collecting] on trunk member: %lu.\r\n", ifindex, 0, 0, 0, 0, 0);
            SWCTRL_UNLOCK();

            SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
        }
        else
        {
            /* normal port: do nothing except state machine.
             */
            SWCTRL_UNLOCK();
        }
    }

    SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME ();
    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
}/* End of SWCTRL_SetPortLacpCollecting () */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetPortOperDormantStatus
 * -------------------------------------------------------------------------
 * FUNCTION: To set status of ifOperStatus 'dormant'
 * INPUT   : ifindex - specified port to change status
 *           level   - see SWCTRL_OperDormantLevel_T
 *           enable  - TRUE/FALSE
 *           stealth - relevant if enable is TRUE.
 *                     TRUE to avoid oper status change from upper (e.g. up)
 *                     to this level of dormant.
 *                     FALSE to allow oper status change from upper (e.g. up)
 *                     to this level of dormant.
 * OUTPUT  : None
 * RETURN  : TRUE/FALSE
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetPortOperDormantStatus(
    UI32_T ifindex,
    SWCTRL_OperDormantLevel_T level,
    BOOL_T enable,
    BOOL_T stealth)
{
    UI32_T pre_state;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (!SWCTRL_IS_USER_PORT(ifindex) && !SWCTRL_IS_TRUNK(ifindex))
    {
        SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
    }

    if (!SWCTRL_IS_EXIST(ifindex))
    {
        SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
    }

    if (level >= SWCTRL_OPER_DORMANT_LV_MAX)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
    }

    assert(sizeof(port_info[ifindex-1].link_oper_dormant_status) * 8 >= SWCTRL_OPER_DORMANT_LV_MAX);

    SWCTRL_LOCK();

    if (enable)
    {
        port_info[ifindex-1].link_oper_dormant_status |= BIT_VALUE(level);
        port_info[ifindex-1].link_oper_dormant_active |= BIT_VALUE(level);
    }
    else
    {
        port_info[ifindex-1].link_oper_dormant_status &= ~ BIT_VALUE(level);
        port_info[ifindex-1].link_oper_dormant_active &= ~ BIT_VALUE(level);
    }

    SWCTRL_UNLOCK();

    if (!stealth)
    {
        if (enable)
        {
            SWCTRL_LinkOperStateMachineChangeState(ifindex, SWCTRL_DORMANT_ENABLE_EVENT);
        }
        else
        {
            SWCTRL_LinkOperStateMachineChangeState(ifindex, SWCTRL_DORMANT_DISABLE_EVENT);
        }
    }

    SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME ();
    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
}


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_TriggerPortOperDormantEvent
 * -------------------------------------------------------------------------
 * FUNCTION: To set status of ifOperStatus 'dormant'
 * INPUT   : ifindex - specified port to change status
 *           level   - see SWCTRL_OperDormantLevel_T
 *           event   - see SWCTRL_OperDormantEvent_T
 * OUTPUT  : None
 * RETURN  : TRUE/FALSE
 * NOTE    : None.
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_TriggerPortOperDormantEvent(
    UI32_T ifindex,
    SWCTRL_OperDormantLevel_T level,
    SWCTRL_OperDormantEvent_T event)
{
    UI32_T pre_state;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (!SWCTRL_IS_USER_PORT(ifindex) && !SWCTRL_IS_TRUNK(ifindex))
    {
        SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
    }

    if (!SWCTRL_IS_EXIST(ifindex))
    {
        SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
    }

    if (event != SWCTRL_OPER_DORMANT_EV_LEAVE &&
        event != SWCTRL_OPER_DORMANT_EV_ENTER)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
    }

    if (level >= SWCTRL_OPER_DORMANT_LV_MAX)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
    }

    assert(sizeof(port_info[ifindex-1].link_oper_dormant_status) * 8 >= SWCTRL_OPER_DORMANT_LV_MAX);

    SWCTRL_LOCK();

    if (event == SWCTRL_OPER_DORMANT_EV_ENTER)
    {
        port_info[ifindex-1].link_oper_dormant_active |= BIT_VALUE(level);
    }
    else
    {
        port_info[ifindex-1].link_oper_dormant_active &= ~ BIT_VALUE(level);
    }

    SWCTRL_UNLOCK();

    if (event == SWCTRL_OPER_DORMANT_EV_ENTER)
    {
        SWCTRL_LinkOperStateMachineChangeState(ifindex, SWCTRL_DORMANT_ENABLE_EVENT);
    }
    else
    {
        SWCTRL_LinkOperStateMachineChangeState(ifindex, SWCTRL_DORMANT_DISABLE_EVENT);
    }

    SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME ();
    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
}


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetPortOperDormantStatus
 * -------------------------------------------------------------------------
 * FUNCTION: To get status of ifOperStatus 'dormant'
 * INPUT   : ifindex - specified port to change status
 *           enable  - TRUE/FALSE
 *           level   - see SWCTRL_OperDormantLevel_T
 * OUTPUT  : None
 * RETURN  : TRUE/FALSE
 * NOTE    : None.
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_GetPortOperDormantStatus(
    UI32_T ifindex,
    SWCTRL_OperDormantLevel_T level,
    UI32_T *dormant_status_p,
    UI32_T *dormant_active_p)
{
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (!SWCTRL_IS_USER_PORT(ifindex) && !SWCTRL_IS_TRUNK(ifindex))
    {
        SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
    }

    if (!SWCTRL_IS_EXIST(ifindex))
    {
        SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
    }

    if (level >= SWCTRL_OPER_DORMANT_LV_MAX)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
    }

    assert(sizeof(port_info[ifindex-1].link_oper_dormant_status) * 8 >= SWCTRL_OPER_DORMANT_LV_MAX);

    SWCTRL_LOCK();

    *dormant_status_p = port_info[ifindex-1].link_oper_dormant_status;
    *dormant_active_p = port_info[ifindex-1].link_oper_dormant_active;

    SWCTRL_UNLOCK();

    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
}


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetUnitPortNumber
 * -------------------------------------------------------------------------
 * FUNCTION: This function will get the total number of ports in a specified
 *           unit
 * INPUT   : unit -- which unit to get
 * OUTPUT  : None
 * RETURN  : The total number of ports
 * NOTE    : None
 * -------------------------------------------------------------------------*/
UI32_T SWCTRL_GetUnitPortNumber(UI32_T unit)
{
    /* Why this API always return max. number of port capability?
     * Because caller always use this API to do for loop.
     * If module A is satcking port and module is normal port
     * then we must return max. port number and caller will not be
     * something wrong.
     */
    UI32_T max_port_number;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(0);

    if (FALSE == STKTPLG_POM_GetMaxPortCapability(unit, &max_port_number))
    {
        max_port_number = 0;
    }
    SWCTRL_RETURN_AND_RELEASE_CSC(max_port_number);
} /* End of SWCTRL_GetUnitPortNumber() */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetSystemPortNumber
 * -------------------------------------------------------------------------
 * FUNCTION: This function will get the total number of ports in the system
 * INPUT   : None
 * OUTPUT  : None
 * RETURN  : The total number of ports
 * NOTE    : None
 * -------------------------------------------------------------------------*/
UI32_T SWCTRL_GetSystemPortNumber(void)
{
    UI32_T unit;
    UI32_T num;
    UI32_T om_idx;
    UI32_T port_num;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(0);

    num = 0;
    for(unit=1; unit<=SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK; unit++)
    {
        port_num = 0;
        for( om_idx =  (unit-1)*SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT;
             om_idx <  (unit)  *SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT;
             om_idx ++)
        {
            if(SWCTRL_IS_EXIST(om_idx+1) )
            {
                port_num++;
            }
        }

        num += port_num;
    }
    SWCTRL_RETURN_AND_RELEASE_CSC( num );
} /* End of SWCTRL_GetSystemPortNumber() */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetLogicalPortNumber
 * -------------------------------------------------------------------------
 * FUNCTION: This function will get the total number of logical ports in the
 *           system
 * INPUT   : None
 * OUTPUT  : None
 * RETURN  : The total number of ports
 * NOTE    : None
 * -------------------------------------------------------------------------*/
UI32_T SWCTRL_GetLogicalPortNumber(void)
{
    UI32_T ifindex;
    UI32_T num;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(0);

    num = 0;
    for (ifindex=1; ifindex<=SYS_ADPT_TOTAL_NBR_OF_LPORT; ifindex++)
    {
        if (TRUE == SWCTRL_LogicalPortExisting(ifindex))
        {
            num++;
        }
    }
    SWCTRL_RETURN_AND_RELEASE_CSC( num );
} /* End of SWCTRL_GetLogicalPortNumber() */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_IsAnyLportOperUp
 * -------------------------------------------------------------------------
 * FUNCTION: This function will check if there is any port up in the port
 *           map
 * INPUT   : port_map -- a bit map of ports to check
 * OUTPUT  : None
 * RETURN  : TRUE: If any one up, FALSE: If none
 * NOTE    : This function will check total number of logical ports, so the
 *           map should be equal or larger than the number of logical ports.
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_IsAnyLportOperUp(UI8_T *port_map)
{
    int l_port, bit;
    UI8_T *ptr;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if(port_map == 0)
    {
        EH_MGR_Handle_Exception (SYS_MODULE_SWCTRL,
                                 SWCTRL_NO_USE_FUNC_NO,
                                 EH_TYPE_MSG_NULL_POINTER,
                                 EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_CRIT); /*SWCTRL_ENO_NULL_POINTER*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    l_port = 1;
    ptr = port_map;

    while(1)
    {
        bit = 0;
        while(bit < 8)
        {
            if((*ptr) & (0x80 >> bit))
            {
                if (SWCTRL_IS_OPER_UP (l_port))
                {
                    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
                }
            }

            l_port++;
            bit++;

            if(l_port > SYS_ADPT_TOTAL_NBR_OF_LPORT)
            {
                SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
            }
        }
        ptr++;
    }
} /* End of SWCTRL_IsAnyLportOperUp() */


#if (defined(ALLAYER_SWITCH) && (SYS_CPNT_DOT1X == TRUE))
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetPortSTAState
 * -------------------------------------------------------------------------
 * FUNCTION: This function will set STA state of a port
 * INPUT   : vid     -- which VLAN to set
 *           ifindex -- which port to set
 *           state   -- spanning tree state to set
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : This function only for Allayer chip using when include 802.1x feature.
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetPortSTAState(UI32_T vid,
                              UI32_T ifindex,
                              UI32_T state)
{
    UI32_T                      unit, port, i;
    SWCTRL_TrunkPortExtInfo_T   trunk_ext_p_info;
    BOOL_T  is_dot1x_enable;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (!SWCTRL_IS_LPORT(ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (!SWCTRL_IS_TRUNK (ifindex)) /*normal port*/
    {
        unit = SWCTRL_IFINDEX_TO_UNIT(ifindex);
        port = SWCTRL_IFINDEX_TO_PORT(ifindex);

        SWCTRL_LOCK();
        if (FALSE == SWDRV_SetPortSTAState(vid, unit, port, state))
        {
            SWCTRL_UNLOCK();
            SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
        }
        SWCTRL_UNLOCK();

        /* Aaron add the code for Noval 802.1x using, 2002-12-26 */
        is_dot1x_enable = (user_ext_port_info[ifindex-1].dot1x_status == SWCTRL_DOT1X_PORT_ENABLE   ? TRUE : FALSE);

        if (state == VAL_dot1dStpPortState_blocking)
        {
            port_info[ifindex-1].sta_state = state;
            SWCTRL_EnableFilterAllIngressPacketAndTrapSpecialPacket(ifindex);
        }
        else if (state == VAL_dot1dStpPortState_listening ||
                 state == VAL_dot1dStpPortState_learning)
        {
            port_info[ifindex-1].sta_state = state;
        }
        else /* if (state == VAL_dot1dStpPortState_forwarding ||
                    state == VAL_dot1dStpPortState_disabled)  */
        {
            UI32_T  pvid;
            UI32_T  vlan_ingress;
            VLAN_OM_Vlan_Port_Info_T    vlan_port_info;

            SWCTRL_LOCK();
            if ((retval = SWDRV_SetPortSTAState(vid, unit, port, state)) == TRUE )
            {
                port_info[ifindex-1].sta_state = state;
                memset(&vlan_port_info, 0, sizeof(VLAN_OM_Vlan_Port_Info_T));
                vlan_port_info.lport_ifindex = ifindex;
                VLAN_OM_GetVlanPortEntry(&vlan_port_info);
                pvid = vlan_port_info.port_item.dot1q_pvid_index - SYS_ADPT_VLAN_1_IF_INDEX_NUMBER + 1;
                vlan_ingress = vlan_port_info.port_item.dot1q_port_ingress_filtering;
                SWDRV_DisableFilterAllIngressPacket(unit, port, pvid, vlan_ingress);
            }
            SWCTRL_UNLOCK();
        }
    }
    else /* trunk */
    {
        SWCTRL_GetTrunkPortExtInfo (ifindex, &trunk_ext_p_info);
        SWCTRL_LOCK();
        for(i = 0; i < trunk_ext_p_info.member_number; i++)
        {
            unit = (UI32_T) trunk_ext_p_info.member_list[i].unit;
            port = (UI32_T) trunk_ext_p_info.member_list[i].port;

/*#if (SYS_ADPT_SUPPORT_SOFTWARE_TRUNK_FAILOVER == 1)*/
            if( state != VAL_dot1dStpPortState_disabled  &&
                state != VAL_dot1dStpPortState_blocking  )
            {
                if (!SWCTRL_IS_LINK_UP(SWCTRL_UPORT_TO_IFINDEX(unit, port)))
                {
                    continue;
                }
            }
/*#endif*/
            if ( (retval = SWDRV_SetPortSTAState(vid, unit, port, state)) == TRUE )
            {
                port_info[SWCTRL_UPORT_TO_IFINDEX(unit, port)-1].sta_state = state;
            }
            else
            {
                break;
            }
        } /* End of for () */

        if (retval)
            port_info[ifindex-1].sta_state = state;
        SWCTRL_UNLOCK();
    } /* End of if (trunk) */
    SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME ();
    SWCTRL_RETURN_AND_RELEASE_CSC( retval );
} /* End of SWCTRL_SetPortSTAState() */
#else
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetPortSTAState
 * -------------------------------------------------------------------------
 * FUNCTION: This function will set STA state of a port
 * INPUT   : vid     -- which VLAN to set
 *           ifindex -- which port to set
 *           state   -- spanning tree state to set
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetPortSTAState(UI32_T vid,
                              UI32_T ifindex,
                              UI32_T state)
{
    UI32_T                      unit, port, i;
    SWCTRL_TrunkPortExtInfo_T   trunk_ext_p_info;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (!SWCTRL_IS_LPORT(ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (!SWCTRL_IS_TRUNK (ifindex))
    {
        unit = SWCTRL_IFINDEX_TO_UNIT(ifindex);
        port = SWCTRL_IFINDEX_TO_PORT(ifindex);

        if (FALSE == SWDRV_SetPortSTAState(vid, unit, port, state))
        {
            SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
        }
    }
    else                            /*trunk port*/
    {
        SWCTRL_GetTrunkPortExtInfo (ifindex, &trunk_ext_p_info);

        SWCTRL_LOCK();
        for(i = 0; i < trunk_ext_p_info.member_number; i++)
        {
            unit = (UI32_T) trunk_ext_p_info.member_list[i].unit;
            port = (UI32_T) trunk_ext_p_info.member_list[i].port;

            /* Trunk fail over mechanism:
             * if a trunk member is inactive, then don't set STA state to driver
             */
            if (!SWCTRL_IS_OPER_ACTIVE_TRUNK_MEMBER(
                    SWCTRL_IFINDEX_TO_TRUNKID(ifindex),
                    SWCTRL_UPORT_TO_IFINDEX(unit, port)))
            {
                continue;
            }

            if (FALSE == SWDRV_SetPortSTAState(vid, unit, port, state))
            {
                SWCTRL_UNLOCK();
                SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
            }
        }
        SWCTRL_UNLOCK();
    } /* End of if (trunk) */

    SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME ();
    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
} /* End of SWCTRL_SetPortSTAState() */
#endif

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetPortXstpState
 * -------------------------------------------------------------------------
 * PURPOSE  : Set the Stp port state
 * INPUT    : xstid     -- multiple spanning tree instance identifier
 *            vlan_list -- UI8_T pointer for the bitmap of SYS_ADPT_MAX_VLAN_ID
 *                         bits.
 *                         Vlan bitmap for specified instance xstid:
 *                         If a bit in vlan list is 1, the corresponding VALN
 *                         is a member of this instance NO MATTER the spanning
 *                         tree is enabled or not.
 *                         Note that bit 0 of byte 0 is smallest VLAN (1).
 *                         i.e. BIT_0 of vlan_list[0] is VLAN 1.
 *            ifindex   -- ifindex of this logical port.
 *                         Only normal port and trunk port is allowed.
 *            state     -- port state 1) VAL_dot1dStpPortState_disabled
 *                                    2) VAL_dot1dStpPortState_blocking
 *                                    3) VAL_dot1dStpPortState_listening
 *                                    4) VAL_dot1dStpPortState_learning
 *                                    5) VAL_dot1dStpPortState_forwarding
 * OUTPUT   : None
 * RETURN   : TRUE/FALSE
 * NOTE     : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetPortXstpState (UI32_T xstid,
                                UI8_T *vlan_list,
                                UI32_T ifindex,
                                UI32_T state)
{
    UI32_T                       port_type;
    UI32_T                       unit;
    UI32_T                       port;
    UI32_T                       trunk_id;

    UI16_T                       vid;
    UI32_T                       vlan_count = 0;
    UI16_T                       *set_vlan_list;
    UI16_T                       *set_op_vlan_list;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    port_type = SWCTRL_LogicalPortToUserPort(ifindex, &unit, &port, &trunk_id);

    if (port_type != SWCTRL_LPORT_TRUNK_PORT  &&
        port_type != SWCTRL_LPORT_NORMAL_PORT )
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (xstid > XSTP_TYPE_MAX_MSTID ) /*0 is valid*/
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Instance ID (0-%d)", XSTP_TYPE_MAX_MSTID);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_MST_INSTANCE_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (vlan_list == 0)
    {
        EH_MGR_Handle_Exception (SYS_MODULE_SWCTRL,
                                 SWCTRL_NO_USE_FUNC_NO,
                                 EH_TYPE_MSG_NULL_POINTER,
                                 EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_CRIT); /*SWCTRL_ENO_NULL_POINTER*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (state != VAL_dot1dStpPortState_disabled   &&
        state != VAL_dot1dStpPortState_blocking   &&
        state != VAL_dot1dStpPortState_listening  &&
        state != VAL_dot1dStpPortState_learning   &&
        state != VAL_dot1dStpPortState_forwarding )
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_INVALID_PARAMETER,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "MST state");   /*SWCTRL_ENO_INVALID_MST_STATE*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    /* get VLAN count and to allocate memory
     */
    for(vid = 1; vid<=SYS_ADPT_MAX_VLAN_ID; vid++)
    {
        int byte = (vid&0xff8) >> 3;
        int bit =  (vid&0x7);

        if (vlan_list[byte] & (1<<bit) )
        {
            vlan_count++;
        }
    }

    if (vlan_count == 0)
    {
        EH_MGR_Handle_Exception (SYS_MODULE_SWCTRL,
                                 SWCTRL_NO_USE_FUNC_NO,
                                 EH_TYPE_MSG_NO_VLAN_IN_INSTANCE,
                                 EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR);   /*SWCTRL_ENO_INVALID_MST_STATE*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
    else
    {
        set_vlan_list = calloc(vlan_count, sizeof(UI16_T));

        if (NULL == set_vlan_list)
        {
            EH_MGR_Handle_Exception (SYS_MODULE_SWCTRL,
                                     SWCTRL_NO_USE_FUNC_NO,
                                     EH_TYPE_MSG_MEM_ALLOCATE,
                                     EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR);

            SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
        }
        else
        {
            set_op_vlan_list = set_vlan_list;
        }
    }

    /* prepare argument to set SWDRV
     */
    for(vid = 1; vid<=SYS_ADPT_MAX_VLAN_ID; vid++)
    {
        int byte = (vid&0xff8) >> 3;
        int bit =  (vid&0x7);

        if (vlan_list[byte] & (1<<bit) )
        {
            *set_op_vlan_list = vid;

            set_op_vlan_list++;
        }
    }

    if (port_type == SWCTRL_LPORT_NORMAL_PORT)
    {
        if (FALSE == SWDRV_SetPortXstpState(xstid, vlan_count, set_vlan_list, unit, port, state))
        {
            free(set_vlan_list);
            SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
        }
    }
    else            /*SWCTRL_LPORT_TRUNK_PORT*/
    {
        UI32_T i;
        UI32_T trk_mem_unit;
        UI32_T trk_mem_port;

        SWCTRL_LOCK();
        if(trunk_ext_port_info[SWCTRL_IFINDEX_TO_TRUNKID(ifindex)-1].member_number == 0)
        {
            SWCTRL_UNLOCK();
            free(set_vlan_list);

            EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                      SWCTRL_NO_USE_FUNC_NO,
                                      EH_TYPE_MSG_TRUNK_CNFG_ERR,
                                      SYSLOG_LEVEL_INFO,
                                      "Trunk contains no members");  /*SWCTRL_ENO_NO_MEMBER_IN_TRUNK*/

            SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
        }

        for(i=0; i<trunk_ext_port_info[SWCTRL_IFINDEX_TO_TRUNKID(ifindex)-1].member_number; i++)
        {
            trk_mem_unit = trunk_ext_port_info[SWCTRL_IFINDEX_TO_TRUNKID(ifindex)-1].member_list[i].unit;
            trk_mem_port = trunk_ext_port_info[SWCTRL_IFINDEX_TO_TRUNKID(ifindex)-1].member_list[i].port;

            /* Trunk fail over mechanism:
             * if a trunk member is inactive, then don't set STA state to driver
             */
            if (!SWCTRL_IS_OPER_ACTIVE_TRUNK_MEMBER(
                    SWCTRL_IFINDEX_TO_TRUNKID(ifindex),
                    SWCTRL_UPORT_TO_IFINDEX(trk_mem_unit, trk_mem_port)))
            {
                continue;
            }

            if (FALSE == SWDRV_SetPortXstpState(xstid, vlan_count, set_vlan_list, trk_mem_unit, trk_mem_port, state))
            {
                SWCTRL_UNLOCK();
                free(set_vlan_list);

                SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
            }
        }
        SWCTRL_UNLOCK();
    }

    free(set_vlan_list);
    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
}



#if (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_MSTP)
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetMstEnableStatus
 * -------------------------------------------------------------------------
 * FUNCTION: This function will is used to set the spanning tree protocal
 * INPUT   : mst_enable  -- SWCTRL_MST_DISABLE
 *                          SWCTRL_MST_ENABLE
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    :
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetMstEnableStatus(UI32_T mst_enable_status)
{
    UI32_T unit;
    BOOL_T retval = TRUE;
    UI32_T num_of_unit;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if(!STKTPLG_POM_GetNumberOfUnit(&num_of_unit))
    {
        /*error code was set in STKTPLG_POM_GetNumberOfUnit() */
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (mst_enable_status != SWCTRL_MST_DISABLE &&
        mst_enable_status != SWCTRL_MST_ENABLE)
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_INVALID_PARAMETER,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "MST state");   /*SWCTRL_ENO_INVALID_MST_STATE*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    for (unit=0; STKTPLG_POM_GetNextUnit(&unit) && retval; )
    {
        if (mst_enable_status == SWCTRL_MST_ENABLE) /*802.1s*/
            retval = SWDRV_EnableMultipleSTA(unit);
        else /* 802.1d */
            retval = SWDRV_DisableMultipleSTA(unit);
    }

    SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME();

    SWCTRL_RETURN_AND_RELEASE_CSC( retval );
} /* End of SWCTRL_SetMstEnableStatus() */
#endif /* end of #if (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_MSTP)*/

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetCpuMac
 * -------------------------------------------------------------------------
 * FUNCTION: This function will get the MAC address of CPU
 * INPUT   : None
 * OUTPUT  : mac -- the buffer to put MAC address
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_GetCpuMac(UI8_T *mac)
{
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if(mac == 0)
    {
        EH_MGR_Handle_Exception (SYS_MODULE_SWCTRL,
                                 SWCTRL_NO_USE_FUNC_NO,
                                 EH_TYPE_MSG_NULL_POINTER,
                                 EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_CRIT); /*SWCTRL_ENO_NULL_POINTER*/
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    SWCTRL_RETURN_AND_RELEASE_CSC( STKTPLG_POM_GetLocalUnitBaseMac(mac) );
} /* End of SWCTRL_GetCpuMac() */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetUPortMac
 * -------------------------------------------------------------------------
 * FUNCTION: This function will get the MAC address of a port
 * INPUT   : ifindex -- which port to get
 * OUTPUT  : mac     -- the buffer to put MAC address
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
static BOOL_T SWCTRL_GetUPortMac(UI32_T unit, UI32_T port, UI8_T *mac)
{
    if (!STKTPLG_POM_GetUnitBaseMac(unit, mac))
    {
        return FALSE;
    }

    SWCTRL_MacCalculation(mac, 5, port);

    return TRUE;
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetPortMac
 * -------------------------------------------------------------------------
 * FUNCTION: This function will get the MAC address of a port
 * INPUT   : ifindex -- which port to get
 * OUTPUT  : mac     -- the buffer to put MAC address
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_GetPortMac(UI32_T ifindex, UI8_T *mac)
{
    SYS_TYPE_Uport_T    unit_port;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if ( ifindex == 0 || ifindex > SYS_ADPT_TOTAL_NBR_OF_LPORT)
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Logical Port ID (1-%d)", SYS_ADPT_TOTAL_NBR_OF_LPORT);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_LOGICAL_PORT_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (!SWCTRL_IS_EXIST (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Interface");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    /* if lport is trunk port, the port mac is the mac of primary port of trunk
     */
    if(mac == 0)
    {
        EH_MGR_Handle_Exception (SYS_MODULE_SWCTRL,
                                 SWCTRL_NO_USE_FUNC_NO,
                                 EH_TYPE_MSG_NULL_POINTER,
                                 EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_CRIT); /*SWCTRL_ENO_NULL_POINTER*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (SWCTRL_IS_TRUNK (ifindex))
    {
        /* trunk port
         */
#if TRUNK_MAC_USE_PRIMARY_PORT_MAC
        if (!SWCTRL_GetTrunkPrimaryPort(ifindex, &ifindex))
        {
            SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
        }
        unit_port.unit = SWCTRL_IFINDEX_TO_UNIT(ifindex);
        unit_port.port = SWCTRL_IFINDEX_TO_PORT(ifindex);
#else
        /* get the mac of first trunk member
         */
        unit_port.unit = trunk_ext_port_info[SWCTRL_IFINDEX_TO_TRUNKID(ifindex)-1].member_list[0].unit;
        unit_port.port = trunk_ext_port_info[SWCTRL_IFINDEX_TO_TRUNKID(ifindex)-1].member_list[0].port;
        ifindex = SWCTRL_UPORT_TO_IFINDEX (unit_port.unit, unit_port.port);
#endif
    }
    else
    {
        /* normal port
         */
        unit_port.unit = SWCTRL_IFINDEX_TO_UNIT(ifindex);
        unit_port.port = SWCTRL_IFINDEX_TO_PORT(ifindex);
    }

    if (!SWCTRL_GetUPortMac(unit_port.unit, unit_port.port, mac))
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
} /* End of SWCTRL_GetPortMac() */



/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetLastChangeTime
 * -------------------------------------------------------------------------
 * FUNCTION: This function will get the last change time of whole system
 * INPUT   : None
 * OUTPUT  : None
 * RETURN  : the time of last change of any port
 * NOTE    : None
 * -------------------------------------------------------------------------*/
UI32_T SWCTRL_GetLastChangeTime()
{
    SWCTRL_USE_CSC_CHECK_OPER_MODE(0);

    SWCTRL_RETURN_AND_RELEASE_CSC( system_info.last_change_time );
} /* End of SWCTRL_GetLastChangeTime() */


/*-------------------------------------------------------------------------|
 * ROUTINE NAME - SWCTRL_UpdatePortSecurityActionTrapOperStatus
 * ------------------------------------------------------------------------|
 * FUNCTION : update the port security action trap operation status
 * INPUT    : ifindex : the logical port
 * OUTPUT   : None
 * RETURN   : TRUE/FALSE
 * NOTE     : None
 * ------------------------------------------------------------------------*/
static void SWCTRL_UpdatePortSecurityActionTrapOperStatus(UI32_T ifindex)
{
    if (port_info[ifindex-1].port_security_status == VAL_portSecPortStatus_enabled &&
        (port_info[ifindex-1].port_security_action_status == VAL_portSecAction_trap ||
         port_info[ifindex-1].port_security_action_status == VAL_portSecAction_trapAndShutdown))
    port_info[ifindex-1].port_security_action_trap_oper_status = VAL_portSecAction_trap;
    return;
} /* end of SWCTRL_UpdatePortSecurityActionTrapOperStatus */

#if 0 /* obsolete, use SWCTRL_SetPortPktTrapStatus(SWCTRL_PKTTYPE_INTRUDER) instead */
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetUPortSecurityActionStatus
 * -------------------------------------------------------------------------
 * FUNCTION: Set port security action to chip
 * INPUT   : unit: unit to set.
 *               port: port to set.
 * OUTPUT   : None.
 * RETURN  : TRUE/FALSE
 * NOTE    :
 * -------------------------------------------------------------------------*/
static BOOL_T SWCTRL_SetUPortSecurityActionStatus(UI32_T unit, UI32_T port, UI32_T action_status)
{
    UI32_T  retval = FALSE;

    switch(action_status)
    {
        case VAL_portSecAction_none:
            retval = SWDRV_PortSecurityActionNone (unit, port);
            break;
        case VAL_portSecAction_trap:
            retval = SWDRV_PortSecurityActionTrap (unit, port);
            break;
        case VAL_portSecAction_shutdown:
            retval = SWDRV_PortSecurityActionShutdown (unit, port);
            break;
        case VAL_portSecAction_trapAndShutdown:
            retval = SWDRV_PortSecurityActionTrapAndShutdown (unit, port);
            break;
    }
    return retval;
}
#endif

/*-------------------------------------------------------------------------|
 * ROUTINE NAME - SWCTRL_SetPortSecurityStatus
 * ------------------------------------------------------------------------|
 * FUNCTION : set the port security status
 * INPUT    : ifindex : the logical port
 *            port_security_status : VAL_portSecPortStatus_enabled
 *                                   VAL_portSecPortStatus_disabled
 * OUTPUT   : None
 * RETURN   : TRUE/FALSE
 * NOTE     : Port security doesn't support 1) unknown port, 2) trunk member, and
 *                                          3) trunk port
 * ------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetPortSecurityStatus( UI32_T ifindex, UI32_T  port_security_status,UI32_T port_security_called_by_who /*kevin*/)
{
    UI32_T                       type;
    UI32_T                       unit;
    UI32_T                       port;
    UI32_T                       trunk_id;
    BOOL_T                       retval = FALSE;

    UI32_T tm_num;
    SWCTRL_TrapPktOwner_T owner;
    BOOL_T to_cpu, drop;

    SYS_TYPE_Uport_T unit_ports[SYS_ADPT_MAX_NBR_OF_PORT_PER_TRUNK];
    int i;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    type = SWCTRL_LogicalPortToUserPort(ifindex, &unit, &port, &trunk_id);

    /* not support unknown port, trunk port, and trunk member
     */
    if( type == SWCTRL_LPORT_UNKNOWN_PORT      ||
        type == SWCTRL_LPORT_TRUNK_PORT_MEMBER )
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  SYSLOG_LEVEL_INFO,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

#if (SYS_CPNT_PORT_SECURITY_TRUNK != TRUE)
    if( type == SWCTRL_LPORT_TRUNK_PORT)
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_TRUNK_CNFG_ERR,
                                  SYSLOG_LEVEL_INFO,
                                  "it doesn't support Port Security.");  /*SWCTRL_ENO_NOT_TRUNK*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#endif

    /* In our design, LACP and (DOT1X || PSEC) could not be enable state at the same time
     */
     /*just normal port need to check the lacp status---DanXie*/
     if(type == SWCTRL_LPORT_NORMAL_PORT)
     {
         if (
#if (SYS_CPNT_STATIC_TRUNK_CONFIG_ALLOWED_ON_LACP_PORT == TRUE)
             user_ext_port_info[ifindex-1].lacp_admin_status == VAL_lacpPortStatus_enabled &&
#else
             user_ext_port_info[ifindex-1].lacp_status == VAL_lacpPortStatus_enabled &&
#endif
             port_security_status == VAL_portSecPortStatus_enabled                   )
         {
              EH_MGR_Handle_Exception2 (SYS_MODULE_SWCTRL,
                                        SWCTRL_NO_USE_FUNC_NO,
                                        EH_TYPE_MSG_MUTUAL_EXCLUSIVE,
                                        SYSLOG_LEVEL_INFO,
                                        "LACP", "Port Security");  /*SWCTRL_ENO_MUTEX*/
              SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
         }
    }

    if ( port_info[ifindex-1].port_security_status == port_security_status )
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
    }

    switch (port_security_called_by_who)
    {
        case SWCTRL_PORT_SECURITY_ENABLED_BY_NONE:
            owner = SWCTRL_INTRUDER_TRAP_BY_PSEC |
                    SWCTRL_INTRUDER_TRAP_BY_DOT1X |
                    SWCTRL_INTRUDER_TRAP_BY_NETACCESS;
            break;

        case SWCTRL_PORT_SECURITY_ENABLED_BY_PSEC:
            owner = SWCTRL_INTRUDER_TRAP_BY_PSEC;
            break;

        case SWCTRL_PORT_SECURITY_ENABLED_BY_DOT1X:
            owner = SWCTRL_INTRUDER_TRAP_BY_DOT1X;
            break;

        case SWCTRL_PORT_SECURITY_ENABLED_BY_NETACCESS:
            owner = SWCTRL_INTRUDER_TRAP_BY_NETACCESS;
            break;

        default:
            SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    SWCTRL_LOCK ();

    if( type == SWCTRL_LPORT_TRUNK_PORT)
    {
        if (TRK_MGR_GetTrunkPorts(trunk_id, &tm_num, unit_ports))
        {
            for(i = 0; i < tm_num; i++)
            {
                if (port_security_status == VAL_portSecPortStatus_enabled)
                {
                    drop = TRUE;
                    to_cpu = (port_info[ifindex-1].port_security_action_status != VAL_portSecAction_none);
                }
                else
                {
                    drop = FALSE;
                    to_cpu = FALSE;
                }

                retval = SWCTRL_SetPortPktTrapStatus_Local(
                    SWCTRL_UPORT_TO_IFINDEX(unit_ports[i].unit, unit_ports[i].port),
                    SWCTRL_PKTTYPE_INTRUDER,
                    owner,
                    to_cpu,
                    drop);
            }
        }
    }
    /* Normal port
     */
    else
    {
        if (port_security_status == VAL_portSecPortStatus_enabled)
        {
            to_cpu = (port_info[ifindex-1].port_security_action_status != VAL_portSecAction_none);
            drop = TRUE;
        }
        else
        {
            to_cpu = FALSE;
            drop = FALSE;
        }

        retval = SWCTRL_SetPortPktTrapStatus_Local(
            ifindex,
            SWCTRL_PKTTYPE_INTRUDER,
            owner,
            to_cpu,
            drop);
    }

    if (retval)
    {
        port_info[ifindex-1].port_security_status = port_security_status;
        if(port_security_status == VAL_portSecPortStatus_enabled)/*kevin*/
                port_info[ifindex-1].port_security_enabled_by_who = port_security_called_by_who;
        else
            port_info[ifindex-1].port_security_enabled_by_who = SWCTRL_PORT_SECURITY_ENABLED_BY_NONE;
        SWCTRL_UpdatePortSecurityActionTrapOperStatus(ifindex);
    }
    SWCTRL_UNLOCK ();

#if (SYS_CPNT_PORT_SECURITY_TRUNK_DEBUG== TRUE)
    if (!retval)
        printf("%s--%s--%d retval:%d \n",__FILE__,__FUNCTION__,__LINE__,retval);
#endif

    SWCTRL_RETURN_AND_RELEASE_CSC( retval );
} /* End of SWCTRL_SetPortSecurity () */

/*-------------------------------------------------------------------------|
 * ROUTINE NAME - SWCTRL_SetPortSecurityActionStatus
 * ------------------------------------------------------------------------|
 * FUNCTION : set the port security action status
 * INPUT    : ifindex : the logical port
 *            action_status: VAL_portSecAction_none(1)
 *                           VAL_portSecAction_trap(2)
 *                           VAL_portSecAction_shutdown(3)
 *                           VAL_portSecAction_trapAndShutdown(4)
 * OUTPUT   : None
 * RETURN   : TRUE/FALSE
 * NOTE     : Port security doesn't support 1) unknown port, 2) trunk member, and
 *                                          3) trunk port
 * ------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetPortSecurityActionStatus( UI32_T ifindex, UI32_T  action_status)
{
    UI32_T                          type;
    UI32_T                          unit;
    UI32_T                          port;
    UI32_T                          trunk_id;
    BOOL_T                          retval = TRUE;
    UI32_T tm_num;
    SWCTRL_TrapPktOwner_T owner;
    BOOL_T to_cpu, drop;

    SYS_TYPE_Uport_T unit_ports[SYS_ADPT_MAX_NBR_OF_PORT_PER_TRUNK];
    int i;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    type = SWCTRL_LogicalPortToUserPort(ifindex, &unit, &port, &trunk_id);

    /* not support unknown port, trunk port, and trunk member
     */
    if( type == SWCTRL_LPORT_UNKNOWN_PORT      ||
        type == SWCTRL_LPORT_TRUNK_PORT_MEMBER )
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  SYSLOG_LEVEL_INFO,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#if (SYS_CPNT_PORT_SECURITY_TRUNK != TRUE)
    if( type == SWCTRL_LPORT_TRUNK_PORT)
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_TRUNK_CNFG_ERR,
                                  SYSLOG_LEVEL_INFO,
                                  "it doesn't support Port Security.");  /*SWCTRL_ENO_NOT_TRUNK*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#endif

    if ( port_info[ifindex-1].port_security_action_status == action_status )
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
    }

    switch (port_info[ifindex-1].port_security_enabled_by_who)
    {
        case SWCTRL_PORT_SECURITY_ENABLED_BY_NONE:
            owner = SWCTRL_INTRUDER_TRAP_BY_PSEC |
                    SWCTRL_INTRUDER_TRAP_BY_DOT1X |
                    SWCTRL_INTRUDER_TRAP_BY_NETACCESS;
            break;

        case SWCTRL_PORT_SECURITY_ENABLED_BY_PSEC:
            owner = SWCTRL_INTRUDER_TRAP_BY_PSEC;
            break;

        case SWCTRL_PORT_SECURITY_ENABLED_BY_DOT1X:
            owner = SWCTRL_INTRUDER_TRAP_BY_DOT1X;
            break;

        case SWCTRL_PORT_SECURITY_ENABLED_BY_NETACCESS:
            owner = SWCTRL_INTRUDER_TRAP_BY_NETACCESS;
            break;

        default:
            SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    SWCTRL_LOCK ();

    if( type == SWCTRL_LPORT_TRUNK_PORT)
    {
        if (TRK_MGR_GetTrunkPorts(trunk_id, &tm_num, unit_ports))
        {
            for(i = 0; i < tm_num; i++)
            {
                to_cpu = (action_status != VAL_portSecAction_none);
                drop = TRUE;

                if (port_info[ifindex-1].port_security_status == VAL_portSecPortStatus_enabled)
                {
                    retval = SWCTRL_SetPortPktTrapStatus_Local(
                        SWCTRL_UPORT_TO_IFINDEX(unit_ports[i].unit, unit_ports[i].port),
                        SWCTRL_PKTTYPE_INTRUDER,
                        owner,
                        to_cpu,
                        drop);
                }
            }
        }
    }
    else
    /* Normal port
     */
    {
        to_cpu = (action_status != VAL_portSecAction_none);
        drop = TRUE;

        if (port_info[ifindex-1].port_security_status == VAL_portSecPortStatus_enabled)
        {
            retval = SWCTRL_SetPortPktTrapStatus_Local(
                ifindex,
                SWCTRL_PKTTYPE_INTRUDER,
                owner,
                to_cpu,
                drop);
        }
    }

    if (retval)
    {
        port_info[ifindex-1].port_security_action_status = action_status;
        SWCTRL_UpdatePortSecurityActionTrapOperStatus(ifindex);
    }
    SWCTRL_UNLOCK ();

    SWCTRL_RETURN_AND_RELEASE_CSC( retval );
} /* End of SWCTRL_SetPortSecurityActionStatus () */


/*-------------------------------------------------------------------------|
 * ROUTINE NAME - SWCTRL_SetPortSecurityActionTrapOperStatus
 * ------------------------------------------------------------------------|
 * FUNCTION : set the port security action trap operation status
 * INPUT    : ifindex : the logical port
 *            action_trap_status : VAL_portSecActionTrap_enabled
 *                                 VAL_portSecActionTrap_disabled
 * OUTPUT   : None
 * RETURN   : TRUE/FALSE
 * NOTE     : Port security doesn't support 1) unknown port, 2) trunk member, and
 *                                          3) trunk port
 * ------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetPortSecurityActionTrapOperStatus( UI32_T ifindex, UI32_T  action_trap_oper_status)
{
    UI32_T                          type;
    UI32_T                          unit;
    UI32_T                          port;
    UI32_T                          trunk_id;
    UI32_T tm_num;
    SWCTRL_TrapPktOwner_T owner;
    BOOL_T to_cpu, drop;

    SYS_TYPE_Uport_T unit_ports[SYS_ADPT_MAX_NBR_OF_PORT_PER_TRUNK];
    int i;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    type = SWCTRL_LogicalPortToUserPort(ifindex, &unit, &port, &trunk_id);

    /* not support unknown port, trunk port, and trunk member
     */
    if( type == SWCTRL_LPORT_UNKNOWN_PORT      ||
        type == SWCTRL_LPORT_TRUNK_PORT_MEMBER )
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  SYSLOG_LEVEL_INFO,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#if (SYS_CPNT_PORT_SECURITY_TRUNK != TRUE)
    if( type == SWCTRL_LPORT_TRUNK_PORT)
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_TRUNK_CNFG_ERR,
                                  SYSLOG_LEVEL_INFO,
                                  "it doesn't support Port Security.");  /*SWCTRL_ENO_NOT_TRUNK*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#endif
    if ( port_info[ifindex-1].port_security_action_trap_oper_status == action_trap_oper_status )
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
    }

    switch (port_info[ifindex-1].port_security_enabled_by_who)
    {
        case SWCTRL_PORT_SECURITY_ENABLED_BY_NONE:
            owner = SWCTRL_INTRUDER_TRAP_BY_PSEC |
                    SWCTRL_INTRUDER_TRAP_BY_DOT1X |
                    SWCTRL_INTRUDER_TRAP_BY_NETACCESS;
            break;

        case SWCTRL_PORT_SECURITY_ENABLED_BY_PSEC:
            owner = SWCTRL_INTRUDER_TRAP_BY_PSEC;
            break;

        case SWCTRL_PORT_SECURITY_ENABLED_BY_DOT1X:
            owner = SWCTRL_INTRUDER_TRAP_BY_DOT1X;
            break;

        case SWCTRL_PORT_SECURITY_ENABLED_BY_NETACCESS:
            owner = SWCTRL_INTRUDER_TRAP_BY_NETACCESS;
            break;

        default:
            SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    /* Normal port
     */
    SWCTRL_LOCK ();
    port_info[ifindex-1].port_security_action_trap_oper_status = action_trap_oper_status;
    SWCTRL_UNLOCK ();

    /* arthur 11/12/2002 02:53pm, Disable CPU learning
     */
    if (port_info[ifindex-1].port_security_action_status == VAL_portSecAction_trap)
    {
        if( type == SWCTRL_LPORT_TRUNK_PORT)
        {
            if (TRK_MGR_GetTrunkPorts(trunk_id, &tm_num, unit_ports))
            {
                for(i = 0; i < tm_num; i++)
                {
                    if (action_trap_oper_status == VAL_portSecAction_none)
                    {
                        to_cpu = FALSE;
                    }
                    else /*VAL_portSecAction_trap*/
                    {
                        to_cpu = (port_info[ifindex-1].port_security_action_status != VAL_portSecAction_none);
                    }
                    drop = TRUE;

                    if (port_info[ifindex-1].port_security_status == VAL_portSecPortStatus_enabled)
                    {
                        SWCTRL_SetPortPktTrapStatus_Local(
                            SWCTRL_UPORT_TO_IFINDEX(unit_ports[i].unit, unit_ports[i].port),
                            SWCTRL_PKTTYPE_INTRUDER,
                            owner,
                            to_cpu,
                            drop);
                    }
                }
            }
        }
        else
        /* Normal port
         */
        {
            if (action_trap_oper_status == VAL_portSecAction_none)
            {
                to_cpu = FALSE;
            }
            else /*VAL_portSecAction_trap*/
            {
                to_cpu = (port_info[ifindex-1].port_security_action_status != VAL_portSecAction_none);
            }
            drop = TRUE;

            if (port_info[ifindex-1].port_security_status == VAL_portSecPortStatus_enabled)
            {
                SWCTRL_SetPortPktTrapStatus_Local(
                    ifindex,
                    SWCTRL_PKTTYPE_INTRUDER,
                    owner,
                    to_cpu,
                    drop);
            }
        }
    }
    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );

} /* End of SWCTRL_SetPortSecurityActionTrapOperStatus () */

/*-------------------------------------------------------------------------|
 * ROUTINE NAME - SWCTRL_IsSecurityPort
 * ------------------------------------------------------------------------|
 * FUNCTION : check the port is in security
 * INPUT    : ifindex : the port
 * OUTPUT   : port_security_enabled_by_who ---  SWCTRL_PORT_SECURITY_ENABLED_BY_NONE
 *                                  SWCTRL_PORT_SECURITY_ENABLED_BY_PSEC
 *                                  SWCTRL_PORT_SECURITY_ENABLED_BY_DOT1X
 * RETURN   : TRUE/FALSE
 * NOTE     : Port security doesn't support 1) unknown port, 2) trunk member, and
 *                                          3) trunk port
 * ------------------------------------------------------------------------*/
BOOL_T SWCTRL_IsSecurityPort( UI32_T ifindex,UI32_T *port_security_enabled_by_who/*kevin*/)
{
    UI32_T                          type;
    UI32_T                          unit;
    UI32_T                          port;
    UI32_T                          trunk_id;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    type = SWCTRL_LogicalPortToUserPort(ifindex, &unit, &port, &trunk_id);

    /* not support unknown port, trunk port, and trunk member
     */
    if( type == SWCTRL_LPORT_UNKNOWN_PORT      ||
        type == SWCTRL_LPORT_TRUNK_PORT_MEMBER )
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  SYSLOG_LEVEL_INFO,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

#if (SYS_CPNT_PORT_SECURITY_TRUNK == FALSE)
    /* allow trunk port to be config */

    if( type == SWCTRL_LPORT_TRUNK_PORT)
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_TRUNK_CNFG_ERR,
                                  SYSLOG_LEVEL_INFO,
                                  "it doesn't support Port Security.");  /*SWCTRL_ENO_NOT_TRUNK*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#endif

    if (port_info[ifindex-1].port_security_status == VAL_portSecPortStatus_enabled)
    {
        *port_security_enabled_by_who = port_info[ifindex-1].port_security_enabled_by_who;/*kevin*/
        SWCTRL_RETURN_AND_RELEASE_CSC(TRUE );
    }

    SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );





}

/*-------------------------------------------------------------------------|
 * ROUTINE NAME - SWCTRL_GetSecurityActionTrapPort
 * ------------------------------------------------------------------------|
 * FUNCTION : check the port is security action trap enable or disable
 * INPUT    : ifindex : the port
 * OUTPUT   : *action_status: output status
 * RETURN   : TRUE/FALSE
 * NOTE     : Port security doesn't support 1) unknown port, 2) trunk member, and
 *                                          3) trunk port
 * ------------------------------------------------------------------------*/
BOOL_T SWCTRL_GetSecurityActionStatus( UI32_T ifindex, UI32_T *action_status)
{
    UI32_T                          type;
    UI32_T                          unit;
    UI32_T                          port;
    UI32_T                          trunk_id;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    type = SWCTRL_LogicalPortToUserPort(ifindex, &unit, &port, &trunk_id);

    /* not support unknown port, trunk port, and trunk member
     */
    if( type == SWCTRL_LPORT_UNKNOWN_PORT      ||
        type == SWCTRL_LPORT_TRUNK_PORT_MEMBER )
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  SYSLOG_LEVEL_INFO,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#if (SYS_CPNT_PORT_SECURITY_TRUNK != TRUE)
    if( type == SWCTRL_LPORT_TRUNK_PORT)
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_TRUNK_CNFG_ERR,
                                  SYSLOG_LEVEL_INFO,
                                  "it doesn't support Port Security.");  /*SWCTRL_ENO_NOT_TRUNK*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#endif
    if (port_info[ifindex-1].port_security_action_status < VAL_portSecAction_none ||
        port_info[ifindex-1].port_security_action_status > VAL_portSecAction_trapAndShutdown)
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_INVALID_PARAMETER,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "port security state");   /*SWCTRL_ENO_INVALID_PORT_SECURITY_STATE*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    *action_status = port_info[ifindex-1].port_security_action_status;
    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
}

/*-------------------------------------------------------------------------|
 * ROUTINE NAME - SWCTRL_IsSecurityOperActionTrapPort
 * ------------------------------------------------------------------------|
 * FUNCTION : check the port is security operation action trap enable or disable
 * INPUT    : ifindex : the port
 * OUTPUT   : None
 * RETURN   : TRUE/FALSE
 * NOTE     : Port security doesn't support 1) unknown port, 2) trunk member, and
 *                                          3) trunk port
 * ------------------------------------------------------------------------*/
BOOL_T SWCTRL_IsSecurityOperActionTrapPort( UI32_T ifindex)
{
    UI32_T                          type;
    UI32_T                          unit;
    UI32_T                          port;
    UI32_T                          trunk_id;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    type = SWCTRL_LogicalPortToUserPort(ifindex, &unit, &port, &trunk_id);

    /* not support unknown port, trunk port, and trunk member
     */
    if( type == SWCTRL_LPORT_UNKNOWN_PORT      ||
        type == SWCTRL_LPORT_TRUNK_PORT_MEMBER )
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  SYSLOG_LEVEL_INFO,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#if (SYS_CPNT_PORT_SECURITY_TRUNK != TRUE)
    if( type == SWCTRL_LPORT_TRUNK_PORT)
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_TRUNK_CNFG_ERR,
                                  SYSLOG_LEVEL_INFO,
                                  "it doesn't support Port Security.");  /*SWCTRL_ENO_NOT_TRUNK*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#endif
    if (port_info[ifindex-1].port_security_action_trap_oper_status == VAL_portSecAction_trap)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
    }

    SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
}

/*-------------------------------------------------------------------------|
 * ROUTINE NAME - SWCTRL_IsSecurityActionTrapTimerExpiry
 * ------------------------------------------------------------------------|
 * FUNCTION : check the port is security action trap timer expiry or not?
 * INPUT    : ifindex : interface index.
 *            time_expiry_ticks : timer expiry ticks value.
 * OUTPUT   : None
 * RETURN   : TRUE/FALSE
 * NOTE     : Port security doesn't support 1) unknown port, 2) trunk member, and
 *                                          3) trunk port
 * ------------------------------------------------------------------------*/
BOOL_T SWCTRL_IsSecurityActionTrapTimerExpiry( UI32_T ifindex, UI32_T time_expiry_ticks)
{
    UI32_T                          type;
    UI32_T                          unit;
    UI32_T                          port;
    UI32_T                          trunk_id;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    type = SWCTRL_LogicalPortToUserPort(ifindex, &unit, &port, &trunk_id);

    /* not support unknown port, trunk port, and trunk member
     */
    if( type == SWCTRL_LPORT_UNKNOWN_PORT      ||
        type == SWCTRL_LPORT_TRUNK_PORT_MEMBER )
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  SYSLOG_LEVEL_INFO,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#if (SYS_CPNT_PORT_SECURITY_TRUNK != TRUE)
    if( type == SWCTRL_LPORT_TRUNK_PORT)
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_TRUNK_CNFG_ERR,
                                  SYSLOG_LEVEL_INFO,
                                  "it doesn't support Port Security.");  /*SWCTRL_ENO_NOT_TRUNK*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#endif
    if (port_info[ifindex-1].port_security_action_trap_time_stamp >= time_expiry_ticks)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
    }

    SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
}

/*-------------------------------------------------------------------------|
 * ROUTINE NAME - SWCTRL_AddSecurityActionTrapTimeStamp
 * ------------------------------------------------------------------------|
 * FUNCTION : increase the timer stamp to the timer of this port?
 * INPUT    : ifindex : interface index.
 *            increase_time_stamp_ticks : increase ticks of the timer stamp.
 * OUTPUT   : None
 * RETURN   : TRUE/FALSE
 * NOTE     : Port security doesn't support 1) unknown port, 2) trunk member, and
 *                                          3) trunk port
 * ------------------------------------------------------------------------*/
BOOL_T SWCTRL_AddSecurityActionTrapTimeStamp( UI32_T ifindex, UI32_T increase_time_stamp_ticks)
{
    UI32_T                          type;
    UI32_T                          unit;
    UI32_T                          port;
    UI32_T                          trunk_id;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    type = SWCTRL_LogicalPortToUserPort(ifindex, &unit, &port, &trunk_id);

    /* not support unknown port, trunk port, and trunk member
     */
    if( type == SWCTRL_LPORT_UNKNOWN_PORT      ||
        type == SWCTRL_LPORT_TRUNK_PORT_MEMBER )
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  SYSLOG_LEVEL_INFO,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#if (SYS_CPNT_PORT_SECURITY_TRUNK != TRUE)
    if( type == SWCTRL_LPORT_TRUNK_PORT)
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_TRUNK_CNFG_ERR,
                                  SYSLOG_LEVEL_INFO,
                                  "it doesn't support Port Security.");  /*SWCTRL_ENO_NOT_TRUNK*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#endif
    port_info[ifindex-1].port_security_action_trap_time_stamp += increase_time_stamp_ticks;
    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
}


/*-------------------------------------------------------------------------|
 * ROUTINE NAME - SWCTRL_ResetSecurityActionTrapTimeStamp
 * ------------------------------------------------------------------------|
 * FUNCTION : reset the timer stamp to the timer of this port?
 * INPUT    : ifindex : interface index.
 * OUTPUT   : None
 * RETURN   : TRUE/FALSE
 * NOTE     : Port security doesn't support 1) unknown port, 2) trunk member, and
 *                                          3) trunk port
 * ------------------------------------------------------------------------*/
BOOL_T SWCTRL_ResetSecurityActionTrapTimeStamp( UI32_T ifindex)
{
    UI32_T                          type;
    UI32_T                          unit;
    UI32_T                          port;
    UI32_T                          trunk_id;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    type = SWCTRL_LogicalPortToUserPort(ifindex, &unit, &port, &trunk_id);

    /* not support unknown port, trunk port, and trunk member
     */
    if( type == SWCTRL_LPORT_UNKNOWN_PORT      ||
        type == SWCTRL_LPORT_TRUNK_PORT_MEMBER )
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  SYSLOG_LEVEL_INFO,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#if (SYS_CPNT_PORT_SECURITY_TRUNK != TRUE)
    if( type == SWCTRL_LPORT_TRUNK_PORT)
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_TRUNK_CNFG_ERR,
                                  SYSLOG_LEVEL_INFO,
                                  "it doesn't support Port Security.");  /*SWCTRL_ENO_NOT_TRUNK*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#endif
    port_info[ifindex-1].port_security_action_trap_time_stamp = 0;
    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
}


#if (defined(ALLAYER_SWITCH) && (SYS_CPNT_DOT1X == TRUE))
/*-------------------------------------------------------------------------|
 * ROUTINE NAME - SWCTRL_EnableFilterAllIngressPacketAndTrapSpecialPacket
 * ------------------------------------------------------------------------|
 * FUNCTION : enable filter all ingress packet and trap 802.1x to CPU
 *            when enter SWCTRL_PORT_DORMANT_STATUS_TYPE_DOT1X state.
 * INPUT    : ifindex : interface index.
 * OUTPUT   : None
 * RETURN   : TRUE/FALSE
 * NOTE     :
 * ------------------------------------------------------------------------*/
static BOOL_T SWCTRL_EnableFilterAllIngressPacketAndTrapSpecialPacket(UI32_T ifindex)
{
    UI32_T  unit, port, pvid;
    VLAN_OM_Vlan_Port_Info_T    vlan_port_info;

    if (SWCTRL_IS_TRUNK (ifindex))
    {
        return FALSE;
    }

    unit = SWCTRL_IFINDEX_TO_UNIT(ifindex);
    port = SWCTRL_IFINDEX_TO_PORT(ifindex);
    memset(&vlan_port_info, 0, sizeof(VLAN_OM_Vlan_Port_Info_T));
    vlan_port_info.lport_ifindex = ifindex;
    VLAN_OM_GetVlanPortEntry(&vlan_port_info);
    pvid = vlan_port_info.port_item.dot1q_pvid_index - SYS_ADPT_VLAN_1_IF_INDEX_NUMBER + 1;
    SWDRV_EnableFilterAllIngressPacketAndTrapSpecialPacket(unit, port, pvid);

    return TRUE;
}
#endif

/****************************************************************************/
/* VLAN                                                                     */
/****************************************************************************/
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetPortPVID
 * -------------------------------------------------------------------------
 * FUNCTION: This function will set default VLAN ID of a port
 * INPUT   : ifindex -- which port to set
 *           pvid    -- permanent VID to set
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetPortPVID(UI32_T ifindex, UI32_T pvid,BOOL_T port_check)
{
    UI32_T                          unit, port, i;
    BOOL_T                          retval = FALSE;
    SWCTRL_TrunkPortExtInfo_T    trunk_ext_p_info;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (port_check && !SWCTRL_IS_LPORT(ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    SWCTRL_LOCK();
    if (!SWCTRL_IS_TRUNK (ifindex))
    {
        unit = SWCTRL_IFINDEX_TO_UNIT(ifindex);
        port = SWCTRL_IFINDEX_TO_PORT(ifindex);

        retval = SWDRV_SetPortPVID(unit, port, pvid);
    }
    else /* trunk */
    {
        SWCTRL_GetTrunkPortExtInfo (ifindex, &trunk_ext_p_info);

        for(i = 0; i < trunk_ext_p_info.member_number; i++)
        {
            unit = (UI32_T) trunk_ext_p_info.member_list[i].unit;
            port = (UI32_T) trunk_ext_p_info.member_list[i].port;
            if (!(retval = SWDRV_SetPortPVID(unit, port, pvid)))
                break;
        } /* End of for () */
    } /* End of if (trunk) */
    SWCTRL_UNLOCK();

    SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME ();
    SWCTRL_RETURN_AND_RELEASE_CSC( retval );
} /* End of SWCTRL_SetPortPVID() */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_CreateVlan
 * -------------------------------------------------------------------------
 * FUNCTION: This function will create a specified VLAN
 * INPUT   : vid -- which VLAN to create
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not availabl
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_CreateVlan(UI32_T vid)
{
    BOOL_T retval, learning;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if( vid == 0 || vid >  SYS_ADPT_MAX_VLAN_ID )
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "VLAN ID (1-%d)", SYS_ADPT_MAX_VLAN_ID);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_VLAN_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    SWCTRL_LOCK();
    retval = SWDRV_CreateVlan(vid);
#if (SYS_CPNT_AMTR_VLAN_MAC_LEARNING == TRUE)
    AMTR_OM_GetVlanLearningStatus(vid, &learning);
    retval &= SWDRV_SetVlanLearningStatus(vid, learning);
#endif
    SWCTRL_UNLOCK();
    SWCTRL_RETURN_AND_RELEASE_CSC( retval );
} /* End of SWCTRL_CreateVlan() */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_DestroyVlan
 * -------------------------------------------------------------------------
 * FUNCTION: This function will delete a specified VLAN
 * INPUT   : vid -- which VLAN to delete
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not availabl
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_DestroyVlan(UI32_T vid)
{
    BOOL_T retval;
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if( vid == 0 || vid >  SYS_ADPT_MAX_VLAN_ID )
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "VLAN ID (1-%d)", SYS_ADPT_MAX_VLAN_ID);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_TRUNK_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    SWCTRL_LOCK();
    retval = SWDRV_DestroyVlan(vid);

    SWCTRL_UNLOCK();
    SWCTRL_RETURN_AND_RELEASE_CSC( retval );
} /* End of SWCTRL_DestroyVlan() */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetGlobalDefaultVlan
 * -------------------------------------------------------------------------
 * FUNCTION: This function changes the global default VLAN
 * INPUT   : vid                -- the vid of the new default VLAN
 * OUTPUT  : None
 * RETURN  : TRUE               -- Success
 *           FALSE              -- If the specified VLAN is not available.
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetGlobalDefaultVlan(UI32_T vid)
{
    BOOL_T retval;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if( vid == 0 || vid >  SYS_ADPT_MAX_VLAN_ID )
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "VLAN ID (1-%d)", SYS_ADPT_MAX_VLAN_ID);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_TRUNK_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    SWCTRL_LOCK();
    retval = SWDRV_SetGlobalDefaultVlan(vid);
    SWCTRL_UNLOCK();
    SWCTRL_RETURN_AND_RELEASE_CSC( retval );
} /* End of SWCTRL_SetGlobalDefaultVlan() */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_AddPortToVlanMemberSet
 * -------------------------------------------------------------------------
 * FUNCTION: This function will add a port to the member set of a specified
 *           VLAN
 * INPUT   : ifindex -- which port to add
 *           vid     -- which VLAN ID
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_AddPortToVlanMemberSet(UI32_T ifindex, UI32_T vid,BOOL_T port_check)
{
    UI32_T                          unit, port, i;
    BOOL_T                          retval = FALSE;
    SWCTRL_TrunkPortExtInfo_T    trunk_ext_p_info;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (port_check && !SWCTRL_IS_LPORT(ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if( vid == 0 || vid >  SYS_ADPT_MAX_VLAN_ID )
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "VLAN ID (1-%d)", SYS_ADPT_MAX_VLAN_ID);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_TRUNK_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    SWCTRL_LOCK();
    if (!SWCTRL_IS_TRUNK (ifindex))
    {
        unit = SWCTRL_IFINDEX_TO_UNIT(ifindex);
        port = SWCTRL_IFINDEX_TO_PORT(ifindex);

        retval = SWDRV_AddPortToVlanMemberSet(unit, port, vid);
    }
    else /* trunk */
    {
        SWCTRL_GetTrunkPortExtInfo (ifindex, &trunk_ext_p_info);

        for(i = 0; i < trunk_ext_p_info.member_number; i++)
        {
            unit = (UI32_T) trunk_ext_p_info.member_list[i].unit;
            port = (UI32_T) trunk_ext_p_info.member_list[i].port;
            if (!(retval = SWDRV_AddPortToVlanMemberSet(unit, port, vid)))
                break;
        } /* End of for () */
    } /* End of if (trunk) */
    SWCTRL_UNLOCK();
    SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME ();
    SWCTRL_RETURN_AND_RELEASE_CSC( retval );
} /* End of SWCTRL_AddPortToVlanMemberSet() */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_AddTrunkMemberPortToVlanMemberSet
 * -------------------------------------------------------------------------
 * FUNCTION: This function will add a port to the member set of a specified
 *           VLAN
 * INPUT   : ifindex -- which port to add
 *           vid     -- which VLAN ID
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : This function is used only for vlan to add the trunk member from vlan
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_AddTrunkMemberPortToVlanMemberSet(UI32_T trunk_mem_ifindex, UI32_T vid)
{
    UI32_T                          unit, port;
    BOOL_T                          retval = FALSE;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if( vid == 0 || vid >  SYS_ADPT_MAX_VLAN_ID )
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "VLAN ID (1-%d)", SYS_ADPT_MAX_VLAN_ID);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_TRUNK_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    unit = SWCTRL_IFINDEX_TO_UNIT(trunk_mem_ifindex);
    port = SWCTRL_IFINDEX_TO_PORT(trunk_mem_ifindex);

    SWCTRL_LOCK();
    retval = SWDRV_AddPortToVlanMemberSet(unit, port, vid);
    SWCTRL_UNLOCK();
    SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME ();
    SWCTRL_RETURN_AND_RELEASE_CSC( retval );
} /* End of SWCTRL_AddTrunkMemberPortToVlanMemberSet() */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_DeletePortFromVlanMemberSet
 * -------------------------------------------------------------------------
 * FUNCTION: This function will delete a port from the member set of a
 *           specified VLAN
 * INPUT   : ifindex -- which port to delete
 *           vid     -- which VLAN ID
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_DeletePortFromVlanMemberSet(UI32_T ifindex, UI32_T vid,BOOL_T port_check)
{
    UI32_T                          unit, port, i;
    BOOL_T                          retval = FALSE;
    SWCTRL_TrunkPortExtInfo_T    trunk_ext_p_info;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (port_check && !SWCTRL_IS_LPORT(ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if( vid == 0 || vid >  SYS_ADPT_MAX_VLAN_ID )
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "VLAN ID (1-%d)", SYS_ADPT_MAX_VLAN_ID);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_TRUNK_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    SWCTRL_LOCK();
    if (!SWCTRL_IS_TRUNK (ifindex))
    {
        unit = SWCTRL_IFINDEX_TO_UNIT(ifindex);
        port = SWCTRL_IFINDEX_TO_PORT(ifindex);

        retval = SWDRV_DeletePortFromVlanMemberSet(unit, port, vid);
    }
    else /* trunk */
    {
        SWCTRL_GetTrunkPortExtInfo (ifindex, &trunk_ext_p_info);

        for(i = 0; i < trunk_ext_p_info.member_number; i++)
        {
            unit = (UI32_T) trunk_ext_p_info.member_list[i].unit;
            port = (UI32_T) trunk_ext_p_info.member_list[i].port;
            if (!(retval = SWDRV_DeletePortFromVlanMemberSet(unit, port, vid)))
                break;
        } /* End of for () */
    } /* End of if (trunk) */
    SWCTRL_UNLOCK();
    SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME ();
    SWCTRL_RETURN_AND_RELEASE_CSC( retval );
} /* End of SWCTRL_DeletePortFromVlanMemberSet() */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_DeleteTrunkMemberPortFromVlanMemberSet
 * -------------------------------------------------------------------------
 * FUNCTION: This function will delete a trunk member port from the member set of a
 *           specified VLAN
 * INPUT   : ifindex -- which port to delete
 *           vid     -- which VLAN ID
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : This function is used only for vlan to remove the trunk member from vlan
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_DeleteTrunkMemberPortFromVlanMemberSet(UI32_T trunk_mem_ifindex, UI32_T vid)
{
    UI32_T                          unit, port;
    BOOL_T                          retval = FALSE;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if( vid == 0 || vid >  SYS_ADPT_MAX_VLAN_ID )
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "VLAN ID (1-%d)", SYS_ADPT_MAX_VLAN_ID);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_TRUNK_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    unit = SWCTRL_IFINDEX_TO_UNIT(trunk_mem_ifindex);
    port = SWCTRL_IFINDEX_TO_PORT(trunk_mem_ifindex);

    SWCTRL_LOCK();
    retval=SWDRV_DeletePortFromVlanMemberSet(unit, port, vid);
    SWCTRL_UNLOCK();
    SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME ();
    SWCTRL_RETURN_AND_RELEASE_CSC( retval );
} /* End of SWCTRL_DeleteTrunkMemberPortFromVlanMemberSet() */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_AddPortToVlanUntaggedSet
 * -------------------------------------------------------------------------
 * FUNCTION: This function will set a port to output untagged frames over
 *           the specified VLAN
 * INPUT   : ifindex -- which port to add
 *           vid     -- which VLAN ID
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_AddPortToVlanUntaggedSet(UI32_T ifindex, UI32_T vid,BOOL_T is_check)
{
    UI32_T                          unit, port, i;
    BOOL_T                          retval = FALSE;
    SWCTRL_TrunkPortExtInfo_T    trunk_ext_p_info;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (is_check && !SWCTRL_IS_LPORT(ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if( vid == 0 || vid >  SYS_ADPT_MAX_VLAN_ID )
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "VLAN ID (1-%d)", SYS_ADPT_MAX_VLAN_ID);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_TRUNK_ID*/

#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    SWCTRL_LOCK();
    if (!SWCTRL_IS_TRUNK (ifindex))
    {
        unit = SWCTRL_IFINDEX_TO_UNIT(ifindex);
        port = SWCTRL_IFINDEX_TO_PORT(ifindex);

        retval = SWDRV_AddPortToVlanUntaggedSet(unit, port, vid);
    }
    else /* trunk */
    {
        SWCTRL_GetTrunkPortExtInfo (ifindex, &trunk_ext_p_info);

        for(i = 0; i < trunk_ext_p_info.member_number; i++)
        {
            unit = (UI32_T) trunk_ext_p_info.member_list[i].unit;
            port = (UI32_T) trunk_ext_p_info.member_list[i].port;
            if (!(retval = SWDRV_AddPortToVlanUntaggedSet(unit, port, vid)))
                break;
        } /* End of for () */
    } /* End of if (trunk) */
    SWCTRL_UNLOCK();
    SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME ();
    SWCTRL_RETURN_AND_RELEASE_CSC( retval );
} /* End of SWCTRL_AddPortToVlanUntaggedSet() */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_AddTrunkMembersPortToVlanUntaggedSet
 * -------------------------------------------------------------------------
 * FUNCTION: This function will set a port to output untagged frames over
 *           the specified VLAN
 * INPUT   : ifindex -- which port to add
 *           vid     -- which VLAN ID
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : This function is used only for vlan to add the trunk member from vlan
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_AddTrunkMembersPortToVlanUntaggedSet(UI32_T trunk_mem_ifindex, UI32_T vid)
{
    UI32_T                          unit, port;
    BOOL_T                          retval = FALSE;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);
    /*EPR: ES3628BT-FLF-ZZ-00772
    Problem:RIP: LACP member add/remove will cause L3 packets lost.
    Rootcause:when sync trunk info to trunk member,it will fail.
              (1)because the port added to trunk ,it will set trunk member info in port_info.
              (2)when sync trunk member vlan attribute,and add/remove from chip,it will check if trunk member ,if it is trunk

    member it will return FALSE.
              (3)when set pvid,it will add the port to the vlan,and remove it .At last ,the port will not in the native vlan
    Solution: when add trunk member to vlan when syn the attribute ,not check trunk member
              just set pvid ,not remove the port
    Files:vlan_mgr.c,swctrl.h,swctrl.c*/

#if 0
    if (!SWCTRL_IS_LPORT(trunk_mem_ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#endif
    if( vid == 0 || vid >  SYS_ADPT_MAX_VLAN_ID )
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "VLAN ID (1-%d)", SYS_ADPT_MAX_VLAN_ID);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_TRUNK_ID*/

#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    unit = SWCTRL_IFINDEX_TO_UNIT(trunk_mem_ifindex);
    port = SWCTRL_IFINDEX_TO_PORT(trunk_mem_ifindex);

    SWCTRL_LOCK();
    retval = SWDRV_AddPortToVlanUntaggedSet(unit, port, vid);
    SWCTRL_UNLOCK();
    SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME ();
    SWCTRL_RETURN_AND_RELEASE_CSC( retval );
} /* End of SWCTRL_AddTrunkMembersPortToVlanUntaggedSet() */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_DeletePortFromVlanUntaggedSet
 * -------------------------------------------------------------------------
 * FUNCTION: This function will delete a port from the untagged set of a
 *           specified VLAN
 * INPUT   : ifindex -- which port to add
 *           vid     -- which VLAN ID
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : Delete a port from untagged set means to recover this port to be
 *           a tagged member set of specified vlan.
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_DeletePortFromVlanUntaggedSet(UI32_T ifindex, UI32_T vid,BOOL_T port_check)
{
    UI32_T                          unit, port, i;
    BOOL_T                          retval = FALSE;
    SWCTRL_TrunkPortExtInfo_T    trunk_ext_p_info;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (port_check && !SWCTRL_IS_LPORT(ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if( vid == 0 || vid >  SYS_ADPT_MAX_VLAN_ID )
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "VLAN ID (1-%d)", SYS_ADPT_MAX_VLAN_ID);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_TRUNK_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    SWCTRL_LOCK();
    if (!SWCTRL_IS_TRUNK (ifindex))
    {
        unit = SWCTRL_IFINDEX_TO_UNIT(ifindex);
        port = SWCTRL_IFINDEX_TO_PORT(ifindex);

        retval = SWDRV_DeletePortFromVlanUntaggedSet(unit, port, vid);
    }
    else /* trunk */
    {
        SWCTRL_GetTrunkPortExtInfo (ifindex, &trunk_ext_p_info);

        for(i = 0; i < trunk_ext_p_info.member_number; i++)
        {
            unit = (UI32_T) trunk_ext_p_info.member_list[i].unit;
            port = (UI32_T) trunk_ext_p_info.member_list[i].port;
            if (!(retval = SWDRV_DeletePortFromVlanUntaggedSet(unit, port, vid)))
                break;
        } /* End of for () */
    } /* End of if (trunk) */
    SWCTRL_UNLOCK();
    SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME ();
    SWCTRL_RETURN_AND_RELEASE_CSC( retval );
} /* End of SWCTRL_DeletePortFromVlanUntaggedSet() */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_DeletePortFromVlanUntaggedSet
 * -------------------------------------------------------------------------
 * FUNCTION: This function will delete a port from the untagged set of a
 *           specified VLAN
 * INPUT   : ifindex -- which port to add
 *           vid     -- which VLAN ID
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : This function is used only for vlan to remove the trunk member from vlan
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_DeleteTrunkMemberPortFromVlanUntaggedSet(UI32_T trunk_mem_ifindex, UI32_T vid)
{
    UI32_T                          unit, port;
    BOOL_T                          retval = FALSE;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if( vid == 0 || vid >  SYS_ADPT_MAX_VLAN_ID )
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "VLAN ID (1-%d)", SYS_ADPT_MAX_VLAN_ID);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_TRUNK_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    unit = SWCTRL_IFINDEX_TO_UNIT(trunk_mem_ifindex);
    port = SWCTRL_IFINDEX_TO_PORT(trunk_mem_ifindex);

    SWCTRL_LOCK();
    retval = SWDRV_DeletePortFromVlanUntaggedSet(unit, port, vid);
    SWCTRL_UNLOCK();
    SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME ();
    SWCTRL_RETURN_AND_RELEASE_CSC( retval );
} /* End of SWCTRL_DeleteTrunkMemberPortFromVlanUntaggedSet() */


BOOL_T  SWCTRL_GetSystemMTU(UI32_T *jumbo,UI32_T *mtu)
{
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);
    if(jumbo==NULL)
        {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NULL_POINTER,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_FATAL,
                                  "Parameter jumbo is null");

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
        }

    if(mtu==NULL)
        {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NULL_POINTER,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_FATAL,
                                  "Parameter mtu is null");

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
        }

    SWCTRL_LOCK();
    *jumbo=system_info.jumbo_mtu;
    *mtu=system_info.mtu;
    SWCTRL_UNLOCK();


    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
}



BOOL_T SWCTRL_SetSystemMTU(UI32_T status,UI32_T mtu)
{
    UI32_T ifindex;
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

/*check jumbo*/
    if((status!=TRUE)&&(status!=FALSE))
        {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  "Parameter jumbo is incorrect");

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
        }
/*check mtu*/
    if((status==TRUE)&&((mtu>SYS_ADPT_MAX_JUMBO_MTU)||(mtu<SYS_ADPT_IF_MTU)))
        {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  "Parameter mtu is incorrect");

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
        }
    if((status==FALSE)&&((mtu>1548)||(mtu<SYS_ADPT_IF_MTU)))
        {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  "Parameter mtu is incorrect");

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
        }

#if 0 /* JinhuaWei, 14 August, 2008 3:15:26 */
    rv=SWDRV_SetSystemMTU(status,mtu);

    if(rv==TRUE)
        {
        SWCTRL_LOCK();
        if(status==TRUE)
            system_info.jumbo_mtu=mtu;
        else
            system_info.mtu=mtu;

        SWCTRL_UNLOCK();
    }
#endif /* #if 0 */
   /* EPR:ES4827G-FLF-ZZ-00324
      *Problem:we use constant variable value for nodes ifMtu and portMtu.but it will not change when system mtu change
      *RootCause:because we use constant variable for ifMtu and portMtu.so it can't be changed
      *Solution:so here we should add varialbe portMtu under structure SWCTRL_PortEntry_T,and because we set system mtu to each port ,so
                   here we put the new system mtu to each port directly
      *File:swctrl.c,swctrl.h,if_mgr.c
      *approve:Hard.Sun
      *Fixed by:Jinhua Wei
      */
    for (ifindex = 1; ifindex <= SYS_ADPT_TOTAL_NBR_OF_LPORT; ifindex++)
    {
        /*If setting mtu differ from current mtu, neet change current mtu in port_info -- xiongyu 20081211*/
        if ((SWCTRL_IS_LPORT(ifindex)) && (mtu != port_info[ifindex-1].port_entry.port_mtu))
        {
            if (!SWCTRL_SetPortMTU(ifindex, mtu))
            {
                SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
            }
        }
    }
    system_info.jumbo_mtu=mtu;
    SWCTRL_RETURN_AND_RELEASE_CSC(TRUE);

}


BOOL_T SWCTRL_SetPortMTU(UI32_T ifindex,UI32_T MTU)
{
    UI32_T                            unit, port, i;
    BOOL_T                            retval = FALSE;
    SWCTRL_TrunkPortExtInfo_T        trunk_ext_info;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    /* check ifindex
     */
    if(!SWCTRL_IS_LPORT(ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "specified port is not a logical port");

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    /* parameter MTU range check
     */
    if((MTU>SYS_ADPT_MAX_JUMBO_MTU)||(MTU<SYS_ADPT_IF_MTU))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "parameter MTU      is incorrect");

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (FALSE== SWCTRL_IS_TRUNK (ifindex))    /*normal port*/
    {
        /* if "jumbo frame" is disabled
         * 1. just allow to set the default MTU (1518)  to chip
         * 2. the configuration is only updated to database.
         */
        if(SWCTRL_JUMBO_FRAME_DISABLE == system_info.jumbo_frame_status)
        {
            retval = SWDRV_SetPortMTU(SWCTRL_IFINDEX_TO_UNIT(ifindex),SWCTRL_IFINDEX_TO_PORT(ifindex),SYS_DFLT_PORT_MTU);
        }
        else
        {
            retval = SWDRV_SetPortMTU(SWCTRL_IFINDEX_TO_UNIT(ifindex),SWCTRL_IFINDEX_TO_PORT(ifindex),MTU);
        }

        /* sync max frame size
         */
        SWCTRL_LOCK();
        SWCTRL_SyncUPortMaxFrameSize(SWCTRL_IFINDEX_TO_UNIT(ifindex), SWCTRL_IFINDEX_TO_PORT(ifindex));
        SWCTRL_UNLOCK();
    }
    else /*trunk port*/
    {
        if((retval=SWCTRL_GetTrunkPortExtInfo (ifindex, &trunk_ext_info))==TRUE)
        {
            for(i = 0; i < trunk_ext_info.member_number; i++)
            {
                unit = (UI32_T) trunk_ext_info.member_list[i].unit;
                port = (UI32_T) trunk_ext_info.member_list[i].port;

                /* if "jumbo frame" is disabled
                 * 1. just allow to set the default MTU (1518)  to chip
                 * 2. the configuration is only updated to database.
                 */
                if(SWCTRL_JUMBO_FRAME_DISABLE == system_info.jumbo_frame_status)
                {
                    retval = SWDRV_SetPortMTU(unit,port,SYS_DFLT_PORT_MTU);
                }
                else
                {
                    retval = SWDRV_SetPortMTU(unit,port,MTU);
                }
                if (FALSE == retval )
                {
                    break;
                }


                SWCTRL_LOCK();
                /* sync max frame size
                 */
                SWCTRL_SyncUPortMaxFrameSize(unit, port);
                /* update trunk member OM
                 */
                port_info[SWCTRL_UPORT_TO_IFINDEX(unit, port) - 1].port_entry.port_mtu = MTU;
                SWCTRL_UNLOCK();
            }
        }
    }

    SWCTRL_LOCK();
    if(retval==TRUE)
        port_info[ifindex-1].port_entry.port_mtu=MTU;
    SWCTRL_UNLOCK();

    SWCTRL_RETURN_AND_RELEASE_CSC( retval );
}

/* -------------------------------------------------------------------------
 * FUNCTION NAME - SWCTRL_SyncUPortMaxFrameSize
 * -------------------------------------------------------------------------
 * PURPOSE : to sync max frame size of port from chip to db
 * INPUT   : unit
 *           port
 * OUTPUT  : None
 * RETURN  : TRUE / FALSE
 * NOTE    : None
 * -------------------------------------------------------------------------
 */
static BOOL_T SWCTRL_SyncUPortMaxFrameSize(UI32_T unit, UI32_T port)
{
    UI32_T ifindex;
    BOOL_T ret = TRUE;

    if (unit != 0 && port != 0)
    {
        ifindex = SWCTRL_UPORT_TO_IFINDEX(unit, port);

        if (!SWCTRL_IS_USER_PORT(ifindex) || !SWCTRL_IS_EXIST(ifindex))
        {
            ret = FALSE;
        }
        else
        {
            ret = SWDRV_GetPortMaxFrameSize(unit, port,
                &user_ext_port_info[ifindex-1].untagged_max_frame_sz,
                &user_ext_port_info[ifindex-1].tagged_max_frame_sz);
        }
    }
    else
    {
        for (ifindex = 1; ifindex < SYS_ADPT_TOTAL_NBR_OF_LPORT; ifindex++)
        {
            if (!SWCTRL_IS_USER_PORT(ifindex) || !SWCTRL_IS_EXIST(ifindex))
                continue;

            unit = SWCTRL_IFINDEX_TO_UNIT(ifindex);
            port = SWCTRL_IFINDEX_TO_PORT(ifindex);

            ret = ret && SWDRV_GetPortMaxFrameSize(unit, port,
                &user_ext_port_info[ifindex-1].untagged_max_frame_sz,
                &user_ext_port_info[ifindex-1].tagged_max_frame_sz);
        }
    }

    return ret;
}

/* -------------------------------------------------------------------------
 * FUNCTION NAME - SWCTRL_GetTrunkMaxFrameSize
 * -------------------------------------------------------------------------
 * PURPOSE : to calculate max frame size of trunk
 * INPUT   : ifindex                 - trunk ifindex
 * OUTPUT  : untagged_max_frame_sz_p - max frame size for untagged frames
 *           tagged_max_frame_sz_p   - max frame size for tagged frames
 * RETURN  : TRUE / FALSE
 * NOTE    : None
 * -------------------------------------------------------------------------
 */
static BOOL_T SWCTRL_GetTrunkMaxFrameSize(UI32_T ifindex, UI32_T *untagged_max_frame_sz_p, UI32_T *tagged_max_frame_sz_p)
{
    UI32_T trunk_id = SWCTRL_IFINDEX_TO_TRUNKID(ifindex);
    UI32_T untagged_max_frame_sz, tagged_max_frame_sz;
    UI32_T i;

    untagged_max_frame_sz = tagged_max_frame_sz = 0;

    for (i = 0; i < trunk_ext_port_info[trunk_id-1].member_number; i++)
    {
        UI32_T unit, port;
        UI32_T member_ifindex;

        unit = (UI32_T) trunk_ext_port_info[trunk_id-1].member_list[i].unit;
        port = (UI32_T) trunk_ext_port_info[trunk_id-1].member_list[i].port;
        member_ifindex = SWCTRL_UPORT_TO_IFINDEX (unit, port);

        /* use min valud as trunk max frame size.
         *
         * NOTE: Ideally, all trunk member should have the same max frame size.
         */
        if (untagged_max_frame_sz == 0 ||
            untagged_max_frame_sz > user_ext_port_info[member_ifindex-1].untagged_max_frame_sz)
        {
            untagged_max_frame_sz = user_ext_port_info[member_ifindex-1].untagged_max_frame_sz;
        }
        if (tagged_max_frame_sz == 0 ||
            tagged_max_frame_sz > user_ext_port_info[member_ifindex-1].tagged_max_frame_sz)
        {
            tagged_max_frame_sz = user_ext_port_info[member_ifindex-1].tagged_max_frame_sz;
        }
    }

    *untagged_max_frame_sz_p = untagged_max_frame_sz;
    *tagged_max_frame_sz_p = tagged_max_frame_sz;

    return TRUE;
}

/* -------------------------------------------------------------------------
 * FUNCTION NAME - SWCTRL_GetPortMaxFrameSize
 * -------------------------------------------------------------------------
 * PURPOSE : to get max frame size of port
 * INPUT   : ifindex                 - ifindex
 * OUTPUT  : untagged_max_frame_sz_p - max frame size for untagged frames
 *           tagged_max_frame_sz_p   - max frame size for tagged frames
 * RETURN  : TRUE / FALSE
 * NOTE    : None
 * -------------------------------------------------------------------------
 */
BOOL_T SWCTRL_GetPortMaxFrameSize(UI32_T ifindex, UI32_T *untagged_max_frame_sz_p, UI32_T *tagged_max_frame_sz_p)
{
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if ((!SWCTRL_IS_USER_PORT(ifindex) && !SWCTRL_IS_TRUNK(ifindex)) ||
        !SWCTRL_IS_EXIST(ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (!SWCTRL_IS_TRUNK(ifindex))
    {
        *untagged_max_frame_sz_p = user_ext_port_info[ifindex-1].untagged_max_frame_sz;
        *tagged_max_frame_sz_p = user_ext_port_info[ifindex-1].tagged_max_frame_sz;
    }
    else
    {
        SWCTRL_GetTrunkMaxFrameSize(ifindex, untagged_max_frame_sz_p, tagged_max_frame_sz_p);
    }

    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_EnableIngressFilter
 * -------------------------------------------------------------------------
 * FUNCTION: This function will enable ingress filter of a port
 * INPUT   : ifindex -- which port to enable
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_EnableIngressFilter(UI32_T ifindex)
{
    UI32_T                          unit, port, i;
    BOOL_T                          retval = FALSE;
    SWCTRL_TrunkPortExtInfo_T    trunk_ext_p_info;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (!SWCTRL_IS_LPORT(ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    SWCTRL_LOCK();
    if (!SWCTRL_IS_TRUNK (ifindex))
    {
        unit = SWCTRL_IFINDEX_TO_UNIT(ifindex);
        port = SWCTRL_IFINDEX_TO_PORT(ifindex);

        retval = SWDRV_EnableIngressFilter(unit, port);
    }
    else /* trunk */
    {
        SWCTRL_GetTrunkPortExtInfo (ifindex, &trunk_ext_p_info);

        for(i = 0; i < trunk_ext_p_info.member_number; i++)
        {
            unit = (UI32_T) trunk_ext_p_info.member_list[i].unit;
            port = (UI32_T) trunk_ext_p_info.member_list[i].port;
            if (!(retval = SWDRV_EnableIngressFilter(unit, port)))
                break;
        } /* End of for () */
    } /* End of if (trunk) */
    SWCTRL_UNLOCK();
    SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME ();
    SWCTRL_RETURN_AND_RELEASE_CSC( retval );
} /* End of SWCTRL_EnableIngressFilter() */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_EnableIngressFilter
 * -------------------------------------------------------------------------
 * FUNCTION: This function will enable ingress filter of a port
 * INPUT   : ifindex -- which port to enable
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_EnableIngressFilterForTrunkMember(UI32_T ifindex)
{
    UI32_T                          unit, port;
    BOOL_T                          retval = FALSE;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (!SWCTRL_IS_LPORT(ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    SWCTRL_LOCK();

    unit = SWCTRL_IFINDEX_TO_UNIT(ifindex);
    port = SWCTRL_IFINDEX_TO_PORT(ifindex);

    retval = SWDRV_EnableIngressFilter(unit, port);
    SWCTRL_UNLOCK();
    SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME ();
    SWCTRL_RETURN_AND_RELEASE_CSC( retval );
} /* End of SWCTRL_EnableIngressFilter() */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_DisableIngressFilter
 * -------------------------------------------------------------------------
 * FUNCTION: This function will disable ingress filter of a port
 * INPUT   : ifindex -- which port to disable
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_DisableIngressFilter(UI32_T ifindex)
{
    UI32_T                          unit, port, i;
    BOOL_T                          retval = FALSE;
    SWCTRL_TrunkPortExtInfo_T    trunk_ext_p_info;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (!SWCTRL_IS_LPORT(ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    SWCTRL_LOCK();
    if (!SWCTRL_IS_TRUNK (ifindex))
    {
        unit = SWCTRL_IFINDEX_TO_UNIT(ifindex);
        port = SWCTRL_IFINDEX_TO_PORT(ifindex);

        retval = SWDRV_DisableIngressFilter(unit, port);
    }
    else /* trunk */
    {
        SWCTRL_GetTrunkPortExtInfo (ifindex, &trunk_ext_p_info);

        for(i = 0; i < trunk_ext_p_info.member_number; i++)
        {
            unit = (UI32_T) trunk_ext_p_info.member_list[i].unit;
            port = (UI32_T) trunk_ext_p_info.member_list[i].port;
            if (!(retval = SWDRV_DisableIngressFilter(unit, port)))
                break;
        } /* End of for () */
    } /* End of if (trunk) */
    SWCTRL_UNLOCK();
    SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME ();
    SWCTRL_RETURN_AND_RELEASE_CSC( retval );
} /* End of SWCTRL_DisableIngressFilter() */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_DisableIngressFilterForTrunkMember
 * -------------------------------------------------------------------------
 * FUNCTION: This function will disable ingress filter of a port
 * INPUT   : ifindex -- which port to disable
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_DisableIngressFilterForTrunkMember(UI32_T trunk_mem_ifindex)
{
    UI32_T                          unit, port;
    BOOL_T                          retval = FALSE;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (!SWCTRL_IS_TRUNK_MEMBER(trunk_mem_ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a trunk member port.");

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    SWCTRL_LOCK();

    unit = SWCTRL_IFINDEX_TO_UNIT(trunk_mem_ifindex);
    port = SWCTRL_IFINDEX_TO_PORT(trunk_mem_ifindex);

    retval = SWDRV_DisableIngressFilter(unit, port);
    SWCTRL_UNLOCK();
    SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME ();
    SWCTRL_RETURN_AND_RELEASE_CSC( retval );
} /* End of SWCTRL_DisableIngressFilterForTrunkMember() */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_AdmitVLANTaggedFramesOnlyForTrunkMember
 * -------------------------------------------------------------------------
 * FUNCTION: This function will only allow tagged frames entering a port
 * INPUT   : ifindex -- which port to set
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_AdmitVLANTaggedFramesOnlyForTrunkMember(UI32_T trunk_mem_ifindex)
{
    UI32_T                          unit, port;
    BOOL_T                          retval = FALSE;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (!SWCTRL_IS_TRUNK_MEMBER(trunk_mem_ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a trunk member port.");

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    SWCTRL_LOCK();

    unit = SWCTRL_IFINDEX_TO_UNIT(trunk_mem_ifindex);
    port = SWCTRL_IFINDEX_TO_PORT(trunk_mem_ifindex);

    retval = SWDRV_AdmitVLANTaggedFramesOnly(unit, port);

    if (retval)
    {
        retval = LAN_SetPortDiscardUntaggedFrame(unit, port, TRUE);
    }

    if (retval)
    {
        retval = LAN_SetPortDiscardTaggedFrame(unit, port, FALSE);
    }

    SWCTRL_UNLOCK();
    SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME ();
    SWCTRL_RETURN_AND_RELEASE_CSC( retval );
} /* End of SWCTRL_AdmitVLANTaggedFramesOnlyForTrunkMember() */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_AdmitVLANTaggedFramesOnly
 * -------------------------------------------------------------------------
 * FUNCTION: This function will only allow tagged frames entering a port
 * INPUT   : ifindex -- which port to set
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_AdmitVLANTaggedFramesOnly(UI32_T ifindex)
{
    UI32_T                          unit, port, i;
    BOOL_T                          retval = FALSE;
    SWCTRL_TrunkPortExtInfo_T    trunk_ext_p_info;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (!SWCTRL_IS_LPORT(ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    SWCTRL_LOCK();
    if (!SWCTRL_IS_TRUNK (ifindex))
    {
        unit = SWCTRL_IFINDEX_TO_UNIT(ifindex);
        port = SWCTRL_IFINDEX_TO_PORT(ifindex);

        retval = SWDRV_AdmitVLANTaggedFramesOnly(unit, port);

        if (retval)
        {
            retval = LAN_SetPortDiscardUntaggedFrame(unit, port, TRUE);
        }

        if (retval)
        {
            retval = LAN_SetPortDiscardTaggedFrame(unit, port, FALSE);
        }
    }
    else /* trunk */
    {
        SWCTRL_GetTrunkPortExtInfo (ifindex, &trunk_ext_p_info);

        for(i = 0; i < trunk_ext_p_info.member_number; i++)
        {
            unit = (UI32_T) trunk_ext_p_info.member_list[i].unit;
            port = (UI32_T) trunk_ext_p_info.member_list[i].port;
            if (!(retval = SWDRV_AdmitVLANTaggedFramesOnly(unit, port)))
                break;
            if (!(retval = LAN_SetPortDiscardUntaggedFrame(unit, port, TRUE)))
                break;
            if (!(retval = LAN_SetPortDiscardTaggedFrame(unit, port, FALSE)))
                break;
        } /* End of for () */
    } /* End of if (trunk) */
    SWCTRL_UNLOCK();
    SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME ();
    SWCTRL_RETURN_AND_RELEASE_CSC( retval );
} /* End of SWCTRL_AdmitVLANTaggedFramesOnly() */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_AdmitVLANUntaggedFramesOnly
 * -------------------------------------------------------------------------
 * FUNCTION: This function will only allow untagged frames entering a port
 * INPUT   : ifindex -- which port to set
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_AdmitVLANUntaggedFramesOnly(UI32_T ifindex)
{
    UI32_T                          unit, port, i;
    BOOL_T                          retval = FALSE;
    SWCTRL_TrunkPortExtInfo_T    trunk_ext_p_info;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (!SWCTRL_IS_LPORT(ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    SWCTRL_LOCK();
    if (!SWCTRL_IS_TRUNK (ifindex))
    {
        unit = SWCTRL_IFINDEX_TO_UNIT(ifindex);
        port = SWCTRL_IFINDEX_TO_PORT(ifindex);

        retval = SWDRV_AdmitVLANUntaggedFramesOnly(unit, port);

        if (retval)
        {
            retval = LAN_SetPortDiscardUntaggedFrame(unit, port, FALSE);
        }

        if (retval)
        {
            retval = LAN_SetPortDiscardTaggedFrame(unit, port, TRUE);
        }
    }
    else /* trunk */
    {
        SWCTRL_GetTrunkPortExtInfo (ifindex, &trunk_ext_p_info);

        for(i = 0; i < trunk_ext_p_info.member_number; i++)
        {
            unit = (UI32_T) trunk_ext_p_info.member_list[i].unit;
            port = (UI32_T) trunk_ext_p_info.member_list[i].port;
            if (!(retval = SWDRV_AdmitVLANUntaggedFramesOnly(unit, port)))
                break;
            if (!(retval = LAN_SetPortDiscardUntaggedFrame(unit, port, FALSE)))
                break;
            if (!(retval = LAN_SetPortDiscardTaggedFrame(unit, port, TRUE)))
                break;
        } /* End of for () */
    } /* End of if (trunk) */
    SWCTRL_UNLOCK();
    SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME ();
    SWCTRL_RETURN_AND_RELEASE_CSC( retval );
} /* End of SWCTRL_AdmitVLANUntaggedFramesOnly() */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_AdmitAllFramesForTrunkMember
 * -------------------------------------------------------------------------
 * FUNCTION: This function will allow all kinds of frames entering a port
 * INPUT   : ifindex -- which port to set
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_AdmitAllFramesForTrunkMember(UI32_T trunk_mem_ifindex)
{
    UI32_T                          unit, port;
    BOOL_T                          retval = FALSE;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (!SWCTRL_IS_TRUNK_MEMBER(trunk_mem_ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a trunk member port.");

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    SWCTRL_LOCK();

    unit = SWCTRL_IFINDEX_TO_UNIT(trunk_mem_ifindex);
    port = SWCTRL_IFINDEX_TO_PORT(trunk_mem_ifindex);

    retval = SWDRV_AdmitAllFrames(unit, port);

    if (retval)
    {
        retval = LAN_SetPortDiscardUntaggedFrame(unit, port, FALSE);
    }

    if (retval)
    {
        retval = LAN_SetPortDiscardTaggedFrame(unit, port, FALSE);
    }

    SWCTRL_UNLOCK();
    SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME ();
    SWCTRL_RETURN_AND_RELEASE_CSC( retval );
} /* End of SWCTRL_AdmitAllFramesForTrunkMember() */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_AdmitAllFrames
 * -------------------------------------------------------------------------
 * FUNCTION: This function will allow all kinds of frames entering a port
 * INPUT   : ifindex -- which port to set
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_AdmitAllFrames(UI32_T ifindex)
{
    UI32_T                          unit, port, i;
    BOOL_T                          retval = FALSE;
    SWCTRL_TrunkPortExtInfo_T    trunk_ext_p_info;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (!SWCTRL_IS_LPORT(ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    SWCTRL_LOCK();
    if (!SWCTRL_IS_TRUNK (ifindex))
    {
        unit = SWCTRL_IFINDEX_TO_UNIT(ifindex);
        port = SWCTRL_IFINDEX_TO_PORT(ifindex);

        retval = SWDRV_AdmitAllFrames(unit, port);

        if (retval)
        {
            retval = LAN_SetPortDiscardUntaggedFrame(unit, port, FALSE);
        }

        if (retval)
        {
            retval = LAN_SetPortDiscardTaggedFrame(unit, port, FALSE);
        }
    }
    else /* trunk */
    {
        SWCTRL_GetTrunkPortExtInfo (ifindex, &trunk_ext_p_info);

        for(i = 0; i < trunk_ext_p_info.member_number; i++)
        {
            unit = (UI32_T) trunk_ext_p_info.member_list[i].unit;
            port = (UI32_T) trunk_ext_p_info.member_list[i].port;
            if (!(retval = SWDRV_AdmitAllFrames(unit, port)))
                break;
            if (!(retval = LAN_SetPortDiscardUntaggedFrame(unit, port, FALSE)))
                break;
            if (!(retval = LAN_SetPortDiscardTaggedFrame(unit, port, FALSE)))
                break;
        } /* End of for () */
    } /* End of if (trunk) */
    SWCTRL_UNLOCK();
    SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME ();
    SWCTRL_RETURN_AND_RELEASE_CSC( retval );
} /* End of SWCTRL_AdmitAllFrames() */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_AddHostToVlan

 * -------------------------------------------------------------------------
 * FUNCTION: This function will add CPU to a specified VLAN
 * INPUT   : vid -- which VLAN to add
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_AddHostToVlan(UI32_T vid)
{
    BOOL_T retval;

    if( vid == 0 || vid >  SYS_ADPT_MAX_VLAN_ID )
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "VLAN ID (1-%d)", SYS_ADPT_MAX_VLAN_ID);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_TRUNK_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    SWCTRL_LOCK();
    retval = SWDRV_AddHostToVlan(vid);
    SWCTRL_UNLOCK();
    SWCTRL_RETURN_AND_RELEASE_CSC( retval );
} /* End of SWCTRL_AddHostToVlan() */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_DeleteHostFromVlan

 * -------------------------------------------------------------------------
 * FUNCTION: This function will delete CPU from a specified VLAN
 * INPUT   : vid -- which VLAN to delete
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_DeleteHostFromVlan(UI32_T vid)
{
    BOOL_T retval;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if( vid == 0 || vid > SYS_ADPT_MAX_VLAN_ID )
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "VLAN ID (1-%d)", SYS_ADPT_MAX_VLAN_ID);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_TRUNK_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    SWCTRL_LOCK();
    retval = SWDRV_DeleteHostFromVlan(vid);
    SWCTRL_UNLOCK();
    SWCTRL_RETURN_AND_RELEASE_CSC( retval );
} /* End of SWCTRL_DeleteHostFromVlan() */




/****************************************************************************/
/* Port Mirroring                                                           */
/****************************************************************************/
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_IsAnalyzerPort
 * -------------------------------------------------------------------------
 * FUNCTION: This function will get if this port is an analyzer port
 * INPUT   : unit_port -- the port to get
 * OUTPUT  : None
 * RETURN  : TRUE: Is an analyzer port, FALSE: If not
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_IsAnalyzerPort(SYS_TYPE_Uport_T unit_port)
{
    UI32_T ifindex;
    UI32_T om_idx;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if((unit_port.unit < 1) || (unit_port.unit > SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK))
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Unit (1-%d)", SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_UNIT_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    ifindex = SWCTRL_UPORT_TO_IFINDEX (unit_port.unit, unit_port.port);

    if(!SWCTRL_IS_EXIST (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Interface");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

#if (SYS_CPNT_ALLOW_DUMMY_MIRRORING_DEST == TRUE)
    /* dummy dest is also eye
     */
    if (system_info.dummy_mirroring_dest == ifindex)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
    }
#endif

    /*ifindex is 1-based, but the OM is 0-based*/
    SWCTRL_LOCK();
    for(om_idx = 0; om_idx <= SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK*SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT - 1; om_idx++)
    {
        if(!SWCTRL_IS_EXIST(om_idx+1))
            continue;

        if (user_ext_port_info[om_idx].mirroring_tx_dest_port == ifindex ||
            user_ext_port_info[om_idx].mirroring_rx_dest_port == ifindex)
        {
            SWCTRL_UNLOCK();
            SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
        }
    }
    SWCTRL_UNLOCK();

    SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
} /* End of SWCTRL_IsAnalyzerPort() */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_IsMonitoredPort
 * -------------------------------------------------------------------------
 * FUNCTION: This function will get if this port is an monitored port
 * INPUT   : unit_port -- the port to get
 * OUTPUT  : None
 * RETURN  : TRUE: Is an monitored port, FALSE: If not
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_IsMonitoredPort(SYS_TYPE_Uport_T unit_port)
{
    UI32_T ifindex;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if((unit_port.unit < 1) || (unit_port.unit > SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK))
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Unit (1-%d)", SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_UNIT_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    ifindex = SWCTRL_UPORT_TO_IFINDEX (unit_port.unit, unit_port.port);

    if(!SWCTRL_IS_EXIST (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Interface");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    /*ifindex is 1-based, but the OM is 0-based*/
    if (user_ext_port_info[ifindex-1].mirroring_tx_dest_port ||
        user_ext_port_info[ifindex-1].mirroring_rx_dest_port)
        SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );

    SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
} /* End of SWCTRL_IsMonitoredPort() */




/****************************************************************************/
/* Trunking                                                                 */
/****************************************************************************/
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_CreateTrunk
 * -------------------------------------------------------------------------
 * FUNCTION: This function will create a trunking port
 * INPUT   : trunk_id -- which trunking port to create
 *           is_static-- create by user/LCAP
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : fot TRK_MGR
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_CreateTrunk(UI32_T trunk_id, BOOL_T is_static)
{
    BOOL_T retval;
    UI32_T ifindex;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if((trunk_id < 1) || (trunk_id > SYS_ADPT_MAX_NBR_OF_TRUNK_PER_SYSTEM))
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Trunk ID (1-%d)", SYS_ADPT_MAX_NBR_OF_TRUNK_PER_SYSTEM);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);   /*SWCTRL_ENO_OUT_OF_RANGE_TRUNK_ID*/

#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    ifindex = SWCTRL_TRUNKID_TO_IFINDEX (trunk_id);

    if(SWCTRL_IS_EXIST (ifindex))
        SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );

    SWCTRL_LOCK();
    retval = SWDRV_CreateTrunk (trunk_id);
    if(retval)
    {
        port_info[ifindex-1].link_oper_status = VAL_ifOperStatus_lowerLayerDown;
        port_info[ifindex-1].link_oper_status_level = 0;
        port_info[ifindex-1].link_oper_dormant_status = 0;
        port_info[ifindex-1].link_oper_dormant_active = 0;

        port_info[ifindex-1].port_entry.port_name[0] = '\0';
        port_info[ifindex-1].port_entry.port_forced_mode = VAL_portComboForcedMode_none;

        port_info[ifindex-1].ingress_rate_limit_status = SYS_DFLT_INGRESS_RATE_LIMIT_STATUS;
        port_info[ifindex-1].egress_rate_limit_status = SYS_DFLT_EGRESS_RATE_LIMIT_STATUS;

        trunk_ext_port_info[trunk_id-1].member_number = 0;
        trunk_ext_port_info[trunk_id-1].is_static = is_static;
        memset(trunk_ext_port_info[trunk_id-1].admin_active_members, 0, sizeof(trunk_ext_port_info[trunk_id-1].admin_active_members));
        memset(trunk_ext_port_info[trunk_id-1].oper_active_members, 0, sizeof(trunk_ext_port_info[trunk_id-1].oper_active_members));
    }
    SWCTRL_UNLOCK();

    SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME ();
    SWCTRL_RETURN_AND_RELEASE_CSC( retval );
} /* End of SWCTRL_CreateTrunk() */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_DestroyTrunk
 * -------------------------------------------------------------------------
 * FUNCTION: This function will destroy a trunking port
 * INPUT   : trunk_id -- which trunking port to destroy
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_DestroyTrunk(UI32_T trunk_id)
{
    SWCTRL_TrunkPortExtInfo_T       trunk_ext_p_info;
    SYS_TYPE_Uport_T                unit_port;
    UI32_T                          ifindex;
    BOOL_T                          retval;
    I32_T                           i;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if((trunk_id < 1) || (trunk_id > SYS_ADPT_MAX_NBR_OF_TRUNK_PER_SYSTEM))
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Trunk ID (1-%d)", SYS_ADPT_MAX_NBR_OF_TRUNK_PER_SYSTEM);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);   /*SWCTRL_ENO_OUT_OF_RANGE_TRUNK_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    ifindex = SWCTRL_TRUNKID_TO_IFINDEX (trunk_id);

    if(!SWCTRL_IS_EXIST (ifindex))
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
    }

    SWCTRL_GetTrunkPortExtInfo(ifindex, &trunk_ext_p_info);

    /* delete all of the member of trunk
     */
    for(i=trunk_ext_p_info.member_number-1; i>=0; i--)
    {
        unit_port.unit = trunk_ext_p_info.member_list[i].unit;
        unit_port.port = trunk_ext_p_info.member_list[i].port;

        if (!SWCTRL_DeleteTrunkMember(trunk_id, unit_port))
        {
            /*set error code in SWCTRL_DeleteTrunkMember() */
            SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
        }

        trunk_ext_p_info.member_list[i].unit = 0;
        trunk_ext_p_info.member_list[i].port = 0;
    }

    SWCTRL_LOCK();
    SWCTRL_SetTrunkPorts(trunk_id, 0, trunk_ext_port_info[trunk_id-1].member_list);
    if ( (retval = SWDRV_DestroyTrunk(trunk_id)) == TRUE )
        port_info[ifindex-1].link_oper_status = VAL_ifOperStatus_notPresent;
    SWCTRL_UNLOCK();

#if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION == TRUE)
#if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE == SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE_MULTIPLE_SESSION)
    if (retval == TRUE)
    {
        /* clean trunk id session */
        if (swctl_private_vlan_port_info[ifindex-1].session_id != 0x0)
        {
            /* get user trunk index port is uplink or downlink port */
            if (swctl_private_vlan_port_info[ifindex-1].private_vlan_uplink_port == TRUE)
            {
                swctl_private_vlan_port_info[ifindex-1].private_vlan_uplink_port= FALSE;
                swctl_private_vlan_ext_info[swctl_private_vlan_port_info[ifindex-1].session_id-1].private_vlan_uplink_port_list[SWCTRL_BYTE_IN_BITMAP(ifindex)]
                                                                    &=  ~(SWCTRL_BIT_IN_BITMAP(ifindex));
            }
            else if (swctl_private_vlan_port_info[ifindex-1].private_vlan_downlink_port == TRUE)
            {
                swctl_private_vlan_port_info[ifindex-1].private_vlan_downlink_port = FALSE;
                swctl_private_vlan_ext_info[swctl_private_vlan_port_info[ifindex-1].session_id-1].private_vlan_downlink_port_list[SWCTRL_BYTE_IN_BITMAP(ifindex)]
                                                                    &=  ~(SWCTRL_BIT_IN_BITMAP(ifindex));
            }

            /* clean trunk index port */
            swctl_private_vlan_trunk_port_info[trunk_id-1].session_id = 0x0;
            swctl_private_vlan_port_info[ifindex-1].session_id = 0x0;
        }
    }
#endif /* End of #if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE == SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE_MULTIPLE_SESSION)*/
#endif /* End of #if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION == TRUE) */

    SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME ();
    SWCTRL_RETURN_AND_RELEASE_CSC( retval );
} /* End of SWCTRL_DestroyTrunk() */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_AllowToBeTrunkMember
 * -------------------------------------------------------------------------
 * FUNCTION: This function will return TRUE if the port is allowed to add
 *           into trunk
 * INPUT   : unit -- unit number
 *           port -- which port to check
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_AllowToBeTrunkMember(UI32_T unit, UI32_T port)
{
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

#ifdef SYS_ADPT_ALLOW_TO_BE_TM_PORT_LIST
    /* Ignore the unit. In the stacking case,  s'pose all unit is the same case.
     */
    if ( (swctrl_allow_to_be_tm_port_list[(port-1)/8]<<((port-1)%8))&0x80 )
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
    }
    else
    {
        /*not necessary to set error code*/
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#else
    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
#endif
} /* End of SWCTRL_AllowToBeTrunkMember () */



 /* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_AddTrunkMember
 * -------------------------------------------------------------------------
 * FUNCTION: This function will add a members to a trunk
 * INPUT   : trunk_id   -- which trunking port to set
 *           unit_port  -- member to add
 *           is_static  -- static or dynamic trunk
 *           is_active  -- active or inactive member
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_AddTrunkMember(UI32_T trunk_id, SYS_TYPE_Uport_T unit_port, BOOL_T is_static, BOOL_T is_active)
{
    BOOL_T                  retval;
    UI32_T                  port_type;
    SWCTRL_PortInfo_T       old_port_info;
    UI32_T                  trunk_ifindex, tm_ifindex;
    BOOL_T                  is_trunk_member_forwarding_originally;
    UI32_T                  check_ifindex;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    trunk_ifindex   = SWCTRL_TRUNKID_TO_IFINDEX (trunk_id);
    check_ifindex = SWCTRL_UPORT_TO_IFINDEX(unit_port.unit, unit_port.port);

    /* Sementic check
     */
    /* error if this port is already a trunk member or not existing
     */
    port_type = SWCTRL_UserPortToIfindex(unit_port.unit, unit_port.port, &tm_ifindex);

    if (port_type == SWCTRL_LPORT_TRUNK_PORT_MEMBER)
    {
        UI32_T tm_trunk_ifindex;

        SWCTRL_GetTrunkIfIndexByUport(tm_ifindex, &tm_trunk_ifindex);

        /* CHECK RULE 1. (only join 1 trunk)
         */
        if (trunk_ifindex == tm_trunk_ifindex)
        {
            SWCTRL_RETURN_AND_RELEASE_CSC(TRUE); /* the trunk member is the member of trunk_id already */
        }
        else
        {
            EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                      SWCTRL_NO_USE_FUNC_NO,
                                      EH_TYPE_MSG_TRUNK_MEMBER_JOIN,
                                      SYSLOG_LEVEL_INFO,
                                      "it is a member of another Trunk");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

            SWCTRL_RETURN_AND_RELEASE_CSC(FALSE); /* the trunk member it the member of other trunk */
        }
    }

#if (SYS_CPNT_ATC_BSTORM == TRUE)
    if (port_info[tm_ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_status == SWCTRL_ATC_BROADCAST_STORM_TC_ON_ENABLE)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
    }
#endif
#if (SYS_CPNT_ATC_MSTORM == TRUE)
    if (port_info[tm_ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_status == VAL_atcMcastStormEnable_enabled)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
    }
#endif

    /* By SA's instruction, don't care MSTP case now, so instance is hard code: 0
     */
    is_trunk_member_forwarding_originally = XSTP_OM_IsPortForwardingStateByInstance(0, tm_ifindex);

    if (SWCTRL_CheckUserPortJoinTrunkValidation(trunk_id, unit_port, FALSE, is_active) == FALSE)
    {
        /*set error code in SWCTRL_CheckUserPortJoinTrunkValidation()*/
        SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
    }
#if (SYS_CPNT_TRUNK_MEMBER_AUTO_ATTRIBUTE == TRUE)
    else
    {
        if (FALSE == SWCTRL_UserPortFollowTrunkAttributes(tm_ifindex, trunk_ifindex))
        {
            SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
        }
    }
#endif

#if (SYS_CPNT_SUPPORT_NULL_TRUNK == TRUE)
    /* when support NULL trunk, the trunk member number is 0,
     * change the static/dynamic type by new added member autimatically
     */
    if (0 == trunk_ext_port_info[trunk_id-1].member_number)
    {
        trunk_ext_port_info[trunk_id-1].is_static = is_static;
    }
#endif

#if (SYS_CPNT_SWCTRL_SWITCH_MODE_CONFIGURABLE == TRUE)
    /* Set switching mode to Store-and-Forward when add the port to trunk
     * Now trunks don't support Cut-Through switching mode
     */
    if (port_info[tm_ifindex-1].port_entry.switch_mode != VAL_swctrlSwitchModeSF)
    {
        if (TRUE != SWDRV_SetSwitchingMode(unit_port.unit, unit_port.port, VAL_swctrlSwitchModeSF))
        {
            SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
        }

        SWCTRL_LOCK();
		port_info[tm_ifindex-1].port_entry.switch_mode = VAL_swctrlSwitchModeSF;
		SWCTRL_UNLOCK();
    }
#endif /*#if (SYS_CPNT_SWCTRL_SWITCH_MODE_CONFIGURABLE == TRUE)*/


    SWCTRL_LOCK();
    /* add new member into list
     */
    trunk_ext_port_info[trunk_id-1].member_list[trunk_ext_port_info[trunk_id-1].member_number].unit = unit_port.unit;
    trunk_ext_port_info[trunk_id-1].member_list[trunk_ext_port_info[trunk_id-1].member_number].port = unit_port.port;
    trunk_ext_port_info[trunk_id-1].member_number ++;
    SWCTRL_SET_TRUNK_MEMBER_ADMIN_ACTIVE(trunk_id, tm_ifindex, is_active);
    SWCTRL_SET_TRUNK_MEMBER_OPER_ACTIVE(trunk_id, tm_ifindex, FALSE);
    port_info[tm_ifindex-1].port_entry.port_trunk_index = trunk_id;
    old_port_info = port_info[trunk_ifindex-1];
    SWCTRL_UNLOCK();


    /* notify all registered components
     */
    if (trunk_ext_port_info[trunk_id-1].member_number == 1)
    {
        /* copy the all of attributes of 1st trunk member to trunk
         */
        SWCTRL_LOCK();
        port_info[trunk_ifindex-1] = port_info[tm_ifindex-1];
        port_info[trunk_ifindex-1].shutdown_status &= SWCTRL_PORT_STATUS_SET_BY_CFG;
        SWCTRL_OM_TrunkFollowUserPortAttributes(trunk_ifindex, tm_ifindex);

#if (SYS_CPNT_INGRESS_RATE_LIMIT == TRUE)
        if (port_info[trunk_ifindex-1].ingress_rate_limit_status == VAL_rlPortInputStatus_enabled)
        {
            SWDRV_SetPortIngressRateLimit(1, 1, trunk_id,
                    SWCTRL_ConvertUserRateLimitToPhy(port_info[trunk_ifindex-1].port_entry.port_type,
                    port_info[trunk_ifindex-1].ingress_rate_limit));
        }
#endif

        /* init oper status
         */
        port_info[trunk_ifindex-1].link_oper_status = VAL_ifOperStatus_lowerLayerDown;
        port_info[trunk_ifindex-1].link_oper_status_level = 0;
        port_info[trunk_ifindex-1].link_oper_dormant_status = 0;
        port_info[trunk_ifindex-1].link_oper_dormant_active = 0;

        /* these index should keep original data
         */
        port_info[trunk_ifindex-1].port_entry.port_index                 = trunk_ifindex;
        port_info[trunk_ifindex-1].bcast_storm_entry.bcast_storm_ifindex = trunk_ifindex;
        port_info[trunk_ifindex-1].mcast_storm_entry.mcast_storm_ifindex = trunk_ifindex;

        port_info[trunk_ifindex-1].storm_granularity = port_info[tm_ifindex-1].storm_granularity;

#if (SYS_CPNT_STORM_MODE & SYS_CPNT_STORM_UNKNOWN_USTORM)
        port_info[trunk_ifindex-1].unknown_ucast_storm_entry.unknown_ucast_storm_ifindex = trunk_ifindex;
#endif

        /* MDIX mode
         */
#if (SYS_CPNT_SWCTRL_MDIX_CONFIG == TRUE)
        if (SWCTRL_IS_100TX(check_ifindex))
        {
            port_info[trunk_ifindex-1].MDIX_mode = port_info[check_ifindex-1].MDIX_mode;
            port_info[trunk_ifindex-1].port_entry.port_MDIX_mode = port_info[check_ifindex-1].port_entry.port_MDIX_mode;
        }
        else
        {
            port_info[trunk_ifindex-1].MDIX_mode = SYS_DFLT_MDIX_MODE;
            port_info[trunk_ifindex-1].port_entry.port_MDIX_mode = SYS_DFLT_MDIX_MODE;
        }
#endif

#if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION == TRUE)
#if (SWCTRL_PORT_TRAFFIC_SEGMENTATION_AUTO_ATTRIBUTE == TRUE)
        SWCTRL_PrivateVlanTrunkFollowUserPortAttributes(trunk_ifindex, tm_ifindex);
#endif
#endif

#if (SYS_CPNT_ITRI_MIM == TRUE)
        {
            BOOL_T status;
            L2MUX_MGR_ITRI_MIM_GetStatus(tm_ifindex, &status);
            SWCTRL_ITRI_MIM_SetStatus(trunk_ifindex, status);
        }
#endif

#if(SYS_CPNT_WRED == TRUE)
      SWCTRL_OM_CpyRandomDetectValue(tm_ifindex, trunk_ifindex);
#endif

        SWCTRL_UNLOCK();
        SWCTRL_Notify_TrunkMemberAdd1st(trunk_ifindex, tm_ifindex);
    }
    else
    {
        /* copy the all of attributes of trunk to port member
         */
        SWCTRL_Notify_TrunkMemberAdd(trunk_ifindex, tm_ifindex);
    }


    if (TRUE == is_trunk_member_forwarding_originally)
    {
        SWCTRL_Notify_ForwardingUPortAddToTrunk(trunk_ifindex, tm_ifindex);
    }

    SWCTRL_LOCK();
    retval = SWCTRL_SetTrunkPorts(trunk_id,
                                 trunk_ext_port_info[trunk_id-1].member_number,
                                 trunk_ext_port_info[trunk_id-1].member_list);
    SWCTRL_UNLOCK();

    SWCTRL_LinkOperStateMachineChangeState (trunk_ifindex, SWCTRL_LOWER_LAYER_CHANGED_EVENT);

#if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION == TRUE)
#if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE == SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE_MULTIPLE_SESSION)
#if (SWCTRL_PORT_TRAFFIC_SEGMENTATION_AUTO_ATTRIBUTE == TRUE)
    /* do nothing here,
     * for the first member, handle in SWCTRL_PrivateVlanTrunkFollowUserPortAttributes
     * for other member, handle in SWCTRL_PrivateVlanUserPortFollowTrunkAttributes
     */
#else
    if (retval == TRUE)
    {
        /* set trunk id to port index when pvlan isn't configuration */
        if ((swctl_private_vlan_port_info[tm_ifindex-1].session_id == 0x0) &&
            (swctl_private_vlan_port_info[trunk_ifindex-1].session_id == 0x0))
        {
            /* set port trunk index */
            if (FALSE == swctl_private_vlan_port_info[tm_ifindex-1].is_pvlan_trunk_index_port)
            {
                swctl_private_vlan_port_info[tm_ifindex-1].port_trunk_index = trunk_id;
            }
        }
        else
        {
            /* if trunk index port has pvlan then add member port(s) to group */
            SWCTRL_AddPrivateVlanTrunkMember(trunk_ifindex, tm_ifindex);
        }
    }
#endif /* (SWCTRL_PORT_TRAFFIC_SEGMENTATION_AUTO_ATTRIBUTE == TRUE) */
#endif /* End of #if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE == SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE_MULTIPLE_SESSION)*/
#endif /* End of #if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION == TRUE) */

    if (retval)
    {
        SWCTRL_UpdateTrunkEgressBlock(trunk_ifindex);
    }

    SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME ();
    SWCTRL_RETURN_AND_RELEASE_CSC(retval);

} /* End of SWCTRL_AddTrunkMember() */





/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_DeleteTrunkMember
 * -------------------------------------------------------------------------
 * FUNCTION: This function will delete a members to a trunk
 * INPUT   : trunk_id   -- which trunking port to set
 *           unit_port  -- member to delete
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_DeleteTrunkMember(UI32_T trunk_id,
                                SYS_TYPE_Uport_T unit_port)
{
    int    i, index;
    BOOL_T retval;
    UI32_T trunk_ifindex, tm_ifindex;
    BOOL_T is_trunk_forwarding_originally;
    UI32_T original_trk_mem_link_oper_status;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (trunk_id < 1 || trunk_id > SYS_ADPT_MAX_NBR_OF_TRUNK_PER_SYSTEM)
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Trunk ID (1-%d)", SYS_ADPT_MAX_NBR_OF_TRUNK_PER_SYSTEM);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);   /*SWCTRL_ENO_OUT_OF_RANGE_TRUNK_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
    }

    trunk_ifindex   = SWCTRL_TRUNKID_TO_IFINDEX (trunk_id);
    tm_ifindex      = SWCTRL_UPORT_TO_IFINDEX (unit_port.unit, unit_port.port);

    if(!SWCTRL_IS_EXIST (trunk_ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Trunk");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (trunk_ext_port_info[trunk_id-1].member_number == 0)
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_TRUNK_CNFG_ERR,
                                  SYSLOG_LEVEL_INFO,
                                  "Trunk contains no members");  /*SWCTRL_ENO_NO_MEMBER_IN_TRUNK*/

        SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
    }

    if (unit_port.unit < 1 || unit_port.unit > SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK)
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Unit (1-%d)", SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_UNIT_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
    }

    if (!SWCTRL_IS_EXIST(tm_ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Interface");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
    }

    if((trunk_ext_port_info[trunk_id-1].is_static == FALSE) &&
#if (SYS_CPNT_STATIC_TRUNK_CONFIG_ALLOWED_ON_LACP_PORT == TRUE)
       (user_ext_port_info[tm_ifindex-1].lacp_oper_status == VAL_lacpPortStatus_disabled))
#else
       (user_ext_port_info[tm_ifindex-1].lacp_status == VAL_lacpPortStatus_disabled))
#endif
    {
        EH_MGR_Handle_Exception2 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_LACP_TRUNK_REMOVE,
                                  SYSLOG_LEVEL_INFO,
                                  "disabled",
                                  "dynamic");  /*SWCTRL_ENO_DENY_REMOVE_LACP_DISABLED_PORT_FROM_DYNAMIC_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if((trunk_ext_port_info[trunk_id-1].is_static == TRUE) &&
#if (SYS_CPNT_STATIC_TRUNK_CONFIG_ALLOWED_ON_LACP_PORT == TRUE)
       (user_ext_port_info[tm_ifindex-1].lacp_oper_status == VAL_lacpPortStatus_enabled))
#else
       (user_ext_port_info[tm_ifindex-1].lacp_status == VAL_lacpPortStatus_enabled))
#endif
    {
        EH_MGR_Handle_Exception2 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_LACP_TRUNK_REMOVE,
                                  SYSLOG_LEVEL_INFO,
                                  "enabled",
                                  "static");  /*SWCTRL_ENO_DENY_REMOTE_LACP_ENABLED_PORT_FROM_STATIC_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    SWCTRL_LOCK();
    /* to find the index of the member want to delete from member list
     */
    index = -1;
    for(i=0; i<trunk_ext_port_info[trunk_id-1].member_number; i++)
    {
        if((trunk_ext_port_info[trunk_id-1].member_list[i].unit == unit_port.unit) &&
           (trunk_ext_port_info[trunk_id-1].member_list[i].port == unit_port.port))
        {
            index = i;
            break;
        }
    }
    /* the port is not the member of trunk
     */
    if (index == -1)
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff_1[32] = {0};
        UI8_T buff_2[32] = {0};
#endif

        SWCTRL_UNLOCK();

#if (SYS_CPNT_EH == TRUE)

        sprintf(buff_1, "Port %u of Unit %u ", unit_port.port, unit_port.unit);
        sprintf(buff_2, "%lu", trunk_id);

        EH_MGR_Handle_Exception2 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_TRUNK_MEMBER,
                                  SYSLOG_LEVEL_INFO,
                                  buff_1,
                                  buff_2);  /*SWCTRL_ENO_NOT_A_MEMBER_IN_TRUNK*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

#if (SYS_DFLT_IF_LINK_TRAP_PORT_BASE == TRUE)
    /* inherit per port trap status from trunk
     */
    port_info[tm_ifindex-1].link_change_trap = port_info[trunk_ifindex-1].link_change_trap;
#endif

    /* to remove the port form the member list
     */
    for (i=index; i<trunk_ext_port_info[trunk_id-1].member_number-1; i++)
    {
        trunk_ext_port_info[trunk_id-1].member_list[i].unit = trunk_ext_port_info[trunk_id-1].member_list[i+1].unit;
        trunk_ext_port_info[trunk_id-1].member_list[i].port = trunk_ext_port_info[trunk_id-1].member_list[i+1].port;
    }
    if (i == (trunk_ext_port_info[trunk_id-1].member_number-1))
    {
        trunk_ext_port_info[trunk_id-1].member_list[i].unit = 0;
        trunk_ext_port_info[trunk_id-1].member_list[i].port = 0;
    }

    trunk_ext_port_info[trunk_id-1].member_number --;
    SWCTRL_SET_TRUNK_MEMBER_ADMIN_ACTIVE(trunk_id, tm_ifindex, FALSE);
    SWCTRL_SET_TRUNK_MEMBER_OPER_ACTIVE(trunk_id, tm_ifindex, FALSE);
    port_info[tm_ifindex-1].port_entry.port_trunk_index = 0;

    /* By SA's instruction, don't care MSTP case now, so instance is hard code: 0
     */
    is_trunk_forwarding_originally = XSTP_OM_IsPortForwardingStateByInstance(0, trunk_ifindex);
    original_trk_mem_link_oper_status = port_info[tm_ifindex-1].link_oper_status;

    retval = SWCTRL_SetTrunkPorts(trunk_id,
                                 trunk_ext_port_info[trunk_id-1].member_number,
                                 trunk_ext_port_info[trunk_id-1].member_list);
    SWCTRL_UNLOCK();

    SWCTRL_LinkOperStateMachineChangeState (trunk_ifindex, SWCTRL_LOWER_LAYER_CHANGED_EVENT);

    if(trunk_ext_port_info[trunk_id-1].member_number == 0)
    {
#if (SYS_CPNT_INGRESS_RATE_LIMIT == TRUE)
        if (port_info[trunk_ifindex-1].ingress_rate_limit_status == VAL_rlPortInputStatus_enabled)
        {
            SWDRV_DisablePortIngressRateLimit(1, 1, trunk_id);
        }
#endif

        SWCTRL_Notify_TrunkMemberDeleteLst( trunk_ifindex, tm_ifindex);
    }
    else
        SWCTRL_Notify_TrunkMemberDelete (trunk_ifindex, tm_ifindex);

    if ((TRUE == is_trunk_forwarding_originally) &&
        SWCTRL_OPER_IS_LINK_UP(original_trk_mem_link_oper_status))
    {
        /* trunk is forwarding and trunk is link up, then this is forwarding trunk member.
         */
        SWCTRL_Notify_ForwardingTrunkMemberDelete(trunk_ifindex, tm_ifindex);
    }

    SWCTRL_LOCK();

#if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION == TRUE)
#if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE == SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE_MULTIPLE_SESSION)
    if (retval == TRUE)
    {
        /* erase trunk id to port index when pvlan isn't configuration */
        if ((swctl_private_vlan_port_info[tm_ifindex-1].session_id == 0x0) &&
            (swctl_private_vlan_port_info[trunk_ifindex-1].session_id == 0x0))
        {
            /* set port trunk index */
            if (FALSE == swctl_private_vlan_port_info[tm_ifindex-1].is_pvlan_trunk_index_port)
            {
                swctl_private_vlan_port_info[tm_ifindex-1].port_trunk_index = 0x0;
            }
        }
        else
        {
            /* if trunk index port has pvlan then remove member port(s) to group */
            SWCTRL_DeletePrivateVlanTrunkMember(trunk_ifindex, tm_ifindex);
        }
    }
#endif /* End of #if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE == SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE_MULTIPLE_SESSION)*/
#endif /* End of #if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION == TRUE) */

   /* Upate storm granularity.
    * Because maybe the removed trunk member that is higher granularity.
    */
   {
       SWCTRL_TrunkPortExtInfo_T trunk_ext_p_info;
       UI32_T      get_ifindex,  i, tmp_granularity=0;

       memset(&trunk_ext_p_info, 0, sizeof(SWCTRL_TrunkPortExtInfo_T));
       SWCTRL_GetTrunkPortExtInfo (trunk_ifindex, &trunk_ext_p_info);

       for(i=0; i<trunk_ext_p_info.member_number; i++)
       {
            get_ifindex=SWCTRL_UPORT_TO_IFINDEX(trunk_ext_p_info.member_list[i].unit, trunk_ext_p_info.member_list[i].port);
            if(tmp_granularity<port_info[get_ifindex-1].storm_granularity)
            {
                tmp_granularity=port_info[get_ifindex-1].storm_granularity;
            }
       } /* End of for () */
       port_info[trunk_ifindex-1].storm_granularity=tmp_granularity;
    }

    if (retval)
    {
        SWCTRL_UpdateTrunkEgressBlock(trunk_ifindex);
    }

#if (SYS_CPNT_SWCTRL_SWITCH_MODE_CONFIGURABLE == TRUE)
    /* Set switching mode to default when remove the port from trunk
     * Now trunks don't support Cut-Through switching mode
     */
    if (port_info[tm_ifindex-1].port_entry.switch_mode != SYS_DFLT_SWCTRL_SWITCH_MODE)
    {
        if (TRUE != SWDRV_SetSwitchingMode(unit_port.unit, unit_port.port, SYS_DFLT_SWCTRL_SWITCH_MODE))
        {
            SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
        }
        port_info[tm_ifindex-1].port_entry.switch_mode = SYS_DFLT_SWCTRL_SWITCH_MODE;
    }
#endif /*#if (SYS_CPNT_SWCTRL_SWITCH_MODE_CONFIGURABLE == TRUE)*/


    SWCTRL_UNLOCK();
    SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME ();
    SWCTRL_RETURN_AND_RELEASE_CSC( retval );
} /* End of SWCTRL_DeleteTrunkMember() */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetTrunkStatus
 * -------------------------------------------------------------------------
 * FUNCTION: This function will enable/disable a specific trunk
 * INPUT   : trunk_id     -- which trunking port to enable
 *           trunk_status -- VAL_trunkStatus_valid / VAL_trunkStatus_invalid
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : ES3626A-MIB
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetTrunkStatus(UI32_T trunk_id, UI32_T trunk_status)
{
    BOOL_T retval = FALSE;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if((trunk_id < 1) || (trunk_id > SYS_ADPT_MAX_NBR_OF_TRUNK_PER_SYSTEM))
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Trunk ID (1-%d)", SYS_ADPT_MAX_NBR_OF_TRUNK_PER_SYSTEM);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);   /*SWCTRL_ENO_OUT_OF_RANGE_TRUNK_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if(!SWCTRL_IS_EXIST (SWCTRL_TRUNKID_TO_IFINDEX (trunk_id)))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Trunk");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if((trunk_status != VAL_trunkStatus_valid)&&
       (trunk_status != VAL_trunkStatus_invalid))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_INVALID_PARAMETER,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "trunk state");   /*SWCTRL_ENO_INVALID_TRUNK_STATE*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }


    SWCTRL_LOCK();
    switch (trunk_status)
    {
        case VAL_trunkStatus_valid:
            retval = SWCTRL_SetTrunkPorts(trunk_id,
                                         trunk_ext_port_info[trunk_id-1].member_number,
                                         trunk_ext_port_info[trunk_id-1].member_list);
            break;
        case VAL_trunkStatus_invalid:
            retval = SWCTRL_SetTrunkPorts(trunk_id,
                                         0,
                                         trunk_ext_port_info[trunk_id-1].member_list);
            break;
    }
    SWCTRL_UNLOCK();

    SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME ();
    SWCTRL_RETURN_AND_RELEASE_CSC( retval );
} /* End of SWCTRL_SetTrunkStatus() */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetActiveTrunkMember
 * -------------------------------------------------------------------------
 * FUNCTION: This function will get trunk members which are active
 * INPUT   : trunk_ifindex      -- which interface index
 * OUTPUT  : active_lportarray   -- the active trunk member port array
 *           active_lport_count -- the number of active trunk member
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_GetActiveTrunkMember(
        UI32_T        trunk_ifindex,
        UI32_T         active_lportarray[SYS_ADPT_MAX_NBR_OF_PORT_PER_TRUNK],
        UI32_T        *active_lport_count)
{
    UI32_T trunk_id, i, unit, port, count = 0;
    UI32_T member_ifindex;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (active_lportarray == 0 || active_lport_count == 0)
    {
        EH_MGR_Handle_Exception (SYS_MODULE_SWCTRL,
                                 SWCTRL_NO_USE_FUNC_NO,
                                 EH_TYPE_MSG_NULL_POINTER,
                                 EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_CRIT); /*SWCTRL_ENO_NULL_POINTER*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    *active_lport_count = 0;

    if (!SWCTRL_IS_TRUNK (trunk_ifindex))
    {
        EH_MGR_Handle_Exception (SYS_MODULE_SWCTRL,
                                 SWCTRL_NO_USE_FUNC_NO,
                                 EH_TYPE_MSG_INTERF_NOT_A_TRUNK,
                                 SYSLOG_LEVEL_INFO);  /*SWCTRL_ENO_INVALID_TRUNK_IF_INDEX*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (!SWCTRL_IS_EXIST (trunk_ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Trunk");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    trunk_id = SWCTRL_IFINDEX_TO_TRUNKID (trunk_ifindex);

    for(i=0; i<trunk_ext_port_info[trunk_id-1].member_number; i++)
    {
        unit = trunk_ext_port_info[trunk_id-1].member_list[i].unit;
        port = trunk_ext_port_info[trunk_id-1].member_list[i].port;

        member_ifindex = SWCTRL_UPORT_TO_IFINDEX(unit, port);

        if (!SWCTRL_IS_USER_PORT(member_ifindex))
        {
            break;
        }

        if (SWCTRL_IS_OPER_ACTIVE_TRUNK_MEMBER(trunk_id, SWCTRL_UPORT_TO_IFINDEX(unit, port)))
        {
            active_lportarray[count++] = SWCTRL_UPORT_TO_IFINDEX(unit, port);
        }
    }
    *active_lport_count = count;

    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
}/* End of SWCTRL_GetActiveTrunkMember () */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetTrunkPortExtInfo
 * -------------------------------------------------------------------------
 * FUNCTION: This function will get trunk information
 * INPUT   : ifindex               -- which interface index
 * OUTPUT  : trunk_port_ext_info   -- trunk information
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : only for TRK_MGR
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_GetTrunkPortExtInfo(UI32_T                       ifindex,
                                  SWCTRL_TrunkPortExtInfo_T *trunk_port_ext_info)
{
    UI32_T trunk_id;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    /*This ifindex is not belong to trunk
     */
    if(!SWCTRL_IS_TRUNK(ifindex))
    {
        EH_MGR_Handle_Exception (SYS_MODULE_SWCTRL,
                                 SWCTRL_NO_USE_FUNC_NO,
                                 EH_TYPE_MSG_INTERF_NOT_A_TRUNK,
                                 SYSLOG_LEVEL_INFO);  /*SWCTRL_ENO_NOT_TRUNK*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

     /*don't check*/
    /*This ifindex is belong to trunk, but not be created yet
     */
    /*if(!SWCTRL_IS_EXIST(ifindex))
        return FALSE;
     */

    trunk_id = SWCTRL_IFINDEX_TO_TRUNKID (ifindex);
    memcpy (trunk_port_ext_info, &trunk_ext_port_info[trunk_id-1], sizeof (SWCTRL_TrunkPortExtInfo_T));
    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
}


/* Kelly_Chen, 12/14/01, 11:10:44 new load balance function*/
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_L2LoadBalance
 * -------------------------------------------------------------------------
 * FUNCTION: This function will get the load balance trunk member port
 * INPUT   : mac                -- mac address
 *           trunk_ifindex      -- which interface index
 *           algorithm          -- algoritem
 * OUTPUT  : trunk_member_ifindex -- the selected trunk member port
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_L2LoadBalance(UI8_T *mac, UI32_T trunk_ifindex, UI32_T algorithm, UI32_T *trunk_member_ifindex)
{
    UI32_T i, port_count, key, ip[4], mip;
    UI32_T active_lportlist[SYS_ADPT_MAX_NBR_OF_PORT_PER_TRUNK];

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (mac == 0)
    {
        EH_MGR_Handle_Exception (SYS_MODULE_SWCTRL,
                                 SWCTRL_NO_USE_FUNC_NO,
                                 EH_TYPE_MSG_NULL_POINTER,
                                 EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_CRIT); /*SWCTRL_ENO_NULL_POINTER*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if(SWCTRL_GetActiveTrunkMember(trunk_ifindex, active_lportlist, &port_count)==FALSE)
    {
        *trunk_member_ifindex = 0;
        /*set error code in SWCTRL_GetActiveTrunkMember();*/
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
    else
    {
        for(i=0; i<=3; i++)
        {
            ip[i] = mac[5-i];
        }
        mip = ip[0] | ip[1]<<8 | ip[2]<<16 | ip[3]<<24;
        key = L_MATH_SelectBalancePort(mip, port_count, algorithm);
        if(key == INVALID_ACTIVE_PORT_NUMBER)
        {
            /* something wrong */
            *trunk_member_ifindex = 0;
            SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
        }
        *trunk_member_ifindex = active_lportlist[key];

        SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
    }
} /* end of SWCTRL_L2LoadBalance () */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetTrunkBalanceMode
 * -------------------------------------------------------------------------
 * FUNCTION: This function will set the balance mode of trunking
 * INPUT   : balance_mode
 * OUTPUT  : None
 * RETURN  : True: Successfully, False: If not available
 * NOTE    : balance_mode:
 *           SWCTRL_TRUNK_BALANCE_MODE_MAC_SA      Determinded by source mac address
 *           SWCTRL_TRUNK_BALANCE_MODE_MAC_DA      Determinded by destination mac address
 *           SWCTRL_TRUNK_BALANCE_MODE_MAC_SA_DA   Determinded by source and destination mac address
 *           SWCTRL_TRUNK_BALANCE_MODE_IP_SA       Determinded by source IP address
 *           SWCTRL_TRUNK_BALANCE_MODE_IP_DA       Determinded by destination IP address
 *           SWCTRL_TRUNK_BALANCE_MODE_IP_SA_DA    Determinded by source and destination IP address
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetTrunkBalanceMode(UI32_T balance_mode)
{
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (balance_mode != SWCTRL_TRUNK_BALANCE_MODE_MAC_SA &&
        balance_mode != SWCTRL_TRUNK_BALANCE_MODE_MAC_DA &&
        balance_mode != SWCTRL_TRUNK_BALANCE_MODE_MAC_SA_DA &&
        balance_mode != SWCTRL_TRUNK_BALANCE_MODE_IP_SA &&
        balance_mode != SWCTRL_TRUNK_BALANCE_MODE_IP_DA &&
        balance_mode != SWCTRL_TRUNK_BALANCE_MODE_IP_SA_DA)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
    }

    SWCTRL_LOCK();

    if (system_info.trunk_balance_mode == balance_mode)
    {
        SWCTRL_UNLOCK();
        SWCTRL_RETURN_AND_RELEASE_CSC(TRUE);
    }

    if (!SWDRV_SetTrunkBalanceMode(balance_mode))
    {
        SWCTRL_UNLOCK();
        SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
    }

    system_info.trunk_balance_mode = balance_mode;

    SWCTRL_UNLOCK();
    SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME();
    SWCTRL_RETURN_AND_RELEASE_CSC(TRUE);
}


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetTrunkBalanceMode
 * -------------------------------------------------------------------------
 * FUNCTION: This function will get the balance mode of trunking
 * INPUT   : None
 * OUTPUT  : balance_mode
 * RETURN  : True: Successfully, False: If not available
 * NOTE    : balance_mode:
 *           SWCTRL_TRUNK_BALANCE_MODE_MAC_SA      Determinded by source mac address
 *           SWCTRL_TRUNK_BALANCE_MODE_MAC_DA      Determinded by destination mac address
 *           SWCTRL_TRUNK_BALANCE_MODE_MAC_SA_DA   Determinded by source and destination mac address
 *           SWCTRL_TRUNK_BALANCE_MODE_IP_SA       Determinded by source IP address
 *           SWCTRL_TRUNK_BALANCE_MODE_IP_DA       Determinded by destination IP address
 *           SWCTRL_TRUNK_BALANCE_MODE_IP_SA_DA    Determinded by source and destination IP address
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_GetTrunkBalanceMode(UI32_T *balance_mode_p)
{
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (balance_mode_p == NULL)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
    }

    SWCTRL_LOCK();
    *balance_mode_p = system_info.trunk_balance_mode;
    SWCTRL_UNLOCK();
    SWCTRL_RETURN_AND_RELEASE_CSC(TRUE);
}


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetRunningTrunkBalanceMode
 * -------------------------------------------------------------------------
 * FUNCTION: This function will get the balance mode of trunking
 * INPUT   : None
 * OUTPUT  : balance_mode
 * RETURN  : SYS_TYPE_Get_Running_Cfg_T
 * NOTE    : balance_mode:
 *           SWCTRL_TRUNK_BALANCE_MODE_MAC_SA      Determinded by source mac address
 *           SWCTRL_TRUNK_BALANCE_MODE_MAC_DA      Determinded by destination mac address
 *           SWCTRL_TRUNK_BALANCE_MODE_MAC_SA_DA   Determinded by source and destination mac address
 *           SWCTRL_TRUNK_BALANCE_MODE_IP_SA       Determinded by source IP address
 *           SWCTRL_TRUNK_BALANCE_MODE_IP_DA       Determinded by destination IP address
 *           SWCTRL_TRUNK_BALANCE_MODE_IP_SA_DA    Determinded by source and destination IP address
 * -------------------------------------------------------------------------*/
SYS_TYPE_Get_Running_Cfg_T SWCTRL_GetRunningTrunkBalanceMode(UI32_T *balance_mode_p)
{
    SWCTRL_USE_CSC_CHECK_OPER_MODE( SYS_TYPE_GET_RUNNING_CFG_FAIL );

    SWCTRL_LOCK();
    *balance_mode_p = system_info.trunk_balance_mode;
    SWCTRL_UNLOCK();

    if ( *balance_mode_p != SYS_DFLT_TRUNK_BALANCE_MODE )
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_SUCCESS );
    }
    else
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_NO_CHANGE );
    }
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetTrunkMaxNumOfActivePorts
 * -------------------------------------------------------------------------
 * FUNCTION: This function will set max number of active ports of trunk
 * INPUT   : trunk_id
 *           max_num_of_active_ports
 * OUTPUT  : None
 * RETURN  : True: Successfully, False: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetTrunkMaxNumOfActivePorts(UI32_T trunk_id, UI32_T max_num_of_active_ports)
{
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if((trunk_id < 1) || (trunk_id > SYS_ADPT_MAX_NBR_OF_TRUNK_PER_SYSTEM))
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Trunk ID (1-%d)", SYS_ADPT_MAX_NBR_OF_TRUNK_PER_SYSTEM);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);   /*SWCTRL_ENO_OUT_OF_RANGE_TRUNK_ID*/

#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if((max_num_of_active_ports < 1) || (max_num_of_active_ports > SYS_ADPT_MAX_NBR_OF_PORT_PER_TRUNK))
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Number of active ports (1-%d)", SYS_ADPT_MAX_NBR_OF_PORT_PER_TRUNK);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);

#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (trunk_ext_port_info[trunk_id-1].max_num_of_active_ports == max_num_of_active_ports)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC(TRUE);
    }

    SWCTRL_LOCK();

    trunk_ext_port_info[trunk_id-1].max_num_of_active_ports = max_num_of_active_ports;

    SWCTRL_SetTrunkPorts(trunk_id, trunk_ext_port_info[trunk_id-1].member_number, trunk_ext_port_info[trunk_id-1].member_list);

    SWCTRL_UNLOCK();
    SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME();
    SWCTRL_RETURN_AND_RELEASE_CSC(TRUE);
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetTrunkMaxNumOfActivePorts
 * -------------------------------------------------------------------------
 * FUNCTION: This function will set max number of active ports of trunk
 * INPUT   : trunk_id
 * OUTPUT  : max_num_of_active_ports_p
 * RETURN  : True: Successfully, False: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_GetTrunkMaxNumOfActivePorts(UI32_T trunk_id, UI32_T *max_num_of_active_ports_p)
{
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if((trunk_id < 1) || (trunk_id > SYS_ADPT_MAX_NBR_OF_TRUNK_PER_SYSTEM))
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Trunk ID (1-%d)", SYS_ADPT_MAX_NBR_OF_TRUNK_PER_SYSTEM);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);   /*SWCTRL_ENO_OUT_OF_RANGE_TRUNK_ID*/

#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    SWCTRL_LOCK();

    *max_num_of_active_ports_p = trunk_ext_port_info[trunk_id-1].max_num_of_active_ports;

    SWCTRL_UNLOCK();

    SWCTRL_RETURN_AND_RELEASE_CSC(TRUE);
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetRunningTrunkMaxNumOfActivePorts
 * -------------------------------------------------------------------------
 * FUNCTION: This function will set max number of active ports of trunk
 * INPUT   : trunk_id
 * OUTPUT  : max_num_of_active_ports_p
 * RETURN  : True: Successfully, False: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
SYS_TYPE_Get_Running_Cfg_T SWCTRL_GetRunningTrunkMaxNumOfActivePorts(UI32_T trunk_id, UI32_T *max_num_of_active_ports_p)
{
    SWCTRL_USE_CSC_CHECK_OPER_MODE(SYS_TYPE_GET_RUNNING_CFG_FAIL);

    if((trunk_id < 1) || (trunk_id > SYS_ADPT_MAX_NBR_OF_TRUNK_PER_SYSTEM))
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Trunk ID (1-%d)", SYS_ADPT_MAX_NBR_OF_TRUNK_PER_SYSTEM);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);   /*SWCTRL_ENO_OUT_OF_RANGE_TRUNK_ID*/

#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_FAIL );
    }

    SWCTRL_LOCK();

    *max_num_of_active_ports_p = trunk_ext_port_info[trunk_id-1].max_num_of_active_ports;

    SWCTRL_UNLOCK();

    if (*max_num_of_active_ports_p != SYS_ADPT_MAX_NBR_OF_PORT_PER_TRUNK)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_SUCCESS );
    }
    else
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_NO_CHANGE );
    }
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetTrunkMemberActiveStatus
 * -------------------------------------------------------------------------
 * FUNCTION: This function will add a members to a trunk
 * INPUT   : trunk_id   -- which trunking port to set
 *           unit_port  -- member to add
 *           is_active  -- active or inactive member
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetTrunkMemberActiveStatus(UI32_T trunk_id, SYS_TYPE_Uport_T unit_port, BOOL_T is_active)
{
    UI32_T ifindex;
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (trunk_id < 1 || trunk_id > SYS_ADPT_MAX_NBR_OF_TRUNK_PER_SYSTEM)
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Trunk ID (1-%d)", SYS_ADPT_MAX_NBR_OF_TRUNK_PER_SYSTEM);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);   /*SWCTRL_ENO_OUT_OF_RANGE_TRUNK_ID*/

#endif
        SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
    }

    ifindex = SWCTRL_UPORT_TO_IFINDEX(unit_port.unit, unit_port.port);

    if (!SWCTRL_IS_USER_PORT(ifindex) || !SWCTRL_IS_EXIST(ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Interface.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/
        SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
    }

    if (port_info[(ifindex)-1].port_entry.port_trunk_index != trunk_id)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
    }

    if (SWCTRL_IS_ADMIN_ACTIVE_TRUNK_MEMBER(trunk_id, ifindex) == is_active)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC(TRUE);
    }

    if (!SWCTRL_CheckUserPortJoinTrunkValidation(trunk_id, unit_port, TRUE, is_active))
    {
        SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
    }

    SWCTRL_LOCK();

    SWCTRL_SET_TRUNK_MEMBER_ADMIN_ACTIVE(trunk_id, ifindex, is_active);

    SWCTRL_SetTrunkPorts(trunk_id, trunk_ext_port_info[trunk_id-1].member_number, trunk_ext_port_info[trunk_id-1].member_list);

    SWCTRL_UNLOCK();
    SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME();
    SWCTRL_RETURN_AND_RELEASE_CSC(TRUE);
}



/****************************************************************************/
/* IGMP                                                                     */
/****************************************************************************/
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_EnableIgmpTrap
 * -------------------------------------------------------------------------
 * FUNCTION: This function will enable the IGMP function
 * INPUT   : None
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : RFC2933/igmpInterfaceStatus
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_EnableIgmpTrap(SWCTRL_TrapPktOwner_T owner)
{
    return SWCTRL_SetPktTrapStatus(SWCTRL_PKTTYPE_IGMP, owner, TRUE, TRUE);
} /* End of SWCTRL_EnableIgmpTrap() */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_DisableIgmpTrap
 * -------------------------------------------------------------------------
 * FUNCTION: This function will disable the IGMP function
 * INPUT   : None
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_DisableIgmpTrap(SWCTRL_TrapPktOwner_T owner)
{
    return SWCTRL_SetPktTrapStatus(SWCTRL_PKTTYPE_IGMP, owner, FALSE, FALSE);
} /* End of SWCTRL_DisableIgmpTrap() */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetUnknownIPMcastFwdPortList
 * -------------------------------------------------------------------------
 * FUNCTION: Set the unknown multicast packet forwarding-to port list.
 * INPUT   : port_list  - on which the multicast packets allow to forward-to
 * OUTPUT  : none
 * RETURN  : TRUE/FALSE
 * NOTE    : To determine which ports are allow to forward the unknow IPMC
 *           packets.
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetUnknownIPMcastFwdPortList(UI8_T port_list[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST])
{
    UI8_T  system_uport_list[SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK*SYS_ADPT_NBR_OF_BYTE_FOR_1BIT_UPORT_LIST];
    UI8_T  uport_list[SYS_ADPT_NBR_OF_BYTE_FOR_1BIT_UPORT_LIST];
    UI32_T unit;
    UI32_T port;
    UI32_T ifindex;

    /* BODY
     */
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (port_list == 0)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    memset (system_uport_list, 0, SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK*SYS_ADPT_NBR_OF_BYTE_FOR_1BIT_UPORT_LIST);

    ifindex = 0;
    while (SWCTRL_GetNextIndexFromPortList (&ifindex, port_list))
    {
        /* continue if this port is not exist
         */
        if (!SWCTRL_IS_EXIST (ifindex))
            continue;

        /* continue if the port is a trunk member
         */
        if (SWCTRL_IS_TRUNK_MEMBER (ifindex))
            continue;

        /* the ifindex is normal port
         */
        if(!SWCTRL_IS_TRUNK (ifindex))
        {
            unit = SWCTRL_IFINDEX_TO_UNIT(ifindex);
            port = SWCTRL_IFINDEX_TO_PORT(ifindex);

            system_uport_list[(SYS_ADPT_NBR_OF_BYTE_FOR_1BIT_UPORT_LIST*(unit-1)+((port-1) / 8))]
                                                                    |= ((0x01) << (7 - ((port - 1) % 8)));
        }

        /* the ifindex is trunk port
         */
        if(SWCTRL_IS_TRUNK (ifindex))
        {
            SWCTRL_TrunkPortExtInfo_T trunk_ext_p_info;
            UI32_T                    i;

            SWCTRL_GetTrunkPortExtInfo (ifindex, &trunk_ext_p_info);
            for(i = 0; i < trunk_ext_p_info.member_number; i++)
            {
                unit = (UI32_T) trunk_ext_p_info.member_list[i].unit;
                port = (UI32_T) trunk_ext_p_info.member_list[i].port;

                system_uport_list[(SYS_ADPT_NBR_OF_BYTE_FOR_1BIT_UPORT_LIST*(unit-1)+((port-1) / 8))]
                                                                        |= ((0x01) << (7 - ((port - 1) % 8)));
            } /* End of for () */
        } /* End of if () */
    } /* End of while () */

    for (unit = 1; unit <= SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK; unit++)
    {
        if (!STKTPLG_POM_UnitExist (unit))
            continue;
        memcpy( uport_list,
               &system_uport_list[((unit-1)*SYS_ADPT_NBR_OF_BYTE_FOR_1BIT_UPORT_LIST)],
                SYS_ADPT_NBR_OF_BYTE_FOR_1BIT_UPORT_LIST);
        if (!SWDRV_SetUnknownIPMcastFwdPortList (unit, uport_list))
        { /* upper layer is necessary to rollback to original setting, if failed to set to chip */
            SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
        }
    }

    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );

} /* End of SWCTRL_SetUnknownIPMcastFwdPortList() */



/****************************************************************************/
/* Broadcast/Multicast Storm Control                                        */
/****************************************************************************/
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetBStormControlRateLimit
 * -------------------------------------------------------------------------
 * FUNCTION: This function will set the rate limit of broadcast
 *           storm control function
 * INPUT   : ifindex -- which port to set
 *           mode    -- which mode of rate
 *           nRate   -- rate of broadcast amount
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetBStormControlRateLimit(UI32_T ifindex,
                                        UI32_T mode,
                                        UI32_T nRate)
{
    UI32_T                          unit, port, rate;
    BOOL_T                          retval = FALSE;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

#if (SYS_CPNT_SWCTRL_GLOBAL_STORM_SAMPLE_TYPE == TRUE)
    mode = swctrl_global_storm_sample_type;
#endif

    /* check mode
     */
#if (defined(STRATA_SWITCH) || defined(ALLAYER_SWITCH) || defined(XGS_SWITCH))
    if (mode != VAL_bcastStormSampleType_pkt_rate)
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_INVALID_PARAMETER,
                                  SYSLOG_LEVEL_INFO,
                                  "Sample Type for Broadcast Storm Control"); /*SWCTRL_ENO_INVALID_BSTM_CTRL_TYPE*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#endif

    /* check amount
     */
#if defined(ALLAYER_SWITCH)
    if ((nRate != 16) && (nRate != 64) && (nRate != 128) && (nRate != 256))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_INVALID,
                                  SYSLOG_LEVEL_INFO,
                                  "Broadcast Storm Control rate"); /*SWCTRL_ENO_INVALID_BSTM_CTRL_RATE*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#else
    if ((nRate < SYS_ADPT_MIN_BSTORM_RATE_LIMIT) ||
        (nRate > SYS_ADPT_MAX_BSTORM_RATE_LIMIT))
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[64] = {0};

        sprintf(buff, "Broadcast Storm Control rate (%d-%d)",
                      SYS_ADPT_MIN_BSTORM_RATE_LIMIT,
                      SYS_ADPT_MAX_BSTORM_RATE_LIMIT);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_LOGICAL_PORT_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#endif

    if( ifindex == 0 || ifindex > SYS_ADPT_TOTAL_NBR_OF_LPORT)
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Logical Port ID (1-%d)", SYS_ADPT_TOTAL_NBR_OF_LPORT);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_LOGICAL_PORT_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (!SWCTRL_IS_EXIST (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Interface");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (SWCTRL_IsServerBladePort (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_SRV_BLADE_PORT_CNFG,
                                  SYSLOG_LEVEL_INFO,
                                  "Configuring Broadcast Rate Limit");     /*SWCTRL_ENO_DENY_ON_SERVER_BLADE_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

#if (SYS_CPNT_SWCTRL_STORM_GRANULARITY_VALIDATION==TRUE)
    if(mode != VAL_bcastStormSampleType_percent)
    {
        if(port_info[ifindex-1].storm_granularity > SWCTRL_STORM_GRANULARITY_VALIDATION_MIN)
        {
            if(nRate % port_info[ifindex-1].storm_granularity)
            {
                SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
            }
        }
    }
#endif /* End of #if (SYS_CPNT_SWCTRL_STORM_GRANULARITY_VALIDATION==TRUE) */
    if(mode == VAL_bcastStormSampleType_pkt_rate)
        rate = nRate;
    else if(mode == VAL_bcastStormSampleType_octet_rate)
    {
        #ifdef SYS_ADPT_PACKETCELL_INTERVAL
        rate = nRate / SYS_ADPT_PACKETCELL_INTERVAL * SYS_ADPT_PACKETCELL_INTERVAL;
        #else
        /* Because the limit is base on packet/sec,
         * we assume there are 500 byte/packet,
         * and get the rate from byte/sec.
         */
        rate = nRate / 500;
        #endif
    }
    else if(mode == VAL_bcastStormSampleType_percent)
    {
        if(nRate > 100)
        {
#if (SYS_CPNT_EH == TRUE)
            UI8_T buff[64] = {0};

            sprintf(buff, "Broadcast Storm Control rate (0-%d)", 100);

            EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                      SWCTRL_NO_USE_FUNC_NO,
                                      EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                      SYSLOG_LEVEL_INFO,
                                      buff);/*SWCTRL_ENO_INVALID_BSTM_CTRL_RATE*/
#endif

            SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
        }

        #ifdef SYS_ADPT_PACKETCELL_INTERVAL
        if(SWCTRL_IS_100TX (ifindex) || SWCTRL_IS_100FIBER (ifindex))
        {
            rate = SWCTRL_100MB_PORT_MAX_RATE / SYS_ADPT_PACKETCELL_INTERVAL * nRate / 100;
        }
        else if(SWCTRL_IS_1000T (ifindex) ||SWCTRL_IS_1000FIBER (ifindex))
        {
            rate = SWCTRL_1GB_PORT_MAX_RATE / SYS_ADPT_PACKETCELL_INTERVAL * nRate / 100;
        }
        else if (SWCTRL_IS_10GSFP(ifindex) || SWCTRL_IS_10GCOPPER(ifindex))
        {
            rate = SWCTRL_10GB_PORT_MAX_RATE / SYS_ADPT_PACKETCELL_INTERVAL * nRate / 100;
        }
        else /* 40G */
        {
            rate = SWCTRL_40GB_PORT_MAX_RATE / SYS_ADPT_PACKETCELL_INTERVAL * nRate / 100;
        }
        #else
        if(SWCTRL_IS_100TX (ifindex) || SWCTRL_IS_100FIBER (ifindex))
        {
            rate = 100000000 / 8 / 500 * nRate / 100;
        }
        else if(SWCTRL_IS_1000T (ifindex) ||SWCTRL_IS_1000FIBER (ifindex))
        {
            rate = 1000000000 / 8 / 500 * nRate / 100;
        }
        else /* 10G */
        {
            rate = 2500000 * nRate / 100;
        }
        #endif
    }
    else
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_INVALID_PARAMETER,
                                  SYSLOG_LEVEL_INFO,
                                  "Sample Type for Broadcast Storm Control"); /*SWCTRL_ENO_INVALID_BSTM_CTRL_TYPE*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

#if (SYS_CPNT_BSTORM_SUPPORT_LPORT == TRUE)
    if (SWCTRL_IS_TRUNK_MEMBER (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#endif

    /* if normal port & trunk port can setting
     */
    if(!SWCTRL_IS_TRUNK (ifindex))
    {
        unit = SWCTRL_IFINDEX_TO_UNIT(ifindex);
        port = SWCTRL_IFINDEX_TO_PORT(ifindex);

        retval = SWCTRL_SetUPortBStormControlRateLimit (unit, port, mode, rate, nRate);
    } /* End of normal port */

    /* if trunk port
     */
#if (SYS_CPNT_BSTORM_SUPPORT_LPORT == TRUE)
    if(SWCTRL_IS_TRUNK (ifindex))
    {
        SWCTRL_TrunkPortExtInfo_T trunk_ext_p_info;
        UI32_T                    i;

        memset(&trunk_ext_p_info, 0, sizeof(SWCTRL_TrunkPortExtInfo_T));
        SWCTRL_GetTrunkPortExtInfo (ifindex, &trunk_ext_p_info);

        for(i=0; i<trunk_ext_p_info.member_number; i++)
        {
            unit = trunk_ext_p_info.member_list[i].unit;
            port = trunk_ext_p_info.member_list[i].port;

            if (!(retval = SWCTRL_SetUPortBStormControlRateLimit(unit, port, mode, rate, nRate)))
                break;
        } /* End of for () */
        if (retval)
        {
            SWCTRL_LOCK();
            port_info[ifindex-1].bcast_storm_entry.bcast_storm_ifindex = ifindex;
            port_info[ifindex-1].bcast_storm_entry.bcast_storm_sample_type = mode;
            port_info[ifindex-1].bcast_storm_entry.bcast_storm_pkt_rate   = 0;
            port_info[ifindex-1].bcast_storm_entry.bcast_storm_octet_rate = 0;
            port_info[ifindex-1].bcast_storm_entry.bcast_storm_percent    = 0;
            switch (mode)
            {
                case VAL_bcastStormSampleType_pkt_rate:
                port_info[ifindex-1].bcast_storm_entry.bcast_storm_pkt_rate = nRate;
                break;
                case VAL_bcastStormSampleType_octet_rate:
                port_info[ifindex-1].bcast_storm_entry.bcast_storm_octet_rate = nRate;
                break;
                case VAL_bcastStormSampleType_percent:
                port_info[ifindex-1].bcast_storm_entry.bcast_storm_percent = nRate;
                break;
            }
            SWCTRL_UNLOCK();
        }
    } /* End of trunk port */
#endif /* End of (SYS_CPNT_BSTORM_SUPPORT_LPORT == TRUE) */

#if (SYS_CPNT_SWCTRL_SINGLE_INGRESS_RATE_LIMIT == TRUE)
    if (retval)
    {
        retval = SWCTRL_SyncRateLimitThreshold(ifindex, mode, rate, nRate, SYS_CPNT_SWCTRL_RATE_LIMIT_GROUP_FOR_BSTORM);
    }
#endif

    SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME ();
    SWCTRL_RETURN_AND_RELEASE_CSC( retval );
} /* End of SWCTRL_SetBStormControlRateLimit() */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetMStormControlRateLimit
 * -------------------------------------------------------------------------
 * FUNCTION: This function will set the rate limit of multicast
 *           storm control function
 * INPUT   : ifindex -- which port to set
 *           mode    -- which mode of rate
 *           nRate   -- rate of multicast amount
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetMStormControlRateLimit(UI32_T ifindex,
                                        UI32_T mode,
                                        UI32_T nRate)
{
    UI32_T                          unit, port, rate;
    BOOL_T                          retval = FALSE;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

#if (SYS_CPNT_SWCTRL_GLOBAL_STORM_SAMPLE_TYPE == TRUE)
    mode = swctrl_global_storm_sample_type;
#endif

    /* check mode
     */
#if (defined(STRATA_SWITCH) || defined(ALLAYER_SWITCH) || defined(ALPS))
    if (mode != VAL_mcastStormSampleType_pkt_rate)
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_INVALID_PARAMETER,
                                  SYSLOG_LEVEL_INFO,
                                  "Sample Type for Multicast Storm Control"); /*SWCTRL_ENO_INVALID_BSTM_CTRL_TYPE*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#endif

    /* check amount
     */
#if defined(ALLAYER_SWITCH)
    if ((nRate != 16) && (nRate != 64) && (nRate != 128) && (nRate != 256))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_INVALID,
                                  SYSLOG_LEVEL_INFO,
                                  "Multicast Storm Control rate"); /*SWCTRL_ENO_INVALID_BSTM_CTRL_RATE*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#else
    if ((nRate < SYS_ADPT_MIN_MSTORM_RATE_LIMIT) ||
        (nRate > SYS_ADPT_MAX_MSTORM_RATE_LIMIT))
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[64] = {0};

        sprintf(buff, "Multicast Storm Control rate (%d-%d)",
                      SYS_ADPT_MIN_MSTORM_RATE_LMIMIT,
                      SYS_ADPT_MAX_MSTORM_RATE_LMIMIT);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_LOGICAL_PORT_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#endif

    if( ifindex == 0 || ifindex > SYS_ADPT_TOTAL_NBR_OF_LPORT)
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Logical Port ID (1-%d)", SYS_ADPT_TOTAL_NBR_OF_LPORT);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_LOGICAL_PORT_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (!SWCTRL_IS_EXIST (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Interface");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (SWCTRL_IsServerBladePort (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_SRV_BLADE_PORT_CNFG,
                                  SYSLOG_LEVEL_INFO,
                                  "Configuring Multicast Rate Limit");     /*SWCTRL_ENO_DENY_ON_SERVER_BLADE_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#if (SYS_CPNT_SWCTRL_STORM_GRANULARITY_VALIDATION==TRUE)
    if(mode != VAL_mcastStormSampleType_percent)
    {
        if(port_info[ifindex-1].storm_granularity > SWCTRL_STORM_GRANULARITY_VALIDATION_MIN)
        {
            if(nRate % port_info[ifindex-1].storm_granularity)
            {
                SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
            }
        }
    }
#endif /* End of #if (SYS_CPNT_SWCTRL_STORM_GRANULARITY_VALIDATION==TRUE) */

    if(mode == VAL_mcastStormSampleType_pkt_rate)
        rate = nRate;
    else if(mode == VAL_mcastStormSampleType_octet_rate)
    {
        #ifdef SYS_ADPT_PACKETCELL_INTERVAL
        rate = nRate / SYS_ADPT_PACKETCELL_INTERVAL * SYS_ADPT_PACKETCELL_INTERVAL;
        #else
        /* Because the limit is base on packet/sec,
         * we assume there are 500 byte/packet,
         * and get the rate from byte/sec.
         */
        rate = nRate / 500;
        #endif
    }
    else if(mode == VAL_mcastStormSampleType_percent)
    {
        if(nRate > 100)
        {
#if (SYS_CPNT_EH == TRUE)
            UI8_T buff[64] = {0};

            sprintf(buff, "Multicast Storm Control rate (0-%d)", 100);

            EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                      SWCTRL_NO_USE_FUNC_NO,
                                      EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                      SYSLOG_LEVEL_INFO,
                                      buff);/*SWCTRL_ENO_INVALID_BSTM_CTRL_RATE*/
#endif

            SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
        }

        #ifdef SYS_ADPT_PACKETCELL_INTERVAL
        if(SWCTRL_IS_100TX (ifindex) || SWCTRL_IS_100FIBER (ifindex))
        {
            rate = SWCTRL_100MB_PORT_MAX_RATE / SYS_ADPT_PACKETCELL_INTERVAL * nRate / 100;
        }
        else if(SWCTRL_IS_1000T (ifindex) ||SWCTRL_IS_1000FIBER (ifindex))
        {
            rate = SWCTRL_1GB_PORT_MAX_RATE / SYS_ADPT_PACKETCELL_INTERVAL * nRate / 100;
        }
        else if (SWCTRL_IS_10GSFP(ifindex) || SWCTRL_IS_10GCOPPER(ifindex))
        {
            rate = SWCTRL_10GB_PORT_MAX_RATE / SYS_ADPT_PACKETCELL_INTERVAL * nRate / 100;
        }
        else /* 40G */
        {
            rate = SWCTRL_40GB_PORT_MAX_RATE / SYS_ADPT_PACKETCELL_INTERVAL * nRate / 100;
        }
        #else
        if(SWCTRL_IS_100TX (ifindex) || SWCTRL_IS_100FIBER (ifindex))
        {
            rate = 100000000 / 8 / 500 * nRate / 100;
        }
        else
        {
            rate = 1000000000 / 8 / 500 * nRate / 100;
        }
        #endif
    }
    else
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_INVALID_PARAMETER,
                                  SYSLOG_LEVEL_INFO,
                                  "Sample Type for Multicast Storm Control"); /*SWCTRL_ENO_INVALID_BSTM_CTRL_TYPE*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

#if (SYS_CPNT_MSTORM_SUPPORT_LPORT == TRUE)
    if (SWCTRL_IS_TRUNK_MEMBER (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#endif

    /* if normal port & trunk port can setting
     */
    if(!SWCTRL_IS_TRUNK (ifindex))
    {
        unit = SWCTRL_IFINDEX_TO_UNIT(ifindex);
        port = SWCTRL_IFINDEX_TO_PORT(ifindex);

        retval = SWCTRL_SetUPortMStormControlRateLimit (unit, port, mode, rate, nRate);
    } /* End of normal port */

    /* if trunk port
     */
#if (SYS_CPNT_MSTORM_SUPPORT_LPORT == TRUE)
    if(SWCTRL_IS_TRUNK (ifindex))
    {
        SWCTRL_TrunkPortExtInfo_T trunk_ext_p_info;
        UI32_T                    i;

        memset(&trunk_ext_p_info, 0, sizeof(SWCTRL_TrunkPortExtInfo_T));
        SWCTRL_GetTrunkPortExtInfo (ifindex, &trunk_ext_p_info);

        for(i=0; i<trunk_ext_p_info.member_number; i++)
        {
            unit = trunk_ext_p_info.member_list[i].unit;
            port = trunk_ext_p_info.member_list[i].port;

            if (!(retval = SWCTRL_SetUPortMStormControlRateLimit(unit, port, mode, rate, nRate)))
                break;
        } /* End of for () */
        if (retval)
        {
            SWCTRL_LOCK();
            port_info[ifindex-1].mcast_storm_entry.mcast_storm_ifindex = ifindex;
            port_info[ifindex-1].mcast_storm_entry.mcast_storm_sample_type = mode;
            port_info[ifindex-1].mcast_storm_entry.mcast_storm_pkt_rate   = 0;
            port_info[ifindex-1].mcast_storm_entry.mcast_storm_octet_rate = 0;
            port_info[ifindex-1].mcast_storm_entry.mcast_storm_percent    = 0;
            switch (mode)
            {
                case VAL_mcastStormSampleType_pkt_rate:
                port_info[ifindex-1].mcast_storm_entry.mcast_storm_pkt_rate = nRate;
                break;
                case VAL_mcastStormSampleType_octet_rate:
                port_info[ifindex-1].mcast_storm_entry.mcast_storm_octet_rate = nRate;
                break;
                case VAL_mcastStormSampleType_percent:
                port_info[ifindex-1].mcast_storm_entry.mcast_storm_percent = nRate;
                break;
            }
            SWCTRL_UNLOCK();
        }
    } /* End of trunk port */
#endif /* End of (SYS_CPNT_MSTORM_SUPPORT_LPORT == TRUE) */

#if (SYS_CPNT_SWCTRL_SINGLE_INGRESS_RATE_LIMIT == TRUE)
    if (retval)
    {
        retval = SWCTRL_SyncRateLimitThreshold(ifindex, mode, rate, nRate, SYS_CPNT_SWCTRL_RATE_LIMIT_GROUP_FOR_MSTORM);
    }
#endif

    SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME ();
    SWCTRL_RETURN_AND_RELEASE_CSC( retval );
} /* End of SWCTRL_SetMStormControlRateLimit() */


#if (SYS_CPNT_STORM_MODE & SYS_CPNT_STORM_UNKNOWN_USTORM)
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetUnknownUStormControlRateLimit
 * -------------------------------------------------------------------------
* FUNCTION: This function will set the rate limit of unknowunicast
 *           storm control function
 * INPUT   : ifindex -- which port to set
 *           mode    -- which mode of rate
 *           nRate   -- rate of unknowunicast amount
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetUnknownUStormControlRateLimit(UI32_T ifindex,
                                        UI32_T mode,
                                        UI32_T nRate)
{
    UI32_T                          unit, port, rate;
    BOOL_T                          retval = FALSE;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

#if (SYS_CPNT_SWCTRL_GLOBAL_STORM_SAMPLE_TYPE == TRUE)
    mode = swctrl_global_storm_sample_type;
#endif

    /* check mode
     */
    if (!SWCTRL_IsSupportedStormType(mode))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_INVALID_PARAMETER,
                                  SYSLOG_LEVEL_INFO,
                                  "Sample Type for Multicast Storm Control"); /*SWCTRL_ENO_INVALID_BSTM_CTRL_TYPE*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    /* check amount
     */
#if defined(ALLAYER_SWITCH)
    if ((nRate != 16) && (nRate != 64) && (nRate != 128) && (nRate != 256))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_INVALID,
                                  SYSLOG_LEVEL_INFO,
                                  "Unknown Unicast Storm Control rate"); /*SWCTRL_ENO_INVALID_BSTM_CTRL_RATE*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#else
    if ((nRate < SYS_ADPT_MIN_UNKNOWN_USTORM_RATE_LIMIT) ||
        (nRate > SYS_ADPT_MAX_UNKNOWN_USTORM_RATE_LIMIT))
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[64] = {0};

        sprintf(buff, "Unknown Unicast Storm Control rate (%d-%d)",
                      SYS_ADPT_MIN_UNKNOWN_USTORM_RATE_LIMIT,
                      SYS_ADPT_MAX_UNKNOWN_USTORM_RATE_LIMIT);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_LOGICAL_PORT_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#endif

    if( ifindex == 0 || ifindex > SYS_ADPT_TOTAL_NBR_OF_LPORT)
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Logical Port ID (1-%d)", SYS_ADPT_TOTAL_NBR_OF_LPORT);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_LOGICAL_PORT_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (!SWCTRL_IS_EXIST (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Interface");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (SWCTRL_IsServerBladePort (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_SRV_BLADE_PORT_CNFG,
                                  SYSLOG_LEVEL_INFO,
                                  "Configuring Unknown Unicast Rate Limit");     /*SWCTRL_ENO_DENY_ON_SERVER_BLADE_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#if (SYS_CPNT_SWCTRL_STORM_GRANULARITY_VALIDATION==TRUE)
    if(mode != VAL_unkucastStormSampleType_percent)
    {
        if(port_info[ifindex-1].storm_granularity > SWCTRL_STORM_GRANULARITY_VALIDATION_MIN)
        {
            if(nRate % port_info[ifindex-1].storm_granularity)
            {
                SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
            }
        }
    }
#endif /* End of #if (SYS_CPNT_SWCTRL_STORM_GRANULARITY_VALIDATION==TRUE) */

    if(mode == VAL_unkucastStormSampleType_pkt_rate)
        rate = nRate;
    else if(mode == VAL_unkucastStormSampleType_octet_rate)
    {
        #ifdef SYS_ADPT_PACKETCELL_INTERVAL
        rate = nRate / SYS_ADPT_PACKETCELL_INTERVAL * SYS_ADPT_PACKETCELL_INTERVAL;
        #else
        /* Because the limit is base on packet/sec,
         * we assume there are 500 byte/packet,
         * and get the rate from byte/sec.
         */
        rate = nRate / 500;
        #endif
    }
    else if(mode == VAL_unkucastStormSampleType_percent)
    {
        if(nRate > 100)
        {
#if (SYS_CPNT_EH == TRUE)
            UI8_T buff[64] = {0};

            sprintf(buff, "Unknown Unicast Storm Control rate (0-%d)", 100);

            EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                      SWCTRL_NO_USE_FUNC_NO,
                                      EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                      SYSLOG_LEVEL_INFO,
                                      buff);/*SWCTRL_ENO_INVALID_BSTM_CTRL_RATE*/
#endif

            SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
        }

        #ifdef SYS_ADPT_PACKETCELL_INTERVAL
        if(SWCTRL_IS_100TX (ifindex) || SWCTRL_IS_100FIBER (ifindex))
        {
            rate = SWCTRL_100MB_PORT_MAX_RATE / SYS_ADPT_PACKETCELL_INTERVAL * nRate / 100;
        }
        else if(SWCTRL_IS_1000T (ifindex) ||SWCTRL_IS_1000FIBER (ifindex))
        {
            rate = SWCTRL_1GB_PORT_MAX_RATE / SYS_ADPT_PACKETCELL_INTERVAL * nRate / 100;
        }
        else if (SWCTRL_IS_10GSFP(ifindex) || SWCTRL_IS_10GCOPPER(ifindex))
        {
            rate = SWCTRL_10GB_PORT_MAX_RATE / SYS_ADPT_PACKETCELL_INTERVAL * nRate / 100;
        }
        else /* 40G */
        {
            rate = SWCTRL_40GB_PORT_MAX_RATE / SYS_ADPT_PACKETCELL_INTERVAL * nRate / 100;
        }
        #else
        if(SWCTRL_IS_100TX (ifindex) || SWCTRL_IS_100FIBER (ifindex))
        {
            rate = 100000000 / 8 / 500 * nRate / 100;
        }
        else
        {
            rate = 1000000000 / 8 / 500 * nRate / 100;
        }
        #endif
    }
    else
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_INVALID_PARAMETER,
                                  SYSLOG_LEVEL_INFO,
                                  "Sample Type for Unknown Unicast Storm Control"); /*SWCTRL_ENO_INVALID_BSTM_CTRL_TYPE*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

#if (SYS_CPNT_UNKNOWN_USTORM_SUPPORT_LPORT == TRUE)
    if (SWCTRL_IS_TRUNK_MEMBER (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#endif

    /* if normal port & trunk port can setting
     */
    if(!SWCTRL_IS_TRUNK (ifindex))
    {
        unit = SWCTRL_IFINDEX_TO_UNIT(ifindex);
        port = SWCTRL_IFINDEX_TO_PORT(ifindex);

        retval = SWCTRL_SetUPortUnknownUStormControlRateLimit (unit, port, mode, rate, nRate);
    } /* End of normal port */

    /* if trunk port
     */
#if (SYS_CPNT_UNKNOWN_USTORM_SUPPORT_LPORT == TRUE)
    if(SWCTRL_IS_TRUNK (ifindex))
    {
        SWCTRL_TrunkPortExtInfo_T trunk_ext_p_info;
        UI32_T                    i;

        memset(&trunk_ext_p_info, 0, sizeof(SWCTRL_TrunkPortExtInfo_T));
        SWCTRL_GetTrunkPortExtInfo (ifindex, &trunk_ext_p_info);

        for(i=0; i<trunk_ext_p_info.member_number; i++)
        {
            unit = trunk_ext_p_info.member_list[i].unit;
            port = trunk_ext_p_info.member_list[i].port;

            if (!(retval = SWCTRL_SetUPortUnknownUStormControlRateLimit(unit, port, mode, rate, nRate)))
                break;
        } /* End of for () */
        if (retval)
        {
            SWCTRL_LOCK();
            port_info[ifindex-1].unknown_ucast_storm_entry.unknown_ucast_storm_ifindex = ifindex;
            port_info[ifindex-1].unknown_ucast_storm_entry.unknown_ucast_storm_sample_type = mode;
            port_info[ifindex-1].unknown_ucast_storm_entry.unknown_ucast_storm_pkt_rate   = 0;
            port_info[ifindex-1].unknown_ucast_storm_entry.unknown_ucast_storm_octet_rate = 0;
            port_info[ifindex-1].unknown_ucast_storm_entry.unknown_ucast_storm_percent    = 0;
            switch (mode)
            {
                case VAL_unkucastStormSampleType_pkt_rate:
                port_info[ifindex-1].unknown_ucast_storm_entry.unknown_ucast_storm_pkt_rate = nRate;
                break;
                case VAL_unkucastStormSampleType_octet_rate:
                port_info[ifindex-1].unknown_ucast_storm_entry.unknown_ucast_storm_octet_rate = nRate;
                break;
                case VAL_unkucastStormSampleType_percent:
                port_info[ifindex-1].unknown_ucast_storm_entry.unknown_ucast_storm_percent = nRate;
                break;
            }
            SWCTRL_UNLOCK();
        }
    } /* End of trunk port */
#endif /* End of (SYS_CPNT_UNKNOWN_USTORM_SUPPORT_LPORT == TRUE) */

#if (SYS_CPNT_SWCTRL_SINGLE_INGRESS_RATE_LIMIT == TRUE)
    if (retval)
    {
        retval = SWCTRL_SyncRateLimitThreshold(ifindex, mode, rate, nRate, SYS_CPNT_SWCTRL_RATE_LIMIT_GROUP_FOR_UNKNOWN_USTORM);
    }
#endif

    SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME ();
    SWCTRL_RETURN_AND_RELEASE_CSC( retval );
} /* End of SWCTRL_SetUnknownUStormControlRateLimit() */
#endif


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetBroadcastStormStatus
 * -------------------------------------------------------------------------
 * FUNCTION: This function will enable the broadcast storm control function
 * INPUT   : ifindex -- which port to set
 *           broadcast_storm_status -- VAL_bcastStormStatus_enabled
 *                                     VAL_bcastStormStatus_disabled
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetBroadcastStormStatus(UI32_T ifindex, UI32_T broadcast_storm_status)
{
    UI32_T                          unit, port;
    BOOL_T                          retval = FALSE;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if( ifindex == 0 || ifindex > SYS_ADPT_TOTAL_NBR_OF_LPORT)
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Logical Port ID (1-%d)", SYS_ADPT_TOTAL_NBR_OF_LPORT);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_LOGICAL_PORT_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (!SWCTRL_IS_EXIST (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Interface");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

#if (SYS_CPNT_BSTORM_SUPPORT_LPORT == TRUE)
    if (SWCTRL_IS_TRUNK_MEMBER (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#endif

    if((broadcast_storm_status != VAL_bcastStormStatus_enabled)&&
       (broadcast_storm_status != VAL_bcastStormStatus_disabled))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_INVALID_PARAMETER,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "broadcast storm control status"); /*SWCTRL_ENO_INVALID_BSTM_CTRL_STATUS*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if(port_info[ifindex-1].bcast_storm_entry.bcast_storm_status == broadcast_storm_status)
        SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );


    if (SWCTRL_IsServerBladePort (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_SRV_BLADE_PORT_CNFG,
                                  SYSLOG_LEVEL_INFO,
                                  "Configuring Broadcast Storm Control");     /*SWCTRL_ENO_DENY_ON_SERVER_BLADE_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

#if (SYS_CPNT_INGRESS_RATELIMIT_BSTORM_MSTORM_XOR_EACH_OTHER == TRUE)
    /* For Marvell chipset solution: Rate limit, Bcast storm, Mcast storm and unknown storm are exclude OR.
     * Should call this new API to disable all 4 bits to OFF in chipset, then enabled you want mode
     */
    if (broadcast_storm_status == VAL_bcastStormStatus_enabled)
        retval = SWCTRL_DisableAllRateLimitAndStormsStatus(ifindex);
#endif

    /* When enable the function, ATC function must be disabled. */
#if (SYS_CPNT_ATC_BSTORM == TRUE)
    if ( (broadcast_storm_status == VAL_bcastStormStatus_enabled) &&
         (port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_auto_traffic_control_on == VAL_atcBcastStormEnable_enabled) )
    {
        SWCTRL_SetATCBroadcastStormAutoTrafficControlOnStatus(ifindex, SWCTRL_ATC_BROADCAST_STORM_TC_ON_DISABLE);
    }
#endif

#if (SYS_CPNT_SWCTRL_SINGLE_INGRESS_RATE_LIMIT == TRUE)
    if (broadcast_storm_status == VAL_bcastStormStatus_enabled)
    {
        UI32_T rate_limit_group = SYS_CPNT_SWCTRL_RATE_LIMIT_GROUP_FOR_BSTORM;

        #if (SYS_CPNT_ATC_MSTORM == TRUE)
        if (rate_limit_group == SYS_CPNT_SWCTRL_RATE_LIMIT_GROUP_FOR_MSTORM)
        {
            if (port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_auto_traffic_control_on == VAL_atcMcastStormEnable_enabled)
            {
                SWCTRL_SetATCMulticastStormAutoTrafficControlOnStatus(ifindex, VAL_atcMcastStormEnable_disabled);
            }
        }
        #endif
    }
#endif

    /* if normal port
     */
    if(!SWCTRL_IS_TRUNK (ifindex))
    {
        unit = SWCTRL_IFINDEX_TO_UNIT(ifindex);
        port = SWCTRL_IFINDEX_TO_PORT(ifindex);

        retval = SWCTRL_SetUPortBroadcastStormStatus(unit, port, broadcast_storm_status);
    }

    /* if trunk port
     */
#if (SYS_CPNT_BSTORM_SUPPORT_LPORT == TRUE)
    if(SWCTRL_IS_TRUNK (ifindex))
    {
        SWCTRL_TrunkPortExtInfo_T trunk_ext_p_info;
        UI32_T                    i;

        memset(&trunk_ext_p_info, 0, sizeof(SWCTRL_TrunkPortExtInfo_T));
        SWCTRL_GetTrunkPortExtInfo (ifindex, &trunk_ext_p_info);

        for(i=0; i<trunk_ext_p_info.member_number; i++)
        {
            unit = trunk_ext_p_info.member_list[i].unit;
            port = trunk_ext_p_info.member_list[i].port;

            if (!(retval = SWCTRL_SetUPortBroadcastStormStatus(unit, port, broadcast_storm_status)))
                break;
        } /* End of for () */
        if (retval)
        {
            SWCTRL_LOCK();
            port_info[ifindex-1].bcast_storm_entry.bcast_storm_status = broadcast_storm_status;
            SWCTRL_UNLOCK();
        }
    } /* End of trunk port */
#endif /* End of (SYS_CPNT_BSTORM_SUPPORT_LPORT == TRUE) */

    SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME ();
    SWCTRL_RETURN_AND_RELEASE_CSC( retval );
} /* End of SWCTRL_SetBroadcastStormStatus() */



/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetMulticastStormStatus
 * -------------------------------------------------------------------------
 * FUNCTION: This function will enable the multicast storm control function
 * INPUT   : ifindex -- which port to set
 *           multicast_storm_status -- VAL_bcastStormStatus_enabled
 *                                     VAL_bcastStormStatus_disabled
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetMulticastStormStatus(UI32_T ifindex, UI32_T multicast_storm_status)
{
    UI32_T                          unit, port;
    BOOL_T                          retval = FALSE;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if( ifindex == 0 || ifindex > SYS_ADPT_TOTAL_NBR_OF_LPORT)
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Logical Port ID (1-%d)", SYS_ADPT_TOTAL_NBR_OF_LPORT);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_LOGICAL_PORT_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (!SWCTRL_IS_EXIST (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Interface");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

#if (SYS_CPNT_MSTORM_SUPPORT_LPORT == TRUE)
    if (SWCTRL_IS_TRUNK_MEMBER (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#endif

    if((multicast_storm_status != VAL_mcastStormStatus_enabled)&&
       (multicast_storm_status != VAL_mcastStormStatus_disabled))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_INVALID_PARAMETER,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Multicast Storm Control enable/disable state");   /*SWCTRL_ENO_INVALID_MCAST_CTRL_STATUS*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

#if (SYS_CPNT_INGRESS_RATELIMIT_BSTORM_MSTORM_XOR_EACH_OTHER == TRUE)
    /* For Marvell chipset solution: Rate limit, Bcast storm, Mcast storm and unknown storm are exclude OR.
     * Should call this new API to disable all 4 bits to OFF in chipset, then enabled you want mode
     */
    if (multicast_storm_status == VAL_mcastStormStatus_enabled)
        retval = SWCTRL_DisableAllRateLimitAndStormsStatus(ifindex);
#endif

    /* When enable the function, ATC function must be disabled. */
#if (SYS_CPNT_ATC_MSTORM == TRUE)
    if ( (multicast_storm_status == VAL_mcastStormStatus_enabled) &&
         (port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_auto_traffic_control_on == VAL_atcMcastStormEnable_enabled))
    {
        SWCTRL_SetATCMulticastStormAutoTrafficControlOnStatus(ifindex, VAL_atcMcastStormEnable_disabled);
    }
#endif

#if (SYS_CPNT_SWCTRL_SINGLE_INGRESS_RATE_LIMIT == TRUE)
    if (multicast_storm_status == VAL_mcastStormStatus_enabled)
    {
        UI32_T rate_limit_group = SYS_CPNT_SWCTRL_RATE_LIMIT_GROUP_FOR_MSTORM;

        #if (SYS_CPNT_ATC_BSTORM == TRUE)
        if (rate_limit_group == SYS_CPNT_SWCTRL_RATE_LIMIT_GROUP_FOR_BSTORM)
        {
            if (port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_auto_traffic_control_on == VAL_atcBcastStormEnable_enabled)
            {
                SWCTRL_SetATCBroadcastStormAutoTrafficControlOnStatus(ifindex, SWCTRL_ATC_BROADCAST_STORM_TC_ON_DISABLE);
            }
        }
        #endif
    }
#endif

    /* if normal port
     */
    if(!SWCTRL_IS_TRUNK (ifindex))
    {
        unit = SWCTRL_IFINDEX_TO_UNIT(ifindex);
        port = SWCTRL_IFINDEX_TO_PORT(ifindex);

        retval = SWCTRL_SetUPortMulticastStormStatus(unit, port, multicast_storm_status);
    }

    /* if trunk port
     */
#if (SYS_CPNT_MSTORM_SUPPORT_LPORT == TRUE)
    if(SWCTRL_IS_TRUNK (ifindex))
    {
        SWCTRL_TrunkPortExtInfo_T trunk_ext_p_info;
        UI32_T                    i;

        memset(&trunk_ext_p_info, 0, sizeof(SWCTRL_TrunkPortExtInfo_T));
        SWCTRL_GetTrunkPortExtInfo (ifindex, &trunk_ext_p_info);

        for(i=0; i<trunk_ext_p_info.member_number; i++)
        {
            unit = trunk_ext_p_info.member_list[i].unit;
            port = trunk_ext_p_info.member_list[i].port;

            if (!(retval = SWCTRL_SetUPortMulticastStormStatus(unit, port, multicast_storm_status)))
                break;
        } /* End of for () */
        if (retval)
        {
            SWCTRL_LOCK();
            port_info[ifindex-1].mcast_storm_entry.mcast_storm_status = multicast_storm_status;
            SWCTRL_UNLOCK();
        }
    } /* End of trunk port */
#endif /* End of (SYS_CPNT_MSTORM_SUPPORT_LPORT == TRUE) */

    SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME ();
    SWCTRL_RETURN_AND_RELEASE_CSC( retval );
} /* End of SWCTRL_SetMulticastStormStatus() */

#if (SYS_CPNT_STORM_MODE & SYS_CPNT_STORM_UNKNOWN_USTORM)
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetUnknownUnicastStormStatus
 * -------------------------------------------------------------------------
 * FUNCTION: This function will enable the Unknowunicast storm control function
 * INPUT   : ifindex -- which port to set
 *           uNknowunicast_storm_status -- VAL_unkucastStormStatus_enabled
 *                                     VAL_unkucastStormStatus_disabled
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetUnknownUnicastStormStatus(UI32_T ifindex, UI32_T unknowunicast_storm_status)
{
    UI32_T                          unit, port;
    BOOL_T                          retval = FALSE;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if( ifindex == 0 || ifindex > SYS_ADPT_TOTAL_NBR_OF_LPORT)
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Logical Port ID (1-%d)", SYS_ADPT_TOTAL_NBR_OF_LPORT);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_LOGICAL_PORT_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (!SWCTRL_IS_EXIST (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Interface");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

#if (SYS_CPNT_UNKNOWN_USTORM_SUPPORT_LPORT == TRUE)
    if (SWCTRL_IS_TRUNK_MEMBER (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#endif

    if((unknowunicast_storm_status != VAL_unkucastStormStatus_enabled)&&
       (unknowunicast_storm_status != VAL_unkucastStormStatus_disabled))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_INVALID_PARAMETER,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Unknown Unicast Storm Control enable/disable state");   /*SWCTRL_ENO_INVALID_MCAST_CTRL_STATUS*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

#if (SYS_CPNT_INGRESS_RATELIMIT_BSTORM_MSTORM_XOR_EACH_OTHER == TRUE)
    /* For Marvell chipset solution: Rate limit, Bcast storm, Mcast storm and unknown storm are exclude OR.
     * Should call this new API to disable all 4 bits to OFF in chipset, then enabled you want mode
     */
    if (unknowunicast_storm_status == VAL_unkucastStormStatus_enabled)
        retval = SWCTRL_DisableAllRateLimitAndStormsStatus(ifindex);
#endif

#if (SYS_CPNT_SWCTRL_SINGLE_INGRESS_RATE_LIMIT == TRUE)
    if (unknowunicast_storm_status == VAL_unkucastStormStatus_enabled)
    {
        UI32_T rate_limit_group = SYS_CPNT_SWCTRL_RATE_LIMIT_GROUP_FOR_UNKNOWN_USTORM;

        #if (SYS_CPNT_ATC_BSTORM == TRUE)
        if (rate_limit_group == SYS_CPNT_SWCTRL_RATE_LIMIT_GROUP_FOR_BSTORM)
        {
            if (port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_auto_traffic_control_on == VAL_atcBcastStormEnable_enabled)
            {
                SWCTRL_SetATCBroadcastStormAutoTrafficControlOnStatus(ifindex, SWCTRL_ATC_BROADCAST_STORM_TC_ON_DISABLE);
            }
        }
        #endif

        #if (SYS_CPNT_ATC_MSTORM == TRUE)
        if (rate_limit_group == SYS_CPNT_SWCTRL_RATE_LIMIT_GROUP_FOR_MSTORM)
        {
            if (port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_auto_traffic_control_on == VAL_atcMcastStormEnable_enabled)
            {
                SWCTRL_SetATCMulticastStormAutoTrafficControlOnStatus(ifindex, VAL_atcMcastStormEnable_disabled);
            }
        }
        #endif
    }
#endif

    /* if normal port
     */
    if(!SWCTRL_IS_TRUNK (ifindex))
    {
        unit = SWCTRL_IFINDEX_TO_UNIT(ifindex);
        port = SWCTRL_IFINDEX_TO_PORT(ifindex);

        retval = SWCTRL_SetUPortUnknownUnicastStormStatus(unit, port, unknowunicast_storm_status);
    }

    /* if trunk port
     */
#if (SYS_CPNT_UNKNOWN_USTORM_SUPPORT_LPORT == TRUE)
    if(SWCTRL_IS_TRUNK (ifindex))
    {
        SWCTRL_TrunkPortExtInfo_T trunk_ext_p_info;
        UI32_T                    i;

        memset(&trunk_ext_p_info, 0, sizeof(SWCTRL_TrunkPortExtInfo_T));
        SWCTRL_GetTrunkPortExtInfo (ifindex, &trunk_ext_p_info);

        for(i=0; i<trunk_ext_p_info.member_number; i++)
        {
            unit = trunk_ext_p_info.member_list[i].unit;
            port = trunk_ext_p_info.member_list[i].port;

            if (!(retval = SWCTRL_SetUPortUnknownUnicastStormStatus(unit, port, unknowunicast_storm_status)))
                break;
        } /* End of for () */
        if (retval)
        {
            SWCTRL_LOCK();
            port_info[ifindex-1].unknown_ucast_storm_entry.unknown_ucast_storm_status = unknowunicast_storm_status;
            SWCTRL_UNLOCK();
        }
    } /* End of trunk port */
#endif /* End of (SYS_CPNT_UNKNOWN_USTORM_SUPPORT_LPORT == TRUE) */

    SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME ();
    SWCTRL_RETURN_AND_RELEASE_CSC( retval );
} /* End of SWCTRL_SetMulticastStormStatus() */
#endif

/*------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetPortStormGranularity
 *------------------------------------------------------------------------
 * FUNCTION: This function will get granularity of a port
 * INPUT   : ifindex      -- which port to get
 * OUTPUT  : granularity  -- granularity of a port
 * RETURN  : TRUE/FALSE
 * NOTE    :
 *------------------------------------------------------------------------*/
BOOL_T SWCTRL_GetPortStormGranularity(UI32_T ifindex, UI32_T *granularity)
{
    UI32_T                          unit, port, rate;
    BOOL_T                          retval = FALSE;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);
    /* semantic check
     */
    if (granularity == NULL)
    {
        EH_MGR_Handle_Exception (SYS_MODULE_SWCTRL,
                                 SWCTRL_NO_USE_FUNC_NO,
                                 EH_TYPE_MSG_NULL_POINTER,
                                 EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_CRIT);

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
    if( ifindex == 0 || ifindex > SYS_ADPT_TOTAL_NBR_OF_LPORT)
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Logical Port ID (1-%d)", SYS_ADPT_TOTAL_NBR_OF_LPORT);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_LOGICAL_PORT_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (!SWCTRL_IS_EXIST (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Interface");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (SWCTRL_IsServerBladePort (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_SRV_BLADE_PORT_CNFG,
                                  SYSLOG_LEVEL_INFO,
                                  "Storm Granularity");     /*SWCTRL_ENO_DENY_ON_SERVER_BLADE_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
    *granularity=port_info[ifindex-1].storm_granularity;
    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
}

#if (SYS_CPNT_INGRESS_RATELIMIT_BSTORM_MSTORM_XOR_EACH_OTHER == TRUE)
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_DisableAllRateLimitAndStormsStatus
 * -------------------------------------------------------------------------
 * FUNCTION: This function will disable the rate limit & all storm control function
 * INPUT   : ifindex -- which port to set
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
static BOOL_T SWCTRL_DisableAllRateLimitAndStormsStatus(UI32_T ifindex)
{
    BOOL_T retval = TRUE;
    UI32_T i, start_ifindex, end_ifindex;
    UI8_T unit, port;

    /* if normal port
     */
    if(!SWCTRL_IS_TRUNK (ifindex))
    {
        unit = SWCTRL_IFINDEX_TO_UNIT(ifindex);
        port = SWCTRL_IFINDEX_TO_PORT(ifindex);

#if (SYS_CPNT_BSTORM_ENABLE_PER_PORT == FALSE)
        start_ifindex = 1;
        end_ifindex = SYS_ADPT_TOTAL_NBR_OF_LPORT;
#else
        start_ifindex = SWCTRL_UPORT_TO_IFINDEX (unit, port);
        end_ifindex = start_ifindex;
#endif

        /* if rate limit is enabled, then disable it.
         */
        if (port_info[start_ifindex-1].ingress_rate_limit_status == VAL_rlPortInputStatus_enabled)
        {
            retval = SWDRV_DisablePortIngressRateLimit (unit, port, 0);
            if (retval)
                for(i = start_ifindex; i <= end_ifindex; i++)
                    port_info[i-1].ingress_rate_limit_status = VAL_rlPortInputStatus_disabled;
        }

        /* if broadcast storm is enabled, then disable it.
         */
        if (port_info[start_ifindex-1].bcast_storm_entry.bcast_storm_status == VAL_bcastStormStatus_enabled)
        {
            retval = SWDRV_DisableBroadcastStormControl (unit, port);
            if (retval)
                for(i = start_ifindex; i <= end_ifindex; i++)
                    port_info[i-1].bcast_storm_entry.bcast_storm_status = VAL_bcastStormStatus_disabled;
        }

        /* if multicast storm is enabled, then disable it.
         */
        if (port_info[start_ifindex-1].mcast_storm_entry.mcast_storm_status == VAL_mcastStormStatus_enabled)
        {
            retval = SWDRV_DisableMulticastStormControl (unit, port);
            if (retval)
                for(i = start_ifindex; i <= end_ifindex; i++)
                    port_info[i-1].mcast_storm_entry.mcast_storm_status = VAL_mcastStormStatus_disabled;
        }
#if (SYS_CPNT_STORM_MODE & SYS_CPNT_STORM_UNKNOWN_USTORM)
        /* if unknowunicast storm is enabled, then disable it.
         */
           if (port_info[start_ifindex-1].unknown_ucast_storm_entry.unknown_ucast_storm_status == VAL_unkucastStormStatus_enabled)
        {
            retval = SWDRV_DisableUnknownUnicastStormControl (unit, port);
            if (retval)
                for(i = start_ifindex; i <= end_ifindex; i++)
                    port_info[i-1].unknown_ucast_storm_entry.unknown_ucast_storm_status = VAL_unkucastStormStatus_disabled;
        }
 #endif

    }

    /* if trunk port
     */
#if (SYS_CPNT_BSTORM_SUPPORT_LPORT == TRUE)
    if(SWCTRL_IS_TRUNK (ifindex))
    {
        SWCTRL_TrunkPortExtInfo_T trunk_ext_p_info;
        UI32_T                    i;
        UI32_T       trunk_id;

        memset(&trunk_ext_p_info, 0, sizeof(SWCTRL_TrunkPortExtInfo_T));
        SWCTRL_GetTrunkPortExtInfo (ifindex, &trunk_ext_p_info);

        trunk_id = SWCTRL_IFINDEX_TO_TRUNKID (ifindex);

        for(i=0; i<trunk_ext_p_info.member_number; i++)
        {
            unit = trunk_ext_p_info.member_list[i].unit;
            port = trunk_ext_p_info.member_list[i].port;

#if (SYS_CPNT_BSTORM_ENABLE_PER_PORT == FALSE)
            start_ifindex = 1;
            end_ifindex = SYS_ADPT_TOTAL_NBR_OF_LPORT;
#else
            start_ifindex = SWCTRL_UPORT_TO_IFINDEX (unit, port);
            end_ifindex = start_ifindex;
#endif
            /* if rate limit is enabled, then disable it.
             */
            if (port_info[start_ifindex-1].ingress_rate_limit_status == VAL_rlPortInputStatus_enabled)
            {
                retval = SWDRV_DisablePortIngressRateLimit (unit, port);
                if (retval)
                    for(i = start_ifindex; i <= end_ifindex; i++)
                        port_info[i-1].ingress_rate_limit_status = VAL_rlPortInputStatus_disabled;
            }

            /* if broadcast storm is enabled, then disable it.
             */
            if (port_info[start_ifindex-1].bcast_storm_entry.bcast_storm_status == VAL_bcastStormStatus_enabled)
            {
                retval = SWDRV_DisableBroadcastStormControl (unit, port);
                if (retval)
                    for(i = start_ifindex; i <= end_ifindex; i++)
                        port_info[i-1].bcast_storm_entry.bcast_storm_status = VAL_bcastStormStatus_disabled;
            }

            /* if multicast storm is enabled, then disable it.
             */
            if (port_info[start_ifindex-1].mcast_storm_entry.mcast_storm_status == VAL_mcastStormStatus_enabled)
            {
                retval = SWDRV_DisableMulticastStormControl (unit, port);
                if (retval)
                    for(i = start_ifindex; i <= end_ifindex; i++)
                        port_info[i-1].mcast_storm_entry.mcast_storm_status = VAL_mcastStormStatus_disabled;
            }
#if (SYS_CPNT_STORM_MODE & SYS_CPNT_STORM_UNKNOWN_USTORM)
            /* if unknowunicast storm is enabled, then disable it.
             */
             if (port_info[start_ifindex-1].unknown_ucast_storm_entry.unknown_ucast_storm_status == VAL_unkucastStormStatus_enabled)
            {
                retval = SWDRV_DisableUnknownUnicastStormControl (unit, port);
                if (retval)
                for(i = start_ifindex; i <= end_ifindex; i++)
                    port_info[i-1].unknown_ucast_storm_entry.unknown_ucast_storm_status = VAL_unkucastStormStatus_disabled;
            }
#endif

        } /* End of for () */

        if (retval)
        {
            /* if rate limit is enabled, then disable it.
             */
            if (port_info[ifindex-1].ingress_rate_limit_status == VAL_rlPortInputStatus_enabled)
            {
                retval = SWDRV_DisablePortIngressRateLimit (1, 1, trunk_id);
                port_info[ifindex-1].ingress_rate_limit_status = VAL_rlPortInputStatus_disabled;
            }
            port_info[ifindex-1].bcast_storm_entry.bcast_storm_status = VAL_bcastStormStatus_disabled;
            port_info[ifindex-1].mcast_storm_entry.mcast_storm_status = VAL_mcastStormStatus_disabled;
#if (SYS_CPNT_STORM_MODE & SYS_CPNT_STORM_UNKNOWN_USTORM)
            port_info[ifindex-1].unknown_ucast_storm_entry.unknown_ucast_storm_status = VAL_unkucastStormStatus_disabled;
#endif
        }
    } /* End of trunk port */
#endif /* End of (SYS_CPNT_BSTORM_SUPPORT_LPORT == TRUE) */

    return retval;
} /* end of SWCTRL_DisableAllRateLimitAndStormsStatus() */
#endif

#if (SYS_CPNT_SWCTRL_SINGLE_INGRESS_RATE_LIMIT == TRUE)
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SyncRateLimitThreshold
 * -------------------------------------------------------------------------
 * FUNCTION: This function will sync threshold to all rate limit if needed
 * INPUT   : ifindex -- which port to set
 *           mode    -- sample type
 *           rate
 *           nRate
 *           rate_limit_group -- specify which group the rate setting belongs to
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
static BOOL_T SWCTRL_SyncRateLimitThreshold(UI32_T ifindex, UI32_T mode, UI32_T rate, UI32_T nRate, UI32_T rate_limit_group)
{
    UI32_T unit, port;
    UI32_T retval = TRUE;
    UI32_T config_rate;

#if (SYS_CPNT_INGRESS_RATE_LIMIT == TRUE)
    if (rate_limit_group == SYS_CPNT_SWCTRL_RATE_LIMIT_GROUP_FOR_INGRESS_RATE_LIMIT)
    {
        if(FALSE == SWCTRL_ConvertRateByStormType(ifindex, mode, rate, SWCTRL_STORM_SAMPLE_TYPE_OCTET_RATE, &config_rate))
        {
            return FALSE;
        }
    }
#endif

    /* if normal port & trunk port can setting
     */
    if(!SWCTRL_IS_TRUNK (ifindex))
    {
        unit = SWCTRL_IFINDEX_TO_UNIT(ifindex);
        port = SWCTRL_IFINDEX_TO_PORT(ifindex);

        #if (SYS_CPNT_STORM_MODE & SYS_CPNT_STORM_BSTORM)
        if (rate_limit_group == SYS_CPNT_SWCTRL_RATE_LIMIT_GROUP_FOR_BSTORM)
        {
            retval &= SWCTRL_SetUPortBStormControlRateLimit (unit, port, mode, rate, nRate);
        }
        #endif

        #if (SYS_CPNT_STORM_MODE & SYS_CPNT_STORM_MSTORM)
        if (rate_limit_group == SYS_CPNT_SWCTRL_RATE_LIMIT_GROUP_FOR_MSTORM)
        {
            retval &= SWCTRL_SetUPortMStormControlRateLimit (unit, port, mode, rate, nRate);
        }
        #endif

        #if (SYS_CPNT_STORM_MODE & SYS_CPNT_STORM_UNKNOWN_USTORM)
        if (rate_limit_group == SYS_CPNT_SWCTRL_RATE_LIMIT_GROUP_FOR_UNKNOWN_USTORM)
        {
            retval &= SWCTRL_SetUPortUnknownUStormControlRateLimit (unit, port, mode, rate, nRate);
        }
        #endif

        #if (SYS_CPNT_INGRESS_RATE_LIMIT == TRUE)
        if (rate_limit_group == SYS_CPNT_SWCTRL_RATE_LIMIT_GROUP_FOR_INGRESS_RATE_LIMIT)
        {
            SWCTRL_LOCK();
            if (port_info[ifindex - 1].ingress_rate_limit_status == VAL_rlPortInputStatus_enabled)
                retval &= SWDRV_SetPortIngressRateLimit(unit, port, 0, config_rate);
            port_info[ifindex - 1].ingress_rate_limit = nRate;
            SWCTRL_UNLOCK();
        }
        #endif
    } /* End of normal port */

    /* if trunk port
     */
#if (SYS_CPNT_BSTORM_SUPPORT_LPORT == TRUE) || (SYS_CPNT_MSTORM_SUPPORT_LPORT == TRUE) || (SYS_CPNT_UNKNOWN_USTORM_SUPPORT_LPORT == TRUE)
    if(SWCTRL_IS_TRUNK (ifindex))
    {
        SWCTRL_TrunkPortExtInfo_T trunk_ext_p_info;
        UI32_T                    i;
        UI32_T                    trunk_id;

        memset(&trunk_ext_p_info, 0, sizeof(SWCTRL_TrunkPortExtInfo_T));
        SWCTRL_GetTrunkPortExtInfo (ifindex, &trunk_ext_p_info);

        for(i=0; i<trunk_ext_p_info.member_number; i++)
        {
            UI32_T member_ifindex;

            unit = trunk_ext_p_info.member_list[i].unit;
            port = trunk_ext_p_info.member_list[i].port;
            member_ifindex = SWCTRL_UPORT_TO_IFINDEX(unit, port);

            #if (SYS_CPNT_STORM_MODE & SYS_CPNT_STORM_BSTORM)
            if (rate_limit_group == SYS_CPNT_SWCTRL_RATE_LIMIT_GROUP_FOR_BSTORM)
            {
                retval &= SWCTRL_SetUPortBStormControlRateLimit (unit, port, mode, rate, nRate);
            }
            #endif

            #if (SYS_CPNT_STORM_MODE & SYS_CPNT_STORM_MSTORM)
            if (rate_limit_group == SYS_CPNT_SWCTRL_RATE_LIMIT_GROUP_FOR_MSTORM)
            {
                retval &= SWCTRL_SetUPortMStormControlRateLimit (unit, port, mode, rate, nRate);
            }
            #endif

            #if (SYS_CPNT_STORM_MODE & SYS_CPNT_STORM_UNKNOWN_USTORM)
            if (rate_limit_group == SYS_CPNT_SWCTRL_RATE_LIMIT_GROUP_FOR_UNKNOWN_USTORM)
            {
                retval &= SWCTRL_SetUPortUnknownUStormControlRateLimit (unit, port, mode, rate, nRate);
            }
            #endif

            #if (SYS_CPNT_INGRESS_RATE_LIMIT == TRUE)
            if (rate_limit_group == SYS_CPNT_SWCTRL_RATE_LIMIT_GROUP_FOR_INGRESS_RATE_LIMIT)
            {
                SWCTRL_LOCK();
                if (port_info[member_ifindex - 1].ingress_rate_limit_status == VAL_rlPortInputStatus_enabled)
                    retval &= SWDRV_SetPortIngressRateLimit(unit, port, 0, config_rate);
                port_info[member_ifindex - 1].ingress_rate_limit = nRate;
                SWCTRL_UNLOCK();
            }
            #endif

            if (!retval)
                break;
        } /* End of for () */

        if (retval)
        {
            SWCTRL_LOCK();

            #if (SYS_CPNT_STORM_MODE & SYS_CPNT_STORM_BSTORM) && (SYS_CPNT_BSTORM_SUPPORT_LPORT == TRUE)
            if (rate_limit_group == SYS_CPNT_SWCTRL_RATE_LIMIT_GROUP_FOR_BSTORM)
            {
                port_info[ifindex-1].bcast_storm_entry.bcast_storm_ifindex = ifindex;
                port_info[ifindex-1].bcast_storm_entry.bcast_storm_sample_type = VAL_bcastStormSampleType_octet_rate;
                port_info[ifindex-1].bcast_storm_entry.bcast_storm_pkt_rate   = 0;
                port_info[ifindex-1].bcast_storm_entry.bcast_storm_octet_rate = nRate;
                port_info[ifindex-1].bcast_storm_entry.bcast_storm_percent    = 0;
            }
            #endif

            #if (SYS_CPNT_STORM_MODE & SYS_CPNT_STORM_MSTORM) && (SYS_CPNT_MSTORM_SUPPORT_LPORT == TRUE)
            if (rate_limit_group == SYS_CPNT_SWCTRL_RATE_LIMIT_GROUP_FOR_MSTORM)
            {
                port_info[ifindex-1].mcast_storm_entry.mcast_storm_ifindex = ifindex;
                port_info[ifindex-1].mcast_storm_entry.mcast_storm_sample_type = VAL_mcastStormSampleType_octet_rate;
                port_info[ifindex-1].mcast_storm_entry.mcast_storm_pkt_rate   = 0;
                port_info[ifindex-1].mcast_storm_entry.mcast_storm_octet_rate = nRate;
                port_info[ifindex-1].mcast_storm_entry.mcast_storm_percent    = 0;
            }
            #endif

            #if (SYS_CPNT_STORM_MODE & SYS_CPNT_STORM_UNKNOWN_USTORM) && (SYS_CPNT_UNKNOWN_USTORM_SUPPORT_LPORT == TRUE)
            if (rate_limit_group == SYS_CPNT_SWCTRL_RATE_LIMIT_GROUP_FOR_UNKNOWN_USTORM)
            {
                port_info[ifindex-1].unknown_ucast_storm_entry.unknown_ucast_storm_ifindex = ifindex;
                port_info[ifindex-1].unknown_ucast_storm_entry.unknown_ucast_storm_sample_type = VAL_unkucastStormSampleType_octet_rate;
                port_info[ifindex-1].unknown_ucast_storm_entry.unknown_ucast_storm_pkt_rate   = 0;
                port_info[ifindex-1].unknown_ucast_storm_entry.unknown_ucast_storm_octet_rate = nRate;
                port_info[ifindex-1].unknown_ucast_storm_entry.unknown_ucast_storm_percent    = 0;
            }
            #endif

            #if (SYS_CPNT_INGRESS_RATE_LIMIT == TRUE)
            if (rate_limit_group == SYS_CPNT_SWCTRL_RATE_LIMIT_GROUP_FOR_INGRESS_RATE_LIMIT)
            {
                trunk_id = SWCTRL_IFINDEX_TO_TRUNKID (ifindex);
                if (port_info[ifindex - 1].ingress_rate_limit_status == VAL_rlPortInputStatus_enabled)
                    retval &= SWDRV_SetPortIngressRateLimit(1, 1, trunk_id, config_rate);
                port_info[ifindex - 1].ingress_rate_limit = nRate;
            }
            #endif

            SWCTRL_UNLOCK();
        }
    } /* End of trunk port */
#endif /* End of (SYS_CPNT_BSTORM_SUPPORT_LPORT == TRUE) */

    return retval;
}

#if (SYS_CPNT_ATC_STORM == TRUE)
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SyncUPortATCStormControlRateLimit
 * -------------------------------------------------------------------------
 * FUNCTION: This function will sync threshold to ATC BC/MC if needed
 * INPUT   : unit
 *           port
 * OUTPUT  : None
 * RETURN  : None
 * NOTE    : None
 * -------------------------------------------------------------------------*/
static void SWCTRL_SyncUPortATCStormControlRateLimit(UI32_T unit, UI32_T port)
{
#if (SYS_CPNT_ATC_BSTORM == TRUE) && \
    (SYS_CPNT_ATC_MSTORM == TRUE) && \
    (SYS_CPNT_SWCTRL_RATE_LIMIT_GROUP_FOR_BSTORM == SYS_CPNT_SWCTRL_RATE_LIMIT_GROUP_FOR_MSTORM)

    UI32_T ifindex;
    UI32_T rate, nRate;
    BOOL_T retval = TRUE;

    ifindex = SWCTRL_UPORT_TO_IFINDEX (unit, port);

    rate = 0;

    /* pick higher threshold for ATC BC and MC
     */
    if (port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_traffic_control_on == SWCTRL_ATC_BROADCAST_STORM_TC_ON_ENABLE &&
        port_info[ifindex-1].atc_broadcast_storm_entry.state_machine_action == VAL_atcBcastStormTcAction_rate_control)
    {
        if (rate < port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_packet_rate)
        {
            rate = port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_packet_rate;
        }
    }

    if (port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_traffic_control_on == SWCTRL_ATC_MULTICAST_STORM_TC_ON_ENABLE &&
        port_info[ifindex-1].atc_multicast_storm_entry.state_machine_action == VAL_atcMcastStormTcAction_rate_control)
    {
        if (rate < port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_packet_rate)
        {
            rate = port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_packet_rate;
        }
    }

    /* set picked threshold to ATC BC and MC
     */
    if (port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_traffic_control_on == SWCTRL_ATC_BROADCAST_STORM_TC_ON_ENABLE &&
        port_info[ifindex-1].atc_broadcast_storm_entry.state_machine_action == VAL_atcBcastStormTcAction_rate_control)
    {
        nRate = port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_packet_rate;
        retval = SWCTRL_SetUPortATCBroadcastStormControlRateLimit(unit, port, VAL_atcBcastStormSampleType_packet_rate, rate, nRate);
    }

    if (port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_traffic_control_on == SWCTRL_ATC_MULTICAST_STORM_TC_ON_ENABLE &&
        port_info[ifindex-1].atc_multicast_storm_entry.state_machine_action == VAL_atcMcastStormTcAction_rate_control)
    {
        nRate = port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_packet_rate;
        retval = SWCTRL_SetUPortATCMulticastStormControlRateLimit(unit, port, VAL_atcMcastStormSampleType_packet_rate, rate, nRate);
    }
#endif
}
#endif /* (SYS_CPNT_ATC_STORM == TRUE) */
#endif /* (SYS_CPNT_SWCTRL_SINGLE_INGRESS_RATE_LIMIT == TRUE) */

#if (SYS_CPNT_SWCTRL_GLOBAL_STORM_SAMPLE_TYPE == TRUE)
/*------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetGlobalStormSampleType
 *------------------------------------------------------------------------
 * FUNCTION: This function will set global storm sample type
 * INPUT   : ifindex                        - interface index
 *           global_storm_sample_type       - VAL_stormSampleType_pkt_rate
 *                                            VAL_stormSampleType_octet_rate
 *                                            VAL_stormSampleType_percent
 *                                            0 for default value
 * OUTPUT  : None
 * RETURN  : TRUE/FALSE
 * NOTE    : None
 *------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetGlobalStormSampleType(UI32_T global_storm_sample_type)
{
    UI32_T ifindex, mode, rate;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (global_storm_sample_type == 0)
    {
        global_storm_sample_type = SYS_DFLT_SWCTRL_GLOBAL_STORM_SAMPLE_TYPE;
    }

    if (TRUE
        #if (SYS_CPNT_SWCTRL_GLOBAL_STORM_SAMPLE_TYPE_OCTET == TRUE)
        && global_storm_sample_type != SWCTRL_STORM_SAMPLE_TYPE_OCTET_RATE
        #endif
        #if (SYS_CPNT_SWCTRL_GLOBAL_STORM_SAMPLE_TYPE_PACKET == TRUE)
        && global_storm_sample_type != SWCTRL_STORM_SAMPLE_TYPE_PKT_RATE
        #endif
        #if (SYS_CPNT_SWCTRL_GLOBAL_STORM_SAMPLE_TYPE_PERCENT == TRUE)
        && global_storm_sample_type != SWCTRL_STORM_SAMPLE_TYPE_PERCENT_RATE
        #endif
        )
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_INVALID_PARAMETER,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "storm sample type");   /*SWCTRL_ENO_INVALID_ADMIN*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (swctrl_global_storm_sample_type == global_storm_sample_type)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
    }

    swctrl_global_storm_sample_type = global_storm_sample_type;

    /* reset rate limit of all ports to default
     */
    mode = swctrl_global_storm_sample_type;
    rate = swctrl_dflt_storm_rate[mode-1];

    for (ifindex = 1; ifindex <= SYS_ADPT_TOTAL_NBR_OF_LPORT; ifindex++)
    {
        if (!SWCTRL_IS_EXIST(ifindex))
        {
            continue;
        }

        #if (SYS_CPNT_STORM_MODE & SYS_CPNT_STORM_BSTORM)
        SWCTRL_SetBStormControlRateLimit(ifindex, mode, rate);
        #endif

        #if (SYS_CPNT_STORM_MODE & SYS_CPNT_STORM_MSTORM)
        SWCTRL_SetMStormControlRateLimit(ifindex, mode, rate);
        #endif

        #if (SYS_CPNT_STORM_MODE & SYS_CPNT_STORM_UNKNOWN_USTORM)
        SWCTRL_SetUnknownUStormControlRateLimit(ifindex, mode, rate);
        #endif

        #if (SYS_CPNT_ATC_BSTORM == TRUE)
        SWCTRL_SetATCBroadcastStormStormClearThreshold(ifindex, port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_storm_clear_threshold / SWCTRL_ATC_BROADCAST_STORM_ONE_THOUSAND);
        #endif

        #if (SYS_CPNT_ATC_MSTORM == TRUE)
        SWCTRL_SetATCMulticastStormStormClearThreshold(ifindex, port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_storm_clear_threshold / SWCTRL_ATC_MULTICAST_STORM_ONE_THOUSAND);
        #endif
    }

    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
} /* End of SWCTRL_SetGlobalStormSampleType () */

/*------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetRunningGlobalStormSampleType
 *------------------------------------------------------------------------
 * FUNCTION: This function will get running config of global storm sample type
 * INPUT   : None
 * OUTPUT  : global_storm_sample_type
 * RETURN  : SYS_TYPE_Get_Running_Cfg_T
 * NOTE    : None
 *------------------------------------------------------------------------*/
SYS_TYPE_Get_Running_Cfg_T SWCTRL_GetRunningGlobalStormSampleType(UI32_T *global_storm_sample_type_p)
{
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (global_storm_sample_type_p == NULL)
    {
        EH_MGR_Handle_Exception (SYS_MODULE_SWCTRL,
                                 SWCTRL_NO_USE_FUNC_NO,
                                 EH_TYPE_MSG_NULL_POINTER,
                                 EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_CRIT);

        SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_FAIL );
    }

    *global_storm_sample_type_p = swctrl_global_storm_sample_type;

    if (*global_storm_sample_type_p != SYS_DFLT_SWCTRL_GLOBAL_STORM_SAMPLE_TYPE)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_SUCCESS );
    }
    else
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_NO_CHANGE );
    }
}
#endif /* (SYS_CPNT_SWCTRL_GLOBAL_STORM_SAMPLE_TYPE == TRUE) */




/****************************************************************************/
/* Auto Traffic Control Broadcast/Multicast Storm Control                   */
/****************************************************************************/
#if (SYS_CPNT_ATC_BSTORM == TRUE)

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetATCBroadcastStormAutoTrafficControlOnStatus
 * -------------------------------------------------------------------------
 * 1.
 * FUNCTION: This function will set the auto traffic control on status of broadcast
 *           storm control function
 * INPUT   : ifindex -- which port to set
 *           auto_traffic_control_on_status    -- which status of auto traffic control on
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetATCBroadcastStormAutoTrafficControlOnStatus
(UI32_T ifindex,
UI32_T auto_traffic_control_on_status
)

{
    /* LOCAL VARIABLES
     */
#if (SYS_CPNT_ATC_BSTORM_SUPPORT_LPORT == TRUE)
    UI32_T                          unit, port;
#endif
    UI32_T                          timer;
    UI32_T                          threshold;
    BOOL_T                          retval = FALSE;

    /* BODY
     */
    /* Check Management Port.
     * TRUE: The port is a management port.
     * FALSE: The port is not a managemet port.
     * It returns FALSE, when the port is a management port.
     */
    if ( TRUE == SWCTRL_IsManagementPort(ifindex) )
    {
        return FALSE;
    }

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if( ifindex == 0 || ifindex > SYS_ADPT_TOTAL_NBR_OF_LPORT)
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Logical Port ID (1-%d)", SYS_ADPT_TOTAL_NBR_OF_LPORT);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_LOGICAL_PORT_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (!SWCTRL_IS_EXIST (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Interface");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

#if (SYS_CPNT_ATC_BSTORM_SUPPORT_LPORT != TRUE)
    if (SWCTRL_IS_TRUNK (ifindex))
    {
            EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                      SWCTRL_NO_USE_FUNC_NO,
                                      EH_TYPE_MSG_TRUNK_CNFG_ERR,
                                      SYSLOG_LEVEL_INFO,
                                      "it doesn't support Broadcast Storm Control.");  /*SWCTRL_ENO_NOT_TRUNK*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#else
    if (SWCTRL_IS_TRUNK_MEMBER (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#endif

    if((auto_traffic_control_on_status != VAL_atcBcastStormEnable_enabled) &&
       (auto_traffic_control_on_status != VAL_atcBcastStormEnable_disabled))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_INVALID_PARAMETER,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "auto traffic control on status"); /*SWCTRL_ENO_INVALID_AUTO_TRAFFIC_CONTROL_ON_STATUS*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if(port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_auto_traffic_control_on == auto_traffic_control_on_status)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
    }

    if (SWCTRL_IsServerBladePort (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_SRV_BLADE_PORT_CNFG,
                                  SYSLOG_LEVEL_INFO,
                                  "Configuring Broadcast Storm Control");     /*SWCTRL_ENO_DENY_ON_SERVER_BLADE_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    /* When enable the ATC function, hardware storm control function must be disabled. */
#if (SYS_CPNT_STORM_MODE & SYS_CPNT_STORM_BSTORM)
    if ( (auto_traffic_control_on_status == VAL_atcBcastStormEnable_enabled) &&
         (port_info[ifindex-1].bcast_storm_entry.bcast_storm_status == VAL_bcastStormStatus_enabled) )
    {
        SWCTRL_SetBcastStormStatus(ifindex, VAL_bcastStormStatus_disabled);
    }
#endif

#if (SYS_CPNT_SWCTRL_SINGLE_INGRESS_RATE_LIMIT == TRUE)
    if (auto_traffic_control_on_status == VAL_atcBcastStormEnable_enabled)
    {
        UI32_T rate_limit_group = SYS_CPNT_SWCTRL_RATE_LIMIT_GROUP_FOR_BSTORM;

        #if (SYS_CPNT_STORM_MODE & SYS_CPNT_STORM_MSTORM)
        if (rate_limit_group == SYS_CPNT_SWCTRL_RATE_LIMIT_GROUP_FOR_MSTORM)
        {
            if (port_info[ifindex-1].mcast_storm_entry.mcast_storm_status == VAL_mcastStormStatus_enabled)
            {
                SWCTRL_SetMcastStormStatus(ifindex, VAL_mcastStormStatus_disabled);
            }
        }
        #endif

        #if (SYS_CPNT_STORM_MODE & SYS_CPNT_STORM_UNKNOWN_USTORM)
        if (rate_limit_group == SYS_CPNT_SWCTRL_RATE_LIMIT_GROUP_FOR_UNKNOWN_USTORM)
        {
            if (port_info[ifindex-1].unknown_ucast_storm_entry.unknown_ucast_storm_status == VAL_unkucastStormStatus_enabled)
            {
                SWCTRL_SetUnknownUnicastStormStatus(ifindex, VAL_unkucastStormStatus_disabled);
            }
        }
        #endif
    }
#endif

    /* 1. Traffic Control On Timer */
    /* Check: 1. Timer, Traffic Control On Timer. */
    if ((atc_broadcast_storm_timer.atc_broadcast_storm_traffic_control_on_timer < SYS_ADPT_ATC_BSTORM_MIN_TC_ON_TIMER) ||
        (atc_broadcast_storm_timer.atc_broadcast_storm_traffic_control_on_timer > SYS_ADPT_ATC_BSTORM_MAX_TC_ON_TIMER))
    {
        timer = SYS_DFLT_ATC_BSTORM_TC_ON_TIMER;
        SWCTRL_SetATCBroadcastStormTrafficControlOnTimer(timer);
    }

    /* 2. Traffic Control Release Timer */
    /* Check: 2. Timer, Traffic Control Release Timer. */
    if ((atc_broadcast_storm_timer.atc_broadcast_storm_traffic_control_release_timer < SYS_ADPT_ATC_BSTORM_MIN_TC_RELEASE_TIMER) ||
        (atc_broadcast_storm_timer.atc_broadcast_storm_traffic_control_release_timer > SYS_ADPT_ATC_BSTORM_MAX_TC_RELEASE_TIMER))
    {
        timer = SYS_DFLT_ATC_BSTORM_TC_RELEASE_TIMER;
        SWCTRL_SetATCBroadcastStormTrafficControlReleaseTimer(timer);
    }

    /* 3. Storm Alarm Threshold */
    /* Check: 3. Threshold, Storm Alarm Threshold. */
    if ((port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_storm_alarm_threshold < SYS_ADPT_ATC_BSTORM_MIN_RATE_LIMIT) ||
        (port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_storm_alarm_threshold > SYS_ADPT_ATC_BSTORM_MAX_RATE_LIMIT))
    {
        threshold = (SYS_DFLT_ATC_BSTORM_STORM_ALARM_THRESHOLD / SWCTRL_ATC_BROADCAST_STORM_ONE_THOUSAND);
        SWCTRL_SetATCBroadcastStormStormAlarmThreshold(ifindex, threshold);
    }

#if 0
    /* 4. Storm Clear Threshold */
    /* Check: 4. Threshold, Storm Clear Threshold. */
    if ((port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_storm_clear_threshold < SYS_ADPT_ATC_BSTORM_MIN_RATE_LIMIT) ||
        (port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_storm_clear_threshold > SYS_ADPT_ATC_BSTORM_MAX_RATE_LIMIT))
    {
        threshold = (SYS_DFLT_ATC_BSTORM_STORM_CLEAR_THRESHOLD / SWCTRL_ATC_BROADCAST_STORM_ONE_THOUSAND);
        SWCTRL_SetATCBroadcastStormStormClearThreshold(ifindex, threshold);
    }
    else
    {
        threshold = (port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_storm_clear_threshold / SWCTRL_ATC_BROADCAST_STORM_ONE_THOUSAND);
        SWCTRL_SetATCBroadcastStormStormClearThreshold(ifindex, threshold);
    }
#endif


    /* if normal port
     */
    if(!SWCTRL_IS_TRUNK (ifindex))
    {
        SWCTRL_LOCK();
        port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_auto_traffic_control_on = auto_traffic_control_on_status;
        port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_status= auto_traffic_control_on_status;
        SWCTRL_UNLOCK();
        retval = TRUE;

        /* 4. Storm Clear Threshold */
        /* Check: 4. Threshold, Storm Clear Threshold. */
        if ((port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_storm_clear_threshold < SYS_ADPT_ATC_BSTORM_MIN_RATE_LIMIT) ||
            (port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_storm_clear_threshold > SYS_ADPT_ATC_BSTORM_MAX_RATE_LIMIT))
        {
            threshold = (SYS_DFLT_ATC_BSTORM_STORM_CLEAR_THRESHOLD / SWCTRL_ATC_BROADCAST_STORM_ONE_THOUSAND);
            SWCTRL_SetATCBroadcastStormStormClearThreshold(ifindex, threshold);
        }
        else
        {
            threshold = (port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_storm_clear_threshold / SWCTRL_ATC_BROADCAST_STORM_ONE_THOUSAND);
            SWCTRL_SetATCBroadcastStormStormClearThreshold(ifindex, threshold);
        }

                /*ATC on , Broadcast Storm shold be closed*/
                SWCTRL_DisableBStormAfterClearThreshold(ifindex);

    }

    /* if trunk port
     */
#if (SYS_CPNT_ATC_BSTORM_SUPPORT_LPORT == TRUE)
    if(SWCTRL_IS_TRUNK (ifindex))
    {
        SWCTRL_TrunkPortExtInfo_T trunk_ext_p_info;
        UI32_T                    i;

        memset(&trunk_ext_p_info, 0, sizeof(SWCTRL_TrunkPortExtInfo_T));
        SWCTRL_GetTrunkPortExtInfo (ifindex, &trunk_ext_p_info);

        for(i=0; i<trunk_ext_p_info.member_number; i++)
        {
            unit = trunk_ext_p_info.member_list[i].unit;
            port = trunk_ext_p_info.member_list[i].port;

            SWCTRL_LOCK();
            port_info[(SWCTRL_UPORT_TO_IFINDEX(unit, port)) - 1].atc_broadcast_storm_entry.atc_broadcast_storm_auto_traffic_control_on = auto_traffic_control_on_status;
            port_info[(SWCTRL_UPORT_TO_IFINDEX(unit, port)) - 1].atc_broadcast_storm_entry.atc_broadcast_storm_status= auto_traffic_control_on_status;
            SWCTRL_UNLOCK();
            retval = TRUE;
        } /* End of for () */
        if (retval)
        {
            SWCTRL_LOCK();
            port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_auto_traffic_control_on = auto_traffic_control_on_status;
            port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_status= auto_traffic_control_on_status;
            SWCTRL_UNLOCK();

            /* 4. Storm Clear Threshold */
            /* Check: 4. Threshold, Storm Clear Threshold. */
            if ((port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_storm_clear_threshold < SYS_ADPT_ATC_BSTORM_MIN_RATE_LIMIT) ||
                (port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_storm_clear_threshold > SYS_ADPT_ATC_BSTORM_MAX_RATE_LIMIT))
            {
                threshold = (SYS_DFLT_ATC_BSTORM_STORM_CLEAR_THRESHOLD / SWCTRL_ATC_BROADCAST_STORM_ONE_THOUSAND);
                SWCTRL_SetATCBroadcastStormStormClearThreshold(ifindex, threshold);
            }
            else
            {
                threshold = (port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_storm_clear_threshold / SWCTRL_ATC_BROADCAST_STORM_ONE_THOUSAND);
                SWCTRL_SetATCBroadcastStormStormClearThreshold(ifindex, threshold);
            }
        }
    } /* End of trunk port */
#endif /* End of (SYS_CPNT_ATC_BSTORM_SUPPORT_LPORT == TRUE) */

    if(auto_traffic_control_on_status == VAL_atcBcastStormEnable_enabled)
    {
        SWCTRL_ATCBroadcastStormProtectionFSM(ifindex, SWCTRL_ATCBSTORM_ENTER_AUTO_EV);
    }
    else
    {
        SWCTRL_ATCBroadcastStormProtectionFSM(ifindex, SWCTRL_ATCBSTORM_LEAVE_AUTO_EV);
    }

    SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME ();
    SWCTRL_RETURN_AND_RELEASE_CSC( retval );
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetATCBroadcastStormAutoTrafficControlOnStatus
 * -------------------------------------------------------------------------
 * 2.
 * FUNCTION: This function will get the auto traffic control on status of broadcast
 *           storm control function
 * INPUT   : ifindex -- which port to set
 *
 * OUTPUT  : auto_traffic_control_on_status    -- which status of auto traffic control on
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_GetATCBroadcastStormAutoTrafficControlOnStatus(UI32_T ifindex, UI32_T *auto_traffic_control_on_status)
{
    /* LOCAL VARIABLES
     */

    /* BODY
     */
    /* Check Management Port.
     * TRUE: The port is a management port.
     * FALSE: The port is not a managemet port.
     * It returns FALSE, when the port is a management port.
     */
    if ( TRUE == SWCTRL_IsManagementPort(ifindex) )
    {
        return FALSE;
    }

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if ( ifindex == 0                          ||
         ifindex > SYS_ADPT_TOTAL_NBR_OF_LPORT )
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Logical Port ID (1-%d)", SYS_ADPT_TOTAL_NBR_OF_LPORT);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_LOGICAL_PORT_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (!SWCTRL_IS_EXIST (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Interface");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

#if (SYS_CPNT_ATC_BSTORM_SUPPORT_LPORT != TRUE)
    if (SWCTRL_IS_TRUNK (ifindex))
    {
            EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                      SWCTRL_NO_USE_FUNC_NO,
                                      EH_TYPE_MSG_TRUNK_CNFG_ERR,
                                      SYSLOG_LEVEL_INFO,
                                      "it doesn't support Broadcast Storm Control.");  /*SWCTRL_ENO_NOT_TRUNK*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#else
    if (SWCTRL_IS_TRUNK_MEMBER (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#endif

    SWCTRL_LOCK();
    *auto_traffic_control_on_status = port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_auto_traffic_control_on;
    SWCTRL_UNLOCK();

    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetATCBroadcastStormAutoTrafficControlReleaseStatus
 * -------------------------------------------------------------------------
 * 3.
 * FUNCTION: This function will set the auto traffic control release status of broadcast
 *           storm control function
 * INPUT   : ifindex -- which port to set
 *           auto_traffic_control_release_status    -- which status of auto traffic control release
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetATCBroadcastStormAutoTrafficControlReleaseStatus(UI32_T ifindex, UI32_T auto_traffic_control_release_status)
{
    /* LOCAL VARIABLES
     */
#if (SYS_CPNT_ATC_BSTORM_SUPPORT_LPORT == TRUE)
    UI32_T                          unit, port;
#endif
    BOOL_T                          retval = FALSE;

    /* BODY
     */
    /* Check Management Port.
     * TRUE: The port is a management port.
     * FALSE: The port is not a managemet port.
     * It returns FALSE, when the port is a management port.
     */
    if ( TRUE == SWCTRL_IsManagementPort(ifindex) )
    {
        return FALSE;
    }

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if( ifindex == 0 || ifindex > SYS_ADPT_TOTAL_NBR_OF_LPORT)
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Logical Port ID (1-%d)", SYS_ADPT_TOTAL_NBR_OF_LPORT);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_LOGICAL_PORT_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (!SWCTRL_IS_EXIST (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Interface");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

#if (SYS_CPNT_ATC_BSTORM_SUPPORT_LPORT == TRUE)
    if (SWCTRL_IS_TRUNK_MEMBER (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#endif

    if((auto_traffic_control_release_status != VAL_atcBcastStormAutoRelease_enabled) &&
       (auto_traffic_control_release_status != VAL_atcBcastStormAutoRelease_disabled))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_INVALID_PARAMETER,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "auto traffic control on status"); /*SWCTRL_ENO_INVALID_AUTO_TRAFFIC_CONTROL_ON_STATUS*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if(port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_auto_traffic_control_release == auto_traffic_control_release_status)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
    }

    if (SWCTRL_IsServerBladePort (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_SRV_BLADE_PORT_CNFG,
                                  SYSLOG_LEVEL_INFO,
                                  "Configuring Broadcast Storm Control");     /*SWCTRL_ENO_DENY_ON_SERVER_BLADE_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }


    /* if normal port
     */
    if(!SWCTRL_IS_TRUNK (ifindex))
    {
        SWCTRL_LOCK();
        port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_auto_traffic_control_release = auto_traffic_control_release_status;
        SWCTRL_UNLOCK();
        retval = TRUE;
    }

    /* if trunk port
     */
#if (SYS_CPNT_ATC_BSTORM_SUPPORT_LPORT == TRUE)
    if(SWCTRL_IS_TRUNK (ifindex))
    {
        SWCTRL_TrunkPortExtInfo_T trunk_ext_p_info;
        UI32_T                    i;

        memset(&trunk_ext_p_info, 0, sizeof(SWCTRL_TrunkPortExtInfo_T));
        SWCTRL_GetTrunkPortExtInfo (ifindex, &trunk_ext_p_info);

        for(i=0; i<trunk_ext_p_info.member_number; i++)
        {
            unit = trunk_ext_p_info.member_list[i].unit;
            port = trunk_ext_p_info.member_list[i].port;

            SWCTRL_LOCK();
            port_info[(SWCTRL_UPORT_TO_IFINDEX(unit, port)) - 1].atc_broadcast_storm_entry.atc_broadcast_storm_auto_traffic_control_release = auto_traffic_control_release_status;
            SWCTRL_UNLOCK();
            retval = TRUE;
        } /* End of for () */
        if (retval)
        {
            SWCTRL_LOCK();
            port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_auto_traffic_control_release = auto_traffic_control_release_status;
            SWCTRL_UNLOCK();
        }
    } /* End of trunk port */
#endif /* End of (SYS_CPNT_ATC_BSTORM_SUPPORT_LPORT == TRUE) */

    SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME ();
    SWCTRL_RETURN_AND_RELEASE_CSC( retval );
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetATCBroadcastStormAutoTrafficControlReleaseStatus
 * -------------------------------------------------------------------------
 * 4.
 * FUNCTION: This function will get the auto traffic control release status of broadcast
 *           storm control function
 * INPUT   : ifindex -- which port to set
 *           auto_traffic_control_release_status    -- which status of auto traffic control release
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_GetATCBroadcastStormAutoTrafficControlReleaseStatus(UI32_T ifindex, UI32_T *auto_traffic_control_release_status)
{
    /* LOCAL VARIABLES
     */

    /* BODY
     */
    /* Check Management Port.
     * TRUE: The port is a management port.
     * FALSE: The port is not a managemet port.
     * It returns FALSE, when the port is a management port.
     */
    if ( TRUE == SWCTRL_IsManagementPort(ifindex) )
    {
        return FALSE;
    }

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if ( ifindex == 0                          ||
         ifindex > SYS_ADPT_TOTAL_NBR_OF_LPORT )
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Logical Port ID (1-%d)", SYS_ADPT_TOTAL_NBR_OF_LPORT);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_LOGICAL_PORT_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (!SWCTRL_IS_EXIST (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Interface");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

#if (SYS_CPNT_ATC_BSTORM_SUPPORT_LPORT != TRUE)
    if (SWCTRL_IS_TRUNK (ifindex))
    {
            EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                      SWCTRL_NO_USE_FUNC_NO,
                                      EH_TYPE_MSG_TRUNK_CNFG_ERR,
                                      SYSLOG_LEVEL_INFO,
                                      "it doesn't support Broadcast Storm Control.");  /*SWCTRL_ENO_NOT_TRUNK*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#else
    if (SWCTRL_IS_TRUNK_MEMBER (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#endif

    SWCTRL_LOCK();
    *auto_traffic_control_release_status = port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_auto_traffic_control_release;
    SWCTRL_UNLOCK();

    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
}


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetATCBroadcastStormTrafficControlReleaseStatus
 * -------------------------------------------------------------------------
 * 7.
 * FUNCTION: This function will set the traffic control release status of broadcast
 *           storm control function
 * INPUT   : ifindex -- which port to set
 *           traffic_control_release_status    -- which status of traffic control release
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetATCBroadcastStormTrafficControlReleaseStatus(UI32_T ifindex, UI32_T traffic_control_release_status)
{
    /* LOCAL VARIABLES
     */
#if (SYS_CPNT_ATC_BSTORM_SUPPORT_LPORT == TRUE)
    UI32_T                          unit, port;
#endif
    BOOL_T                          retval = FALSE;

    /* BODY
     */
    /* Check Management Port.
     * TRUE: The port is a management port.
     * FALSE: The port is not a managemet port.
     * It returns FALSE, when the port is a management port.
     */
    if ( TRUE == SWCTRL_IsManagementPort(ifindex) )
    {
        return FALSE;
    }

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if( ifindex == 0 || ifindex > SYS_ADPT_TOTAL_NBR_OF_LPORT)
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Logical Port ID (1-%d)", SYS_ADPT_TOTAL_NBR_OF_LPORT);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_LOGICAL_PORT_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (!SWCTRL_IS_EXIST (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Interface");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

#if (SYS_CPNT_ATC_BSTORM_SUPPORT_LPORT != TRUE)
    if (SWCTRL_IS_TRUNK (ifindex))
    {
            EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                      SWCTRL_NO_USE_FUNC_NO,
                                      EH_TYPE_MSG_TRUNK_CNFG_ERR,
                                      SYSLOG_LEVEL_INFO,
                                      "it doesn't support Broadcast Storm Control.");  /*SWCTRL_ENO_NOT_TRUNK*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#else
    if (SWCTRL_IS_TRUNK_MEMBER (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#endif

    if(port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_traffic_control_release == traffic_control_release_status)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
    }

    if (traffic_control_release_status == SWCTRL_ATC_BROADCAST_STORM_TC_RELEASE_ENABLE)
    {
        if (port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_auto_traffic_control_on == VAL_atcBcastStormEnable_enabled)
        {
            if ( (port_info[ifindex-1].atc_broadcast_storm_entry.state_machine_state  == SWCTRL_ATCBSTORM_CONTROL_ST) ||
                (port_info[ifindex-1].atc_broadcast_storm_entry.state_machine_state  == SWCTRL_ATCBSTORM_CONTROLLOW_ST) )
            {
                SWCTRL_ATCBroadcastStormProtectionFSM(ifindex, SWCTRL_ATCBSTORM_MANUAL_EV);
            }
        }
        retval = TRUE;
    }
    else if (traffic_control_release_status == SWCTRL_ATC_BROADCAST_STORM_TC_RELEASE_DISABLE)
    {
        port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_traffic_control_release = traffic_control_release_status;
        retval = TRUE;
    }

    SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME ();
    SWCTRL_RETURN_AND_RELEASE_CSC( retval );
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetATCBroadcastStormTrafficControlReleaseStatus
 * -------------------------------------------------------------------------
 * 8.
 * FUNCTION: This function will get the traffic control release status of broadcast
 *           storm control function
 * INPUT   : ifindex -- which port to set
 *           traffic_control_release_status    -- which status of traffic control release
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_GetATCBroadcastStormTrafficControlReleaseStatus(UI32_T ifindex, UI32_T *traffic_control_release_status)
{
    /* LOCAL VARIABLES
     */

    /* BODY
     */
    /* Check Management Port.
     * TRUE: The port is a management port.
     * FALSE: The port is not a managemet port.
     * It returns FALSE, when the port is a management port.
     */
    if ( TRUE == SWCTRL_IsManagementPort(ifindex) )
    {
        return FALSE;
    }

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if ( ifindex == 0                          ||
         ifindex > SYS_ADPT_TOTAL_NBR_OF_LPORT )
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Logical Port ID (1-%d)", SYS_ADPT_TOTAL_NBR_OF_LPORT);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_LOGICAL_PORT_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (!SWCTRL_IS_EXIST (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Interface");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

#if (SYS_CPNT_ATC_BSTORM_SUPPORT_LPORT != TRUE)
    if (SWCTRL_IS_TRUNK (ifindex))
    {
            EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                      SWCTRL_NO_USE_FUNC_NO,
                                      EH_TYPE_MSG_TRUNK_CNFG_ERR,
                                      SYSLOG_LEVEL_INFO,
                                      "it doesn't support Broadcast Storm Control.");  /*SWCTRL_ENO_NOT_TRUNK*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#else
    if (SWCTRL_IS_TRUNK_MEMBER (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#endif

    SWCTRL_LOCK();
    *traffic_control_release_status = port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_traffic_control_release;
    SWCTRL_UNLOCK();

    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetATCBroadcastStormTrafficControlOnTimer
 * -------------------------------------------------------------------------
 * 9.
 * FUNCTION: This function will set the auto traffic control on status of broadcast
 *           storm control function
 * INPUT   : traffic_control_on_timer    -- which status of traffic control on timer
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetATCBroadcastStormTrafficControlOnTimer(UI32_T traffic_control_on_timer)
{
    /* LOCAL VARIABLES
     */
#if (SYS_CPNT_ATC_BSTORM_SUPPORT_LPORT == TRUE)
    UI32_T                          unit, port;
#endif
    BOOL_T                          retval = FALSE;

    /* BODY
     */
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if((traffic_control_on_timer < SYS_ADPT_ATC_BSTORM_MIN_TC_ON_TIMER) || (traffic_control_on_timer > SYS_ADPT_ATC_BSTORM_MAX_TC_ON_TIMER))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_INVALID_PARAMETER,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "traffic control on timer"); /*SWCTRL_ENO_INVALID_TRAFFIC_CONTROL_ON_TIMER*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if(atc_broadcast_storm_timer.atc_broadcast_storm_traffic_control_on_timer == traffic_control_on_timer)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
    }

    SWCTRL_LOCK();
    atc_broadcast_storm_timer.atc_broadcast_storm_traffic_control_on_timer = traffic_control_on_timer;
    SWCTRL_UNLOCK();
    retval = TRUE;
    SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME ();
    SWCTRL_RETURN_AND_RELEASE_CSC( retval );
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetATCBroadcastStormTrafficControlOnTimer
 * -------------------------------------------------------------------------
 * 10.
 * FUNCTION: This function will get the traffic control on timer of broadcast
 *           storm control function
 * INPUT   : None
 * OUTPUT  : traffic_control_on_timer    -- which status of traffic control on timer
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_GetATCBroadcastStormTrafficControlOnTimer(UI32_T *traffic_control_on_timer)
{
    /* LOCAL VARIABLES
     */

    /* BODY
     */
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    SWCTRL_LOCK();
    *traffic_control_on_timer = atc_broadcast_storm_timer.atc_broadcast_storm_traffic_control_on_timer;
    SWCTRL_UNLOCK();

    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetATCBroadcastStormTrafficControlReleaseTimer
 * -------------------------------------------------------------------------
 * 11.
 * FUNCTION: This function will set the traffic control release timer of broadcast
 *           storm control function
 * INPUT   : traffic_control_release_timer    -- which status of traffic control release timer
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetATCBroadcastStormTrafficControlReleaseTimer(UI32_T traffic_control_release_timer)
{
    /* LOCAL VARIABLES
     */
#if (SYS_CPNT_ATC_BSTORM_SUPPORT_LPORT == TRUE)
    UI32_T                          unit, port;
#endif
    BOOL_T                          retval = FALSE;

    /* BODY
     */
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if((traffic_control_release_timer < SYS_ADPT_ATC_BSTORM_MIN_TC_RELEASE_TIMER) || (traffic_control_release_timer > SYS_ADPT_ATC_BSTORM_MAX_TC_RELEASE_TIMER))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_INVALID_PARAMETER,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "traffic control release timer"); /*SWCTRL_ENO_INVALID_TRAFFIC_CONTROL_RELEASE_TIMER*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if(atc_broadcast_storm_timer.atc_broadcast_storm_traffic_control_release_timer == traffic_control_release_timer)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
    }

    SWCTRL_LOCK();
    atc_broadcast_storm_timer.atc_broadcast_storm_traffic_control_release_timer = traffic_control_release_timer;
    SWCTRL_UNLOCK();
    retval = TRUE;

    SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME ();
    SWCTRL_RETURN_AND_RELEASE_CSC( retval );
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetATCBroadcastStormTrafficControlReleaseTimer
 * -------------------------------------------------------------------------
 * 12.
 * FUNCTION: This function will get the traffic control release timer of broadcast
 *           storm control function
 * INPUT   : None
 * OUTPUT  : traffic_control_release_timer    -- which status of traffic control release timer
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_GetATCBroadcastStormTrafficControlReleaseTimer(UI32_T *traffic_control_release_timer)
{
    /* LOCAL VARIABLES
     */

    /* BODY
     */
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    SWCTRL_LOCK();
    *traffic_control_release_timer = atc_broadcast_storm_timer.atc_broadcast_storm_traffic_control_release_timer;
    SWCTRL_UNLOCK();

    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetATCBroadcastStormStormAlarmThreshold
 * -------------------------------------------------------------------------
 * 13.
 * FUNCTION: This function will set the storm alarm fire threshold of broadcast
 *           storm control function
 * INPUT   : ifindex -- which port to set
 *           storm_alarm_threshold    -- which status of storm alarm fire threshold
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetATCBroadcastStormStormAlarmThreshold(UI32_T ifindex, UI32_T storm_alarm_threshold)
{
    SWCTRL_RETURN_AND_RELEASE_CSC( SWCTRL_SetATCBroadcastStormStormAlarmThresholdEx(ifindex, storm_alarm_threshold, 0) );
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetATCBroadcastStormStormAlarmThreshold
 * -------------------------------------------------------------------------
 * 14.
 * FUNCTION: This function will get the storm alarm fire threshold of broadcast
 *           storm control function
 * INPUT   : ifindex -- which port to set
 * OUTPUT  : storm_alarm_threshold    -- which status of storm alarm fire threshold
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_GetATCBroadcastStormStormAlarmThreshold(UI32_T ifindex, UI32_T *storm_alarm_threshold)
{
    /* LOCAL VARIABLES
     */

    /* BODY
     */
    /* Check Management Port.
     * TRUE: The port is a management port.
     * FALSE: The port is not a managemet port.
     * It returns FALSE, when the port is a management port.
     */
    if ( TRUE == SWCTRL_IsManagementPort(ifindex) )
    {
        return FALSE;
    }

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if ((ifindex == 0) ||(ifindex > SYS_ADPT_TOTAL_NBR_OF_LPORT))
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Logical Port ID (1-%d)", SYS_ADPT_TOTAL_NBR_OF_LPORT);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_LOGICAL_PORT_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (!SWCTRL_IS_EXIST (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Interface");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

#if (SYS_CPNT_ATC_BSTORM_SUPPORT_LPORT != TRUE)
    if (SWCTRL_IS_TRUNK (ifindex))
    {
            EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                      SWCTRL_NO_USE_FUNC_NO,
                                      EH_TYPE_MSG_TRUNK_CNFG_ERR,
                                      SYSLOG_LEVEL_INFO,
                                      "it doesn't support Broadcast Storm Control.");  /*SWCTRL_ENO_NOT_TRUNK*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#else
    if (SWCTRL_IS_TRUNK_MEMBER (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#endif

    SWCTRL_LOCK();
    *storm_alarm_threshold = (port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_storm_alarm_threshold / SWCTRL_ATC_BROADCAST_STORM_ONE_THOUSAND);
    SWCTRL_UNLOCK();

    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetATCBroadcastStormStormClearThreshold
 * -------------------------------------------------------------------------
 * 15.
 * FUNCTION: This function will set the storm alarm clear threshold of broadcast
 *           storm control function
 * INPUT   : ifindex -- which port to set
 *           auto_clear_threshold    -- which status of storm alarm clear threshold
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetATCBroadcastStormStormClearThreshold(UI32_T ifindex, UI32_T storm_clear_threshold)
{
    SWCTRL_RETURN_AND_RELEASE_CSC( SWCTRL_SetATCBroadcastStormStormAlarmThresholdEx(ifindex, 0, storm_clear_threshold) );
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetATCBroadcastStormStormClearThreshold
 * -------------------------------------------------------------------------
 * 16.
 * FUNCTION: This function will get the storm alarm clear threshold of broadcast
 *           storm control function
 * INPUT   : ifindex -- which port to set
 * OUTPUT  : auto_clear_threshold    -- which status of storm alarm clear threshold
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_GetATCBroadcastStormStormClearThreshold(UI32_T ifindex, UI32_T *storm_clear_threshold)
{
    /* LOCAL VARIABLES
     */

    /* BODY
     */
    /* Check Management Port.
     * TRUE: The port is a management port.
     * FALSE: The port is not a managemet port.
     * It returns FALSE, when the port is a management port.
     */
    if ( TRUE == SWCTRL_IsManagementPort(ifindex) )
    {
        return FALSE;
    }

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if ((ifindex == 0) || (ifindex > SYS_ADPT_TOTAL_NBR_OF_LPORT))
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Logical Port ID (1-%d)", SYS_ADPT_TOTAL_NBR_OF_LPORT);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_LOGICAL_PORT_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (!SWCTRL_IS_EXIST (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Interface");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

#if (SYS_CPNT_ATC_BSTORM_SUPPORT_LPORT != TRUE)
    if (SWCTRL_IS_TRUNK (ifindex))
    {
            EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                      SWCTRL_NO_USE_FUNC_NO,
                                      EH_TYPE_MSG_TRUNK_CNFG_ERR,
                                      SYSLOG_LEVEL_INFO,
                                      "it doesn't support Broadcast Storm Control.");  /*SWCTRL_ENO_NOT_TRUNK*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#else
    if (SWCTRL_IS_TRUNK_MEMBER (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#endif

    SWCTRL_LOCK();
    *storm_clear_threshold = (port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_storm_clear_threshold / SWCTRL_ATC_BROADCAST_STORM_ONE_THOUSAND);
    SWCTRL_UNLOCK();

    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetATCBroadcastStormStormAlarmThresholdEx
 * -------------------------------------------------------------------------
 * FUNCTION: This function will set the storm alarm fire/clear threshold of broadcast
 *           storm control function
 * INPUT   : ifindex -- which port to set
 *           storm_alarm_threshold    -- which status of storm alarm fire threshold
 *                                       0 indicates unchanged.
 *           storm_clear_threshold    -- which status of storm alarm clear threshold
 *                                       0 indicates unchanged.
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetATCBroadcastStormStormAlarmThresholdEx(UI32_T ifindex, UI32_T storm_alarm_threshold, UI32_T storm_clear_threshold)
{
    /* LOCAL VARIABLES
     */
    UI32_T                          unit, port;
    UI32_T                          cfg_storm_alarm_threshold, cfg_storm_clear_threshold;
    UI32_T                          rate = 0;
    BOOL_T                          retval = TRUE;

    /* BODY
     */
    /* Check Management Port.
     * TRUE: The port is a management port.
     * FALSE: The port is not a managemet port.
     * It returns FALSE, when the port is a management port.
     */
    if ( TRUE == SWCTRL_IsManagementPort(ifindex) )
    {
        return FALSE;
    }

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if((ifindex == 0) || (ifindex > SYS_ADPT_TOTAL_NBR_OF_LPORT))
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Logical Port ID (1-%d)", SYS_ADPT_TOTAL_NBR_OF_LPORT);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_LOGICAL_PORT_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (!SWCTRL_IS_EXIST (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Interface");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (storm_alarm_threshold == 0)
    {
        cfg_storm_alarm_threshold = port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_storm_alarm_threshold;
    }
    else
    {
        cfg_storm_alarm_threshold = (storm_alarm_threshold * SWCTRL_ATC_BROADCAST_STORM_ONE_THOUSAND);
    }

    if (storm_clear_threshold == 0)
    {
        cfg_storm_clear_threshold = port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_storm_clear_threshold;
    }
    else
    {
        cfg_storm_clear_threshold = (storm_clear_threshold * SWCTRL_ATC_BROADCAST_STORM_ONE_THOUSAND);
        rate = cfg_storm_clear_threshold;
    }

    if (cfg_storm_alarm_threshold < cfg_storm_clear_threshold)
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Alarm Fire Threshold must be larger than or equal to Alarm Clear Threshold");  /*SWCTRL_ENO_ALARM_FIRE_THRESHOLD*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

#if (SYS_CPNT_ATC_BSTORM_SUPPORT_LPORT != TRUE)
    if (SWCTRL_IS_TRUNK (ifindex))
    {
            EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                      SWCTRL_NO_USE_FUNC_NO,
                                      EH_TYPE_MSG_TRUNK_CNFG_ERR,
                                      SYSLOG_LEVEL_INFO,
                                      "it doesn't support Broadcast Storm Control.");  /*SWCTRL_ENO_NOT_TRUNK*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#else
    if (SWCTRL_IS_TRUNK_MEMBER (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#endif

    if ((cfg_storm_alarm_threshold < SYS_ADPT_ATC_BSTORM_MIN_RATE_LIMIT) || (cfg_storm_alarm_threshold > SYS_ADPT_ATC_BSTORM_MAX_RATE_LIMIT))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_INVALID_PARAMETER,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "storm alarm threshold"); /*SWCTRL_ENO_INVALID_STORM_ALARM_THRESHOLD*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if ((cfg_storm_clear_threshold < SYS_ADPT_ATC_BSTORM_MIN_RATE_LIMIT) || (cfg_storm_clear_threshold > SYS_ADPT_ATC_BSTORM_MAX_RATE_LIMIT))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_INVALID_PARAMETER,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "storm alarm threshold"); /*SWCTRL_ENO_INVALID_STORM_ALARM_THRESHOLD*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_storm_alarm_threshold == cfg_storm_alarm_threshold &&
        port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_storm_clear_threshold == cfg_storm_clear_threshold)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
    }

    if (SWCTRL_IsServerBladePort (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_SRV_BLADE_PORT_CNFG,
                                  SYSLOG_LEVEL_INFO,
                                  "Configuring Broadcast Storm Control");     /*SWCTRL_ENO_DENY_ON_SERVER_BLADE_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    /* if normal port
     */
    if (!SWCTRL_IS_TRUNK (ifindex))
    {
        unit = SWCTRL_IFINDEX_TO_UNIT(ifindex);
        port = SWCTRL_IFINDEX_TO_PORT(ifindex);

        if (rate != 0)
        {
            if (port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_auto_traffic_control_on == VAL_atcBcastStormEnable_enabled)
            {
                retval = SWCTRL_SetUPortATCBroadcastStormControlRateLimit(unit, port, VAL_atcBcastStormSampleType_packet_rate, rate, rate);
            }
            else if (port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_auto_traffic_control_on == VAL_atcBcastStormEnable_disabled)
            {
                port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_ifindex = ifindex;
                port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_sample_type = VAL_atcBcastStormSampleType_packet_rate;
                port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_packet_rate   = 0;
                port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_octet_rate = 0;
                port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_percent    = 0;

                port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_packet_rate = rate;
            }
        }

        if (retval)
        {
            port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_storm_alarm_threshold = cfg_storm_alarm_threshold;
            port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_storm_clear_threshold = cfg_storm_clear_threshold;

#if (SYS_CPNT_SWCTRL_SINGLE_INGRESS_RATE_LIMIT == TRUE)
            if (rate != 0)
            {
                SWCTRL_SyncUPortATCStormControlRateLimit(unit, port);
            }
#endif
        }
    }

    /* if trunk port
     */
#if (SYS_CPNT_ATC_BSTORM_SUPPORT_LPORT == TRUE)
    if (SWCTRL_IS_TRUNK (ifindex))
    {
        SWCTRL_TrunkPortExtInfo_T trunk_ext_p_info;
        UI32_T                    i;
        UI32_T                    member_ifindex;

        memset(&trunk_ext_p_info, 0, sizeof(SWCTRL_TrunkPortExtInfo_T));
        SWCTRL_GetTrunkPortExtInfo (ifindex, &trunk_ext_p_info);

        for (i = 0; i < trunk_ext_p_info.member_number && retval; i++)
        {
            unit = trunk_ext_p_info.member_list[i].unit;
            port = trunk_ext_p_info.member_list[i].port;
            member_ifindex = SWCTRL_UPORT_TO_IFINDEX (unit, port);

            if (rate != 0)
            {
                if (port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_auto_traffic_control_on == VAL_atcBcastStormEnable_enabled)
                {
                    retval = SWCTRL_SetUPortATCBroadcastStormControlRateLimit(unit, port, VAL_atcBcastStormSampleType_packet_rate, rate, rate);
                }
                else if (port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_auto_traffic_control_on == VAL_atcBcastStormEnable_disabled)
                {
                    port_info[member_ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_ifindex = member_ifindex;
                    port_info[member_ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_sample_type = VAL_atcBcastStormSampleType_packet_rate;
                    port_info[member_ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_packet_rate   = 0;
                    port_info[member_ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_octet_rate = 0;
                    port_info[member_ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_percent    = 0;

                    port_info[member_ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_packet_rate = rate;
                }
            }

            if (retval)
            {
                port_info[member_ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_storm_alarm_threshold = cfg_storm_alarm_threshold;
                port_info[member_ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_storm_clear_threshold = cfg_storm_clear_threshold;

#if (SYS_CPNT_SWCTRL_SINGLE_INGRESS_RATE_LIMIT == TRUE)
                if (rate != 0)
                {
                    SWCTRL_SyncUPortATCStormControlRateLimit(unit, port);
                }
#endif
            }
        } /* End of for () */

        if (retval)
        {
            if (rate != 0)
            {
                port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_ifindex = ifindex;
                port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_sample_type = VAL_atcBcastStormSampleType_packet_rate;
                port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_packet_rate   = 0;
                port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_octet_rate = 0;
                port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_percent    = 0;

                port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_packet_rate = rate;
            }

            port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_storm_alarm_threshold = cfg_storm_alarm_threshold;
            port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_storm_clear_threshold = cfg_storm_clear_threshold;
        }
    } /* End of trunk port */
#endif /* End of (SYS_CPNT_ATC_BSTORM_SUPPORT_LPORT == TRUE) */

    SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME ();
    SWCTRL_RETURN_AND_RELEASE_CSC( retval );
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetATCBroadcastStormTrapStormAlarmStatus
 * -------------------------------------------------------------------------
 * 17.
 * FUNCTION: This function will set the storm alarm fire trap status of broadcast
 *           storm control function
 * INPUT   : ifindex -- which port to set
 *           trap_storm_alarm_status    -- which status of storm alarm fire trap
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetATCBroadcastStormTrapStormAlarmStatus(UI32_T ifindex, UI32_T trap_storm_alarm_status)
{
    /* LOCAL VARIABLES
     */
#if (SYS_CPNT_ATC_BSTORM_SUPPORT_LPORT == TRUE)
    UI32_T                          unit, port;
#endif
    BOOL_T                          retval = FALSE;

    /* BODY
     */
    /* Check Management Port.
     * TRUE: The port is a management port.
     * FALSE: The port is not a managemet port.
     * It returns FALSE, when the port is a management port.
     */
    if ( TRUE == SWCTRL_IsManagementPort(ifindex) )
    {
        return FALSE;
    }

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if((ifindex == 0) ||(ifindex > SYS_ADPT_TOTAL_NBR_OF_LPORT))
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Logical Port ID (1-%d)", SYS_ADPT_TOTAL_NBR_OF_LPORT);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_LOGICAL_PORT_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (!SWCTRL_IS_EXIST (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Interface");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

#if (SYS_CPNT_ATC_BSTORM_SUPPORT_LPORT != TRUE)
    if (SWCTRL_IS_TRUNK (ifindex))
    {
            EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                      SWCTRL_NO_USE_FUNC_NO,
                                      EH_TYPE_MSG_TRUNK_CNFG_ERR,
                                      SYSLOG_LEVEL_INFO,
                                      "it doesn't support Broadcast Storm Control.");  /*SWCTRL_ENO_NOT_TRUNK*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#else
    if (SWCTRL_IS_TRUNK_MEMBER (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#endif

    if((trap_storm_alarm_status != VAL_atcBcastStormAlarmFireTrapStatus_enabled) &&
       (trap_storm_alarm_status != VAL_atcBcastStormAlarmFireTrapStatus_disabled))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_INVALID_PARAMETER,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "trap storm alarm"); /*SWCTRL_ENO_INVALID_TRAP_STORM_ALARM*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if(port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_trap_storm_alarm == trap_storm_alarm_status)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
    }

    if (SWCTRL_IsServerBladePort (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_SRV_BLADE_PORT_CNFG,
                                  SYSLOG_LEVEL_INFO,
                                  "Configuring Broadcast Storm Control");     /*SWCTRL_ENO_DENY_ON_SERVER_BLADE_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }


    /* if normal port
     */
    if(!SWCTRL_IS_TRUNK (ifindex))
    {
        SWCTRL_LOCK();
        port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_trap_storm_alarm = trap_storm_alarm_status;
        SWCTRL_UNLOCK();
        retval = TRUE;
    }

    /* if trunk port
     */
#if (SYS_CPNT_ATC_BSTORM_SUPPORT_LPORT == TRUE)
    if(SWCTRL_IS_TRUNK (ifindex))
    {
        SWCTRL_TrunkPortExtInfo_T trunk_ext_p_info;
        UI32_T                    i;

        memset(&trunk_ext_p_info, 0, sizeof(SWCTRL_TrunkPortExtInfo_T));
        SWCTRL_GetTrunkPortExtInfo (ifindex, &trunk_ext_p_info);

        for(i=0; i<trunk_ext_p_info.member_number; i++)
        {
            unit = trunk_ext_p_info.member_list[i].unit;
            port = trunk_ext_p_info.member_list[i].port;

            SWCTRL_LOCK();
            port_info[(SWCTRL_UPORT_TO_IFINDEX(unit, port)) - 1].atc_broadcast_storm_entry.atc_broadcast_storm_trap_storm_alarm = trap_storm_alarm_status;
            SWCTRL_UNLOCK();
            retval = TRUE;
        } /* End of for () */
        if (retval)
        {
            SWCTRL_LOCK();
            port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_trap_storm_alarm = trap_storm_alarm_status;
            SWCTRL_UNLOCK();
        }
    } /* End of trunk port */
#endif /* End of (SYS_CPNT_ATC_BSTORM_SUPPORT_LPORT == TRUE) */

    SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME ();
    SWCTRL_RETURN_AND_RELEASE_CSC( retval );
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetATCBroadcastStormTrapStormAlarmStatus
 * -------------------------------------------------------------------------
 * 18.
 * FUNCTION: This function will get the storm alarm fire trap status of broadcast
 *           storm control function
 * INPUT   : ifindex -- which port to set
 * OUTPUT  : trap_storm_alarm_status    -- which status of storm alarm fire trap
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_GetATCBroadcastStormTrapStormAlarmStatus(UI32_T ifindex, UI32_T *trap_storm_alarm_status)
{
    /* LOCAL VARIABLES
     */

    /* BODY
     */
    /* Check Management Port.
     * TRUE: The port is a management port.
     * FALSE: The port is not a managemet port.
     * It returns FALSE, when the port is a management port.
     */
    if ( TRUE == SWCTRL_IsManagementPort(ifindex) )
    {
        return FALSE;
    }

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if ((ifindex == 0) ||(ifindex > SYS_ADPT_TOTAL_NBR_OF_LPORT))
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Logical Port ID (1-%d)", SYS_ADPT_TOTAL_NBR_OF_LPORT);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_LOGICAL_PORT_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (!SWCTRL_IS_EXIST (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Interface");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

#if (SYS_CPNT_ATC_BSTORM_SUPPORT_LPORT != TRUE)
    if (SWCTRL_IS_TRUNK (ifindex))
    {
            EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                      SWCTRL_NO_USE_FUNC_NO,
                                      EH_TYPE_MSG_TRUNK_CNFG_ERR,
                                      SYSLOG_LEVEL_INFO,
                                      "it doesn't support Broadcast Storm Control.");  /*SWCTRL_ENO_NOT_TRUNK*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#else
    if (SWCTRL_IS_TRUNK_MEMBER (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#endif

    SWCTRL_LOCK();
    *trap_storm_alarm_status = port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_trap_storm_alarm;
    SWCTRL_UNLOCK();

    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetATCBroadcastStormTrapStormClearStatus
 * -------------------------------------------------------------------------
 * 19.
 * FUNCTION: This function will set the storm alarm clear trap status of broadcast
 *           storm control function
 * INPUT   : ifindex -- which port to set
 *           trap_storm_clear_status    -- which status of storm alarm clear trap
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetATCBroadcastStormTrapStormClearStatus(UI32_T ifindex, UI32_T trap_storm_clear_status)
{
    /* LOCAL VARIABLES
     */
#if (SYS_CPNT_ATC_BSTORM_SUPPORT_LPORT == TRUE)
    UI32_T                          unit, port;
#endif
    BOOL_T                          retval = FALSE;

    /* BODY
     */
    /* Check Management Port.
     * TRUE: The port is a management port.
     * FALSE: The port is not a managemet port.
     * It returns FALSE, when the port is a management port.
     */
    if ( TRUE == SWCTRL_IsManagementPort(ifindex) )
    {
        return FALSE;
    }

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if ((ifindex == 0) ||(ifindex > SYS_ADPT_TOTAL_NBR_OF_LPORT))
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Logical Port ID (1-%d)", SYS_ADPT_TOTAL_NBR_OF_LPORT);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_LOGICAL_PORT_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (!SWCTRL_IS_EXIST (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Interface");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

#if (SYS_CPNT_ATC_BSTORM_SUPPORT_LPORT == TRUE)
    if (SWCTRL_IS_TRUNK_MEMBER (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#endif

    if((trap_storm_clear_status != VAL_atcBcastStormAlarmClearTrapStatus_enabled) &&
       (trap_storm_clear_status != VAL_atcBcastStormAlarmClearTrapStatus_disabled))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_INVALID_PARAMETER,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "trap storm alarm"); /*SWCTRL_ENO_INVALID_TRAP_STORM_ALARM*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if(port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_trap_storm_clear == trap_storm_clear_status)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
    }

    if (SWCTRL_IsServerBladePort (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_SRV_BLADE_PORT_CNFG,
                                  SYSLOG_LEVEL_INFO,
                                  "Configuring Broadcast Storm Control");     /*SWCTRL_ENO_DENY_ON_SERVER_BLADE_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }


    /* if normal port
     */
    if(!SWCTRL_IS_TRUNK (ifindex))
    {
        SWCTRL_LOCK();
        port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_trap_storm_clear = trap_storm_clear_status;
        SWCTRL_UNLOCK();
        retval = TRUE;
    }

    /* if trunk port
     */
#if (SYS_CPNT_ATC_BSTORM_SUPPORT_LPORT == TRUE)
    if(SWCTRL_IS_TRUNK (ifindex))
    {
        SWCTRL_TrunkPortExtInfo_T trunk_ext_p_info;
        UI32_T                    i;

        memset(&trunk_ext_p_info, 0, sizeof(SWCTRL_TrunkPortExtInfo_T));
        SWCTRL_GetTrunkPortExtInfo (ifindex, &trunk_ext_p_info);

        for(i=0; i<trunk_ext_p_info.member_number; i++)
        {
            unit = trunk_ext_p_info.member_list[i].unit;
            port = trunk_ext_p_info.member_list[i].port;

            SWCTRL_LOCK();
            port_info[(SWCTRL_UPORT_TO_IFINDEX(unit, port)) - 1].atc_broadcast_storm_entry.atc_broadcast_storm_trap_storm_clear = trap_storm_clear_status;
            SWCTRL_UNLOCK();
            retval = TRUE;
        } /* End of for () */
        if (retval)
        {
            SWCTRL_LOCK();
            port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_trap_storm_clear = trap_storm_clear_status;
            SWCTRL_UNLOCK();
        }
    } /* End of trunk port */
#endif /* End of (SYS_CPNT_ATC_BSTORM_SUPPORT_LPORT == TRUE) */

    SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME ();
    SWCTRL_RETURN_AND_RELEASE_CSC( retval );
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetATCBroadcastStormTrapStormClearStatus
 * -------------------------------------------------------------------------
 * 20.
 * FUNCTION: This function will get the storm alarm clear trap status of broadcast
 *           storm control function
 * INPUT   : ifindex -- which port to set
 * OUTPUT  : trap_storm_clear_status    -- which status of storm alarm clear trap
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_GetATCBroadcastStormTrapStormClearStatus(UI32_T ifindex, UI32_T *trap_storm_clear_status)
{
    /* LOCAL VARIABLES
     */

    /* BODY
     */
    /* Check Management Port.
     * TRUE: The port is a management port.
     * FALSE: The port is not a managemet port.
     * It returns FALSE, when the port is a management port.
     */
    if ( TRUE == SWCTRL_IsManagementPort(ifindex) )
    {
        return FALSE;
    }

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if ((ifindex == 0) ||(ifindex > SYS_ADPT_TOTAL_NBR_OF_LPORT))
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Logical Port ID (1-%d)", SYS_ADPT_TOTAL_NBR_OF_LPORT);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_LOGICAL_PORT_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (!SWCTRL_IS_EXIST (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Interface");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

#if (SYS_CPNT_ATC_BSTORM_SUPPORT_LPORT != TRUE)
    if (SWCTRL_IS_TRUNK (ifindex))
    {
            EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                      SWCTRL_NO_USE_FUNC_NO,
                                      EH_TYPE_MSG_TRUNK_CNFG_ERR,
                                      SYSLOG_LEVEL_INFO,
                                      "it doesn't support Broadcast Storm Control.");  /*SWCTRL_ENO_NOT_TRUNK*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#else
    if (SWCTRL_IS_TRUNK_MEMBER (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#endif

    SWCTRL_LOCK();
    *trap_storm_clear_status = port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_trap_storm_clear;
    SWCTRL_UNLOCK();

    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetATCBroadcastStormTrapTrafficControlOnStatus
 * -------------------------------------------------------------------------
 * 21.
 * FUNCTION: This function will set the traffic control apply trap status of broadcast
 *           storm control function
 * INPUT   : ifindex -- which port to set
 *           trap_traffic_control_on_status    -- which status of traffic control apply trap
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetATCBroadcastStormTrapTrafficControlOnStatus(UI32_T ifindex, UI32_T trap_traffic_control_on_status)
{
    /* LOCAL VARIABLES
     */
#if (SYS_CPNT_ATC_BSTORM_SUPPORT_LPORT == TRUE)
    UI32_T                          unit, port;
#endif
    BOOL_T                          retval = FALSE;

    /* BODY
     */
    /* Check Management Port.
     * TRUE: The port is a management port.
     * FALSE: The port is not a managemet port.
     * It returns FALSE, when the port is a management port.
     */

    if ( TRUE == SWCTRL_IsManagementPort(ifindex) )
    {
        return FALSE;
    }

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if ((ifindex == 0) ||(ifindex > SYS_ADPT_TOTAL_NBR_OF_LPORT))
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Logical Port ID (1-%d)", SYS_ADPT_TOTAL_NBR_OF_LPORT);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_LOGICAL_PORT_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (!SWCTRL_IS_EXIST (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Interface");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

#if (SYS_CPNT_ATC_BSTORM_SUPPORT_LPORT != TRUE)
    if (SWCTRL_IS_TRUNK (ifindex))
    {
            EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                      SWCTRL_NO_USE_FUNC_NO,
                                      EH_TYPE_MSG_TRUNK_CNFG_ERR,
                                      SYSLOG_LEVEL_INFO,
                                      "it doesn't support Broadcast Storm Control.");  /*SWCTRL_ENO_NOT_TRUNK*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#else
    if (SWCTRL_IS_TRUNK_MEMBER (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#endif

    if((trap_traffic_control_on_status != VAL_atcBcastStormTcApplyTrapStatus_enabled) &&
       (trap_traffic_control_on_status != VAL_atcBcastStormTcApplyTrapStatus_disabled))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_INVALID_PARAMETER,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "trap traffic control on"); /*SWCTRL_ENO_INVALID_TRAP_TRAFFIC_CONTROL_ON*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if(port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_trap_traffic_control_on== trap_traffic_control_on_status)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
    }

    if (SWCTRL_IsServerBladePort (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_SRV_BLADE_PORT_CNFG,
                                  SYSLOG_LEVEL_INFO,
                                  "Configuring Broadcast Storm Control");     /*SWCTRL_ENO_DENY_ON_SERVER_BLADE_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }


    /* if normal port
     */
    if(!SWCTRL_IS_TRUNK (ifindex))
    {
        SWCTRL_LOCK();

        port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_trap_traffic_control_on = trap_traffic_control_on_status;


        SWCTRL_UNLOCK();

        retval = TRUE;
    }

    /* if trunk port
     */
#if (SYS_CPNT_ATC_BSTORM_SUPPORT_LPORT == TRUE)
    if(SWCTRL_IS_TRUNK (ifindex))
    {
        SWCTRL_TrunkPortExtInfo_T trunk_ext_p_info;
        UI32_T                    i;

        memset(&trunk_ext_p_info, 0, sizeof(SWCTRL_TrunkPortExtInfo_T));
        SWCTRL_GetTrunkPortExtInfo (ifindex, &trunk_ext_p_info);

        for(i=0; i<trunk_ext_p_info.member_number; i++)
        {
            unit = trunk_ext_p_info.member_list[i].unit;
            port = trunk_ext_p_info.member_list[i].port;

            SWCTRL_LOCK();
            port_info[(SWCTRL_UPORT_TO_IFINDEX(unit, port)) - 1].atc_broadcast_storm_entry.atc_broadcast_storm_trap_traffic_control_on= trap_traffic_control_on_status;
            SWCTRL_UNLOCK();
            retval = TRUE;
        } /* End of for () */
        if (retval)
        {
            SWCTRL_LOCK();
            port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_trap_traffic_control_on = trap_traffic_control_on_status;
            SWCTRL_UNLOCK();
        }
    } /* End of trunk port */
#endif /* End of (SYS_CPNT_ATC_BSTORM_SUPPORT_LPORT == TRUE) */

    SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME ();
    SWCTRL_RETURN_AND_RELEASE_CSC( retval );
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetATCBroadcastStormTrapTrafficControlOnStatus
 * -------------------------------------------------------------------------
 * 22.
 * FUNCTION: This function will get the traffic control apply trap status of broadcast
 *           storm control function
 * INPUT   : ifindex -- which port to set
 * OUTPUT  : trap_traffic_control_on_status    -- which status of traffic control on trap
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_GetATCBroadcastStormTrapTrafficControlOnStatus(UI32_T ifindex, UI32_T *trap_traffic_control_on_status)
{
    /* LOCAL VARIABLES
     */

    /* BODY
     */
    /* Check Management Port.
     * TRUE: The port is a management port.
     * FALSE: The port is not a managemet port.
     * It returns FALSE, when the port is a management port.
     */
    if ( TRUE == SWCTRL_IsManagementPort(ifindex) )
    {
        return FALSE;
    }

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if ((ifindex == 0) ||(ifindex > SYS_ADPT_TOTAL_NBR_OF_LPORT))
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Logical Port ID (1-%d)", SYS_ADPT_TOTAL_NBR_OF_LPORT);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_LOGICAL_PORT_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (!SWCTRL_IS_EXIST (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Interface");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

#if (SYS_CPNT_ATC_BSTORM_SUPPORT_LPORT != TRUE)
    if (SWCTRL_IS_TRUNK (ifindex))
    {
            EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                      SWCTRL_NO_USE_FUNC_NO,
                                      EH_TYPE_MSG_TRUNK_CNFG_ERR,
                                      SYSLOG_LEVEL_INFO,
                                      "it doesn't support Broadcast Storm Control.");  /*SWCTRL_ENO_NOT_TRUNK*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#else
    if (SWCTRL_IS_TRUNK_MEMBER (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#endif

    SWCTRL_LOCK();
    *trap_traffic_control_on_status = port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_trap_traffic_control_on;
    SWCTRL_UNLOCK();

    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetATCBroadcastStormTrapTrafficControlReleaseStatus
 * -------------------------------------------------------------------------
 * 23.
 * FUNCTION: This function will set the traffic control release trap status of broadcast
 *           storm control function
 * INPUT   : ifindex -- which port to set
 *           trap_traffic_control_release_status    -- which status of traffic control release trap
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetATCBroadcastStormTrapTrafficControlReleaseStatus(UI32_T ifindex, UI32_T trap_traffic_control_release_status)
{
    /* LOCAL VARIABLES
     */
#if (SYS_CPNT_ATC_BSTORM_SUPPORT_LPORT == TRUE)
    UI32_T                          unit, port;
#endif
    BOOL_T                          retval = FALSE;

    /* BODY
     */
    /* Check Management Port.
     * TRUE: The port is a management port.
     * FALSE: The port is not a managemet port.
     * It returns FALSE, when the port is a management port.
     */
    if ( TRUE == SWCTRL_IsManagementPort(ifindex) )
    {
        return FALSE;
    }

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if ((ifindex == 0) ||(ifindex > SYS_ADPT_TOTAL_NBR_OF_LPORT))
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Logical Port ID (1-%d)", SYS_ADPT_TOTAL_NBR_OF_LPORT);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_LOGICAL_PORT_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (!SWCTRL_IS_EXIST (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Interface");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

#if (SYS_CPNT_ATC_BSTORM_SUPPORT_LPORT != TRUE)
    if (SWCTRL_IS_TRUNK (ifindex))
    {
            EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                      SWCTRL_NO_USE_FUNC_NO,
                                      EH_TYPE_MSG_TRUNK_CNFG_ERR,
                                      SYSLOG_LEVEL_INFO,
                                      "it doesn't support Broadcast Storm Control.");  /*SWCTRL_ENO_NOT_TRUNK*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#else
    if (SWCTRL_IS_TRUNK_MEMBER (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#endif

    if((trap_traffic_control_release_status != VAL_atcBcastStormTcReleaseTrapStatus_enabled) &&
       (trap_traffic_control_release_status != VAL_atcBcastStormTcReleaseTrapStatus_disabled))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_INVALID_PARAMETER,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "trap traffic control release"); /*SWCTRL_ENO_INVALID_TRAP_TRAFFIC_CONTROL_RELEASE*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if(port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_trap_traffic_control_release == trap_traffic_control_release_status)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
    }

    if (SWCTRL_IsServerBladePort (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_SRV_BLADE_PORT_CNFG,
                                  SYSLOG_LEVEL_INFO,
                                  "Configuring Broadcast Storm Control");     /*SWCTRL_ENO_DENY_ON_SERVER_BLADE_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }


    /* if normal port
     */
    if(!SWCTRL_IS_TRUNK (ifindex))
    {
        SWCTRL_LOCK();
        port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_trap_traffic_control_release = trap_traffic_control_release_status;
        SWCTRL_UNLOCK();
        retval = TRUE;
    }

    /* if trunk port
     */
#if (SYS_CPNT_ATC_BSTORM_SUPPORT_LPORT == TRUE)
    if(SWCTRL_IS_TRUNK (ifindex))
    {
        SWCTRL_TrunkPortExtInfo_T trunk_ext_p_info;
        UI32_T                    i;

        memset(&trunk_ext_p_info, 0, sizeof(SWCTRL_TrunkPortExtInfo_T));
        SWCTRL_GetTrunkPortExtInfo (ifindex, &trunk_ext_p_info);

        for(i=0; i<trunk_ext_p_info.member_number; i++)
        {
            unit = trunk_ext_p_info.member_list[i].unit;
            port = trunk_ext_p_info.member_list[i].port;

            SWCTRL_LOCK();
            port_info[(SWCTRL_UPORT_TO_IFINDEX(unit, port)) - 1].atc_broadcast_storm_entry.atc_broadcast_storm_trap_traffic_control_release = trap_traffic_control_release_status;
            SWCTRL_UNLOCK();
            retval = TRUE;
        } /* End of for () */
        if (retval)
        {
            SWCTRL_LOCK();
            port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_trap_traffic_control_release = trap_traffic_control_release_status;
            SWCTRL_UNLOCK();
        }
    } /* End of trunk port */
#endif /* End of (SYS_CPNT_ATC_BSTORM_SUPPORT_LPORT == TRUE) */

    SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME ();
    SWCTRL_RETURN_AND_RELEASE_CSC( retval );
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetATCBroadcastStormTrapTrafficControlReleaseStatus
 * -------------------------------------------------------------------------
 * 24.
 * FUNCTION: This function will get the traffic control release trap status of broadcast
 *           storm control function
 * INPUT   : ifindex -- which port to set
 * OUTPUT  : trap_traffic_control_release_status    -- which status of traffic control release trap
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_GetATCBroadcastStormTrapTrafficControlReleaseStatus(UI32_T ifindex, UI32_T *trap_traffic_control_release_status)
{
    /* LOCAL VARIABLES
     */

    /* BODY
     */
    /* Check Management Port.
     * TRUE: The port is a management port.
     * FALSE: The port is not a managemet port.
     * It returns FALSE, when the port is a management port.
     */
    if ( TRUE == SWCTRL_IsManagementPort(ifindex) )
    {
        return FALSE;
    }

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if ((ifindex == 0) ||(ifindex > SYS_ADPT_TOTAL_NBR_OF_LPORT))
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Logical Port ID (1-%d)", SYS_ADPT_TOTAL_NBR_OF_LPORT);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_LOGICAL_PORT_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (!SWCTRL_IS_EXIST (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Interface");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

#if (SYS_CPNT_ATC_BSTORM_SUPPORT_LPORT != TRUE)
    if (SWCTRL_IS_TRUNK (ifindex))
    {
            EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                      SWCTRL_NO_USE_FUNC_NO,
                                      EH_TYPE_MSG_TRUNK_CNFG_ERR,
                                      SYSLOG_LEVEL_INFO,
                                      "it doesn't support Broadcast Storm Control.");  /*SWCTRL_ENO_NOT_TRUNK*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#else
    if (SWCTRL_IS_TRUNK_MEMBER (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#endif

    SWCTRL_LOCK();
    *trap_traffic_control_release_status = port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_trap_traffic_control_release;
    SWCTRL_UNLOCK();

    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetATCBroadcastStormAction
 * -------------------------------------------------------------------------
 * 25.
 * FUNCTION: This function will set the action method of broadcast
 *           storm control function
 * INPUT   : ifindex -- which port to set
 *           action    -- which status of action
 *                            --- 1. rate-control , 2. shutdown
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetATCBroadcastStormAction(UI32_T ifindex, UI32_T action)
{
    /* LOCAL VARIABLES
     */
#if (SYS_CPNT_ATC_BSTORM_SUPPORT_LPORT == TRUE)
    UI32_T                          unit, port;
#endif
    BOOL_T                          retval = FALSE;

    /* BODY
     */
    /* Check Management Port.
     * TRUE: The port is a management port.
     * FALSE: The port is not a managemet port.
     * It returns FALSE, when the port is a management port.
     */
    if ( TRUE == SWCTRL_IsManagementPort(ifindex) )
    {
        return FALSE;
    }

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if ((ifindex == 0) ||(ifindex > SYS_ADPT_TOTAL_NBR_OF_LPORT))
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Logical Port ID (1-%d)", SYS_ADPT_TOTAL_NBR_OF_LPORT);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_LOGICAL_PORT_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (!SWCTRL_IS_EXIST (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Interface");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

#if (SYS_CPNT_ATC_BSTORM_SUPPORT_LPORT != TRUE)
    if (SWCTRL_IS_TRUNK (ifindex))
    {
            EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                      SWCTRL_NO_USE_FUNC_NO,
                                      EH_TYPE_MSG_TRUNK_CNFG_ERR,
                                      SYSLOG_LEVEL_INFO,
                                      "it doesn't support Broadcast Storm Control.");  /*SWCTRL_ENO_NOT_TRUNK*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#else
    if (SWCTRL_IS_TRUNK_MEMBER (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#endif

    if((action != VAL_atcBcastStormTcAction_rate_control) &&
       (action != VAL_atcBcastStormTcAction_shutdown))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_INVALID_PARAMETER,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "trap traffic control release"); /*SWCTRL_ENO_INVALID_TRAP_TRAFFIC_CONTROL_RELEASE*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if(port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_action == action)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
    }

    if (SWCTRL_IsServerBladePort (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_SRV_BLADE_PORT_CNFG,
                                  SYSLOG_LEVEL_INFO,
                                  "Configuring Broadcast Storm Control");     /*SWCTRL_ENO_DENY_ON_SERVER_BLADE_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }


    /* if normal port
     */
    if(!SWCTRL_IS_TRUNK (ifindex))
    {
        SWCTRL_LOCK();
        port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_action = action;
        SWCTRL_UNLOCK();
        SWCTRL_SetATCBroadcastStormTrafficControlReleaseStatus(ifindex, SWCTRL_ATC_BROADCAST_STORM_TC_RELEASE_ENABLE);
        retval = TRUE;
    }

    /* if trunk port
     */
#if (SYS_CPNT_ATC_BSTORM_SUPPORT_LPORT == TRUE)
    if(SWCTRL_IS_TRUNK (ifindex))
    {
        SWCTRL_TrunkPortExtInfo_T trunk_ext_p_info;
        UI32_T                    i;

        memset(&trunk_ext_p_info, 0, sizeof(SWCTRL_TrunkPortExtInfo_T));
        SWCTRL_GetTrunkPortExtInfo (ifindex, &trunk_ext_p_info);

        for(i=0; i<trunk_ext_p_info.member_number; i++)
        {
            unit = trunk_ext_p_info.member_list[i].unit;
            port = trunk_ext_p_info.member_list[i].port;

            SWCTRL_LOCK();
            port_info[(SWCTRL_UPORT_TO_IFINDEX(unit, port)) - 1].atc_broadcast_storm_entry.atc_broadcast_storm_action = action;
            SWCTRL_UNLOCK();
            SWCTRL_SetATCBroadcastStormTrafficControlReleaseStatus((SWCTRL_UPORT_TO_IFINDEX(unit, port)), SWCTRL_ATC_BROADCAST_STORM_TC_RELEASE_ENABLE);
            retval=TRUE;
        }/* End of for () */
        if (retval)
        {
            SWCTRL_LOCK();
            port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_action = action;
            SWCTRL_UNLOCK();
        }
    } /* End of trunk port */
#endif /* End of (SYS_CPNT_ATC_BSTORM_SUPPORT_LPORT == TRUE) */

    SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME ();
    SWCTRL_RETURN_AND_RELEASE_CSC( retval );
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetATCBroadcastStormAction
 * -------------------------------------------------------------------------
 * 26.
 * FUNCTION: This function will get the action method of broadcast
 *           storm control function
 * INPUT   : ifindex -- which port to set
 * OUTPUT  : action    -- which status of action
 *                            --- 1. rate-control , 2. shutdown
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_GetATCBroadcastStormAction(UI32_T ifindex, UI32_T *action)
{
    /* LOCAL VARIABLES
     */

    /* BODY
     */
    /* Check Management Port.
     * TRUE: The port is a management port.
     * FALSE: The port is not a managemet port.
     * It returns FALSE, when the port is a management port.
     */
    if ( TRUE == SWCTRL_IsManagementPort(ifindex) )
    {
        return FALSE;
    }

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if ((ifindex == 0) ||(ifindex > SYS_ADPT_TOTAL_NBR_OF_LPORT))
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Logical Port ID (1-%d)", SYS_ADPT_TOTAL_NBR_OF_LPORT);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_LOGICAL_PORT_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (!SWCTRL_IS_EXIST (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Interface");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

#if (SYS_CPNT_ATC_BSTORM_SUPPORT_LPORT != TRUE)
    if (SWCTRL_IS_TRUNK (ifindex))
    {
            EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                      SWCTRL_NO_USE_FUNC_NO,
                                      EH_TYPE_MSG_TRUNK_CNFG_ERR,
                                      SYSLOG_LEVEL_INFO,
                                      "it doesn't support Broadcast Storm Control.");  /*SWCTRL_ENO_NOT_TRUNK*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#else
    if (SWCTRL_IS_TRUNK_MEMBER (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#endif

    SWCTRL_LOCK();
    *action = port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_action;
    SWCTRL_UNLOCK();

    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetATCBroadcastStormEntry
 * -------------------------------------------------------------------------
 * 27.
 * FUNCTION: This function will get the entry of broadcast
 *           storm control function
 * INPUT   : atc_broadcast_storm_entry    -- which status of entry
 * OUTPUT  : atc_broadcast_storm_entry    -- which status of entry
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_GetATCBroadcastStormEntry(UI32_T ifindex,SWCTRL_ATCBroadcastStormEntry_T *atc_broadcast_storm_entry)
{
    /* LOCAL VARIABLES
     */

    /* BODY
     */
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (atc_broadcast_storm_entry == 0)
    {
        EH_MGR_Handle_Exception (SYS_MODULE_SWCTRL,
                                 SWCTRL_NO_USE_FUNC_NO,
                                 EH_TYPE_MSG_NULL_POINTER,
                                 EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_CRIT); /*SWCTRL_ENO_NULL_POINTER*/
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

#if (SYS_CPNT_ATC_BSTORM_SUPPORT_LPORT == TRUE)
    if (!SWCTRL_IS_LPORT(ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Interface.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#else
    if (!SWCTRL_IS_USER_PORT(ifindex) || !SWCTRL_IS_EXIST(ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Interface.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#endif

    *atc_broadcast_storm_entry = port_info[ifindex - 1].atc_broadcast_storm_entry;
    atc_broadcast_storm_entry->atc_broadcast_storm_storm_alarm_threshold /= SWCTRL_ATC_BROADCAST_STORM_ONE_THOUSAND;
    atc_broadcast_storm_entry->atc_broadcast_storm_storm_clear_threshold /= SWCTRL_ATC_BROADCAST_STORM_ONE_THOUSAND;

    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetNextATCBroadcastStormEntry
 * -------------------------------------------------------------------------
 * 28.
 * FUNCTION: This function will get the next entry of broadcast
 *           storm control function
 * INPUT   : atc_broadcast_storm_entry    -- which status of entry
 * OUTPUT  : atc_broadcast_storm_entry    -- which status of the next entry
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_GetNextATCBroadcastStormEntry(UI32_T ifindex,SWCTRL_ATCBroadcastStormEntry_T *atc_broadcast_storm_entry)
{
    /* LOCAL VARIABLES
     */

    /* BODY
     */
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (atc_broadcast_storm_entry == 0)
    {
        EH_MGR_Handle_Exception (SYS_MODULE_SWCTRL,
                                 SWCTRL_NO_USE_FUNC_NO,
                                 EH_TYPE_MSG_NULL_POINTER,
                                 EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_CRIT); /*SWCTRL_ENO_NULL_POINTER*/
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    (*atc_broadcast_storm_entry).atc_broadcast_storm_ifindex= ifindex;

    if((*atc_broadcast_storm_entry).atc_broadcast_storm_ifindex > SYS_ADPT_TOTAL_NBR_OF_LPORT)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    (atc_broadcast_storm_entry->atc_broadcast_storm_ifindex)++;
    for(;
        atc_broadcast_storm_entry->atc_broadcast_storm_ifindex <= SYS_ADPT_TOTAL_NBR_OF_LPORT;
        (atc_broadcast_storm_entry->atc_broadcast_storm_ifindex)++)
    {
         if (!SWCTRL_IS_EXIST (atc_broadcast_storm_entry->atc_broadcast_storm_ifindex))
            continue;

#if (SYS_CPNT_ATC_BSTORM_SUPPORT_LPORT != TRUE)
        if (SWCTRL_IS_TRUNK (atc_broadcast_storm_entry->atc_broadcast_storm_ifindex))
           continue;
#else
        if (SWCTRL_IS_TRUNK_MEMBER (atc_broadcast_storm_entry->atc_broadcast_storm_ifindex))
           continue;
#endif

        *atc_broadcast_storm_entry = port_info[atc_broadcast_storm_entry->atc_broadcast_storm_ifindex-1].atc_broadcast_storm_entry;
            atc_broadcast_storm_entry->atc_broadcast_storm_storm_alarm_threshold /= SWCTRL_ATC_BROADCAST_STORM_ONE_THOUSAND;
            atc_broadcast_storm_entry->atc_broadcast_storm_storm_clear_threshold /= SWCTRL_ATC_BROADCAST_STORM_ONE_THOUSAND;

        SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
    } /* End of for () */

    SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetATCBroadcastStormTimer
 * -------------------------------------------------------------------------
 * 29.
 * FUNCTION: This function will set the tc apply timer and tc release timer on status of broadcast
 *           storm control function
 * INPUT   : a_broadcast_storm_timer    -- which status of tc apply timer and tc release apply
 * OUTPUT  : a_broadcast_storm_timer    -- which status of tc apply timer and tc release apply
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_GetATCBroadcastStormTimer(SWCTRL_ATCBroadcastStormTimer_T *a_broadcast_storm_timer)
{

    /* LOCAL VARIABLES
     */

    /* BODY
     */
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (a_broadcast_storm_timer == 0)
    {
        EH_MGR_Handle_Exception (SYS_MODULE_SWCTRL,
                                 SWCTRL_NO_USE_FUNC_NO,
                                 EH_TYPE_MSG_NULL_POINTER,
                                 EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_CRIT); /*SWCTRL_ENO_NULL_POINTER*/
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    memset(a_broadcast_storm_timer, 0, sizeof(SWCTRL_ATCBroadcastStormTimer_T));

    (*a_broadcast_storm_timer).atc_broadcast_storm_traffic_control_on_timer = atc_broadcast_storm_timer.atc_broadcast_storm_traffic_control_on_timer;
    (*a_broadcast_storm_timer).atc_broadcast_storm_traffic_control_release_timer = atc_broadcast_storm_timer.atc_broadcast_storm_traffic_control_release_timer;

    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );

}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetATCBroadcastStormSampleType
 * -------------------------------------------------------------------------
 * 30.
 * FUNCTION: This function will set the sample type of broadcast
 *           storm control function
 * INPUT   : ifindex -- which port to set
 *           atc_broadcast_storm_sample_type    -- which status of sample type
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetATCBroadcastStormSampleType(UI32_T ifindex, UI32_T atc_broadcast_storm_sample_type)
{
    /* LOCAL VARIABLES
     */
    UI32_T nRate = 0;

    /* BODY
     */
    /* Check Management Port.
     * TRUE: The port is a management port.
     * FALSE: The port is not a managemet port.
     * It returns FALSE, when the port is a management port.
     */
    if ( TRUE == SWCTRL_IsManagementPort(ifindex) )
    {
        return FALSE;
    }

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

#if (SYS_CPNT_SWCTRL_GLOBAL_STORM_SAMPLE_TYPE == TRUE)
    if(atc_broadcast_storm_sample_type != swctrl_global_storm_sample_type)
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_INVALID_PARAMETER,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "sample type"); /*SWCTRL_ENO_INVALID_SAMPLE_TYPE*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#endif

    if((atc_broadcast_storm_sample_type != VAL_atcBcastStormSampleType_packet_rate) &&
       (atc_broadcast_storm_sample_type != VAL_atcBcastStormSampleType_octet_rate) &&
       (atc_broadcast_storm_sample_type != VAL_atcBcastStormSampleType_percent))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_INVALID_PARAMETER,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "sample type"); /*SWCTRL_ENO_INVALID_SAMPLE_TYPE*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if ((ifindex == 0) ||(ifindex > SYS_ADPT_TOTAL_NBR_OF_LPORT))
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Logical Port ID (1-%d)", SYS_ADPT_TOTAL_NBR_OF_LPORT);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_LOGICAL_PORT_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (!SWCTRL_IS_EXIST (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Interface");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

#if (SYS_CPNT_ATC_BSTORM_SUPPORT_LPORT != TRUE)
    if (SWCTRL_IS_TRUNK (ifindex))
    {
            EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                      SWCTRL_NO_USE_FUNC_NO,
                                      EH_TYPE_MSG_TRUNK_CNFG_ERR,
                                      SYSLOG_LEVEL_INFO,
                                      "it doesn't support Broadcast Storm Control.");  /*SWCTRL_ENO_NOT_TRUNK*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#else
    if (SWCTRL_IS_TRUNK_MEMBER (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#endif

    if(port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_sample_type == atc_broadcast_storm_sample_type)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
    }

    if(port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_sample_type == VAL_atcBcastStormSampleType_packet_rate)
    {
        switch (atc_broadcast_storm_sample_type)
        {
        case VAL_atcBcastStormSampleType_packet_rate:
            SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );

        case VAL_atcBcastStormSampleType_octet_rate:
            nRate = port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_packet_rate*500;
            break;

        case VAL_atcBcastStormSampleType_percent:
            if(SWCTRL_IS_100TX (ifindex) || SWCTRL_IS_100FIBER (ifindex))
            {
                nRate = port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_packet_rate* 8 * 500 * 100 / 100000000;
            }
            else if(SWCTRL_IS_1000T (ifindex) || SWCTRL_IS_1000FIBER (ifindex))
            {
                nRate = port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_packet_rate * 8 * 500 * 100 / 1000000000;
            }
            else /* 10G */
            {
                nRate = port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_packet_rate / 25000; /* 25000 = 1/(8 * 500 * 100 / 10000000000) */
            }
            break;
        }
    }

    if(port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_sample_type == VAL_atcBcastStormSampleType_octet_rate)
    {
        switch (atc_broadcast_storm_sample_type)
        {
        case VAL_atcBcastStormSampleType_packet_rate:
            nRate = port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_octet_rate/500;
            break;

        case VAL_atcBcastStormSampleType_octet_rate:
            SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );

        case VAL_atcBcastStormSampleType_percent:
            if(SWCTRL_IS_100TX (ifindex) || SWCTRL_IS_100FIBER (ifindex))
                nRate = port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_octet_rate * 8 * 100 / 100000000;
            else if(SWCTRL_IS_1000T (ifindex) || SWCTRL_IS_1000FIBER (ifindex))
                nRate = port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_octet_rate * 8 * 100 / 1000000000;
            else /* 10G */
                nRate = port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_octet_rate / 25000; /* 25000 = 1/(8 * 500 * 100 / 10000000000) */
            break;
        }
    }

    if(port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_sample_type == VAL_atcBcastStormSampleType_percent)
    {
        switch (atc_broadcast_storm_sample_type)
        {
        case VAL_atcBcastStormSampleType_packet_rate:
            if(SWCTRL_IS_100TX (ifindex) || SWCTRL_IS_100FIBER (ifindex))
            {
                nRate = 100000000 / 8 / 500 * port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_percent / 100;
            }
            else if(SWCTRL_IS_1000T (ifindex) || SWCTRL_IS_1000FIBER (ifindex))
            {
                nRate = 1000000000 / 8 / 500 * port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_percent / 100;
            }
            else /* 10G */
            {
                nRate = 2500000 * port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_percent / 100;  /* 2500000 = (10000000000 / 8 / 500) */
            }
            break;

        case VAL_atcBcastStormSampleType_octet_rate:
            if(SWCTRL_IS_100TX (ifindex) || SWCTRL_IS_100FIBER (ifindex))
            {
                nRate = 100000000 / 8 * port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_percent / 100;
            }
            else if(SWCTRL_IS_1000T (ifindex) || SWCTRL_IS_1000FIBER (ifindex))
            {
                nRate = 1000000000 / 8 * port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_percent / 100;
            }
            else /* 10G */
            {
                nRate = 1250000000 * port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_percent / 100; /* 1250000000 = (10000000000 / 8) */
            }
            break;

        case VAL_atcBcastStormSampleType_percent:
            SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
        }
    }

    if (nRate == 0)
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_INVALID_PARAMETER,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "broadcast storm sample type");   /*SWCTRL_ENO_INVALID_ADMIN*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    SWCTRL_RETURN_AND_RELEASE_CSC( SWCTRL_SetATCBroadcastStormRateLimit(ifindex, atc_broadcast_storm_sample_type, nRate) );
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetATCBroadcastStormPacketRate
 * -------------------------------------------------------------------------
 * 31.
 * FUNCTION: This function will set the packet rate of broadcast
 *           storm control function
 * INPUT   : ifindex -- which port to set
 *           atc_broadcast_storm_packet_rate    -- which status of packet rate
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetATCBroadcastStormPacketRate(UI32_T ifindex, UI32_T atc_broadcast_storm_packet_rate)
{
    /* Check Management Port.
     * TRUE: The port is a management port.
     * FALSE: The port is not a managemet port.
     * It returns FALSE, when the port is a management port.
     */
    if ( TRUE == SWCTRL_IsManagementPort(ifindex) )
    {
        return FALSE;
    }

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    SWCTRL_RETURN_AND_RELEASE_CSC( SWCTRL_SetATCBroadcastStormRateLimit(ifindex, VAL_atcBcastStormSampleType_packet_rate, atc_broadcast_storm_packet_rate) );
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetATCBroadcastStormOctetRate
 * -------------------------------------------------------------------------
 * 32.
 * FUNCTION: This function will set the octet rate of broadcast
 *           storm control function
 * INPUT   : ifindex -- which port to set
 *           atc_broadcast_storm_octet_rate    -- which status of octet rate
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetATCBroadcastStormOctetRate(UI32_T ifindex, UI32_T atc_broadcast_storm_octet_rate)
{
    /* Check Management Port.
     * TRUE: The port is a management port.
     * FALSE: The port is not a managemet port.
     * It returns FALSE, when the port is a management port.
     */
    if ( TRUE == SWCTRL_IsManagementPort(ifindex) )
    {
        return FALSE;
    }

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    SWCTRL_RETURN_AND_RELEASE_CSC( SWCTRL_SetATCBroadcastStormRateLimit(ifindex, VAL_atcBcastStormSampleType_octet_rate, atc_broadcast_storm_octet_rate) );
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetATCBroadcastStormPercent
 * -------------------------------------------------------------------------
 * 33.
 * FUNCTION: This function will set the percent of broadcast
 *           storm control function
 * INPUT   : ifindex -- which port to set
 *           atc_broadcast_storm_percent    -- which status of percent
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetATCBroadcastStormPercent(UI32_T ifindex, UI32_T atc_broadcast_storm_percent)
{
    /* Check Management Port.
     * TRUE: The port is a management port.
     * FALSE: The port is not a managemet port.
     * It returns FALSE, when the port is a management port.
     */
    if ( TRUE == SWCTRL_IsManagementPort(ifindex) )
    {
        return FALSE;
    }

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    SWCTRL_RETURN_AND_RELEASE_CSC( SWCTRL_SetATCBroadcastStormRateLimit(ifindex, VAL_atcBcastStormSampleType_percent, atc_broadcast_storm_percent) );

}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetATCBroadcastStormRateLimit
 * -------------------------------------------------------------------------
 * 34.
 * FUNCTION: This function will set the rate limit of broadcast
 *           storm control function
 * INPUT   : ifindex -- which port to set
 *           mode    -- which status of mode
 *           nRate   -- which status of rate
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetATCBroadcastStormRateLimit(UI32_T ifindex, UI32_T mode, UI32_T nRate)
{
    /* LOCAL VARIABLES
     */
    UI32_T                          unit, port, rate;
    BOOL_T                          retval = FALSE;

    /* BODY
     */
    /* Check Management Port.
     * TRUE: The port is a management port.
     * FALSE: The port is not a managemet port.
     * It returns FALSE, when the port is a management port.
     */
    if ( TRUE == SWCTRL_IsManagementPort(ifindex) )
    {
        return FALSE;
    }

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

#if (SYS_CPNT_SWCTRL_GLOBAL_STORM_SAMPLE_TYPE == TRUE)
    mode = swctrl_global_storm_sample_type;
#endif

    /* check mode
     */
    if ( (mode != VAL_atcBcastStormSampleType_packet_rate) &&
         (mode != VAL_atcBcastStormSampleType_octet_rate) &&
         (mode != VAL_atcBcastStormSampleType_percent) )
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_INVALID_PARAMETER,
                                  SYSLOG_LEVEL_INFO,
                                  "Sample Type for Broadcast Storm Control"); /*SWCTRL_ENO_INVALID_BSTM_CTRL_TYPE*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    /* check amount
     */
#if defined(ALLAYER_SWITCH)
    if ((nRate != 16) && (nRate != 64) && (nRate != 128) && (nRate != 256))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_INVALID,
                                  SYSLOG_LEVEL_INFO,
                                  "Broadcast Storm Control rate"); /*SWCTRL_ENO_INVALID_BSTM_CTRL_RATE*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#else
    if ((nRate < SYS_ADPT_ATC_BSTORM_MIN_RATE_LIMIT) ||
        (nRate > SYS_ADPT_ATC_BSTORM_MAX_RATE_LIMIT))
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[64] = {0};

        sprintf(buff, "Broadcast Storm Control rate (%d-%d)",
                      SYS_ADPT_ATC_BSTORM_MIN_RATE_LIMIT,
                      SYS_ADPT_ATC_BSTORM_MAX_RATE_LIMIT);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_LOGICAL_PORT_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#endif

    if ((ifindex == 0) ||(ifindex > SYS_ADPT_TOTAL_NBR_OF_LPORT))
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Logical Port ID (1-%d)", SYS_ADPT_TOTAL_NBR_OF_LPORT);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_LOGICAL_PORT_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (!SWCTRL_IS_EXIST (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Interface");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (SWCTRL_IsServerBladePort (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_SRV_BLADE_PORT_CNFG,
                                  SYSLOG_LEVEL_INFO,
                                  "Configuring Broadcast Rate Limit");     /*SWCTRL_ENO_DENY_ON_SERVER_BLADE_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if(mode == VAL_atcBcastStormSampleType_packet_rate)
    {
        rate = nRate;
    }
    else if(mode == VAL_atcBcastStormSampleType_octet_rate)
    {
        /* Because the limit is base on packet/sec,
         * we assume there are 500 byte/packet,
         * and get the rate from byte/sec.
         */
        rate = nRate / 500;
    }
    else if(mode == VAL_atcBcastStormSampleType_percent)
    {
        if(nRate > 100)
        {
#if (SYS_CPNT_EH == TRUE)
            UI8_T buff[64] = {0};

            sprintf(buff, "Broadcast Storm Control rate (0-%d)", 100);

            EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                      SWCTRL_NO_USE_FUNC_NO,
                                      EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                      SYSLOG_LEVEL_INFO,
                                      buff);/*SWCTRL_ENO_INVALID_BSTM_CTRL_RATE*/
#endif

            SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
        }

        if(SWCTRL_IS_100TX (ifindex) || SWCTRL_IS_100FIBER (ifindex))
        {
            rate = 100000000 / 8 / 500 * nRate / 100;
        }
        else if(SWCTRL_IS_1000T (ifindex) ||SWCTRL_IS_1000FIBER (ifindex))
        {
            rate = 1000000000 / 8 / 500 * nRate / 100;
        }
        else /* 10G */
        {
            rate = 2500000 * nRate / 100;
        }
    }
    else
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_INVALID_PARAMETER,
                                  SYSLOG_LEVEL_INFO,
                                  "Sample Type for Broadcast Storm Control"); /*SWCTRL_ENO_INVALID_BSTM_CTRL_TYPE*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

#if (SYS_CPNT_ATC_BSTORM_SUPPORT_LPORT != TRUE)
    if (SWCTRL_IS_TRUNK (ifindex))
    {
            EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                      SWCTRL_NO_USE_FUNC_NO,
                                      EH_TYPE_MSG_TRUNK_CNFG_ERR,
                                      SYSLOG_LEVEL_INFO,
                                      "it doesn't support Broadcast Storm Control.");  /*SWCTRL_ENO_NOT_TRUNK*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#else
    if (SWCTRL_IS_TRUNK_MEMBER (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#endif

    /* if normal port & trunk port can setting
     */
    if(!SWCTRL_IS_TRUNK (ifindex))
    {
        unit = SWCTRL_IFINDEX_TO_UNIT(ifindex);
        port = SWCTRL_IFINDEX_TO_PORT(ifindex);

        retval = SWCTRL_SetUPortATCBroadcastStormControlRateLimit(unit, port, mode, rate, nRate);
    } /* End of normal port */

    /* if trunk port
     */
#if (SYS_CPNT_BSTORM_SUPPORT_LPORT == TRUE)
    if(SWCTRL_IS_TRUNK (ifindex))
    {
        SWCTRL_TrunkPortExtInfo_T trunk_ext_p_info;
        UI32_T                    i;

        memset(&trunk_ext_p_info, 0, sizeof(SWCTRL_TrunkPortExtInfo_T));
        SWCTRL_GetTrunkPortExtInfo (ifindex, &trunk_ext_p_info);

        for(i=0; i<trunk_ext_p_info.member_number; i++)
        {
            unit = trunk_ext_p_info.member_list[i].unit;
            port = trunk_ext_p_info.member_list[i].port;

            if (!(retval = SWCTRL_SetUPortATCBroadcastStormControlRateLimit(unit, port, mode, rate, nRate)))
                break;
        } /* End of for () */
        if (retval)
        {
            SWCTRL_LOCK();
            port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_ifindex = ifindex;
            port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_sample_type = mode;
            port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_packet_rate   = 0;
            port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_octet_rate = 0;
            port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_percent    = 0;
            switch (mode)
            {
                case VAL_atcBcastStormSampleType_packet_rate:
                port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_packet_rate = nRate;
                break;
                case VAL_atcBcastStormSampleType_octet_rate:
                port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_octet_rate = nRate;
                break;
                case VAL_atcBcastStormSampleType_percent:
                port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_percent = nRate;
                break;
            }
            SWCTRL_UNLOCK();
        }
    } /* End of trunk port */
#endif /* End of (SYS_CPNT_BSTORM_SUPPORT_LPORT == TRUE) */

    SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME ();
    SWCTRL_RETURN_AND_RELEASE_CSC( retval );
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetATCBroadcastStormPortOperationStatus
 * -------------------------------------------------------------------------
 * 35.
 * FUNCTION: This function will set port operation status of ATC Broadcast Storm
 * INPUT   : ifindex        -- which port to set
 *           operation_status   -- VAL_ifOperStatus_up/VAL_ifOperStatus_down
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : 1. RFC2863
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetATCBroadcastStormPortOperationStatus(UI32_T ifindex, UI32_T operation_status)
{
    UI32_T                          unit, port, i;
    SWCTRL_TrunkPortExtInfo_T       trunk_ext_p_info;

    /* BODY
     */
    /* Check Management Port.
     * TRUE: The port is a management port.
     * FALSE: The port is not a managemet port.
     * It returns FALSE, when the port is a management port.
     */
    if ( TRUE == SWCTRL_IsManagementPort(ifindex) )
    {
        return FALSE;
    }

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if ( (operation_status != VAL_ifOperStatus_up) &&
         (operation_status != VAL_ifOperStatus_down) )
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_INVALID_PARAMETER,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "ATC oper status change");   /*SWCTRL_ENO_INVALID_ADMIN*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (!SWCTRL_IS_LPORT(ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (port_info[ifindex-1].link_oper_status == operation_status )
        SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );

    if (!SYS_CALLBACK_MGR_SetPortStatusCallback(SYS_MODULE_SWCTRL, ifindex, operation_status == VAL_ifOperStatus_up, SWCTRL_PORT_STATUS_SET_BY_ATC_BSTORM))
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    SWCTRL_LOCK();

    if (!SWCTRL_IS_TRUNK (ifindex))
    {
        port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_operation_status = operation_status;
    }
    else /* trunk */
    {
        SWCTRL_GetTrunkPortExtInfo (ifindex, &trunk_ext_p_info);

        for(i = 0; i < trunk_ext_p_info.member_number; i++)
        {
            unit = (UI32_T) trunk_ext_p_info.member_list[i].unit;
            port = (UI32_T) trunk_ext_p_info.member_list[i].port;

            port_info[(SWCTRL_UPORT_TO_IFINDEX(unit, port)) - 1].atc_broadcast_storm_entry.atc_broadcast_storm_operation_status = operation_status;
        } /* End of for () */

        port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_operation_status = operation_status;
    } /* End of if (trunk) */

    SWCTRL_UNLOCK();

    SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME ();
    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
}/* end of SWCTRL_SetATCBroadcastStormPortOperationStatus () */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetATCBroadcastStormCurrentTrafficRate
 * -------------------------------------------------------------------------
 * 36.
 * FUNCTION: This function will get the current traffic rate of broadcast
 *           storm control function
 * INPUT   : ifindex -- which port to set
 * OUTPUT  : current_traffic_rate    -- which status of current traffic rate
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_GetATCBroadcastStormCurrentTrafficRate(UI32_T ifindex, UI32_T *current_traffic_rate)
{
    /* LOCAL VARIABLES
     */

    /* BODY
     */
    /* Check Management Port.
     * TRUE: The port is a management port.
     * FALSE: The port is not a managemet port.
     * It returns FALSE, when the port is a management port.
     */
    if ( TRUE == SWCTRL_IsManagementPort(ifindex) )
    {
        return FALSE;
    }

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if ( ifindex == 0                          ||
         ifindex > SYS_ADPT_TOTAL_NBR_OF_LPORT )
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Logical Port ID (1-%d)", SYS_ADPT_TOTAL_NBR_OF_LPORT);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_LOGICAL_PORT_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (!SWCTRL_IS_EXIST (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Interface");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

#if (SYS_CPNT_ATC_BSTORM_SUPPORT_LPORT != TRUE)
    if (SWCTRL_IS_TRUNK (ifindex))
    {
            EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                      SWCTRL_NO_USE_FUNC_NO,
                                      EH_TYPE_MSG_TRUNK_CNFG_ERR,
                                      SYSLOG_LEVEL_INFO,
                                      "it doesn't support Broadcast Storm Control.");  /*SWCTRL_ENO_NOT_TRUNK*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#else
    if (SWCTRL_IS_TRUNK_MEMBER (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#endif

    SWCTRL_LOCK();
    *current_traffic_rate = port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_current_traffic_rate;
    SWCTRL_UNLOCK();

    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetRunningATCBroadcastStormEntry
 * -------------------------------------------------------------------------
 * 37.
 * FUNCTION: This function will get the running entry of broadcast
 *           storm control function
 * INPUT   : atc_broadcast_storm_entry    -- which status of running entry
 * OUTPUT  : atc_broadcast_storm_entry    -- which status of running entry
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
SYS_TYPE_Get_Running_Cfg_T SWCTRL_GetRunningATCBroadcastStormEntry(UI32_T port,SWCTRL_ATCBroadcastStormEntry_T *atc_broadcast_storm_entry)
{
    /* LOCAL VARIABLES
     */
    UI32_T information_is_changed = FALSE;
    UI32_T ifindex;

    /* BODY
     */
   SWCTRL_USE_CSC_CHECK_OPER_MODE(SYS_TYPE_GET_RUNNING_CFG_FAIL);

    if (atc_broadcast_storm_entry == 0)
    {
        /*UIMSG_MGR_SetErrorCode(); */ /*SWCTRL_ENO_NULL_POINTER*/
        SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_FAIL );
    }

        (*atc_broadcast_storm_entry).atc_broadcast_storm_ifindex = port;
    if ( ((*atc_broadcast_storm_entry).atc_broadcast_storm_ifindex == 0) ||
         ((*atc_broadcast_storm_entry).atc_broadcast_storm_ifindex > SYS_ADPT_TOTAL_NBR_OF_LPORT) )
    {
        /*UIMSG_MGR_SetErrorCode(); */ /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/
        SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_FAIL );
    }

    ifindex = (*atc_broadcast_storm_entry).atc_broadcast_storm_ifindex;
    memset(atc_broadcast_storm_entry, 0, sizeof(atc_broadcast_storm_entry));
    (*atc_broadcast_storm_entry).atc_broadcast_storm_ifindex = ifindex;

    if (SWCTRL_GetATCBroadcastStormEntry(ifindex,atc_broadcast_storm_entry))
    {
        ifindex = (*atc_broadcast_storm_entry).atc_broadcast_storm_ifindex;
        if (!SWCTRL_IS_EXIST (ifindex))
        {
            EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                      SWCTRL_NO_USE_FUNC_NO,
                                      EH_TYPE_MSG_NOT_EXIST,
                                      SYSLOG_LEVEL_INFO,
                                      "Interface");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

            SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_FAIL );
        }

        if (SWCTRL_IS_TRUNK_MEMBER (ifindex))
        {
            /* Return FALSE if the trunk is a static trunk.
             * ( Dynamic trunk member must be treated as normal port
             *  if the port info want to be saved in flash.)
             */
            if(trunk_ext_port_info[SWCTRL_IFINDEX_TO_TRUNKID(ifindex)-1].is_static == TRUE)
            {
                SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_FAIL );
            }
        }

        /* status */
        if ((*atc_broadcast_storm_entry).atc_broadcast_storm_status != SYS_DFLT_ATC_BSTORM_STATUS)
        {
            information_is_changed |= TRUE;
        }
        /* sample type */
        if ((*atc_broadcast_storm_entry).atc_broadcast_storm_sample_type != SYS_DFLT_ATC_BSTORM_TYPE)
        {
            information_is_changed |= TRUE;
        }
        /* auto traffic control on */
        if ((*atc_broadcast_storm_entry).atc_broadcast_storm_auto_traffic_control_on != SYS_DFLT_ATC_BSTORM_ATC_ON)
        {
            information_is_changed |= TRUE;
        }
        /* auto traffic control release */
        if ((*atc_broadcast_storm_entry).atc_broadcast_storm_auto_traffic_control_release != SYS_DFLT_ATC_BSTORM_ATC_RELEASE)
        {
            information_is_changed |= TRUE;
        }
        /* storm alarm threshold */
        if ((*atc_broadcast_storm_entry).atc_broadcast_storm_storm_alarm_threshold != SYS_DFLT_ATC_BSTORM_STORM_ALARM_THRESHOLD)
        {
            information_is_changed |= TRUE;
        }
        /* storm clear threshold */
        if ((*atc_broadcast_storm_entry).atc_broadcast_storm_storm_clear_threshold != SYS_DFLT_ATC_BSTORM_STORM_CLEAR_THRESHOLD)
        {
            information_is_changed |= TRUE;
        }
        /* trap storm alarm */
        if ((*atc_broadcast_storm_entry).atc_broadcast_storm_trap_storm_alarm != SYS_DFLT_ATC_BSTORM_STORM_TRAP_STORM_ALARM)
        {
            information_is_changed |= TRUE;
        }
        /* trap storm clear */
        if ((*atc_broadcast_storm_entry).atc_broadcast_storm_trap_storm_clear != SYS_DFLT_ATC_BSTORM_STORM_TRAP_STORM_CLEAR)
        {
            information_is_changed |= TRUE;
        }
        /* trap traffic control on */
        if ((*atc_broadcast_storm_entry).atc_broadcast_storm_trap_traffic_control_on != SYS_DFLT_ATC_BSTORM_STORM_TRAP_TC_ON)
        {
            information_is_changed |= TRUE;
        }
        /* trap traffic control release */
        if ((*atc_broadcast_storm_entry).atc_broadcast_storm_trap_traffic_control_release != SYS_DFLT_ATC_BSTORM_STORM_TRAP_TC_RELEASE)
        {
            information_is_changed |= TRUE;
        }
        /* action */
        if ((*atc_broadcast_storm_entry).atc_broadcast_storm_action != SYS_DFLT_ATC_BSTORM_STORM_ACTION)
        {
            information_is_changed |= TRUE;
        }

        if (information_is_changed == TRUE)
        {
            SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_SUCCESS )
        }
        else
        {
            SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_NO_CHANGE )
        }
    }

    SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_FAIL );
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetRunningATCBroadcastStormTimer
 * -------------------------------------------------------------------------
 * 38.
 * FUNCTION: This function will get the running tc apply timer and tc release timer of broadcast
 *           storm control function
 * INPUT   : ifindex -- which port to set
 *           a_broadcast_storm_timer    -- which status of running tc apply timer and tc release timer
 * OUTPUT  : a_broadcast_storm_timer    -- which status of running tc apply timer and tc release timer
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
SYS_TYPE_Get_Running_Cfg_T SWCTRL_GetRunningATCBroadcastStormTimer(SWCTRL_ATCBroadcastStormTimer_T *a_broadcast_storm_timer)
{
    /* LOCAL VARIABLES
     */
    UI32_T information_is_changed = FALSE;

    /* BODY
     */
   SWCTRL_USE_CSC_CHECK_OPER_MODE(SYS_TYPE_GET_RUNNING_CFG_FAIL);

    if (a_broadcast_storm_timer == 0)
    {
        /*UIMSG_MGR_SetErrorCode(); */ /*SWCTRL_ENO_NULL_POINTER*/
        SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_FAIL );
    }

    memset(a_broadcast_storm_timer, 0, sizeof(SWCTRL_ATCBroadcastStormTimer_T));

    if (SWCTRL_GetATCBroadcastStormTimer(a_broadcast_storm_timer))
    {

        /* traffic control on timer */
        if ((*a_broadcast_storm_timer).atc_broadcast_storm_traffic_control_on_timer != SYS_DFLT_ATC_BSTORM_TC_ON_TIMER)
        {
            information_is_changed |= TRUE;
        }
        /* traffic control release timer */
        if ((*a_broadcast_storm_timer).atc_broadcast_storm_traffic_control_release_timer != SYS_DFLT_ATC_BSTORM_TC_RELEASE_TIMER)
        {
            information_is_changed |= TRUE;
        }

        if (information_is_changed == TRUE)
        {
            SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_SUCCESS )
        }
        else
        {
            SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_NO_CHANGE )
        }
    }

    SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_FAIL );
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_ATCBroadcastStormProtectionFSM
 * -------------------------------------------------------------------------
 * 39.
 * FUNCTION: This function will set the event of multicast
 *           storm control function
 * INPUT   : ifindex -- which port to set
 *           action    -- which status of event
 * OUTPUT  : None
 * RETURN  : None
 * NOTE    : None
 * -------------------------------------------------------------------------*/
void SWCTRL_ATCBroadcastStormProtectionFSM( UI32_T ifindex, UI32_T event)
{
    const static UI8_T fsm_table[7][8] =
    {
        /* SWCTRL_ATCBSTORM_INIT_ST
         */
        {SWCTRL_ATCBSTORM_INIT_TST,
         SWCTRL_ATCBSTORM_INIT_ST,
         SWCTRL_ATCBSTORM_INIT_ST,
         SWCTRL_ATCBSTORM_INIT_ST,
         SWCTRL_ATCBSTORM_INIT_ST,
         SWCTRL_ATCBSTORM_INIT_ST,
         SWCTRL_ATCBSTORM_INIT_ST,
         SWCTRL_ATCBSTORM_INIT_ST},

        /* SWCTRL_ATCBSTORM_MIDDLE_ST
         */
        {SWCTRL_ATCBSTORM_MIDDLE_ST,
         SWCTRL_ATCBSTORM_LOW_TST,
         SWCTRL_ATCBSTORM_MIDDLE_ST,
         SWCTRL_ATCBSTORM_HIGH_TST,
         SWCTRL_ATCBSTORM_MIDDLE_ST,
         SWCTRL_ATCBSTORM_MIDDLE_ST,
         SWCTRL_ATCBSTORM_MIDDLE_ST,
         SWCTRL_ATCBSTORM_TERMINATE_TST},

        /* SWCTRL_ATCBSTORM_LOW_ST
         */
        {SWCTRL_ATCBSTORM_LOW_ST,
         SWCTRL_ATCBSTORM_LOW_ST,
         SWCTRL_ATCBSTORM_MIDDLE_TST,
         SWCTRL_ATCBSTORM_HIGH_TST,
         SWCTRL_ATCBSTORM_LOW_ST,
         SWCTRL_ATCBSTORM_LOW_ST,
         SWCTRL_ATCBSTORM_LOW_ST,
         SWCTRL_ATCBSTORM_TERMINATE_TST},

        /* SWCTRL_ATCBSTORM_HIGH_ST
         */
        {SWCTRL_ATCBSTORM_HIGH_ST,
         SWCTRL_ATCBSTORM_LOW_TST,
         SWCTRL_ATCBSTORM_MIDDLE_TST,
         SWCTRL_ATCBSTORM_HIGH_ST,
         SWCTRL_ATCBSTORM_CONTROL_TST,
         SWCTRL_ATCBSTORM_HIGH_ST,
         SWCTRL_ATCBSTORM_HIGH_ST,
         SWCTRL_ATCBSTORM_TERMINATE_TST},

        /* SWCTRL_ATCBSTORM_CONTROL_ST
         */
        {SWCTRL_ATCBSTORM_CONTROL_ST,
         SWCTRL_ATCBSTORM_CONTROLLOW_TST,
         SWCTRL_ATCBSTORM_CONTROL_ST,
         SWCTRL_ATCBSTORM_CONTROL_ST,
         SWCTRL_ATCBSTORM_CONTROL_ST,
         SWCTRL_ATCBSTORM_CONTROL_ST,
         SWCTRL_ATCBSTORM_RELEASE_TST,
         SWCTRL_ATCBSTORM_TERMINATE_TST},

        /*SWCTRL_ATCBSTORM_CONTROLLOW_ST
         */
       {SWCTRL_ATCBSTORM_CONTROLLOW_ST,
         SWCTRL_ATCBSTORM_CONTROLLOW_ST,
         SWCTRL_ATCBSTORM_CONTROL_TST,
         SWCTRL_ATCBSTORM_CONTROL_TST,
         SWCTRL_ATCBSTORM_CONTROLLOW_ST,
         SWCTRL_ATCBSTORM_RELEASE_TST,
         SWCTRL_ATCBSTORM_RELEASE_TST,
         SWCTRL_ATCBSTORM_TERMINATE_TST},

        /*SWCTRL_ATCBSTORM_RELEASE_ST
         */
       {SWCTRL_ATCBSTORM_INIT_ST,
         SWCTRL_ATCBSTORM_INIT_ST,
         SWCTRL_ATCBSTORM_INIT_ST,
         SWCTRL_ATCBSTORM_INIT_ST,
         SWCTRL_ATCBSTORM_INIT_ST,
         SWCTRL_ATCBSTORM_INIT_ST,
         SWCTRL_ATCBSTORM_INIT_ST,
         SWCTRL_ATCBSTORM_TERMINATE_TST}

    };

    UI32_T atc_bcast_storm_state_machine_state = 0;
    TRAP_EVENT_TrapData_T   trap_alarm_fire,trap_alarm_clear,trap_tc_apply,trap_tc_release;

    atc_bcast_storm_state_machine_state = port_info[ifindex-1].atc_broadcast_storm_entry.state_machine_state;

    switch (fsm_table[atc_bcast_storm_state_machine_state][event])
    {
        case SWCTRL_ATCBSTORM_INIT_ST:
        case SWCTRL_ATCBSTORM_MIDDLE_ST:
        case SWCTRL_ATCBSTORM_LOW_ST:
        case SWCTRL_ATCBSTORM_HIGH_ST:
        case SWCTRL_ATCBSTORM_CONTROL_ST:
        case SWCTRL_ATCBSTORM_CONTROLLOW_ST :
        case SWCTRL_ATCBSTORM_RELEASE_ST:
            break;

        case SWCTRL_ATCBSTORM_INIT_TST:
            /* 1. Set variable to be default. */
            port_info[ifindex-1].atc_broadcast_storm_entry.state_machine_trapf = SWCTRL_ATC_BROADCAST_STORM_TRAPF_LOW_FLOW;
            port_info[ifindex-1].atc_broadcast_storm_entry.state_machine_ctrapf = 0;
            port_info[ifindex-1].atc_broadcast_storm_entry.state_machine_t1 = 0;
            port_info[ifindex-1].atc_broadcast_storm_entry.state_machine_t2 = 0;
            port_info[ifindex-1].atc_broadcast_storm_entry.state_machine_manual = 0;
            port_info[ifindex-1].atc_broadcast_storm_entry.state_machine_action = 0;

           /* Next state. */
           port_info[ifindex-1].atc_broadcast_storm_entry.state_machine_state = SWCTRL_ATCBSTORM_MIDDLE_ST;

            /* Start of Debug message */
            if (SWCTRL_BACKDOOR_IsDebugFlagATCOn(SWCTRL_BACKDOOR_DEBUG_FLAG_ATC_BROADCAST_TRANSFER_STATE_MACHINE))
            {
                if (port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_auto_traffic_control_on == VAL_atcBcastStormEnable_enabled)
                {
                    BACKDOOR_MGR_Printf("\r\n FSM: Bcast, TST, ifindex = %ld, State: INIT_TST next state =MIDDLE= %ld \r\n", ifindex, port_info[ifindex-1].atc_broadcast_storm_entry.state_machine_state);
                    BACKDOOR_MGR_Printf("  action = %ld , state_machine_action = %ld , state_machine_manual =%ld \r\n",
                       port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_action, port_info[ifindex-1].atc_broadcast_storm_entry.state_machine_action,
                       port_info[ifindex-1].atc_broadcast_storm_entry.state_machine_manual);
                }
            }
            /* End of Debug messag */
            break;

        case SWCTRL_ATCBSTORM_MIDDLE_TST:
            /* 1. state_machine_t1 = 0. */
            port_info[ifindex-1].atc_broadcast_storm_entry.state_machine_t1 = 0;

            /* Next state. */
            port_info[ifindex-1].atc_broadcast_storm_entry.state_machine_state = SWCTRL_ATCBSTORM_MIDDLE_ST;

            /* Start of Debug message */
            if (SWCTRL_BACKDOOR_IsDebugFlagATCOn(SWCTRL_BACKDOOR_DEBUG_FLAG_ATC_BROADCAST_TRANSFER_STATE_MACHINE))
            {
                if (port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_auto_traffic_control_on == VAL_atcBcastStormEnable_enabled)
                {
                    BACKDOOR_MGR_Printf("\r\n FSM: Bcast, TST, ifindex = %ld, State: MIDDLE_TST next state =MIDDLE= %ld \r\n", ifindex, port_info[ifindex-1].atc_broadcast_storm_entry.state_machine_state);
                }
            }
            /* End of Debug messag */
            break;


        case SWCTRL_ATCBSTORM_LOW_TST:
            /* 1. Send Trap according to state_machine_trapf. */
            if( port_info[ifindex-1].atc_broadcast_storm_entry.state_machine_trapf != SWCTRL_ATC_BROADCAST_STORM_TRAPF_LOW_FLOW )
            {
                if (port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_trap_storm_clear == VAL_atcBcastStormAlarmClearTrapStatus_enabled)
                {
                    /* send_trap(); Sent Storm Storm Clear Trap */
                    /* Trap: 2. TRAP_EVENT_BCAST_STORM_ALARM_CLEAR */
                    trap_alarm_clear.trap_type = TRAP_EVENT_BCAST_STORM_ALARM_CLEAR;
                    trap_alarm_clear.community_specified = FALSE;
                    trap_alarm_clear.flag = TRAP_EVENT_SEND_TRAP_OPTION_DEFAULT;
                    trap_alarm_clear.u.bstorm_alarm_clear.IfIndex= ifindex;
                    trap_alarm_clear.u.bstorm_alarm_clear.SampleType= port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_sample_type;
                    trap_alarm_clear.u.bstorm_alarm_clear.CurrentTrafficRate= port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_current_traffic_rate;
                    trap_alarm_clear.u.bstorm_alarm_clear.ClearThreshold= port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_storm_clear_threshold;
#if (SYS_CPNT_TRAPMGMT == TRUE)
                    TRAP_MGR_ReqSendTrap(&trap_alarm_clear);
#else
                    SNMP_PMGR_ReqSendTrap(&trap_alarm_clear);
#endif

                }
                port_info[ifindex-1].atc_broadcast_storm_entry.state_machine_trapf = SWCTRL_ATC_BROADCAST_STORM_TRAPF_LOW_FLOW;
            }

            /* Next state. */
            port_info[ifindex-1].atc_broadcast_storm_entry.state_machine_state = SWCTRL_ATCBSTORM_LOW_ST;

            /* Start of Debug message */
            if (SWCTRL_BACKDOOR_IsDebugFlagATCOn(SWCTRL_BACKDOOR_DEBUG_FLAG_ATC_BROADCAST_TRANSFER_STATE_MACHINE))
            {
                if (port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_auto_traffic_control_on == VAL_atcBcastStormEnable_enabled)
                {
                    BACKDOOR_MGR_Printf("\r\n FSM: Bcast, TST, ifindex = %ld, State: LOW_TST next state =LOW= %ld \r\n", ifindex, port_info[ifindex-1].atc_broadcast_storm_entry.state_machine_state);
                    BACKDOOR_MGR_Printf("  action = %ld , state_machine_action = %ld , state_machine_manual =%ld \r\n",
                           port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_action, port_info[ifindex-1].atc_broadcast_storm_entry.state_machine_action,
                           port_info[ifindex-1].atc_broadcast_storm_entry.state_machine_manual);
                }
            }
            /* End of Debug messag */
            break;


        case SWCTRL_ATCBSTORM_HIGH_TST:
            if( port_info[ifindex-1].atc_broadcast_storm_entry.state_machine_trapf != SWCTRL_ATC_BROADCAST_STORM_TRAPF_HIGH_FLOW )
            {
                if (port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_trap_storm_alarm == VAL_atcBcastStormAlarmFireTrapStatus_enabled)
                {
                    /* send_trap(); Sent Storm Alarm Fire Trap*/
                    /* Trap: 1. TRAP_EVENT_BCAST_STORM_ALARM_FIRE */
                    trap_alarm_fire.trap_type = TRAP_EVENT_BCAST_STORM_ALARM_FIRE;
                    trap_alarm_fire.community_specified = FALSE;
                    trap_alarm_fire.flag = TRAP_EVENT_SEND_TRAP_OPTION_DEFAULT;
                    trap_alarm_fire.u.bstorm_alarm_fire.IfIndex= ifindex;
                    trap_alarm_fire.u.bstorm_alarm_fire.SampleType= port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_sample_type;
                    trap_alarm_fire.u.bstorm_alarm_fire.CurrentTrafficRate= port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_current_traffic_rate;
                    trap_alarm_fire.u.bstorm_alarm_fire.AlarmThreshold= port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_storm_alarm_threshold;
#if (SYS_CPNT_TRAPMGMT == TRUE)
                                TRAP_MGR_ReqSendTrap(&trap_alarm_fire);
#else
                                SNMP_PMGR_ReqSendTrap(&trap_alarm_fire);
#endif
                }
                port_info[ifindex-1].atc_broadcast_storm_entry.state_machine_trapf = SWCTRL_ATC_BROADCAST_STORM_TRAPF_HIGH_FLOW;
            }

            /* 2. Get t1 start tick. */
            port_info[ifindex-1].atc_broadcast_storm_entry.state_machine_t1 = SYSFUN_GetSysTick();

            /* Next state. */
            port_info[ifindex-1].atc_broadcast_storm_entry.state_machine_state = SWCTRL_ATCBSTORM_HIGH_ST;

            /* Start of Debug message */
            if (SWCTRL_BACKDOOR_IsDebugFlagATCOn(SWCTRL_BACKDOOR_DEBUG_FLAG_ATC_BROADCAST_TRANSFER_STATE_MACHINE))
            {
                if (port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_auto_traffic_control_on == VAL_atcBcastStormEnable_enabled)
                {
                    BACKDOOR_MGR_Printf("\r\n FSM: Bcast, TST, ifindex = %ld, State: HIGH_TST next state =HIGH= %ld \r\n", ifindex, port_info[ifindex-1].atc_broadcast_storm_entry.state_machine_state);
                    BACKDOOR_MGR_Printf("  action = %ld , state_machine_action = %ld , state_machine_manual =%ld \r\n",
                           port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_action, port_info[ifindex-1].atc_broadcast_storm_entry.state_machine_action,
                           port_info[ifindex-1].atc_broadcast_storm_entry.state_machine_manual);
                }
            }
            /* End of Debug messag */
            break;


        case SWCTRL_ATCBSTORM_CONTROL_TST:
            /* 1. Send TC On Trap according to state_machine_ctrapf. */
            if( port_info[ifindex-1].atc_broadcast_storm_entry.state_machine_ctrapf !=  SWCTRL_ATC_BROADCAST_STORM_CTRAPF_ON )
            {
                if (port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_trap_traffic_control_on == VAL_atcBcastStormTcApplyTrapStatus_enabled)
                {
                    /* send_trap(); Sent Traffic Control On Trap */
                    /* Trap: 3. TRAP_EVENT_BCAST_STORM_TC_APPLY */
                    trap_tc_apply.trap_type = TRAP_EVENT_BCAST_STORM_TC_APPLY;
                    trap_tc_apply.community_specified = FALSE;
                    trap_tc_apply.flag = TRAP_EVENT_SEND_TRAP_OPTION_DEFAULT;
                    trap_tc_apply.u.bstorm_tc_apply.IfIndex= ifindex;
                    trap_tc_apply.u.bstorm_tc_apply.SampleType= port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_sample_type;
                    trap_tc_apply.u.bstorm_tc_apply.CurrentTrafficRate= port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_current_traffic_rate;
                    trap_tc_apply.u.bstorm_tc_apply.AlarmThreshold= port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_storm_alarm_threshold;
                    trap_tc_apply.u.bstorm_tc_apply.TcAction = port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_action;
                    trap_tc_apply.u.bstorm_tc_apply.TcApplyTime= atc_broadcast_storm_timer.atc_broadcast_storm_traffic_control_on_timer;
#if (SYS_CPNT_TRAPMGMT == TRUE)
                   TRAP_MGR_ReqSendTrap(&trap_tc_apply);
#else
                      SNMP_PMGR_ReqSendTrap(&trap_tc_apply);
#endif
                }
                port_info[ifindex-1].atc_broadcast_storm_entry.state_machine_ctrapf = SWCTRL_ATC_BROADCAST_STORM_CTRAPF_ON;

                /* Start of Debug message */
                if (SWCTRL_BACKDOOR_IsDebugFlagATCOn(SWCTRL_BACKDOOR_DEBUG_FLAG_ATC_BROADCAST_TRANSFER_STATE_MACHINE))
                {
                    if (port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_auto_traffic_control_on == VAL_atcBcastStormEnable_enabled)
                    {
                        BACKDOOR_MGR_Printf("\r\n FSM: Bcast, TST, ifindex = %ld, State: CONTROL_TST , now state = %ld \r\n", ifindex, port_info[ifindex-1].atc_broadcast_storm_entry.state_machine_state);
                        BACKDOOR_MGR_Printf("  Send TC On Trap, state_machine_ctrapf = %ld \r\n",
                            port_info[ifindex-1].atc_broadcast_storm_entry.state_machine_ctrapf);
                    }
                }
                /* End of Debug messag */

            }

            /* 2. state_machine_t2 = 0 */
            port_info[ifindex-1].atc_broadcast_storm_entry.state_machine_t2 = 0;

            /* 3. Traffic On. action type: rate-limitation , shutdown. */
            if (port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_traffic_control_on != SWCTRL_ATC_BROADCAST_STORM_TC_ON_ENABLE)
            {
                                if (port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_traffic_control_release == SWCTRL_ATC_BROADCAST_STORM_TC_RELEASE_ENABLE)
                {
                    SWCTRL_SetATCBroadcastStormFSMTrafficControlReleaseStatus(ifindex, port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_action,
                        SWCTRL_ATC_BROADCAST_STORM_TC_RELEASE_DISABLE);
                }
                SWCTRL_SetATCBroadcastStormFSMTrafficControlOnStatus(ifindex, port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_action,
                    SWCTRL_ATC_BROADCAST_STORM_TC_ON_ENABLE);
            }

            /* 4. Procced to next state machine according to manul flag. */
            port_info[ifindex-1].atc_broadcast_storm_entry.state_machine_state = SWCTRL_ATCBSTORM_CONTROL_ST;

            /* Start of Debug message */
            if (SWCTRL_BACKDOOR_IsDebugFlagATCOn(SWCTRL_BACKDOOR_DEBUG_FLAG_ATC_BROADCAST_TRANSFER_STATE_MACHINE))
            {
                if (port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_auto_traffic_control_on == VAL_atcBcastStormEnable_enabled)
                {
                    BACKDOOR_MGR_Printf("\r\n FSM: Bcast, TST, ifindex = %ld, State: CONTROL_TST next state =CONTROL= %ld \r\n", ifindex, port_info[ifindex-1].atc_broadcast_storm_entry.state_machine_state);
                    BACKDOOR_MGR_Printf("  action = %ld , state_machine_action = %ld , state_machine_manual =%ld \r\n",
                           port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_action, port_info[ifindex-1].atc_broadcast_storm_entry.state_machine_action,
                           port_info[ifindex-1].atc_broadcast_storm_entry.state_machine_manual);
                }
            }
            /* End of Debug messag */
            break;

        case SWCTRL_ATCBSTORM_CONTROLLOW_TST:
            /* 1. Send Storm Clear Trap according to state_machine_trapf. */
            if( port_info[ifindex-1].atc_broadcast_storm_entry.state_machine_trapf != SWCTRL_ATC_BROADCAST_STORM_TRAPF_LOW_FLOW )
            {
                if (port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_trap_storm_clear == VAL_atcBcastStormAlarmClearTrapStatus_enabled)
                {
                    /* send_trap(); Sent Storm Clear Trap */
                    /* Trap: 2. TRAP_EVENT_BCAST_STORM_ALARM_CLEAR */
                    trap_alarm_clear.trap_type = TRAP_EVENT_BCAST_STORM_ALARM_CLEAR;
                    trap_alarm_clear.community_specified = FALSE;
                    trap_alarm_clear.flag = TRAP_EVENT_SEND_TRAP_OPTION_DEFAULT;
                    trap_alarm_clear.u.bstorm_alarm_clear.IfIndex= ifindex;
                    trap_alarm_clear.u.bstorm_alarm_clear.SampleType= port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_sample_type;
                    trap_alarm_clear.u.bstorm_alarm_clear.CurrentTrafficRate= port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_current_traffic_rate;
                    trap_alarm_clear.u.bstorm_alarm_clear.ClearThreshold= port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_storm_clear_threshold;
#if (SYS_CPNT_TRAPMGMT == TRUE)
                                TRAP_MGR_ReqSendTrap(&trap_alarm_clear);
#else
                                SNMP_PMGR_ReqSendTrap(&trap_alarm_clear);
#endif
                }
                port_info[ifindex-1].atc_broadcast_storm_entry.state_machine_trapf = SWCTRL_ATC_BROADCAST_STORM_TRAPF_LOW_FLOW;
            }


            /* 2. Get state_machine_t2 start tick. */
            port_info[ifindex-1].atc_broadcast_storm_entry.state_machine_t2 = SYSFUN_GetSysTick();

            /* Next state. */
            port_info[ifindex-1].atc_broadcast_storm_entry.state_machine_state = SWCTRL_ATCBSTORM_CONTROLLOW_ST;

            /* Start of Debug message */
            if (SWCTRL_BACKDOOR_IsDebugFlagATCOn(SWCTRL_BACKDOOR_DEBUG_FLAG_ATC_BROADCAST_TRANSFER_STATE_MACHINE))
            {
                if (port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_auto_traffic_control_on == VAL_atcBcastStormEnable_enabled)
                {
                    BACKDOOR_MGR_Printf("\r\n FSM: Bcast, TST, ifindex = %ld, State: CONTROLLOW_TST next state =CONTROLLOW= %ld \r\n", ifindex, port_info[ifindex-1].atc_broadcast_storm_entry.state_machine_state);
                    BACKDOOR_MGR_Printf("  action = %ld , state_machine_action = %ld , state_machine_manual =%ld \r\n",
                           port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_action, port_info[ifindex-1].atc_broadcast_storm_entry.state_machine_action,
                           port_info[ifindex-1].atc_broadcast_storm_entry.state_machine_manual);
                }
            }
            /* End of Debug messag */
            break;

        case SWCTRL_ATCBSTORM_RELEASE_TST:
            /* 1. Sent Traffic Control Release Trap. */
            if( (port_info[ifindex-1].atc_broadcast_storm_entry.state_machine_action == VAL_atcBcastStormTcAction_rate_control) &&
                (port_info[ifindex-1].atc_broadcast_storm_entry.state_machine_ctrapf !=  SWCTRL_ATC_BROADCAST_STORM_CTRAPF_RELEASE))
            {
                if (port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_trap_traffic_control_release == VAL_atcBcastStormTcReleaseTrapStatus_enabled)
                {
                    /* send_trap(); Sent Traffic Control Release Trap */
                    /* Trap: 4. TRAP_EVENT_BCAST_STORM_TC_RELEASE */
                    trap_tc_release.trap_type = TRAP_EVENT_BCAST_STORM_TC_RELEASE;
                    trap_tc_release.community_specified = FALSE;
                    trap_tc_release.flag = TRAP_EVENT_SEND_TRAP_OPTION_DEFAULT;
                    trap_tc_release.u.bstorm_tc_release.IfIndex= ifindex;
                    trap_tc_release.u.bstorm_tc_release.SampleType= port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_sample_type;
                    trap_tc_release.u.bstorm_tc_release.CurrentTrafficRate= port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_current_traffic_rate;
                    trap_tc_release.u.bstorm_tc_release.ClearThreshold= port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_storm_clear_threshold;
                    trap_tc_release.u.bstorm_tc_release.TcReleaseTime= atc_broadcast_storm_timer.atc_broadcast_storm_traffic_control_release_timer;
#if (SYS_CPNT_TRAPMGMT == TRUE)
                                TRAP_MGR_ReqSendTrap(&trap_tc_release);
#else
                    SNMP_PMGR_ReqSendTrap(&trap_tc_release);
#endif
                }
                port_info[ifindex-1].atc_broadcast_storm_entry.state_machine_ctrapf = SWCTRL_ATC_BROADCAST_STORM_CTRAPF_RELEASE;

                /* Start of Debug message */
                if (SWCTRL_BACKDOOR_IsDebugFlagATCOn(SWCTRL_BACKDOOR_DEBUG_FLAG_ATC_BROADCAST_TRANSFER_STATE_MACHINE))
                {
                    if (port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_auto_traffic_control_on == VAL_atcBcastStormEnable_enabled)
                    {
                        BACKDOOR_MGR_Printf("\r\n FSM: Bcast, TST, ifindex = %ld, State: RELEASE_TST , now state = %ld \r\n", ifindex, port_info[ifindex-1].atc_broadcast_storm_entry.state_machine_state);
                        BACKDOOR_MGR_Printf("  action = %ld , state_machine_action = %ld , state_machine_manual =%ld \r\n",
                            port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_action, port_info[ifindex-1].atc_broadcast_storm_entry.state_machine_action,
                            port_info[ifindex-1].atc_broadcast_storm_entry.state_machine_manual);
                    }
                }
                /* End of Debug messag */

            }

            /* 2. Release. */
            if (port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_traffic_control_release != SWCTRL_ATC_BROADCAST_STORM_TC_RELEASE_ENABLE)
            {
                if (port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_traffic_control_on == SWCTRL_ATC_BROADCAST_STORM_TC_ON_ENABLE)
                {
                    SWCTRL_SetATCBroadcastStormFSMTrafficControlOnStatus(ifindex, port_info[ifindex-1].atc_broadcast_storm_entry.state_machine_action,
                        SWCTRL_ATC_BROADCAST_STORM_TC_ON_DISABLE);
                }

                SWCTRL_SetATCBroadcastStormFSMTrafficControlReleaseStatus(ifindex, port_info[ifindex-1].atc_broadcast_storm_entry.state_machine_action,
                    SWCTRL_ATC_BROADCAST_STORM_TC_RELEASE_ENABLE);
                SWCTRL_SetATCBroadcastStormFSMTrafficControlReleaseStatus(ifindex, port_info[ifindex-1].atc_broadcast_storm_entry.state_machine_action,
                    SWCTRL_ATC_BROADCAST_STORM_TC_RELEASE_DISABLE);
            }

            /* 3. Set Manual to disable.*/
            port_info[ifindex-1].atc_broadcast_storm_entry.state_machine_manual = SWCTRL_ATC_BROADCAST_STORM_STATE_MACHINE_MANUAL_DISABLE;


            /* 4. Set variable to be default. */
            port_info[ifindex-1].atc_broadcast_storm_entry.state_machine_trapf = SWCTRL_ATC_BROADCAST_STORM_TRAPF_LOW_FLOW;
            port_info[ifindex-1].atc_broadcast_storm_entry.state_machine_ctrapf = 0;
            port_info[ifindex-1].atc_broadcast_storm_entry.state_machine_t1 = 0;
            port_info[ifindex-1].atc_broadcast_storm_entry.state_machine_t2 = 0;
            port_info[ifindex-1].atc_broadcast_storm_entry.state_machine_manual = 0;
            port_info[ifindex-1].atc_broadcast_storm_entry.state_machine_action = 0;

            /* Next state. */
            port_info[ifindex-1].atc_broadcast_storm_entry.state_machine_state = SWCTRL_ATCBSTORM_MIDDLE_ST;

            /* Start of Debug message */
            if (SWCTRL_BACKDOOR_IsDebugFlagATCOn(SWCTRL_BACKDOOR_DEBUG_FLAG_ATC_BROADCAST_TRANSFER_STATE_MACHINE))
            {
                if (port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_auto_traffic_control_on == VAL_atcBcastStormEnable_enabled)
                {
                    BACKDOOR_MGR_Printf("\r\n FSM: Bcast, TST, ifindex = %ld, State: RELEASE_TST next state =MIDDLE= %ld \r\n", ifindex, port_info[ifindex-1].atc_broadcast_storm_entry.state_machine_state);
                    BACKDOOR_MGR_Printf("  action = %ld , state_machine_action = %ld , state_machine_manual =%ld \r\n",
                           port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_action, port_info[ifindex-1].atc_broadcast_storm_entry.state_machine_action,
                           port_info[ifindex-1].atc_broadcast_storm_entry.state_machine_manual);
                }
            }
            /* End of Debug messag */
            break;

        case SWCTRL_ATCBSTORM_TERMINATE_TST:
            /* 1. Sent Traffic Control Release Trap. */
            if( (port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_traffic_control_on == SWCTRL_ATC_BROADCAST_STORM_TC_ON_ENABLE) &&
                (port_info[ifindex-1].atc_broadcast_storm_entry.state_machine_action == VAL_atcBcastStormTcAction_rate_control) &&
                (port_info[ifindex-1].atc_broadcast_storm_entry.state_machine_ctrapf !=  SWCTRL_ATC_BROADCAST_STORM_CTRAPF_RELEASE))
            {
                if (port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_trap_traffic_control_release == VAL_atcBcastStormTcReleaseTrapStatus_enabled)
                {
                    /* send_trap(); Sent Traffic Control Release Trap */
                    /* Trap: 4. TRAP_EVENT_BCAST_STORM_TC_RELEASE */
                    trap_tc_release.trap_type = TRAP_EVENT_BCAST_STORM_TC_RELEASE;
                    trap_tc_release.community_specified = FALSE;
                    trap_tc_release.flag = TRAP_EVENT_SEND_TRAP_OPTION_DEFAULT;
                    trap_tc_release.u.bstorm_tc_release.IfIndex= ifindex;
                    trap_tc_release.u.bstorm_tc_release.SampleType= port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_sample_type;
                    trap_tc_release.u.bstorm_tc_release.CurrentTrafficRate= port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_current_traffic_rate;
                    trap_tc_release.u.bstorm_tc_release.ClearThreshold= port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_storm_clear_threshold;
                    trap_tc_release.u.bstorm_tc_release.TcReleaseTime= atc_broadcast_storm_timer.atc_broadcast_storm_traffic_control_release_timer;
#if (SYS_CPNT_TRAPMGMT == TRUE)
                                TRAP_MGR_ReqSendTrap(&trap_tc_release);
#else
                                SNMP_PMGR_ReqSendTrap(&trap_tc_release);
#endif
                }
                port_info[ifindex-1].atc_broadcast_storm_entry.state_machine_ctrapf = SWCTRL_ATC_BROADCAST_STORM_CTRAPF_RELEASE;
            }

            /* 2. Release if traffic_control_on is enabled. */
            if (port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_traffic_control_on == SWCTRL_ATC_BROADCAST_STORM_TC_ON_ENABLE)
            {
                SWCTRL_SetATCBroadcastStormFSMTrafficControlOnStatus(ifindex, port_info[ifindex-1].atc_broadcast_storm_entry.state_machine_action,
                    SWCTRL_ATC_BROADCAST_STORM_TC_ON_DISABLE);

                SWCTRL_SetATCBroadcastStormFSMTrafficControlReleaseStatus(ifindex, port_info[ifindex-1].atc_broadcast_storm_entry.state_machine_action,
                    SWCTRL_ATC_BROADCAST_STORM_TC_RELEASE_ENABLE);
                SWCTRL_SetATCBroadcastStormFSMTrafficControlReleaseStatus(ifindex, port_info[ifindex-1].atc_broadcast_storm_entry.state_machine_action,
                    SWCTRL_ATC_BROADCAST_STORM_TC_RELEASE_DISABLE);

                /* Start of Debug message */
                if (SWCTRL_BACKDOOR_IsDebugFlagATCOn(SWCTRL_BACKDOOR_DEBUG_FLAG_ATC_BROADCAST_TRANSFER_STATE_MACHINE))
                {
                    if (port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_auto_traffic_control_on == VAL_atcBcastStormEnable_enabled)
                    {
                        BACKDOOR_MGR_Printf("\r\n FSM: Bcast, TST, ifindex = %ld, State: TERMINATE_TST , now state = %ld \r\n", ifindex, port_info[ifindex-1].atc_broadcast_storm_entry.state_machine_state);
                        BACKDOOR_MGR_Printf("  atc_broadcast_storm_traffic_control_on = %ld  \r\n",
                            port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_traffic_control_on);
                    }
                }
                /* End of Debug messag */

            }

            /* 3. Set variable to be default. */
            port_info[ifindex-1].atc_broadcast_storm_entry.state_machine_trapf = SWCTRL_ATC_BROADCAST_STORM_TRAPF_LOW_FLOW;
            port_info[ifindex-1].atc_broadcast_storm_entry.state_machine_ctrapf = 0;
            port_info[ifindex-1].atc_broadcast_storm_entry.state_machine_t1 = 0;
            port_info[ifindex-1].atc_broadcast_storm_entry.state_machine_t2 = 0;
            port_info[ifindex-1].atc_broadcast_storm_entry.state_machine_manual = 0;
            port_info[ifindex-1].atc_broadcast_storm_entry.state_machine_action = 0;

            /* Next state. */
            port_info[ifindex-1].atc_broadcast_storm_entry.state_machine_state = SWCTRL_ATCBSTORM_INIT_ST;

            /* Start of Debug message */
            if (SWCTRL_BACKDOOR_IsDebugFlagATCOn(SWCTRL_BACKDOOR_DEBUG_FLAG_ATC_BROADCAST_TRANSFER_STATE_MACHINE))
            {
                if (port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_auto_traffic_control_on == VAL_atcBcastStormEnable_enabled)
                {
                    BACKDOOR_MGR_Printf("\r\n FSM: Bcast, TST, ifindex = %ld, State: TERMINATE_TST next state =INIT= %ld \r\n", ifindex, port_info[ifindex-1].atc_broadcast_storm_entry.state_machine_state);
                    BACKDOOR_MGR_Printf("  action = %ld , state_machine_action = %ld , state_machine_manual =%ld \r\n",
                       port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_action, port_info[ifindex-1].atc_broadcast_storm_entry.state_machine_action,
                       port_info[ifindex-1].atc_broadcast_storm_entry.state_machine_manual);
                }
            }
            /* End of Debug messag */
            break;

        default:
            break;
    } /* end of switch */
} /* End of SWCTRL_ATCBroadcastStormProtectionFSM */

BOOL_T SWCTRL_DisableBStormAfterClearThreshold(UI32_T ifindex)
{

    UI32_T fsm_state, atc_state;

    if ( TRUE == SWCTRL_IsManagementPort(ifindex) )
    {
        return FALSE;
    }

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if ((ifindex == 0) ||(ifindex > SYS_ADPT_TOTAL_NBR_OF_LPORT))
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Logical Port ID (1-%d)", SYS_ADPT_TOTAL_NBR_OF_LPORT);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_LOGICAL_PORT_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (!SWCTRL_IS_EXIST (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Interface");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

#if (SYS_CPNT_ATC_BSTORM_SUPPORT_LPORT != TRUE)
    if (SWCTRL_IS_TRUNK (ifindex))
    {
            EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                      SWCTRL_NO_USE_FUNC_NO,
                                      EH_TYPE_MSG_TRUNK_CNFG_ERR,
                                      SYSLOG_LEVEL_INFO,
                                      "it doesn't support Broadcast Storm Control.");  /*SWCTRL_ENO_NOT_TRUNK*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#else
    if (SWCTRL_IS_TRUNK_MEMBER (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#endif

    SWCTRL_LOCK();
    fsm_state = port_info[ifindex-1].atc_broadcast_storm_entry.state_machine_state;
    atc_state = port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_auto_traffic_control_on;
    SWCTRL_UNLOCK();

        if((fsm_state != SWCTRL_ATCBSTORM_CONTROL_ST )&&(atc_state == VAL_atcBcastStormEnable_enabled))
        {
        return SWDRV_DisableBroadcastStormControl(SWCTRL_IFINDEX_TO_UNIT(ifindex), ifindex);
        }
        else
            return TRUE;


}

#endif /* End of SYS_CPNT_ATC_BSTORM */

#if (SYS_CPNT_ATC_MSTORM == TRUE)
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetATCMulticastStormAutoTrafficControlOnStatus
 * -------------------------------------------------------------------------
 * 1.
 * FUNCTION: This function will set the auto traffic control on status of multicast
 *           storm control function
 * INPUT   : ifindex -- which port to set
 *           auto_traffic_control_on_status    -- which status of auto traffic control on
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetATCMulticastStormAutoTrafficControlOnStatus(UI32_T ifindex, UI32_T auto_traffic_control_on_status)
{
    /* LOCAL VARIABLES
     */
#if (SYS_CPNT_ATC_MSTORM_SUPPORT_LPORT == TRUE)
    UI32_T                          unit, port;
#endif
    UI32_T                          timer;
    UI32_T                          threshold;
    BOOL_T                          retval = FALSE;

    /* BODY
     */
    /* Check Management Port.
     * TRUE: The port is a management port.
     * FALSE: The port is not a managemet port.
     * It returns FALSE, when the port is a management port.
     */

    if ( TRUE == SWCTRL_IsManagementPort(ifindex) )
    {
        return FALSE;
    }

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if( ifindex == 0 || ifindex > SYS_ADPT_TOTAL_NBR_OF_LPORT)
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Logical Port ID (1-%d)", SYS_ADPT_TOTAL_NBR_OF_LPORT);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_LOGICAL_PORT_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (!SWCTRL_IS_EXIST (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Interface");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

#if (SYS_CPNT_ATC_MSTORM_SUPPORT_LPORT != TRUE)
    if (SWCTRL_IS_TRUNK (ifindex))
    {
            EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                      SWCTRL_NO_USE_FUNC_NO,
                                      EH_TYPE_MSG_TRUNK_CNFG_ERR,
                                      SYSLOG_LEVEL_INFO,
                                      "it doesn't support Multicast Storm Control.");  /*SWCTRL_ENO_NOT_TRUNK*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#else
    if (SWCTRL_IS_TRUNK_MEMBER (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#endif

    if((auto_traffic_control_on_status != VAL_atcMcastStormEnable_enabled) &&
       (auto_traffic_control_on_status != VAL_atcMcastStormEnable_disabled))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_INVALID_PARAMETER,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "auto traffic control on status"); /*SWCTRL_ENO_INVALID_AUTO_TRAFFIC_CONTROL_ON_STATUS*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if(port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_auto_traffic_control_on == auto_traffic_control_on_status)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
    }

    if (SWCTRL_IsServerBladePort (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_SRV_BLADE_PORT_CNFG,
                                  SYSLOG_LEVEL_INFO,
                                  "Configuring Multicast Storm Control");     /*SWCTRL_ENO_DENY_ON_SERVER_BLADE_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    /* When enable the function, ATC function must be disabled. */
#if (SYS_CPNT_STORM_MODE & SYS_CPNT_STORM_MSTORM)
    if ( (auto_traffic_control_on_status == VAL_atcMcastStormEnable_enabled) &&
         (port_info[ifindex-1].mcast_storm_entry.mcast_storm_status == VAL_mcastStormStatus_enabled) )
    {
        SWCTRL_SetMcastStormStatus(ifindex, VAL_mcastStormStatus_disabled);
    }
#endif

#if (SYS_CPNT_SWCTRL_SINGLE_INGRESS_RATE_LIMIT == TRUE)
    if (auto_traffic_control_on_status == VAL_atcMcastStormEnable_enabled)
    {
        UI32_T rate_limit_group = SYS_CPNT_SWCTRL_RATE_LIMIT_GROUP_FOR_MSTORM;

        #if (SYS_CPNT_STORM_MODE & SYS_CPNT_STORM_BSTORM)
        if (rate_limit_group == SYS_CPNT_SWCTRL_RATE_LIMIT_GROUP_FOR_BSTORM)
        {
            if (port_info[ifindex-1].bcast_storm_entry.bcast_storm_status == VAL_bcastStormStatus_enabled)
            {
                SWCTRL_SetBcastStormStatus(ifindex, VAL_bcastStormStatus_disabled);
            }
        }
        #endif

        #if (SYS_CPNT_STORM_MODE & SYS_CPNT_STORM_UNKNOWN_USTORM)
        if (rate_limit_group == SYS_CPNT_SWCTRL_RATE_LIMIT_GROUP_FOR_UNKNOWN_USTORM)
        {
            if (port_info[ifindex-1].unknown_ucast_storm_entry.unknown_ucast_storm_status == VAL_unkucastStormStatus_enabled)
            {
                SWCTRL_SetUnknownUnicastStormStatus(ifindex, VAL_unkucastStormStatus_disabled);
            }
        }
        #endif
    }
#endif

    /* 1. Traffic Control On Timer */
    /* Check: 1. Timer, Traffic Control On Timer. */
    if ((atc_multicast_storm_timer.atc_multicast_storm_traffic_control_on_timer < SYS_ADPT_ATC_MSTORM_MIN_TC_ON_TIMER) ||
        (atc_multicast_storm_timer.atc_multicast_storm_traffic_control_on_timer > SYS_ADPT_ATC_MSTORM_MAX_TC_ON_TIMER))
    {
        timer = SYS_DFLT_ATC_MSTORM_TC_ON_TIMER;
        SWCTRL_SetATCMulticastStormTrafficControlOnTimer(timer);
    }

    /* 2. Traffic Control Release Timer */
    /* Check: 2. Timer, Traffic Control Release Timer. */
    if ((atc_multicast_storm_timer.atc_multicast_storm_traffic_control_release_timer < SYS_ADPT_ATC_MSTORM_MIN_TC_RELEASE_TIMER) ||
        (atc_multicast_storm_timer.atc_multicast_storm_traffic_control_release_timer > SYS_ADPT_ATC_MSTORM_MAX_TC_RELEASE_TIMER))
    {
        timer= SYS_DFLT_ATC_MSTORM_TC_RELEASE_TIMER;
        SWCTRL_SetATCMulticastStormTrafficControlReleaseTimer(timer);
    }

    /* 3. Storm Alarm Threshold */
    /* Check: 3. Threshold, Storm Alarm Threshold. */
    if ((port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_storm_alarm_threshold < SYS_ADPT_ATC_MSTORM_MIN_RATE_LIMIT) ||
        (port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_storm_alarm_threshold > SYS_ADPT_ATC_MSTORM_MAX_RATE_LIMIT))
    {
        threshold = (SYS_DFLT_ATC_MSTORM_STORM_ALARM_THRESHOLD / SWCTRL_ATC_MULTICAST_STORM_ONE_THOUSAND);
        SWCTRL_SetATCMulticastStormStormAlarmThreshold(ifindex, threshold);
    }

#if 0
    /* 4. Storm Clear Threshold */
    /* Check: 4. Threshold, Storm Clear Threshold. */
    if ((port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_storm_clear_threshold < SYS_ADPT_ATC_MSTORM_MIN_RATE_LIMIT) ||
        (port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_storm_clear_threshold > SYS_ADPT_ATC_MSTORM_MAX_RATE_LIMIT))
    {
        threshold = (SYS_DFLT_ATC_MSTORM_STORM_CLEAR_THRESHOLD / SWCTRL_ATC_MULTICAST_STORM_ONE_THOUSAND);
        SWCTRL_SetATCMulticastStormStormClearThreshold(ifindex, threshold);
    }
    else
    {
        threshold = (port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_storm_clear_threshold / SWCTRL_ATC_MULTICAST_STORM_ONE_THOUSAND);
        SWCTRL_SetATCMulticastStormStormClearThreshold(ifindex, threshold);
    }
#endif


    /* if normal port
     */
    if(!SWCTRL_IS_TRUNK (ifindex))
    {
        SWCTRL_LOCK();
        port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_auto_traffic_control_on = auto_traffic_control_on_status;
        port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_status= auto_traffic_control_on_status;
        SWCTRL_UNLOCK();
        retval = TRUE;

        /* 4. Storm Clear Threshold */
        /* Check: 4. Threshold, Storm Clear Threshold. */
        if ((port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_storm_clear_threshold < SYS_ADPT_ATC_MSTORM_MIN_RATE_LIMIT) ||
            (port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_storm_clear_threshold > SYS_ADPT_ATC_MSTORM_MAX_RATE_LIMIT))
        {
            threshold = (SYS_DFLT_ATC_MSTORM_STORM_CLEAR_THRESHOLD / SWCTRL_ATC_MULTICAST_STORM_ONE_THOUSAND);
            SWCTRL_SetATCMulticastStormStormClearThreshold(ifindex, threshold);
        }
        else
        {
            threshold = (port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_storm_clear_threshold / SWCTRL_ATC_MULTICAST_STORM_ONE_THOUSAND);
            SWCTRL_SetATCMulticastStormStormClearThreshold(ifindex, threshold);
        }
                /*ATC on , Broadcast Storm shold be closed*/
                SWCTRL_DisableMStormAfterClearThreshold(ifindex);

    }

    /* if trunk port
     */
#if (SYS_CPNT_ATC_MSTORM_SUPPORT_LPORT == TRUE)
    if(SWCTRL_IS_TRUNK (ifindex))
    {
        SWCTRL_TrunkPortExtInfo_T trunk_ext_p_info;
        UI32_T                    i;

        memset(&trunk_ext_p_info, 0, sizeof(SWCTRL_TrunkPortExtInfo_T));
        SWCTRL_GetTrunkPortExtInfo (ifindex, &trunk_ext_p_info);

        for(i=0; i<trunk_ext_p_info.member_number; i++)
        {
            unit = trunk_ext_p_info.member_list[i].unit;
            port = trunk_ext_p_info.member_list[i].port;

            SWCTRL_LOCK();
            port_info[(SWCTRL_UPORT_TO_IFINDEX(unit, port)) - 1].atc_multicast_storm_entry.atc_multicast_storm_auto_traffic_control_on = auto_traffic_control_on_status;
            port_info[(SWCTRL_UPORT_TO_IFINDEX(unit, port)) - 1].atc_multicast_storm_entry.atc_multicast_storm_status = auto_traffic_control_on_status;
            SWCTRL_UNLOCK();
            retval = TRUE;
        } /* End of for () */
        if (retval)
        {
            SWCTRL_LOCK();
            port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_auto_traffic_control_on = auto_traffic_control_on_status;
            port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_status= auto_traffic_control_on_status;
            SWCTRL_UNLOCK();

            /* 4. Storm Clear Threshold */
            /* Check: 4. Threshold, Storm Clear Threshold. */
            if ((port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_storm_clear_threshold < SYS_ADPT_ATC_MSTORM_MIN_RATE_LIMIT) ||
                (port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_storm_clear_threshold > SYS_ADPT_ATC_MSTORM_MAX_RATE_LIMIT))
            {
                threshold = (SYS_DFLT_ATC_MSTORM_STORM_CLEAR_THRESHOLD / SWCTRL_ATC_MULTICAST_STORM_ONE_THOUSAND);
                SWCTRL_SetATCMulticastStormStormClearThreshold(ifindex, threshold);
            }
            else
            {
                threshold = (port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_storm_clear_threshold / SWCTRL_ATC_MULTICAST_STORM_ONE_THOUSAND);
                SWCTRL_SetATCMulticastStormStormClearThreshold(ifindex, threshold);
            }
        }
    } /* End of trunk port */
#endif /* End of (SYS_CPNT_ATC_MSTORM_SUPPORT_LPORT == TRUE) */

    if(auto_traffic_control_on_status == VAL_atcMcastStormEnable_enabled)
    {
        SWCTRL_ATCMulticastStormProtectionFSM(ifindex, SWCTRL_ATCMSTORM_ENTER_AUTO_EV);
    }
    else
    {
        SWCTRL_ATCMulticastStormProtectionFSM(ifindex, SWCTRL_ATCMSTORM_LEAVE_AUTO_EV);
    }

    SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME ();
    SWCTRL_RETURN_AND_RELEASE_CSC( retval );
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetATCMulticastStormAutoTrafficControlOnStatus
 * -------------------------------------------------------------------------
 * 2.
 * FUNCTION: This function will get the auto traffic control on status of multicast
 *           storm control function
 * INPUT   : ifindex -- which port to set
 *
 * OUTPUT  : auto_traffic_control_on_status    -- which status of auto traffic control on
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_GetATCMulticastStormAutoTrafficControlOnStatus(UI32_T ifindex, UI32_T *auto_traffic_control_on_status)
{
    /* LOCAL VARIABLES
     */

    /* BODY
     */
    /* Check Management Port.
     * TRUE: The port is a management port.
     * FALSE: The port is not a managemet port.
     * It returns FALSE, when the port is a management port.
     */
    if ( TRUE == SWCTRL_IsManagementPort(ifindex) )
    {
        return FALSE;
    }

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if ( ifindex == 0                          ||
         ifindex > SYS_ADPT_TOTAL_NBR_OF_LPORT )
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Logical Port ID (1-%d)", SYS_ADPT_TOTAL_NBR_OF_LPORT);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_LOGICAL_PORT_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (!SWCTRL_IS_EXIST (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Interface");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

#if (SYS_CPNT_ATC_MSTORM_SUPPORT_LPORT != TRUE)
    if (SWCTRL_IS_TRUNK (ifindex))
    {
            EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                      SWCTRL_NO_USE_FUNC_NO,
                                      EH_TYPE_MSG_TRUNK_CNFG_ERR,
                                      SYSLOG_LEVEL_INFO,
                                      "it doesn't support Multicast Storm Control.");  /*SWCTRL_ENO_NOT_TRUNK*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#else
    if (SWCTRL_IS_TRUNK_MEMBER (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#endif

    SWCTRL_LOCK();
    *auto_traffic_control_on_status = port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_auto_traffic_control_on;
    SWCTRL_UNLOCK();

    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetATCMulticastStormAutoTrafficControlReleaseStatus
 * -------------------------------------------------------------------------
 * 3.
 * FUNCTION: This function will set the auto traffic control release status of multicast
 *           storm control function
 * INPUT   : ifindex -- which port to set
 *           auto_traffic_control_release_status    -- which status of auto traffic control release
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetATCMulticastStormAutoTrafficControlReleaseStatus(UI32_T ifindex, UI32_T auto_traffic_control_release_status)
{
    /* LOCAL VARIABLES
     */
#if (SYS_CPNT_ATC_MSTORM_SUPPORT_LPORT == TRUE)
    UI32_T                          unit, port;
#endif
    BOOL_T                          retval = FALSE;

    /* BODY
     */
    /* Check Management Port.
     * TRUE: The port is a management port.
     * FALSE: The port is not a managemet port.
     * It returns FALSE, when the port is a management port.
     */
    if ( TRUE == SWCTRL_IsManagementPort(ifindex) )
    {
        return FALSE;
    }

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if( ifindex == 0 || ifindex > SYS_ADPT_TOTAL_NBR_OF_LPORT)
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Logical Port ID (1-%d)", SYS_ADPT_TOTAL_NBR_OF_LPORT);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_LOGICAL_PORT_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (!SWCTRL_IS_EXIST (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Interface");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

#if (SYS_CPNT_ATC_MSTORM_SUPPORT_LPORT == TRUE)
    if (SWCTRL_IS_TRUNK_MEMBER (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#endif

    if((auto_traffic_control_release_status != VAL_atcMcastStormAutoRelease_enabled) &&
       (auto_traffic_control_release_status != VAL_atcMcastStormAutoRelease_disabled))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_INVALID_PARAMETER,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "auto traffic control on status"); /*SWCTRL_ENO_INVALID_AUTO_TRAFFIC_CONTROL_ON_STATUS*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if(port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_auto_traffic_control_release == auto_traffic_control_release_status)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
    }

    if (SWCTRL_IsServerBladePort (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_SRV_BLADE_PORT_CNFG,
                                  SYSLOG_LEVEL_INFO,
                                  "Configuring Multicast Storm Control");     /*SWCTRL_ENO_DENY_ON_SERVER_BLADE_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }


    /* if normal port
     */
    if(!SWCTRL_IS_TRUNK (ifindex))
    {
        SWCTRL_LOCK();
        port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_auto_traffic_control_release = auto_traffic_control_release_status;
        SWCTRL_UNLOCK();
        retval = TRUE;
    }

    /* if trunk port
     */
#if (SYS_CPNT_ATC_MSTORM_SUPPORT_LPORT == TRUE)
    if(SWCTRL_IS_TRUNK (ifindex))
    {
        SWCTRL_TrunkPortExtInfo_T trunk_ext_p_info;
        UI32_T                    i;

        memset(&trunk_ext_p_info, 0, sizeof(SWCTRL_TrunkPortExtInfo_T));
        SWCTRL_GetTrunkPortExtInfo (ifindex, &trunk_ext_p_info);

        for(i=0; i<trunk_ext_p_info.member_number; i++)
        {
            unit = trunk_ext_p_info.member_list[i].unit;
            port = trunk_ext_p_info.member_list[i].port;

            SWCTRL_LOCK();
            port_info[(SWCTRL_UPORT_TO_IFINDEX(unit, port)) - 1].atc_multicast_storm_entry.atc_multicast_storm_auto_traffic_control_release = auto_traffic_control_release_status;
            SWCTRL_UNLOCK();
            retval = TRUE;
        } /* End of for () */
        if (retval)
        {
            SWCTRL_LOCK();
            port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_auto_traffic_control_release = auto_traffic_control_release_status;
            SWCTRL_UNLOCK();
        }
    } /* End of trunk port */
#endif /* End of (SYS_CPNT_ATC_MSTORM_SUPPORT_LPORT == TRUE) */

    SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME ();
    SWCTRL_RETURN_AND_RELEASE_CSC( retval );
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetATCMulticastStormAutoTrafficControlReleaseStatus
 * -------------------------------------------------------------------------
 * 4.
 * FUNCTION: This function will get the auto traffic control release status of multicast
 *           storm control function
 * INPUT   : ifindex -- which port to set
 *           auto_traffic_control_release_status    -- which status of auto traffic control release
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_GetATCMulticastStormAutoTrafficControlReleaseStatus(UI32_T ifindex, UI32_T *auto_traffic_control_release_status)
{
    /* LOCAL VARIABLES
     */

    /* BODY
     */
    /* Check Management Port.
     * TRUE: The port is a management port.
     * FALSE: The port is not a managemet port.
     * It returns FALSE, when the port is a management port.
     */
    if ( TRUE == SWCTRL_IsManagementPort(ifindex) )
    {
        return FALSE;
    }

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if ( ifindex == 0                          ||
         ifindex > SYS_ADPT_TOTAL_NBR_OF_LPORT )
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Logical Port ID (1-%d)", SYS_ADPT_TOTAL_NBR_OF_LPORT);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_LOGICAL_PORT_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (!SWCTRL_IS_EXIST (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Interface");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

#if (SYS_CPNT_ATC_MSTORM_SUPPORT_LPORT != TRUE)
    if (SWCTRL_IS_TRUNK (ifindex))
    {
            EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                      SWCTRL_NO_USE_FUNC_NO,
                                      EH_TYPE_MSG_TRUNK_CNFG_ERR,
                                      SYSLOG_LEVEL_INFO,
                                      "it doesn't support Multicast Storm Control.");  /*SWCTRL_ENO_NOT_TRUNK*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#else
    if (SWCTRL_IS_TRUNK_MEMBER (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#endif

    SWCTRL_LOCK();
    *auto_traffic_control_release_status = port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_auto_traffic_control_release;
    SWCTRL_UNLOCK();

    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetATCMulticastStormTrafficControlOnStatus
 * -------------------------------------------------------------------------
 * 5.
 * FUNCTION: This function will set the traffic control on status of multicast
 *           storm control function
 * INPUT   : ifindex -- which port to set
 *           traffic_control_on_status    -- which status of traffic control on
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetATCMulticastStormTrafficControlOnStatus(UI32_T ifindex, UI32_T traffic_control_on_status)
{
    /* LOCAL VARIABLES
     */
#if (SYS_CPNT_ATC_MSTORM_SUPPORT_LPORT == TRUE)
    UI32_T                          unit, port;
#endif
    BOOL_T                          retval = FALSE;

    /* BODY
     */
    /* Check Management Port.
     * TRUE: The port is a management port.
     * FALSE: The port is not a managemet port.
     * It returns FALSE, when the port is a management port.
     */
    if ( TRUE == SWCTRL_IsManagementPort(ifindex) )
    {
        return FALSE;
    }

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if( ifindex == 0 || ifindex > SYS_ADPT_TOTAL_NBR_OF_LPORT)
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Logical Port ID (1-%d)", SYS_ADPT_TOTAL_NBR_OF_LPORT);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_LOGICAL_PORT_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (!SWCTRL_IS_EXIST (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Interface");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

#if (SYS_CPNT_ATC_MSTORM_SUPPORT_LPORT != TRUE)
    if (SWCTRL_IS_TRUNK (ifindex))
    {
            EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                      SWCTRL_NO_USE_FUNC_NO,
                                      EH_TYPE_MSG_TRUNK_CNFG_ERR,
                                      SYSLOG_LEVEL_INFO,
                                      "it doesn't support Multicast Storm Control.");  /*SWCTRL_ENO_NOT_TRUNK*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#else
    if (SWCTRL_IS_TRUNK_MEMBER (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#endif

    if(port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_traffic_control_on == traffic_control_on_status)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
    }

    retval = TRUE;

    SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME ();
    SWCTRL_RETURN_AND_RELEASE_CSC( retval );
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetATCMulticastStormTrafficControlOnStatus
 * -------------------------------------------------------------------------
 * 6.
 * FUNCTION: This function will get the traffic control on status of multicast
 *           storm control function
 * INPUT   : ifindex -- which port to set
 *           traffic_control_on_status    -- which status of traffic control on
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_GetATCMulticastStormTrafficControlOnStatus(UI32_T ifindex, UI32_T *traffic_control_on_status)
{
    /* LOCAL VARIABLES
     */

    /* BODY
     */
    /* Check Management Port.
     * TRUE: The port is a management port.
     * FALSE: The port is not a managemet port.
     * It returns FALSE, when the port is a management port.
     */
    if ( TRUE == SWCTRL_IsManagementPort(ifindex) )
    {
        return FALSE;
    }

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if ( ifindex == 0                          ||
         ifindex > SYS_ADPT_TOTAL_NBR_OF_LPORT )
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Logical Port ID (1-%d)", SYS_ADPT_TOTAL_NBR_OF_LPORT);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_LOGICAL_PORT_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (!SWCTRL_IS_EXIST (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Interface");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

#if (SYS_CPNT_ATC_MSTORM_SUPPORT_LPORT != TRUE)
    if (SWCTRL_IS_TRUNK (ifindex))
    {
            EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                      SWCTRL_NO_USE_FUNC_NO,
                                      EH_TYPE_MSG_TRUNK_CNFG_ERR,
                                      SYSLOG_LEVEL_INFO,
                                      "it doesn't support Multicast Storm Control.");  /*SWCTRL_ENO_NOT_TRUNK*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#else
    if (SWCTRL_IS_TRUNK_MEMBER (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#endif

    SWCTRL_LOCK();
    *traffic_control_on_status = port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_traffic_control_on;
    SWCTRL_UNLOCK();

    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetATCMulticastStormTrafficControlReleaseStatus
 * -------------------------------------------------------------------------
 * 7.
 * FUNCTION: This function will set the traffic control release status of multicast
 *           storm control function
 * INPUT   : ifindex -- which port to set
 *           traffic_control_release_status    -- which status of traffic control release
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetATCMulticastStormTrafficControlReleaseStatus(UI32_T ifindex, UI32_T traffic_control_release_status)
{
    /* LOCAL VARIABLES
     */
#if (SYS_CPNT_ATC_MSTORM_SUPPORT_LPORT == TRUE)
    UI32_T                          unit, port;
#endif
    BOOL_T                          retval = FALSE;

    /* BODY
     */
    /* Check Management Port.
     * TRUE: The port is a management port.
     * FALSE: The port is not a managemet port.
     * It returns FALSE, when the port is a management port.
     */
    if ( TRUE == SWCTRL_IsManagementPort(ifindex) )
    {
        return FALSE;
    }

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if( ifindex == 0 || ifindex > SYS_ADPT_TOTAL_NBR_OF_LPORT)
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Logical Port ID (1-%d)", SYS_ADPT_TOTAL_NBR_OF_LPORT);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_LOGICAL_PORT_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (!SWCTRL_IS_EXIST (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Interface");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

#if (SYS_CPNT_ATC_MSTORM_SUPPORT_LPORT != TRUE)
    if (SWCTRL_IS_TRUNK (ifindex))
    {
            EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                      SWCTRL_NO_USE_FUNC_NO,
                                      EH_TYPE_MSG_TRUNK_CNFG_ERR,
                                      SYSLOG_LEVEL_INFO,
                                      "it doesn't support Multicast Storm Control.");  /*SWCTRL_ENO_NOT_TRUNK*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#else
    if (SWCTRL_IS_TRUNK_MEMBER (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#endif

    if(port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_traffic_control_release == traffic_control_release_status)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
    }

    if (traffic_control_release_status == SWCTRL_ATC_MULTICAST_STORM_TC_RELEASE_ENABLE)
    {
        if (port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_auto_traffic_control_on == VAL_atcMcastStormEnable_enabled)
        {
            if ( (port_info[ifindex-1].atc_multicast_storm_entry.state_machine_state  == SWCTRL_ATCMSTORM_CONTROL_ST) ||
                (port_info[ifindex-1].atc_multicast_storm_entry.state_machine_state  == SWCTRL_ATCMSTORM_CONTROLLOW_ST) )
            {
                SWCTRL_ATCMulticastStormProtectionFSM(ifindex, SWCTRL_ATCMSTORM_MANUAL_EV);
            }
        }
        retval = TRUE;
    }
    else if (traffic_control_release_status == SWCTRL_ATC_MULTICAST_STORM_TC_RELEASE_DISABLE)
    {
        port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_traffic_control_release = traffic_control_release_status;
        retval = TRUE;
    }

    SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME ();
    SWCTRL_RETURN_AND_RELEASE_CSC( retval );
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetATCMulticastStormTrafficControlReleaseStatus
 * -------------------------------------------------------------------------
 * 8.
 * FUNCTION: This function will get the traffic control release status of multicast
 *           storm control function
 * INPUT   : ifindex -- which port to set
 *           traffic_control_release_status    -- which status of traffic control release
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_GetATCMulticastStormTrafficControlReleaseStatus(UI32_T ifindex, UI32_T *traffic_control_release_status)
{
    /* LOCAL VARIABLES
     */

    /* BODY
     */
    /* Check Management Port.
     * TRUE: The port is a management port.
     * FALSE: The port is not a managemet port.
     * It returns FALSE, when the port is a management port.
     */
    if ( TRUE == SWCTRL_IsManagementPort(ifindex) )
    {
        return FALSE;
    }

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if ( ifindex == 0                          ||
         ifindex > SYS_ADPT_TOTAL_NBR_OF_LPORT )
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Logical Port ID (1-%d)", SYS_ADPT_TOTAL_NBR_OF_LPORT);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_LOGICAL_PORT_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (!SWCTRL_IS_EXIST (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Interface");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

#if (SYS_CPNT_ATC_MSTORM_SUPPORT_LPORT != TRUE)
    if (SWCTRL_IS_TRUNK (ifindex))
    {
            EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                      SWCTRL_NO_USE_FUNC_NO,
                                      EH_TYPE_MSG_TRUNK_CNFG_ERR,
                                      SYSLOG_LEVEL_INFO,
                                      "it doesn't support Multicast Storm Control.");  /*SWCTRL_ENO_NOT_TRUNK*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#else
    if (SWCTRL_IS_TRUNK_MEMBER (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#endif

    SWCTRL_LOCK();
    *traffic_control_release_status = port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_traffic_control_release;
    SWCTRL_UNLOCK();

    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetATCMulticastStormTrafficControlOnTimer
 * -------------------------------------------------------------------------
 * 9.
 * FUNCTION: This function will set the auto traffic control on status of multicast
 *           storm control function
 * INPUT   : traffic_control_on_timer    -- which status of traffic control on timer
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetATCMulticastStormTrafficControlOnTimer(UI32_T traffic_control_on_timer)
{
    /* LOCAL VARIABLES
     */
#if (SYS_CPNT_ATC_MSTORM_SUPPORT_LPORT == TRUE)
    UI32_T                          unit, port;
#endif
    BOOL_T                          retval = FALSE;

    /* BODY
     */
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if((traffic_control_on_timer < SYS_ADPT_ATC_MSTORM_MIN_TC_ON_TIMER) || (traffic_control_on_timer > SYS_ADPT_ATC_MSTORM_MAX_TC_ON_TIMER))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_INVALID_PARAMETER,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "traffic control on timer"); /*SWCTRL_ENO_INVALID_TRAFFIC_CONTROL_ON_TIMER*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if(atc_multicast_storm_timer.atc_multicast_storm_traffic_control_on_timer == traffic_control_on_timer)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
    }

    SWCTRL_LOCK();
    atc_multicast_storm_timer.atc_multicast_storm_traffic_control_on_timer = traffic_control_on_timer;
    SWCTRL_UNLOCK();
    retval = TRUE;

    SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME ();
    SWCTRL_RETURN_AND_RELEASE_CSC( retval );
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetATCMulticastStormTrafficControlOnTimer
 * -------------------------------------------------------------------------
 * 10.
 * FUNCTION: This function will get the traffic control on timer of multicast
 *           storm control function
 * INPUT   : None
 * OUTPUT  : traffic_control_on_timer    -- which status of traffic control on timer
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_GetATCMulticastStormTrafficControlOnTimer(UI32_T *traffic_control_on_timer)
{
    /* LOCAL VARIABLES
     */

    /* BODY
     */
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    SWCTRL_LOCK();
    *traffic_control_on_timer = atc_multicast_storm_timer.atc_multicast_storm_traffic_control_on_timer;
    SWCTRL_UNLOCK();

    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetATCMulticastStormTrafficControlReleaseTimer
 * -------------------------------------------------------------------------
 * 11.
 * FUNCTION: This function will set the traffic control release timer of multicast
 *           storm control function
 * INPUT   : traffic_control_release_timer    -- which status of traffic control release timer
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetATCMulticastStormTrafficControlReleaseTimer(UI32_T traffic_control_release_timer)
{
    /* LOCAL VARIABLES
     */
#if (SYS_CPNT_ATC_MSTORM_SUPPORT_LPORT == TRUE)
    UI32_T                          unit, port;
#endif
    BOOL_T                          retval = FALSE;

    /* BODY
     */
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if((traffic_control_release_timer < SYS_ADPT_ATC_MSTORM_MIN_TC_RELEASE_TIMER) || (traffic_control_release_timer > SYS_ADPT_ATC_MSTORM_MAX_TC_RELEASE_TIMER))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_INVALID_PARAMETER,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "traffic control release timer"); /*SWCTRL_ENO_INVALID_TRAFFIC_CONTROL_RELEASE_TIMER*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if(atc_multicast_storm_timer.atc_multicast_storm_traffic_control_release_timer == traffic_control_release_timer)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
    }

    SWCTRL_LOCK();
    atc_multicast_storm_timer.atc_multicast_storm_traffic_control_release_timer = traffic_control_release_timer;
    SWCTRL_UNLOCK();
    retval = TRUE;

    SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME ();
    SWCTRL_RETURN_AND_RELEASE_CSC( retval );
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetATCMulticastStormTrafficControlReleaseTimer
 * -------------------------------------------------------------------------
 * 12.
 * FUNCTION: This function will get the traffic control release timer of multicast
 *           storm control function
 * INPUT   : None
 * OUTPUT  : traffic_control_release_timer    -- which status of traffic control release timer
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_GetATCMulticastStormTrafficControlReleaseTimer(UI32_T *traffic_control_release_timer)
{
    /* LOCAL VARIABLES
     */

    /* BODY
     */
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    SWCTRL_LOCK();
    *traffic_control_release_timer = atc_multicast_storm_timer.atc_multicast_storm_traffic_control_release_timer;
    SWCTRL_UNLOCK();

    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetATCMulticastStormStormAlarmThreshold
 * -------------------------------------------------------------------------
 * 13.
 * FUNCTION: This function will set the storm alarm fire threshold of multicast
 *           storm control function
 * INPUT   : ifindex -- which port to set
 *           storm_alarm_threshold    -- which status of storm alarm fire threshold
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetATCMulticastStormStormAlarmThreshold(UI32_T ifindex, UI32_T storm_alarm_threshold)
{
    /* LOCAL VARIABLES
     */
#if (SYS_CPNT_ATC_MSTORM_SUPPORT_LPORT == TRUE)
    UI32_T                          unit, port;
#endif
    UI32_T                          rate;
    BOOL_T                          retval = FALSE;

    /* BODY
     */
    /* Check Management Port.
     * TRUE: The port is a management port.
     * FALSE: The port is not a managemet port.
     * It returns FALSE, when the port is a management port.
     */
    if ( TRUE == SWCTRL_IsManagementPort(ifindex) )
    {
        return FALSE;
    }

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if((ifindex == 0) || (ifindex > SYS_ADPT_TOTAL_NBR_OF_LPORT))
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Logical Port ID (1-%d)", SYS_ADPT_TOTAL_NBR_OF_LPORT);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_LOGICAL_PORT_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (!SWCTRL_IS_EXIST (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Interface");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    rate = (storm_alarm_threshold * SWCTRL_ATC_MULTICAST_STORM_ONE_THOUSAND);

    if ( rate < port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_storm_clear_threshold)
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Alarm Fire Threshold must be larger than or equal to Alarm Clear Threshold");  /*SWCTRL_ENO_ALARM_FIRE_THRESHOLD*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

#if (SYS_CPNT_ATC_MSTORM_SUPPORT_LPORT != TRUE)
    if (SWCTRL_IS_TRUNK (ifindex))
    {
            EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                      SWCTRL_NO_USE_FUNC_NO,
                                      EH_TYPE_MSG_TRUNK_CNFG_ERR,
                                      SYSLOG_LEVEL_INFO,
                                      "it doesn't support Multicast Storm Control.");  /*SWCTRL_ENO_NOT_TRUNK*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#else
    if (SWCTRL_IS_TRUNK_MEMBER (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#endif

    if((rate < SYS_ADPT_ATC_MSTORM_MIN_RATE_LIMIT) || (rate > SYS_ADPT_ATC_MSTORM_MAX_RATE_LIMIT))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_INVALID_PARAMETER,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "storm alarm threshold"); /*SWCTRL_ENO_INVALID_STORM_ALARM_THRESHOLD*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if(port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_storm_alarm_threshold == rate)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
    }

    if (SWCTRL_IsServerBladePort (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_SRV_BLADE_PORT_CNFG,
                                  SYSLOG_LEVEL_INFO,
                                  "Configuring Multicast Storm Control");     /*SWCTRL_ENO_DENY_ON_SERVER_BLADE_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }


    /* if normal port
     */
    if(!SWCTRL_IS_TRUNK (ifindex))
    {
        SWCTRL_LOCK();
        port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_storm_alarm_threshold = rate;
        SWCTRL_UNLOCK();
        retval = TRUE;
    }

    /* if trunk port
     */
#if (SYS_CPNT_ATC_MSTORM_SUPPORT_LPORT == TRUE)
    if(SWCTRL_IS_TRUNK (ifindex))
    {
        SWCTRL_TrunkPortExtInfo_T trunk_ext_p_info;
        UI32_T                    i;

        memset(&trunk_ext_p_info, 0, sizeof(SWCTRL_TrunkPortExtInfo_T));
        SWCTRL_GetTrunkPortExtInfo (ifindex, &trunk_ext_p_info);

        for(i=0; i<trunk_ext_p_info.member_number; i++)
        {
            unit = trunk_ext_p_info.member_list[i].unit;
            port = trunk_ext_p_info.member_list[i].port;

            SWCTRL_LOCK();
            port_info[(SWCTRL_UPORT_TO_IFINDEX(unit, port)) - 1].atc_multicast_storm_entry.atc_multicast_storm_storm_alarm_threshold = rate;
            SWCTRL_UNLOCK();
            retval = TRUE;
        } /* End of for () */
        if (retval)
        {
            SWCTRL_LOCK();
            port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_storm_alarm_threshold = rate;
            SWCTRL_UNLOCK();
        }
    } /* End of trunk port */
#endif /* End of (SYS_CPNT_ATC_MSTORM_SUPPORT_LPORT == TRUE) */

    SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME ();
    SWCTRL_RETURN_AND_RELEASE_CSC( retval );
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetATCMulticastStormStormAlarmThreshold
 * -------------------------------------------------------------------------
 * 14.
 * FUNCTION: This function will get the storm alarm fire threshold of multicast
 *           storm control function
 * INPUT   : ifindex -- which port to set
 * OUTPUT  : storm_alarm_threshold    -- which status of storm alarm fire threshold
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_GetATCMulticastStormStormAlarmThreshold(UI32_T ifindex, UI32_T *storm_alarm_threshold)
{
    /* LOCAL VARIABLES
     */

    /* BODY
     */
    /* Check Management Port.
     * TRUE: The port is a management port.
     * FALSE: The port is not a managemet port.
     * It returns FALSE, when the port is a management port.
     */
    if ( TRUE == SWCTRL_IsManagementPort(ifindex) )
    {
        return FALSE;
    }

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if ((ifindex == 0) ||(ifindex > SYS_ADPT_TOTAL_NBR_OF_LPORT))
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Logical Port ID (1-%d)", SYS_ADPT_TOTAL_NBR_OF_LPORT);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_LOGICAL_PORT_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (!SWCTRL_IS_EXIST (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Interface");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

#if (SYS_CPNT_ATC_MSTORM_SUPPORT_LPORT != TRUE)
    if (SWCTRL_IS_TRUNK (ifindex))
    {
            EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                      SWCTRL_NO_USE_FUNC_NO,
                                      EH_TYPE_MSG_TRUNK_CNFG_ERR,
                                      SYSLOG_LEVEL_INFO,
                                      "it doesn't support Multicast Storm Control.");  /*SWCTRL_ENO_NOT_TRUNK*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#else
    if (SWCTRL_IS_TRUNK_MEMBER (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#endif

    SWCTRL_LOCK();
    *storm_alarm_threshold = (port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_storm_alarm_threshold / SWCTRL_ATC_MULTICAST_STORM_ONE_THOUSAND);
    SWCTRL_UNLOCK();

    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetATCMulticastStormStormClearThreshold
 * -------------------------------------------------------------------------
 * 15.
 * FUNCTION: This function will set the storm alarm clear threshold of multicast
 *           storm control function
 * INPUT   : ifindex -- which port to set
 *           auto_clear_threshold    -- which status of storm alarm clear threshold
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetATCMulticastStormStormClearThreshold(UI32_T ifindex, UI32_T storm_clear_threshold)
{
    /* LOCAL VARIABLES
     */
#if (SYS_CPNT_ATC_MSTORM_SUPPORT_LPORT == TRUE)
    UI32_T                          local_ifindex;
#endif
    UI32_T                          unit, port;
    UI32_T                          rate;
    BOOL_T                          retval = FALSE;

    /* BODY
     */
    /* Check Management Port.
     * TRUE: The port is a management port.
     * FALSE: The port is not a managemet port.
     * It returns FALSE, when the port is a management port.
     */
    if ( TRUE == SWCTRL_IsManagementPort(ifindex) )
    {
        return FALSE;
    }

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if((ifindex == 0) || (ifindex > SYS_ADPT_TOTAL_NBR_OF_LPORT))
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Logical Port ID (1-%d)", SYS_ADPT_TOTAL_NBR_OF_LPORT);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_LOGICAL_PORT_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (!SWCTRL_IS_EXIST (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Interface");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    rate = (storm_clear_threshold * SWCTRL_ATC_MULTICAST_STORM_ONE_THOUSAND);

    if ( rate > port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_storm_alarm_threshold)
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Alarm Clear Threshold must be smaller than or equal to Alarm Fire Threshold");  /*SWCTRL_ENO_ALARM_CLEAR_THRESHOLD*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

#if (SYS_CPNT_ATC_MSTORM_SUPPORT_LPORT != TRUE)
    if (SWCTRL_IS_TRUNK (ifindex))
    {
            EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                      SWCTRL_NO_USE_FUNC_NO,
                                      EH_TYPE_MSG_TRUNK_CNFG_ERR,
                                      SYSLOG_LEVEL_INFO,
                                      "it doesn't support Multicast Storm Control.");  /*SWCTRL_ENO_NOT_TRUNK*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#else
    if (SWCTRL_IS_TRUNK_MEMBER (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#endif

    if((rate < SYS_ADPT_ATC_MSTORM_MIN_RATE_LIMIT) || (rate > SYS_ADPT_ATC_MSTORM_MAX_RATE_LIMIT))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_INVALID_PARAMETER,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "storm alarm threshold"); /*SWCTRL_ENO_INVALID_STORM_ALARM_THRESHOLD*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

#if 0
    if(port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_storm_clear_threshold == temp_storm_clear_threshold)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
    }
#endif

    if (SWCTRL_IsServerBladePort (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_SRV_BLADE_PORT_CNFG,
                                  SYSLOG_LEVEL_INFO,
                                  "Configuring Broadcast Storm Control");     /*SWCTRL_ENO_DENY_ON_SERVER_BLADE_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }


    /* if normal port
     */
    if(!SWCTRL_IS_TRUNK (ifindex))
    {
        unit = SWCTRL_IFINDEX_TO_UNIT(ifindex);
        port = SWCTRL_IFINDEX_TO_PORT(ifindex);

        if (port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_auto_traffic_control_on == VAL_atcMcastStormEnable_enabled)
        {
            retval = SWCTRL_SetUPortATCMulticastStormControlRateLimit(unit, port, VAL_atcMcastStormSampleType_packet_rate, rate, rate);
        }
        else if (port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_auto_traffic_control_on == VAL_atcMcastStormEnable_disabled)
        {
            port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_ifindex = ifindex;
            port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_sample_type = VAL_atcMcastStormSampleType_packet_rate;
            port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_packet_rate   = 0;
            port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_octet_rate = 0;
            port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_percent    = 0;

            port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_packet_rate = rate;
            retval = TRUE;
        }

        if (retval)
        {
            port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_storm_clear_threshold = rate;
#if (SYS_CPNT_SWCTRL_SINGLE_INGRESS_RATE_LIMIT == TRUE)
            SWCTRL_SyncUPortATCStormControlRateLimit(unit, port);
#endif
        }
    }

    /* if trunk port
     */
#if (SYS_CPNT_ATC_MSTORM_SUPPORT_LPORT == TRUE)
    if(SWCTRL_IS_TRUNK (ifindex))
    {
        SWCTRL_TrunkPortExtInfo_T trunk_ext_p_info;
        UI32_T                    i;

        memset(&trunk_ext_p_info, 0, sizeof(SWCTRL_TrunkPortExtInfo_T));
        SWCTRL_GetTrunkPortExtInfo (ifindex, &trunk_ext_p_info);

        for(i=0; i<trunk_ext_p_info.member_number; i++)
        {
            unit = trunk_ext_p_info.member_list[i].unit;
            port = trunk_ext_p_info.member_list[i].port;

            if (port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_auto_traffic_control_on == VAL_atcMcastStormEnable_enabled)
            {
                retval = SWCTRL_SetUPortATCMulticastStormControlRateLimit(unit, port, VAL_atcMcastStormSampleType_packet_rate, rate, rate);
                if (!retval)
                {
                    break;
                }
            }
            else if (port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_auto_traffic_control_on == VAL_atcMcastStormEnable_disabled)
            {
                local_ifindex = SWCTRL_UPORT_TO_IFINDEX (unit, port);
                port_info[local_ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_ifindex = local_ifindex;
                port_info[local_ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_sample_type = VAL_atcMcastStormSampleType_packet_rate;
                port_info[local_ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_packet_rate   = 0;
                port_info[local_ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_octet_rate = 0;
                port_info[local_ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_percent    = 0;

                port_info[local_ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_packet_rate = rate;
                retval = TRUE;
            }

            if (retval)
            {
                port_info[local_ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_storm_clear_threshold = rate;
#if (SYS_CPNT_SWCTRL_SINGLE_INGRESS_RATE_LIMIT == TRUE)
                SWCTRL_SyncUPortATCStormControlRateLimit(unit, port);
#endif
            }
        } /* End of for () */
        if (retval)
        {
            SWCTRL_LOCK();
            port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_ifindex = ifindex;
            port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_sample_type = VAL_atcMcastStormSampleType_packet_rate;
            port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_packet_rate   = 0;
            port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_octet_rate = 0;
            port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_percent    = 0;

            port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_packet_rate = rate;
            port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_storm_clear_threshold = rate;
            SWCTRL_UNLOCK();
        }
    } /* End of trunk port */
#endif /* End of (SYS_CPNT_ATC_MSTORM_SUPPORT_LPORT == TRUE) */

    SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME ();
    SWCTRL_RETURN_AND_RELEASE_CSC( retval );

}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetATCMulticastStormStormClearThreshold
 * -------------------------------------------------------------------------
 * 16.
 * FUNCTION: This function will get the storm alarm clear threshold of multicast
 *           storm control function
 * INPUT   : ifindex -- which port to set
 * OUTPUT  : auto_clear_threshold    -- which status of storm alarm clear threshold
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_GetATCMulticastStormStormClearThreshold(UI32_T ifindex, UI32_T *storm_clear_threshold)
{
    /* LOCAL VARIABLES
     */

    /* BODY
     */
    /* Check Management Port.
     * TRUE: The port is a management port.
     * FALSE: The port is not a managemet port.
     * It returns FALSE, when the port is a management port.
     */
    if ( TRUE == SWCTRL_IsManagementPort(ifindex) )
    {
        return FALSE;
    }

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if ((ifindex == 0) || (ifindex > SYS_ADPT_TOTAL_NBR_OF_LPORT))
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Logical Port ID (1-%d)", SYS_ADPT_TOTAL_NBR_OF_LPORT);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_LOGICAL_PORT_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (!SWCTRL_IS_EXIST (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Interface");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

#if (SYS_CPNT_ATC_MSTORM_SUPPORT_LPORT != TRUE)
    if (SWCTRL_IS_TRUNK (ifindex))
    {
            EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                      SWCTRL_NO_USE_FUNC_NO,
                                      EH_TYPE_MSG_TRUNK_CNFG_ERR,
                                      SYSLOG_LEVEL_INFO,
                                      "it doesn't support Multicast Storm Control.");  /*SWCTRL_ENO_NOT_TRUNK*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#else
    if (SWCTRL_IS_TRUNK_MEMBER (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#endif

    SWCTRL_LOCK();
    *storm_clear_threshold = (port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_storm_clear_threshold / SWCTRL_ATC_MULTICAST_STORM_ONE_THOUSAND);
    SWCTRL_UNLOCK();

    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetATCMulticastStormStormAlarmThresholdEx
 * -------------------------------------------------------------------------
 * FUNCTION: This function will set the storm alarm fire/clear threshold of multicast
 *           storm control function
 * INPUT   : ifindex -- which port to set
 *           storm_alarm_threshold    -- which status of storm alarm fire threshold
 *                                       0 indicates unchanged.
 *           storm_clear_threshold    -- which status of storm alarm clear threshold
 *                                       0 indicates unchanged.
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetATCMulticastStormStormAlarmThresholdEx(UI32_T ifindex, UI32_T storm_alarm_threshold, UI32_T storm_clear_threshold)
{
    /* LOCAL VARIABLES
     */
    UI32_T                          unit, port;
    UI32_T                          cfg_storm_alarm_threshold, cfg_storm_clear_threshold;
    UI32_T                          rate = 0;
    BOOL_T                          retval = TRUE;

    /* BODY
     */
    /* Check Management Port.
     * TRUE: The port is a management port.
     * FALSE: The port is not a managemet port.
     * It returns FALSE, when the port is a management port.
     */
    if ( TRUE == SWCTRL_IsManagementPort(ifindex) )
    {
        return FALSE;
    }

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if((ifindex == 0) || (ifindex > SYS_ADPT_TOTAL_NBR_OF_LPORT))
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Logical Port ID (1-%d)", SYS_ADPT_TOTAL_NBR_OF_LPORT);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_LOGICAL_PORT_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (!SWCTRL_IS_EXIST (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Interface");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (storm_alarm_threshold == 0)
    {
        cfg_storm_alarm_threshold = port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_storm_alarm_threshold;
    }
    else
    {
        cfg_storm_alarm_threshold = (storm_alarm_threshold * SWCTRL_ATC_MULTICAST_STORM_ONE_THOUSAND);
    }

    if (storm_clear_threshold == 0)
    {
        cfg_storm_clear_threshold = port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_storm_clear_threshold;
    }
    else
    {
        cfg_storm_clear_threshold = (storm_clear_threshold * SWCTRL_ATC_MULTICAST_STORM_ONE_THOUSAND);
        rate = cfg_storm_clear_threshold;
    }

    if (cfg_storm_alarm_threshold < cfg_storm_clear_threshold)
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Alarm Fire Threshold must be larger than or equal to Alarm Clear Threshold");  /*SWCTRL_ENO_ALARM_FIRE_THRESHOLD*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

#if (SYS_CPNT_ATC_MSTORM_SUPPORT_LPORT != TRUE)
    if (SWCTRL_IS_TRUNK (ifindex))
    {
            EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                      SWCTRL_NO_USE_FUNC_NO,
                                      EH_TYPE_MSG_TRUNK_CNFG_ERR,
                                      SYSLOG_LEVEL_INFO,
                                      "it doesn't support Multicast Storm Control.");  /*SWCTRL_ENO_NOT_TRUNK*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#else
    if (SWCTRL_IS_TRUNK_MEMBER (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#endif

    if ((cfg_storm_alarm_threshold < SYS_ADPT_ATC_MSTORM_MIN_RATE_LIMIT) || (cfg_storm_alarm_threshold > SYS_ADPT_ATC_MSTORM_MAX_RATE_LIMIT))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_INVALID_PARAMETER,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "storm alarm threshold"); /*SWCTRL_ENO_INVALID_STORM_ALARM_THRESHOLD*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if ((cfg_storm_clear_threshold < SYS_ADPT_ATC_MSTORM_MIN_RATE_LIMIT) || (cfg_storm_clear_threshold > SYS_ADPT_ATC_MSTORM_MAX_RATE_LIMIT))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_INVALID_PARAMETER,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "storm alarm threshold"); /*SWCTRL_ENO_INVALID_STORM_ALARM_THRESHOLD*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_storm_alarm_threshold == cfg_storm_alarm_threshold &&
        port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_storm_clear_threshold == cfg_storm_clear_threshold)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
    }

    if (SWCTRL_IsServerBladePort (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_SRV_BLADE_PORT_CNFG,
                                  SYSLOG_LEVEL_INFO,
                                  "Configuring Multicast Storm Control");     /*SWCTRL_ENO_DENY_ON_SERVER_BLADE_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    /* if normal port
     */
    if (!SWCTRL_IS_TRUNK (ifindex))
    {
        unit = SWCTRL_IFINDEX_TO_UNIT(ifindex);
        port = SWCTRL_IFINDEX_TO_PORT(ifindex);

        if (rate != 0)
        {
            if (port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_auto_traffic_control_on == VAL_atcMcastStormEnable_enabled)
            {
                retval = SWCTRL_SetUPortATCMulticastStormControlRateLimit(unit, port, VAL_atcMcastStormSampleType_packet_rate, rate, rate);
            }
            else if (port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_auto_traffic_control_on == VAL_atcMcastStormEnable_disabled)
            {
                port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_ifindex = ifindex;
                port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_sample_type = VAL_atcMcastStormSampleType_packet_rate;
                port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_packet_rate   = 0;
                port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_octet_rate = 0;
                port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_percent    = 0;

                port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_packet_rate = rate;
            }
        }

        if (retval)
        {
            port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_storm_alarm_threshold = cfg_storm_alarm_threshold;
            port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_storm_clear_threshold = cfg_storm_clear_threshold;

#if (SYS_CPNT_SWCTRL_SINGLE_INGRESS_RATE_LIMIT == TRUE)
            if (rate != 0)
            {
                SWCTRL_SyncUPortATCStormControlRateLimit(unit, port);
            }
#endif
        }
    }

    /* if trunk port
     */
#if (SYS_CPNT_ATC_MSTORM_SUPPORT_LPORT == TRUE)
    if (SWCTRL_IS_TRUNK (ifindex))
    {
        SWCTRL_TrunkPortExtInfo_T trunk_ext_p_info;
        UI32_T                    i;
        UI32_T                    member_ifindex;

        memset(&trunk_ext_p_info, 0, sizeof(SWCTRL_TrunkPortExtInfo_T));
        SWCTRL_GetTrunkPortExtInfo (ifindex, &trunk_ext_p_info);

        for (i = 0; i < trunk_ext_p_info.member_number && retval; i++)
        {
            unit = trunk_ext_p_info.member_list[i].unit;
            port = trunk_ext_p_info.member_list[i].port;
            member_ifindex = SWCTRL_UPORT_TO_IFINDEX (unit, port);

            if (rate != 0)
            {
                if (port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_auto_traffic_control_on == VAL_atcMcastStormEnable_enabled)
                {
                    retval = SWCTRL_SetUPortATCMulticastStormControlRateLimit(unit, port, VAL_atcMcastStormSampleType_packet_rate, rate, rate);
                }
                else if (port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_auto_traffic_control_on == VAL_atcMcastStormEnable_disabled)
                {
                    port_info[member_ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_ifindex = member_ifindex;
                    port_info[member_ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_sample_type = VAL_atcMcastStormSampleType_packet_rate;
                    port_info[member_ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_packet_rate   = 0;
                    port_info[member_ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_octet_rate = 0;
                    port_info[member_ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_percent    = 0;

                    port_info[member_ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_packet_rate = rate;
                }
            }

            if (retval)
            {
                port_info[member_ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_storm_alarm_threshold = cfg_storm_alarm_threshold;
                port_info[member_ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_storm_clear_threshold = cfg_storm_clear_threshold;

#if (SYS_CPNT_SWCTRL_SINGLE_INGRESS_RATE_LIMIT == TRUE)
                if (rate != 0)
                {
                    SWCTRL_SyncUPortATCStormControlRateLimit(unit, port);
                }
#endif
            }
        } /* End of for () */

        if (retval)
        {
            if (rate != 0)
            {
                port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_ifindex = ifindex;
                port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_sample_type = VAL_atcMcastStormSampleType_packet_rate;
                port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_packet_rate   = 0;
                port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_octet_rate = 0;
                port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_percent    = 0;

                port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_packet_rate = rate;
            }

            port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_storm_alarm_threshold = cfg_storm_alarm_threshold;
            port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_storm_clear_threshold = cfg_storm_clear_threshold;
        }
    } /* End of trunk port */
#endif /* End of (SYS_CPNT_ATC_MSTORM_SUPPORT_LPORT == TRUE) */

    SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME ();
    SWCTRL_RETURN_AND_RELEASE_CSC( retval );
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetATCMulticastStormTrapStormAlarmStatus
 * -------------------------------------------------------------------------
 * 17.
 * FUNCTION: This function will set the storm alarm fire trap status of multicast
 *           storm control function
 * INPUT   : ifindex -- which port to set
 *           trap_storm_alarm_status    -- which status of storm alarm fire trap
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetATCMulticastStormTrapStormAlarmStatus(UI32_T ifindex, UI32_T trap_storm_alarm_status)
{
    /* LOCAL VARIABLES
     */
#if (SYS_CPNT_ATC_MSTORM_SUPPORT_LPORT == TRUE)
    UI32_T                          unit, port;
#endif
    BOOL_T                          retval = FALSE;

    /* BODY
     */
    /* Check Management Port.
     * TRUE: The port is a management port.
     * FALSE: The port is not a managemet port.
     * It returns FALSE, when the port is a management port.
     */
    if ( TRUE == SWCTRL_IsManagementPort(ifindex) )
    {
        return FALSE;
    }

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if((ifindex == 0) ||(ifindex > SYS_ADPT_TOTAL_NBR_OF_LPORT))
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Logical Port ID (1-%d)", SYS_ADPT_TOTAL_NBR_OF_LPORT);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_LOGICAL_PORT_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (!SWCTRL_IS_EXIST (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Interface");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

#if (SYS_CPNT_ATC_MSTORM_SUPPORT_LPORT != TRUE)
    if (SWCTRL_IS_TRUNK (ifindex))
    {
            EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                      SWCTRL_NO_USE_FUNC_NO,
                                      EH_TYPE_MSG_TRUNK_CNFG_ERR,
                                      SYSLOG_LEVEL_INFO,
                                      "it doesn't support Multicast Storm Control.");  /*SWCTRL_ENO_NOT_TRUNK*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#else
    if (SWCTRL_IS_TRUNK_MEMBER (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#endif

    if((trap_storm_alarm_status != VAL_atcMcastStormAlarmFireTrapStatus_enabled) &&
       (trap_storm_alarm_status != VAL_atcMcastStormAlarmFireTrapStatus_disabled))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_INVALID_PARAMETER,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "trap storm alarm"); /*SWCTRL_ENO_INVALID_TRAP_STORM_ALARM*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if(port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_trap_storm_alarm == trap_storm_alarm_status)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
    }

    if (SWCTRL_IsServerBladePort (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_SRV_BLADE_PORT_CNFG,
                                  SYSLOG_LEVEL_INFO,
                                  "Configuring Multicast Storm Control");     /*SWCTRL_ENO_DENY_ON_SERVER_BLADE_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }


    /* if normal port
     */
    if(!SWCTRL_IS_TRUNK (ifindex))
    {
        SWCTRL_LOCK();
        port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_trap_storm_alarm = trap_storm_alarm_status;
        SWCTRL_UNLOCK();
        retval = TRUE;
    }

    /* if trunk port
     */
#if (SYS_CPNT_ATC_MSTORM_SUPPORT_LPORT == TRUE)
    if(SWCTRL_IS_TRUNK (ifindex))
    {
        SWCTRL_TrunkPortExtInfo_T trunk_ext_p_info;
        UI32_T                    i;

        memset(&trunk_ext_p_info, 0, sizeof(SWCTRL_TrunkPortExtInfo_T));
        SWCTRL_GetTrunkPortExtInfo (ifindex, &trunk_ext_p_info);

        for(i=0; i<trunk_ext_p_info.member_number; i++)
        {
            unit = trunk_ext_p_info.member_list[i].unit;
            port = trunk_ext_p_info.member_list[i].port;

            SWCTRL_LOCK();
            port_info[(SWCTRL_UPORT_TO_IFINDEX(unit, port)) - 1].atc_multicast_storm_entry.atc_multicast_storm_trap_storm_alarm = trap_storm_alarm_status;
            SWCTRL_UNLOCK();
            retval = TRUE;
        } /* End of for () */
        if (retval)
        {
            SWCTRL_LOCK();
            port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_trap_storm_alarm = trap_storm_alarm_status;
            SWCTRL_UNLOCK();
        }
    } /* End of trunk port */
#endif /* End of (SYS_CPNT_ATC_MSTORM_SUPPORT_LPORT == TRUE) */

    SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME ();
    SWCTRL_RETURN_AND_RELEASE_CSC( retval );
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetATCMulticastStormTrapStormAlarmStatus
 * -------------------------------------------------------------------------
 * 18.
 * FUNCTION: This function will get the storm alarm fire trap status of multicast
 *           storm control function
 * INPUT   : ifindex -- which port to set
 * OUTPUT  : trap_storm_alarm_status    -- which status of storm alarm fire trap
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_GetATCMulticastStormTrapStormAlarmStatus(UI32_T ifindex, UI32_T *trap_storm_alarm_status)
{
    /* LOCAL VARIABLES
     */

    /* BODY
     */
    /* Check Management Port.
     * TRUE: The port is a management port.
     * FALSE: The port is not a managemet port.
     * It returns FALSE, when the port is a management port.
     */
    if ( TRUE == SWCTRL_IsManagementPort(ifindex) )
    {
        return FALSE;
    }

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if ((ifindex == 0) ||(ifindex > SYS_ADPT_TOTAL_NBR_OF_LPORT))
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Logical Port ID (1-%d)", SYS_ADPT_TOTAL_NBR_OF_LPORT);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_LOGICAL_PORT_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (!SWCTRL_IS_EXIST (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Interface");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

#if (SYS_CPNT_ATC_MSTORM_SUPPORT_LPORT != TRUE)
    if (SWCTRL_IS_TRUNK (ifindex))
    {
            EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                      SWCTRL_NO_USE_FUNC_NO,
                                      EH_TYPE_MSG_TRUNK_CNFG_ERR,
                                      SYSLOG_LEVEL_INFO,
                                      "it doesn't support Multicast Storm Control.");  /*SWCTRL_ENO_NOT_TRUNK*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#else
    if (SWCTRL_IS_TRUNK_MEMBER (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#endif

    SWCTRL_LOCK();
    *trap_storm_alarm_status = port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_trap_storm_alarm;
    SWCTRL_UNLOCK();

    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetATCMulticastStormTrapStormClearStatus
 * -------------------------------------------------------------------------
 * 19.
 * FUNCTION: This function will set the storm alarm clear trap status of multicast
 *           storm control function
 * INPUT   : ifindex -- which port to set
 *           trap_storm_clear_status    -- which status of storm alarm clear trap
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetATCMulticastStormTrapStormClearStatus(UI32_T ifindex, UI32_T trap_storm_clear_status)
{
    /* LOCAL VARIABLES
     */
#if (SYS_CPNT_ATC_MSTORM_SUPPORT_LPORT == TRUE)
    UI32_T                          unit, port;
#endif
    BOOL_T                          retval = FALSE;

    /* BODY
     */
    /* Check Management Port.
     * TRUE: The port is a management port.
     * FALSE: The port is not a managemet port.
     * It returns FALSE, when the port is a management port.
     */
    if ( TRUE == SWCTRL_IsManagementPort(ifindex) )
    {
        return FALSE;
    }

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if ((ifindex == 0) ||(ifindex > SYS_ADPT_TOTAL_NBR_OF_LPORT))
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Logical Port ID (1-%d)", SYS_ADPT_TOTAL_NBR_OF_LPORT);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_LOGICAL_PORT_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (!SWCTRL_IS_EXIST (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Interface");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

#if (SYS_CPNT_ATC_MSTORM_SUPPORT_LPORT == TRUE)
    if (SWCTRL_IS_TRUNK_MEMBER (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#endif

    if((trap_storm_clear_status != VAL_atcMcastStormAlarmClearTrapStatus_enabled) &&
       (trap_storm_clear_status != VAL_atcMcastStormAlarmClearTrapStatus_disabled))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_INVALID_PARAMETER,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "trap storm alarm"); /*SWCTRL_ENO_INVALID_TRAP_STORM_ALARM*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if(port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_trap_storm_clear == trap_storm_clear_status)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
    }

    if (SWCTRL_IsServerBladePort (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_SRV_BLADE_PORT_CNFG,
                                  SYSLOG_LEVEL_INFO,
                                  "Configuring Multicast Storm Control");     /*SWCTRL_ENO_DENY_ON_SERVER_BLADE_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }


    /* if normal port
     */
    if(!SWCTRL_IS_TRUNK (ifindex))
    {
        SWCTRL_LOCK();
        port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_trap_storm_clear = trap_storm_clear_status;
        SWCTRL_UNLOCK();
        retval = TRUE;
    }

    /* if trunk port
     */
#if (SYS_CPNT_ATC_MSTORM_SUPPORT_LPORT == TRUE)
    if(SWCTRL_IS_TRUNK (ifindex))
    {
        SWCTRL_TrunkPortExtInfo_T trunk_ext_p_info;
        UI32_T                    i;

        memset(&trunk_ext_p_info, 0, sizeof(SWCTRL_TrunkPortExtInfo_T));
        SWCTRL_GetTrunkPortExtInfo (ifindex, &trunk_ext_p_info);

        for(i=0; i<trunk_ext_p_info.member_number; i++)
        {
            unit = trunk_ext_p_info.member_list[i].unit;
            port = trunk_ext_p_info.member_list[i].port;

            SWCTRL_LOCK();
            port_info[(SWCTRL_UPORT_TO_IFINDEX(unit, port)) - 1].atc_multicast_storm_entry.atc_multicast_storm_trap_storm_clear = trap_storm_clear_status;
            SWCTRL_UNLOCK();
            retval = TRUE;
        } /* End of for () */
        if (retval)
        {
            SWCTRL_LOCK();
            port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_trap_storm_clear = trap_storm_clear_status;
            SWCTRL_UNLOCK();
        }
    } /* End of trunk port */
#endif /* End of (SYS_CPNT_ATC_BSTORM_SUPPORT_LPORT == TRUE) */

    SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME ();
    SWCTRL_RETURN_AND_RELEASE_CSC( retval );
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetATCMulticastStormTrapStormClearStatus
 * -------------------------------------------------------------------------
 * 20.
 * FUNCTION: This function will get the storm alarm clear trap status of multicast
 *           storm control function
 * INPUT   : ifindex -- which port to set
 * OUTPUT  : trap_storm_clear_status    -- which status of storm alarm clear trap
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_GetATCMulticastStormTrapStormClearStatus(UI32_T ifindex, UI32_T *trap_storm_clear_status)
{
    /* LOCAL VARIABLES
     */

    /* BODY
     */
    /* Check Management Port.
     * TRUE: The port is a management port.
     * FALSE: The port is not a managemet port.
     * It returns FALSE, when the port is a management port.
     */
    if ( TRUE == SWCTRL_IsManagementPort(ifindex) )
    {
        return FALSE;
    }

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if ((ifindex == 0) ||(ifindex > SYS_ADPT_TOTAL_NBR_OF_LPORT))
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Logical Port ID (1-%d)", SYS_ADPT_TOTAL_NBR_OF_LPORT);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_LOGICAL_PORT_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (!SWCTRL_IS_EXIST (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Interface");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

#if (SYS_CPNT_ATC_MSTORM_SUPPORT_LPORT != TRUE)
    if (SWCTRL_IS_TRUNK (ifindex))
    {
            EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                      SWCTRL_NO_USE_FUNC_NO,
                                      EH_TYPE_MSG_TRUNK_CNFG_ERR,
                                      SYSLOG_LEVEL_INFO,
                                      "it doesn't support Multicast Storm Control.");  /*SWCTRL_ENO_NOT_TRUNK*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#else
    if (SWCTRL_IS_TRUNK_MEMBER (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#endif

    SWCTRL_LOCK();
    *trap_storm_clear_status = port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_trap_storm_clear;
    SWCTRL_UNLOCK();

    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetATCMulticastStormTrapTrafficControlOnStatus
 * -------------------------------------------------------------------------
 * 21.
 * FUNCTION: This function will set the traffic control apply trap status of multicast
 *           storm control function
 * INPUT   : ifindex -- which port to set
 *           trap_traffic_control_on_status    -- which status of traffic control apply trap
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetATCMulticastStormTrapTrafficControlOnStatus(UI32_T ifindex, UI32_T trap_traffic_control_on_status)
{
    /* LOCAL VARIABLES
     */
#if (SYS_CPNT_ATC_MSTORM_SUPPORT_LPORT == TRUE)
    UI32_T                          unit, port;
#endif
    BOOL_T                          retval = FALSE;

    /* BODY
     */
    /* Check Management Port.
     * TRUE: The port is a management port.
     * FALSE: The port is not a managemet port.
     * It returns FALSE, when the port is a management port.
     */
    if ( TRUE == SWCTRL_IsManagementPort(ifindex) )
    {
        return FALSE;
    }

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if ((ifindex == 0) ||(ifindex > SYS_ADPT_TOTAL_NBR_OF_LPORT))
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Logical Port ID (1-%d)", SYS_ADPT_TOTAL_NBR_OF_LPORT);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_LOGICAL_PORT_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (!SWCTRL_IS_EXIST (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Interface");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

#if (SYS_CPNT_ATC_MSTORM_SUPPORT_LPORT != TRUE)
    if (SWCTRL_IS_TRUNK (ifindex))
    {
            EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                      SWCTRL_NO_USE_FUNC_NO,
                                      EH_TYPE_MSG_TRUNK_CNFG_ERR,
                                      SYSLOG_LEVEL_INFO,
                                      "it doesn't support Multicast Storm Control.");  /*SWCTRL_ENO_NOT_TRUNK*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#else
    if (SWCTRL_IS_TRUNK_MEMBER (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#endif

    if((trap_traffic_control_on_status != VAL_atcMcastStormTcApplyTrapStatus_enabled) &&
       (trap_traffic_control_on_status != VAL_atcMcastStormTcApplyTrapStatus_disabled))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_INVALID_PARAMETER,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "trap traffic control on"); /*SWCTRL_ENO_INVALID_TRAP_TRAFFIC_CONTROL_ON*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if(port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_trap_traffic_control_on== trap_traffic_control_on_status)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
    }

    if (SWCTRL_IsServerBladePort (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_SRV_BLADE_PORT_CNFG,
                                  SYSLOG_LEVEL_INFO,
                                  "Configuring Multicast Storm Control");     /*SWCTRL_ENO_DENY_ON_SERVER_BLADE_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }


    /* if normal port
     */
    if(!SWCTRL_IS_TRUNK (ifindex))
    {
        SWCTRL_LOCK();
        port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_trap_traffic_control_on = trap_traffic_control_on_status;
        SWCTRL_UNLOCK();
        retval = TRUE;
    }

    /* if trunk port
     */
#if (SYS_CPNT_ATC_MSTORM_SUPPORT_LPORT == TRUE)
    if(SWCTRL_IS_TRUNK (ifindex))
    {
        SWCTRL_TrunkPortExtInfo_T trunk_ext_p_info;
        UI32_T                    i;

        memset(&trunk_ext_p_info, 0, sizeof(SWCTRL_TrunkPortExtInfo_T));
        SWCTRL_GetTrunkPortExtInfo (ifindex, &trunk_ext_p_info);

        for(i=0; i<trunk_ext_p_info.member_number; i++)
        {
            unit = trunk_ext_p_info.member_list[i].unit;
            port = trunk_ext_p_info.member_list[i].port;

            SWCTRL_LOCK();
            port_info[(SWCTRL_UPORT_TO_IFINDEX(unit, port)) - 1].atc_multicast_storm_entry.atc_multicast_storm_trap_traffic_control_on= trap_traffic_control_on_status;
            SWCTRL_UNLOCK();
            retval = TRUE;
        } /* End of for () */
        if (retval)
        {
            SWCTRL_LOCK();
            port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_trap_traffic_control_on = trap_traffic_control_on_status;
            SWCTRL_UNLOCK();
        }
    } /* End of trunk port */
#endif /* End of (SYS_CPNT_ATC_MSTORM_SUPPORT_LPORT == TRUE) */

    SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME ();
    SWCTRL_RETURN_AND_RELEASE_CSC( retval );
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetATCMulticastStormTrapTrafficControlOnStatus
 * -------------------------------------------------------------------------
 * 22.
 * FUNCTION: This function will get the traffic control apply trap status of multicast
 *           storm control function
 * INPUT   : ifindex -- which port to set
 * OUTPUT  : trap_traffic_control_on_status    -- which status of traffic control on trap
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_GetATCMulticastStormTrapTrafficControlOnStatus(UI32_T ifindex, UI32_T *trap_traffic_control_on_status)
{
    /* LOCAL VARIABLES
     */

    /* BODY
     */
    /* Check Management Port.
     * TRUE: The port is a management port.
     * FALSE: The port is not a managemet port.
     * It returns FALSE, when the port is a management port.
     */
    if ( TRUE == SWCTRL_IsManagementPort(ifindex) )
    {
        return FALSE;
    }

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if ((ifindex == 0) ||(ifindex > SYS_ADPT_TOTAL_NBR_OF_LPORT))
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Logical Port ID (1-%d)", SYS_ADPT_TOTAL_NBR_OF_LPORT);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_LOGICAL_PORT_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (!SWCTRL_IS_EXIST (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Interface");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

#if (SYS_CPNT_ATC_MSTORM_SUPPORT_LPORT != TRUE)
    if (SWCTRL_IS_TRUNK (ifindex))
    {
            EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                      SWCTRL_NO_USE_FUNC_NO,
                                      EH_TYPE_MSG_TRUNK_CNFG_ERR,
                                      SYSLOG_LEVEL_INFO,
                                      "it doesn't support Multicast Storm Control.");  /*SWCTRL_ENO_NOT_TRUNK*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#else
    if (SWCTRL_IS_TRUNK_MEMBER (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#endif

    SWCTRL_LOCK();
    *trap_traffic_control_on_status = port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_trap_traffic_control_on;
    SWCTRL_UNLOCK();

    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetATCMulticastStormTrapTrafficControlReleaseStatus
 * -------------------------------------------------------------------------
 * 23.
 * FUNCTION: This function will set the traffic control release trap status of multicast
 *           storm control function
 * INPUT   : ifindex -- which port to set
 *           trap_traffic_control_release_status    -- which status of traffic control release trap
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetATCMulticastStormTrapTrafficControlReleaseStatus(UI32_T ifindex, UI32_T trap_traffic_control_release_status)
{
    /* LOCAL VARIABLES
     */
#if (SYS_CPNT_ATC_MSTORM_SUPPORT_LPORT == TRUE)
    UI32_T                          unit, port;
#endif
    BOOL_T                          retval = FALSE;

    /* BODY
     */
    /* Check Management Port.
     * TRUE: The port is a management port.
     * FALSE: The port is not a managemet port.
     * It returns FALSE, when the port is a management port.
     */
    if ( TRUE == SWCTRL_IsManagementPort(ifindex) )
    {
        return FALSE;
    }

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if ((ifindex == 0) ||(ifindex > SYS_ADPT_TOTAL_NBR_OF_LPORT))
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Logical Port ID (1-%d)", SYS_ADPT_TOTAL_NBR_OF_LPORT);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_LOGICAL_PORT_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (!SWCTRL_IS_EXIST (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Interface");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

#if (SYS_CPNT_ATC_MSTORM_SUPPORT_LPORT != TRUE)
    if (SWCTRL_IS_TRUNK (ifindex))
    {
            EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                      SWCTRL_NO_USE_FUNC_NO,
                                      EH_TYPE_MSG_TRUNK_CNFG_ERR,
                                      SYSLOG_LEVEL_INFO,
                                      "it doesn't support Multicast Storm Control.");  /*SWCTRL_ENO_NOT_TRUNK*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#else
    if (SWCTRL_IS_TRUNK_MEMBER (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#endif

    if((trap_traffic_control_release_status != VAL_atcMcastStormTcReleaseTrapStatus_enabled) &&
       (trap_traffic_control_release_status != VAL_atcMcastStormTcReleaseTrapStatus_disabled))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_INVALID_PARAMETER,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "trap traffic control release"); /*SWCTRL_ENO_INVALID_TRAP_TRAFFIC_CONTROL_RELEASE*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if(port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_trap_traffic_control_release == trap_traffic_control_release_status)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
    }

    if (SWCTRL_IsServerBladePort (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_SRV_BLADE_PORT_CNFG,
                                  SYSLOG_LEVEL_INFO,
                                  "Configuring Broadcast Storm Control");     /*SWCTRL_ENO_DENY_ON_SERVER_BLADE_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }


    /* if normal port
     */
    if(!SWCTRL_IS_TRUNK (ifindex))
    {
        SWCTRL_LOCK();
        port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_trap_traffic_control_release = trap_traffic_control_release_status;
        SWCTRL_UNLOCK();
        retval = TRUE;
    }

    /* if trunk port
     */
#if (SYS_CPNT_ATC_MSTORM_SUPPORT_LPORT == TRUE)
    if(SWCTRL_IS_TRUNK (ifindex))
    {
        SWCTRL_TrunkPortExtInfo_T trunk_ext_p_info;
        UI32_T                    i;

        memset(&trunk_ext_p_info, 0, sizeof(SWCTRL_TrunkPortExtInfo_T));
        SWCTRL_GetTrunkPortExtInfo (ifindex, &trunk_ext_p_info);

        for(i=0; i<trunk_ext_p_info.member_number; i++)
        {
            unit = trunk_ext_p_info.member_list[i].unit;
            port = trunk_ext_p_info.member_list[i].port;

            SWCTRL_LOCK();
            port_info[(SWCTRL_UPORT_TO_IFINDEX(unit, port)) - 1].atc_multicast_storm_entry.atc_multicast_storm_trap_traffic_control_release = trap_traffic_control_release_status;
            SWCTRL_UNLOCK();
            retval = TRUE;
        } /* End of for () */
        if (retval)
        {
            SWCTRL_LOCK();
            port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_trap_traffic_control_release = trap_traffic_control_release_status;
            SWCTRL_UNLOCK();
        }
    } /* End of trunk port */
#endif /* End of (SYS_CPNT_ATC_MSTORM_SUPPORT_LPORT == TRUE) */

    SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME ();
    SWCTRL_RETURN_AND_RELEASE_CSC( retval );
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetATCMulticastStormTrapTrafficControlReleaseStatus
 * -------------------------------------------------------------------------
 * 24.
 * FUNCTION: This function will get the traffic control release trap status of multicast
 *           storm control function
 * INPUT   : ifindex -- which port to set
 * OUTPUT  : trap_traffic_control_release_status    -- which status of traffic control release trap
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_GetATCMulticastStormTrapTrafficControlReleaseStatus(UI32_T ifindex, UI32_T *trap_traffic_control_release_status)
{
    /* LOCAL VARIABLES
     */

    /* BODY
     */
    /* Check Management Port.
     * TRUE: The port is a management port.
     * FALSE: The port is not a managemet port.
     * It returns FALSE, when the port is a management port.
     */
    if ( TRUE == SWCTRL_IsManagementPort(ifindex) )
    {
        return FALSE;
    }

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if ((ifindex == 0) ||(ifindex > SYS_ADPT_TOTAL_NBR_OF_LPORT))
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Logical Port ID (1-%d)", SYS_ADPT_TOTAL_NBR_OF_LPORT);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_LOGICAL_PORT_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (!SWCTRL_IS_EXIST (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Interface");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

#if (SYS_CPNT_ATC_MSTORM_SUPPORT_LPORT != TRUE)
    if (SWCTRL_IS_TRUNK (ifindex))
    {
            EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                      SWCTRL_NO_USE_FUNC_NO,
                                      EH_TYPE_MSG_TRUNK_CNFG_ERR,
                                      SYSLOG_LEVEL_INFO,
                                      "it doesn't support Multicast Storm Control.");  /*SWCTRL_ENO_NOT_TRUNK*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#else
    if (SWCTRL_IS_TRUNK_MEMBER (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#endif

    SWCTRL_LOCK();
    *trap_traffic_control_release_status = port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_trap_traffic_control_release;
    SWCTRL_UNLOCK();

    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetATCMulticastStormAction
 * -------------------------------------------------------------------------
 * 25.
 * FUNCTION: This function will set the action method of multicast
 *           storm control function
 * INPUT   : ifindex -- which port to set
 *           action    -- which status of action
 *                            --- 1. rate-control , 2. shutdown
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetATCMulticastStormAction(UI32_T ifindex, UI32_T action)
{
    /* LOCAL VARIABLES
     */
#if (SYS_CPNT_ATC_MSTORM_SUPPORT_LPORT == TRUE)
    UI32_T                          unit, port;
#endif
    BOOL_T                          retval = FALSE;

    /* BODY
     */
    /* Check Management Port.
     * TRUE: The port is a management port.
     * FALSE: The port is not a managemet port.
     * It returns FALSE, when the port is a management port.
     */
    if ( TRUE == SWCTRL_IsManagementPort(ifindex) )
    {
        return FALSE;
    }

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if ((ifindex == 0) ||(ifindex > SYS_ADPT_TOTAL_NBR_OF_LPORT))
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Logical Port ID (1-%d)", SYS_ADPT_TOTAL_NBR_OF_LPORT);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_LOGICAL_PORT_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (!SWCTRL_IS_EXIST (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Interface");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

#if (SYS_CPNT_ATC_MSTORM_SUPPORT_LPORT != TRUE)
    if (SWCTRL_IS_TRUNK (ifindex))
    {
            EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                      SWCTRL_NO_USE_FUNC_NO,
                                      EH_TYPE_MSG_TRUNK_CNFG_ERR,
                                      SYSLOG_LEVEL_INFO,
                                      "it doesn't support Multicast Storm Control.");  /*SWCTRL_ENO_NOT_TRUNK*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#else
    if (SWCTRL_IS_TRUNK_MEMBER (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#endif

    if((action != VAL_atcMcastStormTcAction_rate_control) &&
       (action != VAL_atcMcastStormTcAction_shutdown))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_INVALID_PARAMETER,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "trap traffic control release"); /*SWCTRL_ENO_INVALID_TRAP_TRAFFIC_CONTROL_RELEASE*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if(port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_action == action)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
    }

    if (SWCTRL_IsServerBladePort (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_SRV_BLADE_PORT_CNFG,
                                  SYSLOG_LEVEL_INFO,
                                  "Configuring Multicast Storm Control");     /*SWCTRL_ENO_DENY_ON_SERVER_BLADE_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }


    /* if normal port
     */
    if(!SWCTRL_IS_TRUNK (ifindex))
    {
        SWCTRL_LOCK();
        port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_action = action;
        SWCTRL_UNLOCK();
        SWCTRL_SetATCMulticastStormTrafficControlReleaseStatus(ifindex, SWCTRL_ATC_MULTICAST_STORM_TC_RELEASE_ENABLE);
        retval = TRUE;
    }

    /* if trunk port
     */
#if (SYS_CPNT_ATC_MSTORM_SUPPORT_LPORT == TRUE)
    if(SWCTRL_IS_TRUNK (ifindex))
    {
        SWCTRL_TrunkPortExtInfo_T trunk_ext_p_info;
        UI32_T                    i;

        memset(&trunk_ext_p_info, 0, sizeof(SWCTRL_TrunkPortExtInfo_T));
        SWCTRL_GetTrunkPortExtInfo (ifindex, &trunk_ext_p_info);

        for(i=0; i<trunk_ext_p_info.member_number; i++)
        {
            unit = trunk_ext_p_info.member_list[i].unit;
            port = trunk_ext_p_info.member_list[i].port;

            SWCTRL_LOCK();
            port_info[(SWCTRL_UPORT_TO_IFINDEX(unit, port)) - 1].atc_multicast_storm_entry.atc_multicast_storm_action = action;
            SWCTRL_UNLOCK();
            SWCTRL_SetATCMulticastStormTrafficControlReleaseStatus((SWCTRL_UPORT_TO_IFINDEX(unit, port)), SWCTRL_ATC_MULTICAST_STORM_TC_RELEASE_ENABLE);
            retval=TRUE;
        }/* End of for () */
        if (retval)
        {
            SWCTRL_LOCK();
            port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_action = action;
            SWCTRL_UNLOCK();
        }
    } /* End of trunk port */
#endif /* End of (SYS_CPNT_ATC_MSTORM_SUPPORT_LPORT == TRUE) */

    SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME ();
    SWCTRL_RETURN_AND_RELEASE_CSC( retval );
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetATCMulticastStormAction
 * -------------------------------------------------------------------------
 * 26.
 * FUNCTION: This function will get the action method of multicast
 *           storm control function
 * INPUT   : ifindex -- which port to set
 * OUTPUT  : action    -- which status of action
 *                            --- 1. rate-control , 2. shutdown
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_GetATCMulticastStormAction(UI32_T ifindex, UI32_T *action)
{
    /* LOCAL VARIABLES
     */

    /* BODY
     */
    /* Check Management Port.
     * TRUE: The port is a management port.
     * FALSE: The port is not a managemet port.
     * It returns FALSE, when the port is a management port.
     */
    if ( TRUE == SWCTRL_IsManagementPort(ifindex) )
    {
        return FALSE;
    }

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if ((ifindex == 0) ||(ifindex > SYS_ADPT_TOTAL_NBR_OF_LPORT))
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Logical Port ID (1-%d)", SYS_ADPT_TOTAL_NBR_OF_LPORT);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_LOGICAL_PORT_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (!SWCTRL_IS_EXIST (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Interface");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

#if (SYS_CPNT_ATC_MSTORM_SUPPORT_LPORT != TRUE)
    if (SWCTRL_IS_TRUNK (ifindex))
    {
            EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                      SWCTRL_NO_USE_FUNC_NO,
                                      EH_TYPE_MSG_TRUNK_CNFG_ERR,
                                      SYSLOG_LEVEL_INFO,
                                      "it doesn't support Multicast Storm Control.");  /*SWCTRL_ENO_NOT_TRUNK*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#else
    if (SWCTRL_IS_TRUNK_MEMBER (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#endif

    SWCTRL_LOCK();
    *action = port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_action;
    SWCTRL_UNLOCK();

    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetATCMulticastStormEntry
 * -------------------------------------------------------------------------
 * 27.
 * FUNCTION: This function will get the entry of multicast
 *           storm control function
 * INPUT   : atc_multicast_storm_entry    -- which status of entry
 * OUTPUT  : atc_multicast_storm_entry    -- which status of entry
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_GetATCMulticastStormEntry(UI32_T ifindex,SWCTRL_ATCMulticastStormEntry_T *atc_multicast_storm_entry)
{
    /* LOCAL VARIABLES
     */

    /* BODY
     */
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (atc_multicast_storm_entry == 0)
    {
        EH_MGR_Handle_Exception (SYS_MODULE_SWCTRL,
                                 SWCTRL_NO_USE_FUNC_NO,
                                 EH_TYPE_MSG_NULL_POINTER,
                                 EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_CRIT); /*SWCTRL_ENO_NULL_POINTER*/
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

#if (SYS_CPNT_ATC_MSTORM_SUPPORT_LPORT == TRUE)
    if (!SWCTRL_IS_LPORT(ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Interface.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#else
    if (!SWCTRL_IS_USER_PORT(ifindex) || !SWCTRL_IS_EXIST(ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Interface.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#endif

     *atc_multicast_storm_entry = port_info[ifindex - 1].atc_multicast_storm_entry;
    atc_multicast_storm_entry->atc_multicast_storm_storm_alarm_threshold /= SWCTRL_ATC_MULTICAST_STORM_ONE_THOUSAND;
    atc_multicast_storm_entry->atc_multicast_storm_storm_clear_threshold /= SWCTRL_ATC_MULTICAST_STORM_ONE_THOUSAND;

    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetNextATCMulticastStormEntry
 * -------------------------------------------------------------------------
 * 28.
 * FUNCTION: This function will get the next entry of multicast
 *           storm control function
 * INPUT   : atc_multicast_storm_entry    -- which status of entry
 * OUTPUT  : atc_multicast_storm_entry    -- which status of the next entry
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_GetNextATCMulticastStormEntry(UI32_T ifindex,SWCTRL_ATCMulticastStormEntry_T *atc_multicast_storm_entry)
{
    /* LOCAL VARIABLES
     */

    /* BODY
     */
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (atc_multicast_storm_entry == 0)
    {
        EH_MGR_Handle_Exception (SYS_MODULE_SWCTRL,
                                 SWCTRL_NO_USE_FUNC_NO,
                                 EH_TYPE_MSG_NULL_POINTER,
                                 EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_CRIT); /*SWCTRL_ENO_NULL_POINTER*/
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    (*atc_multicast_storm_entry).atc_multicast_storm_ifindex = ifindex;

    if((*atc_multicast_storm_entry).atc_multicast_storm_ifindex > SYS_ADPT_TOTAL_NBR_OF_LPORT)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    (atc_multicast_storm_entry->atc_multicast_storm_ifindex)++;
    for(;
        atc_multicast_storm_entry->atc_multicast_storm_ifindex <= SYS_ADPT_TOTAL_NBR_OF_LPORT;
        (atc_multicast_storm_entry->atc_multicast_storm_ifindex)++)
    {
         if (!SWCTRL_IS_EXIST (atc_multicast_storm_entry->atc_multicast_storm_ifindex))
            continue;

#if (SYS_CPNT_ATC_MSTORM_SUPPORT_LPORT != TRUE)
        if (SWCTRL_IS_TRUNK (atc_multicast_storm_entry->atc_multicast_storm_ifindex))
           continue;
#else
        if (SWCTRL_IS_TRUNK_MEMBER (atc_multicast_storm_entry->atc_multicast_storm_ifindex))
           continue;
#endif

        *atc_multicast_storm_entry = port_info[atc_multicast_storm_entry->atc_multicast_storm_ifindex-1].atc_multicast_storm_entry;

            atc_multicast_storm_entry->atc_multicast_storm_storm_alarm_threshold /= SWCTRL_ATC_MULTICAST_STORM_ONE_THOUSAND;
            atc_multicast_storm_entry->atc_multicast_storm_storm_clear_threshold /= SWCTRL_ATC_MULTICAST_STORM_ONE_THOUSAND;

        SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
    } /* End of for () */

    SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetATCMulticastStormTimer
 * -------------------------------------------------------------------------
 * 29.
 * FUNCTION: This function will get the tc apply timer and tc release timer on status of multicast
 *           storm control function
 * INPUT   : a_multicast_storm_timer    -- which status of tc apply timer and tc release apply
 * OUTPUT  : a_multicast_storm_timer    -- which status of tc apply timer and tc release apply
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_GetATCMulticastStormTimer(SWCTRL_ATCMulticastStormTimer_T *a_multicast_storm_timer)
{
    /* LOCAL VARIABLES
     */

    /* BODY
     */
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (a_multicast_storm_timer == 0)
    {
        EH_MGR_Handle_Exception (SYS_MODULE_SWCTRL,
                                 SWCTRL_NO_USE_FUNC_NO,
                                 EH_TYPE_MSG_NULL_POINTER,
                                 EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_CRIT); /*SWCTRL_ENO_NULL_POINTER*/
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    memset(a_multicast_storm_timer, 0, sizeof(SWCTRL_ATCMulticastStormTimer_T));
    (*a_multicast_storm_timer).atc_multicast_storm_traffic_control_on_timer = atc_multicast_storm_timer.atc_multicast_storm_traffic_control_on_timer;
    (*a_multicast_storm_timer).atc_multicast_storm_traffic_control_release_timer = atc_multicast_storm_timer.atc_multicast_storm_traffic_control_release_timer;
    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );

}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetATCMulticastStormSampleType
 * -------------------------------------------------------------------------
 * 30.
 * FUNCTION: This function will set the sample type of multicast
 *           storm control function
 * INPUT   : ifindex -- which port to set
 *           atc_multicast_storm_sample_type    -- which status of sample type
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetATCMulticastStormSampleType(UI32_T ifindex, UI32_T atc_multicast_storm_sample_type)
{
    /* LOCAL VARIABLES
     */
    UI32_T nRate = 0;

    /* BODY
     */
    /* Check Management Port.
     * TRUE: The port is a management port.
     * FALSE: The port is not a managemet port.
     * It returns FALSE, when the port is a management port.
     */
    if ( TRUE == SWCTRL_IsManagementPort(ifindex) )
    {
        return FALSE;
    }

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

#if (SYS_CPNT_SWCTRL_GLOBAL_STORM_SAMPLE_TYPE == TRUE)
    if(atc_multicast_storm_sample_type != swctrl_global_storm_sample_type)
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_INVALID_PARAMETER,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "sample type"); /*SWCTRL_ENO_INVALID_SAMPLE_TYPE*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#endif

    if((atc_multicast_storm_sample_type != VAL_atcMcastStormSampleType_packet_rate) &&
       (atc_multicast_storm_sample_type != VAL_atcMcastStormSampleType_octet_rate) &&
       (atc_multicast_storm_sample_type != VAL_atcMcastStormSampleType_percent))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_INVALID_PARAMETER,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "sample type"); /*SWCTRL_ENO_INVALID_SAMPLE_TYPE*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if ((ifindex == 0) ||(ifindex > SYS_ADPT_TOTAL_NBR_OF_LPORT))
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Logical Port ID (1-%d)", SYS_ADPT_TOTAL_NBR_OF_LPORT);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_LOGICAL_PORT_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (!SWCTRL_IS_EXIST (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Interface");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

#if (SYS_CPNT_ATC_MSTORM_SUPPORT_LPORT != TRUE)
    if (SWCTRL_IS_TRUNK (ifindex))
    {
            EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                      SWCTRL_NO_USE_FUNC_NO,
                                      EH_TYPE_MSG_TRUNK_CNFG_ERR,
                                      SYSLOG_LEVEL_INFO,
                                      "it doesn't support Multicast Storm Control.");  /*SWCTRL_ENO_NOT_TRUNK*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#else
    if (SWCTRL_IS_TRUNK_MEMBER (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#endif

    if(port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_sample_type == atc_multicast_storm_sample_type)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
    }

    if(port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_sample_type == VAL_atcMcastStormSampleType_packet_rate)
    {
        switch (atc_multicast_storm_sample_type)
        {
        case VAL_atcMcastStormSampleType_packet_rate:
            SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );

        case VAL_atcMcastStormSampleType_octet_rate:
            nRate = port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_packet_rate*500;
            break;

        case VAL_atcMcastStormSampleType_percent:
            if(SWCTRL_IS_100TX (ifindex) || SWCTRL_IS_100FIBER (ifindex))
            {
                nRate = port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_packet_rate* 8 * 500 * 100 / 100000000;
            }
            else if(SWCTRL_IS_1000T (ifindex) || SWCTRL_IS_1000FIBER (ifindex))
            {
                nRate = port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_packet_rate * 8 * 500 * 100 / 1000000000;
            }
            else /* 10G */
            {
                nRate = port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_packet_rate / 25000; /* 25000 = 1/(8 * 500 * 100 / 10000000000) */
            }
            break;
        }
    }

    if(port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_sample_type == VAL_atcMcastStormSampleType_octet_rate)
    {
        switch (atc_multicast_storm_sample_type)
        {
        case VAL_atcMcastStormSampleType_packet_rate:
            nRate = port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_octet_rate/500;
            break;

        case VAL_atcMcastStormSampleType_octet_rate:
            SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );

        case VAL_atcMcastStormSampleType_percent:
            if(SWCTRL_IS_100TX (ifindex) || SWCTRL_IS_100FIBER (ifindex))
                nRate = port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_octet_rate * 8 * 100 / 100000000;
            else if(SWCTRL_IS_1000T (ifindex) || SWCTRL_IS_1000FIBER (ifindex))
                nRate = port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_octet_rate * 8 * 100 / 1000000000;
            else /* 10G */
                nRate = port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_octet_rate / 25000; /* 25000 = 1/(8 * 500 * 100 / 10000000000) */
            break;
        }
    }

    if(port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_sample_type == VAL_atcMcastStormSampleType_percent)
    {
        switch (atc_multicast_storm_sample_type)
        {
        case VAL_atcMcastStormSampleType_packet_rate:
            if(SWCTRL_IS_100TX (ifindex) || SWCTRL_IS_100FIBER (ifindex))
            {
                nRate = 100000000 / 8 / 500 * port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_percent / 100;
            }
            else if(SWCTRL_IS_1000T (ifindex) || SWCTRL_IS_1000FIBER (ifindex))
            {
                nRate = 1000000000 / 8 / 500 * port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_percent / 100;
            }
            else /* 10G */
            {
                nRate = 2500000 * port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_percent / 100;  /* 2500000 = (10000000000 / 8 / 500) */
            }
            break;

        case VAL_atcMcastStormSampleType_octet_rate:
            if(SWCTRL_IS_100TX (ifindex) || SWCTRL_IS_100FIBER (ifindex))
            {
                nRate = 100000000 / 8 * port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_percent / 100;
            }
            else if(SWCTRL_IS_1000T (ifindex) || SWCTRL_IS_1000FIBER (ifindex))
            {
                nRate = 1000000000 / 8 * port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_percent / 100;
            }
            else /* 10G */
            {
                nRate = 1250000000 * port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_percent / 100; /* 1250000000 = (10000000000 / 8) */
            }
            break;

        case VAL_atcMcastStormSampleType_percent:
            SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
        }
    }

    if (nRate == 0)
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_INVALID_PARAMETER,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "multicast storm sample type");   /*SWCTRL_ENO_INVALID_ADMIN*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    SWCTRL_RETURN_AND_RELEASE_CSC( SWCTRL_SetATCMulticastStormRateLimit(ifindex, atc_multicast_storm_sample_type, nRate) );
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetATCMulticastStormPacketRate
 * -------------------------------------------------------------------------
 * 31.
 * FUNCTION: This function will set the packet rate of multicast
 *           storm control function
 * INPUT   : ifindex -- which port to set
 *           atc_multicast_storm_packet_rate    -- which status of packet rate
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetATCMulticastStormPacketRate(UI32_T ifindex, UI32_T atc_multicast_storm_packet_rate)
{
    /* Check Management Port.
     * TRUE: The port is a management port.
     * FALSE: The port is not a managemet port.
     * It returns FALSE, when the port is a management port.
     */
    if ( TRUE == SWCTRL_IsManagementPort(ifindex) )
    {
        return FALSE;
    }

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    SWCTRL_RETURN_AND_RELEASE_CSC( SWCTRL_SetATCMulticastStormRateLimit(ifindex, VAL_atcMcastStormSampleType_packet_rate, atc_multicast_storm_packet_rate) );
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetATCMulticastStormOctetRate
 * -------------------------------------------------------------------------
 * 32.
 * FUNCTION: This function will set the octet rate of multicast
 *           storm control function
 * INPUT   : ifindex -- which port to set
 *           atc_multicast_storm_octet_rate    -- which status of octet rate
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetATCMulticastStormOctetRate(UI32_T ifindex, UI32_T atc_multicast_storm_octet_rate)
{
    /* Check Management Port.
     * TRUE: The port is a management port.
     * FALSE: The port is not a managemet port.
     * It returns FALSE, when the port is a management port.
     */
    if ( TRUE == SWCTRL_IsManagementPort(ifindex) )
    {
        return FALSE;
    }

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    SWCTRL_RETURN_AND_RELEASE_CSC( SWCTRL_SetATCMulticastStormRateLimit(ifindex, VAL_atcMcastStormSampleType_octet_rate, atc_multicast_storm_octet_rate) );
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetATCMulticastStormPercent
 * -------------------------------------------------------------------------
 * 33.
 * FUNCTION: This function will set the percent of multicast
 *           storm control function
 * INPUT   : ifindex -- which port to set
 *           atc_multicast_storm_percent    -- which status of percent
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetATCMulticastStormPercent(UI32_T ifindex, UI32_T atc_multicast_storm_percent)
{
    /* Check Management Port.
     * TRUE: The port is a management port.
     * FALSE: The port is not a managemet port.
     * It returns FALSE, when the port is a management port.
     */
    if ( TRUE == SWCTRL_IsManagementPort(ifindex) )
    {
        return FALSE;
    }

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    SWCTRL_RETURN_AND_RELEASE_CSC( SWCTRL_SetATCMulticastStormRateLimit(ifindex, VAL_atcMcastStormSampleType_percent, atc_multicast_storm_percent) );

}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetATCMulticastStormRateLimit
 * -------------------------------------------------------------------------
 * 34.
 * FUNCTION: This function will set the rate limit of multicast
 *           storm control function
 * INPUT   : ifindex -- which port to set
 *           mode    -- which status of mode
 *           nRate   -- which status of rate
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetATCMulticastStormRateLimit(UI32_T ifindex, UI32_T mode, UI32_T nRate)
{
    /* LOCAL VARIABLES
     */
    UI32_T                          unit, port, rate;
    BOOL_T                          retval = FALSE;

    /* BODY
     */
    /* Check Management Port.
     * TRUE: The port is a management port.
     * FALSE: The port is not a managemet port.
     * It returns FALSE, when the port is a management port.
     */
    if ( TRUE == SWCTRL_IsManagementPort(ifindex) )
    {
        return FALSE;
    }

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

#if (SYS_CPNT_SWCTRL_GLOBAL_STORM_SAMPLE_TYPE == TRUE)
    mode = swctrl_global_storm_sample_type;
#endif

    /* check mode
     */
    if ( (mode != VAL_atcMcastStormSampleType_packet_rate) &&
         (mode != VAL_atcMcastStormSampleType_octet_rate) &&
         (mode != VAL_atcMcastStormSampleType_percent) )
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_INVALID_PARAMETER,
                                  SYSLOG_LEVEL_INFO,
                                  "Sample Type for Multicast Storm Control"); /*SWCTRL_ENO_INVALID_BSTM_CTRL_TYPE*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    /* check amount
     */
#if defined(ALLAYER_SWITCH)
    if ((nRate != 16) && (nRate != 64) && (nRate != 128) && (nRate != 256))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_INVALID,
                                  SYSLOG_LEVEL_INFO,
                                  "Multicast Storm Control rate"); /*SWCTRL_ENO_INVALID_MSTM_CTRL_RATE*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#else
    if ((nRate < SYS_ADPT_ATC_MSTORM_MIN_RATE_LIMIT) ||
        (nRate > SYS_ADPT_ATC_MSTORM_MAX_RATE_LIMIT))
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[64] = {0};

        sprintf(buff, "Multicast Storm Control rate (%d-%d)",
                      SYS_ADPT_ATC_MSTORM_MIN_RATE_LIMIT,
                      SYS_ADPT_ATC_MSTORM_MAX_RATE_LIMIT);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_LOGICAL_PORT_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#endif

    if ((ifindex == 0) ||(ifindex > SYS_ADPT_TOTAL_NBR_OF_LPORT))
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Logical Port ID (1-%d)", SYS_ADPT_TOTAL_NBR_OF_LPORT);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_LOGICAL_PORT_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (!SWCTRL_IS_EXIST (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Interface");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (SWCTRL_IsServerBladePort (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_SRV_BLADE_PORT_CNFG,
                                  SYSLOG_LEVEL_INFO,
                                  "Configuring Multicast Rate Limit");     /*SWCTRL_ENO_DENY_ON_SERVER_BLADE_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if(mode == VAL_atcMcastStormSampleType_packet_rate)
    {
        rate = nRate;
    }
    else if(mode == VAL_atcMcastStormSampleType_octet_rate)
    {
        /* Because the limit is base on packet/sec,
         * we assume there are 500 byte/packet,
         * and get the rate from byte/sec.
         */
        rate = nRate / 500;
    }
    else if(mode == VAL_atcMcastStormSampleType_percent)
    {
        if(nRate > 100)
        {
#if (SYS_CPNT_EH == TRUE)
            UI8_T buff[64] = {0};

            sprintf(buff, "Multicast Storm Control rate (0-%d)", 100);

            EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                      SWCTRL_NO_USE_FUNC_NO,
                                      EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                      SYSLOG_LEVEL_INFO,
                                      buff);/*SWCTRL_ENO_INVALID_MSTM_CTRL_RATE*/
#endif

            SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
        }

        if(SWCTRL_IS_100TX (ifindex) || SWCTRL_IS_100FIBER (ifindex))
        {
            rate = 100000000 / 8 / 500 * nRate / 100;
        }
        else if(SWCTRL_IS_1000T (ifindex) ||SWCTRL_IS_1000FIBER (ifindex))
        {
            rate = 1000000000 / 8 / 500 * nRate / 100;
        }
        else /* 10G */
        {
            rate = 2500000 * nRate / 100;
        }
    }
    else
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_INVALID_PARAMETER,
                                  SYSLOG_LEVEL_INFO,
                                  "Sample Type for Multicast Storm Control"); /*SWCTRL_ENO_INVALID_MSTM_CTRL_TYPE*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

#if (SYS_CPNT_ATC_MSTORM_SUPPORT_LPORT != TRUE)
    if (SWCTRL_IS_TRUNK (ifindex))
    {
            EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                      SWCTRL_NO_USE_FUNC_NO,
                                      EH_TYPE_MSG_TRUNK_CNFG_ERR,
                                      SYSLOG_LEVEL_INFO,
                                      "it doesn't support Multicast Storm Control.");  /*SWCTRL_ENO_NOT_TRUNK*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#else
    if (SWCTRL_IS_TRUNK_MEMBER (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#endif

    /* if normal port & trunk port can setting
     */
    if(!SWCTRL_IS_TRUNK (ifindex))
    {
        unit = SWCTRL_IFINDEX_TO_UNIT(ifindex);
        port = SWCTRL_IFINDEX_TO_PORT(ifindex);

        retval = SWCTRL_SetUPortATCMulticastStormControlRateLimit(unit, port, mode, rate, nRate);
    } /* End of normal port */

    /* if trunk port
     */
#if (SYS_CPNT_MSTORM_SUPPORT_LPORT == TRUE)
    if(SWCTRL_IS_TRUNK (ifindex))
    {
        SWCTRL_TrunkPortExtInfo_T trunk_ext_p_info;
        UI32_T                    i;

        memset(&trunk_ext_p_info, 0, sizeof(SWCTRL_TrunkPortExtInfo_T));
        SWCTRL_GetTrunkPortExtInfo (ifindex, &trunk_ext_p_info);

        for(i=0; i<trunk_ext_p_info.member_number; i++)
        {
            unit = trunk_ext_p_info.member_list[i].unit;
            port = trunk_ext_p_info.member_list[i].port;

            if (!(retval = SWCTRL_SetUPortATCMulticastStormControlRateLimit(unit, port, mode, rate, nRate)))
                break;
        } /* End of for () */
        if (retval)
        {
            SWCTRL_LOCK();
            port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_ifindex = ifindex;
            port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_sample_type = mode;
            port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_packet_rate   = 0;
            port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_octet_rate = 0;
            port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_percent    = 0;
            switch (mode)
            {
                case VAL_atcMcastStormSampleType_packet_rate:
                port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_packet_rate = nRate;
                break;
                case VAL_atcMcastStormSampleType_octet_rate:
                port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_octet_rate = nRate;
                break;
                case VAL_atcMcastStormSampleType_percent:
                port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_percent = nRate;
                break;
            }
            SWCTRL_UNLOCK();
        }
    } /* End of trunk port */
#endif /* End of (SYS_CPNT_MSTORM_SUPPORT_LPORT == TRUE) */

    SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME ();
    SWCTRL_RETURN_AND_RELEASE_CSC( retval );
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetATCMulticastStormPortOperationStatus
 * -------------------------------------------------------------------------
 * 35.
 * FUNCTION: This function will set port operation status of ATC Multicast Storm
 * INPUT   : ifindex        -- which port to set
 *           operation_status   -- VAL_ifOperStatus_up/VAL_ifOperStatus_down
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : 1. RFC2863
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetATCMulticastStormPortOperationStatus(UI32_T ifindex, UI32_T operation_status)
{
    UI32_T                          unit, port, i;
    SWCTRL_TrunkPortExtInfo_T       trunk_ext_p_info;

    /* BODY
     */
    /* Check Management Port.
     * TRUE: The port is a management port.
     * FALSE: The port is not a managemet port.
     * It returns FALSE, when the port is a management port.
     */
    if ( TRUE == SWCTRL_IsManagementPort(ifindex) )
    {
        return FALSE;
    }

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if ( (operation_status != VAL_ifOperStatus_up) &&
         (operation_status != VAL_ifOperStatus_down) )
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_INVALID_PARAMETER,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "ATC oper status change");   /*SWCTRL_ENO_INVALID_ADMIN*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (!SWCTRL_IS_LPORT(ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (port_info[ifindex-1].link_oper_status == operation_status )
        SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );

    if (!SYS_CALLBACK_MGR_SetPortStatusCallback(SYS_MODULE_SWCTRL, ifindex, operation_status == VAL_ifOperStatus_up, SWCTRL_PORT_STATUS_SET_BY_ATC_MSTORM))
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    SWCTRL_LOCK();

    if (!SWCTRL_IS_TRUNK (ifindex))
    {
        port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_operation_status = operation_status;
    }
    else /* trunk */
    {
        SWCTRL_GetTrunkPortExtInfo (ifindex, &trunk_ext_p_info);

        for(i = 0; i < trunk_ext_p_info.member_number; i++)
        {
            unit = (UI32_T) trunk_ext_p_info.member_list[i].unit;
            port = (UI32_T) trunk_ext_p_info.member_list[i].port;

            port_info[(SWCTRL_UPORT_TO_IFINDEX(unit, port)) - 1].atc_multicast_storm_entry.atc_multicast_storm_operation_status = operation_status;
        } /* End of for () */

        port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_operation_status = operation_status;
    } /* End of if (trunk) */

    SWCTRL_UNLOCK();

    SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME ();
    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
}/* end of SWCTRL_SetATCMulticastStormPortOperationStatus () */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetATCMulticastStormCurrentTrafficRate
 * -------------------------------------------------------------------------
 * 36.
 * FUNCTION: This function will get the current traffic rate of multicast
 *           storm control function
 * INPUT   : ifindex -- which port to set
 * OUTPUT  : current_traffic_rate    -- which status of current traffic rate
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_GetATCMulticastStormCurrentTrafficRate(UI32_T ifindex, UI32_T *current_traffic_rate)
{
    /* LOCAL VARIABLES
     */

    /* BODY
     */
    /* Check Management Port.
     * TRUE: The port is a management port.
     * FALSE: The port is not a managemet port.
     * It returns FALSE, when the port is a management port.
     */
    if ( TRUE == SWCTRL_IsManagementPort(ifindex) )
    {
        return FALSE;
    }

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if ( ifindex == 0                          ||
         ifindex > SYS_ADPT_TOTAL_NBR_OF_LPORT )
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Logical Port ID (1-%d)", SYS_ADPT_TOTAL_NBR_OF_LPORT);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_LOGICAL_PORT_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (!SWCTRL_IS_EXIST (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Interface");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

#if (SYS_CPNT_ATC_MSTORM_SUPPORT_LPORT != TRUE)
    if (SWCTRL_IS_TRUNK (ifindex))
    {
            EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                      SWCTRL_NO_USE_FUNC_NO,
                                      EH_TYPE_MSG_TRUNK_CNFG_ERR,
                                      SYSLOG_LEVEL_INFO,
                                      "it doesn't support Multicast Storm Control.");  /*SWCTRL_ENO_NOT_TRUNK*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#else
    if (SWCTRL_IS_TRUNK_MEMBER (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#endif

    SWCTRL_LOCK();
    *current_traffic_rate = port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_current_traffic_rate;
    SWCTRL_UNLOCK();

    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetRunningATCMulticastStormEntry
 * -------------------------------------------------------------------------
 * 37.
 * FUNCTION: This function will get the running entry of multicast
 *           storm control function
 * INPUT   : atc_multicast_storm_entry    -- which status of running entry
 * OUTPUT  : atc_multicast_storm_entry    -- which status of running entry
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
SYS_TYPE_Get_Running_Cfg_T SWCTRL_GetRunningATCMulticastStormEntry(UI32_T port,SWCTRL_ATCMulticastStormEntry_T *atc_multicast_storm_entry)
{
    /* LOCAL VARIABLES
     */
    UI32_T information_is_changed = FALSE;
    UI32_T ifindex;

    /* BODY
     */
   SWCTRL_USE_CSC_CHECK_OPER_MODE(SYS_TYPE_GET_RUNNING_CFG_FAIL);

    if (atc_multicast_storm_entry == 0)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_FAIL );
    }

    (*atc_multicast_storm_entry).atc_multicast_storm_ifindex = port;
    if ( ((*atc_multicast_storm_entry).atc_multicast_storm_ifindex == 0) ||
         ((*atc_multicast_storm_entry).atc_multicast_storm_ifindex > SYS_ADPT_TOTAL_NBR_OF_LPORT) )
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_FAIL );
    }

    ifindex = (*atc_multicast_storm_entry).atc_multicast_storm_ifindex;
    memset(atc_multicast_storm_entry, 0, sizeof(atc_multicast_storm_entry));
    (*atc_multicast_storm_entry).atc_multicast_storm_ifindex = ifindex;

    if (SWCTRL_GetATCMulticastStormEntry(ifindex,atc_multicast_storm_entry))
    {
        ifindex = (*atc_multicast_storm_entry).atc_multicast_storm_ifindex;
        if (!SWCTRL_IS_EXIST (ifindex))
        {
            EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                      SWCTRL_NO_USE_FUNC_NO,
                                      EH_TYPE_MSG_NOT_EXIST,
                                      SYSLOG_LEVEL_INFO,
                                      "Interface");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

            SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_FAIL );
        }

        if (SWCTRL_IS_TRUNK_MEMBER (ifindex))
        {
            /* Return FALSE if the trunk is a static trunk.
             * ( Dynamic trunk member must be treated as normal port
             *  if the port info want to be saved in flash.)
             */
            if(trunk_ext_port_info[SWCTRL_IFINDEX_TO_TRUNKID(ifindex)-1].is_static == TRUE)
            {
                SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_FAIL );
            }
        }

        /* status */
        if ((*atc_multicast_storm_entry).atc_multicast_storm_status != SYS_DFLT_ATC_MSTORM_STATUS)
        {
            information_is_changed |= TRUE;
        }
        /* sample type */
        if ((*atc_multicast_storm_entry).atc_multicast_storm_sample_type != SYS_DFLT_ATC_MSTORM_TYPE)
        {
            information_is_changed |= TRUE;
        }
        /* auto traffic control on */
        if ((*atc_multicast_storm_entry).atc_multicast_storm_auto_traffic_control_on != SYS_DFLT_ATC_MSTORM_ATC_ON)
        {
            information_is_changed |= TRUE;
        }
        /* auto traffic control release */
        if ((*atc_multicast_storm_entry).atc_multicast_storm_auto_traffic_control_release != SYS_DFLT_ATC_MSTORM_ATC_RELEASE)
        {
            information_is_changed |= TRUE;
        }
        /* storm alarm threshold */
        if ((*atc_multicast_storm_entry).atc_multicast_storm_storm_alarm_threshold != SYS_DFLT_ATC_MSTORM_STORM_ALARM_THRESHOLD)
        {
            information_is_changed |= TRUE;
        }
        /* storm clear threshold */
        if ((*atc_multicast_storm_entry).atc_multicast_storm_storm_clear_threshold != SYS_DFLT_ATC_MSTORM_STORM_CLEAR_THRESHOLD)
        {
            information_is_changed |= TRUE;
        }
        /* trap storm alarm */
        if ((*atc_multicast_storm_entry).atc_multicast_storm_trap_storm_alarm != SYS_DFLT_ATC_MSTORM_STORM_TRAP_STORM_ALARM)
        {
            information_is_changed |= TRUE;
        }
        /* trap storm clear */
        if ((*atc_multicast_storm_entry).atc_multicast_storm_trap_storm_clear != SYS_DFLT_ATC_MSTORM_STORM_TRAP_STORM_CLEAR)
        {
            information_is_changed |= TRUE;
        }
        /* trap traffic control on */
        if ((*atc_multicast_storm_entry).atc_multicast_storm_trap_traffic_control_on != SYS_DFLT_ATC_MSTORM_STORM_TRAP_TC_ON)
        {
            information_is_changed |= TRUE;
        }
        /* trap traffic control release */
        if ((*atc_multicast_storm_entry).atc_multicast_storm_trap_traffic_control_release != SYS_DFLT_ATC_MSTORM_STORM_TRAP_TC_RELEASE)
        {
            information_is_changed |= TRUE;
        }
        /* action */
        if ((*atc_multicast_storm_entry).atc_multicast_storm_action != SYS_DFLT_ATC_MSTORM_STORM_ACTION)
        {
            information_is_changed |= TRUE;
        }

        if (information_is_changed == TRUE)
        {
            SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_SUCCESS )
        }
        else
        {
            SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_NO_CHANGE )
        }
    }

    SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_FAIL );
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetRunningATCMulticastStormTimer
 * -------------------------------------------------------------------------
 * 38.
 * FUNCTION: This function will get the running tc apply timer and tc release timer of multicast
 *           storm control function
 * INPUT   : ifindex -- which port to set
 *           a_multicast_storm_timer    -- which status of running tc apply timer and tc release timer
 * OUTPUT  : a_multicast_storm_timer    -- which status of running tc apply timer and tc release timer
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
SYS_TYPE_Get_Running_Cfg_T SWCTRL_GetRunningATCMulticastStormTimer(SWCTRL_ATCMulticastStormTimer_T *a_multicast_storm_timer)
{
    /* LOCAL VARIABLES
     */
    UI32_T information_is_changed = FALSE;

    /* BODY
     */
   SWCTRL_USE_CSC_CHECK_OPER_MODE(SYS_TYPE_GET_RUNNING_CFG_FAIL);

    if (a_multicast_storm_timer == 0)
    {
        /*UIMSG_MGR_SetErrorCode(); */ /*SWCTRL_ENO_NULL_POINTER*/
        SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_FAIL );
    }

    memset(a_multicast_storm_timer, 0, sizeof(SWCTRL_ATCMulticastStormTimer_T));

    if (SWCTRL_GetATCMulticastStormTimer(a_multicast_storm_timer))
    {

        /* traffic control on timer */
        if ((*a_multicast_storm_timer).atc_multicast_storm_traffic_control_on_timer != SYS_DFLT_ATC_MSTORM_TC_ON_TIMER)
        {
            information_is_changed |= TRUE;
        }
        /* traffic control release timer */
        if ((*a_multicast_storm_timer).atc_multicast_storm_traffic_control_release_timer != SYS_DFLT_ATC_MSTORM_TC_RELEASE_TIMER)
        {
            information_is_changed |= TRUE;
        }

        if (information_is_changed == TRUE)
        {
            SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_SUCCESS )
        }
        else
        {
            SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_NO_CHANGE )
        }
    }

    SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_FAIL );
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_ATCMulticastStormProtectionFSM
 * -------------------------------------------------------------------------
 * 39.
 * FUNCTION: This function will set the event of multicast
 *           storm control function
 * INPUT   : ifindex -- which port to set
 *           action    -- which status of event
 * OUTPUT  : None
 * RETURN  : None
 * NOTE    : None
 * -------------------------------------------------------------------------*/
void SWCTRL_ATCMulticastStormProtectionFSM( UI32_T ifindex, UI32_T event)
{
    const static UI8_T fsm_table[7][8] =
    {
        /* SWCTRL_ATCMSTORM_INIT_ST
         */
        {SWCTRL_ATCMSTORM_INIT_TST,
         SWCTRL_ATCMSTORM_INIT_ST,
         SWCTRL_ATCMSTORM_INIT_ST,
         SWCTRL_ATCMSTORM_INIT_ST,
         SWCTRL_ATCMSTORM_INIT_ST,
         SWCTRL_ATCMSTORM_INIT_ST,
         SWCTRL_ATCMSTORM_INIT_ST,
         SWCTRL_ATCMSTORM_INIT_ST},

        /* SWCTRL_ATCMSTORM_MIDDLE_ST
         */
        {SWCTRL_ATCMSTORM_MIDDLE_ST,
         SWCTRL_ATCMSTORM_LOW_TST,
         SWCTRL_ATCMSTORM_MIDDLE_ST,
         SWCTRL_ATCMSTORM_HIGH_TST,
         SWCTRL_ATCMSTORM_MIDDLE_ST,
         SWCTRL_ATCMSTORM_MIDDLE_ST,
         SWCTRL_ATCMSTORM_MIDDLE_ST,
         SWCTRL_ATCMSTORM_TERMINATE_TST},

        /* SWCTRL_ATCMSTORM_LOW_ST
         */
        {SWCTRL_ATCMSTORM_LOW_ST,
         SWCTRL_ATCMSTORM_LOW_ST,
         SWCTRL_ATCMSTORM_MIDDLE_TST,
         SWCTRL_ATCMSTORM_HIGH_TST,
         SWCTRL_ATCMSTORM_LOW_ST,
         SWCTRL_ATCMSTORM_LOW_ST,
         SWCTRL_ATCMSTORM_LOW_ST,
         SWCTRL_ATCMSTORM_TERMINATE_TST},

        /* SWCTRL_ATCMSTORM_HIGH_ST
         */
        {SWCTRL_ATCMSTORM_HIGH_ST,
         SWCTRL_ATCMSTORM_LOW_TST,
         SWCTRL_ATCMSTORM_MIDDLE_TST,
         SWCTRL_ATCMSTORM_HIGH_ST,
         SWCTRL_ATCMSTORM_CONTROL_TST,
         SWCTRL_ATCMSTORM_HIGH_ST,
         SWCTRL_ATCMSTORM_HIGH_ST,
         SWCTRL_ATCMSTORM_TERMINATE_TST},

        /* SWCTRL_ATCMSTORM_CONTROL_ST
         */
        {SWCTRL_ATCMSTORM_CONTROL_ST,
         SWCTRL_ATCMSTORM_CONTROLLOW_TST,
         SWCTRL_ATCMSTORM_CONTROL_ST,
         SWCTRL_ATCMSTORM_CONTROL_ST,
         SWCTRL_ATCMSTORM_CONTROL_ST,
         SWCTRL_ATCMSTORM_CONTROL_ST,
         SWCTRL_ATCMSTORM_RELEASE_TST,
         SWCTRL_ATCMSTORM_TERMINATE_TST},

        /*SWCTRL_ATCMSTORM_CONTROLLOW_ST
         */
       {SWCTRL_ATCMSTORM_CONTROLLOW_ST,
         SWCTRL_ATCMSTORM_CONTROLLOW_ST,
         SWCTRL_ATCMSTORM_CONTROL_TST,
         SWCTRL_ATCMSTORM_CONTROL_TST,
         SWCTRL_ATCMSTORM_CONTROLLOW_ST,
         SWCTRL_ATCMSTORM_RELEASE_TST,
         SWCTRL_ATCMSTORM_RELEASE_TST,
         SWCTRL_ATCMSTORM_TERMINATE_TST},

        /*SWCTRL_ATCMSTORM_RELEASE_ST
         */
       {SWCTRL_ATCMSTORM_INIT_ST,
         SWCTRL_ATCMSTORM_INIT_ST,
         SWCTRL_ATCMSTORM_INIT_ST,
         SWCTRL_ATCMSTORM_INIT_ST,
         SWCTRL_ATCMSTORM_INIT_ST,
         SWCTRL_ATCMSTORM_INIT_ST,
         SWCTRL_ATCMSTORM_INIT_ST,
         SWCTRL_ATCMSTORM_TERMINATE_TST}

    };

    UI32_T atc_mcast_storm_state_machine_state = 0;
    TRAP_EVENT_TrapData_T   trap_alarm_fire,trap_alarm_clear,trap_tc_apply,trap_tc_release;

    atc_mcast_storm_state_machine_state = port_info[ifindex-1].atc_multicast_storm_entry.state_machine_state;
    switch (fsm_table[atc_mcast_storm_state_machine_state][event])
    {
        case SWCTRL_ATCMSTORM_INIT_ST:
        case SWCTRL_ATCMSTORM_MIDDLE_ST:
        case SWCTRL_ATCMSTORM_LOW_ST:
        case SWCTRL_ATCMSTORM_HIGH_ST:
        case SWCTRL_ATCMSTORM_CONTROL_ST:
        case SWCTRL_ATCMSTORM_CONTROLLOW_ST :
        case SWCTRL_ATCMSTORM_RELEASE_ST:
            break;

        case SWCTRL_ATCMSTORM_INIT_TST:

            /* 1. Set variable to be default. */
            port_info[ifindex-1].atc_multicast_storm_entry.state_machine_trapf = SWCTRL_ATC_MULTICAST_STORM_TRAPF_LOW_FLOW;
            port_info[ifindex-1].atc_multicast_storm_entry.state_machine_ctrapf = 0;
            port_info[ifindex-1].atc_multicast_storm_entry.state_machine_t1 = 0;
            port_info[ifindex-1].atc_multicast_storm_entry.state_machine_t2 = 0;
            port_info[ifindex-1].atc_multicast_storm_entry.state_machine_manual = 0;
            port_info[ifindex-1].atc_multicast_storm_entry.state_machine_action = 0;

           /* Next state. */
           port_info[ifindex-1].atc_multicast_storm_entry.state_machine_state = SWCTRL_ATCMSTORM_MIDDLE_ST;

            /* Start of Debug message */
            if (SWCTRL_BACKDOOR_IsDebugFlagATCOn(SWCTRL_BACKDOOR_DEBUG_FLAG_ATC_MULTICAST_TRANSFER_STATE_MACHINE))
            {
                if (port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_auto_traffic_control_on == VAL_atcMcastStormEnable_enabled)
                {
                    BACKDOOR_MGR_Printf("\r\n FSM: Mcast, TST, ifindex = %ld, State: INIT_TST next state =MIDDLE= %ld \r\n", ifindex, port_info[ifindex-1].atc_multicast_storm_entry.state_machine_state);
                    BACKDOOR_MGR_Printf("  action = %ld , state_machine_action = %ld , state_machine_manual =%ld \r\n",
                       port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_action, port_info[ifindex-1].atc_multicast_storm_entry.state_machine_action,
                       port_info[ifindex-1].atc_multicast_storm_entry.state_machine_manual);
                }
            }
            /* End of Debug messag */
            break;

        case SWCTRL_ATCMSTORM_MIDDLE_TST:

            /* 1. state_machine_t1 = 0. */
            port_info[ifindex-1].atc_multicast_storm_entry.state_machine_t1 = 0;

            /* Next state. */
            port_info[ifindex-1].atc_multicast_storm_entry.state_machine_state = SWCTRL_ATCMSTORM_MIDDLE_ST;

            /* Start of Debug message */
            if (SWCTRL_BACKDOOR_IsDebugFlagATCOn(SWCTRL_BACKDOOR_DEBUG_FLAG_ATC_MULTICAST_TRANSFER_STATE_MACHINE))
            {
                if (port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_auto_traffic_control_on == VAL_atcMcastStormEnable_enabled)
                {
                    BACKDOOR_MGR_Printf("\r\n FSM: Mcast, TST, ifindex = %ld, State: MIDDLE_TST next state =MIDDLE= %ld \r\n", ifindex, port_info[ifindex-1].atc_multicast_storm_entry.state_machine_state);
                }
            }
            /* End of Debug messag */
            break;


        case SWCTRL_ATCMSTORM_LOW_TST:

            /* 1. Send Trap according to state_machine_trapf. */
            if( port_info[ifindex-1].atc_multicast_storm_entry.state_machine_trapf != SWCTRL_ATC_MULTICAST_STORM_TRAPF_LOW_FLOW )
            {
                if (port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_trap_storm_clear == VAL_atcMcastStormAlarmClearTrapStatus_enabled)
                {
                    /* send_trap(); Sent Storm Storm Clear Trap */
                    /* Trap: 2. TRAP_EVENT_MCAST_STORM_ALARM_CLEAR */
                    trap_alarm_clear.trap_type = TRAP_EVENT_MCAST_STORM_ALARM_CLEAR;
                    trap_alarm_clear.community_specified = FALSE;
                    trap_alarm_clear.flag = TRAP_EVENT_SEND_TRAP_OPTION_DEFAULT;
                    trap_alarm_clear.u.mstorm_alarm_clear.IfIndex= ifindex;
                    trap_alarm_clear.u.mstorm_alarm_clear.SampleType= port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_sample_type;
                    trap_alarm_clear.u.mstorm_alarm_clear.CurrentTrafficRate= port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_current_traffic_rate;
                    trap_alarm_clear.u.mstorm_alarm_clear.ClearThreshold= port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_storm_clear_threshold;
#if (SYS_CPNT_TRAPMGMT == TRUE)
                    TRAP_MGR_ReqSendTrap(&trap_alarm_clear);
#else
                    SNMP_PMGR_ReqSendTrap(&trap_alarm_clear);
#endif
                }
                port_info[ifindex-1].atc_multicast_storm_entry.state_machine_trapf = SWCTRL_ATC_MULTICAST_STORM_TRAPF_LOW_FLOW;
            }

            /* Next state. */
            port_info[ifindex-1].atc_multicast_storm_entry.state_machine_state = SWCTRL_ATCMSTORM_LOW_ST;

            /* Start of Debug message */
            if (SWCTRL_BACKDOOR_IsDebugFlagATCOn(SWCTRL_BACKDOOR_DEBUG_FLAG_ATC_MULTICAST_TRANSFER_STATE_MACHINE))
            {
                if (port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_auto_traffic_control_on == VAL_atcMcastStormEnable_enabled)
                {
                    BACKDOOR_MGR_Printf("\r\n FSM: Mcast, TST, ifindex = %ld, State: LOW_TST next state =LOW= %ld \r\n", ifindex, port_info[ifindex-1].atc_multicast_storm_entry.state_machine_state);
                    BACKDOOR_MGR_Printf("  action = %ld , state_machine_action = %ld , state_machine_manual =%ld \r\n",
                           port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_action, port_info[ifindex-1].atc_multicast_storm_entry.state_machine_action,
                           port_info[ifindex-1].atc_multicast_storm_entry.state_machine_manual);
                }
            }
            /* End of Debug messag */
            break;


        case SWCTRL_ATCMSTORM_HIGH_TST:

            /* 1. Send Trap according to state_machine_trapf. */
            if( port_info[ifindex-1].atc_multicast_storm_entry.state_machine_trapf != SWCTRL_ATC_MULTICAST_STORM_TRAPF_HIGH_FLOW )
            {
                if (port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_trap_storm_alarm == VAL_atcMcastStormAlarmFireTrapStatus_enabled)
                {
                    /* send_trap(); Sent Storm Alarm Fire Trap*/
                    /* Trap: 1. TRAP_EVENT_MCAST_STORM_ALARM_FIRE */
                    trap_alarm_fire.trap_type = TRAP_EVENT_MCAST_STORM_ALARM_FIRE;
                    trap_alarm_fire.community_specified = FALSE;
                    trap_alarm_fire.flag = TRAP_EVENT_SEND_TRAP_OPTION_DEFAULT;
                    trap_alarm_fire.u.mstorm_alarm_fire.IfIndex= ifindex;
                    trap_alarm_fire.u.mstorm_alarm_fire.SampleType= port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_sample_type;
                    trap_alarm_fire.u.mstorm_alarm_fire.CurrentTrafficRate= port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_current_traffic_rate;
                    trap_alarm_fire.u.mstorm_alarm_fire.AlarmThreshold= port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_storm_alarm_threshold;
#if (SYS_CPNT_TRAPMGMT == TRUE)
                    TRAP_MGR_ReqSendTrap(&trap_alarm_fire);
#else
                    SNMP_PMGR_ReqSendTrap(&trap_alarm_fire);
#endif
                }
                port_info[ifindex-1].atc_multicast_storm_entry.state_machine_trapf = SWCTRL_ATC_MULTICAST_STORM_TRAPF_HIGH_FLOW;
            }

            /* 2. Get t1 start tick. */
            port_info[ifindex-1].atc_multicast_storm_entry.state_machine_t1 = SYSFUN_GetSysTick();

            /* Next state. */
            port_info[ifindex-1].atc_multicast_storm_entry.state_machine_state = SWCTRL_ATCMSTORM_HIGH_ST;

            /* Start of Debug message */
            if (SWCTRL_BACKDOOR_IsDebugFlagATCOn(SWCTRL_BACKDOOR_DEBUG_FLAG_ATC_MULTICAST_TRANSFER_STATE_MACHINE))
            {
                if (port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_auto_traffic_control_on == VAL_atcMcastStormEnable_enabled)
                {
                    BACKDOOR_MGR_Printf("\r\n FSM: Mcast, TST, ifindex = %ld, State: HIGH_TST next state =HIGH= %ld \r\n", ifindex, port_info[ifindex-1].atc_multicast_storm_entry.state_machine_state);
                    BACKDOOR_MGR_Printf("  action = %ld , state_machine_action = %ld , state_machine_manual =%ld \r\n",
                           port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_action, port_info[ifindex-1].atc_multicast_storm_entry.state_machine_action,
                           port_info[ifindex-1].atc_multicast_storm_entry.state_machine_manual);
                }
            }
            /* End of Debug messag */
            break;


        case SWCTRL_ATCMSTORM_CONTROL_TST:

            /* 1. Send TC On Trap according to state_machine_ctrapf. */
            if( port_info[ifindex-1].atc_multicast_storm_entry.state_machine_ctrapf !=  SWCTRL_ATC_MULTICAST_STORM_CTRAPF_ON )
            {
                if (port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_trap_traffic_control_on == VAL_atcMcastStormTcApplyTrapStatus_enabled)
                {
                    /* send_trap(); Sent Traffic Control On Trap */
                    /* Trap: 3. TRAP_EVENT_MCAST_STORM_TC_APPLY */
                    trap_tc_apply.trap_type = TRAP_EVENT_MCAST_STORM_TC_APPLY;
                    trap_tc_apply.community_specified = FALSE;
                    trap_tc_apply.flag = TRAP_EVENT_SEND_TRAP_OPTION_DEFAULT;
                    trap_tc_apply.u.mstorm_tc_apply.IfIndex= ifindex;
                    trap_tc_apply.u.mstorm_tc_apply.SampleType= port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_sample_type;
                    trap_tc_apply.u.mstorm_tc_apply.CurrentTrafficRate= port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_current_traffic_rate;
                    trap_tc_apply.u.mstorm_tc_apply.AlarmThreshold= port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_storm_alarm_threshold;
                    trap_tc_apply.u.mstorm_tc_apply.TcAction = port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_action;
                    trap_tc_apply.u.mstorm_tc_apply.TcApplyTime= atc_multicast_storm_timer.atc_multicast_storm_traffic_control_on_timer;
#if (SYS_CPNT_TRAPMGMT == TRUE)
                    TRAP_MGR_ReqSendTrap(&trap_tc_apply);
#else
                    SNMP_PMGR_ReqSendTrap(&trap_tc_apply);
#endif
                }
                port_info[ifindex-1].atc_multicast_storm_entry.state_machine_ctrapf = SWCTRL_ATC_MULTICAST_STORM_CTRAPF_ON;

                /* Start of Debug message */
                if (SWCTRL_BACKDOOR_IsDebugFlagATCOn(SWCTRL_BACKDOOR_DEBUG_FLAG_ATC_MULTICAST_TRANSFER_STATE_MACHINE))
                {
                    if (port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_auto_traffic_control_on == VAL_atcMcastStormEnable_enabled)
                    {
                        BACKDOOR_MGR_Printf("\r\n FSM: Mcast, TST, ifindex = %ld, State: CONTROL_TST , now state = %ld \r\n", ifindex, port_info[ifindex-1].atc_multicast_storm_entry.state_machine_state);
                        BACKDOOR_MGR_Printf("  Send TC On Trap, state_machine_ctrapf = %ld \r\n",
                            port_info[ifindex-1].atc_multicast_storm_entry.state_machine_ctrapf);
                    }
                }
                /* End of Debug messag */

            }

            /* 2. state_machine_t2 = 0 */
            port_info[ifindex-1].atc_multicast_storm_entry.state_machine_t2 = 0;


            /* 3. Traffic On. action type: rate-limitation , shutdown. */
            if (port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_traffic_control_on != SWCTRL_ATC_MULTICAST_STORM_TC_ON_ENABLE)
            {
                if (port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_traffic_control_release == SWCTRL_ATC_MULTICAST_STORM_TC_RELEASE_ENABLE)
                {
                    SWCTRL_SetATCMulticastStormFSMTrafficControlReleaseStatus(ifindex, port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_action,
                        SWCTRL_ATC_MULTICAST_STORM_TC_RELEASE_DISABLE);
                }
                SWCTRL_SetATCMulticastStormFSMTrafficControlOnStatus(ifindex, port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_action,
                    SWCTRL_ATC_MULTICAST_STORM_TC_ON_ENABLE);
            }

            /* 4. Procced to next state machine according to manul flag. */
            port_info[ifindex-1].atc_multicast_storm_entry.state_machine_state = SWCTRL_ATCMSTORM_CONTROL_ST;

            /* Start of Debug message */
            if (SWCTRL_BACKDOOR_IsDebugFlagATCOn(SWCTRL_BACKDOOR_DEBUG_FLAG_ATC_MULTICAST_TRANSFER_STATE_MACHINE))
            {
                if (port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_auto_traffic_control_on == VAL_atcMcastStormEnable_enabled)
                {
                    BACKDOOR_MGR_Printf("\r\n FSM: Mcast, TST, ifindex = %ld, State: CONTROL_TST next state =CONTROL= %ld \r\n", ifindex, port_info[ifindex-1].atc_multicast_storm_entry.state_machine_state);
                    BACKDOOR_MGR_Printf("  action = %ld , state_machine_action = %ld , state_machine_manual =%ld \r\n",
                           port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_action, port_info[ifindex-1].atc_multicast_storm_entry.state_machine_action,
                           port_info[ifindex-1].atc_multicast_storm_entry.state_machine_manual);
                }
            }
            /* End of Debug messag */
            break;

        case SWCTRL_ATCMSTORM_CONTROLLOW_TST:

            /* 1. Send Storm Clear Trap according to state_machine_trapf. */
            if( port_info[ifindex-1].atc_multicast_storm_entry.state_machine_trapf != SWCTRL_ATC_MULTICAST_STORM_TRAPF_LOW_FLOW )
            {
                if (port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_trap_storm_clear == VAL_atcMcastStormAlarmClearTrapStatus_enabled)
                {
                    /* send_trap(); Sent Storm Clear Trap */
                    /* Trap: 2. TRAP_EVENT_MCAST_STORM_ALARM_CLEAR */
                    trap_alarm_clear.trap_type = TRAP_EVENT_MCAST_STORM_ALARM_CLEAR;
                    trap_alarm_clear.community_specified = FALSE;
                    trap_alarm_clear.flag = TRAP_EVENT_SEND_TRAP_OPTION_DEFAULT;
                    trap_alarm_clear.u.mstorm_alarm_clear.IfIndex= ifindex;
                    trap_alarm_clear.u.mstorm_alarm_clear.SampleType= port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_sample_type;
                    trap_alarm_clear.u.mstorm_alarm_clear.CurrentTrafficRate= port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_current_traffic_rate;
                    trap_alarm_clear.u.mstorm_alarm_clear.ClearThreshold= port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_storm_clear_threshold;
#if (SYS_CPNT_TRAPMGMT == TRUE)
                    TRAP_MGR_ReqSendTrap(&trap_alarm_clear);
#else
                    SNMP_PMGR_ReqSendTrap(&trap_alarm_clear);
#endif
                }
                port_info[ifindex-1].atc_multicast_storm_entry.state_machine_trapf = SWCTRL_ATC_MULTICAST_STORM_TRAPF_LOW_FLOW;
            }

            /* 2. Get state_machine_t2 start tick. */
            port_info[ifindex-1].atc_multicast_storm_entry.state_machine_t2 = SYSFUN_GetSysTick();

            /* Next state. */
            port_info[ifindex-1].atc_multicast_storm_entry.state_machine_state = SWCTRL_ATCMSTORM_CONTROLLOW_ST;

            /* Start of Debug message */
            if (SWCTRL_BACKDOOR_IsDebugFlagATCOn(SWCTRL_BACKDOOR_DEBUG_FLAG_ATC_MULTICAST_TRANSFER_STATE_MACHINE))
            {
                if (port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_auto_traffic_control_on == VAL_atcMcastStormEnable_enabled)
                {
                    BACKDOOR_MGR_Printf("\r\n FSM: Mcast, TST, ifindex = %ld, State: CONTROLLOW_TST next state =CONTROLLOW= %ld \r\n", ifindex, port_info[ifindex-1].atc_multicast_storm_entry.state_machine_state);
                    BACKDOOR_MGR_Printf("  action = %ld , state_machine_action = %ld , state_machine_manual =%ld \r\n",
                           port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_action, port_info[ifindex-1].atc_multicast_storm_entry.state_machine_action,
                           port_info[ifindex-1].atc_multicast_storm_entry.state_machine_manual);
                }
            }
            /* End of Debug messag */
            break;

        case SWCTRL_ATCMSTORM_RELEASE_TST:

            /* 1. Sent Traffic Control Release Trap. */
            if( (port_info[ifindex-1].atc_multicast_storm_entry.state_machine_action == VAL_atcMcastStormTcAction_rate_control) &&
                (port_info[ifindex-1].atc_multicast_storm_entry.state_machine_ctrapf !=  SWCTRL_ATC_MULTICAST_STORM_CTRAPF_RELEASE))
            {
                if (port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_trap_traffic_control_release == VAL_atcMcastStormTcReleaseTrapStatus_enabled)
                {
                    /* send_trap(); Sent Traffic Control Release Trap */
                    /* Trap: 4. TRAP_EVENT_MCAST_STORM_TC_RELEASE */
                    trap_tc_release.trap_type = TRAP_EVENT_MCAST_STORM_TC_RELEASE;
                    trap_tc_release.community_specified = FALSE;
                    trap_tc_release.flag = TRAP_EVENT_SEND_TRAP_OPTION_DEFAULT;
                    trap_tc_release.u.mstorm_tc_release.IfIndex= ifindex;
                    trap_tc_release.u.mstorm_tc_release.SampleType= port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_sample_type;
                    trap_tc_release.u.mstorm_tc_release.CurrentTrafficRate= port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_current_traffic_rate;
                    trap_tc_release.u.mstorm_tc_release.ClearThreshold= port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_storm_clear_threshold;
                    trap_tc_release.u.mstorm_tc_release.TcReleaseTime= atc_multicast_storm_timer.atc_multicast_storm_traffic_control_release_timer;
#if (SYS_CPNT_TRAPMGMT == TRUE)
                    TRAP_MGR_ReqSendTrap(&trap_tc_release);
#else
                    SNMP_PMGR_ReqSendTrap(&trap_tc_release);
#endif
                }
                port_info[ifindex-1].atc_multicast_storm_entry.state_machine_ctrapf = SWCTRL_ATC_MULTICAST_STORM_CTRAPF_RELEASE;

                /* Start of Debug message */
                if (SWCTRL_BACKDOOR_IsDebugFlagATCOn(SWCTRL_BACKDOOR_DEBUG_FLAG_ATC_MULTICAST_TRANSFER_STATE_MACHINE))
                {
                    if (port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_auto_traffic_control_on == VAL_atcMcastStormEnable_enabled)
                    {
                        BACKDOOR_MGR_Printf("\r\n FSM: Mcast, TST, ifindex = %ld, State: RELEASE_TST , now state = %ld \r\n", ifindex, port_info[ifindex-1].atc_multicast_storm_entry.state_machine_state);
                        BACKDOOR_MGR_Printf("  action = %ld , state_machine_action = %ld , state_machine_manual =%ld \r\n",
                            port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_action, port_info[ifindex-1].atc_multicast_storm_entry.state_machine_action,
                            port_info[ifindex-1].atc_multicast_storm_entry.state_machine_manual);
                    }
                }
                /* End of Debug messag */

            }

            /* 2. Release. */
            if (port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_traffic_control_release != SWCTRL_ATC_MULTICAST_STORM_TC_RELEASE_ENABLE)
            {
                if (port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_traffic_control_on == SWCTRL_ATC_MULTICAST_STORM_TC_ON_ENABLE)
                {
                    SWCTRL_SetATCMulticastStormFSMTrafficControlOnStatus(ifindex, port_info[ifindex-1].atc_multicast_storm_entry.state_machine_action,
                        SWCTRL_ATC_MULTICAST_STORM_TC_ON_DISABLE);
                }
                SWCTRL_SetATCMulticastStormFSMTrafficControlReleaseStatus(ifindex, port_info[ifindex-1].atc_multicast_storm_entry.state_machine_action,
                    SWCTRL_ATC_MULTICAST_STORM_TC_RELEASE_ENABLE);
                SWCTRL_SetATCMulticastStormFSMTrafficControlReleaseStatus(ifindex, port_info[ifindex-1].atc_multicast_storm_entry.state_machine_action,
                    SWCTRL_ATC_MULTICAST_STORM_TC_RELEASE_DISABLE);
            }

            /* 3. Set Manual to disable.*/
            port_info[ifindex-1].atc_multicast_storm_entry.state_machine_manual = SWCTRL_ATC_MULTICAST_STORM_STATE_MACHINE_MANUAL_DISABLE;


            /* 4. Set variable to be default. */
            port_info[ifindex-1].atc_multicast_storm_entry.state_machine_trapf = SWCTRL_ATC_MULTICAST_STORM_TRAPF_LOW_FLOW;
            port_info[ifindex-1].atc_multicast_storm_entry.state_machine_ctrapf = 0;
            port_info[ifindex-1].atc_multicast_storm_entry.state_machine_t1 = 0;
            port_info[ifindex-1].atc_multicast_storm_entry.state_machine_t2 = 0;
            port_info[ifindex-1].atc_multicast_storm_entry.state_machine_manual = 0;
            port_info[ifindex-1].atc_multicast_storm_entry.state_machine_action = 0;

            /* Next state. */
            port_info[ifindex-1].atc_multicast_storm_entry.state_machine_state = SWCTRL_ATCMSTORM_MIDDLE_ST;

            /* Start of Debug message */
            if (SWCTRL_BACKDOOR_IsDebugFlagATCOn(SWCTRL_BACKDOOR_DEBUG_FLAG_ATC_MULTICAST_TRANSFER_STATE_MACHINE))
            {
                if (port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_auto_traffic_control_on == VAL_atcMcastStormEnable_enabled)
                {
                    BACKDOOR_MGR_Printf("\r\n FSM: Mcast, TST, ifindex = %ld, State: RELEASE_TST next state =MIDDLE= %ld \r\n", ifindex, port_info[ifindex-1].atc_multicast_storm_entry.state_machine_state);
                    BACKDOOR_MGR_Printf("  action = %ld , state_machine_action = %ld , state_machine_manual =%ld \r\n",
                           port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_action, port_info[ifindex-1].atc_multicast_storm_entry.state_machine_action,
                           port_info[ifindex-1].atc_multicast_storm_entry.state_machine_manual);
                }
            }
            /* End of Debug messag */
            break;

        case SWCTRL_ATCMSTORM_TERMINATE_TST:

            /* 1. Sent Traffic Control Release Trap. */
            if( (port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_traffic_control_on == SWCTRL_ATC_MULTICAST_STORM_TC_ON_ENABLE) &&
                (port_info[ifindex-1].atc_multicast_storm_entry.state_machine_action == VAL_atcMcastStormTcAction_rate_control) &&
                (port_info[ifindex-1].atc_multicast_storm_entry.state_machine_ctrapf !=  SWCTRL_ATC_MULTICAST_STORM_CTRAPF_RELEASE))
            {
                if (port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_trap_traffic_control_release == VAL_atcMcastStormTcReleaseTrapStatus_enabled)
                {
                    /* send_trap(); Sent Traffic Control Release Trap */
                    /* Trap: 4. TRAP_EVENT_MCAST_STORM_TC_RELEASE */
                    trap_tc_release.trap_type = TRAP_EVENT_MCAST_STORM_TC_RELEASE;
                    trap_tc_release.community_specified = FALSE;
                    trap_tc_release.flag = TRAP_EVENT_SEND_TRAP_OPTION_DEFAULT;
                    trap_tc_release.u.mstorm_tc_release.IfIndex= ifindex;
                    trap_tc_release.u.mstorm_tc_release.SampleType= port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_sample_type;
                    trap_tc_release.u.mstorm_tc_release.CurrentTrafficRate= port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_current_traffic_rate;
                    trap_tc_release.u.mstorm_tc_release.ClearThreshold= port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_storm_clear_threshold;
                    trap_tc_release.u.mstorm_tc_release.TcReleaseTime= atc_multicast_storm_timer.atc_multicast_storm_traffic_control_release_timer;
#if (SYS_CPNT_TRAPMGMT == TRUE)
                    TRAP_MGR_ReqSendTrap(&trap_tc_release);
#else
                    SNMP_PMGR_ReqSendTrap(&trap_tc_release);
#endif
                }
                port_info[ifindex-1].atc_multicast_storm_entry.state_machine_ctrapf = SWCTRL_ATC_MULTICAST_STORM_CTRAPF_RELEASE;
            }

            /* 2. Release if traffic_control_on is enabled. */
            if (port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_traffic_control_on == SWCTRL_ATC_MULTICAST_STORM_TC_ON_ENABLE)
            {
                SWCTRL_SetATCMulticastStormFSMTrafficControlOnStatus(ifindex, port_info[ifindex-1].atc_multicast_storm_entry.state_machine_action,
                    SWCTRL_ATC_MULTICAST_STORM_TC_ON_DISABLE);

                SWCTRL_SetATCMulticastStormFSMTrafficControlReleaseStatus(ifindex, port_info[ifindex-1].atc_multicast_storm_entry.state_machine_action,
                    SWCTRL_ATC_MULTICAST_STORM_TC_RELEASE_ENABLE);
                SWCTRL_SetATCMulticastStormFSMTrafficControlReleaseStatus(ifindex, port_info[ifindex-1].atc_multicast_storm_entry.state_machine_action,
                    SWCTRL_ATC_MULTICAST_STORM_TC_RELEASE_DISABLE);

                /* Start of Debug message */
                if (SWCTRL_BACKDOOR_IsDebugFlagATCOn(SWCTRL_BACKDOOR_DEBUG_FLAG_ATC_MULTICAST_TRANSFER_STATE_MACHINE))
                {
                    if (port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_auto_traffic_control_on == VAL_atcMcastStormEnable_enabled)
                    {
                        BACKDOOR_MGR_Printf("\r\n FSM: Mcast, TST, ifindex = %ld, State: TERMINATE_TST , now state = %ld \r\n", ifindex, port_info[ifindex-1].atc_multicast_storm_entry.state_machine_state);
                        BACKDOOR_MGR_Printf("  atc_multicast_storm_traffic_control_on = %ld  \r\n",
                            port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_traffic_control_on);
                    }
                }
                /* End of Debug messag */

            }

            /* 3. Set variable to be default. */
            port_info[ifindex-1].atc_multicast_storm_entry.state_machine_trapf = SWCTRL_ATC_MULTICAST_STORM_TRAPF_LOW_FLOW;
            port_info[ifindex-1].atc_multicast_storm_entry.state_machine_ctrapf = 0;
            port_info[ifindex-1].atc_multicast_storm_entry.state_machine_t1 = 0;
            port_info[ifindex-1].atc_multicast_storm_entry.state_machine_t2 = 0;
            port_info[ifindex-1].atc_multicast_storm_entry.state_machine_manual = 0;
            port_info[ifindex-1].atc_multicast_storm_entry.state_machine_action = 0;

            /* Next state. */
            port_info[ifindex-1].atc_multicast_storm_entry.state_machine_state = SWCTRL_ATCMSTORM_INIT_ST;

            /* Start of Debug message */
            if (SWCTRL_BACKDOOR_IsDebugFlagATCOn(SWCTRL_BACKDOOR_DEBUG_FLAG_ATC_MULTICAST_TRANSFER_STATE_MACHINE))
            {
                if (port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_auto_traffic_control_on == VAL_atcMcastStormEnable_enabled)
                {
                    BACKDOOR_MGR_Printf("\r\n FSM: Mcast, TST, ifindex = %ld, State: TERMINATE_TST next state =INIT= %ld \r\n", ifindex, port_info[ifindex-1].atc_multicast_storm_entry.state_machine_state);
                    BACKDOOR_MGR_Printf("  action = %ld , state_machine_action = %ld , state_machine_manual =%ld \r\n",
                       port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_action, port_info[ifindex-1].atc_multicast_storm_entry.state_machine_action,
                       port_info[ifindex-1].atc_multicast_storm_entry.state_machine_manual);
                }
            }
            /* End of Debug messag */
            break;

        default:
            break;
    } /* end of switch */
} /* End of SWCTRL_ATCMulticastStormProtectionFSM */

BOOL_T SWCTRL_DisableMStormAfterClearThreshold(UI32_T ifindex)
{

    UI32_T fsm_state, atc_state;

    if ( TRUE == SWCTRL_IsManagementPort(ifindex) )
    {
        return FALSE;
    }

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if ((ifindex == 0) ||(ifindex > SYS_ADPT_TOTAL_NBR_OF_LPORT))
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Logical Port ID (1-%d)", SYS_ADPT_TOTAL_NBR_OF_LPORT);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_LOGICAL_PORT_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (!SWCTRL_IS_EXIST (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Interface");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

#if (SYS_CPNT_ATC_BSTORM_SUPPORT_LPORT != TRUE)
    if (SWCTRL_IS_TRUNK (ifindex))
    {
            EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                      SWCTRL_NO_USE_FUNC_NO,
                                      EH_TYPE_MSG_TRUNK_CNFG_ERR,
                                      SYSLOG_LEVEL_INFO,
                                      "it doesn't support Broadcast Storm Control.");  /*SWCTRL_ENO_NOT_TRUNK*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#else
    if (SWCTRL_IS_TRUNK_MEMBER (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#endif

    SWCTRL_LOCK();
    fsm_state = port_info[ifindex-1].atc_multicast_storm_entry.state_machine_state;
    atc_state = port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_auto_traffic_control_on;
    SWCTRL_UNLOCK();

        if((fsm_state != SWCTRL_ATCMSTORM_CONTROL_ST )&&(atc_state == VAL_atcMcastStormEnable_enabled))
        {
        return SWDRV_DisableMulticastStormControl(SWCTRL_IFINDEX_TO_UNIT(ifindex), ifindex);
        }
        else
            return TRUE;


}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_ProcessATCMulticastStormTrafficControlReleasePassively
 * -------------------------------------------------------------------------
 * FUNCTION: This function will be executed when ATC port admin status is
 *           enabled by someone. (ex. "no shutdown" by user)
 * INPUT   : ifindex -- which port to set
 *           traffic_control_release_status    -- which status of traffic control release
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
static BOOL_T SWCTRL_ProcessATCMulticastStormTrafficControlReleasePassively(UI32_T ifindex)
{
    BOOL_T retval = FALSE;

#if (SYS_CPNT_ATC_MSTORM_SUPPORT_LPORT != TRUE)
    if (SWCTRL_IS_TRUNK (ifindex))
    {
        SWCTRL_TrunkPortExtInfo_T trunk_ext_p_info;
        int i;

        SWCTRL_GetTrunkPortExtInfo (ifindex, &trunk_ext_p_info);

        for(i = 0, retval = TRUE; retval && i < trunk_ext_p_info.member_number; i++)
        {
            UI32_T unit, port, ifindex;

            unit = trunk_ext_p_info.member_list[i].unit;
            port = trunk_ext_p_info.member_list[i].port;
            ifindex = SWCTRL_UPORT_TO_IFINDEX(unit, port);
            retval = SWCTRL_SetATCMulticastStormTrafficControlReleaseStatus(ifindex, SWCTRL_ATC_MULTICAST_STORM_TC_RELEASE_ENABLE);
        }
    }
    else
#endif /* (SYS_CPNT_ATC_MSTORM_SUPPORT_LPORT != TRUE) */
    {
        retval = SWCTRL_SetATCMulticastStormTrafficControlReleaseStatus(ifindex, SWCTRL_ATC_MULTICAST_STORM_TC_RELEASE_ENABLE);
    }

    return retval;
}
#endif /* End of SYS_CPNT_ATC_MSTORM */

#if (SYS_CPNT_ATC_STORM == TRUE)

UI32_T BcastPkts[SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK * SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT][2]={{0,0},};
UI32_T McastPkts[SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK * SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT][2]={{0,0},};
void GetAutoTrafficControlBCastDifferentCounter(UI32_T ifindex)
{
    UI8_T  i=0;
    UI32_T max=0;

        BcastPkts[ifindex-1][0] = BcastPkts[ifindex-1][1];
        BcastPkts[ifindex-1][1] = swctrl_different_counter[ifindex-1].ifInBroadcastPkts;

        for(i=0;i<2;i++)
        {
            if(BcastPkts[ifindex-1][i] != 0)
            {
                max = (BcastPkts[ifindex-1][i]>max)?BcastPkts[ifindex-1][i]:max;
            }
        }

        if(max != 0x0)
        {
          swctrl_different_counter[ifindex-1].ifInBroadcastPkts= max;
        }

}

void GetAutoTrafficControlMCastDifferentCounter(UI32_T ifindex)
{
    UI8_T  i=0;
    UI32_T max=0;

        McastPkts[ifindex-1][0] = McastPkts[ifindex-1][1];
        McastPkts[ifindex-1][1] = swctrl_different_counter[ifindex-1].ifInMulticastPkts;

        for(i=0;i<2;i++)
        {
            if(McastPkts[ifindex-1][i] != 0)
            {
                max = (McastPkts[ifindex-1][i]>max)?McastPkts[ifindex-1][i]:max;
            }
        }

        if(max != 0x0)
        {
          swctrl_different_counter[ifindex-1].ifInMulticastPkts= max;
        }

}


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_PacketFlowAnalyser
 * -------------------------------------------------------------------------
 * 40.
 * FUNCTION: This function will do the packet flow analyser of auto traffic control
 *           storm control function
 * INPUT   : None
 * OUTPUT  : None
 * RETURN  : None
 * NOTE    : None
 * -------------------------------------------------------------------------*/
UI32_T SWCTRL_PacketFlowAnalyser(void)
{
    UI32_T  ifindex;
    UI32_T  unit_id = 1;
    UI32_T  swctrl_event = 0;
    UI32_T  current_timer; /* current time */
    UI32_T  limit_timer; /* limit time */
    UI32_T  calculate_timer; /* calculate the period */
    BOOL_T  bypass_analyzer[SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK * SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT];

    UI32_T  traffic_flow_level = 0; /* 1: low flow, 2: middle flow, 3: high flow */

    /* 1. Initialize static value. */
    memset(bypass_analyzer, 0, sizeof(bypass_analyzer));

    /* 2. Get the old different counter. */
    SWCTRL_LOCK();
    {
        for(ifindex = 1;
            ifindex <= SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK * SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT;
            ifindex++)
        {
#if (SYS_CPNT_ATC_BSTORM  == TRUE)
            if (port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_auto_traffic_control_on == VAL_atcBcastStormEnable_enabled)
            {
                swctrl_total_counter_last_time[ifindex-1].ifInBroadcastPkts = swctrl_if_xtable_stats[ifindex-1].ifInBroadcastPkts;
            }
#endif

#if (SYS_CPNT_ATC_MSTORM  == TRUE)
            if (port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_auto_traffic_control_on == VAL_atcMcastStormEnable_enabled)
            {
                swctrl_total_counter_last_time[ifindex-1].ifInMulticastPkts = swctrl_if_xtable_stats[ifindex-1].ifInMulticastPkts;
            }
#endif
        }
    }
    SWCTRL_UNLOCK();

    /* 3. Get counter states. */
    for(ifindex = 1;
        ifindex <= SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK * SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT;
        ifindex++)
    {
        if (!SWCTRL_IS_EXIST(ifindex))
        {
            continue;
        }

        NMTRDRV_OM_GetIfXStats(SWCTRL_IFINDEX_TO_UNIT(ifindex), SWCTRL_IFINDEX_TO_PORT(ifindex), &swctrl_if_xtable_stats[ifindex-1]);
    }

    /* 4. Get Final difference. */
    /* Start of 4. Get Final difference. */
    for(ifindex = 1;
        ifindex <= SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK * SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT;
        ifindex++)
    {
        /* 1. Get difference.*/
#if (SYS_CPNT_ATC_BSTORM  == TRUE)
        if (port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_auto_traffic_control_on == VAL_atcBcastStormEnable_enabled)
        {
            if ((UI32_T)swctrl_if_xtable_stats[ifindex-1].ifInBroadcastPkts >= swctrl_total_counter_last_time[ifindex-1].ifInBroadcastPkts)
            {
                swctrl_different_counter[ifindex-1].ifInBroadcastPkts = (UI32_T)swctrl_if_xtable_stats[ifindex-1].ifInBroadcastPkts - swctrl_total_counter_last_time[ifindex-1].ifInBroadcastPkts;
                /*when storm on,sometimes the ifInBroadcastPkts not changed*/
                /*at this instance,it should not go to Low Flow or Middle Flow */
                GetAutoTrafficControlBCastDifferentCounter(ifindex);
            }
            else
            {
                /* if current counter is lesser than last one,
                 * it might be
                 *    1) counter overflow or
                 *    2) counter reset (ex. hot insertion)
                 *
                 * for counter overflow, it is harmless.
                 * for counter reset, need to bypass analyzer this time.
                 *
                 * to simpify implementation,
                 * always bypass analyzer whether counter overflow or counter reset.
                 */
                bypass_analyzer[ifindex-1] = TRUE;
            }
        }
#endif

#if (SYS_CPNT_ATC_MSTORM  == TRUE)
        if (port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_auto_traffic_control_on == VAL_atcMcastStormEnable_enabled)
        {
            if ((UI32_T)swctrl_if_xtable_stats[ifindex-1].ifInMulticastPkts >= swctrl_total_counter_last_time[ifindex-1].ifInMulticastPkts)
            {
                swctrl_different_counter[ifindex-1].ifInMulticastPkts = (UI32_T)swctrl_if_xtable_stats[ifindex-1].ifInMulticastPkts - swctrl_total_counter_last_time[ifindex-1].ifInMulticastPkts;
                /*when storm on,sometimes the ifInBroadcastPkts not changed*/
                /*at this instance,it should not go to Low Flow or Middle Flow */
                GetAutoTrafficControlMCastDifferentCounter(ifindex);
            }
            else
            {
                /* if current counter is lesser than last one,
                 * it might be
                 *    1) counter overflow or
                 *    2) counter reset (ex. hot insertion)
                 *
                 * for counter overflow, it is harmless.
                 * for counter reset, need to bypass analyzer this time.
                 *
                 * to simpify implementation,
                 * always bypass analyzer whether counter overflow or counter reset.
                 */
                bypass_analyzer[ifindex-1] = TRUE;
            }
        }
#endif

        /* Start of Debug message */
        if (SWCTRL_BACKDOOR_IsDebugFlagATCOn(SWCTRL_BACKDOOR_DEBUG_FLAG_ATC_PACKET_COUNTER))
        {
#if (SYS_CPNT_ATC_BSTORM  == TRUE)
            if (port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_auto_traffic_control_on == VAL_atcBcastStormEnable_enabled)
            {
                BACKDOOR_MGR_Printf("\r\n AnalyB: 4. 1.1 Get Diff unit=%ld,index=%ld,now=%ld,last=%ld, diff= %ld\r\n",
                    unit_id, ifindex,
                    (UI32_T)swctrl_if_xtable_stats[ifindex-1].ifInBroadcastPkts,
                    swctrl_total_counter_last_time[ifindex-1].ifInBroadcastPkts,
                    swctrl_different_counter[ifindex-1].ifInBroadcastPkts);
            }
#endif

#if (SYS_CPNT_ATC_MSTORM  == TRUE)
            if (port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_auto_traffic_control_on == VAL_atcMcastStormEnable_enabled)
            {
                BACKDOOR_MGR_Printf("\r\n AnalyM: 4. 1.2 Get Diff unit=%ld,index=%ld,now=%ld,last=%ld, diff= %ld\r\n",
                    unit_id, ifindex,
                    (UI32_T)swctrl_if_xtable_stats[ifindex-1].ifInMulticastPkts,
                    swctrl_total_counter_last_time[ifindex-1].ifInMulticastPkts,
                    swctrl_different_counter[ifindex-1].ifInMulticastPkts);
            }
#endif
        }
        /* End of Debug message */

    }
    /* End of 4. Get Final difference. */

    /* 5. Get the event according to ATC Broadcast Storm and then send the event. */
#if (SYS_CPNT_ATC_BSTORM  == TRUE)
    for(ifindex = 1;
        ifindex <= SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK * SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT;
        ifindex++)
    {
        if (bypass_analyzer[ifindex-1])
        {
            continue;
        }

        /* 1. Check auto-traffic-control status. */
        if( port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_auto_traffic_control_on == VAL_atcBcastStormEnable_disabled)
        {
        continue;
        }

        /* 2. Initialize the swctrl event. */
        swctrl_event = SWCTRL_ATCBSTORM_NO_EV; /* It does not send the event to FSM. */

        /* 3. Get current packet rate. */
        port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_current_traffic_rate = swctrl_different_counter[ifindex-1].ifInBroadcastPkts;
        /* 4. Get traffic flow level and Estimate the type of events. */
        if (swctrl_different_counter[ifindex-1].ifInBroadcastPkts <= port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_storm_clear_threshold)
        {
            traffic_flow_level = 1;
        }
        else if (swctrl_different_counter[ifindex-1].ifInBroadcastPkts < port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_storm_alarm_threshold)
        {
            traffic_flow_level = 2;
        }
        else if (swctrl_different_counter[ifindex-1].ifInBroadcastPkts >= port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_storm_alarm_threshold)
        {
            traffic_flow_level = 3;
        }

        switch(traffic_flow_level)
        {
            case 1: /* low flow */
                /* Check 1. (1)state = control, (2)!manual, => event: low flow. */
                /*               (1)state = control, (2)manual, => event: no event. */
                /* Check 2. (1)state = control_low, (2)!t2, (3)t2 is expired, => event: timer release. */
                /*               (1)state = control_low, (2)!t2, (3)t2 is not expired, => event: no event. */
                /* Check 3. event: low flow.*/

                /* Check 1. (1)state = control, (2)!manual, => event: low flow. */
                /*               (1)state = control, (2)manual, => event: no event. */
                if (port_info[ifindex-1].atc_broadcast_storm_entry.state_machine_state == SWCTRL_ATCBSTORM_CONTROL_ST)
                {
                    if (port_info[ifindex-1].atc_broadcast_storm_entry.state_machine_manual != SWCTRL_ATC_BROADCAST_STORM_STATE_MACHINE_MANUAL_ENABLE)
                    {
                        swctrl_event = SWCTRL_ATCBSTORM_LOW_FLOW_EV;
                    }
                    else
                    {
                        swctrl_event = SWCTRL_ATCBSTORM_NO_EV;
                    }

                    /* Start of Debug message */
                    if (SWCTRL_BACKDOOR_IsDebugFlagATCOn(SWCTRL_BACKDOOR_DEBUG_FLAG_ATC_BROADCAST_EVENT))
                    {
                        if (port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_auto_traffic_control_on == VAL_atcBcastStormEnable_enabled)
                        {
                            if (swctrl_event == SWCTRL_ATCBSTORM_LOW_FLOW_EV)
                            {
                                BACKDOOR_MGR_Printf("\r\n Analyser: Bcast, EV, index = %ld, low_flow, state = control, swctrl_event =LOW= %ld \r\n", ifindex, swctrl_event);
                            }
                            else if (swctrl_event == SWCTRL_ATCBSTORM_NO_EV)
                            {
                                BACKDOOR_MGR_Printf("\r\n Analyser: Bcast, EV, index = %ld, low_flow, state = control, swctrl_event =NO= %ld \r\n", ifindex, swctrl_event);
                            }

                        }
                    }
                    /* End of Debug message */

                }
                /* Check 2. (1)state = control_low, (2)!t2, (3)t2 is expired, => event: timer release. */
                /*               (1)state = control_low, (2)!t2, (3)t2 is not expired, => event: no event. */
                else if ( (port_info[ifindex-1].atc_broadcast_storm_entry.state_machine_state == SWCTRL_ATCBSTORM_CONTROLLOW_ST) &&
                     (port_info[ifindex-1].atc_broadcast_storm_entry.state_machine_t2 != 0) )
                 {
                     current_timer = SYSFUN_GetSysTick();
                     limit_timer = 0xffffffff;
                     if (port_info[ifindex-1].atc_broadcast_storm_entry.state_machine_t2 >= (limit_timer - (100 * atc_broadcast_storm_timer.atc_broadcast_storm_traffic_control_release_timer)) )
                     {
                         calculate_timer = current_timer + (limit_timer -port_info[ifindex-1].atc_broadcast_storm_entry.state_machine_t2);
                     }
                     else
                     {
                         calculate_timer = current_timer -port_info[ifindex-1].atc_broadcast_storm_entry.state_machine_t2;
                     }

                     if (calculate_timer >= (100 * atc_broadcast_storm_timer.atc_broadcast_storm_traffic_control_release_timer))
                     {
                         swctrl_event = SWCTRL_ATCBSTORM_TIMER_RELEASE_EV;
                     }
                    else
                    {
                        swctrl_event = SWCTRL_ATCBSTORM_NO_EV;
                    }

                    /* Start of Debug message */
                    if (SWCTRL_BACKDOOR_IsDebugFlagATCOn(SWCTRL_BACKDOOR_DEBUG_FLAG_ATC_BROADCAST_EVENT))
                    {
                        if (port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_auto_traffic_control_on == VAL_atcBcastStormEnable_enabled)
                        {
                            if (swctrl_event == SWCTRL_ATCBSTORM_LOW_FLOW_EV)
                            {
                                BACKDOOR_MGR_Printf("\r\n Analyser: Bcast, EV, index = %ld, low_flow, state = control_low, swctrl_event =LOW=%ld \r\n", ifindex, swctrl_event);
                                BACKDOOR_MGR_Printf("\r\n  current_timer = %ld , machine_t2 = %ld, calculate_timer =%ld \r\n",
                                    current_timer,port_info[ifindex-1].atc_broadcast_storm_entry.state_machine_t2, calculate_timer);
                            }
                            else if (swctrl_event == SWCTRL_ATCBSTORM_NO_EV)
                            {
                                BACKDOOR_MGR_Printf("\r\n Analyser: Bcast, EV, index = %ld, low_flow, state = control_low, swctrl_event =NO= %ld \r\n", ifindex, swctrl_event);
                                BACKDOOR_MGR_Printf("\r\n  current_timer = %ld , machine_t2 = %ld, calculate_timer = %ld \r\n",
                                    current_timer,port_info[ifindex-1].atc_broadcast_storm_entry.state_machine_t2, calculate_timer);
                            }
                        }
                    }
                    /* End of Debug message */

                 }
                /* Check 3. event: low flow.*/
                else
                {
                    swctrl_event = SWCTRL_ATCBSTORM_LOW_FLOW_EV;

                    /* Start of Debug message */
                    if (SWCTRL_BACKDOOR_IsDebugFlagATCOn(SWCTRL_BACKDOOR_DEBUG_FLAG_ATC_BROADCAST_EVENT))
                    {
                        if (port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_auto_traffic_control_on == VAL_atcBcastStormEnable_enabled)
                        {
                            BACKDOOR_MGR_Printf("\r\n Analyser: Bcast, EV, index = %ld, low_flow, state = ???, swctrl_event =LOW= %ld \r\n", ifindex, swctrl_event);
                        }
                    }
                    /* End of Debug message */

                }

                break;

            case 2: /* middle flow */
                /* Check 1. (1)state = control_low, (2)!manual, => event: middle flow. */
                /*          (1)state = control_low, (2)manual, => event: no event. */
                /* Check 2. event: middle flow. */

                 /* Check 1. (1)state = control_low, (2)!manual, => event: middle flow. */
                /*          (1)state = control_low, (2)manual, => event: no event. */
                if (port_info[ifindex-1].atc_broadcast_storm_entry.state_machine_state == SWCTRL_ATCBSTORM_CONTROLLOW_ST)
                {
                    if (port_info[ifindex-1].atc_broadcast_storm_entry.state_machine_manual != SWCTRL_ATC_BROADCAST_STORM_STATE_MACHINE_MANUAL_ENABLE)
                    {
                        swctrl_event = SWCTRL_ATCBSTORM_MIDDLE_FLOW_EV;
                    }
                    else
                    {
                        swctrl_event = SWCTRL_ATCBSTORM_NO_EV;
                    }

                    /* Start of Debug message */
                    if (SWCTRL_BACKDOOR_IsDebugFlagATCOn(SWCTRL_BACKDOOR_DEBUG_FLAG_ATC_BROADCAST_EVENT))
                    {
                        if (port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_auto_traffic_control_on == VAL_atcBcastStormEnable_enabled)
                        {
                            if (swctrl_event == SWCTRL_ATCBSTORM_MIDDLE_FLOW_EV)
                            {
                                BACKDOOR_MGR_Printf("\r\n Analyser: Bcast, EV, index = %ld, middle_flow, state = control_low, swctrl_event =MIDDLE= %ld \r\n", ifindex, swctrl_event);
                            }
                            else if (swctrl_event == SWCTRL_ATCBSTORM_NO_EV)
                            {
                                BACKDOOR_MGR_Printf("\r\n Analyser: Bcast, EV, index = %ld, middle_flow, state = control_low, swctrl_event =NO= %ld \r\n", ifindex, swctrl_event);
                            }
                        }
                    }
                    /* End of Debug message */

                }
                /* Check 2. event: middle flow. */
                else
                {
                    swctrl_event = SWCTRL_ATCBSTORM_MIDDLE_FLOW_EV;

                    /* Start of Debug message */
                    if (SWCTRL_BACKDOOR_IsDebugFlagATCOn(SWCTRL_BACKDOOR_DEBUG_FLAG_ATC_BROADCAST_EVENT))
                    {
                        if (port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_auto_traffic_control_on == VAL_atcBcastStormEnable_enabled)
                        {
                            BACKDOOR_MGR_Printf("\r\n Analyser: Bcast, EV, index = %ld, middle_flow, state = ???, swctrl_event =MIDDLE= %ld \r\n", ifindex, swctrl_event);
                        }
                    }
                    /* End of Debug message */

                }
                break;

            case 3: /* high flow */
                /* Check 1. (1)state = high, (2)!t1, (3)t1 is expired, =>event: timer on. */
                /*          (1).state = high, (2)!t1, (3)t1 is not expired, => event: no event. */
                /* Check 2. (1)state = control_low, (2)!manual, => event: high flow. */
                /*          (1)state = control_low, (2)manual, => event: no event. */
                /* Check 3. event: high flow. */

                /* Check 1. (1)state = high, (2)!t1, (3)t1 is expired, =>event: timer on. */
                /*          (1).state = high, (2)!t1, (3)t1 is not expired, => event: no event. */
                if ( (port_info[ifindex-1].atc_broadcast_storm_entry.state_machine_state == SWCTRL_ATCBSTORM_HIGH_ST) &&
                    (port_info[ifindex-1].atc_broadcast_storm_entry.state_machine_t1 != 0) )
                {
                    current_timer = SYSFUN_GetSysTick();
                    limit_timer = 0xffffffff;
                    if (port_info[ifindex-1].atc_broadcast_storm_entry.state_machine_t1 >= (limit_timer - (100 * atc_broadcast_storm_timer.atc_broadcast_storm_traffic_control_on_timer)) )
                    {
                        calculate_timer = current_timer + (limit_timer -port_info[ifindex-1].atc_broadcast_storm_entry.state_machine_t1);
                    }
                    else
                    {
                        calculate_timer = current_timer -port_info[ifindex-1].atc_broadcast_storm_entry.state_machine_t1;
                    }

                    if (calculate_timer >= (100 * atc_broadcast_storm_timer.atc_broadcast_storm_traffic_control_on_timer))
                    {
                        /* When send Timer On event, check the manual release whether it is enable. */
                        if ( ( (port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_action == VAL_atcBcastStormTcAction_rate_control) &&
                            (port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_auto_traffic_control_release == VAL_atcBcastStormAutoRelease_disabled) )
                            ||
                            (port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_action == VAL_atcBcastStormTcAction_shutdown) )
                        {
                            port_info[ifindex-1].atc_broadcast_storm_entry.state_machine_manual = SWCTRL_ATC_BROADCAST_STORM_STATE_MACHINE_MANUAL_ENABLE;
                        }
                        else
                        {
                            port_info[ifindex-1].atc_broadcast_storm_entry.state_machine_manual = SWCTRL_ATC_BROADCAST_STORM_STATE_MACHINE_MANUAL_DISABLE;
                        }
                        /* Fix the action value. */
                        port_info[ifindex-1].atc_broadcast_storm_entry.state_machine_action =  port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_action;
                        /* Send timer on event. */
                        swctrl_event = SWCTRL_ATCBSTORM_TIMER_ON_EV;
                    }
                    else
                    {
                        swctrl_event = SWCTRL_ATCBSTORM_NO_EV;
                    }

                    /* Start of Debug message */
                    if (SWCTRL_BACKDOOR_IsDebugFlagATCOn(SWCTRL_BACKDOOR_DEBUG_FLAG_ATC_BROADCAST_EVENT))
                    {
                        if (port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_auto_traffic_control_on == VAL_atcBcastStormEnable_enabled)
                        {
                            if (swctrl_event == SWCTRL_ATCBSTORM_TIMER_ON_EV)
                            {
                                BACKDOOR_MGR_Printf("\r\n Analyser: Bcast, EV, index = %ld, high_flow, state = high, swctrl_event =TIMER_ON= %ld \r\n", ifindex, swctrl_event);
                                BACKDOOR_MGR_Printf("\r\n  current_timer = %ld , machine_t1 = %ld, calculate_timer =%ld \r\n",
                                    current_timer,port_info[ifindex-1].atc_broadcast_storm_entry.state_machine_t1, calculate_timer);
                                BACKDOOR_MGR_Printf("\r\n  state_machine_manual = %ld , state_machine_action = %ld \r\n",
                                    port_info[ifindex-1].atc_broadcast_storm_entry.state_machine_manual,
                                    port_info[ifindex-1].atc_broadcast_storm_entry.state_machine_action);
                            }
                            else if (swctrl_event == SWCTRL_ATCBSTORM_NO_EV)
                            {
                                BACKDOOR_MGR_Printf("\r\n Analyser: Bcast, EV, index = %ld, high_flow, state = high, swctrl_event =NO= %ld \r\n", ifindex, swctrl_event);
                                BACKDOOR_MGR_Printf("\r\n  current_timer = %ld , machine_t1 = %ld, calculate_timer =%ld \r\n",
                                    current_timer,port_info[ifindex-1].atc_broadcast_storm_entry.state_machine_t1, calculate_timer);
                            }
                        }
                    }
                    /* End of Debug message */

                }
                /* Check 2. (1)state = control_low, (2)!manual, => event: high flow. */
                /*          (1)state = control_low, (2)manual, => event: no event. */
                else if (port_info[ifindex-1].atc_broadcast_storm_entry.state_machine_state == SWCTRL_ATCBSTORM_CONTROLLOW_ST)
                {
                    if (port_info[ifindex-1].atc_broadcast_storm_entry.state_machine_manual != SWCTRL_ATC_BROADCAST_STORM_STATE_MACHINE_MANUAL_ENABLE)
                    {
                        swctrl_event = SWCTRL_ATCBSTORM_HIGH_FLOW_EV;
                    }
                    else
                    {
                        swctrl_event = SWCTRL_ATCBSTORM_NO_EV;
                    }

                    /* Start of Debug message */
                    if (SWCTRL_BACKDOOR_IsDebugFlagATCOn(SWCTRL_BACKDOOR_DEBUG_FLAG_ATC_BROADCAST_EVENT))
                    {
                        if (port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_auto_traffic_control_on == VAL_atcBcastStormEnable_enabled)
                        {
                            if (swctrl_event == SWCTRL_ATCBSTORM_HIGH_FLOW_EV)
                            {
                                BACKDOOR_MGR_Printf("\r\n Analyser: Bcast, EV, index = %ld, high_flow, state = control_low, swctrl_event =HIGH= %ld \r\n", ifindex, swctrl_event);
                                BACKDOOR_MGR_Printf("\r\n  state_machine_manual = %ld , state_machine_action = %ld \r\n",
                                    port_info[ifindex-1].atc_broadcast_storm_entry.state_machine_manual,
                                    port_info[ifindex-1].atc_broadcast_storm_entry.state_machine_action);
                            }
                            else if (swctrl_event == SWCTRL_ATCBSTORM_NO_EV)
                            {
                                BACKDOOR_MGR_Printf("\r\n Analyser: Bcast, EV, index = %ld, high_flow, state = control_low, swctrl_event =NO= %ld \r\n", ifindex, swctrl_event);
                            }
                        }
                    }
                    /* End of Debug message */

                }
                /* Check 3. event: high flow. */
                else
                {
                    swctrl_event = SWCTRL_ATCBSTORM_HIGH_FLOW_EV;

                    /* Start of Debug message */
                    if (SWCTRL_BACKDOOR_IsDebugFlagATCOn(SWCTRL_BACKDOOR_DEBUG_FLAG_ATC_BROADCAST_EVENT))
                    {
                        if (port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_auto_traffic_control_on == VAL_atcBcastStormEnable_enabled)
                        {
                            BACKDOOR_MGR_Printf("\r\n Analyser: Bcast, EV, index = %ld, high_flow, state = ???, swctrl_event =HIGH= %ld \r\n", ifindex, swctrl_event);
                        }
                    }
                    /* End of Debug message */

                }
                break;

            default:
                break;

        }

        /* 5. Sent event. */
        if (swctrl_event != SWCTRL_ATCBSTORM_NO_EV)
        {
            SWCTRL_ATCBroadcastStormProtectionFSM(ifindex, swctrl_event);
        }
    }
#endif /* End of #if (SYS_CPNT_ATC_BSTORM  == TRUE) */
    /* End of 5. Get the event according to ATC Broadcast Storm and then send the event. */

    /* 6. Get the event according to ATC Multicast Storm and then send the event. */
#if (SYS_CPNT_ATC_MSTORM  == TRUE)
    for(ifindex = 1;
        ifindex <= SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK * SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT;
        ifindex++)
    {
        if (bypass_analyzer[ifindex-1])
        {
            continue;
        }

        /* 1. Check auto-traffic-control status. */
        if( port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_auto_traffic_control_on == VAL_atcMcastStormEnable_disabled)
        {
        continue;
        }

        /* 2. Initialize the swctrl event. */
        swctrl_event = SWCTRL_ATCMSTORM_NO_EV; /* It does not send the event to FSM. */

        /* 3. Get current packet rate. */
        port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_current_traffic_rate = swctrl_different_counter[ifindex-1].ifInMulticastPkts;

        /* 4. Get traffic flow level and Estimate the type of events. */
        if (swctrl_different_counter[ifindex-1].ifInMulticastPkts <= port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_storm_clear_threshold)
        {
            traffic_flow_level = 1;
        }
        else if (swctrl_different_counter[ifindex-1].ifInMulticastPkts < port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_storm_alarm_threshold)
        {
            traffic_flow_level = 2;
        }
        else if (swctrl_different_counter[ifindex-1].ifInMulticastPkts >= port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_storm_alarm_threshold)
        {
            traffic_flow_level = 3;
        }

        switch(traffic_flow_level)
        {
            case 1: /* low flow */
                /* Check 1. (1)state = control, (2)!manual, => event: low flow. */
                /*               (1)state = control, (2)manual, => event: no event. */
                /* Check 2. (1)state = control_low, (2)!t2, (3)t2 is expired, => event: timer release. */
                /*               (1)state = control_low, (2)!t2, (3)t2 is not expired, => event: no event. */
                /* Check 3. event: low flow.*/

                /* Check 1. (1)state = control, (2)!manual, => event: low flow. */
                /*               (1)state = control, (2)manual, => event: no event. */
                if (port_info[ifindex-1].atc_multicast_storm_entry.state_machine_state == SWCTRL_ATCMSTORM_CONTROL_ST)
                {
                    if (port_info[ifindex-1].atc_multicast_storm_entry.state_machine_manual != SWCTRL_ATC_MULTICAST_STORM_STATE_MACHINE_MANUAL_ENABLE)
                    {
                        swctrl_event = SWCTRL_ATCMSTORM_LOW_FLOW_EV;
                    }
                    else
                    {
                        swctrl_event = SWCTRL_ATCMSTORM_NO_EV;
                    }

                    /* Start of Debug message */
                    if (SWCTRL_BACKDOOR_IsDebugFlagATCOn(SWCTRL_BACKDOOR_DEBUG_FLAG_ATC_MULTICAST_EVENT))
                    {
                        if (port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_auto_traffic_control_on == VAL_atcMcastStormEnable_enabled)
                        {
                            if (swctrl_event == SWCTRL_ATCMSTORM_LOW_FLOW_EV)
                            {
                                BACKDOOR_MGR_Printf("\r\n Analyser: Mcast, EV, index = %ld, low_flow, state = control, swctrl_event =LOW= %ld \r\n", ifindex, swctrl_event);
                            }
                            else if (swctrl_event == SWCTRL_ATCMSTORM_NO_EV)
                            {
                                BACKDOOR_MGR_Printf("\r\n Analyser: Mcast, EV, index = %ld, low_flow, state = control, swctrl_event =NO= %ld \r\n", ifindex, swctrl_event);
                            }

                        }
                    }
                    /* End of Debug message */

                }
                /* Check 2. (1)state = control_low, (2)!t2, (3)t2 is expired, => event: timer release. */
                /*               (1)state = control_low, (2)!t2, (3)t2 is not expired, => event: no event. */
                else if ( (port_info[ifindex-1].atc_multicast_storm_entry.state_machine_state == SWCTRL_ATCMSTORM_CONTROLLOW_ST) &&
                     (port_info[ifindex-1].atc_multicast_storm_entry.state_machine_t2 != 0) )
                 {
                     current_timer = SYSFUN_GetSysTick();
                     limit_timer = 0xffffffff;
                     if (port_info[ifindex-1].atc_multicast_storm_entry.state_machine_t2 >= (limit_timer - (100 * atc_multicast_storm_timer.atc_multicast_storm_traffic_control_release_timer)) )
                     {
                         calculate_timer = current_timer + (limit_timer -port_info[ifindex-1].atc_multicast_storm_entry.state_machine_t2);
                     }
                     else
                     {
                         calculate_timer = current_timer -port_info[ifindex-1].atc_multicast_storm_entry.state_machine_t2;
                     }

                     if (calculate_timer >= (100 * atc_multicast_storm_timer.atc_multicast_storm_traffic_control_release_timer))
                     {
                         swctrl_event = SWCTRL_ATCMSTORM_TIMER_RELEASE_EV;
                     }
                    else
                    {
                        swctrl_event = SWCTRL_ATCMSTORM_NO_EV;
                    }

                    /* Start of Debug message */
                    if (SWCTRL_BACKDOOR_IsDebugFlagATCOn(SWCTRL_BACKDOOR_DEBUG_FLAG_ATC_MULTICAST_EVENT))
                    {
                        if (port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_auto_traffic_control_on == VAL_atcMcastStormEnable_enabled)
                        {
                            if (swctrl_event == SWCTRL_ATCMSTORM_LOW_FLOW_EV)
                            {
                                BACKDOOR_MGR_Printf("\r\n Analyser: Mcast, EV, index = %ld, low_flow, state = control_low, swctrl_event =LOW=%ld \r\n", ifindex, swctrl_event);
                                BACKDOOR_MGR_Printf("\r\n  current_timer = %ld , machine_t2 = %ld, calculate_timer =%ld \r\n",
                                    current_timer,port_info[ifindex-1].atc_multicast_storm_entry.state_machine_t2, calculate_timer);
                            }
                            else if (swctrl_event == SWCTRL_ATCMSTORM_NO_EV)
                            {
                                BACKDOOR_MGR_Printf("\r\n Analyser: Mcast, EV, index = %ld, low_flow, state = control_low, swctrl_event =NO= %ld \r\n", ifindex, swctrl_event);
                                BACKDOOR_MGR_Printf("\r\n  current_timer = %ld , machine_t2 = %ld, calculate_timer = %ld \r\n",
                                    current_timer,port_info[ifindex-1].atc_multicast_storm_entry.state_machine_t2, calculate_timer);
                            }
                        }
                    }
                    /* End of Debug message */

                 }
                /* Check 3. event: low flow.*/
                else
                {
                    swctrl_event = SWCTRL_ATCMSTORM_LOW_FLOW_EV;

                    /* Start of Debug message */
                    if (SWCTRL_BACKDOOR_IsDebugFlagATCOn(SWCTRL_BACKDOOR_DEBUG_FLAG_ATC_MULTICAST_EVENT))
                    {
                        if (port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_auto_traffic_control_on == VAL_atcMcastStormEnable_enabled)
                        {
                            BACKDOOR_MGR_Printf("\r\n Analyser: Mcast, EV, index = %ld, low_flow, state = ???, swctrl_event =LOW= %ld \r\n", ifindex, swctrl_event);
                        }
                    }
                    /* End of Debug message */

                }

                break;

            case 2: /* middle flow */
                /* Check 1. (1)state = control_low, (2)!manual, => event: middle flow. */
                /*          (1)state = control_low, (2)manual, => event: no event. */
                /* Check 2. event: middle flow. */

                 /* Check 1. (1)state = control_low, (2)!manual, => event: middle flow. */
                /*          (1)state = control_low, (2)manual, => event: no event. */
                if (port_info[ifindex-1].atc_multicast_storm_entry.state_machine_state == SWCTRL_ATCMSTORM_CONTROLLOW_ST)
                {
                    if (port_info[ifindex-1].atc_multicast_storm_entry.state_machine_manual != SWCTRL_ATC_MULTICAST_STORM_STATE_MACHINE_MANUAL_ENABLE)
                    {
                        swctrl_event = SWCTRL_ATCMSTORM_MIDDLE_FLOW_EV;
                    }
                    else
                    {
                        swctrl_event = SWCTRL_ATCMSTORM_NO_EV;
                    }

                    /* Start of Debug message */
                    if (SWCTRL_BACKDOOR_IsDebugFlagATCOn(SWCTRL_BACKDOOR_DEBUG_FLAG_ATC_MULTICAST_EVENT))
                    {
                        if (port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_auto_traffic_control_on == VAL_atcMcastStormEnable_enabled)
                        {
                            if (swctrl_event == SWCTRL_ATCMSTORM_MIDDLE_FLOW_EV)
                            {
                                BACKDOOR_MGR_Printf("\r\n Analyser: Mcast, EV, index = %ld, middle_flow, state = control_low, swctrl_event =MIDDLE= %ld \r\n", ifindex, swctrl_event);
                            }
                            else if (swctrl_event == SWCTRL_ATCMSTORM_NO_EV)
                            {
                                BACKDOOR_MGR_Printf("\r\n Analyser: Mcast, EV, index = %ld, middle_flow, state = control_low, swctrl_event =NO= %ld \r\n", ifindex, swctrl_event);
                            }
                        }
                    }
                    /* End of Debug message */

                }
                /* Check 2. event: middle flow. */
                else
                {
                    swctrl_event = SWCTRL_ATCMSTORM_MIDDLE_FLOW_EV;

                    /* Start of Debug message */
                    if (SWCTRL_BACKDOOR_IsDebugFlagATCOn(SWCTRL_BACKDOOR_DEBUG_FLAG_ATC_MULTICAST_EVENT))
                    {
                        if (port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_auto_traffic_control_on == VAL_atcMcastStormEnable_enabled)
                        {
                            BACKDOOR_MGR_Printf("\r\n Analyser: Mcast, EV, index = %ld, middle_flow, state = ???, swctrl_event =MIDDLE= %ld \r\n", ifindex, swctrl_event);
                        }
                    }
                    /* End of Debug message */

                }
                break;

            case 3: /* high flow */
                /* Check 1. (1)state = high, (2)!t1, (3)t1 is expired, =>event: timer on. */
                /*          (1).state = high, (2)!t1, (3)t1 is not expired, => event: no event. */
                /* Check 2. (1)state = control_low, (2)!manual, => event: high flow. */
                /*          (1)state = control_low, (2)manual, => event: no event. */
                /* Check 3. event: high flow. */

                /* Check 1. (1)state = high, (2)!t1, (3)t1 is expired, =>event: timer on. */
                /*          (1).state = high, (2)!t1, (3)t1 is not expired, => event: no event. */
                if ( (port_info[ifindex-1].atc_multicast_storm_entry.state_machine_state == SWCTRL_ATCMSTORM_HIGH_ST) &&
                    (port_info[ifindex-1].atc_multicast_storm_entry.state_machine_t1 != 0) )
                {
                    current_timer = SYSFUN_GetSysTick();
                    limit_timer = 0xffffffff;
                    if (port_info[ifindex-1].atc_multicast_storm_entry.state_machine_t1 >= (limit_timer - (100 * atc_multicast_storm_timer.atc_multicast_storm_traffic_control_on_timer)) )
                    {
                        calculate_timer = current_timer + (limit_timer -port_info[ifindex-1].atc_multicast_storm_entry.state_machine_t1);
                    }
                    else
                    {
                        calculate_timer = current_timer -port_info[ifindex-1].atc_multicast_storm_entry.state_machine_t1;
                    }

                    if (calculate_timer >= (100 * atc_multicast_storm_timer.atc_multicast_storm_traffic_control_on_timer))
                    {
                        /* When send Timer On event, check the manual release whether it is enable. */
                        if ( ( (port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_action == VAL_atcMcastStormTcAction_rate_control) &&
                            (port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_auto_traffic_control_release == VAL_atcMcastStormAutoRelease_disabled) )
                            ||
                            (port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_action == VAL_atcMcastStormTcAction_shutdown) )
                        {
                            port_info[ifindex-1].atc_multicast_storm_entry.state_machine_manual = SWCTRL_ATC_MULTICAST_STORM_STATE_MACHINE_MANUAL_ENABLE;
                        }
                        else
                        {
                            port_info[ifindex-1].atc_multicast_storm_entry.state_machine_manual = SWCTRL_ATC_MULTICAST_STORM_STATE_MACHINE_MANUAL_DISABLE;
                        }
                        /* Fix the action value. */
                        port_info[ifindex-1].atc_multicast_storm_entry.state_machine_action =  port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_action;
                        /* Send timer on event. */
                        swctrl_event = SWCTRL_ATCMSTORM_TIMER_ON_EV;
                    }
                    else
                    {
                        swctrl_event = SWCTRL_ATCMSTORM_NO_EV;
                    }

                    /* Start of Debug message */
                    if (SWCTRL_BACKDOOR_IsDebugFlagATCOn(SWCTRL_BACKDOOR_DEBUG_FLAG_ATC_MULTICAST_EVENT))
                    {
                        if (port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_auto_traffic_control_on == VAL_atcMcastStormEnable_enabled)
                        {
                            if (swctrl_event == SWCTRL_ATCMSTORM_TIMER_ON_EV)
                            {
                                BACKDOOR_MGR_Printf("\r\n Analyser: Mcast, EV, index = %ld, high_flow, state = high, swctrl_event =TIMER_ON= %ld \r\n", ifindex, swctrl_event);
                                BACKDOOR_MGR_Printf("\r\n  current_timer = %ld , machine_t1 = %ld, calculate_timer =%ld \r\n",
                                    current_timer,port_info[ifindex-1].atc_multicast_storm_entry.state_machine_t1, calculate_timer);
                                BACKDOOR_MGR_Printf("\r\n  state_machine_manual = %ld , state_machine_action = %ld \r\n",
                                    port_info[ifindex-1].atc_multicast_storm_entry.state_machine_manual,
                                    port_info[ifindex-1].atc_multicast_storm_entry.state_machine_action);
                            }
                            else if (swctrl_event == SWCTRL_ATCMSTORM_NO_EV)
                            {
                                BACKDOOR_MGR_Printf("\r\n Analyser: Mcast, EV, index = %ld, high_flow, state = high, swctrl_event =NO= %ld \r\n", ifindex, swctrl_event);
                                BACKDOOR_MGR_Printf("\r\n  current_timer = %ld , machine_t1 = %ld, calculate_timer =%ld \r\n",
                                    current_timer,port_info[ifindex-1].atc_multicast_storm_entry.state_machine_t1, calculate_timer);
                            }
                        }
                    }
                    /* End of Debug message */

                }
                /* Check 2. (1)state = control_low, (2)!manual, => event: high flow. */
                /*          (1)state = control_low, (2)manual, => event: no event. */
                else if (port_info[ifindex-1].atc_multicast_storm_entry.state_machine_state == SWCTRL_ATCMSTORM_CONTROLLOW_ST)
                {
                    if (port_info[ifindex-1].atc_multicast_storm_entry.state_machine_manual != SWCTRL_ATC_MULTICAST_STORM_STATE_MACHINE_MANUAL_ENABLE)
                    {
                        swctrl_event = SWCTRL_ATCMSTORM_HIGH_FLOW_EV;
                    }
                    else
                    {
                        swctrl_event = SWCTRL_ATCMSTORM_NO_EV;
                    }

                    /* Start of Debug message */
                    if (SWCTRL_BACKDOOR_IsDebugFlagATCOn(SWCTRL_BACKDOOR_DEBUG_FLAG_ATC_MULTICAST_EVENT))
                    {
                        if (port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_auto_traffic_control_on == VAL_atcMcastStormEnable_enabled)
                        {
                            if (swctrl_event == SWCTRL_ATCMSTORM_HIGH_FLOW_EV)
                            {
                                BACKDOOR_MGR_Printf("\r\n Analyser: Mcast, EV, index = %ld, high_flow, state = control_low, swctrl_event =HIGH= %ld \r\n", ifindex, swctrl_event);
                                BACKDOOR_MGR_Printf("\r\n  state_machine_manual = %ld , state_machine_action = %ld \r\n",
                                    port_info[ifindex-1].atc_multicast_storm_entry.state_machine_manual,
                                    port_info[ifindex-1].atc_multicast_storm_entry.state_machine_action);
                            }
                            else if (swctrl_event == SWCTRL_ATCMSTORM_NO_EV)
                            {
                                BACKDOOR_MGR_Printf("\r\n Analyser: Mcast, EV, index = %ld, high_flow, state = control_low, swctrl_event =NO= %ld \r\n", ifindex, swctrl_event);
                            }
                        }
                    }
                    /* End of Debug message */

                }
                /* Check 3. event: high flow. */
                else
                {
                    swctrl_event = SWCTRL_ATCMSTORM_HIGH_FLOW_EV;

                    /* Start of Debug message */
                    if (SWCTRL_BACKDOOR_IsDebugFlagATCOn(SWCTRL_BACKDOOR_DEBUG_FLAG_ATC_MULTICAST_EVENT))
                    {
                        if (port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_auto_traffic_control_on == VAL_atcMcastStormEnable_enabled)
                        {
                            BACKDOOR_MGR_Printf("\r\n Analyser: Mcast, EV, index = %ld, high_flow, state = ???, swctrl_event =HIGH= %ld \r\n", ifindex, swctrl_event);
                        }
                    }
                    /* End of Debug message */

                }
                break;

            default:
                break;

        }

        /* 5. Sent event. */
        if (swctrl_event != SWCTRL_ATCMSTORM_NO_EV)
        {
            SWCTRL_ATCMulticastStormProtectionFSM(ifindex, swctrl_event);
        }
    }
#endif /* End of #if (SYS_CPNT_ATC_MSTORM  == TRUE) */
    /* End of 6. Get the event according to ATC Multicast Storm and then send the event. */

    return TRUE;
}


#endif

/* ATC Broadcast Storm */
#if (SYS_CPNT_ATC_BSTORM == TRUE)
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetUPortATCBroadcastStormControlRateLimit
 * -------------------------------------------------------------------------
 * FUNCTION: This function will set the rate limit of broadcast
 *           storm control function
 * INPUT   : unit    -- which unit
 *           port    -- which port to set
 *           mode    -- which mode of rate
 *           rate    -- rate after conversion
 *           nRate   -- rate of broadcast amount
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
static BOOL_T SWCTRL_SetUPortATCBroadcastStormControlRateLimit(UI32_T unit,
                                                           UI32_T port,
                                                           UI32_T mode,
                                                           UI32_T rate,
                                                           UI32_T nRate)
{
    BOOL_T retval = FALSE;
    UI32_T i, start_ifindex, end_ifindex;
    UI32_T config_mode;

#if (SYS_CPNT_ATC_BSTORM_RATE_PER_PORT_CTRL == FALSE)
    start_ifindex = 1;
    end_ifindex = SYS_ADPT_TOTAL_NBR_OF_LPORT;
#else
    start_ifindex = SWCTRL_UPORT_TO_IFINDEX (unit, port);
    end_ifindex = start_ifindex;
#endif

    if (SWCTRL_IsSupportedStormType(mode))
    {
        config_mode = mode;
    }
    else
    {
        config_mode = SYS_DFLT_BCAST_STORM_MODE;
        SWCTRL_ConvertRateByStormType(SWCTRL_UPORT_TO_IFINDEX(unit, port), mode, rate, config_mode, &rate);
    }

    SWCTRL_LOCK();
    if((retval = SWDRV_SetATCBroadcastStormControlThreshold(unit, port, rate, config_mode)) == TRUE)
    {
        for(i = start_ifindex; i <= end_ifindex; i++)
        {
            port_info[i-1].atc_broadcast_storm_entry.atc_broadcast_storm_ifindex     = i;
            port_info[i-1].atc_broadcast_storm_entry.atc_broadcast_storm_sample_type = mode;
            port_info[i-1].atc_broadcast_storm_entry.atc_broadcast_storm_packet_rate    = 0;
            port_info[i-1].atc_broadcast_storm_entry.atc_broadcast_storm_octet_rate  = 0;
            port_info[i-1].atc_broadcast_storm_entry.atc_broadcast_storm_percent     = 0;
            switch (mode)
            {
                case VAL_atcBcastStormSampleType_packet_rate:
                port_info[i-1].atc_broadcast_storm_entry.atc_broadcast_storm_packet_rate = nRate;
                break;
                case VAL_atcBcastStormSampleType_octet_rate:
                port_info[i-1].atc_broadcast_storm_entry.atc_broadcast_storm_octet_rate = nRate;
                break;
                case VAL_atcBcastStormSampleType_percent:
                port_info[i-1].atc_broadcast_storm_entry.atc_broadcast_storm_percent = nRate;
                break;
            }
        }
    }
    SWCTRL_UNLOCK();

    return retval;
} /* End of SWCTRL_SetUPortATCBroadcastStormControlRateLimit() */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetUPortATCBroadcastStormStatus
 * -------------------------------------------------------------------------
 * FUNCTION: This function will enable the broadcast storm control function
 * INPUT   : unit -- which unit
 *           port -- which port to set
 *           atc_broadcast_storm_status -- VAL_atcBcastStormStatus_enabled
 *                                     VAL_atcBcastStormStatus_disabled
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
static BOOL_T SWCTRL_SetUPortATCBroadcastStormTrafficControlOnStatus(UI32_T unit,
                                                  UI32_T port,
                                                  UI32_T atc_broadcast_storm_status)
{
    BOOL_T retval = FALSE;
    UI32_T i, start_ifindex, end_ifindex;

#if (SYS_CPNT_ATC_BSTORM_ENABLE_PER_PORT == FALSE)
    start_ifindex = 1;
    end_ifindex = SYS_ADPT_TOTAL_NBR_OF_LPORT;
#else
    start_ifindex = SWCTRL_UPORT_TO_IFINDEX (unit, port);
    end_ifindex = start_ifindex;
#endif

    if(port_info[start_ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_traffic_control_on == atc_broadcast_storm_status)
    {
        return TRUE;
    }

    SWCTRL_LOCK();
    if (atc_broadcast_storm_status == SWCTRL_ATC_BROADCAST_STORM_TC_ON_ENABLE)
    {
        retval = SWDRV_EnableATCBroadcastStormControl (unit, port);
    }
    else /* SWCTRL_ATC_BROADCAST_STORM_TC_ON_DISABLE */
    {
        retval = TRUE;
    }

    if (retval)
    {
        for(i = start_ifindex; i <= end_ifindex; i++)
        {
            port_info[i-1].atc_broadcast_storm_entry.atc_broadcast_storm_traffic_control_on = atc_broadcast_storm_status;
        }
    }
    SWCTRL_UNLOCK();

    return retval;
} /* end of SWCTRL_SetUPortATCBroadcastStormTrafficControlOnStatus () */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetUPortATCBroadcastStormStatus
 * -------------------------------------------------------------------------
 * FUNCTION: This function will enable the broadcast storm control function
 * INPUT   : unit -- which unit
 *           port -- which port to set
 *           atc_broadcast_storm_status -- VAL_atcBcastStormStatus_enabled
 *                                     VAL_atcBcastStormStatus_disabled
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
static BOOL_T SWCTRL_SetUPortATCBroadcastStormTrafficControlReleaseStatus(UI32_T unit,
                                                  UI32_T port,
                                                  UI32_T atc_broadcast_storm_status)
{
    BOOL_T retval = FALSE;
    UI32_T i, start_ifindex, end_ifindex;

#if (SYS_CPNT_ATC_BSTORM_ENABLE_PER_PORT == FALSE)
    start_ifindex = 1;
    end_ifindex = SYS_ADPT_TOTAL_NBR_OF_LPORT;
#else
    start_ifindex = SWCTRL_UPORT_TO_IFINDEX (unit, port);
    end_ifindex = start_ifindex;
#endif

    if(port_info[start_ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_traffic_control_release == atc_broadcast_storm_status)
    {
        return TRUE;
    }

    SWCTRL_LOCK();
    if (atc_broadcast_storm_status == SWCTRL_ATC_BROADCAST_STORM_TC_RELEASE_ENABLE)
    {
        retval = SWDRV_DisableATCBroadcastStormControl (unit, port);
    }
    else /* SWCTRL_ATC_BROADCAST_STORM_TC_RELEASE_DISABLE */
    {
        retval = TRUE;
    }

    if (retval)
    {
        for(i = start_ifindex; i <= end_ifindex; i++)
        {
            port_info[i-1].atc_broadcast_storm_entry.atc_broadcast_storm_traffic_control_release = atc_broadcast_storm_status;
        }
    }
    SWCTRL_UNLOCK();

    return retval;
} /* end of SWCTRL_SetUPortATCBroadcastStormTrafficControlReleaseStatus () */

static BOOL_T SWCTRL_SetATCBroadcastStormFSMTrafficControlOnStatus(UI32_T ifindex, UI32_T action, UI32_T traffic_control_on_status)
{
    /* LOCAL VARIABLES
     */
    UI32_T                          unit, port;
    BOOL_T                          retval = FALSE;

    UI32_T                                                  threshold;
    /* BODY
     */
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    /* Start of Debug message */
    if (SWCTRL_BACKDOOR_IsDebugFlagATCOn(SWCTRL_BACKDOOR_DEBUG_FLAG_ATC_BROADCAST_EVENT))
    {
        BACKDOOR_MGR_Printf("\r\n SWCTRL_SetATCBroadcastStormFSMTrafficControlOnStatus: 1. ifindex = %ld , action = %ld,  traffic_control_on_status = %ld \r\n", ifindex, action, traffic_control_on_status);
    }
    /* End of Debug messag */

    if( ifindex == 0 || ifindex > SYS_ADPT_TOTAL_NBR_OF_LPORT)
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Logical Port ID (1-%d)", SYS_ADPT_TOTAL_NBR_OF_LPORT);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_LOGICAL_PORT_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (!SWCTRL_IS_EXIST (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Interface");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

#if (SYS_CPNT_ATC_BSTORM_SUPPORT_LPORT != TRUE)
    if (SWCTRL_IS_TRUNK (ifindex))
    {
            EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                      SWCTRL_NO_USE_FUNC_NO,
                                      EH_TYPE_MSG_TRUNK_CNFG_ERR,
                                      SYSLOG_LEVEL_INFO,
                                      "it doesn't support Broadcast Storm Control.");  /*SWCTRL_ENO_NOT_TRUNK*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#else
    if (SWCTRL_IS_TRUNK_MEMBER (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#endif

    if((traffic_control_on_status != SWCTRL_ATC_BROADCAST_STORM_TC_ON_ENABLE) &&
       (traffic_control_on_status != SWCTRL_ATC_BROADCAST_STORM_TC_ON_DISABLE))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_INVALID_PARAMETER,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "traffic control on status"); /*SWCTRL_ENO_INVALID_AUTO_TRAFFIC_CONTROL_ON_STATUS*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if(port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_traffic_control_on == traffic_control_on_status)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
    }

    if (SWCTRL_IsServerBladePort (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_SRV_BLADE_PORT_CNFG,
                                  SYSLOG_LEVEL_INFO,
                                  "Configuring Broadcast Storm Control");     /*SWCTRL_ENO_DENY_ON_SERVER_BLADE_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }


    /* if normal port
     */
    if(!SWCTRL_IS_TRUNK (ifindex))
    {
        unit = SWCTRL_IFINDEX_TO_UNIT(ifindex);
        port = SWCTRL_IFINDEX_TO_PORT(ifindex);

        if(traffic_control_on_status  == SWCTRL_ATC_BROADCAST_STORM_TC_ON_ENABLE)
        {
            if (action == VAL_atcBcastStormTcAction_rate_control)
            {

                /* Start of Debug message */
                if (SWCTRL_BACKDOOR_IsDebugFlagATCOn(SWCTRL_BACKDOOR_DEBUG_FLAG_ATC_BROADCAST_EVENT))
                {
                    BACKDOOR_MGR_Printf("\r\n SWCTRL_SetATCBroadcastStormFSMTrafficControlOnStatus: 2. TC_ON = enabled, action = rate-control \r\n");
                }
                /* End of Debug messag */

                threshold = (port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_storm_clear_threshold / SWCTRL_ATC_BROADCAST_STORM_ONE_THOUSAND);
                SWCTRL_SetATCBroadcastStormStormClearThreshold(ifindex, threshold);

                retval = SWCTRL_SetUPortATCBroadcastStormTrafficControlOnStatus(unit, port, traffic_control_on_status);

#if (SYS_CPNT_SWCTRL_SINGLE_INGRESS_RATE_LIMIT == TRUE)
                SWCTRL_SyncUPortATCStormControlRateLimit(unit, port);
#endif
            }
            else if (action == VAL_atcBcastStormTcAction_shutdown)
            {

                /* Start of Debug message */
                if (SWCTRL_BACKDOOR_IsDebugFlagATCOn(SWCTRL_BACKDOOR_DEBUG_FLAG_ATC_BROADCAST_EVENT))
                {
                    BACKDOOR_MGR_Printf("\r\n SWCTRL_SetATCBroadcastStormFSMTrafficControlOnStatus: 2. TC_ON = enabled, action = shutdown \r\n");
                }
                /* End of Debug messag */

                retval = SWCTRL_SetATCBroadcastStormPortOperationStatus(ifindex, VAL_ifOperStatus_down);
                if (retval)
                {
                    port_info[(SWCTRL_UPORT_TO_IFINDEX(unit, port)) - 1].atc_broadcast_storm_entry.atc_broadcast_storm_traffic_control_on = traffic_control_on_status;
                }
            }
        }
        else if(traffic_control_on_status  == SWCTRL_ATC_BROADCAST_STORM_TC_ON_DISABLE)
        {
                /* Start of Debug message */
                if (SWCTRL_BACKDOOR_IsDebugFlagATCOn(SWCTRL_BACKDOOR_DEBUG_FLAG_ATC_BROADCAST_EVENT))
                {
                    BACKDOOR_MGR_Printf("\r\n SWCTRL_SetATCBroadcastStormFSMTrafficControlOnStatus: 2. TC_ON = disabled \r\n");
                }
                /* End of Debug messag */

            SWCTRL_LOCK();
            port_info[(SWCTRL_UPORT_TO_IFINDEX(unit, port)) - 1].atc_broadcast_storm_entry.atc_broadcast_storm_traffic_control_on = traffic_control_on_status;
            SWCTRL_UNLOCK();
            retval = TRUE;
        }
    }

    /* if trunk port
     */
#if (SYS_CPNT_ATC_BSTORM_SUPPORT_LPORT == TRUE)
    if(SWCTRL_IS_TRUNK (ifindex))
    {
        SWCTRL_TrunkPortExtInfo_T trunk_ext_p_info;
        UI32_T                    i;

        memset(&trunk_ext_p_info, 0, sizeof(SWCTRL_TrunkPortExtInfo_T));
        SWCTRL_GetTrunkPortExtInfo (ifindex, &trunk_ext_p_info);

        for(i=0; i<trunk_ext_p_info.member_number; i++)
        {
            unit = trunk_ext_p_info.member_list[i].unit;
            port = trunk_ext_p_info.member_list[i].port;

            if(traffic_control_on_status  == SWCTRL_ATC_BROADCAST_STORM_TC_ON_ENABLE)
            {
                if (action == VAL_atcBcastStormTcAction_rate_control)
                {
                    retval = SWCTRL_SetUPortATCBroadcastStormTrafficControlOnStatus(unit, port, traffic_control_on_status);
#if (SYS_CPNT_SWCTRL_SINGLE_INGRESS_RATE_LIMIT == TRUE)
                    SWCTRL_SyncUPortATCStormControlRateLimit(unit, port);
#endif
                }
                else if (action == VAL_atcBcastStormTcAction_shutdown)
                {
                    retval = SWCTRL_SetATCBroadcastStormPortOperationStatus(ifindex, VAL_ifOperStatus_down);
                    if (retval)
                    {
                        port_info[(SWCTRL_UPORT_TO_IFINDEX(unit, port)) - 1].atc_broadcast_storm_entry.atc_broadcast_storm_traffic_control_on = traffic_control_on_status;
                    }
                }
                if (!retval)
                {
                    break;
                }
            }
            else if(traffic_control_on_status  == SWCTRL_ATC_BROADCAST_STORM_TC_ON_DISABLE)
            {
                SWCTRL_LOCK();
                port_info[(SWCTRL_UPORT_TO_IFINDEX(unit, port)) - 1].atc_broadcast_storm_entry.atc_broadcast_storm_traffic_control_on = traffic_control_on_status;
                SWCTRL_UNLOCK();
                retval = TRUE;
            }
        } /* End of for () */
        if (retval)
        {
            SWCTRL_LOCK();
            port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_traffic_control_on = traffic_control_on_status;
            SWCTRL_UNLOCK();
        }
    } /* End of trunk port */
#endif /* End of (SYS_CPNT_ATC_BSTORM_SUPPORT_LPORT == TRUE) */

    SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME ();
    SWCTRL_RETURN_AND_RELEASE_CSC( retval );
}

static BOOL_T SWCTRL_SetATCBroadcastStormFSMTrafficControlReleaseStatus(UI32_T ifindex, UI32_T action, UI32_T traffic_control_release_status)
{
    /* LOCAL VARIABLES
     */
    UI32_T                          unit, port;
    BOOL_T                          retval = FALSE;

    /* BODY
     */
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    /* Start of Debug message */
    if (SWCTRL_BACKDOOR_IsDebugFlagATCOn(SWCTRL_BACKDOOR_DEBUG_FLAG_ATC_BROADCAST_EVENT))
    {
        BACKDOOR_MGR_Printf("\r\n SWCTRL_SetATCBroadcastStormFSMTrafficControlReleaseStatus: 1. ifindex = %ld , action = %ld,  traffic_control_release_status = %ld \r\n", ifindex, action, traffic_control_release_status);
    }
    /* End of Debug messag */

    if( ifindex == 0 || ifindex > SYS_ADPT_TOTAL_NBR_OF_LPORT)
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Logical Port ID (1-%d)", SYS_ADPT_TOTAL_NBR_OF_LPORT);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_LOGICAL_PORT_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (!SWCTRL_IS_EXIST (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Interface");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

#if (SYS_CPNT_ATC_BSTORM_SUPPORT_LPORT == TRUE)
    if (SWCTRL_IS_TRUNK_MEMBER (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#endif

    if((traffic_control_release_status != SWCTRL_ATC_BROADCAST_STORM_TC_RELEASE_ENABLE) &&
       (traffic_control_release_status != SWCTRL_ATC_BROADCAST_STORM_TC_RELEASE_DISABLE))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_INVALID_PARAMETER,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "traffic control release status"); /*SWCTRL_ENO_INVALID_AUTO_TRAFFIC_CONTROL_RELEASE_STATUS*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if(port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_traffic_control_release == traffic_control_release_status)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
    }

    if (SWCTRL_IsServerBladePort (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_SRV_BLADE_PORT_CNFG,
                                  SYSLOG_LEVEL_INFO,
                                  "Configuring Broadcast Storm Control");     /*SWCTRL_ENO_DENY_ON_SERVER_BLADE_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }


    /* if normal port
     */
    if(!SWCTRL_IS_TRUNK (ifindex))
    {
        unit = SWCTRL_IFINDEX_TO_UNIT(ifindex);
        port = SWCTRL_IFINDEX_TO_PORT(ifindex);

        if(traffic_control_release_status  == SWCTRL_ATC_BROADCAST_STORM_TC_RELEASE_ENABLE)
        {
            if (action == VAL_atcBcastStormTcAction_rate_control)
            {

                /* Start of Debug message */
                if (SWCTRL_BACKDOOR_IsDebugFlagATCOn(SWCTRL_BACKDOOR_DEBUG_FLAG_ATC_BROADCAST_EVENT))
                {
                    BACKDOOR_MGR_Printf("\r\n SWCTRL_SetATCBroadcastStormFSMTrafficControlReleaeStatus: 2. TC_RELEASE = enabled, action = rate-control \r\n");
                }
                /* End of Debug messag */

                retval = SWCTRL_SetUPortATCBroadcastStormTrafficControlReleaseStatus(unit, port, traffic_control_release_status);
#if (SYS_CPNT_SWCTRL_SINGLE_INGRESS_RATE_LIMIT == TRUE)
                SWCTRL_SyncUPortATCStormControlRateLimit(unit, port);
#endif
            }
            else if (action == VAL_atcBcastStormTcAction_shutdown)
            {

                /* Start of Debug message */
                if (SWCTRL_BACKDOOR_IsDebugFlagATCOn(SWCTRL_BACKDOOR_DEBUG_FLAG_ATC_BROADCAST_EVENT))
                {
                    BACKDOOR_MGR_Printf("\r\n SWCTRL_SetATCBroadcastStormFSMTrafficControlReleaeStatus: 2. TC_RELEASE = enabled, action = shutdown \r\n");
                }
                /* End of Debug messag */

                retval = SWCTRL_SetATCBroadcastStormPortOperationStatus(ifindex, VAL_ifOperStatus_up);
                if (retval)
                {
                    port_info[(SWCTRL_UPORT_TO_IFINDEX(unit, port)) - 1].atc_broadcast_storm_entry.atc_broadcast_storm_traffic_control_release = traffic_control_release_status;
                }
            }
        }
        else if(traffic_control_release_status  == SWCTRL_ATC_BROADCAST_STORM_TC_RELEASE_DISABLE)
        {

            /* Start of Debug message */
            if (SWCTRL_BACKDOOR_IsDebugFlagATCOn(SWCTRL_BACKDOOR_DEBUG_FLAG_ATC_BROADCAST_EVENT))
            {
                BACKDOOR_MGR_Printf("\r\n SWCTRL_SetATCBroadcastStormFSMTrafficControlReleaeStatus: 2. TC_RELEASE = disabled \r\n");
            }
            /* End of Debug messag */

            SWCTRL_LOCK();
            port_info[(SWCTRL_UPORT_TO_IFINDEX(unit, port)) - 1].atc_broadcast_storm_entry.atc_broadcast_storm_traffic_control_release = traffic_control_release_status;
            SWCTRL_UNLOCK();
            retval = TRUE;
        }
    }

    /* if trunk port
     */
#if (SYS_CPNT_ATC_BSTORM_SUPPORT_LPORT == TRUE)
    if(SWCTRL_IS_TRUNK (ifindex))
    {
        SWCTRL_TrunkPortExtInfo_T trunk_ext_p_info;
        UI32_T                    i;

        memset(&trunk_ext_p_info, 0, sizeof(SWCTRL_TrunkPortExtInfo_T));
        SWCTRL_GetTrunkPortExtInfo (ifindex, &trunk_ext_p_info);

        for(i=0; i<trunk_ext_p_info.member_number; i++)
        {
            unit = trunk_ext_p_info.member_list[i].unit;
            port = trunk_ext_p_info.member_list[i].port;

            if(traffic_control_release_status  == SWCTRL_ATC_BROADCAST_STORM_TC_RELEASE_ENABLE)
            {
                if (action == VAL_atcBcastStormTcAction_rate_control)
                {
                    retval = SWCTRL_SetUPortATCBroadcastStormTrafficControlReleaseStatus(unit, port, traffic_control_release_status);
#if (SYS_CPNT_SWCTRL_SINGLE_INGRESS_RATE_LIMIT == TRUE)
                    SWCTRL_SyncUPortATCStormControlRateLimit(unit, port);
#endif
                }
                else if (action == VAL_atcBcastStormTcAction_shutdown)
                {
                    retval = SWCTRL_SetATCBroadcastStormPortOperationStatus(ifindex, VAL_ifOperStatus_up);
                    if (retval)
                    {
                        port_info[(SWCTRL_UPORT_TO_IFINDEX(unit, port)) - 1].atc_broadcast_storm_entry.atc_broadcast_storm_traffic_control_release = traffic_control_release_status;
                    }
                }
                if (!retval)
                {
                    break;
                }
            }
            else if(traffic_control_release_status  == SWCTRL_ATC_BROADCAST_STORM_TC_RELEASE_DISABLE)
            {
                SWCTRL_LOCK();
                port_info[(SWCTRL_UPORT_TO_IFINDEX(unit, port)) - 1].atc_broadcast_storm_entry.atc_broadcast_storm_traffic_control_release = traffic_control_release_status;
                SWCTRL_UNLOCK();
                retval = TRUE;
            }
        } /* End of for () */
        if (retval)
        {
            SWCTRL_LOCK();
            port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_traffic_control_release = traffic_control_release_status;
            SWCTRL_UNLOCK();
        }
    } /* End of trunk port */
#endif /* End of (SYS_CPNT_ATC_BSTORM_SUPPORT_LPORT == TRUE) */

    SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME ();
    SWCTRL_RETURN_AND_RELEASE_CSC( retval );
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_ProcessATCBroadcastStormTrafficControlReleasePassively
 * -------------------------------------------------------------------------
 * FUNCTION: This function will be executed when ATC port admin status is
 *           enabled by someone. (ex. "no shutdown" by user)
 * INPUT   : ifindex -- which port to set
 *           traffic_control_release_status    -- which status of traffic control release
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
static BOOL_T SWCTRL_ProcessATCBroadcastStormTrafficControlReleasePassively(UI32_T ifindex)
{
    BOOL_T retval = FALSE;

#if (SYS_CPNT_ATC_BSTORM_SUPPORT_LPORT != TRUE)
    if (SWCTRL_IS_TRUNK (ifindex))
    {
        SWCTRL_TrunkPortExtInfo_T trunk_ext_p_info;
        int i;

        SWCTRL_GetTrunkPortExtInfo (ifindex, &trunk_ext_p_info);

        for(i = 0, retval = TRUE; retval && i < trunk_ext_p_info.member_number; i++)
        {
            UI32_T unit, port, ifindex;

            unit = trunk_ext_p_info.member_list[i].unit;
            port = trunk_ext_p_info.member_list[i].port;
            ifindex = SWCTRL_UPORT_TO_IFINDEX(unit, port);
            retval = SWCTRL_SetATCBroadcastStormTrafficControlReleaseStatus(ifindex, SWCTRL_ATC_BROADCAST_STORM_TC_RELEASE_ENABLE);
        }
    }
    else
#endif
    {
        retval = SWCTRL_SetATCBroadcastStormTrafficControlReleaseStatus(ifindex, SWCTRL_ATC_BROADCAST_STORM_TC_RELEASE_ENABLE);
    }

    return retval;
}
#endif /* SYS_CPNT_ATC_BSTORM */

/* ATC Multicast Storm */
#if (SYS_CPNT_ATC_MSTORM == TRUE)
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetUPortATCMulticastStormControlRateLimit
 * -------------------------------------------------------------------------
 * FUNCTION: This function will set the rate limit of broadcast
 *           storm control function
 * INPUT   : unit    -- which unit
 *           port    -- which port to set
 *           mode    -- which mode of rate
 *           rate    -- rate after conversion
 *           nRate   -- rate of broadcast amount
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
static BOOL_T SWCTRL_SetUPortATCMulticastStormControlRateLimit(UI32_T unit,
                                                               UI32_T port,
                                                               UI32_T mode,
                                                               UI32_T rate,
                                                               UI32_T nRate)
{
    BOOL_T retval = FALSE;
    UI32_T i, start_ifindex, end_ifindex;
    UI32_T config_mode;

#if (SYS_CPNT_ATC_MSTORM_RATE_PER_PORT_CTRL == FALSE)
    start_ifindex = 1;
    end_ifindex = SYS_ADPT_TOTAL_NBR_OF_LPORT;
#else
    start_ifindex = SWCTRL_UPORT_TO_IFINDEX (unit, port);
    end_ifindex = start_ifindex;
#endif

    if (SWCTRL_IsSupportedStormType(mode))
    {
        config_mode = mode;
    }
    else
    {
        config_mode = SYS_DFLT_MCAST_STORM_MODE;
        SWCTRL_ConvertRateByStormType(SWCTRL_UPORT_TO_IFINDEX(unit, port), mode, rate, config_mode, &rate);
    }

    SWCTRL_LOCK();
    if((retval = SWDRV_SetATCMulticastStormControlThreshold(unit, port, rate, config_mode)) == TRUE)
    {
        for(i = start_ifindex; i <= end_ifindex; i++)
        {
            port_info[i-1].atc_multicast_storm_entry.atc_multicast_storm_ifindex     = i;
            port_info[i-1].atc_multicast_storm_entry.atc_multicast_storm_sample_type = mode;
            port_info[i-1].atc_multicast_storm_entry.atc_multicast_storm_packet_rate    = 0;
            port_info[i-1].atc_multicast_storm_entry.atc_multicast_storm_octet_rate  = 0;
            port_info[i-1].atc_multicast_storm_entry.atc_multicast_storm_percent     = 0;
            switch (mode)
            {
                case VAL_atcMcastStormSampleType_packet_rate:
                port_info[i-1].atc_multicast_storm_entry.atc_multicast_storm_packet_rate = nRate;
                break;
                case VAL_atcMcastStormSampleType_octet_rate:
                port_info[i-1].atc_multicast_storm_entry.atc_multicast_storm_octet_rate = nRate;
                break;
                case VAL_atcMcastStormSampleType_percent:
                port_info[i-1].atc_multicast_storm_entry.atc_multicast_storm_percent = nRate;
                break;
            }
        }
    }
    SWCTRL_UNLOCK();

    return retval;
} /* End of SWCTRL_SetUPortATCMulticastStormControlRateLimit() */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetUPortATCMulticastStormStatus
 * -------------------------------------------------------------------------
 * FUNCTION: This function will enable the multicast storm control function
 * INPUT   : unit -- which unit
 *           port -- which port to set
 *           atc_multicast_storm_status -- VAL_atcMcastStormStatus_enabled
 *                                     VAL_atcMcastStormStatus_disabled
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
static BOOL_T SWCTRL_SetUPortATCMulticastStormTrafficControlOnStatus(UI32_T unit,
                                                  UI32_T port,
                                                  UI32_T atc_multicast_storm_status)
{
    BOOL_T retval = FALSE;
    UI32_T i, start_ifindex, end_ifindex;

#if (SYS_CPNT_ATC_MSTORM_ENABLE_PER_PORT == FALSE)
    start_ifindex = 1;
    end_ifindex = SYS_ADPT_TOTAL_NBR_OF_LPORT;
#else
    start_ifindex = SWCTRL_UPORT_TO_IFINDEX (unit, port);
    end_ifindex = start_ifindex;
#endif

    if(port_info[start_ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_traffic_control_on == atc_multicast_storm_status)
    {
        return TRUE;
    }

    SWCTRL_LOCK();
    if (atc_multicast_storm_status == SWCTRL_ATC_MULTICAST_STORM_TC_ON_ENABLE)
    {
        retval = SWDRV_EnableATCMulticastStormControl (unit, port);
    }
    else /* SWCTRL_ATC_MULTICAST_STORM_TC_ON_DISABLE */
    {
        retval = TRUE;
    }

    if (retval)
    {
        for(i = start_ifindex; i <= end_ifindex; i++)
        {
            port_info[i-1].atc_multicast_storm_entry.atc_multicast_storm_traffic_control_on = atc_multicast_storm_status;
        }
    }
    SWCTRL_UNLOCK();

    return retval;
} /* end of SWCTRL_SetUPortATCMulticastStormTrafficControlOnStatus () */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetUPortATCMulticastStormStatus
 * -------------------------------------------------------------------------
 * FUNCTION: This function will enable the multicast storm control function
 * INPUT   : unit -- which unit
 *           port -- which port to set
 *           atc_multicast_storm_status -- VAL_atcMcastStormStatus_enabled
 *                                     VAL_atcMcastStormStatus_disabled
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
static BOOL_T SWCTRL_SetUPortATCMulticastStormTrafficControlReleaseStatus(UI32_T unit,
                                                  UI32_T port,
                                                  UI32_T atc_multicast_storm_status)
{
    BOOL_T retval = FALSE;
    UI32_T i, start_ifindex, end_ifindex;

#if (SYS_CPNT_ATC_MSTORM_ENABLE_PER_PORT == FALSE)
    start_ifindex = 1;
    end_ifindex = SYS_ADPT_TOTAL_NBR_OF_LPORT;
#else
    start_ifindex = SWCTRL_UPORT_TO_IFINDEX (unit, port);
    end_ifindex = start_ifindex;
#endif

    if(port_info[start_ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_traffic_control_release == atc_multicast_storm_status)
    {
        return TRUE;
    }

    SWCTRL_LOCK();
    if (atc_multicast_storm_status == SWCTRL_ATC_MULTICAST_STORM_TC_RELEASE_ENABLE)
    {
        retval = SWDRV_DisableATCMulticastStormControl (unit, port);
    }
    else /* SWCTRL_ATC_MULTICAST_STORM_TC_RELEASE_DISABLE */
    {
        retval = TRUE;
    }

    if (retval)
    {
        for(i = start_ifindex; i <= end_ifindex; i++)
        {
            port_info[i-1].atc_multicast_storm_entry.atc_multicast_storm_traffic_control_release = atc_multicast_storm_status;
        }
    }
    SWCTRL_UNLOCK();

    return retval;
} /* end of SWCTRL_SetUPortATCMulticastStormTrafficControlReleaseStatus () */

static BOOL_T SWCTRL_SetATCMulticastStormFSMTrafficControlOnStatus(UI32_T ifindex, UI32_T action, UI32_T traffic_control_on_status)
{
    /* LOCAL VARIABLES
     */
    UI32_T                          unit, port;
    BOOL_T                          retval = FALSE;
    UI32_T                          threshold;

    /* BODY
     */
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    /* Start of Debug message */
    if (SWCTRL_BACKDOOR_IsDebugFlagATCOn(SWCTRL_BACKDOOR_DEBUG_FLAG_ATC_MULTICAST_EVENT))
    {
        BACKDOOR_MGR_Printf("\r\n SWCTRL_SetATCMulticastStormFSMTrafficControlOnStatus: 1. ifindex = %ld , action = %ld,  traffic_control_on_status = %ld \r\n", ifindex, action, traffic_control_on_status);
    }
    /* End of Debug messag */

    if( ifindex == 0 || ifindex > SYS_ADPT_TOTAL_NBR_OF_LPORT)
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Logical Port ID (1-%d)", SYS_ADPT_TOTAL_NBR_OF_LPORT);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_LOGICAL_PORT_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (!SWCTRL_IS_EXIST (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Interface");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

#if (SYS_CPNT_ATC_MSTORM_SUPPORT_LPORT != TRUE)
    if (SWCTRL_IS_TRUNK (ifindex))
    {
            EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                      SWCTRL_NO_USE_FUNC_NO,
                                      EH_TYPE_MSG_TRUNK_CNFG_ERR,
                                      SYSLOG_LEVEL_INFO,
                                      "it doesn't support Multicast Storm Control.");  /*SWCTRL_ENO_NOT_TRUNK*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#else
    if (SWCTRL_IS_TRUNK_MEMBER (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#endif

    if((traffic_control_on_status != SWCTRL_ATC_MULTICAST_STORM_TC_ON_ENABLE) &&
       (traffic_control_on_status != SWCTRL_ATC_MULTICAST_STORM_TC_ON_DISABLE))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_INVALID_PARAMETER,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "traffic control on status"); /*SWCTRL_ENO_INVALID_AUTO_TRAFFIC_CONTROL_ON_STATUS*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if(port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_traffic_control_on == traffic_control_on_status)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
    }

    if (SWCTRL_IsServerBladePort (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_SRV_BLADE_PORT_CNFG,
                                  SYSLOG_LEVEL_INFO,
                                  "Configuring Multicast Storm Control");     /*SWCTRL_ENO_DENY_ON_SERVER_BLADE_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }


    /* if normal port
     */
    if(!SWCTRL_IS_TRUNK (ifindex))
    {
        unit = SWCTRL_IFINDEX_TO_UNIT(ifindex);
        port = SWCTRL_IFINDEX_TO_PORT(ifindex);

        if(traffic_control_on_status  == SWCTRL_ATC_MULTICAST_STORM_TC_ON_ENABLE)
        {
            if (action == VAL_atcMcastStormTcAction_rate_control)
            {

                /* Start of Debug message */
                if (SWCTRL_BACKDOOR_IsDebugFlagATCOn(SWCTRL_BACKDOOR_DEBUG_FLAG_ATC_MULTICAST_EVENT))
                {
                    BACKDOOR_MGR_Printf("\r\n SWCTRL_SetATCMulticastStormFSMTrafficControlOnStatus: 2. TC_ON = enabled, action = rate-control \r\n");
                }
                /* End of Debug messag */

                threshold = (port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_storm_clear_threshold / SWCTRL_ATC_MULTICAST_STORM_ONE_THOUSAND);
                SWCTRL_SetATCMulticastStormStormClearThreshold(ifindex, threshold);
                retval = SWCTRL_SetUPortATCMulticastStormTrafficControlOnStatus(unit, port, traffic_control_on_status);
#if (SYS_CPNT_SWCTRL_SINGLE_INGRESS_RATE_LIMIT == TRUE)
                SWCTRL_SyncUPortATCStormControlRateLimit(unit, port);
#endif
            }
            else if (action == VAL_atcMcastStormTcAction_shutdown)
            {

                /* Start of Debug message */
                if (SWCTRL_BACKDOOR_IsDebugFlagATCOn(SWCTRL_BACKDOOR_DEBUG_FLAG_ATC_MULTICAST_EVENT))
                {
                    BACKDOOR_MGR_Printf("\r\n SWCTRL_SetATCMulticastStormFSMTrafficControlOnStatus: 2. TC_ON = enabled, action = shutdown \r\n");
                }
                /* End of Debug messag */

                retval = SWCTRL_SetATCMulticastStormPortOperationStatus(ifindex, VAL_ifOperStatus_down);
                if (retval)
                {
                    port_info[(SWCTRL_UPORT_TO_IFINDEX(unit, port)) - 1].atc_multicast_storm_entry.atc_multicast_storm_traffic_control_on = traffic_control_on_status;
                }
            }
        }
        else if(traffic_control_on_status  == SWCTRL_ATC_MULTICAST_STORM_TC_ON_DISABLE)
        {

            /* Start of Debug message */
            if (SWCTRL_BACKDOOR_IsDebugFlagATCOn(SWCTRL_BACKDOOR_DEBUG_FLAG_ATC_MULTICAST_EVENT))
            {
                BACKDOOR_MGR_Printf("\r\n SWCTRL_SetATCMulticastStormFSMTrafficControlOnStatus: 2. TC_ON = disabled \r\n");
            }
            /* End of Debug messag */

            SWCTRL_LOCK();
            port_info[(SWCTRL_UPORT_TO_IFINDEX(unit, port)) - 1].atc_multicast_storm_entry.atc_multicast_storm_traffic_control_on = traffic_control_on_status;
            SWCTRL_UNLOCK();
            retval = TRUE;
        }
    }

    /* if trunk port
     */
#if (SYS_CPNT_ATC_MSTORM_SUPPORT_LPORT == TRUE)
    if(SWCTRL_IS_TRUNK (ifindex))
    {
        SWCTRL_TrunkPortExtInfo_T trunk_ext_p_info;
        UI32_T                    i;

        memset(&trunk_ext_p_info, 0, sizeof(SWCTRL_TrunkPortExtInfo_T));
        SWCTRL_GetTrunkPortExtInfo (ifindex, &trunk_ext_p_info);

        for(i=0; i<trunk_ext_p_info.member_number; i++)
        {
            unit = trunk_ext_p_info.member_list[i].unit;
            port = trunk_ext_p_info.member_list[i].port;

            if(traffic_control_on_status  == SWCTRL_ATC_MULTICAST_STORM_TC_ON_ENABLE)
            {
                if (action == VAL_atcMcastStormTcAction_rate_control)
                {
                    retval = SWCTRL_SetUPortATCMulticastStormTrafficControlOnStatus(unit, port, traffic_control_on_status);
#if (SYS_CPNT_SWCTRL_SINGLE_INGRESS_RATE_LIMIT == TRUE)
                    SWCTRL_SyncUPortATCStormControlRateLimit(unit, port);
#endif
                }
                else if (action == VAL_atcMcastStormTcAction_shutdown)
                {
                    retval = SWCTRL_SetATCMulticastStormPortOperationStatus(ifindex, VAL_ifOperStatus_down);
                    if (retval)
                    {
                        port_info[(SWCTRL_UPORT_TO_IFINDEX(unit, port)) - 1].atc_multicast_storm_entry.atc_multicast_storm_traffic_control_on = traffic_control_on_status;
                    }
                }
                if (!retval)
                {
                    break;
                }
            }
            else if(traffic_control_on_status  == SWCTRL_ATC_MULTICAST_STORM_TC_ON_DISABLE)
            {
                SWCTRL_LOCK();
                port_info[(SWCTRL_UPORT_TO_IFINDEX(unit, port)) - 1].atc_multicast_storm_entry.atc_multicast_storm_traffic_control_on = traffic_control_on_status;
                SWCTRL_UNLOCK();
                retval = TRUE;
            }
        } /* End of for () */
        if (retval)
        {
            SWCTRL_LOCK();
            port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_traffic_control_on = traffic_control_on_status;
            SWCTRL_UNLOCK();
        }
    } /* End of trunk port */
#endif /* End of (SYS_CPNT_ATC_MSTORM_SUPPORT_LPORT == TRUE) */

    SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME ();
    SWCTRL_RETURN_AND_RELEASE_CSC( retval );
}

static BOOL_T SWCTRL_SetATCMulticastStormFSMTrafficControlReleaseStatus(UI32_T ifindex, UI32_T action, UI32_T traffic_control_release_status)
{
    /* LOCAL VARIABLES
     */
    UI32_T                          unit, port;
    BOOL_T                          retval = FALSE;

    /* BODY
     */
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    /* Start of Debug message */
    if (SWCTRL_BACKDOOR_IsDebugFlagATCOn(SWCTRL_BACKDOOR_DEBUG_FLAG_ATC_MULTICAST_EVENT))
    {
        BACKDOOR_MGR_Printf("\r\n SWCTRL_SetATCMulticastStormFSMTrafficControlReleaseStatus: 1. ifindex = %ld , action = %ld,  traffic_control_release_status = %ld \r\n", ifindex, action, traffic_control_release_status);
    }
    /* End of Debug messag */

    if( ifindex == 0 || ifindex > SYS_ADPT_TOTAL_NBR_OF_LPORT)
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Logical Port ID (1-%d)", SYS_ADPT_TOTAL_NBR_OF_LPORT);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_LOGICAL_PORT_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (!SWCTRL_IS_EXIST (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Interface");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

#if (SYS_CPNT_ATC_MSTORM_SUPPORT_LPORT == TRUE)
    if (SWCTRL_IS_TRUNK_MEMBER (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#endif

    if((traffic_control_release_status != SWCTRL_ATC_MULTICAST_STORM_TC_RELEASE_ENABLE) &&
       (traffic_control_release_status != SWCTRL_ATC_MULTICAST_STORM_TC_RELEASE_DISABLE))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_INVALID_PARAMETER,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "traffic control release status"); /*SWCTRL_ENO_INVALID_AUTO_TRAFFIC_CONTROL_RELEASE_STATUS*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if(port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_traffic_control_release == traffic_control_release_status)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
    }

    if (SWCTRL_IsServerBladePort (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_SRV_BLADE_PORT_CNFG,
                                  SYSLOG_LEVEL_INFO,
                                  "Configuring Multicast Storm Control");     /*SWCTRL_ENO_DENY_ON_SERVER_BLADE_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }


    /* if normal port
     */
    if(!SWCTRL_IS_TRUNK (ifindex))
    {
        unit = SWCTRL_IFINDEX_TO_UNIT(ifindex);
        port = SWCTRL_IFINDEX_TO_PORT(ifindex);

        if(traffic_control_release_status  == SWCTRL_ATC_MULTICAST_STORM_TC_RELEASE_ENABLE)
        {
            if (action == VAL_atcMcastStormTcAction_rate_control)
            {

                /* Start of Debug message */
                if (SWCTRL_BACKDOOR_IsDebugFlagATCOn(SWCTRL_BACKDOOR_DEBUG_FLAG_ATC_MULTICAST_EVENT))
                {
                    BACKDOOR_MGR_Printf("\r\n SWCTRL_SetATCMulticastStormFSMTrafficControlReleaseStatus: 2. TC_RELEASE = enabled, action = rate-control \r\n");
                }
                /* End of Debug messag */

                retval = SWCTRL_SetUPortATCMulticastStormTrafficControlReleaseStatus(unit, port, traffic_control_release_status);
#if (SYS_CPNT_SWCTRL_SINGLE_INGRESS_RATE_LIMIT == TRUE)
                SWCTRL_SyncUPortATCStormControlRateLimit(unit, port);
#endif
            }
            else if (action == VAL_atcMcastStormTcAction_shutdown)
            {

                /* Start of Debug message */
                if (SWCTRL_BACKDOOR_IsDebugFlagATCOn(SWCTRL_BACKDOOR_DEBUG_FLAG_ATC_MULTICAST_EVENT))
                {
                    BACKDOOR_MGR_Printf("\r\n SWCTRL_SetATCMulticastStormFSMTrafficControlReleaseStatus: 2. TC_RELEASE = enabled, action = shutdown \r\n");
                }
                /* End of Debug messag */

                retval = SWCTRL_SetATCMulticastStormPortOperationStatus(ifindex, VAL_ifOperStatus_up);
                if (retval)
                {
                    port_info[(SWCTRL_UPORT_TO_IFINDEX(unit, port)) - 1].atc_multicast_storm_entry.atc_multicast_storm_traffic_control_release = traffic_control_release_status;
                }
            }
        }
        else if(traffic_control_release_status  == SWCTRL_ATC_MULTICAST_STORM_TC_RELEASE_DISABLE)
        {

            /* Start of Debug message */
            if (SWCTRL_BACKDOOR_IsDebugFlagATCOn(SWCTRL_BACKDOOR_DEBUG_FLAG_ATC_MULTICAST_EVENT))
            {
                BACKDOOR_MGR_Printf("\r\n SWCTRL_SetATCMulticastStormFSMTrafficControlReleaseStatus: 2. TC_RELEASE = disabled \r\n");
            }
            /* End of Debug messag */

            SWCTRL_LOCK();
            port_info[(SWCTRL_UPORT_TO_IFINDEX(unit, port)) - 1].atc_multicast_storm_entry.atc_multicast_storm_traffic_control_release = traffic_control_release_status;
            SWCTRL_UNLOCK();
            retval = TRUE;
        }
    }

    /* if trunk port
     */
#if (SYS_CPNT_ATC_MSTORM_SUPPORT_LPORT == TRUE)
    if(SWCTRL_IS_TRUNK (ifindex))
    {
        SWCTRL_TrunkPortExtInfo_T trunk_ext_p_info;
        UI32_T                    i;

        memset(&trunk_ext_p_info, 0, sizeof(SWCTRL_TrunkPortExtInfo_T));
        SWCTRL_GetTrunkPortExtInfo (ifindex, &trunk_ext_p_info);

        for(i=0; i<trunk_ext_p_info.member_number; i++)
        {
            unit = trunk_ext_p_info.member_list[i].unit;
            port = trunk_ext_p_info.member_list[i].port;

            if(traffic_control_release_status  == SWCTRL_ATC_MULTICAST_STORM_TC_RELEASE_ENABLE)
            {
                if (action == VAL_atcMcastStormTcAction_rate_control)
                {
                    retval = SWCTRL_SetUPortATCMulticastStormTrafficControlReleaseStatus(unit, port, traffic_control_release_status);
#if (SYS_CPNT_SWCTRL_SINGLE_INGRESS_RATE_LIMIT == TRUE)
                    SWCTRL_SyncUPortATCStormControlRateLimit(unit, port);
#endif
                }
                else if (action == VAL_atcMcastStormTcAction_shutdown)
                {
                    retval = SWCTRL_SetATCMulticastStormPortOperationStatus(ifindex, VAL_ifOperStatus_up);
                    if (retval)
                    {
                        port_info[(SWCTRL_UPORT_TO_IFINDEX(unit, port)) - 1].atc_multicast_storm_entry.atc_multicast_storm_traffic_control_release = traffic_control_release_status;
                    }
                }
                if (!retval)
                {
                    break;
                }
            }
            else if(traffic_control_release_status  == SWCTRL_ATC_MULTICAST_STORM_TC_RELEASE_DISABLE)
            {
                SWCTRL_LOCK();
                port_info[(SWCTRL_UPORT_TO_IFINDEX(unit, port)) - 1].atc_multicast_storm_entry.atc_multicast_storm_traffic_control_release = traffic_control_release_status;
                SWCTRL_UNLOCK();
                retval = TRUE;
            }
        } /* End of for () */
        if (retval)
        {
            SWCTRL_LOCK();
            port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_traffic_control_release = traffic_control_release_status;
            SWCTRL_UNLOCK();
        }
    } /* End of trunk port */
#endif /* End of (SYS_CPNT_ATC_MSTORM_SUPPORT_LPORT == TRUE) */

    SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME ();
    SWCTRL_RETURN_AND_RELEASE_CSC( retval );
}
#endif



/****************************************************************************/
/* Quality of Service                                                       */
/****************************************************************************/
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetPortUserDefaultPriority
 * -------------------------------------------------------------------------
 * FUNCTION: This function will set user default priority
 * INPUT   : ifindex  -- which port to set
 *           priority -- user default priority to set
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If priority is not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetPortUserDefaultPriority(UI32_T ifindex, UI32_T priority)
{
    UI32_T unit;
    UI32_T port;
    BOOL_T retval = FALSE;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if(ifindex == 0 || ifindex > SYS_ADPT_TOTAL_NBR_OF_LPORT)
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Logical Port ID (1-%d)", SYS_ADPT_TOTAL_NBR_OF_LPORT);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_LOGICAL_PORT_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (port_info[ifindex-1].port_entry.port_type == STKTPLG_PORT_TYPE_STACKING)
        SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
    if (!SWCTRL_IS_EXIST (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Interface");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (SWCTRL_IS_TRUNK_MEMBER (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if ( priority < SYS_DFLT_1P_0_Regen_User_Priority ||
         priority > SYS_DFLT_1P_7_Regen_User_Priority )
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[40] = {0};

        sprintf(buff, "User Default Priority (%d-%d)",
                      SYS_DFLT_1P_0_Regen_User_Priority,
                      SYS_DFLT_1P_7_Regen_User_Priority);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_PRIORITY_IS_OUT_OF_RANGE*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if(SWCTRL_IS_TRUNK(ifindex))
    {
        UI32_T trunk_id = SWCTRL_IFINDEX_TO_TRUNKID(ifindex);

        if(trunk_ext_port_info[trunk_id-1].member_number == 0)
        {
            EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                      SWCTRL_NO_USE_FUNC_NO,
                                      EH_TYPE_MSG_TRUNK_CNFG_ERR,
                                      SYSLOG_LEVEL_INFO,
                                      "Trunk contains no members");  /*SWCTRL_ENO_NO_MEMBER_IN_TRUNK*/

            SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
        }
        else
        {
            UI32_T i;

            for(i=0; i<trunk_ext_port_info[trunk_id-1].member_number; i++)
            {
                unit = trunk_ext_port_info[trunk_id-1].member_list[i].unit;
                port = trunk_ext_port_info[trunk_id-1].member_list[i].port;

                retval = SWDRV_SetPortUserDefaultPriority(unit, port, priority);

                if(retval == FALSE)
                {
                    break;
                }
            }
        }
    }
    else  /*normal port*/
    {
        unit = SWCTRL_IFINDEX_TO_UNIT(ifindex);
        port = SWCTRL_IFINDEX_TO_PORT(ifindex);

        retval = SWDRV_SetPortUserDefaultPriority(unit, port, priority);
    }
    SWCTRL_RETURN_AND_RELEASE_CSC( retval );
} /* End of SWCTRL_SetPortUserDefaultPriority() */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetPriorityMapping
 * -------------------------------------------------------------------------
 * FUNCTION: This function will set priority mapping of 10/100 ports
 * INPUT   : ifindex -- which port to set
 *           mapping -- priority mapping to set
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If priority is not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetPriorityMapping(UI32_T ifindex, UI8_T mapping[8])
{
    UI32_T  unit;
    UI32_T  port;

    BOOL_T  retval = FALSE;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if(ifindex == 0 || ifindex > SYS_ADPT_TOTAL_NBR_OF_LPORT)
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Logical Port ID (1-%d)", SYS_ADPT_TOTAL_NBR_OF_LPORT);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_LOGICAL_PORT_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (port_info[ifindex-1].port_entry.port_type == STKTPLG_PORT_TYPE_STACKING)
        SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
    if (!SWCTRL_IS_EXIST (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Interface");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (SWCTRL_IS_TRUNK_MEMBER (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if(SWCTRL_IS_TRUNK(ifindex))
    {
        UI32_T trunk_id = SWCTRL_IFINDEX_TO_TRUNKID(ifindex);

        if(trunk_ext_port_info[trunk_id-1].member_number == 0)
        {
            EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                      SWCTRL_NO_USE_FUNC_NO,
                                      EH_TYPE_MSG_TRUNK_CNFG_ERR,
                                      SYSLOG_LEVEL_INFO,
                                      "Trunk contains no members");  /*SWCTRL_ENO_NO_MEMBER_IN_TRUNK*/

            SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
        }
        else
        {
            UI32_T i;

            for(i=0; i<trunk_ext_port_info[trunk_id-1].member_number; i++)
            {
                unit = trunk_ext_port_info[trunk_id-1].member_list[i].unit;
                port = trunk_ext_port_info[trunk_id-1].member_list[i].port;

                retval = SWDRV_SetPriorityMapping(unit, port, mapping);

                if(retval == FALSE)
                {
                    break;
                }
            }
        }
    }
    else /*normal port*/
    {
        unit = SWCTRL_IFINDEX_TO_UNIT(ifindex);
        port = SWCTRL_IFINDEX_TO_PORT(ifindex);

        retval = SWDRV_SetPriorityMapping(unit, port, mapping);
    }

    SWCTRL_RETURN_AND_RELEASE_CSC( retval );
} /* End of SWCTRL_SetPriorityMapping() */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetPriorityMappingPerSystem
 * -------------------------------------------------------------------------
 * FUNCTION: This function will set priority mapping of per-system
 * INPUT   : mapping -- priority mapping to set
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If priority is not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetPriorityMappingPerSystem(UI8_T mapping[8])
{
    BOOL_T  retval = FALSE;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    retval = SWDRV_SetPriorityMappingPerSystem(mapping);

    SWCTRL_RETURN_AND_RELEASE_CSC( retval );
} /* End of SWCTRL_SetPriorityMappingPerSystem() */


#if (SYS_CPNT_STACKING == TRUE)
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetStackingPortPriorityMapping
 * -------------------------------------------------------------------------
 * FUNCTION: This function will set priority mapping of stacking port
 * INPUT   : ifindex -- which port to set
 *           mapping -- priority mapping to set
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If priority is not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetStackingPortPriorityMapping(UI32_T ifindex,
                                             UI8_T mapping[8])
{
    UI8_T unit, port;
    BOOL_T retval;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);


    if(ifindex == 0 || ifindex > SYS_ADPT_TOTAL_NBR_OF_LPORT)
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Logical Port ID (1-%d)", SYS_ADPT_TOTAL_NBR_OF_LPORT);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_LOGICAL_PORT_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    /* because oper status of stacking port is "not present"
     * so don't check.
     */
    /*
    if (!SWCTRL_IS_EXIST (ifindex))
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
     */

    if (SWCTRL_IS_TRUNK_MEMBER (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if(SWCTRL_IS_TRUNK(ifindex))
    {
        UI32_T trunk_id = SWCTRL_IFINDEX_TO_TRUNKID(ifindex);

        if(trunk_ext_port_info[trunk_id-1].member_number == 0)
        {
            EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                      SWCTRL_NO_USE_FUNC_NO,
                                      EH_TYPE_MSG_TRUNK_CNFG_ERR,
                                      SYSLOG_LEVEL_INFO,
                                      "Trunk contains no members");  /*SWCTRL_ENO_NO_MEMBER_IN_TRUNK*/

            SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
        }
        else
        {
            UI32_T i;

            for(i=0; i<trunk_ext_port_info[trunk_id-1].member_number; i++)
            {
                unit = trunk_ext_port_info[trunk_id-1].member_list[i].unit;
                port = trunk_ext_port_info[trunk_id-1].member_list[i].port;

                retval = SWDRV_SetStackingPortPriorityMapping(unit, port, mapping);

                if(retval == FALSE)
                {
                    break;
                }
            }
        }
    }
    else /*normal port*/
    {
        unit = SWCTRL_IFINDEX_TO_UNIT(ifindex);
        port = SWCTRL_IFINDEX_TO_PORT(ifindex);

        retval = SWDRV_SetStackingPortPriorityMapping(unit, port, mapping);
    }

    SWCTRL_RETURN_AND_RELEASE_CSC( retval );
} /* End of SWCTRL_SetStackingPortPriorityMapping() */
#endif

/****************************************************************************/
/* COS                                                                      */
/****************************************************************************/
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_EnableTosCosMap
 * -------------------------------------------------------------------------
 * FUNCTION: This function will enable TOS/COS mapping of system
 * INPUT   : none
 * OUTPUT  : None
 * RETURN  : None
 * NOTE    : 1.ES3626A
 * -------------------------------------------------------------------------*/
void SWCTRL_EnableTosCosMap()
{
    SWCTRL_USE_CSC_CHECK_OPER_MODE_WITHOUT_RETURN_VALUE();

    SWDRVL4_EnableTosCosMap();
    SWCTRL_RETURN_AND_RELEASE_CSC_WITHOUT_RETUEN_VALUE();
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_DisableTosCosMap
 * -------------------------------------------------------------------------
 * FUNCTION: This function will disable TOS/COS mapping of system
 * INPUT   : none
 * OUTPUT  : None
 * RETURN  : None
 * NOTE    : 1.ES3626A
 * -------------------------------------------------------------------------*/
void SWCTRL_DisableTosCosMap()
{
    SWCTRL_USE_CSC_CHECK_OPER_MODE_WITHOUT_RETURN_VALUE();

    SWDRVL4_DisableTosCosMap();
    SWCTRL_RETURN_AND_RELEASE_CSC_WITHOUT_RETUEN_VALUE();

}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_EnableDscpCosMap
 * -------------------------------------------------------------------------
 * FUNCTION: This function will enable DSCP/COS mapping of system
 * INPUT   : none
 * OUTPUT  : None
 * RETURN  : None
 * NOTE    : 1.ES3626A
 * -------------------------------------------------------------------------*/
void SWCTRL_EnableDscpCosMap()
{
    SWCTRL_USE_CSC_CHECK_OPER_MODE_WITHOUT_RETURN_VALUE();

    SWDRVL4_EnableDscpCosMap();
    SWCTRL_RETURN_AND_RELEASE_CSC_WITHOUT_RETUEN_VALUE();

}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_DisableDscpCosMap
 * -------------------------------------------------------------------------
 * FUNCTION: This function will disable DSCP/COS mapping of system
 * INPUT   : none
 * OUTPUT  : None
 * RETURN  : None
 * NOTE    : 1.ES3626A
 * -------------------------------------------------------------------------*/
void SWCTRL_DisableDscpCosMap()
{
    SWCTRL_USE_CSC_CHECK_OPER_MODE_WITHOUT_RETURN_VALUE();

    SWDRVL4_DisableDscpCosMap();
    SWCTRL_RETURN_AND_RELEASE_CSC_WITHOUT_RETUEN_VALUE();

}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_EnableTcpPortCosMap
 * -------------------------------------------------------------------------
 * FUNCTION: This function will enable TCP_PORT/COS mapping of system
 * INPUT   : none
 * OUTPUT  : None
 * RETURN  : None
 * NOTE    : 1.ES3626A
 * -------------------------------------------------------------------------*/
void SWCTRL_EnableTcpPortCosMap()
{
    SWCTRL_USE_CSC_CHECK_OPER_MODE_WITHOUT_RETURN_VALUE();

    SWDRVL4_EnableTcpPortCosMap();
    SWCTRL_RETURN_AND_RELEASE_CSC_WITHOUT_RETUEN_VALUE();

}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_DisableTcpPortCosMap
 * -------------------------------------------------------------------------
 * FUNCTION: This function will disable TCP_PORT/COS mapping of system
 * INPUT   : none
 * OUTPUT  : None
 * RETURN  : None
 * NOTE    : 1.ES3626A
 * -------------------------------------------------------------------------*/
void SWCTRL_DisableTcpPortCosMap()
{
    SWCTRL_USE_CSC_CHECK_OPER_MODE_WITHOUT_RETURN_VALUE();

    SWDRVL4_DisableTcpPortCosMap();
    SWCTRL_RETURN_AND_RELEASE_CSC_WITHOUT_RETUEN_VALUE();

}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetPortTosCosMap
 * -------------------------------------------------------------------------
 * FUNCTION: This function will set one entry of TOS/COS mapping of a port
 * INPUT   : ifindex      -- which port to set
 *           tos          -- from which tos value will be mapped
 *           cos_priority -- to which priority will be mapped
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: Interface not available or asci config fail
 * NOTE    : 1.ES3626A
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetPortTosCosMap(UI32_T ifindex, UI32_T tos, UI32_T cos_priority)
{
    /* LOCAL VARIABLES
     */
    UI16_T unit, port;
    UI32_T i, trunk_id;
    BOOL_T asic_status = FALSE;

    /* BODY
     */
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    /* This is a special case for Broadcom driver gateway */
    if (ifindex == 65535)  /* use 65535 as GLOBAL to save entries in FFP */
    {
        asic_status=SWDRVL4_SetTosCosMap (1, 65535, tos, cos_priority );
        SWCTRL_RETURN_AND_RELEASE_CSC( asic_status );
    }

    if (!SWCTRL_IS_LPORT(ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    SWCTRL_LOCK();
    if (!SWCTRL_IS_TRUNK (ifindex))
    {
        unit = SWCTRL_IFINDEX_TO_UNIT(ifindex);
        port = SWCTRL_IFINDEX_TO_PORT(ifindex);

        asic_status=SWDRVL4_SetTosCosMap (unit, port, tos, cos_priority );
    }

    if (SWCTRL_IS_TRUNK (ifindex))
    {
        trunk_id = SWCTRL_IFINDEX_TO_TRUNKID (ifindex);

        for(i=0; i<trunk_ext_port_info[trunk_id-1].member_number; i++)
        {
            unit = trunk_ext_port_info[trunk_id-1].member_list[i].unit;
            port = trunk_ext_port_info[trunk_id-1].member_list[i].port;
            asic_status=SWDRVL4_SetTosCosMap (unit, port, tos, cos_priority );
        }
    } /* End of if */
    SWCTRL_UNLOCK();

    SWCTRL_RETURN_AND_RELEASE_CSC( asic_status );
} /* End of SWCTRL_SetPortTosCosMap() */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetPortDscpCosMap
 * -------------------------------------------------------------------------
 * FUNCTION: This function will set one entry of DSCP/COS mapping of a port
 * INPUT   : ifindex      -- which port to set
 *           dscp         -- from which dscp value will be mapped
 *           cos_priority -- to which priority will be mapped
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: Interface not available or asci config fail
 * NOTE    : 1.ES3626A
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetPortDscpCosMap(UI32_T ifindex, UI32_T dscp, UI32_T cos_priority)
{
    /* LOCAL VARIABLES
     */
    UI16_T unit, port;
    UI32_T i, trunk_id;
    BOOL_T asic_status = FALSE;

    /* BODY
     */
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    /* This is a special case for Broadcom driver gateway */
    if (ifindex == 65535)  /* use 65535 as Global to save entries in FFP */
    {
        asic_status=SWDRVL4_SetDscpCosMap (1, 65535, dscp, cos_priority );
        SWCTRL_RETURN_AND_RELEASE_CSC( asic_status );
    }

    if (!SWCTRL_IS_LPORT(ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    SWCTRL_LOCK();
    if (!SWCTRL_IS_TRUNK (ifindex))
    {
        unit = SWCTRL_IFINDEX_TO_UNIT(ifindex);
        port = SWCTRL_IFINDEX_TO_PORT(ifindex);

        asic_status=SWDRVL4_SetDscpCosMap (unit, port, dscp, cos_priority );
    }

    if (SWCTRL_IS_TRUNK (ifindex))
    {
        trunk_id = SWCTRL_IFINDEX_TO_TRUNKID (ifindex);

        for(i=0; i<trunk_ext_port_info[trunk_id-1].member_number; i++)
        {
            unit = trunk_ext_port_info[trunk_id-1].member_list[i].unit;
            port = trunk_ext_port_info[trunk_id-1].member_list[i].port;
            asic_status=SWDRVL4_SetDscpCosMap (unit, port, dscp, cos_priority );
        }
    } /* End of if */
    SWCTRL_UNLOCK();

    SWCTRL_RETURN_AND_RELEASE_CSC( asic_status );
} /* End of SWCTRL_SetPortDscpCosMap() */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetPortTcpPortCosMap
 * -------------------------------------------------------------------------
 * FUNCTION: This function will set one entry of TCP_PORT/COS mapping of a port
 * INPUT   : ifindex      -- which port to set
 *           tcp_port     -- from which dscp value will be mapped
 *           cos_priority -- to which priority will be mapped
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: Interface not available or asci config fail
 * NOTE    : 1.ES3626A
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetPortTcpPortCosMap(UI32_T ifindex, UI32_T tcp_port, UI32_T cos_priority)
{
    /* LOCAL VARIABLES
     */
    UI16_T unit, port;
    UI32_T i, trunk_id;
    BOOL_T asic_status = FALSE;

    /* BODY
     */
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (!SWCTRL_IS_LPORT(ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    SWCTRL_LOCK();
    if (!SWCTRL_IS_TRUNK (ifindex))
    {
        unit = SWCTRL_IFINDEX_TO_UNIT(ifindex);
        port = SWCTRL_IFINDEX_TO_PORT(ifindex);

        asic_status=SWDRVL4_SetTcpPortCosMap (unit, port, tcp_port, cos_priority );
    }

    if (SWCTRL_IS_TRUNK (ifindex))
    {
        trunk_id = SWCTRL_IFINDEX_TO_TRUNKID (ifindex);

        for(i=0; i<trunk_ext_port_info[trunk_id-1].member_number; i++)
        {
            unit = trunk_ext_port_info[trunk_id-1].member_list[i].unit;
            port = trunk_ext_port_info[trunk_id-1].member_list[i].port;
            asic_status=SWDRVL4_SetTcpPortCosMap (unit, port, tcp_port, cos_priority );
        }
    } /* End of if */
    SWCTRL_UNLOCK();

    SWCTRL_RETURN_AND_RELEASE_CSC( asic_status );
} /* End of SWCTRL_SetPortDscpCosMap() */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_DelPortTosCosMap
 * -------------------------------------------------------------------------
 * FUNCTION: This function will delete one entry of TOS/COS mapping of a port
 * INPUT   : ifindex      -- which port to delete
 *           tos         -- which tos mapping will be deleted
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: Interface not available or asci config fail
 * NOTE    : 1.ES3626A
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_DelPortTosCosMap(UI32_T ifindex, UI32_T tos)
{
    /* LOCAL VARIABLES
     */
    UI16_T unit, port;
    UI32_T i, trunk_id;
    BOOL_T asic_status = FALSE;

    /* BODY
     */
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (!SWCTRL_IS_LPORT(ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    SWCTRL_LOCK();
    if (!SWCTRL_IS_TRUNK (ifindex))
    {
        unit = SWCTRL_IFINDEX_TO_UNIT(ifindex);
        port = SWCTRL_IFINDEX_TO_PORT(ifindex);

        asic_status=SWDRVL4_DelTosCosMap (unit, port, tos);
    }

    if (SWCTRL_IS_TRUNK (ifindex))
    {
        trunk_id = SWCTRL_IFINDEX_TO_TRUNKID (ifindex);

        for(i=0; i<trunk_ext_port_info[trunk_id-1].member_number; i++)
        {
            unit = trunk_ext_port_info[trunk_id-1].member_list[i].unit;
            port = trunk_ext_port_info[trunk_id-1].member_list[i].port;
            asic_status=SWDRVL4_DelTosCosMap (unit, port, tos);
        }
    } /* End of if */
    SWCTRL_UNLOCK();

    SWCTRL_RETURN_AND_RELEASE_CSC( asic_status );
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_DelPortDscpCosMap
 * -------------------------------------------------------------------------
 * FUNCTION: This function will delete one entry of DSCP/COS mapping of a port
 * INPUT   : ifindex      -- which port to delete
 *           dscp         -- which dscp mapping will be deleted
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: Interface not available or asci config fail
 * NOTE    : 1.ES3626A
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_DelPortDscpCosMap(UI32_T ifindex, UI32_T dscp)
{
    /* LOCAL VARIABLES
     */
    UI16_T unit, port;
    UI32_T i, trunk_id;
    BOOL_T asic_status = FALSE;

    /* BODY
     */
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (!SWCTRL_IS_LPORT(ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    SWCTRL_LOCK();
    if (!SWCTRL_IS_TRUNK (ifindex))
    {
        unit = SWCTRL_IFINDEX_TO_UNIT(ifindex);
        port = SWCTRL_IFINDEX_TO_PORT(ifindex);

        asic_status=SWDRVL4_DelDscpCosMap (unit, port, dscp);
    }

    if (SWCTRL_IS_TRUNK (ifindex))
    {
        trunk_id = SWCTRL_IFINDEX_TO_TRUNKID (ifindex);

        for(i=0; i<trunk_ext_port_info[trunk_id-1].member_number; i++)
        {
            unit = trunk_ext_port_info[trunk_id-1].member_list[i].unit;
            port = trunk_ext_port_info[trunk_id-1].member_list[i].port;
            asic_status=SWDRVL4_DelDscpCosMap (unit, port, dscp);
        }
    } /* End of if */
    SWCTRL_UNLOCK();

    SWCTRL_RETURN_AND_RELEASE_CSC( asic_status );
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_DelPortTcpPortCosMap
 * -------------------------------------------------------------------------
 * FUNCTION: This function will delete one entry of DSCP/COS mapping of a port
 * INPUT   : ifindex      -- which port to delete
 *           tcp_port     -- which tcp port mapping will be deleted
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: Interface not available or asci config fail
 * NOTE    : 1.ES3626A
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_DelPortTcpPortCosMap(UI32_T ifindex, UI32_T tcp_port)
{
    /* LOCAL VARIABLES
     */
    UI16_T unit, port;
    UI32_T i, trunk_id;
    BOOL_T asic_status = FALSE;

    /* BODY
     */
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (!SWCTRL_IS_LPORT(ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    SWCTRL_LOCK();
    if (!SWCTRL_IS_TRUNK (ifindex))
    {
        unit = SWCTRL_IFINDEX_TO_UNIT(ifindex);
        port = SWCTRL_IFINDEX_TO_PORT(ifindex);

        asic_status=SWDRVL4_DelTcpPortCosMap (unit, port, tcp_port);
    }

    if (SWCTRL_IS_TRUNK (ifindex))
    {
        trunk_id = SWCTRL_IFINDEX_TO_TRUNKID (ifindex);

        for(i=0; i<trunk_ext_port_info[trunk_id-1].member_number; i++)
        {
            unit = trunk_ext_port_info[trunk_id-1].member_list[i].unit;
            port = trunk_ext_port_info[trunk_id-1].member_list[i].port;
            asic_status=SWDRVL4_DelTcpPortCosMap (unit, port, tcp_port);
        }
    } /* End of if */
    SWCTRL_UNLOCK();

    SWCTRL_RETURN_AND_RELEASE_CSC( asic_status );
}

BOOL_T SWCTRL_SetQosTrustMode(UI32_T ifindex, UI32_T mode)
{
    /* LOCAL VARIABLES
     */
    UI16_T unit, port;
    #if 0
    UI32_T i, trunk_id;   /* modified by Jinhua Wei ,to remove warning ,becaued the variable never used */
    #endif
    BOOL_T asic_status = FALSE;

    /* BODY
     */
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    SWCTRL_LOCK();
    if (!SWCTRL_IS_TRUNK (ifindex))
    {
        unit = SWCTRL_IFINDEX_TO_UNIT(ifindex);
        port = SWCTRL_IFINDEX_TO_PORT(ifindex);
        asic_status=SWDRVL4_SetCosTrustMode (unit, port, mode);
    }

    SWCTRL_UNLOCK();
    SWCTRL_RETURN_AND_RELEASE_CSC( asic_status );
}

BOOL_T SWCTRL_SetPortListQosTrustMode(UI8_T *port_list, UI32_T mode)
{
    /* LOCAL VARIABLES
     */
    #if 0
    UI16_T unit, port;
    UI32_T i, trunk_id;   /* modified by Jinhua Wei ,to remove warning ,becaued the variable never used */
    #endif
    BOOL_T asic_status = FALSE;

    /* BODY
     */
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    SWCTRL_LOCK();
    asic_status=SWDRVL4_SetPortListCosTrustMode (port_list, mode);
    SWCTRL_UNLOCK();
    SWCTRL_RETURN_AND_RELEASE_CSC( asic_status );
}

BOOL_T SWCTRL_SetQosIngressCos2Dscp(UI32_T lport,UI32_T cos,UI32_T cfi,UI32_T phb,UI32_T color)
{
    /* LOCAL VARIABLES
     */
    UI16_T unit, port;
    #if 0
    UI32_T i, trunk_id;  /* modified by Jinhua Wei ,to remove warning ,becaued the variable never used */
    #endif
    BOOL_T asic_status = FALSE;

    /* BODY
     */
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    SWCTRL_LOCK();
    if (!SWCTRL_IS_TRUNK (lport))
    {
        unit = SWCTRL_IFINDEX_TO_UNIT(lport);
        port = SWCTRL_IFINDEX_TO_PORT(lport);

        asic_status=SWDRVL4_SetQosIngCos2Dscp (unit,port,cos,cfi,phb,color);
    }

    SWCTRL_UNLOCK();

    SWCTRL_RETURN_AND_RELEASE_CSC( asic_status );
}

BOOL_T SWCTRL_SetPortListQosIngressCos2Dscp(UI8_T *port_list,UI32_T cos,UI32_T cfi,UI32_T phb,UI32_T color)
{
    /* LOCAL VARIABLES
     */
    #if 0
    UI16_T unit, port;
    UI32_T i, trunk_id;  /* modified by Jinhua Wei ,to remove warning ,becaued the variable never used */
    #endif
    BOOL_T asic_status = FALSE;

    /* BODY
     */
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    SWCTRL_LOCK();
    asic_status=SWDRVL4_SetPortListQosIngCos2Dscp (port_list,cos,cfi,phb,color);

    SWCTRL_UNLOCK();

    SWCTRL_RETURN_AND_RELEASE_CSC( asic_status );
}

BOOL_T SWCTRL_SetQosIngressPre2Dscp(UI32_T lport,UI32_T pre,UI32_T phb,UI32_T color)
{
    /* LOCAL VARIABLES
     */
    UI16_T unit, port;
    #if 0
    UI32_T trunk_id;   /* modified by Jinhua Wei ,to remove warning ,becaued the variable never used */
    #endif
    BOOL_T asic_status = FALSE;
    int related_dscp;
    /* BODY
     */
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);
    SWCTRL_LOCK();

    related_dscp = pre << 3;

    if (!SWCTRL_IS_TRUNK (lport))
    {
        unit = SWCTRL_IFINDEX_TO_UNIT(lport);
        port = SWCTRL_IFINDEX_TO_PORT(lport);

            asic_status=SWDRVL4_SetQosIngPre2Dscp (unit,port,related_dscp,phb,color);
            if(!asic_status)
            {
                SWCTRL_UNLOCK();
                SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
            }

    }

    SWCTRL_UNLOCK();

    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
}

BOOL_T SWCTRL_SetPortListQosIngressPre2Dscp(UI8_T *port_list,UI32_T pre,UI32_T phb,UI32_T color)
{
    /* LOCAL VARIABLES
     */
    #if 0
    UI16_T unit, port;
    UI32_T trunk_id;  /* modified by Jinhua Wei ,to remove warning ,becaued the variable never used */
    #endif
    BOOL_T asic_status = FALSE;
    int related_dscp;
    /* BODY
     */
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);
    SWCTRL_LOCK();

    related_dscp = pre << 3;

        asic_status=SWDRVL4_SetPortListQosIngPre2Dscp (port_list,related_dscp,phb,color);
        if(!asic_status)
        {
            SWCTRL_UNLOCK();
            SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    SWCTRL_UNLOCK();

    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
}

BOOL_T SWCTRL_SetQosIngressDscp2Dscp(UI32_T lport,UI32_T o_dscp,UI32_T phb,UI32_T color)
{
    /* LOCAL VARIABLES
     */
    UI16_T unit, port;
    #if 0
    UI32_T i, trunk_id;  /* modified by Jinhua Wei ,to remove warning ,becaued the variable never used */
    #endif
    BOOL_T asic_status = FALSE;

    /* BODY
     */
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    SWCTRL_LOCK();
    if (!SWCTRL_IS_TRUNK (lport))
    {
        unit = SWCTRL_IFINDEX_TO_UNIT(lport);
        port = SWCTRL_IFINDEX_TO_PORT(lport);

        asic_status=SWDRVL4_SetQosIngDscp2Dscp (unit,port,o_dscp,phb,color);
    }

    SWCTRL_UNLOCK();

    SWCTRL_RETURN_AND_RELEASE_CSC( asic_status );
}

BOOL_T SWCTRL_SetPortListQosIngressDscp2Dscp(UI8_T *port_list,UI32_T o_dscp,UI32_T phb,UI32_T color)
{
    /* LOCAL VARIABLES
     */
    #if 0
    UI16_T unit, port;
    UI32_T i, trunk_id;  /* modified by Jinhua Wei ,to remove warning ,becaued the variable never used */
    #endif
    BOOL_T asic_status = FALSE;

    /* BODY
     */
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    SWCTRL_LOCK();
    asic_status=SWDRVL4_SetPortListQosIngDscp2Dscp (port_list,o_dscp,phb,color);

    SWCTRL_UNLOCK();

    SWCTRL_RETURN_AND_RELEASE_CSC( asic_status );
}

BOOL_T SWCTRL_SetQosIngressDscp2Queue(UI32_T lport,UI32_T phb,UI32_T queue)
{
    /* LOCAL VARIABLES
     */
    UI16_T unit, port;
    #if 0
    UI32_T i, trunk_id; /* modified by Jinhua Wei ,to remove warning ,becaued the variable never used */
    #endif
    BOOL_T asic_status = FALSE;

    /* BODY
     */
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    SWCTRL_LOCK();
    if (!SWCTRL_IS_TRUNK (lport))
    {
        unit = SWCTRL_IFINDEX_TO_UNIT(lport);
        port = SWCTRL_IFINDEX_TO_PORT(lport);

        asic_status=SWDRVL4_SetQosIngDscp2Queue(unit,port,phb,queue);
    }

    SWCTRL_UNLOCK();

    SWCTRL_RETURN_AND_RELEASE_CSC( asic_status );
}

BOOL_T SWCTRL_SetPortListQosIngressDscp2Queue(UI8_T *port_list,UI32_T phb,UI32_T queue)
{
    /* LOCAL VARIABLES
     */
    #if 0
    UI16_T unit, port;
    UI32_T i, trunk_id;  /* modified by Jinhua Wei ,to remove warning ,becaued the variable never used */
    #endif
    BOOL_T asic_status = FALSE;

    /* BODY
     */
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    SWCTRL_LOCK();

    asic_status=SWDRVL4_SetPortListQosIngDscp2Queue(port_list,phb,queue);

    SWCTRL_UNLOCK();

    SWCTRL_RETURN_AND_RELEASE_CSC( asic_status );
}

BOOL_T SWCTRL_SetQosIngressDscp2Color(UI32_T lport,UI32_T phb,UI32_T color)
{
    /* LOCAL VARIABLES
     */
    UI16_T unit, port;
    #if 0
    UI32_T i, trunk_id;  /* modified by Jinhua Wei ,to remove warning ,becaued the variable never used */
    #endif
    BOOL_T asic_status = FALSE;

    /* BODY
     */
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    SWCTRL_LOCK();
    if (!SWCTRL_IS_TRUNK (lport))
    {
        unit = SWCTRL_IFINDEX_TO_UNIT(lport);
        port = SWCTRL_IFINDEX_TO_PORT(lport);

        asic_status=SWDRVL4_SetQosIngDscp2Color(unit,port,phb,color);
    }

    SWCTRL_UNLOCK();

    SWCTRL_RETURN_AND_RELEASE_CSC( asic_status );
}

BOOL_T SWCTRL_SetPortListQosIngressDscp2Color(UI8_T *port_list,UI32_T phb,UI32_T color)
{
    /* LOCAL VARIABLES
     */
    #if 0
    UI16_T unit, port;
    UI32_T i, trunk_id;  /* modified by Jinhua Wei ,to remove warning ,becaued the variable never used */
    #endif
    BOOL_T asic_status = FALSE;

    /* BODY
     */
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    SWCTRL_LOCK();

    asic_status=SWDRVL4_SetPortListQosIngDscp2Color(port_list,phb,color);

    SWCTRL_UNLOCK();

    SWCTRL_RETURN_AND_RELEASE_CSC( asic_status );
}

BOOL_T SWCTRL_SetQosIngressDscp2Cos(UI32_T lport,UI32_T phb,UI32_T color,UI32_T cos,UI32_T cfi)
{
    /* LOCAL VARIABLES
     */
    UI16_T unit, port;
    #if 0
    UI32_T i, trunk_id; /* modified by Jinhua Wei ,to remove warning ,becaued the variable never used */
    #endif
    BOOL_T asic_status = FALSE;

    /* BODY
     */
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    SWCTRL_LOCK();
    if (!SWCTRL_IS_TRUNK (lport))
    {
        unit = SWCTRL_IFINDEX_TO_UNIT(lport);
        port = SWCTRL_IFINDEX_TO_PORT(lport);

        asic_status=SWDRVL4_SetQosIngDscp2Cos (unit,port,phb,color,cos,cfi);
    }

    SWCTRL_UNLOCK();

    SWCTRL_RETURN_AND_RELEASE_CSC( asic_status );
}

BOOL_T SWCTRL_SetPortListQosIngressDscp2Cos(UI8_T *port_list,UI32_T phb,UI32_T color,UI32_T cos,UI32_T cfi)
{
    /* LOCAL VARIABLES
     */
    #if 0
    UI16_T unit, port;
    UI32_T i, trunk_id;  /* modified by Jinhua Wei ,to remove warning ,becaued the variable never used */
    #endif
    BOOL_T asic_status = FALSE;

    /* BODY
     */
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    SWCTRL_LOCK();
    asic_status=SWDRVL4_SetPortListQosIngDscp2Cos (port_list,phb,color,cos,cfi);

    SWCTRL_UNLOCK();

    SWCTRL_RETURN_AND_RELEASE_CSC( asic_status );
}
#if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION == TRUE)
/*********************
 * Private VLAN APIs *
 *********************/
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_EnablePrivateVlan
 * -------------------------------------------------------------------------
 * FUNCTION: This function will enable the private vlan
 * INPUT   : None
 * OUTPUT  : None
 * RETURN  : True: Successfully, FALSE: Failed
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_EnablePrivateVlan()
{
#if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE == SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE_MULTIPLE_SESSION)
    UI32_T session_id;
#endif /* End of #if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE == SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE_MULTIPLE_SESSION) */

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    SWCTRL_LOCK();
    if (system_info.is_private_vlan_enable == VAL_privateVlanStatus_enabled)
    {
        /*SWCTRL_RETURN_AND_RELEASE_CSC_AND_UNLOCK( TRUE );*/
         SWCTRL_UNLOCK();
         SWCTRL_RELEASE_CSC();
         return (TRUE);
    }

#if (SWCTRL_PORT_TRAFFIC_SEGMENTATION_PORT_EGRESS_BLOCK == TRUE)
    if (SWCTRL_PortEgressBlock_EnableTrafficSegmatation())
#else
    if (TRUE == SWDRV_EnableTrafficSegmatation())
#endif
    {
        system_info.is_private_vlan_enable = VAL_privateVlanStatus_enabled;

#if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_WITHOUT_FFP == TRUE)
        {
            /* Now is from disable to enable.
             * If no FFP, then no HRDRV, then no database in lower,
             * so, setting data in OM to driver is necessary.
             */
            UI8_T uplink_ports[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST];
            UI8_T downlink_ports[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST];

            memset(&uplink_ports, 0, sizeof(UI8_T)*SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST);
            memset(&downlink_ports, 0, sizeof(UI8_T)*SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST);

#if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE == SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE_MULTIPLE_SESSION)

            for(session_id=1; session_id<=SYS_ADPT_PORT_TRAFFIC_SEGMENTATION_MAX_NBR_OF_SESSIONS ; session_id++)
            {
                /* continue while session invalid */
                if (swctl_private_vlan_ext_info[session_id-1].is_valid == FALSE)
                {
                    continue;
                }

                memset(&uplink_ports, 0, sizeof(UI8_T)*SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST);
                memset(&downlink_ports, 0, sizeof(UI8_T)*SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST);
                SWCTRL_GetPrivateVlanBySessionId(session_id, uplink_ports, downlink_ports);

                /* set session group to private vlan group */
                if (FALSE == SWCTRL_SetPrivateVlanBySessionId_(session_id, uplink_ports, downlink_ports))
                {
                    SWCTRL_RETURN_AND_RELEASE_CSC_AND_UNLOCK( FALSE );
                }
            }
#else
            SWCTRL_GetPrivateVlanPortList(TRUE,  uplink_ports);
            SWCTRL_GetPrivateVlanPortList(FALSE, downlink_ports);

            if (FALSE == SWCTRL_SetPrivateVlan_(uplink_ports, downlink_ports))
            {
                /*SWCTRL_RETURN_AND_RELEASE_CSC_AND_UNLOCK( FALSE );*/
                SWCTRL_UNLOCK();
                SWCTRL_RELEASE_CSC();
                return (FALSE);
            }
#endif /* End of #if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE == SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE_MULTIPLE_SESSION) */
        }
#endif

       /* SWCTRL_RETURN_AND_RELEASE_CSC_AND_UNLOCK( TRUE );*/
       SWCTRL_UNLOCK();
       SWCTRL_RELEASE_CSC();
       return (TRUE);
    }

    /*SWCTRL_RETURN_AND_RELEASE_CSC_AND_UNLOCK( FALSE );*/
    SWCTRL_UNLOCK();
    SWCTRL_RELEASE_CSC();
    return (FALSE);
} /* End of SWCTRL_EnablePrivateVlan () */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_DisablePrivateVlan
 * -------------------------------------------------------------------------
 * FUNCTION: This function will disable the private vlan
 * INPUT   : None
 * OUTPUT  : None
 * RETURN  : True: Successfully, FALSE: Failed
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_DisablePrivateVlan()
{
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (system_info.is_private_vlan_enable == VAL_privateVlanStatus_disabled)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
    }

#if (SWCTRL_PORT_TRAFFIC_SEGMENTATION_PORT_EGRESS_BLOCK == TRUE)
    if (SWCTRL_PortEgressBlock_DisableTrafficSegmatation())
#else
    if (TRUE == SWDRV_DisableTrafficSegmatation ())
#endif
    {
        system_info.is_private_vlan_enable = VAL_privateVlanStatus_disabled;
        SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
    }

    SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
} /* End of SWCTRL_DisablePrivateVlan () */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetPrivateVlan
 * -------------------------------------------------------------------------
 * FUNCTION: This function will set the private vlan
 * INPUT   : uplink_port_list  -- uplink port list
 *           downlink_port_list -- downlink port list
 * OUTPUT  : None
 * RETURN  : True: Successfully, FALSE: Failed
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetPrivateVlan(UI8_T uplink_port_list  [SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST],
                             UI8_T downlink_port_list[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST])
{
    BOOL_T retval;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    SWCTRL_ENTER_XOR_CRITICAL_SECTION(&retval);

    SWCTRL_XOR_CHECK(
        SYSCTRL_XOR_MGR_PermitBeingSetToPrivatePort(downlink_port_list));

    SWCTRL_LOCK();

    retval = SWCTRL_SetPrivateVlan_(uplink_port_list, downlink_port_list);

    /*SWCTRL_RETURN_AND_RELEASE_CSC_AND_UNLOCK( retval );*/
    SWCTRL_UNLOCK();
    SWCTRL_LEAVE_XOR_CRITICAL_SECTION();
    SWCTRL_RELEASE_CSC();
    return (retval);
} /* End of SWCTRL_SetPrivateVlan () */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_AddPrivateVlanUplinkPortMember
 * -------------------------------------------------------------------------
 * FUNCTION: This function will add port into the private vlan uplink member list
 * INPUT   : ifindex -- which port to add
 * OUTPUT  : None
 * RETURN  : True: Successfully, FALSE: Failed
 * NOTE    : None
 * -------------------------------------------------------------------------*/
#define UI8_T_ARRAY_INDEX_BY_IFINDEX(IFINDEX)  ((int)(((IFINDEX)-1)/8))
#define BIT_IN_UI8_T_BY_IFINDEX(IFINDEX)       (1 << (7 - (((IFINDEX)-1) - (UI8_T_ARRAY_INDEX_BY_IFINDEX(IFINDEX)*8))))

BOOL_T SWCTRL_AddPrivateVlanUplinkPortMember(UI32_T ifindex)
{
    UI8_T uplink_ports[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST];
    UI8_T downlink_port[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST];

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    SWCTRL_LOCK();
    if (port_info[ifindex-1].private_vlan_uplink_port == TRUE)
    {
        SWCTRL_UNLOCK();
        SWCTRL_RELEASE_CSC();
        return (TRUE);
    }
        /*SWCTRL_RETURN_AND_RELEASE_CSC_AND_UNLOCK( TRUE );*/ /* already existing */

    SWCTRL_GetPrivateVlanPortList(TRUE,  uplink_ports);
    SWCTRL_GetPrivateVlanPortList(FALSE, downlink_port);

    uplink_ports[UI8_T_ARRAY_INDEX_BY_IFINDEX(ifindex)] |= BIT_IN_UI8_T_BY_IFINDEX(ifindex);

    if (SWCTRL_SetPrivateVlan_(uplink_ports, downlink_port))
    {
        SWCTRL_UNLOCK();
        SWCTRL_RELEASE_CSC();
        return (TRUE);
    }
            /*SWCTRL_RETURN_AND_RELEASE_CSC_AND_UNLOCK( TRUE );*/

    /* Error code was set in SWCTRL_SetPrivateVlan_(); */
    /*SWCTRL_RETURN_AND_RELEASE_CSC_AND_UNLOCK( FALSE );*/
    SWCTRL_UNLOCK();
    SWCTRL_RELEASE_CSC();
    return (FALSE);

}/*End of SWCTRL_AddPrivateVlanUplinkPortMember () */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_DeletePrivateVlanUplinkPortMember
 * -------------------------------------------------------------------------
 * FUNCTION: This function will delete the port from private vlan uplink list
 * INPUT   : ifindex -- which port to delete
 * OUTPUT  : None
 * RETURN  : True: Successfully, FALSE: Failed
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_DeletePrivateVlanUplinkPortMember(UI32_T ifindex)
{
    UI8_T uplink_ports[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST];
    UI8_T downlink_port[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST];

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    SWCTRL_LOCK();
    if (port_info[ifindex-1].private_vlan_uplink_port != TRUE)
    {
        SWCTRL_UNLOCK();
        SWCTRL_RELEASE_CSC();
        return (TRUE);
    }
       /* SWCTRL_RETURN_AND_RELEASE_CSC_AND_UNLOCK( TRUE );*//* already not existing */

    SWCTRL_GetPrivateVlanPortList(TRUE, uplink_ports);
    SWCTRL_GetPrivateVlanPortList(FALSE, downlink_port);

    uplink_ports[UI8_T_ARRAY_INDEX_BY_IFINDEX(ifindex)] &=  ~(BIT_IN_UI8_T_BY_IFINDEX(ifindex));

    if (SWCTRL_SetPrivateVlan_(uplink_ports, downlink_port))
    {
        SWCTRL_UNLOCK();
        SWCTRL_RELEASE_CSC();
        return (TRUE);
    }
    /*    SWCTRL_RETURN_AND_RELEASE_CSC_AND_UNLOCK( TRUE );*/

    /* Error code was set in SWCTRL_SetPrivateVlan_(); */
    /*SWCTRL_RETURN_AND_RELEASE_CSC_AND_UNLOCK( FALSE );*/
    SWCTRL_UNLOCK();
    SWCTRL_RELEASE_CSC();
    return (FALSE);
}/*End of SWCTRL_DeletePrivateVlanUplinkPortMember () */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_AddPrivateVlanDownlinkPortMember
 * -------------------------------------------------------------------------
 * FUNCTION: This function will add port into the private vlan downlink member list
 * INPUT   : ifindex -- which port to add
 * OUTPUT  : None
 * RETURN  : True: Successfully, FALSE: Failed
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_AddPrivateVlanDownlinkPortMember(UI32_T ifindex)
{
    UI8_T uplink_ports[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST];
    UI8_T downlink_port[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST];

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    SWCTRL_LOCK();
    if (port_info[ifindex-1].private_vlan_downlink_port == TRUE)
    {
        SWCTRL_UNLOCK();
        SWCTRL_RELEASE_CSC();
        return (TRUE);
    }
        /*SWCTRL_RETURN_AND_RELEASE_CSC_AND_UNLOCK( TRUE );*/ /* already existing */

    SWCTRL_GetPrivateVlanPortList(TRUE,  uplink_ports);
    SWCTRL_GetPrivateVlanPortList(FALSE, downlink_port);

    downlink_port[UI8_T_ARRAY_INDEX_BY_IFINDEX(ifindex)] |= BIT_IN_UI8_T_BY_IFINDEX(ifindex);

    if (SWCTRL_SetPrivateVlan_(uplink_ports, downlink_port))
    {
        SWCTRL_UNLOCK();
        SWCTRL_RELEASE_CSC();
        return (TRUE);
    }
        /*SWCTRL_RETURN_AND_RELEASE_CSC_AND_UNLOCK( TRUE );*/

    /* Error code was set in SWCTRL_SetPrivateVlan_(); */
    /*SWCTRL_RETURN_AND_RELEASE_CSC_AND_UNLOCK( FALSE );*/
    SWCTRL_UNLOCK();
    SWCTRL_RELEASE_CSC();
    return (FALSE);
}/*End of SWCTRL_AddPrivateVlanDownlinkPortMember () */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_DeletePrivateVlanDownlinkPortMember
 * -------------------------------------------------------------------------
 * FUNCTION: This function will delete the port from private vlan downlink list
 * INPUT   : ifindex -- which port to delete
 * OUTPUT  : None
 * RETURN  : True: Successfully, FALSE: Failed
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_DeletePrivateVlanDownlinkPortMember(UI32_T ifindex)
{
    UI8_T uplink_ports[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST];
    UI8_T downlink_port[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST];

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    SWCTRL_LOCK();
    if (port_info[ifindex-1].private_vlan_downlink_port != TRUE)
    {
        SWCTRL_UNLOCK();
        SWCTRL_RELEASE_CSC();
        return(TRUE);
    }
        /*SWCTRL_RETURN_AND_RELEASE_CSC( TRUE ); *//* already not existing */

    SWCTRL_GetPrivateVlanPortList(TRUE, uplink_ports);
    SWCTRL_GetPrivateVlanPortList(FALSE, downlink_port);

    downlink_port[UI8_T_ARRAY_INDEX_BY_IFINDEX(ifindex)] &= ~(BIT_IN_UI8_T_BY_IFINDEX(ifindex));

    if (SWCTRL_SetPrivateVlan_(uplink_ports, downlink_port))
    {
        SWCTRL_UNLOCK();
        SWCTRL_RELEASE_CSC();
        return (TRUE);
    }
        /*SWCTRL_RETURN_AND_RELEASE_CSC_AND_UNLOCK( TRUE );*/

    /* Error code was set in SWCTRL_SetPrivateVlan()_; */
    /*SWCTRL_RETURN_AND_RELEASE_CSC_AND_UNLOCK( FALSE );*/
    SWCTRL_UNLOCK();
    SWCTRL_RELEASE_CSC();
    return (FALSE);
}/*End of SWCTRL_DeletePrivateVlanDownlinkPortMember () */

#if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION == TRUE)
#if (SYS_DFLT_TRAFFIC_SEG_METHOD == SYS_DFLT_TRAFFIC_SEG_METHOD_PORT_PRIVATE_MODE)
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetPortPrivateMode
 * -------------------------------------------------------------------------
 * FUNCTION: This function will set the private mode for the specified port
 * INPUT   : ifindex            -- the specified port index
 *           port_private_mode  -- VAL_portPrivateMode_enabled (1L) : private port
 *                                 VAL_portPrivateMode_disabled (2L): public port
 * OUTPUT  : None
 * RETURN  : TRUE/FALSE
 * NOTE    : None
 * -------------------------------------------------------------------------
 */
BOOL_T SWCTRL_SetPortPrivateMode(UI32_T ifindex, UI32_T port_private_mode)
{
    BOOL_T ret_val = TRUE;
    UI8_T uplink_ports[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST];
    UI8_T downlink_port[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST];

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (ifindex == 0 || ifindex > SYS_ADPT_TOTAL_NBR_OF_LPORT)
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Logical Port ID (1-%d)", SYS_ADPT_TOTAL_NBR_OF_LPORT);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_LOGICAL_PORT_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    SWCTRL_ENTER_XOR_CRITICAL_SECTION(&ret_val);

    SWCTRL_XOR_CHECK(
        SYSCTRL_XOR_MGR_PermitBeingSetToPrivatePortByIfindex(ifindex));

    SWCTRL_LOCK();

    if (VAL_portPrivateMode_disabled == port_private_mode)
    {
        /* uplink port
         */
        if (port_info[ifindex-1].private_vlan_uplink_port == TRUE)
        {
            SWCTRL_UNLOCK();
            SWCTRL_BREAK_XOR_CRITICAL_SECTION(FALSE);
        }

        SWCTRL_GetPrivateVlanPortList(TRUE,  uplink_ports);
        SWCTRL_GetPrivateVlanPortList(FALSE, downlink_port);

        uplink_ports[UI8_T_ARRAY_INDEX_BY_IFINDEX(ifindex)] |= BIT_IN_UI8_T_BY_IFINDEX(ifindex);
        downlink_port[UI8_T_ARRAY_INDEX_BY_IFINDEX(ifindex)] &= ~(BIT_IN_UI8_T_BY_IFINDEX(ifindex));

        if (SWCTRL_SetPrivateVlan_(uplink_ports, downlink_port))
        {
            SWCTRL_UNLOCK();
            SWCTRL_BREAK_XOR_CRITICAL_SECTION(TRUE);
        }
    }
    else if(VAL_portPrivateMode_enabled == port_private_mode)
    {
        /* downlink port
         */
        if (port_info[ifindex-1].private_vlan_downlink_port == TRUE)
        {
            SWCTRL_UNLOCK();
            SWCTRL_BREAK_XOR_CRITICAL_SECTION(TRUE);
        }

        SWCTRL_GetPrivateVlanPortList(TRUE,  uplink_ports);
        SWCTRL_GetPrivateVlanPortList(FALSE, downlink_port);

        uplink_ports[UI8_T_ARRAY_INDEX_BY_IFINDEX(ifindex)] &= ~(BIT_IN_UI8_T_BY_IFINDEX(ifindex));
        downlink_port[UI8_T_ARRAY_INDEX_BY_IFINDEX(ifindex)] |= BIT_IN_UI8_T_BY_IFINDEX(ifindex);

        if (SWCTRL_SetPrivateVlan_(uplink_ports, downlink_port))
        {
            SWCTRL_UNLOCK();
            SWCTRL_BREAK_XOR_CRITICAL_SECTION(TRUE);
        }
    }

    SWCTRL_UNLOCK();
    SWCTRL_LEAVE_XOR_CRITICAL_SECTION();
    SWCTRL_RETURN_AND_RELEASE_CSC(ret_val);

}/*End of SWCTRL_SetPortPrivateMode () */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetPortPrivateMode
 * -------------------------------------------------------------------------
 * FUNCTION: This function will get the private mode for the specified port
 * INPUT   : ifindex            -- the specified port index
 * OUTPUT  : port_private_mode  -- VAL_portPrivateMode_enabled (1L) : private port
 *                                 VAL_portPrivateMode_disabled (2L): public port
 * RETURN  : TRUE/FALSE
 * NOTE    : None
 * -------------------------------------------------------------------------
 */
BOOL_T SWCTRL_GetPortPrivateMode(UI32_T ifindex, UI32_T *port_private_mode)
{
    if (ifindex == 0 || ifindex > SYS_ADPT_TOTAL_NBR_OF_LPORT || port_private_mode == NULL)
        return FALSE;

    /* not support trunk port currently; trunk member is always rejected */
    if (SWCTRL_IS_TRUNK(ifindex) || SWCTRL_IS_TRUNK_MEMBER(ifindex))
        return FALSE;

    SWCTRL_LOCK();

    if (port_info[ifindex-1].private_vlan_downlink_port == TRUE)
        *port_private_mode = VAL_portPrivateMode_enabled;
    else
        *port_private_mode = VAL_portPrivateMode_disabled;

    SWCTRL_UNLOCK();
    return TRUE;
} /* End of SWCTRL_GetPortPrivateMode() */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetNextPortPrivateMode
 * -------------------------------------------------------------------------
 * FUNCTION: This function will get the private mode for the next port
 * INPUT   : ifindex            -- which port to get
 * OUTPUT  : ifindex            -- the next port index
 *           port_private_mode  -- VAL_portPrivateMode_enabled (1L) : private port
 *                                 VAL_portPrivateMode_disabled (2L): public port
 * RETURN  : TRUE/FALSE
 * NOTE    : None
 * -------------------------------------------------------------------------
 */
BOOL_T SWCTRL_GetNextPortPrivateMode(UI32_T *ifindex, UI32_T *port_private_mode)
{
    if (ifindex == NULL || port_private_mode == NULL)
        return FALSE;

    while (SWCTRL_GetNextLogicalPort(ifindex) != SWCTRL_LPORT_UNKNOWN_PORT)
    {
        /* not support trunk port currently */
        if (SWCTRL_IS_TRUNK(*ifindex))
            continue;

        else
        {
            SWCTRL_LOCK();

            if (port_info[*ifindex-1].private_vlan_downlink_port == TRUE)
                *port_private_mode = VAL_portPrivateMode_enabled;
            else
                *port_private_mode = VAL_portPrivateMode_disabled;

            SWCTRL_UNLOCK();
            return TRUE;
        }
    }

    return FALSE;
}

/*--------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetRunningPortPrioQueueMode
 *---------------------------------------------------------------------------
 * PURPOSE:  This function will get the running config of PrivateMode of the
 *           specified port.
 * INPUT:    ifindex           -- which port to get
 * OUTPUT:   port_private_mode -- VAL_portPrivateMode_enabled (1L) : private port
 *                                VAL_portPrivateMode_disabled (2L): public port
 * RETURN:   SYS_TYPE_GET_RUNNING_CFG_FAIL -- error (system is not in MASTER mode)
 *           SYS_TYPE_GET_RUNNING_CFG_NO_CHANGE -- same as default
 *           SYS_TYPE_GET_RUNNING_CFG_SUCCESS -- different from default value
 * NOTE:
 *---------------------------------------------------------------------------
 */
SYS_TYPE_Get_Running_Cfg_T SWCTRL_GetRunningPortPrivateMode(UI32_T ifindex, UI32_T *port_private_mode)
{
    if (port_private_mode == NULL)
        return SYS_TYPE_GET_RUNNING_CFG_FAIL;

    /* not support trunk port currently; trunk member is always rejected */
    if (SWCTRL_IS_TRUNK(ifindex) || SWCTRL_IS_TRUNK_MEMBER(ifindex))
        return SYS_TYPE_GET_RUNNING_CFG_FAIL;

    SWCTRL_LOCK();

    if (port_info[ifindex-1].private_vlan_downlink_port == TRUE)
    {
        *port_private_mode = VAL_portPrivateMode_enabled;
        SWCTRL_UNLOCK();
        return SYS_TYPE_GET_RUNNING_CFG_SUCCESS;
    }
    else
    {
        *port_private_mode = VAL_portPrivateMode_disabled;
        SWCTRL_UNLOCK();
        return SYS_TYPE_GET_RUNNING_CFG_NO_CHANGE;
    }
}
#endif /* #if (SYS_DFLT_TRAFFIC_SEG_METHOD == SYS_DFLT_TRAFFIC_SEG_METHOD_PORT_PRIVATE_MODE) */
#endif /* #if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION == TRUE) */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetPrivateVlan
 * -------------------------------------------------------------------------
 * FUNCTION:
 * INPUT   :
 * OUTPUT  :
 * RETURN  :
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_GetPrivateVlan(SWCTRL_PrivateVlan_T *private_vlan)
{
    UI32_T ifindex;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (private_vlan == 0)
    {
        EH_MGR_Handle_Exception (SYS_MODULE_SWCTRL,
                                 SWCTRL_NO_USE_FUNC_NO,
                                 EH_TYPE_MSG_NULL_POINTER,
                                 EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_CRIT); /*SWCTRL_ENO_NULL_POINTER*/
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    memset(private_vlan, 0, sizeof(SWCTRL_PrivateVlan_T));

    SWCTRL_LOCK();
    private_vlan->vlan_status = system_info.is_private_vlan_enable;

    SWCTRL_GetPrivateVlanPortList(TRUE, private_vlan->uplink_ports);
    SWCTRL_GetPrivateVlanPortList(FALSE, private_vlan->downlink_ports);
    SWCTRL_UNLOCK();

    /* trunk member port shall be invisible*/
    for (ifindex=1; ifindex<=SYS_ADPT_TOTAL_NBR_OF_LPORT; ifindex++)
    {
        if (SWCTRL_IS_TRUNK_MEMBER(ifindex))
        {
            private_vlan->uplink_ports[UI8_T_ARRAY_INDEX_BY_IFINDEX(ifindex)] &= ~ BIT_IN_UI8_T_BY_IFINDEX(ifindex);
            private_vlan->downlink_ports[UI8_T_ARRAY_INDEX_BY_IFINDEX(ifindex)] &= ~ BIT_IN_UI8_T_BY_IFINDEX(ifindex);
        }
    }

    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
}/*End of SWCTRL_GetPrivateVlan () */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetPrivateVlanStatus
 * -------------------------------------------------------------------------
 * FUNCTION: This function will get the private vlan status
 * INPUT   : None
 * OUTPU   : vlan_status -- VAL_privateVlanStatus_enabled/VAL_privateVlanStatus_disabled
 * RETURN  : True: Successfully, FALSE: Failed
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_GetPrivateVlanStatus(UI32_T *vlan_status)
{
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (vlan_status == 0)
    {
        EH_MGR_Handle_Exception (SYS_MODULE_SWCTRL,
                                 SWCTRL_NO_USE_FUNC_NO,
                                 EH_TYPE_MSG_NULL_POINTER,
                                 EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_CRIT); /*SWCTRL_ENO_NULL_POINTER*/
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    *vlan_status = system_info.is_private_vlan_enable;

    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
}/* End of SWCTRL_GetPrivateVlanStatus () */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetRunningPrivateVlanStatus
 * -------------------------------------------------------------------------
 * FUNCTION: This function will get the private vlan running config
 * INPUT   : None
 * OUTPU   : vlan_status -- VAL_privateVlanStatus_enabled/VAL_privateVlanStatus_disabled
 * RETURN  : SYS_TYPE_Get_Running_Cfg_T
 * NOTE    : None
 * -------------------------------------------------------------------------*/
SYS_TYPE_Get_Running_Cfg_T SWCTRL_GetRunningPrivateVlanStatus(UI32_T *vlan_status)
{
    SWCTRL_USE_CSC_CHECK_OPER_MODE(SYS_TYPE_GET_RUNNING_CFG_FAIL);

    if (vlan_status == 0)
    {
        EH_MGR_Handle_Exception (SYS_MODULE_SWCTRL,
                                 SWCTRL_NO_USE_FUNC_NO,
                                 EH_TYPE_MSG_NULL_POINTER,
                                 EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_CRIT); /*SWCTRL_ENO_NULL_POINTER*/
        SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_FAIL );
    }

    *vlan_status = system_info.is_private_vlan_enable;

    if (*vlan_status != SYS_DFLT_PRIVATE_VLAN_STATUS)
        SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_SUCCESS )
    else
        SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_NO_CHANGE )

}/* End of SWCTRL_GetRunningPrivateVlanStatus () */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetRunningPrivateVlanUplinkPortList
 * -------------------------------------------------------------------------
 * FUNCTION: This function will get the private vlan running config
 * INPUT   : None
 * OUTPU   : uplink_port_list -- uplink port list
 * RETURN  : SYS_TYPE_Get_Running_Cfg_T
 * NOTE    : None
 * -------------------------------------------------------------------------*/
SYS_TYPE_Get_Running_Cfg_T SWCTRL_GetRunningPrivateVlanUplinkPortList(
                                UI8_T uplink_port_list[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST])
{
    UI32_T ifindex;
    UI32_T i;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(SYS_TYPE_GET_RUNNING_CFG_FAIL);

    SWCTRL_LOCK();
    SWCTRL_GetPrivateVlanPortList(TRUE, uplink_port_list);

    /* return uport only
     */
    ifindex = 0;
    while (SWCTRL_GetNextIndexFromPortList (&ifindex, uplink_port_list))
    {
        if (SWCTRL_IS_TRUNK(ifindex))
        {
            UI32_T trunk_id;
            UI32_T member_ifindex;

            trunk_id = port_info[ifindex-1].port_entry.port_trunk_index;

            for (i = 0; i < trunk_ext_port_info[trunk_id-1].member_number; i++)
            {
                member_ifindex = SWCTRL_UPORT_TO_IFINDEX(
                    trunk_ext_port_info[trunk_id-1].member_list[i].unit,
                    trunk_ext_port_info[trunk_id-1].member_list[i].port);
                uplink_port_list[UI8_T_ARRAY_INDEX_BY_IFINDEX(member_ifindex)] |= BIT_IN_UI8_T_BY_IFINDEX(member_ifindex);
            }

            uplink_port_list[UI8_T_ARRAY_INDEX_BY_IFINDEX(ifindex)] &= ~ BIT_IN_UI8_T_BY_IFINDEX(ifindex);
        }
    }
    SWCTRL_UNLOCK();

#if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION == TRUE)
#if (SYS_DFLT_TRAFFIC_SEG_METHOD == SYS_DFLT_TRAFFIC_SEG_METHOD_PORT_PRIVATE_MODE)
    for(i=0; i<SYS_ADPT_TOTAL_NBR_OF_LPORT; i++)
    {
        if (!port_info[i].private_vlan_uplink_port)
        {
            SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_SUCCESS );
        }
    }
#else
    for(i=0; i<SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST; i++)
    {
        if (uplink_port_list[i])
        {
            SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_SUCCESS );
        }
    }
#endif
#endif

    SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_NO_CHANGE );
} /* end of SWCTRL_GetRunningPrivateVlanUplinkPortList () */

/*--------------------------------------------------------------------------
 * FUNCTION NAME - SWCTRL_IsPortPrivateVlanUplinkMember
 *--------------------------------------------------------------------------
 * PURPOSE  : This funcion returns true if current port is in private vlan's
 *            uplink member list.  Otherwise, returns false.
 * INPUT    : ifindex -- the specified port
 * OUTPUT   : none
 * RETURN   : TRUE \ FALSE
 * NOTES    : none
 *--------------------------------------------------------------------------*/
BOOL_T SWCTRL_IsPortPrivateVlanUplinkMember(UI32_T ifindex)
{
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

#if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE == SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE_MULTIPLE_SESSION)
    SWCTRL_RETURN_AND_RELEASE_CSC( swctl_private_vlan_port_info[ifindex-1].private_vlan_uplink_port );
#else
    SWCTRL_RETURN_AND_RELEASE_CSC( port_info[ifindex-1].private_vlan_uplink_port );
#endif
} /* End of SWCTRL_IsPortPrivateVlanUplinkMember () */

/*--------------------------------------------------------------------------
 * FUNCTION NAME - SWCTRL_IsPortPrivateVlanDownlinkMember
 *--------------------------------------------------------------------------
 * PURPOSE  : This funcion returns true if current port is in private vlan's
 *            downlink member list.  Otherwise, returns false.
 * INPUT    : ifindex -- the specified port
 * OUTPUT   : none
 * RETURN   : TRUE \ FALSE
 * NOTES    : none
 *--------------------------------------------------------------------------*/
BOOL_T SWCTRL_IsPortPrivateVlanDownlinkMember(UI32_T ifindex)
{
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

#if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE == SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE_MULTIPLE_SESSION)
    SWCTRL_RETURN_AND_RELEASE_CSC( swctl_private_vlan_port_info[ifindex-1].private_vlan_downlink_port );
#else
    SWCTRL_RETURN_AND_RELEASE_CSC( port_info[ifindex-1].private_vlan_downlink_port );
#endif
} /* End of SWCTRL_IsPortPrivateVlanDownlinkMember () */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetRunningPrivateVlanDownlinkPortList
 * -------------------------------------------------------------------------
 * FUNCTION: This function will get the private vlan running config
 * INPUT   : None
 * OUTPU   : downlink_port_list -- downlink port list
 * RETURN  : SYS_TYPE_Get_Running_Cfg_T
 * NOTE    : None
 * -------------------------------------------------------------------------*/
SYS_TYPE_Get_Running_Cfg_T SWCTRL_GetRunningPrivateVlanDownlinkPortList(
                                UI8_T downlink_port_list[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST])
{
    UI32_T ifindex;
    UI32_T i;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(SYS_TYPE_GET_RUNNING_CFG_FAIL);

    if (downlink_port_list == 0)
    {
        EH_MGR_Handle_Exception (SYS_MODULE_SWCTRL,
                                 SWCTRL_NO_USE_FUNC_NO,
                                 EH_TYPE_MSG_NULL_POINTER,
                                 EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_CRIT); /*SWCTRL_ENO_NULL_POINTER*/
        SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_FAIL );
    }

    SWCTRL_LOCK();
    SWCTRL_GetPrivateVlanPortList(FALSE, downlink_port_list);

    /* return uport only
     */
    ifindex = 0;
    while (SWCTRL_GetNextIndexFromPortList (&ifindex, downlink_port_list))
    {
        if (SWCTRL_IS_TRUNK(ifindex))
        {
            UI32_T trunk_id;
            UI32_T member_ifindex;

            trunk_id = port_info[ifindex-1].port_entry.port_trunk_index;

            for (i = 0; i < trunk_ext_port_info[trunk_id-1].member_number; i++)
            {
                member_ifindex = SWCTRL_UPORT_TO_IFINDEX(
                    trunk_ext_port_info[trunk_id-1].member_list[i].unit,
                    trunk_ext_port_info[trunk_id-1].member_list[i].port);
                downlink_port_list[UI8_T_ARRAY_INDEX_BY_IFINDEX(member_ifindex)] |= BIT_IN_UI8_T_BY_IFINDEX(member_ifindex);
            }

            downlink_port_list[UI8_T_ARRAY_INDEX_BY_IFINDEX(ifindex)] &= ~ BIT_IN_UI8_T_BY_IFINDEX(ifindex);
        }
    }
    SWCTRL_UNLOCK();

    for(i=0; i<SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST; i++)
    {
        if (downlink_port_list[i])
        {
            SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_SUCCESS );
        }
    }

    SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_NO_CHANGE );
} /* end of SWCTRL_GetRunningPrivateVlanDownlinkPortList () */
#endif /* end of #if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION == TRUE) */
#if (SYS_CPNT_ISOLATED_PRIVATE_VLAN == TRUE)
/*-------------------------------------------------------------------------
 * FUNCTION NAME - SWCTRL_SetIsolatedPVlan
 * ------------------------------------------------------------------------
 * PURPOSE  :   This function returns true if the isolated private vlan is
 *              set successfully. Otherwise, false is returned.
 * INPUT    :   uplink_lport_list   -- the lport list of the uplink port in
 *                                     the format of bit map with the length of
 *SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST/8
 *                                     bytes
 *              downlink_lport_list -- the lport list of the downlink port in
 *                                     the format of bit map with the length of
 *SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST/8
 *                                     bytes
 *              vid                 -- isolated private vlan ID
 * OUTPUT   :   None
 * RETURN   :   TRUE/FALSE
 * NOTES    :   None.
 * ------------------------------------------------------------------------
 */
BOOL_T SWCTRL_SetIsolatedPVlan( UI8_T   *uplink_lport_list,
                                UI8_T   *downlink_lport_list,
                                UI32_T   vid
                              )
{
    UI8_T  uplink_uport_cnt = 0;
    UI8_T  downlink_uport_cnt = 0;
    UI32_T ifindex,i,j;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

     if ((uplink_lport_list == 0) || (downlink_lport_list == 0))
    {
        /*UIMSG_MGR_SetErrorCode(); */ /*SWCTRL_ENO_NULL_POINTER*/
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    SWCTRL_LOCK();
     /* a port should not be up-link and down-link port at the same time
     */
    for (i=0; i<SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST; i++)
    {
        if (uplink_lport_list[i] == 0)
        {
            continue;
        }

        for (j=0; j<8; j++)
        {
            if ((uplink_lport_list[i]<<j) & 0x80)
            {
                if ((downlink_lport_list[i]<<j) & 0x80)
                {
                    SWCTRL_UNLOCK();
                    /*UIMSG_MGR_SetErrorCode(); */ /*SWCTRL_ENO_PVLAN_UP_DOWN_LINK_ON_THE_SAME_PORT*/
                    SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
                }
            }
        }
    }

    /* uplink_lport_list ==> uplink_uport_list
     */
    ifindex = 0;
    while (SWCTRL_GetNextIndexFromPortList (&ifindex, uplink_lport_list))
    {
        /* Unknown port
         */
        if(!SWCTRL_IS_EXIST(ifindex))
        {
            SWCTRL_UNLOCK();
            /*UIMSG_MGR_SetErrorCode(); */ /*xxxxxxxxx*/
            SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
        }

        /* Trunk member
         */
        if(SWCTRL_IS_TRUNK_MEMBER(ifindex))
        {
          /*  SWCTRL_UNLOCK();*/
            /*UIMSG_MGR_SetErrorCode(); */ /*xxxxxxxxx*/
          /*  SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );*/
            uplink_uport_list[uplink_uport_cnt].unit = 0xFFFF;
            uplink_uport_list[uplink_uport_cnt].port = port_info[ifindex-1].port_entry.port_trunk_index;
            uplink_uport_cnt++;
            uplink_uport_list[uplink_uport_cnt].unit = SWCTRL_IFINDEX_TO_UNIT(ifindex);
            uplink_uport_list[uplink_uport_cnt].port = SWCTRL_IFINDEX_TO_PORT(ifindex);
            uplink_uport_cnt++;

        }

        /* Normal port
         */
        if(SWCTRL_IS_USER_PORT (ifindex))
        {
            uplink_uport_list[uplink_uport_cnt].unit = SWCTRL_IFINDEX_TO_UNIT(ifindex);
            uplink_uport_list[uplink_uport_cnt].port = SWCTRL_IFINDEX_TO_PORT(ifindex);
            uplink_uport_cnt++;
        }

        /* Trunk port
         */
        if(SWCTRL_IS_TRUNK (ifindex))
        {
            if (trunk_ext_port_info[port_info[ifindex-1].port_entry.port_trunk_index -1].member_number ==0 )
            {
            SWCTRL_UNLOCK();
            /*UIMSG_MGR_SetErrorCode(); */ /*xxxxxxxxx*/
            SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
            }
            else
            {
                uplink_uport_list[uplink_uport_cnt].unit = 0xFFFF;
                uplink_uport_list[uplink_uport_cnt].port = port_info[ifindex-1].port_entry.port_trunk_index;
                uplink_uport_cnt++;
                uplink_uport_list[uplink_uport_cnt].unit = trunk_ext_port_info[port_info[ifindex-1].port_entry.port_trunk_index -1].member_list[0].unit;
                uplink_uport_list[uplink_uport_cnt].port = trunk_ext_port_info[port_info[ifindex-1].port_entry.port_trunk_index -1].member_list[0].port;
                uplink_uport_cnt++;
            }

        } /* End of if () */
    } /* End of while */

     /* downlink_lport_list ==> downlink_uport_list
     */
    ifindex = 0;
    while (SWCTRL_GetNextIndexFromPortList (&ifindex, downlink_lport_list))
    {
        /* Unknown port
         */
        if(!SWCTRL_IS_EXIST(ifindex))
        {
            SWCTRL_UNLOCK();
            /*UIMSG_MGR_SetErrorCode(); */ /*xxxxxxxxx*/
            SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
        }

        /* Trunk member
         */
        if(SWCTRL_IS_TRUNK_MEMBER(ifindex))
        {
            SWCTRL_UNLOCK();
            /*UIMSG_MGR_SetErrorCode(); */ /*xxxxxxxxx*/
            SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
        }

        /* Normal port
         */
        if(SWCTRL_IS_USER_PORT (ifindex))
        {
            downlink_uport_list[downlink_uport_cnt].unit = SWCTRL_IFINDEX_TO_UNIT(ifindex);
            downlink_uport_list[downlink_uport_cnt].port = SWCTRL_IFINDEX_TO_PORT(ifindex);
            downlink_uport_cnt++;
        }

        /* Trunk port
         */
        if(SWCTRL_IS_TRUNK (ifindex))
        {
            SWCTRL_UNLOCK();
            /*UIMSG_MGR_SetErrorCode(); */ /*SWCTRL_ENO_PVLAN_TRUNK*/
            SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
        } /* End of if () */
    } /* End of while */


    if (FALSE == SWDRV_SetIsolatedPVlan(uplink_uport_list, uplink_uport_cnt,
                      downlink_uport_list, downlink_uport_cnt, vid))
    {
        SWCTRL_UNLOCK();
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
    SWCTRL_UNLOCK();
    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
}

#endif /* end of #if (SYS_CPNT_ISOLATED_PRIVATE_VLAN == TRUE) */


#if (SYS_CPNT_INGRESS_RATE_LIMIT == TRUE)
/*******************
 * Rate Limit APIs *
 *******************/
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_EnablePortIngressRateLimit
 * -------------------------------------------------------------------------
 * FUNCTION: This function will enable the port ingress rate limit
 * INPUT   : ifindex -- which port to enable
 * OUTPUT  : None
 * RETURN  : True: Successfully, FALSE: Failed
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_EnablePortIngressRateLimit(UI32_T ifindex)
{
    BOOL_T retval;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (!SWCTRL_IS_LPORT(ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }


#if (SYS_CPNT_NETACCESS_DYNAMIC_QOS == TRUE)
    if (port_info[ifindex-1].ingress_rate_limit_dynamic_cfg == TRUE)
    {
        retval = SWCTRL_SetPortIngressRateLimit(ifindex, port_info[ifindex-1].ingress_rate_limit_user_cfg);
    }
    else
#endif /* #if (SYS_CPNT_NETACCESS_DYNAMIC_QOS == TRUE) */
    {
        retval = SWCTRL_SetPortIngressRateLimit(ifindex, port_info[ifindex-1].ingress_rate_limit);
    }

    SWCTRL_RETURN_AND_RELEASE_CSC( retval );
}/* end of SWCTRL_EnablePortIngressRateLimit () */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_DisablePortIngressRateLimit
 * -------------------------------------------------------------------------
 * FUNCTION: This function will disable the port ingress rate limit
 * INPUT   : ifindex -- which port to disable
 * OUTPUT  : None
 * RETURN  : True: Successfully, FALSE: Failed
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_DisablePortIngressRateLimit(UI32_T ifindex)
{
    BOOL_T retval;
    UI8_T unit, port;
    UI32_T l_port = ifindex;
    UI32_T i, trunk_id;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (!SWCTRL_IS_LPORT(ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (!SWCTRL_IS_TRUNK (l_port))
    {
        unit = SWCTRL_IFINDEX_TO_UNIT(l_port);
        port = SWCTRL_IFINDEX_TO_PORT(l_port);

#if (SYS_CPNT_MGMT_PORT == TRUE)
        if (port == SYS_ADPT_MGMT_PORT)
        {
#if 0
            EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                      SWCTRL_NO_USE_FUNC_NO,
                                      EH_TYPE_MSG_MGMT_PORT_CNFG,
                                      SYSLOG_LEVEL_INFO,
                                      "Ingress Rate Limit");  /*SWCTRL_ENO_NOT_SUPPORT_MGMT_PORT*/

            SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
#else
            SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
#endif
        }
#endif

    #if (SYS_CPNT_NETACCESS_DYNAMIC_QOS == TRUE)
        if (port_info[l_port-1].ingress_rate_limit_dynamic_cfg == TRUE)
        {
            if (port_info[l_port-1].ingress_rate_limit_status_user_cfg == VAL_rlPortInputStatus_disabled)
                SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
        }
        else
    #endif /* #if (SYS_CPNT_NETACCESS_DYNAMIC_QOS == TRUE) */
        {
            if (port_info[l_port-1].ingress_rate_limit_status == VAL_rlPortInputStatus_disabled)
                SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
        }

        SWCTRL_LOCK();

    #if (SYS_CPNT_NETACCESS_DYNAMIC_QOS == TRUE)
        /* If ingress_rate_limit_dynamic_cfg is TRUE, the ingress rate limit status is
         * configured by SWCTRL_SetDynamicPortIngressRateLimit from NETACCESS directly.
         * So it's not necessary to call SWDRV_DisablePortIngressRateLimit
         */
        if (port_info[l_port-1].ingress_rate_limit_dynamic_cfg == TRUE)
        {
            port_info[l_port-1].ingress_rate_limit_status_user_cfg = VAL_rlPortInputStatus_disabled;
            retval = TRUE;
        }
        else
    #endif /* #if (SYS_CPNT_NETACCESS_DYNAMIC_QOS == TRUE) */
        {
            if ((retval = SWDRV_DisablePortIngressRateLimit (unit, port, 0)) == TRUE)
                port_info[l_port-1].ingress_rate_limit_status = VAL_rlPortInputStatus_disabled;
        }

        SWCTRL_UNLOCK();
    }

    if (SWCTRL_IS_TRUNK (l_port))
    {
        trunk_id = SWCTRL_IFINDEX_TO_TRUNKID (l_port);

        /* if no member, should not set
         */
        if(trunk_ext_port_info[trunk_id-1].member_number == 0)
        {
            EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                      SWCTRL_NO_USE_FUNC_NO,
                                      EH_TYPE_MSG_TRUNK_CNFG_ERR,
                                      SYSLOG_LEVEL_INFO,
                                      "Trunk contains no members");  /*SWCTRL_ENO_NO_MEMBER_IN_TRUNK*/

            SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
        }

        for(i=0; i<trunk_ext_port_info[trunk_id-1].member_number; i++)
        {
            UI32_T member_ifindex;

            unit = trunk_ext_port_info[trunk_id-1].member_list[i].unit;
            port = trunk_ext_port_info[trunk_id-1].member_list[i].port;

#if (SYS_CPNT_MGMT_PORT == TRUE)
            if (port == SYS_ADPT_MGMT_PORT)
            {
            EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                      SWCTRL_NO_USE_FUNC_NO,
                                      EH_TYPE_MSG_MGMT_PORT_CNFG,
                                      SYSLOG_LEVEL_INFO,
                                      "Ingress Rate Limit");  /*SWCTRL_ENO_NOT_SUPPORT_MGMT_PORT*/

                SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
            }
#endif

            SWCTRL_LOCK();

            SWCTRL_UserPortToIfindex(unit, port, &member_ifindex);

        #if (SYS_CPNT_NETACCESS_DYNAMIC_QOS == TRUE)
            /* If ingress_rate_limit_dynamic_cfg is TRUE, the ingress rate limit status is
             * configured by SWCTRL_SetDynamicPortIngressRateLimit from NETACCESS directly.
             * So it's not necessary to call SWDRV_DisablePortIngressRateLimit
             */
            if (port_info[l_port-1].ingress_rate_limit_dynamic_cfg == TRUE)
            {
                port_info[member_ifindex-1].ingress_rate_limit_status_user_cfg = VAL_rlPortInputStatus_disabled;
                retval = TRUE;
            }
            else
        #endif /* #if (SYS_CPNT_NETACCESS_DYNAMIC_QOS == TRUE) */
            {
                if ((retval = SWDRV_DisablePortIngressRateLimit (unit, port, 0)) == TRUE)
                {
                    port_info[member_ifindex-1].ingress_rate_limit_status = VAL_rlPortInputStatus_disabled;
                }
            }

            SWCTRL_UNLOCK();
        }
        if (retval == TRUE)
        {
            SWCTRL_LOCK();
        #if (SYS_CPNT_NETACCESS_DYNAMIC_QOS == TRUE)
            if (port_info[l_port-1].ingress_rate_limit_dynamic_cfg == TRUE)
            {
                port_info[l_port-1].ingress_rate_limit_status_user_cfg = VAL_rlPortInputStatus_disabled;
            }
            else
        #endif /* #if (SYS_CPNT_NETACCESS_DYNAMIC_QOS == TRUE) */
            {
                if ((retval = SWDRV_DisablePortIngressRateLimit (1, 1, trunk_id)) == TRUE)
                {
                port_info[l_port-1].ingress_rate_limit_status = VAL_rlPortInputStatus_disabled;
                }
            }
            SWCTRL_UNLOCK();
        }
    }

    SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME();
    SWCTRL_RETURN_AND_RELEASE_CSC( retval );
}/* end of SWCTRL_DisablePortIngressRateLimit () */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetPortIngressRateLimit
 * -------------------------------------------------------------------------
 * FUNCTION: This function will set the port ingress rate limit
 * INPUT   : ifindex -- which port to set
 *           rate -- port ingress rate limit
 * OUTPUT  : None
 * RETURN  : True: Successfully, FALSE: Failed
 * NOTE    : # kbits
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetPortIngressRateLimit(UI32_T ifindex, UI32_T rate)
{
    BOOL_T retval = FALSE;
    UI32_T unit, port, trunk_id, om_idx;
    UI32_T config_rate;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (!SWCTRL_IS_LPORT(ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

#if (SYS_CPNT_INGRESS_RATELIMIT_BSTORM_MSTORM_XOR_EACH_OTHER == TRUE)
    retval = SWCTRL_DisableAllRateLimitAndStormsStatus(ifindex);
#endif

    config_rate = SWCTRL_ConvertUserRateLimitToPhy(port_info[ifindex-1].port_entry.port_type, rate);

    /* the ifindex is normal port
     */
    if (!SWCTRL_IS_TRUNK (ifindex))
    {
        unit = SWCTRL_IFINDEX_TO_UNIT(ifindex);
        port = SWCTRL_IFINDEX_TO_PORT(ifindex);

#if (SYS_CPNT_MGMT_PORT == TRUE)
        if (port == SYS_ADPT_MGMT_PORT)
        {
#if 0
            EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                      SWCTRL_NO_USE_FUNC_NO,
                                      EH_TYPE_MSG_MGMT_PORT_CNFG,
                                      SYSLOG_LEVEL_INFO,
                                      "Ingress Rate Limit");  /*SWCTRL_ENO_NOT_SUPPORT_MGMT_PORT*/

            SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
#else
            SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
#endif
        }
#endif

        if (SWCTRL_CheckRateLimitRange(port_info[ifindex-1].port_entry.port_type, rate) == FALSE)
            SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );

        /* The original setting is the same caller wish
         */
#if (SYS_CPNT_NETACCESS_DYNAMIC_QOS == TRUE)
        if(port_info[ifindex-1].ingress_rate_limit_dynamic_cfg == TRUE)
        {
            if((port_info[ifindex-1].ingress_rate_limit_user_cfg == rate) &&
                (VAL_rlPortInputStatus_enabled == port_info[ifindex - 1].ingress_rate_limit_status_user_cfg))
                SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
        }
        else
#endif /* #if (SYS_CPNT_NETACCESS_DYNAMIC_QOS == TRUE) */
        {
            if((port_info[ifindex-1].ingress_rate_limit == rate) &&
                (VAL_rlPortInputStatus_enabled == port_info[ifindex - 1].ingress_rate_limit_status))
            SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
        }

        SWCTRL_LOCK();

#if (SYS_CPNT_NETACCESS_DYNAMIC_QOS == TRUE)
        /* If ingress_rate_limit_dynamic_cfg is TRUE, the ingress rate limit is
         * configured by SWCTRL_SetDynamicPortIngressRateLimit from NETACCESS directly.
         * So it's not necessary to call SWDRV_SetPortIngressRateLimit
         */
        if(port_info[ifindex-1].ingress_rate_limit_dynamic_cfg == TRUE)
        {
            port_info[ifindex-1].ingress_rate_limit_user_cfg = rate;
            port_info[ifindex-1].ingress_rate_limit_status_user_cfg = VAL_rlPortInputStatus_enabled;
            retval = TRUE;
        }
        else
#endif /* #if (SYS_CPNT_NETACCESS_DYNAMIC_QOS == TRUE) */
        {
            if((retval = SWDRV_SetPortIngressRateLimit(unit, port, 0, config_rate)) == TRUE)
            {
                port_info[ifindex - 1].ingress_rate_limit = rate;
                port_info[ifindex - 1].ingress_rate_limit_status = VAL_rlPortInputStatus_enabled;
            }
        }

        SWCTRL_UNLOCK();
    }

    /* the ifindex is trunk port
     */
    if (SWCTRL_IS_TRUNK (ifindex))
    {
        trunk_id = SWCTRL_IFINDEX_TO_TRUNKID (ifindex);

        /* if no member, should not set
         */
        if(trunk_ext_port_info[trunk_id-1].member_number == 0)
        {
            EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                      SWCTRL_NO_USE_FUNC_NO,
                                      EH_TYPE_MSG_TRUNK_CNFG_ERR,
                                      SYSLOG_LEVEL_INFO,
                                      "Trunk contains no members");  /*SWCTRL_ENO_NO_MEMBER_IN_TRUNK*/

            SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
        }

        if(SWCTRL_CheckRateLimitRange(port_info[ifindex-1].port_entry.port_type, rate) == FALSE)
            SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );

        for(om_idx = 0; om_idx <= SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK*SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT - 1; om_idx++)
        {
            UI32_T member_ifindex;

            if(!SWCTRL_IS_EXIST(om_idx+1))
                continue;

            if( SWCTRL_TRUNKID_TO_IFINDEX(port_info[om_idx].port_entry.port_trunk_index) != ifindex)
                continue;

            unit = SWCTRL_IFINDEX_TO_UNIT(om_idx+1);
            port = SWCTRL_IFINDEX_TO_PORT(om_idx+1);

            SWCTRL_LOCK();

            SWCTRL_UserPortToIfindex(unit, port, &member_ifindex);
        #if (SYS_CPNT_NETACCESS_DYNAMIC_QOS == TRUE)
            /* If ingress_rate_limit_dynamic_cfg is TRUE, the ingress rate limit is
             * configured by SWCTRL_SetDynamicPortIngressRateLimit from NETACCESS directly.
             * So it's not necessary to call SWDRV_SetPortIngressRateLimit
             */
            if(port_info[ifindex-1].ingress_rate_limit_dynamic_cfg == TRUE)
            {
                port_info[member_ifindex-1].ingress_rate_limit_user_cfg = rate;
                port_info[member_ifindex-1].ingress_rate_limit_status_user_cfg = VAL_rlPortInputStatus_enabled;
                retval = TRUE;
            }
            else
        #endif /* #if (SYS_CPNT_NETACCESS_DYNAMIC_QOS == TRUE) */
            {
                if((retval = SWDRV_SetPortIngressRateLimit(unit, port, 0, config_rate)) == TRUE)
                {
                    port_info[member_ifindex-1].ingress_rate_limit = rate;
                    port_info[member_ifindex-1].ingress_rate_limit_status = VAL_rlPortInputStatus_enabled;
                }
                else
                {
                    SWCTRL_UNLOCK();

                    /* Error code was set in SWDRV_SetPortIngressRateLimit(); */
                    SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
                }
            }

            SWCTRL_UNLOCK();
        }

        SWCTRL_LOCK();
        if (retval == TRUE)
        {
        #if (SYS_CPNT_NETACCESS_DYNAMIC_QOS == TRUE)
            if(port_info[ifindex-1].ingress_rate_limit_dynamic_cfg == TRUE)
            {
                port_info[ifindex-1].ingress_rate_limit_user_cfg = rate;
                port_info[ifindex-1].ingress_rate_limit_status_user_cfg = VAL_rlPortInputStatus_enabled;
            }
            else
        #endif /* #if (SYS_CPNT_NETACCESS_DYNAMIC_QOS == TRUE) */
            {
                if((retval = SWDRV_SetPortIngressRateLimit(1, 1, trunk_id, config_rate)) == TRUE)
                {
                    port_info[ifindex-1].ingress_rate_limit = rate;
                    port_info[ifindex-1].ingress_rate_limit_status = VAL_rlPortInputStatus_enabled;
                }
                else
                {
                    SWCTRL_UNLOCK();

                    /* Error code was set in SWDRV_SetPortIngressRateLimit(); */
                    SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
                }
            }
        }
        SWCTRL_UNLOCK();
    } /* End of if () */

#if (SYS_CPNT_SWCTRL_SINGLE_INGRESS_RATE_LIMIT == TRUE)
    if (retval)
    {
        retval = SWCTRL_SyncRateLimitThreshold(
                    ifindex,
                    SWCTRL_STORM_SAMPLE_TYPE_OCTET_RATE,
                    config_rate,
                    rate,
                    SYS_CPNT_SWCTRL_RATE_LIMIT_GROUP_FOR_INGRESS_RATE_LIMIT);
    }
#endif

    SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME ();
    SWCTRL_RETURN_AND_RELEASE_CSC( retval );

} /* End of SWCTRL_SetPortIngressRateLimit () */

#if (SYS_CPNT_NETACCESS_DYNAMIC_QOS == TRUE)

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetDynamicPortIngressRateLimit
 * -------------------------------------------------------------------------
 * FUNCTION: This function will set the port ingress rate limit for dynamic qos
 * INPUT   : ifindex -- which port to set
 *           rate -- port ingress rate limit
 * OUTPUT  : None
 * RETURN  : True: Successfully, FALSE: Failed
 * NOTE    : 1. Unit of rate limit is kbits.
 *           2. When apply dynamic port ingress rate limit, the user configured
 *              setting should be saved.
 *           3. The ingress rate limit satus should be enabled, if this function
 *              successed.
 *           4. If rate is 0, restore the dynamic rate limit to user configured.
 *           5. The dynamic ingress limit value is got from authentication server.
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetDynamicPortIngressRateLimit(UI32_T ifindex, UI32_T rate)
{
    enum {RESTORE_TO_MANUAL_CONFIG = 0};

    UI32_T unit, port, trunk_id, om_idx;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    /* the ifindex is normal port
     */
    if(SWCTRL_LogicalPortToUserPort(ifindex, &unit, &port, &trunk_id) == SWCTRL_LPORT_NORMAL_PORT)
    {

#if (SYS_CPNT_MGMT_PORT == TRUE)
        if (port == SYS_ADPT_MGMT_PORT)
        {
#if 0
            EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                      SWCTRL_NO_USE_FUNC_NO,
                                      EH_TYPE_MSG_MGMT_PORT_CNFG,
                                      SYSLOG_LEVEL_INFO,
                                      "Ingress Rate Limit");  /*SWCTRL_ENO_NOT_SUPPORT_MGMT_PORT*/

            SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
#else
            SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
#endif
        }
#endif

        SWCTRL_LOCK();

        if (FALSE == SWCTRL_LocalSetDynamicPortIngressRateLimit(ifindex, rate))
        {
            SWCTRL_UNLOCK();
            SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
        }

        SWCTRL_UNLOCK();

        SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME ();
        SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
    }
    /* the ifindex is trunk port
     */
    if(SWCTRL_LogicalPortToUserPort(ifindex, &unit, &port, &trunk_id) == SWCTRL_LPORT_TRUNK_PORT) /* trunk ??? */
    {
        /* if no member, should not set
         */
        if(trunk_ext_port_info[trunk_id-1].member_number == 0)
        {
            EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                      SWCTRL_NO_USE_FUNC_NO,
                                      EH_TYPE_MSG_TRUNK_CNFG_ERR,
                                      SYSLOG_LEVEL_INFO,
                                      "Trunk contains no members");  /*SWCTRL_ENO_NO_MEMBER_IN_TRUNK*/

            SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
        }

        /* range check : lowest number is 1000 for FE and 8000 for GE for BroadCom chip.
         *               8 level from 1 to 8 for ACD chip.
         */
        if(SWCTRL_CheckRateLimitRange(port_info[ifindex-1].port_entry.port_type, rate) == FALSE)
            SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );

        for(om_idx = 0; om_idx <= SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK*SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT - 1; om_idx++)
        {
            UI32_T member_ifindex;

            if(!SWCTRL_IS_EXIST(om_idx+1))
                continue;

            if( SWCTRL_TRUNKID_TO_IFINDEX(port_info[om_idx].port_entry.port_trunk_index) != ifindex)
                continue;

            unit = SWCTRL_IFINDEX_TO_UNIT(om_idx+1);
            port = SWCTRL_IFINDEX_TO_PORT(om_idx+1);

            SWCTRL_LOCK();

            SWCTRL_UserPortToIfindex(unit, port, &member_ifindex);
            if (FALSE == SWCTRL_LocalSetDynamicPortIngressRateLimit(member_ifindex, rate))
            {
                SWCTRL_UNLOCK();
                SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
            }

            SWCTRL_UNLOCK();
        }

        SWCTRL_LOCK();

        if (rate == RESTORE_TO_MANUAL_CONFIG)
        {
            port_info[ifindex-1].ingress_rate_limit_status =
            port_info[ifindex-1].ingress_rate_limit_status_user_cfg;
            port_info[ifindex-1].ingress_rate_limit =
            port_info[ifindex-1].ingress_rate_limit_user_cfg;

            port_info[ifindex-1].ingress_rate_limit_dynamic_cfg = FALSE;
        }
        else
        {
            /* backup ingress rate limit status and value
             */
            if(port_info[ifindex-1].ingress_rate_limit_dynamic_cfg == FALSE)
            {
                port_info[ifindex-1].ingress_rate_limit_status_user_cfg =
                port_info[ifindex-1].ingress_rate_limit_status;
                port_info[ifindex-1].ingress_rate_limit_user_cfg =
                port_info[ifindex-1].ingress_rate_limit;

                port_info[ifindex-1].ingress_rate_limit_dynamic_cfg = TRUE;
            }

            port_info[ifindex-1].ingress_rate_limit_status = VAL_rlPortInputStatus_enabled;
            port_info[ifindex-1].ingress_rate_limit = rate;
        }

        SWCTRL_UNLOCK();

        SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME ();
        SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
    } /* End of if () */

    EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                              SWCTRL_NO_USE_FUNC_NO,
                              EH_TYPE_MSG_DEB_MSG,
                              EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                              "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

    SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );

}
#endif /* #if (SYS_CPNT_NETACCESS_DYNAMIC_QOS == TRUE) */

/*------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetRunningPortIngressRateLimitStatus
 *------------------------------------------------------------------------
 * FUNCTION: This function will get the ingress rate limit status running config
 * INPUT   : ifindex
 * OUTPUT  : port_ingress_rate_limit_status -- enable/disable
 * RETURN  : SYS_TYPE_Get_Running_Cfg_T
 * NOTE    : None
 *------------------------------------------------------------------------*/
SYS_TYPE_Get_Running_Cfg_T SWCTRL_GetRunningPortIngressRateLimitStatus(UI32_T ifindex, UI32_T *port_ingress_rate_limit_status)
{
    UI32_T l_port = ifindex;
    UI8_T unit, port;
    UI32_T trunk_id;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(SYS_TYPE_GET_RUNNING_CFG_FAIL);

    if (!SWCTRL_IS_LPORT(ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_FAIL );
    }

    if (port_ingress_rate_limit_status == 0)
    {
        EH_MGR_Handle_Exception (SYS_MODULE_SWCTRL,
                                 SWCTRL_NO_USE_FUNC_NO,
                                 EH_TYPE_MSG_NULL_POINTER,
                                 EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_CRIT); /*SWCTRL_ENO_NULL_POINTER*/
        SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_FAIL );
    }

    if (!SWCTRL_IS_TRUNK (l_port))
    {
        unit = SWCTRL_IFINDEX_TO_UNIT(l_port);
        port = SWCTRL_IFINDEX_TO_PORT(l_port);
    }

    if (SWCTRL_IS_TRUNK (l_port))
    {
        trunk_id = SWCTRL_IFINDEX_TO_TRUNKID (ifindex);

        unit = trunk_ext_port_info[trunk_id-1].member_list[1].unit;
        port = trunk_ext_port_info[trunk_id-1].member_list[1].port;
    }

#if (SYS_CPNT_MGMT_PORT == TRUE)
    if (port == SYS_ADPT_MGMT_PORT)
    {
            EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                      SWCTRL_NO_USE_FUNC_NO,
                                      EH_TYPE_MSG_MGMT_PORT_CNFG,
                                      SYSLOG_LEVEL_INFO,
                                      "Ingress Rate Limit");  /*SWCTRL_ENO_NOT_SUPPORT_MGMT_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_FAIL );
    }
#endif

    *port_ingress_rate_limit_status = port_info[l_port-1].ingress_rate_limit_status;

    if (*port_ingress_rate_limit_status != SYS_DFLT_INGRESS_RATE_LIMIT_STATUS)
        SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_SUCCESS )
    else
        SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_NO_CHANGE )

}/* End of SWCTRL_GetRunningPortIngressRateLimitStatus () */
#endif /* #if (SYS_CPNT_INGRESS_RATE_LIMIT == TRUE) */

#if (SYS_CPNT_EGRESS_RATE_LIMIT == TRUE)
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_EnablePortEgressRateLimit
 * -------------------------------------------------------------------------
 * FUNCTION: This function will enable the port Egress rate limit
 * INPUT   : None
 * OUTPUT  : None
 * RETURN  : True: Successfully, FALSE: Failed
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_EnablePortEgressRateLimit(UI32_T ifindex)
{
    BOOL_T retval;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (!SWCTRL_IS_LPORT(ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    retval = SWCTRL_SetPortEgressRateLimit(ifindex, port_info[ifindex-1].egress_rate_limit);

    SWCTRL_RETURN_AND_RELEASE_CSC( retval );
}/* end of SWCTRL_EnablePortEgressRateLimit () */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_DisablePortEgressRateLimit
 * -------------------------------------------------------------------------
 * FUNCTION: This function will disable the port Egress rate limit
 * INPUT   : None
 * OUTPUT  : None
 * RETURN  : True: Successfully, FALSE: Failed
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_DisablePortEgressRateLimit(UI32_T ifindex)
{
    BOOL_T retval;
    UI8_T unit, port;
    UI32_T l_port = ifindex;
    UI32_T i, trunk_id;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (!SWCTRL_IS_LPORT(ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (!SWCTRL_IS_TRUNK (ifindex))
    {
        unit = SWCTRL_IFINDEX_TO_UNIT(ifindex);
        port = SWCTRL_IFINDEX_TO_PORT(ifindex);

#if (SYS_CPNT_MGMT_PORT == TRUE)
        if (port == SYS_ADPT_MGMT_PORT)
        {
#if 0
            EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                      SWCTRL_NO_USE_FUNC_NO,
                                      EH_TYPE_MSG_MGMT_PORT_CNFG,
                                      SYSLOG_LEVEL_INFO,
                                      "Egress Rate Limit");  /*SWCTRL_ENO_NOT_SUPPORT_MGMT_PORT*/

            SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
#else
            SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
#endif
        }
#endif

        if (port_info[l_port-1].egress_rate_limit_status == VAL_rlPortOutputStatus_disabled)
        {
            SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
        }

        SWCTRL_LOCK();
        if ((retval = SWDRV_DisablePortEgressRateLimit (unit, port)) == TRUE)
            port_info[l_port-1].egress_rate_limit_status = VAL_rlPortOutputStatus_disabled;
        SWCTRL_UNLOCK();
    }

    if (SWCTRL_IS_TRUNK (ifindex))
    {
        trunk_id = SWCTRL_IFINDEX_TO_TRUNKID (ifindex);

        /* if no member, should not set
         */
        if(trunk_ext_port_info[trunk_id-1].member_number == 0)
        {
            EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                      SWCTRL_NO_USE_FUNC_NO,
                                      EH_TYPE_MSG_TRUNK_CNFG_ERR,
                                      SYSLOG_LEVEL_INFO,
                                      "Trunk contains no members");  /*SWCTRL_ENO_NO_MEMBER_IN_TRUNK*/

            SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
        }

        for(i=0; i<trunk_ext_port_info[trunk_id-1].member_number; i++)
        {
            UI32_T temp_ifindex;

            unit = trunk_ext_port_info[trunk_id-1].member_list[i].unit;
            port = trunk_ext_port_info[trunk_id-1].member_list[i].port;

#if (SYS_CPNT_MGMT_PORT == TRUE)
            if (port == SYS_ADPT_MGMT_PORT)
            {
                EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                          SWCTRL_NO_USE_FUNC_NO,
                                          EH_TYPE_MSG_MGMT_PORT_CNFG,
                                          SYSLOG_LEVEL_INFO,
                                          "Egress Rate Limit");  /*SWCTRL_ENO_NOT_SUPPORT_MGMT_PORT*/

                SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
            }
#endif
            SWCTRL_LOCK();
            if ((retval = SWDRV_DisablePortEgressRateLimit (unit, port)) == TRUE)
            {
               SWCTRL_UserPortToIfindex(unit, port, &temp_ifindex);
               port_info[temp_ifindex-1].egress_rate_limit_status = VAL_rlPortOutputStatus_disabled;
            }
            SWCTRL_UNLOCK();
        }
        if (retval == TRUE)
            port_info[l_port-1].egress_rate_limit_status = VAL_rlPortOutputStatus_disabled;
    }

    SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME();
    SWCTRL_RETURN_AND_RELEASE_CSC( retval );
}/* end of SWCTRL_DisablePortEgressRateLimit () */

/*------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetRunningPortEgressRateLimitStatus
 *------------------------------------------------------------------------
 * FUNCTION: This function will get the Egress rate limit status running config
 * INPUT   : None
 * OUTPUT  : port_rgress_rate_limit_status -- enable/disable
 * RETURN  : SYS_TYPE_Get_Running_Cfg_T
 * NOTE    : None
 *------------------------------------------------------------------------*/
SYS_TYPE_Get_Running_Cfg_T SWCTRL_GetRunningPortEgressRateLimitStatus(UI32_T ifindex, UI32_T *port_egress_rate_limit_status)
{
    UI32_T l_port = ifindex;
    UI8_T unit, port;
    UI32_T trunk_id;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(SYS_TYPE_GET_RUNNING_CFG_FAIL);

    if (!SWCTRL_IS_LPORT(ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_FAIL );
    }

    if (port_egress_rate_limit_status == 0)
    {
        EH_MGR_Handle_Exception (SYS_MODULE_SWCTRL,
                                 SWCTRL_NO_USE_FUNC_NO,
                                 EH_TYPE_MSG_NULL_POINTER,
                                 EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_CRIT); /*SWCTRL_ENO_NULL_POINTER*/
        SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_FAIL );
    }

    if (!SWCTRL_IS_TRUNK (ifindex))
    {
        unit = SWCTRL_IFINDEX_TO_UNIT(ifindex);
        port = SWCTRL_IFINDEX_TO_PORT(ifindex);
    }

    if (SWCTRL_IS_TRUNK (ifindex))
    {
        trunk_id = SWCTRL_IFINDEX_TO_TRUNKID (ifindex);

        unit = trunk_ext_port_info[trunk_id-1].member_list[1].unit;
        port = trunk_ext_port_info[trunk_id-1].member_list[1].port;
    }

#if (SYS_CPNT_MGMT_PORT == TRUE)
    if (port == SYS_ADPT_MGMT_PORT)
    {
            EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                      SWCTRL_NO_USE_FUNC_NO,
                                      EH_TYPE_MSG_MGMT_PORT_CNFG,
                                      SYSLOG_LEVEL_INFO,
                                      "Egress Rate Limit");  /*SWCTRL_ENO_NOT_SUPPORT_MGMT_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_FAIL );
    }
#endif

    *port_egress_rate_limit_status = port_info[l_port-1].egress_rate_limit_status;

    if (*port_egress_rate_limit_status != SYS_DFLT_EGRESS_RATE_LIMIT_STATUS)
        SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_SUCCESS )
    else
        SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_NO_CHANGE )

}/* End of SWCTRL_GetRunningPortEgressRateLimitStatus () */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetPortEgressRateLimit
 * -------------------------------------------------------------------------
 * FUNCTION: This function will set the port egress rate limit
 * INPUT   : ifindex -- which port to set
 *           rate -- port egress rate limit
 * OUTPUT  : None
 * RETURN  : True: Successfully, FALSE: Failed
 * NOTE    : # kbits
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetPortEgressRateLimit(UI32_T ifindex, UI32_T rate)
{
    BOOL_T retval;
    UI32_T unit, port, trunk_id, i;
    UI32_T usercfg_rate;

    /*used to keep the user config rate in om because chip setting used the rate which is been converted
      by one resulution ex. 64Kb or 1000 depending on chip.
     */
    usercfg_rate = rate;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (! SWCTRL_LogicalPortExisting(ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    /* the ifindex is normal port
     */
    if (!SWCTRL_IS_TRUNK (ifindex))
    {
        unit = SWCTRL_IFINDEX_TO_UNIT(ifindex);
        port = SWCTRL_IFINDEX_TO_PORT(ifindex);

#if (SYS_CPNT_MGMT_PORT == TRUE)
        if (port == SYS_ADPT_MGMT_PORT)
        {
#if 0
            EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                      SWCTRL_NO_USE_FUNC_NO,
                                      EH_TYPE_MSG_MGMT_PORT_CNFG,
                                      SYSLOG_LEVEL_INFO,
                                      "Egress Rate Limit");  /*SWCTRL_ENO_NOT_SUPPORT_MGMT_PORT*/

            SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
#else
            SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
#endif
        }
#endif

        if (SWCTRL_CheckRateLimitRange(port_info[ifindex-1].port_entry.port_type, rate) == FALSE)
            SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );

        rate = SWCTRL_ConvertUserRateLimitToPhy(port_info[ifindex-1].port_entry.port_type, rate);

        if((port_info[ifindex - 1].egress_rate_limit == usercfg_rate) &&
            (VAL_rlPortOutputStatus_enabled == port_info[ifindex - 1].egress_rate_limit_status))
            SWCTRL_RETURN_AND_RELEASE_CSC(TRUE);

        SWCTRL_LOCK();
        if((retval = SWDRV_SetPortEgressRateLimit(unit, port, rate)) == TRUE)
        {
            port_info[ifindex - 1].egress_rate_limit = usercfg_rate;
            port_info[ifindex - 1].egress_rate_limit_status = VAL_rlPortOutputStatus_enabled;
        }
        SWCTRL_UNLOCK();

        SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME ();
        SWCTRL_RETURN_AND_RELEASE_CSC( retval );
    }
    /* the ifindex is trunk port
     */
    if (SWCTRL_IS_TRUNK (ifindex))
    {
        trunk_id = SWCTRL_IFINDEX_TO_TRUNKID (ifindex);

        /* if no member, should not set
         */
        if(trunk_ext_port_info[trunk_id-1].member_number == 0)
        {
            EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                      SWCTRL_NO_USE_FUNC_NO,
                                      EH_TYPE_MSG_TRUNK_CNFG_ERR,
                                      SYSLOG_LEVEL_INFO,
                                      "Trunk contains no members");  /*SWCTRL_ENO_NO_MEMBER_IN_TRUNK*/

            SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
        }

        if (SWCTRL_CheckRateLimitRange(port_info[ifindex-1].port_entry.port_type, rate) == FALSE)
            SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );

        for(i=0; i<trunk_ext_port_info[trunk_id-1].member_number; i++)
        {
            UI32_T temp_ifindex;

            unit = trunk_ext_port_info[trunk_id-1].member_list[i].unit;
            port = trunk_ext_port_info[trunk_id-1].member_list[i].port;

#if (SYS_CPNT_MGMT_PORT == TRUE)
            if (port == SYS_ADPT_MGMT_PORT)
            {
            EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                      SWCTRL_NO_USE_FUNC_NO,
                                      EH_TYPE_MSG_MGMT_PORT_CNFG,
                                      SYSLOG_LEVEL_INFO,
                                      "Egress Rate Limit");  /*SWCTRL_ENO_NOT_SUPPORT_MGMT_PORT*/

                SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
            }
#endif

            rate = SWCTRL_ConvertUserRateLimitToPhy(port_info[ifindex-1].port_entry.port_type, rate);

            SWCTRL_LOCK();
            if((retval = SWDRV_SetPortEgressRateLimit(unit, port, rate)) == TRUE)
            {
                SWCTRL_UserPortToIfindex(unit, port, &temp_ifindex);
                port_info[temp_ifindex-1].egress_rate_limit = usercfg_rate;
                port_info[temp_ifindex-1].egress_rate_limit_status = VAL_rlPortOutputStatus_enabled;
                SWCTRL_UNLOCK();
            }
            else
            {
                SWCTRL_UNLOCK();

                /* Error code was set in SWDRV_SetPortEgressRateLimit(); */
                SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
            }
        }
        SWCTRL_LOCK();
        if (retval == TRUE)
        {
            port_info[ifindex-1].egress_rate_limit = usercfg_rate;
            port_info[ifindex-1].egress_rate_limit_status = VAL_rlPortOutputStatus_enabled;
        }
        SWCTRL_UNLOCK();
        SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME();
        SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
    } /* End of if () */

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  SYSLOG_LEVEL_INFO,
                                  "Port is not a logical port.");

    SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
} /* End of SWCTRL_SetPortEgressRateLimit () */
#endif

#if (SYS_CPNT_JUMBO_FRAMES == TRUE)
/********************
 * Jumbo Frame APIs *
 ********************/
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetJumboFrameStatus
 * -------------------------------------------------------------------------
 * FUNCTION: This function will enable/disable the jumbo frame
 * INPUT   : jumbo_frame_status --  SWCTRL_JUMBO_FRAME_ENABLE
 *                                  SWCTRL_JUMBO_FRAME_DISABLE
 * OUTPUT  : None
 * RETURN  : True: Successfully, FALSE: Failed
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetJumboFrameStatus (UI32_T jumbo_frame_status)
{
    BOOL_T retval;
#if (SYS_CPNT_SWCTRL_MTU_CONFIG_MODE != SYS_CPNT_SWCTRL_MTU_PER_SYSTEM )
    UI32_T ifindex;
#endif
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if ((jumbo_frame_status != SWCTRL_JUMBO_FRAME_ENABLE) &&
        (jumbo_frame_status != SWCTRL_JUMBO_FRAME_DISABLE))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_INVALID_PARAMETER,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "jumbo frame status");   /*SWCTRL_ENO_INVALID_JUMBO_FRAME_STATUS*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (system_info.jumbo_frame_status == jumbo_frame_status)
        SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );

    SWCTRL_LOCK();
    if (jumbo_frame_status == SWCTRL_JUMBO_FRAME_ENABLE)
        retval = SWDRV_EnableJumboFrame();
    else
        retval = SWDRV_DisableJumboFrame();

    if (retval)
        system_info.jumbo_frame_status = jumbo_frame_status;

    SWCTRL_UNLOCK();

    /* if configuration of jumbo frame is changed, should re-apply MTU */
#if (SYS_CPNT_SWCTRL_MTU_CONFIG_MODE == SYS_CPNT_SWCTRL_MTU_PER_PORT )
    for (ifindex = 1; ifindex <= SYS_ADPT_TOTAL_NBR_OF_LPORT; ifindex++)
    {
        if (SWCTRL_IS_LPORT(ifindex))
        {
            if (FALSE == SWCTRL_SetPortMTU(ifindex, port_info[ifindex-1].port_entry.port_mtu))
            {
                SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
            }
        }
    }
#elif (SYS_CPNT_SWCTRL_MTU_CONFIG_MODE == SYS_CPNT_SWCTRL_MTU_PER_SYSTEM )
    if (!SWCTRL_SetSystemMTU(TRUE, system_info.jumbo_mtu))
    {
        SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
    }
#else /* (SYS_CPNT_SWCTRL_MTU_CONFIG_MODE == SYS_CPNT_SWCTRL_MTU_NOT_CONFIGURABLE ) */
    /* update database,
     * so that other CSC can get correct MTU from port info.
     */
    SWCTRL_LOCK();

    if (jumbo_frame_status == SWCTRL_JUMBO_FRAME_ENABLE)
    {
        system_info.jumbo_mtu = SYS_ADPT_MAX_JUMBO_MTU;
    }
    else
    {
        system_info.jumbo_mtu = SYS_DFLT_PORT_MTU;
    }

    for (ifindex = 1; ifindex <= SYS_ADPT_TOTAL_NBR_OF_LPORT; ifindex++)
    {
        if (SWCTRL_IS_EXIST(ifindex))
        {
            port_info[ifindex-1].port_entry.port_mtu = system_info.jumbo_mtu;
        }
    }

    /* sync max frame size
     */
    SWCTRL_SyncUPortMaxFrameSize(0, 0);

    SWCTRL_UNLOCK();
#endif /* SYS_CPNT_SWCTRL_MTU_CONFIG_MODE */
    SWCTRL_RETURN_AND_RELEASE_CSC( retval );
}/* end of SWCTRL_SetJumboFrameStatus () */


/*------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetJumboFrameStatus
 *------------------------------------------------------------------------
 * FUNCTION: This function will get the jumbo frame status
 * INPUT   : None
 * OUTPUT  : jumbo_frame_status -- SWCTRL_JUMBO_FRAME_ENABLE/SWCTRL_JUMBO_FRAME_DISABLE
 * RETURN  : True: Successfully, FALSE: Failed
 * NOTE    : None
 *------------------------------------------------------------------------*/
BOOL_T SWCTRL_GetJumboFrameStatus (UI32_T *jumbo_frame_status)
{
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (jumbo_frame_status == 0)
    {
        EH_MGR_Handle_Exception (SYS_MODULE_SWCTRL,
                                 SWCTRL_NO_USE_FUNC_NO,
                                 EH_TYPE_MSG_NULL_POINTER,
                                 EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_CRIT); /*SWCTRL_ENO_NULL_POINTER*/
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    *jumbo_frame_status = system_info.jumbo_frame_status;

    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
}/* End of SWCTRL_GetJumboFrameStatus () */


/*------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetRunningJumboFrameStatus
 *------------------------------------------------------------------------
 * FUNCTION: This function will get the jumbo frame running config
 * INPUT   : None
 * OUTPUT  : jumbo_frame_status -- SWCTRL_JUMBO_FRAME_ENABLE/SWCTRL_JUMBO_FRAME_DISABLE
 * RETURN  : SYS_TYPE_Get_Running_Cfg_T
 * NOTE    : None
 *------------------------------------------------------------------------*/
SYS_TYPE_Get_Running_Cfg_T SWCTRL_GetRunningJumboFrameStatus (UI32_T *jumbo_frame_status)
{
    SWCTRL_USE_CSC_CHECK_OPER_MODE(SYS_TYPE_GET_RUNNING_CFG_FAIL);

    if (jumbo_frame_status == 0)
    {
        EH_MGR_Handle_Exception (SYS_MODULE_SWCTRL,
                                 SWCTRL_NO_USE_FUNC_NO,
                                 EH_TYPE_MSG_NULL_POINTER,
                                 EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_CRIT); /*SWCTRL_ENO_NULL_POINTER*/
        SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_FAIL );
    }

    *jumbo_frame_status = system_info.jumbo_frame_status;

    if (*jumbo_frame_status != SYS_DFLT_JUMBO_FRAME_STATUS)
        SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_SUCCESS )
    else
        SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_NO_CHANGE )
}/* End of SWCTRL_GetRunningJumboFrameStatus () */

#endif /* End of #if (SYS_CPNT_JUMBO_FRAMES == TRUE) */

/****************************************************************************/
/* Port mapping                                                             */
/****************************************************************************/
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_UserPortToLogicalPort
 * -------------------------------------------------------------------------
 * FUNCTION: This function will get a logical port mapping from a user port
 * INPUT   : unit    -- which unit to map
 *           port    -- which port to map
 * OUTPUT  : ifindex -- the logical port
 * RETURN  : One of SWCTRL_Lport_Type_T
 * NOTE    : None
 * -------------------------------------------------------------------------*/
SWCTRL_Lport_Type_T SWCTRL_UserPortToLogicalPort(UI32_T unit,
                                                 UI32_T port,
                                                 UI32_T *ifindex)
{
    SWCTRL_USE_CSC_CHECK_OPER_MODE(SWCTRL_LPORT_UNKNOWN_PORT);

    if ((unit < 1) || (unit > SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK))
        SWCTRL_RETURN_AND_RELEASE_CSC( SWCTRL_LPORT_UNKNOWN_PORT );

    if (port == 0 || port > SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT)
        SWCTRL_RETURN_AND_RELEASE_CSC( SWCTRL_LPORT_UNKNOWN_PORT );

    *ifindex = SWCTRL_UPORT_TO_IFINDEX (unit, port);

    if (!SWCTRL_IS_EXIST (*ifindex))
        SWCTRL_RETURN_AND_RELEASE_CSC( SWCTRL_LPORT_UNKNOWN_PORT );

    if (!SWCTRL_IS_TRUNK_MEMBER (*ifindex))
        SWCTRL_RETURN_AND_RELEASE_CSC( SWCTRL_LPORT_NORMAL_PORT )
    else
    {
        *ifindex = SWCTRL_TRUNKID_TO_IFINDEX (port_info[*ifindex-1].port_entry.port_trunk_index);
        SWCTRL_RETURN_AND_RELEASE_CSC( SWCTRL_LPORT_TRUNK_PORT_MEMBER );
    }

} /* End of SWCTRL_UserPortToLogicalPort() */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_UserPortToIfindex
 * -------------------------------------------------------------------------
 * FUNCTION: This function will get the ifindex mapping from a user port
 * INPUT   : unit    -- which unit to map
 *           port    -- which port to map
 * OUTPUT  : ifindex -- the logical port
 * RETURN  : One of SWCTRL_Lport_Type_T
 * NOTE    : None
 * -------------------------------------------------------------------------*/
SWCTRL_Lport_Type_T SWCTRL_UserPortToIfindex(UI32_T unit,
                                             UI32_T port,
                                             UI32_T *ifindex)
{
    SWCTRL_USE_CSC_CHECK_OPER_MODE(SWCTRL_LPORT_UNKNOWN_PORT);

    if((unit < 1) || (unit > SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK))
        SWCTRL_RETURN_AND_RELEASE_CSC( SWCTRL_LPORT_UNKNOWN_PORT );

    if( port == 0 || port > SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT)
        SWCTRL_RETURN_AND_RELEASE_CSC( SWCTRL_LPORT_UNKNOWN_PORT );

    if( ifindex == 0)
    {
        EH_MGR_Handle_Exception (SYS_MODULE_SWCTRL,
                                 SWCTRL_NO_USE_FUNC_NO,
                                 EH_TYPE_MSG_NULL_POINTER,
                                 EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_CRIT); /*SWCTRL_ENO_NULL_POINTER*/
        SWCTRL_RETURN_AND_RELEASE_CSC( SWCTRL_LPORT_UNKNOWN_PORT );
    }

    *ifindex = SWCTRL_UPORT_TO_IFINDEX (unit, port);

    if (!SWCTRL_IS_EXIST (*ifindex))
        SWCTRL_RETURN_AND_RELEASE_CSC( SWCTRL_LPORT_UNKNOWN_PORT );

    if (!SWCTRL_IS_TRUNK_MEMBER (*ifindex))
        SWCTRL_RETURN_AND_RELEASE_CSC( SWCTRL_LPORT_NORMAL_PORT )
    else
        SWCTRL_RETURN_AND_RELEASE_CSC( SWCTRL_LPORT_TRUNK_PORT_MEMBER )

} /* End of SWCTRL_UserPortToIfindex() */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_UserPortToTrunkPort
 * -------------------------------------------------------------------------
 * FUNCTION: This function will get a trunk port mapping from a user port
 * INPUT   : unit     -- which unit to map
 *           port     -- which port to map
 * OUTPUT  : trunk_id -- the logical port
 * RETURN  : One of SWCTRL_Lport_Type_T
 * NOTE    : None
 * -------------------------------------------------------------------------*/
SWCTRL_Lport_Type_T SWCTRL_UserPortToTrunkPort(UI32_T unit,
                                               UI32_T port,
                                               UI32_T *trunk_id)
{
    UI32_T                  ifindex;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(SWCTRL_LPORT_UNKNOWN_PORT);

    if((unit < 1) || (unit > SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK))
        SWCTRL_RETURN_AND_RELEASE_CSC( SWCTRL_LPORT_UNKNOWN_PORT );

    if( port == 0 || port > SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT)
        SWCTRL_RETURN_AND_RELEASE_CSC( SWCTRL_LPORT_UNKNOWN_PORT );

    if( trunk_id == 0)
    {
        EH_MGR_Handle_Exception (SYS_MODULE_SWCTRL,
                                 SWCTRL_NO_USE_FUNC_NO,
                                 EH_TYPE_MSG_NULL_POINTER,
                                 EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_CRIT); /*SWCTRL_ENO_NULL_POINTER*/

        SWCTRL_RETURN_AND_RELEASE_CSC( SWCTRL_LPORT_UNKNOWN_PORT );
    }

    ifindex = SWCTRL_UPORT_TO_IFINDEX (unit, port);

    if (!SWCTRL_IS_EXIST (ifindex))
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( SWCTRL_LPORT_UNKNOWN_PORT );
    }

    *trunk_id = port_info[ifindex-1].port_entry.port_trunk_index;

    if(*trunk_id != 0)
        SWCTRL_RETURN_AND_RELEASE_CSC( SWCTRL_LPORT_TRUNK_PORT_MEMBER )
    else
        SWCTRL_RETURN_AND_RELEASE_CSC( SWCTRL_LPORT_NORMAL_PORT )

} /* End of SWCTRL_UserPortToTrunkPort() */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_LogicalPortToUserPort
 * -------------------------------------------------------------------------
 * FUNCTION: This function will get a user port mapping from a logical port
 * INPUT   : ifindex  -- which port to map
 * OUTPUT  : unit     -- the unit
 *           port     -- the user port
 *           trunk_id -- trunk ID if it is a trunk port
 * RETURN  : One of SWCTRL_Lport_Type_T
 * NOTE    : None
 * -------------------------------------------------------------------------*/
SWCTRL_Lport_Type_T SWCTRL_LogicalPortToUserPort(UI32_T ifindex,
                                                 UI32_T *unit,
                                                 UI32_T *port,
                                                 UI32_T *trunk_id)
{
    SWCTRL_USE_CSC_CHECK_OPER_MODE(SWCTRL_LPORT_UNKNOWN_PORT);
#if (SYS_CPNT_VXLAN == TRUE)
    if( ifindex == 0 || ifindex > SYS_ADPT_TOTAL_NBR_OF_LPORT_INCLUDE_VXLAN)
#else
    if( ifindex == 0 || ifindex > SYS_ADPT_TOTAL_NBR_OF_LPORT)
#endif
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Logical Port ID (1-%d)", SYS_ADPT_TOTAL_NBR_OF_LPORT);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_LOGICAL_PORT_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( SWCTRL_LPORT_UNKNOWN_PORT );
    }

#if (SYS_CPNT_VXLAN == TRUE)
    if (VXLAN_TYPE_IS_L_PORT(ifindex))
    {
        STKTPLG_OM_GetMyUnitID(unit);
        *port = 0;
        *trunk_id = 0;
        SWCTRL_RETURN_AND_RELEASE_CSC( SWCTRL_LPORT_VXLAN_PORT );
    }
#endif

    if (!SWCTRL_IS_EXIST (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  SYSLOG_LEVEL_INFO,
                                  "Interface");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( SWCTRL_LPORT_UNKNOWN_PORT );
    }

    if( unit == 0 || port == 0 || trunk_id == 0)
    {
        EH_MGR_Handle_Exception (SYS_MODULE_SWCTRL,
                                 SWCTRL_NO_USE_FUNC_NO,
                                 EH_TYPE_MSG_NULL_POINTER,
                                 EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_CRIT); /*SWCTRL_ENO_NULL_POINTER*/

        SWCTRL_RETURN_AND_RELEASE_CSC( SWCTRL_LPORT_UNKNOWN_PORT );
    }


    if(SWCTRL_IS_TRUNK_MEMBER (ifindex))
    {
        *unit = SWCTRL_IFINDEX_TO_UNIT(ifindex);
        *port = SWCTRL_IFINDEX_TO_PORT(ifindex);
        *trunk_id = port_info[ifindex-1].port_entry.port_trunk_index;

        if( *unit == 0 && *port == 0 && *trunk_id == 0)
        {
            SYSFUN_LogMsg("Invalid output (1): %lu.\r\n", ifindex, 0, 0, 0, 0, 0);
        }

        SWCTRL_RETURN_AND_RELEASE_CSC( SWCTRL_LPORT_TRUNK_PORT_MEMBER );
    }
    else if(SWCTRL_IS_TRUNK (ifindex))
    {
        *unit = 0;
        *port = 0;
        *trunk_id = SWCTRL_IFINDEX_TO_TRUNKID (ifindex);

        if( *unit == 0 && *port == 0 && *trunk_id == 0)
        {
            SYSFUN_LogMsg("Invalid output (2): %lu.\r\n", ifindex, 0, 0, 0, 0, 0);
        }

        SWCTRL_RETURN_AND_RELEASE_CSC( SWCTRL_LPORT_TRUNK_PORT );
    }
    else /* normal port */
    {
        *unit = SWCTRL_IFINDEX_TO_UNIT(ifindex);
        *port = SWCTRL_IFINDEX_TO_PORT(ifindex);
        *trunk_id = 0;

        if( *unit == 0 && *port == 0 && *trunk_id == 0)
        {
            SYSFUN_LogMsg("Invalid output (3): %lu.\r\n", ifindex, 0, 0, 0, 0, 0);
        }

        SWCTRL_RETURN_AND_RELEASE_CSC( SWCTRL_LPORT_NORMAL_PORT );
    }

} /* End of SWCTRL_LogicalPortToUserPort() */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_TrunkIDToLogicalPort
 * -------------------------------------------------------------------------
 * FUNCTION: This function will get a logical port mapping from a trunk port
 * INPUT   : trunk_id -- which trunk port to map
 * OUTPUT  : ifindex  -- the logical port
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_TrunkIDToLogicalPort(UI32_T trunk_id,
                                   UI32_T *ifindex)
{
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if((trunk_id < 1) || (trunk_id > SYS_ADPT_MAX_NBR_OF_TRUNK_PER_SYSTEM))
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Trunk ID (1-%d)", SYS_ADPT_MAX_NBR_OF_TRUNK_PER_SYSTEM);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);   /*SWCTRL_ENO_OUT_OF_RANGE_TRUNK_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if( ifindex == 0)
    {
        EH_MGR_Handle_Exception (SYS_MODULE_SWCTRL,
                                 SWCTRL_NO_USE_FUNC_NO,
                                 EH_TYPE_MSG_NULL_POINTER,
                                 EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_CRIT); /*SWCTRL_ENO_NULL_POINTER*/
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    *ifindex = SWCTRL_TRUNKID_TO_IFINDEX (trunk_id);

    if (!SWCTRL_IS_EXIST (*ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Trunk");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
} /* End of SWCTRL_TrunkIDToLogicalPort() */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetNextLogicalPort
 * -------------------------------------------------------------------------
 * FUNCTION: This function will get the next existing logical port
 * INPUT   : l_port -- the key
 * OUTPUT  : l_port -- the next existing logical port
 * RETURN  : One of SWCTRL_Lport_Type_T
 * NOTE    : None
 * -------------------------------------------------------------------------*/
SWCTRL_Lport_Type_T SWCTRL_GetNextLogicalPort(UI32_T *l_port)
{
    UI32_T i;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(SWCTRL_LPORT_UNKNOWN_PORT);

    if(*l_port > SYS_ADPT_TOTAL_NBR_OF_LPORT)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( SWCTRL_LPORT_UNKNOWN_PORT );
    }

    if( l_port == 0)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( SWCTRL_LPORT_UNKNOWN_PORT );
    }


    for (i = ++(*l_port) ; i <= SYS_ADPT_TOTAL_NBR_OF_LPORT; i++, *l_port = i)
    {
        if (!SWCTRL_IS_EXIST (*l_port))
            continue;

        if(SWCTRL_IS_TRUNK_MEMBER (*l_port))
            continue;

        if(SWCTRL_IS_TRUNK (*l_port))
            SWCTRL_RETURN_AND_RELEASE_CSC( SWCTRL_LPORT_TRUNK_PORT );

        SWCTRL_RETURN_AND_RELEASE_CSC( SWCTRL_LPORT_NORMAL_PORT );
    }
    SWCTRL_RETURN_AND_RELEASE_CSC( SWCTRL_LPORT_UNKNOWN_PORT );
} /* End of SWCTRL_GetNextLogicalPort() */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetNextActiveLogicalPort
 * -------------------------------------------------------------------------
 * FUNCTION: This function will get the next logical port with link_oper_status = VAL_ifOperStatus_up
             null trunk, dormant state, and link-down port will not returned from this API
 * INPUT   : l_port -- the key
 * OUTPUT  : l_port -- the next oper up logical port
 * RETURN  : One of SWCTRL_Lport_Type_T
 * NOTE    : None
 * -------------------------------------------------------------------------*/
SWCTRL_Lport_Type_T SWCTRL_GetNextActiveLogicalPort(UI32_T *l_port)
{
    UI32_T i,trunk_id;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(SWCTRL_LPORT_UNKNOWN_PORT);

    if(*l_port > SYS_ADPT_TOTAL_NBR_OF_LPORT)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( SWCTRL_LPORT_UNKNOWN_PORT );
    }

    if( l_port == 0)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( SWCTRL_LPORT_UNKNOWN_PORT );
    }


    for (i = ++(*l_port) ; i <= SYS_ADPT_TOTAL_NBR_OF_LPORT; i++, *l_port = i)
    {
        if (!SWCTRL_IS_EXIST (*l_port))
            continue;

        if(SWCTRL_IS_TRUNK_MEMBER (*l_port))
            continue;

    if(!SWCTRL_IS_OPER_UP (*l_port))
            continue;

        if(SWCTRL_IS_TRUNK (*l_port))
     {
            trunk_id = SWCTRL_IFINDEX_TO_TRUNKID (*l_port);
            if(trunk_ext_port_info[trunk_id-1].member_number==0)
             continue;
            SWCTRL_RETURN_AND_RELEASE_CSC( SWCTRL_LPORT_TRUNK_PORT );
        }

        SWCTRL_RETURN_AND_RELEASE_CSC( SWCTRL_LPORT_NORMAL_PORT );
    }
    SWCTRL_RETURN_AND_RELEASE_CSC( SWCTRL_LPORT_UNKNOWN_PORT );
}/*end SWCTRL_GetNextActiveLogicalPort*/



/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_LogicalPortExisting
 * -------------------------------------------------------------------------
 * FUNCTION: This function will return if this port is existing
 * INPUT   : l_port -- the key to ask
 * OUTPUT  : None
 * RETURN  : TRUE: Existing, FALSE: Not existing
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_LogicalPortExisting(UI32_T l_port)
{
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if(l_port == 0 || l_port > SYS_ADPT_TOTAL_NBR_OF_LPORT)
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Logical Port ID (1-%d)", SYS_ADPT_TOTAL_NBR_OF_LPORT);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_LOGICAL_PORT_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (!SWCTRL_IS_EXIST (l_port))
    {
        /* 1) trunk have not been created yet.
         * 2) physical port doesn't exist
         */
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Interface");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if(SWCTRL_IS_TRUNK_MEMBER(l_port))
    {
        /* Trunk member is not logical port
         */
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
} /* End of SWCTRL_LogicalPortExisting() */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_UserPortExisting
 * -------------------------------------------------------------------------
 * FUNCTION: This function will return if this user port is existing
 * INPUT   : unit -- which unit
 *           port -- the key to ask
 * OUTPUT  : None
 * RETURN  : TRUE: Existing, FALSE: Not existing
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_UserPortExisting(UI32_T unit, UI32_T port)
{
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if((unit < 1) || (unit > SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK))
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Unit (1-%d)", SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_UNIT_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if((port < 1) || (port > SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT))
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Port number (1-%d)", SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_UNIT_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (!SWCTRL_IS_EXIST (SWCTRL_UPORT_TO_IFINDEX (unit, port)))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Interface");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
}/* End of SWCTRL_UserPortExisting () */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_PortExisting
 * -------------------------------------------------------------------------
 * FUNCTION: This function will return if this user port is existing
 * INPUT   : port -- the key to ask
 * OUTPUT  : None
 * RETURN  : TRUE: Existing, FALSE: Not existing
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_PortExisting(UI32_T l_port)
{
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if(l_port == 0 || l_port > SYS_ADPT_TOTAL_NBR_OF_LPORT)
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Logical Port ID (1-%d)", SYS_ADPT_TOTAL_NBR_OF_LPORT);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_LOGICAL_PORT_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (!SWCTRL_IS_EXIST (l_port))
    {
        /* 1) trunk have not been created yet.
         * 2) physical port doesn't exist
         */
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Interface");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
}
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_LogicalPortIsTrunkPort
 * -------------------------------------------------------------------------
 * FUNCTION: This function will return if this port is trunk port
 * INPUT   : uport_ifindex -- the key to ask
 * OUTPUT  : None
 * RETURN  : TRUE: trunk port , FALSE: Not existing
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_LogicalPortIsTrunkPort(UI32_T ifindex)
{
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if( ifindex == 0 || ifindex > SYS_ADPT_TOTAL_NBR_OF_LPORT)
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Logical Port ID (1-%d)", SYS_ADPT_TOTAL_NBR_OF_LPORT);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_LOGICAL_PORT_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (!SWCTRL_IS_EXIST (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Interface");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    SWCTRL_RETURN_AND_RELEASE_CSC( SWCTRL_IS_TRUNK (ifindex) );
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_IsTrunkMember
 * -------------------------------------------------------------------------
 * FUNCTION: This function is used to get if a user port is trunk member, and
 *           if this user port is a trunk member check if this static trunk
 *           member or dynamic trunk member.
 * INPUT   : uport_ifindex --- which user port.
 * OUTPUT  : trunk_ifindex --- if this user port is trunk member, this is user
 *                             port is belong to which trunk
 *           is_static --- TRUE:  static trunk member.
 *                         FALSE: dynamic trunk member.
 * RETURN  : TRUE/FALSE
 * NOTE    : None.
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_IsTrunkMember(UI32_T uport_ifindex, UI32_T *trunk_ifindex, BOOL_T *is_static)
{
    UI32_T trunk_id;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (NULL == is_static)
    {
        /*UIMSG_MGR_SetErrorCode(); */ /*SWCTRL_ENO_NULL_POINTER*/
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (FALSE == SWCTRL_IS_USER_PORT(uport_ifindex) )
    {
        /*UIMSG_MGR_SetErrorCode(); */ /*XXXXXXX*/
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (FALSE == SWCTRL_IS_EXIST (uport_ifindex))
    {
        /*UIMSG_MGR_SetErrorCode(); */ /*SWCTRL_ENO_PORT_NOT_PRESENT*/
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (FALSE == SWCTRL_IS_TRUNK_MEMBER(uport_ifindex))
    {
        /* normal case: not trunk member, don't set exception handler
         */
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    /* check static or dynamic trunk member
     */
    trunk_id = port_info[uport_ifindex-1].port_entry.port_trunk_index;

    *trunk_ifindex = SWCTRL_TRUNKID_TO_IFINDEX(trunk_id);
    *is_static = trunk_ext_port_info[trunk_id-1].is_static;

    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
}


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetTrunkIfIndexByUport
 * -------------------------------------------------------------------------
 * FUNCTION: This function will return if this port is trunk member
 * INPUT   : uport_ifindex -- the key to ask
 * OUTPUT  : trunk_ifindex -- trunk ifindex
 * RETURN  : TRUE: trunk member , FALSE: Not existing
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_GetTrunkIfIndexByUport(UI32_T uport_ifindex, UI32_T *trunk_ifindex)
{
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if  (uport_ifindex == 0 || uport_ifindex > SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK*SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT)
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Logical Port ID (1-%d)", SYS_ADPT_TOTAL_NBR_OF_LPORT);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_LOGICAL_PORT_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if( trunk_ifindex == 0)
    {
        EH_MGR_Handle_Exception (SYS_MODULE_SWCTRL,
                                 SWCTRL_NO_USE_FUNC_NO,
                                 EH_TYPE_MSG_NULL_POINTER,
                                 EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_CRIT); /*SWCTRL_ENO_NULL_POINTER*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (!SWCTRL_IS_EXIST (uport_ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Interface");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if  (!SWCTRL_IS_TRUNK_MEMBER (uport_ifindex))
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    *trunk_ifindex = SWCTRL_TRUNKID_TO_IFINDEX (port_info[uport_ifindex-1].port_entry.port_trunk_index);

    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
} /* End of SWCTRL_IsLogicalPortTrunkMember() */



/* -------------------------------------------------------------------------
 * ROUTINE NAME -  SWCTRL_LportToActiveUport
 * -------------------------------------------------------------------------
 * FUNCTION: This function will get the primary port from logical port
 * INPUT   : vid        -- The VLAN to ask, if the vid is SYS_TYPE_IGNORE_VID_CHECK
 *                         then don't check STA state
 *           l_port     -- the key to ask
 * OUTPUT  : *unit_port -- primary port (active)
 * RETURN  : TRUE/FALSE
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T  SWCTRL_LportToActiveUport(UI32_T vid, UI32_T l_port, SYS_TYPE_Uport_T *unit_port)
{
    UI32_T                       i, unit = 0, port = 0, tm_ifindex, min_tm_ifindex = 0xffff;
    SWCTRL_TrunkPortExtInfo_T    trunk_ext_p_info;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (unit_port == 0)
    {
        EH_MGR_Handle_Exception (SYS_MODULE_SWCTRL,
                                 SWCTRL_NO_USE_FUNC_NO,
                                 EH_TYPE_MSG_NULL_POINTER,
                                 EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_CRIT); /*SWCTRL_ENO_NULL_POINTER*/
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if( l_port == 0 || l_port > SYS_ADPT_TOTAL_NBR_OF_LPORT)
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    /* return if this port is not exist
     */
    if (!SWCTRL_IS_EXIST (l_port))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Interface");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    /* return if the port is a trunk member
     */
    if (SWCTRL_IS_TRUNK_MEMBER (l_port))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if(!SWCTRL_IS_TRUNK (l_port)) /*normal port*/
    {
        unit = SWCTRL_IFINDEX_TO_UNIT(l_port);
        port = SWCTRL_IFINDEX_TO_PORT(l_port);

        /* return if the port is inactive
         */
        if (SWCTRL_IS_OPER_UP(l_port))
        {
            if (vid == SYS_TYPE_IGNORE_VID_CHECK)
            {
                unit_port->unit = (UI16_T) unit;
                unit_port->port = (UI16_T) port;
            }
            else
            {
                if (FALSE == XSTP_OM_IsPortForwardingStateByVlan(vid, l_port))
                {
                    SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
                }
                else
                {
                    unit_port->unit = (UI16_T) unit;
                    unit_port->port = (UI16_T) port;
                }
            }

        }
        else
        {
            SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
        }
    }
    else                         /*trunk port*/
    {
        if (SWCTRL_IS_OPER_UP(l_port))
        {
            if (vid != SYS_TYPE_IGNORE_VID_CHECK)
            {
                if (FALSE == XSTP_OM_IsPortForwardingStateByVlan(vid, l_port))
                {
                    SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
                }
            }

            if (!SWCTRL_GetTrunkPortExtInfo (l_port,&trunk_ext_p_info))
            {
                SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
            }

            for(i = 0; i < trunk_ext_p_info.member_number; i++)
            {
                unit = (UI32_T) trunk_ext_p_info.member_list[i].unit;
                port = (UI32_T) trunk_ext_p_info.member_list[i].port;

                tm_ifindex = SWCTRL_UPORT_TO_IFINDEX (unit, port);

                if (!SWCTRL_IS_USER_PORT(tm_ifindex))
                {
                    break;
                }

                if (SWCTRL_IS_OPER_ACTIVE_TRUNK_MEMBER(SWCTRL_IFINDEX_TO_TRUNKID(l_port), tm_ifindex))

                {
                    if (tm_ifindex < min_tm_ifindex)
                    {
                        min_tm_ifindex = tm_ifindex;
                    }
                }
            } /* End of for () */

            if( min_tm_ifindex == 0xffff)
            {
                SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
            }
            else
            {
                unit = SWCTRL_IFINDEX_TO_UNIT(min_tm_ifindex);
                port = SWCTRL_IFINDEX_TO_PORT(min_tm_ifindex);
            }
        }
        else
        {
            SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
        }
    } /* End of if () */

    if (unit == 0 || port == 0)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    unit_port->unit = (UI16_T) unit;
    unit_port->port = (UI16_T) port;

    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
} /* end of  SWCTRL_LportToActiveUport () */



static BOOL_T SWCTRL_LportListToActiveUportListEngine  (UI32_T vid,
                                                        UI8_T  *lportlist,
                                                        UI8_T  active_uport_count_per_unit[SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK],
                                                        UI32_T *total_active_uport_count,
                                                        UI8_T  *uportlist)
{
    UI32_T                          i, ifindex, unit = 0, port = 0, tm_ifindex ;
    UI32_T                          total_num_of_byte_for_a_unit, min_tm_ifindex = 0xffff;
    SWCTRL_TrunkPortExtInfo_T    trunk_ext_p_info;

    if ((lportlist == 0) || (active_uport_count_per_unit == 0) || (uportlist == 0) || (uportlist == 0))
    {
        EH_MGR_Handle_Exception (SYS_MODULE_SWCTRL,
                                 SWCTRL_NO_USE_FUNC_NO,
                                 EH_TYPE_MSG_NULL_POINTER,
                                 EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_CRIT); /*SWCTRL_ENO_NULL_POINTER*/
        return( FALSE );
    }

    memset (uportlist, 0, SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST);
    for (i=0;i<SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK;i++)
    {
        active_uport_count_per_unit[i] = 0;
    }
    (*total_active_uport_count) = 0;

    ifindex = 0;
    while (SWCTRL_GetNextIndexFromPortList (&ifindex, lportlist))
    {
        /* SWCTRL_LPORT_UNKNOWN_PORT
         */
        if (!SWCTRL_IS_EXIST (ifindex))
            continue;

        /* SWCTRL_LPORT_TRUNK_PORT_MEMBER
         */
        if (SWCTRL_IS_TRUNK_MEMBER (ifindex))
            continue;

        /* SWCTRL_LPORT_NORMAL_PORT
         */
        if(!SWCTRL_IS_TRUNK (ifindex))
        {
            if(!SWCTRL_IS_OPER_UP (ifindex))
            {
                continue;
            }

            if(vid != SYS_TYPE_IGNORE_VID_CHECK)
            {
                if (FALSE == XSTP_OM_IsPortForwardingStateByVlan(vid, ifindex))
                {
                    continue;
                }
            }

            unit = SWCTRL_IFINDEX_TO_UNIT(ifindex);
            port = SWCTRL_IFINDEX_TO_PORT(ifindex);
        }

        /* SWCTRL_LPORT_TRUNK_PORT
         */
        if(SWCTRL_IS_TRUNK (ifindex))
        {
            if(!SWCTRL_IS_OPER_UP (ifindex))
            {
                continue;
            }

            if(vid != SYS_TYPE_IGNORE_VID_CHECK)
            {
                if (FALSE == XSTP_OM_IsPortForwardingStateByVlan(vid, ifindex))
                {
                    continue;
                }
            }

            SWCTRL_GetTrunkPortExtInfo (ifindex, &trunk_ext_p_info);
            min_tm_ifindex = 0xffff;

            for(i = 0; i < trunk_ext_p_info.member_number; i++)
            {
                unit = (UI32_T) trunk_ext_p_info.member_list[i].unit;
                port = (UI32_T) trunk_ext_p_info.member_list[i].port;

                tm_ifindex = SWCTRL_UPORT_TO_IFINDEX (unit, port);

                if (!SWCTRL_IS_USER_PORT(tm_ifindex))
                {
                    break;
                }

                if (SWCTRL_IS_OPER_ACTIVE_TRUNK_MEMBER(SWCTRL_IFINDEX_TO_TRUNKID(ifindex), tm_ifindex))
                {
                    if (vid != SYS_TYPE_IGNORE_VID_CHECK)
                    {
                        /* If a member port is link up then the trunk port STA state
                         * will apply the trunk member, only checking link up is necessary
                         */
                        if (tm_ifindex < min_tm_ifindex)
                        {
                            min_tm_ifindex = tm_ifindex;
                        }
                    }
                    else
                    {
                        if (tm_ifindex < min_tm_ifindex)
                        {
                            min_tm_ifindex = tm_ifindex;
                        }
                    }
                }
            } /* End of for () */

            if (min_tm_ifindex == 0xffff)
            {
                continue;
            }
            else
            {
                unit = SWCTRL_IFINDEX_TO_UNIT(min_tm_ifindex);
                port = SWCTRL_IFINDEX_TO_PORT(min_tm_ifindex);
             }
        } /* End of if () */

        /* uportlist :
         *           +---------+---------+------+---------+
         *  unit     |    1    |    2    | ...  |    8    |
         *           +---------+---------+------+---------+
         *  portlist | 4 bytes | 4 bytes | ...  | 4 bytes |
         *           +---------+---------+------+---------+
         */
        total_num_of_byte_for_a_unit = (SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT+7)/8;

        uportlist[(total_num_of_byte_for_a_unit*(unit-1)+((port-1) / 8))] |= ((0x01) << (7 - ((port - 1) % 8)));

        active_uport_count_per_unit[unit-1]++; /* unit : 0 ~ 7 */
        (*total_active_uport_count)++;

    } /* End of for () */
    return( TRUE );
}


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_LportListToActiveUportList
 * -------------------------------------------------------------------------
 * FUNCTION: This function will translate the logical port list to active
 *           unit port list
 * INPUT   : lportlist -- logical port list
 * OUTPUT  : active_uport_count_per_unit -- how many uport is active ?
 *           uport;ist -- unit port list
 * RETURN  : TRUE: Existing, FALSE: Not existing
 * NOTE    : 1. for GVRP, STA, IGMP Snooping, IPMC
 *           2. Lport bit array(ifindex view) --> uport list(for non trunk member,
 *              keep the same for trunk member, select a u port as primary port).
 *              Primary port is usually the port which number is smallest.
 *           3. For Example: 24 ports / per unit, total 8 units in whole system
 *              uportlist : ( the MSB represents the port 1)
 *                           +---------+---------+------+---------+
 *                  unit     |    1    |    2    | ...  |    8    |
 *                           +---------+---------+------+---------+
 *                  portlist | 4 bytes | 4 bytes | ...  | 4 bytes |
 *                           +---------+---------+------+---------+
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_LportListToActiveUportList(
           UI32_T vid,
           UI8_T  *lportlist,
           UI8_T  active_uport_count_per_unit[SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK],
           UI8_T  *uportlist)
{
    UI32_T total_active_uport_count;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (FALSE == SWCTRL_LportListToActiveUportListEngine(vid, lportlist, active_uport_count_per_unit, &total_active_uport_count, uportlist))
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    SWCTRL_RETURN_AND_RELEASE_CSC(TRUE);

} /* End of SWCTRL_LportListToActiveUportList() */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_LportListToActiveUportListExt
 * -------------------------------------------------------------------------
 * FUNCTION: This function will translate the logical port list to active
 *           unit port list, if no active uport, then return FALSE.
 * INPUT   : 1) vid       -- VLAN ID for the ports to check.
 *           2) lportlist -- logical port list
 * OUTPUT  : 1) active_uport_count_per_unit -- how many uport is active
 *           2) uportlist -- unit port list
 * RETURN  : TRUE:  Have active uport.
 *           FALSE: Parameter is invali, no active uport.
 * NOTE    : The only difference between SWCTRL_LportListToActiveUportList()
 *           is when active uport number is 0, this API will return FALSE.
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_LportListToActiveUportListExt(
                   UI32_T vid,
                   UI8_T  *lportlist,
                   UI8_T  active_uport_count_per_unit[SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK],
                   UI8_T  *uportlist)
{
    UI32_T total_active_uport_count;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (FALSE == SWCTRL_LportListToActiveUportListEngine(vid, lportlist, active_uport_count_per_unit, &total_active_uport_count, uportlist))
    {
        SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
    }

    if (0 == total_active_uport_count)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
    }

    SWCTRL_RETURN_AND_RELEASE_CSC(TRUE);
}

#if (SYS_CPNT_WRR_Q_MODE_PER_PORT_CTRL == FALSE)
/*------------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetPrioQueueMode
 *------------------------------------------------------------------------------
 * PURPOSE:  This function will set the port egress schedulering method
 * INPUT:    mode   -- SWCTRL_WEIGHT_ROUND_ROBIN_METHOD,
 *                     SWCTRL_STRICT_PRIORITY_METHOD,
 *                     following is for firebolt2
 *                     SWCTRL_DEFICIT_ROUND_RBIN_METHOD,
 *                     SWCTRL_SP_WRR_METHOD,
 *                     SWCTRL_SP_DRR_METHOD
 * OUTPUT  : None
 * RETURN:   TRUE/FALSE
 * NOTE:
 *------------------------------------------------------------------------------
 */
BOOL_T SWCTRL_SetPrioQueueMode(UI32_T mode)
{
    BOOL_T ret = FALSE;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    ret = SWDRV_SetEgressSchedulingMethod(mode);

    SWCTRL_RETURN_AND_RELEASE_CSC(ret);
}
#else
/*--------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetPortPrioQueueMode
 *---------------------------------------------------------------------------
 * PURPOSE:  This function will set the port egress schedulering method
 * INPUT:    l_port -- which port to set
 *           mode   -- SWCTRL_WEIGHT_ROUND_ROBIN_METHOD,
                    SWCTRL_STRICT_PRIORITY_METHOD,
                    following is for firebolt2
                    SWCTRL_DEFICIT_ROUND_RBIN_METHOD,
                    SWCTRL_SP_WRR_METHOD,
                    SWCTRL_SP_DRR_METHOD
 * OUTPUT  : None
 * RETURN:   TRUE/FALSE
 * NOTE:
 *---------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetPortPrioQueueMode(UI32_T l_port, UI32_T mode)
{
    /* LOCAL VARIABLES
     */
    UI16_T unit, port;
    UI32_T i, trunk_id, q_id;
    BOOL_T retval=FALSE;
    UI32_T ifindex_member ;

    /* BODY
     */
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if ((mode != SWCTRL_WEIGHT_ROUND_ROBIN_METHOD) && (mode != SWCTRL_STRICT_PRIORITY_METHOD) &&
        (mode != SWCTRL_DEFICIT_ROUND_ROBIN_METHOD) && (mode != SWCTRL_SP_WRR_METHOD) &&
        (mode != SWCTRL_SP_DRR_METHOD))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_INVALID_PARAMETER,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "mode for Egress Queue Scheduling method");   /*SWCTRL_ENO_INVALID_MIRROR_TYPE*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (!SWCTRL_IS_USER_PORT(l_port) || !SWCTRL_IS_EXIST(l_port))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a valid port.");

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (!SWCTRL_IS_TRUNK (l_port))
    {
        unit = SWCTRL_IFINDEX_TO_UNIT(l_port);
        port = SWCTRL_IFINDEX_TO_PORT(l_port);

#if (SYS_CPNT_MGMT_PORT == TRUE)
        if (port == SYS_ADPT_MGMT_PORT)
        {
            EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                      SWCTRL_NO_USE_FUNC_NO,
                                      EH_TYPE_MSG_MGMT_PORT_CNFG,
                                      SYSLOG_LEVEL_INFO,
                                      "Priority Queue");  /*SWCTRL_ENO_NOT_SUPPORT_MGMT_PORT*/

            SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
        }
#endif

        SWCTRL_LOCK();

        /* 2008-06-03, Jinfeng.Chen: Set mode and store the data into port_info */
        if ((retval = SWDRV_SetPortEgressSchedulingMethod (unit, port, mode)) == TRUE)
        {
            UI32_T dflt_weights[SYS_ADPT_MAX_NBR_OF_PRIORITY_QUEUE] =
                    {   SYS_DFLT_WRR_Q0_WEIGHT,
                        SYS_DFLT_WRR_Q1_WEIGHT,
                        SYS_DFLT_WRR_Q2_WEIGHT,
                        SYS_DFLT_WRR_Q3_WEIGHT,
                    #if (8 == SYS_ADPT_MAX_NBR_OF_PRIORITY_QUEUE)
                        SYS_DFLT_WRR_Q4_WEIGHT,
                        SYS_DFLT_WRR_Q5_WEIGHT,
                        SYS_DFLT_WRR_Q6_WEIGHT,
                        SYS_DFLT_WRR_Q7_WEIGHT,
                    #endif
                    };

            port_info[l_port-1].egress_scheduler_method = mode;
            switch(mode)
            {
                case SWCTRL_STRICT_PRIORITY_METHOD:
                    memset(port_info[l_port - 1].wrr_weight, 0, sizeof(port_info[l_port - 1].wrr_weight));
                    break;

                case SWCTRL_WEIGHT_ROUND_ROBIN_METHOD:
                case SWCTRL_SP_WRR_METHOD:
                case SWCTRL_DEFICIT_ROUND_ROBIN_METHOD:
                case SWCTRL_SP_DRR_METHOD:
                    memcpy(port_info[l_port - 1].wrr_weight, dflt_weights, sizeof(port_info[l_port - 1].wrr_weight));
                    break;

                default:
                    break;
            }
        }
        SWCTRL_UNLOCK();
    }

    if (SWCTRL_IS_TRUNK (l_port))
    {
        trunk_id = SWCTRL_IFINDEX_TO_TRUNKID (l_port);

        /* if no member, should not set
         */
        if(trunk_ext_port_info[trunk_id-1].member_number == 0)
        {
            EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                      SWCTRL_NO_USE_FUNC_NO,
                                      EH_TYPE_MSG_TRUNK_CNFG_ERR,
                                      SYSLOG_LEVEL_INFO,
                                      "Trunk contains no members");  /*SWCTRL_ENO_NO_MEMBER_IN_TRUNK*/

            SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
        }

        for(i=0; i<trunk_ext_port_info[trunk_id-1].member_number; i++)
        {
            unit = trunk_ext_port_info[trunk_id-1].member_list[i].unit;
            port = trunk_ext_port_info[trunk_id-1].member_list[i].port;

#if (SYS_CPNT_MGMT_PORT == TRUE)
            if (port == SYS_ADPT_MGMT_PORT)
            {
                EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                          SWCTRL_NO_USE_FUNC_NO,
                                          EH_TYPE_MSG_MGMT_PORT_CNFG,
                                          SYSLOG_LEVEL_INFO,
                                          "Priority Queue");  /*SWCTRL_ENO_NOT_SUPPORT_MGMT_PORT*/

                SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
            }
#endif
            SWCTRL_LOCK();
            if ((retval = SWDRV_SetPortEgressSchedulingMethod (unit, port, mode)) == TRUE)
            {
                ifindex_member = SWCTRL_UPORT_TO_IFINDEX (unit, port);
                port_info[ifindex_member-1].egress_scheduler_method = mode;

                if (mode == SWCTRL_WEIGHT_ROUND_ROBIN_METHOD)
                {
                     SWCTRL_UNLOCK();
                     for (q_id=MIN_WrrWeightQueue; q_id<=MAX_WrrWeightQueue; q_id++)
                        SWCTRL_SetPortWrrQueueWeight(ifindex_member, q_id, port_info[ifindex_member-1].wrr_weight[q_id]);
                     SWCTRL_LOCK();
            }
        }
        SWCTRL_UNLOCK();
        }
        if (retval == TRUE)
            port_info[l_port - 1].egress_scheduler_method = mode;
    } /* End of if */

    SWCTRL_RETURN_AND_RELEASE_CSC( retval );
}
#endif

#if 0
/*--------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetPortPrioQueueMode
 *---------------------------------------------------------------------------
 * PURPOSE:  This function will get the port egress schedulering method
 * INPUT:    l_port-- which port to get
 * OUTPUT:   mode -- SWCTRL_STRICT_MODE / SWCTRL_WEIGHT_FAIR_ROUND_ROBIN_MODE
 * RETURN:   TRUE / FALSE
 * NOTE:
 *---------------------------------------------------------------------------*/
BOOL_T SWCTRL_GetPortPrioQueueMode(UI32_T l_port, UI32_T *mode)
{
    /* BODY
     */
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

#if (SYS_CPNT_WRR_Q_MODE_PER_PORT_CTRL == TRUE)
    if (!SWCTRL_IS_LPORT(l_port))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if ( l_port == 0 || l_port > SYS_ADPT_TOTAL_NBR_OF_LPORT)
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Logical Port ID (1-%d)", SYS_ADPT_TOTAL_NBR_OF_LPORT);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_LOGICAL_PORT_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (! SWCTRL_LogicalPortExisting(l_port))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#else
    l_port = 0;
    if(SWCTRL_GetNextLogicalPort(&l_port) == SWCTRL_LPORT_UNKNOWN_PORT)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#endif

    SWCTRL_LOCK();
    *mode = port_info[l_port-1].egress_scheduler_method;
    SWCTRL_UNLOCK();
    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
}


/*--------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetPortStrictQueueMap
 *---------------------------------------------------------------------------
 * PURPOSE:  This function will get the port strict queue map.
 * INPUT:    l_port-- which port to get
 * OUTPUT:   strict queue map
 * RETURN:   TRUE / FALSE
 * NOTE:
 *---------------------------------------------------------------------------*/
BOOL_T SWCTRL_GetPortStrictQueueMap(UI32_T l_port, UI8_T *map)
{
    if(NULL == map)
        return FALSE;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

#if (SYS_CPNT_WRR_Q_MODE_PER_PORT_CTRL == TRUE)
    if (!SWCTRL_IS_LPORT(l_port))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if ( l_port == 0 || l_port > SYS_ADPT_TOTAL_NBR_OF_LPORT)
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Logical Port ID (1-%d)", SYS_ADPT_TOTAL_NBR_OF_LPORT);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_LOGICAL_PORT_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (! SWCTRL_LogicalPortExisting(l_port))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#else
    l_port = 0;
    if(SWCTRL_GetNextLogicalPort(&l_port) == SWCTRL_LPORT_UNKNOWN_PORT)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#endif

    SWCTRL_LOCK();

    if(port_info[l_port - 1].egress_scheduler_method != SWCTRL_SP_WRR_METHOD &&
        port_info[l_port - 1].egress_scheduler_method != SWCTRL_SP_DRR_METHOD)
    {
        SWCTRL_UNLOCK();
        SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
    }
    *map = port_info[l_port - 1].strict_queue_map;

    SWCTRL_UNLOCK();
    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
}

/*--------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetNextPortPrioQueueMode
 *---------------------------------------------------------------------------
 * PURPOSE:  This function will get the next port egress schedulering method
 * INPUT:    l_port-- which port to get
 * OUTPUT:   l_port-- the next port
 *       mode -- SWCTRL_STRICT_MODE / SWCTRL_WEIGHT_FAIR_ROUND_ROBIN_MODE
 * RETURN:   TRUE / FALSE
 * NOTE:
 *---------------------------------------------------------------------------*/
BOOL_T SWCTRL_GetNextPortPrioQueueMode(UI32_T *l_port, UI32_T *mode)
{
   /* BODY
     */
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);


    if ((l_port == 0) || (mode == 0))
    {
        EH_MGR_Handle_Exception (SYS_MODULE_SWCTRL,
                                 SWCTRL_NO_USE_FUNC_NO,
                                 EH_TYPE_MSG_NULL_POINTER,
                                 EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_CRIT); /*SWCTRL_ENO_NULL_POINTER*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#if (SYS_CPNT_WRR_Q_MODE_PER_PORT_CTRL == TRUE)
    if (*l_port > SYS_ADPT_TOTAL_NBR_OF_LPORT)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }



#else
    *l_port = 0;
#endif
    if(SWCTRL_GetNextLogicalPort(l_port) == SWCTRL_LPORT_UNKNOWN_PORT)
            {
               SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
            }
    SWCTRL_LOCK();
    *mode = port_info[*l_port-1].egress_scheduler_method;

    SWCTRL_UNLOCK();

    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
}

/*--------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetRunningPortPrioQueueMode
 *---------------------------------------------------------------------------
 * PURPOSE:  This function will get the port egress schedulering method
 * INPUT:    l_port -- which port to get
 * OUTPUT:   mode -- SWCTRL_STRICT_MODE / SWCTRL_WEIGHT_FAIR_ROUND_ROBIN_MODE
 * RETURN:   SYS_TYPE_GET_RUNNING_CFG_FAIL -- error (system is not in MASTER mode)
 *                SYS_TYPE_GET_RUNNING_CFG_NO_CHANGE -- same as default
 *                SYS_TYPE_GET_RUNNING_CFG_SUCCESS -- different from default value
 * NOTE:
 *---------------------------------------------------------------------------*/
SYS_TYPE_Get_Running_Cfg_T SWCTRL_GetRunningPortPrioQueueMode(UI32_T l_port, UI32_T *mode)
{
    SWCTRL_USE_CSC_CHECK_OPER_MODE(SYS_TYPE_GET_RUNNING_CFG_FAIL);

    /* LOCAL VARIABLES
     */

    /* BODY
     */

#if (SYS_CPNT_WRR_Q_MODE_PER_PORT_CTRL == TRUE)
    if (mode == 0)
    {
        EH_MGR_Handle_Exception (SYS_MODULE_SWCTRL,
                                 SWCTRL_NO_USE_FUNC_NO,
                                 EH_TYPE_MSG_NULL_POINTER,
                                 EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_CRIT); /*SWCTRL_ENO_NULL_POINTER*/

        SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_FAIL );
    }
    if ( l_port == 0 || l_port > SYS_ADPT_TOTAL_NBR_OF_LPORT)
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};]

        sprintf(buff, "Logical Port ID (1-%d)", SYS_ADPT_TOTAL_NBR_OF_LPORT);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_LOGICAL_PORT_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_FAIL );
    }
#else
    l_port = 0;
    if(SWCTRL_GetNextLogicalPort(&l_port) == SWCTRL_LPORT_UNKNOWN_PORT)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_FAIL );
    }
#endif

    if (SWCTRL_GetPortPrioQueueMode(l_port, mode))
    {
       if ((*mode) != default_egress_scheduler_mode)
          SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_SUCCESS );

       SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_NO_CHANGE );
    }

    /* Error code was set in SWCTRL_GetPortQueueWeight(); */
    SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_FAIL );
}

/*--------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetNextRunningPortPrioQueueMode
 *---------------------------------------------------------------------------
 * PURPOSE:  This function will get the next port egress schedulering method
 * INPUT:    l_port-- which port to get
 * OUTPUT:   mode -- SWCTRL_STRICT_MODE / SWCTRL_WEIGHT_FAIR_ROUND_ROBIN_MODE
 * RETURN:   SYS_TYPE_GET_RUNNING_CFG_FAIL -- error (system is not in MASTER mode)
 *                SYS_TYPE_GET_RUNNING_CFG_NO_CHANGE -- same as default
 *                SYS_TYPE_GET_RUNNING_CFG_SUCCESS -- different from default value
 * NOTE:
 *---------------------------------------------------------------------------*/
SYS_TYPE_Get_Running_Cfg_T SWCTRL_GetNextRunningPortPrioQueueMode(UI32_T *l_port, UI32_T *mode)
{
   SWCTRL_USE_CSC_CHECK_OPER_MODE(SYS_TYPE_GET_RUNNING_CFG_FAIL);

    /* LOCAL VARIABLES
     */

    /* BODY
     */
#if (SYS_CPNT_WRR_Q_MODE_PER_PORT_CTRL == TRUE)
    if((l_port == 0) || (mode == 0))
    {
        EH_MGR_Handle_Exception (SYS_MODULE_SWCTRL,
                                 SWCTRL_NO_USE_FUNC_NO,
                                 EH_TYPE_MSG_NULL_POINTER,
                                 EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_CRIT); /*SWCTRL_ENO_NULL_POINTER*/

        SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_FAIL );
    }
    if(*l_port > SYS_ADPT_TOTAL_NBR_OF_LPORT)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_FAIL );
    }
#else
    *l_port = 0;
    if(SWCTRL_GetNextLogicalPort(l_port) == SWCTRL_LPORT_UNKNOWN_PORT)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_FAIL );
    }
#endif

    if (SWCTRL_GetNextPortPrioQueueMode(l_port, mode))
    {
       if ((*mode) != default_egress_scheduler_mode)
          SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_SUCCESS );

       SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_NO_CHANGE );
    }

    /* Error code was set in SWCTRL_GetNextPortPrioQueueMode(); */
    SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_FAIL );
}
#endif

#if (SYS_CPNT_WRR_Q_WEIGHT_PER_PORT_CTRL == TRUE)
/*--------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetPortWrrQueueWeight
 *---------------------------------------------------------------------------
 * PURPOSE:  This function will set the weight of queue bandwidths
 * INPUT:    l_port     -- This is the primary key and represent the logical port number
 *           q_id       -- This is the second key and represent the index of wrr queue
 *           weight     -- The weight of (l_port, q_id)
 * OUTPUT:   None
 * RETURN:   TRUE/FALSE
 * NOTE:  The ratio of weight determines the weight of the WRR scheduler.
 *        Driver maybe need to provide API to enable WRR of ASIC
 *---------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetPortWrrQueueWeight(UI32_T l_port, UI32_T q_id, UI32_T weight)
{
    /* LOCAL VARIABLES
     */
    UI16_T unit, port;
    UI32_T trunk_id,i;
    BOOL_T ret=FALSE;
    BOOL_T permit_set = TRUE;

    #if 0
    BOOL_T old_zero=FALSE;  /* modified by Jinhua Wei ,to remove warning ,becaued the variable never used */
    #endif

    /* BODY
     */
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if ( l_port == 0 || l_port > SYS_ADPT_TOTAL_NBR_OF_LPORT)
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Logical Port ID (1-%d)", SYS_ADPT_TOTAL_NBR_OF_LPORT);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_LOGICAL_PORT_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (q_id >= SYS_ADPT_MAX_NBR_OF_PRIORITY_QUEUE)
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Egress Queue ID (1-%d)", SYS_ADPT_MAX_NBR_OF_PRIORITY_QUEUE);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_LOGICAL_PORT_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (!SWCTRL_IS_USER_PORT(l_port) || !SWCTRL_IS_EXIST(l_port))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a valid port.");

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    SWCTRL_LOCK();

    if (!SWCTRL_IS_TRUNK (l_port))
    {
        unit = SWCTRL_IFINDEX_TO_UNIT(l_port);
        port = SWCTRL_IFINDEX_TO_PORT(l_port);

        switch(port_info[l_port - 1].egress_scheduler_method)
        {
            case SWCTRL_STRICT_PRIORITY_METHOD:
                permit_set = FALSE;
                break;

            case SWCTRL_WEIGHT_ROUND_ROBIN_METHOD:
                if(weight > SYS_ADPT_MAX_RATIO_OF_WRR || weight < SYS_ADPT_MIN_RATIO_OF_WRR)
                    permit_set = FALSE;
                break;

            case SWCTRL_SP_WRR_METHOD:
                if(weight > SYS_ADPT_MAX_RATIO_OF_WRR)
                    permit_set = FALSE;

#if 0
                /*we don't need to check here, due to we have checked in cos_vm*/
                if ( (weight != 0) &&
                          (port_info[l_port - 1].strict_queue_map & 1 << q_id) )
                {
                    port_info[l_port - 1].wrr_weight[q_id] = weight;
                    SWCTRL_UNLOCK();
                    SWCTRL_RETURN_AND_RELEASE_CSC(TRUE);
                }
#endif
                break;

            case SWCTRL_DEFICIT_ROUND_ROBIN_METHOD:
                if(weight > SYS_ADPT_MAX_RATIO_OF_DRR || weight < SYS_ADPT_MIN_RATIO_OF_DRR)
                    permit_set = FALSE;
                break;

            case SWCTRL_SP_DRR_METHOD:
                if(weight > SYS_ADPT_MAX_RATIO_OF_DRR)
                    permit_set = FALSE;
#if 0
                /*we don't need to check here, due to we have checked in cos_vm*/
                if ( (weight != 0) &&
                     (port_info[l_port - 1].strict_queue_map & 1 << q_id) )
                {
                    port_info[l_port - 1].wrr_weight[q_id] = weight;
                    SWCTRL_UNLOCK();
                    SWCTRL_RETURN_AND_RELEASE_CSC(TRUE);
                }
#endif
                break;
        }

        if(permit_set)
            ret = SWDRV_SetPortWrrQueueWeight(unit, port, q_id, weight);
    }

    if (SWCTRL_IS_TRUNK (l_port))
    {
        trunk_id = SWCTRL_IFINDEX_TO_TRUNKID (l_port);

        for(i=0; i<trunk_ext_port_info[trunk_id-1].member_number; i++)
        {
            unit = trunk_ext_port_info[trunk_id-1].member_list[i].unit;
            port = trunk_ext_port_info[trunk_id-1].member_list[i].port;
            ret=SWDRV_SetPortWrrQueueWeight(unit, port, q_id, weight);
            if (ret)
               port_info[port-1].wrr_weight[q_id] = weight;
        }
    } /* End of if */

    if (ret)
    {
            port_info[l_port - 1].wrr_weight[q_id] = weight;
    }

    SWCTRL_UNLOCK();
    SWCTRL_RETURN_AND_RELEASE_CSC( ret );
} /* End of SWCTRL_SetPortWrrQueueWeight() */
#else
/*------------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetWrrQueueWeight
 *------------------------------------------------------------------------------
 * PURPOSE:  This function will set the weight of queue bandwidths
 * INPUT:    q_id       -- This is the second key and represent the index of
 *                         wrr queue.
 *           weight     -- The weight of (l_port, q_id).
 * OUTPUT:   None
 * RETURN:   TRUE/FALSE
 * NOTE:     The ratio of weight determines the weight of the WRR scheduler.
 *           Driver maybe need to provide API to enable WRR of ASIC
 *------------------------------------------------------------------------------
 */
BOOL_T SWCTRL_SetWrrQueueWeight(UI32_T q_id, UI32_T weight)
{
    BOOL_T ret = FALSE;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    ret = (weight == 0) ?
        SWDRV_SetStrictPriorityQueue(q_id) :
        SWDRV_SetWrrQueueWeight(q_id, weight);

    SWCTRL_RETURN_AND_RELEASE_CSC(ret);
}
#endif

#if 0
/*--------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetWrrQueueWeight
 *---------------------------------------------------------------------------
 * PURPOSE:  This function will set the weight of queue bandwidths
 * INPUT:    q_id       -- This is the second key and represent the index of wrr queue
 *           weight     -- The weight of (l_port, q_id)
 * OUTPUT:   None
 * RETURN:   TRUE/FALSE
 * NOTE:  The ratio of weight determines the weight of the WRR scheduler.
 *        Driver maybe need to provide API to enable WRR of ASIC
 *---------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetWrrQueueWeight(UI32_T q_id, UI32_T weight)
{
    /* LOCAL VARIABLES
     */
    UI32_T trunk_id, i;

    /* BODY
     */
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (q_id >= SYS_ADPT_MAX_NBR_OF_PRIORITY_QUEUE)
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Egress Queue ID (1-%d)", SYS_ADPT_MAX_NBR_OF_PRIORITY_QUEUE);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_LOGICAL_PORT_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    for(i = 1; i <= SYS_ADPT_TOTAL_NBR_OF_LPORT; i++)
    {
        if (! SWCTRL_LogicalPortExisting(i))
            continue;
        if (!SWCTRL_SetPortWrrQueueWeight(i, q_id, weight))
        {
            if (!SWCTRL_IS_TRUNK (i) && !SWCTRL_IS_TRUNK_MEMBER (i))  /* normal port */
            {
                /* Error code was set in SWCTRL_SetPortWrrQueueWeight(); */
                SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
            }

            if (SWCTRL_IS_TRUNK (i))                                  /* trunk port */
            {
                trunk_id = SWCTRL_IFINDEX_TO_TRUNKID (i);

                if(trunk_ext_port_info[trunk_id-1].member_number > 0)
                {
                    /* Error code was set in SWCTRL_SetPortWrrQueueWeight(); */
                    SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
                }
            } /* End of if */
        }
    }
    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );

} /* End of SWCTRL_SetWrrQueueWeight() */


/*--------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_ResetPortWrrQueueWeight
 *---------------------------------------------------------------------------
 * PURPOSE:  This function will reset the current weight to default
 * INPUT:    l_port     -- This is the primary key and represent the logical port number
 *           q_id       -- This is the second key and represent the index of wrr queue
 * OUTPUT:   none
 * RETURN:   TRUE/FALSE
 * NOTE:  The default ratio of weight is defined in sys_dflt.h
 *        Driver maybe need to provide API to disable WRR of ASIC
 *---------------------------------------------------------------------------*/
BOOL_T SWCTRL_ResetPortWrrQueueWeight(UI32_T l_port, UI32_T q_id)
{
    /* LOCAL VARIABLES
     */
    UI16_T unit, port;
    UI32_T trunk_id,i;
    BOOL_T ret=FALSE;

    /* BODY
     */
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if ( l_port == 0 || l_port > SYS_ADPT_TOTAL_NBR_OF_LPORT)
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Logical Port ID (1-%d)", SYS_ADPT_TOTAL_NBR_OF_LPORT);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_LOGICAL_PORT_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (q_id >= SYS_ADPT_MAX_NBR_OF_PRIORITY_QUEUE)
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Logical Port ID (1-%d)", SYS_ADPT_TOTAL_NBR_OF_LPORT);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_LOGICAL_PORT_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
    if (! SWCTRL_LogicalPortExisting(l_port))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (SWCTRL_IS_TRUNK_MEMBER (l_port))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    SWCTRL_LOCK();

    if (!SWCTRL_IS_TRUNK (l_port))
    {
        unit = SWCTRL_IFINDEX_TO_UNIT(l_port);
        port = SWCTRL_IFINDEX_TO_PORT(l_port);

        ret=SWDRV_SetPortWrrQueueWeight(unit, port, q_id, wrr_queue_default[q_id]);
    }

    if (SWCTRL_IS_TRUNK (l_port))
    {
        trunk_id = SWCTRL_IFINDEX_TO_TRUNKID (l_port);

        for(i=0; i<trunk_ext_port_info[trunk_id-1].member_number; i++)
        {
            unit = trunk_ext_port_info[trunk_id-1].member_list[i].unit;
            port = trunk_ext_port_info[trunk_id-1].member_list[i].port;
            ret=SWDRV_SetPortWrrQueueWeight(unit, port, q_id, wrr_queue_default[q_id]);
        }
    } /* End of switch */

    if (ret)
       port_info[l_port-1].wrr_weight[q_id] = wrr_queue_default[q_id];

    SWCTRL_UNLOCK();

    SWCTRL_RETURN_AND_RELEASE_CSC( ret );
} /* End of SWCTRL_ResetPortWrrQueueWeight() */

/*--------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetPortWrrQueueWeight
 *---------------------------------------------------------------------------
 * PURPOSE:  This function will get the current weight of queue bandwidths
 * INPUT:    l_port     -- This is the primary key and represent the logical port number
 *           q_id       -- This is the second key and represent the index of wrr queue
 * OUTPUT:   weight     -- The weight of (l_port, q_id)
 * RETURN:   TRUE/FALSE
 * NOTE:  The ratio of weight determines the weight of the WRR scheduler.
 *---------------------------------------------------------------------------*/
BOOL_T SWCTRL_GetPortWrrQueueWeight(UI32_T l_port, UI32_T q_id, UI32_T *weight)
{
    /* BODY
     */
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (weight == 0)
    {
        EH_MGR_Handle_Exception (SYS_MODULE_SWCTRL,
                                 SWCTRL_NO_USE_FUNC_NO,
                                 EH_TYPE_MSG_NULL_POINTER,
                                 EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_CRIT); /*SWCTRL_ENO_NULL_POINTER*/
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if ( l_port == 0 || l_port > SYS_ADPT_TOTAL_NBR_OF_LPORT)
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Logical Port ID (1-%d)", SYS_ADPT_TOTAL_NBR_OF_LPORT);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_LOGICAL_PORT_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (q_id >= SYS_ADPT_MAX_NBR_OF_PRIORITY_QUEUE)
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Egress Queue ID (1-%d)", SYS_ADPT_MAX_NBR_OF_PRIORITY_QUEUE);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_LOGICAL_PORT_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (! SWCTRL_LogicalPortExisting(l_port))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    SWCTRL_LOCK();

    switch(port_info[l_port - 1].egress_scheduler_method)
    {
        case SWCTRL_STRICT_PRIORITY_METHOD:
            *weight = 0;
            break;

        case SWCTRL_WEIGHT_ROUND_ROBIN_METHOD:
        case SWCTRL_DEFICIT_ROUND_ROBIN_METHOD:
            *weight = port_info[l_port-1].wrr_weight[q_id];
            break;

        case SWCTRL_SP_DRR_METHOD:
        case SWCTRL_SP_WRR_METHOD:
            if(port_info[l_port - 1].strict_queue_map & 1 << q_id)
                *weight = 0;
            else
                *weight = port_info[l_port-1].wrr_weight[q_id];
            break;

        default:
            break;
    }

    SWCTRL_UNLOCK();
    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
} /* End of SWCTRL_GetPortWrrQueueWeight() */

/*--------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetNextPortWrrQueueWeight
 *---------------------------------------------------------------------------
 * PURPOSE:  This function will get the value of indexed entry and output next index
 * INPUT:    l_port     -- This is the primary key and represent the logical port number
 *           q_id       -- This is the second key and represent the index of wrr queue
 * OUTPUT:   l_port -- next index
 *           q_id   -- next index
 *           weight     -- The weight of (l_port, q_id)
 * RETURN:   True/False
 * NOTE:     The returned value will base on the database of core layer
 *           rather than the database of ASIC
 *---------------------------------------------------------------------------*/
BOOL_T SWCTRL_GetNextPortWrrQueueWeight(UI32_T *l_port, UI32_T *q_id, UI32_T *weight)
{
    /* BODY
     */
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if ((l_port == 0) || (q_id == 0) || (weight == 0))
    {
        EH_MGR_Handle_Exception (SYS_MODULE_SWCTRL,
                                 SWCTRL_NO_USE_FUNC_NO,
                                 EH_TYPE_MSG_NULL_POINTER,
                                 EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_CRIT); /*SWCTRL_ENO_NULL_POINTER*/
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
    if (*l_port > SYS_ADPT_TOTAL_NBR_OF_LPORT)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (! SWCTRL_LogicalPortExisting(*l_port) || ++*q_id >= SYS_ADPT_MAX_NBR_OF_PRIORITY_QUEUE)
    {
     *q_id = MIN_WrrWeightQueue;
         if(SWCTRL_GetNextLogicalPort(l_port) == SWCTRL_LPORT_UNKNOWN_PORT)
         {
            SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
         }
    }
    SWCTRL_LOCK();
    *weight = port_info[*l_port-1].wrr_weight[*q_id];
    SWCTRL_UNLOCK();
    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
} /* End of SWCTRL_GetNextPortWrrQueueWeight() */

/*--------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetRunningPortWrrQueueWeight
 *---------------------------------------------------------------------------
 * PURPOSE:  This function will get the current weight of WRR queues
 * INPUT:    l_port     -- This is the primary key and represent the logical port number
 *           q_id       -- This is the second key and represent the index of wrr queue
 * OUTPUT:   weight     -- The weight of (l_port, q_id)
 * RETURN:   SYS_TYPE_GET_RUNNING_CFG_FAIL -- error (system is not in MASTER mode)
 *           SYS_TYPE_GET_RUNNING_CFG_NO_CHANGE -- same as default
 *           SYS_TYPE_GET_RUNNING_CFG_SUCCESS -- different from default value
 * NOTE:
 *---------------------------------------------------------------------------*/
SYS_TYPE_Get_Running_Cfg_T SWCTRL_GetRunningPortWrrQueueWeight(UI32_T l_port, UI32_T q_id, UI32_T *weight)
{
    int i;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(SYS_TYPE_GET_RUNNING_CFG_FAIL);

    /* LOCAL VARIABLES
     */

    /* BODY
     */
    if (weight == 0)
    {
        EH_MGR_Handle_Exception (SYS_MODULE_SWCTRL,
                                 SWCTRL_NO_USE_FUNC_NO,
                                 EH_TYPE_MSG_NULL_POINTER,
                                 EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_CRIT); /*SWCTRL_ENO_NULL_POINTER*/
        SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_FAIL );
    }
    if ( l_port == 0 || l_port > SYS_ADPT_TOTAL_NBR_OF_LPORT)
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Logical Port ID (1-%d)", SYS_ADPT_TOTAL_NBR_OF_LPORT);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_LOGICAL_PORT_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_FAIL );
    }
    if (q_id >= SYS_ADPT_MAX_NBR_OF_PRIORITY_QUEUE)
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Egress Queue ID (1-%d)", SYS_ADPT_MAX_NBR_OF_PRIORITY_QUEUE);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_LOGICAL_PORT_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_FAIL );
    }
    switch(port_info[l_port - 1].egress_scheduler_method)
    {
        case SWCTRL_STRICT_PRIORITY_METHOD:
            SWCTRL_RETURN_AND_RELEASE_CSC(SYS_TYPE_GET_RUNNING_CFG_NO_CHANGE);
        case SWCTRL_WEIGHT_ROUND_ROBIN_METHOD:
        case SWCTRL_DEFICIT_ROUND_ROBIN_METHOD:
        case SWCTRL_SP_WRR_METHOD:
        case SWCTRL_SP_DRR_METHOD:
            for(i = 0; i < SYS_ADPT_MAX_NBR_OF_PRIORITY_QUEUE; i++)
                if(port_info[l_port - 1].wrr_weight[i] != wrr_queue_default[i])
                    break;

            if(SYS_ADPT_MAX_NBR_OF_PRIORITY_QUEUE == i)
                SWCTRL_RETURN_AND_RELEASE_CSC(SYS_TYPE_GET_RUNNING_CFG_NO_CHANGE);
            break;
    }

    *weight = port_info[l_port - 1].wrr_weight[q_id];
    SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_SUCCESS );

#if 0
    if (SWCTRL_GetPortWrrQueueWeight(l_port, q_id, weight))
    {
       if ((*weight) != wrr_queue_default[q_id])
          SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_SUCCESS );

       SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_NO_CHANGE );
    }

    /* Error code was set in SWCTRL_GetPortWrrQueueWeight(); */
    SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_FAIL );
#endif
} /* End of SWCTRL_GetRunningPortWrrQueueWeight() */

/* ---------------------------------------------------------------------
 * ROUTINE NAME  - SWCTRL_GetNextRunningPortWrrQueueWeight
 * ---------------------------------------------------------------------
 * PURPOSE: This function same as GetRunning but also output next index
 * INPUT:    l_port     -- This is the primary key and represent the logical port number
 *           q_id       -- This is the second key and represent the index of wrr queue
 * OUTPUT:   l_port -- next index
 *           q_id   -- next index
 *           weight -- The weight of (l_port, q_id)
 * RETURN:  status : SYS_TYPE_Get_Running_Cfg_T
 *                    1.SYS_TYPE_GET_RUNNING_CFG_FAIL -- system not in MASTER mode
 *                    2.SYS_TYPE_GET_RUNNING_CFG_SUCCESS -- different with default
 *                    3.SYS_TYPE_GET_RUNNING_CFG_NO_CHANGE-- same as default
 * NOTES: 1. This function shall only be invoked by CLI to save the
 *           "running configuration" to local or remote files.
 *        2. Since only non-default configuration will be saved, this
 *           function shall return non-default weight
 *        3. Caller has to prepare buffer for storing weight
 * ---------------------------------------------------------------------*/
SYS_TYPE_Get_Running_Cfg_T SWCTRL_GetNextRunningPortWrrQueueWeight(UI32_T *l_port , UI32_T *q_id, UI32_T *weight)
{
    SWCTRL_USE_CSC_CHECK_OPER_MODE(SYS_TYPE_GET_RUNNING_CFG_FAIL);

    /* LOCAL VARIABLES
     */

    /* BODY
     */
    if((weight == 0) || (l_port == 0) || (q_id == 0))
    {
        EH_MGR_Handle_Exception (SYS_MODULE_SWCTRL,
                                 SWCTRL_NO_USE_FUNC_NO,
                                 EH_TYPE_MSG_NULL_POINTER,
                                 EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_CRIT); /*SWCTRL_ENO_NULL_POINTER*/
        SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_FAIL );
    }
    if(*l_port > SYS_ADPT_TOTAL_NBR_OF_LPORT)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_FAIL );
    }
    if(*q_id >= SYS_ADPT_MAX_NBR_OF_PRIORITY_QUEUE)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_FAIL );
    }
    if (SWCTRL_GetNextPortWrrQueueWeight(l_port, q_id, weight))
    {
       if ((*weight) != wrr_queue_default[(*q_id)])
          SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_SUCCESS );

       SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_NO_CHANGE );
    }

    /* Error code was set in SWCTRL_GetNextPortWrrQueueWeight(); */
    SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_FAIL );
} /* End of SWCTRL_GetNextRunningPortWrrQueueWeight() */
#endif

/*---------------------------------------------------------------------- */
/* (portMgt 1)--ES3626A */
/*
 *      INDEX       { portIndex }
 *      PortEntry ::= SEQUENCE
 *      {
 *          portIndex                Integer32,
 *          portName                 DisplayString,
 *          portType                 INTEGER,
 *          portSpeedDpxCfg          INTEGER,
 *          portFlowCtrlCfg          INTEGER,
 *          portCapabilities         BITS,
 *          portAutonegotiation      INTEGER,
 *          portSpeedDpxStatus       INTEGER,
 *          portFlowCtrlStatus       INTEGER,
 *          portTrunkIndex           Integer32
 *      }
 */
/*------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetPortEntry
 *------------------------------------------------------------------------
 * FUNCTION: This function will get the port table entry info
 * INPUT   : port_entry->port_index - interface index
 * OUTPUT  : port_entry             - The port table entry info
 * RETURN  : TRUE/FALSE
 * NOTE    : ES3626A MIB/portMgt 1
 *------------------------------------------------------------------------*/
BOOL_T SWCTRL_GetPortEntry(SWCTRL_PortEntry_T *port_entry)
{
    UI32_T unit;
    UI32_T port;
    UI32_T trunk_id;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (port_entry == 0)
    {
        EH_MGR_Handle_Exception (SYS_MODULE_SWCTRL,
                                 SWCTRL_NO_USE_FUNC_NO,
                                 EH_TYPE_MSG_NULL_POINTER,
                                 EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_CRIT); /*SWCTRL_ENO_NULL_POINTER*/
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if ((!SWCTRL_IS_USER_PORT(port_entry->port_index) && !SWCTRL_IS_TRUNK(port_entry->port_index)) ||
        !SWCTRL_IS_EXIST(port_entry->port_index))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Interface");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    *port_entry = port_info[(port_entry->port_index) - 1].port_entry;

#if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION == TRUE)
#if (SYS_DFLT_TRAFFIC_SEG_METHOD == SYS_DFLT_TRAFFIC_SEG_METHOD_PORT_PRIVATE_MODE)

/* Added not available for private mode*/
#if (SYS_CPNT_SYSCTRL_XOR == TRUE)
    /* The port list only contain one ifindex.
     * The ifindex can be set to private.
     */
    if(TRUE == SYSCTRL_XOR_MGR_PermitBeingSetToPrivatePortByIfindex(port_entry->port_index))
    {
        /* The ifindex is downlink port */
        if (port_info[(port_entry->port_index) - 1].private_vlan_downlink_port)
        {
            port_entry->port_private_mode = VAL_portPrivateMode_enabled;
        }
        else /* The ifindex is uplink port */
        {
            port_entry->port_private_mode = VAL_portPrivateMode_disabled;
        }
    }
    else /* The ifindex can not be set to private. */
    {
        port_entry->port_private_mode = VAL_portPrivateMode_notAvailable;
    }
#else /* SYS_CPNT_SYSCTRL_XOR == FALSE */
    if (port_info[(port_entry->port_index) - 1].private_vlan_downlink_port)
    {
        port_entry->port_private_mode = VAL_portPrivateMode_enabled;
    }
    else
    {
        port_entry->port_private_mode = VAL_portPrivateMode_disabled;
    }
#endif /* End of #if (SYS_CPNT_SYSCTRL_XOR == TRUE) */
#endif /* End of #if (SYS_DFLT_TRAFFIC_SEG_METHOD == SYS_DFLT_TRAFFIC_SEG_METHOD_PORT_PRIVATE_MODE) */
#endif /* End of #if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION == TRUE) */

    /* port up time */
    if (SWCTRL_IS_OPER_UP(port_entry->port_index))
    {
        UI32_T sys_uptime;

        SYS_TIME_GetSystemUpTimeByTick(&sys_uptime);

        port_entry->uptime = sys_uptime - port_info[port_entry->port_index-1].link_oper_status_last_up;
    }
    else
    {
        port_entry->uptime = 0;
    }

    /* This status or config of trunk port should be primary port or
     * first trtunk member
     */
    if( SWCTRL_LogicalPortToUserPort(port_entry->port_index, &unit, &port, &trunk_id) == SWCTRL_LPORT_TRUNK_PORT )
    {
        UI32_T local_ifindex;

        /* trunk port
         */
        if (!SWCTRL_GetTrunkPrimaryPort(port_entry->port_index, &local_ifindex))
        {
            /* This is temporary solution.
             * Need to spec change,
             * i.e
             * If a trunk has no member,
             * this API should return FALSE.
             */
            local_ifindex = port_entry->port_index;
        }

        /* port type
         */
        port_entry->port_type = port_info[local_ifindex-1].port_entry.port_type;
        /*port_mtu,added by jinhua.wei
        */
        port_entry->port_mtu = port_info[local_ifindex-1].port_entry.port_mtu;
#if(SYS_CPNT_AMTR_PORT_MAC_LEARNING == TRUE)/*Tony.Lei*/
        /*port mac learning,added by jinhua.wei
            */
        port_entry->port_macaddr_learning = port_info[local_ifindex-1].port_entry.port_macaddr_learning ;
#endif

        /* autoneg capability
         */
        port_entry->port_capabilities = port_info[local_ifindex-1].port_entry.port_capabilities;

        /* speed-duplex
         */
        port_entry->port_speed_dpx_status = port_info[local_ifindex-1].port_entry.port_speed_dpx_status;

        /* flow control oper status
         */
        port_entry->port_flow_ctrl_status = port_info[local_ifindex -1].port_entry.port_flow_ctrl_status;

        /* port_forced_mode
         */
        port_entry->port_forced_mode = port_info[local_ifindex-1].port_entry.port_forced_mode;

#if(SYS_CPNT_SWCTRL_SWITCH_MODE_CONFIGURABLE == TRUE)
        /* switch_mode
         */
        port_entry->switch_mode = port_info[local_ifindex-1].port_entry.switch_mode;
#endif
    }

    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
} /* End of SWCTRL_GetPortEntry () */


/*------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetNextPortEntry
 *------------------------------------------------------------------------
 * FUNCTION: This function will get the next port table entry info
 * INPUT   : port_entry->port_index - interface index
 * OUTPUT  : port_entry             - The port table entry info
 * RETURN  : TRUE/FALSE
 * NOTE    : ES3626A MIB/portMgt 1
 *------------------------------------------------------------------------*/
BOOL_T SWCTRL_GetNextPortEntry(SWCTRL_PortEntry_T *port_entry)
{
    UI32_T i;
    SWCTRL_PortEntry_T tmp_port_entry;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (port_entry == 0)
    {
        EH_MGR_Handle_Exception (SYS_MODULE_SWCTRL,
                                 SWCTRL_NO_USE_FUNC_NO,
                                 EH_TYPE_MSG_NULL_POINTER,
                                 EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_CRIT); /*SWCTRL_ENO_NULL_POINTER*/
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    for (i = ++(port_entry->port_index); i <= SYS_ADPT_TOTAL_NBR_OF_LPORT; i++)
    {
        tmp_port_entry.port_index = i;

        if (SWCTRL_GetPortEntry(&tmp_port_entry))
        {
            *port_entry = tmp_port_entry;

            SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
        }
    }

    SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
} /* End of SWCTRL_GetNextPortEntry () */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetPortName
 * -------------------------------------------------------------------------
 * FUNCTION: This function will set name to a port
 * INPUT   : ifindex    -- which port to set
 *           port_name  -- the name to set
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : ES3626A MIB/portMgt 1
 *           size (0..64)
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetPortName(UI32_T ifindex, UI8_T *port_name)
{
    UI32_T                    member_ifindex = 0;
    UI32_T                    unit = 0, port = 0, i = 0;
    SWCTRL_TrunkPortExtInfo_T trunk_ext_p_info;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (!SWCTRL_IS_LPORT(ifindex))
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Logical Port ID (1-%d)", SYS_ADPT_TOTAL_NBR_OF_LPORT);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_LOGICAL_PORT_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if(port_name == 0)
    {
        EH_MGR_Handle_Exception (SYS_MODULE_SWCTRL,
                                 SWCTRL_NO_USE_FUNC_NO,
                                 EH_TYPE_MSG_NULL_POINTER,
                                 EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_CRIT); /*SWCTRL_ENO_NULL_POINTER*/
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    SWCTRL_LOCK();

    /* for trunk port & normal port
     */
    strncpy((char*)port_info[ifindex-1].port_entry.port_name, (char*)port_name, MAXSIZE_portName);
    port_info[ifindex-1].port_entry.port_name[MAXSIZE_portName] = 0;
#if (SYS_CPNT_SWCTRL_PORT_DESCRIPTION_MIRROR_TO_IF_ALIAS == TRUE)
    strncpy((char*)port_info[ifindex-1].port_entry.port_alias, (char*)port_name, MAXSIZE_ifAlias);
    port_info[ifindex-1].port_entry.port_alias[MAXSIZE_ifAlias] = 0;
#endif

    /* for trunk member port
     */
    if (SWCTRL_IS_TRUNK(ifindex))
    {
        if (SWCTRL_GetTrunkPortExtInfo(ifindex, &trunk_ext_p_info))
        {
            for(i = 0; i < trunk_ext_p_info.member_number; i ++)
            {
                unit = (UI32_T) trunk_ext_p_info.member_list[i].unit;
                port = (UI32_T) trunk_ext_p_info.member_list[i].port;
                member_ifindex = SWCTRL_UPORT_TO_IFINDEX(unit, port);

                strncpy((char*)port_info[member_ifindex-1].port_entry.port_name, (char*)port_name, MAXSIZE_portName);
                port_info[member_ifindex-1].port_entry.port_name[MAXSIZE_portName] = 0;
#if (SYS_CPNT_SWCTRL_PORT_DESCRIPTION_MIRROR_TO_IF_ALIAS == TRUE)
                strncpy((char*)port_info[member_ifindex-1].port_entry.port_alias, (char*)port_name, MAXSIZE_ifAlias);
                port_info[member_ifindex-1].port_entry.port_alias[MAXSIZE_ifAlias] = 0;
#endif
            } /* End of for () */
        }
    } /* End of if (trunk) */

    SWCTRL_UNLOCK();
    SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME ();
    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
} /* End of SWCTRL_SetPortName() */

/*EPR:ES4827G-FLF-ZZ-00232
 *Problem: CLI:size of vlan name different in console and mib
 *Solution: add CLI command "alias" for interface set,the
 *          alias is different from name and port descrition,so
 *          need add new command.
 *modify file: cli_cmd.c,cli_cmd.h,cli_arg.c,cli_arg.h,cli_msg.c,
 *             cli_msg.h,cli_api_vlan.c,cli_api_vlan.h,cli_api_ehternet.c
 *             cli_api_ethernet.h,cli_api_port_channel.c,cli_api_port_channel.h,
 *             cli_running.c,rfc_2863.c,swctrl.h,trk_mgr.h,trk_pmgr.h,swctrl.c
 *             swctrl_pmgr.c,trk_mgr.c,trk_pmgr.c,vlan_mgr.h,vlan_pmgr.h,
 *             vlan_type.h,vlan_mgr.c,vlan_pmgr.c,if_mgr.c
 *Approved by:Hardsun
 *Fixed by:Dan Xie
 */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetPortAlias
 * -------------------------------------------------------------------------
 * FUNCTION: This function will set alias to a port
 * INPUT   : ifindex    -- which port to set
 *           port_name  -- the alias to set
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : ES3626A MIB/portMgt 1
 *           size (0..64)
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetPortAlias(UI32_T ifindex, UI8_T *port_alias)
{
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (!SWCTRL_IS_LPORT(ifindex))
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Logical Port ID (1-%d)", SYS_ADPT_TOTAL_NBR_OF_LPORT);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_LOGICAL_PORT_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if(port_alias == 0)
    {
        EH_MGR_Handle_Exception (SYS_MODULE_SWCTRL,
                                 SWCTRL_NO_USE_FUNC_NO,
                                 EH_TYPE_MSG_NULL_POINTER,
                                 EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_CRIT); /*SWCTRL_ENO_NULL_POINTER*/
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    SWCTRL_LOCK();
    strncpy((char*)port_info[ifindex-1].port_entry.port_alias, (char*)port_alias, MAXSIZE_ifAlias);
    port_info[ifindex-1].port_entry.port_alias[MAXSIZE_ifAlias] = 0;
#if (SYS_CPNT_SWCTRL_PORT_DESCRIPTION_MIRROR_TO_IF_ALIAS == TRUE)
    strncpy((char*)port_info[ifindex-1].port_entry.port_name, (char*)port_alias, MAXSIZE_portName);
    port_info[ifindex-1].port_entry.port_name[MAXSIZE_portName] = 0;
#endif
    SWCTRL_UNLOCK();
    SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME ();
    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
}
/*------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetPortSpeedDpxCfg
 *------------------------------------------------------------------------
 * FUNCTION: This function will Set the port speed and duplex mode
 * INPUT   : ifindex                        - interface index
 *           port_speed_dpx_cfg             - VAL_portSpeedDpxCfg_halfDuplex10
 *                                            VAL_portSpeedDpxCfg_fullDuplex10
 *                                            VAL_portSpeedDpxCfg_halfDuplex100
 *                                            VAL_portSpeedDpxCfg_fullDuplex100
 *                                            VAL_portSpeedDpxCfg_halfDuplex1000 <== no support
 *                                            VAL_portSpeedDpxCfg_fullDuplex1000
 * OUTPUT  : None
 * RETURN  : TRUE/FALSE
 * NOTE    : ES3626A MIB/portMgt 1
 *------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetPortSpeedDpxCfg(UI32_T ifindex, UI32_T port_speed_dpx_cfg)
{
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    SWCTRL_RETURN_AND_RELEASE_CSC( SWCTRL_SetPortCfgSpeedDuplex(ifindex, port_speed_dpx_cfg) );
} /* End of SWCTRL_SetPortSpeedDpxCfg () */


/*------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetPortFlowCtrlCfg
 *------------------------------------------------------------------------
 * FUNCTION: This function will Set the port flow control mechanism
 * INPUT   : ifindex                        - interface index
 *           port_flow_ctrl_cfg             - VAL_portFlowCtrlCfg_enabled
 *                                            VAL_portFlowCtrlCfg_disabled
 *                                            VAL_portFlowCtrlCfg_backPressure
 *                                            VAL_portFlowCtrlCfg_dot3xFlowControl
 *                                            VAL_portFlowCtrlCfg_tx
 *                                            VAL_portFlowCtrlCfg_rx
 * OUTPUT  : None
 * RETURN  : TRUE/FALSE
 * NOTE    : ES3626A MIB/portMgt 1
 *------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetPortFlowCtrlCfg(UI32_T ifindex, UI32_T port_flow_ctrl_cfg)
{
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    /* VAL_portFlowCtrlCfg_backPressure:         no implemented now
       VAL_portFlowCtrlCfg_dot3xFlowControl:     no implemented now
    */
    SWCTRL_RETURN_AND_RELEASE_CSC( SWCTRL_SetPortCfgFlowCtrlEnable(ifindex, port_flow_ctrl_cfg) );
}/* End of SWCTRL_SetPortFlowCtrlCfg () */


/*------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetPortCapabilities
 *------------------------------------------------------------------------
 * FUNCTION: This function will Set the port capabilities
 * INPUT   : ifindex                        - interface index
 *           port_capabilities              - bitmap to set capability
 *
 *          SYS_VAL_portCapabilities_portCap10half          BIT_0
 *          SYS_VAL_portCapabilities_portCap10full          BIT_1
 *          SYS_VAL_portCapabilities_portCap100half         BIT_2
 *          SYS_VAL_portCapabilities_portCap100full         BIT_3
 *          SYS_VAL_portCapabilities_portCap1000half        BIT_4 <== not support
 *          SYS_VAL_portCapabilities_portCap1000full        BIT_5
 *          SYS_VAL_portCapabilities_portCapSym             BIT_14
 *          SYS_VAL_portCapabilities_portCapFlowCtrl        BIT_15
 * OUTPUT  : None
 * RETURN  : TRUE/FALSE
 * NOTE    : ES3626A MIB/portMgt 1
 * Usage   : set 10half and 100full ==>
 *     bitmap = SYS_VAL_portCapabilities_portCap10half | SYS_VAL_portCapabilities_portCap100full
 *------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetPortCapabilities(UI32_T ifindex, UI32_T port_capabilities)
{
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    SWCTRL_RETURN_AND_RELEASE_CSC( SWCTRL_SetPortAutoNegCapability(ifindex, port_capabilities) );
}/* End of SWCTRL_SetPortCapabilities () */


/*------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetPortAutonegotiation
 *------------------------------------------------------------------------
 * FUNCTION: This function will Set the port autonegotiation
 * INPUT   : ifindex                        - interface index
 *           port_autonegotiation           - VAL_portAutonegotiation_enabled
 *                                            VAL_portAutonegotiation_disabled
 * OUTPUT  : None
 * RETURN  : TRUE/FALSE
 * NOTE    : ES3626A MIB/portMgt 1
 *------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetPortAutonegotiation(UI32_T ifindex, UI32_T port_autonegotiation)
{
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    SWCTRL_RETURN_AND_RELEASE_CSC( SWCTRL_SetPortAutoNegEnable(ifindex, port_autonegotiation) );
}/* End of SWCTRL_SetPortAutonegotiation() */


/*---------------------------------------------------------------------- */
/* ( mirrorMgt 1)--ES3626A */
/*
 *      INDEX { mirrorDestinationPort, mirrorSourcePort }
 *      MirrorEntry ::= SEQUENCE
 *      {
 *          mirrorDestinationPort  Integer32,
 *          mirrorSourcePort       Integer32,
 *          mirrorType             INTEGER,
 *          mirrorStatus           INTEGER
 *      }
 */
/*------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetMirrorEntry
 *------------------------------------------------------------------------
 * FUNCTION: This function will get the mirror table entry info
 * INPUT   : mirror_entry->mirror_destination_port - mirror destination port
 *           mirror_entry->mirror_source_port      - mirror source port
 * OUTPUT  : mirror_entry                          - The mirror entry info
 * RETURN  : TRUE/FALSE
 * NOTE    : ES3626A MIB/mirrorMgt 1
 *------------------------------------------------------------------------*/
BOOL_T SWCTRL_GetMirrorEntry(SWCTRL_MirrorEntry_T *mirror_entry)
{
#define TX_DEST_MATCHED_BIT  (1<<0)
#define RX_DEST_MATCHED_BIT  (1<<1)

    UI8_T matched_bitmap = 0;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (mirror_entry == 0)
    {
        EH_MGR_Handle_Exception (SYS_MODULE_SWCTRL,
                                 SWCTRL_NO_USE_FUNC_NO,
                                 EH_TYPE_MSG_NULL_POINTER,
                                 EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_CRIT); /*SWCTRL_ENO_NULL_POINTER*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }


#if (SYS_CPNT_ALLOW_DUMMY_MIRRORING_DEST == TRUE)
    if ((0 == mirror_entry->mirror_source_port) &&
        (0 != mirror_entry->mirror_destination_port) )
    {
        if (mirror_entry->mirror_destination_port == system_info.dummy_mirroring_dest)
        {
            mirror_entry->mirror_type = VAL_mirrorType_both;
            mirror_entry->mirror_status = VAL_mirrorStatus_invalid;

            SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
        }
    }
#endif

    /*should not be "not present" */
    if (!SWCTRL_IS_EXIST (mirror_entry->mirror_source_port     ) ||
        !SWCTRL_IS_EXIST (mirror_entry->mirror_destination_port) )
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Interface");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    /*should not be trunk*/
    if (SWCTRL_IS_TRUNK (mirror_entry->mirror_source_port     ) ||
        SWCTRL_IS_TRUNK (mirror_entry->mirror_destination_port) )
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_TRUNK_CNFG_ERR,
                                  SYSLOG_LEVEL_INFO,
                                  "it doesn't support Mirroring");  /*SWCTRL_ENO_NOT_TRUNK*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    /*dest. port should not be trunk member*/
    if (SWCTRL_IS_TRUNK_MEMBER (mirror_entry->mirror_destination_port))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_MIRROR_NOT_SUPPORT,
                                  SYSLOG_LEVEL_INFO,
                                  "Analyzer Port for Trunk member");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }


    /*ifindex is 1-based, but the OM is 0-based*/
    if(user_ext_port_info[mirror_entry->mirror_source_port - 1].mirroring_tx_dest_port == mirror_entry->mirror_destination_port)
        matched_bitmap |= TX_DEST_MATCHED_BIT;

    if(user_ext_port_info[mirror_entry->mirror_source_port - 1].mirroring_rx_dest_port == mirror_entry->mirror_destination_port)
        matched_bitmap |= RX_DEST_MATCHED_BIT;

    switch(matched_bitmap)
    {
    case (TX_DEST_MATCHED_BIT | RX_DEST_MATCHED_BIT):
        mirror_entry->mirror_type = VAL_mirrorType_both;
        break;

    case (RX_DEST_MATCHED_BIT):
        mirror_entry->mirror_type = VAL_mirrorType_rx;
        break;

    case (TX_DEST_MATCHED_BIT):
        mirror_entry->mirror_type = VAL_mirrorType_tx;
        break;

    default:
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_INVALID_PARAMETER,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "mirror type");   /*SWCTRL_ENO_INVALID_MIRROR_TYPE*/
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    mirror_entry->mirror_status = VAL_mirrorStatus_valid;
    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
}/* End of SWCTRL_GetMirrorEntry () */


/*------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetNextMirrorEntry
 *------------------------------------------------------------------------
 * FUNCTION: This function will get the next mirror table entry info
 * INPUT   : mirror_entry->mirror_destination_port - mirror destination port
 *           mirror_entry->mirror_source_port      - mirror source port
 * OUTPUT  : mirror_entry                          - The mirror entry info
 * RETURN  : TRUE/FALSE
 * NOTE    : ES3626A MIB/mirrorMgt 1
 *------------------------------------------------------------------------*/
#if 0
BOOL_T SWCTRL_GetNextMirrorEntry(SWCTRL_MirrorEntry_T *mirror_entry)
{
    UI32_T om_idx;
    UI32_T matched_om_idx = 0xffffffff;
    UI32_T matched_dest_ifindex = 0xffffffff;
    UI32_T matched_src_ifindex  = 0xffffffff;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (mirror_entry == 0)
    {
        EH_MGR_Handle_Exception (SYS_MODULE_SWCTRL,
                                 SWCTRL_NO_USE_FUNC_NO,
                                 EH_TYPE_MSG_NULL_POINTER,
                                 EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_CRIT); /*SWCTRL_ENO_NULL_POINTER*/
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    /*the input keys should be in reage of user port or 0*/
    if( mirror_entry->mirror_source_port != 0                &&
       !SWCTRL_IS_USER_PORT(mirror_entry->mirror_source_port) )
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    /*the input keys should be in reage of user port or 0*/
    if( mirror_entry->mirror_source_port != 0                &&
       !SWCTRL_IS_USER_PORT(mirror_entry->mirror_destination_port) )
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    /*in the case that destination port (primary key) is 0 and source port is any
      is the same as destination port is 0 and source port is 0xffffffff*/
    if(mirror_entry->mirror_destination_port == 0)
    {
        mirror_entry->mirror_destination_port = 0;
        mirror_entry->mirror_source_port      = 0xffffffff;
    }

#define UPDATE_CANDIDATE(MATCHED_DEST)     \
    matched_om_idx = om_idx;               \
    matched_dest_ifindex = MATCHED_DEST;   \
    matched_src_ifindex  = om_idx+1;


    /* ifindex is 1-based, but the OM is 0-based*/
    for(om_idx = 0; om_idx <= SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK*SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT - 1; om_idx++)
    {
        if(!SWCTRL_IS_EXIST(om_idx + 1))
        {
            continue;
        }

        if( user_ext_port_info[om_idx].mirroring_tx_dest_port == mirror_entry->mirror_destination_port &&
            om_idx+1 > mirror_entry->mirror_source_port)
        {
            /* Primary key the same: TX.
             */
            if(om_idx+1 < matched_src_ifindex)
            {
                UPDATE_CANDIDATE(user_ext_port_info[om_idx].mirroring_tx_dest_port);
            }
        }
        else if( user_ext_port_info[om_idx].mirroring_rx_dest_port == mirror_entry->mirror_destination_port &&
                 om_idx+1 > mirror_entry->mirror_source_port)
        {
            /* Primary key the same: RX.
             */
            if(om_idx+1 < matched_src_ifindex)
            {
                UPDATE_CANDIDATE(user_ext_port_info[om_idx].mirroring_rx_dest_port);
            }
        }
        else if( user_ext_port_info[om_idx].mirroring_tx_dest_port > mirror_entry->mirror_destination_port  ||
                 user_ext_port_info[om_idx].mirroring_rx_dest_port > mirror_entry->mirror_destination_port   )
        {
            /* to get smaller primary key
             */
            if ((user_ext_port_info[om_idx].mirroring_rx_dest_port < user_ext_port_info[om_idx].mirroring_tx_dest_port && user_ext_port_info[om_idx].mirroring_rx_dest_port != 0) ||
                user_ext_port_info[om_idx].mirroring_tx_dest_port == 0)
            {
                if(user_ext_port_info[om_idx].mirroring_rx_dest_port < matched_dest_ifindex)
                {
                    UPDATE_CANDIDATE(user_ext_port_info[om_idx].mirroring_rx_dest_port);
                }
                else if(user_ext_port_info[om_idx].mirroring_rx_dest_port == matched_dest_ifindex)
                {
                    if(om_idx+1 < matched_src_ifindex)
                    {
                        UPDATE_CANDIDATE(user_ext_port_info[om_idx].mirroring_rx_dest_port);
                    }
                }
                else /* > */
                {
                    ;
                }
            }
            else if (user_ext_port_info[om_idx].mirroring_tx_dest_port == user_ext_port_info[om_idx].mirroring_rx_dest_port)
            {
                /* dest are the same for both TX and RX
                 */
                if(om_idx+1 < matched_src_ifindex)
                {
                    UPDATE_CANDIDATE(user_ext_port_info[om_idx].mirroring_tx_dest_port);
                }
            }
            else if ((user_ext_port_info[om_idx].mirroring_tx_dest_port < user_ext_port_info[om_idx].mirroring_rx_dest_port && user_ext_port_info[om_idx].mirroring_tx_dest_port != 0) ||
                     user_ext_port_info[om_idx].mirroring_rx_dest_port == 0)
            {
                if(user_ext_port_info[om_idx].mirroring_tx_dest_port < matched_dest_ifindex)
                {
                    UPDATE_CANDIDATE(user_ext_port_info[om_idx].mirroring_tx_dest_port);
                }
                else if(user_ext_port_info[om_idx].mirroring_tx_dest_port == matched_dest_ifindex)
                {
                    if(om_idx+1 < matched_src_ifindex)
                    {
                        UPDATE_CANDIDATE(user_ext_port_info[om_idx].mirroring_tx_dest_port);
                    }
                }
                else /* > */
                {
                    ;
                }
            }
        }
        else if( user_ext_port_info[om_idx].mirroring_tx_dest_port > mirror_entry->mirror_destination_port  &&
                 user_ext_port_info[om_idx].mirroring_rx_dest_port < mirror_entry->mirror_destination_port   )
        {
            if(user_ext_port_info[om_idx].mirroring_tx_dest_port < matched_dest_ifindex)
            {
                UPDATE_CANDIDATE(user_ext_port_info[om_idx].mirroring_tx_dest_port);
            }
            else if(user_ext_port_info[om_idx].mirroring_tx_dest_port == matched_dest_ifindex)
            {
                if(om_idx+1 < matched_src_ifindex)
                {
                    UPDATE_CANDIDATE(user_ext_port_info[om_idx].mirroring_tx_dest_port);
                }
            }
            else /* > */
            {
                ;
            }
        }
        else if( user_ext_port_info[om_idx].mirroring_tx_dest_port < mirror_entry->mirror_destination_port  &&
                 user_ext_port_info[om_idx].mirroring_rx_dest_port > mirror_entry->mirror_destination_port   )
        {
            if(user_ext_port_info[om_idx].mirroring_rx_dest_port < matched_dest_ifindex)
            {
                UPDATE_CANDIDATE(user_ext_port_info[om_idx].mirroring_rx_dest_port);
            }
            else if(user_ext_port_info[om_idx].mirroring_rx_dest_port == matched_dest_ifindex)
            {
                if(om_idx+1 < matched_src_ifindex)
                {
                    UPDATE_CANDIDATE(user_ext_port_info[om_idx].mirroring_rx_dest_port);
                }
            }
            else /* > */
            {
                ;
            }
        }
    }

    if(matched_om_idx == 0xffffffff)
    {
#if (SYS_CPNT_ALLOW_DUMMY_MIRRORING_DEST == TRUE)
        if (0 != system_info.dummy_mirroring_dest)
        {
            if (system_info.dummy_mirroring_dest > mirror_entry->mirror_destination_port)
            {
                mirror_entry->mirror_destination_port = system_info.dummy_mirroring_dest;
                mirror_entry->mirror_source_port = 0;
                mirror_entry->mirror_status = VAL_mirrorStatus_invalid;
                mirror_entry->mirror_type = VAL_mirrorType_both;

                SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
            }
        }
#endif
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );

    }

#if (SYS_CPNT_ALLOW_DUMMY_MIRRORING_DEST == TRUE)
    if (0 != system_info.dummy_mirroring_dest)
    {
        if ((system_info.dummy_mirroring_dest >  mirror_entry->mirror_destination_port) &&
            (system_info.dummy_mirroring_dest <= matched_dest_ifindex))
        {
            mirror_entry->mirror_destination_port = system_info.dummy_mirroring_dest;
            mirror_entry->mirror_source_port = 0;
            mirror_entry->mirror_status = VAL_mirrorStatus_invalid;
            mirror_entry->mirror_type = VAL_mirrorType_both;
        }
    }
#endif

    mirror_entry->mirror_destination_port = matched_dest_ifindex;
    mirror_entry->mirror_source_port = matched_src_ifindex;
    mirror_entry->mirror_status = VAL_mirrorStatus_valid;
    if(user_ext_port_info[matched_om_idx].mirroring_tx_dest_port == user_ext_port_info[matched_om_idx].mirroring_rx_dest_port)
    {
        mirror_entry->mirror_type = VAL_mirrorType_both;
    }
    else
    {
        if(user_ext_port_info[matched_om_idx].mirroring_tx_dest_port == matched_dest_ifindex)
            mirror_entry->mirror_type = VAL_mirrorType_tx;
        else
            mirror_entry->mirror_type = VAL_mirrorType_rx;

    }


    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
}/* End of SWCTRL_GetNextMirrorEntry () */

#else
BOOL_T SWCTRL_GetNextMirrorEntry(SWCTRL_MirrorEntry_T *mirror_entry)
{
    SWCTRL_MIRROR_MTP_T  mirror_mtp_entry   /*dst port is the primary index*/;
    UI32_T               index = 0,reason = 0,got_index=0;


    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (mirror_entry == 0)
    {
        EH_MGR_Handle_Exception (SYS_MODULE_SWCTRL,
                                 SWCTRL_NO_USE_FUNC_NO,
                                 EH_TYPE_MSG_NULL_POINTER,
                                 EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_CRIT); /*SWCTRL_ENO_NULL_POINTER*/
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    /*the input keys should be in reage of user port or 0*/
    if( mirror_entry->mirror_source_port != 0                &&
       !SWCTRL_IS_USER_PORT(mirror_entry->mirror_source_port) )
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    /*the input keys should be in reage of user port or 0*/
    if( mirror_entry->mirror_source_port != 0                &&
       !SWCTRL_IS_USER_PORT(mirror_entry->mirror_destination_port) )
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    /*first time get all entry*/
    if(mirror_entry->mirror_destination_port == 0 && mirror_entry->mirror_source_port == 0)
    {
        index = 0;
    }
    else
    {
        /*use specific "CLI get index" for get all entry*/
        for(index=0;index < SYS_ADPT_MAX_NBR_OF_MIRROR_PORT;index++)
        {
            SWCTRL_GetMirrorNodeIndex(mirror_entry->mirror_destination_port,index,&got_index,&reason);
            if(reason == 3)
            {
                /*got the index*/
                break;
            }
        }

        if(index >= SYS_ADPT_MAX_NBR_OF_MIRROR_PORT)
            SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if(!SWCTRL_GetNextPortFromMirrorNode( index,mirror_entry->mirror_source_port,&mirror_mtp_entry))
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );

    mirror_entry->mirror_destination_port = mirror_mtp_entry.dst_port;
    mirror_entry->mirror_source_port = mirror_mtp_entry.src_port;
    mirror_entry->mirror_status = VAL_mirrorStatus_valid;
    mirror_entry->mirror_type = mirror_mtp_entry.direction;

    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
}
#endif
/*------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetNextRunningMirrorEntry
 *------------------------------------------------------------------------
 * FUNCTION: This function will get the next running config mirror table entry info
 * INPUT   : mirror_entry->mirror_destination_port - mirror destination port
 *           mirror_entry->mirror_source_port      - mirror source port
 * OUTPUT  : mirror_entry                          - The mirror entry info
 * RETURN  : SYS_TYPE_Get_Running_Cfg_T
 * NOTE    : None
 *------------------------------------------------------------------------*/
SYS_TYPE_Get_Running_Cfg_T SWCTRL_GetNextRunningMirrorEntry(SWCTRL_MirrorEntry_T *mirror_entry)
{
    SWCTRL_USE_CSC_CHECK_OPER_MODE(SYS_TYPE_GET_RUNNING_CFG_FAIL);

#if (SYS_CPNT_ALLOW_DUMMY_MIRRORING_DEST == TRUE)
    while(SWCTRL_GetNextMirrorEntry(mirror_entry))
    {
        if (0 == mirror_entry->mirror_source_port)
        {
            continue;
        }
        SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_SUCCESS )
    }
    SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_NO_CHANGE )
#else
    if (SWCTRL_GetNextMirrorEntry(mirror_entry))
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_SUCCESS )
    }
    else
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_NO_CHANGE )
}
#endif
}

/*------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetMirrorType
 *------------------------------------------------------------------------
 * FUNCTION: This function will Set the mirror type
 * INPUT   : ifindex_src   -- which ifindex to mirror
 *          ifindex_dest  -- which ifindex mirrors the received/transmitted packets
 *          port_autonegotiation           - VAL_mirrorType_rx
 *                                           VAL_mirrorType_tx
 *                                           VAL_mirrorType_both
 * OUTPUT  : None
 * RETURN  : TRUE/FALSE
 * NOTE    : ES3626A MIB/mirrorMgt 1
 *------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetMirrorType(UI32_T ifindex_src, UI32_T ifindex_dest, UI32_T mirror_type)
{
    BOOL_T retval;
    SYS_TYPE_Uport_T from_port, rx_to_port, tx_to_port;
    SWCTRL_MIRROR_MTP_T mirror_mtp_info;
#if (SYS_CPNT_RSPAN == TRUE)
    RSPAN_OM_SessionEntry_T is_rspan_entry_valid;
    memset(&is_rspan_entry_valid, 0, sizeof(RSPAN_OM_SessionEntry_T) );
    is_rspan_entry_valid.session_id = RSPAN_MGR_MAX_SESSION_NUM + 1 ;
#endif /* End of #if (SYS_CPNT_RSPAN == TRUE) */

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if( mirror_type != VAL_mirrorType_rx &&
        mirror_type != VAL_mirrorType_tx &&
        mirror_type != VAL_mirrorType_both )
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_INVALID_PARAMETER,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "mirror type"); /*SWCTRL_ENO_INVALID_MIRROR_TYPE*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

#if (SYS_CPNT_ALLOW_DUMMY_MIRRORING_DEST == TRUE)
    if (0 == ifindex_src)
    {
        UI32_T om_idx;

        /* Only want set dummy destination.
         */
        if (FALSE == SWCTRL_DummyMirroringDestValidationCheck(ifindex_dest))
        {
            SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
        }

        /* not support multiple analyzer port
         */
        for(om_idx = 0; om_idx <= SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK*SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT - 1; om_idx++)
        {
            if(!SWCTRL_IS_EXIST(om_idx+1))
                continue;

            if ((user_ext_port_info[om_idx].mirroring_tx_dest_port != 0)  ||
                (user_ext_port_info[om_idx].mirroring_rx_dest_port != 0)  )
            {
                /* even the same dummy eye is not allowable, because valid eye exist.
                 */
                EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                          SWCTRL_NO_USE_FUNC_NO,
                                          EH_TYPE_MSG_MIRROR_NOT_SUPPORT,
                                          SYSLOG_LEVEL_ERR,
                                          "multiple Analyzer Ports");  /*SWCTRL_ENO_MONITERED_PORT_SHOULD_NOT_BE_AN_ANALYZER_PORT*/

                SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
            }
        }
    }

    /* replace or first time to set
     */
    system_info.dummy_mirroring_dest = ifindex_dest;
    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );

#endif

    if(!SWCTRL_MirroringValidationCheck(ifindex_src, ifindex_dest ,VAL_mirrorStatus_valid))
    {
        /* Error code in SWCTRL_MirroringValidationCheck(); */
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    /* If this port-pair not exists, can't allow to set mirror type */
    if (   user_ext_port_info[ifindex_src-1].mirroring_tx_dest_port != ifindex_dest
        && user_ext_port_info[ifindex_src-1].mirroring_rx_dest_port != ifindex_dest
       )
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

#if (SYS_CPNT_RSPAN == TRUE)

#if (SYS_CPNT_SYSCTRL_XOR == TRUE)
    SYSCTRL_XOR_MGR_GetSemaphore();
#endif /*if (SYS_CPNT_SYSCTRL_XOR == TRUE)*/

    /* to indicate this is dst port. */
    is_rspan_entry_valid.dst = ifindex_dest ;

    if ( ! RSPAN_MGR_SettingValidation ( &is_rspan_entry_valid, ifindex_dest ) )
    {
#if (SYS_CPNT_SYSCTRL_XOR == TRUE)
    SYSCTRL_XOR_MGR_ReleaseSemaphore();
#endif /*if (SYS_CPNT_SYSCTRL_XOR == TRUE)*/
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    /* reset dst port. */
    is_rspan_entry_valid.dst = 0 ;

    /* to indicate this is src port. */
    if ( mirror_type == VAL_mirrorType_tx || mirror_type == VAL_mirrorType_both )
        is_rspan_entry_valid.src_tx[0] = ifindex_src ;
    if ( mirror_type == VAL_mirrorType_rx || mirror_type == VAL_mirrorType_both )
        is_rspan_entry_valid.src_rx[0] = ifindex_src ;

    if ( ! RSPAN_MGR_SettingValidation ( &is_rspan_entry_valid, ifindex_src ) )
    {
#if (SYS_CPNT_SYSCTRL_XOR == TRUE)
    SYSCTRL_XOR_MGR_ReleaseSemaphore();
#endif /*if (SYS_CPNT_SYSCTRL_XOR == TRUE)*/
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    /* Put the newest data in the structure. */
    memset(is_rspan_entry_valid.src_tx, 0, sizeof(is_rspan_entry_valid.src_tx));
    memset(is_rspan_entry_valid.src_rx, 0, sizeof(is_rspan_entry_valid.src_rx));

    if ( mirror_type == VAL_mirrorType_tx || mirror_type == VAL_mirrorType_both )
        is_rspan_entry_valid.src_tx[(UI8_T)((ifindex_src-1)/8)] |=  ((0x01) << (7 - ((ifindex_src-1)%8)));
    if ( mirror_type == VAL_mirrorType_rx || mirror_type == VAL_mirrorType_both )
        is_rspan_entry_valid.src_rx[(UI8_T)((ifindex_src-1)/8)] |=  ((0x01) << (7 - ((ifindex_src-1)%8)));

    is_rspan_entry_valid.dst = ifindex_dest ;


    if ( RSPAN_MGR_SetRspanSessionEntry ( &is_rspan_entry_valid ) != TRUE )
    {
#if (SYS_CPNT_SYSCTRL_XOR == TRUE)
    SYSCTRL_XOR_MGR_ReleaseSemaphore();
#endif /*if (SYS_CPNT_SYSCTRL_XOR == TRUE)*/
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

#if (SYS_CPNT_SYSCTRL_XOR == TRUE)
    SYSCTRL_XOR_MGR_ReleaseSemaphore();
#endif /*if (SYS_CPNT_SYSCTRL_XOR == TRUE)*/

#endif /* End of #if (SYS_CPNT_RSPAN == TRUE) */

    /*action*/
    memset(&from_port,  0, sizeof (SYS_TYPE_Uport_T));
    memset(&tx_to_port, 0, sizeof (SYS_TYPE_Uport_T));
    memset(&rx_to_port, 0, sizeof (SYS_TYPE_Uport_T));

    from_port.unit = SWCTRL_IFINDEX_TO_UNIT(ifindex_src);
    from_port.port = SWCTRL_IFINDEX_TO_PORT(ifindex_src);

    switch(mirror_type)
    {
    /*input specifies the rx dest port*/
    case VAL_mirrorType_rx:
        /*keep the original tx dest setting*/
        tx_to_port.unit = 0;
        tx_to_port.port = 0;
        /*remove rx argument base on input*/
        rx_to_port.unit = SWCTRL_IFINDEX_TO_UNIT(ifindex_dest);
        rx_to_port.port = SWCTRL_IFINDEX_TO_PORT(ifindex_dest);
        break;

    /*if input specifies the tx dest port*/
    case VAL_mirrorType_tx:
        /*specify the tx argument base on input*/
        tx_to_port.unit = SWCTRL_IFINDEX_TO_UNIT(ifindex_dest);
        tx_to_port.port = SWCTRL_IFINDEX_TO_PORT(ifindex_dest);
        /*remove tx dest setting*/
        rx_to_port.unit = 0;
        rx_to_port.port = 0;
        break;

    case VAL_mirrorType_both:
        /*specify bothe the tx and rx arguments base on input*/
        tx_to_port.unit = SWCTRL_IFINDEX_TO_UNIT(ifindex_dest);
        tx_to_port.port = SWCTRL_IFINDEX_TO_PORT(ifindex_dest);
        rx_to_port.unit = SWCTRL_IFINDEX_TO_UNIT(ifindex_dest);
        rx_to_port.port = SWCTRL_IFINDEX_TO_PORT(ifindex_dest);
        break;
    }

    SWCTRL_ENTER_XOR_CRITICAL_SECTION(&retval);

    /* The ifindex can be set to mirror. */
    SWCTRL_XOR_CHECK(
        SYSCTRL_XOR_MGR_PermitBeingSetToMirror(ifindex_src, ifindex_dest));

    SWCTRL_LOCK();

    if((retval = SWDRV_SetPortMirroring(from_port, rx_to_port, tx_to_port)) == TRUE)
    {
        switch(mirror_type)
        {
        case VAL_mirrorType_tx:
            user_ext_port_info[ifindex_src-1].mirroring_tx_dest_port = ifindex_dest;
            user_ext_port_info[ifindex_src-1].mirroring_rx_dest_port = 0;
            break;

        case VAL_mirrorType_rx:
            user_ext_port_info[ifindex_src-1].mirroring_tx_dest_port = 0;
            user_ext_port_info[ifindex_src-1].mirroring_rx_dest_port = ifindex_dest;
            break;

        case VAL_mirrorType_both:
            user_ext_port_info[ifindex_src-1].mirroring_tx_dest_port = ifindex_dest;
            user_ext_port_info[ifindex_src-1].mirroring_rx_dest_port = ifindex_dest;
            break;
        }
    }

    SWCTRL_UNLOCK();

    SWCTRL_LEAVE_XOR_CRITICAL_SECTION();

    if(retval)
    {
        SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME();

        mirror_mtp_info.dst_port = ifindex_dest;
        mirror_mtp_info.src_port = ifindex_src;
        mirror_mtp_info.direction = mirror_type;
        /*if change the type need del the list first then restore the entry */
        if(!SWCTRL_DelPortFromMirrorList(&mirror_mtp_info))
        {
            SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
        }


        if(!SWCTRL_SetPortToMirrorList(&mirror_mtp_info))
        {

            SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
        }

        SWCTRL_RETURN_AND_RELEASE_CSC(TRUE );
    }
    else
    {
        /* Error code was set in SWDRV_SetPortMirroring(); */
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
}/*End of SWCTRL_SetMirrorType () */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetMirrorStatus
 * -------------------------------------------------------------------------
 * FUNCTION: This function will create/destroy the mirroring function
 * INPUT   : ifindex_src   -- which ifindex to mirror
 *           ifindex_dext  -- which ifindex mirrors the received/transmitted packets
 * OUTPUT  : mirror_status -- VAL_mirrorStatus_valid / VAL_mirrorStatus_invalid
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : 1. ES3626A MIB/mirrorMgt 1
 *           2. No matter support SYS_CPNT_ALLOW_DUMMY_MIRRORING_DEST or not
 *              source == 0 is not valid.
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetMirrorStatus(UI32_T ifindex_src , UI32_T ifindex_dest, UI32_T mirror_status)
{
    UI32_T om_idx;
    SYS_TYPE_Uport_T src_unit_port, dest_unit_port;
    SWCTRL_MIRROR_MTP_T mirror_mtp_info;
#if (SYS_CPNT_RSPAN == TRUE)
    UI8_T   session_cnt = 0 ;
#endif /*#if (SYS_CPNT_RSPAN == TRUE)*/

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    /*status: I. should be VAL_mirrorStatus_valid, or
             II. should be VAL_mirrorStatus_invalid
     */
    if (mirror_status != VAL_mirrorStatus_valid   &&
        mirror_status != VAL_mirrorStatus_invalid )
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_INVALID_PARAMETER,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "mirror status");   /*SWCTRL_ENO_INVALID_MIRROR_STATUS*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

#if (SYS_CPNT_ALLOW_DUMMY_MIRRORING_DEST == TRUE)
    if (0 == ifindex_src)
    {
        if (VAL_mirrorStatus_invalid == mirror_status)
        {
            /* Only want set dummy destination.
            */
            if (FALSE == SWCTRL_DummyMirroringDestValidationCheck(ifindex_dest))
            {
                SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
            }
            src_unit_port.unit = 0;
            src_unit_port.port = 0;
        }
        else
        {
            SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
        }
    }
    else
    {
        if(!SWCTRL_MirroringValidationCheck(ifindex_src, ifindex_dest, mirror_status))
        {
            /* Error code in SWCTRL_MirroringValidationCheck(); */
            SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
        }
        src_unit_port.unit = SWCTRL_IFINDEX_TO_UNIT(ifindex_src);
        src_unit_port.port = SWCTRL_IFINDEX_TO_PORT(ifindex_src);
    }

#else
    if(!SWCTRL_MirroringValidationCheck(ifindex_src, ifindex_dest, mirror_status))
    {
        /* Error code in SWCTRL_MirroringValidationCheck(); */
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    src_unit_port.unit = SWCTRL_IFINDEX_TO_UNIT(ifindex_src);
    src_unit_port.port = SWCTRL_IFINDEX_TO_PORT(ifindex_src);
#endif

    dest_unit_port.unit = SWCTRL_IFINDEX_TO_UNIT(ifindex_dest);
    dest_unit_port.port = SWCTRL_IFINDEX_TO_PORT(ifindex_dest);

    mirror_mtp_info.dst_port = ifindex_dest;
    mirror_mtp_info.src_port = ifindex_src;

    switch (mirror_status)
    {
    case VAL_mirrorStatus_valid:

        /* If the dest port (MTP) exist in database of specified source port, return true and don't need set again. */
        if( user_ext_port_info[ifindex_src-1].mirroring_tx_dest_port == ifindex_dest ||
            user_ext_port_info[ifindex_src-1].mirroring_rx_dest_port == ifindex_dest )
        {
            /*This port pair has existed, no matter the type is both, tx, or rx.
             */
            SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
        }
        /* if no dest port exist in database, allow to set new dest port */
        else if (user_ext_port_info[ifindex_src-1].mirroring_tx_dest_port == 0 &&
                    user_ext_port_info[ifindex_src-1].mirroring_rx_dest_port == 0 )
        {
            BOOL_T ret_val = TRUE;
            SYS_TYPE_Uport_T dest_tx_unit_port;

            SWCTRL_ENTER_XOR_CRITICAL_SECTION(&ret_val);

            SWCTRL_XOR_CHECK(
                SYSCTRL_XOR_MGR_PermitBeingSetToMirror(ifindex_src, ifindex_dest));

            SWCTRL_LOCK();

            /* if only set mirror status, it will set mirror type as 'rx' in default.
             */
            dest_tx_unit_port.unit = 0;
            dest_tx_unit_port.port = 0;

            if( !SWDRV_SetPortMirroring(src_unit_port, dest_unit_port, dest_tx_unit_port) )
            {
                /*Set driver fail
                 */
                SWCTRL_UNLOCK();

                /* Error code in SWDRV_SetPortMirroring(); */
                SWCTRL_BREAK_XOR_CRITICAL_SECTION(FALSE);
            }
            else
            {
                /*Set driver successfully, enable mirroring function
                 *Note: force to enable this function, checking current
                 *      setting may be necessary for performance concern.
                 */
                if(!SWDRV_EnablePortMirroring(src_unit_port))
                {
                    SWCTRL_UNLOCK();

                    /* Error code in SWDRV_EnablePortMirroring(); */
                    SWCTRL_BREAK_XOR_CRITICAL_SECTION(FALSE);
                }
                SWCTRL_OM_SetMirrorConfigMode(SWCTRL_OM_PORT_MIRROR_MODE, TRUE);
                SWCTRL_SetMTPTable(ifindex_dest,  mirror_status);

                /*If set driver successfully, save port mirror to swctrl database as 'rx' type
                 */
                user_ext_port_info[ifindex_src-1].mirroring_tx_dest_port = 0;
                user_ext_port_info[ifindex_src-1].mirroring_rx_dest_port = ifindex_dest;


                mirror_mtp_info.direction = VAL_mirrorType_rx;


                /*store the mirror port infor in list for CLI show*/
                if(!SWCTRL_SetPortToMirrorList(&mirror_mtp_info))
                {
                    SWDRV_DeletePortMirroring(src_unit_port,dest_unit_port);
                    SWCTRL_UNLOCK();
                    SWCTRL_BREAK_XOR_CRITICAL_SECTION(FALSE);
                }

                SWCTRL_UNLOCK();
                SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME();
                SWCTRL_BREAK_XOR_CRITICAL_SECTION(TRUE);
            }

            SWCTRL_UNLOCK();
            SWCTRL_LEAVE_XOR_CRITICAL_SECTION();
            SWCTRL_RETURN_AND_RELEASE_CSC(ret_val);
        }
        /* if input dest port is not exist in database and database already have dest port,
             do not set this dest port and return */
        else if ( (user_ext_port_info[ifindex_src-1].mirroring_tx_dest_port != ifindex_dest ||
             user_ext_port_info[ifindex_src-1].mirroring_rx_dest_port != ifindex_dest) &&
                     (user_ext_port_info[ifindex_src-1].mirroring_tx_dest_port != 0 ||
                      user_ext_port_info[ifindex_src-1].mirroring_rx_dest_port != 0 ))

        {

            EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                      SWCTRL_NO_USE_FUNC_NO,
                                      EH_TYPE_MSG_INVALID_PARAMETER,
                                      EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                      "this source port have been set to another dest port :");

            SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
        }

        break;

    case VAL_mirrorStatus_invalid:
#if (SYS_CPNT_ALLOW_DUMMY_MIRRORING_DEST == TRUE)
        if (0 == ifindex_src)
        {
            if (ifindex_dest == system_info.dummy_mirroring_dest)
            {
                system_info.dummy_mirroring_dest = 0;
            }
            SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
        }
#endif

        if( user_ext_port_info[ifindex_src-1].mirroring_tx_dest_port != ifindex_dest &&
            user_ext_port_info[ifindex_src-1].mirroring_rx_dest_port != ifindex_dest )
        {
            /* If the input dest port (MTP) is not exist in database,
                 don't need to take any remove operation.
             */
            SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
        }
        else
#if 1
        {

            /* It will disable port mirror on specified port with 'both' type
              */
            SWCTRL_LOCK();
            if(!SWDRV_DeletePortMirroring(src_unit_port,dest_unit_port))
            {
                SWCTRL_UNLOCK();
                SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
            }
            else
            {

                SWCTRL_SetMTPTable(ifindex_dest,  mirror_status);

                /*del the mirror port infor in list for CLI show*/
                if(!SWCTRL_DelPortFromMirrorList(&mirror_mtp_info))
                {

                    SWDRV_EnablePortMirroring(src_unit_port);
                    SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
                }
                /*Set driver successfully, maintain database
                    Both tx and rx destination ports were destroied
                 */
                user_ext_port_info[ifindex_src-1].mirroring_tx_dest_port = 0;
                user_ext_port_info[ifindex_src-1].mirroring_rx_dest_port = 0;

                SWCTRL_UNLOCK();
                SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME();
            }

        }
#else
{
            SYS_TYPE_Uport_T tx_dest_unit_port, rx_dest_unit_port;

            /* init with input port ID */
            tx_dest_unit_port.unit = dest_unit_port.unit;
            tx_dest_unit_port.port = dest_unit_port.port;

            rx_dest_unit_port.unit = dest_unit_port.unit;
            rx_dest_unit_port.port = dest_unit_port.port;

            /* handle the tx MTP */
            if( user_ext_port_info[ifindex_src-1].mirroring_tx_dest_port == ifindex_dest ||
                user_ext_port_info[ifindex_src-1].mirroring_tx_dest_port == 0            )
            {
               /* 1) if input port is exist in database
                 * 2) if port which in database is empty
                 * remove the port
                 */
                tx_dest_unit_port.unit = 0;
                tx_dest_unit_port.port = 0;
            }
            else
            {
               /* if don't need to remove the port, use original port to set again.
                */
                tx_dest_unit_port.unit = SWCTRL_IFINDEX_TO_UNIT(user_ext_port_info[ifindex_src-1].mirroring_tx_dest_port);
                tx_dest_unit_port.port = SWCTRL_IFINDEX_TO_PORT(user_ext_port_info[ifindex_src-1].mirroring_tx_dest_port);
            }

            /* handle the rx MTP */
            if( user_ext_port_info[ifindex_src-1].mirroring_rx_dest_port == ifindex_dest ||
                user_ext_port_info[ifindex_src-1].mirroring_rx_dest_port == 0            )
            {
                /* 1) rx is what caller want to destory
                 * 2) rx originally doesn't exist
                 */
                rx_dest_unit_port.unit = 0;
                rx_dest_unit_port.port = 0;
            }
            else
            {
                /* rx is not caller want to destory
                 */
                rx_dest_unit_port.unit = SWCTRL_IFINDEX_TO_UNIT(user_ext_port_info[ifindex_src-1].mirroring_rx_dest_port);
                rx_dest_unit_port.port = SWCTRL_IFINDEX_TO_PORT(user_ext_port_info[ifindex_src-1].mirroring_rx_dest_port);
            }

            /* remove dest port with 'both' type */
            if((tx_dest_unit_port.unit == 0 && tx_dest_unit_port.port == 0) &&
               (rx_dest_unit_port.unit == 0 && rx_dest_unit_port.port == 0) )
            {
                /* If there is no destination port for both tx and rx, then
                 * the source prot will become unused.
                 */
                SWCTRL_LOCK();
                if(!SWDRV_DeletePortMirroring(src_unit_port,dest_unit_port))
                {
                    /* Set driver fail
                     */
                    SWCTRL_UNLOCK();
                    /* Error code in SWDRV_DeletePortMirroring(); */
                    SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
                }
                else
                {
                    /*Set driver successfully, maintain database
                     */
                    /* Both tx and rx destination ports were destroied
                     */
                    user_ext_port_info[ifindex_src-1].mirroring_tx_dest_port = 0;
                    user_ext_port_info[ifindex_src-1].mirroring_rx_dest_port = 0;

                    SWCTRL_UNLOCK();
                    SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME();
                }
            }
            else
            {
                SWCTRL_LOCK();
                if( !SWDRV_SetPortMirroring(src_unit_port, tx_dest_unit_port, rx_dest_unit_port) )
                {
                    /* Set driver fail
                     */
                    SWCTRL_UNLOCK();
                    /* Error code in SWDRV_SetPortMirroring(); */
                    SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
                }
                else
                {
                    /*Set driver successfully, maintain database
                     */
                    /* I. tx dest. was destroied successfully
                     */
                    if( tx_dest_unit_port.unit == 0 && tx_dest_unit_port.port == 0)
                        user_ext_port_info[ifindex_src-1].mirroring_tx_dest_port = 0;

                    /* II. rx dest. was destroied successfully
                     */
                    if( rx_dest_unit_port.unit == 0 && rx_dest_unit_port.port == 0)
                        user_ext_port_info[ifindex_src-1].mirroring_rx_dest_port = 0;

                    SWCTRL_UNLOCK();
                    SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME();
                }
            }
        }
#endif

#if (SYS_CPNT_RSPAN == TRUE)
        /* Delete Local Port Monitor from RSPAN OM. */
{
        RSPAN_OM_SessionEntry_T     rspan_entry ;

        memset(&rspan_entry, 0, sizeof(RSPAN_OM_SessionEntry_T) );

        rspan_entry.session_id = RSPAN_MGR_MAX_SESSION_NUM + 1 ;
        rspan_entry.src_tx[0] = ifindex_src ;
        rspan_entry.src_rx[0] = ifindex_src ;
        rspan_entry.dst = ifindex_dest ;

        RSPAN_MGR_DeleteRspanSessionEntry( &rspan_entry ) ;
}
#endif /*end of #if (SYS_CPNT_RSPAN == TRUE)*/

        /* Disable the mirroring function while no any mirroring entry in database
         */
        for(om_idx = 0; om_idx <=SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK*SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT-1; om_idx++)
        {
            if(!SWCTRL_IS_EXIST(om_idx+1))
            {
                continue;
            }

            /* Find some mirroring record
             */
            if( (user_ext_port_info[om_idx].mirroring_tx_dest_port != 0) ||
                (user_ext_port_info[om_idx].mirroring_rx_dest_port != 0) )
            {
                SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
            }
        }

        /* No mirroring record was found
         */
#if (SYS_CPNT_RSPAN == TRUE)
        /* Becasue RSPAN is added, disable mirror needs to check session counter. By Tien. 08/04/2007 */
        RSPAN_MGR_GetSessionEntryCounter(&session_cnt);
        if ( ! session_cnt )
            SWDRV_DisablePortMirroring(src_unit_port);
#else
        SWDRV_DisablePortMirroring(src_unit_port);
        SWCTRL_OM_SetMirrorConfigMode(SWCTRL_OM_PORT_MIRROR_MODE, FALSE);
#endif /*end of #if (SYS_CPNT_RSPAN == TRUE)*/

#if (SYS_CPNT_ALLOW_DUMMY_MIRRORING_DEST == TRUE)
        /* becasuse this feature only support only when one allowable mirroring destination
         * if no any entry, remove dummy destination.
         */
        system_info.dummy_mirroring_dest = 0;
#endif

        break;
    }

    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
} /* End of SWCTRL_SetMirrorStatus() */

#if (SYS_CPNT_VLAN_MIRROR == TRUE)
/*------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetVlanMirrorEntry
 *------------------------------------------------------------------------
 * FUNCTION: This function will get the vlan mirror table entry info
 * INPUT   : vlan_mirror_entry->mirror_dest_port        - mirror destination port
 *           vlan_mirror_entry->mirror_source_vlan      - mirror source vlan id
 * OUTPUT  : vlan_mirror_entry                          - The vlan mirror entry info
 * RETURN  : TRUE/FALSE
 * NOTE    : The input keys (ifindex & vid) will get current vlan entry.
 *           if specifies a mirror_dest_port = 0 , so return system dest port
 *------------------------------------------------------------------------*/
BOOL_T SWCTRL_GetVlanMirrorEntry(SWCTRL_VlanMirrorEntry_T *vlan_mirror_entry)
{
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (vlan_mirror_entry == 0)
    {
        EH_MGR_Handle_Exception (SYS_MODULE_SWCTRL,
                                 SWCTRL_NO_USE_FUNC_NO,
                                 EH_TYPE_MSG_NULL_POINTER,
                                 EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_CRIT); /*SWCTRL_ENO_NULL_POINTER*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    /* should not be trunk */
    if (SWCTRL_IS_TRUNK (vlan_mirror_entry->mirror_dest_port))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_TRUNK_CNFG_ERR,
                                  SYSLOG_LEVEL_INFO,
                                  "it doesn't support Vlan Mirroring");  /*SWCTRL_ENO_NOT_TRUNK*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    /* dest. port should not be trunk member*/
    if (SWCTRL_IS_TRUNK_MEMBER (vlan_mirror_entry->mirror_dest_port))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_MIRROR_NOT_SUPPORT,
                                  SYSLOG_LEVEL_INFO,
                                  "Analyzer Port for Trunk member");

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    /* get source vlan is mirrored entry */
    if ((vlan_mirror_entry->mirror_source_vlan == 0)                     ||
        (vlan_mirror_entry->mirror_source_vlan >  SYS_ADPT_MAX_VLAN_ID))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_FAILED_TO_GET,
                                  SYSLOG_LEVEL_INFO,
                                  "The source VLAN mirror incorrect");

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    /* check this vlan mirror status */
    if (SWCTRL_IS_VLAN_MIRROR(vlan_mirror_entry->mirror_source_vlan) != 0x80)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    /* a destination port shall be match */
    if ( (vlan_mirror_entry->mirror_dest_port!=0) &&
         (FALSE == SWCTRL_IS_VLAN_DEST_PORT(vlan_mirror_entry->mirror_dest_port)))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_FAILED_TO_GET,
                                  SYSLOG_LEVEL_INFO,
                                  "The source VLAN mirror is incorrect");

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
    else if (vlan_mirror_entry->mirror_dest_port == 0)
    {
        /* if not specifies a destination port, so return current system port */
        vlan_mirror_entry->mirror_dest_port   = sys_vlan_mirror_info.mirror_dest_port;
    }

    vlan_mirror_entry->mirror_vlan_status = VAL_vlanMirrorStatus_valid;
    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );

}/* End of SWCTRL_GetVlanMirrorEntry() */

/*------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetNextVlanMirrorEntry
 *------------------------------------------------------------------------
 * FUNCTION: This function will get the next vlan mirror table entry info
 * INPUT   : vlan_mirror_entry->mirror_dest_port        - mirror destination port
 *           vlan_mirror_entry->mirror_source_vlan      - mirror source vlan id
 * OUTPUT  : vlan_mirror_entry                          - The vlan mirror entry info
 * RETURN  : TRUE/FALSE
 * NOTE    : The input key shall be contain vlan id and destination port, however
 *           the destination port can be specifies to 0, because we can get
 *           system destination port currently
 *------------------------------------------------------------------------*/
BOOL_T SWCTRL_GetNextVlanMirrorEntry(SWCTRL_VlanMirrorEntry_T *vlan_mirror_entry)
{
    UI32_T om_vidx;
    BOOL_T is_found = FALSE;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (vlan_mirror_entry == 0)
    {
        EH_MGR_Handle_Exception (SYS_MODULE_SWCTRL,
                                 SWCTRL_NO_USE_FUNC_NO,
                                 EH_TYPE_MSG_NULL_POINTER,
                                 EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_CRIT); /*SWCTRL_ENO_NULL_POINTER*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    /* should not be trunk */
    if (SWCTRL_IS_TRUNK (vlan_mirror_entry->mirror_dest_port))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_TRUNK_CNFG_ERR,
                                  SYSLOG_LEVEL_INFO,
                                  "it doesn't support Vlan Mirroring");  /*SWCTRL_ENO_NOT_TRUNK*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    /* dest. port should not be trunk member*/
    if (SWCTRL_IS_TRUNK_MEMBER (vlan_mirror_entry->mirror_dest_port))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_MIRROR_NOT_SUPPORT,
                                  SYSLOG_LEVEL_INFO,
                                  "Analyzer Port for Trunk member");

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    /* get destination port shall be correct */
    if ( (vlan_mirror_entry->mirror_dest_port!=0) &&
         (FALSE == SWCTRL_IS_VLAN_DEST_PORT(vlan_mirror_entry->mirror_dest_port)))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_FAILED_TO_GET,
                                  SYSLOG_LEVEL_INFO,
                                  "The source VLAN mirror is incorrect");

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    /* get vlan id in order to maximal range */
    if (vlan_mirror_entry->mirror_source_vlan > SYS_ADPT_MAX_VLAN_ID)
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_FAILED_TO_GET,
                                  SYSLOG_LEVEL_INFO,
                                  "The source VLAN-ID is incorrect");  /*SWCTRL_ENO_VLAN_FAILED_TO_GET*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    /* get next source vlan is mirrored entry */
    om_vidx = vlan_mirror_entry->mirror_source_vlan;
    for (++om_vidx; om_vidx<=SYS_ADPT_MAX_VLAN_ID; om_vidx++)
    {
        /* get source vlan is mirrored entry */
        if (SWCTRL_IS_VLAN_MIRROR(om_vidx) == 0x80)
        {
            vlan_mirror_entry->mirror_source_vlan = om_vidx;
            vlan_mirror_entry->mirror_dest_port   = sys_vlan_mirror_info.mirror_dest_port;
            is_found = TRUE;
            break;
        }
    }

    /* can't found the next vlan mirror entry */
    if (is_found == FALSE)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    vlan_mirror_entry->mirror_vlan_status = VAL_vlanMirrorStatus_valid;
    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );

}/* End of SWCTRL_GetNextVlanMirrorEntry()*/
/*------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_AddVlanMirror
 *------------------------------------------------------------------------
 * FUNCTION: This function will add the vlan mirror and desination port
 * INPUT   : vid           -- which vlan-id add to source mirrored table
 *           ifindex_dest  -- which ifindex-port received mirror packets
 * OUTPUT  : None
 * RETURN  : TRUE/FALSE
 * NOTE    : A destination port shall be consistent whenever vlan-id created
 *------------------------------------------------------------------------*/
BOOL_T SWCTRL_AddVlanMirror(UI32_T vid, UI32_T ifindex_dest)
{
    UI32_T  unit, port;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    /* check vlan mirror validation */
    if (FALSE == SWCTRL_VlanMirroringValidation(vid, ifindex_dest))
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    unit = SWCTRL_IFINDEX_TO_UNIT(ifindex_dest);
    port = SWCTRL_IFINDEX_TO_PORT(ifindex_dest);

    /* add a vlan mirror */
    SWCTRL_LOCK();

    if (FALSE == SWDRV_AddVlanMirror(unit, port, vid))
    {
        SWCTRL_UNLOCK();
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
    else
    {
        /* set driver successfully, maintain database */
        sys_vlan_mirror_info.mirror_dest_port = ifindex_dest;
        sys_vlan_mirror_info.mirror_source_vlans[SWCTRL_BYTE_IN_BITMAP(vid)]
                                                |=  SWCTRL_BIT_IN_BITMAP(vid);

        /* change system vlan mirror status */
        if (sys_vlan_mirror_info.system_vlan_mirror_status == SWCTRL_VLAN_MIRROR_DISABLE)
        {
            sys_vlan_mirror_info.system_vlan_mirror_status = SWCTRL_VLAN_MIRROR_ENABLE;
        }

        /* rule 1: set mirror config mode to om database */
        SWCTRL_OM_SetMirrorConfigMode(SWCTRL_OM_VLAN_MIRROR_MODE, TRUE);

        /* rule 2: set VLAN&MAC mirror destination port */
        SWCTRL_OM_SetCommonMirrorDestPort(ifindex_dest);

        SWCTRL_UNLOCK();
    }

    SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME();
    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
}

/*------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_DeleteVlanMirror
 *------------------------------------------------------------------------
 * FUNCTION: This function will delete the vlan mirror and destination port
 * INPUT   : vid           -- which vlan-id remove from source mirrored table
 *           ifindex_dest  -- which ifindex-port received mirror packets
 * OUTPUT  : None
 * RETURN  : TRUE/FALSE
 * NOTE    : A destination port shall be removed when source vlan mirror has empty
 *------------------------------------------------------------------------*/
BOOL_T SWCTRL_DeleteVlanMirror(UI32_T vid, UI32_T ifindex_dest)
{
    UI32_T  unit, port;
    UI32_T  om_vidx, vidx_cnt = 0, conf_mode;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    /* check vlan mirror validation */
    if (FALSE == SWCTRL_VlanMirroringValidation(vid, ifindex_dest))
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    unit = SWCTRL_IFINDEX_TO_UNIT(ifindex_dest);
    port = SWCTRL_IFINDEX_TO_PORT(ifindex_dest);

    /* delete a vlan mirror */
    SWCTRL_LOCK();

    if (FALSE == SWDRV_DeleteVlanMirror(unit, port, vid))
    {
        SWCTRL_UNLOCK();
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
    else
    {
        /* set driver successfully, maintain database */
        sys_vlan_mirror_info.mirror_dest_port = ifindex_dest;
        sys_vlan_mirror_info.mirror_source_vlans[SWCTRL_BYTE_IN_BITMAP(vid)]
                                                 &= ~(SWCTRL_BIT_IN_BITMAP(vid));

        /* calculate the rest of vlan mirror entries */
        for (om_vidx=1; om_vidx<=SYS_ADPT_MAX_VLAN_ID; om_vidx++)
        {
            if (SWCTRL_IS_VLAN_MIRROR(om_vidx)== 0x80)
            {
                vidx_cnt++;
            }
        }

        /* clear up dest. port while vid table none exist */
        if (vidx_cnt == 0)
        {
            sys_vlan_mirror_info.mirror_dest_port = 0;
            sys_vlan_mirror_info.system_vlan_mirror_status = SWCTRL_VLAN_MIRROR_DISABLE;

            /*  rule 1: set mirror config mode to om database */
            SWCTRL_OM_SetMirrorConfigMode(SWCTRL_OM_VLAN_MIRROR_MODE, FALSE);

            /* rule 2: if vlan and mac mode are disabled, clear the VLAN&MAC destination port */
            SWCTRL_OM_GetMirrorConfigMode(&conf_mode);

            /* only need to check VLAN and MAC mirror mode */
            if ( (conf_mode&(SWCTRL_OM_VLAN_MIRROR_MODE|SWCTRL_OM_MAC_MIRROR_MODE|SWCTRL_OM_ACL_MIRROR_MODE)) == SWCTRL_OM_NONE_MIRROR_MODE )
            {
                /* remove a VLAN&MAC destination port configuration to om database
                 * swdrv shall be take care this action already, means clear mirror port
                 * register.
                 */
                SWCTRL_OM_SetCommonMirrorDestPort(0);
            }
        }

        SWCTRL_UNLOCK();
    }

    SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME();
    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
}

/*------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_VlanMirroringValidation
 *------------------------------------------------------------------------
 * FUNCTION: This function will vlan mirror validation
 * INPUT   : vid           -- which vlan-id remove from source mirrored table
 *           ifindex_dest  -- which ifindex-port received mirror packets
 * OUTPUT  : None
 * RETURN  : TRUE/FALSE
 * NOTE    :
 *------------------------------------------------------------------------*/
static BOOL_T SWCTRL_VlanMirroringValidation(UI32_T vid, UI32_T ifindex_dest)
{
    /* rule 1: vlan id range and cluster VLAN */
    if ((vid == 0) || (vid > SYS_ADPT_MAX_VLAN_ID) ||
        (vid == SYS_DFLT_CLUSTER_DEFAULT_VLAN))
    {
        return FALSE;
    }

    /* check dest port
     */
    if (!SWCTRL_CommonMirrorDestPortValidation(ifindex_dest, SWCTRL_COMMON_MIRROR_TYPE_RX))
    {
        return FALSE;
    }

    return TRUE;
}/* End of SWCTRL_VlanMirroringValidation()*/

#endif /* end of #if (SYS_CPNT_VLAN_MIRROR == TRUE) */

#if (SYS_CPNT_MAC_BASED_MIRROR == TRUE)
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetMacMirrorEntry
 * -------------------------------------------------------------------------
 * PURPOSE  : This function will set the MAC based MIRROR entry
 * INPUT    : ifindex_dest       -- destnation port
 *            mac_address        -- MAC address
 * OUTPUT   : None
 * RETURN   : TRUE/FALSE    - TRUE if successful;FALSE if failed
 * NOTES    :
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetMacMirrorEntry(UI32_T ifindex_dest, UI8_T *mac_address)
{
    BOOL_T  retval = FALSE;
    UI32_T  unit, port, om_idx, mac_addr_cnt, conf_mode;
    SWCTRL_MacAddrMirrorEntry_T mac_addr_entry;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

     /* check rule validation */
    if (SWCTRL_MacAddrMirrorValidation(ifindex_dest, mac_address) == FALSE)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
    }

    memset(&mac_addr_entry , 0 , sizeof(SWCTRL_MacAddrMirrorEntry_T));
    mac_addr_entry.addr_entry_index = 0;
    memcpy(mac_addr_entry.mac_addr, mac_address, SYS_ADPT_MAC_ADDR_LEN);

    /* check this mac-address entry */
    if (SWCTRL_OM_GetExactMacAddrMirrorEntry(&mac_addr_entry) == TRUE)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC(TRUE);
    }

    /* get mac-address entries counter */
    SWCTRL_OM_GetMacAddrMirrorCnt(&mac_addr_cnt);

    /* check entries are occupied */
    if (mac_addr_cnt == SYS_ADPT_MAX_NBR_OF_MAC_BASED_MIRROR_ENTRY)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
    }

    SWCTRL_LOCK();
    /* set mac mirror address entry to database
     */

    /* save data to database
     * lower level marvell alleycat mac mirror workaround requires
     * to get dest port information from swctrl_om
     * Thus need to set OM before calling swdrv.
     */
    SWCTRL_OM_SetMacAddrMirrorEntry(mac_address, TRUE);
    SWCTRL_OM_SetMirrorConfigMode(SWCTRL_OM_MAC_MIRROR_MODE, TRUE);
    SWCTRL_OM_GetCommonMirrorDestPort(&om_idx);

    unit = SWCTRL_IFINDEX_TO_UNIT(ifindex_dest);
    port = SWCTRL_IFINDEX_TO_PORT(ifindex_dest);

    /* set first mirror destination port to system
     */
    if (om_idx == 0)
    {
        retval = SWDRV_SetDestPortForMacMirror(unit, port, TRUE);

        if(retval==FALSE)
        {
            /* set dest port for mac mirror failed
             * update database
             */
            SWCTRL_OM_SetMacAddrMirrorEntry(mac_address, FALSE);
            SWCTRL_OM_SetMirrorConfigMode(SWCTRL_OM_MAC_MIRROR_MODE, FALSE);
            SWCTRL_OM_SetCommonMirrorDestPort(0); /* 0 means mirror dest port is not set */
            SWCTRL_UNLOCK();
            SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
        }

        /* set mirror destination port
         */
        SWCTRL_OM_SetCommonMirrorDestPort(ifindex_dest);
    }
    else
    {
        /* dest port had been set up
         */
        retval = TRUE;
    }

    if(retval==TRUE)
    {
        retval = SWDRV_SetMacMirrorEntry(mac_address);
        if(retval==FALSE)
        {
            /* set mac for mirror failed
             * update database
             */
            SWCTRL_OM_SetMacAddrMirrorEntry(mac_address, FALSE);
            if(mac_addr_cnt==0)
            {
                SWCTRL_OM_SetMirrorConfigMode(SWCTRL_OM_MAC_MIRROR_MODE, FALSE);
            }
            SWCTRL_OM_GetMirrorConfigMode(&conf_mode);

            /* if both vlan and mac mirror modes are disabled
             * clear a destination port
             */
            if ( (conf_mode & (SWCTRL_OM_VLAN_MIRROR_MODE|SWCTRL_OM_MAC_MIRROR_MODE|SWCTRL_OM_ACL_MIRROR_MODE)) == SWCTRL_OM_NONE_MIRROR_MODE )
            {
                /* remove a destination port configuration
                 */
                SWCTRL_OM_SetCommonMirrorDestPort(0); /* 0 means no dest port */

                /* for mac-address mirror, we shall reset destination port
                 */
                SWDRV_SetDestPortForMacMirror(unit, port, FALSE);
            }

            SWCTRL_UNLOCK();
            SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
        }
    }

    SWCTRL_UNLOCK();

    if (retval == TRUE)
    {
        SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME();
    }

    SWCTRL_RETURN_AND_RELEASE_CSC(retval);
}/* End of SWCTRL_SetMacMirrorEntry() */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_DeleteMacMirrorEntry
 * -------------------------------------------------------------------------
 * PURPOSE  : This function will delete MAC based MIRROR entry
 * INPUT    : ifindex_dest       -- destnation port
 *            mac_address        -- MAC address
 * OUTPUT   : None
 * RETURN   : TRUE/FALSE    - TRUE if successful;FALSE if failed
 * NOTES    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_DeleteMacMirrorEntry(UI32_T ifindex_dest, UI8_T *mac_address)
{
    UI32_T  mac_addr_cnt, conf_mode;
    UI32_T  unit, port;
    BOOL_T  retval = FALSE;
    SWCTRL_MacAddrMirrorEntry_T mac_addr_entry;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    /* check rule validation */
    if (SWCTRL_MacAddrMirrorValidation(ifindex_dest, mac_address) == FALSE)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
    }

    memset(&mac_addr_entry , 0 , sizeof(SWCTRL_MacAddrMirrorEntry_T));

    /* since, we don't know this mac-address array index then keeping to 0 */
    mac_addr_entry.addr_entry_index = 0;
    memcpy(mac_addr_entry.mac_addr, mac_address, SYS_ADPT_MAC_ADDR_LEN);

    /* check this mac-address shall be exist */
    if (SWCTRL_OM_GetExactMacAddrMirrorEntry(&mac_addr_entry) == FALSE)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
    }

    SWCTRL_LOCK ();
    retval = SWDRV_DeleteMacMirrorEntry(mac_address);

    /* delete mac mirror address entry */
    if (retval == TRUE)
    {
        SWCTRL_OM_SetMacAddrMirrorEntry(mac_address, FALSE);
        SWCTRL_OM_GetMacAddrMirrorCnt(&mac_addr_cnt);

        /* rule 1: find remainder mac-addr entry */
        if (mac_addr_cnt == 0)
        {
            SWCTRL_OM_SetMirrorConfigMode(SWCTRL_OM_MAC_MIRROR_MODE, FALSE);
        }

        SWCTRL_OM_GetMirrorConfigMode(&conf_mode);

        /* rule 2: if both vlan and mac mirror modes are disabled
         * clear a destination port
         */
        if ( (conf_mode & (SWCTRL_OM_VLAN_MIRROR_MODE|SWCTRL_OM_MAC_MIRROR_MODE|SWCTRL_OM_ACL_MIRROR_MODE)) == SWCTRL_OM_NONE_MIRROR_MODE )
        {
            /* remove a destination port configuration */
            SWCTRL_OM_SetCommonMirrorDestPort(0); /* 0 means no dest port */

            /* for mac-address mirror, we shall reset destination port */
            unit = SWCTRL_IFINDEX_TO_UNIT(ifindex_dest);
            port = SWCTRL_IFINDEX_TO_PORT(ifindex_dest);

            retval = SWDRV_SetDestPortForMacMirror(unit, port, FALSE);
        }
    }

    SWCTRL_UNLOCK ();

    if (retval == TRUE)
    {
        SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME();
    }

    SWCTRL_RETURN_AND_RELEASE_CSC(retval);
} /* End of SWCTRL_DeleteMacMirrorEntry() */

/*------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_MacAddrMirrorValidation
 *------------------------------------------------------------------------
 * FUNCTION: This function will do mac address mirror validation
 * INPUT   : ifindex_dest  -- which ifindex-port received mirror packets
 *           mac_address   -- mac address
 * OUTPUT  : None
 * RETURN  : TRUE/FALSE
 * NOTE    :
 *------------------------------------------------------------------------*/
static BOOL_T SWCTRL_MacAddrMirrorValidation(UI32_T ifindex_dest, UI8_T *mac_address)
{
    /* rule 1: mac-address is NULL */
    if (mac_address == NULL)
    {
        return FALSE;
    }

    /* check dest port
     */
    if (!SWCTRL_CommonMirrorDestPortValidation(ifindex_dest, SWCTRL_COMMON_MIRROR_TYPE_RX))
    {
        return FALSE;
    }


    return TRUE;
}/* End of SWCTRL_MacAddrMirrorValidation() */

#endif /* End of #if (SYS_CPNT_MAC_BASED_MIRROR == TRUE) */

#if (SYS_CPNT_ACL_MIRROR == TRUE)
/*------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetAclMirrorDestPort
 *------------------------------------------------------------------------
 * FUNCTION: This function will setup dest port for  ACL-based mirror
 * INPUT   : ifindex_dest  -- which ifindex-port received mirror packets
 *           mirror_type   -- mirror type
 *                           (VAL_aclMirrorType_rx/VAL_aclMirrorType_tx/VAL_aclMirrorType_both)
 *           enable        -- TRUE to set, FALSE to remove
 * OUTPUT  : None
 * RETURN  : TRUE/FALSE
 * NOTE    :
 *------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetAclMirrorDestPort(UI32_T ifindex_dest, UI32_T mirror_type, BOOL_T enable)
{
    UI32_T unit, port;
    UI32_T conf_mode;
    BOOL_T retval = TRUE;
    SWCTRL_CommonMirrorType_T common_mirror_type;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    switch(mirror_type)
    {
        case VAL_aclMirrorType_rx:
            common_mirror_type = SWCTRL_COMMON_MIRROR_TYPE_RX;
            break;
        case VAL_aclMirrorType_tx:
            common_mirror_type = SWCTRL_COMMON_MIRROR_TYPE_TX;
            break;
        case VAL_aclMirrorType_both:
            common_mirror_type = SWCTRL_COMMON_MIRROR_TYPE_BOTH;
            break;
        default:
            return FALSE;
    }

    if (!SWCTRL_CommonMirrorDestPortValidation(ifindex_dest, common_mirror_type))
    {
        SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
    }

    SWCTRL_LOCK();

    if (enable)
    {
        unit = SWCTRL_IFINDEX_TO_UNIT(ifindex_dest);
        port = SWCTRL_IFINDEX_TO_PORT(ifindex_dest);

        retval = SWDRV_SetDestPortForAclMirror(unit, port, TRUE);

        if (retval)
        {
            if (common_mirror_type == SWCTRL_COMMON_MIRROR_TYPE_RX ||
                common_mirror_type == SWCTRL_COMMON_MIRROR_TYPE_BOTH)
            {
                SWCTRL_OM_SetMirrorConfigMode(SWCTRL_OM_ACL_MIRROR_MODE, TRUE);
                SWCTRL_OM_SetCommonMirrorDestPort(ifindex_dest);
            }
#if (SYS_CPNT_ACL_MIRROR_EGRESS == TRUE)
            if (common_mirror_type == SWCTRL_COMMON_MIRROR_TYPE_TX ||
                common_mirror_type == SWCTRL_COMMON_MIRROR_TYPE_BOTH)
            {
                SWCTRL_OM_SetMirrorConfigMode(SWCTRL_OM_ACL_EGRESS_MIRROR_MODE, TRUE);
                SWCTRL_OM_SetCommonMirrorTxDestPort(ifindex_dest);
            }
#endif
        }
    }
    else
    {
        UI32_T tmp_rx_ifindex, tmp_tx_ifindex;

        if (common_mirror_type == SWCTRL_COMMON_MIRROR_TYPE_RX ||
            common_mirror_type == SWCTRL_COMMON_MIRROR_TYPE_BOTH)
        {
            SWCTRL_OM_GetMirrorConfigMode(&conf_mode);
            SWCTRL_OM_SetMirrorConfigMode(SWCTRL_OM_ACL_MIRROR_MODE, FALSE);
            if ( (conf_mode & (SWCTRL_OM_VLAN_MIRROR_MODE|SWCTRL_OM_MAC_MIRROR_MODE)) == SWCTRL_OM_NONE_MIRROR_MODE )
            {
                /* remove a destination port configuration */
                SWCTRL_OM_SetCommonMirrorDestPort(0); /* 0 means no dest port */
#if (SYS_CPNT_ACL_MIRROR_EGRESS != TRUE)
                /* for mac-address mirror, we shall reset destination port */
                unit = SWCTRL_IFINDEX_TO_UNIT(ifindex_dest);
                port = SWCTRL_IFINDEX_TO_PORT(ifindex_dest);

                retval = SWDRV_SetDestPortForAclMirror(unit, port, FALSE);
#endif
            }
        }

#if (SYS_CPNT_ACL_MIRROR_EGRESS == TRUE)
        if (common_mirror_type == SWCTRL_COMMON_MIRROR_TYPE_TX ||
            common_mirror_type == SWCTRL_COMMON_MIRROR_TYPE_BOTH)
        {
            SWCTRL_OM_SetMirrorConfigMode(SWCTRL_OM_ACL_EGRESS_MIRROR_MODE, FALSE);
            SWCTRL_OM_SetCommonMirrorTxDestPort(0);  /* 0 means no dest port */
        }

        SWCTRL_OM_GetCommonMirrorDestPort(&tmp_rx_ifindex);
        SWCTRL_OM_GetCommonMirrorTxDestPort(&tmp_tx_ifindex);
        if (tmp_rx_ifindex != ifindex_dest && tmp_tx_ifindex != ifindex_dest)
        {
            /* for mac-address mirror, we shall reset destination port */
            unit = SWCTRL_IFINDEX_TO_UNIT(ifindex_dest);
            port = SWCTRL_IFINDEX_TO_PORT(ifindex_dest);

            retval = SWDRV_SetDestPortForAclMirror(unit, port, FALSE);
        }
#endif
    }

    SWCTRL_UNLOCK();

    SWCTRL_RETURN_AND_RELEASE_CSC(retval);
}

/*------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetAclMirrorDestPort
 *------------------------------------------------------------------------
 * FUNCTION: This function will setup dest port for  ACL-based mirror
 * INPUT   : ifindex_dest  -- Destination port. Pass 0 to start.
 * OUTPUT  : ifindex_dest  -- which ifindex-port received mirror packets
 * RETURN  : TRUE/FALSE
 * NOTE    :
 *------------------------------------------------------------------------*/
BOOL_T SWCTRL_GetNextAclMirrorDestPort(UI32_T *ifindex_dest)
{
    BOOL_T retval = FALSE;
    UI32_T tmp_ifindex = 0;
    UI32_T ifindex_rx;
#if (SYS_CPNT_ACL_MIRROR_EGRESS == TRUE)
    UI32_T ifindex_tx;
#endif

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);
    SWCTRL_LOCK();

    SWCTRL_OM_GetCommonMirrorDestPort(&ifindex_rx);
    if (*ifindex_dest < ifindex_rx)
    {
        tmp_ifindex = ifindex_rx;
        retval = TRUE;
    }

#if (SYS_CPNT_ACL_MIRROR_EGRESS == TRUE)
    SWCTRL_OM_GetCommonMirrorTxDestPort(&ifindex_tx);
    if (*ifindex_dest < ifindex_tx)
    {
        if (retval == TRUE)
        {
            if (tmp_ifindex > ifindex_tx)
            {
                tmp_ifindex = ifindex_tx;
            }
        }
        else
        {
            tmp_ifindex = ifindex_tx;
            retval = TRUE;
        }
    }
#endif

    *ifindex_dest = tmp_ifindex;

    SWCTRL_UNLOCK();
    SWCTRL_RETURN_AND_RELEASE_CSC(retval);
}
#endif /* SYS_CPNT_ACL_MIRROR */

#if (SYS_CPNT_VLAN_MIRROR == TRUE) || (SYS_CPNT_MAC_BASED_MIRROR == TRUE) || (SYS_CPNT_ACL_MIRROR == TRUE)
/*------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_CommonMirrorDestPortValidation
 *------------------------------------------------------------------------
 * FUNCTION: This function will do common mirror dest port validation
 * INPUT   : ifindex_dest  -- which ifindex-port received mirror packets
 *           mirror_type   -- mirror type
 * OUTPUT  : None
 * RETURN  : TRUE/FALSE
 * NOTE    : the tx and rx can set different destination port
 *------------------------------------------------------------------------*/
static BOOL_T SWCTRL_CommonMirrorDestPortValidation(UI32_T ifindex_dest, SWCTRL_CommonMirrorType_T mirror_type)
{
    UI32_T om_idx, om_ifindex;

    /* rule 1: compare current dest port index
     */
    if (mirror_type == SWCTRL_COMMON_MIRROR_TYPE_RX || mirror_type == SWCTRL_COMMON_MIRROR_TYPE_BOTH)
    {
        SWCTRL_OM_GetCommonMirrorDestPort(&om_ifindex);
        if ((om_ifindex != ifindex_dest) && (om_ifindex != 0))
        {
           return FALSE;
        }
    }

#if (SYS_CPNT_ACL_MIRROR_EGRESS == TRUE)
    if (mirror_type == SWCTRL_COMMON_MIRROR_TYPE_TX || mirror_type == SWCTRL_COMMON_MIRROR_TYPE_BOTH)
    {
        SWCTRL_OM_GetCommonMirrorTxDestPort(&om_ifindex);
        if ((om_ifindex != ifindex_dest) && (om_ifindex != 0))
        {
           return FALSE;
        }
    }
#endif /*#if (SYS_CPNT_ACL_MIRROR_EGRESS == TRUE)*/

    /* rule 2: check port attributes
     * 2.1. dest. port should be user port
     * 2.2. dest. port should exist
     */
    if (!SWCTRL_IS_USER_PORT(ifindex_dest) ||
        !SWCTRL_IS_EXIST(ifindex_dest))
    {
        return FALSE;
    }

    /* rule 3. dest. port should not be trunk member and trunk
     */
    if (SWCTRL_IS_TRUNK_MEMBER(ifindex_dest) || SWCTRL_IS_TRUNK(ifindex_dest))
    {
        return FALSE;
    }

    /* rule 4. LACP enabled port can't be set port mirroring
     */
#if (SYS_CPNT_STATIC_TRUNK_CONFIG_ALLOWED_ON_LACP_PORT == TRUE)
    if (user_ext_port_info[ifindex_dest-1].lacp_oper_status == VAL_lacpPortStatus_enabled)
#else
    if (user_ext_port_info[ifindex_dest-1].lacp_status == VAL_lacpPortStatus_enabled)
#endif
    {
        return FALSE;
    }

    /* rule 5. dest. port shall be only one in system
     */
#if (SYS_CPNT_VLAN_MIRROR == TRUE)
    if ((sys_vlan_mirror_info.mirror_dest_port != 0) &&
        (sys_vlan_mirror_info.mirror_dest_port != ifindex_dest))
    {
        return FALSE;
    }
#endif

    return TRUE;
}
#endif

/*

*/
BOOL_T SWCTRL_CheckMTPTable(UI32_T ifindex_dest, UI32_T mirror_status)
{
    int i;

    if (mirror_status != VAL_mirrorStatus_valid   &&
        mirror_status != VAL_mirrorStatus_invalid )
    {
        return FALSE;
    }

    if (ifindex_dest==0)
        return FALSE;

#if 0
    for (i=0;i<SYS_ADPT_MAX_NBR_OF_MIRROR_PORT;i++)
    {
        printf("%s--%s--%d mtp_info_table[i].MTP:%d  source_port_count:%d \n",
            __FILE__,__FUNCTION__,__LINE__,mtp_info_table[i].MTP,mtp_info_table[i].source_port_count);
    }
#endif

    if (mirror_status == VAL_mirrorStatus_valid)
    {
     /* check if database is not full with other MTP
     */
        for (i=0;i<SYS_ADPT_MAX_NBR_OF_MIRROR_PORT;i++)
        {
            if (mtp_info_table[i].MTP==ifindex_dest || mtp_info_table[i].source_port_count==0 )
                return TRUE;
        }
        return FALSE;
    }
    if (mirror_status == VAL_mirrorStatus_invalid)
    {
     /* check if input MTP exist in database and in use (source_port_count>0)
     */
        for (i=0;i<SYS_ADPT_MAX_NBR_OF_MIRROR_PORT;i++)
        {
            if (mtp_info_table[i].MTP==ifindex_dest && mtp_info_table[i].source_port_count > 0)
                return TRUE;
        }
        return FALSE;
    }

    return FALSE;
}



/*
check the MTP table for whether the input MTP can be set to chip.
Support 4 MTP in entire system.
*/
BOOL_T SWCTRL_SetMTPTable(UI32_T ifindex_dest, UI32_T mirror_status)
{
    int i;

    if (mirror_status != VAL_mirrorStatus_valid   &&
        mirror_status != VAL_mirrorStatus_invalid )
    {
        return FALSE;
    }

    if (ifindex_dest==0)
        return FALSE;

    if (mirror_status == VAL_mirrorStatus_valid)
    {
     /* search MTP in database
            1. exist in database, increase count
     */
        for (i=0;i<SYS_ADPT_MAX_NBR_OF_MIRROR_PORT;i++)
        {
            if ( mtp_info_table[i].MTP==ifindex_dest)
            {
                mtp_info_table[i].source_port_count++;
                return TRUE;
            }
        }
        /* search unused MTP
            1. exist unused MTP, increase count and save MTP to database
        */
        for (i=0;i<SYS_ADPT_MAX_NBR_OF_MIRROR_PORT;i++)
        {
            if (mtp_info_table[i].source_port_count==0)
            {
                mtp_info_table[i].MTP=ifindex_dest;
                mtp_info_table[i].source_port_count++;
                return TRUE;
            }
        }
        return FALSE;
    }
    if (mirror_status == VAL_mirrorStatus_invalid)
    {
     /* search MTP in database
            1. input MTP exist in database and in use(source_port_count>0), decrease count
            2. otherwise, return false
     */
        for (i=0;i<SYS_ADPT_MAX_NBR_OF_MIRROR_PORT;i++)
        {
            if ((mtp_info_table[i].MTP==ifindex_dest) && mtp_info_table[i].source_port_count > 0)
            {
                mtp_info_table[i].source_port_count--;
                return TRUE;
            }
        }
        return FALSE;
    }

    return FALSE;
}

void SWCTRL_InitPortMirrorList(UI32_T index)
{

    /*DanXie,use for mirror show*/
     L_SORT_LST_Create(&mirror_mtp_list[index],
                       SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK *
                                           SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT,
                       sizeof(SWCTRL_MIRROR_MTP_T),
                       SWCTRL_SortCompMirrorInfo);
     return ;
}


BOOL_T SWCTRL_SetPortToMirrorList(SWCTRL_MIRROR_MTP_T *mirror_mtp_info)
{
    UI32_T index = 0,reason = 0,got_index = 0;;



    for(index=0;index < SYS_ADPT_MAX_NBR_OF_MIRROR_PORT;index++)
    {
        SWCTRL_GetMirrorNodeIndex(mirror_mtp_info->dst_port,index,&got_index,&reason);
        if(reason == 1 || reason == 3)
        {
            if(!L_SORT_LST_Set(&mirror_mtp_list[index],mirror_mtp_info))
                SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
            SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
        }
        else if(reason == 2)
        {
            continue;
        }
    }
    SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
}

BOOL_T SWCTRL_DelPortFromMirrorList(SWCTRL_MIRROR_MTP_T *mirror_mtp_info)
{
    UI32_T index = 0,got_index = 0,reason = 0;

    for(index=0;index < SYS_ADPT_MAX_NBR_OF_MIRROR_PORT;index++)
    {
        SWCTRL_GetMirrorNodeIndex(mirror_mtp_info->dst_port,index,&got_index,&reason);
        if(reason == 3)
        {
            /*got the index*/
            break;
        }
    }

    if(index >= SYS_ADPT_MAX_NBR_OF_MIRROR_PORT)
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );

    if(!L_SORT_LST_Delete(&mirror_mtp_list[index], mirror_mtp_info))
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );

    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
}

static int SWCTRL_SortCompMirrorInfo(void *inlist_element, void *input_element)
{
    SWCTRL_MIRROR_MTP_T   element1, element2;

    element1 = *((SWCTRL_MIRROR_MTP_T *)inlist_element);
    element2 = *((SWCTRL_MIRROR_MTP_T *)input_element);

    return (element1.src_port - element2.src_port);
}

BOOL_T SWCTRL_GetMirrorNodeIndex(UI32_T dst_port, UI32_T index,UI32_T *got_index,UI32_T *reason)
{
    SWCTRL_MIRROR_MTP_T mirror_mtp_info;


    if(L_SORT_LST_Get_1st(&mirror_mtp_list[index], &mirror_mtp_info))
    {
        if(dst_port == (mirror_mtp_info.dst_port))
        {
            *got_index = index;
            *reason  = 3;
            return TRUE;
        }
        else
        {
            *got_index = index;
            /*need found next dst_port_mirror_list*/
            *reason  = 2;
            return TRUE;
        }
    }
    else
    {
        /*have not found the first node,need use the count to create new list*/
        *reason = 1;
        *got_index = index;
        return TRUE;
    }

    return FALSE;
}


BOOL_T SWCTRL_GetNextPortFromMirrorNode(UI32_T index, UI32_T src_port, SWCTRL_MIRROR_MTP_T *mirror_mtp_info)
{
    UI8_T               count=0;

    if(L_SORT_LST_Get_1st(&mirror_mtp_list[index], mirror_mtp_info))
    {
        do{
            /* if find element, return */
            if(mirror_mtp_info->src_port > src_port)
                return TRUE;
        }while(L_SORT_LST_Get_Next(&mirror_mtp_list[index], mirror_mtp_info));
    }

    for(count=index+1;count < SYS_ADPT_MAX_NBR_OF_MIRROR_PORT;count++)
    {
        if(L_SORT_LST_Get_1st(&mirror_mtp_list[count], mirror_mtp_info))
            return TRUE;
    }
    return FALSE;
}

static void SWCTRL_HandleHotRemoval_ForPortMirroring(UI32_T starting_port_ifindex, UI32_T number_of_port)
{
    UI32_T ifindex_src, ifindex_dest;
    UI32_T ending_port_ifindex = starting_port_ifindex + number_of_port;
    BOOL_T remove_drv_config, remove_om_config;

    /* it is necessary to clear all mirroring config related to the ports on removed unit.
     */
    for (ifindex_src = 1; ifindex_src <= SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK*SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT; ifindex_src++)
    {
        if (!SWCTRL_IS_EXIST(ifindex_src))
            continue;

        remove_drv_config = remove_om_config = FALSE;

        /* invalidate port mirror config if its mirrored port is removed.
         */
        if (ifindex_src >= starting_port_ifindex &&
            ifindex_src <= ending_port_ifindex &&
            (user_ext_port_info[ifindex_src-1].mirroring_tx_dest_port != 0 ||
             user_ext_port_info[ifindex_src-1].mirroring_rx_dest_port != 0))
        {
            remove_om_config = TRUE;
        }

        /* invalidate port mirror config if its analyzer port is removed.
         */
        if ((user_ext_port_info[ifindex_src-1].mirroring_tx_dest_port >= starting_port_ifindex &&
             user_ext_port_info[ifindex_src-1].mirroring_tx_dest_port <= ending_port_ifindex) ||
            (user_ext_port_info[ifindex_src-1].mirroring_rx_dest_port >= starting_port_ifindex &&
             user_ext_port_info[ifindex_src-1].mirroring_rx_dest_port <= ending_port_ifindex))
        {
            remove_drv_config = TRUE;
            remove_om_config = TRUE;
        }

        if (remove_drv_config || remove_om_config)
        {
            if (user_ext_port_info[ifindex_src-1].mirroring_tx_dest_port != 0)
                ifindex_dest = user_ext_port_info[ifindex_src-1].mirroring_tx_dest_port;
            else
                ifindex_dest = user_ext_port_info[ifindex_src-1].mirroring_rx_dest_port;

            /* remove chip config
             */
            if (remove_drv_config)
            {
                SYS_TYPE_Uport_T src_unit_port, dest_unit_port;

                src_unit_port.unit = SWCTRL_IFINDEX_TO_UNIT(ifindex_src);
                src_unit_port.port = SWCTRL_IFINDEX_TO_PORT(ifindex_src);
                dest_unit_port.unit = SWCTRL_IFINDEX_TO_UNIT(ifindex_dest);
                dest_unit_port.port = SWCTRL_IFINDEX_TO_PORT(ifindex_dest);

                SWDRV_DeletePortMirroring(src_unit_port,dest_unit_port);
            }

            /* remove database config
             */
            if (remove_om_config)
            {
                SWCTRL_MIRROR_MTP_T mirror_mtp_info;

                SWCTRL_SetMTPTable(ifindex_dest, VAL_mirrorStatus_invalid);

                mirror_mtp_info.dst_port = ifindex_dest;
                mirror_mtp_info.src_port = ifindex_src;

                SWCTRL_DelPortFromMirrorList(&mirror_mtp_info);

                user_ext_port_info[ifindex_src-1].mirroring_tx_dest_port = 0;
                user_ext_port_info[ifindex_src-1].mirroring_rx_dest_port = 0;
            }
        }
    }
}



/*---------------------------------------------------------------------- */
/* ( bcastStormMgt 1 )--ES3626A */
/*
 *      INDEX       { bcastStormIfIndex }
 *      BcastStormEntry ::= SEQUENCE
 *      {
 *          bcastStormIfIndex      Integer32,
 *          bcastStormStatus       INTEGER,
 *          bcastStormSampleType   INTEGER,
 *          bcastStormPktRate      INTEGER,
 *          bcastStormOctetRate    INTEGER,
 *          bcastStormPercent      INTEGER
 *      }
 */
/*------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetBcastStormEntry
 *------------------------------------------------------------------------
 * FUNCTION: This function will get the broadcast storm management entry
 * INPUT   : bcast_storm_entry->bcast_storm_ifindex - interface index
 * OUTPUT  : bcast_storm_entry                      - broadcast storm management entry
 * RETURN  : TRUE/FALSE
 * NOTE    : ES3626A MIB/bcastStormMgt 1
 *------------------------------------------------------------------------*/
BOOL_T SWCTRL_GetBcastStormEntry(SWCTRL_BcastStormEntry_T *bcast_storm_entry)
{
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (bcast_storm_entry == 0)
    {
        EH_MGR_Handle_Exception (SYS_MODULE_SWCTRL,
                                 SWCTRL_NO_USE_FUNC_NO,
                                 EH_TYPE_MSG_NULL_POINTER,
                                 EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_CRIT); /*SWCTRL_ENO_NULL_POINTER*/
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if ( bcast_storm_entry->bcast_storm_ifindex == 0                          ||
         bcast_storm_entry->bcast_storm_ifindex > SYS_ADPT_TOTAL_NBR_OF_LPORT )
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Logical Port ID (1-%d)", SYS_ADPT_TOTAL_NBR_OF_LPORT);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_LOGICAL_PORT_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (!SWCTRL_IS_EXIST (bcast_storm_entry->bcast_storm_ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Interface");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

#if (SYS_CPNT_BSTORM_SUPPORT_LPORT != TRUE)
    if (SWCTRL_IS_TRUNK (bcast_storm_entry->bcast_storm_ifindex))
    {
            EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                      SWCTRL_NO_USE_FUNC_NO,
                                      EH_TYPE_MSG_TRUNK_CNFG_ERR,
                                      SYSLOG_LEVEL_INFO,
                                      "it doesn't support Broadcast Storm Control.");  /*SWCTRL_ENO_NOT_TRUNK*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#else
    if (SWCTRL_IS_TRUNK_MEMBER (bcast_storm_entry->bcast_storm_ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#endif

    *bcast_storm_entry = port_info[bcast_storm_entry->bcast_storm_ifindex-1].bcast_storm_entry;

    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
} /* End of SWCTRL_GetBcastStormMgtEntry () */


/*------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetNextBcastStormEntry
 *------------------------------------------------------------------------
 * FUNCTION: This function will get the next broadcast storm management entry
 * INPUT   : bcast_storm_entry->bcast_storm_ifindex - interface index
 * OUTPUT  : bcast_storm_entry                      - broadcast storm management entry
 * RETURN  : TRUE/FALSE
 * NOTE    : ES3626A MIB/bcastStormMgt 1
 *------------------------------------------------------------------------*/
BOOL_T SWCTRL_GetNextBcastStormEntry(SWCTRL_BcastStormEntry_T *bcast_storm_entry)
{
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (bcast_storm_entry == 0)
    {
        EH_MGR_Handle_Exception (SYS_MODULE_SWCTRL,
                                 SWCTRL_NO_USE_FUNC_NO,
                                 EH_TYPE_MSG_NULL_POINTER,
                                 EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_CRIT); /*SWCTRL_ENO_NULL_POINTER*/
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if((*bcast_storm_entry).bcast_storm_ifindex > SYS_ADPT_TOTAL_NBR_OF_LPORT)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    (bcast_storm_entry->bcast_storm_ifindex)++;
    for(;
        bcast_storm_entry->bcast_storm_ifindex <= SYS_ADPT_TOTAL_NBR_OF_LPORT;
        (bcast_storm_entry->bcast_storm_ifindex)++)
    {
         if (!SWCTRL_IS_EXIST (bcast_storm_entry->bcast_storm_ifindex))
            continue;

#if (SYS_CPNT_BSTORM_SUPPORT_LPORT != TRUE)
        if (SWCTRL_IS_TRUNK (bcast_storm_entry->bcast_storm_ifindex))
           continue;
#else
        if (SWCTRL_IS_TRUNK_MEMBER (bcast_storm_entry->bcast_storm_ifindex))
           continue;
#endif

        *bcast_storm_entry = port_info[bcast_storm_entry->bcast_storm_ifindex-1].bcast_storm_entry;

        SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
    } /* End of for () */

    SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
}/* End of SWCTRL_GetNextBcastStormMgtEntry () */


/*------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetBcastStormStatus
 *------------------------------------------------------------------------
 * FUNCTION: This function will Set the broadcast storm status
 * INPUT   : ifindex                      - interface index
 *           bcast_storm_status           - VAL_bcastStormStatus_enabled
 *                                          VAL_bcastStormStatus_disabled
 * OUTPUT  : None
 * RETURN  : TRUE/FALSE
 * NOTE    : ES3626A MIB/bcastStormMgt 1
 *------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetBcastStormStatus(UI32_T ifindex, UI32_T bcast_storm_status)
{
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    SWCTRL_RETURN_AND_RELEASE_CSC( SWCTRL_SetBroadcastStormStatus(ifindex, bcast_storm_status) );
}


/*------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetBcastStormSampleType
 *------------------------------------------------------------------------
 * FUNCTION: This function will Set the broadcast storm sample type
 * INPUT   : ifindex                        - interface index
 *           bcast_storm_sample_type        - VAL_bcastStormSampleType_pkt_rate
 *                                            VAL_bcastStormSampleType_octet_rate
 *                                            VAL_bcastStormSampleType_percent
 * OUTPUT  : None
 * RETURN  : TRUE/FALSE
 * NOTE    : ES3626A MIB/bcastStormMgt 1
 *------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetBcastStormSampleType(UI32_T ifindex, UI32_T bcast_storm_sample_type)
{
    UI32_T nRate = 0;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

#if (SYS_CPNT_SWCTRL_GLOBAL_STORM_SAMPLE_TYPE == TRUE)
    if(bcast_storm_sample_type != swctrl_global_storm_sample_type)
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_INVALID_PARAMETER,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "sample type"); /*SWCTRL_ENO_INVALID_SAMPLE_TYPE*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#endif

#if (defined(STRATA_SWITCH) || defined(ALLAYER_SWITCH) || defined(XGS_SWITCH))
    if (bcast_storm_sample_type != VAL_bcastStormSampleType_pkt_rate)
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_INVALID_PARAMETER,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "broadcast storm sample type");   /*SWCTRL_ENO_INVALID_ADMIN*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#endif

    if((bcast_storm_sample_type != VAL_bcastStormSampleType_pkt_rate) &&
       (bcast_storm_sample_type != VAL_bcastStormSampleType_octet_rate) &&
       (bcast_storm_sample_type != VAL_bcastStormSampleType_percent))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_INVALID_PARAMETER,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "broadcast storm sample type");   /*SWCTRL_ENO_INVALID_ADMIN*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if( ifindex == 0 || ifindex > SYS_ADPT_TOTAL_NBR_OF_LPORT)
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Logical Port ID (1-%d)", SYS_ADPT_TOTAL_NBR_OF_LPORT);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_LOGICAL_PORT_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (!SWCTRL_IS_EXIST (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Interface");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

#if (SYS_CPNT_BSTORM_SUPPORT_LPORT != TRUE)
    if (SWCTRL_IS_TRUNK (ifindex))
    {
            EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                      SWCTRL_NO_USE_FUNC_NO,
                                      EH_TYPE_MSG_TRUNK_CNFG_ERR,
                                      SYSLOG_LEVEL_INFO,
                                      "it doesn't support Broadcast Storm Control.");  /*SWCTRL_ENO_NOT_TRUNK*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#else
    if (SWCTRL_IS_TRUNK_MEMBER (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#endif

    if(port_info[ifindex-1].bcast_storm_entry.bcast_storm_sample_type == VAL_bcastStormSampleType_pkt_rate)
    {
        switch (bcast_storm_sample_type)
        {
        case VAL_bcastStormSampleType_pkt_rate:
            SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );

        case VAL_bcastStormSampleType_octet_rate:
            nRate = port_info[ifindex-1].bcast_storm_entry.bcast_storm_pkt_rate*500;
            break;

        case VAL_bcastStormSampleType_percent:
            if(SWCTRL_IS_100TX (ifindex) || SWCTRL_IS_100FIBER (ifindex))
            {
                nRate = port_info[ifindex-1].bcast_storm_entry.bcast_storm_pkt_rate * 8 * 500 * 100 / 100000000;
            }
            else if(SWCTRL_IS_1000T (ifindex) || SWCTRL_IS_1000FIBER (ifindex))
            {
                nRate = port_info[ifindex-1].bcast_storm_entry.bcast_storm_pkt_rate * 8 * 500 * 100 / 1000000000;
            }
            else /* 10G */
            {
                nRate = port_info[ifindex-1].bcast_storm_entry.bcast_storm_pkt_rate / 25000; /* 25000 = 1/(8 * 500 * 100 / 10000000000) */
            }
            break;
        }
    }

    if(port_info[ifindex-1].bcast_storm_entry.bcast_storm_sample_type== VAL_bcastStormSampleType_octet_rate)
    {
        switch (bcast_storm_sample_type)
        {
        case VAL_bcastStormSampleType_pkt_rate:
            nRate = port_info[ifindex-1].bcast_storm_entry.bcast_storm_octet_rate/500;
            break;

        case VAL_bcastStormSampleType_octet_rate:
            SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );

        case VAL_bcastStormSampleType_percent:
            if(SWCTRL_IS_100TX (ifindex) || SWCTRL_IS_100FIBER (ifindex))
                nRate = port_info[ifindex-1].bcast_storm_entry.bcast_storm_octet_rate * 8 * 100 / 100000000;
            else if(SWCTRL_IS_1000T (ifindex) || SWCTRL_IS_1000FIBER (ifindex))
                nRate = port_info[ifindex-1].bcast_storm_entry.bcast_storm_octet_rate * 8 * 100 / 1000000000;
            else /* 10G */
                nRate = port_info[ifindex-1].bcast_storm_entry.bcast_storm_octet_rate / 25000; /* 25000 = 1/(8 * 500 * 100 / 10000000000) */
            break;
        }
    }

    if(port_info[ifindex-1].bcast_storm_entry.bcast_storm_sample_type== VAL_bcastStormSampleType_percent)
    {
        switch (bcast_storm_sample_type)
        {
        case VAL_bcastStormSampleType_pkt_rate:
            if(SWCTRL_IS_100TX (ifindex) || SWCTRL_IS_100FIBER (ifindex))
            {
                nRate = 100000000 / 8 / 500 * port_info[ifindex-1].bcast_storm_entry.bcast_storm_percent / 100;
            }
            else if(SWCTRL_IS_1000T (ifindex) || SWCTRL_IS_1000FIBER (ifindex))
            {
                nRate = 1000000000 / 8 / 500 * port_info[ifindex-1].bcast_storm_entry.bcast_storm_percent / 100;
            }
            else /* 10G */
            {
                nRate = 2500000 * port_info[ifindex-1].bcast_storm_entry.bcast_storm_percent / 100;  /* 2500000 = (10000000000 / 8 / 500) */
            }
            break;

        case VAL_bcastStormSampleType_octet_rate:
            if(SWCTRL_IS_100TX (ifindex) || SWCTRL_IS_100FIBER (ifindex))
            {
                nRate = 100000000 / 8 * port_info[ifindex-1].bcast_storm_entry.bcast_storm_octet_rate / 100;
            }
            else if(SWCTRL_IS_1000T (ifindex) || SWCTRL_IS_1000FIBER (ifindex))
            {
                nRate = 1000000000 / 8 * port_info[ifindex-1].bcast_storm_entry.bcast_storm_octet_rate / 100;
            }
            else /* 10G */
            {
                nRate = 1250000000 * port_info[ifindex-1].bcast_storm_entry.bcast_storm_octet_rate / 100; /* 1250000000 = (10000000000 / 8) */
            }
            break;

        case VAL_bcastStormSampleType_percent:
            SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
        }
    }

    if (nRate == 0)
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_INVALID_PARAMETER,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "broadcast storm sample type");   /*SWCTRL_ENO_INVALID_ADMIN*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    SWCTRL_RETURN_AND_RELEASE_CSC( SWCTRL_SetBStormControlRateLimit(ifindex, bcast_storm_sample_type, nRate) );
} /* End of SWCTRL_SetBcastStormSampleType () */


/*------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetBcastStormPktRate
 *------------------------------------------------------------------------
 * FUNCTION: This function will Set tthe broadcast storm packet rate
 * INPUT   : ifindex                        - interface index
 *           bcast_storm_pkt_rate           - the broadcast storm packet rate
 * OUTPUT  : None
 * RETURN  : TRUE/FALSE
 * NOTE    : ES3626A MIB/bcastStormMgt 1
 *------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetBcastStormPktRate(UI32_T ifindex, UI32_T bcast_storm_pkt_rate)
{
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    SWCTRL_RETURN_AND_RELEASE_CSC( SWCTRL_SetBStormControlRateLimit(ifindex, VAL_bcastStormSampleType_pkt_rate, bcast_storm_pkt_rate) );
}


/*------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetBcastStormOctetRate
 *------------------------------------------------------------------------
 * FUNCTION: This function will Set tthe broadcast storm octet rate
 * INPUT   : ifindex                        - interface index
 *           bcast_storm_octet_rate         - the broadcast storm octet rate
 * OUTPUT  : None
 * RETURN  : TRUE/FALSE
 * NOTE    : ES3626A MIB/bcastStormMgt 1
 *------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetBcastStormOctetRate(UI32_T ifindex, UI32_T bcast_storm_octet_rate)
{
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    SWCTRL_RETURN_AND_RELEASE_CSC( SWCTRL_SetBStormControlRateLimit(ifindex, VAL_bcastStormSampleType_octet_rate, bcast_storm_octet_rate) );
}


/*------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetBcastStormPercent
 *------------------------------------------------------------------------
 * FUNCTION: This function will Set tthe broadcast storm octet rate
 * INPUT   : ifindex                       - interface index
 *           bcast_storm_percent           - the broadcast storm percent
 * OUTPUT  : None
 * RETURN  : TRUE/FALSE
 * NOTE    : ES3626A MIB/bcastStormMgt 1
 *------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetBcastStormPercent(UI32_T ifindex, UI32_T bcast_storm_percent)
{
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    SWCTRL_RETURN_AND_RELEASE_CSC( SWCTRL_SetBStormControlRateLimit(ifindex, VAL_bcastStormSampleType_percent, bcast_storm_percent) );
}




/*---------------------------------------------------------------------- */
/* ( mcastStormMgt 1 )--ES3626A */
/*
 *      INDEX       { mcastStormIfIndex }
 *      McastStormEntry ::= SEQUENCE
 *      {
 *          mcastStormIfIndex      Integer32,
 *          mcastStormStatus       INTEGER,
 *          mcastStormSampleType   INTEGER,
 *          mcastStormPktRate      INTEGER,
 *          mcastStormOctetRate    INTEGER,
 *          mcastStormPercent      INTEGER
 *      }
 */
/*------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetMcastStormEntry
 *------------------------------------------------------------------------
 * FUNCTION: This function will get the multicast storm management entry
 * INPUT   : mcast_storm_entry->bcast_storm_ifindex - interface index
 * OUTPUT  : mcast_storm_entry                      - multicast storm management entry
 * RETURN  : TRUE/FALSE
 * NOTE    : ES3626A MIB/mcastStormMgt 1
 *------------------------------------------------------------------------*/
BOOL_T SWCTRL_GetMcastStormEntry(SWCTRL_McastStormEntry_T *mcast_storm_entry)
{
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (mcast_storm_entry == 0)
    {
        EH_MGR_Handle_Exception (SYS_MODULE_SWCTRL,
                                 SWCTRL_NO_USE_FUNC_NO,
                                 EH_TYPE_MSG_NULL_POINTER,
                                 EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_CRIT); /*SWCTRL_ENO_NULL_POINTER*/
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if ( mcast_storm_entry->mcast_storm_ifindex == 0                          ||
         mcast_storm_entry->mcast_storm_ifindex > SYS_ADPT_TOTAL_NBR_OF_LPORT )
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Logical Port ID (1-%d)", SYS_ADPT_TOTAL_NBR_OF_LPORT);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_LOGICAL_PORT_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (!SWCTRL_IS_EXIST (mcast_storm_entry->mcast_storm_ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Interface");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

#if (SYS_CPNT_MSTORM_SUPPORT_LPORT != TRUE)
    if (SWCTRL_IS_TRUNK (mcast_storm_entry->mcast_storm_ifindex))
    {
            EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                      SWCTRL_NO_USE_FUNC_NO,
                                      EH_TYPE_MSG_TRUNK_CNFG_ERR,
                                      SYSLOG_LEVEL_INFO,
                                      "it doesn't support Multicast Storm Control.");  /*SWCTRL_ENO_NOT_TRUNK*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#else
    if (SWCTRL_IS_TRUNK_MEMBER (mcast_storm_entry->mcast_storm_ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#endif

    *mcast_storm_entry = port_info[mcast_storm_entry->mcast_storm_ifindex-1].mcast_storm_entry;

    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
} /* End of SWCTRL_GetMcastStormMgtEntry () */


/*------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetNextMcastStormEntry
 *------------------------------------------------------------------------
 * FUNCTION: This function will get the next multicast storm management entry
 * INPUT   : mcast_storm_entry->mcast_storm_ifindex - interface index
 * OUTPUT  : mcast_storm_entry                      - multicast storm management entry
 * RETURN  : TRUE/FALSE
 * NOTE    : ES3626A MIB/mcastStormMgt 1
 *------------------------------------------------------------------------*/
BOOL_T SWCTRL_GetNextMcastStormEntry(SWCTRL_McastStormEntry_T *mcast_storm_entry)
{
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (mcast_storm_entry == 0)
    {
        EH_MGR_Handle_Exception (SYS_MODULE_SWCTRL,
                                 SWCTRL_NO_USE_FUNC_NO,
                                 EH_TYPE_MSG_NULL_POINTER,
                                 EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_CRIT); /*SWCTRL_ENO_NULL_POINTER*/
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if((*mcast_storm_entry).mcast_storm_ifindex > SYS_ADPT_TOTAL_NBR_OF_LPORT)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    (mcast_storm_entry->mcast_storm_ifindex)++;
    for(;
        mcast_storm_entry->mcast_storm_ifindex <= SYS_ADPT_TOTAL_NBR_OF_LPORT;
        (mcast_storm_entry->mcast_storm_ifindex)++)
    {
         if (!SWCTRL_IS_EXIST (mcast_storm_entry->mcast_storm_ifindex))
            continue;

#if (SYS_CPNT_MSTORM_SUPPORT_LPORT != TRUE)
        if (SWCTRL_IS_TRUNK (mcast_storm_entry->mcast_storm_ifindex))
           continue;
#else
        if (SWCTRL_IS_TRUNK_MEMBER (mcast_storm_entry->mcast_storm_ifindex))
           continue;
#endif

        *mcast_storm_entry = port_info[mcast_storm_entry->mcast_storm_ifindex-1].mcast_storm_entry;

        SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
    } /* End of for () */

    SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
}/* End of SWCTRL_GetNextMcastStormMgtEntry () */


/*------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetMcastStormStatus
 *------------------------------------------------------------------------
 * FUNCTION: This function will Set the multicast storm status
 * INPUT   : ifindex                      - interface index
 *           mcast_storm_status           - VAL_mcastStormStatus_enabled
 *                                          VAL_mcastStormStatus_disabled
 * OUTPUT  : None
 * RETURN  : TRUE/FALSE
 * NOTE    : ES3626A MIB/mcastStormMgt 1
 *------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetMcastStormStatus(UI32_T ifindex, UI32_T mcast_storm_status)
{
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    SWCTRL_RETURN_AND_RELEASE_CSC( SWCTRL_SetMulticastStormStatus(ifindex, mcast_storm_status) );
}


/*------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetMcastStormSampleType
 *------------------------------------------------------------------------
 * FUNCTION: This function will Set the multicast storm sample type
 * INPUT   : ifindex                        - interface index
 *           mcast_storm_sample_type        - VAL_mcastStormSampleType_pkt_rate
 *                                            VAL_mcastStormSampleType_octet_rate
 *                                            VAL_mcastStormSampleType_percent
 * OUTPUT  : None
 * RETURN  : TRUE/FALSE
 * NOTE    : ES3626A MIB/mcastStormMgt 1
 *------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetMcastStormSampleType(UI32_T ifindex, UI32_T mcast_storm_sample_type)
{
    UI32_T nRate = 0;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

#if (SYS_CPNT_SWCTRL_GLOBAL_STORM_SAMPLE_TYPE == TRUE)
    if(mcast_storm_sample_type != swctrl_global_storm_sample_type)
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_INVALID_PARAMETER,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "sample type"); /*SWCTRL_ENO_INVALID_SAMPLE_TYPE*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#endif

#if (defined(STRATA_SWITCH) || defined(ALLAYER_SWITCH))
    if (mcast_storm_sample_type != VAL_mcastStormSampleType_octet_rate)
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_INVALID_PARAMETER,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "multicast storm sample type");   /*SWCTRL_ENO_INVALID_ADMIN*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#endif

    if((mcast_storm_sample_type != VAL_mcastStormSampleType_pkt_rate) &&
       (mcast_storm_sample_type != VAL_mcastStormSampleType_octet_rate) &&
       (mcast_storm_sample_type != VAL_mcastStormSampleType_percent))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_INVALID_PARAMETER,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "multicast storm sample type");   /*SWCTRL_ENO_INVALID_ADMIN*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if( ifindex == 0 || ifindex > SYS_ADPT_TOTAL_NBR_OF_LPORT)
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Logical Port ID (1-%d)", SYS_ADPT_TOTAL_NBR_OF_LPORT);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_LOGICAL_PORT_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (!SWCTRL_IS_EXIST (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Interface");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

#if (SYS_CPNT_MSTORM_SUPPORT_LPORT != TRUE)
    if (SWCTRL_IS_TRUNK (ifindex))
    {
            EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                      SWCTRL_NO_USE_FUNC_NO,
                                      EH_TYPE_MSG_TRUNK_CNFG_ERR,
                                      SYSLOG_LEVEL_INFO,
                                      "it doesn't support Multicast Storm Control.");  /*SWCTRL_ENO_NOT_TRUNK*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#else
    if (SWCTRL_IS_TRUNK_MEMBER (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#endif

    if(port_info[ifindex-1].mcast_storm_entry.mcast_storm_sample_type == VAL_mcastStormSampleType_pkt_rate)
    {
        switch (mcast_storm_sample_type)
        {
        case VAL_mcastStormSampleType_pkt_rate:
            SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
        case VAL_mcastStormSampleType_octet_rate:
            nRate = port_info[ifindex-1].mcast_storm_entry.mcast_storm_pkt_rate*500;
            break;
        case VAL_mcastStormSampleType_percent:
            if(SWCTRL_IS_100TX (ifindex) || SWCTRL_IS_100FIBER (ifindex))
                nRate = port_info[ifindex-1].mcast_storm_entry.mcast_storm_pkt_rate * 8 * 500 * 100 / 100000000;
            else
                nRate = port_info[ifindex-1].mcast_storm_entry.mcast_storm_pkt_rate * 8 * 500 * 100 / 1000000000;
            break;
        }
    }
    if(port_info[ifindex-1].mcast_storm_entry.mcast_storm_sample_type== VAL_mcastStormSampleType_octet_rate)
    {
        switch (mcast_storm_sample_type)
        {
        case VAL_mcastStormSampleType_pkt_rate:
            nRate = port_info[ifindex-1].mcast_storm_entry.mcast_storm_octet_rate/500;
            break;
        case VAL_mcastStormSampleType_octet_rate:
            SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
        case VAL_mcastStormSampleType_percent:
            if(SWCTRL_IS_100TX (ifindex) || SWCTRL_IS_100FIBER (ifindex))
                nRate = port_info[ifindex-1].mcast_storm_entry.mcast_storm_octet_rate * 8 * 100 / 100000000;
            else
                nRate = port_info[ifindex-1].mcast_storm_entry.mcast_storm_octet_rate * 8 * 100 / 1000000000;
            break;
        }
    }
    if(port_info[ifindex-1].mcast_storm_entry.mcast_storm_sample_type== VAL_mcastStormSampleType_percent)
    {
        switch (mcast_storm_sample_type)
        {
        case VAL_mcastStormSampleType_pkt_rate:
            if(SWCTRL_IS_100TX (ifindex) || SWCTRL_IS_100FIBER (ifindex))
                nRate = 100000000 / 8 / 500 * port_info[ifindex-1].mcast_storm_entry.mcast_storm_percent / 100;
            else
                nRate = 1000000000 / 8 / 500 * port_info[ifindex-1].mcast_storm_entry.mcast_storm_percent / 100;
            break;
        case VAL_mcastStormSampleType_octet_rate:
            if(SWCTRL_IS_100TX (ifindex) || SWCTRL_IS_100FIBER (ifindex))
                nRate = 100000000 / 8 * port_info[ifindex-1].mcast_storm_entry.mcast_storm_percent / 100;
            else
                nRate = 1000000000 / 8 * port_info[ifindex-1].mcast_storm_entry.mcast_storm_percent / 100;
            break;
        case VAL_mcastStormSampleType_percent:
            SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
        }
    }

    if (nRate == 0)
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_INVALID_PARAMETER,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "multicast storm sample type");   /*SWCTRL_ENO_INVALID_ADMIN*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    SWCTRL_RETURN_AND_RELEASE_CSC( SWCTRL_SetMStormControlRateLimit(ifindex, mcast_storm_sample_type, nRate) );
} /* End of SWCTRL_SetMcastStormSampleType () */


/*------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetMcastStormPktRate
 *------------------------------------------------------------------------
 * FUNCTION: This function will Set tthe multicast storm packet rate
 * INPUT   : ifindex                        - interface index
 *           mcast_storm_pkt_rate           - the multicast storm packet rate
 * OUTPUT  : None
 * RETURN  : TRUE/FALSE
 * NOTE    : ES3626A MIB/mcastStormMgt 1
 *------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetMcastStormPktRate(UI32_T ifindex, UI32_T mcast_storm_pkt_rate)
{
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    SWCTRL_RETURN_AND_RELEASE_CSC( SWCTRL_SetMStormControlRateLimit(ifindex, VAL_mcastStormSampleType_pkt_rate, mcast_storm_pkt_rate) );
}


/*------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetMcastStormOctetRate
 *------------------------------------------------------------------------
 * FUNCTION: This function will Set tthe multicast storm octet rate
 * INPUT   : ifindex                        - interface index
 *           mcast_storm_octet_rate         - the multicast storm octet rate
 * OUTPUT  : None
 * RETURN  : TRUE/FALSE
 * NOTE    : ES3626A MIB/mcastStormMgt 1
 *------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetMcastStormOctetRate(UI32_T ifindex, UI32_T mcast_storm_octet_rate)
{
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    SWCTRL_RETURN_AND_RELEASE_CSC( SWCTRL_SetMStormControlRateLimit(ifindex, VAL_mcastStormSampleType_octet_rate, mcast_storm_octet_rate) );
}


/*------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetMcastStormPercent
 *------------------------------------------------------------------------
 * FUNCTION: This function will Set tthe multicast storm octet rate
 * INPUT   : ifindex                       - interface index
 *           mcast_storm_percent           - the multicast storm percent
 * OUTPUT  : None
 * RETURN  : TRUE/FALSE
 * NOTE    : ES3626A MIB/mcastStormMgt 1
 *------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetMcastStormPercent(UI32_T ifindex, UI32_T mcast_storm_percent)
{
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    SWCTRL_RETURN_AND_RELEASE_CSC( SWCTRL_SetMStormControlRateLimit(ifindex, VAL_mcastStormSampleType_percent, mcast_storm_percent) );
}

#if (SYS_CPNT_STORM_MODE & SYS_CPNT_STORM_UNKNOWN_USTORM)
/*---------------------------------------------------------------------- */
/* ( unkucastStormMgt 1 )--ES3626A */
/*
 *      INDEX       { unkucastStormIfIndex }
 *      UnkucastStormEntry ::= SEQUENCE
 *      {
 *          unkucastStormIfIndex      Integer32,
 *          unkucastStormStatus       INTEGER,
 *          unkucastStormSampleType   INTEGER,
 *          unkucastStormPktRate      INTEGER,
 *          unkucastStormOctetRate    INTEGER,
 *          unkucastStormPercent      INTEGER
 *      }
 */
/*------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetUnkucastStormEntry
 *------------------------------------------------------------------------
 * FUNCTION: This function will get the unknowunicast storm management entry
 * INPUT   : unkucast_storm_entry->unkucast_storm_ifindex - interface index
 * OUTPUT  : unkucast_storm_entry                      - unknowunicast storm management entry
 * RETURN  : TRUE/FALSE
 * NOTE    : ES3626A MIB/unkucastStormMgt 1
 *------------------------------------------------------------------------*/
BOOL_T SWCTRL_GetUnkucastStormEntry(SWCTRL_UnknownUcastStormEntry_T *unkucast_storm_entry)
{
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (unkucast_storm_entry == 0)
    {
        EH_MGR_Handle_Exception (SYS_MODULE_SWCTRL,
                                 SWCTRL_NO_USE_FUNC_NO,
                                 EH_TYPE_MSG_NULL_POINTER,
                                 EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_CRIT); /*SWCTRL_ENO_NULL_POINTER*/
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if ( unkucast_storm_entry->unknown_ucast_storm_ifindex == 0                          ||
         unkucast_storm_entry->unknown_ucast_storm_ifindex > SYS_ADPT_TOTAL_NBR_OF_LPORT )
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Logical Port ID (1-%d)", SYS_ADPT_TOTAL_NBR_OF_LPORT);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_LOGICAL_PORT_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (!SWCTRL_IS_EXIST (unkucast_storm_entry->unknown_ucast_storm_ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Interface");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

#if (SYS_CPNT_MSTORM_SUPPORT_LPORT != TRUE)
    if (SWCTRL_IS_TRUNK (unkucast_storm_entry->unknown_ucast_storm_ifindex))
    {
            EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                      SWCTRL_NO_USE_FUNC_NO,
                                      EH_TYPE_MSG_TRUNK_CNFG_ERR,
                                      SYSLOG_LEVEL_INFO,
                                      "it doesn't support Unknown Unicast Storm Control.");  /*SWCTRL_ENO_NOT_TRUNK*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#else
    if (SWCTRL_IS_TRUNK_MEMBER (unkucast_storm_entry->unknown_ucast_storm_ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#endif

    *unkucast_storm_entry = port_info[unkucast_storm_entry->unknown_ucast_storm_ifindex-1].unknown_ucast_storm_entry;

    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
}


/*------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetNextUnkucastStormEntry
 *------------------------------------------------------------------------
 * FUNCTION: This function will get the next unknowunicast storm management entry
 * INPUT   : unkucast_storm_entry->unkucast_storm_ifindex - interface index
 * OUTPUT  : unkucast_storm_entry                      - unknowunicast storm management entry
 * RETURN  : TRUE/FALSE
 * NOTE    : ES3626A MIB/unkucastStormMgt 1
 *------------------------------------------------------------------------*/
BOOL_T SWCTRL_GetNextUnkucastStormEntry(SWCTRL_UnknownUcastStormEntry_T *unkucast_storm_entry)
{
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (unkucast_storm_entry == 0)
    {
        EH_MGR_Handle_Exception (SYS_MODULE_SWCTRL,
                                 SWCTRL_NO_USE_FUNC_NO,
                                 EH_TYPE_MSG_NULL_POINTER,
                                 EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_CRIT); /*SWCTRL_ENO_NULL_POINTER*/
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if((*unkucast_storm_entry).unknown_ucast_storm_ifindex > SYS_ADPT_TOTAL_NBR_OF_LPORT)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    (unkucast_storm_entry->unknown_ucast_storm_ifindex)++;
    for(;
        unkucast_storm_entry->unknown_ucast_storm_ifindex <= SYS_ADPT_TOTAL_NBR_OF_LPORT;
        (unkucast_storm_entry->unknown_ucast_storm_ifindex)++)
    {
         if (!SWCTRL_IS_EXIST (unkucast_storm_entry->unknown_ucast_storm_ifindex))
            continue;

#if (SYS_CPNT_UNKNOWN_USTORM_SUPPORT_LPORT != TRUE)
        if (SWCTRL_IS_TRUNK (unkucast_storm_entry->unknown_ucast_storm_ifindex))
           continue;
#else
        if (SWCTRL_IS_TRUNK_MEMBER (unkucast_storm_entry->unknown_ucast_storm_ifindex))
           continue;
#endif

        *unkucast_storm_entry = port_info[unkucast_storm_entry->unknown_ucast_storm_ifindex-1].unknown_ucast_storm_entry;

        SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
    } /* End of for () */

    SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
}


/*------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetUnkucastStormSampleType
 *------------------------------------------------------------------------
 * FUNCTION: This function will Set the unknowunicast storm sample type
 * INPUT   : ifindex                        - interface index
 *           unkucast_storm_sample_type        - VAL_unkucastStormSampleType_pkt_rate
 *                                            VAL_unkucastStormSampleType_octet_rate
 *                                            VAL_unkucastStormSampleType_percent
 * OUTPUT  : None
 * RETURN  : TRUE/FALSE
 * NOTE    : ES3626A MIB/unkucastStormMgt 1
 *------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetUnkucastStormSampleType(UI32_T ifindex, UI32_T unkucast_storm_sample_type)
{
    UI32_T nRate = 0;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

#if (SYS_CPNT_SWCTRL_GLOBAL_STORM_SAMPLE_TYPE == TRUE)
    if(unkucast_storm_sample_type != swctrl_global_storm_sample_type)
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_INVALID_PARAMETER,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "sample type"); /*SWCTRL_ENO_INVALID_SAMPLE_TYPE*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#endif

    if (!SWCTRL_IsSupportedStormType(unkucast_storm_sample_type))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_INVALID_PARAMETER,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "unknown unicast storm sample type");   /*SWCTRL_ENO_INVALID_ADMIN*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if( ifindex == 0 || ifindex > SYS_ADPT_TOTAL_NBR_OF_LPORT)
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Logical Port ID (1-%d)", SYS_ADPT_TOTAL_NBR_OF_LPORT);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_LOGICAL_PORT_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (!SWCTRL_IS_EXIST (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Interface");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

#if (SYS_CPNT_UNKNOWN_USTORM_SUPPORT_LPORT != TRUE)
    if (SWCTRL_IS_TRUNK (ifindex))
    {
            EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                      SWCTRL_NO_USE_FUNC_NO,
                                      EH_TYPE_MSG_TRUNK_CNFG_ERR,
                                      SYSLOG_LEVEL_INFO,
                                      "it doesn't support Unknown Unicast Storm Control.");  /*SWCTRL_ENO_NOT_TRUNK*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#else
    if (SWCTRL_IS_TRUNK_MEMBER (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#endif

    if(port_info[ifindex-1].unknown_ucast_storm_entry.unknown_ucast_storm_sample_type == VAL_unkucastStormSampleType_pkt_rate)
    {
        switch (unkucast_storm_sample_type)
        {
        case VAL_unkucastStormSampleType_pkt_rate:
            SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
        case VAL_unkucastStormSampleType_octet_rate:
            nRate = port_info[ifindex-1].unknown_ucast_storm_entry.unknown_ucast_storm_pkt_rate*500;
            break;
        case VAL_unkucastStormSampleType_percent:
            if(SWCTRL_IS_100TX (ifindex) || SWCTRL_IS_100FIBER (ifindex))
                nRate = port_info[ifindex-1].unknown_ucast_storm_entry.unknown_ucast_storm_pkt_rate * 8 * 500 * 100 / 100000000;
            else
                nRate = port_info[ifindex-1].unknown_ucast_storm_entry.unknown_ucast_storm_pkt_rate * 8 * 500 * 100 / 1000000000;
            break;
        }
    }
    if(port_info[ifindex-1].unknown_ucast_storm_entry.unknown_ucast_storm_sample_type== VAL_unkucastStormSampleType_octet_rate)
    {
        switch (unkucast_storm_sample_type)
        {
        case VAL_unkucastStormSampleType_pkt_rate:
            nRate = port_info[ifindex-1].unknown_ucast_storm_entry.unknown_ucast_storm_octet_rate/500;
            break;
        case VAL_unkucastStormSampleType_octet_rate:
            SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
        case VAL_unkucastStormSampleType_percent:
            if(SWCTRL_IS_100TX (ifindex) || SWCTRL_IS_100FIBER (ifindex))
                nRate = port_info[ifindex-1].unknown_ucast_storm_entry.unknown_ucast_storm_octet_rate * 8 * 100 / 100000000;
            else
                nRate = port_info[ifindex-1].unknown_ucast_storm_entry.unknown_ucast_storm_octet_rate * 8 * 100 / 1000000000;
            break;
        }
    }
    if(port_info[ifindex-1].unknown_ucast_storm_entry.unknown_ucast_storm_sample_type== VAL_unkucastStormSampleType_percent)
    {
        switch (unkucast_storm_sample_type)
        {
        case VAL_unkucastStormSampleType_pkt_rate:
            if(SWCTRL_IS_100TX (ifindex) || SWCTRL_IS_100FIBER (ifindex))
                nRate = 100000000 / 8 / 500 * port_info[ifindex-1].unknown_ucast_storm_entry.unknown_ucast_storm_percent / 100;
            else
                nRate = 1000000000 / 8 / 500 * port_info[ifindex-1].unknown_ucast_storm_entry.unknown_ucast_storm_percent / 100;
            break;
        case VAL_unkucastStormSampleType_octet_rate:
            if(SWCTRL_IS_100TX (ifindex) || SWCTRL_IS_100FIBER (ifindex))
                nRate = 100000000 / 8 * port_info[ifindex-1].unknown_ucast_storm_entry.unknown_ucast_storm_percent / 100;
            else
                nRate = 1000000000 / 8 * port_info[ifindex-1].unknown_ucast_storm_entry.unknown_ucast_storm_percent / 100;
            break;
        case VAL_unkucastStormSampleType_percent:
            SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
        }
    }

    if (nRate == 0)
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_INVALID_PARAMETER,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "unknown unicast storm sample type");   /*SWCTRL_ENO_INVALID_ADMIN*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    SWCTRL_RETURN_AND_RELEASE_CSC( SWCTRL_SetUnknownUStormControlRateLimit(ifindex, unkucast_storm_sample_type, nRate) );
}


/*------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetUnkucastStormPktRate
 *------------------------------------------------------------------------
 * FUNCTION: This function will Set tthe unknowunicast storm packet rate
 * INPUT   : ifindex                        - interface index
 *           unkucast_storm_pkt_rate           - the unknowunicast storm packet rate
 * OUTPUT  : None
 * RETURN  : TRUE/FALSE
 * NOTE    : ES3626A MIB/unkucastStormMgt 1
 *------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetUnkucastStormPktRate(UI32_T ifindex, UI32_T unkucast_storm_pkt_rate)
{
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    SWCTRL_RETURN_AND_RELEASE_CSC( SWCTRL_SetUnknownUStormControlRateLimit(ifindex, VAL_unkucastStormSampleType_pkt_rate, unkucast_storm_pkt_rate) );
}


/*------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetUnkucastStormOctetRate
 *------------------------------------------------------------------------
 * FUNCTION: This function will Set tthe unknowunicast storm octet rate
 * INPUT   : ifindex                        - interface index
 *           unkucast_storm_octet_rate           - the unknowunicast storm octet rate
 * OUTPUT  : None
 * RETURN  : TRUE/FALSE
 * NOTE    : ES3626A MIB/unkucastStormMgt 1
 *------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetUnkucastStormOctetRate(UI32_T ifindex, UI32_T unkucast_storm_octet_rate)
{
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    SWCTRL_RETURN_AND_RELEASE_CSC( SWCTRL_SetUnknownUStormControlRateLimit(ifindex, VAL_unkucastStormSampleType_octet_rate, unkucast_storm_octet_rate) );
}


/*------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetUnkucastStormPercent
 *------------------------------------------------------------------------
 * FUNCTION: This function will Set tthe unknowunicast storm octet rate
 * INPUT   : ifindex                       - interface index
 *           unkucast_storm_percent           - the unknowunicast storm percent
 * OUTPUT  : None
 * RETURN  : TRUE/FALSE
 * NOTE    : ES3626A MIB/unkucastStormMgt 1
 *------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetUnkucastStormPercent(UI32_T ifindex, UI32_T unkucast_storm_percent)
{
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    SWCTRL_RETURN_AND_RELEASE_CSC( SWCTRL_SetUnknownUStormControlRateLimit(ifindex, VAL_unkucastStormSampleType_percent, unkucast_storm_percent) );
}
#endif /*#if (SYS_CPNT_STORM_MODE & SYS_CPNT_STORM_UNKNOWN_USTORM)*/


/*------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_ShutdownSwitch
 *------------------------------------------------------------------------
 * FUNCTION: This function will shutdown the switch before warm start
 * INPUT   : None
 * OUTPUT  : None
 * RETURN  : None
 * NOTE    :
 *------------------------------------------------------------------------*/
void SWCTRL_ShutdownSwitch(void)
{
    SWCTRL_USE_CSC_CHECK_OPER_MODE_WITHOUT_RETURN_VALUE();

    SWDRV_ShutdownSwitch();
    SWCTRL_RETURN_AND_RELEASE_CSC_WITHOUT_RETUEN_VALUE();

} /* end of SWCTRL_ShutdownSwitch */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_IsServerBladePort
 * -------------------------------------------------------------------------
 * FUNCTION:
 * INPUT   :
 * OUTPUT  :
 * RETURN  :
 * NOTE    :
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_IsServerBladePort (UI32_T ifindex)
{
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

#if (SYS_ADPT_SUPPORT_SERVER_BLADE == 1)
    if (SWCTRL_LogicalPortIsTrunkPort (ifindex))
    {
        UI32_T unit, port, trunk_id;

        trunk_id = SWCTRL_IFINDEX_TO_TRUNKID(ifindex);

        if (VAL_ifOperStatus_notPresent == port_info[ifindex-1].link_oper_status)
        {
            SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
        }

        if (0 == trunk_ext_port_info[trunk_id-1].member_number)
        {
            SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
        }

        /* first trunk member
         */
        unit = trunk_ext_port_info[trunk_id-1].member_list[0].unit;
        port = trunk_ext_port_info[trunk_id-1].member_list[0].port;

        ifindex = SWCTRL_UPORT_TO_IFINDEX(unit, port);
    }

    if ((ifindex >= SYS_ADPT_SERVER_BLADE_PORT_START) &&
        (ifindex <= SYS_ADPT_SERVER_BLADE_PORT_END))
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
    }
#endif
    SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
} /*end of SWCTRL_IsServerBladePort() */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_DisableIPMC
 * -------------------------------------------------------------------------
 * FUNCTION: This function will disable IPMC
 * INPUT   : None
 * OUTPUT  : None
 * RETURN  : True: Successfully, False: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_DisableIPMC(void)
{
    BOOL_T status=FALSE;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);
    status = SWDRV_DisableIPMC();

    if (status == FALSE)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_EnableIPMC
 * -------------------------------------------------------------------------
 * FUNCTION: This function will enable IPMC
 * INPUT   : None
 * OUTPUT  : None
 * RETURN  : True: Successfully, False: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_EnableIPMC(void)
{
    BOOL_T status=FALSE;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);
    status = SWDRV_EnableIPMC();

    if (status == FALSE)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
}

/*-------------------------------------------------------------------------
 * FUNCTION NAME - SWCTRL_DisableUMCASTIpTrap
 * ------------------------------------------------------------------------
 * PURPOSE  :   This funtion will disable trap unknown multicast ip
 * INPUT    :   None
 * OUTPUT   :   None
 * RETURN   :   TRUE/FALSE
 * NOTES    :   for XGS , disable IPMC , trap unknown ip or mcast packet
 * ------------------------------------------------------------------------
 */
BOOL_T SWCTRL_DisableUMCASTIpTrap(void)
{
    BOOL_T status=FALSE;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);
    status = SWDRV_DisableUMCASTIpTrap();

    if (status == FALSE)
    {
        /*UIMSG_MGR_SetErrorCode(); */
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
}

/*-------------------------------------------------------------------------
 * FUNCTION NAME - SWDRV_EnableUMCASTIpTrap
 * ------------------------------------------------------------------------
 * PURPOSE  :   This funtion will enable trap unknown multicast ip
 * INPUT    :   None
 * OUTPUT   :   None
 * RETURN   :   TRUE/FALSE
 * NOTES    :   for XGS , disable IPMC , trap unknown ip or mcast packet
 * ------------------------------------------------------------------------
 */
BOOL_T SWCTRL_EnableUMCASTIpTrap(void)
{
    BOOL_T status=FALSE;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);
    status = SWDRV_EnableUMCASTIpTrap();

    if (status == FALSE)
    {
        /*UIMSG_MGR_SetErrorCode(); */
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
}

/*-------------------------------------------------------------------------
 * FUNCTION NAME - SWCTRL_DisableUMCASTMacTrap
 * ------------------------------------------------------------------------
 * PURPOSE  :   This funtion will disable trap unknown multicast mac
 * INPUT    :   None
 * OUTPUT   :   None
 * RETURN   :   TRUE/FALSE
 * NOTES    :   for XGS , disable IPMC , trap unknown mac or mcast packet
 *              Aaron add, 2003/07/31
 * ------------------------------------------------------------------------
 */
BOOL_T SWCTRL_DisableUMCASTMacTrap(void)
{
    BOOL_T status=FALSE;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);
    status = SWDRV_DisableUMCASTMacTrap();

    if (status == FALSE)
    {
        /*UIMSG_MGR_SetErrorCode(); */
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
}

/*-------------------------------------------------------------------------
 * FUNCTION NAME - SWDRV_EnableUMCASTMacTrap
 * ------------------------------------------------------------------------
 * PURPOSE  :   This funtion will enable trap unknown multicast mac
 * INPUT    :   None
 * OUTPUT   :   None
 * RETURN   :   TRUE/FALSE
 * NOTES    :   for XGS , disable IPMC , trap unknown mac or mcast packet
 *              Aaron add, 2003/07/31
 * ------------------------------------------------------------------------
 */
BOOL_T SWCTRL_EnableUMCASTMacTrap(void)
{
    BOOL_T status=FALSE;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);
    status = SWDRV_EnableUMCASTMacTrap();

    if (status == FALSE)
    {
        /*UIMSG_MGR_SetErrorCode(); */
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
}

/*********************
 * Callback Processing
 *********************/

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_CallbackPreProcessor
 * -------------------------------------------------------------------------
 * FUNCTION: When SWDRV callback to SWCTRL, SWCTRL keep the data in paviate
 *           database and wait proper timing to process or decide to do
 *           some other action in advance.
 * INPUT   : unit -- in which unit
 *           port -- which port
 *           event -- which event
 *           data  -- data belong to this event
 * OUTPUT  : None
 * RETURN  : None
 * NOTE    : Callback from SWDRV.
 * -------------------------------------------------------------------------
 */
BOOL_T SWCTRL_CallbackPreProcessor(UI32_T event, UI32_T unit, UI32_T port, UI32_T data, UI32_T data2)
{
    UI32_T ifindex;

    ifindex = SWCTRL_UPORT_TO_IFINDEX(unit, port);

    switch(event)
    {
    case SWCTRL_CALLBACK_EVENT_PORT_LINKUP:
        /* fast callback to LED
         */
        SWCTRL_Notify_uPortFastLinkUp(unit, port);

        SWCTRL_CALLBACK_LOCK();
        user_port_changed_info[ifindex-1].changed_link_status = TRUE;
        user_port_changed_info[ifindex-1].link_status_dirty_time = SYS_TIME_GetSystemTicksBy10ms();
        SWCTRL_CALLBACK_UNLOCK();
        break;

    case SWCTRL_CALLBACK_EVENT_PORT_LINKDOWN:
        /* fast callback to LED
         */
        SWCTRL_Notify_uPortFastLinkDown(unit, port);

        SWCTRL_CALLBACK_LOCK();
        user_port_changed_info[ifindex-1].changed_link_status = FALSE;
        user_port_changed_info[ifindex-1].link_status_dirty_time = SYS_TIME_GetSystemTicksBy10ms();
        SWCTRL_CALLBACK_UNLOCK();
        break;

    case SWCTRL_CALLBACK_EVENT_PORT_TYPE_CHANGED:   /*with data*/
        SWCTRL_CALLBACK_LOCK();
        if (data != 0)
        {
            user_port_changed_info[ifindex-1].changed_module_id = data;
            user_port_changed_info[ifindex-1].module_id_dirty_time = SYS_TIME_GetSystemTicksBy10ms();
        }
        user_port_changed_info[ifindex-1].changed_port_type = data2;
        user_port_changed_info[ifindex-1].port_type_dirty_time = SYS_TIME_GetSystemTicksBy10ms();
        SWCTRL_CALLBACK_UNLOCK();
        break;

    case SWCTRL_CALLBACK_EVENT_PORT_SPEEDDUPLEX:    /*with data*/
        SWCTRL_CALLBACK_LOCK();
        user_port_changed_info[ifindex-1].changed_oper_speedduplex = data;
        user_port_changed_info[ifindex-1].oper_speedduplex_dirty_time = SYS_TIME_GetSystemTicksBy10ms();
        SWCTRL_CALLBACK_UNLOCK();
        break;

    case SWCTRL_CALLBACK_EVENT_PORT_FLOWCTRL:       /*with data*/
        SWCTRL_CALLBACK_LOCK();
        user_port_changed_info[ifindex-1].changed_oper_flowctrl = data;
        user_port_changed_info[ifindex-1].oper_flowctrl_dirty_time = SYS_TIME_GetSystemTicksBy10ms();
        SWCTRL_CALLBACK_UNLOCK();
        break;

#if (SYS_CPNT_SWDRV_MONITOR_SFP_DDM == TRUE)
    case SWCTRL_CALLBACK_EVENT_PORT_SFP_PRESENT:   /*with data*/
        SWCTRL_CALLBACK_LOCK();
        user_port_changed_info[ifindex-1].changed_sfp_present_status = (BOOL_T)data;
        user_port_changed_info[ifindex-1].sfp_present_status_dirty_time = SYS_TIME_GetSystemTicksBy10ms();
        SWCTRL_CALLBACK_UNLOCK();
        break;

    case SWCTRL_CALLBACK_EVENT_PORT_SFP_DDM_INFO_MEASURED:
        SWCTRL_CALLBACK_LOCK();
        user_port_changed_info[ifindex-1].sfp_ddm_measured_info_dirty_time = SYS_TIME_GetSystemTicksBy10ms();
        SWCTRL_CALLBACK_UNLOCK();
        break;
#endif

    default:
        return FALSE;
    }

    return TRUE;
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_CallbackPostProcessor
 * -------------------------------------------------------------------------
 * FUNCTION: To process the dirty event.
 * INPUT   : None.
 * OUTPUT  : None
 * RETURN  : TRUE   -- There are still dirty port need to process.
 *           FALSE  -- There is no dirty port need to process.
 * NOTE    : Call by SWCTRL_TASK.
 * -------------------------------------------------------------------------*/
SWCTRL_LinkScanReturnCode_T SWCTRL_CallbackPostProcessor(void)
{
    static UI32_T last_ifindex = 0;
    UI32_T                      ifindex;
    SWCTRL_ChangedStatusInfo_T  changed_info;
#if (SYS_CPNT_SWDRV_MONITOR_SFP_DDM == TRUE)
    UI32_T unit, port, trunk_id, sfp_index = 0;
    BOOL_T is_present = FALSE;
#endif

#if (SYS_CPNT_SWCTRL_PORT_PENDING_LINK_UP == TRUE)
    BOOL_T is_pending_dirty = FALSE;
#endif

    /* search first dirty port
     */
    SWCTRL_CALLBACK_LOCK();
    for (ifindex = last_ifindex + 1;
        ifindex <= (SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK*SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT);
        ifindex++)
    {
        /* The stacking port's 'link_status_dirty_time' will not be '0' in stacking mode.
         * So this loop will be broken when loop to stacking port.
         * And the stacking port's 'link_oper_status' will always be 'VAL_ifOperStatus_notPresent'
         * in stacking mode. This make the operation of link up/down will never execute and
         * the port link up/down failed in stacking mode.
         * Here we skip the port which 'link_oper_status' is 'VAL_ifOperStatus_notPresent' to resolve this issue.
         */
        if ((STKTPLG_PORT_TYPE_STACKING != port_info[ifindex-1].port_entry.port_type) &&
            (port_info[ifindex-1].link_oper_status == VAL_ifOperStatus_notPresent))
                continue;

        if ((user_port_changed_info[ifindex-1].port_type_dirty_time         != 0) ||
            (user_port_changed_info[ifindex-1].link_status_dirty_time       != 0) ||
            (user_port_changed_info[ifindex-1].oper_speedduplex_dirty_time  != 0) ||
            (user_port_changed_info[ifindex-1].sfp_present_status_dirty_time != 0) ||
            (user_port_changed_info[ifindex-1].sfp_ddm_measured_info_dirty_time != 0) ||
            (user_port_changed_info[ifindex-1].oper_flowctrl_dirty_time     != 0) )
        {
            /* got dirty port ifindex
             */
            memcpy(&changed_info,
                   &(user_port_changed_info[ifindex-1]),
                   sizeof(SWCTRL_ChangedStatusInfo_T) );
            break;
        }
    }
    SWCTRL_CALLBACK_UNLOCK();

    if (ifindex>SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK*SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT)
    {
        last_ifindex = 0;
        goto dirty_check;

    }

    last_ifindex = ifindex;

    /* I. for port type change
     */
    if (0 != changed_info.port_type_dirty_time)
    {
        UI32_T changed_module_id = 0;
        BOOL_T process_port_type_changed = FALSE;

        /* PortTypeChanged is significant even though value of either
         * module_id and port_type are not changed.
         * This event indicates that driver layer had updated hw interface
         * config and user-config may be reset, so swctrl must process it to
         * reapply user-config.
         */
        if (0 != changed_info.module_id_dirty_time)
        {
            changed_module_id = changed_info.changed_module_id;
            process_port_type_changed = TRUE;

            SWCTRL_CALLBACK_LOCK();
            user_port_changed_info[ifindex-1].module_id_dirty_time = 0;
            SWCTRL_CALLBACK_UNLOCK();
        }

        if (0 != changed_info.port_type_dirty_time)
        {
            process_port_type_changed = TRUE;

            /* return to zero and note update time
             */
            SWCTRL_CALLBACK_LOCK();
            user_port_changed_info[ifindex-1].port_type_updated_time = SYS_TIME_GetSystemTicksBy10ms();
            user_port_changed_info[ifindex-1].port_type_dirty_time = 0;
            SWCTRL_CALLBACK_UNLOCK();
        }
        else
        {
            SWCTRL_CALLBACK_LOCK();
            user_port_changed_info[ifindex-1].port_type_dirty_time = 0;
            SWCTRL_CALLBACK_UNLOCK();
        }

        /* port type changed even might be triggered by module insert,
         * so it is neccessary to reinit port even though port type is not changed.
         */
        if (process_port_type_changed)
        {
            SWCTRL_ProcessPortTypeChanged(SWCTRL_IFINDEX_TO_UNIT(ifindex), SWCTRL_IFINDEX_TO_PORT(ifindex), changed_module_id, changed_info.changed_port_type);
        }
    }

    /* To enhance link up trap event to log speed-duplex info when port link up,
     * speed-duplex must be updated before link status.
     */
    /* III. for oper speed-duplex change
     */
    if (0 != changed_info.oper_speedduplex_dirty_time)
    {
        if ((changed_info.changed_oper_speedduplex == VAL_portSpeedDpxStatus_fullDuplex10g)
            ||(changed_info.changed_oper_speedduplex != port_info[ifindex-1].port_entry.port_speed_dpx_status))
        {
            /* return to zero and note update time
             */
            SWCTRL_CALLBACK_LOCK();
            user_port_changed_info[ifindex-1].oper_speedduplex_updated_time = SYS_TIME_GetSystemTicksBy10ms();
            user_port_changed_info[ifindex-1].oper_speedduplex_dirty_time = 0;
            SWCTRL_CALLBACK_UNLOCK();

            SWCTRL_ProcessPortSpeedDuplexChanged(SWCTRL_IFINDEX_TO_UNIT(ifindex), SWCTRL_IFINDEX_TO_PORT(ifindex), changed_info.changed_oper_speedduplex);
        }
        else
        {
            SWCTRL_CALLBACK_LOCK();
            user_port_changed_info[ifindex-1].oper_speedduplex_dirty_time = 0;
            SWCTRL_CALLBACK_UNLOCK();
        }
    }

    /* II. for link up/down
     */
    if (0 != changed_info.link_status_dirty_time)
    {
        if (VAL_ifOperStatus_lowerLayerDown == port_info[ifindex-1].link_oper_status)
        {
#if (SYS_CPNT_SWCTRL_PORT_PENDING_LINK_UP == TRUE)
            if (port_info[ifindex-1].link_status_pending_up_status)
            {
                if (changed_info.changed_link_status)
                {
                    if (user_port_changed_info[ifindex-1].link_status_pending_up_dirty_time == 0 ||
                        user_port_changed_info[ifindex-1].link_status_pending_up_dirty_time !=
                            user_port_changed_info[ifindex-1].link_status_dirty_time)
                    {
                        /* new link up event,
                         * shall start pending link up timer.
                         */

                        SWCTRL_CALLBACK_LOCK();
                        user_port_changed_info[ifindex-1].link_status_pending_up_dirty_time =
                            user_port_changed_info[ifindex-1].link_status_dirty_time;
                        SWCTRL_CALLBACK_UNLOCK();

                        SWCTRL_ProcessPortPendingLinkUp(SWCTRL_IFINDEX_TO_UNIT(ifindex), SWCTRL_IFINDEX_TO_PORT(ifindex));
                    }
                    else if (port_info[ifindex-1].link_status_pending_up_expired_time == 0)
                    {
                        /* pending link up timer expired,
                         * it's time to process link up.
                         */

                        SWCTRL_CALLBACK_LOCK();
                        user_port_changed_info[ifindex-1].link_status_updated_time = SYS_TIME_GetSystemTicksBy10ms();
                        user_port_changed_info[ifindex-1].link_status_dirty_time = 0;
                        user_port_changed_info[ifindex-1].link_status_pending_up_dirty_time = 0;
                        SWCTRL_CALLBACK_UNLOCK();

                        SWCTRL_ProcessPortLinkUp(SWCTRL_IFINDEX_TO_UNIT(ifindex), SWCTRL_IFINDEX_TO_PORT(ifindex));
                    }
                    else
                    {
                        /* pending link up timer is started and not expired,
                         * do nothing.
                         */
                        ;
                    }
                }
                else
                {
                    SWCTRL_CALLBACK_LOCK();
                    user_port_changed_info[ifindex-1].link_status_dirty_time = 0;
                    user_port_changed_info[ifindex-1].link_status_pending_up_dirty_time = 0;
                    SWCTRL_CALLBACK_UNLOCK();
                }
            }
            else
#endif
            /* link down
             */
            if (TRUE == changed_info.changed_link_status)
            {
                /* note update time
                 */
                SWCTRL_CALLBACK_LOCK();
                user_port_changed_info[ifindex-1].link_status_updated_time = SYS_TIME_GetSystemTicksBy10ms();
                user_port_changed_info[ifindex-1].link_status_dirty_time = 0;
                SWCTRL_CALLBACK_UNLOCK();

                /* down to up
                 */
                SWCTRL_ProcessPortLinkUp(SWCTRL_IFINDEX_TO_UNIT(ifindex), SWCTRL_IFINDEX_TO_PORT(ifindex));
            }
            else
            {
                /* check timing
                 */
                if (changed_info.link_status_dirty_time - changed_info.link_status_updated_time >= SWCTRL_DIRTY_LATENCY_TORENCE)
                {
                    /* down to up to down
                     */
                    SWCTRL_CALLBACK_LOCK();
                    /* note update time
                     */
                    user_port_changed_info[ifindex-1].link_status_updated_time = SYS_TIME_GetSystemTicksBy10ms();

                    /* make this port dirty, and wait for next turn to process
                     */
                    user_port_changed_info[ifindex-1].link_status_dirty_time = SYS_TIME_GetSystemTicksBy10ms();
                    SWCTRL_CALLBACK_UNLOCK();

                    /* down to up
                     */
                    SWCTRL_ProcessPortLinkUp(SWCTRL_IFINDEX_TO_UNIT(ifindex), SWCTRL_IFINDEX_TO_PORT(ifindex));

                }
                else
                {
                    /* not longer that torence time, and state is the same: ignore transition
                     */
                    SWCTRL_CALLBACK_LOCK();
                    user_port_changed_info[ifindex-1].link_status_dirty_time = 0;
                    SWCTRL_CALLBACK_UNLOCK();
                }
            }
        }
        else if (VAL_ifOperStatus_notPresent != port_info[ifindex-1].link_oper_status)
        {
            /* not lowerLayerDown and not notPresent: link up
             */
            if (FALSE == changed_info.changed_link_status)
            {
                /* note update time
                 */
                SWCTRL_CALLBACK_LOCK();
                user_port_changed_info[ifindex-1].link_status_updated_time = SYS_TIME_GetSystemTicksBy10ms();
                user_port_changed_info[ifindex-1].link_status_dirty_time = 0;
                SWCTRL_CALLBACK_UNLOCK();

                /* up to down
                 */
                SWCTRL_ProcessPortLinkDown(SWCTRL_IFINDEX_TO_UNIT(ifindex), SWCTRL_IFINDEX_TO_PORT(ifindex));
            }
            else
            {
                /* check timing
                 */
                if (changed_info.link_status_dirty_time - changed_info.link_status_updated_time >= SWCTRL_DIRTY_LATENCY_TORENCE)
                {
                    /* up to down to up
                     */
                    SWCTRL_CALLBACK_LOCK();
                    /* note update time
                     */
                    user_port_changed_info[ifindex-1].link_status_updated_time = SYS_TIME_GetSystemTicksBy10ms();

                    /* make this port dirty, and wait for next turn to process
                     */
                    user_port_changed_info[ifindex-1].link_status_dirty_time = SYS_TIME_GetSystemTicksBy10ms();
                    SWCTRL_CALLBACK_UNLOCK();

                    /* up to down
                     */
                    SWCTRL_ProcessPortLinkDown(SWCTRL_IFINDEX_TO_UNIT(ifindex), SWCTRL_IFINDEX_TO_PORT(ifindex));
                }
                else
                {
                    /* not longer that torence time, and state is the same: ignore transition
                     */
                    SWCTRL_CALLBACK_LOCK();
                    user_port_changed_info[ifindex-1].link_status_dirty_time = 0;
                    SWCTRL_CALLBACK_UNLOCK();
                }

            }
        }
        else
        if(STKTPLG_PORT_TYPE_STACKING == port_info[ifindex-1].port_entry.port_type)
        {
            /*to stack port, port_type is not present,so deal with stack port especially*/
            switch(changed_info.changed_link_status)
            {
                case TRUE:
                        if (VAL_ifOperStatus_notPresent == port_info[ifindex-1].link_oper_status)
                        {
                            SWCTRL_CALLBACK_LOCK();
                            user_port_changed_info[ifindex-1].link_status_updated_time = SYS_TIME_GetSystemTicksBy10ms();
                            user_port_changed_info[ifindex-1].link_status_dirty_time = 0;
                            SWCTRL_CALLBACK_UNLOCK();
                            /* stack port,light LED,use this interface ,different other ports */
                          SWCTRL_Notify_uPortLinkUp(SWCTRL_IFINDEX_TO_UNIT(ifindex), SWCTRL_IFINDEX_TO_PORT(ifindex));
                        }
                        else
                        {
                            /* check timing
                             */
                            if (changed_info.link_status_dirty_time - changed_info.link_status_updated_time >= SWCTRL_DIRTY_LATENCY_TORENCE)
                            {
                                /* down to up to down
                                 */
                                SWCTRL_CALLBACK_LOCK();
                                /* note update time
                                 */
                                user_port_changed_info[ifindex-1].link_status_updated_time = SYS_TIME_GetSystemTicksBy10ms();

                                /* make this port dirty, and wait for next turn to process
                                 */
                                user_port_changed_info[ifindex-1].link_status_dirty_time = SYS_TIME_GetSystemTicksBy10ms();
                                SWCTRL_CALLBACK_UNLOCK();

                                /* down to up
                                 */
                                /* stack port,light LED,use this interface ,different other ports */
                              SWCTRL_Notify_uPortLinkUp(SWCTRL_IFINDEX_TO_UNIT(ifindex), SWCTRL_IFINDEX_TO_PORT(ifindex));

                            }
                            else
                            {
                                /* not longer that torence time, and state is the same: ignore transition
                                 */
                                SWCTRL_CALLBACK_LOCK();
                                user_port_changed_info[ifindex-1].link_status_dirty_time = 0;
                                SWCTRL_CALLBACK_UNLOCK();
                            }
                         }
                        break;
                case FALSE:
                        if (VAL_ifOperStatus_notPresent == port_info[ifindex-1].link_oper_status)
                        {
                            SWCTRL_CALLBACK_LOCK();
                            user_port_changed_info[ifindex-1].link_status_updated_time = SYS_TIME_GetSystemTicksBy10ms();
                            user_port_changed_info[ifindex-1].link_status_dirty_time = 0;
                            SWCTRL_CALLBACK_UNLOCK();
                             /* stack port,close LED,use this interface ,different other ports */
                            SWCTRL_Notify_uPortLinkDown(SWCTRL_IFINDEX_TO_UNIT(ifindex), SWCTRL_IFINDEX_TO_PORT(ifindex));
                        }
                        else
                        {
                            /* check timing
                             */
                            if (changed_info.link_status_dirty_time - changed_info.link_status_updated_time >= SWCTRL_DIRTY_LATENCY_TORENCE)
                            {
                                /* up to down to up
                                 */
                                SWCTRL_CALLBACK_LOCK();
                                /* note update time
                                 */
                                user_port_changed_info[ifindex-1].link_status_updated_time = SYS_TIME_GetSystemTicksBy10ms();

                                /* make this port dirty, and wait for next turn to process
                                 */
                                user_port_changed_info[ifindex-1].link_status_dirty_time = SYS_TIME_GetSystemTicksBy10ms();
                                SWCTRL_CALLBACK_UNLOCK();

                                /* up to down
                                 */
                                /* stack port,close LED,use this interface ,different other ports */
                               SWCTRL_Notify_uPortLinkDown(SWCTRL_IFINDEX_TO_UNIT(ifindex), SWCTRL_IFINDEX_TO_PORT(ifindex));
                            }
                            else
                            {
                             /* not longer that torence time, and state is the same: ignore transition
                                 */
                                SWCTRL_CALLBACK_LOCK();
                                user_port_changed_info[ifindex-1].link_status_dirty_time = 0;
                                SWCTRL_CALLBACK_UNLOCK();
                            }
                         }
                        break;
                default:
                        break;
            }
        }
    }

    /* IV. for oper flowcontrol change
     */
    if (0 != changed_info.oper_flowctrl_dirty_time)
    {
        if (changed_info.changed_oper_flowctrl != port_info[ifindex-1].port_entry.port_flow_ctrl_status)
        {
            /* return to zero and note update time
             */
            SWCTRL_CALLBACK_LOCK();
            user_port_changed_info[ifindex-1].oper_flowctrl_updated_time = SYS_TIME_GetSystemTicksBy10ms();
            user_port_changed_info[ifindex-1].oper_flowctrl_dirty_time = 0;
            SWCTRL_CALLBACK_UNLOCK();

            SWCTRL_ProcessPortFlowCtrlChanged(SWCTRL_IFINDEX_TO_UNIT(ifindex), SWCTRL_IFINDEX_TO_PORT(ifindex), changed_info.changed_oper_flowctrl);
        }
        else
        {
            SWCTRL_CALLBACK_LOCK();
            user_port_changed_info[ifindex-1].oper_flowctrl_dirty_time = 0;
            SWCTRL_CALLBACK_UNLOCK();
        }
    }

#if (SYS_CPNT_SWDRV_MONITOR_SFP_DDM == TRUE)
    /* V. for sfp present status change
     *    sfp ddm measured info change
     */
    if(SWCTRL_LPORT_UNKNOWN_PORT == SWCTRL_LogicalPortToUserPort(ifindex, &unit, &port, &trunk_id))
        return SWCTRL_LINKSCAN_E_ERROR;

    if(TRUE == STKTPLG_POM_UserPortToSfpIndex(unit, port, &sfp_index))
    {
        if (0 != changed_info.sfp_present_status_dirty_time)
        {
            SWCTRL_GetPortSfpPresent(unit, sfp_index, &is_present);
            if (changed_info.changed_sfp_present_status != is_present)
            {
                /* return to zero and note update time
                 */
                SWCTRL_CALLBACK_LOCK();
                user_port_changed_info[ifindex-1].sfp_present_status_updated_time = SYS_TIME_GetSystemTicksBy10ms();
                user_port_changed_info[ifindex-1].sfp_present_status_dirty_time = 0;
                SWCTRL_CALLBACK_UNLOCK();

                SWCTRL_SetPortSfpPresent(unit, sfp_index, changed_info.changed_sfp_present_status);
            #if (SYS_CPNT_SFP_DDM_ALARMWARN_TRAP == TRUE)
                /* when first present, reset pre_rx_loss status */
                if(TRUE == changed_info.changed_sfp_present_status)
                    pre_rx_loss[unit-1][sfp_index-1] = TRUE;
                else
                    SWCTRL_ProcessPortSfpDdmThresholdMeasuredInfoChanged(unit, sfp_index, TRUE);
            #endif
            }
            else
            {
                SWCTRL_CALLBACK_LOCK();
                user_port_changed_info[ifindex-1].sfp_present_status_dirty_time = 0;
                SWCTRL_CALLBACK_UNLOCK();
            }

        }

        if (0 != changed_info.sfp_ddm_measured_info_dirty_time)
        {
        #if (SYS_CPNT_SFP_DDM_ALARMWARN_TRAP == TRUE)
            SWCTRL_ProcessPortSfpDdmThresholdMeasuredInfoChanged(unit, sfp_index, FALSE);
        #endif
            SWCTRL_CALLBACK_LOCK();
            user_port_changed_info[ifindex-1].sfp_ddm_measured_info_dirty_time = 0;
            SWCTRL_CALLBACK_UNLOCK();
        }
    }
#endif /* #if (SYS_CPNT_SWDRV_MONITOR_SFP_DDM == TRUE) */

dirty_check:
    /* still have dirty status?
     */
    SWCTRL_CALLBACK_LOCK();
    for(ifindex = 1;
        ifindex<= SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK*SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT;
        ifindex++)
    {
        /* The stacking port's 'link_status_dirty_time' will not be '0' in stacking mode.
         * So this loop will be broken when loop to stacking port.
         * And the stacking port's 'link_oper_status' will always be 'VAL_ifOperStatus_notPresent'
         * in stacking mode. This make the operation of link up/down will never execute and
         * the port link up/down failed in stacking mode.
         * Here we skip the port which 'link_oper_status' is 'VAL_ifOperStatus_notPresent' to resolve this issue.
         */
        if ((STKTPLG_PORT_TYPE_STACKING != port_info[ifindex-1].port_entry.port_type) &&
            (port_info[ifindex-1].link_oper_status == VAL_ifOperStatus_notPresent))
            continue;

        if ((user_port_changed_info[ifindex-1].port_type_dirty_time         != 0) ||
#if (SYS_CPNT_SWCTRL_PORT_PENDING_LINK_UP != TRUE)
            (user_port_changed_info[ifindex-1].link_status_dirty_time       != 0) ||
#endif
            (user_port_changed_info[ifindex-1].oper_speedduplex_dirty_time  != 0) ||
            (user_port_changed_info[ifindex-1].sfp_present_status_dirty_time != 0) ||
            (user_port_changed_info[ifindex-1].sfp_ddm_measured_info_dirty_time != 0) ||
            (user_port_changed_info[ifindex-1].oper_flowctrl_dirty_time     != 0) )
        {
            /* yes, still have dirty port
             */
            SWCTRL_CALLBACK_UNLOCK();
            return SWCTRL_LINKSCAN_E_DIRTY;
        }

#if (SYS_CPNT_SWCTRL_PORT_PENDING_LINK_UP == TRUE)
        if (user_port_changed_info[ifindex-1].link_status_dirty_time != 0)
        {
            if (port_info[ifindex-1].link_status_pending_up_status)
            {
                if (user_port_changed_info[ifindex-1].link_status_pending_up_dirty_time != 0)
                {
                    is_pending_dirty = TRUE;
                    continue;
        }
    }

            /* yes, still have dirty port
             */
    SWCTRL_CALLBACK_UNLOCK();
            return SWCTRL_LINKSCAN_E_DIRTY;
        }
#endif
    }

#if (SYS_CPNT_SWCTRL_PORT_PENDING_LINK_UP == TRUE)
    if (is_pending_dirty)
    {
        SWCTRL_CALLBACK_UNLOCK();
        return SWCTRL_LINKSCAN_E_PENDING_DIRTY;
    }
#endif

    SWCTRL_CALLBACK_UNLOCK();
    return SWCTRL_LINKSCAN_E_NO_DIRTY;
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_ProcessPortLinkUp
 * -------------------------------------------------------------------------
 * FUNCTION: Do all actions related to port link up
 * INPUT   : unit -- in which unit
 *           port -- which port
 * OUTPUT  : None
 * RETURN  : None
 * NOTE    : None
 * -------------------------------------------------------------------------*/
void SWCTRL_ProcessPortLinkUp(UI32_T unit, UI32_T port)
{
    UI32_T ifindex = SWCTRL_UPORT_TO_IFINDEX (unit, port);
    UI32_T trunk_id, trunk_ifindex;
    TRAP_EVENT_TrapData_T     trap_data;
    UI32_T                    trap_style;

    BOOL_T  isTrunkMember = SWCTRL_IS_TRUNK_MEMBER (ifindex);

    SWCTRL_USE_CSC_CHECK_OPER_MODE_WITHOUT_RETURN_VALUE();

    port_info[ifindex-1].bandwidth =
        SWCTRL_PORT_BANDWIDTH(port_info[ifindex-1].port_entry.port_speed_dpx_status);

    /* Call back notification
     */
    SWCTRL_LinkOperStateMachineChangeState (ifindex, SWCTRL_LINK_UP_EVENT);

    if(isTrunkMember)
    {
        trunk_id = port_info[ifindex-1].port_entry.port_trunk_index;
        trunk_ifindex = SWCTRL_TRUNKID_TO_IFINDEX (trunk_id);

        SWCTRL_LOCK();
        /* because SWDRV accept link up and sorted member port list,
         * we must process that if port link up/down
         */
        SWCTRL_SetTrunkPorts(trunk_id,
                             trunk_ext_port_info[trunk_id-1].member_number,
                             trunk_ext_port_info[trunk_id-1].member_list);
        SWCTRL_UNLOCK();

        SWCTRL_LinkOperStateMachineChangeState (trunk_ifindex, SWCTRL_LOWER_LAYER_CHANGED_EVENT);
    } /* End of trunk member */

#if (SYS_CPNT_SWCTRL_PORT_PENDING_LINK_UP != TRUE)
#if (SYS_CPNT_POWER_SAVE == TRUE)
    if (user_ext_port_info[ifindex-1].power_save_admin_status == VAL_portPowerSave_enabled)
    {
        BOOL_T is_forced = FALSE;

        /* if speed is differnt, shall reconfig power saving again,
         * so that driver can config for current speed.
         */
        if (user_ext_port_info[ifindex-1].power_save_oper_status == VAL_portPowerSave_enabled)
        {
            is_forced = user_ext_port_info[ifindex-1].power_save_speed_duplex != port_info[ifindex-1].port_entry.port_speed_dpx_status;
        }

        SWCTRL_SetUPortPowerSave(unit, port, VAL_portPowerSave_enabled, is_forced);
    }
#endif
#endif

#if (SYS_CPNT_SWCTRL_FEC == TRUE)
    if (SWCTRL_IsPortFecSupported(ifindex, VAL_portFecMode_baseR) ||
        SWCTRL_IsPortFecSupported(ifindex, VAL_portFecMode_rs))
    {
        SWCTRL_LOCK();
        if (!SWDRV_GetPortFecStatus(unit, port, &user_ext_port_info[ifindex-1].port_fec_status))
        {
            user_ext_port_info[ifindex-1].port_fec_status = VAL_portFecMode_disabled;
        }
        SWCTRL_UNLOCK();
    }
#endif

    SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME();
    SWCTRL_RETURN_AND_RELEASE_CSC_WITHOUT_RETUEN_VALUE();

} /* End of SWCTRL_ProcessPortLinkUp() */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_ProcessPortLinkDown
 * -------------------------------------------------------------------------
 * FUNCTION: Do all actions related to port link down
 * INPUT   : unit -- in which unit
 *           port -- which port
 * OUTPUT  : None
 * RETURN  : None
 * NOTE    : None
 * -------------------------------------------------------------------------*/
void SWCTRL_ProcessPortLinkDown(UI32_T unit,
                                UI32_T port)
{
    UI32_T ifindex = SWCTRL_UPORT_TO_IFINDEX (unit, port);
    UI32_T trunk_id;
    UI32_T trunk_ifindex = 0;
    UI32_T trunk_old_state, trunk_new_state;
    UI32_T trunk_old_level, trunk_new_level;
    BOOL_T is_trunk_oper_changed;
    BOOL_T is_trunk_forwarding_originally = FALSE;
    BOOL_T isTrunkMember                = FALSE;
    UI32_T old_state, new_state;
    UI32_T old_level, new_level;
    TRAP_EVENT_TrapData_T     trap_data;
    UI32_T                    trap_style;

    SWCTRL_USE_CSC_CHECK_OPER_MODE_WITHOUT_RETURN_VALUE();

    /* Begin processing */
    SWCTRL_LOCK();

    isTrunkMember = SWCTRL_IS_TRUNK_MEMBER (ifindex);
    /* get STA state before all other callback
     */
    if (isTrunkMember)
    {
        trunk_id = port_info[ifindex-1].port_entry.port_trunk_index;
        trunk_ifindex = SWCTRL_TRUNKID_TO_IFINDEX (trunk_id);

        /* By SA's instruction, don't care MSTP case now, so instance is hard code: 0
         */
        is_trunk_forwarding_originally = XSTP_OM_IsPortForwardingStateByInstance(0, trunk_ifindex);
    }

    port_info[ifindex-1].bandwidth = 0;

    if (FALSE == SWCTRL_ProcessLinkOperStateMachine(ifindex, SWCTRL_LINK_DOWN_EVENT, &old_state, &new_state, &old_level, &new_level, FALSE))
    {
        SWCTRL_UNLOCK();
        SWCTRL_RETURN_AND_RELEASE_CSC_WITHOUT_RETUEN_VALUE();
    }
    SWCTRL_ProcessLinkOperStatusChangePostproc(ifindex, SWCTRL_LINK_DOWN_EVENT, old_state, new_state, old_level, new_level, FALSE);

    if (isTrunkMember)
    {
        /* because SWDRV accept link up and sorted member port list,
         * we must process that if port link up/down
         */
        SWCTRL_SetTrunkPorts(trunk_id,
                             trunk_ext_port_info[trunk_id-1].member_number,
                             trunk_ext_port_info[trunk_id-1].member_list);

        is_trunk_oper_changed = SWCTRL_ProcessLinkOperStateMachine(trunk_ifindex, SWCTRL_LOWER_LAYER_CHANGED_EVENT, &trunk_old_state, &trunk_new_state, &trunk_old_level, &trunk_new_level, FALSE);

        if (is_trunk_oper_changed)
        {
            SWCTRL_ProcessLinkOperStatusChangePostproc(trunk_ifindex, SWCTRL_LOWER_LAYER_CHANGED_EVENT, trunk_old_state, trunk_new_state, trunk_old_level, trunk_new_level, FALSE);
        }
    } /* End of trunk member */

    SWCTRL_UNLOCK();
    /* End processing */

    /* Callback notification for Link oper_status changed */
    SWCTRL_ProcessLinkOperStatusChangeNotifying(ifindex, unit, port, SWCTRL_LINK_DOWN_EVENT, old_state, new_state, old_level, new_level);

    if(isTrunkMember)
    {
        if (is_trunk_oper_changed)
        {
            SWCTRL_ProcessLinkOperStatusChangeNotifying(trunk_ifindex, 0, 0, SWCTRL_LOWER_LAYER_CHANGED_EVENT, trunk_old_state, trunk_new_state, trunk_old_level, trunk_new_level);
        }
    }

    if (is_trunk_forwarding_originally)
    {
        SWCTRL_Notify_ForwardingTrunkMemberToNonForwarding(trunk_ifindex, ifindex);
    }

#if (SYS_CPNT_POWER_SAVE == TRUE)
    if (user_ext_port_info[ifindex-1].power_save_admin_status == VAL_portPowerSave_enabled &&
        user_ext_port_info[ifindex-1].power_save_oper_status == VAL_portPowerSave_enabled)
    {
        SWCTRL_ProcessPortLinkDownForPowerSave(ifindex);
    }
#endif

    SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME();
    SWCTRL_RETURN_AND_RELEASE_CSC_WITHOUT_RETUEN_VALUE();

} /* End of SWCTRL_ProcessPortLinkDown() */



/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_ProcessCraftPortLinkUp
 * -------------------------------------------------------------------------
 * FUNCTION: Do all actions related to port link up
 * INPUT   : unit -- in which unit
 * OUTPUT  : None
 * RETURN  : None
 * NOTE    : None
 * -------------------------------------------------------------------------*/
void SWCTRL_ProcessCraftPortLinkUp(UI32_T unit)
{
    TRAP_EVENT_TrapData_T     trap_data;

    SWCTRL_USE_CSC_CHECK_OPER_MODE_WITHOUT_RETURN_VALUE();

    /* send trap */
    trap_data.trap_type = TRAP_EVENT_CRAFT_PORT_LINK_UP;
    trap_data.community_specified = FALSE;

    trap_data.u.craft_link_up.unit_id = unit;

#if (SYS_CPNT_TRAPMGMT == TRUE)
            TRAP_MGR_ReqSendTrapOptional(&trap_data, TRAP_EVENT_SEND_TRAP_OPTION_LOG_AND_TRAP);
#else
            SNMP_PMGR_ReqSendTrapOptional(&trap_data, TRAP_EVENT_SEND_TRAP_OPTION_LOG_AND_TRAP);
#endif

    SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME();
    SWCTRL_RETURN_AND_RELEASE_CSC_WITHOUT_RETUEN_VALUE();

} /* End of SWCTRL_ProcessCraftPortLinkUp() */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_ProcessCraftPortLinkDown
 * -------------------------------------------------------------------------
 * FUNCTION: Do all actions related to port link down
 * INPUT   : unit -- in which unit
 * OUTPUT  : None
 * RETURN  : None
 * NOTE    : None
 * -------------------------------------------------------------------------*/
void SWCTRL_ProcessCraftPortLinkDown(UI32_T unit)
{
    TRAP_EVENT_TrapData_T     trap_data;

    SWCTRL_USE_CSC_CHECK_OPER_MODE_WITHOUT_RETURN_VALUE();

    /* send trap */
    trap_data.trap_type = TRAP_EVENT_CRAFT_PORT_LINK_DOWN;
    trap_data.community_specified = FALSE;

    trap_data.u.craft_link_up.unit_id = unit;

#if (SYS_CPNT_TRAPMGMT == TRUE)
            TRAP_MGR_ReqSendTrapOptional(&trap_data, TRAP_EVENT_SEND_TRAP_OPTION_LOG_AND_TRAP);
#else
            SNMP_PMGR_ReqSendTrapOptional(&trap_data, TRAP_EVENT_SEND_TRAP_OPTION_LOG_AND_TRAP);
#endif

    SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME();
    SWCTRL_RETURN_AND_RELEASE_CSC_WITHOUT_RETUEN_VALUE();

} /* End of SWCTRL_ProcessCraftPortLinkDown() */

#if (SYS_CPNT_SWCTRL_PORT_PENDING_LINK_UP == TRUE)
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_PortPendingLinkUpCheck
 * -------------------------------------------------------------------------
 * FUNCTION: This function will process pending link up.
 * INPUT   : ifindex
 * OUTPUT  : None
 * RETURN  : True: Successfully, False: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
static void SWCTRL_PortPendingLinkUpCheck(void *arg)
{
    BOOL_T *task_is_created_p = arg;
    UI32_T ifindex;
    UI32_T sys_tick;
    UI32_T wait_events = 0;
    UI32_T received_events = 0;
    UI32_T num_of_ports_to_check;
    void *timer_id;

    if ((timer_id = SYSFUN_PeriodicTimer_Create()) == NULL)
    {
        return;
    }

    SYSFUN_PeriodicTimer_Start(timer_id, SYS_BLD_TICKS_PER_SECOND, BIT_0);
    wait_events |= BIT_0;

    while (1)
    {
        SYSFUN_ReceiveEvent(
            wait_events,
            SYSFUN_EVENT_WAIT_ANY,
            SYSFUN_TIMEOUT_WAIT_FOREVER,
            &received_events);

        if (SYSFUN_GET_CSC_OPERATING_MODE() != SYS_TYPE_STACKING_MASTER_MODE)
        {
            break;
        }

        sys_tick = SYS_TIME_GetSystemTicksBy10ms();
        num_of_ports_to_check = 0;

        /* NOTE:
         *   this lock/unlock is necessay for power_save_check_ticks.
         *   it maybe lead to performance issue if too many ports
         *   need to be checked.
         */
        SWCTRL_LOCK();

        for (ifindex = 1; ifindex <= SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK * SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT; ifindex++)
        {
            if (!SWCTRL_IS_EXIST(ifindex))
            {
                continue;
            }

            if (user_port_changed_info[ifindex-1].link_status_pending_up_dirty_time == 0)
            {
                continue;
            }

            if (port_info[ifindex-1].link_status_pending_up_expired_time == 0)
            {
                continue;
            }

            if (!L_MATH_TimeOut32(sys_tick, port_info[ifindex-1].link_status_pending_up_expired_time))
            {
                num_of_ports_to_check++;
                continue;
            }

            port_info[ifindex-1].link_status_pending_up_expired_time = 0;
        }

        if (num_of_ports_to_check == 0)
        {
            break;
        }

        SWCTRL_UNLOCK();
    }

    SYSFUN_PeriodicTimer_Destroy(timer_id);

    *task_is_created_p = FALSE;

    SWCTRL_UNLOCK();
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_ProcessPortPendingLinkUp
 * -------------------------------------------------------------------------
 * FUNCTION: Do all actions related to port pending link up
 * INPUT   : unit -- in which unit
 *           port -- which port
 * OUTPUT  : None
 * RETURN  : None
 * NOTE    : None
 * -------------------------------------------------------------------------*/
static void SWCTRL_ProcessPortPendingLinkUp(UI32_T unit, UI32_T port)
{
    static BOOL_T task_is_created;

    UI32_T ifindex = SWCTRL_UPORT_TO_IFINDEX (unit, port);
    UI32_T link_up_delay_time=SYS_ADPT_SWCTRL_PORT_PENDING_LINK_UP_DELAY_TIME_FOR_DFLTCFG;

    SWCTRL_USE_CSC_CHECK_OPER_MODE_WITHOUT_RETURN_VALUE();

    SWCTRL_LOCK();

    if (0 == (port_info[ifindex-1].link_status_pending_up_status & ~ SWCTRL_PORT_PENDING_LINKUP_OWNER__DFLT_CFG))
    {
        link_up_delay_time=SYS_ADPT_SWCTRL_PORT_PENDING_LINK_UP_DELAY_TIME_FOR_DFLTCFG;
    }
    else
    {
        link_up_delay_time=SYS_ADPT_SWCTRL_PORT_PENDING_LINK_UP_DELAY_TIME_FOR_ENABLED;
    }

#if defined(SYS_ADPT_SWCTRL_PORT_PENDING_LINK_UP_DELAY_TIME_FOR_10G_SFP_PORT)
    if(SWCTRL_IS_10GSFP(ifindex))
    {
        link_up_delay_time=SYS_ADPT_SWCTRL_PORT_PENDING_LINK_UP_DELAY_TIME_FOR_10G_SFP_PORT;
    }
#endif

    port_info[ifindex-1].link_status_pending_up_expired_time =
        user_port_changed_info[ifindex-1].link_status_pending_up_dirty_time +
        link_up_delay_time;

    if (!task_is_created)
    {
        UI32_T task_id;
        BOOL_T ret;

        ret = SYSFUN_SpawnThread(
                SYS_BLD_PROCESS_DEFAULT_PRIORITY,
                SYS_BLD_PROCESS_DEFAULT_SCHED_POLICY,
                "PendingLinkUp",
                SYS_BLD_TASK_COMMON_STACK_SIZE,
                SYSFUN_TASK_NO_FP,
                SWCTRL_PortPendingLinkUpCheck,
                &task_is_created,
                &task_id) == SYSFUN_OK;

        if (ret)
        {
            task_is_created = TRUE;
        }
    }

    SWCTRL_UNLOCK();

#if (SYS_CPNT_POWER_SAVE == TRUE)
    if (user_ext_port_info[ifindex-1].power_save_admin_status == VAL_portPowerSave_enabled)
    {
        BOOL_T is_forced = FALSE;

        /* if speed is differnt, shall reconfig power saving again,
         * so that driver can config for current speed.
         */
        if (user_ext_port_info[ifindex-1].power_save_oper_status == VAL_portPowerSave_enabled)
        {
            is_forced = user_ext_port_info[ifindex-1].power_save_speed_duplex != port_info[ifindex-1].port_entry.port_speed_dpx_status;
        }

        SWCTRL_SetUPortPowerSave(unit, port, VAL_portPowerSave_enabled, is_forced);
    }
#endif

    SWCTRL_RETURN_AND_RELEASE_CSC_WITHOUT_RETUEN_VALUE();

} /* End of SWCTRL_ProcessPortPendingLinkUp() */
#endif /* (SYS_CPNT_SWCTRL_PORT_PENDING_LINK_UP == TRUE) */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_ProcessPortTypeChanged
 * -------------------------------------------------------------------------
 * FUNCTION: Do all actions related to port type change
 * INPUT   : unit       -- in which unit
 *           port       -- which port
 *           module_id
 *           port_type  -- which port type
 * OUTPUT  : None
 * RETURN  : None
 * NOTE    : None
 * -------------------------------------------------------------------------*/
void SWCTRL_ProcessPortTypeChanged(UI32_T unit,
                                   UI32_T port,
                                   UI32_T module_id,
                                   UI32_T port_type)
{
    UI32_T           ifindex = SWCTRL_UPORT_TO_IFINDEX (unit, port);
    SYS_TYPE_Uport_T unit_port;
    UI32_T           old_port_type;

    unit_port.unit = (UI16_T) unit;
    unit_port.port = (UI16_T) port;

    SWCTRL_USE_CSC_CHECK_OPER_MODE_WITHOUT_RETURN_VALUE();

    old_port_type = port_info[ifindex-1].port_entry.port_type;
    port_info[ifindex-1].port_entry.port_type = port_type;

    if( SWCTRL_IS_TRUNK_MEMBER(SWCTRL_UPORT_TO_IFINDEX(unit, port)) )
    {
        UI32_T trunk_id;
        BOOL_T ret;

        /* keep trunk info
         */
        trunk_id = port_info[ifindex-1].port_entry.port_trunk_index;

#if (SYS_CPNT_SWCTRL_COMBO_PORT_CONFIG_KEEP == TRUE)
        /* 1. reset phy cfg
         * 2. config phy to work on appropriate mode for new port type
         * 3. config phy with new phy cfg
         */
#if (SWCTRL_UPDATE_PORT_ABILITY == TRUE)
        if (SWCTRL_UpdatePortAbility(unit, port))
        {
            SWCTRL_ReInitCfgComboPortChanged(unit, port);
        }

#if (SYS_CPNT_COMBO_PORT_FORCE_MODE == TRUE)
        if (module_id != 0)
        {
            SWCTRL_ReInitPortComboForcedMode(unit, port);

            if (SWCTRL_UpdatePortAbility(unit, port))
            {
                SWCTRL_ReInitCfgComboPortChanged(unit, port);
            }
        }
#endif
#else /* (SWCTRL_UPDATE_PORT_ABILITY == TRUE) */
        if (port_info[ifindex-1].port_entry.port_type != old_port_type)
        {
            SWCTRL_ReInitCfgComboPortChanged(unit, port);
        }

#if (SYS_CPNT_COMBO_PORT_FORCE_MODE == TRUE)
        if (module_id != 0)
        {
            SWCTRL_ReInitPortComboForcedMode(unit, port);
        }
#endif
#endif /* (SWCTRL_UPDATE_PORT_ABILITY == TRUE) */

        SWCTRL_ReInitPhyComboPortChanged(unit,port,port_type);
#else
        SWCTRL_ConfigUserPortToDefaultState(unit, port, port_type, FALSE);
#endif

        /* restore trunk info
         */
        port_info[ifindex-1].port_entry.port_trunk_index = trunk_id;

        ret = SWCTRL_CheckUserPortJoinTrunkValidation(trunk_id, unit_port, TRUE, FALSE);

        if( ret == FALSE)
        {
            SWCTRL_DeleteTrunkMember(trunk_id, unit_port);
        }
        else
        {
            if(trunk_ext_port_info[trunk_id-1].member_number == 1)
            {
                /* If this port is the only trunk member of
                 * this trunk all setting of this user port
                 * need to apply to the trunk database, just link
                 * add first trunk trunk member.
                 */
                /* copy the all of attributes of 1st trunk member to trunk
                 */
                SWCTRL_LOCK();
                port_info[SWCTRL_TRUNKID_TO_IFINDEX(trunk_id)-1] = port_info[ifindex-1];

                /* these index should keep original data
                 */
                port_info[SWCTRL_TRUNKID_TO_IFINDEX(trunk_id)-1].port_entry.port_index                 = SWCTRL_TRUNKID_TO_IFINDEX(trunk_id);
                port_info[SWCTRL_TRUNKID_TO_IFINDEX(trunk_id)-1].bcast_storm_entry.bcast_storm_ifindex = SWCTRL_TRUNKID_TO_IFINDEX(trunk_id);
                SWCTRL_UNLOCK();
            }
        }
    }
    else
    {
        /* normal port
         */
#if (SYS_CPNT_SWCTRL_COMBO_PORT_CONFIG_KEEP == TRUE)
        /* 1. reset phy cfg
         * 2. config phy to work on appropriate mode for new port type
         * 3. config phy with new phy cfg
         */
#if (SWCTRL_UPDATE_PORT_ABILITY == TRUE)
        if (SWCTRL_UpdatePortAbility(unit, port))
        {
            SWCTRL_ReInitCfgComboPortChanged(unit, port);
        }

#if (SYS_CPNT_COMBO_PORT_FORCE_MODE == TRUE)
        if (module_id != 0)
        {
            SWCTRL_ReInitPortComboForcedMode(unit, port);

            if (SWCTRL_UpdatePortAbility(unit, port))
            {
                SWCTRL_ReInitCfgComboPortChanged(unit, port);
            }
        }
#endif
#else /* (SWCTRL_UPDATE_PORT_ABILITY == TRUE) */
        if (port_info[ifindex-1].port_entry.port_type != old_port_type)
        {
            SWCTRL_ReInitCfgComboPortChanged(unit, port);
        }

#if (SYS_CPNT_COMBO_PORT_FORCE_MODE == TRUE)
        if (module_id != 0)
        {
            SWCTRL_ReInitPortComboForcedMode(unit, port);
        }
#endif
#endif /* (SWCTRL_UPDATE_PORT_ABILITY == TRUE) */

        SWCTRL_ReInitPhyComboPortChanged(unit,port,port_type);
#else
        SWCTRL_ConfigUserPortToDefaultState(unit, port, port_type, FALSE);
#endif


        /* only normal port can triger logical port type change
         */
        if (port_type != old_port_type)
        {
            SWCTRL_Notify_LPortTypeChanged(SWCTRL_UPORT_TO_IFINDEX(unit, port), port_type);
        }
    }

    if (port_type != old_port_type)
    {
        SWCTRL_Notify_UPortTypeChanged(unit, port, port_type);
    }

    SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME();
    SWCTRL_RETURN_AND_RELEASE_CSC_WITHOUT_RETUEN_VALUE();

} /* End of SWCTRL_TASK_Process_PortTypeChanged() */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_ProcessPortSpeedDuplexChanged
 * -------------------------------------------------------------------------
 * FUNCTION: Do all actions related to port speed duplex change
 * INPUT   : unit           -- in which unit
 *           port           -- which port
 *           speed_duplex   -- which port type
 * OUTPUT  : None
 * RETURN  : None
 * NOTE    : None
 * -------------------------------------------------------------------------*/
void SWCTRL_ProcessPortSpeedDuplexChanged(UI32_T unit, UI32_T port, UI32_T speed_duplex)
{
    UI32_T ifindex = SWCTRL_UPORT_TO_IFINDEX(unit, port);

    SWCTRL_USE_CSC_CHECK_OPER_MODE_WITHOUT_RETURN_VALUE();

    SWCTRL_LOCK();
    port_info[ifindex-1].port_entry.port_speed_dpx_status = speed_duplex;
    SWCTRL_UNLOCK();

    {
        BOOL_T dormant_enable;

        dormant_enable =
            (SWCTRL_IS_FULL_DUPLEX (ifindex) &&
            (user_ext_port_info[ifindex-1].lacp_oper_status == VAL_lacpPortStatus_enabled));

        SWCTRL_SetPortOperDormantStatus(ifindex, SWCTRL_OPER_DORMANT_LV_LACP, dormant_enable, FALSE);
    }

    SWCTRL_Notify_uPortSpeedDuplex(unit, port, speed_duplex);

    if (SWCTRL_IS_TRUNK_MEMBER(ifindex)) /*trunk member*/
    {
        UI32_T primary_ifindex;
        UI32_T trunk_id = port_info[ifindex-1].port_entry.port_trunk_index;
        UI32_T trunk_ifindex = SWCTRL_TRUNKID_TO_IFINDEX(trunk_id);

        SWCTRL_SetTrunkPorts(trunk_id,
                             trunk_ext_port_info[trunk_id - 1].member_number,
                             trunk_ext_port_info[trunk_id - 1].member_list);

        if (!SWCTRL_GetTrunkPrimaryPort(trunk_ifindex, &primary_ifindex))
        {
            /* no primary port, use this user port
             */
            primary_ifindex = ifindex;
        }

        if (primary_ifindex == ifindex)
        {
            SWCTRL_Notify_PortSpeedDuplex (trunk_ifindex, speed_duplex);
        }
    }
    else /*normal port*/
    {
        SWCTRL_Notify_PortSpeedDuplex (ifindex, speed_duplex);
    }

    SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME();
    SWCTRL_RETURN_AND_RELEASE_CSC_WITHOUT_RETUEN_VALUE();

} /* End of  SWCTRL_Process_PortSpeedDuplexChanged () */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_ProcessPortFlowCtrlChanged
 * -------------------------------------------------------------------------
 * FUNCTION: Do all actions related to port speed duplex change
 * INPUT   : unit           -- in which unit
 *           port           -- which port
 *           flowctrl_status-- which status (backpressure/802.3x/none)
 * OUTPUT  : None
 * RETURN  : None
 * NOTE    : None
 * -------------------------------------------------------------------------*/
void SWCTRL_ProcessPortFlowCtrlChanged(UI32_T unit, UI32_T port, UI32_T flowctrl_status)
{
    UI32_T ifindex = SWCTRL_UPORT_TO_IFINDEX (unit, port);

    SWCTRL_USE_CSC_CHECK_OPER_MODE_WITHOUT_RETURN_VALUE();

    SWCTRL_LOCK();
    port_info[ifindex-1].port_entry.port_flow_ctrl_status = flowctrl_status;
    SWCTRL_UNLOCK();

    SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME();
    SWCTRL_RETURN_AND_RELEASE_CSC_WITHOUT_RETUEN_VALUE();

} /*end of SWCTRL_ProcessPortFlowCtrlChanged*/

#if (SYS_CPNT_SFP_DDM_ALARMWARN_TRAP == TRUE)
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_ProcessPortSfpDdmThresholdMeasuredInfoChanged
 * -------------------------------------------------------------------------
 * FUNCTION: Send trap if mesaured ddm info exceeds alarm/warning threshold
 * INPUT   : unit           -- in which unit
 *           sfp_index      -- which sfp index
 *           is_changing_to_not_present
 * OUTPUT  : None
 * RETURN  : None
 * NOTE    : None
 * -------------------------------------------------------------------------
 */
void SWCTRL_ProcessPortSfpDdmThresholdMeasuredInfoChanged(UI32_T unit, UI32_T sfp_index, BOOL_T is_changing_to_not_present)
{
    SWCTRL_OM_SfpInfo_T                sfp_info;;
    SWCTRL_OM_SfpDdmInfoMeasured_T     sfp_ddm_info_measured;
    SWCTRL_OM_SfpDdmThreshold_T        sfp_ddm_threshold;
    SWCTRL_OM_SfpDdmThresholdStatus_T  sfp_ddm_threshold_status;
    UI32_T  trap_type;
    BOOL_T  auto_mode, trap_enable, is_rx_loss, status_changed = FALSE;

    SWCTRL_USE_CSC_CHECK_OPER_MODE_WITHOUT_RETURN_VALUE();

    SWCTRL_LOCK();
    SWCTRL_OM_GetPortSfpDdmTrapEnable(unit, sfp_index, &trap_enable);
    SWCTRL_UNLOCK();

    if(trap_enable == FALSE)
        SWCTRL_RETURN_AND_RELEASE_CSC_WITHOUT_RETUEN_VALUE();

    SWCTRL_LOCK();
    SWCTRL_OM_GetPortSfpInfo(unit, sfp_index, &sfp_info);
    SWCTRL_OM_GetPortSfpDdmThreshold(unit, sfp_index, &sfp_ddm_threshold);
    SWCTRL_OM_GetPortSfpDdmInfoMeasured(unit, sfp_index, &sfp_ddm_info_measured);
    SWCTRL_OM_GetPortSfpDdmThresholdStatus(unit, sfp_index, &sfp_ddm_threshold_status);
    SWCTRL_OM_GetPortSfpDdmThresholdAutoMode(unit, sfp_index, &auto_mode);
    SWCTRL_UNLOCK();

    is_rx_loss = sfp_ddm_info_measured.rx_los_asserted;

    //if (SWCTRL_BACKDOOR_IsDebugFlagOn(SWCTRL_BACKDOOR_DEBUG_FLAG_SFP_DDM_TRAP))
    //    printf("[SFP %ld] pre_rx_loss:%x is_rx_loss %x\r\n", sfp_index, pre_rx_loss[unit-1][sfp_index-1], is_rx_loss);

    /* When fibber is disconnect from SFP. If previous status is in alarm/warning status,
     * send alarmwarn_cease trap.
     */
    if((pre_rx_loss[unit-1][sfp_index-1] == FALSE && is_rx_loss == TRUE) || is_changing_to_not_present)
    {
        /* rx-power */
        if(sfp_ddm_threshold_status.rx_power_high_alarm == 1 ||
           sfp_ddm_threshold_status.rx_power_high_warning == 1 ||
           sfp_ddm_threshold_status.rx_power_low_warning == 1 ||
           sfp_ddm_threshold_status.rx_power_low_alarm == 1)
        {
            SWCTRL_SendPortSfpDdmTrap(unit, sfp_index, TRAP_EVENT_SFP_RX_POWER_ALARMWARN_CEASE);
            sfp_ddm_threshold_status.rx_power_high_alarm = 0;
            sfp_ddm_threshold_status.rx_power_low_alarm = 0;
            sfp_ddm_threshold_status.rx_power_high_warning = 0;
            sfp_ddm_threshold_status.rx_power_low_warning = 0;
            if (SWCTRL_BACKDOOR_IsDebugFlagOn(SWCTRL_BACKDOOR_DEBUG_FLAG_SFP_DDM_TRAP))
            {
                if(!is_changing_to_not_present)
                    BACKDOOR_MGR_Printf("rx power[SFP %ld] cease (link down)!...\r\n", sfp_index);
                else
                    BACKDOOR_MGR_Printf("rx power[SFP %ld] cease (unplug)!...\r\n", sfp_index);
            }
        }

        /* tx power */
        if(sfp_info.identifier == SWDRV_TYPE_GBIC_ID_SFP ||
           sfp_info.identifier == SWDRV_TYPE_GBIC_ID_XFP)
        {
            if(sfp_ddm_threshold_status.tx_power_high_alarm == 1 ||
                    sfp_ddm_threshold_status.tx_power_high_warning == 1||
                    sfp_ddm_threshold_status.tx_power_low_warning == 1 ||
                    sfp_ddm_threshold_status.tx_power_low_alarm == 1)
            {
                SWCTRL_SendPortSfpDdmTrap(unit, sfp_index, TRAP_EVENT_SFP_TX_POWER_ALARMWARN_CEASE);
                sfp_ddm_threshold_status.tx_power_high_alarm = 0;
                sfp_ddm_threshold_status.tx_power_low_alarm = 0;
                sfp_ddm_threshold_status.tx_power_high_warning = 0;
                sfp_ddm_threshold_status.tx_power_low_warning = 0;
                if (SWCTRL_BACKDOOR_IsDebugFlagOn(SWCTRL_BACKDOOR_DEBUG_FLAG_SFP_DDM_TRAP))
                {
                    if(!is_changing_to_not_present)
                        BACKDOOR_MGR_Printf("tx power[SFP %ld] cease (link down)!...\r\n", sfp_index);
                    else
                        BACKDOOR_MGR_Printf("tx power[SFP %ld] cease (unplug)!...\r\n", sfp_index);
                }
            }
        }

        /* temperature */
        if(sfp_ddm_threshold_status.temp_high_alarm == 1 ||
           sfp_ddm_threshold_status.temp_high_warning == 1||
           sfp_ddm_threshold_status.temp_low_warning == 1 ||
           sfp_ddm_threshold_status.temp_low_alarm == 1)
        {
            SWCTRL_SendPortSfpDdmTrap(unit, sfp_index, TRAP_EVENT_SFP_TEMP_ALARMWARN_CEASE);
            sfp_ddm_threshold_status.temp_high_alarm = 0;
            sfp_ddm_threshold_status.temp_low_alarm = 0;
            sfp_ddm_threshold_status.temp_high_warning = 0;
            sfp_ddm_threshold_status.temp_low_warning = 0;
            if (SWCTRL_BACKDOOR_IsDebugFlagOn(SWCTRL_BACKDOOR_DEBUG_FLAG_SFP_DDM_TRAP))
            {
                if(!is_changing_to_not_present)
                    BACKDOOR_MGR_Printf("temperature [SFP %ld] cease (link down)!...\r\n", sfp_index);
                else
                    BACKDOOR_MGR_Printf("temperature [SFP %ld] cease (unplug)!...\r\n", sfp_index);
            }
        }

        /* voltage */
        if(sfp_ddm_threshold_status.voltage_high_alarm == 1 ||
           sfp_ddm_threshold_status.voltage_high_warning == 1||
           sfp_ddm_threshold_status.voltage_low_warning == 1 ||
           sfp_ddm_threshold_status.voltage_low_alarm == 1)
        {
            SWCTRL_SendPortSfpDdmTrap(unit, sfp_index, TRAP_EVENT_SFP_VOLTAGE_ALARMWARN_CEASE);
            sfp_ddm_threshold_status.voltage_high_alarm = 0;
            sfp_ddm_threshold_status.voltage_low_alarm = 0;
            sfp_ddm_threshold_status.voltage_high_warning = 0;
            sfp_ddm_threshold_status.voltage_low_warning = 0;
            if (SWCTRL_BACKDOOR_IsDebugFlagOn(SWCTRL_BACKDOOR_DEBUG_FLAG_SFP_DDM_TRAP))
            {
                if(!is_changing_to_not_present)
                    BACKDOOR_MGR_Printf("voltage [SFP %ld] cease (link down)!...\r\n", sfp_index);
                else
                    BACKDOOR_MGR_Printf("voltage [SFP %ld] cease (unplug)!...\r\n", sfp_index);
            }
        }

        /* current */
        if(sfp_ddm_threshold_status.bias_high_alarm == 1 ||
           sfp_ddm_threshold_status.bias_high_warning == 1||
           sfp_ddm_threshold_status.bias_low_warning == 1 ||
           sfp_ddm_threshold_status.bias_low_alarm == 1)
        {
            SWCTRL_SendPortSfpDdmTrap(unit, sfp_index, TRAP_EVENT_SFP_CURRENT_ALARMWARN_CEASE);
            sfp_ddm_threshold_status.bias_high_alarm = 0;
            sfp_ddm_threshold_status.bias_low_alarm = 0;
            sfp_ddm_threshold_status.bias_high_warning = 0;
            sfp_ddm_threshold_status.bias_low_warning = 0;
            if (SWCTRL_BACKDOOR_IsDebugFlagOn(SWCTRL_BACKDOOR_DEBUG_FLAG_SFP_DDM_TRAP))
            {
                if(!is_changing_to_not_present)
                    BACKDOOR_MGR_Printf("current [SFP %ld] cease (link down)!...\r\n", sfp_index);
                else
                    BACKDOOR_MGR_Printf("current [SFP %ld] cease (unplug)!...\r\n", sfp_index);
            }
        }

        memset(&sfp_ddm_threshold_status, 0, sizeof(SWCTRL_OM_SfpDdmThresholdStatus_T));
        SWCTRL_OM_SetPortSfpDdmThresholdStatus(unit, sfp_index, &sfp_ddm_threshold_status);
        pre_rx_loss[unit-1][sfp_index-1] = TRUE;

        if(is_changing_to_not_present)/* Used when present -> not present */
            return;
    }

    if(is_rx_loss == FALSE)
    {
        if(pre_rx_loss[unit-1][sfp_index-1] == TRUE)
            pre_rx_loss[unit-1][sfp_index-1] = FALSE;

        /* rx power */
        if (sfp_ddm_threshold_status.rx_power_high_alarm == 0 &&
            sfp_ddm_info_measured.rx_power >= sfp_ddm_threshold.rx_power_high_alarm)
        {
            SWCTRL_SendPortSfpDdmTrap(unit, sfp_index, TRAP_EVENT_SFP_RX_POWER_HIGH_ALARM);
            status_changed = TRUE;
            sfp_ddm_threshold_status.rx_power_high_alarm = 1;
            sfp_ddm_threshold_status.rx_power_high_warning = 1;
            sfp_ddm_threshold_status.rx_power_low_alarm = 0;
            sfp_ddm_threshold_status.rx_power_low_warning = 0;
            if (SWCTRL_BACKDOOR_IsDebugFlagOn(SWCTRL_BACKDOOR_DEBUG_FLAG_SFP_DDM_TRAP))
                BACKDOOR_MGR_Printf("rx power[SFP %ld] high alarm !... (%.2f)\r\n",
                    sfp_index, sfp_ddm_info_measured.rx_power);
        }
        else if (sfp_ddm_threshold_status.rx_power_low_alarm == 0 &&
                 sfp_ddm_info_measured.rx_power <= sfp_ddm_threshold.rx_power_low_alarm)
        {
            SWCTRL_SendPortSfpDdmTrap(unit, sfp_index, TRAP_EVENT_SFP_RX_POWER_LOW_ALARM);
            status_changed = TRUE;
            sfp_ddm_threshold_status.rx_power_low_alarm = 1;
            sfp_ddm_threshold_status.rx_power_low_warning = 1;
            sfp_ddm_threshold_status.rx_power_high_alarm = 0;
            sfp_ddm_threshold_status.rx_power_high_warning = 0;
            if (SWCTRL_BACKDOOR_IsDebugFlagOn(SWCTRL_BACKDOOR_DEBUG_FLAG_SFP_DDM_TRAP))
                BACKDOOR_MGR_Printf("rx power[SFP %ld] low alarm !... (%.2f)\r\n",
                    sfp_index, sfp_ddm_info_measured.rx_power);
        }
        else if ((sfp_ddm_threshold_status.rx_power_high_warning == 0 ||
                  (sfp_ddm_threshold_status.rx_power_high_alarm == 1 &&
                 sfp_ddm_threshold_status.rx_power_high_warning == 1)) &&
                 sfp_ddm_info_measured.rx_power < sfp_ddm_threshold.rx_power_high_alarm &&
                 sfp_ddm_info_measured.rx_power >= sfp_ddm_threshold.rx_power_high_warning)
        {
            SWCTRL_SendPortSfpDdmTrap(unit, sfp_index, TRAP_EVENT_SFP_RX_POWER_HIGH_WARNING);
            status_changed = TRUE;
            sfp_ddm_threshold_status.rx_power_high_alarm = 0;
            sfp_ddm_threshold_status.rx_power_high_warning = 1;
            sfp_ddm_threshold_status.rx_power_low_alarm = 0;
            sfp_ddm_threshold_status.rx_power_low_warning = 0;
            if (SWCTRL_BACKDOOR_IsDebugFlagOn(SWCTRL_BACKDOOR_DEBUG_FLAG_SFP_DDM_TRAP))
                BACKDOOR_MGR_Printf("rx power[SFP %ld] high warning !... (%.2f)\r\n",
                    sfp_index, sfp_ddm_info_measured.rx_power);
        }
        else if ((sfp_ddm_threshold_status.rx_power_low_warning == 0 ||
                  (sfp_ddm_threshold_status.rx_power_low_warning == 1 &&
                 sfp_ddm_threshold_status.rx_power_low_alarm == 1)) &&
                 sfp_ddm_info_measured.rx_power > sfp_ddm_threshold.rx_power_low_alarm &&
                 sfp_ddm_info_measured.rx_power <= sfp_ddm_threshold.rx_power_low_warning)
        {
            SWCTRL_SendPortSfpDdmTrap(unit, sfp_index, TRAP_EVENT_SFP_RX_POWER_LOW_WARNING);
            status_changed = TRUE;
            sfp_ddm_threshold_status.rx_power_low_alarm = 0;
            sfp_ddm_threshold_status.rx_power_low_warning = 1;
            sfp_ddm_threshold_status.rx_power_high_alarm = 0;
            sfp_ddm_threshold_status.rx_power_high_warning = 0;
            if (SWCTRL_BACKDOOR_IsDebugFlagOn(SWCTRL_BACKDOOR_DEBUG_FLAG_SFP_DDM_TRAP))
                BACKDOOR_MGR_Printf("rx power[SFP %ld] low warning !... (%.2f)\r\n",
                    sfp_index, sfp_ddm_info_measured.rx_power);
        }
        else if((sfp_ddm_threshold_status.rx_power_high_alarm == 1 ||
                 sfp_ddm_threshold_status.rx_power_high_warning == 1 ||
                 sfp_ddm_threshold_status.rx_power_low_warning == 1 ||
                 sfp_ddm_threshold_status.rx_power_low_alarm == 1) &&
                (sfp_ddm_info_measured.rx_power > sfp_ddm_threshold.rx_power_low_warning) &&
                (sfp_ddm_info_measured.rx_power < sfp_ddm_threshold.rx_power_high_warning))
        {
            SWCTRL_SendPortSfpDdmTrap(unit, sfp_index, TRAP_EVENT_SFP_RX_POWER_ALARMWARN_CEASE);
            status_changed = TRUE;
            if (SWCTRL_BACKDOOR_IsDebugFlagOn(SWCTRL_BACKDOOR_DEBUG_FLAG_SFP_DDM_TRAP))
                BACKDOOR_MGR_Printf("rx power[SFP %ld] cease!... %.2f\r\n",
                    sfp_index, sfp_ddm_info_measured.rx_power);
            sfp_ddm_threshold_status.rx_power_high_alarm = 0;
            sfp_ddm_threshold_status.rx_power_low_alarm = 0;
            sfp_ddm_threshold_status.rx_power_high_warning = 0;
            sfp_ddm_threshold_status.rx_power_low_warning = 0;
        }

        /* tx power */
        if(sfp_info.identifier == SWDRV_TYPE_GBIC_ID_SFP ||
           sfp_info.identifier == SWDRV_TYPE_GBIC_ID_XFP)
        {
            if (sfp_ddm_threshold_status.tx_power_high_alarm == 0 &&
                    sfp_ddm_info_measured.tx_power >= sfp_ddm_threshold.tx_power_high_alarm)
            {
                SWCTRL_SendPortSfpDdmTrap(unit, sfp_index, TRAP_EVENT_SFP_TX_POWER_HIGH_ALARM);
                status_changed = TRUE;
                sfp_ddm_threshold_status.tx_power_high_alarm = 1;
                sfp_ddm_threshold_status.tx_power_high_warning = 1;
                sfp_ddm_threshold_status.tx_power_low_alarm = 0;
                sfp_ddm_threshold_status.tx_power_low_warning = 0;
                if (SWCTRL_BACKDOOR_IsDebugFlagOn(SWCTRL_BACKDOOR_DEBUG_FLAG_SFP_DDM_TRAP))
                    BACKDOOR_MGR_Printf("tx power[SFP %ld] high alarm !... (%.2f)\r\n",
                            sfp_index, sfp_ddm_info_measured.tx_power);
            }
            else if (sfp_ddm_threshold_status.tx_power_low_alarm == 0 &&
                    sfp_ddm_info_measured.tx_power <= sfp_ddm_threshold.tx_power_low_alarm)
            {
                SWCTRL_SendPortSfpDdmTrap(unit, sfp_index, TRAP_EVENT_SFP_TX_POWER_LOW_ALARM);
                status_changed = TRUE;
                sfp_ddm_threshold_status.tx_power_low_alarm = 1;
                sfp_ddm_threshold_status.tx_power_low_warning = 1;
                sfp_ddm_threshold_status.tx_power_high_alarm = 0;
                sfp_ddm_threshold_status.tx_power_high_warning = 0;
                if (SWCTRL_BACKDOOR_IsDebugFlagOn(SWCTRL_BACKDOOR_DEBUG_FLAG_SFP_DDM_TRAP))
                    BACKDOOR_MGR_Printf("tx power[SFP %ld] low alarm !... (%.2f)\r\n",
                            sfp_index, sfp_ddm_info_measured.tx_power);
            }
            else if ((sfp_ddm_threshold_status.tx_power_high_warning == 0 ||
                        (sfp_ddm_threshold_status.tx_power_high_alarm == 1 &&
                         sfp_ddm_threshold_status.tx_power_high_warning == 1)) &&
                    sfp_ddm_info_measured.tx_power < sfp_ddm_threshold.tx_power_high_alarm &&
                    sfp_ddm_info_measured.tx_power >= sfp_ddm_threshold.tx_power_high_warning)
            {
                SWCTRL_SendPortSfpDdmTrap(unit, sfp_index, TRAP_EVENT_SFP_TX_POWER_HIGH_WARNING);
                status_changed = TRUE;
                sfp_ddm_threshold_status.tx_power_high_alarm = 0;
                sfp_ddm_threshold_status.tx_power_high_warning = 1;
                sfp_ddm_threshold_status.tx_power_low_alarm = 0;
                sfp_ddm_threshold_status.tx_power_low_warning = 0;
                if (SWCTRL_BACKDOOR_IsDebugFlagOn(SWCTRL_BACKDOOR_DEBUG_FLAG_SFP_DDM_TRAP))
                    BACKDOOR_MGR_Printf("tx power[SFP %ld] high warning !... (%.2f)\r\n",
                            sfp_index, sfp_ddm_info_measured.tx_power);
            }
            else if ((sfp_ddm_threshold_status.tx_power_low_warning == 0 ||
                        (sfp_ddm_threshold_status.tx_power_low_warning == 1 &&
                         sfp_ddm_threshold_status.tx_power_low_alarm == 1)) &&
                    sfp_ddm_info_measured.tx_power > sfp_ddm_threshold.tx_power_low_alarm &&
                    sfp_ddm_info_measured.tx_power <= sfp_ddm_threshold.tx_power_low_warning)
            {
                SWCTRL_SendPortSfpDdmTrap(unit, sfp_index, TRAP_EVENT_SFP_TX_POWER_LOW_WARNING);
                status_changed = TRUE;
                sfp_ddm_threshold_status.tx_power_low_alarm = 0;
                sfp_ddm_threshold_status.tx_power_low_warning = 1;
                sfp_ddm_threshold_status.tx_power_high_alarm = 0;
                sfp_ddm_threshold_status.tx_power_high_warning = 0;
                if (SWCTRL_BACKDOOR_IsDebugFlagOn(SWCTRL_BACKDOOR_DEBUG_FLAG_SFP_DDM_TRAP))
                    BACKDOOR_MGR_Printf("tx power[SFP %ld] low warning !... (%.2f)\r\n",
                            sfp_index,sfp_ddm_info_measured.tx_power);
            }
            else if((sfp_ddm_threshold_status.tx_power_high_alarm == 1 ||
                        sfp_ddm_threshold_status.tx_power_high_warning == 1 ||
                        sfp_ddm_threshold_status.tx_power_low_warning == 1 ||
                        sfp_ddm_threshold_status.tx_power_low_alarm == 1) &&
                    (sfp_ddm_info_measured.tx_power > sfp_ddm_threshold.tx_power_low_warning) &&
                    (sfp_ddm_info_measured.tx_power < sfp_ddm_threshold.tx_power_high_warning))
            {
                SWCTRL_SendPortSfpDdmTrap(unit, sfp_index, TRAP_EVENT_SFP_TX_POWER_ALARMWARN_CEASE);
                status_changed = TRUE;
                if (SWCTRL_BACKDOOR_IsDebugFlagOn(SWCTRL_BACKDOOR_DEBUG_FLAG_SFP_DDM_TRAP))
                    BACKDOOR_MGR_Printf("tx power[SFP %ld] cease!... (%.2f)\r\n",
                            sfp_index, sfp_ddm_info_measured.tx_power);
                sfp_ddm_threshold_status.tx_power_high_alarm = 0;
                sfp_ddm_threshold_status.tx_power_low_alarm = 0;
                sfp_ddm_threshold_status.tx_power_high_warning = 0;
                sfp_ddm_threshold_status.tx_power_low_warning = 0;
            }
        }

        /* temperature */
        if (sfp_ddm_threshold_status.temp_high_alarm == 0 &&
            sfp_ddm_info_measured.temperature >= sfp_ddm_threshold.temp_high_alarm)
        {
            SWCTRL_SendPortSfpDdmTrap(unit, sfp_index, TRAP_EVENT_SFP_TEMP_HIGH_ALARM);
            status_changed = TRUE;
            sfp_ddm_threshold_status.temp_high_alarm = 1;
            sfp_ddm_threshold_status.temp_high_warning = 1;
            sfp_ddm_threshold_status.temp_low_alarm = 0;
            sfp_ddm_threshold_status.temp_low_warning = 0;
            if (SWCTRL_BACKDOOR_IsDebugFlagOn(SWCTRL_BACKDOOR_DEBUG_FLAG_SFP_DDM_TRAP))
                BACKDOOR_MGR_Printf("Temperature[SFP %ld] high alarm !... (%.2f)\r\n",
                    sfp_index, sfp_ddm_info_measured.temperature);
        }
        else if (sfp_ddm_threshold_status.temp_low_alarm == 0 &&
            sfp_ddm_info_measured.temperature <= sfp_ddm_threshold.temp_low_alarm)
        {
            SWCTRL_SendPortSfpDdmTrap(unit, sfp_index, TRAP_EVENT_SFP_TEMP_LOW_ALARM);
            status_changed = TRUE;
            sfp_ddm_threshold_status.temp_low_alarm = 1;
            sfp_ddm_threshold_status.temp_low_warning = 1;
            sfp_ddm_threshold_status.temp_high_alarm = 0;
            sfp_ddm_threshold_status.temp_high_warning = 0;
            if (SWCTRL_BACKDOOR_IsDebugFlagOn(SWCTRL_BACKDOOR_DEBUG_FLAG_SFP_DDM_TRAP))
                BACKDOOR_MGR_Printf("Temperature[SFP %ld] low alarm !... (%.2f)\r\n",
                    sfp_index, sfp_ddm_info_measured.temperature);
        }
        else if ((sfp_ddm_threshold_status.temp_high_warning == 0 ||
                  (sfp_ddm_threshold_status.temp_high_alarm == 1 &&
                  sfp_ddm_threshold_status.temp_high_warning == 1)) &&
                 sfp_ddm_info_measured.temperature < sfp_ddm_threshold.temp_high_alarm &&
                 sfp_ddm_info_measured.temperature >= sfp_ddm_threshold.temp_high_warning)
        {
            SWCTRL_SendPortSfpDdmTrap(unit, sfp_index, TRAP_EVENT_SFP_TEMP_HIGH_WARNING);
            status_changed = TRUE;
            sfp_ddm_threshold_status.temp_high_alarm = 0;
            sfp_ddm_threshold_status.temp_high_warning = 1;
            sfp_ddm_threshold_status.temp_low_alarm = 0;
            sfp_ddm_threshold_status.temp_low_warning = 0;
            if (SWCTRL_BACKDOOR_IsDebugFlagOn(SWCTRL_BACKDOOR_DEBUG_FLAG_SFP_DDM_TRAP))
                BACKDOOR_MGR_Printf("Temperature[SFP %ld] high warning !... (%.2f)\r\n",
                    sfp_index, sfp_ddm_info_measured.temperature);
        }
        else if ((sfp_ddm_threshold_status.temp_low_warning == 0 ||
                 (sfp_ddm_threshold_status.temp_low_warning == 1 &&
                 sfp_ddm_threshold_status.temp_low_alarm == 1)) &&
                 sfp_ddm_info_measured.temperature > sfp_ddm_threshold.temp_low_alarm &&
                 sfp_ddm_info_measured.temperature <= sfp_ddm_threshold.temp_low_warning)
        {
            SWCTRL_SendPortSfpDdmTrap(unit, sfp_index, TRAP_EVENT_SFP_TEMP_LOW_WARNING);
            status_changed = TRUE;
            sfp_ddm_threshold_status.temp_low_alarm = 0;
            sfp_ddm_threshold_status.temp_low_warning = 1;
            sfp_ddm_threshold_status.temp_high_alarm = 0;
            sfp_ddm_threshold_status.temp_high_warning = 0;
            if (SWCTRL_BACKDOOR_IsDebugFlagOn(SWCTRL_BACKDOOR_DEBUG_FLAG_SFP_DDM_TRAP))
                BACKDOOR_MGR_Printf("Temperature[SFP %ld] low warning !... (%.2f)\r\n",
                    sfp_index,sfp_ddm_info_measured.temperature);
        }
        else if((sfp_ddm_threshold_status.temp_high_alarm == 1 ||
                 sfp_ddm_threshold_status.temp_high_warning == 1 ||
                 sfp_ddm_threshold_status.temp_low_warning == 1 ||
                 sfp_ddm_threshold_status.temp_low_alarm == 1) &&
                (sfp_ddm_info_measured.temperature > sfp_ddm_threshold.temp_low_warning) &&
                (sfp_ddm_info_measured.temperature < sfp_ddm_threshold.temp_high_warning))
        {
            SWCTRL_SendPortSfpDdmTrap(unit, sfp_index, TRAP_EVENT_SFP_TEMP_ALARMWARN_CEASE);
            status_changed = TRUE;
            if (SWCTRL_BACKDOOR_IsDebugFlagOn(SWCTRL_BACKDOOR_DEBUG_FLAG_SFP_DDM_TRAP))
                BACKDOOR_MGR_Printf("Temperature power[SFP %ld] cease!... (%.2f)\r\n",
                    sfp_index, sfp_ddm_info_measured.temperature);
            sfp_ddm_threshold_status.temp_high_alarm = 0;
            sfp_ddm_threshold_status.temp_low_alarm = 0;
            sfp_ddm_threshold_status.temp_high_warning = 0;
            sfp_ddm_threshold_status.temp_low_warning = 0;
        }

        /* voltage */
        if (sfp_ddm_threshold_status.voltage_high_alarm == 0 &&
            sfp_ddm_info_measured.voltage >= sfp_ddm_threshold.voltage_high_alarm)
        {
            SWCTRL_SendPortSfpDdmTrap(unit, sfp_index, TRAP_EVENT_SFP_VOLTAGE_HIGH_ALARM);
            status_changed = TRUE;
            sfp_ddm_threshold_status.voltage_high_alarm = 1;
            sfp_ddm_threshold_status.voltage_high_warning = 1;
            sfp_ddm_threshold_status.voltage_low_alarm = 0;
            sfp_ddm_threshold_status.voltage_low_warning = 0;
            if (SWCTRL_BACKDOOR_IsDebugFlagOn(SWCTRL_BACKDOOR_DEBUG_FLAG_SFP_DDM_TRAP))
                BACKDOOR_MGR_Printf("Voltage [SFP %ld] high alarm !... (%.2f)\r\n",
                    sfp_index, sfp_ddm_info_measured.voltage);
        }
        else if (sfp_ddm_threshold_status.voltage_low_alarm == 0 &&
            sfp_ddm_info_measured.voltage <= sfp_ddm_threshold.voltage_low_alarm)
        {
            SWCTRL_SendPortSfpDdmTrap(unit, sfp_index, TRAP_EVENT_SFP_VOLTAGE_LOW_ALARM);
            status_changed = TRUE;
            sfp_ddm_threshold_status.voltage_low_alarm = 1;
            sfp_ddm_threshold_status.voltage_low_warning = 1;
            sfp_ddm_threshold_status.voltage_high_alarm = 0;
            sfp_ddm_threshold_status.voltage_high_warning = 0;
            if (SWCTRL_BACKDOOR_IsDebugFlagOn(SWCTRL_BACKDOOR_DEBUG_FLAG_SFP_DDM_TRAP))
                BACKDOOR_MGR_Printf("voltage [SFP %ld] low alarm !... (%.2f)\r\n",
                    sfp_index, sfp_ddm_info_measured.voltage);
        }
        else if ((sfp_ddm_threshold_status.voltage_high_warning == 0 ||
                  (sfp_ddm_threshold_status.voltage_high_alarm == 1 &&
                  sfp_ddm_threshold_status.voltage_high_warning == 1)) &&
                 sfp_ddm_info_measured.voltage < sfp_ddm_threshold.voltage_high_alarm &&
                 sfp_ddm_info_measured.voltage >= sfp_ddm_threshold.voltage_high_warning)
        {
            SWCTRL_SendPortSfpDdmTrap(unit, sfp_index, TRAP_EVENT_SFP_VOLTAGE_HIGH_WARNING);
            status_changed = TRUE;
            sfp_ddm_threshold_status.voltage_high_alarm = 0;
            sfp_ddm_threshold_status.voltage_high_warning = 1;
            sfp_ddm_threshold_status.voltage_low_alarm = 0;
            sfp_ddm_threshold_status.voltage_low_warning = 0;
            if (SWCTRL_BACKDOOR_IsDebugFlagOn(SWCTRL_BACKDOOR_DEBUG_FLAG_SFP_DDM_TRAP))
                BACKDOOR_MGR_Printf("Voltage [SFP %ld] high warning !... (%.2f)\r\n",
                    sfp_index, sfp_ddm_info_measured.voltage);
        }
        else if ((sfp_ddm_threshold_status.voltage_low_warning == 0 ||
                  (sfp_ddm_threshold_status.voltage_low_warning == 1 &&
                  sfp_ddm_threshold_status.voltage_low_alarm == 1)) &&
                 sfp_ddm_info_measured.voltage > sfp_ddm_threshold.voltage_low_alarm &&
                 sfp_ddm_info_measured.voltage <= sfp_ddm_threshold.voltage_low_warning)
        {
            SWCTRL_SendPortSfpDdmTrap(unit, sfp_index, TRAP_EVENT_SFP_VOLTAGE_LOW_WARNING);
            status_changed = TRUE;
            sfp_ddm_threshold_status.voltage_low_alarm = 0;
            sfp_ddm_threshold_status.voltage_low_warning = 1;
            sfp_ddm_threshold_status.voltage_high_alarm = 0;
            sfp_ddm_threshold_status.voltage_high_warning = 0;
            if (SWCTRL_BACKDOOR_IsDebugFlagOn(SWCTRL_BACKDOOR_DEBUG_FLAG_SFP_DDM_TRAP))
                BACKDOOR_MGR_Printf("Voltage [SFP %ld] low warning !... (%.2f)\r\n",
                    sfp_index,sfp_ddm_info_measured.voltage);
        }
        else if((sfp_ddm_threshold_status.voltage_high_alarm == 1||
                 sfp_ddm_threshold_status.voltage_high_warning == 1||
                 sfp_ddm_threshold_status.voltage_low_warning == 1||
                 sfp_ddm_threshold_status.voltage_low_alarm == 1) &&
                (sfp_ddm_info_measured.voltage > sfp_ddm_threshold.voltage_low_warning) &&
                (sfp_ddm_info_measured.voltage < sfp_ddm_threshold.voltage_high_warning))
        {
            SWCTRL_SendPortSfpDdmTrap(unit, sfp_index, TRAP_EVENT_SFP_VOLTAGE_ALARMWARN_CEASE);
            status_changed = TRUE;
            if (SWCTRL_BACKDOOR_IsDebugFlagOn(SWCTRL_BACKDOOR_DEBUG_FLAG_SFP_DDM_TRAP))
                BACKDOOR_MGR_Printf("Voltage [SFP %ld] cease!... (%.2f)\r\n",
                    sfp_index, sfp_ddm_info_measured.voltage);
            sfp_ddm_threshold_status.voltage_high_alarm = 0;
            sfp_ddm_threshold_status.voltage_low_alarm = 0;
            sfp_ddm_threshold_status.voltage_high_warning = 0;
            sfp_ddm_threshold_status.voltage_low_warning = 0;
        }

        /* current */
        if (sfp_ddm_threshold_status.bias_high_alarm == 0 &&
            sfp_ddm_info_measured.tx_bias_current >= sfp_ddm_threshold.bias_high_alarm)
        {
            SWCTRL_SendPortSfpDdmTrap(unit, sfp_index, TRAP_EVENT_SFP_CURRENT_HIGH_ALARM);
            status_changed = TRUE;
            sfp_ddm_threshold_status.bias_high_alarm = 1;
            sfp_ddm_threshold_status.bias_high_warning = 1;
            sfp_ddm_threshold_status.bias_low_alarm = 0;
            sfp_ddm_threshold_status.bias_low_warning = 0;
            if (SWCTRL_BACKDOOR_IsDebugFlagOn(SWCTRL_BACKDOOR_DEBUG_FLAG_SFP_DDM_TRAP))
                BACKDOOR_MGR_Printf("Bias current [SFP %ld] high alarm !... (%.2f)\r\n",
                    sfp_index, sfp_ddm_info_measured.tx_bias_current);
        }
        else if (sfp_ddm_threshold_status.bias_low_alarm == 0 &&
            sfp_ddm_info_measured.tx_bias_current <= sfp_ddm_threshold.bias_low_alarm)
        {
            SWCTRL_SendPortSfpDdmTrap(unit, sfp_index, TRAP_EVENT_SFP_CURRENT_LOW_ALARM);
            status_changed = TRUE;
            sfp_ddm_threshold_status.bias_low_alarm = 1;
            sfp_ddm_threshold_status.bias_low_warning = 1;
            sfp_ddm_threshold_status.bias_high_alarm = 0;
            sfp_ddm_threshold_status.bias_high_warning = 0;
            if (SWCTRL_BACKDOOR_IsDebugFlagOn(SWCTRL_BACKDOOR_DEBUG_FLAG_SFP_DDM_TRAP))
                BACKDOOR_MGR_Printf("Bias current [SFP %ld] low alarm !... (%.2f)\r\n",
                    sfp_index, sfp_ddm_info_measured.tx_bias_current);
        }
        else if ((sfp_ddm_threshold_status.bias_high_warning == 0 ||
                 (sfp_ddm_threshold_status.bias_high_alarm == 1 &&
                 sfp_ddm_threshold_status.bias_high_warning == 1)) &&
                 sfp_ddm_info_measured.tx_bias_current < sfp_ddm_threshold.bias_high_alarm &&
                 sfp_ddm_info_measured.tx_bias_current >= sfp_ddm_threshold.bias_high_warning)
        {
            SWCTRL_SendPortSfpDdmTrap(unit, sfp_index, TRAP_EVENT_SFP_CURRENT_HIGH_WARNING);
            status_changed = TRUE;
            sfp_ddm_threshold_status.bias_high_alarm = 0;
            sfp_ddm_threshold_status.bias_high_warning = 1;
            sfp_ddm_threshold_status.bias_low_alarm = 0;
            sfp_ddm_threshold_status.bias_low_warning = 0;
            if (SWCTRL_BACKDOOR_IsDebugFlagOn(SWCTRL_BACKDOOR_DEBUG_FLAG_SFP_DDM_TRAP))
                BACKDOOR_MGR_Printf("Bias current [SFP %ld] high warning !... (%.2f)\r\n",
                    sfp_index, sfp_ddm_info_measured.tx_bias_current);
        }
        else if ((sfp_ddm_threshold_status.bias_low_warning == 0 ||
                 (sfp_ddm_threshold_status.bias_low_warning == 1 &&
                 sfp_ddm_threshold_status.bias_low_alarm == 1)) &&
                 sfp_ddm_info_measured.tx_bias_current > sfp_ddm_threshold.bias_low_alarm &&
                 sfp_ddm_info_measured.tx_bias_current <= sfp_ddm_threshold.bias_low_warning)
        {
            SWCTRL_SendPortSfpDdmTrap(unit, sfp_index, TRAP_EVENT_SFP_CURRENT_LOW_WARNING);
            status_changed = TRUE;
            sfp_ddm_threshold_status.bias_low_alarm = 0;
            sfp_ddm_threshold_status.bias_low_warning = 1;
            sfp_ddm_threshold_status.bias_high_alarm = 0;
            sfp_ddm_threshold_status.bias_high_warning = 0;
            if (SWCTRL_BACKDOOR_IsDebugFlagOn(SWCTRL_BACKDOOR_DEBUG_FLAG_SFP_DDM_TRAP))
                BACKDOOR_MGR_Printf("Bias current [SFP %ld] low warning !... (%.2f)\r\n",
                    sfp_index, sfp_ddm_info_measured.tx_bias_current);
        }
        else if((sfp_ddm_threshold_status.bias_high_alarm == 1 ||
                 sfp_ddm_threshold_status.bias_high_warning == 1 ||
                 sfp_ddm_threshold_status.bias_low_warning == 1 ||
                 sfp_ddm_threshold_status.bias_low_alarm == 1) &&
                (sfp_ddm_info_measured.tx_bias_current > sfp_ddm_threshold.bias_low_warning) &&
                (sfp_ddm_info_measured.tx_bias_current < sfp_ddm_threshold.bias_high_warning))
        {
            SWCTRL_SendPortSfpDdmTrap(unit, sfp_index, TRAP_EVENT_SFP_CURRENT_ALARMWARN_CEASE);
            status_changed = TRUE;
            if (SWCTRL_BACKDOOR_IsDebugFlagOn(SWCTRL_BACKDOOR_DEBUG_FLAG_SFP_DDM_TRAP))
                BACKDOOR_MGR_Printf("Bias current [SFP %ld] cease!... (%.2f)\r\n",
                    sfp_index, sfp_ddm_info_measured.tx_bias_current);
            sfp_ddm_threshold_status.bias_high_alarm = 0;
            sfp_ddm_threshold_status.bias_low_alarm = 0;
            sfp_ddm_threshold_status.bias_high_warning = 0;
            sfp_ddm_threshold_status.bias_low_warning = 0;
        }
        if(status_changed==TRUE)
        {
            SWCTRL_OM_SetPortSfpDdmThresholdStatus(unit, sfp_index, &sfp_ddm_threshold_status);
        }
    }

    SWCTRL_RETURN_AND_RELEASE_CSC_WITHOUT_RETUEN_VALUE();
}
#endif/* End of #if (SYS_CPNT_SFP_DDM_ALARMWARN_TRAP == TRUE) */

/* Local Functions
 */
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetUPortAutoNegEnable
 * -------------------------------------------------------------------------
 * FUNCTION: This function will set port auto-negotiation enable state
 * INPUT   : unit           -- which unit
 *           port           -- which port to set
 *           autoneg_state  -- VAL_portAutonegotiation_enabled /
 *                             VAL_portAutonegotiation_disabled
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : 1. EA3626A
 *           2. Take effect only when auto mode.
 * -------------------------------------------------------------------------*/
static BOOL_T SWCTRL_SetUPortAutoNegEnable(UI32_T unit, UI32_T port, UI32_T autoneg_state)
{
    UI32_T ifindex;
    BOOL_T retval = FALSE;

    ifindex = SWCTRL_UPORT_TO_IFINDEX (unit, port);

    if (port_info[ifindex-1].port_entry.port_autonegotiation == autoneg_state)
        return TRUE;

    if (autoneg_state == VAL_portAutonegotiation_enabled)
    {
        SWCTRL_LOCK();

#if (SYS_CPNT_SWCTRL_FEC == TRUE)
        user_ext_port_info[ifindex-1].port_fec_status = VAL_portFecMode_disabled;
#endif

        /* I. enable auto-nego
         */
        if((retval = SWDRV_EnablePortAutoNeg(unit, port)) == TRUE)
        {
            port_info[ifindex-1].port_entry.port_autonegotiation = VAL_portAutonegotiation_enabled;

            #if (SYS_CPNT_SUPPORT_FORCED_1000BASE_T_MODE == TRUE)
            retval = SWDRV_SetPort1000BaseTForceMode (unit, port, VAL_portMasterSlaveModeCfg_auto);
            #endif

            /* III. set flowcontrol state: In auto mode: always disabled, dicide by the result of auto-nego
             */
            retval = SWDRV_SetPortCfgFlowCtrl(unit, port, VAL_portFlowCtrlCfg_disabled);

            /* II. set capabilities, that is set when auto-nego is disabled, to driver
             */
            if( (retval = SWDRV_SetPortAutoNegCapability (unit, port, port_info[ifindex-1].port_entry.port_capabilities)) == TRUE)
            {
                SWCTRL_UNLOCK();

                #if (SYS_CPNT_SUPPORT_FORCED_1000BASE_T_MODE == TRUE)
                /* Aaron Chuang, 2005-02-26
                 * Set chipset only when the port is 1000BASE-T forced mode active.
                 * Mean: no neg + speed-duplex (1000f) in copper port
                 */
                if (port_info[ifindex-1].port_entry.port_type == VAL_portType_thousandBaseT &&
                    port_info[ifindex-1].port_entry.port_autonegotiation == VAL_portAutonegotiation_disabled &&
                    port_info[ifindex-1].port_entry.port_speed_dpx_cfg == VAL_portSpeedDpxCfg_fullDuplex1000)
                    retval = SWDRV_SetPort1000BaseTForceMode (unit, port, port_info[ifindex-1].port_entry.port_forced_1000t_mode);
                #endif

            }
            else
            {
                SWCTRL_UNLOCK();
            }
        }
        else
        {
            SWCTRL_UNLOCK();
        }
    }
    else /* VAL_portAutonegotiation_disabled */
    {
        SWCTRL_LOCK();

        /* I. disable auto-nego
         */
        if((retval = SWDRV_DisablePortAutoNeg(unit, port)) == TRUE)
        {
            port_info[ifindex-1].port_entry.port_autonegotiation = VAL_portAutonegotiation_disabled;

            /* II. set force mode speed-duplex, that is set when auto-nego is enabled, to driver
             */
            if( (retval = SWDRV_SetPortCfgSpeedDuplex(unit, port, port_info[ifindex-1].port_entry.port_speed_dpx_cfg)) == TRUE)
            {
                SWCTRL_UNLOCK();

                /* III. set flowcontrol state
                 */
                retval = SWDRV_SetPortCfgFlowCtrl(unit, port, port_info[ifindex-1].port_entry.port_flow_ctrl_cfg);

#if (SYS_CPNT_SWCTRL_FEC == TRUE)
                SWDRV_SetPortFec(unit, port, user_ext_port_info[ifindex-1].port_fec_mode);
                SWDRV_GetPortFecStatus(unit, port, &user_ext_port_info[ifindex-1].port_fec_status);
#endif
            }
            else
            {
                SWCTRL_UNLOCK();
            }
        }
        else
        {
            SWCTRL_UNLOCK();
        }
    }

    return retval;
} /* End of SWCTRL_SetUPortAutoNegEnable () */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetUPortAutoNegCapability
 * -------------------------------------------------------------------------
 * FUNCTION: This function will set port auto-negotiation capability.
 * INPUT   : unit           -- which unit
 *           port           -- which port to set
 *           capability     -- Capabilities to set.
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : 1. EA3626A
 *           2. Should handle a. force mode - 1) force mode speed-duplex
 *                                            2) flowcontrol state
 *                            b. auto mode  - 1) auto mode capability
 * -------------------------------------------------------------------------*/
static BOOL_T SWCTRL_SetUPortAutoNegCapability (UI32_T unit, UI32_T port, UI32_T capability)
{
    UI32_T ifindex;
    BOOL_T retval = FALSE;

    ifindex = SWCTRL_UPORT_TO_IFINDEX (unit, port);

    if (port_info[ifindex-1].port_entry.port_capabilities == capability)
        return TRUE;


    if( port_info[ifindex-1].port_entry.port_autonegotiation == VAL_portAutonegotiation_enabled )
    {
        /* auto-nego enabled
         */
        SWCTRL_LOCK();
        if((retval = SWDRV_SetPortAutoNegCapability(unit, port, capability)) == TRUE)
        {
            port_info[ifindex-1].port_entry.port_capabilities = capability;
        }
        SWCTRL_UNLOCK();
    }
    else
    {
        /* auto-nego disabled
         */
        /* if the auto-nego is disabled when user set the capabilitis,
         * only maintaining the database is necessary.
         * Once the user enable the auto-nego, the value in database will set into chip.
         * Don't set capabilities here, because setting capabilities to driver will make
         * auto-nego restart.
         */
        SWCTRL_LOCK();
        port_info[ifindex-1].port_entry.port_capabilities = capability;
        SWCTRL_UNLOCK();

        retval = TRUE;
    }
    return retval;

} /* End of SWCTRL_SetUPortAutoNegCapability () */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetUPortCfgFlowCtrlEnable
 * -------------------------------------------------------------------------
 * FUNCTION: This function will enable flow control of a port or not
 * INPUT   : unit               -- which unit
 *           port               -- which port to set
 *           flow_contrl_cfg    -- VAL_portFlowCtrlCfg_enabled /
                                   VAL_portFlowCtrlCfg_disabled /
                                   VAL_portFlowCtrlCfg_tx /
                                   VAL_portFlowCtrlCfg_rx
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : 1. ES3626A
 *           2. Take effect only when force mode.
 * -------------------------------------------------------------------------*/
static BOOL_T SWCTRL_SetUPortCfgFlowCtrlEnable(UI32_T unit, UI32_T port, UI32_T flow_control_cfg)
{
    UI32_T ifindex;
    BOOL_T retval = FALSE;

    ifindex = SWCTRL_UPORT_TO_IFINDEX (unit, port);

    if(port_info[ifindex-1].port_entry.port_flow_ctrl_cfg == flow_control_cfg)
    {
        return TRUE;
    }

    if( port_info[ifindex-1].port_entry.port_autonegotiation == VAL_portAutonegotiation_enabled )
    {
        /* auto-nego enabled
         */
        /* if the auto-nego is enabled when user set the flowcontrol state,
         * only maintaining the database is necessary.
         * Once the user disable the auto-nego, the value in database will set into chip.        SWCTRL_LOCK();
         */
        SWCTRL_LOCK();
        port_info[ifindex-1].port_entry.port_flow_ctrl_cfg = flow_control_cfg;
        SWCTRL_UNLOCK();

        retval = TRUE;
    }
    else
    {
        /* auto-nego disabled
         */
        if((retval = SWDRV_SetPortCfgFlowCtrl(unit, port, flow_control_cfg)) == TRUE)
            {
                SWCTRL_LOCK();
            port_info[ifindex-1].port_entry.port_flow_ctrl_cfg = flow_control_cfg;

            if (VAL_portFlowCtrlCfg_disabled == flow_control_cfg)
            {
                port_info[ifindex-1].port_entry.port_flow_ctrl_status = VAL_portFlowCtrlStatus_none;
            }
            SWCTRL_UNLOCK();
        }
    }
    return retval;
}/* end of SWCTRL_SetUPortCfgFlowCtrlEnable () */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetUPortBStormControlRateLimit
 * -------------------------------------------------------------------------
 * FUNCTION: This function will set the rate limit of broadcast
 *           storm control function
 * INPUT   : unit    -- which unit
 *           port    -- which port to set
 *           mode    -- which mode of rate
 *           rate    -- rate after conversion
 *           nRate   -- rate of broadcast amount
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
static BOOL_T SWCTRL_SetUPortBStormControlRateLimit(UI32_T unit,
                                                    UI32_T port,
                                                    UI32_T mode,
                                                    UI32_T rate,
                                                    UI32_T nRate)
{
    BOOL_T retval = FALSE;
    UI32_T i, start_ifindex, end_ifindex;

#if (SYS_CPNT_BSTORM_RATE_PER_PORT_CTRL == FALSE)
    start_ifindex = 1;
    end_ifindex = SYS_ADPT_TOTAL_NBR_OF_LPORT;
#else
    start_ifindex = SWCTRL_UPORT_TO_IFINDEX (unit, port);
    end_ifindex = start_ifindex;
#endif

    SWCTRL_LOCK();
    if((retval = SWDRV_SetBroadcastStormControlThreshold(unit, port, rate, mode)) == TRUE)
    {
        for(i = start_ifindex; i <= end_ifindex; i++)
        {
            port_info[i-1].bcast_storm_entry.bcast_storm_ifindex     = i;
            port_info[i-1].bcast_storm_entry.bcast_storm_sample_type = mode;
            port_info[i-1].bcast_storm_entry.bcast_storm_pkt_rate    = 0;
            port_info[i-1].bcast_storm_entry.bcast_storm_octet_rate  = 0;
            port_info[i-1].bcast_storm_entry.bcast_storm_percent     = 0;
            switch (mode)
            {
                case VAL_bcastStormSampleType_pkt_rate:
                port_info[i-1].bcast_storm_entry.bcast_storm_pkt_rate = nRate;
                break;
                case VAL_bcastStormSampleType_octet_rate:
                port_info[i-1].bcast_storm_entry.bcast_storm_octet_rate = nRate;
                break;
                case VAL_bcastStormSampleType_percent:
                port_info[i-1].bcast_storm_entry.bcast_storm_percent = nRate;
                break;
            }
        }
    }
    SWCTRL_UNLOCK();

    return retval;
} /* End of SWCTRL_SetUPortBStormControlRateLimit() */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetUPortMStormControlRateLimit
 * -------------------------------------------------------------------------
 * FUNCTION: This function will set the rate limit of multicast
 *           storm control function
 * INPUT   : unit    -- which unit
 *           port    -- which port to set
 *           mode    -- which mode of rate
 *           rate    -- rate after conversion
 *           nRate   -- rate of multicast amount
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
static BOOL_T SWCTRL_SetUPortMStormControlRateLimit(UI32_T unit,
                                                    UI32_T port,
                                                    UI32_T mode,
                                                    UI32_T rate,
                                                    UI32_T nRate)
{
    BOOL_T retval = FALSE;
    UI32_T i, start_ifindex, end_ifindex;

#if (SYS_CPNT_MSTORM_RATE_PER_PORT_CTRL == FALSE)
    start_ifindex = 1;
    end_ifindex = SYS_ADPT_TOTAL_NBR_OF_LPORT;
#else
    start_ifindex = SWCTRL_UPORT_TO_IFINDEX (unit, port);
    end_ifindex = start_ifindex;
#endif

    SWCTRL_LOCK();
    if((retval = SWDRV_SetMulticastStormControlThreshold(unit, port, rate, mode)) == TRUE)
    {
        for(i = start_ifindex; i <= end_ifindex; i++)
        {
            port_info[i-1].mcast_storm_entry.mcast_storm_ifindex     = i;
            port_info[i-1].mcast_storm_entry.mcast_storm_sample_type = mode;
            port_info[i-1].mcast_storm_entry.mcast_storm_pkt_rate    = 0;
            port_info[i-1].mcast_storm_entry.mcast_storm_octet_rate  = 0;
            port_info[i-1].mcast_storm_entry.mcast_storm_percent     = 0;
            switch (mode)
            {
                case VAL_mcastStormSampleType_pkt_rate:
                port_info[i-1].mcast_storm_entry.mcast_storm_pkt_rate = nRate;
                break;
                case VAL_mcastStormSampleType_octet_rate:
                port_info[i-1].mcast_storm_entry.mcast_storm_octet_rate = nRate;
                break;
                case VAL_mcastStormSampleType_percent:
                port_info[i-1].mcast_storm_entry.mcast_storm_percent = nRate;
                break;
            }
        }
    }
    SWCTRL_UNLOCK();

    return retval;
} /* End of SWCTRL_SetUPortMStormControlRateLimit() */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetUPortBroadcastStormStatus
 * -------------------------------------------------------------------------
 * FUNCTION: This function will enable the broadcast storm control function
 * INPUT   : unit -- which unit
 *           port -- which port to set
 *           broadcast_storm_status -- VAL_bcastStormStatus_enabled
 *                                     VAL_bcastStormStatus_disabled
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
static BOOL_T SWCTRL_SetUPortBroadcastStormStatus(UI32_T unit,
                                                  UI32_T port,
                                                  UI32_T broadcast_storm_status)
{
    BOOL_T retval = FALSE;
    UI32_T i, start_ifindex, end_ifindex;

#if (SYS_CPNT_BSTORM_ENABLE_PER_PORT == FALSE)
    start_ifindex = 1;
    end_ifindex = SYS_ADPT_TOTAL_NBR_OF_LPORT;
#else
    start_ifindex = SWCTRL_UPORT_TO_IFINDEX (unit, port);
    end_ifindex = start_ifindex;
#endif

    if(port_info[start_ifindex-1].bcast_storm_entry.bcast_storm_status == broadcast_storm_status)
        return TRUE;

    SWCTRL_LOCK();
    if (broadcast_storm_status == VAL_bcastStormStatus_enabled)
        retval = SWDRV_EnableBroadcastStormControl (unit, port);
    else /* VAL_bcastStormStatus_disabled */
        retval = SWDRV_DisableBroadcastStormControl (unit, port);

    if (retval)
        for(i = start_ifindex; i <= end_ifindex; i++)
            port_info[i-1].bcast_storm_entry.bcast_storm_status = broadcast_storm_status;
    SWCTRL_UNLOCK();

    return retval;
} /* end of SWCTRL_SetUPortBroadcastStormStatus () */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetUPortMulticastStormStatus
 * -------------------------------------------------------------------------
 * FUNCTION: This function will enable the multicast storm control function
 * INPUT   : unit -- which unit
 *           port -- which port to set
 *           multicast_storm_status -- VAL_bcastStormStatus_enabled
 *                                     VAL_bcastStormStatus_disabled
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
static BOOL_T SWCTRL_SetUPortMulticastStormStatus(UI32_T unit,
                                                  UI32_T port,
                                                  UI32_T multicast_storm_status)
{
    BOOL_T retval = FALSE;
    UI32_T i, start_ifindex, end_ifindex;

#if (SYS_CPNT_MSTORM_ENABLE_PER_PORT == FALSE)
    start_ifindex = 1;
    end_ifindex = SYS_ADPT_TOTAL_NBR_OF_LPORT;
#else
    start_ifindex = SWCTRL_UPORT_TO_IFINDEX (unit, port);
    end_ifindex = start_ifindex;
#endif

    if(port_info[start_ifindex-1].mcast_storm_entry.mcast_storm_status == multicast_storm_status)
        return TRUE;

    SWCTRL_LOCK();
    if (multicast_storm_status == VAL_mcastStormStatus_enabled)
        retval = SWDRV_EnableMulticastStormControl (unit, port);
    else /* VAL_mcastStormStatus_disabled */
        retval = SWDRV_DisableMulticastStormControl (unit, port);

    if (retval)
        for(i = start_ifindex; i <= end_ifindex; i++)
            port_info[i-1].mcast_storm_entry.mcast_storm_status = multicast_storm_status;
    SWCTRL_UNLOCK();

    return retval;
} /* end of SWCTRL_SetUPortMulticastStormStatus () */

#if (SYS_CPNT_STORM_MODE & SYS_CPNT_STORM_UNKNOWN_USTORM)
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetUPortUnknownUStormControlRateLimit
 * -------------------------------------------------------------------------
 * FUNCTION: This function will set the rate limit of unknown unicast
 *           storm control function
 * INPUT   : unit    -- which unit
 *           port    -- which port to set
 *           mode    -- which mode of rate
 *           rate    -- rate after conversion
 *           nRate   -- rate of unknown unicast amount
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
static BOOL_T SWCTRL_SetUPortUnknownUStormControlRateLimit(UI32_T unit, UI32_T port, UI32_T mode, UI32_T rate, UI32_T nRate)
{
    BOOL_T retval = FALSE;
    UI32_T i, start_ifindex, end_ifindex;

#if (SYS_CPNT_MSTORM_RATE_PER_PORT_CTRL == FALSE)
    start_ifindex = 1;
    end_ifindex = SYS_ADPT_TOTAL_NBR_OF_LPORT;
#else
    start_ifindex = SWCTRL_UPORT_TO_IFINDEX (unit, port);
    end_ifindex = start_ifindex;
#endif

    SWCTRL_LOCK();
    if((retval = SWDRV_SetUnknownUnicastStormControlThreshold(unit, port, rate, mode)) == TRUE)
    {
        for(i = start_ifindex; i <= end_ifindex; i++)
        {
            port_info[i-1].unknown_ucast_storm_entry.unknown_ucast_storm_ifindex     = i;
            port_info[i-1].unknown_ucast_storm_entry.unknown_ucast_storm_sample_type = mode;
            port_info[i-1].unknown_ucast_storm_entry.unknown_ucast_storm_pkt_rate    = 0;
            port_info[i-1].unknown_ucast_storm_entry.unknown_ucast_storm_octet_rate  = 0;
            port_info[i-1].unknown_ucast_storm_entry.unknown_ucast_storm_percent     = 0;
            switch (mode)
            {
                case VAL_unkucastStormSampleType_pkt_rate:
                port_info[i-1].unknown_ucast_storm_entry.unknown_ucast_storm_pkt_rate = nRate;
                break;
                case VAL_unkucastStormSampleType_octet_rate:
                port_info[i-1].unknown_ucast_storm_entry.unknown_ucast_storm_octet_rate = nRate;
                break;
                case VAL_unkucastStormSampleType_percent:
                port_info[i-1].unknown_ucast_storm_entry.unknown_ucast_storm_percent = nRate;
                break;
            }
        }
    }
    SWCTRL_UNLOCK();

    return retval;
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetUPortUnknownUnicastStormStatus
 * -------------------------------------------------------------------------
 * FUNCTION: This function will enable the unknown unicast storm control function
 * INPUT   : unit -- which unit
 *           port -- which port to set
 *           unknowunicast_storm_status -- VAL_bcastStormStatus_enabled
 *                                         VAL_bcastStormStatus_disabled
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
static BOOL_T SWCTRL_SetUPortUnknownUnicastStormStatus(UI32_T unit, UI32_T port, UI32_T unknowunicast_storm_status)
{
    BOOL_T retval = FALSE;
    UI32_T i, start_ifindex, end_ifindex;

#if (SYS_CPNT_MSTORM_ENABLE_PER_PORT == FALSE)
    start_ifindex = 1;
    end_ifindex = SYS_ADPT_TOTAL_NBR_OF_LPORT;
#else
    start_ifindex = SWCTRL_UPORT_TO_IFINDEX (unit, port);
    end_ifindex = start_ifindex;
#endif

    if(port_info[start_ifindex-1].unknown_ucast_storm_entry.unknown_ucast_storm_status == unknowunicast_storm_status)
        return TRUE;

    SWCTRL_LOCK();
    if (unknowunicast_storm_status == VAL_unkucastStormStatus_enabled)
        retval = SWDRV_EnableUnknownUnicastStormControl (unit, port);
    else /* VAL_unkucastStormStatus_disabled */
        retval = SWDRV_DisableUnknownUnicastStormControl (unit, port);

    if (retval)
        for(i = start_ifindex; i <= end_ifindex; i++)
            port_info[i-1].unknown_ucast_storm_entry.unknown_ucast_storm_status = unknowunicast_storm_status;
    SWCTRL_UNLOCK();

    return retval;
}
#endif


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetUPortAdminStatus
 * -------------------------------------------------------------------------
 * FUNCTION: This function will enable the admin status of a user port.
 * INPUT   : unit -- which unit
 *           port -- which port to set
 *           admin_status -- VAL_ifAdminStatus_up
 *                           VAL_ifAdminStatus_down
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : 1. all SWCTRL APIs should not call this directly,
 *              please use SWCTRL_SetPortStatus_Local instead.
 * -------------------------------------------------------------------------*/
static BOOL_T SWCTRL_SetUPortAdminStatus (UI32_T unit, UI32_T port, UI32_T admin_status)
{
    BOOL_T retval = FALSE;
    UI32_T ifindex, event;

    ifindex = SWCTRL_UPORT_TO_IFINDEX (unit, port);

    if (admin_status == VAL_ifAdminStatus_up)
    {
        event = SWCTRL_ADMIN_ENABLE_EVENT;

#if (SYS_CPNT_3COM_LOOPBACK_TEST == TRUE)
        if (TRUE == user_ext_port_info[ifindex-1].is_loopback_test_failed)
        {
            /* loopback test failed port:
             * only maintain database is necessary
             */
            retval = TRUE;

            SWCTRL_LOCK();
            port_info[ifindex-1].admin_status = VAL_ifAdminStatus_up;
            SWCTRL_UNLOCK();
        }
        else
        {
#endif
            /* loopback test passed port:
             * set ASIC and maintain database
             */
        SWCTRL_LOCK();
        if((retval = SWDRV_EnablePortAdmin(unit, port)) == TRUE)
        {
#ifdef NOVAL
            BCMDRV_ClearSecViolationDisablePort(ifindex);
#endif
            port_info[ifindex-1].admin_status = VAL_ifAdminStatus_up;
        }
        SWCTRL_UNLOCK();

#if (SYS_CPNT_3COM_LOOPBACK_TEST == TRUE)
        }
#endif

        if (retval)
        {
            SWCTRL_Notify_uPortAdminEnable(unit, port);
        }
    }
    else
    {
        event = SWCTRL_ADMIN_DISABLE_EVENT;

#if (SYS_CPNT_3COM_LOOPBACK_TEST == TRUE)
        if (TRUE == user_ext_port_info[ifindex-1].is_loopback_test_failed)
        {
            /* loopback test failed port:
             * only maintain database is necessary
             */
            retval = TRUE;

            SWCTRL_LOCK();
            port_info[ifindex-1].admin_status = VAL_ifAdminStatus_down;
            SWCTRL_UNLOCK();
        }
        else
        {
#endif

            /* loopback test passed port:
             * set ASIC and maintain database
             */
            SWCTRL_LOCK();
            if((retval = SWDRV_DisablePortAdmin(unit, port)) == TRUE)
            {
                port_info[ifindex-1].admin_status = VAL_ifAdminStatus_down;
            }
            SWCTRL_UNLOCK();

#if (SYS_CPNT_3COM_LOOPBACK_TEST == TRUE)
        }
#endif

        if (retval)
        {
            SWCTRL_Notify_uPortAdminDisable(unit, port);
        }
    }

    if (retval)
    {
        SWCTRL_LinkOperStateMachineChangeState (ifindex, event);
    }

    return retval;
} /* End of SWCTRL_SetUPortAdminStatus () */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetUPortCfgSpeedDuplex
 * -------------------------------------------------------------------------
 * FUNCTION: This function will set port auto-negotiation capability.
 * INPUT   : unit           -- which unit
 *           port           -- which port to set
 *           speed_duplex   -- speed-duplex to set.
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : 1. EA3626A
 *           2. Take effect only when force mode.
 * -------------------------------------------------------------------------*/
static BOOL_T SWCTRL_SetUPortCfgSpeedDuplex (UI32_T unit, UI32_T port, UI32_T speed_duplex)
{
    UI32_T ifindex;
    BOOL_T retval = FALSE;

    ifindex = SWCTRL_UPORT_TO_IFINDEX (unit, port);

    if (port_info[ifindex-1].port_entry.port_speed_dpx_cfg == speed_duplex)
        return TRUE;

    if( port_info[ifindex-1].port_entry.port_autonegotiation == VAL_portAutonegotiation_enabled )
    {
        /* auto-nego enabled
         */
        /* if the auto-nego is disabled when user set the force speed-duplex config,
         * only maintaining the database is necessary.
         * Once the user enable the auto-nego, the value in database will set into chip.
         */
        SWCTRL_LOCK();
        port_info[ifindex-1].port_entry.port_speed_dpx_cfg = speed_duplex;
        #if (SYS_CPNT_SUPPORT_COMBO_PORT_NO_NEG_KEEP == TRUE)
        if (port_info[ifindex-1].port_entry.port_type == VAL_portType_thousandBaseT)
            port_info[ifindex-1].port_entry.port_combo_copper_speed_dpx_cfg = speed_duplex;
        else
            port_info[ifindex-1].port_entry.port_combo_fiber_speed_dpx_cfg = speed_duplex;
        #endif
        SWCTRL_UNLOCK();

        retval = TRUE;
    }
    else
    {
        /* auto-nego disabled
         */
        SWCTRL_LOCK();
        if((retval = SWDRV_SetPortCfgSpeedDuplex(unit, port, speed_duplex)) == TRUE)
        {
            port_info[ifindex-1].port_entry.port_speed_dpx_cfg = speed_duplex;
            #if (SYS_CPNT_SUPPORT_COMBO_PORT_NO_NEG_KEEP == TRUE)
            if (port_info[ifindex-1].port_entry.port_type == VAL_portType_thousandBaseT)
                port_info[ifindex-1].port_entry.port_combo_copper_speed_dpx_cfg = speed_duplex;
            else
                port_info[ifindex-1].port_entry.port_combo_fiber_speed_dpx_cfg = speed_duplex;
            #endif
        }
        SWCTRL_UNLOCK();
    }

    return retval;
} /* End of SWDRV_SetPortCfgSpeedDuplex () */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_LinkOperStateMachineChangeState
 * -------------------------------------------------------------------------
 * FUNCTION: Event deiven state machine/
 * INPUT   : ifindex -- which interface
 *           event -- which event ( link status/admin status/duplex status/lacp status )
                SWCTRL_LINK_UP_EVENT/SWCTRL_LINK_DOWN_EVENT/SWCTRL_ADMIN_ENABLE_EVENT/SWCTRL_ADMIN_DISABLE_EVENT/
                SWCTRL_DUPLEX_FULL_EVENT/SWCTRL_DUPLEX_HALF_EVENT/SWCTRL_LACP_ENABLE_EVENT/SWCTRL_LACP_DISABLE_EVENT/
                SWCTRL_LACP_COLLECTING_EVENT/SWCTRL_LACP_DETACHED_EVENT
 * OUTPUT  : None
 * RETURN  : BOOL_T -- the state is changed or not
 * NOTE    : None.
 * -------------------------------------------------------------------------*/
static BOOL_T SWCTRL_LinkOperStateMachineChangeState(UI32_T ifindex, UI32_T event)
{
    UI32_T old_state, new_state;
    UI32_T old_level, new_level;

    if ( SWCTRL_ProcessLinkOperStateMachine(ifindex, event, &old_state, &new_state, &old_level, &new_level, TRUE) )
    {
        UI32_T  unit, port;
        if (SWCTRL_IS_TRUNK (ifindex))
        {
            unit = 0;
            port = 0;
        }
        else
        {
            unit = SWCTRL_IFINDEX_TO_UNIT(ifindex);
            port = SWCTRL_IFINDEX_TO_PORT(ifindex);
        }
        SWCTRL_ProcessLinkOperStatusChangeNotifying(ifindex, unit, port, event, old_state, new_state, old_level, new_level);
        SWCTRL_ProcessLinkOperStatusChangePostproc(ifindex, event, old_state, new_state, old_level, new_level, TRUE);
        return TRUE;

    }
    else
    {
        return FALSE;
    }
} /* End of SWCTRL_LinkOperStateMachineChangeState */

static BOOL_T SWCTRL_ProcessLinkOperStateMachine(UI32_T ifindex, UI32_T event, UI32_T *old_state, UI32_T *new_state, UI32_T *old_level, UI32_T *new_level, BOOL_T lock)
{
    UI32_T current_state;
    UI32_T next_state;

    UI32_T current_level, next_level;
    UI32_T dormant_status;

    UI32_T unit = 0; /*to remove compile warring*/
    UI32_T port = 0; /*to remove compile warring*/

    BOOL_T is_present;
    BOOL_T is_duplex_full;
    BOOL_T is_admin_enable;
    BOOL_T is_dot1x_enable;
    BOOL_T is_lacp_enable;
#if (SYS_CPNT_INTERNAL_LOOPBACK_TEST == TRUE)
    BOOL_T is_int_loopback_mode;
#endif
#if (SYS_CPNT_EFM_OAM == TRUE)
    BOOL_T is_oam_loopback_mode;
#endif

    SWCTRL_SEMLOCK(lock);
    current_state = port_info[ifindex-1].link_oper_status;
    next_state    = 0;   /*invalid state*/

    if (current_state == VAL_ifOperStatus_dormant)
    {
        current_level = port_info[ifindex-1].link_oper_status_level;
    }
    else
    {
        current_level = 0;
    }
    next_level = current_level;

    dormant_status = port_info[ifindex-1].link_oper_dormant_active;

    is_present      = SWCTRL_IS_EXIST(ifindex);
    is_duplex_full  = SWCTRL_IS_FULL_DUPLEX (ifindex);
    is_admin_enable = (port_info[ifindex-1].admin_status == VAL_ifAdminStatus_up ? TRUE : FALSE);
    if (SWCTRL_IS_TRUNK (ifindex))
    {
        /* if this ifindex is belong to trunk,
         * these 2 status could be viewed as disable
         */
        is_dot1x_enable = FALSE;
        is_lacp_enable  = FALSE;

#if (SYS_CPNT_INTERNAL_LOOPBACK_TEST == TRUE)
        is_int_loopback_mode = FALSE;
#endif

#if (SYS_CPNT_EFM_OAM == TRUE)
        is_oam_loopback_mode = FALSE;
#endif
    }
    else
    {
        unit = SWCTRL_IFINDEX_TO_UNIT(ifindex);
        port = SWCTRL_IFINDEX_TO_PORT(ifindex);

        is_dot1x_enable = (user_ext_port_info[ifindex-1].dot1x_status == SWCTRL_DOT1X_PORT_ENABLE   ? TRUE : FALSE);

#if (SYS_CPNT_STATIC_TRUNK_CONFIG_ALLOWED_ON_LACP_PORT == TRUE)
        is_lacp_enable  = (user_ext_port_info[ifindex-1].lacp_oper_status  == VAL_lacpPortStatus_enabled ? TRUE : FALSE);
#else
        is_lacp_enable  = (user_ext_port_info[ifindex-1].lacp_status  == VAL_lacpPortStatus_enabled ? TRUE : FALSE);
#endif

#if (SYS_CPNT_INTERNAL_LOOPBACK_TEST == TRUE)
        is_int_loopback_mode = user_ext_port_info[ifindex-1].is_int_loopback_mode;
#endif

#if (SYS_CPNT_EFM_OAM == TRUE)
        is_oam_loopback_mode = user_ext_port_info[ifindex-1].is_oam_loopback_mode;
#endif
    }
    SWCTRL_SEMUNLOCK(lock);

#if (SYS_CPNT_3COM_LOOPBACK_TEST == TRUE)
    if (FALSE == SWCTRL_IS_TRUNK (ifindex) &&
        TRUE  == user_ext_port_info[ifindex-1].is_loopback_test_failed)
    {
        /* loopback test failed user port:
         * only 3 state for this kinf of port
         * 1) VAL_ifOperStatus_down
         * 2) VAL_ifOperStatus_notPresent
         * 3) VAL_ifOperStatus_lowerLayerDown
         */
        switch(event)
        {
        case SWCTRL_HOT_SWAP_INSERT_EVENT:
            /* S'pose this event occurs only when not present
             */
            if( current_state == VAL_ifOperStatus_notPresent )
            {
                 next_state = VAL_ifOperStatus_lowerLayerDown;
            }
            break;

        case SWCTRL_HOT_SWAP_REMOVE_EVENT:
            /* To not present state from any state
             */
            next_state = VAL_ifOperStatus_notPresent;
            break;

        case SWCTRL_LINK_UP_EVENT:
            /* from link-down to link-up, no matter other factors,
             * view as "down", because loopback test failed port is
             * admin-down in ASIC.
             */
            if (current_state == VAL_ifOperStatus_lowerLayerDown )
            {
                next_state = VAL_ifOperStatus_down;
            }
            break;

        case SWCTRL_LINK_DOWN_EVENT:
            /* S'pose this event doesn't occur when not present
             */
            if( current_state != VAL_ifOperStatus_notPresent )
            {
                next_state = VAL_ifOperStatus_lowerLayerDown;
            }
            break;

        case SWCTRL_DUPLEX_FULL_EVENT:
        case SWCTRL_DUPLEX_HALF_EVENT:
        case SWCTRL_ADMIN_ENABLE_EVENT:
        case SWCTRL_ADMIN_DISABLE_EVENT:
        case SWCTRL_LACP_ENABLE_EVENT:
        case SWCTRL_LACP_DISABLE_EVENT:
        case SWCTRL_LACP_COLLECTING_EVENT:
        case SWCTRL_LACP_DETACHED_EVENT:
        case SWCTRL_DOT1X_ENABLE_EVENT:
        case SWCTRL_DOT1X_DISABLE_EVENT:
        case SWCTRL_DOT1X_AUTHORIZED_EVENT:
        case SWCTRL_DOT1X_UNAUTHORIZED_EVENT:
        default:
            /* do nothing, keep original state
             */
            break;
        }
    }
    else
    {
#endif

        /* 1) loopback test passed user port, or
         * 2) trunk port
         */
    switch(event)
    {
    case SWCTRL_HOT_SWAP_INSERT_EVENT:
        /* S'pose this event occurs only when not present
         */
        if( current_state == VAL_ifOperStatus_notPresent )
        {
             next_state = VAL_ifOperStatus_lowerLayerDown;
        }
        break;

    case SWCTRL_HOT_SWAP_REMOVE_EVENT:
         /* To not present state from any state
          */
         next_state = VAL_ifOperStatus_notPresent;
         break;

    case SWCTRL_LINK_UP_EVENT:
        /* S'pose this event occurs only when low layer down state
         */
        if( current_state == VAL_ifOperStatus_lowerLayerDown )
        {
            /* low layer down => testing
             */
#if (SYS_CPNT_INTERNAL_LOOPBACK_TEST == TRUE)
            if (is_int_loopback_mode)
            {
                next_state = VAL_ifOperStatus_testing;
                break;
            }
#endif

#if (SYS_CPNT_EFM_OAM == TRUE)
            if (is_oam_loopback_mode)
            {
                next_state = VAL_ifOperStatus_testing;
                break;
            }
#endif

            /* 1) admin disable: low layer down => down
             */
            if( is_admin_enable == FALSE )
            {
                next_state = VAL_ifOperStatus_down;
                break;
            }

            if (!SWCTRL_ProcessLinkOperStateMachineForDormant(ifindex, event, current_state, &next_state, current_level, &next_level, dormant_status))
            {
                next_state = VAL_ifOperStatus_up;
            }
        }
        break;

    case SWCTRL_LINK_DOWN_EVENT:
        /* S'pose this event doesn't occur when not present
         */
        if( current_state != VAL_ifOperStatus_notPresent )
        {
            next_state = VAL_ifOperStatus_lowerLayerDown;
        }
        break;

    case SWCTRL_ADMIN_ENABLE_EVENT:
        /* this event only make state change when port down,
         * if port is low layer down or not present, state not change
         */
        if( current_state == VAL_ifOperStatus_down )
        {
            if (SWCTRL_IS_TRUNK(ifindex))
            {
                next_state = SWCTRL_CalculateTrunkOperStatus(SWCTRL_IFINDEX_TO_TRUNKID(ifindex));

                if (next_state == VAL_ifOperStatus_dormant)
                {
                    next_level = SWCTRL_OPER_DORMANT_LV_LOWERLAYER;
                    break;
                }
            }

            if (!SWCTRL_ProcessLinkOperStateMachineForDormant(ifindex, event, current_state, &next_state, current_level, &next_level, dormant_status))
            {
                next_state = VAL_ifOperStatus_up;
            }
        }
        break;

    case SWCTRL_ADMIN_DISABLE_EVENT:
        /* this event only make state change when dormant-lacp, dormant-dot1x or up,
         * if port is low layer down or not present, state not change
         */
        if( current_state == VAL_ifOperStatus_up                   ||
            current_state == VAL_ifOperStatus_dormant )
        {
            next_state = VAL_ifOperStatus_down;
        }
        break;

    case SWCTRL_DORMANT_ENABLE_EVENT:
        if( current_state == VAL_ifOperStatus_up                  ||
            current_state == VAL_ifOperStatus_dormant)
        {
            if (SWCTRL_IS_TRUNK(ifindex))
            {
                next_state = SWCTRL_CalculateTrunkOperStatus(SWCTRL_IFINDEX_TO_TRUNKID(ifindex));

                if (next_state == VAL_ifOperStatus_dormant)
                {
                    next_level = SWCTRL_OPER_DORMANT_LV_LOWERLAYER;
                    break;
                }
            }

            if (!SWCTRL_ProcessLinkOperStateMachineForDormant(ifindex, event, current_state, &next_state, current_level, &next_level, dormant_status))
            {
                next_state = VAL_ifOperStatus_up;
            }
        }
        break;

    case SWCTRL_DORMANT_DISABLE_EVENT:
        if( current_state == VAL_ifOperStatus_dormant)
        {
            if (!SWCTRL_ProcessLinkOperStateMachineForDormant(ifindex, event, current_state, &next_state, current_level, &next_level, dormant_status))
            {
                next_state = VAL_ifOperStatus_up;
            }
        }
        break;

    case SWCTRL_LOOPBACK_START_EVENT:
        if( current_state != VAL_ifOperStatus_notPresent          &&
            current_state != VAL_ifOperStatus_lowerLayerDown      )
        {
            next_state = VAL_ifOperStatus_testing;
        }
        break;

    case SWCTRL_LOOPBACK_STOP_EVENT:
        if( current_state == VAL_ifOperStatus_testing )
        {
            /* stay at testing
             */
#if (SYS_CPNT_INTERNAL_LOOPBACK_TEST == TRUE)
            if (is_int_loopback_mode)
            {
                break;
            }
#endif

#if (SYS_CPNT_EFM_OAM == TRUE)
            if (is_oam_loopback_mode)
            {
                break;
            }
#endif

            /* 1) admin disable: testing => down
             */
            if( is_admin_enable == FALSE )
            {
                next_state = VAL_ifOperStatus_down;
                break;
            }

            if (!SWCTRL_ProcessLinkOperStateMachineForDormant(ifindex, event, current_state, &next_state, current_level, &next_level, dormant_status))
            {
                next_state = VAL_ifOperStatus_up;
            }
        }
        break;

    case SWCTRL_LOWER_LAYER_CHANGED_EVENT:
        next_state = SWCTRL_CalculateTrunkOperStatus(SWCTRL_IFINDEX_TO_TRUNKID(ifindex));

        /* all member down
         */
        if (next_state == VAL_ifOperStatus_lowerLayerDown)
        {
            break;
        }

        /* admin down
         */
        if (!is_admin_enable)
        {
            next_state = VAL_ifOperStatus_down;
            break;
        }

        /* lower layer dormant
         */
        if (next_state == VAL_ifOperStatus_dormant)
        {
            next_level = SWCTRL_OPER_DORMANT_LV_LOWERLAYER;
            break;
        }

        /* lower layer state: up -> up
         *
         * LOWER_LAYER_CHANGED_EVENT only consider lower layer changes,
         * so keep original state & level.
         */
        if (current_state == VAL_ifOperStatus_dormant &&
            current_level > SWCTRL_OPER_DORMANT_LV_LOWERLAYER)
        {
            next_state = current_state;
            break;
        }

        /* lower layer state: up -> up
         *
         * LOWER_LAYER_CHANGED_EVENT only consider lower layer changes,
         * so keep original state & level.
         */
        if (current_state == VAL_ifOperStatus_up)
        {
            break;
        }

        /* lower layer state: not_up -> up
         */
        SWCTRL_ProcessLinkOperStateMachineForDormant(ifindex, event, current_state, &next_state, current_level, &next_level, dormant_status);
        break;

    default:
        return FALSE;
    }
#if (SYS_CPNT_3COM_LOOPBACK_TEST == TRUE)
    }
#endif

    if ((current_state != next_state || current_level != next_level) && next_state != 0)
    {
        SWCTRL_SEMLOCK(lock);
        port_info[ifindex-1].link_oper_status = next_state;
        port_info[ifindex-1].link_oper_status_level = next_level;
        SWCTRL_SEMUNLOCK(lock);
        *new_state  = next_state;
        *old_state  = current_state;
        *new_level = next_level;
        *old_level = current_level;
    }
    else
    {
        return FALSE;
    }

    /* print debug message
     */
    if (SWCTRL_BACKDOOR_IsDebugFlagOn (SWCTRL_BACKDOOR_DEBUG_FLAG_PORT_OPER_STATUS_CHANGED))
    {
        SWCTRL_PrintDebugMsgIfOperStatusChanged (ifindex, next_state);
    }

    /* link_oper_status_last_change */
    SWCTRL_UPDATE_LINK_OPER_STATUS_LAST_CHANGE_TIME(ifindex);

    if (SWCTRL_OPER_IS_OPER_UP(*new_state))
    {
        SWCTRL_UPDATE_LINK_OPER_STATUS_LAST_UP_TIME(ifindex);
    }

    return TRUE;
} /* end of SWCTRL_ProcessLinkOperStateMachine() */

/* TRUE: change state to dormant
 * FALSE: state is not changed
 */
static BOOL_T SWCTRL_ProcessLinkOperStateMachineForDormant(UI32_T ifindex, UI32_T event, UI32_T old_state, UI32_T *new_state, UI32_T old_level, UI32_T *new_level, UI32_T dormant_status)
{
    SWCTRL_OperDormantLevel_T level;

    for (level = 0; level < SWCTRL_OPER_DORMANT_LV_MAX; level++)
    {
        if ((dormant_status & BIT_VALUE(level)))
        {
            *new_state = VAL_ifOperStatus_dormant;
            *new_level = level;
            return TRUE;
        }
    }

    return FALSE;
}

static void SWCTRL_ProcessLinkOperStatusChangePostproc(UI32_T ifindex, UI32_T event, UI32_T current_state, UI32_T next_state, UI32_T current_level, UI32_T next_level, BOOL_T lock)
{
    SWCTRL_SEMLOCK(lock);

    if (current_state == VAL_ifOperStatus_testing || next_state == VAL_ifOperStatus_testing)
    {
        SWCTRL_ProcessLinkOperStatusChangePostproc_ToOrFromTesting(ifindex, event, current_state, next_state);
    }

    SWCTRL_ProcessLinkOperStatusChangePostproc_ForDormant(ifindex, event, current_state, next_state, current_level, next_level);

    SWCTRL_SEMUNLOCK(lock);
}

static void SWCTRL_ProcessLinkOperStatusChangePostproc_ToOrFromTesting(UI32_T ifindex, UI32_T event, UI32_T current_state, UI32_T next_state)
{
    UI32_T unit, port;

    if (SWCTRL_IS_TRUNK(ifindex))
    {
        return;
    }

    unit = SWCTRL_IFINDEX_TO_UNIT(ifindex);
    port = SWCTRL_IFINDEX_TO_PORT(ifindex);

    /* oper status changed from testing:
     * 1. restore broadcast storm
     */
    if (current_state == VAL_ifOperStatus_testing)
    {
        if (port_info[ifindex-1].bcast_storm_entry.bcast_storm_status == VAL_bcastStormStatus_enabled)
        {
            SWDRV_EnableBroadcastStormControl(unit, port);
        }

#if (SYS_CPNT_ATC_BSTORM == TRUE)
        if (port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_traffic_control_on == SWCTRL_ATC_BROADCAST_STORM_TC_ON_ENABLE &&
            port_info[ifindex-1].atc_broadcast_storm_entry.state_machine_action == VAL_atcBcastStormTcAction_rate_control)
        {
            SWDRV_EnableATCBroadcastStormControl(unit, port);
        }
#endif
    }

    /* oper status changed to testing:
     * 1. disable broadcast storm
     */
    if (next_state == VAL_ifOperStatus_testing)
    {
        if (port_info[ifindex-1].bcast_storm_entry.bcast_storm_status == VAL_bcastStormStatus_enabled)
        {
            SWDRV_DisableBroadcastStormControl(unit, port);
        }

#if (SYS_CPNT_ATC_BSTORM == TRUE)
        if (port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_traffic_control_on == SWCTRL_ATC_BROADCAST_STORM_TC_ON_ENABLE &&
            port_info[ifindex-1].atc_broadcast_storm_entry.state_machine_action == VAL_atcBcastStormTcAction_rate_control)
        {
            SWDRV_DisableATCBroadcastStormControl(unit, port);
        }
#endif
    }
}

static void SWCTRL_ProcessLinkOperStatusChangePostproc_ForDormant(UI32_T ifindex, UI32_T event, UI32_T current_state, UI32_T next_state, UI32_T current_level, UI32_T next_level)
{
    SWCTRL_OperDormantLevel_T level, level_start;

    if (next_state == VAL_ifOperStatus_up)
    {
        level_start = SWCTRL_OPER_DORMANT_LV_MAX;
    }
    else if (next_state == VAL_ifOperStatus_dormant)
    {
        level_start = next_level;
    }
    else
    {
        level_start = 0;
    }

    for (level = level_start; level < SWCTRL_OPER_DORMANT_LV_MAX; level++)
    {
        if ((port_info[ifindex-1].link_oper_dormant_status & BIT_VALUE(level)))
        {
            port_info[ifindex-1].link_oper_dormant_active |= BIT_VALUE(level);
        }
    }
}

static void   SWCTRL_ProcessLinkOperStatusChangeNotifying(UI32_T ifindex, UI32_T unit, UI32_T port, UI32_T event, UI32_T current_state, UI32_T next_state, UI32_T current_level, UI32_T next_level)
{
    /* send trap
     */
    {
        TRAP_EVENT_TrapData_T     trap_data;
        UI32_T                    trap_style;

        if (!SWCTRL_OPER_IS_LINK_UP(current_state) &&
            SWCTRL_OPER_IS_LINK_UP(next_state))
        {
            trap_data.trap_type = TRAP_EVENT_LINK_UP;
            trap_data.community_specified = FALSE;

            /* handle user port
             */
            trap_data.u.link_up.instance_ifindex = ifindex;
            trap_data.u.link_up.ifindex = ifindex;
            trap_data.u.link_up.instance_adminstatus = ifindex;
            trap_data.u.link_up.adminstatus = port_info[ifindex-1].admin_status;
            trap_data.u.link_up.instance_operstatus = ifindex;
            trap_data.u.link_up.operstatus = port_info[ifindex-1].link_oper_status;
            trap_data.u.link_up.speed_duplex = port_info[ifindex-1].port_entry.port_speed_dpx_status;

            if( port_info[ifindex-1].link_change_trap == VAL_ifLinkUpDownTrapEnable_enabled)
            {
                trap_style = TRAP_EVENT_SEND_TRAP_OPTION_LOG_AND_TRAP;
            }
            else
            {
                trap_style = TRAP_EVENT_SEND_TRAP_OPTION_LOG_ONLY;
            }

#if (SYS_CPNT_TRAPMGMT == TRUE)
            TRAP_MGR_ReqSendTrapOptional(&trap_data, trap_style);
#else
            SNMP_PMGR_ReqSendTrapOptional(&trap_data, trap_style);
#endif
        } /* link up */

        if (SWCTRL_OPER_IS_LINK_UP(current_state) &&
            !SWCTRL_OPER_IS_LINK_UP(next_state))
        {
            /* send trap */
            trap_data.trap_type = TRAP_EVENT_LINK_DOWN;
            trap_data.community_specified = FALSE;

            /* handle user port
             */
            trap_data.u.link_down.instance_ifindex = ifindex;
            trap_data.u.link_down.ifindex = ifindex;
            trap_data.u.link_down.instance_adminstatus = ifindex;
            trap_data.u.link_down.adminstatus = port_info[ifindex-1].admin_status;
            trap_data.u.link_down.instance_operstatus = ifindex;
            trap_data.u.link_down.operstatus = port_info[ifindex-1].link_oper_status;

            if(port_info[ifindex-1].link_change_trap == VAL_ifLinkUpDownTrapEnable_enabled)
            {
                trap_style = TRAP_EVENT_SEND_TRAP_OPTION_LOG_AND_TRAP;
            }
            else
            {
                trap_style = TRAP_EVENT_SEND_TRAP_OPTION_LOG_ONLY;
            }

#if (SYS_CPNT_TRAPMGMT == TRUE)
            TRAP_MGR_ReqSendTrapOptional(&trap_data, trap_style);
#else
            SNMP_PMGR_ReqSendTrapOptional(&trap_data, trap_style);
#endif
        } /* link down */
    } /* send trap */

    /* notify the link status changed
     */
    {
        /* link up
         */
        if (!SWCTRL_OPER_IS_LINK_UP(current_state) &&
            SWCTRL_OPER_IS_LINK_UP(next_state))
        {
            if (SWCTRL_IS_USER_PORT(ifindex))
            {
                SWCTRL_Notify_uPortLinkUp(unit, port);
            }
            SWCTRL_Notify_PortLinkUp(ifindex);
        } /* link up */

        /* link down
         */
        if (SWCTRL_OPER_IS_LINK_UP(current_state) &&
            !SWCTRL_OPER_IS_LINK_UP(next_state))
        {
            if (SWCTRL_IS_USER_PORT(ifindex))
            {
                SWCTRL_Notify_uPortLinkDown(unit, port);
            }
            SWCTRL_Notify_PortLinkDown(ifindex);
        } /* link down */
    } /* notify link status changed */

    /* notify the oper status changed
     */
    {
        /* port oper up
         */
        if (!SWCTRL_OPER_IS_OPER_UP(current_state) &&
            SWCTRL_OPER_IS_OPER_UP(next_state))
        {
            if (!SWCTRL_IS_TRUNK_MEMBER (ifindex))
            {
                SWCTRL_Notify_PortOperUp (ifindex);
            }
            else
            {
                SWCTRL_Notify_TrunkMemberPortOperUp( SWCTRL_TRUNKID_TO_IFINDEX(port_info[ifindex-1].port_entry.port_trunk_index), ifindex);
            }
        }

        /* port not oper up
         */
        if (SWCTRL_OPER_IS_OPER_UP(current_state) &&
            !SWCTRL_OPER_IS_OPER_UP(next_state))
        {
            if (!SWCTRL_IS_TRUNK_MEMBER (ifindex))
            {
                SWCTRL_Notify_PortNotOperUp (ifindex);
            }
            else
            {
                SWCTRL_Notify_TrunkMemberPortNotOperUp( SWCTRL_TRUNKID_TO_IFINDEX(port_info[ifindex-1].port_entry.port_trunk_index), ifindex);
            }
        }

        /* notify effective status change
         */
        {
            SWCTRL_OperDormantLevel_T level, new_dormant_level;
            UI32_T old_effective_dormant_status, new_effective_dormant_status;
            UI32_T diff_effective_dormant_status;

            /* old_effective_dormant_status
             */
            if (current_state == VAL_ifOperStatus_up)
            {
                old_effective_dormant_status = 0xffffffff;
            }
            else if (current_state == VAL_ifOperStatus_dormant)
            {
                old_effective_dormant_status = BIT_VALUE(current_level);
                old_effective_dormant_status |= BIT_VALUE(current_level) - 1;
            }
            else
            {
                old_effective_dormant_status = 0;
            }

            /* new_effective_dormant_status
             */
            if (next_state == VAL_ifOperStatus_up)
            {
                new_effective_dormant_status = 0xffffffff;
            }
            else if (next_state == VAL_ifOperStatus_dormant)
            {
                new_effective_dormant_status = BIT_VALUE(next_level);
                new_effective_dormant_status |= BIT_VALUE(next_level) - 1;
            }
            else
            {
                new_effective_dormant_status = 0;
            }

            /* new_dormant_level
             */
            if (next_state == VAL_ifOperStatus_dormant)
            {
                new_dormant_level = next_level;
            }
            else
            {
                new_dormant_level = SWCTRL_OPER_DORMANT_LV_MAX;
            }

            diff_effective_dormant_status =
                old_effective_dormant_status ^ new_effective_dormant_status;

            for (level = 0; level < SWCTRL_OPER_DORMANT_LV_MAX; level++)
            {
                if ((diff_effective_dormant_status & BIT_VALUE(level)) &&
                    (port_info[ifindex-1].link_oper_dormant_status & BIT_VALUE(level)))
                {
                    SWCTRL_Notify_PortEffectiveOperStatusChanged(ifindex, current_state, next_state, new_dormant_level, level);

                    /* backward compatible
                     */
                    if (!SWCTRL_IS_TRUNK (ifindex))
                    {
                        if (level == SWCTRL_OPER_DORMANT_LV_DOT1X)
                        {
                            SWCTRL_Notify_uPortDot1xEffectiveOperStatusChanged(unit, port, current_state, next_state);
                        }

                        if (level == SWCTRL_OPER_DORMANT_LV_LACP)
                        {
                            SWCTRL_Notify_uPortLacpEffectiveOperStatusChanged(unit, port, current_state, next_state);
                        }
                    }
                }
            }
        }
    } /* notify the oper status changed */

    return;
} /* End of SWCTRL_ProcessLinkOperStatusChangeNotifying */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_CalculateTrunkOperStatus
 * -------------------------------------------------------------------------
 * FUNCTION: calculate oper status of trunk
 * INPUT   : trunk_id
 * OUTPUT  : None.
 * RETURN  : updated oper status
 * NOTE    : None.
 * -------------------------------------------------------------------------*/
static UI32_T SWCTRL_CalculateTrunkOperStatus(UI32_T trunk_id)
{
/* Oper Status Transition Table of an upper layer interface for new lower layer interface join
 *
 * ref to RFC 2863: 3.1.14.  IfOperStatus in an Interface Stack
 *
 * upper\lower    up             dormant        down           notPresent     lowerLayerDown testing
 * -------------- -------------- -------------- -------------- -------------- -------------- --------------
 * up             up             up             up             up             up             up
 * dormant        up             dormant        dormant        dormant        dormant        dormant
 * lowerLayerDown up             dormant        lowerLayerDown lowerLayerDown lowerLayerDown lowerLayerDown
*/
#define SWCTRL_TRUNK_OPER_STATUS_WITH_NEW_PORT_JOIN(trunk_status, member_status) \
    (((trunk_status) == VAL_ifOperStatus_up || (member_status) == VAL_ifOperStatus_up) ? VAL_ifOperStatus_up : \
        (((trunk_status) == VAL_ifOperStatus_dormant || (member_status) == VAL_ifOperStatus_dormant) ? VAL_ifOperStatus_dormant : \
            VAL_ifOperStatus_lowerLayerDown))


    UI32_T unit, port;
    UI32_T trunk_ifindex, member_ifindex;
    UI32_T new_trunk_oper_status = VAL_ifOperStatus_lowerLayerDown;
    int i;

    trunk_ifindex = SWCTRL_TRUNKID_TO_IFINDEX(trunk_id);

    for (i = 0; i < trunk_ext_port_info[trunk_id-1].member_number; i++)
    {
        unit = trunk_ext_port_info[trunk_id-1].member_list[i].unit;
        port = trunk_ext_port_info[trunk_id-1].member_list[i].port;
        member_ifindex = SWCTRL_UPORT_TO_IFINDEX(unit, port);

        if (SWCTRL_IS_OPER_ACTIVE_TRUNK_MEMBER(trunk_id, member_ifindex))
        {
            new_trunk_oper_status =
                SWCTRL_TRUNK_OPER_STATUS_WITH_NEW_PORT_JOIN(
                    new_trunk_oper_status,
                    port_info[member_ifindex-1].link_oper_status);
        }
    }

    return new_trunk_oper_status;
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_MacCalculation
 * -------------------------------------------------------------------------
 * FUNCTION:
 * INPUT   :
 * OUTPUT  :
 * RETURN  :
 * NOTE    : None.
 * -------------------------------------------------------------------------*/
static void SWCTRL_MacCalculation(UI8_T *mac, UI32_T array_index, UI32_T added_value)
{
    if (array_index < 3) /* dont modify OUI */
        return;
    if ((mac[array_index]+added_value) > 0xFF)
    {
        mac[array_index] = (UI8_T)(mac[array_index] + added_value - 0x100);
        SWCTRL_MacCalculation(mac, --array_index, 1);
    }
    else
        mac[array_index] = mac[array_index] + (UI8_T) added_value;

    return;
} /* end of SWCTRL_MacCalculation()*/


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetNextIndexFromPortList
 * -------------------------------------------------------------------------
 * FUNCTION:
 * INPUT   :
 * OUTPUT  :
 * RETURN  :
 * NOTE    : None.
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_GetNextIndexFromPortList (UI32_T *index,
                                               UI8_T  port_list[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST])
{
    I32_T byte;
    I32_T bit;
    I32_T init_byte;                /*byte: 0 1 2 ... */
    I32_T init_bit;                 /*bit:  7 6 5 ... 0*/

    if(*index >= SYS_ADPT_TOTAL_NBR_OF_LPORT)
    {
        return FALSE;
    }

    init_byte = (UI32_T)((*index)/8);
    init_bit  = 7 - ( (*index)%8 );

    for (byte = init_byte; byte < SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST; byte++)
    {
        if (port_list[byte] == 0)
        {
            init_bit = 7;
            continue;
        }

        for (bit = init_bit; bit >= 0; bit--)
        {
            if ( port_list[byte] & (1<<bit))
            {
                *index = (8*byte) + (8-bit);
                return TRUE;
            }
        }
        init_bit = 7;
    }
    return FALSE;
} /* end of SWCTRL_GetNextIndexFromPortList() */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_PrintDebugMsgIfOperStatusChanged
 * -------------------------------------------------------------------------
 * FUNCTION:
 * INPUT   :
 * OUTPUT  :
 * RETURN  :
 * NOTE    : None.
 * -------------------------------------------------------------------------*/
static void SWCTRL_PrintDebugMsgIfOperStatusChanged (UI32_T ifindex, UI32_T state)
{
    char str[32];
    switch (state)
    {
    case VAL_ifOperStatus_notPresent:
        strcpy(str, "VAL_ifOperStatus_notPresent");
        break;

    case VAL_ifOperStatus_lowerLayerDown:
        strcpy(str, "VAL_ifOperStatus_lowerLayerDown");
        break;

    case VAL_ifOperStatus_testing:
        strcpy(str, "VAL_ifOperStatus_testing");
        break;

    case VAL_ifOperStatus_down:
        strcpy(str, "VAL_ifOperStatus_down");
        break;

    case VAL_ifOperStatus_dormant:
        strcpy(str, "VAL_ifOperStatus_dormant");
        break;

    case VAL_ifOperStatus_up:
        strcpy(str, "VAL_ifOperStatus_up");
        break;

    default:
        return;
    }

    BACKDOOR_MGR_Printf("\r\nIfindex %ld OperStatus = %s", ifindex, str);
    return;
} /* end of SWCTRL_PrintDebugMsgIfOperStatusChanged() */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_MirroringValidationCheck
 * -------------------------------------------------------------------------
 * FUNCTION:
 * INPUT   :
 * OUTPUT  :
 * RETURN  :
 * NOTE    : None.
 * -------------------------------------------------------------------------*/
static BOOL_T SWCTRL_MirroringValidationCheck(UI32_T ifindex_src, UI32_T ifindex_dest , UI32_T mirror_status)
{
    UI32_T om_idx;

    /* src. port should not be the same as dest. port
     */
    if( ifindex_src == ifindex_dest )
    {
        EH_MGR_Handle_Exception (SYS_MODULE_SWCTRL,
                                 SWCTRL_NO_USE_FUNC_NO,
                                 EH_TYPE_MSG_MIRROR_DEST_SAME,
                                 SYSLOG_LEVEL_ERR);  /*SWCTRL_ENO_SRC_EQUAL_TO_DST*/
        return FALSE;
    }

    /* 1. src. port should be user port
     * 2. src. port should exist
     */
    if (!SWCTRL_IS_USER_PORT(ifindex_src) ||
        !SWCTRL_IS_EXIST(ifindex_src)     )
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Interface");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        return FALSE;
    }

    /* LACP enabled port can't be set port mirroring */
#if (SYS_CPNT_STATIC_TRUNK_CONFIG_ALLOWED_ON_LACP_PORT == TRUE)
    if (   user_ext_port_info[ifindex_src-1].lacp_admin_status  == VAL_lacpPortStatus_enabled
        || user_ext_port_info[ifindex_dest-1].lacp_admin_status == VAL_lacpPortStatus_enabled
       )
#else
    if (   user_ext_port_info[ifindex_src-1].lacp_status  == VAL_lacpPortStatus_enabled
        || user_ext_port_info[ifindex_dest-1].lacp_status == VAL_lacpPortStatus_enabled
       )
#endif
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Set port mirroring for LACP enabled port");

        return FALSE;
    }

    /* 3. src. port should not be trunk member
     * New rule from 32, this will sync to platform, further more,
     * if someday, we'll support whole trunk port as monitored port,
     * then all trunk member need to set to chip as monitored port.
     */
    if ( SWCTRL_IS_TRUNK_MEMBER(ifindex_src))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_MIRROR_NOT_SUPPORT,
                                  SYSLOG_LEVEL_INFO,
                                  "Monitored Port for Trunk member");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        return FALSE;
    }

    /* 1. dest. port should be user port
     * 2. dest. port should exist
     */
    if (!SWCTRL_IS_USER_PORT(ifindex_dest)    ||
        !SWCTRL_IS_EXIST(ifindex_dest)        )
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Interface");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        return FALSE;
    }

    /* 3. dest. port should not be trunk member
     */
    if ( SWCTRL_IS_TRUNK_MEMBER(ifindex_dest))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_MIRROR_NOT_SUPPORT,
                                  SYSLOG_LEVEL_INFO,
                                  "Analyzer Port for Trunk member");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        return FALSE;
    }

    /* the analyzer port should not be an monitered port
     */
    if( user_ext_port_info[ifindex_dest - 1].mirroring_tx_dest_port != 0 ||
        user_ext_port_info[ifindex_dest - 1].mirroring_rx_dest_port != 0  )
    {
        EH_MGR_Handle_Exception (SYS_MODULE_SWCTRL,
                                 SWCTRL_NO_USE_FUNC_NO,
                                 EH_TYPE_MSG_MIRROR_MON_CONFLICT,
                                 SYSLOG_LEVEL_ERR);  /*SWCTRL_ENO_SRC_EQUAL_TO_DST*/
        return FALSE;
    }

    /* the monitored port should not be an analyzer port
     */
    for(om_idx = 0; om_idx <= SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK*SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT - 1; om_idx++)
    {
        if(!SWCTRL_IS_EXIST(om_idx+1))
            continue;

        if( user_ext_port_info[om_idx].mirroring_tx_dest_port == ifindex_src ||
            user_ext_port_info[om_idx].mirroring_rx_dest_port == ifindex_src  )
        {
            EH_MGR_Handle_Exception (SYS_MODULE_SWCTRL,
                                     SWCTRL_NO_USE_FUNC_NO,
                                     EH_TYPE_MSG_MIRROR_MON_CONFLICT,
                                     SYSLOG_LEVEL_ERR);  /*SWCTRL_ENO_MONITERED_PORT_SHOULD_NOT_BE_AN_ANALYZER_PORT*/
            return FALSE;
        }
    }

    /* Support multiple monitered port or not
     */
#if (SYS_CPNT_MULTI_MIRRORED_PORT == FALSE)

    for(om_idx = 0; om_idx <= SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK*SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT - 1; om_idx++)
    {
        if(!SWCTRL_IS_EXIST(om_idx+1))
            continue;

        if(user_ext_port_info[om_idx].mirroring_tx_dest_port != 0 ||
           user_ext_port_info[om_idx].mirroring_rx_dest_port != 0 )
        {
            /*this is monitered port*/
            if(om_idx+1 != ifindex_src)
            {
                EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                          SWCTRL_NO_USE_FUNC_NO,
                                          EH_TYPE_MSG_MIRROR_NOT_SUPPORT,
                                          SYSLOG_LEVEL_ERR,
                                          "multiple Monitored Ports");  /*SWCTRL_ENO_MONITERED_PORT_SHOULD_NOT_BE_AN_ANALYZER_PORT*/

                return FALSE;
            }
        }
    }
#endif

    /* Support multiple analyzer port or not
     */
#if (SYS_CPNT_MULTI_MIRROR_TO_PORT == FALSE)
    for(om_idx = 0; om_idx <= SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK*SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT - 1; om_idx++)
    {
        if(!SWCTRL_IS_EXIST(om_idx+1))
            continue;

        if( user_ext_port_info[om_idx].mirroring_tx_dest_port != 0            &&
            ifindex_dest != user_ext_port_info[om_idx].mirroring_tx_dest_port )
        {
                EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                          SWCTRL_NO_USE_FUNC_NO,
                                          EH_TYPE_MSG_MIRROR_NOT_SUPPORT,
                                          SYSLOG_LEVEL_ERR,
                                          "multiple Analyzer Ports");  /*SWCTRL_ENO_MONITERED_PORT_SHOULD_NOT_BE_AN_ANALYZER_PORT*/

            return FALSE;
        }

        if( user_ext_port_info[om_idx].mirroring_rx_dest_port != 0            &&
            ifindex_dest != user_ext_port_info[om_idx].mirroring_rx_dest_port )
        {
                EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                          SWCTRL_NO_USE_FUNC_NO,
                                          EH_TYPE_MSG_MIRROR_NOT_SUPPORT,
                                          SYSLOG_LEVEL_ERR,
                                          "multiple Analyzer Ports");  /*SWCTRL_ENO_MONITERED_PORT_SHOULD_NOT_BE_AN_ANALYZER_PORT*/

            return FALSE;
        }
    }
#else

    if (!SWCTRL_CheckMTPTable(  ifindex_dest,  mirror_status))
    {
                EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                          SWCTRL_NO_USE_FUNC_NO,
                                          EH_TYPE_MSG_MIRROR_NOT_SUPPORT,
                                          SYSLOG_LEVEL_ERR,
                                          "port monitor max nbr mirror port ");

            return FALSE;
    }

#endif

   return TRUE;
} /* end of SWCTRL_MirroringValidationCheck() */


#if (SYS_CPNT_ALLOW_DUMMY_MIRRORING_DEST == TRUE)
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_DummyMirroringDestValidationCheck
 * -------------------------------------------------------------------------
 * FUNCTION: To verify dummy mirroring destionation validation.
 * INPUT   : Mirroring destionation ifindex.
 * OUTPUT  : None.
 * RETURN  : TRUE/FALSE
 * NOTE    : Use this feature only if support one destination port.
 * -------------------------------------------------------------------------*/
static BOOL_T SWCTRL_DummyMirroringDestValidationCheck(UI32_T ifindex_dest)
{
    UI32_T om_idx;

#if (SYS_CPNT_MULTI_MIRROR_TO_PORT == TRUE)
    /* Use this feature only if support one destination port.
     */
    return FALSE;
#else
    for(om_idx = 0; om_idx <= SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK*SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT - 1; om_idx++)
    {
        if(!SWCTRL_IS_EXIST(om_idx+1))
        {
            continue;
        }

        if( user_ext_port_info[om_idx].mirroring_tx_dest_port != 0            &&
            ifindex_dest != user_ext_port_info[om_idx].mirroring_tx_dest_port )
        {
                EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                          SWCTRL_NO_USE_FUNC_NO,
                                          EH_TYPE_MSG_MIRROR_NOT_SUPPORT,
                                          SYSLOG_LEVEL_ERR,
                                          "multiple Analyzer Ports");  /*SWCTRL_ENO_MONITERED_PORT_SHOULD_NOT_BE_AN_ANALYZER_PORT*/

            return FALSE;
        }

        if( user_ext_port_info[om_idx].mirroring_rx_dest_port != 0            &&
            ifindex_dest != user_ext_port_info[om_idx].mirroring_rx_dest_port )
        {
                EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                          SWCTRL_NO_USE_FUNC_NO,
                                          EH_TYPE_MSG_MIRROR_NOT_SUPPORT,
                                          SYSLOG_LEVEL_ERR,
                                          "multiple Analyzer Ports");  /*SWCTRL_ENO_MONITERED_PORT_SHOULD_NOT_BE_AN_ANALYZER_PORT*/

            return FALSE;
        }
    }
#endif

    /* 1. dest. port should be user port
     * 2. dest. port should exist
     */
    if (!SWCTRL_IS_USER_PORT(ifindex_dest)    ||
        !SWCTRL_IS_EXIST(ifindex_dest)        )
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Interface");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        return FALSE;
    }

    /* 3. dest. port should not be trunk member
     */
    if ( SWCTRL_IS_TRUNK_MEMBER(ifindex_dest))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_MIRROR_NOT_SUPPORT,
                                  SYSLOG_LEVEL_INFO,
                                  "Analyzer Port for Trunk member");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        return FALSE;
    }

    /* 4. the analyzer port should not be an monitered port
     */
    if( user_ext_port_info[ifindex_dest - 1].mirroring_tx_dest_port != 0 ||
        user_ext_port_info[ifindex_dest - 1].mirroring_rx_dest_port != 0  )
    {
        EH_MGR_Handle_Exception (SYS_MODULE_SWCTRL,
                                 SWCTRL_NO_USE_FUNC_NO,
                                 EH_TYPE_MSG_MIRROR_MON_CONFLICT,
                                 SYSLOG_LEVEL_ERR);  /*SWCTRL_ENO_SRC_EQUAL_TO_DST*/
        return FALSE;
    }

    return TRUE;
}
#endif

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetServerBladePortFixAttributes
 * -------------------------------------------------------------------------
 * FUNCTION:
 * INPUT   :
 * OUTPUT  :
 * RETURN  :
 * NOTE    : None.
 * -------------------------------------------------------------------------*/
static void SWCTRL_SetServerBladePortFixAttributes (UI32_T unit, UI32_T port)
{
#if (SYS_ADPT_SUPPORT_SERVER_BLADE == 1)
    UI32_T ifindex;
    UI32_T temp;

    ifindex = SWCTRL_UPORT_TO_IFINDEX(unit, port);

    if (!SWCTRL_IsServerBladePort(ifindex))
    {
        return;
    }

#if defined(SYS_DFLT_SERVER_BLADE_PORT_AUTONEG_STATUS)
    port_info[ifindex-1].port_entry.port_autonegotiation = SYS_DFLT_SERVER_BLADE_PORT_AUTONEG_STATUS;

    if(port_info[ifindex-1].port_entry.port_type == VAL_portType_hundredBaseTX)
    {
        temp = VAL_portSpeedDpxCfg_fullDuplex100;
    }
    else
    {
        temp = VAL_portSpeedDpxCfg_fullDuplex1000;
    }

    if(port_info[ifindex-1].port_entry.port_autonegotiation == VAL_portAutonegotiation_enabled)
    {
        SWDRV_EnablePortAutoNeg(unit, port);
        port_info[ifindex-1].port_entry.port_speed_dpx_cfg = temp;
    }
    else
    {
        if(port_info[ifindex-1].port_entry.port_type == VAL_portType_thousandBaseT)
        {
            temp = VAL_portSpeedDpxCfg_fullDuplex100;
        }

        SWDRV_SetPortCfgSpeedDuplex(unit, port, temp);
        port_info[ifindex-1].port_entry.port_speed_dpx_cfg = temp;
    }

#endif

#if defined(SYS_DFLT_SERVER_BLADE_PORT_CAPABILITIES)
    SWDRV_SetPortAutoNegCapability(unit, port, SYS_DFLT_SERVER_BLADE_PORT_CAPABILITIES);
    port_info[ifindex-1].port_entry.port_capabilities = SYS_DFLT_SERVER_BLADE_PORT_CAPABILITIES;
#endif

#if defined(SYS_DFLT_SERVER_BLADE_PORT_FLOWCTRL_STATUS)
    port_info[ifindex-1].port_entry.port_flow_ctrl_cfg = SYS_DFLT_SERVER_BLADE_PORT_FLOWCTRL_STATUS;
    SWDRV_SetPortCfgFlowCtrl(unit, port, unit_info[unit].port_info[port].flow_control_cfg);

#endif

#if defined(SYS_ADPT_SERVER_BLADE_PORT_BCAST_STORM_STATUS)
    port_info[ifindex-1].bcast_storm_entry.bcast_storm_status = SYS_ADPT_SERVER_BLADE_PORT_BCAST_STORM_STATUS;
    if (port_info[ifindex-1].bcast_storm_entry.bcast_storm_status == VAL_bcastStormStatus_enabled)
    {
        SWDRV_EnableBroadcastStormControl(unit, port);
        port_info[ifindex-1].bcast_storm_entry.bcast_storm_pkt_rate = SYS_DFLT_BSTORM_RATE_LIMIT;
        SWDRV_SetStormControlThreshold(unit, port, SYS_DFLT_BSTORM_RATE_LIMIT, SYS_DFLT_BCAST_STORM_MODE);
    }
    else
    {
        SWDRV_DisableBroadcastStormControl(unit, port);
        port_info[ifindex-1].bcast_storm_entry.bcast_storm_pkt_rate = 0;
    }
#endif

#endif /* SYS_DFLT_SERVER_BLADE_PORT_AUTONEG_STATUS */
    return;
} /* end of SWCTRL_SetServerBladePortFixAttributes() */


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_CheckUserPortJoinTrunkValidation
 * -------------------------------------------------------------------------
 * FUNCTION: Check if this user port could be trunk member or not.
 * INPUT   : trunk_id   -- which trunking port to set
 *           unit_port  -- member to add
 *           is_re_check
 *           is_changed_to_active  -- the member is to be changed to admin active
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_CheckUserPortJoinTrunkValidation(UI32_T trunk_id, SYS_TYPE_Uport_T unit_port, BOOL_T is_re_check, BOOL_T is_changed_to_active)
{
    UI32_T trunk_ifindex = SWCTRL_TRUNKID_TO_IFINDEX(trunk_id);
    UI32_T uport_ifindex = SWCTRL_UPORT_TO_IFINDEX(unit_port.unit, unit_port.port);

    /* check trunk id
     */
    if (trunk_id < 1 || trunk_id > SYS_ADPT_MAX_NBR_OF_TRUNK_PER_SYSTEM)
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Trunk number (1-%d): ", SYS_ADPT_MAX_NBR_OF_TRUNK_PER_SYSTEM);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_NOT_TRUNK*/
#endif
        return FALSE;
    }

    /* this trunk must be created
     */
    if (!SWCTRL_IS_EXIST(trunk_ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  SYSLOG_LEVEL_INFO,
                                  "Interface");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/
        return FALSE;
    }

    /* CHECK RULE 2. (trunk member capacity)
     */
    /* check if the trunk reach max number of trunk member
     */
    if (is_re_check == FALSE)
    {
        if (trunk_ext_port_info[trunk_id-1].member_number == SYS_ADPT_MAX_NBR_OF_PORT_PER_TRUNK)
        {
            EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                      SWCTRL_NO_USE_FUNC_NO,
                                      EH_TYPE_MSG_TRUNK_MEMBER_JOIN,
                                      SYSLOG_LEVEL_INFO,
                                      "maximum number of Trunk members exceeded");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

            return FALSE;
        }
    }

    /* check if the trunk reach max number of active trunk member
     */
    if (is_changed_to_active)
    {
        UI32_T i, num_of_admin_active_ports = 0;
        UI32_T unit, port, tmp_ifindex;

        for (i = 0; i < trunk_ext_port_info[trunk_id-1].member_number; i ++)
        {
            unit = trunk_ext_port_info[trunk_id-1].member_list[i].unit;
            port = trunk_ext_port_info[trunk_id-1].member_list[i].port;
            tmp_ifindex = SWCTRL_UPORT_TO_IFINDEX(unit, port);

            if (tmp_ifindex != uport_ifindex)
            {
                if (SWCTRL_IS_OPER_ACTIVE_TRUNK_MEMBER(trunk_id, tmp_ifindex))
                {
                    num_of_admin_active_ports ++;
                }
            }
        }

        if (num_of_admin_active_ports >= trunk_ext_port_info[trunk_id-1].max_num_of_active_ports)
        {
            EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                      SWCTRL_NO_USE_FUNC_NO,
                                      EH_TYPE_MSG_TRUNK_MEMBER_JOIN,
                                      SYSLOG_LEVEL_INFO,
                                      "maximum number of active Trunk members exceeded");

            return FALSE;
        }
    }

    /* this user port must exist
     */
    if (!SWCTRL_IS_EXIST(uport_ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  SYSLOG_LEVEL_INFO,
                                  "Interface");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        return FALSE;
    }

#if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION == TRUE)
#if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE == SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE_MULTIPLE_SESSION)
#if (SWCTRL_PORT_TRAFFIC_SEGMENTATION_AUTO_ATTRIBUTE == TRUE)
    /* always permit user port to join trunk, then update its attribute.
     */
#else

    /* check multi-session of Private VLAN whenever port is joined to trunk or not */
    if (FALSE == SWCTRL_IsUserPortJoinPrivateVlanToTrunk(trunk_id, unit_port))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_TRUNK_MEMBER_JOIN,
                                  SYSLOG_LEVEL_INFO,
                                  "Failed to join trunk for different session_id of Private VLAN");

        return FALSE;
    }

#endif /* (SWCTRL_PORT_TRAFFIC_SEGMENTATION_AUTO_ATTRIBUTE == TRUE) */
#endif /* End of #if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE == SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE_MULTIPLE_SESSION)*/
#endif /* End of #if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION == TRUE) */

    /* this user port have joined this trunk
     */
    if (is_re_check == FALSE)
    {
        if (port_info[uport_ifindex-1].port_entry.port_trunk_index == trunk_id)
            return TRUE;
    }

    /* check the pre-defined value in sys_adpt.h
     */
    if (SWCTRL_AllowToBeTrunkMember(unit_port.unit, unit_port.port) == FALSE)
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_TRUNK_MEMBER_JOIN,
                                  SYSLOG_LEVEL_INFO,
                                  "it is forbidden to join a Trunk by design."); /*SWCTRL_ENO_DENY_SET_TRUNK_MEMBER*/

        return FALSE;
    }

#if (SYS_CPNT_MGMT_PORT == TRUE)
    /* Management port could not be trunk member, defined in sys_adpt.h.
     */
    /* Here, we ignore the parameter unit, becasue currently the product that
     * support management port don't support universal mix stacking.
     */
    if (unit_port.port == SYS_ADPT_MGMT_PORT)
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_TRUNK_MEMBER_JOIN,
                                  SYSLOG_LEVEL_INFO,
                                  "it is Management Port"); /*SWCTRL_ENO_DENY_SET_TRUNK_MEMBER*/

        return FALSE;
    }
#endif

#if (SYS_CPNT_SUPPORT_NULL_TRUNK == TRUE)
     /* CHECK RULE 6. (mutex with lacp 2)
      */
     /* LACP-disabled port could not join dynamic trunk
      * For NULL trunk feature:
      * WHEN DYNAMIC TRUNK HAS LACP-enabled user port member already
      */
    if (trunk_ext_port_info[trunk_id-1].is_static == FALSE &&
#if (SYS_CPNT_STATIC_TRUNK_CONFIG_ALLOWED_ON_LACP_PORT == TRUE)
        user_ext_port_info[uport_ifindex-1].lacp_oper_status == VAL_lacpPortStatus_disabled)
#else
        user_ext_port_info[uport_ifindex-1].lacp_status == VAL_lacpPortStatus_disabled)
#endif
    {
        if (trunk_ext_port_info[trunk_id-1].member_number > 0)
        {
            EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                      SWCTRL_NO_USE_FUNC_NO,
                                      EH_TYPE_MSG_TRUNK_MEMBER_JOIN,
                                      SYSLOG_LEVEL_INFO,
                                      "LACP disabled ports cannot join a dynamic Trunk"); /*SWCTRL_ENO_DENY_SET_TRUNK_MEMBER*/
            return FALSE;
        }
    }

    /* CHECK RULE 5. (mutex with lacp 1)
     */
    /* LACP-enabled port could not be static trunk member
     * For NULL trunk feature:
     * WHEN STATIC TRUNK HAS LACP-disabled user port member already
     */
    if (trunk_ext_port_info[trunk_id-1].is_static == TRUE &&
#if (SYS_CPNT_STATIC_TRUNK_CONFIG_ALLOWED_ON_LACP_PORT == TRUE)
        user_ext_port_info[uport_ifindex-1].lacp_oper_status == VAL_lacpPortStatus_enabled)
#else
        user_ext_port_info[uport_ifindex-1].lacp_status == VAL_lacpPortStatus_enabled)
#endif
    {
        if (trunk_ext_port_info[trunk_id-1].member_number > 0)
        {
            EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                      SWCTRL_NO_USE_FUNC_NO,
                                      EH_TYPE_MSG_TRUNK_MEMBER_JOIN,
                                      SYSLOG_LEVEL_INFO,
                                      "LACP enabled ports cannot join a static Trunk"); /*SWCTRL_ENO_DENY_SET_TRUNK_MEMBER*/
            return FALSE;
        }
    }
#else
     /* CHECK RULE 6. (mutex with lacp 2)
      */
     /* LACP-disabled port could not join dynamic trunk
      */
    if (trunk_ext_port_info[trunk_id-1].is_static == FALSE &&
#if (SYS_CPNT_STATIC_TRUNK_CONFIG_ALLOWED_ON_LACP_PORT == TRUE)
        user_ext_port_info[uport_ifindex-1].lacp_oper_status == VAL_lacpPortStatus_disabled)
#else
        user_ext_port_info[uport_ifindex-1].lacp_status == VAL_lacpPortStatus_disabled)
#endif
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_TRUNK_MEMBER_JOIN,
                                  SYSLOG_LEVEL_INFO,
                                  "LACP disabled ports cannot join a dynamic Trunk"); /*SWCTRL_ENO_DENY_SET_TRUNK_MEMBER*/
        return FALSE;
    }

    /* CHECK RULE 5. (mutex with lacp 1)
     */
    /* LACP-enabled port could not be static trunk member member
     */
    if (trunk_ext_port_info[trunk_id-1].is_static == TRUE &&
#if (SYS_CPNT_STATIC_TRUNK_CONFIG_ALLOWED_ON_LACP_PORT == TRUE)
        user_ext_port_info[uport_ifindex-1].lacp_oper_status == VAL_lacpPortStatus_enabled)
#else
        user_ext_port_info[uport_ifindex-1].lacp_status == VAL_lacpPortStatus_enabled)
#endif
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_TRUNK_MEMBER_JOIN,
                                  SYSLOG_LEVEL_INFO,
                                  "LACP enabled ports cannot join a static Trunk"); /*SWCTRL_ENO_DENY_SET_TRUNK_MEMBER*/
        return FALSE;
    }
#endif /* (SYS_CPNT_SUPPORT_NULL_TRUNK == TRUE) */


    /* CHECK RULE 1. (only join 1 trunk)
     */
    /* this user port have joined trunk, but not this trunk
     */
    if (port_info[uport_ifindex-1].port_entry.port_trunk_index != 0 &&
        port_info[uport_ifindex-1].port_entry.port_trunk_index != trunk_id)
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_TRUNK_MEMBER_JOIN,
                                  SYSLOG_LEVEL_INFO,
                                  "this port is a member of another Port Channel"); /*SWCTRL_ENO_DENY_SET_TRUNK_MEMBER*/

        return FALSE;
    }

    /* CHECK RULE 7. (mutex with dot1x)
     */

    /* In our design, dot1x enabled port could not be trunk member
     */
    if (user_ext_port_info[uport_ifindex-1].dot1x_status == SWCTRL_DOT1X_PORT_ENABLE)
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_TRUNK_MEMBER_JOIN,
                                  SYSLOG_LEVEL_INFO,
                                  "it is DOT1X enabled"); /*SWCTRL_ENO_DENY_SET_TRUNK_MEMBER*/
        return FALSE;
    }

    /* CHECK RULE 8. (mutex with port security)
     */
    /* In our design, port security enabled port could not be trunk member
     */
    if (port_info[uport_ifindex-1].port_security_status == VAL_portSecPortStatus_enabled)
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_TRUNK_MEMBER_JOIN,
                                  SYSLOG_LEVEL_INFO,
                                  "this port is Port Security enabled"); /*SWCTRL_ENO_DENY_SET_TRUNK_MEMBER*/

        return FALSE;
    }

    /* CHECK RULE 4. (mutex with mirroring dest.)
     */
    /* user port should not be analyzer port
     */
    {
        UI32_T om_idx;

#if (SYS_CPNT_ALLOW_DUMMY_MIRRORING_DEST == TRUE)
        if (system_info.dummy_mirroring_dest == uport_ifindex)
        {
            return FALSE;
        }
#endif

        for (om_idx = 0; om_idx < SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK*SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT; om_idx ++)
        {
            if (!SWCTRL_IS_EXIST(om_idx + 1))
                continue;

            /* this user port monitor tx or rx traffic of other user port
             */
            if (user_ext_port_info[om_idx].mirroring_tx_dest_port == uport_ifindex ||
                user_ext_port_info[om_idx].mirroring_rx_dest_port == uport_ifindex)
            {
                EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                          SWCTRL_NO_USE_FUNC_NO,
                                          EH_TYPE_MSG_TRUNK_MEMBER_JOIN,
                                          SYSLOG_LEVEL_INFO,
                                          "it is an Analyzer Port");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

                return FALSE;
            }

        }
    }

    /* user port should not be monitored port
     * new rule from 32, will sync to platform, don't support monitor port as trunk member
     * if someday, we'll support whole trunk port as monitored port,
     * then all trunk member need to set to chip as monitored port.
     */
    {
        /* this user port monitor tx or rx traffic of other user port
         */
        if (user_ext_port_info[uport_ifindex-1].mirroring_tx_dest_port != 0 ||
            user_ext_port_info[uport_ifindex-1].mirroring_rx_dest_port != 0)
        {
            EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                      SWCTRL_NO_USE_FUNC_NO,
                                      EH_TYPE_MSG_TRUNK_MEMBER_JOIN,
                                      SYSLOG_LEVEL_INFO,
                                      "it is an Monitored Port");
            return FALSE;
        }
    }

    /* check the following member to see if all attributes are the same
     */
    if (trunk_ext_port_info[trunk_id-1].member_number > 0)
    {
        SYS_TYPE_Uport_T first_member_unit_port;
        UI32_T           first_member_ifindex;/* first trunk member ifindex */
        UI32_T           trunk_ifindex;

        first_member_unit_port.unit = trunk_ext_port_info[trunk_id-1].member_list[0].unit;
        first_member_unit_port.port = trunk_ext_port_info[trunk_id-1].member_list[0].port;
        first_member_ifindex        = SWCTRL_UPORT_TO_IFINDEX(first_member_unit_port.unit, first_member_unit_port.port);
        trunk_ifindex               = SWCTRL_TRUNKID_TO_IFINDEX(trunk_id);

        if ((unit_port.unit == first_member_unit_port.unit) &&
            (unit_port.port == first_member_unit_port.port) &&
            (trunk_ext_port_info[trunk_id-1].member_number > 1))
        {
            /* When a port need to verify join trunk again, and
             * this user port is the first trunk member?
             * If the first trunk member itself port type change,
             * this first trunk should compare with second trunk member
             */
            first_member_unit_port.unit = trunk_ext_port_info[trunk_id-1].member_list[1].unit;
            first_member_unit_port.port = trunk_ext_port_info[trunk_id-1].member_list[1].port;
            first_member_ifindex        = SWCTRL_UPORT_TO_IFINDEX(first_member_unit_port.unit, first_member_unit_port.port);
        }

#if (SYS_ADPT_SUPPORT_SERVER_BLADE == 1)
        /* server blade port , JBOS */
        if (SWCTRL_IsServerBladePort (first_member_ifindex))
        {
            /* member port number
             */
            if( is_re_check == FALSE)
            {
                if( trunk_ext_port_info[trunk_id-1].member_number == SYS_ADPT_MAX_NBR_OF_SERVER_BLADE_PORT_PER_TRUNK)
                {
                    EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                              SWCTRL_NO_USE_FUNC_NO,
                                              EH_TYPE_MSG_TRUNK_MEMBER_JOIN,
                                              SYSLOG_LEVEL_INFO,
                                              "maximum number of Server Blade Trunk members exceeded");   /*SWCTRL_ENO_EXCEED_MAX_NBR_OF_SERVER_BLADE_PORT_PER_TRUNK*/

                    return FALSE;
                }
            }

            /* it can not trunked server blade port and uplink port together
             */
            if(!SWCTRL_IsServerBladePort (uport_ifindex))
            {
                 EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                           SWCTRL_NO_USE_FUNC_NO,
                                           EH_TYPE_MSG_TRUNK_MEMBER_JOIN,
                                           SYSLOG_LEVEL_INFO,
                                           "this Port Channel is for Down Link Ports only");   /*SWCTRL_ENO_EXCEED_MAX_NBR_OF_SERVER_BLADE_PORT_PER_TRUNK*/

                return FALSE;
            }

            /* server blade trunk member port should be neighbored
             */
            if( abs((int)first_member_ifindex - (int)uport_ifindex) != 1)
            {
                 EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                           SWCTRL_NO_USE_FUNC_NO,
                                           EH_TYPE_MSG_TRUNK_MEMBER_JOIN,
                                           SYSLOG_LEVEL_INFO,
                                           "this port is not a neighbor of the other Port Channel members");   /*SWCTRL_ENO_EXCEED_MAX_NBR_OF_SERVER_BLADE_PORT_PER_TRUNK*/

                return FALSE;
            }
        }
#endif

#if (SYS_CPNT_TRUNK_MEMBER_AUTO_ATTRIBUTE == FALSE)
        /* CHECK RULE 9. (auto-nego enable/disable state)
         */
        if (port_info[first_member_ifindex-1].port_entry.port_autonegotiation !=
            port_info[uport_ifindex       -1].port_entry.port_autonegotiation)
        {
            EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                      SWCTRL_NO_USE_FUNC_NO,
                                      EH_TYPE_MSG_TRUNK_MEMBERS_SAME,
                                      SYSLOG_LEVEL_INFO,
                                      "Auto-Negotiation state");  /*SWCTRL_ENO_PORT_TYPES_ARE_NOT_THE_SAME_FAMILY_IN_TRUNK*/

            return FALSE;
        }

        if (port_info[uport_ifindex-1].port_entry.port_autonegotiation == VAL_portAutonegotiation_enabled)
        {
            /* auto-nego capability about flowcontrol
             */
            if ((port_info[first_member_ifindex-1].port_entry.port_capabilities & SYS_VAL_portCapabilities_portCapFlowCtrl) !=
                (port_info[uport_ifindex       -1].port_entry.port_capabilities & SYS_VAL_portCapabilities_portCapFlowCtrl))
            {
                EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                          SWCTRL_NO_USE_FUNC_NO,
                                          EH_TYPE_MSG_TRUNK_MEMBERS_SAME,
                                          SYSLOG_LEVEL_INFO,
                                          "Auto-Negotiated Flow Control capability");  /*SWCTRL_ENO_PORT_TYPES_ARE_NOT_THE_SAME_FAMILY_IN_TRUNK*/

                return FALSE;
            }

            if ((port_info[first_member_ifindex-1].port_entry.port_capabilities & SYS_VAL_portCapabilities_portCapSym) !=
                (port_info[uport_ifindex       -1].port_entry.port_capabilities & SYS_VAL_portCapabilities_portCapSym))
            {
                EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                          SWCTRL_NO_USE_FUNC_NO,
                                          EH_TYPE_MSG_TRUNK_MEMBERS_SAME,
                                          SYSLOG_LEVEL_INFO,
                                          "Auto-negotiated symmetric capability");  /*SWCTRL_ENO_PORT_TYPES_ARE_NOT_THE_SAME_FAMILY_IN_TRUNK*/

                return FALSE;
            }

            /* CHECK RULE 12. (auto-nego speed-duplex capabilities)
             */
            /* auto-nego capability about speed duplex
             */
            if (SWCTRL_HIGHEST_SPD_DPX_CAPA(port_info[first_member_ifindex-1].port_entry.port_capabilities) !=
                SWCTRL_HIGHEST_SPD_DPX_CAPA(port_info[uport_ifindex       -1].port_entry.port_capabilities))
            {
                EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                          SWCTRL_NO_USE_FUNC_NO,
                                          EH_TYPE_MSG_TRUNK_MEMBERS_SAME,
                                          SYSLOG_LEVEL_INFO,
                                          "Highest auto-negotiated speed/duplex capability");  /*SWCTRL_ENO_PORT_TYPES_ARE_NOT_THE_SAME_FAMILY_IN_TRUNK*/

                return FALSE;
            }
        }
        else
        {
            /* CHECK RULE 13.
             */
            /* check if the force mode speed/duplex config are the same
             */
            if (port_info[first_member_ifindex-1].port_entry.port_speed_dpx_cfg !=
                port_info[uport_ifindex       -1].port_entry.port_speed_dpx_cfg)
            {
                EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                          SWCTRL_NO_USE_FUNC_NO,
                                          EH_TYPE_MSG_TRUNK_MEMBERS_SAME,
                                          SYSLOG_LEVEL_INFO,
                                          "Force mode Speed/duplex mode");  /*SWCTRL_ENO_PORT_TYPES_ARE_NOT_THE_SAME_FAMILY_IN_TRUNK*/

                return FALSE;
            }

            /* check if the force mode flow control states are the same
             */
            if (port_info[first_member_ifindex-1].port_entry.port_flow_ctrl_cfg !=
                port_info[uport_ifindex       -1].port_entry.port_flow_ctrl_cfg)
            {
                EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                          SWCTRL_NO_USE_FUNC_NO,
                                          EH_TYPE_MSG_TRUNK_MEMBERS_SAME,
                                          SYSLOG_LEVEL_INFO,
                                          "Forced Flow Control Mode");  /*SWCTRL_ENO_PORT_TYPES_ARE_NOT_THE_SAME_FAMILY_IN_TRUNK*/

                return FALSE;
            }
        }

        /* CHECK RULE 14. (admin enable/disable state)
         */
        /* check if the admin states are the same
         */
        if (port_info[first_member_ifindex-1].admin_status !=
            port_info[uport_ifindex       -1].admin_status)
        {
                EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                          SWCTRL_NO_USE_FUNC_NO,
                                          EH_TYPE_MSG_TRUNK_MEMBERS_SAME,
                                          SYSLOG_LEVEL_INFO,
                                          "Port Administrative enable/disable state");  /*SWCTRL_ENO_PORT_TYPES_ARE_NOT_THE_SAME_FAMILY_IN_TRUNK*/

            return FALSE;
        }

        /* CHECK RULE 16. (VLAN)
         */
        if (is_re_check == FALSE)
        {
            VLAN_OM_Dot1qVlanCurrentEntry_T vlan_info;

            UI32_T byte1,  byte2;
            UI32_T shift1, shift2;

            byte1  = (UI32_T)(trunk_ifindex - 1) / 8;
            shift1 = (UI32_T)(trunk_ifindex - 1) % 8;

            byte2  = (UI32_T)(uport_ifindex - 1) / 8;
            shift2 = (UI32_T)(uport_ifindex - 1) % 8;

            memset(&vlan_info, 0, sizeof(VLAN_OM_Dot1qVlanCurrentEntry_T));

            while (VLAN_OM_GetNextVlanEntry(&vlan_info))
            {
                BOOL_T is_member1, is_member2;

                if(vlan_info.dot1q_vlan_status == VAL_dot1qVlanStatus_permanent)
                {
                    is_member1 = (vlan_info.dot1q_vlan_static_egress_ports[byte1] & ((0x01) << (7-shift1))) > 0 ? TRUE : FALSE;
                    is_member2 = (vlan_info.dot1q_vlan_static_egress_ports[byte2] & ((0x01) << (7-shift2))) > 0 ? TRUE : FALSE;

                    if( is_member1 != is_member2 )
                    {
                        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                                  SWCTRL_NO_USE_FUNC_NO,
                                                  EH_TYPE_MSG_TRUNK_MEMBERS_SAME,
                                                  SYSLOG_LEVEL_INFO,
                                                  "Static VLAN membership");  /*SWCTRL_ENO_PORT_TYPES_ARE_NOT_THE_SAME_FAMILY_IN_TRUNK*/

                        return FALSE;
                    }
                }
            }
        }

#if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION == TRUE)
        /* CHECK RULE 15.
         */
#if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE == SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE_MULTIPLE_SESSION)
        /* Exclusive-or whether uport should be follow trunk attribute */
        if ((swctl_private_vlan_port_info[trunk_ifindex-1].private_vlan_uplink_port) ^
            (swctl_private_vlan_port_info[uport_ifindex-1].private_vlan_uplink_port))
        {
            EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                      SWCTRL_NO_USE_FUNC_NO,
                                      EH_TYPE_MSG_TRUNK_MEMBER_JOIN,
                                      SYSLOG_LEVEL_INFO,
                                      "Failed to join trunk for Private VLAN");

            return FALSE;
        }

        /* Exclusive-or whether uport should be follow trunk attribute */
        if ((swctl_private_vlan_port_info[trunk_ifindex-1].private_vlan_downlink_port) ^
            (swctl_private_vlan_port_info[uport_ifindex-1].private_vlan_downlink_port))
        {
            EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                      SWCTRL_NO_USE_FUNC_NO,
                                      EH_TYPE_MSG_TRUNK_MEMBER_JOIN,
                                      SYSLOG_LEVEL_INFO,
                                      "Failed to join trunk for Private VLAN");

            return FALSE;
        }

        /* check session_id will be the same, and user port  */
        if (((swctl_private_vlan_port_info[trunk_ifindex-1].session_id) !=
             (swctl_private_vlan_port_info[uport_ifindex-1].session_id)) &&
             ((swctl_private_vlan_port_info[uport_ifindex-1].session_id) !=0x0))

        {
            EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                      SWCTRL_NO_USE_FUNC_NO,
                                      EH_TYPE_MSG_TRUNK_MEMBER_JOIN,
                                      SYSLOG_LEVEL_INFO,
                                      "Failed to join trunk for different session_id of Private VLAN");

            return FALSE;
        }
#else
        /* check if on same private vlan
         */
        if (SWCTRL_IsPortPrivateVlanUplinkMember(trunk_ifindex) ^
            SWCTRL_IsPortPrivateVlanUplinkMember(uport_ifindex))
        {
            EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                      SWCTRL_NO_USE_FUNC_NO,
                                      EH_TYPE_MSG_TRUNK_MEMBERS_SAME,
                                      SYSLOG_LEVEL_INFO,
                                      "Private VLAN");  /*SWCTRL_ENO_PORT_TYPES_ARE_NOT_THE_SAME_FAMILY_IN_TRUNK*/

            return FALSE;
        }

        if (SWCTRL_IsPortPrivateVlanDownlinkMember(trunk_ifindex) ^
            SWCTRL_IsPortPrivateVlanDownlinkMember(uport_ifindex))
        {
            EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                      SWCTRL_NO_USE_FUNC_NO,
                                      EH_TYPE_MSG_TRUNK_MEMBERS_SAME,
                                      SYSLOG_LEVEL_INFO,
                                      "Private VLAN");  /*SWCTRL_ENO_PORT_TYPES_ARE_NOT_THE_SAME_FAMILY_IN_TRUNK*/

            return FALSE;
        }
#endif /* End of #if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE == SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE_MULTIPLE_SESSION)*/
#endif

#endif /* End of #if (SYS_CPNT_TRUNK_MEMBER_AUTO_ATTRIBUTE == FALSE) */
    }
    return TRUE;
} /* end of SWCTRL_CheckUserPortJoinTrunkValidation() */

#if (SYS_CPNT_TRUNK_MEMBER_AUTO_ATTRIBUTE == TRUE)
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_UserPortFollowTrunkAttributes
 * -------------------------------------------------------------------------
 * FUNCTION: This function is used to make a user port follow trunk atributes
 * INPUT   : uport_ifindex --- User port ifindex.
 *           trunk_ifindex --- Trunk port ifindex.
 * OUTPUT  : None.
 * RETURN  : TRUE/FALSE
 * NOTE    : Follow CHECK RULE 9 ~ 15
 *           16 will be done by VLAN itself.
 * -------------------------------------------------------------------------*/
static BOOL_T SWCTRL_UserPortFollowTrunkAttributes(UI32_T uport_ifindex, UI32_T trunk_ifindex)
{
    SYS_TYPE_Uport_T first_member_unit_port;
    UI32_T           first_member_ifindex;                /*first trunk member ifindex*/
    UI32_T           trunk_id;
    UI32_T           uport_unit;
    UI32_T           uport_port;
    UI32_T           ifindex_for_follow_storm_rate_cfg;
    UI32_T           ifindex_for_set_storm_rate;

    trunk_id = SWCTRL_IFINDEX_TO_TRUNKID(trunk_ifindex);

    /* if this trunk has no member no necessary to do follow
     */
    if (trunk_ext_port_info[trunk_id-1].member_number == 0)
    {
        return TRUE;
    }

    if (!SWCTRL_GetTrunkPrimaryPort(trunk_ifindex, &first_member_ifindex))
    {
        return FALSE;
    }
    first_member_unit_port.unit = SWCTRL_IFINDEX_TO_UNIT(first_member_ifindex);
    first_member_unit_port.port = SWCTRL_IFINDEX_TO_PORT(first_member_ifindex);

    uport_unit = SWCTRL_IFINDEX_TO_UNIT(uport_ifindex);
    uport_port = SWCTRL_IFINDEX_TO_PORT(uport_ifindex);

    /* name & alias
     */
    strcpy((char*)(port_info[uport_ifindex-1].port_entry.port_name), (char*)(port_info[trunk_ifindex-1].port_entry.port_name));
    strcpy((char*)(port_info[uport_ifindex-1].port_entry.port_alias), (char*)(port_info[trunk_ifindex-1].port_entry.port_alias));

    /* MTU
     */
    if (FALSE == SWCTRL_SetPortMTU(uport_ifindex, port_info[trunk_ifindex - 1].port_entry.port_mtu))
    {
        return FALSE;
    }

    /* CHECK RULE 10. (auto-nego flowcontrol capabilities)
     */
    /* CHECK RULE 12. (auto-nego speed-duplex capabilities)
     */
    if (SWCTRL_IsPortAutoNegCapabilitySupported(uport_ifindex, port_info[first_member_ifindex-1].port_entry.port_capabilities))
    {
        if (FALSE == SWCTRL_SetUPortAutoNegCapability (uport_unit, uport_port, port_info[first_member_ifindex-1].port_entry.port_capabilities))
        {
            return FALSE;
        }
    }

#if (SYS_CPNT_SWCTRL_MDIX_CONFIG == TRUE)
    /* MDIX mode
     */
    if (SWCTRL_IS_100TX(uport_ifindex) == TRUE)
    {
        if (FALSE == SWCTRL_SetUPortMDIXMode(uport_unit, uport_port, port_info[first_member_ifindex-1].port_entry.port_MDIX_mode))
        {
            return FALSE;
        }
    }
#endif

    /* CHECK RULE 11. (force-mode flowcontrol enable/disable state)
     */
    if (FALSE == SWCTRL_SetUPortCfgFlowCtrlEnable (uport_unit, uport_port, port_info[first_member_ifindex-1].port_entry.port_flow_ctrl_cfg))
    {
        return FALSE;
    }

    /* CHECK RULE 13. (force-mode speed-duplex)
     */
    if (SWCTRL_IsPortCfgSpeedDuplexSupported(uport_ifindex, port_info[first_member_ifindex-1].port_entry.port_speed_dpx_cfg))
    {
        if (FALSE == SWCTRL_SetUPortCfgSpeedDuplex (uport_unit, uport_port, port_info[first_member_ifindex-1].port_entry.port_speed_dpx_cfg))
        {
            return FALSE;
        }
    }

    /* CHECK RULE 9. (auto-nego enable/disable state)
     */
    if (SWCTRL_IsPortAutoNegEnableSupported(uport_ifindex, port_info[first_member_ifindex-1].port_entry.port_autonegotiation))
    {
        if (FALSE == SWCTRL_SetUPortAutoNegEnable(uport_unit, uport_port, port_info[first_member_ifindex-1].port_entry.port_autonegotiation))
        {
            return FALSE;
        }
    }

    /* CHECK RULE 14. (admin enable/disable state)
     */
    if (!SWCTRL_SetPortStatus_Local(
            SWCTRL_UPORT_TO_IFINDEX(uport_unit, uport_port),
            !(port_info[trunk_ifindex-1].shutdown_status & SWCTRL_PORT_STATUS_SET_BY_CFG),
            SWCTRL_PORT_STATUS_SET_BY_CFG,
            TRUE))
    {
        return FALSE;
    }

    /* port learning status
     */
    user_ext_port_info[uport_ifindex-1].learning_disabled_status =
        user_ext_port_info[first_member_ifindex-1].learning_disabled_status;

    SWCTRL_SetUPortLearningStatus(uport_unit, uport_port, !user_ext_port_info[uport_ifindex-1].learning_disabled_status, TRUE);

#if(SYS_CPNT_AMTR_PORT_MAC_LEARNING == TRUE)/*Tony.Lei*/
    port_info[uport_ifindex-1].port_entry.port_macaddr_learning =
        !(user_ext_port_info[uport_ifindex-1].learning_disabled_status & SWCTRL_LEARNING_DISABLED_BY_CFG);
#endif

    /* Need to set trunk granularity to be equal to the max granularity of trunk members
     * So must check new joining member's granularity.
     * storm rate will follow by rate of max storm granularity.
     * To avoid if some port is smaller granulairy and higher rate, but rate is not
     * multiple of max granularity.
     */
     /* determine how to follow attribute for storm rate
     */
    if( port_info[trunk_ifindex-1].storm_granularity < port_info[uport_ifindex-1].storm_granularity)
    {
        /* update trunk granularity with this uport granularity
         */
        port_info[trunk_ifindex-1].storm_granularity = port_info[uport_ifindex-1].storm_granularity;

        /* sync uport config to trunk and members
         */
        ifindex_for_follow_storm_rate_cfg = uport_ifindex;
        ifindex_for_set_storm_rate = trunk_ifindex;
    }
    else
    {
        /* follow trunk config and sync to uport
         */
        ifindex_for_follow_storm_rate_cfg = trunk_ifindex;
        ifindex_for_set_storm_rate = uport_ifindex;
    }
#if (SYS_CPNT_STORM_MODE & SYS_CPNT_STORM_BSTORM)
#if (SYS_CPNT_BSTORM_SUPPORT_LPORT == TRUE)
    {
        UI32_T status;
        UI32_T mode;
        UI32_T nRate = 0;

        status = port_info[first_member_ifindex-1].bcast_storm_entry.bcast_storm_status;
        mode = port_info[first_member_ifindex-1].bcast_storm_entry.bcast_storm_sample_type;
        switch (mode)
        {
            case VAL_bcastStormSampleType_pkt_rate:
                nRate = port_info[ifindex_for_follow_storm_rate_cfg-1].bcast_storm_entry.bcast_storm_pkt_rate;
                break;
            case VAL_bcastStormSampleType_octet_rate:
                nRate = port_info[ifindex_for_follow_storm_rate_cfg-1].bcast_storm_entry.bcast_storm_octet_rate;

                break;
            case VAL_bcastStormSampleType_percent:
                nRate = port_info[ifindex_for_follow_storm_rate_cfg-1].bcast_storm_entry.bcast_storm_percent;
                break;
        }
        if (!SWCTRL_SetBStormControlRateLimit(ifindex_for_set_storm_rate, mode, nRate))
        {
            return FALSE;
        }
        if (!SWCTRL_SetBroadcastStormStatus(uport_ifindex, status))
        {
            return FALSE;
        }
    }
#endif /* (SYS_CPNT_BSTORM_SUPPORT_LPORT == TRUE) */
#endif /* (SYS_CPNT_STORM_MODE & SYS_CPNT_STORM_BSTORM) */

#if (SYS_CPNT_STORM_MODE & SYS_CPNT_STORM_MSTORM)
#if (SYS_CPNT_MSTORM_SUPPORT_LPORT == TRUE)
    {
        UI32_T status;
        UI32_T mode;
        UI32_T nRate = 0;

        status = port_info[first_member_ifindex-1].mcast_storm_entry.mcast_storm_status;
        mode = port_info[first_member_ifindex-1].mcast_storm_entry.mcast_storm_sample_type;

        switch (mode)
        {
            case VAL_bcastStormSampleType_pkt_rate:
                nRate=port_info[ifindex_for_follow_storm_rate_cfg-1].mcast_storm_entry.mcast_storm_pkt_rate;
                break;
            case VAL_bcastStormSampleType_octet_rate:
                nRate=port_info[ifindex_for_follow_storm_rate_cfg-1].mcast_storm_entry.mcast_storm_octet_rate;
                break;
            case VAL_bcastStormSampleType_percent:
                nRate = port_info[ifindex_for_follow_storm_rate_cfg-1].mcast_storm_entry.mcast_storm_percent;
                break;
        }
        if (!SWCTRL_SetMStormControlRateLimit(ifindex_for_set_storm_rate, mode, nRate))
        {
            return FALSE;
        }
        if (!SWCTRL_SetMulticastStormStatus(uport_ifindex, status))
        {
            return FALSE;
        }
    }
#endif /* (SYS_CPNT_MSTORM_SUPPORT_LPORT == TRUE) */
#endif /* (SYS_CPNT_STORM_MODE & SYS_CPNT_STORM_MSTORM) */

#if (SYS_CPNT_STORM_MODE & SYS_CPNT_STORM_UNKNOWN_USTORM)
#if (SYS_CPNT_UNKNOWN_USTORM_SUPPORT_LPORT == TRUE)
    {
        UI32_T status;
        UI32_T mode;
        UI32_T nRate = 0;

        status = port_info[first_member_ifindex-1].unknown_ucast_storm_entry.unknown_ucast_storm_status;
        mode = port_info[first_member_ifindex-1].unknown_ucast_storm_entry.unknown_ucast_storm_sample_type;
        switch (mode)
        {
            case VAL_bcastStormSampleType_pkt_rate:
                nRate=port_info[ifindex_for_follow_storm_rate_cfg-1].unknown_ucast_storm_entry.unknown_ucast_storm_pkt_rate;
                break;
            case VAL_bcastStormSampleType_octet_rate:
                nRate=port_info[ifindex_for_follow_storm_rate_cfg-1].unknown_ucast_storm_entry.unknown_ucast_storm_octet_rate;
                break;
            case VAL_bcastStormSampleType_percent:
                nRate = port_info[ifindex_for_follow_storm_rate_cfg-1].unknown_ucast_storm_entry.unknown_ucast_storm_percent;
                break;
        }
        if (!SWCTRL_SetUnknownUStormControlRateLimit(ifindex_for_set_storm_rate, mode, nRate))
        {
            return FALSE;
        }
        if (!SWCTRL_SetUnknownUnicastStormStatus(uport_ifindex, status))
        {
            return FALSE;
        }
    }
#endif /* (SYS_CPNT_UNKNOWN_USTORM_SUPPORT_LPORT == TRUE) */
#endif /* (SYS_CPNT_STORM_MODE & SYS_CPNT_STORM_UNKNOWN_USTORM) */

#if (SYS_CPNT_INGRESS_RATE_LIMIT == TRUE)
#if (SYS_CPNT_NETACCESS_DYNAMIC_QOS == TRUE)
    if(port_info[uport_ifindex-1].ingress_rate_limit_dynamic_cfg == TRUE)
    {
        ;/* do nothing */
    }
    else
#endif
    {
        port_info[uport_ifindex-1].ingress_rate_limit = port_info[trunk_ifindex-1].ingress_rate_limit;
        port_info[uport_ifindex-1].ingress_rate_limit_status = port_info[trunk_ifindex-1].ingress_rate_limit_status;

        if (port_info[uport_ifindex-1].ingress_rate_limit_status == VAL_rlPortInputStatus_enabled)
        {
            if (!SWDRV_SetPortIngressRateLimit(uport_unit, uport_port, 0,
                    SWCTRL_ConvertUserRateLimitToPhy(
                        port_info[uport_ifindex-1].port_entry.port_type,
                        port_info[uport_ifindex-1].ingress_rate_limit)))
            {
                return FALSE;
            }
        }
        else
        {
            if (!SWDRV_DisablePortIngressRateLimit(uport_unit, uport_port, 0))
            {
                return FALSE;
            }
        }
    }
#endif /* (SYS_CPNT_INGRESS_RATE_LIMIT == TRUE) */

#if (SYS_CPNT_EGRESS_RATE_LIMIT == TRUE)
    port_info[uport_ifindex-1].egress_rate_limit = port_info[trunk_ifindex-1].egress_rate_limit;
    port_info[uport_ifindex-1].egress_rate_limit_status = port_info[trunk_ifindex-1].egress_rate_limit_status;

    if (port_info[uport_ifindex-1].egress_rate_limit_status == VAL_rlPortOutputStatus_enabled)
    {
        if (!SWDRV_SetPortEgressRateLimit(uport_unit, uport_port,
                SWCTRL_ConvertUserRateLimitToPhy(
                    port_info[uport_ifindex-1].port_entry.port_type,
                    port_info[uport_ifindex-1].egress_rate_limit)))
        {
            return FALSE;
        }
    }
    else
    {
        if (!SWDRV_DisablePortEgressRateLimit(uport_unit, uport_port))
        {
            return FALSE;
        }
    }
#endif /* (SYS_CPNT_EGRESS_RATE_LIMIT == TRUE) */

#if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION == TRUE)
    /* CHECK RULE 15. (private VALN)
     */
#if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE == SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE_MULTIPLE_SESSION)
#if (SWCTRL_PORT_TRAFFIC_SEGMENTATION_AUTO_ATTRIBUTE == TRUE)
    if (!SWCTRL_PrivateVlanUserPortFollowTrunkAttributes(uport_ifindex, trunk_ifindex))
    {
        return FALSE;
    }
#endif /* (SWCTRL_PORT_TRAFFIC_SEGMENTATION_AUTO_ATTRIBUTE == TRUE) */
#else
    if (TRUE == port_info[first_member_ifindex-1].private_vlan_uplink_port)
    {
        /* If downlink port wants to join uplink port trunk, it must change its attribute to uplink port first.
         */
        if (TRUE == port_info[uport_ifindex-1].private_vlan_downlink_port)
        {
            if (FALSE == SWCTRL_DeletePrivateVlanDownlinkPortMember(uport_ifindex))
            {
                return FALSE;
            }
        }

        if (FALSE == SWCTRL_AddPrivateVlanUplinkPortMember(uport_ifindex))
        {
            return FALSE;
        }
    }
    else
    {
        if (FALSE == SWCTRL_DeletePrivateVlanUplinkPortMember(uport_ifindex))
        {
            return FALSE;
        }
    }

    if (TRUE == port_info[first_member_ifindex-1].private_vlan_downlink_port)
    {
        /* If uplink port wants to join downlink port trunk, it must change its attribute to downlink port first.
         */
        if (TRUE == port_info[uport_ifindex-1].private_vlan_uplink_port)
        {
            if (FALSE == SWCTRL_DeletePrivateVlanUplinkPortMember(uport_ifindex))
            {
                return FALSE;
            }
        }

        if (FALSE == SWCTRL_AddPrivateVlanDownlinkPortMember(uport_ifindex))
        {
            return FALSE;
        }
    }
    else
    {
        if (FALSE == SWCTRL_DeletePrivateVlanDownlinkPortMember(uport_ifindex))
        {
            return FALSE;
        }
    }
#endif /* End of #if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE == SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE_SINGLE_SESSION) */
#endif

#if (SYS_CPNT_ITRI_MIM == TRUE)
    {
        BOOL_T status;
        SWCTRL_ITRI_MIM_GetStatus(trunk_ifindex, &status);
        SWCTRL_ITRI_MIM_SetStatus(uport_ifindex, status);
    }
#endif

#if(SYS_CPNT_WRED == TRUE)
    {
      SWCTRL_OM_RandomDetect_T info;
      SWCTRL_RandomDetect_T    value;
	  UI8_T i;

	  SWCTRL_OM_GetRandomDetect(trunk_ifindex, &info);

      if(info.all_queue)
      {
          value.queue_id = -1;
          value.min  = info.min[0];
          value.max  = info.max[0];
          value.drop = info.drop[0];
          value.ecn  = info.ecn[0];
          value.valid= info.valid[0];
          SWCTRL_Random_Detect(uport_ifindex, &value);
      }
      else
      {
        for(i=0 ;i <SYS_ADPT_MAX_NBR_OF_PRIORITY_QUEUE; i++)
        {
          value.queue_id = i;
          value.min  = info.min[i];
          value.max  = info.max[i];
          value.drop = info.drop[i];
          value.ecn  = info.ecn[i];
          value.valid= info.valid[i];
          SWCTRL_Random_Detect(uport_ifindex, &value);
        }
      }
    }
#endif
    return TRUE;
}
#endif

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_ConfigUserPortToDefaultState
 * -------------------------------------------------------------------------
 * FUNCTION: This function will config a user port to default state base on
 *           the port type.
 * INPUT   : unit                 -- which unit
 *           port                 -- which port to set
 *           port_type            -- port type
 *           is_enter_master_mode -- TRUE/FALSE
 * OUTPUT  : None.
 * RETURN  : None.
 * NOTE    : a. This API will not set:
 *              1) port type
 *              2) port_entry.port_index
 *              3) bcast_storm_entry.bcast_storm_ifindex
 *              4) mcast_storm_entry.mcast_storm_ifindex
 *              5) link_oper_status
 *           b. This API could be used when:
 *              1) enter master mode,
 *              2) port type change, and
 *              3) hot swap insert.
 * -------------------------------------------------------------------------*/
static void SWCTRL_ConfigUserPortToDefaultState(UI32_T unit, UI32_T port, UI32_T port_type, BOOL_T is_enter_master_mode)
{
    UI32_T             ifindex;
    SWCTRL_PortInfo_T  original_port_info;
    UI32_T             q_id;

    ifindex = SWCTRL_UPORT_TO_IFINDEX(unit, port);

    if (STKTPLG_PORT_TYPE_STACKING == port_info[ifindex-1].port_entry.port_type  ||
        STKTPLG_PORT_TYPE_NOT_EXIST == port_info[ifindex-1].port_entry.port_type )
    {
        return;
    }

    SWCTRL_LOCK();
    original_port_info = port_info[ifindex-1];
    SWCTRL_UNLOCK();

#if (SWCTRL_UPDATE_PORT_ABILITY == TRUE)
    SWCTRL_UpdatePortAbility(unit, port);
#endif

#if (SYS_CPNT_COMBO_PORT_FORCE_MODE == TRUE)
    if (is_enter_master_mode)
    {
        SWCTRL_ReInitPortComboForcedMode(unit, port);
#if (SWCTRL_UPDATE_PORT_ABILITY == TRUE)
        SWCTRL_UpdatePortAbility(unit, port);
#endif
    }
#endif

    /* port mac
     */
    {
        UI8_T mac[SYS_ADPT_MAC_ADDR_LEN];

        if (SWCTRL_GetUPortMac(unit, port, mac))
        {
            SWDRV_SetPortMacAddr(unit, port, mac);
        }
    }

    /* admin_state
     */
    SWCTRL_LOCK();
    port_info[ifindex-1].admin_status = SYS_DFLT_IF_ADMIN_STATUS;
    port_info[ifindex-1].shutdown_status =
        (port_info[ifindex-1].admin_status == VAL_ifAdminStatus_up) ?
            0 : SWCTRL_PORT_STATUS_SET_BY_CFG;

    if(is_enter_master_mode == FALSE)
    {
        /* When SWCTRL enter master mode, all ports are not allowed to admin enabled,
         * so, only setting database is necessary and the value may be changed becuase of provision.
         * When provision complete, the value in database will be took effect.
         */

        if(!original_port_info.shutdown_status != !port_info[ifindex-1].shutdown_status)
        {
            if(port_info[ifindex-1].shutdown_status == 0)
            {
#if (SYS_CPNT_3COM_LOOPBACK_TEST == TRUE)
                if (TRUE == user_ext_port_info[ifindex-1].is_loopback_test_failed)
                {
                    /* loopback test failed port:
                     * don't set ASIC
                     */
                    ;
                }
                else
                {
#endif
                    /* loopback test passed port:
                     * set ASIC
                     */
                    SWDRV_EnablePortAdmin(unit, port);
#if (SYS_CPNT_3COM_LOOPBACK_TEST == TRUE)
                }
#endif

                SWCTRL_UNLOCK();
            }
            else
            {
#if (SYS_CPNT_3COM_LOOPBACK_TEST == TRUE)
                if (TRUE == user_ext_port_info[ifindex-1].is_loopback_test_failed)
                {
                    /* loopback test failed port:
                     * don't set ASIC
                     */
                    ;
                }
                else
                {
#endif
                    /* loopback test passed port:
                     * set ASIC
                     */
                SWDRV_DisablePortAdmin(unit, port);
#if (SYS_CPNT_3COM_LOOPBACK_TEST == TRUE)
                }
#endif

                SWCTRL_UNLOCK();
            }
        }

        if(original_port_info.admin_status != port_info[ifindex-1].admin_status)
        {
            if(port_info[ifindex-1].admin_status == VAL_ifAdminStatus_up)
            {
                /* callback
                 */
                SWCTRL_Notify_uPortAdminEnable(unit, port);

                if(!SWCTRL_IS_TRUNK_MEMBER(ifindex))
                    SWCTRL_Notify_PortAdminEnable(ifindex);

                SWCTRL_LOCK();
            }
            else
            {
                /* callback
                 */
                SWCTRL_Notify_uPortAdminDisable(unit, port);

                if(!SWCTRL_IS_TRUNK_MEMBER(ifindex))
                    SWCTRL_Notify_PortAdminDisable(ifindex);

                SWCTRL_LOCK();
            }
        }
    }
    SWCTRL_UNLOCK();

    /* dormant status
     */
    port_info[ifindex-1].link_oper_status_level = 0;
    port_info[ifindex-1].link_oper_dormant_status = 0;
    port_info[ifindex-1].link_oper_dormant_active = 0;

    /* port_name
     */
    SWCTRL_LOCK();
    memcpy(port_info[ifindex-1].port_entry.port_name, SYS_DFLT_PORT_NAME, sizeof(SYS_DFLT_PORT_NAME));
    port_info[ifindex-1].port_entry.port_name[sizeof(SYS_DFLT_PORT_NAME)] = 0;
    SWCTRL_UNLOCK();

    /* port_capabilities
     */
    /* Setting SWDRV_SetPortAutoNegCapability() will not make chip to run force or auto mode,
     * so, set this API here.
     */
    SWCTRL_LOCK();
#if (SWCTRL_UPDATE_PORT_ABILITY == TRUE)
    port_info[ifindex-1].port_entry.port_capabilities = SWCTRL_GetPortAutoNegCapabilityDfltCfg(unit, port);

    if (user_ext_port_info[ifindex-1].port_abililty.port_autoneg_supported & BIT_VALUE(VAL_portAutonegotiation_enabled))
    {
        SWDRV_SetPortAutoNegCapability (unit, port, port_info[ifindex-1].port_entry.port_capabilities);
    }
#else /* (SWCTRL_UPDATE_PORT_ABILITY == TRUE) */
    if (port_type == VAL_portType_hundredBaseTX)                    /*100 copper*/
    {
        port_info[ifindex-1].port_entry.port_capabilities = SYS_DFLT_10_100_PORT_CAPABILITIES;
    }
    else if (port_type == VAL_portType_hundredBaseFX             ||
             port_type == VAL_portType_hundredBaseFxScSingleMode ||
             port_type == VAL_portType_hundredBaseFxScMultiMode  )  /*100 fiber*/
    {
        port_info[ifindex-1].port_entry.port_capabilities = SYS_DFLT_100_FIBER_PORT_CAPABILITIES;
    }
    else if (port_type == VAL_portType_thousandBaseSX   ||
             port_type == VAL_portType_thousandBaseLX   ||
             port_type == VAL_portType_thousandBaseGBIC ||
             port_type == VAL_portType_thousandBaseSfp  )          /*1000 fiber*/
    {
        port_info[ifindex-1].port_entry.port_capabilities = SYS_DFLT_1000_FIBER_PORT_CAPABILITIES ;
    }
#ifdef SYS_DFLT_10G_FIBER_PORT_CAPABILITIES
    else if (port_type == VAL_portType_tenG         ||
             port_type == VAL_portType_tenGBaseXFP  ||
             port_type == VAL_portType_tenGBaseSFP  )                  /*10G fiber*/
    {
        port_info[ifindex-1].port_entry.port_capabilities = SYS_DFLT_10G_FIBER_PORT_CAPABILITIES;
    }
#endif
#ifdef SYS_DFLT_10G_COPPER_PORT_CAPABILITIES
    /* 10G Copper */
    else if (port_type == VAL_portType_tenGBaseT)
    {
        port_info[ifindex-1].port_entry.port_capabilities = SYS_DFLT_10G_COPPER_PORT_CAPABILITIES;
    }
#endif
#ifdef SYS_DFLT_40G_FIBER_PORT_CAPABILITIES
    /* 40G Fiber */
    else if (port_type == VAL_portType_fortyGBaseQSFP)
    {
        port_info[ifindex-1].port_entry.port_capabilities = SYS_DFLT_40G_FIBER_PORT_CAPABILITIES;
    }
#endif
    else if (port_type == VAL_portType_thousandBaseT)
    {
        port_info[ifindex-1].port_entry.port_capabilities = SYS_DFLT_10_100_1000_PORT_CAPABILITIES ;
    }
    else
    {
        port_info[ifindex-1].port_entry.port_capabilities = 0;
    }
    SWDRV_SetPortAutoNegCapability (unit, port, port_info[ifindex-1].port_entry.port_capabilities);
#endif /* (SWCTRL_UPDATE_PORT_ABILITY == TRUE) */

    /* port_speed_dpx_cfg
     */
    /* Setting SWDRV_SetPortCfgSpeedDuplex() will make chip run force mode, we don't know
     * the auto or force mode, now. In this way, don't set this API here.
     */
#if (SWCTRL_UPDATE_PORT_ABILITY == TRUE)
    port_info[ifindex-1].port_entry.port_speed_dpx_cfg = SWCTRL_GetPortCfgSpeedDuplexDfltCfg(unit, port);
#else /* (SWCTRL_UPDATE_PORT_ABILITY == TRUE) */
    if( port_type == VAL_portType_hundredBaseTX )                    /*FE_COPPER*/
    {
        port_info[ifindex-1].port_entry.port_speed_dpx_cfg = SYS_DFLT_FE_COPPER_PORT_FORCE_MODE_SPDDPX;
    }
    else if( port_type == VAL_portType_hundredBaseFX             ||
             port_type == VAL_portType_hundredBaseFxScSingleMode ||
             port_type == VAL_portType_hundredBaseFxScMultiMode  )    /*FE_FIBER*/
    {
        port_info[ifindex-1].port_entry.port_speed_dpx_cfg = SYS_DFLT_FE_FIBER_PORT_FORCE_MODE_SPDDPX;
    }
    else if( port_type == VAL_portType_thousandBaseSX   ||
             port_type == VAL_portType_thousandBaseLX   ||
             port_type == VAL_portType_thousandBaseGBIC ||
             port_type == VAL_portType_thousandBaseSfp  )    /*GE_FIBER*/
    {
        port_info[ifindex-1].port_entry.port_speed_dpx_cfg = SYS_DFLT_GE_FIBER_PORT_FORCE_MODE_SPDDPX;
        #if (SYS_CPNT_SUPPORT_COMBO_PORT_NO_NEG_KEEP == TRUE)
        port_info[ifindex-1].port_entry.port_combo_fiber_speed_dpx_cfg = SYS_DFLT_GE_FIBER_PORT_FORCE_MODE_SPDDPX;
        #endif
    }
#ifdef SYS_DFLT_40GE_FIBER_PORT_FORCE_MODE_SPDDPX
    else if( port_type == VAL_portType_fortyGBaseQSFP ) /* 40G Port */
    {
        port_info[ifindex-1].port_entry.port_speed_dpx_cfg = SYS_DFLT_40GE_FIBER_PORT_FORCE_MODE_SPDDPX;
    }
#endif
#ifdef SYS_DFLT_10GE_FIBER_PORT_FORCE_MODE_SPDDPX
    else if( port_type == VAL_portType_tenG         ||
             port_type == VAL_portType_tenGBaseXFP  ||
             port_type == VAL_portType_tenGBaseSFP  )          /*10G Port*/
    {
        port_info[ifindex-1].port_entry.port_speed_dpx_cfg = SYS_DFLT_10GE_FIBER_PORT_FORCE_MODE_SPDDPX;
    }
#endif
#ifdef SYS_DFLT_10GE_COPPER_PORT_FORCE_MODE_SPDDPX
    else if( port_type == VAL_portType_tenGBaseT )          /*10G Port COPPER*/
    {
        port_info[ifindex-1].port_entry.port_speed_dpx_cfg = SYS_DFLT_10GE_COPPER_PORT_FORCE_MODE_SPDDPX;
    }
#endif
    else                                                     /*GE_COPPER*/
    {
        /* Aaron add for combo port keep */
        UI32_T media_cap;
        STKTPLG_POM_GetPortMediaCapability(unit, port, &media_cap);

        #if (SYS_CPNT_SUPPORT_COMBO_PORT_NO_NEG_KEEP == TRUE)
        if ((media_cap & STKTPLG_TYPE_PORT_MEDIA_CAP_COPPER) && (media_cap & STKTPLG_TYPE_PORT_MEDIA_CAP_FIBER))
        {
            if (is_provision_complete == FALSE)
            {
                port_info[ifindex-1].port_entry.port_combo_copper_speed_dpx_cfg = SYS_DFLT_GE_COPPER_PORT_FORCE_MODE_SPDDPX;
                port_info[ifindex-1].port_entry.port_combo_fiber_speed_dpx_cfg = SYS_DFLT_GE_FIBER_PORT_FORCE_MODE_SPDDPX;
                port_info[ifindex-1].port_entry.port_speed_dpx_cfg = SYS_DFLT_GE_COPPER_PORT_FORCE_MODE_SPDDPX;
            }
            else
            {
                if (port_info[ifindex-1].port_entry.port_type == VAL_portType_thousandBaseT)
                    port_info[ifindex-1].port_entry.port_speed_dpx_cfg = port_info[ifindex-1].port_entry.port_combo_copper_speed_dpx_cfg;
                else
                    port_info[ifindex-1].port_entry.port_speed_dpx_cfg = port_info[ifindex-1].port_entry.port_combo_fiber_speed_dpx_cfg;
            }

        }
        else
        {
            port_info[ifindex-1].port_entry.port_speed_dpx_cfg = SYS_DFLT_GE_COPPER_PORT_FORCE_MODE_SPDDPX;
            port_info[ifindex-1].port_entry.port_combo_copper_speed_dpx_cfg = SYS_DFLT_GE_COPPER_PORT_FORCE_MODE_SPDDPX;
        }
        #else
            port_info[ifindex-1].port_entry.port_speed_dpx_cfg = SYS_DFLT_GE_COPPER_PORT_FORCE_MODE_SPDDPX;
        #endif
    }
#endif /* (SWCTRL_UPDATE_PORT_ABILITY == TRUE) */

    /* 1000 base-T force configure mode
     */
    #if (SYS_CPNT_SUPPORT_FORCED_1000BASE_T_MODE == TRUE)
    if (is_provision_complete == FALSE)
    {
        port_info[ifindex-1].port_entry.port_forced_1000t_mode = SYS_DFLT_FORCED_1000BASE_T_MASTER_SLAVE_MODE;
        port_info[ifindex-1].forced_1000t_mode = SYS_DFLT_FORCED_1000BASE_T_MASTER_SLAVE_MODE;
    }
    #endif

    /* port_flow_ctrl_cfg
     */
#if (SWCTRL_UPDATE_PORT_ABILITY == TRUE)
    port_info[ifindex-1].port_entry.port_flow_ctrl_cfg = SWCTRL_GetPortCfgFlowCtrlDfltCfg(unit, port);
#else
    port_info[ifindex-1].port_entry.port_flow_ctrl_cfg = SYS_DFLT_PORT_FLOW_CONTROL;
#endif

    /* port_autonegotiation
     */
#if (SWCTRL_UPDATE_PORT_ABILITY == TRUE)
    port_info[ifindex-1].port_entry.port_autonegotiation = SWCTRL_GetPortAutoNegStatusDfltCfg(unit, port);
#else /* (SWCTRL_UPDATE_PORT_ABILITY == TRUE) */
    if (SWCTRL_IS_100FIBER (ifindex) || SWCTRL_IS_10GFIBER (ifindex) || SWCTRL_IS_40GFIBER (ifindex))
    {
        /* Charles: Currently, the default values in SYS_DFLT.H is not port type dependent.
         *          I patch here for 100 fiber port and wait for further instruction.
         */
        port_info[ifindex-1].port_entry.port_autonegotiation = VAL_portAutonegotiation_disabled;
    }
    else if (SWCTRL_IS_10GCOPPER(ifindex))
    {
        port_info[ifindex-1].port_entry.port_autonegotiation = SYS_DFLT_PORT_AUTONEGOTIATION;
    }
    else
    {
        /* Aaron add for combo port keep */
        UI32_T media_cap;
        STKTPLG_POM_GetPortMediaCapability(unit, port, &media_cap);

        #if (SYS_CPNT_SUPPORT_FORCED_1000BASE_T_MODE == TRUE && SYS_CPNT_SUPPORT_COMBO_PORT_NO_NEG_KEEP == TRUE)
        if ((media_cap & STKTPLG_TYPE_PORT_MEDIA_CAP_COPPER) && (media_cap & STKTPLG_TYPE_PORT_MEDIA_CAP_FIBER))
        {
            if (is_provision_complete == FALSE)
                port_info[ifindex-1].port_entry.port_autonegotiation = SYS_DFLT_PORT_AUTONEGOTIATION;
            else
                ; /* no reset the port_autonegotiation */
        }
        else
            port_info[ifindex-1].port_entry.port_autonegotiation = SYS_DFLT_PORT_AUTONEGOTIATION;
        #else
            port_info[ifindex-1].port_entry.port_autonegotiation = SYS_DFLT_PORT_AUTONEGOTIATION;
            #ifdef ASF4526B_FLF_P5
            if( !(media_cap & STKTPLG_TYPE_PORT_MEDIA_CAP_COPPER) )
            {
                port_info[ifindex-1].port_entry.port_autonegotiation = VAL_portAutonegotiation_disabled;
            }
            #endif
        #endif
    }
#endif /* (SWCTRL_UPDATE_PORT_ABILITY == TRUE) */

    /* port_speed_dpx_status
     */
    if(is_enter_master_mode == TRUE)
    {
        /* When SWCTRL enter master mode, all ports are admin shutdowned. The operation speed-duplex is unknown.
         * So, setting the speed-duplex status here base on the port type is just for UIs to get and to show.
         */
#if (SWCTRL_UPDATE_PORT_ABILITY == TRUE)
        port_info[ifindex-1].port_entry.port_speed_dpx_status = SWCTRL_GetPortOptimumOperSpeedDuplex(unit, port);
#else /* (SWCTRL_UPDATE_PORT_ABILITY == TRUE) */
        if( port_type == VAL_portType_hundredBaseTX )                  /*FE_COPPER*/
        {
            port_info[ifindex-1].port_entry.port_speed_dpx_status = VAL_portSpeedDpxCfg_fullDuplex100;
        }
        else if( port_type == VAL_portType_hundredBaseFX             || /*FE_FIBER*/
                 port_type == VAL_portType_hundredBaseFxScSingleMode ||
                 port_type == VAL_portType_hundredBaseFxScMultiMode  )
        {
            port_info[ifindex-1].port_entry.port_speed_dpx_status = VAL_portSpeedDpxCfg_fullDuplex100;
        }
        else if( port_type == VAL_portType_thousandBaseSX   ||         /*GE_FIBER*/
                 port_type == VAL_portType_thousandBaseLX   ||
                 port_type == VAL_portType_thousandBaseGBIC ||
                 port_type == VAL_portType_thousandBaseSfp  )
        {
            port_info[ifindex-1].port_entry.port_speed_dpx_status = VAL_portSpeedDpxCfg_fullDuplex1000;
        }
        else if( port_type == VAL_portType_tenG         ||
                 port_type == VAL_portType_tenGBaseT    ||
                 port_type == VAL_portType_tenGBaseXFP  ||
                 port_type == VAL_portType_tenGBaseSFP    )                      /*10G port*/
        {
            port_info[ifindex-1].port_entry.port_speed_dpx_status = VAL_portSpeedDpxStatus_fullDuplex10g;
        }
        else if( port_type == VAL_portType_twentyFiveGBaseSFP ) /* 25G port */
        {
            port_info[ifindex-1].port_entry.port_speed_dpx_status = VAL_portSpeedDpxStatus_fullDuplex25g;
        }
        else if( port_type == VAL_portType_fortyGBaseQSFP ) /* 40G port */
        {
            port_info[ifindex-1].port_entry.port_speed_dpx_status = VAL_portSpeedDpxStatus_fullDuplex40g;
        }
        else if( port_type == VAL_portType_hundredGBaseQSFP ) /* 100G port */
        {
            port_info[ifindex-1].port_entry.port_speed_dpx_status = VAL_portSpeedDpxStatus_fullDuplex100g;
        }
        else                                                           /*GE_COPPER*/
        {
            port_info[ifindex-1].port_entry.port_speed_dpx_status = VAL_portSpeedDpxCfg_fullDuplex1000;
        }
#endif /* (SWCTRL_UPDATE_PORT_ABILITY == TRUE) */
    }

    /* port_flow_ctrl_status
     */
    if(is_enter_master_mode == TRUE)
    {
        /* When SWCTRL enter master mode, all ports are admin shutdowned. The operation flowcontrol type is unknow.
         * So, setting the flowcontrol type here is just for UIs to get and to show.
         */
        port_info[ifindex-1].port_entry.port_flow_ctrl_status = VAL_portFlowCtrlStatus_none;
    }

    /* port_fec_mode
     */
#if (SYS_CPNT_SWCTRL_FEC == TRUE)
#if (SWCTRL_UPDATE_PORT_ABILITY == TRUE)
    user_ext_port_info[ifindex-1].port_fec_mode = SWCTRL_GetPortFecDfltCfg(unit, port);
#endif
    user_ext_port_info[ifindex-1].port_fec_status = VAL_portFecMode_disabled;
#endif

    /* do something about auto-nego enable or auto-nego disable
     */
    if(port_info[ifindex-1].port_entry.port_autonegotiation == VAL_portAutonegotiation_enabled)
    {
        /* auto mode
         */
        SWDRV_EnablePortAutoNeg(unit, port);

        /* auto-nego capabilities were set in chip, so, it's not necessary to set again.
         */
    }
    else
    {
        /* force mode
         */
         SWDRV_DisablePortAutoNeg(unit, port);

         /* force mode speed-duplex config
          */
         SWDRV_SetPortCfgSpeedDuplex(unit, port, port_info[ifindex-1].port_entry.port_speed_dpx_cfg);

         if(is_enter_master_mode == FALSE)
         {
             /* flowcontrol state
              */
             SWDRV_SetPortCfgFlowCtrl(unit, port, port_info[ifindex-1].port_entry.port_flow_ctrl_cfg);
         }

#if (SYS_CPNT_SWCTRL_FEC == TRUE)
        SWDRV_SetPortFec(unit, port, user_ext_port_info[ifindex-1].port_fec_mode);
        SWDRV_GetPortFecStatus(unit, port, &user_ext_port_info[ifindex-1].port_fec_status);
#endif
    }
    SWCTRL_UNLOCK();

    /* MDIX mode
     */
#if (SYS_CPNT_SWCTRL_MDIX_CONFIG == TRUE)
    /*config mdix default value :auto */
            SWCTRL_SetMDIXMode(ifindex,SYS_DFLT_MDIX_MODE);
#endif

    /* port mtu
     */
#if (SYS_CPNT_SWCTRL_MTU_CONFIG_MODE != SYS_CPNT_SWCTRL_MTU_NOT_CONFIGURABLE)
    if (SWCTRL_JUMBO_FRAME_DISABLE == system_info.jumbo_frame_status)
    {
        SWDRV_SetPortMTU(unit, port, SYS_DFLT_PORT_MTU);
    }
    else
    {
        SWDRV_SetPortMTU(unit, port, port_info[ifindex-1].port_entry.port_mtu);
    }
#endif

    /* sync max frame size
     */
    SWCTRL_SyncUPortMaxFrameSize(unit, port);

    /* port_trunk_index
     */
    port_info[ifindex-1].port_entry.port_trunk_index = 0;

    /* link_change_trap
     */
    port_info[ifindex-1].link_change_trap = SYS_DFLT_IF_LINK_UP_DOWN_TRAP_ENABLE;

    /* port learning status
     */
    SWCTRL_LOCK();
    user_ext_port_info[ifindex-1].learning_disabled_status = 0;
    SWCTRL_SetUPortLearningStatus(unit, port, !user_ext_port_info[ifindex-1].learning_disabled_status, TRUE);
    SWCTRL_UNLOCK();

#if(SYS_CPNT_AMTR_PORT_MAC_LEARNING == TRUE)/*Tony.Lei*/
    SWCTRL_LOCK();
    port_info[ifindex-1].port_entry.port_macaddr_learning = SYS_DFLT_PORT_MAC_LEARNING;
    SWCTRL_SetPortLearningStatus_Local(ifindex, port_info[ifindex-1].port_entry.port_macaddr_learning, SWCTRL_LEARNING_DISABLED_BY_CFG);
    SWCTRL_UNLOCK();
#endif

    if (is_enter_master_mode == TRUE)
    {
        /* port security
         */
        SWCTRL_LOCK();
        port_info[ifindex-1].port_security_status                  = VAL_portSecPortStatus_disabled;
        port_info[ifindex-1].port_security_action_status           = VAL_portSecAction_none;
        port_info[ifindex-1].port_security_action_trap_oper_status = VAL_portSecAction_none;
        port_info[ifindex-1].port_security_action_trap_time_stamp  = 0;

        SWCTRL_SetPortPktTrapStatus_Local(
            ifindex,
            SWCTRL_PKTTYPE_INTRUDER,
            (SWCTRL_INTRUDER_TRAP_BY_PSEC | SWCTRL_INTRUDER_TRAP_BY_DOT1X | SWCTRL_INTRUDER_TRAP_BY_NETACCESS),
            (port_info[ifindex-1].port_security_status == VAL_portSecPortStatus_enabled),
            (port_info[ifindex-1].port_security_action_status != VAL_portSecAction_none));

        SWCTRL_UNLOCK();
    }

#if (SYS_CPNT_INGRESS_RATELIMIT_BSTORM_MSTORM_XOR_EACH_OTHER == TRUE)
    SWCTRL_DisableAllRateLimitAndStormsStatus(ifindex);
#endif

    SWCTRL_LOCK();
#ifdef SYS_ADPT_PACKETCELL_INTERVAL
    if(!SWDRV_GetPortStormGranularity(unit, port, SYS_DFLT_BSTORM_TYPE, &port_info[ifindex-1].storm_granularity))
    {
        port_info[ifindex-1].storm_granularity=SYS_ADPT_PACKETCELL_INTERVAL;
    }
#else   /* Not all project */
    port_info[ifindex-1].storm_granularity=1;

#endif
    SWCTRL_UNLOCK();

#if (SYS_CPNT_STORM_MODE & SYS_CPNT_STORM_UNKNOWN_USTORM)
    /* Enable Unknowunicast Storm will impact IGMP function
     */
    SWCTRL_LOCK();
    port_info[ifindex-1].unknown_ucast_storm_entry.unknown_ucast_storm_status = SYS_DFLT_UNKUCAST_STORM_STATUS;
    if (port_info[ifindex-1].unknown_ucast_storm_entry.unknown_ucast_storm_status == VAL_unkucastStormStatus_enabled)
    {
        SWDRV_EnableUnknownUnicastStormControl (unit, port);
    }
    else
    {
#if (SYS_CPNT_INGRESS_RATELIMIT_BSTORM_MSTORM_XOR_EACH_OTHER == FALSE)
        SWDRV_DisableUnknownUnicastStormControl (unit, port);
#endif
    }
    port_info[ifindex-1].unknown_ucast_storm_entry.unknown_ucast_storm_sample_type = SYS_DFLT_UNKUSTORM_TYPE;

    if (port_info[ifindex-1].unknown_ucast_storm_entry.unknown_ucast_storm_sample_type == VAL_unkucastStormSampleType_pkt_rate)
    {
        /* Differen port maybe have differnet granularity.
         * So can't set all port to use SYS_DFLT_UNKUSTORM_RATE_LIMIT
         */
        port_info[ifindex-1].unknown_ucast_storm_entry.unknown_ucast_storm_pkt_rate = (port_info[ifindex-1].storm_granularity > SYS_DFLT_UNKUSTORM_RATE_LIMIT)
                                                                      ?port_info[ifindex-1].storm_granularity:SYS_DFLT_UNKUSTORM_RATE_LIMIT;
    }
    else if (port_info[ifindex-1].unknown_ucast_storm_entry.unknown_ucast_storm_sample_type == VAL_unkucastStormSampleType_octet_rate)
    {
        port_info[ifindex-1].unknown_ucast_storm_entry.unknown_ucast_storm_octet_rate = (port_info[ifindex-1].storm_granularity > SYS_DFLT_UNKUSTORM_RATE_LIMIT)
                                                                      ?port_info[ifindex-1].storm_granularity:SYS_DFLT_UNKUSTORM_RATE_LIMIT;
    }
    else
    {
        port_info[ifindex-1].unknown_ucast_storm_entry.unknown_ucast_storm_percent = SYS_DFLT_UNKUSTORM_RATE_LIMIT;
    }

    SWDRV_SetUnknownUnicastStormControlThreshold (unit, port, SYS_DFLT_UNKUSTORM_RATE_LIMIT, SYS_DFLT_UNKUCAST_STORM_MODE);
    SWCTRL_UNLOCK();
#endif

#if (SYS_CPNT_SWCTRL_SINGLE_INGRESS_RATE_LIMIT == TRUE)
    if(port_info[ifindex-1].storm_granularity >SYS_DFLT_UNKUSTORM_RATE_LIMIT)
    {
        SWCTRL_SyncRateLimitThreshold(ifindex, SYS_DFLT_UNKUCAST_STORM_MODE, port_info[ifindex-1].storm_granularity, port_info[ifindex-1].storm_granularity, SYS_CPNT_SWCTRL_RATE_LIMIT_GROUP_FOR_UNKNOWN_USTORM);
    }
    else
    {
        SWCTRL_SyncRateLimitThreshold(ifindex, SYS_DFLT_UNKUCAST_STORM_MODE, SYS_DFLT_UNKUSTORM_RATE_LIMIT, SYS_DFLT_UNKUSTORM_RATE_LIMIT, SYS_CPNT_SWCTRL_RATE_LIMIT_GROUP_FOR_UNKNOWN_USTORM);
    }
#endif

    /* Enable Multicast Storm will impact IGMP function
     */
    SWCTRL_LOCK();
    port_info[ifindex-1].mcast_storm_entry.mcast_storm_status = SYS_DFLT_MCAST_STORM_STATUS;
    if (port_info[ifindex-1].mcast_storm_entry.mcast_storm_status == VAL_mcastStormStatus_enabled)
    {
        SWDRV_EnableMulticastStormControl (unit, port);
    }
    else
    {
#if (SYS_CPNT_INGRESS_RATELIMIT_BSTORM_MSTORM_XOR_EACH_OTHER == FALSE)
        SWDRV_DisableMulticastStormControl (unit, port);
#endif
    }
    port_info[ifindex-1].mcast_storm_entry.mcast_storm_sample_type = SYS_DFLT_MSTORM_TYPE;

    if (port_info[ifindex-1].mcast_storm_entry.mcast_storm_sample_type == VAL_mcastStormSampleType_pkt_rate)
    {
        port_info[ifindex-1].mcast_storm_entry.mcast_storm_pkt_rate = (port_info[ifindex-1].storm_granularity > SYS_DFLT_MSTORM_RATE_LIMIT)
                                                                      ?port_info[ifindex-1].storm_granularity:SYS_DFLT_MSTORM_RATE_LIMIT;
    }
    else if (port_info[ifindex-1].mcast_storm_entry.mcast_storm_sample_type == VAL_mcastStormSampleType_octet_rate)
    {
        port_info[ifindex-1].mcast_storm_entry.mcast_storm_octet_rate = (port_info[ifindex-1].storm_granularity > SYS_DFLT_MSTORM_RATE_LIMIT)
                                                                      ?port_info[ifindex-1].storm_granularity:SYS_DFLT_MSTORM_RATE_LIMIT;
    }
    else
    {
        port_info[ifindex-1].mcast_storm_entry.mcast_storm_percent = SYS_DFLT_MSTORM_RATE_LIMIT;
    }

    SWDRV_SetMulticastStormControlThreshold (unit, port, SYS_DFLT_MSTORM_RATE_LIMIT, SYS_DFLT_MCAST_STORM_MODE);
    SWCTRL_UNLOCK();

#if (SYS_CPNT_SWCTRL_SINGLE_INGRESS_RATE_LIMIT == TRUE)
    if(port_info[ifindex-1].storm_granularity >SYS_DFLT_MSTORM_RATE_LIMIT)
    {
        SWCTRL_SyncRateLimitThreshold(ifindex, SYS_DFLT_MCAST_STORM_MODE, port_info[ifindex-1].storm_granularity, port_info[ifindex-1].storm_granularity, SYS_CPNT_SWCTRL_RATE_LIMIT_GROUP_FOR_MSTORM);
    }
    else
    {
        SWCTRL_SyncRateLimitThreshold(ifindex, SYS_DFLT_MCAST_STORM_MODE, SYS_DFLT_MSTORM_RATE_LIMIT, SYS_DFLT_MSTORM_RATE_LIMIT, SYS_CPNT_SWCTRL_RATE_LIMIT_GROUP_FOR_MSTORM);
    }
#endif

    /* broadcast sotrm control
     */
    SWCTRL_LOCK();
    port_info[ifindex-1].bcast_storm_entry.bcast_storm_status = SYS_DFLT_BCAST_STORM_STATUS;
    if (port_info[ifindex-1].bcast_storm_entry.bcast_storm_status == VAL_bcastStormStatus_enabled)
    {
        SWDRV_EnableBroadcastStormControl (unit, port);
    }
    else
    {
#if (SYS_CPNT_INGRESS_RATELIMIT_BSTORM_MSTORM_XOR_EACH_OTHER == FALSE)
        SWDRV_DisableBroadcastStormControl (unit, port);
#endif
    }
    port_info[ifindex-1].bcast_storm_entry.bcast_storm_sample_type = SYS_DFLT_BSTORM_TYPE;

    if (port_info[ifindex-1].bcast_storm_entry.bcast_storm_sample_type == VAL_bcastStormSampleType_pkt_rate)
    {
        port_info[ifindex-1].bcast_storm_entry.bcast_storm_pkt_rate = (port_info[ifindex-1].storm_granularity > SYS_DFLT_BSTORM_RATE_LIMIT)
                                                                      ?port_info[ifindex-1].storm_granularity:SYS_DFLT_BSTORM_RATE_LIMIT;
    }
    else if (port_info[ifindex-1].bcast_storm_entry.bcast_storm_sample_type == VAL_bcastStormSampleType_octet_rate)
    {
        port_info[ifindex-1].bcast_storm_entry.bcast_storm_octet_rate = (port_info[ifindex-1].storm_granularity > SYS_DFLT_BSTORM_RATE_LIMIT)
                                                                      ?port_info[ifindex-1].storm_granularity:SYS_DFLT_BSTORM_RATE_LIMIT;
    }
    else
    {
        port_info[ifindex-1].bcast_storm_entry.bcast_storm_percent = SYS_DFLT_BSTORM_RATE_LIMIT;
    }

    SWDRV_SetBroadcastStormControlThreshold (unit, port, SYS_DFLT_BSTORM_RATE_LIMIT, SYS_DFLT_BCAST_STORM_MODE);
    SWCTRL_UNLOCK();

#if (SYS_CPNT_SWCTRL_SINGLE_INGRESS_RATE_LIMIT == TRUE)
    if(port_info[ifindex-1].storm_granularity >SYS_DFLT_BSTORM_RATE_LIMIT)
    {
        SWCTRL_SyncRateLimitThreshold(ifindex, SYS_DFLT_BCAST_STORM_MODE, port_info[ifindex-1].storm_granularity, port_info[ifindex-1].storm_granularity, SYS_CPNT_SWCTRL_RATE_LIMIT_GROUP_FOR_BSTORM);
    }
    else
    {
        SWCTRL_SyncRateLimitThreshold(ifindex, SYS_DFLT_BCAST_STORM_MODE, SYS_DFLT_BSTORM_RATE_LIMIT, SYS_DFLT_BSTORM_RATE_LIMIT, SYS_CPNT_SWCTRL_RATE_LIMIT_GROUP_FOR_BSTORM);
    }
#endif


#if (SYS_CPNT_ATC_BSTORM == TRUE)
    port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_status = SYS_DFLT_ATC_BSTORM_STATUS;
    port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_sample_type = SYS_DFLT_ATC_BSTORM_TYPE;
    port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_status = SYS_DFLT_ATC_BSTORM_STATUS;

    if (port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_sample_type == VAL_atcBcastStormSampleType_packet_rate)
    {
        port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_packet_rate = SYS_DFLT_ATC_BSTORM_STORM_CLEAR_THRESHOLD;
    }
    else if (port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_sample_type == VAL_atcBcastStormSampleType_octet_rate)
    {
        port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_octet_rate = SYS_DFLT_ATC_BSTORM_STORM_CLEAR_THRESHOLD;
    }
    else
    {
        port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_percent = SYS_DFLT_ATC_BSTORM_STORM_CLEAR_THRESHOLD;
    }

    port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_current_traffic_rate = 0;
    port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_auto_traffic_control_on = SYS_DFLT_ATC_BSTORM_ATC_ON;
    port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_auto_traffic_control_release = SYS_DFLT_ATC_BSTORM_ATC_RELEASE;
    port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_traffic_control_on = SYS_DFLT_ATC_BSTORM_STORM_TC_ON;
    port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_traffic_control_release = SYS_DFLT_ATC_BSTORM_STORM_TC_RELEASE;
    port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_storm_alarm_threshold = SYS_DFLT_ATC_BSTORM_STORM_ALARM_THRESHOLD;
    port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_storm_clear_threshold = SYS_DFLT_ATC_BSTORM_STORM_CLEAR_THRESHOLD;
    port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_trap_storm_alarm = SYS_DFLT_ATC_BSTORM_STORM_TRAP_STORM_ALARM;
    port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_trap_storm_clear = SYS_DFLT_ATC_BSTORM_STORM_TRAP_STORM_CLEAR;
    port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_trap_traffic_control_on = SYS_DFLT_ATC_BSTORM_STORM_TRAP_TC_ON;
    port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_trap_traffic_control_release = SYS_DFLT_ATC_BSTORM_STORM_TRAP_TC_RELEASE;
    port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_action = SYS_DFLT_ATC_BSTORM_STORM_ACTION;
    port_info[ifindex-1].atc_broadcast_storm_entry.atc_broadcast_storm_operation_status = SYS_DFLT_ATC_BSTORM_OPEARATION_STATUS;

    port_info[ifindex-1].atc_broadcast_storm_entry.state_machine_state = SWCTRL_ATCBSTORM_INIT_ST;
    port_info[ifindex-1].atc_broadcast_storm_entry.state_machine_trapf = SWCTRL_ATC_MULTICAST_STORM_TRAPF_LOW_FLOW;
    port_info[ifindex-1].atc_broadcast_storm_entry.state_machine_ctrapf = SWCTRL_ATC_MULTICAST_STORM_CTRAPF_RELEASE;
    port_info[ifindex-1].atc_broadcast_storm_entry.state_machine_t1 = 0;
    port_info[ifindex-1].atc_broadcast_storm_entry.state_machine_t2 = 0;
    port_info[ifindex-1].atc_broadcast_storm_entry.state_machine_manual = SWCTRL_ATC_MULTICAST_STORM_STATE_MACHINE_MANUAL_DISABLE;
#endif

#if (SYS_CPNT_ATC_MSTORM == TRUE)
    port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_status = SYS_DFLT_ATC_MSTORM_STATUS;
    port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_sample_type = SYS_DFLT_ATC_MSTORM_TYPE;
    port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_status = SYS_DFLT_ATC_MSTORM_STATUS;

    if (port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_sample_type == VAL_atcMcastStormSampleType_packet_rate)
    {
        port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_packet_rate = SYS_DFLT_ATC_MSTORM_STORM_CLEAR_THRESHOLD;
    }
    else if (port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_sample_type == VAL_atcMcastStormSampleType_octet_rate)
    {
        port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_octet_rate = SYS_DFLT_ATC_MSTORM_STORM_CLEAR_THRESHOLD;
    }
    else
    {
        port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_percent = SYS_DFLT_ATC_MSTORM_STORM_CLEAR_THRESHOLD;
    }

    port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_current_traffic_rate = 0;
    port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_auto_traffic_control_on = SYS_DFLT_ATC_MSTORM_ATC_ON;
    port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_auto_traffic_control_release = SYS_DFLT_ATC_MSTORM_ATC_RELEASE;
    port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_traffic_control_on = SYS_DFLT_ATC_MSTORM_STORM_TC_ON;
    port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_traffic_control_release = SYS_DFLT_ATC_MSTORM_STORM_TC_RELEASE;
    port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_storm_alarm_threshold = SYS_DFLT_ATC_MSTORM_STORM_ALARM_THRESHOLD;
    port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_storm_clear_threshold = SYS_DFLT_ATC_MSTORM_STORM_CLEAR_THRESHOLD;
    port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_trap_storm_alarm = SYS_DFLT_ATC_MSTORM_STORM_TRAP_STORM_ALARM;
    port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_trap_storm_clear = SYS_DFLT_ATC_MSTORM_STORM_TRAP_STORM_CLEAR;
    port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_trap_traffic_control_on = SYS_DFLT_ATC_MSTORM_STORM_TRAP_TC_ON;
    port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_trap_traffic_control_release = SYS_DFLT_ATC_MSTORM_STORM_TRAP_TC_RELEASE;
    port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_action = SYS_DFLT_ATC_MSTORM_STORM_ACTION;
    port_info[ifindex-1].atc_multicast_storm_entry.atc_multicast_storm_operation_status = SYS_DFLT_ATC_MSTORM_OPEARATION_STATUS;

    port_info[ifindex-1].atc_multicast_storm_entry.state_machine_state = SWCTRL_ATCMSTORM_INIT_ST;
    port_info[ifindex-1].atc_multicast_storm_entry.state_machine_trapf = SWCTRL_ATC_MULTICAST_STORM_TRAPF_LOW_FLOW;
    port_info[ifindex-1].atc_multicast_storm_entry.state_machine_ctrapf = SWCTRL_ATC_MULTICAST_STORM_CTRAPF_RELEASE;
    port_info[ifindex-1].atc_multicast_storm_entry.state_machine_t1 = 0;
    port_info[ifindex-1].atc_multicast_storm_entry.state_machine_t2 = 0;
    port_info[ifindex-1].atc_multicast_storm_entry.state_machine_manual = SWCTRL_ATC_MULTICAST_STORM_STATE_MACHINE_MANUAL_DISABLE;
#endif


#if (SYS_CPNT_INGRESS_RATE_LIMIT == TRUE)
    /* ingress rate limit
     */
    SWCTRL_LOCK();
    port_info[ifindex-1].ingress_rate_limit_status = SYS_DFLT_INGRESS_RATE_LIMIT_STATUS;
    port_info[ifindex-1].ingress_rate_limit = SWCTRL_GetDefaultRateLimit(port_info[ifindex-1].port_entry.port_type);

    SWDRV_SetPortIngressRateLimit (unit, port, 0, port_info[ifindex-1].ingress_rate_limit);
    if (port_info[ifindex-1].ingress_rate_limit_status == TRUE)
    {
        SWDRV_EnablePortIngressRateLimit(unit, port);
    }
    else
    {
#if (SYS_CPNT_INGRESS_RATELIMIT_BSTORM_MSTORM_XOR_EACH_OTHER == FALSE)
        SWDRV_DisablePortIngressRateLimit(unit, port, 0);
#endif
    }

    SWCTRL_UNLOCK();

#if (SYS_CPNT_SWCTRL_SINGLE_INGRESS_RATE_LIMIT == TRUE)
    SWCTRL_SyncRateLimitThreshold(
        ifindex,
        SWCTRL_STORM_SAMPLE_TYPE_OCTET_RATE,
        port_info[ifindex-1].ingress_rate_limit,
        port_info[ifindex-1].ingress_rate_limit,
        SYS_CPNT_SWCTRL_RATE_LIMIT_GROUP_FOR_INGRESS_RATE_LIMIT);
#endif
#endif

#if (SYS_CPNT_EGRESS_RATE_LIMIT == TRUE)
    /* egress rate limit
     */
    SWCTRL_LOCK();
    port_info[ifindex-1].egress_rate_limit_status = SYS_DFLT_EGRESS_RATE_LIMIT_STATUS;
    port_info[ifindex-1].egress_rate_limit = SWCTRL_GetDefaultRateLimit(port_info[ifindex-1].port_entry.port_type);

    SWDRV_SetPortEgressRateLimit (unit, port, port_info[ifindex-1].egress_rate_limit);
    if (port_info[ifindex-1].egress_rate_limit_status == TRUE)
    {
        SWDRV_EnablePortEgressRateLimit(unit, port);
    }
    else
    {
        SWDRV_DisablePortEgressRateLimit(unit, port);
    }
    SWCTRL_UNLOCK();
#endif
    /* set egress scheduler mode
     */
#if (SYS_CPNT_WRR_Q_MODE_PER_PORT_CTRL == TRUE) && (SYS_CPNT_WRR_Q_WEIGHT_PER_PORT_CTRL == TRUE)
    /*
     * In the per port case, if cos_vm has done the init, swctrl should not do
     * init again. cos_vm is taking care of queuing and scheduling logic now.
     * So that swctrl should never control or triger the CSC functionalities.
     */
    SWCTRL_LOCK();
    if (default_egress_scheduler_mode == SWCTRL_WEIGHT_ROUND_ROBIN_METHOD)
    {
        port_info[ifindex-1].egress_scheduler_method = SWCTRL_WEIGHT_ROUND_ROBIN_METHOD;
        SWDRV_SetPortEgressSchedulingMethod(unit, port, SWCTRL_WEIGHT_ROUND_ROBIN_METHOD);
         for (q_id=0; q_id<SYS_ADPT_MAX_NBR_OF_PRIORITY_QUEUE; q_id++)
         {
            SWDRV_SetPortWrrQueueWeight(unit, port, q_id, wrr_queue_default[q_id]);
            port_info[ifindex-1].wrr_weight[q_id] = wrr_queue_default[q_id];
         }
    }
    else
    {
        port_info[ifindex-1].egress_scheduler_method = SWCTRL_STRICT_PRIORITY_METHOD;
        SWDRV_SetPortEgressSchedulingMethod(unit, port, SWCTRL_STRICT_PRIORITY_METHOD);
    }
    SWCTRL_UNLOCK();
#endif

    /* set attributes to fixed value
     */
    SWCTRL_SetServerBladePortFixAttributes (unit, port);

    /* link_oper_status_last_change
     */
    SYS_TIME_GetSystemUpTimeByTick(&(port_info[ifindex-1].link_oper_status_last_change));

    /* port egress block
     */
    SWCTRL_SetPortEgressBlockEx(ifindex, NULL, NULL);

#if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION == TRUE)
#if (SYS_DFLT_TRAFFIC_SEG_METHOD == SYS_DFLT_TRAFFIC_SEG_METHOD_PORT_PRIVATE_MODE)
    if(is_enter_master_mode == TRUE)
    {
        SWCTRL_LOCK();
        port_info[ifindex-1].private_vlan_uplink_port = TRUE;
        SWCTRL_UNLOCK();
    }
#endif
#endif

    /* these 4 database entries jsut for user port
     */

    {
        SYS_TYPE_Uport_T    unit_port;

        unit_port.unit = (UI16_T) unit;
        unit_port.port = (UI16_T) port;

        if (is_enter_master_mode == TRUE)
        {
            /* LACP_state
             */
#if (SYS_CPNT_STATIC_TRUNK_CONFIG_ALLOWED_ON_LACP_PORT == TRUE)
            /* From now on, LACP should tell SWCTRL admin/oper status, When LACP
             * enter master mode, so, it's not necessary for SWCTRL to set this
             * 2 variable: 1) lacp_admin_status, and 2) lacp_oper_status
             */
#else
            user_ext_port_info[ifindex-1].lacp_status = SYS_DFLT_PORT_LACP_PORT_STATUS;
#endif

            /* Dot1x_state
             */
            user_ext_port_info[ifindex-1].dot1x_status = SWCTRL_DOT1X_PORT_DEFAULT_STATE;
        }

        /* mirroring
         */
        /* if analyzer => delete all entry
         */
        if(SWCTRL_IsAnalyzerPort(unit_port))
        {
            UI32_T src;

            for(src = 1; src<=SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK*SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT; src++)
            {
                SWCTRL_SetMirrorStatus(src, ifindex, VAL_mirrorStatus_invalid);
            }
        }
        /* if monitored => delete all entry
         */

        if(SWCTRL_IsMonitoredPort(unit_port))
        {
            UI32_T dest;

            for(dest = 1; dest <= SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK*SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT; dest++)
            {
                SWCTRL_SetMirrorStatus(ifindex , dest, VAL_mirrorStatus_invalid);
            }
        }
        user_ext_port_info[ifindex-1].mirroring_tx_dest_port = 0;
        user_ext_port_info[ifindex-1].mirroring_rx_dest_port = 0;
    }

#if (SYS_CPNT_INTERNAL_LOOPBACK_TEST == TRUE)
    user_ext_port_info[ifindex-1].is_int_loopback_mode = FALSE;
#endif

#if (SYS_CPNT_EFM_OAM == TRUE)
    user_ext_port_info[ifindex-1].is_oam_loopback_mode = FALSE;
#endif

#if (SYS_CPNT_SWCTRL_PORT_PENDING_LINK_UP == TRUE)
    port_info[ifindex-1].link_status_pending_up_status = 0;

    if (SYS_DFLT_SWCTRL_PORT_PENDING_LINK_UP_STATUS)
    {
        port_info[ifindex-1].link_status_pending_up_status |= SWCTRL_PORT_PENDING_LINKUP_OWNER__DFLT_CFG;
    }
    else
    {
        port_info[ifindex-1].link_status_pending_up_status &= ~SWCTRL_PORT_PENDING_LINKUP_OWNER__DFLT_CFG;
    }

    #if defined(SYS_DFLT_SWCTRL_PORT_PENDING_LINK_UP_STATUS_FOR_10G_SFP_PORT)
    if (SWCTRL_IS_10GSFP(ifindex))
    {
        if (SYS_DFLT_SWCTRL_PORT_PENDING_LINK_UP_STATUS_FOR_10G_SFP_PORT)
        {
            port_info[ifindex-1].link_status_pending_up_status |= SWCTRL_PORT_PENDING_LINKUP_OWNER__DFLT_CFG;
        }
        else
        {
            port_info[ifindex-1].link_status_pending_up_status &= ~SWCTRL_PORT_PENDING_LINKUP_OWNER__DFLT_CFG;
        }
    }
    #endif

#endif

#if (SYS_CPNT_POWER_SAVE == TRUE)
    if (SWCTRL_IsPortPowerSaveSupported(ifindex))
    {
        user_ext_port_info[ifindex-1].power_save_admin_status = SYS_DFLT_POWER_SAVE_STATUS;
    }
    else
    {
        user_ext_port_info[ifindex-1].power_save_admin_status = VAL_portPowerSave_disabled;
    }
#if (SYS_CPNT_SWCTRL_PORT_PENDING_LINK_UP == TRUE)
    if (user_ext_port_info[ifindex-1].power_save_admin_status == VAL_portPowerSave_enabled)
    {
        port_info[ifindex-1].link_status_pending_up_status |= SWCTRL_PORT_PENDING_LINKUP_OWNER__POWER_SAVE;
    }
    else
    {
        port_info[ifindex-1].link_status_pending_up_status &= ~SWCTRL_PORT_PENDING_LINKUP_OWNER__POWER_SAVE;
    }
#endif
    {
        BOOL_T power_save_oper_status = user_ext_port_info[ifindex-1].power_save_admin_status;

        if (!SWCTRL_IS_LINK_UP(ifindex))
        {
            power_save_oper_status = VAL_portPowerSave_disabled;
        }

        SWCTRL_SetUPortPowerSave(unit, port, power_save_oper_status, TRUE);
    }
#endif

#if (SYS_CPNT_RSPAN == TRUE)
    port_info[ifindex-1].rspan_frame_sz_is_modified = FALSE;
#endif

#if (SYS_CPNT_ITRI_MIM == TRUE)
    SWCTRL_ITRI_MIM_SetStatus(ifindex, FALSE);
#endif

} /* end of SWCTRL_ConfigUserPortToDefaultState()*/


#if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION == TRUE)
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetPrivateVlanPortList
 * -------------------------------------------------------------------------
 * FUNCTION: This function will get the private vlan
 * INPUT   : None
 * OUTPU   : uplink_port_list  -- uplink port list
 *           downlink_port_list -- downlink port list
 * RETURN  :
 * NOTE    : None
 * -------------------------------------------------------------------------*/
static void SWCTRL_GetPrivateVlanPortList(BOOL_T is_uplink, UI8_T port_list[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST])
{
#define UI8_T_ARRAY_INDEX(OM_IDX)  ((int)((OM_IDX)/8))
#define BIT_IN_UI8_T(OM_IDX)       (1 << (7 - ((OM_IDX) - (UI8_T_ARRAY_INDEX(OM_IDX)*8))))

    UI32_T om_idx;

    memset(port_list, 0, SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST);

    if(is_uplink)
    {
        for(om_idx = 0; om_idx<SYS_ADPT_TOTAL_NBR_OF_LPORT; om_idx++)
        {
            if(!SWCTRL_IS_EXIST(om_idx+1))
                continue;

            if( port_info[om_idx].private_vlan_uplink_port == TRUE )
                port_list[ UI8_T_ARRAY_INDEX(om_idx) ] |= BIT_IN_UI8_T(om_idx);
        }
    }
    else
    {
        for(om_idx = 0; om_idx<SYS_ADPT_TOTAL_NBR_OF_LPORT; om_idx++)
        {
            if(!SWCTRL_IS_EXIST(om_idx+1))
                continue;

            if( port_info[om_idx].private_vlan_downlink_port == TRUE )
                port_list[ UI8_T_ARRAY_INDEX(om_idx) ] |= BIT_IN_UI8_T(om_idx);
        }
    }
} /* end of SWCTRL_GetPrivateVlanPortList() */

#endif /*#if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION == TRUE)*/

#if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION == TRUE)
#if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE == SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE_MULTIPLE_SESSION)
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetPrivateVlanBySessionId
 * -------------------------------------------------------------------------
 * FUNCTION: This function will get private vlan by group session id
 * INPUT   : session_id         -- is group session id
 *           uplink_port_list   -- uplink port list
 *           downlink_port_list -- downlink port list
 * OUTPUT  : None
 * RETURN  : True: Successfully, FALSE: Failed
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_GetPrivateVlanBySessionId(
              UI32_T session_id,
              UI8_T  uplink_port_list  [SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST],
              UI8_T  downlink_port_list[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST])
{
    UI32_T sId = 0, ifindex = 0;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (uplink_port_list == 0 || downlink_port_list == 0 )
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    sId = session_id;

    if (sId < 1 || sId > SYS_ADPT_PORT_TRAFFIC_SEGMENTATION_MAX_NBR_OF_SESSIONS )
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (swctl_private_vlan_ext_info[sId-1].is_valid == FALSE)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
    else
    {
        memset(uplink_port_list, 0, SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST);
        memset(downlink_port_list, 0, SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST);
        memcpy(uplink_port_list, swctl_private_vlan_ext_info[sId-1].private_vlan_uplink_port_list, SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST);
        memcpy(downlink_port_list, swctl_private_vlan_ext_info[sId-1].private_vlan_downlink_port_list, SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST);
    }

    /* when trunk port is pvlan, which member of trunk port shall be invisible*/
    for (ifindex=1; ifindex<=SYS_ADPT_TOTAL_NBR_OF_LPORT; ifindex++)
    {
        if((uplink_port_list[(ifindex-1)/8]<<((ifindex-1)%8))&0x80 )
        {
            if (swctl_private_vlan_port_info[ifindex-1].is_pvlan_trunk_index_port == TRUE)
            {
                uplink_port_list[SWCTRL_BYTE_IN_BITMAP(ifindex)] &= ~(SWCTRL_BIT_IN_BITMAP(ifindex));
            }
        }
        else if((downlink_port_list[(ifindex-1)/8]<<((ifindex-1)%8))&0x80 )
        {
            if (swctl_private_vlan_port_info[ifindex-1].is_pvlan_trunk_index_port == TRUE)
            {
                downlink_port_list[SWCTRL_BYTE_IN_BITMAP(ifindex)] &= ~(SWCTRL_BIT_IN_BITMAP(ifindex));
            }
        }
    }

    SWCTRL_RETURN_AND_RELEASE_CSC(TRUE);

} /* end of SWCTRL_GetPrivateVlanBySessionId() */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetRunningPrivateVlanPortListBySessionId
 * -------------------------------------------------------------------------
 * FUNCTION: This function will get the private vlan running config by sId
 * INPUT   : session_id         -- get pvlan group id
 *           uplink_port_list   -- uplink port list
 *           downlink_port_list -- downlink port list
 * OUTPU   : uplink_port_list, downlink_port_list
 * RETURN  : SYS_TYPE_Get_Running_Cfg_T, No change while entry no exist
 * NOTE    : None
 * -------------------------------------------------------------------------*/
SYS_TYPE_Get_Running_Cfg_T SWCTRL_GetRunningPrivateVlanPortListBySessionId(
                                UI32_T session_id,
                                UI8_T  uplink_port_list  [SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST],
                                UI8_T  downlink_port_list[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST])
{
    UI32_T sId = 0, ifindex = 0;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(SYS_TYPE_GET_RUNNING_CFG_FAIL);

    if (uplink_port_list == 0 || downlink_port_list == 0)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC(SYS_TYPE_GET_RUNNING_CFG_FAIL);
    }

    sId = session_id;

    if (sId < 1 || sId > SYS_ADPT_PORT_TRAFFIC_SEGMENTATION_MAX_NBR_OF_SESSIONS )
    {
        SWCTRL_RETURN_AND_RELEASE_CSC(SYS_TYPE_GET_RUNNING_CFG_FAIL);
    }

    if (swctl_private_vlan_ext_info[sId-1].is_valid == FALSE)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_NO_CHANGE );
    }

    SWCTRL_LOCK();
    memset(uplink_port_list, 0, SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST);
    memset(downlink_port_list, 0, SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST);
    memcpy(uplink_port_list, swctl_private_vlan_ext_info[sId-1].private_vlan_uplink_port_list, SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST);
    memcpy(downlink_port_list, swctl_private_vlan_ext_info[sId-1].private_vlan_downlink_port_list, SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST);
    SWCTRL_UNLOCK();

#if (SWCTRL_PORT_TRAFFIC_SEGMENTATION_AUTO_ATTRIBUTE == TRUE)
    /* filter out all trunk config
     */
    for (ifindex=1; ifindex<=SYS_ADPT_TOTAL_NBR_OF_LPORT; ifindex++)
    {
        if (!SWCTRL_IS_USER_PORT(ifindex))
        {
            uplink_port_list[SWCTRL_BYTE_IN_BITMAP(ifindex)] &= ~(SWCTRL_BIT_IN_BITMAP(ifindex));
            downlink_port_list[SWCTRL_BYTE_IN_BITMAP(ifindex)] &= ~(SWCTRL_BIT_IN_BITMAP(ifindex));
        }
    }
#else
    /* when trunk port is pvlan, which member of trunk port shall be invisible*/
    for (ifindex=1; ifindex<=SYS_ADPT_TOTAL_NBR_OF_LPORT; ifindex++)
    {
        if((uplink_port_list[(ifindex-1)/8]<<((ifindex-1)%8))&0x80 )
        {
            if (swctl_private_vlan_port_info[ifindex-1].is_pvlan_trunk_index_port == TRUE)
            {
                uplink_port_list[SWCTRL_BYTE_IN_BITMAP(ifindex)] &= ~(SWCTRL_BIT_IN_BITMAP(ifindex));
            }
        }
        else if((downlink_port_list[(ifindex-1)/8]<<((ifindex-1)%8))&0x80 )
        {
            if (swctl_private_vlan_port_info[ifindex-1].is_pvlan_trunk_index_port == TRUE)
            {
                downlink_port_list[SWCTRL_BYTE_IN_BITMAP(ifindex)] &= ~(SWCTRL_BIT_IN_BITMAP(ifindex));
            }
        }
    }
#endif

    SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_SUCCESS )
} /* end of SWCTRL_GetRunningPrivateVlanUplinkPortList () */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetNextSessionFromPrivateVlanPortList
 * -------------------------------------------------------------------------
 * FUNCTION: This function will get private vlan for next session Id
 * INPUT   : session_id -- pvlan group id
 * OUTPUT  : session_id -- return achieved session id
 *           uplink_port_list   -- uplink port list
 *           downlink_port_list -- downlink port list
 * RETURN  : True: Successfully, FALSE: Failed
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_GetNextSessionFromPrivateVlanPortList(
              UI32_T *session_id,
              UI8_T  uplink_port_list[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST],
              UI8_T  downlink_port_list[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST])
{
    UI32_T sId = 0, ifindex = 0;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    /* get a null pointer */
    if (session_id == 0 || uplink_port_list == 0 || downlink_port_list == 0)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    /* session id illegal */
    if (*session_id > SYS_ADPT_PORT_TRAFFIC_SEGMENTATION_MAX_NBR_OF_SESSIONS )
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    sId = *session_id;

    /* get next available session id */
    for (++sId; sId<=SYS_ADPT_PORT_TRAFFIC_SEGMENTATION_MAX_NBR_OF_SESSIONS ; sId++)
    {
        if (swctl_private_vlan_ext_info[sId-1].is_valid == TRUE)
        {
            memset(uplink_port_list, 0, SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST);
            memset(downlink_port_list, 0, SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST);
            memcpy(uplink_port_list, swctl_private_vlan_ext_info[sId-1].private_vlan_uplink_port_list, SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST);
            memcpy(downlink_port_list, swctl_private_vlan_ext_info[sId-1].private_vlan_downlink_port_list, SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST);

            /* when trunk port is pvlan, which member of trunk port shall be invisible*/
            for (ifindex=1; ifindex<=SYS_ADPT_TOTAL_NBR_OF_LPORT; ifindex++)
            {
                if((uplink_port_list[(ifindex-1)/8]<<((ifindex-1)%8))&0x80 )
                {
                    if (swctl_private_vlan_port_info[ifindex-1].is_pvlan_trunk_index_port == TRUE)
                    {
                        uplink_port_list[SWCTRL_BYTE_IN_BITMAP(ifindex)] &= ~(SWCTRL_BIT_IN_BITMAP(ifindex));
                    }
                }
                else if((downlink_port_list[(ifindex-1)/8]<<((ifindex-1)%8))&0x80 )
                {
                    if (swctl_private_vlan_port_info[ifindex-1].is_pvlan_trunk_index_port == TRUE)
                    {
                        downlink_port_list[SWCTRL_BYTE_IN_BITMAP(ifindex)] &= ~(SWCTRL_BIT_IN_BITMAP(ifindex));
                    }
                }
            }/* End of for loop */

            *session_id = sId; /* return current session_id */
            SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
        }/* end of if (swctl_private_vlan_ext_info[sId-1].is_valid == TRUE) */
    }/* End of for loop*/

    SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );

}/* End of SWCTRL_GetNextSessionFromPrivateVlanPortList()*/

#endif /* End of #if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE == SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE_MULTIPLE_SESSION)*/
#endif /* End of #if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION == TRUE) */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetTrunkPorts
 * -------------------------------------------------------------------------
 * FUNCTION: This function will set trunk port list to SWDRV.
 *           Because SWDRV need sorted link up member port list and link up member
 *           port count, this API will set SWDRV after filtering link up port and
 *           sorting them.
 * INPUT   : trunk_id: Trunk ID to set.
 *           port_count: Number of trunk member, no matter link up or link down.
 *           port_member: Un-sorted trunk member port list.
 * OUTPU   : None.
 * RETURN  : True: Successfully, FALSE: Failed
 * NOTE    : Case to use this API:
 *           1) UIs or LACP set trunk.
 *           2) Member port link up.
 *           3) Member port link down.
 * -------------------------------------------------------------------------*/
static BOOL_T SWCTRL_SetTrunkPorts(UI32_T trunk_id, UI32_T port_count, SYS_TYPE_Uport_T *port_member)
{
#define PORT_1_IS_SMALLER_THAN_PORT_2(USER_PORT_1, USER_PORT_2) \
  ((USER_PORT_1.unit < USER_PORT_2.unit) ? TRUE  :              \
    ((USER_PORT_1.unit > USER_PORT_2.unit) ? FALSE :            \
     ((USER_PORT_1.port < USER_PORT_2.port) ? TRUE : FALSE)))

    UI32_T           link_up_member_number;
    SYS_TYPE_Uport_T link_up_member_port_list[SYS_ADPT_MAX_NBR_OF_PORT_PER_TRUNK];
    SYS_TYPE_Uport_T link_up_sorted_member_port_list[SYS_ADPT_MAX_NBR_OF_PORT_PER_TRUNK];
    SYS_TYPE_Uport_T inactive_member_port_list[SYS_ADPT_MAX_NBR_OF_PORT_PER_TRUNK];
    SYS_TYPE_Uport_T *active_member_port_list;
    UI32_T           active_member_number;
    UI32_T           inactive_member_number;
    UI32_T           i;
    UI32_T           j;
    UI32_T           k;
    UI32_T           ifindex;
    UI32_T           will_insert_to;
    UI32_T           speed_duplex_status_max;

    link_up_member_number = 0;
    inactive_member_number = 0;
    memset(link_up_member_port_list, 0, sizeof(link_up_member_port_list));
    memset(link_up_sorted_member_port_list, 0, sizeof(link_up_sorted_member_port_list));
    memset(inactive_member_port_list, 0, sizeof(inactive_member_port_list));

    speed_duplex_status_max = SWCTRL_GetMaxSpeedDuplexFromActiveTrunkMember(trunk_id);

    /* get link up ports and link port number
     */
    for (i = 0; i < port_count; i++)
    {
        ifindex = SWCTRL_UPORT_TO_IFINDEX(port_member[i].unit, port_member[i].port);

        /* this user port is:
         * 1) link up, and
         * 2) loopback test passed
         */
        if (SWCTRL_IS_LINK_UP(ifindex) &&
            SWCTRL_IS_ADMIN_ACTIVE_TRUNK_MEMBER(trunk_id, ifindex) &&
            (VAL_portSpeedDpxCfg_reserved != port_info[ifindex - 1].port_entry.port_speed_dpx_status &&
            speed_duplex_status_max == port_info[ifindex - 1].port_entry.port_speed_dpx_status)
#if (SYS_CPNT_3COM_LOOPBACK_TEST == TRUE)
            &&
            user_ext_port_info[ifindex-1].is_loopback_test_failed == FALSE
#endif
                                                                                     )
        {
            link_up_member_port_list[link_up_member_number] = port_member[i];
            link_up_member_number ++;
        }
        else
        {
            inactive_member_port_list[inactive_member_number] = port_member[i];
            inactive_member_number ++;
        }
    }

    /* init entry
     */
    if (link_up_member_number >= 1)
    {
        link_up_sorted_member_port_list[0] = link_up_member_port_list[0];
    }

    /* begin to sort
     */
    /*
     * i: index in unsorted list
     * j: index in sorted list
     */
    for (i = 1; i < link_up_member_number; i ++)
    {
        will_insert_to = 0xffffffff;

        if (i == 1)
        {
            /* only compare with entry 0 in sorted list is necessary
             */
            if (PORT_1_IS_SMALLER_THAN_PORT_2(link_up_member_port_list[i], link_up_sorted_member_port_list[0]))
            {
                /* insert entry
                 */
                will_insert_to = 0;
            }
        }
        else
        {
            for(j=0 ; j<i-1; j++)
            {
                if (j == 0)
                {
                    if (PORT_1_IS_SMALLER_THAN_PORT_2( link_up_member_port_list[i], link_up_sorted_member_port_list[0] ))
                    {
                        will_insert_to = 0;
                        break;
                    }
                }

                if(!PORT_1_IS_SMALLER_THAN_PORT_2( link_up_member_port_list[i], link_up_sorted_member_port_list[j]   ) &&
                    PORT_1_IS_SMALLER_THAN_PORT_2( link_up_member_port_list[i], link_up_sorted_member_port_list[j+1] ) )
                {
                    /* insert entry
                     */
                    will_insert_to = j+1;
                    break;
                }
            }
        }

        if (will_insert_to == 0xffffffff)
        {
            /* put entry at the tail
             */
            link_up_sorted_member_port_list[i] = link_up_member_port_list[i];
        }
        else
        {
            /* insert entry
             */
            /* shift first
             */
            for(k=i-1; k>=will_insert_to; k--)
            {
                link_up_sorted_member_port_list[k+1] = link_up_sorted_member_port_list[k];

                if( k == 0)
                    break;
            }

            /* fill
             */
            link_up_sorted_member_port_list[will_insert_to] = link_up_member_port_list[i];
        }
    }

    active_member_number = link_up_member_number;
    active_member_port_list = link_up_sorted_member_port_list;

    /* adjust active/inactive member by max_num_of_active_ports
     */
    if (active_member_number > trunk_ext_port_info[trunk_id-1].max_num_of_active_ports)
    {
        active_member_number = trunk_ext_port_info[trunk_id-1].max_num_of_active_ports;
    }

    for (i = active_member_number; i < link_up_member_number; i++)
    {
        inactive_member_port_list[inactive_member_number] = link_up_sorted_member_port_list[i];
        inactive_member_number ++;
    }

    if (FALSE == SWDRV_SetTrunkPorts(trunk_id, active_member_number, active_member_port_list))
    {
        /* error message handle in SWDRV_SetTrunkPorts()
         */
        return FALSE;
    }

    /* calculate bandwidth
     */
    {
        UI32_T port_speed_dpx_status;
        UI32_T bandwitdh = 0;

        for (i = 0; i < active_member_number; i++)
        {
            ifindex = SWCTRL_UPORT_TO_IFINDEX(active_member_port_list[i].unit, active_member_port_list[i].port);

            port_speed_dpx_status =
                port_info[ifindex-1].port_entry.port_speed_dpx_status;

            bandwitdh += SWCTRL_PORT_BANDWIDTH(port_speed_dpx_status);
        }

        port_info[SWCTRL_TRUNKID_TO_IFINDEX(trunk_id)-1].bandwidth = bandwitdh;
    }

    /* set trunk member ports to active/inactive.
     */
    {
        UI16_T unit, port;

        for (i = 0; i < inactive_member_number; i++)
        {
            unit = inactive_member_port_list[i].unit;
            port = inactive_member_port_list[i].port;
            ifindex = SWCTRL_UPORT_TO_IFINDEX(unit, port);

            if (SWCTRL_IS_OPER_ACTIVE_TRUNK_MEMBER(trunk_id, ifindex))
            {
                if (SWCTRL_SetPortToActiveTrunkMember(unit, port, FALSE))
                {
                    SWCTRL_SET_TRUNK_MEMBER_OPER_ACTIVE(trunk_id, ifindex, FALSE);

                    SWCTRL_Notify_TrunkMemberInactive(SWCTRL_TRUNKID_TO_IFINDEX(trunk_id), ifindex);
                }
            }
        }

        for (i = 0; i < active_member_number; i++)
        {
            unit = active_member_port_list[i].unit;
            port = active_member_port_list[i].port;
            ifindex = SWCTRL_UPORT_TO_IFINDEX(unit, port);

            if (!SWCTRL_IS_OPER_ACTIVE_TRUNK_MEMBER(trunk_id, ifindex))
            {
                if (SWCTRL_SetPortToActiveTrunkMember(unit, port, TRUE))
                {
                    SWCTRL_SET_TRUNK_MEMBER_OPER_ACTIVE(trunk_id, ifindex, TRUE);

                    SWCTRL_Notify_TrunkMemberActive(SWCTRL_TRUNKID_TO_IFINDEX(trunk_id), ifindex);
                }
            }
        }
    }

    return TRUE;
} /* SWCTRL_SetTrunkPorts() */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetPortToActiveTrunkMember
 * -------------------------------------------------------------------------
 * FUNCTION: This function will set trunk member port to active or inactive.
 * INPUT   : unit
 *           port
 *           is_active_trunk_member
 * OUTPUT  : None.
 * RETURN  : True: Successfully, FALSE: Failed
 * NOTE    : None.
 * -------------------------------------------------------------------------*/
static BOOL_T SWCTRL_SetPortToActiveTrunkMember(UI32_T unit, UI32_T port, BOOL_T is_active_trunk_member)
{
    UI32_T trunk_id, trunk_ifindex;
    UI32_T ifindex;
    BOOL_T ret = TRUE;

    ifindex = SWCTRL_UPORT_TO_IFINDEX(unit, port);
    trunk_id = port_info[ifindex-1].port_entry.port_trunk_index;
    trunk_ifindex = SWCTRL_TRUNKID_TO_IFINDEX (trunk_id);

    /* Trunk failover by software
     *
     * for trunk member port becames active,
     * to recover the STA state of trunk member due to the state
     * is set to BLOCKING when the port is link down. (see ProcessPortLinkDown)
     *
     * for trunk member port becames inactive,
     * It is essential to set the STA state of trunk member to
     * BLOCKING when the trunk still keep link up after the trunk member is linked down.
     * Ortherwise, the LOOPING will occur if the STA state of trunk member is FORWADING and
     * link it up to the linked up trunk (in the period of H/W setting).
     */
    {
        UI32_T xstid = 0;
        UI32_T mstidx = 0;
        UI32_T sta_state;
        BOOL_T tmp_ret = TRUE;

        while (XSTP_OM_GetNextExistingMstidByLport(trunk_ifindex, &xstid))  /*not include instance 0*/
        {
            tmp_ret = TRUE;

            if (is_active_trunk_member)
            {
                if (!(tmp_ret = XSTP_OM_GetPortStateByInstance(xstid, trunk_ifindex, &sta_state)))
                {
                    SYSFUN_LogMsg("Trunk failover (U): failed to get state.\n\r", 0, 0, 0, 0, 0, 0);
                }
            }
            else
            {
                sta_state = VAL_dot1dStpPortState_blocking;
            }

            if (tmp_ret)
            {
                if (!(tmp_ret = XSTP_OM_GetMstInstanceIndexByMstid(xstid, &mstidx)))
                {
                    SYSFUN_LogMsg("Trunk failover (U): failed to get mstidx.\n\r", 0, 0, 0, 0, 0, 0);
                }
            }

            if (tmp_ret)
            {
                if (!(tmp_ret = SWDRV_SetPortStateWithMstidx( mstidx, unit, port, sta_state)))
                {
                    SYSFUN_LogMsg("Trunk failover (U): failed to set state.\n\r", 0, 0, 0, 0, 0, 0);
                }
            }

            ret &= tmp_ret;
        }

        /* recover the trunk member's STA state on instance 0*/
        {
            xstid = 0;
            mstidx = 0;

            tmp_ret = TRUE;

            if (is_active_trunk_member)
            {
                if (!(tmp_ret = XSTP_OM_GetPortStateByInstance(xstid, trunk_ifindex, &sta_state)))
                {
                    SYSFUN_LogMsg("Trunk failover (U): failed to get state.\n\r", 0, 0, 0, 0, 0, 0);
                }
            }
            else
            {
                sta_state = VAL_dot1dStpPortState_blocking;
            }

            if (tmp_ret)
            {
                if (!(tmp_ret = XSTP_OM_GetMstInstanceIndexByMstid(xstid, &mstidx)))
                {
                    SYSFUN_LogMsg("Trunk failover (U): failed to get mstidx.\n\r", 0, 0, 0, 0, 0, 0);
                }
            }

            if (tmp_ret)
            {
                if (!(tmp_ret = SWDRV_SetPortStateWithMstidx( mstidx, unit, port, sta_state)))
                {
                    SYSFUN_LogMsg("Trunk failover (U): failed to set state.\n\r", 0, 0, 0, 0, 0, 0);
                }
            }

            ret &= tmp_ret;
        }
    }

    return ret;
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetMaxSpeedDuplexFromActiveTrunkMember
 * -------------------------------------------------------------------------
 * FUNCTION: Scan all trunk member and find the highest member
 *           with highest speed member
 * INPUT   : trunk_id       -- trunk id
 * OUTPUT  : None
 * RETURN  : Max Active Trunk member speed duplex
 *           One of the following value
 *           VAL_portSpeedDpxCfg_reserved
 *           VAL_portSpeedDpxCfg_fullDuplex10
 *           VAL_portSpeedDpxCfg_fullDuplex100
 *           VAL_portSpeedDpxCfg_fullDuplex1000
 *           VAL_portSpeedDpxCfg_fullDuplex10g
 *           VAL_portSpeedDpxCfg_fullDuplex40g
 * NOTE    : None
 * -------------------------------------------------------------------------*/
static UI32_T SWCTRL_GetMaxSpeedDuplexFromActiveTrunkMember(UI32_T trunk_id)
{
    SWCTRL_TrunkPortExtInfo_T trunk_port_ext_info = trunk_ext_port_info[trunk_id - 1];
    UI32_T speed_duplex_status_max = VAL_portSpeedDpxCfg_reserved;
    UI16_T trk_member_idx;

    for (trk_member_idx = 0; trk_member_idx < trunk_port_ext_info.member_number; trk_member_idx ++)
    {
        UI32_T unit, port;
        UI32_T trk_member_ifindex;
        UI32_T speed_duplex_status;

        unit = (UI32_T)trunk_port_ext_info.member_list[trk_member_idx].unit;
        port = (UI32_T)trunk_port_ext_info.member_list[trk_member_idx].port;
        trk_member_ifindex = SWCTRL_UPORT_TO_IFINDEX(unit, port);

        if (!SWCTRL_IS_LINK_UP(trk_member_ifindex))
        {
            continue;
        }

        speed_duplex_status = port_info[trk_member_ifindex - 1].port_entry.port_speed_dpx_status;

        if (VAL_portSpeedDpxCfg_reserved == speed_duplex_status ||
            VAL_portSpeedDpxCfg_halfDuplex10 == speed_duplex_status ||
            VAL_portSpeedDpxCfg_halfDuplex100 == speed_duplex_status ||
            VAL_portSpeedDpxCfg_halfDuplex1000 == speed_duplex_status ||
            VAL_portSpeedDpxCfg_halfDuplex10g == speed_duplex_status ||
            VAL_portSpeedDpxCfg_halfDuplex40g == speed_duplex_status)
        {
            continue;
        }

        if (speed_duplex_status > speed_duplex_status_max)
            speed_duplex_status_max = speed_duplex_status;
    }

    return speed_duplex_status_max;
}

/*------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_UIGetUnitPortNumber
 *------------------------------------------------------------------------
 * FUNCTION: This API is used to get the number of some unit that caller
 *           want to get and should only be used by  CLI.
 * INPUT   : unit --- which unit caller want to get.
 * OUTPUT  : None.
 * RETURN  : The port number of that unit.
 *           > 0 --- 1) Base on the unit MAC address table given by CLI
 *                      before provision complete.
 *                   2) Output normal ifindex after provision complete.
 *           0   --- Get fail.
 *                   1) Not in master mode.
 *                   2) Argument is invalid.
 *                   3) This unit is not present.
 * NOTE    : Return port number base on the table given by CLI before provision complete.
 *           Return port number normally after provision complete.
 *------------------------------------------------------------------------*/
UI32_T SWCTRL_UIGetUnitPortNumber(UI32_T unit)
{
    if(is_provision_complete == FALSE)
    {
        if (re_numbering_mapping_table[unit-1]   == 0     ||
            device_type_validation_table[unit-1] == FALSE )
        {
            return 0;
        }
        return SWCTRL_GetUnitPortNumber(re_numbering_mapping_table[unit-1]);
    }

    return SWCTRL_GetUnitPortNumber(unit);
}

/*------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_UIUserPortToLogicalPort
 *------------------------------------------------------------------------
 * FUNCTION: This API is used to get ifindex of some unit and some port that
 *           caller want to get and should only be used by  CLI.
 * INPUT   : unit --- which unit caller want to get.
 *           port --- which port caller want to get.
 * OUTPUT  : ifindex --- 1) Base on the unit MAC address table given by CLI
 *                          before provision complete.
 *                       2) Output normal ifindex after provision complete.
 * RETURN  : SWCTRL_LPORT_UNKNOWN_PORT      --- 1) Not in master mode.
 *                                              2) Argument is invalid.
 *                                              3) This port is not present.
 *           SWCTRL_LPORT_NORMAL_PORT       --- This is a normal port.
 *           SWCTRL_LPORT_TRUNK_PORT_MEMBER --- This port is a member of a trunk.
 * NOTE    : Process "unit" base on the table given by CLI before provision complete.
 *           Process "unit" normally after provision complete.
 *------------------------------------------------------------------------*/
SWCTRL_Lport_Type_T SWCTRL_UIUserPortToLogicalPort(UI32_T unit, UI32_T port, UI32_T *ifindex)
{
    if(is_provision_complete == FALSE)
    {
        if (re_numbering_mapping_table[unit-1]   == 0     ||
            device_type_validation_table[unit-1] == FALSE )
        {
            return SWCTRL_LPORT_UNKNOWN_PORT;
        }
        return SWCTRL_UserPortToLogicalPort(re_numbering_mapping_table[unit-1], port, ifindex);
    }

    return SWCTRL_UserPortToLogicalPort(unit, port, ifindex);
}

/*------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_UIUserPortToIfindex
 *------------------------------------------------------------------------
 * FUNCTION: This API is used to get ifindex of some unit and some port that
 *           caller want to get and should only be used by  CLI.
 * INPUT   : unit --- which unit caller want to get.
 *           port --- which port caller want to get.
 * OUTPUT  : ifindex --- 1) Base on the unit MAC address table given by CLI
 *                          before provision complete.
 *                       2) Output normal ifindex after provision complete.
 *           is_inherit- 1) TRUE  UI should inherit this ifindex's config to provision
 *                       2) FALSE UI should not inherit this ifindex's config to provision
 * RETURN  : SWCTRL_LPORT_UNKNOWN_PORT      --- 1) Not in master mode.
 *                                              2) Argument is invalid.
 *                                              3) This port is not present.
 *           SWCTRL_LPORT_NORMAL_PORT       --- This is a normal port.
 *           SWCTRL_LPORT_TRUNK_PORT_MEMBER --- This port is a member of a trunk.
 * NOTE    : Output "ifindex" base on the table given by CLI before provision complete.
             Output "ifindex" normally after provision complete.
 *------------------------------------------------------------------------*/
SWCTRL_Lport_Type_T SWCTRL_UIUserPortToIfindex (UI32_T unit, UI32_T port, UI32_T *ifindex, BOOL_T *is_inherit)
{
    if(is_provision_complete == FALSE)
    {
        if (re_numbering_mapping_table[unit-1]   == 0     ||
            device_type_validation_table[unit-1] == FALSE )
        {
            *is_inherit = FALSE;
            return SWCTRL_LPORT_UNKNOWN_PORT;
        }
        else
        {
            *is_inherit = TRUE;
        return SWCTRL_UserPortToIfindex(re_numbering_mapping_table[unit-1], port, ifindex);
    }
    }
    *is_inherit = TRUE;
    return SWCTRL_UserPortToIfindex(unit, port, ifindex);
}

/*------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_UIUserPortToTrunkPort
 *------------------------------------------------------------------------
 * FUNCTION: This API is used to get trunk ID of some user port that
 *           and should only be used by  CLI.
 * INPUT   : unit --- which unit caller want to get.
 *           port --- which port caller want to get.
 * OUTPUT  : trunk_id ---
 * RETURN  : SWCTRL_LPORT_UNKNOWN_PORT      --- 1) Not in master mode.
 *                                              2) Argument is invalid.
 *                                              3) This port is not present.
 *           SWCTRL_LPORT_NORMAL_PORT       --- This is a normal port.
 *           SWCTRL_LPORT_TRUNK_PORT_MEMBER --- This port is a member of a trunk.
 * NOTE    : Process "unit" base on the table given by CLI before provision complete.
 *           Process "unit" normally after provision complete.
 *------------------------------------------------------------------------*/
SWCTRL_Lport_Type_T SWCTRL_UIUserPortToTrunkPort(UI32_T unit, UI32_T port, UI32_T *trunk_id)
{
    if(is_provision_complete == FALSE)
    {
        if (re_numbering_mapping_table[unit-1]   == 0     ||
            device_type_validation_table[unit-1] == FALSE )
        {
            return SWCTRL_LPORT_UNKNOWN_PORT;
        }
        return SWCTRL_UserPortToTrunkPort(re_numbering_mapping_table[unit-1], port, trunk_id);
    }

    return SWCTRL_UserPortToTrunkPort(unit, port, trunk_id);
}

/*------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_UIUserPortExisting
 *------------------------------------------------------------------------
 * FUNCTION: This API is used to check if a user port exists or not, and
 *           should only be called by CLI.
 * INPUT   : unit --- which unit caller want to get.
 *           port --- which port caller want to get.
 * OUTPUT  : None.
 * RETURN  : TRUE  --- This user port exist.
 *           FALSE --- This user port does not exist.
 * NOTE    : Return TRUE/FALSE base on the table given by CLI before provision complete.
 *           Return TRUE/FALSE normally after provision complete.
 *------------------------------------------------------------------------*/
BOOL_T SWCTRL_UIUserPortExisting (UI32_T unit, UI32_T port)
{
    if(is_provision_complete == FALSE)
    {
        if (re_numbering_mapping_table[unit-1]   == 0     ||
            device_type_validation_table[unit-1] == FALSE )
        {
            return FALSE;
        }
        return SWCTRL_UserPortExisting(re_numbering_mapping_table[unit-1], port);
    }

    return SWCTRL_UserPortExisting(unit, port);
}


/*------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetUnitsBaseMacAddrTable
 *------------------------------------------------------------------------
 * FUNCTION: This API is used to set the table of MAC address of each unit
 *           in CLI configuration file. This API should only be called by
 *           CLI and should be called before any command rovision.
 * INPUT   : mac_addr --- MAC addresses of all unit.
 *                        If some unit is not present the MAC address should
 *                        be 00-00-00-00-00-00.
 * OUTPUT  : None.
 * RETURN  : TRUE  --- Set table successfully.
 *           FALSE --- Set table fail.
 *                     1) Not in MASETR mode.
 *                     2) Provision has been already completed.
 * NOTE    : None.
 *------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetUnitsBaseMacAddrTable(UI8_T mac_addr[SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK][6])
{
    UI32_T unit;
    UI32_T unit_in_tplg;
    UI8_T  tplg_unit_mac_addr[SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK][6];
    BOOL_T default_config_current_unit[SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK];

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if( is_provision_complete == TRUE)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
    }

    for(unit = 0; unit<SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK; unit++)
    {
        if(STKTPLG_POM_GetUnitBaseMac(unit+1, tplg_unit_mac_addr[unit]) == FALSE)
        {
            memset(tplg_unit_mac_addr[unit], 0, sizeof(UI8_T)*6);
        }

        default_config_current_unit[unit] = TRUE;
    }

    /* searching for mapping
     */
    for(unit = 0; unit<SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK; unit++)
    {
        BOOL_T is_ui_unit_in_current_stack;

        if( mac_addr[unit][0] == 0 && mac_addr[unit][1] == 0 && mac_addr[unit][2] == 0 &&
            mac_addr[unit][3] == 0 && mac_addr[unit][4] == 0 && mac_addr[unit][5] == 0 )
        {
            /* no such unit in CLI config file
             */
            re_numbering_mapping_table[unit] = 0;
            continue;
        }

        is_ui_unit_in_current_stack = FALSE;
        for(unit_in_tplg = 0; unit_in_tplg<SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK; unit_in_tplg++)
        {
            if(memcmp(mac_addr[unit], tplg_unit_mac_addr[unit_in_tplg], sizeof(UI8_T)*6) == 0)
            {
                /* the unit in CLI config file is an unit in current stack
                 */
                re_numbering_mapping_table[unit] = unit_in_tplg+1;

                default_config_current_unit[unit_in_tplg] = FALSE;

                is_ui_unit_in_current_stack = TRUE;
                break;
            }
        }

        if(is_ui_unit_in_current_stack == FALSE)
        {
            /* the unit in CLI config file doesn't exist in current stack
             */
            re_numbering_mapping_table[unit] = 0;
        }
    }

    /* The following section was SYS_CPNT_UNIT_CONFIGURATION_AUTO_INHERIT.
     * But our spec requires it to be always TRUE.
     * So this SYS_CPNT in not needed any more.
     * Zhong Qiyao, 2004.07.09
     *
     * If this constant is TRUE.
     * If there is a new unit in the stack and the MAC addrss is not specified in the
     * configuration file, then this new unit will follow the configuration in the
     * configurationfile. But old unit, i.e. the MAC address of this old unit is specified
     * in the configuration file, will follow original setting.
     *
     * If this constant is FALSE.
     * If there is a new unit in the stack and the MAC addrss is not specified in the
     * configuration file, then this new unit will follow factory default setting. But
     * old unit, i.e. the MAC address of this old unit is specified in the configuration
     * file, will follow original setting.
     *
     * For EPR: Mercury_V2-01900.
     */
    for(unit = 0; unit<SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK; unit++)
    {
        UI32_T unit_config_file;

        if( tplg_unit_mac_addr[unit][0] == 0 && tplg_unit_mac_addr[unit][1] == 0 && tplg_unit_mac_addr[unit][2] == 0 &&
            tplg_unit_mac_addr[unit][3] == 0 && tplg_unit_mac_addr[unit][4] == 0 && tplg_unit_mac_addr[unit][5] == 0 )
        {
            /* no such unit in current stack
             */
            continue;
        }

        for(unit_config_file = 0; unit_config_file<SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK; unit_config_file++)
        {
            /* if a unit in CLI config file is not in current stack, and
             * a unit in current stack will use default setting.
             * Need to do association to make this unit in current stack to follow
             * the first non-used setting in the configuration file.
             */
            if ((0    == re_numbering_mapping_table[unit_config_file]) &&
                (TRUE == default_config_current_unit[unit])       )
            {
                re_numbering_mapping_table[unit_config_file] = unit+1;
                default_config_current_unit[unit] = FALSE;
            }
        }
    }
    /* end of original SYS_CPNT_UNIT_CONFIGURATION_AUTO_INHERIT.
     */

#if 0
    {
        UI32_T i;

        printf("\r\n");
        printf("================================\r\n");
        printf("|      Re-Numbering Table      |\r\n");
        printf("--------------------------------\r\n");
        printf("|   CLI               STKTPLG  |\r\n");
        printf("================================\r\n");

        for(i=0; i<SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK; i++)
        {
            if(re_numbering_mapping_table[i] != 0 )
                printf("|    %lu  -------------->  %lu     |\r\n", i+1, re_numbering_mapping_table[i]);
            else
                printf("|    %lu  -------------->  %s     |\r\n", i+1, "X");
        }
        printf("================================\r\n");
    }
#endif

    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
}


/*------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetUnitsBaseMacAddrTable
 *------------------------------------------------------------------------
 * FUNCTION: This API is used to set the table of device type of each unit
 *           in CLI configuration file. This API should only be called by
 *           CLI and should be called before any command rovision.
 * INPUT   : device_type --- Device Types of all unit.
 *                        If some unit is not present the device type should
 *                        be 0xffffffff.
 * OUTPUT  : None.
 * RETURN  : TRUE  --- Set table successfully.
 *           FALSE --- Set table fail.
 *                     1) Not in MASETR mode.
 *                     2) Provision has been already completed.
 * NOTE    : CLI shall call this API after call SWCTRL_SetUnitsBaseMacAddrTable()
 *------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetUnitsDeviceTypeTable(UI32_T device_type[SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK])
{
    UI32_T unit;
    UI32_T tplg_unit_device_type;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if( is_provision_complete == TRUE)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
    }

    /* searching for mapping
     */
    for(unit=0; unit<SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK; unit++)
    {
        if (0xffffffff == device_type[unit])
        {
            /* if CLI doesn't specify, then invalid.
             */
            device_type_validation_table[unit] = FALSE;
            continue;
        }

        if (0 == re_numbering_mapping_table[unit])
        {
            /* if re-numbering table doesn't think this is valid, then invalid
             */
            device_type_validation_table[unit] = FALSE;
            continue;
        }

        if(STKTPLG_POM_GetUnitBoardID(re_numbering_mapping_table[unit], &tplg_unit_device_type) == FALSE)
        {
            /* failed to get device type, then invalid
             */
            device_type_validation_table[unit] = FALSE;
            continue;
        }

        if (tplg_unit_device_type != device_type[unit])
        {
            /* device type not the same, then invalid
             */
            device_type_validation_table[unit] = FALSE;
            continue;
        }

        device_type_validation_table[unit] = TRUE;
    }

#if 0
    {
        UI32_T i;

        printf("\r\n");
        printf("================================\r\n");
        printf("|       Device Type Table      |\r\n");
        printf("--------------------------------\r\n");
        printf("|   CLI               STKTPLG  |\r\n");
        printf("================================\r\n");
        for(i=0; i<SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK; i++)
        {
            if (device_type_validation_table[i] == TRUE )
                printf("|    %lu  --------------> (O)    |\r\n", i+1);
            else
                printf("|    %lu  --------------> (X)    |\r\n", i+1);
        }
        printf("================================\r\n");
    }
#endif

    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
}

#if (SYS_CPNT_MAU_MIB == TRUE)
static BOOL_T SWCTRL_Is_Running_Mau (UI32_T ifindex,UI32_T media_type)
{
    UI32_T port_type;
    BOOL_T is_running_mau = FALSE;

    port_type = port_info[ifindex-1].port_entry.port_type;
    //printf("CC DEBUG %s-%d,%d,mt %d,pt %d.\n",__FUNCTION__,__LINE__,ifindex,media_type,port_type);
    if (( media_type == STKTPLG_TYPE_MEDIA_TYPE_THOUSAND_BASE_T) &&
        (port_type == VAL_portType_thousandBaseT ||
        port_type == VAL_portType_hundredBaseTX))
    {
        /*Front Port*/
        is_running_mau = TRUE;
    }
    else if(( media_type == STKTPLG_TYPE_MEDIA_TYPE_HUNDRED_BASE_TX) &&
        (port_type == VAL_portType_hundredBaseTX))
    {
        is_running_mau = TRUE;
    }
    else if ( (media_type == STKTPLG_TYPE_MEDIA_TYPE_THOUSAND_BASE_SX ||
              media_type == STKTPLG_TYPE_MEDIA_TYPE_THOUSAND_BASE_LX ||
              media_type == STKTPLG_TYPE_MEDIA_TYPE_THOUSAND_BASE_CX ||
              media_type == STKTPLG_TYPE_MEDIA_TYPE_THOUSAND_BASE_X )  &&
             (port_type == VAL_portType_thousandBaseGBIC ||
              port_type == VAL_portType_thousandBaseSfp  ))
    {
        /* Because if port type is SFP or GBIC, the media type is 1000SX or 1000LX,
         * and there is no case for the same ifindex have 1000SX and 1000LX on different
         * MAUs.
         * If some time, the MAU1 and MAU2 are 1000SX and 1000LX at the same time,
         * this mechanism should be fine tuned.
         */
        is_running_mau = TRUE;
    }
    else if(((media_type == STKTPLG_TYPE_MEDIA_TYPE_10G_BASE_LR)||
             (media_type == STKTPLG_TYPE_MEDIA_TYPE_10G_BASE_ER)||
             (media_type == STKTPLG_TYPE_MEDIA_TYPE_10G_BASE_CX4)||
             (media_type == STKTPLG_TYPE_MEDIA_TYPE_10G_BASE_X))&&
            ((port_type == VAL_portType_tenG) ||
             (port_type == VAL_portType_tenGBaseT)))
    {
        is_running_mau = TRUE;
    }
    else
    {
        is_running_mau = FALSE;
    }
    //printf("CC DEBUG %s-%d,run mau?%d.\n",__FUNCTION__,__LINE__,is_running_mau);
    return is_running_mau;
}

static BOOL_T SWCTRL_GetMauMediaType(UI32_T unit, UI32_T port, UI32_T if_mau_index, UI32_T *media_type)
{
    /* Becasue change of SFP preset and EEPROM monitor mechanism,
     * STKTPLG_OM_GetMauMediaType is not work for sfp port now.
     * This function is used as substitution of partial function of
     * STKTPLG_OM_GetMauMediaType temporarily.
     */

    if (!STKTPLG_POM_GetMauMediaType(unit, port, if_mau_index, media_type))
    {
        return FALSE;
    }

#if (SYS_CPNT_SWDRV_MONITOR_SFP_DDM == TRUE)
    if ((*media_type == STKTPLG_TYPE_MEDIA_TYPE_HUNDRED_BASE_FX) ||
        (*media_type == STKTPLG_TYPE_MEDIA_TYPE_HUNDRED_BASE_BX) ||
        (*media_type == STKTPLG_TYPE_MEDIA_TYPE_THOUSAND_BASE_SX) ||
        (*media_type == STKTPLG_TYPE_MEDIA_TYPE_THOUSAND_BASE_LX) ||
        (*media_type == STKTPLG_TYPE_MEDIA_TYPE_THOUSAND_BASE_CX) ||
        (*media_type == STKTPLG_TYPE_MEDIA_TYPE_THOUSAND_BASE_X) ||
        (*media_type == STKTPLG_TYPE_MEDIA_TYPE_HUNDRED_BASE_FX_SC_SINGLE_MODE) ||
        (*media_type == STKTPLG_TYPE_MEDIA_TYPE_HUNDRED_BASE_FX_SC_MULTI_MODE))
    {
        UI32_T sfp_index;
        SWCTRL_OM_SfpInfo_T sfp_info;

        if (!STKTPLG_POM_UserPortToSfpIndex(unit, port, &sfp_index))
        {
            return FALSE;
        }

        if (SWCTRL_OM_GetPortSfpPresent(unit, sfp_index))
        {
            SWCTRL_OM_GetPortSfpInfo(unit, sfp_index, &sfp_info);

            /* According to SFP MSA, Data Addr 3-8 traceiver code,
             * byte 6 (ie,transceiver[3]) is compliance codes
             */
            if ((sfp_info.transceiver[3] & GIGABIT_CODES_VLAUE_1000BASE_SX) ||
                (sfp_info.transceiver[3] & GIGABIT_CODES_VLAUE_1000BASE_LX) ||
                (sfp_info.transceiver[3] & GIGABIT_CODES_VLAUE_1000BASE_CX))
            {
                *media_type = STKTPLG_TYPE_MEDIA_TYPE_THOUSAND_BASE_X;
            }
            else
            if ((sfp_info.transceiver[3] & GIGABIT_CODES_VLAUE_1000BASE_T))
            {
                *media_type = STKTPLG_TYPE_MEDIA_TYPE_THOUSAND_BASE_T;
            }
            else
            if ((sfp_info.transceiver[3] & BIT_VALUE(5)))
            {
                *media_type = STKTPLG_TYPE_MEDIA_TYPE_HUNDRED_BASE_FX;
            }
            else
            {
                *media_type = STKTPLG_TYPE_MEDIA_TYPE_OTHER;
            }
        }
    }
#endif /* (SYS_CPNT_SWDRV_MONITOR_SFP_DDM == TRUE) */

    return TRUE;
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetIfMauStatus
 * -------------------------------------------------------------------------
 * FUNCTION: Set MAU status.
 * INPUT   : if_mau_ifindex  -- Which interface.
 *           if_mau_index    -- Which MAU.
 *           status          -- VAL_ifMauStatus_other
 *                              VAL_ifMauStatus_unknown
 *                              VAL_ifMauStatus_operational
 *                              VAL_ifMauStatus_standby
 *                              VAL_ifMauStatus_shutdown
 *                              VAL_ifMauStatus_reset
 * OUTPUT  : None.
 * RETURN  : TRUE/FALSE
 * NOTE    : 1) Base on RFC-3636 (snmpDot3MauMgt)
 *           2) For User port only.
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetIfMauStatus (UI32_T if_mau_ifindex,
                              UI32_T if_mau_index,
                              UI32_T status)
{
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    /* Currently, MAU MIB only support "read",
     * i.e. if the access is "read/write", we support APIs for SNMP to call to "write",
     * but always return FALSE.
     * In this way, if we support "write" in the future, SNMP doesn't need to modify the
     * code, and the effort will only in SWCTRL, SWDRV, and DEV_SWDRV.
     */
    SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetIfMauDefaultType
 * -------------------------------------------------------------------------
 * FUNCTION: Set the default MAU type.
 * INPUT   : if_mau_ifindex  -- Which interface.
 *           if_mau_index    -- Which MAU.
 *           default_type    -- Caller should use naming constant in SWCTRL_IF_MAU_TYPE_E.
 * OUTPUT  : None.
 * RETURN  : TRUE/FALSE
 * NOTE    : 1) Base on RFC-3636 (snmpDot3MauMgt)
 *           2) For User port only.
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetIfMauDefaultType (UI32_T if_mau_ifindex,
                                   UI32_T if_mau_index,
                                   UI32_T default_type)
{
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    /* Currently, MAU MIB only support "read",
     * i.e. if the access is "read/write", we support APIs for SNMP to call to "write",
     * but always return FALSE.
     * In this way, if we support "write" in the future, SNMP doesn't need to modify the
     * code, and the effort will only in SWCTRL, SWDRV, and DEV_SWDRV.
     */
    SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
}


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetIfMauEntry
 * -------------------------------------------------------------------------
 * FUNCTION: Get MAU entry specified in RFC-3636.
 * INPUT   : if_mau_entry->ifMauIfIndex  -- Which interface.
 *           if_mau_entry->ifMauIndex    -- Which MAU.
 * OUTPUT  : if_mau_entry.
 * RETURN  : TRUE/FALSE
 * NOTE    : 1) Base on RFC-3636 (snmpDot3MauMgt)
 *           2) For User port only.
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_GetIfMauEntry (SWCTRL_IfMauEntry_T *if_mau_entry)
{
    BOOL_T is_running_mau = FALSE;
    UI32_T media_type;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    /* Argument validation
     */
    if (NULL == if_mau_entry)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
    }

    /* Only for user port: ifMauIfIndex (key 1)
     */
    if (FALSE == SWCTRL_IS_USER_PORT(if_mau_entry->ifMauIfIndex))
    {
        SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
    }

    /* Present port is necessary: ifMauIfIndex (key 1)
     */
    if (FALSE == SWCTRL_IS_EXIST(if_mau_entry->ifMauIfIndex))
    {
        SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
    }

    /* MAU index range: ifMauIndex (key 2)
     */
    /* Checking this MAU is present or not is not SWCTRL knowledge,
     * checking max possible index is necessary.
     */
    if (if_mau_entry->ifMauIndex == 0 ||
        if_mau_entry->ifMauIndex > SYS_ADPT_MAX_NBR_OF_MAU_PER_USER_PORT)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
    }

    /* ifMauType = "media type" + "running speed-duplex"    */
    if (FALSE == SWCTRL_GetMauMediaType (SWCTRL_IFINDEX_TO_UNIT(if_mau_entry->ifMauIfIndex),
                                         SWCTRL_IFINDEX_TO_PORT(if_mau_entry->ifMauIfIndex),
                                         if_mau_entry->ifMauIndex,
                                         &media_type))
    {
        /* Shall be not present   */
        SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
    }
    is_running_mau = SWCTRL_Is_Running_Mau(if_mau_entry->ifMauIfIndex,media_type);

    if (TRUE == is_running_mau)
    {
        SWCTRL_GetActualIfMauEntry(media_type, if_mau_entry);
    }
    else
    {
        SWCTRL_GetDefaultIfMauEntry(media_type, if_mau_entry);
    }

    SWCTRL_RETURN_AND_RELEASE_CSC(TRUE);
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetActualIfMauEntry
 * -------------------------------------------------------------------------
 * FUNCTION: Get ifMauEntry base on actual facts.
 * INPUT   : media_type                  -- Media type.
 *           if_mau_entry->ifMauIfIndex  -- Which interface.
 *           if_mau_entry->ifMauIndex    -- Which MAU.
 * OUTPUT  : if_mau_entry.
 * RETURN  : TRUE/FALSE
 * NOTE    : None.
 * -------------------------------------------------------------------------*/
static BOOL_T SWCTRL_GetActualIfMauEntry  (UI32_T media_type, SWCTRL_IfMauEntry_T *if_mau_entry)
{
    UI32_T remote_fault;

    /* ifMauType =  "media type" + "running speed-duplex config"
     */
    SWCTRL_GetMauTypeByMediaTypeAndSpdDpx (media_type,
                                           port_info[if_mau_entry->ifMauIfIndex - 1].port_entry.port_speed_dpx_status,
                                           &(if_mau_entry->ifMauType));

    /* ifMauStatus: Only support (3: operational) (5: shutdown)
     */
     if (VAL_ifAdminStatus_down == port_info[if_mau_entry->ifMauIfIndex - 1].admin_status)
     {
        if_mau_entry->ifMauStatus = VAL_ifMauStatus_shutdown;
     }
     else
     {
        if_mau_entry->ifMauStatus = VAL_ifMauStatus_operational;
     }

    /* ifMauMediaAvailable
     */
    if (!SWCTRL_IS_LINK_UP(if_mau_entry->ifMauIfIndex))
    {
        if_mau_entry->ifMauMediaAvailable = VAL_ifMauMediaAvailable_notAvailable;
    }
    else
    {
        if (TRUE == SWDRV_GetPortLinkPartnerAutoNegoRemoteFault (SWCTRL_IFINDEX_TO_UNIT(if_mau_entry->ifMauIfIndex),
                                                                 SWCTRL_IFINDEX_TO_PORT(if_mau_entry->ifMauIfIndex),
                                                                 &remote_fault))
        {
            switch (remote_fault)
            {
            case VAL_ifMauAutoNegRemoteFaultReceived_offline:
                if_mau_entry->ifMauMediaAvailable = VAL_ifMauMediaAvailable_offline;
                break;

            case VAL_ifMauAutoNegRemoteFaultReceived_linkFailure:
                if_mau_entry->ifMauMediaAvailable = VAL_ifMauMediaAvailable_remoteFault;
                break;

            case VAL_ifMauAutoNegRemoteFaultReceived_autoNegError:
                if_mau_entry->ifMauMediaAvailable = VAL_ifMauMediaAvailable_autoNegError;
                break;

            case VAL_ifMauAutoNegRemoteFaultReceived_noError:
            default:
                if_mau_entry->ifMauMediaAvailable = VAL_ifMauMediaAvailable_available;
                break;
            }
        }
        else
        {
            if_mau_entry->ifMauMediaAvailable = VAL_ifMauMediaAvailable_unknown;
        }
    }

    /* ifMauMediaAvailableStateExits: Not support
     */
    if_mau_entry->ifMauMediaAvailableStateExits = 0;

    /* ifMauJabberState
     */
    if (FALSE == SWDRV_GetPortJabberState (SWCTRL_IFINDEX_TO_UNIT(if_mau_entry->ifMauIfIndex),
                                           SWCTRL_IFINDEX_TO_PORT(if_mau_entry->ifMauIfIndex),
                                           &(if_mau_entry->ifMauJabberState)) )
    {
        if_mau_entry->ifMauJabberState = VAL_ifMauJabberState_unknown;
    }


    /* ifMauJabberingStateEnters: Not support
     */
    if_mau_entry->ifMauJabberingStateEnters = 0;

    /* ifMauFalseCarriers
     */
    if (FALSE == SWDRV_GetPortFalseCarrierSenseCounter (SWCTRL_IFINDEX_TO_UNIT(if_mau_entry->ifMauIfIndex),
                                                        SWCTRL_IFINDEX_TO_PORT(if_mau_entry->ifMauIfIndex),
                                                        &(if_mau_entry->ifMauFalseCarriers)) )
    {
        if_mau_entry->ifMauFalseCarriers = 0;
    }

    /* ifMauTypeList: DEPRECATED
     */
    /*if_mau_entry->ifMauTypeList = 0;
     */

    /* ifMauDefaultType =  "media type" + "force mode speed-duplex config"
     */
    SWCTRL_GetMauTypeByMediaTypeAndSpdDpx (media_type,
                                           port_info[if_mau_entry->ifMauIfIndex - 1].port_entry.port_speed_dpx_cfg,
                                           &(if_mau_entry->ifMauDefaultType));

    /* ifMauAutoNegSupported
     */
    if (TRUE == SWCTRL_IS_100FIBER(if_mau_entry->ifMauIfIndex)||
        TRUE == SWCTRL_IS_10GFIBER(if_mau_entry->ifMauIfIndex)||
        TRUE == SWCTRL_IS_40GFIBER(if_mau_entry->ifMauIfIndex))
    {
        /* 100/10G/40G fiber doesn't support auto-nego
         */
        if_mau_entry->ifMauAutoNegSupported = VAL_ifMauAutoNegSupported_false;
    }
    else
    {
        if_mau_entry->ifMauAutoNegSupported = VAL_ifMauAutoNegSupported_true;
    }

    /* ifMauTypeListBits
     */
    SWCTRL_GetPossibleMauTypeListBitsByMediaType(media_type, if_mau_entry->ifMauTypeListBits);

    return TRUE;
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetDefaultIfMauEntry
 * -------------------------------------------------------------------------
 * FUNCTION: Get ifMauEntry base on default value.
 * INPUT   : media_type                  -- Media type.
 *           if_mau_entry->ifMauIfIndex  -- Which interface.
 *           if_mau_entry->ifMauIndex    -- Which MAU.
 * OUTPUT  : if_mau_entry.
 * RETURN  : TRUE/FALSE
 * NOTE    : For not running MAU.
 * -------------------------------------------------------------------------*/
static BOOL_T SWCTRL_GetDefaultIfMauEntry (UI32_T media_type, SWCTRL_IfMauEntry_T *if_mau_entry)
{
    UI32_T default_speed_duplex_status;
    UI32_T default_force_speed_duplex;

    /* ifMauType =  "media type" + "running speed-duplex config"
     * Default speed-duplex status follow SWCTRL_ConfigUserPortToDefaultState()
     */
    switch(media_type)
    {
    case STKTPLG_TYPE_MEDIA_TYPE_HUNDRED_BASE_TX:                /*100 copper*/
    case STKTPLG_TYPE_MEDIA_TYPE_HUNDRED_BASE_FX:                /*100 fiber*/
    case STKTPLG_TYPE_MEDIA_TYPE_HUNDRED_BASE_FX_SC_SINGLE_MODE:
    case STKTPLG_TYPE_MEDIA_TYPE_HUNDRED_BASE_FX_SC_MULTI_MODE:
        default_speed_duplex_status = VAL_portSpeedDpxCfg_fullDuplex100;
        break;

    case STKTPLG_TYPE_MEDIA_TYPE_THOUSAND_BASE_SX:                /*1000 fiber*/
    case STKTPLG_TYPE_MEDIA_TYPE_THOUSAND_BASE_LX:
    case STKTPLG_TYPE_MEDIA_TYPE_THOUSAND_BASE_CX:
    case STKTPLG_TYPE_MEDIA_TYPE_THOUSAND_BASE_X:
    case STKTPLG_TYPE_MEDIA_TYPE_THOUSAND_BASE_T:                 /*1000 copper*/
        default_speed_duplex_status = VAL_portSpeedDpxCfg_fullDuplex1000;
        break;


    case STKTPLG_TYPE_MEDIA_TYPE_OTHER:
    default:
        default_speed_duplex_status = 0; /*invalid*/
        break;
    }

    SWCTRL_GetMauTypeByMediaTypeAndSpdDpx (media_type,
                                           default_speed_duplex_status,
                                           &(if_mau_entry->ifMauType));

    /* ifMauStatus: Only support (3: operational) (5: shutdown)
     */
    if (VAL_ifAdminStatus_down == SYS_DFLT_IF_ADMIN_STATUS)
    {
       if_mau_entry->ifMauStatus = VAL_ifMauStatus_shutdown;
    }
    else
    {
       if_mau_entry->ifMauStatus = VAL_ifMauStatus_operational;
    }

    /* ifMauMediaAvailable
     * Not running: link-down => VAL_ifMauMediaAvailable_notAvailable
     */
    if_mau_entry->ifMauMediaAvailable = VAL_ifMauMediaAvailable_notAvailable;


    /* ifMauMediaAvailableStateExits: Not support
     */
    if_mau_entry->ifMauMediaAvailableStateExits = 0;

    /* ifMauJabberState
     * Not running: link-down => VAL_ifMauJabberState_other
     */
    if_mau_entry->ifMauJabberState = VAL_ifMauJabberState_other;


    /* ifMauJabberingStateEnters: Not support
     */
    if_mau_entry->ifMauJabberingStateEnters = 0;

    /* ifMauFalseCarriers
     * Not running: 0
     */
    if_mau_entry->ifMauFalseCarriers = 0;

    /* ifMauTypeList: DEPRECATED
     */
    /*if_mau_entry->ifMauTypeList = 0;
     */

    /* ifMauDefaultType =  "media type" + "force mode speed-duplex config"
     * Default force speed-duplex follow SWCTRL_ConfigUserPortToDefaultState()
     */
    switch(media_type)
    {
    case STKTPLG_TYPE_MEDIA_TYPE_HUNDRED_BASE_TX:                /*100 copper*/
        default_force_speed_duplex = SYS_DFLT_FE_COPPER_PORT_FORCE_MODE_SPDDPX;
        break;

    case STKTPLG_TYPE_MEDIA_TYPE_HUNDRED_BASE_FX:                /*100 fiber*/
    case STKTPLG_TYPE_MEDIA_TYPE_HUNDRED_BASE_FX_SC_SINGLE_MODE:
    case STKTPLG_TYPE_MEDIA_TYPE_HUNDRED_BASE_FX_SC_MULTI_MODE:
        default_force_speed_duplex = SYS_DFLT_FE_FIBER_PORT_FORCE_MODE_SPDDPX;
        break;

    case STKTPLG_TYPE_MEDIA_TYPE_THOUSAND_BASE_T:                 /*1000 copper*/
        default_force_speed_duplex = SYS_DFLT_GE_COPPER_PORT_FORCE_MODE_SPDDPX;
        break;

    case STKTPLG_TYPE_MEDIA_TYPE_THOUSAND_BASE_SX:                /*1000 fiber*/
    case STKTPLG_TYPE_MEDIA_TYPE_THOUSAND_BASE_LX:
    case STKTPLG_TYPE_MEDIA_TYPE_THOUSAND_BASE_CX:
    case STKTPLG_TYPE_MEDIA_TYPE_THOUSAND_BASE_X:
        default_force_speed_duplex = SYS_DFLT_FE_COPPER_PORT_FORCE_MODE_SPDDPX;
        break;

    case STKTPLG_TYPE_MEDIA_TYPE_OTHER:
    default:
        default_force_speed_duplex = 0; /*invalid*/
        break;
    }
    SWCTRL_GetMauTypeByMediaTypeAndSpdDpx (media_type,
                                           default_force_speed_duplex,
                                           &(if_mau_entry->ifMauDefaultType));

    /* ifMauAutoNegSupported
     */
    if (STKTPLG_TYPE_MEDIA_TYPE_HUNDRED_BASE_FX                == media_type || /*100 fiber*/
        STKTPLG_TYPE_MEDIA_TYPE_HUNDRED_BASE_FX_SC_SINGLE_MODE == media_type ||
        STKTPLG_TYPE_MEDIA_TYPE_HUNDRED_BASE_FX_SC_MULTI_MODE  == media_type )
    {
        /* Only 100 fiber doesn't support auto-nego
         */
        if_mau_entry->ifMauAutoNegSupported = VAL_ifMauAutoNegSupported_false;
    }
    else
    {
        if_mau_entry->ifMauAutoNegSupported = VAL_ifMauAutoNegSupported_true;
    }

    /* ifMauTypeListBits
     */
    SWCTRL_GetPossibleMauTypeListBitsByMediaType(media_type, if_mau_entry->ifMauTypeListBits);

    return TRUE;
}


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetNextIfMauEntry
 * -------------------------------------------------------------------------
 * FUNCTION: Get next MAU entry specified in RFC-3636.
 * INPUT   : if_mau_entry->ifMauIfIndex  -- Next to which interface.
 *           if_mau_entry->ifMauIndex    -- Next to which MAU.
 * OUTPUT  : if_mau_entry.
 * RETURN  : TRUE/FALSE
 * NOTE    : 1) Base on RFC-3636 (snmpDot3MauMgt)
 *           2) For User port only.
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_GetNextIfMauEntry (SWCTRL_IfMauEntry_T *if_mau_entry)
{
    BOOL_T is_init = TRUE;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    /* 1) Argument validation
     */
    if (NULL == if_mau_entry)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
    }
    else
    {
       if_mau_entry->ifMauIndex++; /*First next one*/
    }

    do
    {
        if (FALSE == is_init)
        {
            if_mau_entry->ifMauIndex = 1;
        }

        do
        {
            is_init = FALSE;

            if (TRUE == SWCTRL_GetIfMauEntry (if_mau_entry))
            {
                SWCTRL_RETURN_AND_RELEASE_CSC(TRUE);
            }
        }while(if_mau_entry->ifMauIndex++ <= SYS_ADPT_MAX_NBR_OF_MAU_PER_USER_PORT);
    }while(if_mau_entry->ifMauIfIndex++ <= SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK * SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT);

    SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetIfMauAutoNegAdminStatus
 * -------------------------------------------------------------------------
 * FUNCTION: Set MAU auto-negoation admin status.
 * INPUT   : if_mau_ifindex        -- Which interface.
 *           if_mau_index          -- Which MAU.
 *           auto_neg_admin_status -- VAL_ifMauAutoNegAdminStatus_enabled
 *                                    VAL_ifMauAutoNegAdminStatus_disabled
 * OUTPUT  : None.
 * RETURN  : TRUE/FALSE
 * NOTE    : 1) Base on RFC-3636 (snmpDot3MauMgt)
 *           2) For User port only.
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetIfMauAutoNegAdminStatus (UI32_T if_mau_ifindex,
                                          UI32_T if_mau_index,
                                          UI32_T auto_neg_admin_status)
{
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    SWCTRL_RETURN_AND_RELEASE_CSC(SWCTRL_SetPortAutoNegEnable(if_mau_ifindex, auto_neg_admin_status));
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetIfMauAutoNegRestart
 * -------------------------------------------------------------------------
 * FUNCTION: Set MAU to auto-negoation restart.
 * INPUT   : if_mau_ifindex   -- Which interface.
 *           if_mau_index     -- Which MAU.
 *           auto_neg_restart -- VAL_ifMauAutoNegRestart_restart
                                 VAL_ifMauAutoNegRestart_norestart
 * OUTPUT  : None.
 * RETURN  : TRUE/FALSE
 * NOTE    : 1) Base on RFC-3636 (snmpDot3MauMgt)
 *           2) For User port only.
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetIfMauAutoNegRestart (UI32_T if_mau_ifindex,
                                      UI32_T if_mau_index,
                                      UI32_T auto_neg_restart)
{
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if(VAL_ifMauAutoNegRestart_restart == auto_neg_restart)
    {
         if(VAL_portAutonegotiation_enabled == port_info[if_mau_ifindex-1].port_entry.port_autonegotiation)
         {
             /*Disable then enable*/
             if (FALSE == SWCTRL_SetPortAutoNegEnable(if_mau_ifindex, VAL_portAutonegotiation_disabled))
             {
                 SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
             }

             if (FALSE == SWCTRL_SetPortAutoNegEnable(if_mau_ifindex, VAL_portAutonegotiation_enabled))
             {
                 SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
             }
         }
     }

    SWCTRL_RETURN_AND_RELEASE_CSC(TRUE);
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetIfMauAutoNegCapAdvertisedBits
 * -------------------------------------------------------------------------
 * FUNCTION: Set advertised capability bits in the MAU.
 * INPUT   : if_mau_ifindex  -- Which interface.
 *           if_mau_index    -- Which MAU.
 *           auto_neg_cap_adv_bits -- (1 << VAL_ifMauAutoNegCapAdvertisedBits_bOther      )
 *                                    (1 << VAL_ifMauAutoNegCapAdvertisedBits_b10baseT    )
 *                                    (1 << VAL_ifMauAutoNegCapAdvertisedBits_b10baseTFD  )
 *                                    (1 << VAL_ifMauAutoNegCapAdvertisedBits_b100baseT4  )
 *                                    (1 << VAL_ifMauAutoNegCapAdvertisedBits_b100baseTX  )
 *                                    (1 << VAL_ifMauAutoNegCapAdvertisedBits_b100baseTXFD)
 *                                    (1 << VAL_ifMauAutoNegCapAdvertisedBits_b100baseT2  )
 *                                    (1 << VAL_ifMauAutoNegCapAdvertisedBits_b100baseT2FD)
 *                                    (1 << VAL_ifMauAutoNegCapAdvertisedBits_bFdxPause   )
 *                                    (1 << VAL_ifMauAutoNegCapAdvertisedBits_bFdxAPause  )
 *                                    (1 << VAL_ifMauAutoNegCapAdvertisedBits_bFdxSPause  )
 *                                    (1 << VAL_ifMauAutoNegCapAdvertisedBits_bFdxBPause  )
 *                                    (1 << VAL_ifMauAutoNegCapAdvertisedBits_b1000baseX  )
 *                                    (1 << VAL_ifMauAutoNegCapAdvertisedBits_b1000baseXFD)
 *                                    (1 << VAL_ifMauAutoNegCapAdvertisedBits_b1000baseT  )
 *                                    (1 << VAL_ifMauAutoNegCapAdvertisedBits_b1000baseTFD)
 * OUTPUT  : None.
 * RETURN  : TRUE/FALSE
 * NOTE    : 1) Base on RFC-3636 (snmpDot3MauMgt)
 *           2) For User port only.
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetIfMauAutoNegCapAdvertisedBits (UI32_T if_mau_ifindex,
                                                UI32_T if_mau_index,
                                                UI32_T auto_neg_cap_adv_bits)
{
    UI32_T port_capabilities = 0;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

#define IFMAUCAP_TO_PORTRCAP(MAUCAP, PORTCAP); \
    if (auto_neg_cap_adv_bits & L_CVRT_SNMP_BIT_VALUE_32(MAUCAP)) \
    {port_capabilities |= PORTCAP;}\
    auto_neg_cap_adv_bits &= ~L_CVRT_SNMP_BIT_VALUE_32(MAUCAP);

    IFMAUCAP_TO_PORTRCAP(VAL_ifMauAutoNegCapAdvertisedBits_b1000baseT, SYS_VAL_portCapabilities_portCap1000half);
    IFMAUCAP_TO_PORTRCAP(VAL_ifMauAutoNegCapAdvertisedBits_b1000baseTFD, SYS_VAL_portCapabilities_portCap1000full);
    IFMAUCAP_TO_PORTRCAP(VAL_ifMauAutoNegCapAdvertisedBits_b10baseT, SYS_VAL_portCapabilities_portCap10half);
    IFMAUCAP_TO_PORTRCAP(VAL_ifMauAutoNegCapAdvertisedBits_b10baseTFD, SYS_VAL_portCapabilities_portCap10full);
    IFMAUCAP_TO_PORTRCAP(VAL_ifMauAutoNegCapAdvertisedBits_b100baseTX, SYS_VAL_portCapabilities_portCap100half);
    IFMAUCAP_TO_PORTRCAP(VAL_ifMauAutoNegCapAdvertisedBits_b100baseTXFD, SYS_VAL_portCapabilities_portCap100full);
    IFMAUCAP_TO_PORTRCAP(VAL_ifMauAutoNegCapAdvertisedBits_bFdxAPause, SYS_VAL_portCapabilities_portCapSym);
    IFMAUCAP_TO_PORTRCAP(VAL_ifMauAutoNegCapAdvertisedBits_bFdxPause, SYS_VAL_portCapabilities_portCapFlowCtrl);
    IFMAUCAP_TO_PORTRCAP(VAL_ifMauAutoNegCapAdvertisedBits_b1000baseX, SYS_VAL_portCapabilities_portCap1000half);
    IFMAUCAP_TO_PORTRCAP(VAL_ifMauAutoNegCapAdvertisedBits_b1000baseXFD, SYS_VAL_portCapabilities_portCap1000full);

    if(0 != auto_neg_cap_adv_bits)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
    }

    if(FALSE == SWCTRL_SetPortCapabilities(if_mau_ifindex, port_capabilities))
    {
        SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
    }

    SWCTRL_RETURN_AND_RELEASE_CSC(TRUE);
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetIfMauAutoNegRemoteFaultAdvertised
 * -------------------------------------------------------------------------
 * FUNCTION: Set advertised auto-negoation remote fault in the MAU.
 * INPUT   : if_mau_ifindex            -- Which interface.
 *           if_mau_index              -- Which MAU.
 *           auto_neg_remote_fault_adv -- VAL_ifMauAutoNegRemoteFaultAdvertised_noError
 *                                        VAL_ifMauAutoNegRemoteFaultAdvertised_offline
 *                                        VAL_ifMauAutoNegRemoteFaultAdvertised_linkFailure
 *                                        VAL_ifMauAutoNegRemoteFaultAdvertised_autoNegError
 * OUTPUT  : None.
 * RETURN  : TRUE/FALSE
 * NOTE    : 1) Base on RFC-3636 (snmpDot3MauMgt)
 *           2) For User port only.
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetIfMauAutoNegRemoteFaultAdvertised (UI32_T if_mau_ifindex,
                                                    UI32_T if_mau_index,
                                                    UI32_T auto_neg_remote_fault_adv)
{
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    /* Currently, MAU MIB only support "read",
     * i.e. if the access is "read/write", we support APIs for SNMP to call to "write",
     * but always return FALSE.
     * In this way, if we support "write" in the future, SNMP doesn't need to modify the
     * code, and the effort will only in SWCTRL, SWDRV, and DEV_SWDRV.
     */
    SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetIfMauAutoNegEntry
 * -------------------------------------------------------------------------
 * FUNCTION: Get auto-negoation entry of the MAU, that is specified in REF-3636
 * INPUT   : if_mau_auto_neg_entry->ifMauIfIndex -- Which interface.
 *           if_mau_auto_neg_entry->ifMauIndex   -- Which MAU.
 * OUTPUT  : if_mau_auto_neg_entry.
 * RETURN  : TRUE/FALSE
 * NOTE    : 1) Base on RFC-3636 (snmpDot3MauMgt)
 *           2) For User port only.
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_GetIfMauAutoNegEntry (SWCTRL_IfMauAutoNegEntry_T *if_mau_auto_neg_entry)
{
    BOOL_T is_running_mau = FALSE;
    UI32_T media_type;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    /* Argument validation
     */
    if (NULL == if_mau_auto_neg_entry)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
    }

    /* Only for user port: ifMauIfIndex (key 1)
     */
    if (FALSE == SWCTRL_IS_USER_PORT(if_mau_auto_neg_entry->ifMauIfIndex))
    {
        SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
    }

    /* Present port is necessary: ifMauIfIndex (key 1)
     */
    if (FALSE == SWCTRL_IS_EXIST(if_mau_auto_neg_entry->ifMauIfIndex))
    {
        SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
    }

    /* MAU index range: ifMauIndex (key 2)
     */
    /* Checking this MAU is present or not is not SWCTRL knowledge,
     * checking max possible index is necessary.
     */
    if (if_mau_auto_neg_entry->ifMauIndex == 0 ||
        if_mau_auto_neg_entry->ifMauIndex > SYS_ADPT_MAX_NBR_OF_MAU_PER_USER_PORT)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
    }

    /* Use SWCTRL_GetMauMediaType() to check MAU is present or not
     */
    if (FALSE == SWCTRL_GetMauMediaType (SWCTRL_IFINDEX_TO_UNIT(if_mau_auto_neg_entry->ifMauIfIndex),
                                         SWCTRL_IFINDEX_TO_PORT(if_mau_auto_neg_entry->ifMauIfIndex),
                                         if_mau_auto_neg_entry->ifMauIndex,
                                         &media_type))
    {
        /* Shall be not present   */
        SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
    }
    is_running_mau = SWCTRL_Is_Running_Mau(if_mau_auto_neg_entry->ifMauIfIndex,media_type);

    if (TRUE == is_running_mau)
    {
        SWCTRL_GetActualIfMauAutoNegEntry(media_type, if_mau_auto_neg_entry);
    }
    else
    {
        SWCTRL_GetDefaultIfMauAutoNegEntry(media_type, if_mau_auto_neg_entry);
    }

    SWCTRL_RETURN_AND_RELEASE_CSC(TRUE);
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetActualIfMauAutoNegEntry
 * -------------------------------------------------------------------------
 * FUNCTION: Get ifMauAutoNegEntry base on actual facts.
 * INPUT   : media_type                          -- Media type.
 *           if_mau_auto_neg_entry->ifMauIfIndex -- Which interface.
 *           if_mau_auto_neg_entry->ifMauIndex   -- Which MAU.
 * OUTPUT  : if_mau_auto_neg_entry.
 * RETURN  : TRUE/FALSE
 * NOTE    : None.
 * -------------------------------------------------------------------------*/
static BOOL_T SWCTRL_GetActualIfMauAutoNegEntry  (UI32_T media_type, SWCTRL_IfMauAutoNegEntry_T *if_mau_auto_neg_entry)
{
    /* ifMauAutoNegAdminStatus
     */
    if (VAL_portAutonegotiation_enabled == port_info[if_mau_auto_neg_entry->ifMauIfIndex-1].port_entry.port_autonegotiation)
    {
        if_mau_auto_neg_entry->ifMauAutoNegAdminStatus = VAL_ifMauAutoNegAdminStatus_enabled;
    }
    else
    {
        if_mau_auto_neg_entry->ifMauAutoNegAdminStatus = VAL_ifMauAutoNegAdminStatus_disabled;
    }

    /* ifMauAutoNegRemoteSignaling
     */
    if (FALSE == SWDRV_GetPortLinkPartnerAutoNegoSignalingState (SWCTRL_IFINDEX_TO_UNIT(if_mau_auto_neg_entry->ifMauIfIndex),
                                                                 SWCTRL_IFINDEX_TO_PORT(if_mau_auto_neg_entry->ifMauIfIndex),
                                                                 &(if_mau_auto_neg_entry->ifMauAutoNegRemoteSignaling)))
    {
        if_mau_auto_neg_entry->ifMauAutoNegRemoteSignaling = VAL_ifMauAutoNegRemoteSignaling_notdetected;
    }

    /* ifMauAutoNegConfig
     */
    if (FALSE == SWDRV_GetPortAutoNegoProcessState (SWCTRL_IFINDEX_TO_UNIT(if_mau_auto_neg_entry->ifMauIfIndex),
                                                    SWCTRL_IFINDEX_TO_PORT(if_mau_auto_neg_entry->ifMauIfIndex),
                                                    &(if_mau_auto_neg_entry->ifMauAutoNegConfig)))
    {
        if_mau_auto_neg_entry->ifMauAutoNegConfig = VAL_ifMauAutoNegConfig_other;
    }

    /* ifMauAutoNegCapability: DEPRECATED
     */
    /* if_mau_auto_neg_entry->ifMauAutoNegCapability = 0;
     */

    /* ifMauAutoNegCapAdvertised: DEPRECATED
     */
    /* if_mau_auto_neg_entry->ifMauAutoNegCapAdvertised = 0;
     */

    /* ifMauAutoNegCapReceived: DEPRECATED
     */
    /* if_mau_auto_neg_entry->ifMauAutoNegCapAdvertised = 0;
     */

    /* ifMauAutoNegRestart: Always VAL_ifMauAutoNegRestart_norestart for "get"
     */
    if_mau_auto_neg_entry->ifMauAutoNegRestart = VAL_ifMauAutoNegRestart_norestart;

    /* ifMauAutoNegCapabilityBits
     */
    SWCTRL_GetPossibleAutoNegCapBitsByMediaType(media_type, &(if_mau_auto_neg_entry->ifMauAutoNegCapabilityBits));

    /* ifMauAutoNegCapAdvertisedBits
     */
    SWCTRL_GetAdvAutoNegCapBitsByMediaTypeAndCurrentCapBits (media_type,
                                                             port_info[if_mau_auto_neg_entry->ifMauIfIndex-1].port_entry.port_capabilities,
                                                             &(if_mau_auto_neg_entry->ifMauAutoNegCapAdvertisedBits));

    /* ifMauAutoNegCapReceivedBits
     */
    if (FALSE == SWDRV_GetPortLinkPartnerAutoNegoCapa (SWCTRL_IFINDEX_TO_UNIT(if_mau_auto_neg_entry->ifMauIfIndex),
                                                       SWCTRL_IFINDEX_TO_PORT(if_mau_auto_neg_entry->ifMauIfIndex),
                                                       &(if_mau_auto_neg_entry->ifMauAutoNegCapReceivedBits)))
    {
        if_mau_auto_neg_entry->ifMauAutoNegCapReceivedBits = 0;
    }


    /* ifMauAutoNegRemoteFaultAdvertised
     */
    /* Because we don't support "write" currently, there is no database in SWCTRL.
     * In this way get from ASIC register.
     * When support "write", get local dadabase.
     */
    if (FALSE == SWDRV_GetPortAutoNegoRemoteFaultAdvertisement (SWCTRL_IFINDEX_TO_UNIT(if_mau_auto_neg_entry->ifMauIfIndex),
                                                                SWCTRL_IFINDEX_TO_PORT(if_mau_auto_neg_entry->ifMauIfIndex),
                                                                &(if_mau_auto_neg_entry->ifMauAutoNegRemoteFaultAdvertised)))
    {
        if_mau_auto_neg_entry->ifMauAutoNegRemoteFaultAdvertised = VAL_ifMauAutoNegRemoteFaultAdvertised_autoNegError;
    }

    /* ifMauAutoNegRemoteFaultReceived
     */
    if (FALSE == SWDRV_GetPortLinkPartnerAutoNegoRemoteFault (SWCTRL_IFINDEX_TO_UNIT(if_mau_auto_neg_entry->ifMauIfIndex),
                                                              SWCTRL_IFINDEX_TO_PORT(if_mau_auto_neg_entry->ifMauIfIndex),
                                                              &(if_mau_auto_neg_entry->ifMauAutoNegRemoteFaultReceived)))
    {
        if_mau_auto_neg_entry->ifMauAutoNegRemoteFaultReceived = VAL_ifMauAutoNegRemoteFaultReceived_autoNegError;
    }

    return TRUE;
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetDefaultIfMauAutoNegEntry
 * -------------------------------------------------------------------------
 * FUNCTION: Get ifMauAutoNegEntry base on default value.
 * INPUT   : media_type                          -- Media type.
 *           if_mau_auto_neg_entry->ifMauIfIndex -- Which interface.
 *           if_mau_auto_neg_entry->ifMauIndex   -- Which MAU.
 * OUTPUT  : if_mau_auto_neg_entry.
 * NOTE    : For not running MAU.
 * -------------------------------------------------------------------------*/
static BOOL_T SWCTRL_GetDefaultIfMauAutoNegEntry (UI32_T media_type, SWCTRL_IfMauAutoNegEntry_T *if_mau_auto_neg_entry)
{
    UI32_T default_capabilities;

    /* ifMauAutoNegAdminStatus
     */
    if (VAL_ifAdminStatus_down == SYS_DFLT_PORT_AUTONEGOTIATION)
    {
        if_mau_auto_neg_entry->ifMauAutoNegAdminStatus = VAL_ifMauAutoNegAdminStatus_disabled;
    }
    else
    {
        if_mau_auto_neg_entry->ifMauAutoNegAdminStatus = VAL_ifMauAutoNegAdminStatus_enabled;
    }

    /* ifMauAutoNegRemoteSignaling
     * Not running: no link up => VAL_ifMauAutoNegRemoteSignaling_notdetected
     */
    if_mau_auto_neg_entry->ifMauAutoNegRemoteSignaling = VAL_ifMauAutoNegRemoteSignaling_notdetected;


    /* ifMauAutoNegConfig
     * Not running: no link up => VAL_ifMauAutoNegConfig_other
     */
    if_mau_auto_neg_entry->ifMauAutoNegConfig = VAL_ifMauAutoNegConfig_other;

    /* ifMauAutoNegCapability: DEPRECATED
     */
    /* if_mau_auto_neg_entry->ifMauAutoNegCapability = 0;
     */

    /* ifMauAutoNegCapAdvertised: DEPRECATED
     */
    /* if_mau_auto_neg_entry->ifMauAutoNegCapAdvertised = 0;
     */

    /* ifMauAutoNegCapReceived: DEPRECATED
     */
    /* if_mau_auto_neg_entry->ifMauAutoNegCapAdvertised = 0;
     */

   /* ifMauAutoNegRestart: Always VAL_ifMauAutoNegRestart_norestart for "get"
     */
    if_mau_auto_neg_entry->ifMauAutoNegRestart = VAL_ifMauAutoNegRestart_norestart;


    /* ifMauAutoNegCapabilityBits
     */
    SWCTRL_GetPossibleAutoNegCapBitsByMediaType(media_type, &(if_mau_auto_neg_entry->ifMauAutoNegCapabilityBits));

    /* ifMauAutoNegCapAdvertisedBits
     */
    switch(media_type)
    {
    case STKTPLG_TYPE_MEDIA_TYPE_HUNDRED_BASE_TX:                /*100 copper*/
        default_capabilities = SYS_DFLT_10_100_PORT_CAPABILITIES;
        break;

    case STKTPLG_TYPE_MEDIA_TYPE_HUNDRED_BASE_FX:                /*100 fiber*/
    case STKTPLG_TYPE_MEDIA_TYPE_HUNDRED_BASE_FX_SC_SINGLE_MODE:
    case STKTPLG_TYPE_MEDIA_TYPE_HUNDRED_BASE_FX_SC_MULTI_MODE:
        default_capabilities = SYS_DFLT_100_FIBER_PORT_CAPABILITIES;
        break;

    case STKTPLG_TYPE_MEDIA_TYPE_THOUSAND_BASE_T:                 /*1000 copper*/
        default_capabilities = SYS_DFLT_10_100_1000_PORT_CAPABILITIES;
        break;

    case STKTPLG_TYPE_MEDIA_TYPE_THOUSAND_BASE_SX:                /*1000 fiber*/
    case STKTPLG_TYPE_MEDIA_TYPE_THOUSAND_BASE_LX:
    case STKTPLG_TYPE_MEDIA_TYPE_THOUSAND_BASE_CX:
    case STKTPLG_TYPE_MEDIA_TYPE_THOUSAND_BASE_X:
        default_capabilities = SYS_DFLT_1000_FIBER_PORT_CAPABILITIES;
        break;

    case STKTPLG_TYPE_MEDIA_TYPE_OTHER:
    default:
        default_capabilities = 0; /*invalid*/
        break;
    }
    SWCTRL_GetAdvAutoNegCapBitsByMediaTypeAndCurrentCapBits (media_type,
                                                             default_capabilities,
                                                             &(if_mau_auto_neg_entry->ifMauAutoNegCapAdvertisedBits));

    /* ifMauAutoNegCapReceivedBits
     * Not running: link-down: 0
     */
    if_mau_auto_neg_entry->ifMauAutoNegCapReceivedBits = 0;


    /* ifMauAutoNegRemoteFaultAdvertised
     * Currently, now spec for default value of this items. Need Spec.
     * Not running: VAL_ifMauAutoNegRemoteFaultAdvertised_noError
     */
    if_mau_auto_neg_entry->ifMauAutoNegRemoteFaultAdvertised = VAL_ifMauAutoNegRemoteFaultAdvertised_noError;

    /* ifMauAutoNegRemoteFaultReceived
     * Not running: link-down: VAL_ifMauAutoNegRemoteFaultReceived_noError
     */
    if_mau_auto_neg_entry->ifMauAutoNegRemoteFaultReceived = VAL_ifMauAutoNegRemoteFaultReceived_noError;

    return TRUE;
}


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetNextIfMauAutoNegEntry
 * -------------------------------------------------------------------------
 * FUNCTION: Get next auto-negoation entry of the MAU, one is specified in RFC-3636
 * INPUT   : if_mau_auto_neg_entry->ifMauIfIndex  -- Next to which interface.
 *           if_mau_auto_neg_entry->ifMauIndex    -- Next to which Which MAU.
 * OUTPUT  : if_mau_auto_neg_entry.
 * RETURN  : TRUE/FALSE
 * NOTE    : 1) Base on RFC-3636 (snmpDot3MauMgt)
 *           2) For User port only.
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_GetNextIfMauAutoNegEntry (SWCTRL_IfMauAutoNegEntry_T *if_mau_auto_neg_entry)
{
    BOOL_T is_init = TRUE;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    /* 1) Argument validation
     */
    if (NULL == if_mau_auto_neg_entry)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
    }
    else
    {
       if_mau_auto_neg_entry->ifMauIndex++; /*First next one*/
    }

    do
    {
        if (FALSE == is_init)
        {
            if_mau_auto_neg_entry->ifMauIndex = 1;
        }

        do
        {
            is_init = FALSE;

            if (TRUE == SWCTRL_GetIfMauAutoNegEntry (if_mau_auto_neg_entry))
            {
                SWCTRL_RETURN_AND_RELEASE_CSC(TRUE);
            }
        }while(if_mau_auto_neg_entry->ifMauIndex++ <= SYS_ADPT_MAX_NBR_OF_MAU_PER_USER_PORT);
    }while(if_mau_auto_neg_entry->ifMauIfIndex++ <= SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK * SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT);

    SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetIfJackEntry
 * -------------------------------------------------------------------------
 * FUNCTION: Get jack entry of the jack in some MAU, one is specified in RFC-3636.
 * INPUT   : if_jack_entry->ifMauIfIndex  -- Which interface.
 *           if_jack_entry->ifMauIndex    -- Which MAU.
 *           if_jack_entry->ifJackIndex   -- Which jack.
 * OUTPUT  : if_jack_entry.
 * RETURN  : TRUE/FALSE
 * NOTE    : 1) Base on RFC-3636 (snmpDot3MauMgt)
 *           2) For User port only.
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_GetIfJackEntry (SWCTRL_IfJackEntry_T *if_jack_entry)
{
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    /* Argument validation
     */
    if (NULL == if_jack_entry)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
    }

    /* Only for user port: ifMauIfIndex (key 1)
     */
    if (FALSE == SWCTRL_IS_USER_PORT(if_jack_entry->ifMauIfIndex))
    {
        SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
    }

    /* Present port is necessary: ifMauIfIndex (key 1)
     */
    if (FALSE == SWCTRL_IS_EXIST(if_jack_entry->ifMauIfIndex))
    {
        SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
    }

    /* MAU index range: ifMauIndex (key 2)
     */
    /* Checking this MAU is present or not is not SWCTRL knowledge,
     * checking max possible index is necessary.
     */
    if (if_jack_entry->ifMauIndex == 0 ||
        if_jack_entry->ifMauIndex > SYS_ADPT_MAX_NBR_OF_MAU_PER_USER_PORT)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
    }

    /* Jack index renge: ifJackIndex (key 3)
     */
    /* Checking this jack is present or not is not SWCTRL knowledge,
     * checking max possible index is necessary.
     */
    if (if_jack_entry->ifJackIndex == 0 ||
        if_jack_entry->ifJackIndex > SYS_ADPT_MAX_NBR_OF_JACK_PER_MAU)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
    }

    /* ifJackType
     */
    if (FALSE == STKTPLG_POM_GetJackType (SWCTRL_IFINDEX_TO_UNIT(if_jack_entry->ifMauIfIndex),
                                          SWCTRL_IFINDEX_TO_PORT(if_jack_entry->ifMauIfIndex),
                                          if_jack_entry->ifMauIndex,
                                          if_jack_entry->ifJackIndex,
                                          &(if_jack_entry->ifJackType)))
    {
        SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
    }

    SWCTRL_RETURN_AND_RELEASE_CSC(TRUE);
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetNextIfJackEntry
 * -------------------------------------------------------------------------
 * FUNCTION: Get next jack entry of the jack in some MAU, one is specified in RFC-3636.
 * INPUT   : if_jack_entry->ifMauIfIndex  -- Next to which interface.
 *           if_jack_entry->ifMauIndex    -- Next to which MAU.
 *           if_jack_entry->ifJackIndex   -- Next to which jack.
 * OUTPUT  : if_jack_entry.
 * RETURN  : TRUE/FALSE
 * NOTE    : 1) Base on RFC-3636 (snmpDot3MauMgt)
 *           2) For User port only.
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_GetNextIfJackEntry (SWCTRL_IfJackEntry_T *if_jack_entry)
{
    BOOL_T is_init = TRUE;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    /* Argument validation
     */
    if (NULL == if_jack_entry)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
    }
    else
    {
        if_jack_entry->ifJackIndex++; /*First next one*/
    }

    do
    {
        if (FALSE == is_init)
        {
            if_jack_entry->ifMauIndex = 1;
        }

        do
        {
            if (FALSE == is_init)
            {
                if_jack_entry->ifJackIndex = 1;
            }

            do
            {
                is_init = FALSE;

                if (TRUE == SWCTRL_GetIfJackEntry (if_jack_entry))
                {
                    SWCTRL_RETURN_AND_RELEASE_CSC(TRUE);
                }
            }while(if_jack_entry->ifJackIndex++ <= SYS_ADPT_MAX_NBR_OF_JACK_PER_MAU);
        }while(if_jack_entry->ifMauIndex++ <= SYS_ADPT_MAX_NBR_OF_MAU_PER_USER_PORT);
    }while(if_jack_entry->ifMauIfIndex++ <= SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK * SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT);

    SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
}


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetMauTypeByMediaTypeAndSpdDpx
 * -------------------------------------------------------------------------
 * FUNCTION: Because MAU type = "Media type" + "speed-duplex",
 *           using this API to assemble to get the MAU type.
 * INPUT   : media_type   -- STKTPLG_TYPE_MEDIA_TYPE_OTHER
 *                           STKTPLG_TYPE_MEDIA_TYPE_HUNDRED_BASE_TX
 *                           STKTPLG_TYPE_MEDIA_TYPE_HUNDRED_BASE_FX
 *                           STKTPLG_TYPE_MEDIA_TYPE_THOUSAND_BASE_SX
 *                           STKTPLG_TYPE_MEDIA_TYPE_THOUSAND_BASE_LX
 *                           STKTPLG_TYPE_MEDIA_TYPE_THOUSAND_BASE_T
 *                           STKTPLG_TYPE_MEDIA_TYPE_HUNDRED_BASE_FX_SC_SINGLE_MODE
 *                           STKTPLG_TYPE_MEDIA_TYPE_HUNDRED_BASE_FX_SC_MULTI_MODE
 *           speed_duplex -- VAL_portSpeedDpxCfg_halfDuplex10
 *                           VAL_portSpeedDpxCfg_fullDuplex10
 *                           VAL_portSpeedDpxCfg_halfDuplex100
 *                           VAL_portSpeedDpxCfg_fullDuplex100
 *                           VAL_portSpeedDpxCfg_halfDuplex1000
 *                           VAL_portSpeedDpxCfg_fullDuplex1000
 * OUTPUT  : mau_type     -- Got MAU type.
 * RETURN  : None.
 * NOTE    : None.
 * -------------------------------------------------------------------------*/
static void SWCTRL_GetMauTypeByMediaTypeAndSpdDpx(UI32_T media_type, UI32_T speed_duplex, UI32_T *mau_type)
{
    switch(media_type)
    {
    case STKTPLG_TYPE_MEDIA_TYPE_HUNDRED_BASE_TX:
    case STKTPLG_TYPE_MEDIA_TYPE_THOUSAND_BASE_T:
        switch(speed_duplex)
        {
        case VAL_portSpeedDpxCfg_halfDuplex10:
            *mau_type = SWCTRL_IF_MAU_TYPE_10BASETHD;
            break;

        case VAL_portSpeedDpxCfg_fullDuplex10:
            *mau_type = SWCTRL_IF_MAU_TYPE_10BASETFD;
            break;

        case VAL_portSpeedDpxCfg_halfDuplex100:
            *mau_type = SWCTRL_IF_MAU_TYPE_100BASETXHD;
            break;

        case VAL_portSpeedDpxCfg_fullDuplex100:
            *mau_type = SWCTRL_IF_MAU_TYPE_100BASETXFD;
            break;

        case VAL_portSpeedDpxCfg_halfDuplex1000:
            *mau_type = SWCTRL_IF_MAU_TYPE_1000BASETHD;
            break;

        case VAL_portSpeedDpxCfg_fullDuplex1000:
            *mau_type = SWCTRL_IF_MAU_TYPE_1000BASETFD;
            break;

        default:
            *mau_type = SWCTRL_IF_MAU_TYPE_OTHER;
            break;
        }
        break;

    case STKTPLG_TYPE_MEDIA_TYPE_HUNDRED_BASE_FX:
    case STKTPLG_TYPE_MEDIA_TYPE_HUNDRED_BASE_FX_SC_SINGLE_MODE:
    case STKTPLG_TYPE_MEDIA_TYPE_HUNDRED_BASE_FX_SC_MULTI_MODE:
        switch(speed_duplex)
        {
        case VAL_portSpeedDpxCfg_halfDuplex100:
            *mau_type = SWCTRL_IF_MAU_TYPE_100BASEFXHD;
            break;

        case VAL_portSpeedDpxCfg_fullDuplex100:
            *mau_type = SWCTRL_IF_MAU_TYPE_100BASEFXFD;
            break;

        case VAL_portSpeedDpxCfg_halfDuplex10:
        case VAL_portSpeedDpxCfg_fullDuplex10:
        case VAL_portSpeedDpxCfg_halfDuplex1000:
        case VAL_portSpeedDpxCfg_fullDuplex1000:
        default:
            *mau_type = SWCTRL_IF_MAU_TYPE_OTHER;
            break;
        }
        break;

    case STKTPLG_TYPE_MEDIA_TYPE_THOUSAND_BASE_LX:
        switch(speed_duplex)
        {
        case VAL_portSpeedDpxCfg_halfDuplex1000:
            *mau_type = SWCTRL_IF_MAU_TYPE_1000BASELXHD;
            break;

        case VAL_portSpeedDpxCfg_fullDuplex1000:
            *mau_type = SWCTRL_IF_MAU_TYPE_1000BASELXFD;
            break;

        default:
        case VAL_portSpeedDpxCfg_halfDuplex10:
        case VAL_portSpeedDpxCfg_fullDuplex10:
        case VAL_portSpeedDpxCfg_halfDuplex100:
        case VAL_portSpeedDpxCfg_fullDuplex100:
            *mau_type = SWCTRL_IF_MAU_TYPE_OTHER;
            break;
        }
        break;

    case STKTPLG_TYPE_MEDIA_TYPE_THOUSAND_BASE_SX: /*1000 fiber - 3*/
        switch(speed_duplex)
        {
        case VAL_portSpeedDpxCfg_halfDuplex1000:
            *mau_type = SWCTRL_IF_MAU_TYPE_1000BASESXHD;
            break;

        case VAL_portSpeedDpxCfg_fullDuplex1000:
            *mau_type = SWCTRL_IF_MAU_TYPE_1000BASESXFD;
            break;

        default:
        case VAL_portSpeedDpxCfg_halfDuplex10:
        case VAL_portSpeedDpxCfg_fullDuplex10:
        case VAL_portSpeedDpxCfg_halfDuplex100:
        case VAL_portSpeedDpxCfg_fullDuplex100:
            *mau_type = SWCTRL_IF_MAU_TYPE_OTHER;
            break;
        }
    break;
    case STKTPLG_TYPE_MEDIA_TYPE_THOUSAND_BASE_CX: /*1000 fiber - 3*/
        switch(speed_duplex)
        {
        case VAL_portSpeedDpxCfg_halfDuplex1000:
            *mau_type = SWCTRL_IF_MAU_TYPE_1000BASECXHD;
            break;

        case VAL_portSpeedDpxCfg_fullDuplex1000:
            *mau_type = SWCTRL_IF_MAU_TYPE_1000BASECXFD;
            break;

        default:
        case VAL_portSpeedDpxCfg_halfDuplex10:
        case VAL_portSpeedDpxCfg_fullDuplex10:
        case VAL_portSpeedDpxCfg_halfDuplex100:
        case VAL_portSpeedDpxCfg_fullDuplex100:
            *mau_type = SWCTRL_IF_MAU_TYPE_OTHER;
            break;
        }
        break;
    case STKTPLG_TYPE_MEDIA_TYPE_THOUSAND_BASE_X:
        switch(speed_duplex)
        {
            case VAL_portSpeedDpxCfg_halfDuplex1000:
                *mau_type = SWCTRL_IF_MAU_TYPE_1000BASEXHD;
                break;

            case VAL_portSpeedDpxCfg_fullDuplex1000:
                *mau_type = SWCTRL_IF_MAU_TYPE_1000BASEXFD;
                break;

            default:
            case VAL_portSpeedDpxCfg_halfDuplex10:
            case VAL_portSpeedDpxCfg_fullDuplex10:
            case VAL_portSpeedDpxCfg_halfDuplex100:
            case VAL_portSpeedDpxCfg_fullDuplex100:
                *mau_type = SWCTRL_IF_MAU_TYPE_OTHER;
                break;
        }
        break;
    case STKTPLG_TYPE_MEDIA_TYPE_10G_BASE_LR:
        *mau_type = SWCTRL_IF_MAU_TYPE_10GIGBASELR;
        break;

    case STKTPLG_TYPE_MEDIA_TYPE_10G_BASE_ER:
        *mau_type = SWCTRL_IF_MAU_TYPE_10GIGBASEER;
        break;

    case STKTPLG_TYPE_MEDIA_TYPE_10G_BASE_CX4:
    case STKTPLG_TYPE_MEDIA_TYPE_10G_BASE_X:
        *mau_type = SWCTRL_IF_MAU_TYPE_10GIGBASEX;
        break;

    case STKTPLG_TYPE_MEDIA_TYPE_OTHER:
    default:
        *mau_type = SWCTRL_IF_MAU_TYPE_OTHER;
        break;
    }

    return;
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetPossibleMauTypeListBitsByMediaType
 * -------------------------------------------------------------------------
 * FUNCTION: Get possible MAU type that used to nego.
 * INPUT   : media_type   -- STKTPLG_TYPE_MEDIA_TYPE_OTHER
 *                           STKTPLG_TYPE_MEDIA_TYPE_HUNDRED_BASE_TX
 *                           STKTPLG_TYPE_MEDIA_TYPE_HUNDRED_BASE_FX
 *                           STKTPLG_TYPE_MEDIA_TYPE_THOUSAND_BASE_SX
 *                           STKTPLG_TYPE_MEDIA_TYPE_THOUSAND_BASE_LX
 *                           STKTPLG_TYPE_MEDIA_TYPE_THOUSAND_BASE_CX
 *                           STKTPLG_TYPE_MEDIA_TYPE_THOUSAND_BASE_X
 *                           STKTPLG_TYPE_MEDIA_TYPE_THOUSAND_BASE_T
 *                           STKTPLG_TYPE_MEDIA_TYPE_HUNDRED_BASE_FX_SC_SINGLE_MODE
 *                           STKTPLG_TYPE_MEDIA_TYPE_HUNDRED_BASE_FX_SC_MULTI_MODE
 *                           STKTPLG_TYPE_MEDIA_TYPE_10G_BASE_LR
 *                           STKTPLG_TYPE_MEDIA_TYPE_10G_BASE_ER
 *                           STKTPLG_TYPE_MEDIA_TYPE_10G_BASE_CX4
 *                           STKTPLG_TYPE_MEDIA_TYPE_10G_BASE_X
 * OUTPUT  : mau_type_list_bits --
 *                           VAL_ifMauTypeListBits_bOther
 *                           VAL_ifMauTypeListBits_bAUI
 *                           VAL_ifMauTypeListBits_b10base5
 *                           VAL_ifMauTypeListBits_bFoirl
 *                           VAL_ifMauTypeListBits_b10base2
 *                           VAL_ifMauTypeListBits_b10baseT
 *                           VAL_ifMauTypeListBits_b10baseFP
 *                           VAL_ifMauTypeListBits_b10baseFB
 *                           VAL_ifMauTypeListBits_b10baseFL
 *                           VAL_ifMauTypeListBits_b10broad36
 *                           VAL_ifMauTypeListBits_b10baseTHD
 *                           VAL_ifMauTypeListBits_b10baseTFD
 *                           VAL_ifMauTypeListBits_b10baseFLHD
 *                           VAL_ifMauTypeListBits_b10baseFLFD
 *                           VAL_ifMauTypeListBits_b100baseT4
 *                           VAL_ifMauTypeListBits_b100baseTXHD
 *                           VAL_ifMauTypeListBits_b100baseTXFD
 *                           VAL_ifMauTypeListBits_b100baseFXHD
 *                           VAL_ifMauTypeListBits_b100baseFXFD
 *                           VAL_ifMauTypeListBits_b100baseT2HD
 *                           VAL_ifMauTypeListBits_b100baseT2FD
 *                           VAL_ifMauTypeListBits_b1000baseXHD
 *                           VAL_ifMauTypeListBits_b1000baseXFD
 *                           VAL_ifMauTypeListBits_b1000baseLXHD
 *                           VAL_ifMauTypeListBits_b1000baseLXFD
 *                           VAL_ifMauTypeListBits_b1000baseSXHD
 *                           VAL_ifMauTypeListBits_b1000baseSXFD
 *                           VAL_ifMauTypeListBits_b1000baseCXHD
 *                           VAL_ifMauTypeListBits_b1000baseCXFD
 *                           VAL_ifMauTypeListBits_b1000baseTHD
 *                           VAL_ifMauTypeListBits_b1000baseTFD
 *                           VAL_ifMauTypeListBits_b10GbaseX
 *                           VAL_ifMauTypeListBits_b10GbaseLX4
 *                           VAL_ifMauTypeListBits_b10GbaseR
 *                           VAL_ifMauTypeListBits_b10GbaseER
 *                           VAL_ifMauTypeListBits_b10GbaseLR
 *                           VAL_ifMauTypeListBits_b10GbaseSR
 *                           VAL_ifMauTypeListBits_b10GbaseW
 *                           VAL_ifMauTypeListBits_b10GbaseEW
 *                           VAL_ifMauTypeListBits_b10GbaseLW
 *                           VAL_ifMauTypeListBits_b10GbaseSW
 * RETURN  : None.
 * NOTE    : mau_type_list_bits is an array of 6 bytes.
 * -------------------------------------------------------------------------*/
static void SWCTRL_GetPossibleMauTypeListBitsByMediaType(UI32_T media_type, UI8_T *mau_type_list_bits)
{

    memset(mau_type_list_bits, 0, 6) ;

    switch(media_type)
    {
    case STKTPLG_TYPE_MEDIA_TYPE_THOUSAND_BASE_T:
        /* 1000HD is not supported */
        /* *mau_type_list_bits |= (1 << VAL_ifMauTypeListBits_b1000baseTHD);*/
        SWCTRL_AddBitIndexToByteArray(mau_type_list_bits, 6, VAL_ifMauTypeListBits_b1000baseTFD);

    case STKTPLG_TYPE_MEDIA_TYPE_HUNDRED_BASE_TX:
        SWCTRL_AddBitIndexToByteArray(mau_type_list_bits, 6, VAL_ifMauTypeListBits_b10baseTHD);
        SWCTRL_AddBitIndexToByteArray(mau_type_list_bits, 6, VAL_ifMauTypeListBits_b10baseTFD);
        SWCTRL_AddBitIndexToByteArray(mau_type_list_bits, 6, VAL_ifMauTypeListBits_b100baseTXHD);
        SWCTRL_AddBitIndexToByteArray(mau_type_list_bits, 6, VAL_ifMauTypeListBits_b100baseTXFD);
        break;

    case STKTPLG_TYPE_MEDIA_TYPE_HUNDRED_BASE_FX:
    case STKTPLG_TYPE_MEDIA_TYPE_HUNDRED_BASE_FX_SC_SINGLE_MODE:
    case STKTPLG_TYPE_MEDIA_TYPE_HUNDRED_BASE_FX_SC_MULTI_MODE:
        SWCTRL_AddBitIndexToByteArray(mau_type_list_bits, 6, VAL_ifMauTypeListBits_b100baseFXFD);
        break;

    case STKTPLG_TYPE_MEDIA_TYPE_THOUSAND_BASE_LX:
        SWCTRL_AddBitIndexToByteArray(mau_type_list_bits, 6, VAL_ifMauTypeListBits_b1000baseLXFD);
        break;

    case STKTPLG_TYPE_MEDIA_TYPE_THOUSAND_BASE_SX:
        SWCTRL_AddBitIndexToByteArray(mau_type_list_bits, 6, VAL_ifMauTypeListBits_b1000baseSXFD);
        break;

    case STKTPLG_TYPE_MEDIA_TYPE_THOUSAND_BASE_CX:
        SWCTRL_AddBitIndexToByteArray(mau_type_list_bits, 6, VAL_ifMauTypeListBits_b1000baseCXFD);
        break;

    case STKTPLG_TYPE_MEDIA_TYPE_THOUSAND_BASE_X:
        SWCTRL_AddBitIndexToByteArray(mau_type_list_bits, 6, VAL_ifMauTypeListBits_b1000baseXFD);
        break;

    case STKTPLG_TYPE_MEDIA_TYPE_10G_BASE_LR:
        SWCTRL_AddBitIndexToByteArray(mau_type_list_bits, 6, VAL_ifMauTypeListBits_b10GbaseLR);
        break;

    case STKTPLG_TYPE_MEDIA_TYPE_10G_BASE_ER:
        SWCTRL_AddBitIndexToByteArray(mau_type_list_bits, 6, VAL_ifMauTypeListBits_b10GbaseER);
        break;

    case STKTPLG_TYPE_MEDIA_TYPE_10G_BASE_CX4:
    case STKTPLG_TYPE_MEDIA_TYPE_10G_BASE_X:
        SWCTRL_AddBitIndexToByteArray(mau_type_list_bits, 6, VAL_ifMauTypeListBits_b10GbaseX);
        break;

    case STKTPLG_TYPE_MEDIA_TYPE_OTHER:
    default:
        /* unknown media type: no nego capability
         */
        break;
    }

    return;
}


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_AddBitIndexToByteArray
 * -------------------------------------------------------------------------
 * FUNCTION: Set bit position indicated by bit_index in byte array
 * INPUT   : array
 *         : array_size
 *         : bit_index
 * OUTPUT  :
 * RETURN  : None.
 * NOTE    : This function sets the bits from the left
 *         : ie. Bit_0 is the MSB of array[0], Bit_8 is the MSB of arrary[1]
 * -------------------------------------------------------------------------*/
static void SWCTRL_AddBitIndexToByteArray(UI8_T *array, UI32_T array_size, UI32_T bit_index)
{
    UI8_T byte_offset;
    UI8_T bit_mask;

    if( (bit_index/8) >= array_size )
    {
        return;
    }

    byte_offset = bit_index/8;
    bit_mask = 1<<(7-(bit_index%8));

    array[byte_offset] |= bit_mask;

    return;
}


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetPossibleAutoNegCapBitsByMediaType
 * -------------------------------------------------------------------------
 * FUNCTION: Get possible aoto-nego capability bits type that used to nego.
 * INPUT   : media_type   -- STKTPLG_TYPE_MEDIA_TYPE_HUNDRED_BASE_TX
 *                           STKTPLG_TYPE_MEDIA_TYPE_OTHER
 *                           STKTPLG_TYPE_MEDIA_TYPE_HUNDRED_BASE_TX
 *                           STKTPLG_TYPE_MEDIA_TYPE_HUNDRED_BASE_FX
 *                           STKTPLG_TYPE_MEDIA_TYPE_THOUSAND_BASE_SX
 *                           STKTPLG_TYPE_MEDIA_TYPE_THOUSAND_BASE_LX
 *                           STKTPLG_TYPE_MEDIA_TYPE_THOUSAND_BASE_CX
 *                           STKTPLG_TYPE_MEDIA_TYPE_THOUSAND_BASE_X
 *                           STKTPLG_TYPE_MEDIA_TYPE_THOUSAND_BASE_T
 *                           STKTPLG_TYPE_MEDIA_TYPE_HUNDRED_BASE_FX_SC_SINGLE_MODE
 *                           STKTPLG_TYPE_MEDIA_TYPE_HUNDRED_BASE_FX_SC_MULTI_MODE
 *                           STKTPLG_TYPE_MEDIA_TYPE_10G_BASE_LR
 *                           STKTPLG_TYPE_MEDIA_TYPE_10G_BASE_ER
 *                           STKTPLG_TYPE_MEDIA_TYPE_10G_BASE_CX4
 *                           STKTPLG_TYPE_MEDIA_TYPE_10G_BASE_X
 * OUTPUT  : capa_bits --    VAL_ifMauAutoNegCapabilityBits_bOther
 *                           VAL_ifMauAutoNegCapabilityBits_b10baseT
 *                           VAL_ifMauAutoNegCapabilityBits_b10baseTFD
 *                           VAL_ifMauAutoNegCapabilityBits_b100baseT4
 *                           VAL_ifMauAutoNegCapabilityBits_b100baseTX
 *                           VAL_ifMauAutoNegCapabilityBits_b100baseTXFD
 *                           VAL_ifMauAutoNegCapabilityBits_b100baseT2
 *                           VAL_ifMauAutoNegCapabilityBits_b100baseT2FD
 *                           VAL_ifMauAutoNegCapabilityBits_bfdxPause
 *                           VAL_ifMauAutoNegCapabilityBits_bfdxAPause
 *                           VAL_ifMauAutoNegCapabilityBits_bfdxSPause
 *                           VAL_ifMauAutoNegCapabilityBits_bfdxBPause
 *                           VAL_ifMauAutoNegCapabilityBits_b1000baseX
 *                           VAL_ifMauAutoNegCapabilityBits_b1000baseXFD
 *                           VAL_ifMauAutoNegCapabilityBits_b1000baseT
 *                           VAL_ifMauAutoNegCapabilityBits_b1000baseTFD
 * RETURN  : None.
 * NOTE    : None.
 * -------------------------------------------------------------------------*/
static void SWCTRL_GetPossibleAutoNegCapBitsByMediaType (UI32_T  media_type,UI32_T *capa_bits)
{
    *capa_bits = 0;

    switch(media_type)
    {
    case STKTPLG_TYPE_MEDIA_TYPE_THOUSAND_BASE_T:
        //*capa_bits |= L_CVRT_SNMP_BIT_VALUE_32(VAL_ifMauAutoNegCapabilityBits_b1000baseT);
        *capa_bits |= L_CVRT_SNMP_BIT_VALUE_32(VAL_ifMauAutoNegCapabilityBits_b1000baseTFD);
        *capa_bits |= L_CVRT_SNMP_BIT_VALUE_32(VAL_ifMauAutoNegCapabilityBits_bfdxAPause);

    case STKTPLG_TYPE_MEDIA_TYPE_HUNDRED_BASE_TX:
        *capa_bits |= L_CVRT_SNMP_BIT_VALUE_32(VAL_ifMauAutoNegCapabilityBits_b10baseT);
        *capa_bits |= L_CVRT_SNMP_BIT_VALUE_32(VAL_ifMauAutoNegCapabilityBits_b10baseTFD);
        *capa_bits |= L_CVRT_SNMP_BIT_VALUE_32(VAL_ifMauAutoNegCapabilityBits_b100baseTX);
        *capa_bits |= L_CVRT_SNMP_BIT_VALUE_32(VAL_ifMauAutoNegCapabilityBits_b100baseTXFD);
        *capa_bits |= L_CVRT_SNMP_BIT_VALUE_32(VAL_ifMauAutoNegCapabilityBits_bfdxPause);
        break;

    case STKTPLG_TYPE_MEDIA_TYPE_HUNDRED_BASE_FX:
    case STKTPLG_TYPE_MEDIA_TYPE_HUNDRED_BASE_FX_SC_SINGLE_MODE:
    case STKTPLG_TYPE_MEDIA_TYPE_HUNDRED_BASE_FX_SC_MULTI_MODE:
        /* 100 fiber: force mode only, no capability
         */
        *capa_bits = 0;
        break;

    case STKTPLG_TYPE_MEDIA_TYPE_THOUSAND_BASE_LX:
    case STKTPLG_TYPE_MEDIA_TYPE_THOUSAND_BASE_SX:
    case STKTPLG_TYPE_MEDIA_TYPE_THOUSAND_BASE_CX:
    case STKTPLG_TYPE_MEDIA_TYPE_THOUSAND_BASE_X:
        *capa_bits |= L_CVRT_SNMP_BIT_VALUE_32(VAL_ifMauAutoNegCapabilityBits_b1000baseXFD);
        *capa_bits |= L_CVRT_SNMP_BIT_VALUE_32(VAL_ifMauAutoNegCapabilityBits_bfdxAPause);
        *capa_bits |= L_CVRT_SNMP_BIT_VALUE_32(VAL_ifMauAutoNegCapabilityBits_bfdxPause);
        break;

    case STKTPLG_TYPE_MEDIA_TYPE_OTHER:
    default:
        /* unknown media type: no nego capability
         */
        *capa_bits = 0;
        break;
    }

    return;
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetAdvAutoNegCapBitsByMediaTypeAndCurrentCapBits
 * -------------------------------------------------------------------------
 * FUNCTION: Get advertisement auto-nego capability bits by media type and
 *           current capability bits.
 * INPUT   : media_type   -- STKTPLG_TYPE_MEDIA_TYPE_HUNDRED_BASE_TX
 *                           STKTPLG_TYPE_MEDIA_TYPE_OTHER
 *                           STKTPLG_TYPE_MEDIA_TYPE_HUNDRED_BASE_TX
 *                           STKTPLG_TYPE_MEDIA_TYPE_HUNDRED_BASE_FX
 *                           STKTPLG_TYPE_MEDIA_TYPE_THOUSAND_BASE_SX
 *                           STKTPLG_TYPE_MEDIA_TYPE_THOUSAND_BASE_LX
 *                           STKTPLG_TYPE_MEDIA_TYPE_THOUSAND_BASE_CX
 *                           STKTPLG_TYPE_MEDIA_TYPE_THOUSAND_BASE_X
 *                           STKTPLG_TYPE_MEDIA_TYPE_THOUSAND_BASE_T
 *                           STKTPLG_TYPE_MEDIA_TYPE_HUNDRED_BASE_FX_SC_SINGLE_MODE
 *                           STKTPLG_TYPE_MEDIA_TYPE_HUNDRED_BASE_FX_SC_MULTI_MODE
 *
 *           currrnt_capa -- SYS_VAL_portCapabilities_portCap10half
 *                           SYS_VAL_portCapabilities_portCap10full
 *                           SYS_VAL_portCapabilities_portCap100half
 *                           SYS_VAL_portCapabilities_portCap100full
 *                           SYS_VAL_portCapabilities_portCap1000half
 *                           SYS_VAL_portCapabilities_portCap1000full
 *                           SYS_VAL_portCapabilities_portCapSym
 *                           SYS_VAL_portCapabilities_portCapFlowCtrl
 *
 * OUTPUT  : capa_bits    -- VAL_ifMauAutoNegCapAdvertisedBits_bOther
 *                           VAL_ifMauAutoNegCapAdvertisedBits_b10baseT
 *                           VAL_ifMauAutoNegCapAdvertisedBits_b10baseTFD
 *                           VAL_ifMauAutoNegCapAdvertisedBits_b100baseT4
 *                           VAL_ifMauAutoNegCapAdvertisedBits_b100baseTX
 *                           VAL_ifMauAutoNegCapAdvertisedBits_b100baseTXFD
 *                           VAL_ifMauAutoNegCapAdvertisedBits_b100baseT2
 *                           VAL_ifMauAutoNegCapAdvertisedBits_b100baseT2FD
 *                           VAL_ifMauAutoNegCapAdvertisedBits_bFdxPause
 *                           VAL_ifMauAutoNegCapAdvertisedBits_bFdxAPause
 *                           VAL_ifMauAutoNegCapAdvertisedBits_bFdxSPause
 *                           VAL_ifMauAutoNegCapAdvertisedBits_bFdxBPause
 *                           VAL_ifMauAutoNegCapAdvertisedBits_b1000baseX
 *                           VAL_ifMauAutoNegCapAdvertisedBits_b1000baseXFD
 *                           VAL_ifMauAutoNegCapAdvertisedBits_b1000baseT
 *                           VAL_ifMauAutoNegCapAdvertisedBits_b1000baseTFD
 * RETURN  : None.
 * NOTE    : None.
 * -------------------------------------------------------------------------*/
static void SWCTRL_GetAdvAutoNegCapBitsByMediaTypeAndCurrentCapBits (UI32_T media_type,
                                                                     UI32_T currrnt_capa,
                                                                     UI32_T *adv_capa)
{
#define GET_BIT_OR_TO_DEST(EXAC_BIT, INJ_SHIFT); \
    if (currrnt_capa & (EXAC_BIT)) {*adv_capa |= L_CVRT_SNMP_BIT_VALUE_32(INJ_SHIFT);}

    *adv_capa = 0;

    switch(media_type)
    {
    case STKTPLG_TYPE_MEDIA_TYPE_THOUSAND_BASE_T:
        GET_BIT_OR_TO_DEST(SYS_VAL_portCapabilities_portCap1000half, VAL_ifMauAutoNegCapAdvertisedBits_b1000baseT);
        GET_BIT_OR_TO_DEST(SYS_VAL_portCapabilities_portCap1000full, VAL_ifMauAutoNegCapAdvertisedBits_b1000baseTFD);
        GET_BIT_OR_TO_DEST(SYS_VAL_portCapabilities_portCap10half,   VAL_ifMauAutoNegCapAdvertisedBits_b10baseT);
        GET_BIT_OR_TO_DEST(SYS_VAL_portCapabilities_portCap10full,   VAL_ifMauAutoNegCapAdvertisedBits_b10baseTFD);
        GET_BIT_OR_TO_DEST(SYS_VAL_portCapabilities_portCap100half,  VAL_ifMauAutoNegCapAdvertisedBits_b100baseTX);
        GET_BIT_OR_TO_DEST(SYS_VAL_portCapabilities_portCap100full,  VAL_ifMauAutoNegCapAdvertisedBits_b100baseTXFD);
        GET_BIT_OR_TO_DEST(SYS_VAL_portCapabilities_portCapSym,      VAL_ifMauAutoNegCapAdvertisedBits_bFdxAPause);
        GET_BIT_OR_TO_DEST(SYS_VAL_portCapabilities_portCapFlowCtrl, VAL_ifMauAutoNegCapAdvertisedBits_bFdxPause);
        break;

    case STKTPLG_TYPE_MEDIA_TYPE_HUNDRED_BASE_TX:
        GET_BIT_OR_TO_DEST(SYS_VAL_portCapabilities_portCap10half,   VAL_ifMauAutoNegCapAdvertisedBits_b10baseT);
        GET_BIT_OR_TO_DEST(SYS_VAL_portCapabilities_portCap10full,   VAL_ifMauAutoNegCapAdvertisedBits_b10baseTFD);
        GET_BIT_OR_TO_DEST(SYS_VAL_portCapabilities_portCap100half,  VAL_ifMauAutoNegCapAdvertisedBits_b100baseTX);
        GET_BIT_OR_TO_DEST(SYS_VAL_portCapabilities_portCap100full,  VAL_ifMauAutoNegCapAdvertisedBits_b100baseTXFD);
        GET_BIT_OR_TO_DEST(SYS_VAL_portCapabilities_portCapFlowCtrl, VAL_ifMauAutoNegCapAdvertisedBits_bFdxPause);
        break;

    case STKTPLG_TYPE_MEDIA_TYPE_THOUSAND_BASE_LX:
    case STKTPLG_TYPE_MEDIA_TYPE_THOUSAND_BASE_SX:
    case STKTPLG_TYPE_MEDIA_TYPE_THOUSAND_BASE_CX:
    case STKTPLG_TYPE_MEDIA_TYPE_THOUSAND_BASE_X:
        GET_BIT_OR_TO_DEST(SYS_VAL_portCapabilities_portCap1000half, VAL_ifMauAutoNegCapAdvertisedBits_b1000baseX);
        GET_BIT_OR_TO_DEST(SYS_VAL_portCapabilities_portCap1000full, VAL_ifMauAutoNegCapAdvertisedBits_b1000baseXFD);
        GET_BIT_OR_TO_DEST(SYS_VAL_portCapabilities_portCapSym,      VAL_ifMauAutoNegCapAdvertisedBits_bFdxAPause);
        GET_BIT_OR_TO_DEST(SYS_VAL_portCapabilities_portCapFlowCtrl, VAL_ifMauAutoNegCapAdvertisedBits_bFdxPause);
        break;

    case STKTPLG_TYPE_MEDIA_TYPE_HUNDRED_BASE_FX:
    case STKTPLG_TYPE_MEDIA_TYPE_HUNDRED_BASE_FX_SC_SINGLE_MODE:
    case STKTPLG_TYPE_MEDIA_TYPE_HUNDRED_BASE_FX_SC_MULTI_MODE:
        /* 100 fiber always force mode, no nego capability
         */
        *adv_capa = 0;
        break;

    case STKTPLG_TYPE_MEDIA_TYPE_OTHER:
    default:
        /* unknown media type: no nego capability
         */
        *adv_capa = 0;
        break;
    }

    return;
}

#endif

#if (SYS_CPNT_SFP_DDM_ALARMWARN_TRAP == TRUE)
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetPortSfpDdmTrapEnable
 * -------------------------------------------------------------------------
 * FUNCTION: Enable/Disable SFP ddm threshold alarm trap
 * INPUT   : ifindex   -- which ifindex
 *           trap_enable -- TRUE/FALSE
 *
 * OUTPUT  : None.
 * RETURN  : TRUE/FALSE
 * NOTE    : None.
 * -------------------------------------------------------------------------
 */
BOOL_T SWCTRL_SetPortSfpDdmTrapEnable(UI32_T ifindex, BOOL_T trap_enable)
{
    SWCTRL_Lport_Type_T lport_type;
    UI32_T  unit, port, trunk_id;
    UI32_T  sfp_index;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    lport_type = SWCTRL_LogicalPortToUserPort(ifindex, &unit, &port, &trunk_id);

    if (SWCTRL_LPORT_UNKNOWN_PORT == lport_type || SWCTRL_LPORT_TRUNK_PORT == lport_type)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    /* 1. normal port
     * 2. trunk member port
     */
    if (FALSE == STKTPLG_POM_UserPortToSfpIndex(unit, port, &sfp_index))
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    SWCTRL_LOCK();
    SWCTRL_OM_SetPortSfpDdmTrapEnable(unit, sfp_index, trap_enable);
    SWCTRL_UNLOCK();

    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetPortSfpDdmTrapEnable
 * -------------------------------------------------------------------------
 * FUNCTION: Get status of SFP ddm threshold alarm trap
 * INPUT   : ifindex   -- which ifindex
 *           trap_enable_p
 *
 * OUTPUT  : None.
 * RETURN  : TRUE/FALSE
 * NOTE    : None.
 * -------------------------------------------------------------------------
 */
BOOL_T SWCTRL_GetPortSfpDdmTrapEnable(UI32_T ifindex, BOOL_T *trap_enable_p)
{
    SWCTRL_Lport_Type_T lport_type;
    UI32_T  unit, port, trunk_id;
    UI32_T  sfp_index;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    lport_type = SWCTRL_LogicalPortToUserPort(ifindex, &unit, &port, &trunk_id);

    if (SWCTRL_LPORT_UNKNOWN_PORT == lport_type || SWCTRL_LPORT_TRUNK_PORT == lport_type)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    /* 1. normal port
     * 2. trunk member port
     */
    if (FALSE == STKTPLG_POM_UserPortToSfpIndex(unit, port, &sfp_index))
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    SWCTRL_LOCK();
    SWCTRL_OM_GetPortSfpDdmTrapEnable(unit, sfp_index, trap_enable_p);
    SWCTRL_UNLOCK();

    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetPortSfpDdmThresholdAutoMode
 * -------------------------------------------------------------------------
 * FUNCTION: Enable/Disable SFP ddm threshold auto mode
 * INPUT   : ifindex   -- which ifindex
 *           auto_mode -- TRUE/FALSE
 *
 * OUTPUT  : None.
 * RETURN  : TRUE/FALSE
 * NOTE    : None.
 * -------------------------------------------------------------------------
 */
BOOL_T SWCTRL_SetPortSfpDdmThresholdAutoMode(UI32_T ifindex, BOOL_T auto_mode)
{
    SWCTRL_Lport_Type_T lport_type;
    UI32_T  unit, port, trunk_id;
    UI32_T  sfp_index;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    lport_type = SWCTRL_LogicalPortToUserPort(ifindex, &unit, &port, &trunk_id);

    if (SWCTRL_LPORT_UNKNOWN_PORT == lport_type || SWCTRL_LPORT_TRUNK_PORT == lport_type)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    /* 1. normal port
     * 2. trunk member port
     */
    if (FALSE == STKTPLG_POM_UserPortToSfpIndex(unit, port, &sfp_index))
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    SWCTRL_LOCK();
    SWCTRL_OM_SetPortSfpDdmThresholdAutoMode(unit, sfp_index, auto_mode);
    SWCTRL_UNLOCK();

    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetPortSfpDdmThresholdAutoMode
 * -------------------------------------------------------------------------
 * FUNCTION: Get status of port sfp ddm threshold auto mode
 *
 * INPUT   : ifindex
 * OUTPUT  : sfp_ddm_threshold_p
 * RETURN  : TRUE/FALSE
 * NOTE    : None
 * -------------------------------------------------------------------------
 */
BOOL_T SWCTRL_GetPortSfpDdmThresholdAutoMode(UI32_T ifindex, BOOL_T *auto_mode_p)
{
    SWCTRL_Lport_Type_T lport_type;
    UI32_T unit, port, trunk_id;
    UI32_T sfp_index;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    lport_type = SWCTRL_LogicalPortToUserPort(ifindex, &unit, &port, &trunk_id);

    if (SWCTRL_LPORT_UNKNOWN_PORT == lport_type || SWCTRL_LPORT_TRUNK_PORT == lport_type)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    /* 1. normal port
     * 2. trunk member port
     */
    if (FALSE == STKTPLG_POM_UserPortToSfpIndex(unit, port, &sfp_index))
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    SWCTRL_LOCK();
    SWCTRL_OM_GetPortSfpDdmThresholdAutoMode(unit, sfp_index, auto_mode_p);
    SWCTRL_UNLOCK();

    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
}
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetPortSfpDdmThresholdDefault
 * -------------------------------------------------------------------------
 * FUNCTION: Set SFP ddm threshold to default
 * INPUT   : ifindex   -- which ifindex
 *           threshold_type -- which threshold_type
 *
 * OUTPUT  : None.
 * RETURN  : TRUE/FALSE
 * NOTE    : None.
 * -------------------------------------------------------------------------
 */
BOOL_T SWCTRL_SetPortSfpDdmThresholdDefault(UI32_T ifindex, UI32_T threshold_type)
{
    SWCTRL_Lport_Type_T lport_type;
    UI32_T  unit, port, trunk_id;
    UI32_T  sfp_index;
    BOOL_T  auto_mode;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    lport_type = SWCTRL_LogicalPortToUserPort(ifindex, &unit, &port, &trunk_id);

    if (SWCTRL_LPORT_UNKNOWN_PORT == lport_type || SWCTRL_LPORT_TRUNK_PORT == lport_type)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    /* 1. normal port
     * 2. trunk member port
     */
    if (FALSE == STKTPLG_POM_UserPortToSfpIndex(unit, port, &sfp_index))
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    SWCTRL_LOCK();
    SWCTRL_OM_GetPortSfpDdmThresholdAutoMode(unit, sfp_index, &auto_mode);
    SWCTRL_UNLOCK();

    if (TRUE == auto_mode)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    SWCTRL_LOCK();
    SWCTRL_OM_SetPortSfpDdmThresholdDefault(unit, sfp_index, threshold_type);
    SWCTRL_UNLOCK();

    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetPortSfpDdmThreshold
 * -------------------------------------------------------------------------
 * FUNCTION: Set SFP ddm threshold
 * INPUT   : ifindex   -- which ifindex
 *           threshold_type -- which threshold_type
 *           value
 *           need_to_check_range -- when cli provision, no need to check range
 * OUTPUT  : None.
 * RETURN  : TRUE/FALSE
 * NOTE    : None.
 * -------------------------------------------------------------------------
 */
BOOL_T SWCTRL_SetPortSfpDdmThreshold(UI32_T ifindex, UI32_T threshold_type, I32_T val, BOOL_T need_to_check_range)
{
    SWCTRL_OM_SfpDdmThreshold_T sfp_ddm_threshold;
    SWCTRL_OM_SfpDdmThresholdInteger_T sfp_ddm_threshold_int;
    SWCTRL_Lport_Type_T lport_type;
    UI32_T  unit, port, trunk_id;
    UI32_T  sfp_index;
    float   float_val;
    BOOL_T  auto_mode;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);
    lport_type = SWCTRL_LogicalPortToUserPort(ifindex, &unit, &port, &trunk_id);

    if (SWCTRL_LPORT_UNKNOWN_PORT == lport_type || SWCTRL_LPORT_TRUNK_PORT == lport_type)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    /* 1. normal port
     * 2. trunk member port
     */
    if (FALSE == STKTPLG_POM_UserPortToSfpIndex(unit, port, &sfp_index))
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    SWCTRL_LOCK();
    SWCTRL_OM_GetPortSfpDdmThresholdAutoMode(unit, sfp_index, &auto_mode);
    SWCTRL_UNLOCK();

    if (TRUE == auto_mode)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    SWCTRL_LOCK();
    SWCTRL_OM_GetPortSfpDdmThreshold(unit, sfp_index, &sfp_ddm_threshold);
    SWCTRL_UNLOCK();

    if(need_to_check_range)
    {
        SWDRV_LIB_ChangeSfpDdmThresholdToInteger(&sfp_ddm_threshold, &sfp_ddm_threshold_int);
        switch(threshold_type)
        {
            /* temperature */
            case VAL_trapSfpThresholdAlarmWarnType_temperatureHighAlarm:
                if(val > SWCTRL_GBIC_DDM_TEMPERATURE_MAX || val < SWCTRL_GBIC_DDM_TEMPERATURE_MIN ||
                        val < sfp_ddm_threshold_int.temp_high_warning)
                {
                    SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
                }
                break;
            case VAL_trapSfpThresholdAlarmWarnType_temperatureHighWarning:
                if(val > SWCTRL_GBIC_DDM_TEMPERATURE_MAX || val < SWCTRL_GBIC_DDM_TEMPERATURE_MIN ||
                        val > sfp_ddm_threshold_int.temp_high_alarm ||
                        val < sfp_ddm_threshold_int.temp_low_warning)
                {
                    SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
                }
                break;
            case VAL_trapSfpThresholdAlarmWarnType_temperatureLowWarning:
                if(val > SWCTRL_GBIC_DDM_TEMPERATURE_MAX || val < SWCTRL_GBIC_DDM_TEMPERATURE_MIN ||
                        val > sfp_ddm_threshold_int.temp_high_warning ||
                        val < sfp_ddm_threshold_int.temp_low_alarm)
                {
                    SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
                }
                break;
            case VAL_trapSfpThresholdAlarmWarnType_temperatureLowAlarm:
                if(val > SWCTRL_GBIC_DDM_TEMPERATURE_MAX || val < SWCTRL_GBIC_DDM_TEMPERATURE_MIN ||
                        val > sfp_ddm_threshold_int.temp_low_warning)
                {
                    SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
                }
                break;

                /* voltage */
            case VAL_trapSfpThresholdAlarmWarnType_voltageHighAlarm:
                if(val > SWCTRL_GBIC_DDM_VOLTAGE_MAX || val < SWCTRL_GBIC_DDM_VOLTAGE_MIN ||
                        val < sfp_ddm_threshold_int.voltage_high_warning)
                    SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
                break;
            case VAL_trapSfpThresholdAlarmWarnType_voltageHighWarning:
                if(val > SWCTRL_GBIC_DDM_VOLTAGE_MAX || val < SWCTRL_GBIC_DDM_VOLTAGE_MIN ||
                        val > sfp_ddm_threshold_int.voltage_high_alarm ||
                        val < sfp_ddm_threshold_int.voltage_low_warning)
                    SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
                break;
            case VAL_trapSfpThresholdAlarmWarnType_voltageLowWarning:
                if(val > SWCTRL_GBIC_DDM_VOLTAGE_MAX || val < SWCTRL_GBIC_DDM_VOLTAGE_MIN ||
                        val > sfp_ddm_threshold_int.voltage_high_warning ||
                        val < sfp_ddm_threshold_int.voltage_low_alarm)
                    SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
                break;
            case VAL_trapSfpThresholdAlarmWarnType_voltageLowAlarm:
                if(val > SWCTRL_GBIC_DDM_VOLTAGE_MAX || val < SWCTRL_GBIC_DDM_VOLTAGE_MIN ||
                        val > sfp_ddm_threshold_int.voltage_low_warning)
                    SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
                break;

                /* current */
            case VAL_trapSfpThresholdAlarmWarnType_currentHighAlarm:
                if(val > SWCTRL_GBIC_DDM_CURRENT_MAX || val < SWCTRL_GBIC_DDM_CURRENT_MIN ||
                        val < sfp_ddm_threshold_int.bias_high_warning)
                    SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
                break;
            case VAL_trapSfpThresholdAlarmWarnType_currentHighWarning:
                if(val > SWCTRL_GBIC_DDM_CURRENT_MAX || val < SWCTRL_GBIC_DDM_CURRENT_MIN ||
                        val > sfp_ddm_threshold_int.bias_high_alarm ||
                        val < sfp_ddm_threshold_int.bias_low_warning)
                    SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
                break;
            case VAL_trapSfpThresholdAlarmWarnType_currentLowWarning:
                if(val > SWCTRL_GBIC_DDM_CURRENT_MAX || val < SWCTRL_GBIC_DDM_CURRENT_MIN ||
                        val > sfp_ddm_threshold_int.bias_high_warning ||
                        val < sfp_ddm_threshold_int.bias_low_alarm)
                    SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
                break;
            case VAL_trapSfpThresholdAlarmWarnType_currentLowAlarm:
                if(val > SWCTRL_GBIC_DDM_CURRENT_MAX || val < SWCTRL_GBIC_DDM_CURRENT_MIN ||
                        val > sfp_ddm_threshold_int.bias_low_warning)
                    SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
                break;

                /* tx power */
            case VAL_trapSfpThresholdAlarmWarnType_txPowerHighAlarm:
                if(val > SWCTRL_GBIC_DDM_TX_POWER_MAX || val < SWCTRL_GBIC_DDM_TX_POWER_MIN ||
                        val < sfp_ddm_threshold_int.tx_power_high_warning)
                    SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
                break;
            case VAL_trapSfpThresholdAlarmWarnType_txPowerHighWarning:
                if(val > SWCTRL_GBIC_DDM_TX_POWER_MAX || val < SWCTRL_GBIC_DDM_TX_POWER_MIN ||
                        val > sfp_ddm_threshold_int.tx_power_high_alarm ||
                        val < sfp_ddm_threshold_int.tx_power_low_warning)
                    SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
                break;
            case VAL_trapSfpThresholdAlarmWarnType_txPowerLowWarning:
                if(val > SWCTRL_GBIC_DDM_TX_POWER_MAX || val < SWCTRL_GBIC_DDM_TX_POWER_MIN ||
                        val > sfp_ddm_threshold_int.tx_power_high_warning ||
                        val < sfp_ddm_threshold_int.tx_power_low_alarm)
                    SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
                break;
            case VAL_trapSfpThresholdAlarmWarnType_txPowerLowAlarm:
                if(val > SWCTRL_GBIC_DDM_TX_POWER_MAX || val < SWCTRL_GBIC_DDM_TX_POWER_MIN ||
                        val > sfp_ddm_threshold_int.tx_power_low_warning)
                    SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
                break;

                /* rx power */
            case VAL_trapSfpThresholdAlarmWarnType_rxPowerHighAlarm:
                if(val > SWCTRL_GBIC_DDM_RX_POWER_MAX || val < SWCTRL_GBIC_DDM_RX_POWER_MIN ||
                        val < sfp_ddm_threshold_int.rx_power_high_warning)
                    SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
                break;
            case VAL_trapSfpThresholdAlarmWarnType_rxPowerHighWarning:
                if(val > SWCTRL_GBIC_DDM_RX_POWER_MAX || val < SWCTRL_GBIC_DDM_RX_POWER_MIN ||
                        val > sfp_ddm_threshold_int.rx_power_high_alarm ||
                        val < sfp_ddm_threshold_int.rx_power_low_warning)
                    SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
                break;
            case VAL_trapSfpThresholdAlarmWarnType_rxPowerLowWarning:
                if(val > SWCTRL_GBIC_DDM_RX_POWER_MAX || val < SWCTRL_GBIC_DDM_RX_POWER_MIN ||
                        val > sfp_ddm_threshold_int.rx_power_high_warning ||
                        val < sfp_ddm_threshold_int.rx_power_low_alarm)
                    SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
                break;
            case VAL_trapSfpThresholdAlarmWarnType_rxPowerLowAlarm:
                if(val > SWCTRL_GBIC_DDM_RX_POWER_MAX || val < SWCTRL_GBIC_DDM_RX_POWER_MIN ||
                        val > sfp_ddm_threshold_int.rx_power_low_warning)
                    SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
                break;

            default:
                SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
        }
    }

    float_val = (float)val;/* unit of CLI/SNMP/Web is 100 times than stored in om */
    float_val /= 100;
    SWCTRL_LOCK();
    SWCTRL_OM_SetPortSfpDdmThreshold(unit, sfp_index, threshold_type, float_val);
    SWCTRL_UNLOCK();

    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetPortSfpDdmThresholdForWeb
 * -------------------------------------------------------------------------
 * FUNCTION: Set SFP ddm threshold
 * INPUT   : ifindex   -- which ifindex
 *           threshold_type -- which threshold_type
 *           high_alarm
 *           high_warning
 *           low_warning
 *           low_alarm
 * OUTPUT  : None.
 * RETURN  : TRUE/FALSE
 * NOTE    : None.
 * -------------------------------------------------------------------------
 */
BOOL_T SWCTRL_SetPortSfpDdmThresholdForWeb(UI32_T ifindex, UI32_T threshold_type, I32_T high_alarm, I32_T high_warning, I32_T low_warning, I32_T low_alarm)
{
    SWCTRL_Lport_Type_T lport_type;
    UI32_T  unit, port, trunk_id;
    UI32_T  sfp_index;
    float   f1, f2, f3, f4;
    BOOL_T  auto_mode;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);
    lport_type = SWCTRL_LogicalPortToUserPort(ifindex, &unit, &port, &trunk_id);

    if (SWCTRL_LPORT_UNKNOWN_PORT == lport_type || SWCTRL_LPORT_TRUNK_PORT == lport_type)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    /* 1. normal port
     * 2. trunk member port
     */
    if (FALSE == STKTPLG_POM_UserPortToSfpIndex(unit, port, &sfp_index))
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    SWCTRL_LOCK();
    SWCTRL_OM_GetPortSfpDdmThresholdAutoMode(unit, sfp_index, &auto_mode);
    SWCTRL_UNLOCK();

    if (TRUE == auto_mode)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if(high_alarm   < high_warning ||
       high_warning < low_warning  ||
       low_warning  < low_alarm)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
    }

    switch(threshold_type)
    {
        /* temperature */
        case VAL_trapSfpThresholdAlarmWarnType_temperatureHighAlarm:
        case VAL_trapSfpThresholdAlarmWarnType_temperatureHighWarning:
        case VAL_trapSfpThresholdAlarmWarnType_temperatureLowWarning:
        case VAL_trapSfpThresholdAlarmWarnType_temperatureLowAlarm:
            if(high_alarm   > SWCTRL_GBIC_DDM_TEMPERATURE_MAX ||
               high_warning > SWCTRL_GBIC_DDM_TEMPERATURE_MAX ||
               low_warning  > SWCTRL_GBIC_DDM_TEMPERATURE_MAX ||
               low_alarm    > SWCTRL_GBIC_DDM_TEMPERATURE_MAX ||
               high_alarm   < SWCTRL_GBIC_DDM_TEMPERATURE_MIN ||
               high_warning < SWCTRL_GBIC_DDM_TEMPERATURE_MIN ||
               low_warning  < SWCTRL_GBIC_DDM_TEMPERATURE_MIN ||
               low_alarm    < SWCTRL_GBIC_DDM_TEMPERATURE_MIN)
            {
                SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
            }
            break;
            /* voltage */
        case VAL_trapSfpThresholdAlarmWarnType_voltageHighAlarm:
        case VAL_trapSfpThresholdAlarmWarnType_voltageHighWarning:
        case VAL_trapSfpThresholdAlarmWarnType_voltageLowWarning:
        case VAL_trapSfpThresholdAlarmWarnType_voltageLowAlarm:
            if(high_alarm   > SWCTRL_GBIC_DDM_VOLTAGE_MAX ||
               high_warning > SWCTRL_GBIC_DDM_VOLTAGE_MAX ||
               low_warning  > SWCTRL_GBIC_DDM_VOLTAGE_MAX ||
               low_alarm    > SWCTRL_GBIC_DDM_VOLTAGE_MAX ||
               high_alarm   < SWCTRL_GBIC_DDM_VOLTAGE_MIN ||
               high_warning < SWCTRL_GBIC_DDM_VOLTAGE_MIN ||
               low_warning  < SWCTRL_GBIC_DDM_VOLTAGE_MIN ||
               low_alarm    < SWCTRL_GBIC_DDM_VOLTAGE_MIN)
            {
                SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
            }
            break;
            /* current */
        case VAL_trapSfpThresholdAlarmWarnType_currentHighAlarm:
        case VAL_trapSfpThresholdAlarmWarnType_currentHighWarning:
        case VAL_trapSfpThresholdAlarmWarnType_currentLowWarning:
        case VAL_trapSfpThresholdAlarmWarnType_currentLowAlarm:
            if(high_alarm   > SWCTRL_GBIC_DDM_CURRENT_MAX ||
               high_warning > SWCTRL_GBIC_DDM_CURRENT_MAX ||
               low_warning  > SWCTRL_GBIC_DDM_CURRENT_MAX ||
               low_alarm    > SWCTRL_GBIC_DDM_CURRENT_MAX ||
               high_alarm   < SWCTRL_GBIC_DDM_CURRENT_MIN ||
               high_warning < SWCTRL_GBIC_DDM_CURRENT_MIN ||
               low_warning  < SWCTRL_GBIC_DDM_CURRENT_MIN ||
               low_alarm    < SWCTRL_GBIC_DDM_CURRENT_MIN)
            {
                SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
            }
            break;
            /* tx power */
        case VAL_trapSfpThresholdAlarmWarnType_txPowerHighAlarm:
        case VAL_trapSfpThresholdAlarmWarnType_txPowerHighWarning:
        case VAL_trapSfpThresholdAlarmWarnType_txPowerLowWarning:
        case VAL_trapSfpThresholdAlarmWarnType_txPowerLowAlarm:
            if(high_alarm   > SWCTRL_GBIC_DDM_TX_POWER_MAX ||
               high_warning > SWCTRL_GBIC_DDM_TX_POWER_MAX ||
               low_warning  > SWCTRL_GBIC_DDM_TX_POWER_MAX ||
               low_alarm    > SWCTRL_GBIC_DDM_TX_POWER_MAX ||
               high_alarm   < SWCTRL_GBIC_DDM_TX_POWER_MIN ||
               high_warning < SWCTRL_GBIC_DDM_TX_POWER_MIN ||
               low_warning  < SWCTRL_GBIC_DDM_TX_POWER_MIN ||
               low_alarm    < SWCTRL_GBIC_DDM_TX_POWER_MIN)
            {
                SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
            }
            break;
            /* rx power */
        case VAL_trapSfpThresholdAlarmWarnType_rxPowerHighAlarm:
        case VAL_trapSfpThresholdAlarmWarnType_rxPowerHighWarning:
        case VAL_trapSfpThresholdAlarmWarnType_rxPowerLowWarning:
        case VAL_trapSfpThresholdAlarmWarnType_rxPowerLowAlarm:
            if(high_alarm   > SWCTRL_GBIC_DDM_RX_POWER_MAX ||
               high_warning > SWCTRL_GBIC_DDM_RX_POWER_MAX ||
               low_warning  > SWCTRL_GBIC_DDM_RX_POWER_MAX ||
               low_alarm    > SWCTRL_GBIC_DDM_RX_POWER_MAX ||
               high_alarm   < SWCTRL_GBIC_DDM_RX_POWER_MIN ||
               high_warning < SWCTRL_GBIC_DDM_RX_POWER_MIN ||
               low_warning  < SWCTRL_GBIC_DDM_RX_POWER_MIN ||
               low_alarm    < SWCTRL_GBIC_DDM_RX_POWER_MIN)
            {
                SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
            }
            break;
        default:
            SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
    }

    f1 = (float)high_alarm;/* unit of CLI/SNMP/Web is 100 times than stored in om */
    f1 /= 100;
    f2 = (float)high_warning;/* unit of CLI/SNMP/Web is 100 times than stored in om */
    f2 /= 100;
    f3 = (float)low_warning;/* unit of CLI/SNMP/Web is 100 times than stored in om */
    f3 /= 100;
    f4 = (float)low_alarm;/* unit of CLI/SNMP/Web is 100 times than stored in om */
    f4 /= 100;
    SWCTRL_LOCK();
    SWCTRL_OM_SetPortSfpDdmThresholdForWeb(unit, sfp_index, threshold_type, f1, f2, f3, f4);
    SWCTRL_UNLOCK();

    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
}
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetPortSfpDdmThreshold
 * -------------------------------------------------------------------------
 * FUNCTION: Set SFP ddm threshold
 * INPUT   : ifindex
 *           sfp_ddm_threshold_p
 * OUTPUT  : None.
 * RETURN  : TRUE/FALSE
 * NOTE    : used when ddm auto_mode is enabled
 * -------------------------------------------------------------------------
 */
BOOL_T SWCTRL_SetPortSfpDdmThresholdAll(UI32_T ifindex, SWCTRL_OM_SfpDdmThreshold_T *sfp_ddm_threshold_p)
{
    SWCTRL_Lport_Type_T lport_type;
    UI32_T  unit, port, trunk_id;
    UI32_T  sfp_index;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);
    lport_type = SWCTRL_LogicalPortToUserPort(ifindex, &unit, &port, &trunk_id);

    if (SWCTRL_LPORT_UNKNOWN_PORT == lport_type || SWCTRL_LPORT_TRUNK_PORT == lport_type)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    /* 1. normal port
     * 2. trunk member port
     */
    if (FALSE == STKTPLG_POM_UserPortToSfpIndex(unit, port, &sfp_index))
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    SWCTRL_LOCK();
    SWCTRL_OM_SetPortSfpDdmThresholdAll(unit, sfp_index, sfp_ddm_threshold_p);
    SWCTRL_UNLOCK();

    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
}
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetPortSfpDdmThreshold
 * -------------------------------------------------------------------------
 * FUNCTION: Get port sfp ddm threshold
 *
 * INPUT   : ifindex
 * OUTPUT  : sfp_ddm_threshold_p
 * RETURN  : TRUE/FALSE
 * NOTE    : None
 * -------------------------------------------------------------------------
 */
BOOL_T SWCTRL_GetPortSfpDdmThreshold(UI32_T ifindex, SWCTRL_OM_SfpDdmThreshold_T *sfp_ddm_threshold_p)
{
    SWCTRL_Lport_Type_T lport_type;
    UI32_T unit, port, trunk_id;
    UI32_T sfp_index;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (NULL == sfp_ddm_threshold_p)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    lport_type = SWCTRL_LogicalPortToUserPort(ifindex, &unit, &port, &trunk_id);

    if (SWCTRL_LPORT_UNKNOWN_PORT == lport_type || SWCTRL_LPORT_TRUNK_PORT == lport_type)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    /* 1. normal port
     * 2. trunk member port
     */
    if (FALSE == STKTPLG_POM_UserPortToSfpIndex(unit, port, &sfp_index))
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    SWCTRL_LOCK();
    SWCTRL_OM_GetPortSfpDdmThreshold(unit, sfp_index, sfp_ddm_threshold_p);
    SWCTRL_UNLOCK();

    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetPortSfpDdmThresholdEntry
 * -------------------------------------------------------------------------
 * FUNCTION: Get port sfp ddm threshold
 *
 * INPUT   : ifindex
 * OUTPUT  : sfp_ddm_threshold_entry_p
 * RETURN  : TRUE/FALSE
 * NOTE    : None
 * -------------------------------------------------------------------------
 */
BOOL_T SWCTRL_GetPortSfpDdmThresholdEntry(UI32_T ifindex, SWCTRL_OM_SfpDdmThresholdEntry_T *sfp_ddm_threshold_entry_p)
{
    SWCTRL_Lport_Type_T lport_type;
    UI32_T unit, port, trunk_id;
    UI32_T sfp_index;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (NULL == sfp_ddm_threshold_entry_p)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    lport_type = SWCTRL_LogicalPortToUserPort(ifindex, &unit, &port, &trunk_id);

    if (SWCTRL_LPORT_UNKNOWN_PORT == lport_type || SWCTRL_LPORT_TRUNK_PORT == lport_type)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    /* 1. normal port
     * 2. trunk member port
     */
    if (FALSE == STKTPLG_POM_UserPortToSfpIndex(unit, port, &sfp_index))
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    SWCTRL_LOCK();
    SWCTRL_OM_GetPortSfpDdmThreshold(unit, sfp_index, &sfp_ddm_threshold_entry_p->threshold);
    SWCTRL_OM_GetPortSfpDdmThresholdAutoMode(unit, sfp_index, &sfp_ddm_threshold_entry_p->auto_mode);
    SWCTRL_OM_GetPortSfpDdmTrapEnable(unit, sfp_index, &sfp_ddm_threshold_entry_p->trap_enable);
    SWCTRL_UNLOCK();
    SWDRV_LIB_ChangeSfpDdmThresholdToInteger(&sfp_ddm_threshold_entry_p->threshold, &sfp_ddm_threshold_entry_p->threshold_int);

    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetNextPortSfpDdmThresholdEntry
 * -------------------------------------------------------------------------
 * FUNCTION: Get port sfp ddm threshold, auto_mode, and trap_enable
 * INPUT   : lport_p : Logical port num
 * OUTPUT  : SWCTRL_OM_SfpDdmThresholdEntry_T *sfp_ddm_threshold_entry_p
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : If tranceiver is not present, return FALSE.
 * -------------------------------------------------------------------------
 */
BOOL_T SWCTRL_GetNextPortSfpDdmThresholdEntry(UI32_T *lport_p, SWCTRL_OM_SfpDdmThresholdEntry_T *sfp_ddm_threshold_entry_p)
{
    UI32_T unit, port, trunk_id;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if( lport_p == 0 || sfp_ddm_threshold_entry_p == 0 )
    {
        EH_MGR_Handle_Exception (SYS_MODULE_SWCTRL,
                                 SWCTRL_NO_USE_FUNC_NO,
                                 EH_TYPE_MSG_NULL_POINTER,
                                 EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_CRIT); /*SWCTRL_ENO_NULL_POINTER*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (!SWCTRL_IS_USER_PORT(*lport_p))
    {
        while(*lport_p <= SYS_ADPT_TOTAL_NBR_OF_LPORT)
        {
            if (SWCTRL_IS_USER_PORT(*lport_p))
                break;
            else
                (*lport_p)++;
        }

        if (*lport_p > SYS_ADPT_TOTAL_NBR_OF_LPORT)
        {
            SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
        }
        unit = SWCTRL_IFINDEX_TO_UNIT(*lport_p);
        port = SWCTRL_IFINDEX_TO_PORT(*lport_p)-1;
    }
    else
    {
        unit = SWCTRL_IFINDEX_TO_UNIT(*lport_p);
        port = SWCTRL_IFINDEX_TO_PORT(*lport_p);
    }

    while(TRUE == STKTPLG_OM_GetNextSfpPortByUnitPort(&unit, &port))
    {
        *lport_p = SWCTRL_UPORT_TO_IFINDEX(unit, port);
        sfp_ddm_threshold_entry_p->ifindex = *lport_p;
        if(TRUE == SWCTRL_GetPortSfpDdmThresholdEntry(*lport_p, sfp_ddm_threshold_entry_p))
        {
            SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
        }
        else
        {
            /* when SFP is not present.
             */
            continue;
        }
    }

    SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetPortSfpDdmThresholdStatus
 * -------------------------------------------------------------------------
 * FUNCTION: Get port sfp ddm threshold status
 *
 * INPUT   : ifindex
 * OUTPUT  : sfp_ddm_threshold_status_p
 * RETURN  : TRUE/FALSE
 * NOTE    : None
 * -------------------------------------------------------------------------
 */
BOOL_T SWCTRL_GetPortSfpDdmThresholdStatus(UI32_T ifindex, SWCTRL_OM_SfpDdmThresholdStatus_T *sfp_ddm_threshold_status_p)
{
    SWCTRL_Lport_Type_T lport_type;
    UI32_T unit, port, trunk_id;
    UI32_T sfp_index;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (NULL == sfp_ddm_threshold_status_p)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    lport_type = SWCTRL_LogicalPortToUserPort(ifindex, &unit, &port, &trunk_id);

    if (SWCTRL_LPORT_UNKNOWN_PORT == lport_type || SWCTRL_LPORT_TRUNK_PORT == lport_type)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    /* 1. normal port
     * 2. trunk member port
     */
    if (FALSE == STKTPLG_POM_UserPortToSfpIndex(unit, port, &sfp_index))
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    SWCTRL_LOCK();
    SWCTRL_OM_GetPortSfpDdmThresholdStatus(unit, sfp_index, sfp_ddm_threshold_status_p);
    SWCTRL_UNLOCK();

    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
}
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetRunningPortSfpDdmThresholdEntry
 * -------------------------------------------------------------------------
 * FUNCTION: Get running config of sfp ddm threshold
 * INPUT   : ifindex
 * OUTPUT  : ddm_threshold_p
 * RETURN  : SYS_TYPE_Get_Running_Cfg_T
 * NOTE    : None
 * -------------------------------------------------------------------------
 */
SYS_TYPE_Get_Running_Cfg_T SWCTRL_GetRunningPortSfpDdmThresholdEntry(UI32_T ifindex, SWCTRL_OM_SfpDdmThresholdEntry_T *sfp_ddm_threshold_entry_p)
{
    SWCTRL_Lport_Type_T lport_type;
    UI32_T  unit, port, trunk_id;
    UI32_T  sfp_index;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(SYS_TYPE_GET_RUNNING_CFG_FAIL);

    lport_type = SWCTRL_LogicalPortToUserPort(ifindex, &unit, &port, &trunk_id);

    if (SWCTRL_LPORT_UNKNOWN_PORT == lport_type || SWCTRL_LPORT_TRUNK_PORT == lport_type)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_FAIL );
    }

    /* 1. normal port
     * 2. trunk member port
     */
    if (FALSE == STKTPLG_POM_UserPortToSfpIndex(unit, port, &sfp_index))
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_FAIL );
    }

    SWCTRL_LOCK();
    SWCTRL_OM_GetPortSfpDdmTrapEnable(unit, sfp_index, &sfp_ddm_threshold_entry_p->trap_enable);
    SWCTRL_OM_GetPortSfpDdmThresholdAutoMode(unit, sfp_index, &sfp_ddm_threshold_entry_p->auto_mode);
    SWCTRL_OM_GetPortSfpDdmThreshold(unit, sfp_index, &sfp_ddm_threshold_entry_p->threshold);
    SWCTRL_UNLOCK();
    SWDRV_LIB_ChangeSfpDdmThresholdToInteger(&sfp_ddm_threshold_entry_p->threshold, &sfp_ddm_threshold_entry_p->threshold_int);

    if (sfp_ddm_threshold_entry_p->trap_enable != SYS_DFLT_SFP_DDM_ALARMWARN_TRAP_STATUS)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_SUCCESS );
    }
    if (sfp_ddm_threshold_entry_p->auto_mode != SYS_DFLT_SFP_DDM_ALARMWARN_AUTO_MODE)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_SUCCESS );
    }

    /* rx power */
    if (sfp_ddm_threshold_entry_p->threshold.rx_power_high_alarm != SYS_DFLT_SFP_THRESHOLD_RX_POWER_HIGH_ALARM)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_SUCCESS );
    }
    if (sfp_ddm_threshold_entry_p->threshold.rx_power_low_alarm != SYS_DFLT_SFP_THRESHOLD_RX_POWER_LOW_ALARM)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_SUCCESS );
    }
    if (sfp_ddm_threshold_entry_p->threshold.rx_power_high_warning != SYS_DFLT_SFP_THRESHOLD_RX_POWER_HIGH_WARNING)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_SUCCESS );
    }
    if (sfp_ddm_threshold_entry_p->threshold.rx_power_low_warning != SYS_DFLT_SFP_THRESHOLD_RX_POWER_LOW_WARNING)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_SUCCESS );
    }
    /* tx power */
    if (sfp_ddm_threshold_entry_p->threshold.tx_power_high_alarm != SYS_DFLT_SFP_THRESHOLD_TX_POWER_HIGH_ALARM)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_SUCCESS );
    }
    if (sfp_ddm_threshold_entry_p->threshold.tx_power_low_alarm != SYS_DFLT_SFP_THRESHOLD_TX_POWER_LOW_ALARM)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_SUCCESS );
    }
    if (sfp_ddm_threshold_entry_p->threshold.tx_power_high_warning != SYS_DFLT_SFP_THRESHOLD_TX_POWER_HIGH_WARNING)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_SUCCESS );
    }
    if (sfp_ddm_threshold_entry_p->threshold.tx_power_low_warning != SYS_DFLT_SFP_THRESHOLD_TX_POWER_LOW_WARNING)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_SUCCESS );
    }
    /* temperature */
    if (sfp_ddm_threshold_entry_p->threshold.temp_high_alarm != SYS_DFLT_SFP_THRESHOLD_TEMP_HIGH_ALARM)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_SUCCESS );
    }
    if (sfp_ddm_threshold_entry_p->threshold.temp_low_alarm != SYS_DFLT_SFP_THRESHOLD_TEMP_LOW_ALARM)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_SUCCESS );
    }
    if (sfp_ddm_threshold_entry_p->threshold.temp_high_warning != SYS_DFLT_SFP_THRESHOLD_TEMP_HIGH_WARNING)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_SUCCESS );
    }
    if (sfp_ddm_threshold_entry_p->threshold.temp_low_warning != SYS_DFLT_SFP_THRESHOLD_TEMP_LOW_WARNING)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_SUCCESS );
    }
    /* voltage */
    if (sfp_ddm_threshold_entry_p->threshold.voltage_high_alarm != SYS_DFLT_SFP_THRESHOLD_VOLTAGE_HIGH_ALARM)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_SUCCESS );
    }
    if (sfp_ddm_threshold_entry_p->threshold.voltage_low_alarm != SYS_DFLT_SFP_THRESHOLD_VOLTAGE_LOW_ALARM)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_SUCCESS );
    }
    if (sfp_ddm_threshold_entry_p->threshold.voltage_high_warning != SYS_DFLT_SFP_THRESHOLD_VOLTAGE_HIGH_WARNING)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_SUCCESS );
    }
    if (sfp_ddm_threshold_entry_p->threshold.voltage_low_warning != SYS_DFLT_SFP_THRESHOLD_VOLTAGE_LOW_WARNING)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_SUCCESS );
    }
    /* current */
    if (sfp_ddm_threshold_entry_p->threshold.bias_high_alarm != SYS_DFLT_SFP_THRESHOLD_BIAS_HIGH_ALARM)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_SUCCESS );
    }
    if (sfp_ddm_threshold_entry_p->threshold.bias_low_alarm != SYS_DFLT_SFP_THRESHOLD_BIAS_LOW_ALARM)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_SUCCESS );
    }
    if (sfp_ddm_threshold_entry_p->threshold.bias_high_warning != SYS_DFLT_SFP_THRESHOLD_BIAS_HIGH_WARNING)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_SUCCESS );
    }
    if (sfp_ddm_threshold_entry_p->threshold.bias_low_warning != SYS_DFLT_SFP_THRESHOLD_BIAS_LOW_WARNING)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_SUCCESS );
    }
    SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_NO_CHANGE );
}
#endif /* #if (SYS_CPNT_SFP_DDM_ALARMWARN_TRAP == TRUE) */

#if (SYS_CPNT_COMBO_PORT_FORCE_MODE == TRUE)
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetSupportedPortComboForcedMode_Local
 * -------------------------------------------------------------------------
 * FUNCTION: This function will get supported port force link medium
 * INPUT   : ifindex       -- which port to set
 * OUTPUT  : None
 * RETURN  : Bitmap of VAL_portComboForcedMode_xxx
 * NOTE    : None
 * -------------------------------------------------------------------------*/
static UI32_T SWCTRL_GetSupportedPortComboForcedMode_Local(UI32_T ifindex)
{
    UI32_T unit, port;
    UI32_T media_cap;
    UI32_T port_type;
    UI32_T forcedmode_bmp = BIT_VALUE(VAL_portComboForcedMode_none);

    if (!SWCTRL_IS_USER_PORT(ifindex))
    {
        return forcedmode_bmp;
    }

    unit = SWCTRL_IFINDEX_TO_UNIT(ifindex);
    port = SWCTRL_IFINDEX_TO_PORT(ifindex);

    if (!STKTPLG_POM_GetPortMediaCapability(unit, port, &media_cap))
    {
        return forcedmode_bmp;
    }

    port_type = port_info[ifindex-1].port_entry.port_type;

    if ((media_cap & STKTPLG_TYPE_PORT_MEDIA_CAP_COPPER) && (media_cap & STKTPLG_TYPE_PORT_MEDIA_CAP_FIBER))
    {
        forcedmode_bmp =
            BIT_VALUE(VAL_portComboForcedMode_copperForced) |
            BIT_VALUE(VAL_portComboForcedMode_sfpForced) |
            BIT_VALUE(VAL_portComboForcedMode_sfpPreferredAuto);
    }
#if (SYS_CPNT_COMBO_PORT_FORCED_MODE_SFP_SPEED == TRUE)
    else if ((media_cap & STKTPLG_TYPE_PORT_MEDIA_CAP_FIBER))
    {
        if (port_type == VAL_portType_hundredBaseFX ||
            port_type == VAL_portType_thousandBaseSfp)
        {
            forcedmode_bmp =
                BIT_VALUE(VAL_portComboForcedMode_none) |
                BIT_VALUE(VAL_portComboForcedMode_sfpForced);
        }
    }
#endif

    return forcedmode_bmp;
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetSupportedPortComboForcedMode
 * -------------------------------------------------------------------------
 * FUNCTION: This function will get supported port force link medium
 * INPUT   : ifindex       -- which port to set
 * OUTPUT  : None
 * RETURN  : Bitmap of VAL_portComboForcedMode_xxx
 * NOTE    : None
 * -------------------------------------------------------------------------*/
UI32_T SWCTRL_GetSupportedPortComboForcedMode(UI32_T ifindex)
{
    UI32_T forcedmode_bmp = BIT_VALUE(VAL_portComboForcedMode_none);

    SWCTRL_USE_CSC_CHECK_OPER_MODE( forcedmode_bmp );

    if (!SWCTRL_IS_USER_PORT(ifindex))
    {
        return forcedmode_bmp;
    }

    SWCTRL_LOCK();

#if (SWCTRL_UPDATE_PORT_ABILITY == TRUE)
    forcedmode_bmp = user_ext_port_info[ifindex-1].port_abililty.medium_forced_mode_supported;
#else
    forcedmode_bmp = SWCTRL_GetSupportedPortComboForcedMode_Local(ifindex);
#endif

    SWCTRL_UNLOCK();

    SWCTRL_RETURN_AND_RELEASE_CSC( forcedmode_bmp );
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetDefaultPortComboForcedMode
 * -------------------------------------------------------------------------
 * FUNCTION: This function will get default port force link medium
 * INPUT   : ifindex       -- which port to set
 * OUTPUT  : forcedmode_p  -- which mode of medium
 * RETURN  : TRUE/FALSE
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_GetDefaultPortComboForcedMode(UI32_T ifindex, UI32_T *forcedmode_p)
{
#if (SWCTRL_UPDATE_PORT_ABILITY == TRUE)
    UI32_T unit, port;

    SWCTRL_USE_CSC_CHECK_OPER_MODE( FALSE );

    if (!SWCTRL_IS_USER_PORT(ifindex))
    {
        *forcedmode_p = VAL_portComboForcedMode_none;
        return TRUE;
    }

    unit = SWCTRL_IFINDEX_TO_UNIT(ifindex);
    port = SWCTRL_IFINDEX_TO_PORT(ifindex);

    SWCTRL_LOCK();

    SWCTRL_GetPortComboForcedModeDfltCfg(unit, port, forcedmode_p, NULL);

    SWCTRL_UNLOCK();
#else /* (SWCTRL_UPDATE_PORT_ABILITY == TRUE) */
    UI32_T forcedmode_bmp = 0;

    SWCTRL_USE_CSC_CHECK_OPER_MODE( FALSE );

    if (!SWCTRL_IS_USER_PORT(ifindex))
    {
        *forcedmode_p = VAL_portComboForcedMode_none;
        return TRUE;
    }

    SWCTRL_LOCK();

    forcedmode_bmp = SWCTRL_GetSupportedPortComboForcedMode_Local(ifindex);

    if ((forcedmode_bmp & BIT_VALUE(SYS_DFLT_COMBO_PORT_FORCED_MODE)))
    {
        *forcedmode_p = SYS_DFLT_COMBO_PORT_FORCED_MODE;
    }
    else
    {
        *forcedmode_p = VAL_portComboForcedMode_none;
    }

    SWCTRL_UNLOCK();
#endif /* (SWCTRL_UPDATE_PORT_ABILITY == TRUE) */

    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
}

#if (SYS_CPNT_COMBO_PORT_FORCED_MODE_SFP_SPEED == TRUE)
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetDefaultPortComboForcedModeSfpSpeed
 * -------------------------------------------------------------------------
 * FUNCTION: This function will get default fiber medium speed
 * INPUT   : ifindex       -- which port to set
 * OUTPUT  : fiber_speed_p -- which mode of medium
 * RETURN  : TRUE/FALSE
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_GetDefaultPortComboForcedModeSfpSpeed(UI32_T ifindex, UI32_T *fiber_speed_p)
{
#if (SWCTRL_UPDATE_PORT_ABILITY == TRUE)
    UI32_T unit, port;

    SWCTRL_USE_CSC_CHECK_OPER_MODE( FALSE );

    if (!SWCTRL_IS_USER_PORT(ifindex))
    {
        *fiber_speed_p = VAL_portType_other;
        return TRUE;
    }

    unit = SWCTRL_IFINDEX_TO_UNIT(ifindex);
    port = SWCTRL_IFINDEX_TO_PORT(ifindex);

    SWCTRL_LOCK();

    SWCTRL_GetPortComboForcedModeDfltCfg(unit, port, NULL, fiber_speed_p);

    SWCTRL_UNLOCK();
#else /* (SWCTRL_UPDATE_PORT_ABILITY == TRUE) */
    SWCTRL_USE_CSC_CHECK_OPER_MODE( FALSE );

    if (!SWCTRL_IS_USER_PORT(ifindex))
    {
        *fiber_speed_p = VAL_portType_other;
        return TRUE;
    }

    *fiber_speed_p = SYS_DFLT_COMBO_PORT_FORCED_MODE_SFP_SPEED;
#endif /* (SWCTRL_UPDATE_PORT_ABILITY == TRUE) */

    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
}
#endif /* (SYS_CPNT_COMBO_PORT_FORCED_MODE_SFP_SPEED == TRUE) */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetPortComboForcedMode
 * -------------------------------------------------------------------------
 * FUNCTION: This function will set port force link media
 * INPUT   : ifindex     -- which port to set
 *           forcedmode  -- which mode of media
 *                      - VAL_portComboForcedMode_none
 *                              For trunk and non-combo port only.
 *                      - VAL_portComboForcedMode_copperForced
 *                              Force to copper more ignore SFP transceiver present state.
 *                      - VAL_portComboForcedMode_copperPreferredAuto
 *                              Obsoleted.
 *                      - VAL_portComboForcedMode_sfpForced
 *                              Force to fiber more ignore SFP transceiver present state.
 *                      - VAL_portComboForcedMode_sfpPreferredAuto
 *                              Copper/fiber depends on SFP transceiver present state.
 *                              SFP transceiver present       -> Fiber mode.
 *                                              not present   -> Copper more.
 *           fiber_speed  -- which speed (VAL_portType_hundredBaseFX/VAL_portType_thousandBaseSfp)
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : For trunk, trunk member, and normal port.
 * -------------------------------------------------------------------------*/
#if (SYS_CPNT_COMBO_PORT_FORCED_MODE_SFP_SPEED == TRUE)
BOOL_T SWCTRL_SetPortComboForcedMode(UI32_T ifindex, UI32_T forcedmode, UI32_T fiber_speed)
#else
BOOL_T SWCTRL_SetPortComboForcedMode(UI32_T ifindex, UI32_T forcedmode)
#endif
{
    UI32_T  unit;
    UI32_T  port;
    UI32_T  trunk_id;
    BOOL_T  retval;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (forcedmode != VAL_portComboForcedMode_none              &&
        forcedmode != VAL_portComboForcedMode_copperForced      &&
        forcedmode != VAL_portComboForcedMode_sfpForced         &&
        forcedmode != VAL_portComboForcedMode_sfpPreferredAuto  )
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (SWCTRL_LPORT_UNKNOWN_PORT == SWCTRL_LogicalPortToUserPort(ifindex, &unit, &port, &trunk_id))
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    SWCTRL_LOCK();

    if (forcedmode == port_info[ifindex-1].port_entry.port_forced_mode)
    {
#if (SYS_CPNT_COMBO_PORT_FORCED_MODE_SFP_SPEED == TRUE)
        if (forcedmode == VAL_portComboForcedMode_sfpForced)
        {
            if (fiber_speed == port_info[ifindex-1].port_entry.port_type)
            {
                SWCTRL_UNLOCK();
                SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
            }
        }
        else
#endif
        {
            SWCTRL_UNLOCK();
            SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
        }
    }

#if (SWCTRL_UPDATE_PORT_ABILITY != TRUE)
    if (!(SWCTRL_GetSupportedPortComboForcedMode_Local(ifindex) & BIT_VALUE(forcedmode)))
    {
        SWCTRL_UNLOCK();
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
#endif

    if (TRUE == SWCTRL_IS_TRUNK(ifindex))
    {
        /* 1. trunk: only support "none".
         */
        if (VAL_portComboForcedMode_none != forcedmode)
        {
            SWCTRL_UNLOCK();
            SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
        }

        if (0 == trunk_ext_port_info[SWCTRL_IFINDEX_TO_TRUNKID(ifindex)-1].member_number)
        {
            SWCTRL_UNLOCK();
            SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
        }

        retval = TRUE;
    }
    else
    {
        /* 1. normal port
         * 2. trunk member port
         */
        unit = SWCTRL_IFINDEX_TO_UNIT(ifindex);
        port = SWCTRL_IFINDEX_TO_PORT(ifindex);

#if (SWCTRL_UPDATE_PORT_ABILITY == TRUE)
        if (!(user_ext_port_info[ifindex-1].port_abililty.medium_forced_mode_supported & BIT_VALUE(forcedmode)))
        {
            SWCTRL_UNLOCK();
            SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
        }
#endif

#if (SYS_CPNT_COMBO_PORT_FORCED_MODE_SFP_SPEED == TRUE)
        /* if the user only set "sfp-forced", use the latest setting value to set the speed
         */
        if (fiber_speed == VAL_portType_other)
        {
            fiber_speed = port_info[ifindex-1].port_entry.port_combo_force_mode_speed_cfg;
        }

#if (SWCTRL_UPDATE_PORT_ABILITY == TRUE)
        if (forcedmode == VAL_portComboForcedMode_sfpForced)
        {
            if (!(user_ext_port_info[ifindex-1].port_abililty.medium_fiber_type_supported & BIT_VALUE(fiber_speed)))
            {
                SWCTRL_UNLOCK();
                SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
            }
        }
#endif

        retval = SWDRV_SetPortComboForcedMode(unit, port, forcedmode, fiber_speed);
#else
        retval = SWDRV_SetPortComboForcedMode(unit, port, forcedmode);
#endif
    }

    if (retval)
    {
#if (SYS_CPNT_COMBO_PORT_FORCED_MODE_SFP_SPEED == TRUE)
        if (forcedmode == VAL_portComboForcedMode_sfpForced)
        {
            port_info[ifindex-1].port_entry.port_combo_force_mode_speed_cfg = fiber_speed;
        }
#endif

        port_info[ifindex-1].port_entry.port_forced_mode = forcedmode;
    }

    SWCTRL_UNLOCK();

    SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME ();
    SWCTRL_RETURN_AND_RELEASE_CSC( retval );
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetPortComboForcedMode
 * -------------------------------------------------------------------------
 * FUNCTION: This function will set port force link medium
 * INPUT   : ifindex       -- which port to set
 * OUTPUT  : forcedmode    -- which mode of medium
 *                      - VAL_portComboForcedMode_none                  1L
 *                      - VAL_portComboForcedMode_copperForced          2L
 *                      - VAL_portComboForcedMode_copperPreferredAuto   3L (Obsoleted)
 *                      - VAL_portComboForcedMode_sfpForced             4L
 *                      - VAL_portComboForcedMode_sfpPreferredAuto      5L
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : For trunk and non-combo port, mode only read and is VAL_portComboForcedMode_none
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_GetPortComboForcedMode(UI32_T ifindex, UI32_T *forcedmode)
{
    UI32_T unit;
    UI32_T port;
    UI32_T trunk_id;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (0 == forcedmode)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (SWCTRL_LPORT_UNKNOWN_PORT == SWCTRL_LogicalPortToUserPort(ifindex, &unit, &port, &trunk_id))
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    SWCTRL_LOCK();
    if (TRUE == SWCTRL_IS_TRUNK(ifindex) &&
        0 == trunk_ext_port_info[SWCTRL_IFINDEX_TO_TRUNKID(ifindex)-1].member_number)
    {
            SWCTRL_UNLOCK();
            SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    *forcedmode = port_info[ifindex-1].port_entry.port_forced_mode;
    SWCTRL_UNLOCK();

    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
}

/*------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetRunningPortComboForcedMode
 *------------------------------------------------------------------------
 * FUNCTION: This function will get the port combo force mode running config
 * INPUT   : ifindex       -- which port to set
 * OUTPUT  : forcedmode    -- which mode of medium
 *                      - VAL_portComboForcedMode_none                  1L
 *                      - VAL_portComboForcedMode_copperForced          2L
 *                      - VAL_portComboForcedMode_copperPreferredAuto   3L (Obsoleted)
 *                      - VAL_portComboForcedMode_sfpForced             4L
 *                      - VAL_portComboForcedMode_sfpPreferredAuto      5L
 * RETURN  : SYS_TYPE_Get_Running_Cfg_T
 * NOTE    : None
 *------------------------------------------------------------------------*/
SYS_TYPE_Get_Running_Cfg_T SWCTRL_GetRunningPortComboForcedMode(UI32_T ifindex, UI32_T *forcedmode)
{
    UI32_T dflt_forcedmode;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(SYS_TYPE_GET_RUNNING_CFG_FAIL);

    if (TRUE == SWCTRL_GetPortComboForcedMode(ifindex, forcedmode))
    {
        if (!SWCTRL_GetDefaultPortComboForcedMode(ifindex, &dflt_forcedmode))
        {
            SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_FAIL );
        }

        if (dflt_forcedmode == *forcedmode)
        {
            SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_NO_CHANGE );
        }

        SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_SUCCESS );
    }

    SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_FAIL );
}

#if (SYS_CPNT_COMBO_PORT_FORCED_MODE_SFP_SPEED == TRUE)
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetPortComboForcedModeSpeed
 * -------------------------------------------------------------------------
 * FUNCTION: This function will get active GBIC port type
 * INPUT   : ifindex         -- which port to get
 * OUTPUT  : fiber_speed     -- which speed of medium
 *                                 - VAL_portType_hundredBaseFX
 *                                 - VAL_portType_thousandBaseSfp
 * RETURN  : TRUE: Successfully, FALSE: Fail
 * NOTE    : 2007.03.15, aken, ES3528MO doesn't support I2C information
 *           function refences form SWCTRL_GetPortComboForcedMode()
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_GetPortComboForcedModeSpeed(UI32_T ifindex, UI32_T *fiber_speed)
{
    UI32_T unit;
    UI32_T port;
    UI32_T trunk_id;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (0 == fiber_speed)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (SWCTRL_LPORT_UNKNOWN_PORT == SWCTRL_LogicalPortToUserPort(ifindex, &unit, &port, &trunk_id))
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    SWCTRL_LOCK();
    if (TRUE == SWCTRL_IS_TRUNK(ifindex) &&
        0 == trunk_ext_port_info[SWCTRL_IFINDEX_TO_TRUNKID(ifindex)-1].member_number)
    {
            SWCTRL_UNLOCK();
            SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    *fiber_speed = port_info[ifindex-1].port_entry.port_combo_force_mode_speed_cfg;
    SWCTRL_UNLOCK();

    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetRunningPortComboForcedModeSpeed
 * -------------------------------------------------------------------------
 * FUNCTION: This function will get active GBIC port type of running config
 * INPUT   : ifindex         -- which port to get
 * OUTPUT  : fiber_speed     -- which speed of medium
 *                                      - VAL_portType_hundredBaseFX
 *                                      - VAL_portType_thousandBaseSfp
 * RETURN  : SYS_TYPE_Get_Running_Cfg_T
 * NOTE    : 2007.03.15, aken, ES3528MO doesn't support I2C information
 *           function refences from SWCTRL_GetRunningPortComboForcedMode()
 * -------------------------------------------------------------------------*/
SYS_TYPE_Get_Running_Cfg_T SWCTRL_GetRunningPortComboForcedModeSpeed(UI32_T ifindex, UI32_T *fiber_speed)
{
    UI32_T forcedmode;
    UI32_T dflt_fiber_speed;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(SYS_TYPE_GET_RUNNING_CFG_FAIL);

    if (TRUE == SWCTRL_GetPortComboForcedModeSpeed(ifindex, fiber_speed))
    {
        if (!SWCTRL_GetPortComboForcedMode(ifindex, &forcedmode))
        {
            SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_FAIL );
        }

        if (forcedmode != VAL_portComboForcedMode_sfpForced)
        {
            SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_NO_CHANGE );
        }

        if (!SWCTRL_GetDefaultPortComboForcedModeSfpSpeed(ifindex, &dflt_fiber_speed))
        {
            SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_FAIL );
        }

        if (*fiber_speed == dflt_fiber_speed)
        {
            SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_NO_CHANGE );
        }

        SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_SUCCESS );
    }

    SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_FAIL );
}
#endif    /*end of #if (SYS_CPNT_COMBO_PORT_FORCED_MODE_SFP_SPEED == TRUE)*/

#endif

BOOL_T SWCTRL_DisablePortLearning(UI32_T l_port)
{
    UI32_T unit;
    UI32_T port;
    UI32_T trunk_id;

    if (SWCTRL_LPORT_NORMAL_PORT != SWCTRL_LogicalPortToUserPort(l_port, &unit, &port, &trunk_id))
    {
        return FALSE;
    }

    return SWDRV_DisablePortLearning(unit, port);
}

BOOL_T SWCTRL_EnablePortLearning(UI32_T l_port)
{
    UI32_T unit;
    UI32_T port;
    UI32_T trunk_id;

    if (SWCTRL_LPORT_NORMAL_PORT != SWCTRL_LogicalPortToUserPort(l_port, &unit, &port, &trunk_id))
    {
        return FALSE;
    }

    return SWDRV_EnablePortLearning(unit, port);
}

/*-------------------------------------------------------------------------
 * FUNCTION NAME - SWCTRL_SetUPortLearningStatus
 * ------------------------------------------------------------------------
 * PURPOSE  :   This funtion will set port learning status and NA handling
 *              behavior
 * INPUT    :   unit
 *              port
 *              learning
 *              check_security_status
 * OUTPUT   :   None
 * RETURN   :   TRUE/FALSE
 * NOTES    :   None
 * ------------------------------------------------------------------------
 */
static BOOL_T SWCTRL_SetUPortLearningStatus(UI32_T unit, UI32_T port, BOOL_T learning, BOOL_T check_security_status)
{
    BOOL_T to_cpu, drop, learning_to_config_hw;
    BOOL_T config_chip;
    BOOL_T ret = TRUE;

    learning_to_config_hw = learning;
    to_cpu = FALSE;
    drop = FALSE;
    config_chip = TRUE;

#if (SYS_CPNT_AMTR_HW_LEARN_ON_STANDALONE != TRUE)
    /* for sw learn, disable hw learning and trap na to cpu.
     */
    if (learning)
    {
        learning_to_config_hw = FALSE;
        to_cpu = TRUE;
    }
#endif

    if (check_security_status)
    {
        /* if intruder trap is set, it means some security function is enabled,
         * so ignores port learning config.
         */
        if (swctrl_pkt_trap_status[SWCTRL_PKTTYPE_INTRUDER] ||
            swctrl_pkt_drop_status[SWCTRL_PKTTYPE_INTRUDER] ||
            swctrl_pkt_trap_status_per_port[unit-1][port-1][SWCTRL_PKTTYPE_INTRUDER] ||
            swctrl_pkt_drop_status_per_port[unit-1][port-1][SWCTRL_PKTTYPE_INTRUDER])
        {
            config_chip = FALSE;
        }
    }

    if (config_chip)
    {
        ret = SWDRV_SetPortLearningStatus(unit, port, learning_to_config_hw, to_cpu, drop);

        /* notify learning status changed.
         */
        if (ret)
        {
            UI32_T ifindex = SWCTRL_UPORT_TO_IFINDEX(unit, port);
            UI32_T notify_ifindex = ifindex;
            UI32_T trunk_id;

            if (user_ext_port_info[ifindex-1].current_learning_status != learning)
            {
                if (SWCTRL_IS_TRUNK_MEMBER(ifindex))
                {
                    /* notify trunk only when the port to be config is first member port.
                     */
                    trunk_id = port_info[ifindex-1].port_entry.port_trunk_index;

                    if (trunk_ext_port_info[trunk_id-1].member_number > 0 &&
                        trunk_ext_port_info[trunk_id-1].member_list[0].unit == unit &&
                        trunk_ext_port_info[trunk_id-1].member_list[0].port == port)
                    {
                        notify_ifindex = SWCTRL_TRUNKID_TO_IFINDEX(trunk_id);
                    }
                    else
                    {
                        notify_ifindex = 0;
                    }
                }

                if (notify_ifindex != 0)
                {
                    SWCTRL_Notify_PortLearningStatusChanged(notify_ifindex, learning);
                }

                user_ext_port_info[ifindex-1].current_learning_status = learning;
            }
        }

        /* sync to lan.
         */
        if (ret)
        {
            ret = LAN_SetPortLearning(unit, port, learning);
        }
    }

    return ret;
}

/*-------------------------------------------------------------------------
 * FUNCTION NAME - SWCTRL_SetPortLearningStatus_Local
 * ------------------------------------------------------------------------
 * PURPOSE  :   This funtion will set port learning status
 * INPUT    :   ifindex
 *              learning
 *              owner
 * OUTPUT   :   None
 * RETURN   :   TRUE/FALSE
 * NOTES    :   None
 * ------------------------------------------------------------------------
 */
static BOOL_T SWCTRL_SetPortLearningStatus_Local(UI32_T ifindex, BOOL_T learning, SWCTRL_LearningDisabledOwner_T owner)
{
    UI32_T unit, port;
    UI32_T learning_disabled_status;
    BOOL_T retval = TRUE;

    if (SWCTRL_IS_TRUNK (ifindex))
    {
        UI32_T trunk_id = SWCTRL_IFINDEX_TO_TRUNKID(ifindex);

        if (trunk_ext_port_info[trunk_id-1].member_number == 0)
        {
            EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                      SWCTRL_NO_USE_FUNC_NO,
                                      EH_TYPE_MSG_TRUNK_CNFG_ERR,
                                      SYSLOG_LEVEL_INFO,
                                      "Trunk contains no members");  /*SWCTRL_ENO_NO_MEMBER_IN_TRUNK*/

            retval = FALSE;
        }
        else
        {
            UI32_T i, tm_ifindex;
            SWCTRL_TrunkPortExtInfo_T trunk_ext_info;

            /* while configuring a trunk, set this configure to
             * all member ports.
             */
            if (!SWCTRL_GetTrunkPortExtInfo(ifindex, &trunk_ext_info))
            {
                retval = FALSE;
            }

            for (i = 0; retval && i < trunk_ext_info.member_number; i++)
            {
                unit = (UI32_T) trunk_ext_info.member_list[i].unit;
                port = (UI32_T) trunk_ext_info.member_list[i].port;
                tm_ifindex = SWCTRL_UPORT_TO_IFINDEX(unit, port);

                learning_disabled_status = user_ext_port_info[tm_ifindex-1].learning_disabled_status;

                if (learning)
                {
                    learning_disabled_status &= ~ owner;
                }
                else
                {
                    learning_disabled_status |= owner;
                }

                retval = SWCTRL_SetUPortLearningStatus(unit, port, !learning_disabled_status, TRUE);

                if (retval)
                {
                    user_ext_port_info[tm_ifindex-1].learning_disabled_status = learning_disabled_status;
                }
            }
        }
    }
    else
    {
        unit = SWCTRL_IFINDEX_TO_UNIT(ifindex);
        port = SWCTRL_IFINDEX_TO_PORT(ifindex);

        learning_disabled_status = user_ext_port_info[ifindex-1].learning_disabled_status;

        if (learning)
        {
            learning_disabled_status &= ~ owner;
        }
        else
        {
            learning_disabled_status |= owner;
        }

        retval = SWCTRL_SetUPortLearningStatus(unit, port, !learning_disabled_status, TRUE);

        if (retval)
        {
            user_ext_port_info[ifindex-1].learning_disabled_status = learning_disabled_status;
        }
    }

    return retval;
}

/*-------------------------------------------------------------------------
 * FUNCTION NAME - SWCTRL_SetPortLearningStatus
 * ------------------------------------------------------------------------
 * PURPOSE  :   This funtion will set port learning status
 * INPUT    :   ifindex
 *              learning
 *              owner
 * OUTPUT   :   None
 * RETURN   :   TRUE/FALSE
 * NOTES    :   None
 * ------------------------------------------------------------------------
 */
BOOL_T SWCTRL_SetPortLearningStatus(UI32_T ifindex, BOOL_T learning, SWCTRL_LearningDisabledOwner_T owner)
{
    BOOL_T retval = TRUE;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (!SWCTRL_IS_EXIST(ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  SYSLOG_LEVEL_INFO,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    SWCTRL_LOCK();

    retval = SWCTRL_SetPortLearningStatus_Local(ifindex, learning, owner);

    SWCTRL_UNLOCK();

    SWCTRL_RETURN_AND_RELEASE_CSC( retval );
}

/*-------------------------------------------------------------------------
 * FUNCTION NAME - SWCTRL_GetPortLearningStatusEx
 * ------------------------------------------------------------------------
 * PURPOSE  :   This funtion will get port learning status
 * INPUT    :   ifindex
 *              learning_disabled_status_p
 *              intruder_handlers_p
 * OUTPUT   :   None
 * RETURN   :   TRUE/FALSE
 * NOTES    :   None
 * ------------------------------------------------------------------------
 */
BOOL_T SWCTRL_GetPortLearningStatusEx(UI32_T ifindex, UI32_T *learning_disabled_status_p, UI32_T *intruder_handlers_p)
{
    UI32_T unit, port;
    BOOL_T retval = TRUE;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (!SWCTRL_IS_EXIST(ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  SYSLOG_LEVEL_INFO,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (SWCTRL_IS_TRUNK(ifindex))
    {
        UI32_T primary_ifindex;

        if (!SWCTRL_GetTrunkPrimaryPort(ifindex, &primary_ifindex))
        {
            SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
        }

        ifindex = primary_ifindex;
    }

    unit = SWCTRL_IFINDEX_TO_UNIT(ifindex);
    port = SWCTRL_IFINDEX_TO_PORT(ifindex);

    SWCTRL_LOCK();

    *learning_disabled_status_p = user_ext_port_info[ifindex-1].learning_disabled_status;

    *intruder_handlers_p =
        (swctrl_pkt_trap_status_per_port[unit-1][port-1][SWCTRL_PKTTYPE_INTRUDER] |
         swctrl_pkt_drop_status_per_port[unit-1][port-1][SWCTRL_PKTTYPE_INTRUDER]);

    SWCTRL_UNLOCK();

    SWCTRL_RETURN_AND_RELEASE_CSC( retval );
}


#if (SYS_CPNT_OSPF == TRUE)
/*------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_EnableOSPFTrap
 *------------------------------------------------------------------------
 * FUNCTION: This API is used to enable OSPF trap.
 * INPUT   : None.
 * OUTPUT  : None.
 * RETURN  : TRUE/FALSE.
 * NOTE    : None.
 *------------------------------------------------------------------------*/
BOOL_T SWCTRL_EnableOSPFTrap(void)
{
    BOOL_T ret;
    UI8_T  cpu_mac[6];

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (FALSE == STKTPLG_POM_GetLocalUnitBaseMac(cpu_mac))
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    ret = SWDRV_EnableOSPFTrap(cpu_mac);

    SWCTRL_RETURN_AND_RELEASE_CSC( ret );
}

/*------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_DisableOSPFTrap
 *------------------------------------------------------------------------
 * FUNCTION: This API is used to disable OSPF trap.
 * INPUT   : None.
 * OUTPUT  : None.
 * RETURN  : TRUE/FALSE.
 * NOTE    : None.
 *------------------------------------------------------------------------*/
BOOL_T SWCTRL_DisableOSPFTrap(void)
{
    BOOL_T ret;
    UI8_T  cpu_mac[6];

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (FALSE == STKTPLG_POM_GetLocalUnitBaseMac(cpu_mac))
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    ret = SWDRV_DisableOSPFTrap(cpu_mac);

    SWCTRL_RETURN_AND_RELEASE_CSC( ret );
}
#endif


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetPortStateWithMstidx
 * -------------------------------------------------------------------------
 * PURPOSE  : Set the Stp port state
 * INPUT    : mstidx    -- multiple spanning tree instance index
 *            lport     -- ifindex of this logical port.
 *                         Only normal port and trunk port is allowed.
 *            state     -- port state 1) VAL_dot1dStpPortState_disabled
 *                                    2) VAL_dot1dStpPortState_blocking
 *                                    3) VAL_dot1dStpPortState_listening
 *                                    4) VAL_dot1dStpPortState_learning
 *                                    5) VAL_dot1dStpPortState_forwarding
 * OUTPUT   : None
 * RETURN   : TRUE/FALSE
 * NOTE     : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetPortStateWithMstidx (UI32_T mstidx, UI32_T lport, UI32_T state)
{
    UI32_T                       port_type;
    UI32_T                       unit;
    UI32_T                       port;
    UI32_T                       trunk_id;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    port_type = SWCTRL_LogicalPortToUserPort(lport, &unit, &port, &trunk_id);

    if (port_type != SWCTRL_LPORT_TRUNK_PORT  &&
        port_type != SWCTRL_LPORT_NORMAL_PORT )
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (mstidx >= SYS_ADPT_MAX_NBR_OF_MST_INSTANCE ) /*0 is valid*/
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Instance INDEX (0-%d)", SYS_ADPT_MAX_NBR_OF_MST_INSTANCE);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_MST_INSTANCE_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (state != VAL_dot1dStpPortState_disabled   &&
        state != VAL_dot1dStpPortState_blocking   &&
        state != VAL_dot1dStpPortState_listening  &&
        state != VAL_dot1dStpPortState_learning   &&
        state != VAL_dot1dStpPortState_forwarding )
    {
#if (SYS_CPNT_EH == TRUE)
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_INVALID_PARAMETER,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "MST state");   /*SWCTRL_ENO_INVALID_MST_STATE*/
#endif
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (port_type == SWCTRL_LPORT_NORMAL_PORT)
    {
        if (FALSE == SWDRV_SetPortStateWithMstidx(mstidx, unit, port, state))
        {
            SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
        }
    }
    else            /*SWCTRL_LPORT_TRUNK_PORT*/
    {
        UI32_T i;
        UI32_T trk_mem_unit;
        UI32_T trk_mem_port;

        SWCTRL_LOCK();
        if(trunk_ext_port_info[SWCTRL_IFINDEX_TO_TRUNKID(lport)-1].member_number == 0)
        {
            SWCTRL_UNLOCK();
#if (SYS_CPNT_EH == TRUE)
            EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                      SWCTRL_NO_USE_FUNC_NO,
                                      EH_TYPE_MSG_TRUNK_CNFG_ERR,
                                      SYSLOG_LEVEL_INFO,
                                      "Trunk contains no members");  /*SWCTRL_ENO_NO_MEMBER_IN_TRUNK*/
#endif
            SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
        }

        for(i=0; i<trunk_ext_port_info[SWCTRL_IFINDEX_TO_TRUNKID(lport)-1].member_number; i++)
        {
            trk_mem_unit = trunk_ext_port_info[SWCTRL_IFINDEX_TO_TRUNKID(lport)-1].member_list[i].unit;
            trk_mem_port = trunk_ext_port_info[SWCTRL_IFINDEX_TO_TRUNKID(lport)-1].member_list[i].port;

            /* Trunk fail over mechanism:
             * if a trunk member is inactive, then don't set STA state to driver
             */
            if (!SWCTRL_IS_OPER_ACTIVE_TRUNK_MEMBER(
                    SWCTRL_IFINDEX_TO_TRUNKID(lport),
                    SWCTRL_UPORT_TO_IFINDEX(trk_mem_unit, trk_mem_port)))
            {
                continue;
            }

            if (FALSE == SWDRV_SetPortStateWithMstidx(mstidx, trk_mem_unit, trk_mem_port, state))
            {
                SWCTRL_UNLOCK();
                SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
            }
        }
        SWCTRL_UNLOCK();
    }

    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
}/* End of SWCTRL_SetPortStateWithMstidx() */


#if (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_MSTP)
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_AddVlanToMst
 * -------------------------------------------------------------------------
 * FUNCTION: This function adds a VLAN to a given Spanning Tree instance.
 * INPUT   : vid                -- the VLAN will be added to a given Spanning Tree
 *           mstidx             -- mstidx (multiple spanning tree index) to identify a unique spanning tree
 * OUTPUT  : None
 * RETURN  : TRUE/FALSE
 * NOTE    :
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_AddVlanToMst(UI32_T vid, UI32_T mstidx)
{
    BOOL_T retval;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if( vid == 0 || vid >  SYS_ADPT_MAX_VLAN_ID )
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "VLAN ID (1-%d)", SYS_ADPT_MAX_VLAN_ID);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_VLAN_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (mstidx >= SYS_ADPT_MAX_NBR_OF_MST_INSTANCE ) /*0 is valid*/
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Instance INDEX (0-%d)", SYS_ADPT_MAX_NBR_OF_MST_INSTANCE);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_MST_INSTANCE_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    SWCTRL_LOCK();
    retval = SWDRV_AddVlanToMst(vid, mstidx);
    SWCTRL_UNLOCK();
    SWCTRL_RETURN_AND_RELEASE_CSC( retval );
} /* End of SWCTRL_AddVlanToMst() */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_DeleteVlanFromMst
 * -------------------------------------------------------------------------
 * FUNCTION: This function deletes a VLAN from a given Spanning Tree instance.
 * INPUT   : vid                -- the VLAN will be added to a given Spanning Tree
 *           mstidx             -- mstidx (multiple spanning tree index) to identify a unique spanning tree
 * OUTPUT  : None
 * RETURN  : TRUE/FALSE
 * NOTE    :
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_DeleteVlanFromMst(UI32_T vid, UI32_T mstidx)
{
    BOOL_T retval;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if( vid == 0 || vid >  SYS_ADPT_MAX_VLAN_ID )
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "VLAN ID (1-%d)", SYS_ADPT_MAX_VLAN_ID);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_VLAN_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (mstidx >= SYS_ADPT_MAX_NBR_OF_MST_INSTANCE ) /*0 is valid*/
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Instance INDEX (0-%d)", SYS_ADPT_MAX_NBR_OF_MST_INSTANCE);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_MST_INSTANCE_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    SWCTRL_LOCK();
    retval = SWDRV_DeleteVlanFromMst(vid, mstidx);
    SWCTRL_UNLOCK();
    SWCTRL_RETURN_AND_RELEASE_CSC( retval );
} /* End of SWCTRL_DeleteVlanFromMst() */
#endif /* end of #if (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_MSTP)*/


#if (SYS_CPNT_DOT1X == TRUE)
/****************************************************************************/
/* DOT1X                                                                     */
/****************************************************************************/
/* -------------------------------------------------------------------------
* ROUTINE NAME - SWCTRL_SetDot1xAuthTrap
* -------------------------------------------------------------------------
* FUNCTION: This function will trap EtherType 888E packets to CPU
* INPUT   : ifindex
*           mode      -- SWCTRL_DOT1X_PACKET_DISCARD
*                        SWCTRL_DOT1X_PACKET_FORWARD
*                        SWCTRL_DOT1X_PACKET_TRAPTOCPU
* OUTPUT  : None
* RETURN  : TRUE: Successfully, FALSE: If not available
* NOTE    :
* -------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetDot1xAuthTrap(UI32_T ifindex, UI32_T mode)
{
    UI32_T                          unit, port, i;
    BOOL_T                          retval = FALSE;
    SWCTRL_TrunkPortExtInfo_T    trunk_ext_p_info;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (!SWCTRL_IS_LPORT(ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    SWCTRL_LOCK();
    if (!SWCTRL_IS_TRUNK (ifindex))
    {
        unit = SWCTRL_IFINDEX_TO_UNIT(ifindex);
        port = SWCTRL_IFINDEX_TO_PORT(ifindex);

        retval = SWDRV_SetDot1xAuthTrap(unit, port, mode);
    }
    else /* trunk */
    {
        SWCTRL_GetTrunkPortExtInfo (ifindex, &trunk_ext_p_info);

        for(i = 0; i < trunk_ext_p_info.member_number; i++)
        {
            unit = (UI32_T) trunk_ext_p_info.member_list[i].unit;
            port = (UI32_T) trunk_ext_p_info.member_list[i].port;
            if (!(retval = SWDRV_SetDot1xAuthTrap(unit, port, mode)))
                break;
        } /* End of for () */
    } /* End of if (trunk) */
    SWCTRL_UNLOCK();

    SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME ();
    SWCTRL_RETURN_AND_RELEASE_CSC( retval );
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWDRV_SetDot1xAuthControlMode
 * -------------------------------------------------------------------------
 * FUNCTION: This function will set dot1x auth control mode
 * INPUT   : unit, port,
 *               mode
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    :
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetDot1xAuthControlMode(UI32_T ifindex, UI32_T mode)
{
    UI32_T                          unit, port;
    BOOL_T                          retval = FALSE;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if( mode != SWCTRL_DOT1X_PORT_UNAUTHORIZED &&
        mode != SWCTRL_DOT1X_PORT_AUTHORIZED  )
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_INVALID_PARAMETER,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "DOT1X authentication control mode");

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if(!SWCTRL_IS_LPORT(ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (!SWCTRL_IS_EXIST (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Interface");

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    /* In our design, DOT1X could not be configured on
     * 1) trunk member port
     * 2) trunk port
     */
    if (SWCTRL_IS_TRUNK_MEMBER (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_TRUNK_MEMBER_CNFG_ERR,
                                  SYSLOG_LEVEL_INFO|EH_MGR_FOR_DEBUG_MSG_PURPOSE,
                                  "Trunk member doesn't support DOT1X");  /*SWCTRL_ENO_NOT_TRUNK_MEMBER*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if(SWCTRL_IS_TRUNK(ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_TRUNK_CNFG_ERR,
                                  SYSLOG_LEVEL_INFO,
                                  "it doesn't support DOT1X");  /*SWCTRL_ENO_NOT_TRUNK*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }


    SWCTRL_LOCK();
    if (!SWCTRL_IS_TRUNK (ifindex))
    {
        unit = SWCTRL_IFINDEX_TO_UNIT(ifindex);
        port = SWCTRL_IFINDEX_TO_PORT(ifindex);

        retval = SWDRV_SetDot1xAuthControlMode(unit, port, mode);
    }

    SWCTRL_UNLOCK();

    SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME ();
    SWCTRL_RETURN_AND_RELEASE_CSC( retval );
}
#endif

#if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION == TRUE)
static BOOL_T SWCTRL_SetPrivateVlan_(UI8_T uplink_port_list  [SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST],
                                     UI8_T downlink_port_list[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST])
{
    UI32_T  uplink_uport_cnt = 0;
    UI32_T  downlink_uport_cnt = 0;
    UI32_T  ifindex,i,j;
    BOOL_T  retval;

    if ((uplink_port_list == 0) || (downlink_port_list == 0))
    {
        EH_MGR_Handle_Exception (SYS_MODULE_SWCTRL,
                                 SWCTRL_NO_USE_FUNC_NO,
                                 EH_TYPE_MSG_NULL_POINTER,
                                 EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_CRIT);
        return FALSE;
    }

    /* a port should not be up-link and down-link port at the same time
     */
    for (i=0; i<SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST; i++)
    {
        if (uplink_port_list[i] == 0)
        {
            continue;
        }

        for (j=0; j<8; j++)
        {
            if ((uplink_port_list[i]<<j) & 0x80)
            {
                if ((downlink_port_list[i]<<j) & 0x80)
                {
                    EH_MGR_Handle_Exception (SYS_MODULE_SWCTRL,
                                             SWCTRL_NO_USE_FUNC_NO,
                                             EH_TYPE_MSG_PVLAN_SAME_UL_DL,
                                             SYSLOG_LEVEL_INFO); /*SWCTRL_ENO_PVLAN_UP_DOWN_LINK_ON_THE_SAME_PORT*/

                    return FALSE;
                }
            }
        }
    }

    ifindex = 0;
    while (SWCTRL_GetNextIndexFromPortList (&ifindex, uplink_port_list))
    {
        /* Unknown port
         */
        if(!SWCTRL_IS_EXIST(ifindex))
        {
            return FALSE;
        }

        /* Trunk member
         */
        if(SWCTRL_IS_TRUNK_MEMBER(ifindex))
        {
            uplink_uport_list[uplink_uport_cnt].unit = 0xFFFF;
            uplink_uport_list[uplink_uport_cnt].port = port_info[ifindex-1].port_entry.port_trunk_index;
            uplink_uport_cnt++;
            uplink_uport_list[uplink_uport_cnt].unit = SWCTRL_IFINDEX_TO_UNIT(ifindex);
            uplink_uport_list[uplink_uport_cnt].port = SWCTRL_IFINDEX_TO_PORT(ifindex);
            uplink_uport_cnt++;
        }

        /* Normal port
         */
        if(SWCTRL_IS_USER_PORT (ifindex))
        {
            uplink_uport_list[uplink_uport_cnt].unit = SWCTRL_IFINDEX_TO_UNIT(ifindex);
            uplink_uport_list[uplink_uport_cnt].port = SWCTRL_IFINDEX_TO_PORT(ifindex);
            uplink_uport_cnt++;
        }

        /* Trunk port
         */
        if(SWCTRL_IS_TRUNK (ifindex))
        {
            UI32_T  trunk_id;

            trunk_id = port_info[ifindex-1].port_entry.port_trunk_index;
            if (trunk_ext_port_info[trunk_id-1].member_number == 0 )
            {
                EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                          SWCTRL_NO_USE_FUNC_NO,
                                          EH_TYPE_MSG_TRUNK_CNFG_ERR,
                                          SYSLOG_LEVEL_INFO,
                                          "it doesn't support Private VLANs.");  /*SWCTRL_ENO_NOT_TRUNK*/
                return FALSE;
            }
            else
            {
                uplink_uport_list[uplink_uport_cnt].unit = 0xFFFF;
                uplink_uport_list[uplink_uport_cnt].port = trunk_id;
                uplink_uport_cnt++;
                uplink_uport_list[uplink_uport_cnt].unit = trunk_ext_port_info[trunk_id-1].member_list[0].unit;
                uplink_uport_list[uplink_uport_cnt].port = trunk_ext_port_info[trunk_id-1].member_list[0].port;
                uplink_uport_cnt++;
            }

        } /* End of if () */
    } /* End of while */

    ifindex = 0;
    while (SWCTRL_GetNextIndexFromPortList (&ifindex, downlink_port_list))
    {
        /* Unknown port
         */
        if(!SWCTRL_IS_EXIST(ifindex))
        {
            /*UIMSG_MGR_SetErrorCode(); */ /*xxxxxxxxx*/
            return FALSE;
        }

        /* Trunk member
         */
        if(SWCTRL_IS_TRUNK_MEMBER(ifindex))
        {
            /*UIMSG_MGR_SetErrorCode(); */ /*xxxxxxxxx*/
            return FALSE;
        }

        /* Normal port
         */
        if(SWCTRL_IS_USER_PORT (ifindex))
        {
            downlink_uport_list[downlink_uport_cnt].unit = SWCTRL_IFINDEX_TO_UNIT(ifindex);
            downlink_uport_list[downlink_uport_cnt].port = SWCTRL_IFINDEX_TO_PORT(ifindex);
            downlink_uport_cnt++;
        }

        /* Trunk port
         */
        if(SWCTRL_IS_TRUNK (ifindex))
        {
                EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                          SWCTRL_NO_USE_FUNC_NO,
                                          EH_TYPE_MSG_TRUNK_CNFG_ERR,
                                          SYSLOG_LEVEL_INFO,
                                          "it doesn't support Private VLANs.");  /*SWCTRL_ENO_NOT_TRUNK*/

            return FALSE;
        } /* End of if () */
    } /* End of while */


    if (FALSE == SWDRV_SetTrafficSegmatationByPortlist(uplink_port_list, downlink_port_list))
    {
        return FALSE;
    }
    retval = TRUE;

    if (TRUE == retval)
    {
        /* There 3 cases will be TRUE:
         * 1) With FFP (use HRDRV), and driver return TRUE.
         * 2) Without FFP, PVLAN status is enabled, set to driver successfully, maintain database
         * 3) Without FFP, PVLAN status is disable, maintain database only
         */
        for (ifindex=1; ifindex<=SYS_ADPT_TOTAL_NBR_OF_LPORT; ifindex++)
        {
            port_info[ifindex-1].private_vlan_uplink_port   = FALSE;
            port_info[ifindex-1].private_vlan_downlink_port = FALSE;

            if((uplink_port_list[(ifindex-1)/8]<<((ifindex-1)%8))&0x80 )
            {
                port_info[ifindex-1].private_vlan_uplink_port = TRUE;
            }
            else if((downlink_port_list[(ifindex-1)/8]<<((ifindex-1)%8))&0x80 )
            {
                port_info[ifindex-1].private_vlan_downlink_port = TRUE;
            }
        }
    }
    else
    {
        /* There 2 cases will be FALSE:
         * 1) With FFP (use HRDRV), and driver return FALSE.
         * 2) Without FFP, PVLAN status is enabled, set to driver FALSE
         */
        /* do nothing
         */
    }
    return TRUE;
}/* End of SWCTRL_SetPrivateVlan_ () */
#endif /* #if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION == TRUE) */

#if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION == TRUE)
#if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE == SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE_MULTIPLE_SESSION)
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetPrivateVlanBySessionId
 * -------------------------------------------------------------------------
 * FUNCTION: This function will set the private vlan by group session id
 * INPUT   : session_id         -- is group session id
 *           uplink_port_list   -- uplink port list
 *           downlink_port_list -- downlink port list
 * OUTPUT  : None
 * RETURN  : True: Successfully, FALSE: Failed
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetPrivateVlanBySessionId(
              UI32_T session_id,
              UI8_T  uplink_port_list  [SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST],
              UI8_T  downlink_port_list[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST])
{
    BOOL_T retval;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    /* check session_id is exceed */
    if( session_id > SYS_ADPT_PORT_TRAFFIC_SEGMENTATION_MAX_NBR_OF_SESSIONS )
    {
        SWCTRL_RETURN_AND_RELEASE_CSC_AND_UNLOCK( FALSE );
    }

    SWCTRL_ENTER_XOR_CRITICAL_SECTION(&retval);

    SWCTRL_XOR_CHECK(
       (SYSCTRL_XOR_MGR_PermitBeingSetToPrivatePort(uplink_port_list) &&
        SYSCTRL_XOR_MGR_PermitBeingSetToPrivatePort(downlink_port_list)));

    SWCTRL_LOCK();

    retval = SWCTRL_SetPrivateVlanBySessionId_(session_id, uplink_port_list, downlink_port_list);

    SWCTRL_UNLOCK();
    SWCTRL_LEAVE_XOR_CRITICAL_SECTION();
    SWCTRL_RETURN_AND_RELEASE_CSC( retval );
} /* End of SWCTRL_SetPrivateVlanBySessionId () */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetPrivateVlanBySessionId_
 * -------------------------------------------------------------------------
 * FUNCTION: This function will set the private vlan by group session id
 * INPUT   : session_id         -- is group session id
 *           uplink_port_list   -- uplink port list
 *           downlink_port_list -- downlink port list
 * OUTPUT  : None
 * RETURN  : True: Successfully, FALSE: Failed
 * NOTE    : None
 * -------------------------------------------------------------------------*/
static BOOL_T SWCTRL_SetPrivateVlanBySessionId_(
                     UI32_T session_id,
                     UI8_T uplink_port_list  [SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST],
                     UI8_T downlink_port_list[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST])
{
    UI32_T  ifindex, group_index;
    UI32_T  uplink_uport_cnt = 0;
    UI32_T  downlink_uport_cnt = 0;
    UI8_T   trunk_upport_list[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST];
    UI8_T   trunk_dwport_list[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST];

    if ((uplink_port_list == 0) || (downlink_port_list == 0))
    {
        EH_MGR_Handle_Exception (SYS_MODULE_SWCTRL,
                                 SWCTRL_NO_USE_FUNC_NO,
                                 EH_TYPE_MSG_NULL_POINTER,
                                 EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_CRIT);
        return FALSE;
    }

    /* a port should not be up-link and down-link port at the same time
     */
    if (TRUE == SWCTRL_IsOverlapPortlist(uplink_port_list, downlink_port_list))
    {
        return FALSE;
    }

    /* check user port or trunk index port is permit to pvlan session */
    if (FALSE == SWCTRL_IsPermitPrivateVlanTrunkPort(session_id, uplink_port_list, downlink_port_list))
    {
        return FALSE;
    }

    /* get session id status */
    /* compare two port list if conflict */
    for (group_index=0; group_index<SYS_ADPT_PORT_TRAFFIC_SEGMENTATION_MAX_NBR_OF_SESSIONS ; group_index++)
    {
        /* check different group has binding port list */
        if (swctl_private_vlan_ext_info[group_index].session_id != session_id)
        {
            /* check the other group, which user port can't overlap */
            if (swctl_private_vlan_ext_info[group_index].is_valid == TRUE)
            {
                if ( (TRUE == SWCTRL_IsOverlapPortlist(uplink_port_list,
                              swctl_private_vlan_ext_info[group_index].private_vlan_downlink_port_list)) ||
                     (TRUE == SWCTRL_IsOverlapPortlist(uplink_port_list,
                              swctl_private_vlan_ext_info[group_index].private_vlan_uplink_port_list))   ||
                     (TRUE == SWCTRL_IsOverlapPortlist(downlink_port_list,
                              swctl_private_vlan_ext_info[group_index].private_vlan_downlink_port_list)) ||
                     (TRUE == SWCTRL_IsOverlapPortlist(downlink_port_list,
                              swctl_private_vlan_ext_info[group_index].private_vlan_uplink_port_list)) )
                {
                    return FALSE;
                }
            }
        }/* End of if (swctl_private_vlan_ext_info[group_index].session_id != session_id) */
    }

    if (swctl_private_vlan_ext_info[session_id-1].is_valid == TRUE)
    {
         /* check specific port list has join to uplink/downlink port */
        if ( (TRUE == SWCTRL_IsOverlapPortlist(uplink_port_list,
                      swctl_private_vlan_ext_info[session_id-1].private_vlan_downlink_port_list)) ||
             (TRUE == SWCTRL_IsOverlapPortlist(downlink_port_list,
                      swctl_private_vlan_ext_info[session_id-1].private_vlan_uplink_port_list)) )
        {
            return FALSE;
        }
    }/* End of if (swctl_private_vlan_ext_info[session_id-1].is_valid == FALSE) */

    /* clean trunk port index, because we don't apply trunk index to lower layer
     * keep this trunk of pvlan until end of this function
     */
    memset(trunk_upport_list, 0, sizeof(trunk_upport_list));
    memset(trunk_dwport_list, 0, sizeof(trunk_dwport_list));

    for (ifindex=SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT+1; ifindex<=SYS_ADPT_TOTAL_NBR_OF_LPORT; ifindex++)
    {
        if (SWCTRL_IS_TRUNK(ifindex) == FALSE)
        {
            continue;
        }

        /* clean user trunk index and keep it local port list */
        if((uplink_port_list[(ifindex-1)/8]<<((ifindex-1)%8))&0x80)
        {
            uplink_port_list[SWCTRL_BYTE_IN_BITMAP(ifindex)]  &=  ~(SWCTRL_BIT_IN_BITMAP(ifindex));
            trunk_upport_list[SWCTRL_BYTE_IN_BITMAP(ifindex)] |= SWCTRL_BIT_IN_BITMAP(ifindex);
        }
        else if ((downlink_port_list[(ifindex-1)/8]<<((ifindex-1)%8))&0x80)
        {
            downlink_port_list[SWCTRL_BYTE_IN_BITMAP(ifindex)] &= ~(SWCTRL_BIT_IN_BITMAP(ifindex));
            trunk_dwport_list[SWCTRL_BYTE_IN_BITMAP(ifindex)]  |= SWCTRL_BIT_IN_BITMAP(ifindex);
        }
    }

    /* get normal port counter */
    for (ifindex=1; ifindex<=SYS_ADPT_TOTAL_NBR_OF_LPORT; ifindex++)
    {
        if((uplink_port_list[(ifindex-1)/8]<<((ifindex-1)%8))&0x80 )
        {
            uplink_uport_cnt++;
        }
        else if((downlink_port_list[(ifindex-1)/8]<<((ifindex-1)%8))&0x80 )
        {
            downlink_uport_cnt++;
        }
    }

    /* set pvlan only by port index */
    if ((uplink_uport_cnt>0)||(downlink_uport_cnt>0))
    {
        /* we'll keep status while private vlan disabled */
        if (system_info.is_private_vlan_enable == VAL_privateVlanStatus_enabled)
        {
            /* set port list to driver layer */
            if (FALSE == SWDRV_SetPrivateVlanPortlistBySessionId(session_id, uplink_port_list, downlink_port_list))
            {
                return FALSE;
            }
        }

        /* update private vlan port status */
        for (ifindex=1; ifindex<=SYS_ADPT_TOTAL_NBR_OF_LPORT; ifindex++)
        {
            if((uplink_port_list[(ifindex-1)/8]<<((ifindex-1)%8))&0x80 )
            {
                swctl_private_vlan_port_info[ifindex-1].session_id = session_id;
                swctl_private_vlan_port_info[ifindex-1].private_vlan_uplink_port = TRUE;
                swctl_private_vlan_ext_info[session_id-1].private_vlan_uplink_port_list[SWCTRL_BYTE_IN_BITMAP(ifindex)]
                                                                    |=  SWCTRL_BIT_IN_BITMAP(ifindex);
            }
            else if((downlink_port_list[(ifindex-1)/8]<<((ifindex-1)%8))&0x80 )
            {
                swctl_private_vlan_port_info[ifindex-1].session_id = session_id;
                swctl_private_vlan_port_info[ifindex-1].private_vlan_downlink_port = TRUE;
                swctl_private_vlan_ext_info[session_id-1].private_vlan_downlink_port_list[SWCTRL_BYTE_IN_BITMAP(ifindex)]
                                                                    |=  SWCTRL_BIT_IN_BITMAP(ifindex);
            }
        }
    }/* End of if (uplink_uport_cnt>0 || downlink_uport_cnt>0) */

    /* since, we don't apply trunk index to lower layer then set all trunk members to pvlan
     */
    for (ifindex=SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT+1; ifindex<=SYS_ADPT_TOTAL_NBR_OF_LPORT; ifindex++)
    {
        /* continue when port isn't trunk index port or none exist port */
        if ((SWCTRL_IS_TRUNK(ifindex) == FALSE) || (SWCTRL_IS_EXIST (ifindex) == FALSE))
        {
            continue;
        }

        /* update trunk index info */
        if ((trunk_upport_list[(ifindex-1)/8]<<((ifindex-1)%8))&0x80)
        {
            swctl_private_vlan_port_info[ifindex-1].session_id = session_id;
            swctl_private_vlan_port_info[ifindex-1].private_vlan_uplink_port = TRUE;
            swctl_private_vlan_ext_info[session_id-1].private_vlan_uplink_port_list[SWCTRL_BYTE_IN_BITMAP(ifindex)]
                                                                |=  SWCTRL_BIT_IN_BITMAP(ifindex);
            /* set session_id to trunk port entry */
            swctl_private_vlan_trunk_port_info[SWCTRL_IFINDEX_TO_TRUNKID(ifindex)-1].session_id = session_id;

            /* set all trunk member to apply same session group */
            SWCTRL_AddPrivateVlanTrunkPort(ifindex);
        }
        else if((trunk_dwport_list[(ifindex-1)/8]<<((ifindex-1)%8))&0x80)
        {
            swctl_private_vlan_port_info[ifindex-1].session_id = session_id;
            swctl_private_vlan_port_info[ifindex-1].private_vlan_downlink_port = TRUE;
            swctl_private_vlan_ext_info[session_id-1].private_vlan_downlink_port_list[SWCTRL_BYTE_IN_BITMAP(ifindex)]
                                                                |=  SWCTRL_BIT_IN_BITMAP(ifindex);
            /* set session_id to trunk port entry */
            swctl_private_vlan_trunk_port_info[SWCTRL_IFINDEX_TO_TRUNKID(ifindex)-1].session_id = session_id;

            /* set all trunk member to apply same session group */
            SWCTRL_AddPrivateVlanTrunkPort(ifindex);
        }
    }

    /* updated session status to valid */
    swctl_private_vlan_ext_info[session_id-1].is_valid = TRUE;

    return TRUE;
}/* End of SWCTRL_SetPrivateVlanBySessionId_ () */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_DeletePrivateVlanPortlistBySessionId
 * -------------------------------------------------------------------------
 * FUNCTION: This function will delete private vlan port list with sesion Id
 * INPUT   : session_id         -- is group session id
 *           uplink_port_list   -- uplink port list
 *           downlink_port_list -- downlink port list
 * OUTPUT  : None
 * RETURN  : True: Successfully, FALSE: Failed
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_DeletePrivateVlanPortlistBySessionId(
              UI32_T session_id,
              UI8_T  uplink_port_list  [SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST],
              UI8_T  downlink_port_list[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST])
{
    BOOL_T retval;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    SWCTRL_LOCK();

    /* check session_id is exceed */
    if( session_id > SYS_ADPT_PORT_TRAFFIC_SEGMENTATION_MAX_NBR_OF_SESSIONS)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC_AND_UNLOCK( FALSE );
    }

    retval = SWCTRL_DeletePrivateVlanPortlistBySessionId_(session_id, uplink_port_list, downlink_port_list);

    SWCTRL_RETURN_AND_RELEASE_CSC_AND_UNLOCK( retval );
} /* End of SWCTRL_DeletePrivateVlanPortlistBySessionId () */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_DeletePrivateVlanPortlistBySessionId_
 * -------------------------------------------------------------------------
 * FUNCTION: This function will delete private vlan port list with sesion Id
 * INPUT   : session_id         -- is group session id
 *           uplink_port_list   -- uplink port list
 *           downlink_port_list -- downlink port list
 * OUTPUT  : None
 * RETURN  : True: Successfully, FALSE: Failed
 * NOTE    : None
 * -------------------------------------------------------------------------*/
static BOOL_T SWCTRL_DeletePrivateVlanPortlistBySessionId_(
              UI32_T session_id,
              UI8_T  uplink_port_list  [SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST],
              UI8_T  downlink_port_list[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST])
{
    UI32_T  uplink_uport_cnt = 0;
    UI32_T  downlink_uport_cnt = 0;
    UI32_T  ifindex;
    UI8_T   trunk_upport_list[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST];
    UI8_T   trunk_dwport_list[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST];

    if ((uplink_port_list == 0) || (downlink_port_list == 0))
    {
        EH_MGR_Handle_Exception (SYS_MODULE_SWCTRL,
                                 SWCTRL_NO_USE_FUNC_NO,
                                 EH_TYPE_MSG_NULL_POINTER,
                                 EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_CRIT);
        return FALSE;
    }

    /* a port should not be up-link and down-link port at the same time
     */
    if (TRUE == SWCTRL_IsOverlapPortlist(uplink_port_list, downlink_port_list))
    {
        return FALSE;
    }

    /* get session id status */
    if (swctl_private_vlan_ext_info[session_id-1].is_valid == TRUE)
    {
         /* check specific ports has join to uplink/downlink port list */
        if ( (FALSE == SWCTRL_IsPrivateVlanMemberPort(uplink_port_list,
                      swctl_private_vlan_ext_info[session_id-1].private_vlan_uplink_port_list)) ||
             (FALSE == SWCTRL_IsPrivateVlanMemberPort(downlink_port_list,
                      swctl_private_vlan_ext_info[session_id-1].private_vlan_downlink_port_list)) )
        {
            return FALSE;
        }
    }
    else
    {
        return FALSE; /* can't remove port while invalid session */
    }/* End of if (swctl_private_vlan_ext_info[session_id-1].is_valid == FALSE) */

    /* check user port or trunk index port is permit to pvlan session */
    if (FALSE == SWCTRL_IsPermitPrivateVlanTrunkPort(session_id, uplink_port_list, downlink_port_list))
    {
        return FALSE;
    }

    /* clean trunk port index, because we don't apply trunk index to lower layer
     * keep this trunk of pvlan until end of this function
     */
    memset(trunk_upport_list, 0, sizeof(trunk_upport_list));
    memset(trunk_dwport_list, 0, sizeof(trunk_dwport_list));

    /* get local trunk index list */
    for (ifindex=SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT+1; ifindex<=SYS_ADPT_TOTAL_NBR_OF_LPORT; ifindex++)
    {
        if (SWCTRL_IS_TRUNK(ifindex) != TRUE)
        {
            continue;
        }

        /* clean user trunk index and keep it local port list */
        if((uplink_port_list[(ifindex-1)/8]<<((ifindex-1)%8))&0x80)
        {
            uplink_port_list[SWCTRL_BYTE_IN_BITMAP(ifindex)]  &=  ~(SWCTRL_BIT_IN_BITMAP(ifindex));
            trunk_upport_list[SWCTRL_BYTE_IN_BITMAP(ifindex)] |= SWCTRL_BIT_IN_BITMAP(ifindex);
        }
        else if ((downlink_port_list[(ifindex-1)/8]<<((ifindex-1)%8))&0x80)
        {
            downlink_port_list[SWCTRL_BYTE_IN_BITMAP(ifindex)] &= ~(SWCTRL_BIT_IN_BITMAP(ifindex));
            trunk_dwport_list[SWCTRL_BYTE_IN_BITMAP(ifindex)]  |= SWCTRL_BIT_IN_BITMAP(ifindex);
        }
    }

    /* get normal port counter */
    for (ifindex=1; ifindex<=SYS_ADPT_TOTAL_NBR_OF_LPORT; ifindex++)
    {
        if((uplink_port_list[(ifindex-1)/8]<<((ifindex-1)%8))&0x80 )
        {
            uplink_uport_cnt++;
        }
        else if((downlink_port_list[(ifindex-1)/8]<<((ifindex-1)%8))&0x80 )
        {
            downlink_uport_cnt++;
        }
    }

    /* set pvlan only by port index */
    if ((uplink_uport_cnt>0)||(downlink_uport_cnt>0))
    {
        /* we'll keep status while private vlan disabled */
        if (system_info.is_private_vlan_enable == VAL_privateVlanStatus_enabled)
        {
            /* delete private vlan to default session group */
            if (FALSE == SWDRV_DeletePrivateVlanPortlistBySessionId(session_id, uplink_port_list, downlink_port_list))
            {
                return FALSE;
            }
        }

        /* update port private vlan status to disable */
        for (ifindex=1; ifindex<=SYS_ADPT_TOTAL_NBR_OF_LPORT; ifindex++)
        {
            if((uplink_port_list[(ifindex-1)/8]<<((ifindex-1)%8))&0x80 )
            {
                swctl_private_vlan_port_info[ifindex-1].session_id = 0x0;
                swctl_private_vlan_port_info[ifindex-1].private_vlan_uplink_port= FALSE;
                swctl_private_vlan_ext_info[session_id-1].private_vlan_uplink_port_list[SWCTRL_BYTE_IN_BITMAP(ifindex)]
                                                                    &=  ~(SWCTRL_BIT_IN_BITMAP(ifindex));
            }
            else if((downlink_port_list[(ifindex-1)/8]<<((ifindex-1)%8))&0x80 )
            {
                swctl_private_vlan_port_info[ifindex-1].session_id = 0x0;
                swctl_private_vlan_port_info[ifindex-1].private_vlan_downlink_port = FALSE;
                swctl_private_vlan_ext_info[session_id-1].private_vlan_downlink_port_list[SWCTRL_BYTE_IN_BITMAP(ifindex)]
                                                                    &=  ~(SWCTRL_BIT_IN_BITMAP(ifindex));
            }
        }
    }/*End of if ((uplink_uport_cnt>0)||(downlink_uport_cnt>0))*/

    /* since, we don't apply trunk index to lower layer then set all trunk members to pvlan
     */
    for (ifindex=SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT+1; ifindex<=SYS_ADPT_TOTAL_NBR_OF_LPORT; ifindex++)
    {
        /* continue when port isn't trunk index port or none exist port */
        if ((SWCTRL_IS_TRUNK(ifindex) == FALSE) || (SWCTRL_IS_EXIST (ifindex) == FALSE))
        {
            continue;
        }

        /* update trunk index info */
        if ((trunk_upport_list[(ifindex-1)/8]<<((ifindex-1)%8))&0x80)
        {
            /* clean all trunk member for same session group */
            SWCTRL_DeletePrivateVlanTrunkPort(ifindex);

            swctl_private_vlan_port_info[ifindex-1].session_id = 0x0;
            swctl_private_vlan_port_info[ifindex-1].private_vlan_uplink_port = FALSE;
            swctl_private_vlan_ext_info[session_id-1].private_vlan_uplink_port_list[SWCTRL_BYTE_IN_BITMAP(ifindex)]
                                                                &=  ~(SWCTRL_BIT_IN_BITMAP(ifindex));
        }
        else if((trunk_dwport_list[(ifindex-1)/8]<<((ifindex-1)%8))&0x80)
        {
            /* clean all trunk member for same session group */
            SWCTRL_DeletePrivateVlanTrunkPort(ifindex);

            swctl_private_vlan_port_info[ifindex-1].session_id = 0x0;
            swctl_private_vlan_port_info[ifindex-1].private_vlan_downlink_port = FALSE;
            swctl_private_vlan_ext_info[session_id-1].private_vlan_downlink_port_list[SWCTRL_BYTE_IN_BITMAP(ifindex)]
                                                                &=  ~(SWCTRL_BIT_IN_BITMAP(ifindex));
        }
    }/* End of for loop with trunk index */

    return TRUE;
} /* End of SWCTRL_DeletePrivateVlanPortlistBySessionId_()*/

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_IsOverlapPortlist
 * -------------------------------------------------------------------------
 * FUNCTION: This function will verify two port list will be overlap
 * INPUT   : user_port_list  --  user port list
 *           org_port_list   --  orginal port list
 * OUTPUT  : None
 * RETURN  : True: Successfully, FALSE: Failed
 * NOTE    : None
 * -------------------------------------------------------------------------*/
static BOOL_T SWCTRL_IsOverlapPortlist(UI8_T user_port_list[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST],
                                       UI8_T org_port_list[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST])
{
    UI32_T i,j;

    for (i=0; i<SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST; i++)
    {
        if (user_port_list[i] == 0)
        {
            continue;
        }

        for (j=0; j<8; j++)
        {
            if ((user_port_list[i]<<j) & 0x80)
            {
                if ((org_port_list[i]<<j) & 0x80)
                {
                    return TRUE;
                }
            }
        }
    }
    return FALSE;
}/* End of SWCTRL_IsOverlapPortlist() */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_IsPrivateVlanMemberPort
 * -------------------------------------------------------------------------
 * FUNCTION: This function will check user port is member of session port list
 * INPUT   : user_port_list      --  user port list
 *           session_port_list   --  session port list
 * OUTPUT  : None
 * RETURN  : True: Successfully, FALSE: Failed
 * NOTE    : None
 * -------------------------------------------------------------------------*/
static BOOL_T SWCTRL_IsPrivateVlanMemberPort(UI8_T user_port_list[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST],
                                             UI8_T session_port_list[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST])
{
    UI32_T i,j;
    UI32_T user_port_cnt=0, session_port_cnt=0;

    for (i=0; i<SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST; i++)
    {
        if (user_port_list[i] == 0)
        {
            continue;
        }

        for (j=0; j<8; j++)
        {
            if ((user_port_list[i]<<j) & 0x80)
            {
                user_port_cnt++;

                if ((session_port_list[i]<<j) & 0x80)
                {
                    session_port_cnt++;
                }
                else
                {
                    break;
                }
            }
        }
    }

    /* verify user enter ports are member port of session group */
    if (user_port_cnt <= session_port_cnt)
    {
        return TRUE;
    }

    return FALSE;
}/* End of SWCTRL_IsPrivateVlanMemberPort()*/

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_IsPermitPrivateVlanTrunkPort
 * -------------------------------------------------------------------------
 * FUNCTION: This function will check user trunk index port has permit to pvlan
 * INPUT   : uplink_port_list     --  uplink port list
 *           downlink_port_list   --  downlink port list
 * OUTPUT  : None
 * RETURN  : True: Successfully, FALSE: Failed
 * NOTE    : None
 * -------------------------------------------------------------------------*/
 static BOOL_T SWCTRL_IsPermitPrivateVlanTrunkPort(UI32_T session_id,
                                                   UI8_T uplink_port_list[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST],
                                                   UI8_T downlink_port_list[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST])
{
    UI32_T  ifindex, i = 0;
    UI32_T  trunk_id = 0, port_ifindex, unit, port;

    /* For user port can't permit to pvlan when trunk index port is pvlan
     */
    for (ifindex=1; ifindex<=SYS_ADPT_TOTAL_NBR_OF_LPORT; ifindex++)
    {
        /* The port shall not with trunk index */
        if (((uplink_port_list[(ifindex-1)/8]<<((ifindex-1)%8))&0x80) ||
            ((downlink_port_list[(ifindex-1)/8]<<((ifindex-1)%8))&0x80))
        {
            /* check trunk index port dependence, somehow member port has pvlan */
            if (SWCTRL_IS_TRUNK(ifindex) == TRUE)
            {
                trunk_id  = SWCTRL_IFINDEX_TO_TRUNKID(ifindex);

                /* if trunk member is empty, do nothing */
                if (trunk_ext_port_info[trunk_id-1].member_number == 0)
                {
#if (SWCTRL_PORT_TRAFFIC_SEGMENTATION_AUTO_ATTRIBUTE == TRUE)
                    return FALSE;
#else
                    continue;
#endif
                }

                /* if user session_id has same to trunk sesion_id */
                if (swctl_private_vlan_trunk_port_info[trunk_id-1].session_id == session_id)
                {
                    continue;
                }

                /* check trunk member port has permit to pvlan */
                for(i=0; i<trunk_ext_port_info[trunk_id-1].member_number; i++)
                {
                    unit = trunk_ext_port_info[trunk_id-1].member_list[i].unit;
                    port = trunk_ext_port_info[trunk_id-1].member_list[i].port;
                    port_ifindex = SWCTRL_UPORT_TO_IFINDEX(unit, port);

                    /* check this port is pvlan of trunk index */
                    if ((TRUE == swctl_private_vlan_port_info[port_ifindex-1].is_pvlan_trunk_index_port) &&
                        (swctl_private_vlan_port_info[port_ifindex-1].port_trunk_index !=0x0))
                    {
                        return FALSE;
                    }
                }
            }/* End of if (SWCTRL_IS_TRUNK(ifindex) == TRUE) */
#if (SWCTRL_PORT_TRAFFIC_SEGMENTATION_AUTO_ATTRIBUTE == TRUE)
            else if (SWCTRL_IS_TRUNK_MEMBER(ifindex))
            {
                return FALSE;
            }
#endif

            /* check this port is pvlan of trunk index */
            if ((TRUE == swctl_private_vlan_port_info[ifindex-1].is_pvlan_trunk_index_port) &&
                (swctl_private_vlan_port_info[ifindex-1].port_trunk_index !=0x0))
            {
                return FALSE;
            }
        }/* End of the port shall not with trunk index */
    }

    return TRUE;
}/* End of SWCTRL_IsPermitPrivateVlanTrunkPort() */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_AddPrivateVlanTrunkPort
 * -------------------------------------------------------------------------
 * FUNCTION: This function will add private vlan to trunk port
 * INPUT   : trunk_ifindex -- trunk_index
 * OUTPUT  : None
 * RETURN  : True: Successfully, FALSE: Failed
 * NOTE    : None
 * -------------------------------------------------------------------------*/
static BOOL_T SWCTRL_AddPrivateVlanTrunkPort(UI32_T trunk_ifindex)
{
    UI32_T  unit, port, i=0;
    UI32_T  trunk_id, trunk_session_id=0, port_ifindex=0, ifindex=0;
    UI8_T   up_port_list[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST];
    UI8_T   dw_port_list[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST];
    UI8_T   trunk_upport_list[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST];
    UI8_T   trunk_dwport_list[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST];

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    /* check ifindex is trunk */
    if (SWCTRL_IS_TRUNK(trunk_ifindex) == FALSE)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
    }

    /* get trunk_id and trunk session_id */
    trunk_id         = SWCTRL_IFINDEX_TO_TRUNKID(trunk_ifindex);
    trunk_session_id = swctl_private_vlan_port_info[trunk_ifindex-1].session_id;

    /* if trunk member is empty, do nothing */
    if (trunk_ext_port_info[trunk_id-1].member_number == 0)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC(TRUE);
    }

    /* when trunk port session is 0x0, do nothing */
    if (swctl_private_vlan_trunk_port_info[trunk_id-1].session_id == 0x0)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC(TRUE);
    }

    memset(up_port_list, 0, SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST);
    memset(dw_port_list, 0, SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST);
    memset(trunk_upport_list, 0, SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST);
    memset(trunk_dwport_list, 0, SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST);

    /* update private vlan status for all trunk port member */
    for(i=0; i<trunk_ext_port_info[trunk_id-1].member_number; i++)
    {
        unit = trunk_ext_port_info[trunk_id-1].member_list[i].unit;
        port = trunk_ext_port_info[trunk_id-1].member_list[i].port;
        port_ifindex = SWCTRL_UPORT_TO_IFINDEX(unit, port);

        /* get user trunk index port is uplink or downlink port */
        if (swctl_private_vlan_port_info[trunk_ifindex-1].private_vlan_uplink_port == TRUE)
        {
            trunk_upport_list[ SWCTRL_BYTE_IN_BITMAP(port_ifindex) ] |= SWCTRL_BIT_IN_BITMAP(port_ifindex);
        }
        else
        {
            trunk_dwport_list[ SWCTRL_BYTE_IN_BITMAP(port_ifindex) ] |= SWCTRL_BIT_IN_BITMAP(port_ifindex);
        }

        /* collect all port pvlan status whether is uplink or downlink */
        if (swctl_private_vlan_port_info[port_ifindex-1].private_vlan_uplink_port == TRUE)
        {
            up_port_list[ SWCTRL_BYTE_IN_BITMAP(port_ifindex) ] |= SWCTRL_BIT_IN_BITMAP(port_ifindex);
        }
        else if (swctl_private_vlan_port_info[port_ifindex-1].private_vlan_downlink_port == TRUE)
        {
            dw_port_list[ SWCTRL_BYTE_IN_BITMAP(port_ifindex) ] |= SWCTRL_BIT_IN_BITMAP(port_ifindex);
        }
    }

    /* we'll keep status while private vlan disabled */
    if (system_info.is_private_vlan_enable == VAL_privateVlanStatus_enabled)
    {
        if (!SWDRV_SetPrivateVlanTrunkMode(
            swctl_private_vlan_trunk_port_info[trunk_id-1].session_id,
            trunk_id,
            swctl_private_vlan_port_info[trunk_ifindex-1].private_vlan_uplink_port))
        {
            SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
        }

        /* delete all port pvlan with specific session_id 0x0 */
        if (FALSE == SWDRV_DeletePrivateVlanPortlistBySessionId(0x0, up_port_list, dw_port_list))
        {
            SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
        }

        /* apply trunk session_id to all member ports */
        if (FALSE == SWDRV_SetPrivateVlanPortlistBySessionId(trunk_session_id, trunk_upport_list, trunk_dwport_list))
        {
            SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
        }
    }/* End of private vlan status enable*/

    /* update private vlan to trunk port info */
    for (ifindex=1; ifindex<=SYS_ADPT_TOTAL_NBR_OF_LPORT; ifindex++)
    {
        /* no trunk port can do it */
        if (SWCTRL_IS_TRUNK(ifindex) == TRUE)
        {
            break;
        }

        if((trunk_upport_list[(ifindex-1)/8]<<((ifindex-1)%8))&0x80 )
        {
            /* set member port can't allow to change pvlan status */
            swctl_private_vlan_port_info[ifindex-1].is_pvlan_trunk_index_port = TRUE;
            swctl_private_vlan_port_info[ifindex-1].port_trunk_index = trunk_id;
            swctl_private_vlan_trunk_port_info[trunk_id-1].pvlan_trunk_uplink_port_list[SWCTRL_BYTE_IN_BITMAP(ifindex)]
                                                                    |=  SWCTRL_BIT_IN_BITMAP(ifindex);

#if (SWCTRL_PORT_TRAFFIC_SEGMENTATION_AUTO_ATTRIBUTE == TRUE)
            /* trunk member follows trunk config
             */
            if (swctl_private_vlan_port_info[ifindex-1].session_id != 0)
            {
                UI32_T port_session_id = swctl_private_vlan_port_info[ifindex-1].session_id;

                if (swctl_private_vlan_port_info[ifindex-1].private_vlan_uplink_port)
                {
                    swctl_private_vlan_port_info[ifindex-1].private_vlan_uplink_port = FALSE;
                    swctl_private_vlan_ext_info[port_session_id-1].private_vlan_uplink_port_list[SWCTRL_BYTE_IN_BITMAP(ifindex)]
                                                                        &=  ~(SWCTRL_BIT_IN_BITMAP(ifindex));
                }
                if (swctl_private_vlan_port_info[ifindex-1].private_vlan_downlink_port)
                {
                    swctl_private_vlan_port_info[ifindex-1].private_vlan_downlink_port = FALSE;
                    swctl_private_vlan_ext_info[port_session_id-1].private_vlan_downlink_port_list[SWCTRL_BYTE_IN_BITMAP(ifindex)]
                                                                        &=  ~(SWCTRL_BIT_IN_BITMAP(ifindex));
                }
            }
            swctl_private_vlan_port_info[ifindex-1].private_vlan_uplink_port = TRUE;
            swctl_private_vlan_ext_info[trunk_session_id-1].private_vlan_uplink_port_list[SWCTRL_BYTE_IN_BITMAP(ifindex)]
                                                                |=  (SWCTRL_BIT_IN_BITMAP(ifindex));

            swctl_private_vlan_port_info[ifindex-1].session_id = trunk_session_id;
#endif
        }
        else if((trunk_dwport_list[(ifindex-1)/8]<<((ifindex-1)%8))&0x80 )
        {
            /* set member port can't allow to change pvlan status */
            swctl_private_vlan_port_info[ifindex-1].is_pvlan_trunk_index_port = TRUE;
            swctl_private_vlan_port_info[ifindex-1].port_trunk_index = trunk_id;
            swctl_private_vlan_trunk_port_info[trunk_id-1].pvlan_trunk_downlink_port_list[SWCTRL_BYTE_IN_BITMAP(ifindex)]
                                                                    |=  SWCTRL_BIT_IN_BITMAP(ifindex);
#if (SWCTRL_PORT_TRAFFIC_SEGMENTATION_AUTO_ATTRIBUTE == TRUE)
            /* trunk member follows trunk config
             */
            if (swctl_private_vlan_port_info[ifindex-1].session_id != 0)
            {
                UI32_T port_session_id = swctl_private_vlan_port_info[ifindex-1].session_id;

                if (swctl_private_vlan_port_info[ifindex-1].private_vlan_uplink_port)
                {
                    swctl_private_vlan_port_info[ifindex-1].private_vlan_uplink_port = FALSE;
                    swctl_private_vlan_ext_info[port_session_id-1].private_vlan_uplink_port_list[SWCTRL_BYTE_IN_BITMAP(ifindex)]
                                                                        &=  ~(SWCTRL_BIT_IN_BITMAP(ifindex));
                }
                if (swctl_private_vlan_port_info[ifindex-1].private_vlan_downlink_port)
                {
                    swctl_private_vlan_port_info[ifindex-1].private_vlan_downlink_port = FALSE;
                    swctl_private_vlan_ext_info[port_session_id-1].private_vlan_downlink_port_list[SWCTRL_BYTE_IN_BITMAP(ifindex)]
                                                                        &=  ~(SWCTRL_BIT_IN_BITMAP(ifindex));
                }
            }
            swctl_private_vlan_port_info[ifindex-1].private_vlan_downlink_port = TRUE;
            swctl_private_vlan_ext_info[trunk_session_id-1].private_vlan_downlink_port_list[SWCTRL_BYTE_IN_BITMAP(ifindex)]
                                                                |=  (SWCTRL_BIT_IN_BITMAP(ifindex));

            swctl_private_vlan_port_info[ifindex-1].session_id = trunk_session_id;
#endif
        }
    }

    SWCTRL_RETURN_AND_RELEASE_CSC(TRUE);

}/* End of SWCTRL_AddPrivateVlanTrunkPort() */

#if (SWCTRL_PORT_TRAFFIC_SEGMENTATION_AUTO_ATTRIBUTE != TRUE)
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_AddPrivateVlanTrunkMember
 * -------------------------------------------------------------------------
 * FUNCTION: This function will add trunk member to private vlan
 * INPUT   : trunk_ifindex -- trunk_index
 *           port_ifindex  -- port index
 * OUTPUT  : None
 * RETURN  : True: Successfully, FALSE: Failed
 * NOTE    : None
 * -------------------------------------------------------------------------*/
static BOOL_T SWCTRL_AddPrivateVlanTrunkMember(UI32_T trunk_ifindex, UI32_T port_ifindex)
{
    UI32_T  trunk_id, trunk_session_id=0, port_session_id=0, ifindex=0;
    UI8_T   up_port_list[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST];
    UI8_T   dw_port_list[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST];
    UI8_T   trunk_upport_list[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST];
    UI8_T   trunk_dwport_list[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST];

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    /* get trunk_id and trunk session_id */
    trunk_id         = SWCTRL_IFINDEX_TO_TRUNKID(trunk_ifindex);
    trunk_session_id = swctl_private_vlan_port_info[trunk_ifindex-1].session_id;

    /* when trunk index port is private vlan  */
    if (trunk_session_id != 0x0)
    {
        memset(up_port_list, 0, SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST);
        memset(dw_port_list, 0, SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST);
        memset(trunk_upport_list, 0, SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST);
        memset(trunk_dwport_list, 0, SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST);

        /* get user trunk index port is uplink or downlink port */
        if (swctl_private_vlan_port_info[trunk_ifindex-1].private_vlan_uplink_port == TRUE)
        {
            trunk_upport_list[ SWCTRL_BYTE_IN_BITMAP(port_ifindex) ] |= SWCTRL_BIT_IN_BITMAP(port_ifindex);
        }
        else if (swctl_private_vlan_port_info[trunk_ifindex-1].private_vlan_downlink_port == TRUE)
        {
            trunk_dwport_list[ SWCTRL_BYTE_IN_BITMAP(port_ifindex) ] |= SWCTRL_BIT_IN_BITMAP(port_ifindex);
        }

        /* collect all port pvlan status whether is uplink or downlink */
        if (swctl_private_vlan_port_info[port_ifindex-1].private_vlan_uplink_port == TRUE)
        {
            up_port_list[ SWCTRL_BYTE_IN_BITMAP(port_ifindex) ] |= SWCTRL_BIT_IN_BITMAP(port_ifindex);
        }
        else if (swctl_private_vlan_port_info[port_ifindex-1].private_vlan_downlink_port == TRUE)
        {
            dw_port_list[ SWCTRL_BYTE_IN_BITMAP(port_ifindex) ] |= SWCTRL_BIT_IN_BITMAP(port_ifindex);
        }

        /* get port session_id */
        port_session_id  = swctl_private_vlan_port_info[port_ifindex-1].session_id;

        if (port_session_id !=0x0)
        {
            /* we'll keep status while private vlan disabled */
            if (system_info.is_private_vlan_enable == VAL_privateVlanStatus_enabled)
            {
                /* delete port pvlan session */
                if (FALSE == SWDRV_DeletePrivateVlanPortlistBySessionId(port_session_id, up_port_list, dw_port_list))
                {
                    SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
                }
            }
        }

        /* we'll keep status while private vlan disabled */
        if (system_info.is_private_vlan_enable == VAL_privateVlanStatus_enabled)
        {
            /* Otherwise, trunk member port should be inherit their trunk's pvlan
             * But, we don't apply to swtcrl internal database
             */
            if (FALSE == SWDRV_SetPrivateVlanPortlistBySessionId(trunk_session_id, trunk_upport_list, trunk_dwport_list))
            {
                SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
            }
        }

        /* update private vlan trunk port index */
        for (ifindex=1; ifindex<=SYS_ADPT_TOTAL_NBR_OF_LPORT; ifindex++)
        {
            if(SWCTRL_IS_TRUNK(ifindex) == TRUE)
            {
                break;
            }

            if((trunk_upport_list[(ifindex-1)/8]<<((ifindex-1)%8))&0x80 )
            {
                swctl_private_vlan_trunk_port_info[trunk_id-1].pvlan_trunk_uplink_port_list[SWCTRL_BYTE_IN_BITMAP(ifindex)]
                                                                    |=  SWCTRL_BIT_IN_BITMAP(ifindex);
                /* set member port can't allow to change pvlan status */
                swctl_private_vlan_port_info[ifindex-1].is_pvlan_trunk_index_port = TRUE;
                swctl_private_vlan_port_info[ifindex-1].port_trunk_index = trunk_id;

            }
            else if((trunk_dwport_list[(ifindex-1)/8]<<((ifindex-1)%8))&0x80 )
            {
                swctl_private_vlan_trunk_port_info[trunk_id-1].pvlan_trunk_downlink_port_list[SWCTRL_BYTE_IN_BITMAP(ifindex)]
                                                                    |=  SWCTRL_BIT_IN_BITMAP(ifindex);
                /* set member port can't allow to change pvlan status */
                swctl_private_vlan_port_info[ifindex-1].is_pvlan_trunk_index_port = TRUE;
                swctl_private_vlan_port_info[ifindex-1].port_trunk_index = trunk_id;
            }
        }
    }/* End of  if (trunk_session_id != 0x0) */

    SWCTRL_RETURN_AND_RELEASE_CSC(TRUE);
} /* End of SWCTRL_AddPrivateVlanTrunkMember() */
#endif /* (SWCTRL_PORT_TRAFFIC_SEGMENTATION_AUTO_ATTRIBUTE == TRUE) */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_DeletePrivateVlanTrunkPort
 * -------------------------------------------------------------------------
 * FUNCTION: This function will delete trunk member port and recover
 * INPUT   : trunk_ifindex -- trunk_index
 * OUTPUT  : None
 * RETURN  : True: Successfully, FALSE: Failed
 * NOTE    : None
 * -------------------------------------------------------------------------*/
static BOOL_T SWCTRL_DeletePrivateVlanTrunkPort(UI32_T trunk_ifindex)
{
    UI32_T  unit, port, i=0;
    UI32_T  trunk_id, trunk_session_id=0, ifindex=0;
    UI8_T   up_port_list[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST];
    UI8_T   dw_port_list[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST];

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    /* check ifindex is trunk */
    if (SWCTRL_IS_TRUNK(trunk_ifindex) == FALSE)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
    }

    /* get trunk_id and trunk session_id */
    trunk_id         = SWCTRL_IFINDEX_TO_TRUNKID(trunk_ifindex);
    trunk_session_id = swctl_private_vlan_trunk_port_info[trunk_id-1].session_id;

    /* clean trunk index */
    swctl_private_vlan_trunk_port_info[trunk_id-1].session_id = 0x0;

    /* if trunk member is empty, do nothing */
    if(trunk_ext_port_info[trunk_id-1].member_number == 0)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC(TRUE);
    }

    /* when trunk port session is 0x0, do nothing */
    if (trunk_session_id == 0x0)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC(TRUE);
    }

    /* copy trunk index pvlan table */
    memset(up_port_list, 0, SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST);
    memset(dw_port_list, 0, SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST);
    memcpy(up_port_list, swctl_private_vlan_trunk_port_info[trunk_id-1].pvlan_trunk_uplink_port_list,
           sizeof(up_port_list));
    memcpy(dw_port_list, swctl_private_vlan_trunk_port_info[trunk_id-1].pvlan_trunk_downlink_port_list,
           sizeof(dw_port_list));

    /* we'll keep status while private vlan disabled */
    if (system_info.is_private_vlan_enable == VAL_privateVlanStatus_enabled)
    {
        /* delete all port pvlan by specific trunk session_id  */
        if (FALSE == SWDRV_DeletePrivateVlanPortlistBySessionId(trunk_session_id, up_port_list, dw_port_list))
        {
            SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
        }

#if (SWCTRL_PORT_TRAFFIC_SEGMENTATION_PORT_EGRESS_BLOCK == TRUE)
        if (!SWCTRL_PortEgressBlock_SetPrivateVlanTrunkMode(
            trunk_session_id,
            trunk_id,
            swctl_private_vlan_port_info[trunk_ifindex-1].private_vlan_uplink_port,
            FALSE))
        {
            SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
        }
#endif
    }

    /* clean this trunk port entry */
    memset(swctl_private_vlan_trunk_port_info[trunk_id-1].pvlan_trunk_uplink_port_list,
           0, SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST);
    memset(swctl_private_vlan_trunk_port_info[trunk_id-1].pvlan_trunk_downlink_port_list,
           0, SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST);

    /* update private vlan status for trunk port member */
    for(i=0; i<trunk_ext_port_info[trunk_id-1].member_number; i++)
    {
#if (SWCTRL_PORT_TRAFFIC_SEGMENTATION_AUTO_ATTRIBUTE == TRUE)
        unit = trunk_ext_port_info[trunk_id-1].member_list[i].unit;
        port = trunk_ext_port_info[trunk_id-1].member_list[i].port;
        ifindex = SWCTRL_UPORT_TO_IFINDEX(unit, port);

        swctl_private_vlan_port_info[ifindex-1].private_vlan_uplink_port = FALSE;
        swctl_private_vlan_ext_info[trunk_session_id-1].private_vlan_uplink_port_list[SWCTRL_BYTE_IN_BITMAP(ifindex)]
                                                            &=  ~(SWCTRL_BIT_IN_BITMAP(ifindex));
        swctl_private_vlan_trunk_port_info[trunk_id-1].pvlan_trunk_uplink_port_list[SWCTRL_BYTE_IN_BITMAP(ifindex)]
                                                            &=  ~(SWCTRL_BIT_IN_BITMAP(ifindex));

        swctl_private_vlan_port_info[ifindex-1].private_vlan_downlink_port = FALSE;
        swctl_private_vlan_ext_info[trunk_session_id-1].private_vlan_downlink_port_list[SWCTRL_BYTE_IN_BITMAP(ifindex)]
                                                            &=  ~(SWCTRL_BIT_IN_BITMAP(ifindex));
        swctl_private_vlan_trunk_port_info[trunk_id-1].pvlan_trunk_downlink_port_list[SWCTRL_BYTE_IN_BITMAP(ifindex)]
                                                            &=  ~(SWCTRL_BIT_IN_BITMAP(ifindex));

        swctl_private_vlan_port_info[ifindex-1].session_id = 0x0;
        swctl_private_vlan_port_info[ifindex-1].is_pvlan_trunk_index_port = FALSE;
        swctl_private_vlan_port_info[ifindex-1].port_trunk_index = 0x0;
#else
        UI32_T  port_ifindex, port_session_id;
        UI8_T   normal_port_list[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST];

        memset(up_port_list, 0, SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST);
        memset(dw_port_list, 0, SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST);
        memset(normal_port_list, 0, SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST);

        unit = trunk_ext_port_info[trunk_id-1].member_list[i].unit;
        port = trunk_ext_port_info[trunk_id-1].member_list[i].port;
        port_ifindex = SWCTRL_UPORT_TO_IFINDEX(unit, port);

        /* collect all port pvlan status whether is uplink or downlink */
        if (swctl_private_vlan_port_info[port_ifindex-1].private_vlan_uplink_port == TRUE)
        {
            up_port_list[ SWCTRL_BYTE_IN_BITMAP(port_ifindex) ] |= SWCTRL_BIT_IN_BITMAP(port_ifindex);
        }
        else if (swctl_private_vlan_port_info[port_ifindex-1].private_vlan_downlink_port == TRUE)
        {
            dw_port_list[ SWCTRL_BYTE_IN_BITMAP(port_ifindex) ] |= SWCTRL_BIT_IN_BITMAP(port_ifindex);
        }
        else
        {
            /* remove normal port trunk index attributes */
            normal_port_list[ SWCTRL_BYTE_IN_BITMAP(port_ifindex) ] |= SWCTRL_BIT_IN_BITMAP(port_ifindex);
        }

        /* recover private vlan to port session_id */
        port_session_id  = swctl_private_vlan_port_info[port_ifindex-1].session_id;

        if (port_session_id !=0x0)
        {
            /* we'll keep status while private vlan disabled */
            if (system_info.is_private_vlan_enable == VAL_privateVlanStatus_enabled)
            {
                /* set port pvlan session when port was pvlan before joined trunk index port */
                if (FALSE == SWDRV_SetPrivateVlanPortlistBySessionId(port_session_id, up_port_list, dw_port_list))
                {
                    SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
                }
            }
        }/* End of if (port_session_id !=0x0)*/

        /* update private vlan trunk port index */
        for (ifindex=1; ifindex<=SYS_ADPT_TOTAL_NBR_OF_LPORT; ifindex++)
        {
            if(SWCTRL_IS_TRUNK(ifindex) == TRUE)
            {
                break;
            }

            /* clean port private vlan has trunk index port */
            if( ((up_port_list[(ifindex-1)/8]<<((ifindex-1)%8))&0x80) ||
                ((dw_port_list[(ifindex-1)/8]<<((ifindex-1)%8))&0x80) ||
                ((normal_port_list[(ifindex-1)/8]<<((ifindex-1)%8))&0x80) )
            {
                swctl_private_vlan_port_info[ifindex-1].is_pvlan_trunk_index_port = FALSE;
                swctl_private_vlan_port_info[ifindex-1].port_trunk_index = 0x0;
            }
        }/* End of for (ifindex=1; ifindex<=SYS_ADPT_TOTAL_NBR_OF_LPORT; ifindex++) */
#endif /* (SWCTRL_PORT_TRAFFIC_SEGMENTATION_AUTO_ATTRIBUTE == TRUE) */
    }/* End of for(i=0; i<trunk_ext_port_info[trunk_id-1].member_number; i++) */

    SWCTRL_RETURN_AND_RELEASE_CSC(TRUE);
}/* End of SWCTRL_DeletePrivateVlanTrunkPort() */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_DeletePrivateVlanTrunkMember
 * -------------------------------------------------------------------------
 * FUNCTION: This function will delete trunk member from private vlan
 * INPUT   : trunk_ifindex     -- trunk index
 *           port_ifindex      -- port index
 * OUTPUT  : None
 * RETURN  : True: Successfully, FALSE: Failed
 * NOTE    : None
 * -------------------------------------------------------------------------*/
static BOOL_T SWCTRL_DeletePrivateVlanTrunkMember(UI32_T trunk_ifindex, UI32_T port_ifindex)
{
    UI32_T  trunk_id, trunk_session_id = 0, port_session_id = 0, ifindex = 0;
    UI32_T  unit, port, i=0, lport_ifindex;
    UI8_T   up_port_list[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST];
    UI8_T   dw_port_list[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST];
    UI8_T   trunk_upport_list[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST];
    UI8_T   trunk_dwport_list[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST];

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    /* get trunk_id and trunk session_id */
    trunk_id         = SWCTRL_IFINDEX_TO_TRUNKID(trunk_ifindex);
    trunk_session_id = swctl_private_vlan_port_info[trunk_ifindex-1].session_id;

    /* when trunk index port is private vlan then remove member port */
    if (trunk_session_id != 0x0)
    {
        /* get one of trunk member port has aggregation dev_id */
        for(i=0; i<trunk_ext_port_info[trunk_id-1].member_number; i++)
        {
            unit = trunk_ext_port_info[trunk_id-1].member_list[i].unit;
            port = trunk_ext_port_info[trunk_id-1].member_list[i].port;
            lport_ifindex = SWCTRL_UPORT_TO_IFINDEX(unit, port);

            /* this only synchronize for dev_id, 0x50, 0x51,...0x55 */
            if ((swctl_private_vlan_port_info[lport_ifindex-1].dev_id == 0x0) ||
                (swctl_private_vlan_port_info[lport_ifindex-1].dev_id == 0x8) ||
                (swctl_private_vlan_port_info[lport_ifindex-1].dev_id == 0xFF))
            {
                continue;
            }

            /* We found one of trunk member port is same dev_id
             * so keep trunk port session until empty
             */
            if (swctl_private_vlan_port_info[lport_ifindex-1].dev_id ==
                swctl_private_vlan_port_info[port_ifindex-1].dev_id)
            {
                SWCTRL_RETURN_AND_RELEASE_CSC(TRUE);
            }
        }/* End of trunks member loop */

        memset(up_port_list, 0, SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST);
        memset(dw_port_list, 0, SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST);
        memset(trunk_upport_list, 0, SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST);
        memset(trunk_dwport_list, 0, SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST);

        /* get user trunk index port is uplink or downlink port */
        if (swctl_private_vlan_port_info[trunk_ifindex-1].private_vlan_uplink_port == TRUE)
        {
            trunk_upport_list[ SWCTRL_BYTE_IN_BITMAP(port_ifindex) ] |= SWCTRL_BIT_IN_BITMAP(port_ifindex);
        }
        else if (swctl_private_vlan_port_info[trunk_ifindex-1].private_vlan_downlink_port == TRUE)
        {
            trunk_dwport_list[ SWCTRL_BYTE_IN_BITMAP(port_ifindex) ] |= SWCTRL_BIT_IN_BITMAP(port_ifindex);
        }

        /* collect all port pvlan status whether is uplink or downlink */
        if (swctl_private_vlan_port_info[port_ifindex-1].private_vlan_uplink_port == TRUE)
        {
            up_port_list[ SWCTRL_BYTE_IN_BITMAP(port_ifindex) ] |= SWCTRL_BIT_IN_BITMAP(port_ifindex);
        }
        else if (swctl_private_vlan_port_info[port_ifindex-1].private_vlan_downlink_port == TRUE)
        {
            dw_port_list[ SWCTRL_BYTE_IN_BITMAP(port_ifindex) ] |= SWCTRL_BIT_IN_BITMAP(port_ifindex);
        }

        /* we'll keep status while private vlan disabled */
        if (system_info.is_private_vlan_enable == VAL_privateVlanStatus_enabled)
        {
            /* According trunk index pvlan, which trunk members shall be remove pvlan
             * But, we don't update the swtcrl internal database
             */
            if (FALSE == SWDRV_DeletePrivateVlanPortlistBySessionId(trunk_session_id, trunk_upport_list, trunk_dwport_list))
            {
                SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
            }
        }

        /* recover private vlan of port configuration */
        port_session_id  = swctl_private_vlan_port_info[port_ifindex-1].session_id;

        if (port_session_id !=0x0)
        {
            /* we'll keep status while private vlan disabled */
            if (system_info.is_private_vlan_enable == VAL_privateVlanStatus_enabled)
            {
                /* set port pvlan session when port was pvlan before joined trunk index port */
                if (FALSE == SWDRV_SetPrivateVlanPortlistBySessionId(port_session_id, up_port_list, dw_port_list))
                {
                    SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
                }
            }
        }

        /* remove port index of pvlan from trunk port index */
        for (ifindex=1; ifindex<=SYS_ADPT_TOTAL_NBR_OF_LPORT; ifindex++)
        {
            if(SWCTRL_IS_TRUNK(ifindex) == TRUE)
            {
                break;
            }

            if((trunk_upport_list[(ifindex-1)/8]<<((ifindex-1)%8))&0x80 )
            {
                swctl_private_vlan_trunk_port_info[trunk_id-1].pvlan_trunk_uplink_port_list[SWCTRL_BYTE_IN_BITMAP(ifindex)]
                                                                    &=  ~(SWCTRL_BIT_IN_BITMAP(ifindex));
                swctl_private_vlan_port_info[ifindex-1].is_pvlan_trunk_index_port = FALSE;
                swctl_private_vlan_port_info[ifindex-1].port_trunk_index = 0x0;

            }
            else if((trunk_dwport_list[(ifindex-1)/8]<<((ifindex-1)%8))&0x80 )
            {
                swctl_private_vlan_trunk_port_info[trunk_id-1].pvlan_trunk_downlink_port_list[SWCTRL_BYTE_IN_BITMAP(ifindex)]
                                                                    &=  ~(SWCTRL_BIT_IN_BITMAP(ifindex));

                swctl_private_vlan_port_info[ifindex-1].is_pvlan_trunk_index_port = FALSE;
                swctl_private_vlan_port_info[ifindex-1].port_trunk_index = 0x0;
            }
        }/* End of for */

#if (SWCTRL_PORT_TRAFFIC_SEGMENTATION_AUTO_ATTRIBUTE == TRUE)
        /* if all members in trunk are deleted, clear trunk config.
         */
        if (trunk_ext_port_info[trunk_id-1].member_number == 0)
        {
            /* get user trunk index port is uplink or downlink port */
            if (swctl_private_vlan_port_info[trunk_ifindex-1].private_vlan_uplink_port == TRUE)
            {
                swctl_private_vlan_port_info[trunk_ifindex-1].private_vlan_uplink_port= FALSE;
                swctl_private_vlan_ext_info[trunk_session_id-1].private_vlan_uplink_port_list[SWCTRL_BYTE_IN_BITMAP(trunk_ifindex)]
                                                                    &=  ~(SWCTRL_BIT_IN_BITMAP(trunk_ifindex));
            }
            else if (swctl_private_vlan_port_info[trunk_ifindex-1].private_vlan_downlink_port == TRUE)
            {
                swctl_private_vlan_port_info[trunk_ifindex-1].private_vlan_downlink_port = FALSE;
                swctl_private_vlan_ext_info[trunk_session_id-1].private_vlan_downlink_port_list[SWCTRL_BYTE_IN_BITMAP(trunk_ifindex)]
                                                                    &=  ~(SWCTRL_BIT_IN_BITMAP(trunk_ifindex));
            }

            /* clean trunk index port */
            swctl_private_vlan_trunk_port_info[trunk_id-1].session_id = 0x0;
            swctl_private_vlan_port_info[trunk_ifindex-1].session_id = 0x0;
        }
#endif

    }/* End of  if (trunk_session_id != 0x0) */

    SWCTRL_RETURN_AND_RELEASE_CSC(TRUE);
}/* End of SWCTRL_DeletePrivateVlanTrunkMember() */

#if (SWCTRL_PORT_TRAFFIC_SEGMENTATION_AUTO_ATTRIBUTE == TRUE)
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_PrivateVlanTrunkFollowUserPortAttributes
 * -------------------------------------------------------------------------
 * FUNCTION: To copy the first member config to trunk
 * INPUT   : trunk_ifindex
 *           tm_ifindex
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
static BOOL_T SWCTRL_PrivateVlanTrunkFollowUserPortAttributes(UI32_T trunk_ifindex, UI32_T tm_ifindex)
{
    UI32_T ret = TRUE;
    UI32_T session_id;

    session_id = swctl_private_vlan_port_info[tm_ifindex-1].session_id;

    if (session_id != 0)
    {
        if (swctl_private_vlan_port_info[tm_ifindex-1].private_vlan_uplink_port)
        {
            swctl_private_vlan_port_info[trunk_ifindex-1].private_vlan_uplink_port = TRUE;
            swctl_private_vlan_ext_info[session_id-1].private_vlan_uplink_port_list[SWCTRL_BYTE_IN_BITMAP(trunk_ifindex)]
                                                                |=  SWCTRL_BIT_IN_BITMAP(trunk_ifindex);
        }
        else if (swctl_private_vlan_port_info[tm_ifindex-1].private_vlan_downlink_port)
        {
            swctl_private_vlan_port_info[trunk_ifindex-1].private_vlan_downlink_port = TRUE;
            swctl_private_vlan_ext_info[session_id-1].private_vlan_downlink_port_list[SWCTRL_BYTE_IN_BITMAP(trunk_ifindex)]
                                                                |=  SWCTRL_BIT_IN_BITMAP(trunk_ifindex);
        }
        swctl_private_vlan_port_info[trunk_ifindex-1].session_id = session_id;
        swctl_private_vlan_trunk_port_info[SWCTRL_IFINDEX_TO_TRUNKID(trunk_ifindex)-1].session_id = session_id;

        ret = SWCTRL_AddPrivateVlanTrunkPort(trunk_ifindex);
    }

    return ret;
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_PrivateVlanUserPortFollowTrunkAttributes
 * -------------------------------------------------------------------------
 * FUNCTION: To copy trunk config to user port
 * INPUT   : uport_ifindex
 *           trunk_ifindex
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
static BOOL_T SWCTRL_PrivateVlanUserPortFollowTrunkAttributes(UI32_T uport_ifindex, UI32_T trunk_ifindex)
{
    UI32_T  trunk_id, trunk_session_id=0, port_session_id=0;
    UI8_T   up_port_list[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST];
    UI8_T   dw_port_list[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST];
    UI8_T   trunk_upport_list[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST];
    UI8_T   trunk_dwport_list[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST];

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    /* when trunk index port is private vlan  */
    memset(up_port_list, 0, SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST);
    memset(dw_port_list, 0, SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST);
    memset(trunk_upport_list, 0, SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST);
    memset(trunk_dwport_list, 0, SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST);

    /* get user trunk index port is uplink or downlink port */
    if (swctl_private_vlan_port_info[trunk_ifindex-1].private_vlan_uplink_port == TRUE)
    {
        trunk_upport_list[ SWCTRL_BYTE_IN_BITMAP(uport_ifindex) ] |= SWCTRL_BIT_IN_BITMAP(uport_ifindex);
    }
    else if (swctl_private_vlan_port_info[trunk_ifindex-1].private_vlan_downlink_port == TRUE)
    {
        trunk_dwport_list[ SWCTRL_BYTE_IN_BITMAP(uport_ifindex) ] |= SWCTRL_BIT_IN_BITMAP(uport_ifindex);
    }

    /* collect all port pvlan status whether is uplink or downlink */
    if (swctl_private_vlan_port_info[uport_ifindex-1].private_vlan_uplink_port == TRUE)
    {
        up_port_list[ SWCTRL_BYTE_IN_BITMAP(uport_ifindex) ] |= SWCTRL_BIT_IN_BITMAP(uport_ifindex);
    }
    else if (swctl_private_vlan_port_info[uport_ifindex-1].private_vlan_downlink_port == TRUE)
    {
        dw_port_list[ SWCTRL_BYTE_IN_BITMAP(uport_ifindex) ] |= SWCTRL_BIT_IN_BITMAP(uport_ifindex);
    }

    /* get port session_id */
    port_session_id  = swctl_private_vlan_port_info[uport_ifindex-1].session_id;

    if (port_session_id != 0x0)
    {
        /* we'll keep status while private vlan disabled */
        if (system_info.is_private_vlan_enable == VAL_privateVlanStatus_enabled)
        {
            /* delete port pvlan session */
            if (FALSE == SWDRV_DeletePrivateVlanPortlistBySessionId(port_session_id, up_port_list, dw_port_list))
            {
                SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
            }
        }

        /* cleartrunk member follows trunk config
         */
        if (swctl_private_vlan_port_info[uport_ifindex-1].private_vlan_uplink_port)
        {
            swctl_private_vlan_port_info[uport_ifindex-1].private_vlan_uplink_port = FALSE;
            swctl_private_vlan_ext_info[port_session_id-1].private_vlan_uplink_port_list[SWCTRL_BYTE_IN_BITMAP(uport_ifindex)]
                                                                &=  ~(SWCTRL_BIT_IN_BITMAP(uport_ifindex));
        }
        if (swctl_private_vlan_port_info[uport_ifindex-1].private_vlan_downlink_port)
        {
            swctl_private_vlan_port_info[uport_ifindex-1].private_vlan_downlink_port = FALSE;
            swctl_private_vlan_ext_info[port_session_id-1].private_vlan_downlink_port_list[SWCTRL_BYTE_IN_BITMAP(uport_ifindex)]
                                                                &=  ~(SWCTRL_BIT_IN_BITMAP(uport_ifindex));
        }

        swctl_private_vlan_port_info[uport_ifindex-1].is_pvlan_trunk_index_port = FALSE;
        swctl_private_vlan_port_info[uport_ifindex-1].port_trunk_index = 0x0;

        swctl_private_vlan_port_info[uport_ifindex-1].private_vlan_uplink_port = FALSE;
        swctl_private_vlan_port_info[uport_ifindex-1].session_id = 0;
    } /* end of if (port_session_id != 0x0) */

    /* get trunk_id and trunk session_id */
    trunk_id         = SWCTRL_IFINDEX_TO_TRUNKID(trunk_ifindex);
    trunk_session_id = swctl_private_vlan_port_info[trunk_ifindex-1].session_id;

    if (trunk_session_id != 0x0)
    {
        /* we'll keep status while private vlan disabled */
        if (system_info.is_private_vlan_enable == VAL_privateVlanStatus_enabled)
        {
            /* Otherwise, trunk member port should be inherit their trunk's pvlan
             * But, we don't apply to swtcrl internal database
             */
            if (FALSE == SWDRV_SetPrivateVlanPortlistBySessionId(trunk_session_id, trunk_upport_list, trunk_dwport_list))
            {
                SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
            }
        }

        if((trunk_upport_list[(uport_ifindex-1)/8]<<((uport_ifindex-1)%8))&0x80 )
        {
            swctl_private_vlan_trunk_port_info[trunk_id-1].pvlan_trunk_uplink_port_list[SWCTRL_BYTE_IN_BITMAP(uport_ifindex)]
                                                                |=  SWCTRL_BIT_IN_BITMAP(uport_ifindex);
            /* set member port can't allow to change pvlan status */
            swctl_private_vlan_port_info[uport_ifindex-1].is_pvlan_trunk_index_port = TRUE;
            swctl_private_vlan_port_info[uport_ifindex-1].port_trunk_index = trunk_id;

            /* trunk member follows trunk config
             */
            swctl_private_vlan_port_info[uport_ifindex-1].private_vlan_uplink_port = TRUE;
            swctl_private_vlan_ext_info[trunk_session_id-1].private_vlan_uplink_port_list[SWCTRL_BYTE_IN_BITMAP(uport_ifindex)]
                                                                |=  (SWCTRL_BIT_IN_BITMAP(uport_ifindex));

            swctl_private_vlan_port_info[uport_ifindex-1].session_id = trunk_session_id;
        }
        else if((trunk_dwport_list[(uport_ifindex-1)/8]<<((uport_ifindex-1)%8))&0x80 )
        {
            swctl_private_vlan_trunk_port_info[trunk_id-1].pvlan_trunk_downlink_port_list[SWCTRL_BYTE_IN_BITMAP(uport_ifindex)]
                                                                |=  SWCTRL_BIT_IN_BITMAP(uport_ifindex);
            /* set member port can't allow to change pvlan status */
            swctl_private_vlan_port_info[uport_ifindex-1].is_pvlan_trunk_index_port = TRUE;
            swctl_private_vlan_port_info[uport_ifindex-1].port_trunk_index = trunk_id;

            /* trunk member follows trunk config
             */
            swctl_private_vlan_port_info[uport_ifindex-1].private_vlan_downlink_port = TRUE;
            swctl_private_vlan_ext_info[trunk_session_id-1].private_vlan_downlink_port_list[SWCTRL_BYTE_IN_BITMAP(uport_ifindex)]
                                                                |=  (SWCTRL_BIT_IN_BITMAP(uport_ifindex));

            swctl_private_vlan_port_info[uport_ifindex-1].session_id = trunk_session_id;
        }
    } /* end of if (trunk_session_id != 0x0) */

    SWCTRL_RETURN_AND_RELEASE_CSC(TRUE);
}
#endif /* (SWCTRL_PORT_TRAFFIC_SEGMENTATION_AUTO_ATTRIBUTE == TRUE) */

#if (SWCTRL_PORT_TRAFFIC_SEGMENTATION_PORT_EGRESS_BLOCK == TRUE)
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_PortEgressBlock_EnableTrafficSegmatation
 * -------------------------------------------------------------------------
 * FUNCTION: This function will enable the traffic segematation
 * INPUT   : None
 * OUTPUT  : None
 * RETURN  : True: Successfully, FALSE: Failed
 * NOTE    : None
 * -------------------------------------------------------------------------*/
static BOOL_T SWCTRL_PortEgressBlock_EnableTrafficSegmatation()
{
    return TRUE;
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_PortEgressBlock_DisableTrafficSegmatation
 * -------------------------------------------------------------------------
 * FUNCTION: This function will disable the traffic segmatation
 * INPUT   : None
 * OUTPUT  : None
 * RETURN  : True: Successfully, FALSE: Failed
 * NOTE    : None
 * -------------------------------------------------------------------------*/
static BOOL_T SWCTRL_PortEgressBlock_DisableTrafficSegmatation()
{
    UI32_T ifindex;
    BOOL_T ret = TRUE;

    for (ifindex = 1; ifindex <= SYS_ADPT_TOTAL_NBR_OF_LPORT; ifindex++)
    {
        if (!SWCTRL_IS_EXIST(ifindex))
        {
            continue;
        }

        if (swctl_private_vlan_port_info[ifindex-1].session_id != 0)
        {
            ret = ret &&
                SWCTRL_SetPortEgressBlockEx(ifindex, NULL, NULL);
        }
    }

    return TRUE;
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_PortEgressBlock_SetPrivateVlanPortlistBySessionId
 * -------------------------------------------------------------------------
 * FUNCTION: This function will set the private vlan by session group
 * INPUT   : session_id         -- session id to pvlan group
 *           uplink_port_list   -- uplink port list
 *           downlink_port_list -- downlink port list
 * OUTPUT  : None
 * RETURN  : True: Successfully, FALSE: Failed
 * NOTE    : None
 * -------------------------------------------------------------------------*/
static BOOL_T SWCTRL_PortEgressBlock_SetPrivateVlanPortlistBySessionId(
    UI32_T session_id,
    UI8_T  *uplink_port_list,
    UI8_T  *downlink_port_list)
{
    UI8_T uplink_egr_blk_lport_list[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST];
    UI8_T downlink_egr_blk_lport_list[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST];
    UI32_T ifindex;
    UI32_T byte_index;
    UI8_T bit_value;
    BOOL_T is_uplink, is_downlink, tmp_session_id;
    BOOL_T ret = TRUE;

    /* prepare uplink_egr_blk_lport_list/downlink_egr_blk_lport_list
     *
     * for uplink,
     *   uplink_to_uplink_mode == BLOCKING
     *     block ports in other sessions.
     *   uplink_to_uplink_mode == FORWARDING
     *     block downlink ports in other sessions.
     *
     * for downlink,
     *   block ports in other sessions, other downlink ports and normal ports.
     *
     */
    memset(uplink_egr_blk_lport_list, 0, sizeof(uplink_egr_blk_lport_list));
    memset(downlink_egr_blk_lport_list, 0, sizeof(downlink_egr_blk_lport_list));

    for (ifindex = 1; ifindex <= SYS_ADPT_TOTAL_NBR_OF_LPORT; ifindex++)
    {
        byte_index = SWCTRL_BYTE_IN_BITMAP(ifindex);
        bit_value = SWCTRL_BIT_IN_BITMAP(ifindex);

        tmp_session_id = 0;
        is_uplink = is_downlink = FALSE;

        if ((uplink_port_list[byte_index] & bit_value))
        {
            is_uplink = TRUE;
            tmp_session_id = session_id;
        }
        else if ((downlink_port_list[byte_index] & bit_value))
        {
            is_downlink = TRUE;
            tmp_session_id = session_id;
        }
        else if (swctl_private_vlan_port_info[ifindex-1].session_id != 0)
        {
            tmp_session_id = swctl_private_vlan_port_info[ifindex-1].session_id;
            is_uplink = swctl_private_vlan_port_info[ifindex-1].private_vlan_uplink_port;
            is_downlink = swctl_private_vlan_port_info[ifindex-1].private_vlan_downlink_port;
        }

        if (tmp_session_id == 0)
        {
            downlink_egr_blk_lport_list[byte_index] |= bit_value;
        }
        else if (tmp_session_id == session_id)
        {
            if (is_downlink)
            {
                downlink_egr_blk_lport_list[byte_index] |= bit_value;
            }
        }
        else
        {
            if (is_uplink)
            {
                if (system_info.is_blocking_uplink_to_uplink_mode == SYS_DFLT_TRAFFIC_SEG_UPLINK_TO_UPLINK_MODE_BLOCKING)
                {
                    uplink_egr_blk_lport_list[byte_index] |= bit_value;
                }
            }

            if (is_downlink)
            {
                uplink_egr_blk_lport_list[byte_index] |= bit_value;
            }

            downlink_egr_blk_lport_list[byte_index] |= bit_value;
        }
    } /* end of for (ifindex) */

    /* update egr_blk_lport_list for all traffic seg ports
     *
     * for uplink_port_list
     *   set with uplink_egr_blk_lport_list
     *
     * for downlink_port_list
     *   set with downlink_egr_blk_lport_list
     *
     * for this session,
     *   uplink: no change
     *   downlink: del with uplink_port_list
     *
     * for other session,
     *   uplink: add with
     *              uplink_port_list if is_blocking_uplink_to_uplink_mode = BLOCKING
     *              downlink_port_list
     *   downlink: no change
     *
     */
    for (ifindex = 1; ifindex <= SYS_ADPT_TOTAL_NBR_OF_LPORT; ifindex++)
    {
        if (!SWCTRL_IS_EXIST(ifindex))
        {
            continue;
        }

        byte_index = SWCTRL_BYTE_IN_BITMAP(ifindex);
        bit_value = SWCTRL_BIT_IN_BITMAP(ifindex);

        if ((uplink_port_list[byte_index] & bit_value))
        {
            ret = ret &&
                SWCTRL_SetPortEgressBlockEx(ifindex, NULL, uplink_egr_blk_lport_list);
        }
        else if ((downlink_port_list[byte_index] & bit_value))
        {
            ret = ret &&
                SWCTRL_SetPortEgressBlockEx(ifindex, NULL, downlink_egr_blk_lport_list);
        }
        else if (swctl_private_vlan_port_info[ifindex-1].session_id != 0)
        {
            if (swctl_private_vlan_port_info[ifindex-1].session_id == session_id)
            {
                if (swctl_private_vlan_port_info[ifindex-1].private_vlan_downlink_port)
                {
                    ret = ret &&
                        SWCTRL_SetPortEgressBlockEx(ifindex, uplink_port_list, NULL);
                }
            }
            else
            {
                if (swctl_private_vlan_port_info[ifindex-1].private_vlan_uplink_port)
                {
                    if (system_info.is_blocking_uplink_to_uplink_mode == SYS_DFLT_TRAFFIC_SEG_UPLINK_TO_UPLINK_MODE_BLOCKING)
                    {
                        ret = ret &&
                            SWCTRL_SetPortEgressBlockEx(ifindex, uplink_port_list, uplink_port_list);
                    }
                    ret = ret &&
                        SWCTRL_SetPortEgressBlockEx(ifindex, downlink_port_list, downlink_port_list);
                }
            }
        }
    } /* end of for (ifindex) */

    return ret;
} /* end of SWCTRL_PortEgressBlock_SetPrivateVlanPortlistBySessionId */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_PortEgressBlock_DeletePrivateVlanPortlistBySessionId
 * -------------------------------------------------------------------------
 * FUNCTION: This function will delete the private vlan by session group
 * INPUT   : session_id         -- session id to pvlan group
 *           uplink_port_list   -- uplink port list
 *           downlink_port_list -- downlink port list
 * OUTPUT  : None
 * RETURN  : True: Successfully, FALSE: Failed
 * NOTE    : None
 * -------------------------------------------------------------------------*/
static BOOL_T SWCTRL_PortEgressBlock_DeletePrivateVlanPortlistBySessionId(
    UI32_T session_id,
    UI8_T  *uplink_port_list,
    UI8_T  *downlink_port_list)
{
    UI32_T ifindex;
    UI32_T byte_index;
    UI8_T bit_value;
    BOOL_T ret = TRUE;

    /* update egr_blk_lport_list for all traffic seg ports
     *
     * for uplink_port_list
     *   clear egr_blk_lport_list
     *
     * for downlink_port_list
     *   clear egr_blk_lport_list
     *
     * for this session,
     *   uplink: no change
     *   downlink: add with uplink_port_list
     *
     * for other session,
     *   uplink: del with
     *              uplink_port_list if uplink_to_uplink_mode = BLOCKING
     *              downlink_port_list
     *   downlink: no change
     *
     */
    for (ifindex = 1; ifindex <= SYS_ADPT_TOTAL_NBR_OF_LPORT; ifindex++)
    {
        if (!SWCTRL_IS_EXIST(ifindex))
        {
            continue;
        }

        byte_index = SWCTRL_BYTE_IN_BITMAP(ifindex);
        bit_value = SWCTRL_BIT_IN_BITMAP(ifindex);

        if ((uplink_port_list[byte_index] & bit_value))
        {
            ret = ret &&
                SWCTRL_SetPortEgressBlockEx(ifindex, NULL, NULL);
        }
        else if ((downlink_port_list[byte_index] & bit_value))
        {
            ret = ret &&
                SWCTRL_SetPortEgressBlockEx(ifindex, NULL, NULL);
        }
        else if (swctl_private_vlan_port_info[ifindex-1].session_id != 0)
        {
            if (swctl_private_vlan_port_info[ifindex-1].session_id == session_id)
            {
                if (swctl_private_vlan_port_info[ifindex-1].private_vlan_downlink_port)
                {
                    ret = ret &&
                        SWCTRL_SetPortEgressBlockEx(ifindex, uplink_port_list, uplink_port_list);
                }
            }
            else
            {
                if (swctl_private_vlan_port_info[ifindex-1].private_vlan_uplink_port)
                {
                    if (system_info.is_blocking_uplink_to_uplink_mode == SYS_DFLT_TRAFFIC_SEG_UPLINK_TO_UPLINK_MODE_BLOCKING)
                    {
                        ret = ret &&
                            SWCTRL_SetPortEgressBlockEx(ifindex, uplink_port_list, NULL);
                    }

                    ret = ret &&
                        SWCTRL_SetPortEgressBlockEx(ifindex, downlink_port_list, NULL);
                }
            }
        }
    } /* end of for (ifindex) */
    return ret;
} /* end of SWCTRL_PortEgressBlock_DeletePrivateVlanPortlistBySessionId */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_PortEgressBlock_SetPrivateVlanUplinkToUplinkBlockingMode
 * -------------------------------------------------------------------------
 * FUNCTION: This function will enable blocking traffic of uplink ports
 * INPUT   : enable
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
static BOOL_T SWCTRL_PortEgressBlock_SetPrivateVlanUplinkToUplinkBlockingMode(
    BOOL_T enable)
{
    UI8_T uplink_port_list[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST];
    UI8_T uplink_egr_blk_lport_list[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST];
    UI32_T ifindex;
    UI32_T session_id;
    UI32_T byte_index;
    UI8_T bit_value;
    BOOL_T ret = TRUE;

    /* prepare uplink_port_list
     */
    memset(uplink_port_list, 0, sizeof(uplink_port_list));

    for (ifindex = 1; ifindex <= SYS_ADPT_TOTAL_NBR_OF_LPORT; ifindex++)
    {
        if (swctl_private_vlan_port_info[ifindex-1].session_id == 0)
        {
            continue;
        }

        if (!swctl_private_vlan_port_info[ifindex-1].private_vlan_uplink_port)
        {
            continue;
        }

        byte_index = SWCTRL_BYTE_IN_BITMAP(ifindex);
        bit_value = SWCTRL_BIT_IN_BITMAP(ifindex);

        uplink_port_list[byte_index] |= bit_value;
    } /* end of for (ifindex) */

    /* update egr_blk_lport_list for all uplink ports
     */
    for (session_id = 1; session_id <= SYS_ADPT_PORT_TRAFFIC_SEGMENTATION_MAX_NBR_OF_SESSIONS; session_id++)
    {
        int i;

        if (!swctl_private_vlan_ext_info[session_id-1].is_valid)
        {
            continue;
        }

        memcpy(uplink_egr_blk_lport_list, uplink_port_list, sizeof(uplink_egr_blk_lport_list));

        for (i = 0; i < SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST; i++)
        {
            uplink_egr_blk_lport_list[i] &=
                ~ swctl_private_vlan_ext_info[session_id-1].private_vlan_uplink_port_list[i];
        }

        for (ifindex = 1; ifindex <= SYS_ADPT_TOTAL_NBR_OF_LPORT; ifindex++)
        {
            byte_index = SWCTRL_BYTE_IN_BITMAP(ifindex);
            bit_value = SWCTRL_BIT_IN_BITMAP(ifindex);

            if (!(swctl_private_vlan_ext_info[session_id-1].private_vlan_uplink_port_list[byte_index] & bit_value))
            {
                continue;
            }

            if (enable)
            {
                ret = ret && SWCTRL_SetPortEgressBlockEx(ifindex, uplink_egr_blk_lport_list, uplink_egr_blk_lport_list);
            }
            else
            {
                ret = ret && SWCTRL_SetPortEgressBlockEx(ifindex, uplink_egr_blk_lport_list, NULL);
            }
        }
    } /* end of for (session_id) */

    return ret;
} /* end of SWCTRL_PortEgressBlock_SetPrivateVlanUplinkToUplinkBlockingMode */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_PortEgressBlock_SetPrivateVlanTrunkMode
 * -------------------------------------------------------------------------
 * FUNCTION: This function will set status of private vlan of trunk id
 * INPUT   : session_id
 *           trunk_id
 *           is_uplink
 *           is_add
 * OUTPUT  : None
 * RETURN  : True: Successfully, FALSE: Failed
 * NOTE    : None
 * -------------------------------------------------------------------------*/
static BOOL_T SWCTRL_PortEgressBlock_SetPrivateVlanTrunkMode(
    UI32_T session_id,
    UI32_T trunk_id,
    BOOL_T is_uplink,
    BOOL_T is_add)
{
    UI8_T uplink_port_list[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST];
    UI8_T downlink_port_list[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST];
    UI32_T ifindex;
    UI32_T byte_index;
    UI8_T bit_value;
    BOOL_T ret;

    ifindex = SWCTRL_TRUNKID_TO_IFINDEX(trunk_id);

    byte_index = SWCTRL_BYTE_IN_BITMAP(ifindex);
    bit_value = SWCTRL_BIT_IN_BITMAP(ifindex);

    memset(uplink_port_list, 0, sizeof(uplink_port_list));
    memset(downlink_port_list, 0, sizeof(downlink_port_list));

    if (is_uplink)
    {
        uplink_port_list[byte_index] |= bit_value;
    }
    else
    {
        downlink_port_list[byte_index] |= bit_value;
    }

    if (is_add)
    {
        ret = SWCTRL_PortEgressBlock_SetPrivateVlanPortlistBySessionId(session_id, uplink_port_list, downlink_port_list);
    }
    else
    {
        ret = SWCTRL_PortEgressBlock_DeletePrivateVlanPortlistBySessionId(session_id, uplink_port_list, downlink_port_list);
    }

    return ret;
}
#endif /* (SWCTRL_PORT_TRAFFIC_SEGMENTATION_PORT_EGRESS_BLOCK == TRUE) */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_IsUserPortJoinPrivateVlanToTrunk
 * -------------------------------------------------------------------------
 * FUNCTION: Check if this user port could be trunk member or not for pvlan
 * INPUT   : trunk_id   -- which trunking port to set
 *           unit_port  -- member to add
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_IsUserPortJoinPrivateVlanToTrunk(UI32_T trunk_id, SYS_TYPE_Uport_T unit_port)
{
    UI32_T uport_ifindex = SWCTRL_UPORT_TO_IFINDEX(unit_port.unit, unit_port.port);

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    /* check trunk id
     */
    if( trunk_id < 1 || trunk_id > SYS_ADPT_MAX_NBR_OF_TRUNK_PER_SYSTEM )
    {
        SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
    }

    /* Trunk index has no member and pvlan session */
    if ((swctl_private_vlan_trunk_port_info[trunk_id-1].session_id == 0x0) &&
        (trunk_ext_port_info[trunk_id-1].member_number == 0))
    {
        SWCTRL_RETURN_AND_RELEASE_CSC(TRUE);
    }
    else if ((swctl_private_vlan_trunk_port_info[trunk_id-1].session_id == 0x0) &&
             (trunk_ext_port_info[trunk_id-1].member_number > 0))
    {
        SWCTRL_RETURN_AND_RELEASE_CSC(TRUE);
    }

    /* For user port can't permit to pvlan when trunk index port is pvlan
     */
    if ((TRUE == swctl_private_vlan_port_info[uport_ifindex-1].is_pvlan_trunk_index_port) &&
        (swctl_private_vlan_port_info[uport_ifindex-1].port_trunk_index !=0x0))
    {
        /* For pvlan trunk session, logical ports are aggregation to physical port */
        if (swctl_private_vlan_port_info[uport_ifindex-1].port_trunk_index == trunk_id)
        {
            SWCTRL_RETURN_AND_RELEASE_CSC(TRUE);
        }
        else
        {
            SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
        }
    }

    SWCTRL_RETURN_AND_RELEASE_CSC(TRUE);
}/* End of SWCTRL_IsUserPortJoinPrivateVlanToTrunk()*/

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_DestroyPrivateVlanSession
 * -------------------------------------------------------------------------
 * FUNCTION: Destroy entire Private VLAN session
 * INPUT   : session_id   -- pvlan group id
 *           is_uplink    -- is uplink port
 *           is_downlink  -- is downlink port
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_DestroyPrivateVlanSession(UI32_T session_id, BOOL_T is_uplink, BOOL_T is_downlink)
{
    UI8_T  up_port_list[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST];
    UI8_T  dw_port_list[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST];
    BOOL_T destroy_all = FALSE;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    /* check session id */
    if (session_id > SYS_ADPT_PORT_TRAFFIC_SEGMENTATION_MAX_NBR_OF_SESSIONS)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
    }

    /* clean uplink or downlink port list */
    if ((is_uplink == FALSE)&&(is_downlink == FALSE))
    {
        SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
    }
    else
    {
        memset(up_port_list, 0, SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST);
        memset(dw_port_list, 0, SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST);

        /* clean all port list flag */
        if ((is_uplink == TRUE)&&(is_downlink == TRUE))
        {
            destroy_all = TRUE;
        }

        /* get pvlan port list */
        if (FALSE == SWCTRL_GetPrivateVlanBySessionId(session_id, up_port_list, dw_port_list))
        {
            SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
        }

        if (destroy_all == FALSE)
        {
            if (is_uplink == TRUE)
            {
                memset(dw_port_list, 0, SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST);
            }
            else
            {
                memset(up_port_list, 0, SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST);
            }
        }

        /* destroy 1st session group */
        if (FALSE == SWCTRL_DeletePrivateVlanPortlistBySessionId_(session_id, up_port_list, dw_port_list))
        {
            SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
        }

        /* get pvlan from port entry */
        memset(up_port_list, 0, SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST);
        memset(dw_port_list, 0, SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST);

        /* when private vlan is trunk port before, so we shall remove none trunk port again */
        if (TRUE == SWCTRL_GetPrivateVlanBySessionId(session_id, up_port_list, dw_port_list))
        {
            if (destroy_all == FALSE)
            {
                if (is_uplink == TRUE)
                {
                    memset(dw_port_list, 0, SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST);
                }
                else
                {
                    memset(up_port_list, 0, SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST);
                }
            }

            /* destroy 2nd session group */
            if (FALSE == SWCTRL_DeletePrivateVlanPortlistBySessionId_(session_id, up_port_list, dw_port_list))
            {
                SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
            }
        }/* End of remove none trunk port of pvlan */

        /* set session invalid status */
        if (destroy_all == TRUE)
        {
            swctl_private_vlan_ext_info[session_id-1].is_valid = FALSE;
        }
    }

    SWCTRL_RETURN_AND_RELEASE_CSC(TRUE);
}/* End of SWCTRL_DestroyPrivateVlanSession() */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_EnablePrivateVlanUplinkToUplinkBlockingMode
 * -------------------------------------------------------------------------
 * FUNCTION: This function will enable blocking traffic of uplink ports
 * INPUT   : None
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_EnablePrivateVlanUplinkToUplinkBlockingMode()
{
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (system_info.is_blocking_uplink_to_uplink_mode == SYS_DFLT_TRAFFIC_SEG_UPLINK_TO_UPLINK_MODE_BLOCKING)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC(TRUE);
    }

    if (FALSE ==  SWDRV_EnablePrivateVlanUplinkToUplinkBlockingMode())
    {
        SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
    }

    /* updated is blocking mode variable */
    system_info.is_blocking_uplink_to_uplink_mode = SYS_DFLT_TRAFFIC_SEG_UPLINK_TO_UPLINK_MODE_BLOCKING;
    SWCTRL_RETURN_AND_RELEASE_CSC(TRUE);
}/* End of SWCTRL_EnablePrivateVlanUplinkToUplinkBlockingMode() */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_DisablePrivateVlanUplinkToUplinkBlockingMode
 * -------------------------------------------------------------------------
 * FUNCTION: This function will disable blocking traffic of uplink ports
 *           so every traffic can be forwarding different uplink ports
 * INPUT   : None
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_DisablePrivateVlanUplinkToUplinkBlockingMode()
{
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (system_info.is_blocking_uplink_to_uplink_mode == SYS_DFLT_TRAFFIC_SEG_UPLINK_TO_UPLINK_MODE_FORWARDING)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC(TRUE);
    }

    if (FALSE == SWDRV_DisablePrivateVlanUplinkToUplinkBlockingMode())
    {
        SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
    }

    /* updated blocking mode status to forwarding */
    system_info.is_blocking_uplink_to_uplink_mode = SYS_DFLT_TRAFFIC_SEG_UPLINK_TO_UPLINK_MODE_FORWARDING;

    SWCTRL_RETURN_AND_RELEASE_CSC(TRUE);
}/* End of SWCTRL_DisablePrivateVlanUplinkToUplinkBlockingMode*/

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetRunningPrivateVlanUplinkToUplinkStatus
 * -------------------------------------------------------------------------
 * FUNCTION: This function will get private vlan uplink-to-uplink mode
 * INPUT   : None
 * OUTPU   : up_status -- uplink-to-uplink mode (blocking/forwarding)
 * RETURN  : SYS_TYPE_Get_Running_Cfg_T
 * NOTE    : None
 * -------------------------------------------------------------------------*/
SYS_TYPE_Get_Running_Cfg_T SWCTRL_GetRunningPrivateVlanUplinkToUplinkStatus(UI32_T *up_status)
{
    SWCTRL_USE_CSC_CHECK_OPER_MODE(SYS_TYPE_GET_RUNNING_CFG_FAIL);

    if (up_status == 0)
    {
        EH_MGR_Handle_Exception (SYS_MODULE_SWCTRL,
                                 SWCTRL_NO_USE_FUNC_NO,
                                 EH_TYPE_MSG_NULL_POINTER,
                                 EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_CRIT); /*SWCTRL_ENO_NULL_POINTER*/
        SWCTRL_RETURN_AND_RELEASE_CSC(SYS_TYPE_GET_RUNNING_CFG_FAIL);
    }

    *up_status = system_info.is_blocking_uplink_to_uplink_mode;

    if (*up_status == SYS_DFLT_TRAFFIC_SEG_UPLINK_TO_UPLINK_MODE)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC(SYS_TYPE_GET_RUNNING_CFG_NO_CHANGE);
    }
    else
    {
        SWCTRL_RETURN_AND_RELEASE_CSC(SYS_TYPE_GET_RUNNING_CFG_SUCCESS);
    }
}/* End of SWCTRL_GetRunningPrivateVlanUplinkToUplinkStatus() */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetPrivateVlanUplinkToUplinkStatus
 * -------------------------------------------------------------------------
 * FUNCTION: This function will get the private vlan uplink-to-uplink mode
 * INPUT   : None
 * OUTPU   : up_status -- uplink-to-uplink mode (blocking/forwarding)
 * RETURN  : True: Successfully, FALSE: Failed
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_GetPrivateVlanUplinkToUplinkStatus(UI32_T *up_status)
{
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (up_status == 0)
    {
        EH_MGR_Handle_Exception (SYS_MODULE_SWCTRL,
                                 SWCTRL_NO_USE_FUNC_NO,
                                 EH_TYPE_MSG_NULL_POINTER,
                                 EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_CRIT); /*SWCTRL_ENO_NULL_POINTER*/
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    *up_status = system_info.is_blocking_uplink_to_uplink_mode;

    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
}/* End of SWCTRL_GetPrivateVlanUplinkToUplinkStatus() */

#endif /* End of #if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE == SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE_MULTIPLE_SESSION)*/
#endif /* End of #if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION == TRUE) */

#if (SYS_CPNT_SWDRV_MONITOR_SFP_DDM == TRUE)
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetPortSfpEntry
 * -------------------------------------------------------------------------
 * FUNCTION: This function is used to get information from OM
 * INPUT   : UI32_T lport : Logical port num
 * OUTPUT  : SWCTRL_OM_SfpEntry_T *sfp_entry_p
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : If tranceiver is not present, return FALSE.
 * -------------------------------------------------------------------------
 */
BOOL_T SWCTRL_GetPortSfpEntry(UI32_T lport, SWCTRL_OM_SfpEntry_T *sfp_entry_p)
{
    SWCTRL_OM_SfpInfo_T             sfp_info;
    UI32_T unit, port, trunk_id, sfp_index;
    BOOL_T ret = FALSE, is_present;
    UI8_T  date_code_year, date_code_month, date_code_day;

    memset(sfp_entry_p, 0, sizeof(SWCTRL_OM_SfpEntry_T));
    sfp_entry_p->ifindex = lport;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (SWCTRL_LPORT_UNKNOWN_PORT == SWCTRL_LogicalPortToUserPort(lport, &unit, &port, &trunk_id))
    {
        SYSFUN_Debug_Printf("\r\n SWCTRL: SWCTRL_LogicalPortToUserPort Error...\r\n");
        return FALSE;
    }

    if(FALSE == STKTPLG_POM_UserPortToSfpIndex(unit, port, &sfp_index))
    {
        return FALSE;
    }

    if(FALSE == SWCTRL_GetPortSfpPresent(unit, sfp_index, &is_present) || FALSE == is_present)
    {
        return FALSE;
    }
    /* Get Sfp info
     */
    memset(&sfp_info, 0, sizeof(SWCTRL_OM_SfpInfo_T));
    ret = SWCTRL_GetPortSfpInfo(unit, sfp_index, &sfp_info);
    if (ret == TRUE)
    {
        if (sfp_info.is_invalid)
        {
            if (sfp_info.is_invalid & SWDRV_TYPE_GBIC_INVALID_INFO_READ_ERROR)
            {
                sprintf(sfp_entry_p->error_msg,"%s", "Read error");
            }
            if ((sfp_info.is_invalid & SWDRV_TYPE_GBIC_INVALID_INFO_CHECKSUM_BASE_ERROR) ||
                (sfp_info.is_invalid & SWDRV_TYPE_GBIC_INVALID_INFO_CHECKSUM_EXT_ERROR))
            {
                sprintf(sfp_entry_p->error_msg,"%s","Checksum error");
            }
            return TRUE;
        }
        /* Connector Type */
        SWDRV_LIB_MapSFPEEPROMConnector(sfp_info.connector, sfp_entry_p->connector_type);

        /* Transmission Media */
        if(sfp_info.identifier == SWDRV_TYPE_GBIC_ID_XFP)
        {
            SWDRV_LIB_MapXFPEEPROMTransceiverMedia(sfp_info.link_length_support_km, sfp_entry_p->fiber_type);
        }
        else
        {
            SWDRV_LIB_MapSFPEEPROMTransceiverMedia(sfp_info.transceiver[6],
                                             sfp_info.link_length_support_km,
                                             sfp_entry_p->fiber_type);
        }

        /* Ethernet compliance codes */
        if(sfp_info.identifier == SWDRV_TYPE_GBIC_ID_XFP)
        {
            SWDRV_LIB_MapXFPEEPROMTransceiverCompCode(sfp_info.transceiver[0],
                                                 sfp_info.link_length_support_km,
                                                 sfp_entry_p->eth_comp_code);
        }
        else
        {
            SWDRV_LIB_MapSFPEEPROMTransceiverCompCode(sfp_info.transceiver[3],
                                                 sfp_info.transceiver[0],
                                                 sfp_info.link_length_support_km,
                                                 sfp_info.link_length_support_100m,
                                                 sfp_entry_p->eth_comp_code);
        }

        /* Bit Rate, in unit of 100 MBd (Baud) */
        sprintf(sfp_entry_p->baud_rate, "%d MBd", sfp_info.bitrate * 100);

        /* Vendor OUI */
        sprintf(sfp_entry_p->vendor_oui, "%02X-%02X-%02X", sfp_info.vendor_oui[0],
                                                         sfp_info.vendor_oui[1],
                                                         sfp_info.vendor_oui[2]);

        /* Vendor Name */
        sprintf(sfp_entry_p->vendor_name, "%s", sfp_info.vendor_name);

        /* Vendor PN */
        sprintf(sfp_entry_p->vendor_pn, "%s", sfp_info.vendor_pn);

        /* Vendor Rev */
        sprintf(sfp_entry_p->vendor_rev, "%s", sfp_info.vendor_rev);

        /* Vendor SN */
        sprintf(sfp_entry_p->vendor_sn, "%s", sfp_info.vendor_sn);

        /* Date Code, year, month, day */
        date_code_year  = (UI32_T) ((sfp_info.date_code[0]-'0')*10 + (sfp_info.date_code[1]-'0'));
        date_code_month = (UI32_T) ((sfp_info.date_code[2]-'0')*10 + (sfp_info.date_code[3]-'0'));
        date_code_day   = (UI32_T) ((sfp_info.date_code[4]-'0')*10 + (sfp_info.date_code[5]-'0'));

        sprintf(sfp_entry_p->date_code, "%02d-%02d-%02d", date_code_year, date_code_month, date_code_day);
    }/* End of if(ret == TRUE) */

    return ret;
} /* End of SWCTRL_GetPortSfpEntry */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetNextPortSfpEntry
 * -------------------------------------------------------------------------
 * FUNCTION: This function is used to get information from om
 * INPUT   : UI32_T lport_p : Logical port num
 * OUTPUT  : SWCTRL_OM_SfpEntry_T *sfp_entry_p
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : If tranceiver is not present, return FALSE.
 * -------------------------------------------------------------------------
 */
BOOL_T SWCTRL_GetNextPortSfpEntry(UI32_T *lport_p, SWCTRL_OM_SfpEntry_T *sfp_entry_p)
{
    UI32_T unit, port, trunk_id;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if( lport_p == 0 || sfp_entry_p == 0 )
    {
        EH_MGR_Handle_Exception (SYS_MODULE_SWCTRL,
                                 SWCTRL_NO_USE_FUNC_NO,
                                 EH_TYPE_MSG_NULL_POINTER,
                                 EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_CRIT); /*SWCTRL_ENO_NULL_POINTER*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (!SWCTRL_IS_USER_PORT(*lport_p))
    {
        while(*lport_p <= SYS_ADPT_TOTAL_NBR_OF_LPORT)
        {
            if (SWCTRL_IS_USER_PORT(*lport_p))
                break;
            else
                (*lport_p)++;
        }

        if (*lport_p > SYS_ADPT_TOTAL_NBR_OF_LPORT)
        {
            SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
        }
        unit = SWCTRL_IFINDEX_TO_UNIT(*lport_p);
        port = SWCTRL_IFINDEX_TO_PORT(*lport_p)-1;
    }
    else
    {
        unit = SWCTRL_IFINDEX_TO_UNIT(*lport_p);
        port = SWCTRL_IFINDEX_TO_PORT(*lport_p);
    }

    while(TRUE == STKTPLG_OM_GetNextSfpPortByUnitPort(&unit, &port))
    {
        *lport_p = SWCTRL_UPORT_TO_IFINDEX(unit, port);
        sfp_entry_p->ifindex = *lport_p;
        if(TRUE == SWCTRL_GetPortSfpEntry(*lport_p, sfp_entry_p))
        {
            SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
        }
        else
        {
            /* when SFP is not present.
             */
            continue;
        }
    }

    SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
} /* End of SWCTRL_GetNextPortSfpEntry() */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetPortSfpDdmEntry
 * -------------------------------------------------------------------------
 * FUNCTION: This function is used to get ddm information from om
 * INPUT   : UI32_T lport : Logical port num
 * OUTPUT  : SWCTRL_OM_SfpDdmEntry_T *sfp_ddm_entry_p
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : If tranceiver is not present, return FALSE.
 * -------------------------------------------------------------------------
 */
BOOL_T SWCTRL_GetPortSfpDdmEntry(UI32_T lport, SWCTRL_OM_SfpDdmEntry_T *sfp_ddm_entry_p)
{
    SWCTRL_OM_SfpInfo_T             sfp_info;
    SWCTRL_OM_SfpDdmInfoMeasured_T  sfp_ddm_info_measured;
    UI32_T unit, port, trunk_id, sfp_index;
    BOOL_T ret = FALSE, is_present;

    /* pointers to status text
     */
    #if (SYS_CPNT_SFP_DDM_ALARMWARN_TRAP == TRUE)
    SWCTRL_OM_SfpDdmThresholdStatus_T  sfp_ddm_threshold_status;
    char *normal_p          = " normal",
         *status_p          = normal_p;  /* default; may get one of the following */

    char *low_alarm_p       = " low alarm",
         *low_warning_p     = " low warning",
         *high_warning_p    = " high warning",
         *high_alarm_p      = " high alarm";
    #else
    char *status_p          = "\0";
    #endif


    memset(sfp_ddm_entry_p, 0, sizeof(SWCTRL_OM_SfpEntry_T));
    sfp_ddm_entry_p->ifindex = lport;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (SWCTRL_LPORT_UNKNOWN_PORT == SWCTRL_LogicalPortToUserPort(lport, &unit, &port, &trunk_id))
    {
        SYSFUN_Debug_Printf("\r\n SWCTRL: SWCTRL_LogicalPortToUserPort Error...\r\n");
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if(FALSE == STKTPLG_POM_UserPortToSfpIndex(unit, port, &sfp_index))
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if(FALSE == SWCTRL_GetPortSfpPresent(unit, sfp_index, &is_present) || FALSE == is_present)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
    /* Get Sfp info
     */
    memset(&sfp_info, 0, sizeof(SWCTRL_OM_SfpInfo_T));
    ret = SWCTRL_GetPortSfpInfo(unit, sfp_index, &sfp_info);
    if(ret == TRUE && sfp_info.support_ddm == TRUE)
    {
        memset(&sfp_ddm_info_measured, 0, sizeof(SWCTRL_OM_SfpDdmInfoMeasured_T));
#if (SYS_CPNT_SFP_DDM_ALARMWARN_TRAP == TRUE)
        memset(&sfp_ddm_threshold_status, 0, sizeof(SWCTRL_OM_SfpDdmThresholdStatus_T));

        SWCTRL_LOCK();
        SWCTRL_OM_GetPortSfpDdmThresholdStatus(unit, sfp_index, &sfp_ddm_threshold_status);
        SWCTRL_UNLOCK();
#endif

        if(SWCTRL_GetPortSfpDdmInfoMeasured(unit, sfp_index, &sfp_ddm_info_measured) == TRUE)
        {
            /* Temperature */
#if (SYS_CPNT_SFP_DDM_ALARMWARN_TRAP == TRUE)
            /* get state
             *
             * Because "warning" is "(! alarm) && warning",
             * the following sequence must compare alarm first, and then
             * warning.
             */
            status_p = normal_p;
            if (sfp_ddm_threshold_status.temp_high_alarm)
            {
                status_p = high_alarm_p;
            }
            else if (sfp_ddm_threshold_status.temp_high_warning)
            {
                status_p = high_warning_p;
            }
            else if (sfp_ddm_threshold_status.temp_low_alarm)
            {
                status_p = low_alarm_p;
            }
            else if (sfp_ddm_threshold_status.temp_low_warning)
            {
                status_p = low_warning_p;
            }
#endif
            sprintf(sfp_ddm_entry_p->temperature, "%.2f degrees C%s", sfp_ddm_info_measured.temperature, status_p);

            /* Voltage */
#if (SYS_CPNT_SFP_DDM_ALARMWARN_TRAP == TRUE)
            /* get state
             *
             * Because "warning" is "(! alarm) && warning",
             * the following sequence must compare alarm first, and then
             * warning.
             */
            status_p = normal_p;
            if (sfp_ddm_threshold_status.voltage_high_alarm)
            {
                status_p = high_alarm_p;
            }
            else if (sfp_ddm_threshold_status.voltage_high_warning)
            {
                status_p = high_warning_p;
            }
            else if (sfp_ddm_threshold_status.voltage_low_alarm)
            {
                status_p = low_alarm_p;
            }
            else if (sfp_ddm_threshold_status.voltage_low_warning)
            {
                status_p = low_warning_p;
            }
#endif
            sprintf(sfp_ddm_entry_p->voltage, "%.2f V%s", sfp_ddm_info_measured.voltage, status_p);

            /* Current */
#if (SYS_CPNT_SFP_DDM_ALARMWARN_TRAP == TRUE)
            /* get state
             *
             * Because "warning" is "(! alarm) && warning",
             * the following sequence must compare alarm first, and then
             * warning.
             */
            status_p = normal_p;
            if (sfp_ddm_threshold_status.bias_high_alarm)
            {
                status_p = high_alarm_p;
            }
            else if (sfp_ddm_threshold_status.bias_high_warning)
            {
                status_p = high_warning_p;
            }
            else if (sfp_ddm_threshold_status.bias_low_alarm)
            {
                status_p = low_alarm_p;
            }
            else if (sfp_ddm_threshold_status.bias_low_warning)
            {
                status_p = low_warning_p;
            }
#endif
            sprintf(sfp_ddm_entry_p->bias_current, "%.2f mA%s", sfp_ddm_info_measured.tx_bias_current, status_p);

            /* Tx Power */
#if (SYS_CPNT_SFP_DDM_ALARMWARN_TRAP == TRUE)
            /* get state
             *
             * Because "warning" is "(! alarm) && warning",
             * the following sequence must compare alarm first, and then
             * warning.
             */
            status_p = normal_p;
            if (sfp_ddm_threshold_status.tx_power_high_alarm)
            {
                status_p = high_alarm_p;
            }
            else if (sfp_ddm_threshold_status.tx_power_high_warning)
            {
                status_p = high_warning_p;
            }
            else if (sfp_ddm_threshold_status.tx_power_low_alarm)
            {
                status_p = low_alarm_p;
            }
            else if (sfp_ddm_threshold_status.tx_power_low_warning)
            {
                status_p = low_warning_p;
            }
#endif
            sprintf(sfp_ddm_entry_p->tx_power, "%.2f dBm%s", sfp_ddm_info_measured.tx_power, status_p);

            /* Rx Power */
#if (SYS_CPNT_SFP_DDM_ALARMWARN_TRAP == TRUE)
            /* get state
             *
             * Because "warning" is "(! alarm) && warning",
             * the following sequence must compare alarm first, and then
             * warning.
             */
            status_p = normal_p;
            if (sfp_ddm_threshold_status.rx_power_high_alarm)
            {
                status_p = high_alarm_p;
            }
            else if (sfp_ddm_threshold_status.rx_power_high_warning)
            {
                status_p = high_warning_p;
            }
            else if (sfp_ddm_threshold_status.rx_power_low_alarm)
            {
                status_p = low_alarm_p;
            }
            else if (sfp_ddm_threshold_status.rx_power_low_warning)
            {
                status_p = low_warning_p;
            }
#endif
            sprintf(sfp_ddm_entry_p->rx_power, "%.2f dBm%s", sfp_ddm_info_measured.rx_power, status_p);
        }
    }/* End of if(ret == TRUE) */
    else
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );

    SWCTRL_RETURN_AND_RELEASE_CSC( ret );

} /* End of SWCTRL_GetPortSfpDdmEntry */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetNextPortSfpDdmEntry
 * -------------------------------------------------------------------------
 * FUNCTION: This function is used to get nex ddm information from om
 * INPUT   : UI32_T lport_p : Logical port num
 * OUTPUT  : SWCTRL_OM_SfpDdmEntry_T *sfp_ddm_entry_p
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : If tranceiver is not present, return FALSE.
 * -------------------------------------------------------------------------
 */
BOOL_T SWCTRL_GetNextPortSfpDdmEntry(UI32_T *lport_p, SWCTRL_OM_SfpDdmEntry_T *sfp_ddm_entry_p)
{
    UI32_T unit, port, trunk_id;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if( lport_p == 0 || sfp_ddm_entry_p == 0 )
    {
        EH_MGR_Handle_Exception (SYS_MODULE_SWCTRL,
                                 SWCTRL_NO_USE_FUNC_NO,
                                 EH_TYPE_MSG_NULL_POINTER,
                                 EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_CRIT); /*SWCTRL_ENO_NULL_POINTER*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (!SWCTRL_IS_USER_PORT(*lport_p))
    {
        while(*lport_p <= SYS_ADPT_TOTAL_NBR_OF_LPORT)
        {
            if (SWCTRL_IS_USER_PORT(*lport_p))
                break;
            else
                (*lport_p)++;
        }

        if (*lport_p > SYS_ADPT_TOTAL_NBR_OF_LPORT)
        {
            SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
        }
        unit = SWCTRL_IFINDEX_TO_UNIT(*lport_p);
        port = SWCTRL_IFINDEX_TO_PORT(*lport_p)-1;
    }
    else
    {
        unit = SWCTRL_IFINDEX_TO_UNIT(*lport_p);
        port = SWCTRL_IFINDEX_TO_PORT(*lport_p);
    }

    while(TRUE == STKTPLG_OM_GetNextSfpPortByUnitPort(&unit, &port))
    {
        *lport_p = SWCTRL_UPORT_TO_IFINDEX(unit, port);
        sfp_ddm_entry_p->ifindex = *lport_p;
        if(TRUE == SWCTRL_GetPortSfpDdmEntry(*lport_p, sfp_ddm_entry_p))
        {
            SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
        }
        else
        {
            /* when SFP is not present.
             */
            continue;
        }
    }

    SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
} /* End of SWCTRL_GetNextPortSfpDdmEntry() */
#endif /* SWCTRL_GetPortSfpDdmEntry */

#if (SYS_CPNT_SWCTRL_CABLE_DIAG == TRUE)
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_ExecuteCableDiag
 * -------------------------------------------------------------------------
 * FUNCTION: Get Cable diag result of specific port
 * INPUT   : lport : Logical port num
 * OUTPUT  : result : result of the cable diag test for the port
 * RETURN  : TRUE/FALSE
 * NOTE    : None.
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_ExecuteCableDiag(UI32_T lport, SWCTRL_Cable_Info_T *result)
{
    SWDRV_CableDiagInfo_T cable_diag_result;
    UI32_T  unit, port, trunk_id;
#if (SYS_CPNT_SWCTRL_CABLE_DIAG_CHIP == SYS_CPNT_SWCTRL_CABLE_DIAG_BROADCOM)
    UI32_T  time;
#endif

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (FALSE == SWCTRL_IS_USER_PORT(lport) )
    {
        SYSFUN_Debug_Printf("\r\n SWCTRL: SWCTRL_IS_USER_PORT Error...\r\n");
        return FALSE;
    }

    if (FALSE == SWCTRL_IS_EXIST (lport))
    {
        SYSFUN_Debug_Printf("\r\n SWCTRL: SWCTRL_IS_EXIST Error...\r\n");
        return FALSE;
    }

    if (SWCTRL_LPORT_UNKNOWN_PORT == SWCTRL_LogicalPortToUserPort(lport, &unit, &port, &trunk_id))
    {
        SYSFUN_Debug_Printf("\r\n SWCTRL: SWCTRL_LogicalPortToUserPort Error...\r\n");
        return FALSE;
    }

#if (SYS_CPNT_SWCTRL_CABLE_DIAG_CHIP == SYS_CPNT_SWCTRL_CABLE_DIAG_BROADCOM)
    /* Default length */
    result->fuzz_len = 0;

    if(SWDRV_GetCableDiag(unit, port, &cable_diag_result) != TRUE)
    {
        SYSFUN_Debug_Printf("\r\n SWCTRL: Execute SWDRV_GetCableDiag Error...\r\n");
        return FALSE;
    }

    SYS_TIME_GetRealTimeBySec(&time);

    cable_info[lport-1].cable_status   = result->cable_status = cable_diag_result.state;
    cable_info[lport-1].fuzz_len       = result->fuzz_len = cable_diag_result.fuzz_len;
    cable_info[lport-1].last_test_time = result->last_test_time = time;
    memcpy(result->pair_state, cable_diag_result.pair_state, sizeof(UI32_T) * 4);
    memcpy(cable_info[lport-1].pair_state, cable_diag_result.pair_state, sizeof(UI32_T) * 4);
    memcpy(result->pair_len, cable_diag_result.pair_len, sizeof(UI32_T) * 4);
    memcpy(cable_info[lport-1].pair_len, cable_diag_result.pair_len, sizeof(UI32_T) * 4);

#elif (SYS_CPNT_SWCTRL_CABLE_DIAG_CHIP == SYS_CPNT_SWCTRL_CABLE_DIAG_MARVELL)
    /* marvell design, swctrl don't keep database. Get from getway. */
    if(SWDRV_GetCableDiag(unit, port, &cable_diag_result) != TRUE)
    {
        return FALSE;
    }
#else
#error "Chip not defined!"
#endif

    return TRUE;
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetCableDiagResult
 * -------------------------------------------------------------------------
 * FUNCTION: Get Cable diag result of specific port by latest result
 * INPUT   : lport : Logical port num
 * OUTPUT  : result : result of the cable diag test for the port
 * RETURN  : TRUE/FALSE
 * NOTE    :
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_GetCableDiagResult(UI32_T lport, SWCTRL_Cable_Info_T *result)
{
    UI32_T  unit, port, trunk_id;

    if (FALSE == SWCTRL_IS_USER_PORT(lport) )
    {
        SYSFUN_Debug_Printf("\r\n SWCTRL: SWCTRL_IS_USER_PORT Error...\r\n");
        return FALSE;
    }

    if (FALSE == SWCTRL_IS_EXIST (lport))
    {
        SYSFUN_Debug_Printf("\r\n SWCTRL: SWCTRL_IS_EXIST Error...\r\n");
        return FALSE;
    }

    if (SWCTRL_LPORT_UNKNOWN_PORT == SWCTRL_LogicalPortToUserPort(lport, &unit, &port, &trunk_id))
    {
        SYSFUN_Debug_Printf("\r\n SWCTRL: SWCTRL_LogicalPortToUserPort Error...\r\n");
        return FALSE;
    }

#if (SYS_CPNT_SWCTRL_CABLE_DIAG_CHIP == SYS_CPNT_SWCTRL_CABLE_DIAG_BROADCOM)
    result->cable_status   = cable_info[lport-1].cable_status;
    result->fuzz_len       = cable_info[lport-1].fuzz_len;
    result->last_test_time = cable_info[lport-1].last_test_time;
    memcpy(result->pair_state, cable_info[lport-1].pair_state, sizeof(UI32_T) * 4);
    memcpy(result->pair_len, cable_info[lport-1].pair_len, sizeof(UI32_T) * 4);
#elif (SYS_CPNT_SWCTRL_CABLE_DIAG_CHIP == SYS_CPNT_SWCTRL_CABLE_DIAG_MARVELL)
    /* marvell design, swctrl don't keep database. Get from getway. */
    SWDRV_GetCableDiagResult(unit, port, (SWDRV_CableDiagInfo_T *)result);
#else
#error "Chip not defined!"
#endif

    return TRUE;
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetNextCableDiagResult
 * -------------------------------------------------------------------------
 * FUNCTION: This function will get all cable diag result of ports
 * INPUT   : lport   -- the key to get
 * OUTPUT  : lport   -- the next existing port
 *           result -- all cable diag result of this port
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_GetNextCableDiagResult(UI32_T *lport, SWCTRL_Cable_Info_T *result)
{
    if( lport == 0 )
    {
        EH_MGR_Handle_Exception (SYS_MODULE_SWCTRL,
                                 SWCTRL_NO_USE_FUNC_NO,
                                 EH_TYPE_MSG_NULL_POINTER,
                                 EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_CRIT); /*SWCTRL_ENO_NULL_POINTER*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if( result == 0 )
    {
        EH_MGR_Handle_Exception (SYS_MODULE_SWCTRL,
                                 SWCTRL_NO_USE_FUNC_NO,
                                 EH_TYPE_MSG_NULL_POINTER,
                                 EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_CRIT); /*SWCTRL_ENO_NULL_POINTER*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }
    while( ++(*lport) <= SYS_ADPT_TOTAL_NBR_OF_LPORT )
    {
        if (SWCTRL_IS_EXIST (*lport))
        {
            SWCTRL_RETURN_AND_RELEASE_CSC( SWCTRL_GetCableDiagResult(*lport, result) );
        }
    }

    SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
}
#endif  /* #if (SYS_CPNT_SWCTRL_CABLE_DIAG == TRUE) */

#if (SYS_CPNT_RATE_BASED_STORM_CONTROL == TRUE)
/* -------------------------------------------------------------------------
* ROUTINE NAME - SWCTRL_SetRateBasedStormControl
* -------------------------------------------------------------------------
* FUNCTION: This function will set the rate based storm control
* INPUT   : ifindex
*           rate      -- kbits/s
*           mode      -- VAL_rateBasedStormMode_bcastStorm |
*                        VAL_rateBasedStormMode_mcastStorm |
*                        VAL_rateBasedStormMode_unknownUcastStorm
* OUTPUT  : None
* RETURN  : TRUE: Successfully, FALSE: If not available
* NOTE    : specifically for BCM53115
* -------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetRateBasedStormControl(UI32_T ifindex, UI32_T rate, UI32_T mode)
{
    BOOL_T retval = FALSE;
    UI32_T unit, port, trunk_id;
    int i;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if( ifindex == 0 || ifindex > SYS_ADPT_TOTAL_NBR_OF_LPORT)
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Logical Port ID (1-%d)", SYS_ADPT_TOTAL_NBR_OF_LPORT);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_LOGICAL_PORT_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if ((port_info[ifindex - 1].rate_based_storm_rate == rate) &&
        (port_info[ifindex - 1].rate_based_storm_mode == mode))
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
    }

    if (!SWCTRL_IS_TRUNK(ifindex))
    {
        unit = SWCTRL_IFINDEX_TO_UNIT(ifindex);
        port = SWCTRL_IFINDEX_TO_PORT(ifindex);
        if((retval = SWDRV_SetRateBasedStormControl(unit, port, rate, mode)) != TRUE)
        {
            SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
        }
    }
    else
    {
        retval = TRUE;
        trunk_id = SWCTRL_IFINDEX_TO_TRUNKID(ifindex);
        for(i=0; i<trunk_ext_port_info[trunk_id-1].member_number; i++)
        {
            unit = trunk_ext_port_info[trunk_id-1].member_list[i].unit;
            port = trunk_ext_port_info[trunk_id-1].member_list[i].port;
            if((retval = SWDRV_SetRateBasedStormControl(unit, port, rate, mode)) != TRUE)
            {
                SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
            }
        }
    }

    /* update port_info */
    SWCTRL_LOCK();
    if(retval)
    {
        port_info[ifindex - 1].rate_based_storm_rate = rate;
        port_info[ifindex - 1].rate_based_storm_mode = mode;
    }
    SWCTRL_UNLOCK();

    return retval;
}

/* -------------------------------------------------------------------------
* ROUTINE NAME - SWCTRL_SetRateBasedStormControlRate
* -------------------------------------------------------------------------
* FUNCTION: This function will set the rate based storm control
* INPUT   : ifindex
*           rate      -- kbits/s
*
* OUTPUT  : None
* RETURN  : TRUE: Successfully, FALSE: If not available
* NOTE    : specifically for BCM53115
* -------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetRateBasedStormControlRate(UI32_T ifindex, UI32_T rate)
{
    return SWCTRL_SetRateBasedStormControl(ifindex, rate, port_info[ifindex - 1].rate_based_storm_mode);
}

/* -------------------------------------------------------------------------
* ROUTINE NAME - SWCTRL_SetRateBasedStormControlMode
* -------------------------------------------------------------------------
* FUNCTION: This function will set the rate based storm control
* INPUT   : ifindex
*           mode      -- VAL_rateBasedStormMode_bcastStorm |
*                        VAL_rateBasedStormMode_mcastStorm |
*                        VAL_rateBasedStormMode_unknownUcastStorm
* OUTPUT  : None
* RETURN  : TRUE: Successfully, FALSE: If not available
* NOTE    : specifically for BCM53115
* -------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetRateBasedStormControlMode(UI32_T ifindex, UI32_T mode)
{
    return SWCTRL_SetRateBasedStormControl(ifindex, port_info[ifindex - 1].rate_based_storm_rate, mode);
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetRateBasedStormControl
 * -------------------------------------------------------------------------
 * FUNCTION: This function will get rate based storm control settings.
 * INPUT   : ifindex
 * OUTPUT  : rate
 *           mode
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : specifically for BCM53115
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_GetRateBasedStormControl(UI32_T ifindex, UI32_T *rate, UI32_T *mode)
{
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if( ifindex > SYS_ADPT_TOTAL_NBR_OF_LPORT )
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    *rate = port_info[ifindex - 1].rate_based_storm_rate;
    *mode = port_info[ifindex - 1].rate_based_storm_mode;

    return TRUE;
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetNextRateBasedStormControl
 * -------------------------------------------------------------------------
 * FUNCTION: This function will get rate based storm control settings.
 * INPUT   : ifindex
 * OUTPUT  : ifindex
 *           rate
 *           mode
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : specifically for BCM53115
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_GetNextRateBasedStormControl(UI32_T *ifindex, UI32_T *rate, UI32_T *mode)
{
    if(SWCTRL_GetNextLogicalPort(ifindex) == SWCTRL_LPORT_UNKNOWN_PORT)
        return FALSE;
    return SWCTRL_GetRateBasedStormControl(*ifindex, rate, mode);
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetRunningRateBasedStormControlRate
 * -------------------------------------------------------------------------
 * FUNCTION: This function will get rate based storm control settings.
 * INPUT   : ifindex
 * OUTPUT  : ifindex
 *           rate
 *           mode
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : specifically for BCM53115
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_GetRunningRateBasedStormControlRate(UI32_T ifindex, UI32_T *rate)
{
    UI32_T tmp_mode;

    if(!SWCTRL_GetRateBasedStormControl(ifindex, rate, &tmp_mode))
        return FALSE;
    if(rate != 0)
        return SYS_TYPE_GET_RUNNING_CFG_SUCCESS;
    else
        return SYS_TYPE_GET_RUNNING_CFG_NO_CHANGE;
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetRunningRateBasedStormControlMode
 * -------------------------------------------------------------------------
 * FUNCTION: This function will get rate based storm control settings.
 * INPUT   : ifindex
 * OUTPUT  : ifindex
 *           rate
 *           mode
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : specifically for BCM53115
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_GetRunningRateBasedStormControlMode(UI32_T ifindex, UI32_T *mode)
{
    UI32_T tmp_rate;

    if(!SWCTRL_GetRateBasedStormControl(ifindex, &tmp_rate, mode))
        return FALSE;
    if(mode != 0)
        return SYS_TYPE_GET_RUNNING_CFG_SUCCESS;
    else
        return SYS_TYPE_GET_RUNNING_CFG_NO_CHANGE;
}
#endif

#if (SYS_CPNT_MLDSNP == TRUE)
/*------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_EnableMldPacketTrap
 *------------------------------------------------------------------------
 * FUNCTION: This API is used to enable MLD packet trap.
 * INPUT   : None.
 * OUTPUT  : None.
 * RETURN  : TRUE/FALSE.
 * NOTE    : None.
 *------------------------------------------------------------------------*/
BOOL_T SWCTRL_EnableMldPacketTrap(SWCTRL_TrapPktOwner_T owner)
{
    return SWCTRL_SetPktTrapStatus(SWCTRL_PKTTYPE_MLD, owner, TRUE, TRUE);
}

/*------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_DisableMldPacketTrap
 *------------------------------------------------------------------------
 * FUNCTION: This API is used to enable MLD packet trap.
 * INPUT   : None.
 * OUTPUT  : None.
 * RETURN  : TRUE/FALSE.
 * NOTE    : None.
 *------------------------------------------------------------------------*/
BOOL_T SWCTRL_DisableMldPacketTrap(SWCTRL_TrapPktOwner_T owner)
{
    return SWCTRL_SetPktTrapStatus(SWCTRL_PKTTYPE_MLD, owner, FALSE, FALSE);
}
#endif /*#if (SYS_CPNT_MLDSNP == TRUE)*/

#if (SYS_CPNT_IPV6_RA_GUARD_SW_RELAY == TRUE)
/*------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetRaAndRrPacketTrap
 *------------------------------------------------------------------------
 * FUNCTION: To enable/disable RA/RR packet trap.
 * INPUT   : is_enabled - TRUE to enable
 * OUTPUT  : None.
 * RETURN  : TRUE/FALSE.
 * NOTE    : None.
 *------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetRaAndRrPacketTrap(
    BOOL_T  is_enabled)
{
    return SWDRV_SetRaAndRrPacketTrap(is_enabled);
}
#endif /* #if (SYS_CPNT_IPV6_RA_GUARD_SW_RELAY == TRUE) */

#if (SYS_CPNT_IPV6_RA_GUARD_DROP_BY_RULE == TRUE)
/*------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetPortRaAndRrPacketDrop
 *------------------------------------------------------------------------
 * FUNCTION: To enable/disable RA/RR packet drop by specified ifindex.
 * INPUT   : ifindex    - ifindex to enable/disable
 *           is_enabled - TRUE to enable
 * OUTPUT  : None.
 * RETURN  : TRUE/FALSE.
 * NOTE    : None.
 *------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetPortRaAndRrPacketDrop(
    UI32_T  ifindex, BOOL_T  is_enabled)
{
    UI32_T  i, trunk_id;
    UI16_T  unit, port;
    BOOL_T  asic_status = FALSE;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (!(ifindex != 0
          && ifindex <= SYS_ADPT_TOTAL_NBR_OF_LPORT
          && SWCTRL_IS_EXIST(ifindex))
       )
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    SWCTRL_LOCK();
    /* normal/trunk member, apply to this port
     */
    if (!SWCTRL_IS_TRUNK (ifindex))
    {
        unit = SWCTRL_IFINDEX_TO_UNIT(ifindex);
        port = SWCTRL_IFINDEX_TO_PORT(ifindex);

        asic_status = SWDRV_SetPortRaAndRrPacketDrop(unit, port, is_enabled);
    }

    /* trunk, apply to all member ports
     */
    if (SWCTRL_IS_TRUNK (ifindex))
    {
        trunk_id = SWCTRL_IFINDEX_TO_TRUNKID (ifindex);

        for(i=0; i<trunk_ext_port_info[trunk_id-1].member_number; i++)
        {
            unit = trunk_ext_port_info[trunk_id-1].member_list[i].unit;
            port = trunk_ext_port_info[trunk_id-1].member_list[i].port;
            asic_status = SWDRV_SetPortRaAndRrPacketDrop(unit, port, is_enabled);
        }
    } /* End of if */
    SWCTRL_UNLOCK();

    SWCTRL_RETURN_AND_RELEASE_CSC( asic_status );
}
#endif /* #if (SYS_CPNT_IPV6_RA_GUARD_DROP_BY_RULE == TRUE) */

#if(SYS_CPNT_AMTR_PORT_MAC_LEARNING == TRUE)/*Tony.Lei*/
/*------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetPortMACLearningStatus
 *------------------------------------------------------------------------
 * FUNCTION: This API is used to set port status about Mac learning
 * INPUT   : None.
 * OUTPUT  : None.
 * RETURN  : TRUE/FALSE.
 * NOTE    : None.
 *------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetPortMACLearningStatus(UI32_T ifindex, BOOL_T status)
{
        BOOL_T retval = FALSE;
        UI32_T unit, port, trunk_id;
        int i;
        SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

        if (!SWCTRL_IS_LPORT(ifindex)){
#if (SYS_CPNT_EH == TRUE)
            UI8_T buff[32] = {0};

            sprintf(buff, "Logical Port ID (1-%d)", SYS_ADPT_TOTAL_NBR_OF_LPORT);

            EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                      SWCTRL_NO_USE_FUNC_NO,
                                      EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                      SYSLOG_LEVEL_INFO,
                                      buff);  /*SWCTRL_ENO_OUT_OF_RANGE_LOGICAL_PORT_ID*/
#endif

            SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
        }

        if(port_info[ifindex - 1].port_entry.port_macaddr_learning == status){
            SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
        }

        SWCTRL_LOCK();
        retval = SWCTRL_SetPortLearningStatus_Local(ifindex, status, SWCTRL_LEARNING_DISABLED_BY_CFG);

        /* update port_info */
        if(retval)
        {
            if (SWCTRL_IS_TRUNK (ifindex))
            {
                UI32_T memb_ifindex;

                trunk_id = SWCTRL_IFINDEX_TO_TRUNKID(ifindex);

                for(i=0; i<trunk_ext_port_info[trunk_id-1].member_number; i++)
                {
                    unit = trunk_ext_port_info[trunk_id-1].member_list[i].unit;
                    port = trunk_ext_port_info[trunk_id-1].member_list[i].port;
                    memb_ifindex = SWCTRL_UPORT_TO_IFINDEX(unit, port);
                    /* update port_info */
                    port_info[memb_ifindex - 1].port_entry.port_macaddr_learning = status;
                }
            }

            port_info[ifindex - 1].port_entry.port_macaddr_learning = status;
        }
        SWCTRL_UNLOCK();

        SWCTRL_RETURN_AND_RELEASE_CSC( retval );
    }

#endif


#if (SYS_CPNT_VRRP == TRUE)
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_TrapVrrpToCpu
 * -------------------------------------------------------------------------
 * FUNCTION: This function will trap vrrp packet to cpu
 * INPUT   : trap or not
 * OUTPUT  : None
 * RETURN  : TRUE/FALSE
 * NOTE    : None
 * -------------------------------------------------------------------------*/
static BOOL_T SWCTRL_TrapVrrpToCpu(BOOL_T is_trap)
{
    return SWDRV_TrapVrrpTpCpu(is_trap);
}
#endif

#if(SYS_CPNT_WRED == TRUE)
/*-------------------------------------------------------------------------
 * FUNCTION NAME - SWCTRL_PMGR_RandomDetect
 * ------------------------------------------------------------------------
 * PURPOSE  :   This funtion will set port ecn marking percentage
 * INPUT    :   lport      - which port to set
 *              queue_id   - what queue to confiugre
 *              min        - min threshold
 *              max        - max threshold
 *              drop       - drop probability
 *              ecn        - do ecn marking
 * OUTPUT   :   None
 * RETURN   :   TRUE/FALSE
 * NOTES    :   queue_id = -1 means all queue
 * ------------------------------------------------------------------------
 */
BOOL_T SWCTRL_Random_Detect(UI32_T lport, SWCTRL_RandomDetect_T *random_detect_p)
{
    SWDRV_RandomDetec_T value;
    BOOL_T retval = FALSE;
    UI32_T unit, port, trunk_id;

    if (!SWCTRL_IS_LPORT(lport))
        return FALSE;

    if(random_detect_p->queue_id >= SYS_ADPT_MAX_NBR_OF_PRIORITY_QUEUE)
        return FALSE;

    if(random_detect_p->valid == FALSE)
    {
        SWCTRL_OM_RandomDetect_T om_value;

        if(FALSE == SWCTRL_OM_GetRandomDetect(lport, &om_value))
            return FALSE;

        if(om_value.valid[random_detect_p->queue_id] == FALSE)
        { /*only not valid before, we store it, or we need set to driver to unset it*/
          SWCTRL_OM_SetRandomDetect(lport, random_detect_p->queue_id,
                                           random_detect_p->min,
                                           random_detect_p->max,
                                           random_detect_p->drop,
                                           random_detect_p->ecn,
                                           random_detect_p->valid);
          return TRUE;
        }
    }

    if(random_detect_p->min!=0 /*only negative has 0*/
      &&(random_detect_p->min   <1  || random_detect_p->min >100
        ||random_detect_p->max  <1 || random_detect_p->max  >100
        ||random_detect_p->drop >100
        ||random_detect_p->ecn  >100
        ||random_detect_p->min > random_detect_p->max
        ||(random_detect_p->ecn!=0 && (random_detect_p->ecn < random_detect_p->min))
        )
      )
        return FALSE;

    value.queue_id = random_detect_p->queue_id;
    value.min      = random_detect_p->min;
    value.max      = random_detect_p->max;
    value.drop     = random_detect_p->drop;
    value.ecn      = random_detect_p->ecn;

    if (!SWCTRL_IS_TRUNK(lport))
    {
        unit = SWCTRL_IFINDEX_TO_UNIT(lport);
        port = SWCTRL_IFINDEX_TO_PORT(lport);
        retval = SWDRV_RandomDetect(unit, port, &value);

        if(retval == TRUE)
        {
            SWCTRL_OM_SetRandomDetect(lport, random_detect_p->queue_id,
                                             random_detect_p->min,
                                             random_detect_p->max,
                                             random_detect_p->drop,
                                             random_detect_p->ecn,
                                             random_detect_p->valid);
        }
    }
    else
    {
        UI32_T i;

        trunk_id = SWCTRL_IFINDEX_TO_TRUNKID(lport);

        for(i=0; i<trunk_ext_port_info[trunk_id-1].member_number; i++)
        {
            unit = trunk_ext_port_info[trunk_id-1].member_list[i].unit;
            port = trunk_ext_port_info[trunk_id-1].member_list[i].port;

            retval = SWDRV_RandomDetect(unit, port, &value);

            if(FALSE == retval)
              break;

            /*on trunk member*/
            if(retval == TRUE)
            {
                SWCTRL_OM_SetRandomDetect(SWCTRL_UPORT_TO_IFINDEX(unit, port),
                                          random_detect_p->queue_id,
                                          random_detect_p->min,
                                          random_detect_p->max,
                                          random_detect_p->drop,
                                          random_detect_p->ecn,
                                          random_detect_p->valid);
            }

        }
        /*on trunk port*/
        if(retval == TRUE)
        {
            SWCTRL_OM_SetRandomDetect(lport, random_detect_p->queue_id,
                                             random_detect_p->min,
                                             random_detect_p->max,
                                             random_detect_p->drop,
                                             random_detect_p->ecn,
                                             random_detect_p->valid);
        }

    }

    return retval;
}
#endif /*#if(SYS_CPNT_WRED == TRUE)*/

/*------------------------------------------------------------------------------
 * ROUTINE NAME : SWCTRL_HandleIPCReqMsg
 *------------------------------------------------------------------------------
 * PURPOSE:
 *    Handle the ipc request message for csca mgr.
 * INPUT:
 *    ipcmsg_p  --  input request ipc message buffer
 *
 * OUTPUT:
 *    ipcmsg_p  --  output response ipc message buffer
 *
 * RETURN:
 *    TRUE  - There is a response need to send.
 *    FALSE - There is no response to send.
 *
 * NOTES:
 *    None.
 *------------------------------------------------------------------------------
 */
BOOL_T SWCTRL_MGR_HandleIPCReqMsg(SYSFUN_Msg_T* ipcmsg_p)
{
    SWCTRL_MGR_IPCMsg_T *msg_data_p;
    UI32_T cmd;

    if(ipcmsg_p==NULL)
    {
        SWCTRL_DEBUG_MSG("\r\n SWCTRL_MGR_HandleIPCReqMsg ipcmsg_p==NULL");
        return FALSE;
    }

    msg_data_p = (SWCTRL_MGR_IPCMsg_T*)ipcmsg_p->msg_buf;
    cmd = msg_data_p->type.cmd;
    SWCTRL_DEBUG_LINE();
    SWCTRL_DEBUG_MSG("\r\n cmd %u",cmd);

    /* Every ipc request will fail when operating mode is transition mode
     */
    if (SYSFUN_GET_CSC_OPERATING_MODE() == SYS_TYPE_STACKING_TRANSITION_MODE)
    {
        /*EPR:NULL
         *Problem:When slave enter transition mode,if msg_size have not
         *        any value,will cause sender receive reply overflow.
         *Solution: use a default msg_size to reply the sender.
         *Fixed by:DanXie
         *Modify file:swctrl.c
         *Approved by:Hardsun
         */
        ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
        msg_data_p->type.result_ui32 = FALSE;
        SWCTRL_DEBUG_LINE();
        goto exit;
    }

    switch(cmd)
    {
#if (SYS_CPNT_PFC == TRUE)
        case SWCTRL_MGR_IPCCMD_SETPORTPFCSTATUS:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool = SWCTRL_SetPortPfcStatus(
                msg_data_p->data.ifidx_pfc_data.ifidx,
                msg_data_p->data.ifidx_pfc_data.rx_en,
                msg_data_p->data.ifidx_pfc_data.tx_en,
                msg_data_p->data.ifidx_pfc_data.pri_en_vec);
            break;

        case SWCTRL_MGR_IPCCMD_UPDATEPFCPRIMAP:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool = SWCTRL_UpdatePfcPriMap();
            break;
#endif

        case SWCTRL_MGR_IPCCMD_SETPORTADMINSTATUS:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_SetPortAdminStatus(
                msg_data_p->data.u32a1_u32a2.u32_a1,
                msg_data_p->data.u32a1_u32a2.u32_a2);
            break;

        case SWCTRL_MGR_IPCCMD_SETPORTSTATUS:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_SetPortStatus(
                msg_data_p->data.u32a1_u32a2_u32a3.u32_a1,
                msg_data_p->data.u32a1_u32a2_u32a3.u32_a2,
                msg_data_p->data.u32a1_u32a2_u32a3.u32_a3);
            break;

#if (SYS_CPNT_SUPPORT_FORCED_1000BASE_T_MODE == TRUE)

        case SWCTRL_MGR_IPCCMD_SETPORT1000BASETFORCEMODE:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_SetPort1000BaseTForceMode(
                msg_data_p->data.u32a1_u32a2.u32_a1,
                msg_data_p->data.u32a1_u32a2.u32_a2);
            break;
#endif

        case SWCTRL_MGR_IPCCMD_SETPORTCFGSPEEDDUPLEX:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_SetPortCfgSpeedDuplex(
                msg_data_p->data.u32a1_u32a2.u32_a1,
                msg_data_p->data.u32a1_u32a2.u32_a2);
            break;

        case SWCTRL_MGR_IPCCMD_SETPORTDEFAULTSPEEDDUPLEX:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_SetPortDefaultSpeedDuplex(
                msg_data_p->data.ui32_v);
            break;

        case SWCTRL_MGR_IPCCMD_SETPORTAUTONEGENABLE:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_SetPortAutoNegEnable(
                msg_data_p->data.u32a1_u32a2.u32_a1,
                msg_data_p->data.u32a1_u32a2.u32_a2);
            break;

        case SWCTRL_MGR_IPCCMD_SETPORTCFGFLOWCTRLENABLE:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_SetPortCfgFlowCtrlEnable(
                msg_data_p->data.u32a1_u32a2.u32_a1,
                msg_data_p->data.u32a1_u32a2.u32_a2);
            break;

        case SWCTRL_MGR_IPCCMD_SETPORTAUTONEGCAPABILITY:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_SetPortAutoNegCapability(
                msg_data_p->data.u32a1_u32a2.u32_a1,
                msg_data_p->data.u32a1_u32a2.u32_a2);
            break;

        case SWCTRL_MGR_IPCCMD_SETPORTDEFAULTAUTONEGCAPABILITY:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_SetPortDefaultAutoNegCapability(
                msg_data_p->data.ui32_v);
            break;

#if (SYS_CPNT_SWCTRL_FEC == TRUE)
        case SWCTRL_MGR_IPCCMD_SETPORTFEC:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool = SWCTRL_SetPortFec(
                msg_data_p->data.u32a1_u32a2.u32_a1, 
                msg_data_p->data.u32a1_u32a2.u32_a2);
        break;
#endif

        case SWCTRL_MGR_IPCCMD_SETPORTLINKCHANGETRAPENABLE:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_SetPortLinkChangeTrapEnable(
                msg_data_p->data.u32a1_u32a2.u32_a1,
                msg_data_p->data.u32a1_u32a2.u32_a2);
            break;

        case SWCTRL_MGR_IPCCMD_SETPORTDOT1XENABLE:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_SetPortDot1xEnable(
                msg_data_p->data.u32a1_u32a2.u32_a1,
                msg_data_p->data.u32a1_u32a2.u32_a2);
            break;

        case SWCTRL_MGR_IPCCMD_SETPORTDOT1XAUTHSTATE:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_SetPortDot1xAuthState(
                msg_data_p->data.u32a1_u32a2.u32_a1,
                msg_data_p->data.u32a1_u32a2.u32_a2);
            break;

#if (SYS_CPNT_STATIC_TRUNK_CONFIG_ALLOWED_ON_LACP_PORT == TRUE)

        case SWCTRL_MGR_IPCCMD_SETPORTLACPOPERENABLE:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_SetPortLacpOperEnable(
                msg_data_p->data.u32a1_u32a2.u32_a1,
                msg_data_p->data.u32a1_u32a2.u32_a2);
            break;

        case SWCTRL_MGR_IPCCMD_SETPORTLACPADMINENABLE:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_SetPortLacpAdminEnable(
                msg_data_p->data.u32a1_u32a2.u32_a1,
                msg_data_p->data.u32a1_u32a2.u32_a2);
            break;
#else

        case SWCTRL_MGR_IPCCMD_SETPORTLACPENABLE:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_SetPortLacpEnable(
                msg_data_p->data.u32a1_u32a2.u32_a1,
                msg_data_p->data.u32a1_u32a2.u32_a2);
            break;

        case SWCTRL_MGR_IPCCMD_SETLACPENABLE:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_SetLacpEnable(
                msg_data_p->data.ui32_v);
            break;
#endif

        case SWCTRL_MGR_IPCCMD_SETPORTLACPCOLLECTING:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_SetPortLacpCollecting(
                msg_data_p->data.u32a1_u32a2.u32_a1,
                msg_data_p->data.u32a1_u32a2.u32_a2);
            break;

        case SWCTRL_MGR_IPCCMD_SETPORTOPERDORMANTSTATUS:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_SetPortOperDormantStatus(
                msg_data_p->data.u32a1_u32a2_u32a3_u32a4.u32_a1,
                msg_data_p->data.u32a1_u32a2_u32a3_u32a4.u32_a2,
                msg_data_p->data.u32a1_u32a2_u32a3_u32a4.u32_a3,
                msg_data_p->data.u32a1_u32a2_u32a3_u32a4.u32_a4);
            break;

        case SWCTRL_MGR_IPCCMD_TRIGGERPORTOPERDORMANTEVENT:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_TriggerPortOperDormantEvent(
                msg_data_p->data.u32a1_u32a2_u32a3.u32_a1,
                msg_data_p->data.u32a1_u32a2_u32a3.u32_a2,
                msg_data_p->data.u32a1_u32a2_u32a3.u32_a3);
            break;

        case SWCTRL_MGR_IPCCMD_SETPORTSTASTATE:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_SetPortSTAState(
                msg_data_p->data.u32a1_u32a2_u32a3.u32_a1,
                msg_data_p->data.u32a1_u32a2_u32a3.u32_a2,
                msg_data_p->data.u32a1_u32a2_u32a3.u32_a3);
            break;

#if (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_MSTP)

        case SWCTRL_MGR_IPCCMD_SETMSTENABLESTATUS:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_SetMstEnableStatus(
                msg_data_p->data.ui32_v);
            break;
#endif

        case SWCTRL_MGR_IPCCMD_SETPORTSECURITYSTATUS:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_SetPortSecurityStatus(
                msg_data_p->data.u32a1_u32a2_u32a3.u32_a1,
                msg_data_p->data.u32a1_u32a2_u32a3.u32_a2,
                msg_data_p->data.u32a1_u32a2_u32a3.u32_a3 );
            break;

        case SWCTRL_MGR_IPCCMD_SETPORTSECURITYACTIONSTATUS:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_SetPortSecurityActionStatus(
                msg_data_p->data.u32a1_u32a2.u32_a1,
                msg_data_p->data.u32a1_u32a2.u32_a2);
            break;

        case SWCTRL_MGR_IPCCMD_SETPORTSECURITYACTIONTRAPOPERSTATUS:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_SetPortSecurityActionTrapOperStatus(
                msg_data_p->data.u32a1_u32a2.u32_a1,
                msg_data_p->data.u32a1_u32a2.u32_a2);
            break;

        case SWCTRL_MGR_IPCCMD_ADDSECURITYACTIONTRAPTIMESTAMP:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_AddSecurityActionTrapTimeStamp(
                msg_data_p->data.u32a1_u32a2.u32_a1,
                msg_data_p->data.u32a1_u32a2.u32_a2 );
            break;

        case SWCTRL_MGR_IPCCMD_RESETSECURITYACTIONTRAPTIMESTAMP:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_ResetSecurityActionTrapTimeStamp(
                msg_data_p->data.ui32_v);
            break;

        case SWCTRL_MGR_IPCCMD_SETPORTPVID:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_SetPortPVID(
                msg_data_p->data.u32a1_u32a2.u32_a1,
                msg_data_p->data.u32a1_u32a2.u32_a2,
                TRUE);

        case SWCTRL_MGR_IPCCMD_CREATEVLAN:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_CreateVlan(
                msg_data_p->data.ui32_v);
            break;

        case SWCTRL_MGR_IPCCMD_DESTROYVLAN:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_DestroyVlan(
                msg_data_p->data.ui32_v);
            break;

        case SWCTRL_MGR_IPCCMD_SETGLOBALDEFAULTVLAN:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_SetGlobalDefaultVlan(
                msg_data_p->data.ui32_v);
            break;

        case SWCTRL_MGR_IPCCMD_ADDPORTTOVLANMEMBERSET:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_AddPortToVlanMemberSet(
                msg_data_p->data.u32a1_u32a2.u32_a1,
                msg_data_p->data.u32a1_u32a2.u32_a2,
                TRUE);
            break;

        case SWCTRL_MGR_IPCCMD_DELETEPORTFROMVLANMEMBERSET:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_DeletePortFromVlanMemberSet(
                msg_data_p->data.u32a1_u32a2.u32_a1,
                msg_data_p->data.u32a1_u32a2.u32_a2,
                TRUE);
            break;

        case SWCTRL_MGR_IPCCMD_ADDPORTTOVLANUNTAGGEDSET:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_AddPortToVlanUntaggedSet(
                msg_data_p->data.u32a1_u32a2.u32_a1,
                msg_data_p->data.u32a1_u32a2.u32_a2,TRUE);
            break;

        case SWCTRL_MGR_IPCCMD_DELETEPORTFROMVLANUNTAGGEDSET:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_DeletePortFromVlanUntaggedSet(
                msg_data_p->data.u32a1_u32a2.u32_a1,
                msg_data_p->data.u32a1_u32a2.u32_a2,
                TRUE);
            break;

        case SWCTRL_MGR_IPCCMD_GETSYSTEMMTU:
            ipcmsg_p->msg_size=(sizeof(((SWCTRL_MGR_IPCMsg_T *)0)->data.u32a1_u32a2) + SWCTRL_MGR_MSGBUF_TYPE_SIZE);
            msg_data_p->type.result_bool=SWCTRL_GetSystemMTU(
                &msg_data_p->data.u32a1_u32a2.u32_a1,
                &msg_data_p->data.u32a1_u32a2.u32_a2);
            break;
        case SWCTRL_MGR_IPCCMD_SETSYSTEMMTU:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_SetSystemMTU(
                msg_data_p->data.u32a1_u32a2.u32_a1,
                msg_data_p->data.u32a1_u32a2.u32_a2);
            break;
        case SWCTRL_MGR_IPCCMD_SETPORTMTU:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_SetPortMTU(
                msg_data_p->data.u32a1_u32a2.u32_a1,
                msg_data_p->data.u32a1_u32a2.u32_a2);
            break;

        case SWCTRL_MGR_IPCCMD_ENABLEINGRESSFILTER:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_EnableIngressFilter(
                msg_data_p->data.ui32_v);
            break;

        case SWCTRL_MGR_IPCCMD_DISABLEINGRESSFILTER:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_DisableIngressFilter(
                msg_data_p->data.ui32_v);
            break;

        case SWCTRL_MGR_IPCCMD_ADMITVLANTAGGEDFRAMESONLY:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_AdmitVLANTaggedFramesOnly(
                msg_data_p->data.ui32_v);
            break;

        case SWCTRL_MGR_IPCCMD_ADMITVLANUNTAGGEDFRAMESONLY:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_AdmitVLANUntaggedFramesOnly(
                msg_data_p->data.ui32_v);
            break;

        case SWCTRL_MGR_IPCCMD_ADMITALLFRAMES:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_AdmitAllFrames(
                msg_data_p->data.ui32_v);
            break;

        case SWCTRL_MGR_IPCCMD_ALLOWTOBETRUNKMEMBER:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_AllowToBeTrunkMember(
                msg_data_p->data.u32a1_u32a2.u32_a1,
                msg_data_p->data.u32a1_u32a2.u32_a2);
            break;

        case SWCTRL_MGR_IPCCMD_SETTRUNKBALANCEMODE:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_SetTrunkBalanceMode(
                msg_data_p->data.ui32_v);
            break;

        case SWCTRL_MGR_IPCCMD_SETTRUNKMEMBERACTIVESTATUS:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_SetTrunkMemberActiveStatus(
                msg_data_p->data.trunkid_unitport.trunk_id,
                msg_data_p->data.trunkid_unitport.unit_port,
                msg_data_p->data.trunkid_unitport.u32_a1);
            break;

        case SWCTRL_MGR_IPCCMD_SETTRUNKMAXNUMOFACTIVEPORTS:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_SetTrunkMaxNumOfActivePorts(
                msg_data_p->data.u32a1_u32a2.u32_a1,
                msg_data_p->data.u32a1_u32a2.u32_a2);
            break;

        case SWCTRL_MGR_IPCCMD_ENABLEIGMPTRAP:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_EnableIgmpTrap(msg_data_p->data.ui32_v);
            break;

        case SWCTRL_MGR_IPCCMD_DISABLEIGMPTRAP:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_DisableIgmpTrap(msg_data_p->data.ui32_v);
            break;

        case SWCTRL_MGR_IPCCMD_TRAPUNKNOWNIPMCASTTOCPU:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_TrapUnknownIpMcastToCPU(
                msg_data_p->data.u32a1_u32a2_u32a3_u32a4.u32_a1,
                msg_data_p->data.u32a1_u32a2_u32a3_u32a4.u32_a2,
                msg_data_p->data.u32a1_u32a2_u32a3_u32a4.u32_a3,
                msg_data_p->data.u32a1_u32a2_u32a3_u32a4.u32_a4);
            break;
#if (SYS_CPNT_MLDSNP == TRUE)
        case SWCTRL_MGR_IPCCMD_TRAPUNKNOWNIPV6MCASTTOCPU:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_TrapUnknownIpv6McastToCPU(
                msg_data_p->data.u32a1_u32a2_u32a3.u32_a1,
                msg_data_p->data.u32a1_u32a2_u32a3.u32_a2,
                msg_data_p->data.u32a1_u32a2_u32a3.u32_a3);
            break;
#endif
#if (SYS_CPNT_MLDSNP == TRUE)
                case SWCTRL_MGR_IPCCMD_TRAPIPV6PIMTOCPU:
                    ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
                    msg_data_p->type.result_bool=SWCTRL_TrapIpv6PIMToCPU(
                        msg_data_p->data.u32a1_u32a2.u32_a1,
                        msg_data_p->data.u32a1_u32a2.u32_a2);
                    break;
#endif

        case SWCTRL_MGR_IPCCMD_SETUNKNOWNIPMCASTFWDPORTLIST:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_SetUnknownIPMcastFwdPortList(
                msg_data_p->data.port_list);
            break;

        case SWCTRL_MGR_IPCCMD_SETBSTORMCONTROLRATELIMIT:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_SetBStormControlRateLimit(
                msg_data_p->data.u32a1_u32a2_u32a3.u32_a1,
                msg_data_p->data.u32a1_u32a2_u32a3.u32_a2,
                msg_data_p->data.u32a1_u32a2_u32a3.u32_a3);
            break;

        case SWCTRL_MGR_IPCCMD_SETMSTORMCONTROLRATELIMIT:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_SetMStormControlRateLimit(
                msg_data_p->data.u32a1_u32a2_u32a3.u32_a1,
                msg_data_p->data.u32a1_u32a2_u32a3.u32_a2,
                msg_data_p->data.u32a1_u32a2_u32a3.u32_a3);
            break;

#if (SYS_CPNT_STORM_MODE & SYS_CPNT_STORM_UNKNOWN_USTORM)
        case SWCTRL_MGR_IPCCMD_SETUNKNOWNUSTORMCONTROLRATELIMIT:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_SetUnknownUStormControlRateLimit(
                msg_data_p->data.u32a1_u32a2_u32a3.u32_a1,
                msg_data_p->data.u32a1_u32a2_u32a3.u32_a2,
                msg_data_p->data.u32a1_u32a2_u32a3.u32_a3);
            break;
#endif

        case SWCTRL_MGR_IPCCMD_SETBROADCASTSTORMSTATUS:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_SetBroadcastStormStatus(
                msg_data_p->data.u32a1_u32a2.u32_a1,
                msg_data_p->data.u32a1_u32a2.u32_a2);
            break;

        case SWCTRL_MGR_IPCCMD_SETMULTICASTSTORMSTATUS:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_SetMulticastStormStatus(
                msg_data_p->data.u32a1_u32a2.u32_a1,
                msg_data_p->data.u32a1_u32a2.u32_a2);
            break;

#if (SYS_CPNT_STORM_MODE & SYS_CPNT_STORM_UNKNOWN_USTORM)
        case SWCTRL_MGR_IPCCMD_SETUNKNOWNUNICASTSTORMSTATUS:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_SetUnknownUnicastStormStatus(
                msg_data_p->data.u32a1_u32a2.u32_a1,
                msg_data_p->data.u32a1_u32a2.u32_a2);
            break;
#endif

#if (SYS_CPNT_SWCTRL_GLOBAL_STORM_SAMPLE_TYPE == TRUE)
        case SWCTRL_MGR_IPCCMD_SETGLOBALSTORMSAMPLETYPE:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_SetGlobalStormSampleType(
                msg_data_p->data.ui32_v);
            break;
#endif

        case SWCTRL_MGR_IPCCMD_SETPORTUSERDEFAULTPRIORITY:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_SetPortUserDefaultPriority(
                msg_data_p->data.u32a1_u32a2.u32_a1,
                msg_data_p->data.u32a1_u32a2.u32_a2);
            break;

        case SWCTRL_MGR_IPCCMD_SETPRIORITYMAPPING:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_SetPriorityMapping(
                msg_data_p->data.ifindex_mapping.ifindex,
                msg_data_p->data.ifindex_mapping.mapping);
            break;

        case SWCTRL_MGR_IPCCMD_SETPRIORITYMAPPINGPERSYSTEM:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_SetPriorityMappingPerSystem(
                msg_data_p->data.mapping);
            break;

        case SWCTRL_MGR_IPCCMD_DISABLETOSCOSMAP:
            ipcmsg_p->msg_size=0;
            SWCTRL_DisableTosCosMap();
            break;

        case SWCTRL_MGR_IPCCMD_ENABLEDSCPCOSMAP:
            ipcmsg_p->msg_size=0;
            SWCTRL_EnableDscpCosMap();
            break;

        case SWCTRL_MGR_IPCCMD_DISABLEDSCPCOSMAP:
            ipcmsg_p->msg_size=0;
            SWCTRL_DisableDscpCosMap();
            break;

        case SWCTRL_MGR_IPCCMD_SETPORTTOSCOSMAP:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_SetPortTosCosMap(
                msg_data_p->data.u32a1_u32a2_u32a3.u32_a1,
                msg_data_p->data.u32a1_u32a2_u32a3.u32_a2,
                msg_data_p->data.u32a1_u32a2_u32a3.u32_a3);
            break;

        case SWCTRL_MGR_IPCCMD_SETPORTDSCPCOSMAP:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_SetPortDscpCosMap(
                msg_data_p->data.u32a1_u32a2_u32a3.u32_a1,
                msg_data_p->data.u32a1_u32a2_u32a3.u32_a2,
                msg_data_p->data.u32a1_u32a2_u32a3.u32_a3);
            break;

        case SWCTRL_MGR_IPCCMD_SETPORTTCPPORTCOSMAP:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_SetPortTcpPortCosMap(
                msg_data_p->data.u32a1_u32a2_u32a3.u32_a1,
                msg_data_p->data.u32a1_u32a2_u32a3.u32_a2,
                msg_data_p->data.u32a1_u32a2_u32a3.u32_a3);
            break;

        case SWCTRL_MGR_IPCCMD_DELPORTTOSCOSMAP:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_DelPortTosCosMap(
                msg_data_p->data.u32a1_u32a2.u32_a1,
                msg_data_p->data.u32a1_u32a2.u32_a2);
            break;

        case SWCTRL_MGR_IPCCMD_DELPORTDSCPCOSMAP:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_DelPortDscpCosMap(
                msg_data_p->data.u32a1_u32a2.u32_a1,
                msg_data_p->data.u32a1_u32a2.u32_a2);
            break;

        case SWCTRL_MGR_IPCCMD_DELPORTTCPPORTCOSMAP:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_DelPortTcpPortCosMap(
                msg_data_p->data.u32a1_u32a2.u32_a1,
                msg_data_p->data.u32a1_u32a2.u32_a2);
            break;

#if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION == TRUE)

        case SWCTRL_MGR_IPCCMD_ENABLEPRIVATEVLAN:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_EnablePrivateVlan();
            break;

        case SWCTRL_MGR_IPCCMD_DISABLEPRIVATEVLAN:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_DisablePrivateVlan();
            break;

        case SWCTRL_MGR_IPCCMD_SETPRIVATEVLAN:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_SetPrivateVlan(
                msg_data_p->data.uplinkportlist_downlinkportlist.uplink_port_list,
                msg_data_p->data.uplinkportlist_downlinkportlist.downlink_port_list);
            break;

#if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION == TRUE)
#if (SYS_DFLT_TRAFFIC_SEG_METHOD == SYS_DFLT_TRAFFIC_SEG_METHOD_PORT_PRIVATE_MODE)

        case SWCTRL_MGR_IPCCMD_SETPORTPRIVATEMODE:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_SetPortPrivateMode(
                msg_data_p->data.u32a1_u32a2.u32_a1,
                msg_data_p->data.u32a1_u32a2.u32_a2);
            break;
#endif /* #if (SYS_DFLT_TRAFFIC_SEG_METHOD == SYS_DFLT_TRAFFIC_SEG_METHOD_PORT_PRIVATE_MODE) */
#endif /* #if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION == TRUE) */
#endif /* #if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION == TRUE) */

#if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION == TRUE)
#if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE == SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE_MULTIPLE_SESSION)

        case SWCTRL_MGR_IPCCMD_SETPRIVATEVLANBYSESSIONID:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_SetPrivateVlanBySessionId(
                msg_data_p->data.uplinkportlist_downlinkportlist.session_id,
                msg_data_p->data.uplinkportlist_downlinkportlist.uplink_port_list,
                msg_data_p->data.uplinkportlist_downlinkportlist.downlink_port_list);
            break;

        case SWCTRL_MGR_IPCCMD_DELETEPRIVATEVLANPORTLISTBYSESSIONID:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_DeletePrivateVlanPortlistBySessionId(
                msg_data_p->data.uplinkportlist_downlinkportlist.session_id,
                msg_data_p->data.uplinkportlist_downlinkportlist.uplink_port_list,
                msg_data_p->data.uplinkportlist_downlinkportlist.downlink_port_list);
            break;

        case SWCTRL_MGR_IPCCMD_DESTROYPRIVATEVLANSESSION:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_DestroyPrivateVlanSession(
                msg_data_p->data.u32a1_u32a2_u32a3.u32_a1,
                msg_data_p->data.u32a1_u32a2_u32a3.u32_a2,
                msg_data_p->data.u32a1_u32a2_u32a3.u32_a3);
            break;

        case SWCTRL_MGR_IPCCMD_ENABLEPRIVATEVLANUPLINKTOUPLINKBLOCKINGMODE:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_EnablePrivateVlanUplinkToUplinkBlockingMode();
            break;

        case SWCTRL_MGR_IPCCMD_DISABLEPRIVATEVLANUPLINKTOUPLINKBLOCKINGMODE:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_DisablePrivateVlanUplinkToUplinkBlockingMode();
            break;

#endif /* End of #if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE == SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE_MULTIPLE_SESSION)*/
#endif /* End of #if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION == TRUE) */

#if (SYS_CPNT_INGRESS_RATE_LIMIT == TRUE)

        case SWCTRL_MGR_IPCCMD_ENABLEPORTINGRESSRATELIMIT:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_EnablePortIngressRateLimit(
                msg_data_p->data.ui32_v);
            break;

        case SWCTRL_MGR_IPCCMD_DISABLEPORTINGRESSRATELIMIT:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_DisablePortIngressRateLimit(
                msg_data_p->data.ui32_v);
            break;

        case SWCTRL_MGR_IPCCMD_SETPORTINGRESSRATELIMIT:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_SetPortIngressRateLimit(
                msg_data_p->data.u32a1_u32a2.u32_a1,
                msg_data_p->data.u32a1_u32a2.u32_a2);
            break;
#endif

#if (SYS_CPNT_EGRESS_RATE_LIMIT == TRUE)

        case SWCTRL_MGR_IPCCMD_ENABLEPORTEGRESSRATELIMIT:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_EnablePortEgressRateLimit(
                msg_data_p->data.ui32_v);
            break;

        case SWCTRL_MGR_IPCCMD_DISABLEPORTEGRESSRATELIMIT:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_DisablePortEgressRateLimit(
                msg_data_p->data.ui32_v);
            break;

        case SWCTRL_MGR_IPCCMD_SETPORTEGRESSRATELIMIT:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_SetPortEgressRateLimit(
                msg_data_p->data.u32a1_u32a2.u32_a1,
                msg_data_p->data.u32a1_u32a2.u32_a2);
            break;
#endif

#if (SYS_CPNT_JUMBO_FRAMES == TRUE)

        case SWCTRL_MGR_IPCCMD_SETJUMBOFRAMESTATUS:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_SetJumboFrameStatus (
                msg_data_p->data.ui32_v);
            break;
#endif

#if 0
        case SWCTRL_MGR_IPCCMD_SETPORTPRIOQUEUEMODE:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_SetPortPrioQueueMode(
                msg_data_p->data.u32a1_u32a2.u32_a1,
                msg_data_p->data.u32a1_u32a2.u32_a2);
            break;

        case SWCTRL_MGR_IPCCMD_SETPORTWRRQUEUEWEIGHT:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_SetPortWrrQueueWeight(
                msg_data_p->data.u32a1_u32a2_u32a3.u32_a1,
                msg_data_p->data.u32a1_u32a2_u32a3.u32_a2,
                msg_data_p->data.u32a1_u32a2_u32a3.u32_a3);
            break;

        case SWCTRL_MGR_IPCCMD_SETWRRQUEUEWEIGHT:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_SetWrrQueueWeight(
                msg_data_p->data.u32a1_u32a2.u32_a1,
                msg_data_p->data.u32a1_u32a2.u32_a2);
            break;
#endif

        case SWCTRL_MGR_IPCCMD_SETPORTNAME:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_SetPortName(
                msg_data_p->data.ifindex_portname.ifindex,
                msg_data_p->data.ifindex_portname.port_name);
            break;
        case SWCTRL_MGR_IPCCMD_SETPORTALIAS:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_SetPortAlias(
                msg_data_p->data.ifindex_portname.ifindex,
                msg_data_p->data.ifindex_portname.port_name);
            break;
        case SWCTRL_MGR_IPCCMD_SETPORTSPEEDDPXCFG:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_SetPortSpeedDpxCfg(
                msg_data_p->data.u32a1_u32a2.u32_a1,
               msg_data_p->data.u32a1_u32a2.u32_a2);
            break;

        case SWCTRL_MGR_IPCCMD_SETPORTFLOWCTRLCFG:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_SetPortFlowCtrlCfg(
                msg_data_p->data.u32a1_u32a2.u32_a1,
                msg_data_p->data.u32a1_u32a2.u32_a2);
            break;

        case SWCTRL_MGR_IPCCMD_SETPORTCAPABILITIES:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_SetPortCapabilities(
                msg_data_p->data.u32a1_u32a2.u32_a1,
                msg_data_p->data.u32a1_u32a2.u32_a2);
            break;

        case SWCTRL_MGR_IPCCMD_SETPORTAUTONEGOTIATION:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_SetPortAutonegotiation(
                msg_data_p->data.u32a1_u32a2.u32_a1,
                msg_data_p->data.u32a1_u32a2.u32_a2);
            break;

        case SWCTRL_MGR_IPCCMD_SETMIRRORTYPE:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_SetMirrorType(
                msg_data_p->data.u32a1_u32a2_u32a3.u32_a1,
                msg_data_p->data.u32a1_u32a2_u32a3.u32_a2,
                msg_data_p->data.u32a1_u32a2_u32a3.u32_a3);
            break;

        case SWCTRL_MGR_IPCCMD_SETMIRRORSTATUS:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_SetMirrorStatus(
                msg_data_p->data.u32a1_u32a2_u32a3.u32_a1,
                msg_data_p->data.u32a1_u32a2_u32a3.u32_a2,
                msg_data_p->data.u32a1_u32a2_u32a3.u32_a3);
            break;

#if (SYS_CPNT_VLAN_MIRROR == TRUE)
        case SWCTRL_MGR_IPCCMD_GETVLANMIRRORENTRY:
        {
            SWCTRL_VlanMirrorEntry_T vlan_mirror_entry;

            vlan_mirror_entry.mirror_dest_port = msg_data_p->data.u32a1_u32a2.u32_a1;
            vlan_mirror_entry.mirror_source_vlan = msg_data_p->data.u32a1_u32a2.u32_a2;
            ipcmsg_p->msg_size=(sizeof(((SWCTRL_MGR_IPCMsg_T *)0)->data.u32a1_u32a2_u32a3)
                + SWCTRL_MGR_MSGBUF_TYPE_SIZE);
            msg_data_p->type.result_bool=SWCTRL_GetVlanMirrorEntry(&vlan_mirror_entry);
            msg_data_p->data.u32a1_u32a2_u32a3.u32_a1 = vlan_mirror_entry.mirror_dest_port;
            msg_data_p->data.u32a1_u32a2_u32a3.u32_a2 = vlan_mirror_entry.mirror_source_vlan;
            msg_data_p->data.u32a1_u32a2_u32a3.u32_a3 = vlan_mirror_entry.mirror_vlan_status;
        }
            break;
        case SWCTRL_MGR_IPCCMD_GETNEXTVLANMIRRORENTRY:
        {
            SWCTRL_VlanMirrorEntry_T vlan_mirror_entry;

            vlan_mirror_entry.mirror_dest_port = msg_data_p->data.u32a1_u32a2.u32_a1;
            vlan_mirror_entry.mirror_source_vlan = msg_data_p->data.u32a1_u32a2.u32_a2;
            ipcmsg_p->msg_size=(sizeof(((SWCTRL_MGR_IPCMsg_T *)0)->data.u32a1_u32a2_u32a3)
                + SWCTRL_MGR_MSGBUF_TYPE_SIZE);
            msg_data_p->type.result_bool=SWCTRL_GetNextVlanMirrorEntry(&vlan_mirror_entry);
            msg_data_p->data.u32a1_u32a2_u32a3.u32_a1=vlan_mirror_entry.mirror_dest_port;
            msg_data_p->data.u32a1_u32a2_u32a3.u32_a2=vlan_mirror_entry.mirror_source_vlan;
            msg_data_p->data.u32a1_u32a2_u32a3.u32_a3=vlan_mirror_entry.mirror_vlan_status;
        }
            break;
        case SWCTRL_MGR_IPCCMD_ADDVLANMIRROR:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_AddVlanMirror(
                msg_data_p->data.u32a1_u32a2.u32_a1,
                msg_data_p->data.u32a1_u32a2.u32_a2);
            break;
        case SWCTRL_MGR_IPCCMD_DELETEVLANMIRROR:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_DeleteVlanMirror(
                msg_data_p->data.u32a1_u32a2.u32_a1,
                msg_data_p->data.u32a1_u32a2.u32_a2);
            break;
#endif

#if (SYS_CPNT_MAC_BASED_MIRROR == TRUE)
        case SWCTRL_MGR_IPCCMD_SETMACMIRRORENTRY:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_SetMacMirrorEntry(
                msg_data_p->data.mac_mirror_entry.ifindex_dest,
                msg_data_p->data.mac_mirror_entry.mac);
            break;
        case SWCTRL_MGR_IPCCMD_DELETEMACMIRRORENTRY:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_DeleteMacMirrorEntry(
                msg_data_p->data.mac_mirror_entry.ifindex_dest,
                msg_data_p->data.mac_mirror_entry.mac);
            break;
#endif

#if (SYS_CPNT_ACL_MIRROR == TRUE)
        case SWCTRL_MGR_IPCCMD_SETACLMIRRORDESTPORT:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_SetAclMirrorDestPort(
                msg_data_p->data.u32a1_u32a2_u32a3.u32_a1,
                msg_data_p->data.u32a1_u32a2_u32a3.u32_a2,
                msg_data_p->data.u32a1_u32a2_u32a3.u32_a3);
            break;
#endif

        case SWCTRL_MGR_IPCCMD_SETBCASTSTORMSTATUS:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_SetBcastStormStatus(
                msg_data_p->data.u32a1_u32a2.u32_a1,
                msg_data_p->data.u32a1_u32a2.u32_a2);
            break;

        case SWCTRL_MGR_IPCCMD_SETBCASTSTORMSAMPLETYPE:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_SetBcastStormSampleType(
                msg_data_p->data.u32a1_u32a2.u32_a1,
                msg_data_p->data.u32a1_u32a2.u32_a2);
            break;

        case SWCTRL_MGR_IPCCMD_SETBCASTSTORMPKTRATE:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_SetBcastStormPktRate(
                msg_data_p->data.u32a1_u32a2.u32_a1,
                msg_data_p->data.u32a1_u32a2.u32_a2);
            break;

        case SWCTRL_MGR_IPCCMD_SETBCASTSTORMOCTETRATE:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_SetBcastStormOctetRate(
                msg_data_p->data.u32a1_u32a2.u32_a1,
                msg_data_p->data.u32a1_u32a2.u32_a2);
            break;

        case SWCTRL_MGR_IPCCMD_SETBCASTSTORMPERCENT:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_SetBcastStormPercent(
                msg_data_p->data.u32a1_u32a2.u32_a1,
                msg_data_p->data.u32a1_u32a2.u32_a2);
            break;

        case SWCTRL_MGR_IPCCMD_SETMCASTSTORMSTATUS:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_SetMcastStormStatus(
                msg_data_p->data.u32a1_u32a2.u32_a1,
                msg_data_p->data.u32a1_u32a2.u32_a2);
            break;

        case SWCTRL_MGR_IPCCMD_SETMCASTSTORMSAMPLETYPE:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_SetMcastStormSampleType(
                msg_data_p->data.u32a1_u32a2.u32_a1,
                msg_data_p->data.u32a1_u32a2.u32_a2);
            break;

        case SWCTRL_MGR_IPCCMD_SETMCASTSTORMPKTRATE:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_SetMcastStormPktRate(
                msg_data_p->data.u32a1_u32a2.u32_a1,
                msg_data_p->data.u32a1_u32a2.u32_a2);
            break;

        case SWCTRL_MGR_IPCCMD_SETMCASTSTORMOCTETRATE:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_SetMcastStormOctetRate(
                msg_data_p->data.u32a1_u32a2.u32_a1,
                msg_data_p->data.u32a1_u32a2.u32_a2);
            break;

        case SWCTRL_MGR_IPCCMD_SETMCASTSTORMPERCENT:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_SetMcastStormPercent(
                msg_data_p->data.u32a1_u32a2.u32_a1,
                msg_data_p->data.u32a1_u32a2.u32_a2);
            break;


        case SWCTRL_MGR_IPCCMD_GETNEXTLOGICALPORT:
            ipcmsg_p->msg_size=(sizeof(((SWCTRL_MGR_IPCMsg_T *)0)->data.ui32_v)
                            + SWCTRL_MGR_MSGBUF_TYPE_SIZE);
            msg_data_p->type.result_ui32= SWCTRL_GetNextLogicalPort(&msg_data_p->data.ui32_v);
            break;


        case SWCTRL_MGR_IPCCMD_ISMANAGEMENTPORT:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool= SWCTRL_IsManagementPort(msg_data_p->data.ui32_v);
            break;

        case SWCTRL_MGR_IPCCMD_LOGICALPORTTOUSERPORT:
            ipcmsg_p->msg_size=(sizeof(((SWCTRL_MGR_IPCMsg_T *)0)->data.u32a1_u32a2_u32a3_u32a4))
                            +SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_ui32= SWCTRL_LogicalPortToUserPort(\
                                            msg_data_p->data.u32a1_u32a2_u32a3_u32a4.u32_a1,\
                                            &(msg_data_p->data.u32a1_u32a2_u32a3_u32a4.u32_a2),\
                                            &(msg_data_p->data.u32a1_u32a2_u32a3_u32a4.u32_a3),\
                                            &(msg_data_p->data.u32a1_u32a2_u32a3_u32a4.u32_a4));
            break;

#if (SYS_CPNT_STORM_MODE & SYS_CPNT_STORM_UNKNOWN_USTORM)
        case SWCTRL_MGR_IPCCMD_SETUNKUCASTSTORMSAMPLETYPE:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_SetUnkucastStormSampleType(
                msg_data_p->data.u32a1_u32a2.u32_a1,
                msg_data_p->data.u32a1_u32a2.u32_a2);
            break;

        case SWCTRL_MGR_IPCCMD_SETUNKUCASTSTORMPKTRATE:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_SetUnkucastStormPktRate(
                msg_data_p->data.u32a1_u32a2.u32_a1,
                msg_data_p->data.u32a1_u32a2.u32_a2);
            break;

        case SWCTRL_MGR_IPCCMD_SETUNKUCASTSTORMOCTETRATE:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_SetUnkucastStormOctetRate(
                msg_data_p->data.u32a1_u32a2.u32_a1,
                msg_data_p->data.u32a1_u32a2.u32_a2);
            break;

        case SWCTRL_MGR_IPCCMD_SETUNKUCASTSTORMPERCENT:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_SetUnkucastStormPercent(
                msg_data_p->data.u32a1_u32a2.u32_a1,
                msg_data_p->data.u32a1_u32a2.u32_a2);
            break;
#endif

        case SWCTRL_MGR_IPCCMD_SHUTDOWNSWITCH:
            ipcmsg_p->msg_size=0;
            SWCTRL_ShutdownSwitch();
            break;

        case SWCTRL_MGR_IPCCMD_DISABLEIPMC:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_DisableIPMC();
            break;

        case SWCTRL_MGR_IPCCMD_ENABLEIPMC:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_EnableIPMC();
            break;

        case SWCTRL_MGR_IPCCMD_DISABLEUMCASTIPTRAP:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_DisableUMCASTIpTrap();
            break;

        case SWCTRL_MGR_IPCCMD_ENABLEUMCASTIPTRAP:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_EnableUMCASTIpTrap();
            break;

        case SWCTRL_MGR_IPCCMD_DISABLEUMCASTMACTRAP:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_DisableUMCASTMacTrap();
            break;

        case SWCTRL_MGR_IPCCMD_ENABLEUMCASTMACTRAP:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_EnableUMCASTMacTrap();
            break;

        case SWCTRL_MGR_IPCCMD_SETUNITSBASEMACADDRTABLE:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_SetUnitsBaseMacAddrTable(
                msg_data_p->data.mac_addrs);
            break;

        case SWCTRL_MGR_IPCCMD_SETUNITSDEVICETYPETABLE:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_SetUnitsDeviceTypeTable(
                msg_data_p->data.device_types);
            break;

#if (SYS_CPNT_MAU_MIB == TRUE)

        case SWCTRL_MGR_IPCCMD_SETIFMAUSTATUS:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_SetIfMauStatus (
                msg_data_p->data.u32a1_u32a2_u32a3.u32_a1,
                msg_data_p->data.u32a1_u32a2_u32a3.u32_a2,
                msg_data_p->data.u32a1_u32a2_u32a3.u32_a3);
            break;

        case SWCTRL_MGR_IPCCMD_SETIFMAUDEFAULTTYPE:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_SetIfMauDefaultType (
                msg_data_p->data.u32a1_u32a2_u32a3.u32_a1,
                msg_data_p->data.u32a1_u32a2_u32a3.u32_a2,
                msg_data_p->data.u32a1_u32a2_u32a3.u32_a3);
            break;

        case SWCTRL_MGR_IPCCMD_SETIFMAUAUTONEGADMINSTATUS:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_SetIfMauAutoNegAdminStatus (
                msg_data_p->data.u32a1_u32a2_u32a3.u32_a1,
                msg_data_p->data.u32a1_u32a2_u32a3.u32_a2,
                msg_data_p->data.u32a1_u32a2_u32a3.u32_a3);
            break;

        case SWCTRL_MGR_IPCCMD_SETIFMAUAUTONEGRESTART:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_SetIfMauAutoNegRestart (
                msg_data_p->data.u32a1_u32a2_u32a3.u32_a1,
                msg_data_p->data.u32a1_u32a2_u32a3.u32_a2,
                msg_data_p->data.u32a1_u32a2_u32a3.u32_a3);
            break;

        case SWCTRL_MGR_IPCCMD_SETIFMAUAUTONEGCAPADVERTISEDBITS:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_SetIfMauAutoNegCapAdvertisedBits (
                msg_data_p->data.u32a1_u32a2_u32a3.u32_a1,
                msg_data_p->data.u32a1_u32a2_u32a3.u32_a2,
                msg_data_p->data.u32a1_u32a2_u32a3.u32_a3);
            break;

        case SWCTRL_MGR_IPCCMD_SETIFMAUAUTONEGREMOTEFAULTADVERTISED:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_SetIfMauAutoNegRemoteFaultAdvertised (
                msg_data_p->data.u32a1_u32a2_u32a3.u32_a1,
                msg_data_p->data.u32a1_u32a2_u32a3.u32_a2,
                msg_data_p->data.u32a1_u32a2_u32a3.u32_a3);
            break;
#endif

#if (SYS_CPNT_SFP_DDM_ALARMWARN_TRAP == TRUE)
        case SWCTRL_MGR_IPCCMD_SETPORTSFPDDMTHRESHOLD:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_SetPortSfpDdmThreshold(
                msg_data_p->data.u32a1_u32a2_i32a3_bla4.u32_a1,
                msg_data_p->data.u32a1_u32a2_i32a3_bla4.u32_a2,
                msg_data_p->data.u32a1_u32a2_i32a3_bla4.i32_a3,
                msg_data_p->data.u32a1_u32a2_i32a3_bla4.bl_a4);
            break;
        case SWCTRL_MGR_IPCCMD_SETPORTSFPDDMTHRESHOLDFORWEB:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_SetPortSfpDdmThresholdForWeb(
                msg_data_p->data.u32a1_u32a2_i32a3_i32a4_i32a5_i32a6.u32_a1,
                msg_data_p->data.u32a1_u32a2_i32a3_i32a4_i32a5_i32a6.u32_a2,
                msg_data_p->data.u32a1_u32a2_i32a3_i32a4_i32a5_i32a6.i32_a3,
                msg_data_p->data.u32a1_u32a2_i32a3_i32a4_i32a5_i32a6.i32_a4,
                msg_data_p->data.u32a1_u32a2_i32a3_i32a4_i32a5_i32a6.i32_a5,
                msg_data_p->data.u32a1_u32a2_i32a3_i32a4_i32a5_i32a6.i32_a6);
            break;
        case SWCTRL_MGR_IPCCMD_SETPORTSFPDDMTHRESHOLDDEFAULT:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_SetPortSfpDdmThresholdDefault(
                msg_data_p->data.u32a1_u32a2.u32_a1,
                msg_data_p->data.u32a1_u32a2.u32_a2);
            break;
        case SWCTRL_MGR_IPCCMD_SETPORTSFPDDMTRAPENABLE:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_SetPortSfpDdmTrapEnable(
                msg_data_p->data.u32a1_boola2.u32_a1,
                msg_data_p->data.u32a1_boola2.bool_a2);
            break;
        case SWCTRL_MGR_IPCCMD_SETPORTSFPDDMTHRESHOLDAUTOMODE:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_SetPortSfpDdmThresholdAutoMode(
                msg_data_p->data.u32a1_boola2.u32_a1,
                msg_data_p->data.u32a1_boola2.bool_a2);
            break;
#endif

#if (SYS_CPNT_COMBO_PORT_FORCE_MODE == TRUE)

        case SWCTRL_MGR_IPCCMD_SETPORTCOMBOFORCEDMODE:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
#if (SYS_CPNT_COMBO_PORT_FORCED_MODE_SFP_SPEED == TRUE)
            msg_data_p->type.result_bool=SWCTRL_SetPortComboForcedMode(
                msg_data_p->data.u32a1_u32a2_u32a3.u32_a1,
                msg_data_p->data.u32a1_u32a2_u32a3.u32_a2,
                msg_data_p->data.u32a1_u32a2_u32a3.u32_a3);
#else
            msg_data_p->type.result_bool=SWCTRL_SetPortComboForcedMode(
                msg_data_p->data.u32a1_u32a2.u32_a1,
                msg_data_p->data.u32a1_u32a2.u32_a2);
#endif
            break;
#endif

#if (SYS_CPNT_OSPF == TRUE)

        case SWCTRL_MGR_IPCCMD_ENABLEOSPFTRAP:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_EnableOSPFTrap();
            break;

        case SWCTRL_MGR_IPCCMD_DISABLEOSPFTRAP:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_DisableOSPFTrap();
            break;
#endif

        case SWCTRL_MGR_IPCCMD_SETPORTSTATEWITHMSTIDX:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_SetPortStateWithMstidx (
                msg_data_p->data.u32a1_u32a2_u32a3.u32_a1,
               msg_data_p->data.u32a1_u32a2_u32a3.u32_a2,
                msg_data_p->data.u32a1_u32a2_u32a3.u32_a3);
            break;

#if (SYS_CPNT_STP == SYS_CPNT_STP_TYPE_MSTP)

        case SWCTRL_MGR_IPCCMD_ADDVLANTOMST:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_AddVlanToMst(
                msg_data_p->data.u32a1_u32a2.u32_a1,
                msg_data_p->data.u32a1_u32a2.u32_a2);
            break;
#endif

#if (SYS_CPNT_DOT1X == TRUE)

        case SWCTRL_MGR_IPCCMD_SETDOT1XAUTHTRAP:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_SetDot1xAuthTrap(
                msg_data_p->data.u32a1_u32a2.u32_a1,
                msg_data_p->data.u32a1_u32a2.u32_a2);
            break;

        case SWCTRL_MGR_IPCCMD_SETDOT1XAUTHCONTROLMODE:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_SetDot1xAuthControlMode(
                msg_data_p->data.u32a1_u32a2.u32_a1,
                msg_data_p->data.u32a1_u32a2.u32_a2);
            break;
#endif

#if (SYS_CPNT_SWCTRL_CABLE_DIAG == TRUE)

        case SWCTRL_MGR_IPCCMD_EXCUTECABLEDIAG:
            ipcmsg_p->msg_size=sizeof(msg_data_p->data.cable_diag_info)
                +SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool = SWCTRL_ExecuteCableDiag(
                msg_data_p->data.cable_diag_info.lport,
                &msg_data_p->data.cable_diag_info.result);
            break;
#endif    /* #if (SYS_CPNT_SWCTRL_CABLE_DIAG == TRUE) */

#if (SYS_CPNT_RATE_BASED_STORM_CONTROL == TRUE)
        case SWCTRL_MGR_IPCCMD_SETRATEBASEDSTORMCONTROL:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_SetRateBasedStormControl(
                msg_data_p->data.u32a1_u32a2_u32a3.u32_a1,
                msg_data_p->data.u32a1_u32a2_u32a3.u32_a2,
                msg_data_p->data.u32a1_u32a2_u32a3.u32_a3);
            break;
        case SWCTRL_MGR_IPCCMD_SETRATEBASEDSTORMCONTROLRATE:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_SetRateBasedStormControlRate(
                msg_data_p->data.u32a1_u32a2_u32a3.u32_a1,
                msg_data_p->data.u32a1_u32a2_u32a3.u32_a2);
            break;
        case SWCTRL_MGR_IPCCMD_SETRATEBASEDSTORMCONTROLMODE:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_SetRateBasedStormControlMode(
                msg_data_p->data.u32a1_u32a2_u32a3.u32_a1,
                msg_data_p->data.u32a1_u32a2_u32a3.u32_a2);
            break;
#endif
#if (SYS_CPNT_MLDSNP == TRUE)
        case SWCTRL_MGR_IPCCMD_ENABLEMLDPACKETTRAP:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_EnableMldPacketTrap(msg_data_p->data.ui32_v);
            break;
        case SWCTRL_MGR_IPCCMD_DIABLEMLDPACKETTRAP:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_DisableMldPacketTrap(msg_data_p->data.ui32_v);
            break;
#endif

#if (SYS_CPNT_IPV6_RA_GUARD_SW_RELAY == TRUE)
        case SWCTRL_MGR_IPCCMD_SETRAANDRRPACKETTRAP:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_SetRaAndRrPacketTrap(msg_data_p->data.bool_v);
            break;
#endif /* #if (SYS_CPNT_IPV6_RA_GUARD_SW_RELAY == TRUE) */

#if (SYS_CPNT_IPV6_RA_GUARD_DROP_BY_RULE == TRUE)
        case SWCTRL_MGR_IPCCMD_SETPORTRAANDRRPACKETDROP:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_SetPortRaAndRrPacketDrop(
                msg_data_p->data.u32a1_boola2.u32_a1,
                msg_data_p->data.u32a1_boola2.bool_a2);
            break;
#endif /* #if (SYS_CPNT_IPV6_RA_GUARD_DROP_BY_RULE == TRUE) */

#if (SYS_CPNT_INTERNAL_LOOPBACK_TEST == TRUE)
        case SWCTRL_MGR_IPCCMD_EXECUTEINTERNALLOOPBACKTEST:

            if(SWCTRL_ExecuteInternalLoopbackTest(msg_data_p->data.ui32_v) == TRUE)
            {
                /* record the resp_thread_id to not response immediatly */
                resp_thread_id = ipcmsg_p->msg_type;
                /* In order to hang the resp thread, must return FALSE */
                return FALSE;
            }
            else
            {
                ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
                msg_data_p->type.result_bool = FALSE;
            }
            break;

#endif
#if(SYS_CPNT_AMTR_PORT_MAC_LEARNING == TRUE)
        case SWCTRL_MGR_IPCCMD_SETMACLEARNINGBYPORT:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool= SWCTRL_SetPortMACLearningStatus(msg_data_p->data.u32a1_u32a2.u32_a1,(BOOL_T)msg_data_p->data.u32a1_u32a2.u32_a2);
            break;
#endif



#if(SYS_CPNT_ATC_STORM == TRUE)
        case SWCTRL_MGR_IPCCMD_ATC_BCAST:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool= SWCTRL_SetATCBroadcastStormAutoTrafficControlOnStatus(\
                                            msg_data_p->data.u32a1_u32a2.u32_a1,\
                                            msg_data_p->data.u32a1_u32a2.u32_a2);
            break;

        case SWCTRL_MGR_IPCCMD_ATC_MCAST:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool= SWCTRL_SetATCMulticastStormAutoTrafficControlOnStatus(\
                                            msg_data_p->data.u32a1_u32a2.u32_a1,\
                                            msg_data_p->data.u32a1_u32a2.u32_a2);
            break;

        case SWCTRL_MGR_IPCCMD_ATC_BCASTACTION:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool= SWCTRL_SetATCBroadcastStormAction(\
                                            msg_data_p->data.u32a1_u32a2.u32_a1,\
                                            msg_data_p->data.u32a1_u32a2.u32_a2);
            break;

        case SWCTRL_MGR_IPCCMD_ATC_MCASTACTION:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool= SWCTRL_SetATCMulticastStormAction(\
                                            msg_data_p->data.u32a1_u32a2.u32_a1,\
                                            msg_data_p->data.u32a1_u32a2.u32_a2);
            break;

        case SWCTRL_MGR_IPCCMD_ATC_BCASTAUTOCONTROLRELEASE:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool= SWCTRL_SetATCBroadcastStormAutoTrafficControlReleaseStatus(\
                                            msg_data_p->data.u32a1_u32a2.u32_a1,\
                                            msg_data_p->data.u32a1_u32a2.u32_a2);
            break;

        case SWCTRL_MGR_IPCCMD_ATC_MCASTAUTOCONTROLRELEASE:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool= SWCTRL_SetATCMulticastStormAutoTrafficControlReleaseStatus(\
                                            msg_data_p->data.u32a1_u32a2.u32_a1,\
                                            msg_data_p->data.u32a1_u32a2.u32_a2);
            break;

        case SWCTRL_MGR_IPCCMD_ATC_BCASTALARMFIRETHRESHOLD:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool= SWCTRL_SetATCBroadcastStormStormAlarmThreshold(\
                                            msg_data_p->data.u32a1_u32a2.u32_a1,\
                                            msg_data_p->data.u32a1_u32a2.u32_a2);
            break;

        case SWCTRL_MGR_IPCCMD_ATC_MCASTALARMFIRETHRESHOLD:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool= SWCTRL_SetATCMulticastStormStormAlarmThreshold(\
                                            msg_data_p->data.u32a1_u32a2.u32_a1,\
                                            msg_data_p->data.u32a1_u32a2.u32_a2);
            break;

        case SWCTRL_MGR_IPCCMD_ATC_BCASTALARMCLEARTHRESHOLD:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool= SWCTRL_SetATCBroadcastStormStormClearThreshold(\
                                            msg_data_p->data.u32a1_u32a2.u32_a1,\
                                            msg_data_p->data.u32a1_u32a2.u32_a2);
            break;

        case SWCTRL_MGR_IPCCMD_ATC_MCASTALARMCLEARTHRESHOLD:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool= SWCTRL_SetATCMulticastStormStormClearThreshold(\
                                            msg_data_p->data.u32a1_u32a2.u32_a1,\
                                            msg_data_p->data.u32a1_u32a2.u32_a2);
            break;

        case SWCTRL_MGR_IPCCMD_ATC_BCASTALARMTHRESHOLD:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool= SWCTRL_SetATCBroadcastStormStormAlarmThresholdEx(
                                            msg_data_p->data.u32a1_u32a2_u32a3.u32_a1,
                                            msg_data_p->data.u32a1_u32a2_u32a3.u32_a2,
                                            msg_data_p->data.u32a1_u32a2_u32a3.u32_a3);
            break;

        case SWCTRL_MGR_IPCCMD_ATC_MCASTALARMTHRESHOLD:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool= SWCTRL_SetATCMulticastStormStormAlarmThresholdEx(
                                            msg_data_p->data.u32a1_u32a2_u32a3.u32_a1,
                                            msg_data_p->data.u32a1_u32a2_u32a3.u32_a2,
                                            msg_data_p->data.u32a1_u32a2_u32a3.u32_a3);
            break;

        case SWCTRL_MGR_IPCCMD_ATC_BCASTAPPLYTIME:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool= SWCTRL_SetATCBroadcastStormTrafficControlOnTimer(\
                                            msg_data_p->data.ui32_v);
            break;

        case SWCTRL_MGR_IPCCMD_ATC_GETBCASTAPPLYTIME:
                    ipcmsg_p->msg_size=(sizeof(((SWCTRL_MGR_IPCMsg_T *)0)->data.ui32_v)
                                                        + SWCTRL_MGR_MSGBUF_TYPE_SIZE);
            msg_data_p->type.result_bool= SWCTRL_GetATCBroadcastStormTrafficControlOnTimer(\
                                            &msg_data_p->data.ui32_v);
            break;

        case SWCTRL_MGR_IPCCMD_ATC_MCASTAPPLYTIME:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool= SWCTRL_SetATCMulticastStormTrafficControlOnTimer(\
                                            msg_data_p->data.ui32_v);
            break;

        case SWCTRL_MGR_IPCCMD_ATC_GETMCASTAPPLYTIME:
                    ipcmsg_p->msg_size=(sizeof(((SWCTRL_MGR_IPCMsg_T *)0)->data.ui32_v)
                                                        + SWCTRL_MGR_MSGBUF_TYPE_SIZE);
            msg_data_p->type.result_bool= SWCTRL_GetATCMulticastStormTrafficControlOnTimer(\
                                            &msg_data_p->data.ui32_v);
            break;

        case SWCTRL_MGR_IPCCMD_ATC_BCASTRELEASETIME:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool= SWCTRL_SetATCBroadcastStormTrafficControlReleaseTimer(\
                                            msg_data_p->data.ui32_v);
            break;
        case SWCTRL_MGR_IPCCMD_ATC_GETBCASTRELEASETIME:
                    ipcmsg_p->msg_size=(sizeof(((SWCTRL_MGR_IPCMsg_T *)0)->data.ui32_v)
                                                        + SWCTRL_MGR_MSGBUF_TYPE_SIZE);
            msg_data_p->type.result_bool= SWCTRL_GetATCBroadcastStormTrafficControlReleaseTimer(\
                                            &msg_data_p->data.ui32_v);
            break;


        case SWCTRL_MGR_IPCCMD_ATC_MCASTRELEASETIME:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool= SWCTRL_SetATCMulticastStormTrafficControlReleaseTimer(\
                                            msg_data_p->data.ui32_v);
            break;

        case SWCTRL_MGR_IPCCMD_ATC_GETMCASTRELEASETIME:
                    ipcmsg_p->msg_size=(sizeof(((SWCTRL_MGR_IPCMsg_T *)0)->data.ui32_v)
                                                        + SWCTRL_MGR_MSGBUF_TYPE_SIZE);
            msg_data_p->type.result_bool= SWCTRL_GetATCMulticastStormTrafficControlReleaseTimer(\
                                            &msg_data_p->data.ui32_v);
            break;

    case SWCTRL_MGR_IPCCMD_ATC_BCASTCONTROLRELEASE:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool= SWCTRL_SetATCBroadcastStormTrafficControlReleaseStatus(\
                                            msg_data_p->data.u32a1_u32a2.u32_a1,\
                                            msg_data_p->data.u32a1_u32a2.u32_a2);
        break;

    case SWCTRL_MGR_IPCCMD_ATC_MCASTCONTROLRELEASE:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool= SWCTRL_SetATCMulticastStormTrafficControlReleaseStatus(\
                                            msg_data_p->data.u32a1_u32a2.u32_a1,\
                                            msg_data_p->data.u32a1_u32a2.u32_a2);
        break;

    case SWCTRL_MGR_IPCCMD_ATC_GETBCASTTIMEER:
            ipcmsg_p->msg_size=sizeof(msg_data_p->data.atc_storm_timer)
                +SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool= SWCTRL_GetATCBroadcastStormTimer(\
                                            &(msg_data_p->data.atc_storm_timer.bcast_timer));
       break;

    case SWCTRL_MGR_IPCCMD_ATC_GETMCASTTIMEER:
            ipcmsg_p->msg_size=sizeof(msg_data_p->data.atc_storm_timer)
                +SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool= SWCTRL_GetATCMulticastStormTimer(\
                                            &(msg_data_p->data.atc_storm_timer.mcast_timer));
        break;

    case SWCTRL_MGR_IPCCMD_ATC_GETBCASTSTORMENTRY:
            ipcmsg_p->msg_size=sizeof(msg_data_p->data.get_atc_bcast_entry.bcast_entry)
                +SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool= SWCTRL_GetATCBroadcastStormEntry(\
                                            msg_data_p->data.get_atc_bcast_entry.port,\
                                            &(msg_data_p->data.get_atc_bcast_entry.bcast_entry));
        break;

    case SWCTRL_MGR_IPCCMD_ATC_GETRUNNINGBCASTSTORMENTRY:
            ipcmsg_p->msg_size=sizeof(msg_data_p->data.get_atc_bcast_entry)
                +SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_ui32= SWCTRL_GetRunningATCBroadcastStormEntry(\
                                            msg_data_p->data.get_atc_bcast_entry.port,\
                                            &(msg_data_p->data.get_atc_bcast_entry.bcast_entry));
        break;

    case SWCTRL_MGR_IPCCMD_ATC_GETMCASTSTORMENTRY:
            ipcmsg_p->msg_size=sizeof(msg_data_p->data.get_atc_mcast_entry)
                +SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool= SWCTRL_GetATCMulticastStormEntry(\
                                            msg_data_p->data.get_atc_mcast_entry.port,\
                                            &(msg_data_p->data.get_atc_mcast_entry.mcast_entry));
        break;

        case SWCTRL_MGR_IPCCMD_ATC_GETRUNNINGMCASTSTORMENTRY:
            ipcmsg_p->msg_size=sizeof(msg_data_p->data.get_atc_mcast_entry)
                +SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_ui32= SWCTRL_GetRunningATCMulticastStormEntry(\
                                            msg_data_p->data.get_atc_mcast_entry.port,\
                                            &(msg_data_p->data.get_atc_mcast_entry.mcast_entry));
    break;

        case SWCTRL_MGR_IPCCMD_ATC_GETRUNNINGBCASTTIMEER:
            ipcmsg_p->msg_size=sizeof(msg_data_p->data.atc_storm_timer)
                +SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_ui32= SWCTRL_GetRunningATCBroadcastStormTimer(\
                                            &(msg_data_p->data.atc_storm_timer.bcast_timer));
    break;

        case SWCTRL_MGR_IPCCMD_ATC_GETRUNNINGMCASTTIMEER:
            ipcmsg_p->msg_size=sizeof(msg_data_p->data.atc_storm_timer)
                +SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_ui32= SWCTRL_GetRunningATCMulticastStormTimer(\
                                            &(msg_data_p->data.atc_storm_timer.mcast_timer));
                    break;

        case SWCTRL_SetTrapBStormAlarmStatus:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool= SWCTRL_SetATCBroadcastStormTrapStormAlarmStatus(\
                                            msg_data_p->data.u32a1_u32a2.u32_a1,\
                                            msg_data_p->data.u32a1_u32a2.u32_a2);
        break;

        case SWCTRL_GetTrapBStormAlarmStatus:
            ipcmsg_p->msg_size=(sizeof(((SWCTRL_MGR_IPCMsg_T *)0)->data.u32a1_u32a2)
                                            + SWCTRL_MGR_MSGBUF_TYPE_SIZE);
            msg_data_p->type.result_bool= SWCTRL_GetATCBroadcastStormTrapStormAlarmStatus(\
                                            msg_data_p->data.u32a1_u32a2.u32_a1,\
                                            &msg_data_p->data.u32a1_u32a2.u32_a2);
            break;

        case SWCTRL_SetTrapBStormClearStatus:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool= SWCTRL_SetATCBroadcastStormTrapStormClearStatus(\
                                            msg_data_p->data.u32a1_u32a2.u32_a1,\
                                            msg_data_p->data.u32a1_u32a2.u32_a2);
        break;

        case SWCTRL_GetTrapBStormClearStatus:
            ipcmsg_p->msg_size=(sizeof(((SWCTRL_MGR_IPCMsg_T *)0)->data.u32a1_u32a2)
                                            + SWCTRL_MGR_MSGBUF_TYPE_SIZE);
            msg_data_p->type.result_bool= SWCTRL_GetATCBroadcastStormTrapStormClearStatus(\
                                            msg_data_p->data.u32a1_u32a2.u32_a1,\
                                            &msg_data_p->data.u32a1_u32a2.u32_a2);
        break;

        case SWCTRL_SetTrapBStormTCOnStatus:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool= SWCTRL_SetATCBroadcastStormTrapTrafficControlOnStatus(\
                                            msg_data_p->data.u32a1_u32a2.u32_a1,\
                                            msg_data_p->data.u32a1_u32a2.u32_a2);
        break;
        case SWCTRL_GetTrapBStormTCOnStatus:
            ipcmsg_p->msg_size=(sizeof(((SWCTRL_MGR_IPCMsg_T *)0)->data.u32a1_u32a2)
                                            + SWCTRL_MGR_MSGBUF_TYPE_SIZE);
            msg_data_p->type.result_bool= SWCTRL_GetATCBroadcastStormTrapTrafficControlOnStatus(\
                                            msg_data_p->data.u32a1_u32a2.u32_a1,\
                                            &msg_data_p->data.u32a1_u32a2.u32_a2);
        break;

        case SWCTRL_SetTrapBStormTCReleaseStatus:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool= SWCTRL_SetATCBroadcastStormTrapTrafficControlReleaseStatus(\
                                            msg_data_p->data.u32a1_u32a2.u32_a1,\
                                            msg_data_p->data.u32a1_u32a2.u32_a2);
       break;

        case SWCTRL_GetTrapBStormTCReleaseStatus:
            ipcmsg_p->msg_size=(sizeof(((SWCTRL_MGR_IPCMsg_T *)0)->data.u32a1_u32a2)
                                            + SWCTRL_MGR_MSGBUF_TYPE_SIZE);
            msg_data_p->type.result_bool= SWCTRL_GetATCBroadcastStormTrapTrafficControlReleaseStatus(\
                                            msg_data_p->data.u32a1_u32a2.u32_a1,\
                                            &msg_data_p->data.u32a1_u32a2.u32_a2);
        break;

        case SWCTRL_SetBStormSampleType:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool= SWCTRL_SetATCBroadcastStormSampleType(\
                                        msg_data_p->data.u32a1_u32a2.u32_a1,\
                                        msg_data_p->data.u32a1_u32a2.u32_a2);
        break;


        case SWCTRL_GetNextATCBStormEntry:
            ipcmsg_p->msg_size=sizeof(msg_data_p->data.get_atc_bcast_entry)
                +SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool= SWCTRL_GetNextATCBroadcastStormEntry(\
                                            msg_data_p->data.get_atc_bcast_entry.port,\
                                            &(msg_data_p->data.get_atc_bcast_entry.bcast_entry));
            break;



        case SWCTRL_SetTrapMStormAlarmStatus:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool= SWCTRL_SetATCMulticastStormTrapStormAlarmStatus(\
                                            msg_data_p->data.u32a1_u32a2.u32_a1,\
                                            msg_data_p->data.u32a1_u32a2.u32_a2);
        break;

        case SWCTRL_GetTrapMStormAlarmStatus:
            ipcmsg_p->msg_size=(sizeof(((SWCTRL_MGR_IPCMsg_T *)0)->data.u32a1_u32a2)
                                            + SWCTRL_MGR_MSGBUF_TYPE_SIZE);
            msg_data_p->type.result_bool= SWCTRL_GetATCMulticastStormTrapStormAlarmStatus(\
                                            msg_data_p->data.u32a1_u32a2.u32_a1,\
                                            &msg_data_p->data.u32a1_u32a2.u32_a2);
            break;

        case SWCTRL_SetTrapMStormClearStatus:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool= SWCTRL_SetATCMulticastStormTrapStormClearStatus(\
                                            msg_data_p->data.u32a1_u32a2.u32_a1,\
                                            msg_data_p->data.u32a1_u32a2.u32_a2);
        break;

        case SWCTRL_GetTrapMStormClearStatus:
            ipcmsg_p->msg_size=(sizeof(((SWCTRL_MGR_IPCMsg_T *)0)->data.u32a1_u32a2)
                                            + SWCTRL_MGR_MSGBUF_TYPE_SIZE);
            msg_data_p->type.result_bool= SWCTRL_GetATCMulticastStormTrapStormClearStatus(\
                                            msg_data_p->data.u32a1_u32a2.u32_a1,\
                                            &msg_data_p->data.u32a1_u32a2.u32_a2);
                        break;

        case SWCTRL_SetTrapMStormTCOnStatus:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool= SWCTRL_SetATCMulticastStormTrapTrafficControlOnStatus(\
                                            msg_data_p->data.u32a1_u32a2.u32_a1,\
                                            msg_data_p->data.u32a1_u32a2.u32_a2);
            break;

        case SWCTRL_GetTrapMStormTCOnStatus:
            ipcmsg_p->msg_size=(sizeof(((SWCTRL_MGR_IPCMsg_T *)0)->data.u32a1_u32a2)
                                            + SWCTRL_MGR_MSGBUF_TYPE_SIZE);
            msg_data_p->type.result_bool= SWCTRL_GetATCMulticastStormTrapTrafficControlOnStatus(\
                                            msg_data_p->data.u32a1_u32a2.u32_a1,\
                                            &msg_data_p->data.u32a1_u32a2.u32_a2);
            break;

        case SWCTRL_SetTrapMStormTCReleaseStatus:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool= SWCTRL_SetATCMulticastStormTrapTrafficControlReleaseStatus(\
                                            msg_data_p->data.u32a1_u32a2.u32_a1,\
                                            msg_data_p->data.u32a1_u32a2.u32_a2);
           break;

       case SWCTRL_GetTrapMStormTCReleaseStatus:
           ipcmsg_p->msg_size=(sizeof(((SWCTRL_MGR_IPCMsg_T *)0)->data.u32a1_u32a2)
                                        + SWCTRL_MGR_MSGBUF_TYPE_SIZE);
           msg_data_p->type.result_bool= SWCTRL_GetATCMulticastStormTrapTrafficControlReleaseStatus(\
                                    msg_data_p->data.u32a1_u32a2.u32_a1,\
                                    &msg_data_p->data.u32a1_u32a2.u32_a2);
        break;

        case SWCTRL_DisableBStormAfterSetClearThreshold:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool= SWCTRL_DisableBStormAfterClearThreshold(\
                                            msg_data_p->data.ui32_v);
        break;

        case SWCTRL_DisableMStormAfterSetClearThreshold:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool= SWCTRL_DisableMStormAfterClearThreshold(\
                                            msg_data_p->data.ui32_v);
            break;

        case SWCTRL_SetMStormSampleType:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool= SWCTRL_SetATCMulticastStormSampleType(\
                                            msg_data_p->data.u32a1_u32a2.u32_a1,\
                                            msg_data_p->data.u32a1_u32a2.u32_a2);
            break;

        case SWCTRL_GetNextATCMStormEntry:
            ipcmsg_p->msg_size=sizeof(msg_data_p->data.get_atc_mcast_entry)
                +SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool= SWCTRL_GetNextATCMulticastStormEntry(\
                                            msg_data_p->data.get_atc_mcast_entry.port,\
                                            &(msg_data_p->data.get_atc_mcast_entry.mcast_entry));
            break;

#endif


#if(SYS_CPNT_SWCTRL_MDIX_CONFIG == TRUE)
        case SWCTRL_MGR_IPCCMD_SetMDIXMode:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool= SWCTRL_SetMDIXMode(\
                                            msg_data_p->data.u32a1_u32a2.u32_a1,\
                                            msg_data_p->data.u32a1_u32a2.u32_a2);
            break;

        case SWCTRL_MGR_IPCCMD_GetMDIXMode:
            ipcmsg_p->msg_size=(sizeof(((SWCTRL_MGR_IPCMsg_T *)0)->data.u32a1_u32a2)
                                        + SWCTRL_MGR_MSGBUF_TYPE_SIZE);
            msg_data_p->type.result_bool= SWCTRL_GetMDIXMode(\
                                            msg_data_p->data.u32a1_u32a2.u32_a1,\
                                            &msg_data_p->data.u32a1_u32a2.u32_a2);
            break;



#endif

#if (SYS_CPNT_POWER_SAVE == TRUE)
        case SWCTRL_MGR_IPCCMD_SETPORTPOWERSAVE:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool= SWCTRL_SetPortPowerSave(
                                msg_data_p->data.u32a1_boola2.u32_a1,
                                msg_data_p->data.u32a1_boola2.bool_a2);
            break;
        case SWCTRL_MGR_IPCCMD_GETPORTPOWERSAVESTATUS:
            ipcmsg_p->msg_size=(sizeof(((SWCTRL_MGR_IPCMsg_T *)0)->data.u32a1_boola2)
                            + SWCTRL_MGR_MSGBUF_TYPE_SIZE);
            msg_data_p->type.result_bool= SWCTRL_GetPortPowerSaveStatus(
                                msg_data_p->data.u32a1_boola2.u32_a1,
                                &msg_data_p->data.u32a1_boola2.bool_a2);
            break;
        case SWCTRL_MGR_IPCCMD_GETRUNNINGPORTPOWERSAVESTATUS:
            ipcmsg_p->msg_size=(sizeof(((SWCTRL_MGR_IPCMsg_T *)0)->data.u32a1_boola2)
                            + SWCTRL_MGR_MSGBUF_TYPE_SIZE);
            msg_data_p->type.result_bool= SWCTRL_GetRunningPortPowerSaveStatus(
                                msg_data_p->data.u32a1_boola2.u32_a1,
                                &msg_data_p->data.u32a1_boola2.bool_a2);
            break;
#endif /* end of #if (SYS_CPNT_POWER_SAVE == TRUE) */

#if (SYS_CPNT_EFM_OAM == TRUE)
        case SWCTRL_MGR_IPCCMD_SETOAMLOOPBACK:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_SetOamLoopback(
                msg_data_p->data.u32a1_u32a2_u32a3.u32_a1,
                msg_data_p->data.u32a1_u32a2_u32a3.u32_a2,
                msg_data_p->data.u32a1_u32a2_u32a3.u32_a3);
            break;
#endif /* #if (SYS_CPNT_EFM_OAM == TRUE) */

#if (SYS_CPNT_IPV6_MULTICAST_DATA_DROP== TRUE)
        case SWCTRL_MGR_IPCCMD_DROPIPV6MULTICASTDATA:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_DropIpv6MulticastData(
                msg_data_p->data.u32a1_u32a2.u32_a1,
                msg_data_p->data.u32a1_u32a2.u32_a2);
            break;
#endif

#if (SYS_CPNT_ITRI_MIM == TRUE)
        case SWCTRL_MGR_IPCCMD_ITRIMIMSETSTATUS:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_ITRI_MIM_SetStatus(
                msg_data_p->data.u32a1_u32a2.u32_a1,
                msg_data_p->data.u32a1_u32a2.u32_a2);
            break;
#endif

        case SWCTRL_MGR_IPCCMD_ENABLE_DHCP_PACKET_TRAP:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_EnableDhcpPacketTrap(msg_data_p->data.ui32_v);
            break;

        case SWCTRL_MGR_IPCCMD_DISABLE_DHCP_PACKET_TRAP:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_DisableDhcpPacketTrap(msg_data_p->data.ui32_v);
            break;

#if (SYS_CPNT_CLUSTER == TRUE)
        case SWCTRL_MGR_IPCCMD_SETORGSPECIFICTRAPSTATUS:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_SetOrgSpecificTrapStatus(
                msg_data_p->data.u32a1_boola2.u32_a1,
                msg_data_p->data.u32a1_boola2.bool_a2);
            break;
#endif /* #if (SYS_CPNT_CLUSTER == TRUE) */

#if ((SYS_CPNT_DHCPV6 == TRUE)||(SYS_CPNT_DHCPV6SNP == TRUE))
        case SWCTRL_MGR_IPCCMD_ENABLE_DHCP6_PACKET_TRAP:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_EnableDhcp6PacketTrap(
                msg_data_p->data.ui32_v);

            break;

        case SWCTRL_MGR_IPCCMD_DISABLE_DHCP6_PACKET_TRAP:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_DisableDhcp6PacketTrap(
                msg_data_p->data.ui32_v);
            break;
#endif

#if (SYS_CPNT_NDSNP == TRUE)
        case SWCTRL_MGR_IPCCMD_ENABLE_ND_PACKET_TRAP:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_EnableNdPacketTrap(
                msg_data_p->data.ui32_v);
            break;
        case SWCTRL_MGR_IPCCMD_DISABLE_ND_PACKET_TRAP:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_DisableNdPacketTrap(
                msg_data_p->data.ui32_v);
            break;
#endif

#if (SYS_CPNT_PPPOE_IA == TRUE)
        case SWCTRL_MGR_IPCCMD_SETPPPOEDPKTTOCPU:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool = SWCTRL_SetPPPoEDPktToCpu(
                msg_data_p->data.u32a1_boola2.u32_a1,
                msg_data_p->data.u32a1_boola2.bool_a2);
            break;
        case SWCTRL_MGR_IPCCMD_SETPPPOEDPKTTOCPUPERSYSTEM:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool = SWCTRL_SetPPPoEDPktToCpuPerSystem(
                msg_data_p->data.bool_v);
            break;
#endif /* #if (SYS_CPNT_PPPOE_IA == TRUE) */

#if (SYS_CPNT_DOS == TRUE)
        case SWCTRL_MGR_IPCCMD_SETDOSPROTECTIONFILTER:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool = SWCTRL_SetDosProtectionFilter(
                                            msg_data_p->data.u32a1_u32a2.u32_a1,
                                            msg_data_p->data.u32a1_u32a2.u32_a2);
            break;

        case SWCTRL_MGR_IPCCMD_SETDOSPROTECTIONRATELIMIT:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool = SWCTRL_SetDosProtectionRateLimit(
                                            msg_data_p->data.u32a1_u32a2.u32_a1,
                                            msg_data_p->data.u32a1_u32a2.u32_a2);
            break;
#endif

        case SWCTRL_MGR_IPCCMD_SET_PKT_TRAP_STATUS:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool = SWCTRL_SetPktTrapStatus(
                                            msg_data_p->data.pkt_trap.pkt_type,
                                            msg_data_p->data.pkt_trap.owner,
                                            msg_data_p->data.pkt_trap.to_cpu,
                                            msg_data_p->data.pkt_trap.drop);
            break;

        case SWCTRL_MGR_IPCCMD_SET_PORT_PKT_TRAP_STATUS:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool = SWCTRL_SetPortPktTrapStatus(
                                            msg_data_p->data.pkt_trap.ifindex,
                                            msg_data_p->data.pkt_trap.pkt_type,
                                            msg_data_p->data.pkt_trap.owner,
                                            msg_data_p->data.pkt_trap.to_cpu,
                                            msg_data_p->data.pkt_trap.drop);
            break;

#if (SYS_HWCFG_SUPPORT_PD==TRUE)
        case SWCTRL_MGR_IPCCMD_GETPDPORTSTATUS:
            ipcmsg_p->msg_size= sizeof(((SWCTRL_MGR_IPCMsg_T*)0)->data.pd_info) +
                SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool = SWCTRL_GetPDPortStatus(&(msg_data_p->data.pd_info));
            break;
        case SWCTRL_MGR_IPCCMD_GETNEXTPDPORTSTATUS:
            ipcmsg_p->msg_size= sizeof(((SWCTRL_MGR_IPCMsg_T*)0)->data.pd_info) +
                SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool = SWCTRL_GetNextPDPortStatus(&(msg_data_p->data.pd_info));
            break;
#endif
#if ((SYS_HWCFG_SUPPORT_PD==TRUE) && (SYS_CPNT_SWDRV_ONLY_ALLOW_PD_PORT_LINKUP_WITH_PSE_PORT==TRUE))
        case SWCTRL_MGR_IPCCMD_GETPSECHECKSTATUS:
            ipcmsg_p->msg_size=sizeof(((SWCTRL_MGR_IPCMsg_T *)0)->data.bool_v) +
                SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool = SWCTRL_GetPSECheckStatus(&(msg_data_p->data.bool_v));
            break;
        case SWCTRL_MGR_IPCCMD_SETPSECHECKSTATUS:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool = SWCTRL_SetPSECheckStatus(msg_data_p->data.bool_v);
            break;
#endif

        case SWCTRL_MGR_IPCCMD_SETPORTLEARNINGSTATUS:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_SetPortLearningStatus(
                msg_data_p->data.u32a1_u32a2_u32a3.u32_a1,
                msg_data_p->data.u32a1_u32a2_u32a3.u32_a2,
                msg_data_p->data.u32a1_u32a2_u32a3.u32_a3);
            break;

#if (SYS_CPNT_ETS == TRUE)
        case SWCTRL_MGR_IPCCMD_SETPORTCOSGROUPMAPPING:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_SetPortCosGroupMapping(
                msg_data_p->data.cos_group_mapping.ifindex,
                (msg_data_p->data.cos_group_mapping.cosq2group_is_valid ?
                    msg_data_p->data.cos_group_mapping.cosq2group : NULL));
            break;
        case SWCTRL_MGR_IPCCMD_SETPORTCOSGROUPSCHEDULINGMETHOD:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_SetPortCosGroupSchedulingMethod(
                msg_data_p->data.cos_group_scheduling.ifindex,
                msg_data_p->data.cos_group_scheduling.method,
                (msg_data_p->data.cos_group_scheduling.weights_is_valid ?
                    msg_data_p->data.cos_group_scheduling.weights : NULL));
            break;
#endif

#if (SYS_CPNT_CN == TRUE)
        case SWCTRL_MGR_IPCCMD_SETQCNCNMPRIORITY:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_SetQcnCnmPriority(
                msg_data_p->data.ui32_v);
            break;
        case SWCTRL_MGR_IPCCMD_SETPORTQCNCPQ:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_SetPortQcnCpq(
                msg_data_p->data.u32a1_u32a2_u32a3.u32_a1,
                msg_data_p->data.u32a1_u32a2_u32a3.u32_a2,
                msg_data_p->data.u32a1_u32a2_u32a3.u32_a3);
            break;
        case SWCTRL_MGR_IPCCMD_SETPORTQCNEGRCNTAGREMOVAL:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_SetPortQcnEgrCnTagRemoval(
                msg_data_p->data.u32a1_u32a2.u32_a1,
                msg_data_p->data.u32a1_u32a2.u32_a2 & 0xff);
            break;
        case SWCTRL_MGR_IPCCMD_GETPORTQCNCPID:
            ipcmsg_p->msg_size=SWCTRL_MGR_GET_MSG_SIZE(qcn_cpid);
            msg_data_p->type.result_bool=SWCTRL_GetPortQcnCpid(
                msg_data_p->data.u32a1_u32a2.u32_a1,
                msg_data_p->data.u32a1_u32a2.u32_a2,
                msg_data_p->data.qcn_cpid.cpid);
            break;
#endif

#if (SYS_CPNT_MAC_IN_MAC == TRUE)
        case SWCTRL_MGR_IPCCMD_SETMIMSERVICE:
            ipcmsg_p->msg_size=SWCTRL_MGR_GET_MSG_SIZE(ui32_v);
            msg_data_p->type.result_bool=SWCTRL_SetMimService(
                &msg_data_p->data.mim_service.mim,
                msg_data_p->data.mim_service.is_valid);
            if (msg_data_p->type.result_bool)
                msg_data_p->data.ui32_v =
                    msg_data_p->data.mim_service.mim.hw_idx;
            break;

        case SWCTRL_MGR_IPCCMD_SETMIMSERVICEPORT:
            ipcmsg_p->msg_size=SWCTRL_MGR_GET_MSG_SIZE(ui32_v);
            msg_data_p->type.result_bool=SWCTRL_SetMimServicePort(
                &msg_data_p->data.mim_service_port.mim_port,
                msg_data_p->data.mim_service_port.is_valid);
            if (msg_data_p->type.result_bool)
                msg_data_p->data.ui32_v =
                    msg_data_p->data.mim_service_port.mim_port.hw_idx;
            break;

#if (SYS_CPNT_IAAS == TRUE)
        case SWCTRL_MGR_IPCCMD_SETMIMSERVICEPORTLEARNINGSTATUSFORSTATIONMOVE:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_SetMimServicePortLearningStatusForStationMove(
                msg_data_p->data.u32a1_u32a2_u32a3.u32_a1,
                msg_data_p->data.u32a1_u32a2_u32a3.u32_a2,
                msg_data_p->data.u32a1_u32a2_u32a3.u32_a3);
            break;
#endif
#endif

        case SWCTRL_MGR_IPCCMD_SETCPURATELIMIT:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_SetCpuRateLimit(
                msg_data_p->data.u32a1_u32a2.u32_a1,
                msg_data_p->data.u32a1_u32a2.u32_a2);
            break;

#if (SYS_CPNT_SFLOW == TRUE)
        case SWCTRL_MGR_IPCCMD_SET_SFLOW_PORT_SAMPLING_RATE:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool = SWCTRL_SetSflowPortPacketSamplingRate(
                msg_data_p->data.u32a1_u32a2.u32_a1,
                msg_data_p->data.u32a1_u32a2.u32_a2);
            break;
#endif /* #if (SYS_CPNT_SFLOW == TRUE) */

#if (TRUE == SYS_CPNT_APP_FILTER)
        case SWCTRL_MGR_IPCCMD_DROP_PORT_CDP_PACKE:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_DropPortCdpPacket(
                msg_data_p->data.u32a1_boola2.bool_a2,
                msg_data_p->data.u32a1_boola2.u32_a1);
            break;
        case SWCTRL_MGR_IPCCMD_DROP_PORT_PVST_PACKET:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_DropPortPvstPacket(
                msg_data_p->data.u32a1_boola2.bool_a2,
                msg_data_p->data.u32a1_boola2.u32_a1);
            break;
#endif /* #if (TRUE == SYS_CPNT_APP_FILTER) */

#if (SYS_CPNT_VRRP == TRUE)
        case SWCTRL_MGR_IPCCMD_SET_VRRP_TRAP:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool=SWCTRL_TrapVrrpToCpu(msg_data_p->data.bool_v);
            break;
#endif

#if (SYS_CPNT_MAU_MIB == TRUE)

        case SWCTRL_MGR_IPCCMD_GETIFMAUENTRY:
            ipcmsg_p->msg_size=sizeof(msg_data_p->data.if_mau_entry)
                +SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool = SWCTRL_GetIfMauEntry (
                &msg_data_p->data.if_mau_entry);
            break;

        case SWCTRL_MGR_IPCCMD_GETNEXTIFMAUENTRY:
            ipcmsg_p->msg_size=sizeof(msg_data_p->data.if_mau_entry)
                +SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool = SWCTRL_GetNextIfMauEntry (
                &msg_data_p->data.if_mau_entry);
            break;

        case SWCTRL_MGR_IPCCMD_GETIFMAUAUTONEGENTRY:
            ipcmsg_p->msg_size=sizeof(msg_data_p->data.if_mau_auto_neg_entry)
                +SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool = SWCTRL_GetIfMauAutoNegEntry (
                &msg_data_p->data.if_mau_auto_neg_entry);
            break;

        case SWCTRL_MGR_IPCCMD_GETNEXTIFMAUAUTONEGENTRY:
            ipcmsg_p->msg_size=sizeof(msg_data_p->data.if_mau_auto_neg_entry)
                +SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool = SWCTRL_GetNextIfMauAutoNegEntry (
                &msg_data_p->data.if_mau_auto_neg_entry);
            break;

        case SWCTRL_MGR_IPCCMD_GETIFJACKENTRY:
            ipcmsg_p->msg_size=sizeof(msg_data_p->data.if_jack_entry)
                +SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool = SWCTRL_GetIfJackEntry (
                &msg_data_p->data.if_jack_entry);
            break;

        case SWCTRL_MGR_IPCCMD_GETNEXTIFJACKENTRY:
            ipcmsg_p->msg_size=sizeof(msg_data_p->data.if_jack_entry)
                +SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool = SWCTRL_GetNextIfJackEntry (
                &msg_data_p->data.if_jack_entry);
            break;

#endif

        case SWCTRL_MGR_IPCCMD_SETPORTEGRESSBLOCK:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool = SWCTRL_SetPortEgressBlock(
                msg_data_p->data.u32a1_u32a2_u32a3.u32_a1,
                msg_data_p->data.u32a1_u32a2_u32a3.u32_a2,
                msg_data_p->data.u32a1_u32a2_u32a3.u32_a3);
            break;

        case SWCTRL_MGR_IPCCMD_SETPORTEGRESSBLOCKEX:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool = SWCTRL_SetPortEgressBlockEx(
                msg_data_p->data.port_egress_block.lport,
                msg_data_p->data.port_egress_block.egr_lport_list_is_specified ?
                    msg_data_p->data.port_egress_block.egr_lport_list : NULL,
                msg_data_p->data.port_egress_block.blk_lport_list_is_specified ?
                    msg_data_p->data.port_egress_block.blk_lport_list : NULL);
            break;

#if (SYS_CPNT_HASH_SELECTION == TRUE)
        case SWCTRL_MGR_IPCCMD_BINDHASHSELFORSERVICE:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool = SWCTRL_BindHashSelForService(
                msg_data_p->data.bind_hash_service.service,
                msg_data_p->data.bind_hash_service.list_index);
            break;
        case SWCTRL_MGR_IPCCMD_UNBINDHASHSELFORSERVICE:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool = SWCTRL_UnBindHashSelForService(
                msg_data_p->data.bind_hash_service.service,
                msg_data_p->data.bind_hash_service.list_index);
            break;
        case SWCTRL_MGR_IPCCMD_ADDHASHSELECTION:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool = SWCTRL_AddHashSelection(
                msg_data_p->data.set_hash_sel.list_index,
                &msg_data_p->data.set_hash_sel.selection);
            break;
        case SWCTRL_MGR_IPCCMD_REMOVEHASHSELECTION:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool = SWCTRL_RemoveHashSelection(
                msg_data_p->data.set_hash_sel.list_index,
                &msg_data_p->data.set_hash_sel.selection);
            break;
#endif

#if (SYS_CPNT_SWCTRL_SWITCH_MODE_CONFIGURABLE == TRUE)
        case SWCTRL_MGR_IPCCMD_SETSWITCHINGMODE:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool = SWCTRL_SetSwitchingMode(
                msg_data_p->data.u32a1_u32a2.u32_a1, 
                msg_data_p->data.u32a1_u32a2.u32_a2);
        break;
#endif

#if (SYS_CPNT_WRED == TRUE)
       case SWCTRL_MGR_IPCCMD_RANDOM_DETECT:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool= SWCTRL_Random_Detect(
				    msg_data_p->data.random_detect.lport,
                    &msg_data_p->data.random_detect.value);
            break;
#endif

        default:
            ipcmsg_p->msg_size=SWCTRL_MGR_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_ui32=0;
            SWCTRL_DEBUG_LINE();
            SWCTRL_DEBUG_MSG("%s(): Invalid cmd.\n", __FUNCTION__);
            return TRUE;
    }

    exit:

        /*Check sychronism or asychronism ipc. If it is sychronism(need to respond)then we return true.
         */
        SWCTRL_DEBUG_MSG("\r\n%s cmd(%lu)rel(%lu)",__FUNCTION__,cmd,msg_data_p->type.result_ui32);
        if(cmd<SWCTRL_MGR_IPCCMD_FOLLOWISASYNCHRONISMIPC)
        {
            return TRUE;
        }
        else
        {
            return FALSE;
        }

    return TRUE;
}


/*------------------------------------------------------------------------------
 * ROUTINE NAME : SWCTRL_OM_HandleIPCReqMsg
 *------------------------------------------------------------------------------
 * PURPOSE:
 *    Handle the ipc request message for csca om.
 * INPUT:
 *    ipcmsg_p  --  input request ipc message buffer
 *
 * OUTPUT:
 *    ipcmsg_p  --  output response ipc message buffer
 *
 * RETURN:
 *    TRUE  --  There is a response need to send.
 *    FALSE --  No response need to send.
 *
 * NOTES:
 *    1.The size of ipcmsg_p.msg_buf must be large enough to carry any response
 *      messages.
 *------------------------------------------------------------------------------
 */
BOOL_T SWCTRL_OM_HandleIPCReqMsg(SYSFUN_Msg_T* ipcmsg_p)
{
    SWCTRL_OM_IPCMsg_T *msg_data_p;
    UI32_T cmd;

    if(ipcmsg_p==NULL)
    {
        SWCTRL_DEBUG_MSG("\r\n SWCTRL_OM_HandleIPCReqMsg ipcmsg_p==NULL");
        return FALSE;
    }

    msg_data_p= (SWCTRL_OM_IPCMsg_T*)ipcmsg_p->msg_buf;
    cmd = msg_data_p->type.cmd;
    SWCTRL_DEBUG_LINE();
    SWCTRL_DEBUG_MSG("\r\n ipcmsg_p->cmd %lu",cmd);

    /* Every ipc request will fail when operating mode is transition mode
     */
    if (SYSFUN_GET_CSC_OPERATING_MODE() == SYS_TYPE_STACKING_TRANSITION_MODE)
    {
        /*EPR:NULL
        *Problem:When slave enter transition mode,if msg_size have not
        *        any value,will cause sender receive reply overflow.
        *Solution: use a default msg_size to reply the sender.
        *Fixed by:DanXie
        *Modify file:swctrl.c
        *Approved by:Hardsun
        */
        ipcmsg_p->msg_size=SWCTRL_OM_MSGBUF_TYPE_SIZE;
        msg_data_p->type.result_ui32 = FALSE;
        SWCTRL_DEBUG_LINE();
        goto exit;
    }

    switch(cmd)
    {

        case SWCTRL_OM_IPCCMD_ISPORTLINKUP:
            ipcmsg_p->msg_size=SWCTRL_OM_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool = SWCTRL_isPortLinkUp(
                    msg_data_p->data.ui32_v);
            break;

        case SWCTRL_OM_IPCCMD_GETPORTINFO:
            ipcmsg_p->msg_size=sizeof(msg_data_p->data.ifindex_pinfo)
                +SWCTRL_OM_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool = SWCTRL_GetPortInfo(
                msg_data_p->data.ifindex_pinfo.ifindex,
                &msg_data_p->data.ifindex_pinfo.p_info);
            break;

        case SWCTRL_OM_IPCCMD_GETNEXTPORTINFO:
            ipcmsg_p->msg_size=sizeof(msg_data_p->data.ifindex_pinfo)
                +SWCTRL_OM_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool = SWCTRL_GetNextPortInfo(
                &msg_data_p->data.ifindex_pinfo.ifindex,
                &msg_data_p->data.ifindex_pinfo.p_info);
            break;

        case SWCTRL_OM_IPCCMD_GETRUNNINGPORTINFO:
            ipcmsg_p->msg_size=sizeof(msg_data_p->data.ifindex_pinfo)
                +SWCTRL_OM_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_ui32 = SWCTRL_GetRunningPortInfo(
                msg_data_p->data.ifindex_pinfo.ifindex,
                &msg_data_p->data.ifindex_pinfo.p_info);
            break;

        case SWCTRL_OM_IPCCMD_GETPORTLINKSTATUS:
            ipcmsg_p->msg_size=sizeof(msg_data_p->data.u32a1_u32a2)
                +SWCTRL_OM_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool = SWCTRL_GetPortLinkStatus(
                msg_data_p->data.u32a1_u32a2.u32_a1,
                &msg_data_p->data.u32a1_u32a2.u32_a2);
            break;

        case SWCTRL_OM_IPCCMD_GETPORTSTATUS:
            ipcmsg_p->msg_size=sizeof(msg_data_p->data.ui32_v)
                +SWCTRL_OM_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool = SWCTRL_GetPortStatus(
                msg_data_p->data.ui32_v,
                &msg_data_p->data.ui32_v);
            break;

#if (SYS_CPNT_3COM_LOOPBACK_TEST == TRUE)
        case SWCTRL_OM_IPCCMD_GETSWITCHLOOPBACKTESTFAILUREPORTS:
            ipcmsg_p->msg_size=sizeof(msg_data_p->data.failure_ports)
                +SWCTRL_OM_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool = SWCTRL_GetSwitchLoopbackTestFailurePorts(
                msg_data_p->data.failure_ports);
            break;

#endif

        case SWCTRL_OM_IPCCMD_GETUNITPORTNUMBER:
            ipcmsg_p->msg_size=sizeof(msg_data_p->data.ui32_v)
                +SWCTRL_OM_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_ui32 = SWCTRL_GetUnitPortNumber(
                    msg_data_p->data.ui32_v);
            break;

        case SWCTRL_OM_IPCCMD_GETSYSTEMPORTNUMBER:
            ipcmsg_p->msg_size=SWCTRL_OM_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_ui32 = SWCTRL_GetSystemPortNumber();
            break;

        case SWCTRL_OM_IPCCMD_GETCPUMAC:
            ipcmsg_p->msg_size=sizeof(msg_data_p->data.mac)
                +SWCTRL_OM_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool = SWCTRL_GetCpuMac(
                msg_data_p->data.mac);
            break;

        case SWCTRL_OM_IPCCMD_GETPORTMAC:
            ipcmsg_p->msg_size=sizeof(msg_data_p->data.ifindex_mac)
                +SWCTRL_OM_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool = SWCTRL_GetPortMac(
                msg_data_p->data.ifindex_mac.ifindex,
                msg_data_p->data.ifindex_mac.mac);
            break;

        case SWCTRL_OM_IPCCMD_GETLASTCHANGETIME:
            ipcmsg_p->msg_size=SWCTRL_OM_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_ui32 = SWCTRL_GetLastChangeTime();
            break;

        case SWCTRL_OM_IPCCMD_ISSECURITYPORT:
            ipcmsg_p->msg_size=sizeof(msg_data_p->data.u32a1_u32a2)
                +SWCTRL_OM_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool = SWCTRL_IsSecurityPort(
                msg_data_p->data.u32a1_u32a2.u32_a1,
                &msg_data_p->data.u32a1_u32a2.u32_a2);
            break;

#if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION == TRUE)
#if (SYS_DFLT_TRAFFIC_SEG_METHOD == SYS_DFLT_TRAFFIC_SEG_METHOD_PORT_PRIVATE_MODE)
        case SWCTRL_OM_IPCCMD_GETPORTPRIVATEMODE:
            ipcmsg_p->msg_size = sizeof(msg_data_p->data.u32a1_u32a2)
                +SWCTRL_OM_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool = SWCTRL_GetPortPrivateMode(
                msg_data_p->data.u32a1_u32a2.u32_a1,
                &msg_data_p->data.u32a1_u32a2.u32_a2);
            break;

        case SWCTRL_OM_IPCCMD_GETNEXTPORTPRIVATEMODE:
            ipcmsg_p->msg_size = sizeof(msg_data_p->data.u32a1_u32a2)
                +SWCTRL_OM_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool = SWCTRL_GetNextPortPrivateMode(
                &msg_data_p->data.u32a1_u32a2.u32_a1,
                &msg_data_p->data.u32a1_u32a2.u32_a2);
            break;

        case SWCTRL_OM_IPCCMD_GETRUNNINGPORTPRIVATEMODE:
            ipcmsg_p->msg_size = sizeof(msg_data_p->data.u32a1_u32a2)
                +SWCTRL_OM_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_ui32 = SWCTRL_GetRunningPortPrivateMode(
                msg_data_p->data.u32a1_u32a2.u32_a1,
                &msg_data_p->data.u32a1_u32a2.u32_a2);
            break;
#endif /* #if (SYS_DFLT_TRAFFIC_SEG_METHOD == SYS_DFLT_TRAFFIC_SEG_METHOD_PORT_PRIVATE_MODE) */
        case SWCTRL_OM_IPCCMD_GETPRIVATEVLAN:
            ipcmsg_p->msg_size=sizeof(msg_data_p->data.private_vlan)
                +SWCTRL_OM_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool = SWCTRL_GetPrivateVlan(
                &msg_data_p->data.private_vlan);
            break;

        case SWCTRL_OM_IPCCMD_GETPRIVATEVLANSTATUS:
            ipcmsg_p->msg_size=sizeof(msg_data_p->data.ui32_v)
                +SWCTRL_OM_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool = SWCTRL_GetPrivateVlanStatus(
                    &msg_data_p->data.ui32_v);
            break;

        case SWCTRL_OM_IPCCMD_GETRUNNINGPRIVATEVLANSTATUS:
            ipcmsg_p->msg_size=sizeof(msg_data_p->data.ui32_v)
                +SWCTRL_OM_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_ui32 = SWCTRL_GetRunningPrivateVlanStatus(
                    &msg_data_p->data.ui32_v);
            break;

        case SWCTRL_OM_IPCCMD_GETRUNNINGPRIVATEVLANUPLINKPORTLIST:
            ipcmsg_p->msg_size=sizeof(msg_data_p->data.port_list)
                +SWCTRL_OM_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_ui32 = SWCTRL_GetRunningPrivateVlanUplinkPortList(
                msg_data_p->data.port_list);
            break;

        case SWCTRL_OM_IPCCMD_ISPORTPRIVATEVLANUPLINKMEMBER:
            ipcmsg_p->msg_size=SWCTRL_OM_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool = SWCTRL_IsPortPrivateVlanUplinkMember(
                    msg_data_p->data.ui32_v);
            break;

        case SWCTRL_OM_IPCCMD_ISPORTPRIVATEVLANDOWNLINKMEMBER:
            ipcmsg_p->msg_size=SWCTRL_OM_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool = SWCTRL_IsPortPrivateVlanDownlinkMember(
                    msg_data_p->data.ui32_v);
            break;

        case SWCTRL_OM_IPCCMD_GETRUNNINGPRIVATEVLANDOWNLINKPORTLIST:
            ipcmsg_p->msg_size=sizeof(msg_data_p->data.port_list)
                +SWCTRL_OM_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_ui32 = SWCTRL_GetRunningPrivateVlanDownlinkPortList(
                msg_data_p->data.port_list);
            break;
#endif /* #if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION == TRUE) */

#if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION == TRUE)
#if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE == SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE_MULTIPLE_SESSION)

        case SWCTRL_OM_IPCCMD_GETPRIVATEVLANBYSESSIONID:
            ipcmsg_p->msg_size=sizeof(msg_data_p->data.uplinkportlist_downlinkportlist)
                +SWCTRL_OM_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool = SWCTRL_GetPrivateVlanBySessionId(
                msg_data_p->data.uplinkportlist_downlinkportlist.session_id,
                msg_data_p->data.uplinkportlist_downlinkportlist.uplink_port_list,
                msg_data_p->data.uplinkportlist_downlinkportlist.downlink_port_list);
            break;

        case SWCTRL_OM_IPCCMD_GETRUNNINGPRIVATEVLANPORTLISTBYSESSIONID:
            ipcmsg_p->msg_size=sizeof(msg_data_p->data.uplinkportlist_downlinkportlist)
                +SWCTRL_OM_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_ui32 = SWCTRL_GetRunningPrivateVlanPortListBySessionId(
                msg_data_p->data.uplinkportlist_downlinkportlist.session_id,
                msg_data_p->data.uplinkportlist_downlinkportlist.uplink_port_list,
                msg_data_p->data.uplinkportlist_downlinkportlist.downlink_port_list);
            break;

        case SWCTRL_OM_IPCCMD_GETNEXTSESSIONFROMPRIVATEVLANPORTLIST:
            ipcmsg_p->msg_size=sizeof(msg_data_p->data.uplinkportlist_downlinkportlist)
                +SWCTRL_OM_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool = SWCTRL_GetNextSessionFromPrivateVlanPortList(
                &msg_data_p->data.uplinkportlist_downlinkportlist.session_id,
                msg_data_p->data.uplinkportlist_downlinkportlist.uplink_port_list,
                msg_data_p->data.uplinkportlist_downlinkportlist.downlink_port_list);
            break;

        case SWCTRL_OM_IPCCMD_ISUSERPORTJOINPRIVATEVLANTOTRUNK:
            ipcmsg_p->msg_size=SWCTRL_OM_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool = SWCTRL_IsUserPortJoinPrivateVlanToTrunk(
                msg_data_p->data.trunkid_unitport_check_state.trunk_id,
                msg_data_p->data.trunkid_unitport_check_state.unit_port);
            break;

        case SWCTRL_OM_IPCCMD_GETRUNNINGPRIVATEVLANUPLINKTOUPLINKSTATUS:
            ipcmsg_p->msg_size=sizeof(msg_data_p->data.ui32_v)
                +SWCTRL_OM_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_ui32 = SWCTRL_GetRunningPrivateVlanUplinkToUplinkStatus(
                &msg_data_p->data.ui32_v);
            break;

        case SWCTRL_OM_IPCCMD_GETPRIVATEVLANUPLINKTOUPLINKSTATUS:
            ipcmsg_p->msg_size=sizeof(msg_data_p->data.ui32_v)
                +SWCTRL_OM_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool = SWCTRL_GetPrivateVlanUplinkToUplinkStatus(
                &msg_data_p->data.ui32_v);
            break;

#endif /* End of #if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE == SYS_CPNT_PORT_TRAFFIC_SEGMENTATION_MODE_MULTIPLE_SESSION)*/
#endif /* End of #if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION == TRUE) */

#if (SYS_CPNT_INGRESS_RATE_LIMIT == TRUE)

        case SWCTRL_OM_IPCCMD_GETRUNNINGPORTINGRESSRATELIMITSTATUS:
            ipcmsg_p->msg_size=sizeof(msg_data_p->data.u32a1_u32a2)
                +SWCTRL_OM_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_ui32 = SWCTRL_GetRunningPortIngressRateLimitStatus(
                msg_data_p->data.u32a1_u32a2.u32_a1,
                &msg_data_p->data.u32a1_u32a2.u32_a2);
            break;

#endif

#if (SYS_CPNT_EGRESS_RATE_LIMIT == TRUE)

        case SWCTRL_OM_IPCCMD_GETRUNNINGPORTEGRESSRATELIMITSTATUS:
            ipcmsg_p->msg_size=sizeof(msg_data_p->data.u32a1_u32a2)
                +SWCTRL_OM_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_ui32 = SWCTRL_GetRunningPortEgressRateLimitStatus(
                msg_data_p->data.u32a1_u32a2.u32_a1,
                &msg_data_p->data.u32a1_u32a2.u32_a2);
            break;

#endif

#if (SYS_CPNT_JUMBO_FRAMES == TRUE)


        case SWCTRL_OM_IPCCMD_GETJUMBOFRAMESTATUS:
            ipcmsg_p->msg_size=sizeof(msg_data_p->data.ui32_v)
                +SWCTRL_OM_MSGBUF_TYPE_SIZE;
                msg_data_p->type.result_bool = SWCTRL_GetJumboFrameStatus (
                    &msg_data_p->data.ui32_v);
            break;

        case SWCTRL_OM_IPCCMD_GETRUNNINGJUMBOFRAMESTATUS:
            ipcmsg_p->msg_size=sizeof(msg_data_p->data.ui32_v)
                +SWCTRL_OM_MSGBUF_TYPE_SIZE;
                msg_data_p->type.result_ui32 = SWCTRL_GetRunningJumboFrameStatus (
                    &msg_data_p->data.ui32_v);
            break;

#endif

        case SWCTRL_OM_IPCCMD_USERPORTTOLOGICALPORT:
            ipcmsg_p->msg_size=sizeof(msg_data_p->data.unit_port_ifindex)
                +SWCTRL_OM_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_ui32 = SWCTRL_UserPortToLogicalPort(
                msg_data_p->data.unit_port_ifindex.unit,
                msg_data_p->data.unit_port_ifindex.port,
                &msg_data_p->data.unit_port_ifindex.ifindex);
            break;

        case SWCTRL_OM_IPCCMD_USERPORTTOIFINDEX:
            ipcmsg_p->msg_size=sizeof(msg_data_p->data.unit_port_ifindex)
                +SWCTRL_OM_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_ui32 = SWCTRL_UserPortToIfindex(
                msg_data_p->data.unit_port_ifindex.unit,
                msg_data_p->data.unit_port_ifindex.port,
                &msg_data_p->data.unit_port_ifindex.ifindex);
            break;

        case SWCTRL_OM_IPCCMD_USERPORTTOTRUNKPORT:
            ipcmsg_p->msg_size=sizeof(msg_data_p->data.unit_port_trunk)
                +SWCTRL_OM_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_ui32 = SWCTRL_UserPortToTrunkPort(
                msg_data_p->data.unit_port_trunk.unit,
                msg_data_p->data.unit_port_trunk.port,
                &msg_data_p->data.unit_port_trunk.trunk_id);
            break;

        case SWCTRL_OM_IPCCMD_LPORTTOACTIVEUPORT:
            ipcmsg_p->msg_size=sizeof(msg_data_p->data.u32a1_u32a2_uporta3)
                +SWCTRL_OM_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool = SWCTRL_LportToActiveUport(
                msg_data_p->data.u32a1_u32a2_uporta3.u32_a1,
                msg_data_p->data.u32a1_u32a2_uporta3.u32_a2,
                &msg_data_p->data.u32a1_u32a2_uporta3.uport_a3);
            break;
        case SWCTRL_OM_IPCCMD_LOGICALPORTTOUSERPORT:
            ipcmsg_p->msg_size=sizeof(msg_data_p->data.u32a1_u32a2_u32a3_u32a4)
                +SWCTRL_OM_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_ui32 = SWCTRL_LogicalPortToUserPort(
                msg_data_p->data.u32a1_u32a2_u32a3_u32a4.u32_a1,
                &msg_data_p->data.u32a1_u32a2_u32a3_u32a4.u32_a2,
                &msg_data_p->data.u32a1_u32a2_u32a3_u32a4.u32_a3,
                &msg_data_p->data.u32a1_u32a2_u32a3_u32a4.u32_a4);
            break;

        case SWCTRL_OM_IPCCMD_TRUNKIDTOLOGICALPORT:
            ipcmsg_p->msg_size=sizeof(msg_data_p->data.u32a1_u32a2)
                +SWCTRL_OM_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool = SWCTRL_TrunkIDToLogicalPort(
                msg_data_p->data.u32a1_u32a2.u32_a1,
                &msg_data_p->data.u32a1_u32a2.u32_a2);
            break;

        case SWCTRL_OM_IPCCMD_GETNEXTLOGICALPORT:
            ipcmsg_p->msg_size=sizeof(msg_data_p->data.ui32_v)
                +SWCTRL_OM_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_ui32 = SWCTRL_GetNextLogicalPort(
                &msg_data_p->data.ui32_v);
            break;

        case SWCTRL_OM_IPCCMD_LOGICALPORTEXISTING:
            ipcmsg_p->msg_size=SWCTRL_OM_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool = SWCTRL_LogicalPortExisting(
                msg_data_p->data.ui32_v);
            break;

        case SWCTRL_OM_IPCCMD_USERPORTEXISTING:
            ipcmsg_p->msg_size=SWCTRL_OM_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool = SWCTRL_UserPortExisting(
                msg_data_p->data.u32a1_u32a2.u32_a1,
                msg_data_p->data.u32a1_u32a2.u32_a2);
            break;

        case SWCTRL_OM_IPCCMD_LOGICALPORTISTRUNKPORT:
            ipcmsg_p->msg_size=SWCTRL_OM_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool = SWCTRL_LogicalPortIsTrunkPort(
                msg_data_p->data.ui32_v);
            break;

        case SWCTRL_OM_IPCCMD_ISTRUNKMEMBER:
            ipcmsg_p->msg_size=sizeof(msg_data_p->data.uport_trunk_isstatic)
                +SWCTRL_OM_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool = SWCTRL_IsTrunkMember(
                msg_data_p->data.uport_trunk_isstatic.uport_ifindex,
                &msg_data_p->data.uport_trunk_isstatic.trunk_ifindex,
                &msg_data_p->data.uport_trunk_isstatic.is_static);
            break;

        case SWCTRL_OM_IPCCMD_GETTRUNKIFINDEXBYUPORT:
            ipcmsg_p->msg_size=sizeof(msg_data_p->data.u32a1_u32a2)
                +SWCTRL_OM_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool = SWCTRL_GetTrunkIfIndexByUport(
                msg_data_p->data.u32a1_u32a2.u32_a1,
                &msg_data_p->data.u32a1_u32a2.u32_a2);
            break;

#if 0
        case SWCTRL_OM_IPCCMD_GETPORTPRIOQUEUEMODE:
            ipcmsg_p->msg_size=sizeof(msg_data_p->data.u32a1_u32a2)
                +SWCTRL_OM_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool = SWCTRL_GetPortPrioQueueMode(
                msg_data_p->data.u32a1_u32a2.u32_a1,
                &msg_data_p->data.u32a1_u32a2.u32_a2);
            break;

        case SWCTRL_OM_IPCCMD_GETPORTSTRICTQUEUEMAP:
            ipcmsg_p->msg_size=sizeof(msg_data_p->data.lport_queue_map)
                +SWCTRL_OM_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool = SWCTRL_GetPortStrictQueueMap(
                msg_data_p->data.lport_queue_map.lport,
                &msg_data_p->data.lport_queue_map.map);
            break;

        case SWCTRL_OM_IPCCMD_GETNEXTPORTPRIOQUEUEMODE:
            ipcmsg_p->msg_size=sizeof(msg_data_p->data.u32a1_u32a2)
                +SWCTRL_OM_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool = SWCTRL_GetNextPortPrioQueueMode(
                &msg_data_p->data.u32a1_u32a2.u32_a1,
                &msg_data_p->data.u32a1_u32a2.u32_a2);
            break;

        case SWCTRL_OM_IPCCMD_GETRUNNINGPORTPRIOQUEUEMODE:
            ipcmsg_p->msg_size=sizeof(msg_data_p->data.u32a1_u32a2)
                +SWCTRL_OM_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_ui32 = SWCTRL_GetRunningPortPrioQueueMode(
                msg_data_p->data.u32a1_u32a2.u32_a1,
                &msg_data_p->data.u32a1_u32a2.u32_a2);
            break;

        case SWCTRL_OM_IPCCMD_GETNEXTRUNNINGPORTPRIOQUEUEMODE:
            ipcmsg_p->msg_size=sizeof(msg_data_p->data.u32a1_u32a2)
                +SWCTRL_OM_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_ui32 = SWCTRL_GetNextRunningPortPrioQueueMode(
                &msg_data_p->data.u32a1_u32a2.u32_a1,
                &msg_data_p->data.u32a1_u32a2.u32_a2);
            break;

        case SWCTRL_OM_IPCCMD_GETPORTWRRQUEUEWEIGHT:
            ipcmsg_p->msg_size=sizeof(msg_data_p->data.u32a1_u32a2_u32a3)
                +SWCTRL_OM_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool = SWCTRL_GetPortWrrQueueWeight(
                msg_data_p->data.u32a1_u32a2_u32a3.u32_a1,
                msg_data_p->data.u32a1_u32a2_u32a3.u32_a2,
                &msg_data_p->data.u32a1_u32a2_u32a3.u32_a3);
            break;

        case SWCTRL_OM_IPCCMD_GETNEXTPORTWRRQUEUEWEIGHT:
            ipcmsg_p->msg_size=sizeof(msg_data_p->data.u32a1_u32a2_u32a3)
                +SWCTRL_OM_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool = SWCTRL_GetNextPortWrrQueueWeight(
                &msg_data_p->data.u32a1_u32a2_u32a3.u32_a1,
                &msg_data_p->data.u32a1_u32a2_u32a3.u32_a2,
                &msg_data_p->data.u32a1_u32a2_u32a3.u32_a3);
            break;

        case SWCTRL_OM_IPCCMD_GETRUNNINGPORTWRRQUEUEWEIGHT:
            ipcmsg_p->msg_size=sizeof(msg_data_p->data.u32a1_u32a2_u32a3)
                +SWCTRL_OM_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_ui32 = SWCTRL_GetRunningPortWrrQueueWeight(
                msg_data_p->data.u32a1_u32a2_u32a3.u32_a1,
                msg_data_p->data.u32a1_u32a2_u32a3.u32_a2,
                &msg_data_p->data.u32a1_u32a2_u32a3.u32_a3);
            break;

        case SWCTRL_OM_IPCCMD_GETNEXTRUNNINGPORTWRRQUEUEWEIGHT:
            ipcmsg_p->msg_size=sizeof(msg_data_p->data.u32a1_u32a2_u32a3)
                +SWCTRL_OM_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_ui32 = SWCTRL_GetNextRunningPortWrrQueueWeight(
                &msg_data_p->data.u32a1_u32a2_u32a3.u32_a1,
                &msg_data_p->data.u32a1_u32a2_u32a3.u32_a2,
                &msg_data_p->data.u32a1_u32a2_u32a3.u32_a3);
            break;
#endif

        case SWCTRL_OM_IPCCMD_GETPORTENTRY:
            ipcmsg_p->msg_size=sizeof(msg_data_p->data.port_entry)
                +SWCTRL_OM_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool = SWCTRL_GetPortEntry(
                &msg_data_p->data.port_entry);
            break;

        case SWCTRL_OM_IPCCMD_GETNEXTPORTENTRY:
            ipcmsg_p->msg_size=sizeof(msg_data_p->data.port_entry)
                +SWCTRL_OM_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool = SWCTRL_GetNextPortEntry(
                &msg_data_p->data.port_entry);
            break;

        case SWCTRL_OM_IPCCMD_GETMIRRORENTRY:
            ipcmsg_p->msg_size=sizeof(msg_data_p->data.mirror_entry)
                +SWCTRL_OM_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool = SWCTRL_GetMirrorEntry(
                &msg_data_p->data.mirror_entry);
            break;

        case SWCTRL_OM_IPCCMD_GETNEXTMIRRORENTRY:
            ipcmsg_p->msg_size=sizeof(msg_data_p->data.mirror_entry)
                +SWCTRL_OM_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool = SWCTRL_GetNextMirrorEntry(
                &msg_data_p->data.mirror_entry);
            break;

        case SWCTRL_OM_IPCCMD_GETNEXTRUNNINGMIRRORENTRY:
            ipcmsg_p->msg_size=sizeof(msg_data_p->data.mirror_entry)
                +SWCTRL_OM_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_ui32 = SWCTRL_GetNextRunningMirrorEntry(
                &msg_data_p->data.mirror_entry);
            break;

        case SWCTRL_OM_IPCCMD_GETBCASTSTORMENTRY:
            ipcmsg_p->msg_size=sizeof(msg_data_p->data.bcast_storm_entry)
                +SWCTRL_OM_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool = SWCTRL_GetBcastStormEntry(
                &msg_data_p->data.bcast_storm_entry);
            break;

        case SWCTRL_OM_IPCCMD_GETNEXTBCASTSTORMENTRY:
            ipcmsg_p->msg_size=sizeof(msg_data_p->data.bcast_storm_entry)
                +SWCTRL_OM_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool = SWCTRL_GetNextBcastStormEntry(
                &msg_data_p->data.bcast_storm_entry);
            break;

        case SWCTRL_OM_IPCCMD_GETMCASTSTORMENTRY:
            ipcmsg_p->msg_size=sizeof(msg_data_p->data.mcast_storm_entry)
                +SWCTRL_OM_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool = SWCTRL_GetMcastStormEntry(
                &msg_data_p->data.mcast_storm_entry);
            break;

        case SWCTRL_OM_IPCCMD_GETNEXTMCASTSTORMENTRY:
            ipcmsg_p->msg_size=sizeof(msg_data_p->data.mcast_storm_entry)
                +SWCTRL_OM_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool = SWCTRL_GetNextMcastStormEntry(
                &msg_data_p->data.mcast_storm_entry);
            break;

#if (SYS_CPNT_STORM_MODE & SYS_CPNT_STORM_UNKNOWN_USTORM)
        case SWCTRL_OM_IPCCMD_GETUNKUCASTSTORMENTRY:
            ipcmsg_p->msg_size=sizeof(msg_data_p->data.unknown_ucast_storm_entry)
                +SWCTRL_OM_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool = SWCTRL_GetUnkucastStormEntry(
                &msg_data_p->data.unknown_ucast_storm_entry);
            break;

        case SWCTRL_OM_IPCCMD_GETNEXTUNKUCASTSTORMENTRY:
            ipcmsg_p->msg_size=sizeof(msg_data_p->data.unknown_ucast_storm_entry)
                +SWCTRL_OM_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool = SWCTRL_GetNextUnkucastStormEntry(
                &msg_data_p->data.unknown_ucast_storm_entry);
            break;
#endif
        case SWCTRL_OM_IPCCMD_GETPORTSTORMGRANULARITY:
            ipcmsg_p->msg_size=sizeof(msg_data_p->data.u32a1_u32a2)
                +SWCTRL_OM_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool = SWCTRL_GetPortStormGranularity(
                msg_data_p->data.u32a1_u32a2.u32_a1,
                &msg_data_p->data.u32a1_u32a2.u32_a2);
            break;

        case SWCTRL_OM_IPCCMD_UIGETUNITPORTNUMBER:
            ipcmsg_p->msg_size=SWCTRL_OM_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_ui32 = SWCTRL_UIGetUnitPortNumber(
                msg_data_p->data.ui32_v);
            break;

        case SWCTRL_OM_IPCCMD_UIUSERPORTTOLOGICALPORT:
            ipcmsg_p->msg_size=sizeof(msg_data_p->data.u32a1_u32a2_u32a3)
                +SWCTRL_OM_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_ui32 = SWCTRL_UIUserPortToLogicalPort(
                msg_data_p->data.u32a1_u32a2_u32a3.u32_a1,
                msg_data_p->data.u32a1_u32a2_u32a3.u32_a2,
                &msg_data_p->data.u32a1_u32a2_u32a3.u32_a3);
            break;

        case SWCTRL_OM_IPCCMD_UIUSERPORTTOIFINDEX:
            ipcmsg_p->msg_size=sizeof(msg_data_p->data.unit_port_ifindex_inherit)
                +SWCTRL_OM_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_ui32 = SWCTRL_UIUserPortToIfindex (
                msg_data_p->data.unit_port_ifindex_inherit.unit,
                msg_data_p->data.unit_port_ifindex_inherit.port,
                &msg_data_p->data.unit_port_ifindex_inherit.ifindex,
                &msg_data_p->data.unit_port_ifindex_inherit.is_inherit);
            break;

        case SWCTRL_OM_IPCCMD_UIUSERPORTTOTRUNKPORT:
            ipcmsg_p->msg_size=sizeof(msg_data_p->data.u32a1_u32a2_u32a3)
                +SWCTRL_OM_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_ui32 = SWCTRL_UIUserPortToTrunkPort(
                msg_data_p->data.u32a1_u32a2_u32a3.u32_a1,
                msg_data_p->data.u32a1_u32a2_u32a3.u32_a2,
                &msg_data_p->data.u32a1_u32a2_u32a3.u32_a3);
            break;

        case SWCTRL_OM_IPCCMD_UIUSERPORTEXISTING:
            ipcmsg_p->msg_size=SWCTRL_OM_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool = SWCTRL_UIUserPortExisting (
                msg_data_p->data.u32a1_u32a2.u32_a1,
                msg_data_p->data.u32a1_u32a2.u32_a2);
            break;

#if (SYS_CPNT_SFP_DDM_ALARMWARN_TRAP == TRUE)
        case SWCTRL_OM_IPCCMD_GETRUNNINGPORTSFPDDMTHRESHOLDENTRY:
            ipcmsg_p->msg_size=sizeof(msg_data_p->data.lport_sfp_ddm_threshold_entry)
                +SWCTRL_OM_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_ui32 = SWCTRL_GetRunningPortSfpDdmThresholdEntry(
                msg_data_p->data.lport_sfp_ddm_threshold_entry.lport,
                &msg_data_p->data.lport_sfp_ddm_threshold_entry.sfp_ddm_threshold_entry);
            break;
#endif

#if (SYS_CPNT_COMBO_PORT_FORCE_MODE == TRUE)
        case SWCTRL_OM_IPCCMD_GETSUPPORTEDPORTCOMBOFORCEDMODE:
            ipcmsg_p->msg_size=SWCTRL_OM_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_ui32 = SWCTRL_GetSupportedPortComboForcedMode(
                msg_data_p->data.ui32_v);
            break;

        case SWCTRL_OM_IPCCMD_GETDEFAULTPORTCOMBOFORCEDMODE:
            ipcmsg_p->msg_size=sizeof(msg_data_p->data.ui32_v)
                +SWCTRL_OM_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool = SWCTRL_GetDefaultPortComboForcedMode(
                msg_data_p->data.ui32_v,
                &msg_data_p->data.ui32_v);
            break;

#if (SYS_CPNT_COMBO_PORT_FORCED_MODE_SFP_SPEED == TRUE)
        case SWCTRL_OM_IPCCMD_GETDEFAULTPORTCOMBOFORCEDMODESFPSPEED:
            ipcmsg_p->msg_size=sizeof(msg_data_p->data.ui32_v)
                +SWCTRL_OM_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool = SWCTRL_GetDefaultPortComboForcedModeSfpSpeed(
                msg_data_p->data.ui32_v,
                &msg_data_p->data.ui32_v);
            break;
#endif

        case SWCTRL_OM_IPCCMD_GETPORTCOMBOFORCEDMODE:
            ipcmsg_p->msg_size=sizeof(msg_data_p->data.u32a1_u32a2)
                +SWCTRL_OM_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool = SWCTRL_GetPortComboForcedMode(
                msg_data_p->data.u32a1_u32a2.u32_a1,
                &msg_data_p->data.u32a1_u32a2.u32_a2);
            break;

        case SWCTRL_OM_IPCCMD_GETRUNNINGPORTCOMBOFORCEDMODE:
            ipcmsg_p->msg_size=sizeof(msg_data_p->data.u32a1_u32a2)
                +SWCTRL_OM_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_ui32 = SWCTRL_GetRunningPortComboForcedMode(
                msg_data_p->data.u32a1_u32a2.u32_a1,
                &msg_data_p->data.u32a1_u32a2.u32_a2);
            break;
#if (SYS_CPNT_COMBO_PORT_FORCED_MODE_SFP_SPEED == TRUE)
        case SWCTRL_OM_IPCCMD_GETPORTCOMBOFORCEDMODESPEED:
            ipcmsg_p->msg_size=sizeof(msg_data_p->data.u32a1_u32a2)
                +SWCTRL_OM_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool = SWCTRL_GetPortComboForcedModeSpeed(
                msg_data_p->data.u32a1_u32a2.u32_a1,
                &msg_data_p->data.u32a1_u32a2.u32_a2);
            break;

        case SWCTRL_OM_IPCCMD_GETRUNNINGPORTCOMBOFORCEDMODESPEED:
            ipcmsg_p->msg_size=sizeof(msg_data_p->data.u32a1_u32a2)
                +SWCTRL_OM_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_ui32 = SWCTRL_GetRunningPortComboForcedModeSpeed(
                msg_data_p->data.u32a1_u32a2.u32_a1,
                &msg_data_p->data.u32a1_u32a2.u32_a2);
            break;

#endif
#endif

#if (SYS_CPNT_SWCTRL_CABLE_DIAG == TRUE)

        case SWCTRL_OM_IPCCMD_GETCABLEDIAG:
            ipcmsg_p->msg_size=sizeof(msg_data_p->data.cable_diag_info)
                +SWCTRL_OM_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool = SWCTRL_GetCableDiagResult(
                msg_data_p->data.cable_diag_info.lport,
                &msg_data_p->data.cable_diag_info.result);
            break;

        case SWCTRL_OM_IPCCMD_GETNEXTCABLEDIAG:
            ipcmsg_p->msg_size=sizeof(msg_data_p->data.cable_diag_info)
                +SWCTRL_OM_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool = SWCTRL_GetNextCableDiagResult(
                &msg_data_p->data.cable_diag_info.lport,
                &msg_data_p->data.cable_diag_info.result);
            break;

#endif    /* #if (SYS_CPNT_SWCTRL_CABLE_DIAG == TRUE) */

        case SWCTRL_OM_IPCCMD_GETPORTMAXFRAMESIZE:
            ipcmsg_p->msg_size=sizeof(msg_data_p->data.u32a1_u32a2)
                +SWCTRL_OM_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool = SWCTRL_GetPortMaxFrameSize(
                msg_data_p->data.ui32_v,
                &msg_data_p->data.u32a1_u32a2.u32_a1,
                &msg_data_p->data.u32a1_u32a2.u32_a2);
            break;

#if (SYS_CPNT_MAC_BASED_MIRROR == TRUE)
        case SWCTRL_OM_IPCCMD_GETEXACTMACADDRMIRRORENTRY:
        {
            UI8_T mac[SYS_ADPT_MAC_ADDR_LEN];

            /* set input arguments
             */
            memcpy(mac, msg_data_p->data.mac, sizeof(mac));
            memcpy(&(msg_data_p->data.mac_addr_mirror_entry.mac_addr), mac, sizeof(mac));

            /* set response message size
             */
            ipcmsg_p->msg_size=sizeof(((SWCTRL_OM_IPCMsg_T *)0)->data.mac_addr_mirror_entry)
                +SWCTRL_OM_MSGBUF_TYPE_SIZE;

            /* call target api
             */
            msg_data_p->type.result_bool = SWCTRL_OM_GetExactMacAddrMirrorEntry(
                &(msg_data_p->data.mac_addr_mirror_entry)
                );
        }
            break;
        case SWCTRL_OM_IPCCMD_GETNEXTMACADDRMIRRORENTRY:
        {
            UI32_T addr_entry_index;

            /* set input arguments
             */
            addr_entry_index=msg_data_p->data.ui32_v;
            msg_data_p->data.mac_addr_mirror_entry.addr_entry_index=addr_entry_index;

            /* set response message size
             */
            ipcmsg_p->msg_size=sizeof(((SWCTRL_OM_IPCMsg_T *)0)->data.mac_addr_mirror_entry)
                +SWCTRL_OM_MSGBUF_TYPE_SIZE;

            /* call target api
             */
            msg_data_p->type.result_bool = SWCTRL_OM_GetNextMacAddrMirrorEntry(
                &(msg_data_p->data.mac_addr_mirror_entry)
                );
        }

            break;

        case SWCTRL_OM_IPCCMD_GETNEXTMACADDRMIRRORENTRYFORSNMP:
        {
            UI8_T  mac[SYS_ADPT_MAC_ADDR_LEN];

            /* set input arguments
             */
            memcpy(mac, msg_data_p->data.mac, sizeof(mac));
            memcpy(msg_data_p->data.ifindex_mac.mac, mac, sizeof(mac));


            /* set response message size
             */
            ipcmsg_p->msg_size=sizeof(((SWCTRL_OM_IPCMsg_T *)0)->data.ifindex_mac)
                +SWCTRL_OM_MSGBUF_TYPE_SIZE;

            /* call target api
             */
            msg_data_p->type.result_bool = SWCTRL_OM_GetNextMacAddrMirrorEntryForSnmp(
                msg_data_p->data.ifindex_mac.mac, &msg_data_p->data.ifindex_mac.ifindex);
        }

            break;

        case SWCTRL_OM_IPCCMD_ISEXISTEDMACADDRMIRRORENTRY:
        {
            /* set input arguments
             */


            /* set response message size
             */
            ipcmsg_p->msg_size=sizeof(((SWCTRL_OM_IPCMsg_T *)0)->data.ifindex_mac)
                +SWCTRL_OM_MSGBUF_TYPE_SIZE;

            /* call target api
             */
            msg_data_p->type.result_bool = SWCTRL_OM_IsExistedMacAddrMirrorEntry(
                msg_data_p->data.ifindex_mac.mac, msg_data_p->data.ifindex_mac.ifindex);
        }

            break;
#endif

#if (SYS_CPNT_RATE_BASED_STORM_CONTROL == TRUE)
        case SWCTRL_OM_IPCCMD_GETRATEBASEDSTORMCONTROL:
            ipcmsg_p->msg_size=sizeof(msg_data_p->data.u32a1_u32a2_u32a3)
                +SWCTRL_OM_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool = SWCTRL_GetRateBasedStormControl(
                msg_data_p->data.u32a1_u32a2_u32a3.u32_a1,
                &msg_data_p->data.u32a1_u32a2_u32a3.u32_a2,
                &msg_data_p->data.u32a1_u32a2_u32a3.u32_a3);
            break;
        case SWCTRL_OM_IPCCMD_GETNEXTRATEBASEDSTORMCONTROL:
            ipcmsg_p->msg_size=sizeof(msg_data_p->data.u32a1_u32a2_u32a3)
                +SWCTRL_OM_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool = SWCTRL_GetNextRateBasedStormControl(
                &msg_data_p->data.u32a1_u32a2_u32a3.u32_a1,
                &msg_data_p->data.u32a1_u32a2_u32a3.u32_a2,
                &msg_data_p->data.u32a1_u32a2_u32a3.u32_a3);
            break;
        case SWCTRL_OM_IPCCMD_GETRUNNINGRATEBASEDSTORMCONTROLRATE:
            ipcmsg_p->msg_size=sizeof(msg_data_p->data.u32a1_u32a2)
                +SWCTRL_OM_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_ui32 = SWCTRL_GetRunningRateBasedStormControlRate(
                msg_data_p->data.u32a1_u32a2_u32a3.u32_a1,
                &msg_data_p->data.u32a1_u32a2_u32a3.u32_a2);
            break;
        case SWCTRL_OM_IPCCMD_GETRUNNINGRATEBASEDSTORMCONTROLMODE:
            ipcmsg_p->msg_size=sizeof(msg_data_p->data.u32a1_u32a2)
                +SWCTRL_OM_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_ui32 = SWCTRL_GetRunningRateBasedStormControlMode(
                msg_data_p->data.u32a1_u32a2_u32a3.u32_a1,
                &msg_data_p->data.u32a1_u32a2_u32a3.u32_a2);
            break;
#endif
#if (SYS_CPNT_INTERNAL_LOOPBACK_TEST == TRUE)
        case SWCTRL_OM_IPCCMD_GETINTERNALLOOPBACKTESTRESULT:
            ipcmsg_p->msg_size=sizeof(msg_data_p->data.u32a1_u32a2_u32a3)
                +SWCTRL_OM_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool = SWCTRL_GetInternalLoopbackTestResult(
                                                msg_data_p->data.u32a1_u32a2_u32a3.u32_a1,
                                                &msg_data_p->data.u32a1_u32a2_u32a3.u32_a2,
                                                &msg_data_p->data.u32a1_u32a2_u32a3.u32_a3);
            break;
        case SWCTRL_OM_IPCCMD_GETNEXTINTERNALLOOPBACKTESTRESULT:
            ipcmsg_p->msg_size=sizeof(msg_data_p->data.u32a1_u32a2_u32a3)
                +SWCTRL_OM_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool = SWCTRL_GetNextInternalLoopbackTestResult(
                                                &msg_data_p->data.u32a1_u32a2_u32a3.u32_a1,
                                                &msg_data_p->data.u32a1_u32a2_u32a3.u32_a2,
                                                &msg_data_p->data.u32a1_u32a2_u32a3.u32_a3);
            break;
#endif

#if (SYS_CPNT_MAC_BASED_MIRROR == TRUE) || (SYS_CPNT_VLAN_MIRROR == TRUE) || (SYS_CPNT_ACL_MIRROR == TRUE)
        case SWCTRL_OM_IPCCMD_GETVLANANDMACMIRRORDESTPORT:
            ipcmsg_p->msg_size=(sizeof(((SWCTRL_OM_IPCMsg_T *)0)->data.ui32_v)
                + SWCTRL_OM_MSGBUF_TYPE_SIZE);
            SWCTRL_OM_GetCommonMirrorDestPort(&(msg_data_p->data.ui32_v));
            break;
#endif

#if (SYS_CPNT_ITRI_MIM == TRUE)
        case SWCTRL_OM_IPCCMD_ITRIMIMGETSTATUS:
            {
                BOOL_T status;
                ipcmsg_p->msg_size=sizeof(msg_data_p->data.ui32_v)
                    +SWCTRL_OM_MSGBUF_TYPE_SIZE;
                msg_data_p->type.result_bool = SWCTRL_ITRI_MIM_GetStatus(
                    msg_data_p->data.ui32_v,
                    &status);
                msg_data_p->data.ui32_v = status;
            }
            break;

        case SWCTRL_OM_IPCCMD_ITRIMIMGETNEXTSTATUS:
            {
                BOOL_T status;
                ipcmsg_p->msg_size=sizeof(msg_data_p->data.u32a1_u32a2)
                    +SWCTRL_OM_MSGBUF_TYPE_SIZE;
                msg_data_p->type.result_bool = SWCTRL_ITRI_MIM_GetNextStatus(
                    &msg_data_p->data.u32a1_u32a2.u32_a1,
                    &status);
                msg_data_p->data.u32a1_u32a2.u32_a2 = status;
            }
            break;

        case SWCTRL_OM_IPCCMD_ITRIMIMGETRUNNINGSTATUS:
            {
                BOOL_T status;
                ipcmsg_p->msg_size=sizeof(msg_data_p->data.ui32_v)
                    +SWCTRL_OM_MSGBUF_TYPE_SIZE;
                msg_data_p->type.result_ui32 = SWCTRL_ITRI_MIM_GetRunningStatus(
                    msg_data_p->data.ui32_v,
                    &status);
                msg_data_p->data.ui32_v = status;
            }
            break;
#endif

        case SWCTRL_OM_IPCCMD_GETTRUNKBALANCEMODE:
            ipcmsg_p->msg_size=sizeof(msg_data_p->data.ui32_v)
                +SWCTRL_OM_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool = SWCTRL_GetTrunkBalanceMode(
                &msg_data_p->data.ui32_v);
            break;
        case SWCTRL_OM_IPCCMD_GETRUNNINGTRUNKBALANCEMODE:
            ipcmsg_p->msg_size=sizeof(msg_data_p->data.ui32_v)
                +SWCTRL_OM_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_ui32 = SWCTRL_GetRunningTrunkBalanceMode(
                &msg_data_p->data.ui32_v);
            break;
        case SWCTRL_OM_IPCCMD_GETTRUNKMAXNUMOFACTIVEPORTS:
            ipcmsg_p->msg_size=sizeof(msg_data_p->data.ui32_v)
                +SWCTRL_OM_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool = SWCTRL_GetTrunkMaxNumOfActivePorts(
                msg_data_p->data.ui32_v,
                &msg_data_p->data.ui32_v);
            break;
        case SWCTRL_OM_IPCCMD_GETRUNNINGTRUNKMAXNUMOFACTIVEPORTS:
            ipcmsg_p->msg_size=sizeof(msg_data_p->data.ui32_v)
                +SWCTRL_OM_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_ui32 = SWCTRL_GetRunningTrunkMaxNumOfActivePorts(
                msg_data_p->data.ui32_v,
                &msg_data_p->data.ui32_v);
            break;

        case SWCTRL_OM_IPCCMD_GET_ACTIVE_TRUNK_MEMBER:
            ipcmsg_p->msg_size=sizeof(msg_data_p->data.active_trunk_member)
                +SWCTRL_OM_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool = SWCTRL_GetActiveTrunkMember(
                msg_data_p->data.active_trunk_member.ifindex,
                msg_data_p->data.active_trunk_member.active_lportarray,
                &(msg_data_p->data.active_trunk_member.active_lport_count));
            break;

        case SWCTRL_OM_IPCCMD_GETPORTLEARNINGSTATUSEX:
            ipcmsg_p->msg_size=sizeof(msg_data_p->data.u32a1_u32a2)
                +SWCTRL_OM_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool = SWCTRL_GetPortLearningStatusEx(
                msg_data_p->data.ui32_v,
                &msg_data_p->data.u32a1_u32a2.u32_a1,
                &msg_data_p->data.u32a1_u32a2.u32_a2);
            break;

#if (SYS_CPNT_PFC == TRUE)
        case SWCTRL_OM_IPCCMD_ISPORTFLOWCONTROLENABLED:
            ipcmsg_p->msg_size=SWCTRL_OM_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool = SWCTRL_isPortFlowControlEnabled(
                msg_data_p->data.ui32_v);
            break;
#endif

        case SWCTRL_OM_IPCCMD_GETCPURATELIMIT:
            ipcmsg_p->msg_size=sizeof(msg_data_p->data.ui32_v)
                +SWCTRL_OM_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool = SWCTRL_GetCpuRateLimit(
                msg_data_p->data.ui32_v,
                &msg_data_p->data.ui32_v);
            break;

        case SWCTRL_OM_IPCCMD_GETPORTABILITY:
            ipcmsg_p->msg_size=sizeof(msg_data_p->data.port_ability)
                +SWCTRL_OM_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool = SWCTRL_GetPortAbility(
                msg_data_p->data.ui32_v,
                &msg_data_p->data.port_ability);
            break;

#if (SYS_CPNT_SWCTRL_GLOBAL_STORM_SAMPLE_TYPE == TRUE)
        case SWCTRL_OM_IPCCMD_GETRUNNINGGLOBALSTORMSAMPLETYPE:
            ipcmsg_p->msg_size=sizeof(msg_data_p->data.ui32_v)
                +SWCTRL_OM_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_ui32=SWCTRL_GetRunningGlobalStormSampleType(
                &msg_data_p->data.ui32_v);
            break;
#endif
#if (SYS_CPNT_SWDRV_MONITOR_SFP_DDM == TRUE)
        case SWCTRL_OM_IPCCMD_GETPORTSFPPRESENT:
            ipcmsg_p->msg_size=sizeof(msg_data_p->data.u32a1_u32a2_bl)
                +SWCTRL_OM_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool = SWCTRL_GetPortSfpPresent(
                msg_data_p->data.u32a1_u32a2_bl.u32_a1,
                msg_data_p->data.u32a1_u32a2_bl.u32_a2,
                &msg_data_p->data.u32a1_u32a2_bl.bl);
            break;

        case SWCTRL_OM_IPCCMD_GETPORTSFPINFO:
            ipcmsg_p->msg_size=sizeof(msg_data_p->data.unit_index_sfp_info)
                +SWCTRL_OM_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool = SWCTRL_GetPortSfpInfo(
                msg_data_p->data.unit_index_sfp_info.unit,
                msg_data_p->data.unit_index_sfp_info.sfp_index,
                &msg_data_p->data.unit_index_sfp_info.sfp_info);
            break;

        case SWCTRL_OM_IPCCMD_GETPORTSFPDDMINFO:
            ipcmsg_p->msg_size=sizeof(msg_data_p->data.unit_index_sfp_ddm_info)
                +SWCTRL_OM_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool = SWCTRL_GetPortSfpDdmInfo(
                msg_data_p->data.unit_index_sfp_ddm_info.unit,
                msg_data_p->data.unit_index_sfp_ddm_info.sfp_index,
                &msg_data_p->data.unit_index_sfp_ddm_info.sfp_ddm_info);
            break;

        case SWCTRL_OM_IPCCMD_GETPORTSFPDDMINFOMEASURED:
            ipcmsg_p->msg_size=sizeof(msg_data_p->data.unit_index_sfp_ddm_info_measured)
                +SWCTRL_OM_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool = SWCTRL_GetPortSfpDdmInfoMeasured(
                msg_data_p->data.unit_index_sfp_ddm_info_measured.unit,
                msg_data_p->data.unit_index_sfp_ddm_info_measured.sfp_index,
                &msg_data_p->data.unit_index_sfp_ddm_info_measured.sfp_ddm_info_measured);
            break;

        case SWCTRL_OM_IPCCMD_GETPORTSFPENTRY:
            ipcmsg_p->msg_size=sizeof(msg_data_p->data.lport_sfp_entry)
                +SWCTRL_OM_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool = SWCTRL_GetPortSfpEntry(
                msg_data_p->data.lport_sfp_entry.lport,
                &msg_data_p->data.lport_sfp_entry.sfp_entry);
            break;

        case SWCTRL_OM_IPCCMD_GETNEXTPORTSFPENTRY:
            ipcmsg_p->msg_size=sizeof(msg_data_p->data.lport_sfp_entry)
                +SWCTRL_OM_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool = SWCTRL_GetNextPortSfpEntry(
                &msg_data_p->data.lport_sfp_entry.lport,
                &msg_data_p->data.lport_sfp_entry.sfp_entry);
            break;

        case SWCTRL_OM_IPCCMD_GETPORTSFPDDMENTRY:
            ipcmsg_p->msg_size=sizeof(msg_data_p->data.lport_sfp_ddm_entry)
                +SWCTRL_OM_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool = SWCTRL_GetPortSfpDdmEntry(
                msg_data_p->data.lport_sfp_ddm_entry.lport,
                &msg_data_p->data.lport_sfp_ddm_entry.sfp_ddm_entry);
            break;

        case SWCTRL_OM_IPCCMD_GETNEXTPORTSFPDDMENTRY:
            ipcmsg_p->msg_size=sizeof(msg_data_p->data.lport_sfp_ddm_entry)
                +SWCTRL_OM_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool = SWCTRL_GetNextPortSfpDdmEntry(
                &msg_data_p->data.lport_sfp_ddm_entry.lport,
                &msg_data_p->data.lport_sfp_ddm_entry.sfp_ddm_entry);
            break;
#endif /* #if (SYS_CPNT_SWDRV_MONITOR_SFP_DDM == TRUE) */

#if (SYS_CPNT_SFP_DDM_ALARMWARN_TRAP == TRUE)
        case SWCTRL_OM_IPCCMD_GETPORTSFPDDMTHRESHOLD:
            ipcmsg_p->msg_size=sizeof(msg_data_p->data.lport_sfp_ddm_threshold)
                +SWCTRL_OM_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool = SWCTRL_GetPortSfpDdmThreshold(
                msg_data_p->data.lport_sfp_ddm_threshold.lport,
                &msg_data_p->data.lport_sfp_ddm_threshold.sfp_ddm_threshold);
            break;

        case SWCTRL_OM_IPCCMD_GETPORTSFPDDMTHRESHOLDENTRY:
            ipcmsg_p->msg_size=sizeof(msg_data_p->data.lport_sfp_ddm_threshold_entry)
                +SWCTRL_OM_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool = SWCTRL_GetPortSfpDdmThresholdEntry(
                msg_data_p->data.lport_sfp_ddm_threshold_entry.lport,
                &msg_data_p->data.lport_sfp_ddm_threshold_entry.sfp_ddm_threshold_entry);
            break;

       case SWCTRL_OM_IPCCMD_GETNEXTPORTSFPDDMTHRESHOLDENTRY:
            ipcmsg_p->msg_size=sizeof(msg_data_p->data.lport_sfp_ddm_threshold_entry)
                +SWCTRL_OM_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool = SWCTRL_GetNextPortSfpDdmThresholdEntry(
                &msg_data_p->data.lport_sfp_ddm_threshold_entry.lport,
                &msg_data_p->data.lport_sfp_ddm_threshold_entry.sfp_ddm_threshold_entry);
            break;

        case SWCTRL_OM_IPCCMD_GETPORTSFPDDMTHRESHOLDAUTOMODE:
            ipcmsg_p->msg_size=sizeof(msg_data_p->data.u32a1_boola2)
                +SWCTRL_OM_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool = SWCTRL_GetPortSfpDdmThresholdAutoMode(
                msg_data_p->data.u32a1_boola2.u32_a1,
                &msg_data_p->data.u32a1_boola2.bool_a2);
            break;

        case SWCTRL_OM_IPCCMD_GETPORTSFPDDMTRAPENABLE:
            ipcmsg_p->msg_size=sizeof(msg_data_p->data.u32a1_boola2)
                +SWCTRL_OM_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool = SWCTRL_GetPortSfpDdmTrapEnable(
                msg_data_p->data.u32a1_boola2.u32_a1,
                &msg_data_p->data.u32a1_boola2.bool_a2);
            break;

        case SWCTRL_OM_IPCCMD_GETPORTSFPDDMTHRESHOLDSTATUS:
            ipcmsg_p->msg_size=sizeof(msg_data_p->data.lport_sfp_ddm_threshold_status)
                +SWCTRL_OM_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool = SWCTRL_GetPortSfpDdmThresholdStatus(
                msg_data_p->data.lport_sfp_ddm_threshold_status.lport,
                &msg_data_p->data.lport_sfp_ddm_threshold_status.sfp_ddm_threshold_status);
            break;
#endif /* #if (SYS_CPNT_SFP_DDM_ALARMWARN_TRAP == TRUE) */

#if (SYS_CPNT_HASH_SELECTION == TRUE)
        case SWCTRL_OM_IPCCMD_GETHASHSELECTIONBLOCKINFO:
            ipcmsg_p->msg_size=sizeof(msg_data_p->data.hash_sel_block)
                +SWCTRL_OM_MSGBUF_TYPE_SIZE;
            msg_data_p->type.result_bool = SWCTRL_GetHashBlockInfo(
                msg_data_p->data.hash_sel_block.list_index,
                &msg_data_p->data.hash_sel_block.block_info);
            break;
#endif

#if(SYS_CPNT_WRED == TRUE)
       case SWCTRL_OM_IPCCMD_RANDOMDETECT:
           ipcmsg_p->msg_size=sizeof(msg_data_p->data.random_detect)
                +SWCTRL_OM_MSGBUF_TYPE_SIZE;
           msg_data_p->type.result_bool = SWCTRL_OM_GetRandomDetect(
               msg_data_p->data.random_detect.lport,
               &msg_data_p->data.random_detect.value);
	   	break;
#endif
        default:
            msg_data_p->type.result_ui32=0;
            SWCTRL_DEBUG_MSG("%s(): Invalid cmd.\n", __FUNCTION__);
            return TRUE;

    }
exit:
    /*Check sychronism or asychronism ipc. If it is sychronism(need to respond)then we return true.
     */
    SWCTRL_DEBUG_MSG("\r\n%s cmd(%lu)rel(%lu)",__FUNCTION__,cmd,msg_data_p->type.result_ui32);
    if(cmd<SWCTRL_OM_IPCCMD_FOLLOWISASYNCHRONISMIPC)
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

#if 0 /*Timon*/
SWCTRL_DEBUG_ALLPORTMSG(UI32_T unit)
{
    UI32_T debug_ifindex;
    for(debug_ifindex =  SYS_ADPT_ETHER_1_IF_INDEX_NUMBER;
        debug_ifindex <= unit*SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT;
        debug_ifindex ++)
    {
        printf("\r\n%lu %s %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %hu %hu %lu",
            port_info[debug_ifindex-1].port_entry.port_index,
            port_info[debug_ifindex-1].port_entry.port_name,
            port_info[debug_ifindex-1].port_entry.port_type,
            port_info[debug_ifindex-1].port_entry.port_speed_dpx_cfg,
            port_info[debug_ifindex-1].port_entry.port_flow_ctrl_cfg,
            port_info[debug_ifindex-1].port_entry.port_capabilities,
            port_info[debug_ifindex-1].port_entry.port_autonegotiation,
            port_info[debug_ifindex-1].port_entry.port_speed_dpx_status,
            port_info[debug_ifindex-1].port_entry.port_flow_ctrl_status,
            port_info[debug_ifindex-1].port_entry.port_trunk_index,
            port_info[debug_ifindex-1].port_entry.port_forced_mode,
            port_info[debug_ifindex-1].port_entry.port_forced_1000t_mode,
            port_info[debug_ifindex-1].admin_status,
            port_info[debug_ifindex-1].link_change_trap,
            port_info[debug_ifindex-1].link_oper_status_last_change,
            port_info[debug_ifindex-1].link_oper_status,
            port_info[debug_ifindex-1].ingress_rate_limit_status,
            port_info[debug_ifindex-1].ingress_rate_limit,
            port_info[debug_ifindex-1].egress_rate_limit_status,
            port_info[debug_ifindex-1].egress_rate_limit,
            port_info[debug_ifindex-1].port_security_status,
            port_info[debug_ifindex-1].port_security_enabled_by_who,
            port_info[debug_ifindex-1].port_security_action_status,
            port_info[debug_ifindex-1].port_security_action_trap_oper_status,
            port_info[debug_ifindex-1].port_security_action_trap_time_stamp,
            port_info[debug_ifindex-1].egress_scheduler_method,
            port_info[debug_ifindex-1].private_vlan_uplink_port,
            port_info[debug_ifindex-1].private_vlan_downlink_port,
            port_info[debug_ifindex-1].forced_1000t_mode
            );
        fflush(stdout);
    }
}
#endif /* #if 0 */

/*------------------------------------------------------------------------------
 * ROUTINE NAME : SWCTRL_LportListToUportList
 *------------------------------------------------------------------------------
 * PURPOSE:
 *    Convert logical port list to user port list.
 * INPUT:
 *    lport_list  --  the logical port bitmap to be converted
 *
 * OUTPUT:
 *    uport_list  --  the resulted user port bitmap
 *
 * RETURN:
 *    TRUE  --  Success
 *    FALSE --  Fail
 *
 * NOTES:
 *    1. The size of lport_list/uport_list is
 *       SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST.
 *    2. The uport_list space should be allocated by caller.
 *------------------------------------------------------------------------------
 */
BOOL_T SWCTRL_LportListToUportList(UI8_T *lport_list, UI8_T *uport_list)
{
    UI32_T                       ifindex = 0, unit = 0, port = 0, i;
    UI32_T                       total_bytes_of_one_unit;
    SWCTRL_TrunkPortExtInfo_T    trunk_port_ext_info;

    if ((lport_list == NULL) || (uport_list == NULL))
        return FALSE;

    memset (uport_list, 0, SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST);

    while (SWCTRL_GetNextIndexFromPortList(&ifindex, lport_list))
    {
        /* SWCTRL_LPORT_UNKNOWN_PORT
         */
        if (!SWCTRL_IS_EXIST(ifindex))
            continue;

        /* SWCTRL_LPORT_TRUNK_PORT_MEMBER
         */
        if (SWCTRL_IS_TRUNK_MEMBER(ifindex))
            continue;

        /* SWCTRL_LPORT_NORMAL_PORT
         */
        if (!SWCTRL_IS_TRUNK(ifindex))
        {
            unit = SWCTRL_IFINDEX_TO_UNIT(ifindex);
            port = SWCTRL_IFINDEX_TO_PORT(ifindex);

            /* uport_list :
             *           +---------+---------+------+---------+
             *  unit     |    1    |    2    | ...  |    8    |
             *           +---------+---------+------+---------+
             *  portlist | N bytes | N bytes | ...  | N bytes |
             *           +---------+---------+------+---------+
             *  N = total_bytes_of_one_unit
             */
            total_bytes_of_one_unit = (SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT + 7) / 8;

            uport_list[total_bytes_of_one_unit * (unit-1) + ((port-1) / 8)] |= (1 << (7 - ((port-1) % 8)));
        }

        /* SWCTRL_LPORT_TRUNK_PORT
         */
        if (SWCTRL_IS_TRUNK(ifindex))
        {
            SWCTRL_GetTrunkPortExtInfo(ifindex, &trunk_port_ext_info);

            for (i = 0; i < trunk_port_ext_info.member_number; i++)
            {
                unit = (UI32_T)trunk_port_ext_info.member_list[i].unit;
                port = (UI32_T)trunk_port_ext_info.member_list[i].port;

                /* uport_list :
                 *           +---------+---------+------+---------+
                 *  unit     |    1    |    2    | ...  |    8    |
                 *           +---------+---------+------+---------+
                 *  portlist | N bytes | N bytes | ...  | N bytes |
                 *           +---------+---------+------+---------+
                 *  N = total_bytes_of_one_unit
                 */
                total_bytes_of_one_unit = (SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT + 7) / 8;

                uport_list[total_bytes_of_one_unit * (unit-1) + ((port-1) / 8)] |= (1 << (7 - ((port-1) % 8)));
            }
        } /* End of if */
    } /* end of while */

    return TRUE;
}

#if (SYS_CPNT_EFM_OAM == TRUE)
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetOamLoopback
 * -------------------------------------------------------------------------
 * FUNCTION: This function will enable efm oam loopback mode
 * INPUT   :
 *     l_port -- which logical port
 *     enable -- enable/disable loopback mode
 *     flag --
 *          SWCTRL_LOOPBACK_MODE_TYPE_ACTIVE
 *          SWCTRL_LOOPBACK_MODE_TYPE_PASSIVE
 * OUTPUT  : None
 * RETURN  : True: Successfully, FALSE: Failed
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetOamLoopback(UI32_T l_port, BOOL_T enable, UI32_T flag)
{
    UI32_T  unit;
    UI32_T  port;

    BOOL_T  retval = FALSE;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if(l_port == 0 || l_port > SYS_ADPT_TOTAL_NBR_OF_LPORT)
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Logical Port ID (1-%d)", SYS_ADPT_TOTAL_NBR_OF_LPORT);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_LOGICAL_PORT_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (!SWCTRL_IS_EXIST (l_port))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Interface");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if(!SWCTRL_IS_TRUNK(l_port))
    {
        unit = SWCTRL_IFINDEX_TO_UNIT(l_port);
        port = SWCTRL_IFINDEX_TO_PORT(l_port);

        if (flag == SWCTRL_LOOPBACK_MODE_TYPE_PASSIVE)
        {
            /* make LAN to loop back the packets that can't be looped back by chip */

            LAN_SetOamLoopback(unit, port, enable);

        }

        retval = SWDRV_SetOamLoopback(unit, port, enable, flag);
    }

    if (retval)
    {
        user_ext_port_info[l_port-1].is_oam_loopback_mode = enable;

        if (enable)
        {
            SWCTRL_LinkOperStateMachineChangeState (l_port, SWCTRL_LOOPBACK_START_EVENT);
        }
        else
        {
            SWCTRL_LinkOperStateMachineChangeState (l_port, SWCTRL_LOOPBACK_STOP_EVENT);
        }
    }

    SWCTRL_RETURN_AND_RELEASE_CSC( retval );
}/* end of SWCTRL_EnableOamLoopbackMode () */

/*--------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetOperationSpeedDuplex
 *---------------------------------------------------------------------------
 * PURPOSE:  This function will return this port's operation speed and duplex
 * INPUT:    lport, *upStream,*downSteram
 * OUTPUT:   - VAL_portSpeedDpxCfg_halfDuplex10
 *          VAL_portSpeedDpxCfg_fullDuplex10
 *          VAL_portSpeedDpxCfg_halfDuplex100
 *          VAL_portSpeedDpxCfg_fullDuplex100
 *          VAL_portSpeedDpxCfg_fullDuplex1000
 *
 * RETURN:   Success --> TRUE; Fail --> FALSE
 * NOTE: if only support one stream, the upStream and downStream will be the same value
 *      now, we just support one stream.
 *---------------------------------------------------------------------------
 */
BOOL_T SWCTRL_GetOperationSpeedDuplex(UI32_T l_port, UI32_T *upSteam, UI32_T *downStream)
{
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (!SWCTRL_IS_EXIST (l_port))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Interface");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (SWCTRL_IS_TRUNK_MEMBER(l_port))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Interface");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    *upSteam= port_info[l_port- 1].port_entry.port_speed_dpx_status;
    *downStream= port_info[l_port- 1].port_entry.port_speed_dpx_status;

   SWCTRL_RETURN_AND_RELEASE_CSC(TRUE );
}

#endif /* End of SYS_CPNT_EFM_OAM */

#if (SYS_CPNT_INTERNAL_LOOPBACK_TEST == TRUE)
const UI8_T test_dst_mac[] = {0x01, 0x80, 0xc2, 0x00, 0x00, 0x00};
const UI8_T test_src_mac[] = {0x00, 0x02, 0x05, 0x04, 0x08, 0x01};
const UI16_T test_ether_type = 0x0800;

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SendInternalLoopbackPacket
 * -------------------------------------------------------------------------
 * FUNCTION: This function will send out a loopback packet
 * INPUT   :
 *     l_port -- which logical port
 * OUTPUT  : None
 * RETURN  : True: Successfully, FALSE: Failed
 * NOTE    : None
 * -------------------------------------------------------------------------*/
static BOOL_T SWCTRL_SendInternalLoopbackPacket(UI32_T lport)
{
    UI32_T unit = 0, port = 0, trunkid = 0;
    L_MM_Mref_Handle_T *mref;

    if(SWCTRL_LogicalPortToUserPort(lport, &unit, &port, &trunkid) != SWCTRL_LPORT_NORMAL_PORT)
    {
        return FALSE;
    }

    if((mref = L_MM_AllocateTxBuffer(68, L_MM_USER_ID2(SYS_MODULE_SWCTRL,0))) == NULL)
    {
        return FALSE;
    }

     LAN_SendPacket(mref,                             /* L_MREF * */
                   (UI8_T *)test_dst_mac,                    /* dst mac */
                   (UI8_T *)test_src_mac,                    /* src mac */
                   test_ether_type,                 /* packet type */
                   1,       /* tag_info */
                   68,                               /* packet length */
                   unit,                            /* unit */
                   port,                            /* port */
                   TRUE,                           /* is_tagged */
                   3                               /* transfer priority*/
                  );
    return TRUE;
}


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_PacketHandler
 * -------------------------------------------------------------------------
 * FUNCTION: This function will handle the packet trap to swctrl
 * INPUT   :
 * OUTPUT  : None
 * RETURN  : True: Successfully, FALSE: Failed
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_PacketHandler(UI8_T *dst_mac, UI8_T *src_mac, UI16_T type, SYSFUN_Msg_T* ipcmsg_p)
{
    SWCTRL_MGR_IPCMsg_T *msg_data_p;
    #if 0
    UI32_T unit = 0, port = 0, trunkid = 0;  /* modified by Jinhua Wei ,to remove warning ,becaued the variable never used */
    #endif

    if(memcmp(dst_mac, test_dst_mac, SYS_ADPT_MAC_ADDR_LEN) != 0 ||
       memcmp(src_mac, test_src_mac, SYS_ADPT_MAC_ADDR_LEN) != 0 ||
       test_ether_type != type)
    {
        DBG_PRINT("not my packet");
        return FALSE;
    }

    if (loopback_lport == 0)
    {
        DBG_PRINT("loopback_lport=%d", loopback_lport);
        return FALSE;
    }

    /* 1. Disable loopback mode and stop timer */
    SWCTRL_SetInternalLoopback(loopback_lport,FALSE);
    SWCTRL_GROUP_StopInternalLoopbackTimeoutTimer();

    /* 2. update loopback test result */
    loopback_result[loopback_lport].result = VAL_loopInternalResultStatus_succeeded;
    SYS_TIME_GetRealTimeBySec(&loopback_result[loopback_lport].time);
    loopback_lport = 0;

    /* 3. prepare ipcmsg_p for return to the caller of SWCTRL_ExecuteInternalLoopbackTest */
    ipcmsg_p->msg_size = SWCTRL_MGR_MSGBUF_TYPE_SIZE;       /* response size */
    ipcmsg_p->msg_type = resp_thread_id;
    msg_data_p = (SWCTRL_MGR_IPCMsg_T*)ipcmsg_p->msg_buf;
    msg_data_p->type.cmd = SWCTRL_MGR_IPCCMD_EXECUTEINTERNALLOOPBACKTEST;
    msg_data_p->type.result_bool = TRUE;


    return TRUE;
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetInternalLoopback
 * -------------------------------------------------------------------------
 * FUNCTION: This function will enable internal loopback mode
 * INPUT   :
 *     l_port -- which logical port
 *     enable -- enable/disable loopback mode
 * OUTPUT  : None
 * RETURN  : True: Successfully, FALSE: Failed
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetInternalLoopback(UI32_T l_port, BOOL_T enable)
{
    UI32_T  unit;
    UI32_T  port;

    BOOL_T  retval = FALSE;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if(l_port == 0 || l_port > SYS_ADPT_TOTAL_NBR_OF_LPORT)
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Logical Port ID (1-%d)", SYS_ADPT_TOTAL_NBR_OF_LPORT);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_LOGICAL_PORT_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (!SWCTRL_IS_EXIST (l_port))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Interface");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if(!SWCTRL_IS_TRUNK(l_port))
    {
        unit = SWCTRL_IFINDEX_TO_UNIT(l_port);
        port = SWCTRL_IFINDEX_TO_PORT(l_port);

            /* make LAN to loop back the packets that can't be looped back by chip */

        LAN_SetInternalLoopback(unit, port, enable);

        retval = SWDRV_SetInternalLoopback(unit, port, enable);
    }

    if (retval)
    {
        user_ext_port_info[l_port-1].is_int_loopback_mode = enable;

        if (enable)
        {
            SWCTRL_LinkOperStateMachineChangeState (l_port, SWCTRL_LOOPBACK_START_EVENT);
        }
        else
        {
            SWCTRL_LinkOperStateMachineChangeState (l_port, SWCTRL_LOOPBACK_STOP_EVENT);
        }
    }

    SWCTRL_RETURN_AND_RELEASE_CSC( retval );
}/* end of SWCTRL_SetInternalLoopback () */

/*--------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_ExecuteInternalLoopbackTest
 *---------------------------------------------------------------------------
 * PURPOSE:  This function will execute the internal loopback test
 * INPUT:    lport
 * OUTPUT:   None
 * RETURN:   None
 * NOTE: start a timeout timer and send the loopback frame.
 *---------------------------------------------------------------------------
 */
BOOL_T SWCTRL_ExecuteInternalLoopbackTest(UI32_T lport)
{
    UI32_T unit = 0, port = 0, trunk_id = 0;

    if (loopback_lport != 0 )
    {
        DBG_PRINT("Internal loopback test is testing\r\n");
        return FALSE;
    }

    if (SWCTRL_LogicalPortToUserPort(lport, &unit, &port, &trunk_id) == FALSE)
    {
        DBG_PRINT("Not an normal port\r\n");
        return FALSE;
    }

    if(trunk_id != 0)
    {
        DBG_PRINT("Internal Loopback Test is not support on trunk\r\n");
        return FALSE;
    }

    loopback_lport = lport;

    /* 1. Set Internal loopback */
    if (SWCTRL_SetInternalLoopback(lport, TRUE) == FALSE)
    {
        DBG_PRINT("SWCTRL_SetInternalLoopback fail!");
        return FALSE;
    }

    /* 2. Send Internal loopback packet */
    if (SWCTRL_SendInternalLoopbackPacket(lport) == FALSE)
    {
        DBG_PRINT("SWCTRL_SendInternalLoopbackPacket");
        return FALSE;
    }

    /* 3. start a loopback timer */
    SWCTRL_GROUP_StartInternalLoopbackTimeoutTimer();

    return TRUE;
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetInternalLoopbackTestResult
 * -------------------------------------------------------------------------
 * FUNCTION: This function will get internal loopback test result
 * INPUT   : lport
 * OUTPUT  : lport
 *           result - VAL_loopInternalResultStatus_notTestedYet
 *                    VAL_loopInternalResultStatus_succeeded
 *                    VAL_loopInternalResultStatus_failed
 *           result_time
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_GetInternalLoopbackTestResult(UI32_T lport, UI32_T *result, UI32_T *result_time)
{
    if (!SWCTRL_IS_USER_PORT(lport))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Interface");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        return FALSE;
    }

    if (!SWCTRL_IS_EXIST (lport))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Interface");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        return FALSE;
    }

    if (SWCTRL_IS_TRUNK_MEMBER(lport))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Interface");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        return FALSE;
    }
    *result = loopback_result[lport].result;
    *result_time = loopback_result[lport].time;

    return TRUE;
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetNextInternalLoopbackTestResult
 * -------------------------------------------------------------------------
 * FUNCTION: This function will get rate based storm control settings.
 * INPUT   : lport
 * OUTPUT  : lport
 *           result - VAL_loopInternalResultStatus_notTestedYet
 *                    VAL_loopInternalResultStatus_succeeded
 *                    VAL_loopInternalResultStatus_failed
 *           result_time
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_GetNextInternalLoopbackTestResult(UI32_T *lport, UI32_T *result, UI32_T *result_time)
{
    while (SWCTRL_GetNextLogicalPort(lport) != SWCTRL_LPORT_UNKNOWN_PORT)
    {
        /* not support trunk port currently */
        if (SWCTRL_IS_TRUNK(*lport))
        {
            continue;
        }
        else
        {
            *result = loopback_result[*lport].result;
            *result_time = loopback_result[*lport].time;
            return TRUE;
        }
    }
    return FALSE;
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_InternalLoopbackTimeout
 * -------------------------------------------------------------------------
 * FUNCTION: This function will handle the internal loopback timeout
 * INPUT   : ipcmsg_p   -- for prepare the reponse msg
 * OUTPUT  : ipcmsg_p
 * RETURN  : TRUE/FALSE (need response)
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_InternalLoopbackTimeout(SYSFUN_Msg_T* ipcmsg_p)
{
    if (loopback_lport == 0)
    {
        DBG_PRINT("loopback_lport=%d", loopback_lport);
        return FALSE;
    }


    /* Disable loopback mode and stop timer */
    SWCTRL_GROUP_StopInternalLoopbackTimeoutTimer();
    SWCTRL_SetInternalLoopback(loopback_lport, FALSE);

    if(loopback_lport)
    {
        SWCTRL_MGR_IPCMsg_T *msg_data_p;

        /* 1. update loopback status */
        loopback_result[loopback_lport].result = VAL_loopInternalResultStatus_failed;
        SYS_TIME_GetRealTimeBySec(&loopback_result[loopback_lport].time);
        loopback_lport = 0;

        /* 2. prepare ipcmsg_p*/
        ipcmsg_p->msg_size = SWCTRL_MGR_MSGBUF_TYPE_SIZE; /* response size */
        ipcmsg_p->msg_type = resp_thread_id;
        msg_data_p = (SWCTRL_MGR_IPCMsg_T*)ipcmsg_p->msg_buf;
        msg_data_p->type.cmd = SWCTRL_MGR_IPCCMD_EXECUTEINTERNALLOOPBACKTEST;
        msg_data_p->type.result_bool = TRUE;

        return TRUE;
    }
    return FALSE;
}


#endif
#if (SYS_CPNT_REFINE_ISC_MSG == TRUE)
#if 0
void SWCTRL_lportlist2uportlist(UI8_T *lportlist)
{
  UI32_T i,ifindex,unit, port;
  SWCTRL_TrunkPortExtInfo_T    trunk_ext_p_info;

   if(!lportlist)
    return;

   for(i = 0;i<SYS_ADPT_TOTAL_NBR_OF_LPORT;i++)
   {
     if(*(lportlist+i))
        if(SWCTRL_IS_TRUNK (i+1))
        {
          SWCTRL_GetTrunkPortExtInfo (i+1, &trunk_ext_p_info);

          for(i = 0; i < trunk_ext_p_info.member_number; i++)
          {
            unit = (UI32_T) trunk_ext_p_info.member_list[i].unit;
            port = (UI32_T) trunk_ext_p_info.member_list[i].port;
            ifindex = SWCTRL_UPORT_TO_IFINDEX(unit,port);
            *(lportlist+ifindex) = 1;
          }
         *(lportlist+i) = 0;

        }

   }
}
#endif
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_DisableIngressFilter_PortList
 * -------------------------------------------------------------------------
 * FUNCTION: This function will disable ingress filter of a port
 * INPUT   : ifindex -- which port to disable
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_DisableIngressFilter_PortList(UI8_T* port_list)
{
    BOOL_T                          retval = FALSE;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if(!port_list)
        return FALSE;

    SWCTRL_LOCK();

    retval = SWDRV_DisableIngressFilter_PortList(port_list);

    SWCTRL_UNLOCK();
    SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME ();
    SWCTRL_RETURN_AND_RELEASE_CSC( retval );
} /* End of SWCTRL_DisableIngressFilter() */

BOOL_T SWCTRL_EnableIngressFilter_PortList(UI8_T* port_list)
{
    BOOL_T                          retval = FALSE;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if(!port_list)
        return FALSE;

    SWCTRL_LOCK();

    retval = SWDRV_EnableIngressFilter_PortList(port_list);

    SWCTRL_UNLOCK();
    SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME ();
    SWCTRL_RETURN_AND_RELEASE_CSC( retval );
} /* End of SWCTRL_DisableIngressFilter() */

BOOL_T SWCTRL_AdmitAllFrames_PortList(UI8_T* port_list)
{
    BOOL_T                          retval = FALSE;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if(!port_list)
        return FALSE;

    SWCTRL_LOCK();

    retval = SWDRV_AdmitAllFrames_PortList(port_list);

    SWCTRL_UNLOCK();
    SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME ();
    SWCTRL_RETURN_AND_RELEASE_CSC( retval );
} /* End of SWCTRL_DisableIngressFilter() */


BOOL_T SWCTRL_SetPortPVID_PortList(UI8_T* port_list,UI32_T pvid)
{
    BOOL_T  retval = FALSE;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if(!port_list)
        return FALSE;

    SWCTRL_LOCK();

    retval = SWDRV_SetPortPVID_PortList(port_list,pvid);

    SWCTRL_UNLOCK();
    SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME ();
    SWCTRL_RETURN_AND_RELEASE_CSC( retval );
} /* End of SWCTRL_DisableIngressFilter() */

BOOL_T SWCTRL_AddPortToVlanUntaggedSet_PortList(UI8_T* port_list,UI32_T vid)
{
    BOOL_T  retval = FALSE;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if(!port_list)
        return FALSE;

    SWCTRL_LOCK();

    retval = SWDRV_AddPortToVlanUntaggedSet_PortList(port_list,vid);

    SWCTRL_UNLOCK();
    SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME ();
    SWCTRL_RETURN_AND_RELEASE_CSC( retval );
} /* End of SWCTRL_DisableIngressFilter() */

BOOL_T SWCTRL_AddPortToVlanMemberSet_PortList(UI8_T* port_list,UI32_T vid)
{
    BOOL_T  retval = FALSE;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if(!port_list)
        return FALSE;

    SWCTRL_LOCK();

    retval = SWDRV_AddPortToVlanMemberSet_PortList(port_list,vid);

    SWCTRL_UNLOCK();
    SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME ();
    SWCTRL_RETURN_AND_RELEASE_CSC( retval );
} /* End of SWCTRL_DisableIngressFilter() */

static void SWCTRL_GetPosition(UI32_T index, UI32_T *list_index, UI32_T *list_position)
{
    *list_index =   (UI32_T)(index - 1) / 8;
    *list_position = (UI32_T)(index - 1) % 8;

    return;

} /* end of VLAN_OM_GetPosition() */


static void SWCTRL_ConfigUserPortListToDefaultState(UI32_T start_ifindex, UI32_T end_ifindex,  BOOL_T is_enter_master_mode)
{
    UI32_T             ifindex;
    SWCTRL_PortInfo_T  original_port_info;
    UI32_T             q_id;
    UI32_T             unit,port,port_type;
    UI32_T              byte, shift;
    UI8_T   ports_default1[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST];
    UI8_T   ports_default2[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST];
    UI8_T   ports_default3[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST];


    memset(ports_default1,0,sizeof(ports_default1));
    memset(ports_default2,0,sizeof(ports_default2));
    memset(ports_default3,0,sizeof(ports_default3));

  for(ifindex =  start_ifindex;ifindex <= end_ifindex; ifindex ++)
   {
       if (STKTPLG_PORT_TYPE_STACKING == port_info[ifindex-1].port_entry.port_type  ||
            STKTPLG_PORT_TYPE_NOT_EXIST == port_info[ifindex-1].port_entry.port_type )
        {
            port_info[ifindex-1].link_oper_status = VAL_ifOperStatus_notPresent;
            continue;
        }
        port_type =port_info[ifindex-1].port_entry.port_type;
        unit = SWCTRL_IFINDEX_TO_UNIT(ifindex);
        port = SWCTRL_IFINDEX_TO_PORT(ifindex);

        SWCTRL_LOCK();
        original_port_info = port_info[ifindex-1];
        SWCTRL_UNLOCK();

#if (SYS_CPNT_COMBO_PORT_FORCE_MODE == TRUE)
        if(is_enter_master_mode == TRUE)
        {
        UI32_T media_cap;

        /* port config forced mode : active which medium
         */
        SWCTRL_GetPosition(ifindex, &byte, &shift);
        SWCTRL_LOCK();
        STKTPLG_POM_GetPortMediaCapability(unit, port, &media_cap);

        if ((media_cap & STKTPLG_TYPE_PORT_MEDIA_CAP_COPPER) && (media_cap & STKTPLG_TYPE_PORT_MEDIA_CAP_FIBER))
        {
            ports_default1[byte] |= ((0x01) << (7 - shift));
            port_info[ifindex-1].port_entry.port_forced_mode = SYS_DFLT_COMBO_PORT_FORCED_MODE;
        }
        else if((media_cap & STKTPLG_TYPE_PORT_MEDIA_CAP_COPPER) && (!(media_cap & STKTPLG_TYPE_PORT_MEDIA_CAP_FIBER)))
        {
           ports_default2[byte] |= ((0x01) << (7 - shift));
           port_info[ifindex-1].port_entry.port_forced_mode = VAL_portComboForcedMode_copperForced;
        }
        else
        {
            ports_default3[byte] |= ((0x01) << (7 - shift));
            port_info[ifindex-1].port_entry.port_forced_mode = VAL_portComboForcedMode_sfpForced;
        }
        SWCTRL_UNLOCK();
    }
  #endif
}

 SWDRV_SetPortListComboForcedMode(ports_default1,SYS_DFLT_COMBO_PORT_FORCED_MODE);
 SWDRV_SetPortListComboForcedMode(ports_default2,VAL_portComboForcedMode_copperForced);
 SWDRV_SetPortListComboForcedMode(ports_default3,VAL_portComboForcedMode_sfpForced);


    /* admin_state and port name     */
    memset(ports_default1,0,sizeof(ports_default1));
    memset(ports_default2,0,sizeof(ports_default2));

 for(ifindex =  start_ifindex;ifindex <= end_ifindex; ifindex ++)
   {
       if (STKTPLG_PORT_TYPE_STACKING == port_info[ifindex-1].port_entry.port_type  ||
            STKTPLG_PORT_TYPE_NOT_EXIST == port_info[ifindex-1].port_entry.port_type )
        {
            port_info[ifindex-1].link_oper_status = VAL_ifOperStatus_notPresent;
            continue;
        }
        port_type =port_info[ifindex-1].port_entry.port_type;
        unit = SWCTRL_IFINDEX_TO_UNIT(ifindex);
        port = SWCTRL_IFINDEX_TO_PORT(ifindex);
        SWCTRL_GetPosition(ifindex, &byte, &shift);

        SWCTRL_LOCK();
        original_port_info = port_info[ifindex-1];
        SWCTRL_UNLOCK();

        /* port_name
         */
        SWCTRL_LOCK();
        memcpy(port_info[ifindex-1].port_entry.port_name, SYS_DFLT_PORT_NAME, sizeof(SYS_DFLT_PORT_NAME));
        port_info[ifindex-1].port_entry.port_name[sizeof(SYS_DFLT_PORT_NAME)] = 0;
        SWCTRL_UNLOCK();

        SWCTRL_LOCK();
        port_info[ifindex-1].admin_status = SYS_DFLT_IF_ADMIN_STATUS;
        if(is_enter_master_mode == FALSE)
        {
        /* When SWCTRL enter master mode, all ports are not allowed to admin enabled,
         * so, only setting database is necessary and the value may be changed becuase of provision.
         * When provision complete, the value in database will be took effect.
         */

        if(original_port_info.admin_status != port_info[ifindex-1].admin_status)
        {
            if(port_info[ifindex-1].admin_status == VAL_ifAdminStatus_up)
            {
#if (SYS_CPNT_3COM_LOOPBACK_TEST == TRUE)
                if (TRUE == user_ext_port_info[ifindex-1].is_loopback_test_failed)
                {
                    /* loopback test failed port:
                     * don't set ASIC
                     */
                    ;
                }
                else
                {
#endif
                    /* loopback test passed port:
                     * set ASIC
                     */
                    ports_default1[byte] |= ((0x01) << (7 - shift));
#if (SYS_CPNT_3COM_LOOPBACK_TEST == TRUE)
                }
#endif

                SWCTRL_UNLOCK();

                /* callback
                 */
                SWCTRL_Notify_uPortAdminEnable(unit, port);

                if(!SWCTRL_IS_TRUNK_MEMBER(ifindex))
                    SWCTRL_Notify_PortAdminEnable(ifindex);

                SWCTRL_LOCK();
            }
            else
            {
#if (SYS_CPNT_3COM_LOOPBACK_TEST == TRUE)
                if (TRUE == user_ext_port_info[ifindex-1].is_loopback_test_failed)
                {
                    /* loopback test failed port:
                     * don't set ASIC
                     */
                    ;
                }
                else
                {
#endif
                    /* loopback test passed port:
                     * set ASIC
                     */
                ports_default2[byte] |= ((0x01) << (7 - shift));
#if (SYS_CPNT_3COM_LOOPBACK_TEST == TRUE)
                }
#endif

                SWCTRL_UNLOCK();

                /* callback
                 */
                SWCTRL_Notify_uPortAdminDisable(unit, port);

                if(!SWCTRL_IS_TRUNK_MEMBER(ifindex))
                    SWCTRL_Notify_PortAdminDisable(ifindex);

                SWCTRL_LOCK();
            }
        }
    }
    SWCTRL_UNLOCK();
}

if(is_enter_master_mode == FALSE)
{
  SWDRV_EnablePortListAdmin(ports_default1);
  SWDRV_DisablePortListAdmin(ports_default2);
}



/* port_capabilities
 */
/* Setting SWDRV_SetPortAutoNegCapability() will not make chip to run force or auto mode,
 * so, set this API here.
 */

{
    UI8_T   ports_1000_fiber[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST];
    UI8_T   ports_10G_FIBER[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST];
    UI8_T   ports_1000_copper[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST];
    UI8_T   ports_10G_copper[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST];
    UI8_T   ports_40G_fiber[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST];

       memset(ports_default1,0,sizeof(ports_default1));
       memset(ports_default2,0,sizeof(ports_default2));
       memset(ports_1000_fiber,0,sizeof(ports_1000_fiber));
       memset(ports_10G_FIBER,0,sizeof(ports_10G_FIBER));
       memset(ports_1000_copper,0,sizeof(ports_1000_copper));
       memset(ports_10G_copper,0,sizeof(ports_10G_copper));
       memset(ports_40G_fiber,0,sizeof(ports_40G_fiber));

   for(ifindex =  start_ifindex;ifindex <= end_ifindex; ifindex ++)
   {
       if (STKTPLG_PORT_TYPE_STACKING == port_info[ifindex-1].port_entry.port_type  ||
            STKTPLG_PORT_TYPE_NOT_EXIST == port_info[ifindex-1].port_entry.port_type )
        {
            port_info[ifindex-1].link_oper_status = VAL_ifOperStatus_notPresent;
            continue;
        }

     port_type =port_info[ifindex-1].port_entry.port_type;
      unit = SWCTRL_IFINDEX_TO_UNIT(ifindex);
      port = SWCTRL_IFINDEX_TO_PORT(ifindex);
     SWCTRL_GetPosition(ifindex, &byte, &shift);
     SWCTRL_LOCK();
    if (port_type == VAL_portType_hundredBaseTX)                    /*100 copper*/
    {
        port_info[ifindex-1].port_entry.port_capabilities = SYS_DFLT_10_100_PORT_CAPABILITIES;
        ports_default1[byte] |= ((0x01) << (7 - shift));
    }
    else if (port_type == VAL_portType_hundredBaseFX             ||
             port_type == VAL_portType_hundredBaseFxScSingleMode ||
             port_type == VAL_portType_hundredBaseFxScMultiMode  )  /*100 fiber*/
    {
        port_info[ifindex-1].port_entry.port_capabilities = SYS_DFLT_100_FIBER_PORT_CAPABILITIES;
        ports_default2[byte] |= ((0x01) << (7 - shift));
    }
    else if (port_type == VAL_portType_thousandBaseSX   ||
             port_type == VAL_portType_thousandBaseLX   ||
             port_type == VAL_portType_thousandBaseGBIC ||
             port_type == VAL_portType_thousandBaseSfp  )          /*1000 fiber*/
    {
        port_info[ifindex-1].port_entry.port_capabilities = SYS_DFLT_1000_FIBER_PORT_CAPABILITIES ;
        ports_1000_fiber[byte] |= ((0x01) << (7 - shift));
    }
    else if (port_type == VAL_portType_tenG         ||
             port_type == VAL_portType_tenGBaseXFP  ||
             port_type == VAL_portType_tenGBaseSFP  )                  /*10G fiber*/
    {
        ports_10G_FIBER[byte] |= ((0x01) << (7 - shift));
        port_info[ifindex-1].port_entry.port_capabilities = SYS_DFLT_10G_FIBER_PORT_CAPABILITIES;
    }
    else if (port_type == VAL_portType_tenGBaseT)                  /*10G copper*/
    {
        ports_10G_copper[byte] |= ((0x01) << (7 - shift));
        port_info[ifindex-1].port_entry.port_capabilities = SYS_DFLT_10G_COPPER_PORT_CAPABILITIES;
    }
    else if (port_type == VAL_portType_fortyGBaseQSFP)                  /* 40G */
    {
        ports_40G_fiber[byte] |= ((0x01) << (7 - shift));
        port_info[ifindex-1].port_entry.port_capabilities = SYS_DFLT_40G_FIBER_PORT_CAPABILITIES;
    }
    else                                                           /*1000 copper*/
    {
        ports_1000_copper[byte] |= ((0x01) << (7 - shift));
        port_info[ifindex-1].port_entry.port_capabilities = SYS_DFLT_10_100_1000_PORT_CAPABILITIES ;
    }
    SWCTRL_UNLOCK();
   }
   SWDRV_SetPortListAutoNegCapability (ports_default1,SYS_DFLT_10_100_PORT_CAPABILITIES);
   SWDRV_SetPortListAutoNegCapability (ports_default2,SYS_DFLT_100_FIBER_PORT_CAPABILITIES);
   SWDRV_SetPortListAutoNegCapability (ports_1000_fiber,SYS_DFLT_1000_FIBER_PORT_CAPABILITIES);
   SWDRV_SetPortListAutoNegCapability (ports_10G_FIBER,SYS_DFLT_10G_FIBER_PORT_CAPABILITIES);
   SWDRV_SetPortListAutoNegCapability (ports_40G_fiber,SYS_DFLT_40G_FIBER_PORT_CAPABILITIES);
   SWDRV_SetPortListAutoNegCapability (ports_1000_copper,SYS_DFLT_10_100_1000_PORT_CAPABILITIES);
}

    {

       memset(ports_default1,0,sizeof(ports_default1));

       for(ifindex =  SYS_ADPT_ETHER_1_IF_INDEX_NUMBER;
            ifindex <= SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK*SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT;
            ifindex ++)
       {
           if (STKTPLG_PORT_TYPE_STACKING == port_info[ifindex-1].port_entry.port_type  ||
                STKTPLG_PORT_TYPE_NOT_EXIST == port_info[ifindex-1].port_entry.port_type )
            {
                port_info[ifindex-1].link_oper_status = VAL_ifOperStatus_notPresent;
                continue;
            }
         port_type =port_info[ifindex-1].port_entry.port_type;
         unit = SWCTRL_IFINDEX_TO_UNIT(ifindex);
         port = SWCTRL_IFINDEX_TO_PORT(ifindex);
         SWCTRL_GetPosition(ifindex, &byte, &shift);

         /* port_speed_dpx_cfg
             */
            /* Setting SWDRV_SetPortCfgSpeedDuplex() will make chip run force mode, we don't know
             * the auto or force mode, now. In this way, don't set this API here.
             */
            if( port_type == VAL_portType_hundredBaseTX )                    /*FE_COPPER*/
            {
                port_info[ifindex-1].port_entry.port_speed_dpx_cfg = SYS_DFLT_FE_COPPER_PORT_FORCE_MODE_SPDDPX;
            }
            else if( port_type == VAL_portType_hundredBaseFX             ||
                     port_type == VAL_portType_hundredBaseFxScSingleMode ||
                     port_type == VAL_portType_hundredBaseFxScMultiMode  )    /*FE_FIBER*/
            {
                port_info[ifindex-1].port_entry.port_speed_dpx_cfg = SYS_DFLT_FE_FIBER_PORT_FORCE_MODE_SPDDPX;
            }
            else if( port_type == VAL_portType_thousandBaseSX   ||
                     port_type == VAL_portType_thousandBaseLX   ||
                     port_type == VAL_portType_thousandBaseGBIC ||
                     port_type == VAL_portType_thousandBaseSfp  )    /*GE_FIBER*/
            {
                port_info[ifindex-1].port_entry.port_speed_dpx_cfg = SYS_DFLT_GE_FIBER_PORT_FORCE_MODE_SPDDPX;
       #if (SYS_CPNT_SUPPORT_COMBO_PORT_NO_NEG_KEEP == TRUE)
                port_info[ifindex-1].port_entry.port_combo_fiber_speed_dpx_cfg = SYS_DFLT_GE_FIBER_PORT_FORCE_MODE_SPDDPX;
       #endif
            }
#ifdef SYS_DFLT_40GE_FIBER_PORT_FORCE_MODE_SPDDPX
            else if( port_type == VAL_portType_fortyGBaseQSFP ) /* 40G Port */
            {
                port_info[ifindex-1].port_entry.port_speed_dpx_cfg = SYS_DFLT_40GE_FIBER_PORT_FORCE_MODE_SPDDPX;
            }
#endif
            else if( port_type == VAL_portType_tenG         ||
                     port_type == VAL_portType_tenGBaseXFP  ||
                     port_type == VAL_portType_tenGBaseSFP  )          /*10G Port*/
            {
                port_info[ifindex-1].port_entry.port_speed_dpx_cfg = SYS_DFLT_10GE_FIBER_PORT_FORCE_MODE_SPDDPX;
            }
            else if( port_type == VAL_portType_tenGBaseT)          /*10G Port*/
            {
                port_info[ifindex-1].port_entry.port_speed_dpx_cfg = SYS_DFLT_10GE_COPPER_PORT_FORCE_MODE_SPDDPX;
            }
            else                                                     /*GE_COPPER*/
            {
                /* Aaron add for combo port keep */
                UI32_T media_cap;
                STKTPLG_POM_GetPortMediaCapability(unit, port, &media_cap);

       #if (SYS_CPNT_SUPPORT_COMBO_PORT_NO_NEG_KEEP == TRUE)
                if ((media_cap & STKTPLG_TYPE_PORT_MEDIA_CAP_COPPER) && (media_cap & STKTPLG_TYPE_PORT_MEDIA_CAP_FIBER))
                {
                    if (is_provision_complete == FALSE)
                    {
                        port_info[ifindex-1].port_entry.port_combo_copper_speed_dpx_cfg = SYS_DFLT_GE_COPPER_PORT_FORCE_MODE_SPDDPX;
                        port_info[ifindex-1].port_entry.port_combo_fiber_speed_dpx_cfg = SYS_DFLT_GE_FIBER_PORT_FORCE_MODE_SPDDPX;
                        port_info[ifindex-1].port_entry.port_speed_dpx_cfg = SYS_DFLT_GE_COPPER_PORT_FORCE_MODE_SPDDPX;
                    }
                    else
                    {
                        if (port_info[ifindex-1].port_entry.port_type == VAL_portType_thousandBaseT)
                            port_info[ifindex-1].port_entry.port_speed_dpx_cfg = port_info[ifindex-1].port_entry.port_combo_copper_speed_dpx_cfg;
                        else
                            port_info[ifindex-1].port_entry.port_speed_dpx_cfg = port_info[ifindex-1].port_entry.port_combo_fiber_speed_dpx_cfg;
                    }

                }
                else
                {
                    port_info[ifindex-1].port_entry.port_speed_dpx_cfg = SYS_DFLT_GE_COPPER_PORT_FORCE_MODE_SPDDPX;
                    port_info[ifindex-1].port_entry.port_combo_copper_speed_dpx_cfg = SYS_DFLT_GE_COPPER_PORT_FORCE_MODE_SPDDPX;
                }
       #else
                    port_info[ifindex-1].port_entry.port_speed_dpx_cfg = SYS_DFLT_GE_COPPER_PORT_FORCE_MODE_SPDDPX;
       #endif
            }

            /* 1000 base-T force configure mode
             */
   #if (SYS_CPNT_SUPPORT_FORCED_1000BASE_T_MODE == TRUE)
            if (is_provision_complete == FALSE)
            {
                port_info[ifindex-1].port_entry.port_forced_1000t_mode = SYS_DFLT_FORCED_1000BASE_T_MASTER_SLAVE_MODE;
                port_info[ifindex-1].forced_1000t_mode = SYS_DFLT_FORCED_1000BASE_T_MASTER_SLAVE_MODE;
            }
   #endif

            /* port_flow_ctrl_cfg
             */
            port_info[ifindex-1].port_entry.port_flow_ctrl_cfg = SYS_DFLT_PORT_FLOW_CONTROL;

            /* port_autonegotiation
             */
            if (SWCTRL_IS_100FIBER (ifindex) || SWCTRL_IS_10GFIBER (ifindex) || SWCTRL_IS_40GFIBER (ifindex) )
            {
                /* Charles: Currently, the default values in SYS_DFLT.H is not port type dependent.
                 *          I patch here for 100 fiber port and wait for further instruction.
                 */
                port_info[ifindex-1].port_entry.port_autonegotiation = VAL_portAutonegotiation_disabled;
            }
            if (SWCTRL_IS_10GCOPPER (ifindex))
            {
                port_info[ifindex-1].port_entry.port_autonegotiation = VAL_portAutonegotiation_enabled;
            }
            else
            {
                /* Aaron add for combo port keep */
                UI32_T media_cap;
                STKTPLG_POM_GetPortMediaCapability(unit, port, &media_cap);

       #if (SYS_CPNT_SUPPORT_FORCED_1000BASE_T_MODE == TRUE && SYS_CPNT_SUPPORT_COMBO_PORT_NO_NEG_KEEP == TRUE)
                if ((media_cap & STKTPLG_TYPE_PORT_MEDIA_CAP_COPPER) && (media_cap & STKTPLG_TYPE_PORT_MEDIA_CAP_FIBER))
                {
                    if (is_provision_complete == FALSE)
                        port_info[ifindex-1].port_entry.port_autonegotiation = SYS_DFLT_PORT_AUTONEGOTIATION;
                    else
                        ; /* no reset the port_autonegotiation */
                }
                else
                    port_info[ifindex-1].port_entry.port_autonegotiation = SYS_DFLT_PORT_AUTONEGOTIATION;
       #else
                    port_info[ifindex-1].port_entry.port_autonegotiation = SYS_DFLT_PORT_AUTONEGOTIATION;
       #endif
            }

            /* port_speed_dpx_status
             */
            if(is_enter_master_mode == TRUE)
            {
                /* When SWCTRL enter master mode, all ports are admin shutdowned. The operation speed-duplex is unknown.
                 * So, setting the speed-duplex status here base on the port type is just for UIs to get and to show.
                 */
                if( port_type == VAL_portType_hundredBaseTX )                  /*FE_COPPER*/
                {
                    port_info[ifindex-1].port_entry.port_speed_dpx_status = VAL_portSpeedDpxCfg_fullDuplex100;
                }
                else if( port_type == VAL_portType_hundredBaseFX             || /*FE_FIBER*/
                         port_type == VAL_portType_hundredBaseFxScSingleMode ||
                         port_type == VAL_portType_hundredBaseFxScMultiMode  )
                {
                    port_info[ifindex-1].port_entry.port_speed_dpx_status = VAL_portSpeedDpxCfg_fullDuplex100;
                }
                else if( port_type == VAL_portType_thousandBaseSX   ||         /*GE_FIBER*/
                         port_type == VAL_portType_thousandBaseLX   ||
                         port_type == VAL_portType_thousandBaseGBIC ||
                         port_type == VAL_portType_thousandBaseSfp  )
                {
                    port_info[ifindex-1].port_entry.port_speed_dpx_status = VAL_portSpeedDpxCfg_fullDuplex1000;
                }
                else if( port_type == VAL_portType_fortyGBaseQSFP )        /* 40G Port */
                {
                    port_info[ifindex-1].port_entry.port_speed_dpx_status = VAL_portSpeedDpxStatus_fullDuplex40g;
                }
                else if( port_type == VAL_portType_tenG         ||
                         port_type == VAL_portType_tenGBaseXFP  ||
                         port_type == VAL_portType_tenGBaseSFP  )          /*10G Port*/
                {
                    port_info[ifindex-1].port_entry.port_speed_dpx_status = VAL_portSpeedDpxStatus_fullDuplex10g;
                }
                else if( port_type == VAL_portType_tenGBaseT )                     /*10G port*/
                {
                    port_info[ifindex-1].port_entry.port_speed_dpx_status = VAL_portSpeedDpxStatus_fullDuplex10g;
                }
                else                                                           /*GE_COPPER*/
                {
                    port_info[ifindex-1].port_entry.port_speed_dpx_status = VAL_portSpeedDpxCfg_fullDuplex1000;
                }
            }

            /* port_flow_ctrl_status
             */
            if(is_enter_master_mode == TRUE)
            {
                /* When SWCTRL enter master mode, all ports are admin shutdowned. The operation flowcontrol type is unknow.
                 * So, setting the flowcontrol type here is just for UIs to get and to show.
                 */
                port_info[ifindex-1].port_entry.port_flow_ctrl_status = VAL_portFlowCtrlStatus_none;
            }

            /* do something about auto-nego enable or auto-nego disable
             */
            if(port_info[ifindex-1].port_entry.port_autonegotiation == VAL_portAutonegotiation_enabled)
            {
                /* auto mode
                 */
                SWDRV_EnablePortAutoNeg(unit, port);

                /* auto-nego capabilities were set in chip, so, it's not necessary to set again.
                 */
            }
            else
            {
                /* force mode
                 */
                 SWDRV_DisablePortAutoNeg(unit, port);

                 /* force mode speed-duplex config
                  */
                 SWDRV_SetPortCfgSpeedDuplex(unit, port, port_info[ifindex-1].port_entry.port_speed_dpx_cfg);

                 if(is_enter_master_mode == FALSE)
                 {
                     /* flowcontrol state
                      */
                     SWDRV_SetPortCfgFlowCtrl(unit, port, port_info[ifindex-1].port_entry.port_flow_ctrl_cfg);
                 }
            }


            /* port_trunk_index
             */
            port_info[ifindex-1].port_entry.port_trunk_index = 0;

            /* link_change_trap
             */
            port_info[ifindex-1].link_change_trap = SYS_DFLT_IF_LINK_UP_DOWN_TRAP_ENABLE;

            if (is_enter_master_mode == TRUE)
            {
                /* port security
                 */
                SWCTRL_LOCK();
                port_info[ifindex-1].port_security_status                  = VAL_portSecPortStatus_disabled;
                port_info[ifindex-1].port_security_action_status           = VAL_portSecAction_none;
                port_info[ifindex-1].port_security_action_trap_oper_status = VAL_portSecAction_none;
                port_info[ifindex-1].port_security_action_trap_time_stamp  = 0;

                ports_default1[byte] |= ((0x01) << (7 - shift));
                SWCTRL_UNLOCK();
            }

    }
    if (is_enter_master_mode == TRUE)
    {
       /* disable port security */
       SWDRV_DisablePortListSecurity (ports_default1);
       /* set default violation action to chip */
       SWDRV_PortListSecurityActionNone (ports_default1);
    }
}


    {
        UI8_T   ports_MulticastStormControlThreshold[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST];

           memset(ports_default1,0,sizeof(ports_default1));
           memset(ports_default2,0,sizeof(ports_default2));
           memset(ports_MulticastStormControlThreshold,0,sizeof(ports_MulticastStormControlThreshold));

           for(ifindex =  start_ifindex;ifindex <= end_ifindex; ifindex ++)
           {
               if (STKTPLG_PORT_TYPE_STACKING == port_info[ifindex-1].port_entry.port_type  ||
                    STKTPLG_PORT_TYPE_NOT_EXIST == port_info[ifindex-1].port_entry.port_type )
                {
                    port_info[ifindex-1].link_oper_status = VAL_ifOperStatus_notPresent;
                    continue;
                }
             port_type =port_info[ifindex-1].port_entry.port_type;
             unit = SWCTRL_IFINDEX_TO_UNIT(ifindex);
             port = SWCTRL_IFINDEX_TO_PORT(ifindex);
             SWCTRL_GetPosition(ifindex, &byte, &shift);
             SWCTRL_LOCK();
             port_info[ifindex-1].mcast_storm_entry.mcast_storm_status = SYS_DFLT_MCAST_STORM_STATUS;
             if (port_info[ifindex-1].mcast_storm_entry.mcast_storm_status == VAL_mcastStormStatus_enabled)
             {
                 ports_default1[byte] |= ((0x01) << (7 - shift));
             }
             else
             {
                 ports_default2[byte] |= ((0x01) << (7 - shift));
             }
             port_info[ifindex-1].mcast_storm_entry.mcast_storm_sample_type = SYS_DFLT_MSTORM_TYPE;

             if (port_info[ifindex-1].mcast_storm_entry.mcast_storm_sample_type == VAL_mcastStormSampleType_pkt_rate)
             {
                 port_info[ifindex-1].mcast_storm_entry.mcast_storm_pkt_rate = SYS_DFLT_MSTORM_RATE_LIMIT;
             }
             else if (port_info[ifindex-1].mcast_storm_entry.mcast_storm_sample_type == VAL_mcastStormSampleType_octet_rate)
             {
                 port_info[ifindex-1].mcast_storm_entry.mcast_storm_octet_rate = SYS_DFLT_MSTORM_RATE_LIMIT;
             }
             else
             {
                 port_info[ifindex-1].mcast_storm_entry.mcast_storm_percent = SYS_DFLT_MSTORM_RATE_LIMIT;
             }

             if (port_info[ifindex-1].mcast_storm_entry.mcast_storm_status == VAL_mcastStormStatus_enabled)
             {
                 ports_MulticastStormControlThreshold[byte] |= ((0x01) << (7 - shift));
             }
             SWCTRL_UNLOCK();
          }

          SWDRV_EnablePortListMulticastStormControl (ports_default1);
          SWDRV_DisablePortListMulticastStormControl (ports_default2);
          SWDRV_SetPortListMulticastStormControlThreshold (ports_MulticastStormControlThreshold, SYS_DFLT_MSTORM_RATE_LIMIT, SYS_DFLT_MCAST_STORM_MODE);
    }



    /* Enable Multicast Storm will impact IGMP function
     */


    /* broadcast sotrm control
     */
    {
        UI8_T   ports_BcastStormControlThreshold[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST];

           memset(ports_default1,0,sizeof(ports_default1));
           memset(ports_default2,0,sizeof(ports_default2));
           memset(ports_BcastStormControlThreshold,0,sizeof(ports_BcastStormControlThreshold));

           for(ifindex =  start_ifindex;ifindex <= end_ifindex; ifindex ++)
           {
               if (STKTPLG_PORT_TYPE_STACKING == port_info[ifindex-1].port_entry.port_type  ||
                    STKTPLG_PORT_TYPE_NOT_EXIST == port_info[ifindex-1].port_entry.port_type )
                {
                    port_info[ifindex-1].link_oper_status = VAL_ifOperStatus_notPresent;
                    continue;
                }

            port_type =port_info[ifindex-1].port_entry.port_type;
             SWCTRL_GetPosition(ifindex, &byte, &shift);
             SWCTRL_LOCK();
             port_info[ifindex-1].bcast_storm_entry.bcast_storm_status = SYS_DFLT_BCAST_STORM_STATUS;
             if (port_info[ifindex-1].bcast_storm_entry.bcast_storm_status == VAL_bcastStormStatus_enabled)
             {
                 ports_default1[byte] |= ((0x01) << (7 - shift));
             }
             else
             {
                 ports_default2[byte] |= ((0x01) << (7 - shift));
             }
             port_info[ifindex-1].bcast_storm_entry.bcast_storm_sample_type = SYS_DFLT_BSTORM_TYPE;

             if (port_info[ifindex-1].bcast_storm_entry.bcast_storm_sample_type == VAL_bcastStormSampleType_pkt_rate)
             {
                 port_info[ifindex-1].bcast_storm_entry.bcast_storm_pkt_rate = SYS_DFLT_BSTORM_RATE_LIMIT;
             }
             else if (port_info[ifindex-1].bcast_storm_entry.bcast_storm_sample_type == VAL_bcastStormSampleType_octet_rate)
             {
                 port_info[ifindex-1].bcast_storm_entry.bcast_storm_octet_rate = SYS_DFLT_BSTORM_RATE_LIMIT;
             }
             else
             {
                 port_info[ifindex-1].bcast_storm_entry.bcast_storm_percent = SYS_DFLT_BSTORM_RATE_LIMIT;
             }

             if (port_info[ifindex-1].bcast_storm_entry.bcast_storm_status == VAL_bcastStormStatus_enabled)
             {
                //printf("bcast_storm_status if %d,%x byte %d \n",ifindex,ports_BcastStormControlThreshold[byte],byte);
                ports_BcastStormControlThreshold[byte] |= ((0x01) << (7 - shift));
             }
             SWCTRL_UNLOCK();
          }

          SWDRV_EnablePortListBroadcastStormControl (ports_default1);
          SWDRV_DisablePortListBroadcastStormControl (ports_default2);
          SWDRV_SetPortListBroadcastStormControlThreshold (ports_BcastStormControlThreshold, SYS_DFLT_BSTORM_RATE_LIMIT, SYS_DFLT_BCAST_STORM_MODE);
    }


#if (SYS_CPNT_INGRESS_RATE_LIMIT == TRUE)
    /* ingress rate limit
     */
    {
        UI8_T   ingress_fe_rate_limit[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST];
        UI8_T   ingress_10ge_rate_limit[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST];
        UI8_T   ingress_40ge_rate_limit[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST];
        UI8_T   ingress_ge_rate_limit[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST];

        memset(ports_default1,0,sizeof(ports_default1));
        memset(ports_default2,0,sizeof(ports_default2));
        memset(ingress_fe_rate_limit,0,sizeof(ingress_fe_rate_limit));
        memset(ingress_10ge_rate_limit,0,sizeof(ingress_10ge_rate_limit));
        memset(ingress_40ge_rate_limit,0,sizeof(ingress_40ge_rate_limit));
        memset(ingress_ge_rate_limit,0,sizeof(ingress_ge_rate_limit));

        for(ifindex =  start_ifindex;ifindex <= end_ifindex; ifindex ++)
        {
            if (STKTPLG_PORT_TYPE_STACKING == port_info[ifindex-1].port_entry.port_type  ||
                 STKTPLG_PORT_TYPE_NOT_EXIST == port_info[ifindex-1].port_entry.port_type )
            {
                port_info[ifindex-1].link_oper_status = VAL_ifOperStatus_notPresent;
                continue;
            }
            port_type =port_info[ifindex-1].port_entry.port_type;
            unit = SWCTRL_IFINDEX_TO_UNIT(ifindex);
            port = SWCTRL_IFINDEX_TO_PORT(ifindex);
            SWCTRL_GetPosition(ifindex, &byte, &shift);
            SWCTRL_LOCK();
            port_info[ifindex-1].ingress_rate_limit_status = SYS_DFLT_INGRESS_RATE_LIMIT_STATUS;

            if( SWCTRL_IS_100TX(ifindex) || SWCTRL_IS_100FIBER(ifindex)  )
            {
                port_info[ifindex-1].ingress_rate_limit = SYS_DFLT_FE_INGRESS_RATE_LIMIT;
                ingress_fe_rate_limit[byte] |= ((0x01) << (7 - shift));
            }
            else if( SWCTRL_IS_1000T(ifindex) || SWCTRL_IS_1000FIBER(ifindex) )
            {
                port_info[ifindex-1].ingress_rate_limit = SYS_DFLT_GE_INGRESS_RATE_LIMIT;
                ingress_ge_rate_limit[byte] |= ((0x01) << (7 - shift));
            }
            else if( SWCTRL_IS_10GFIBER(ifindex) || SWCTRL_IS_10GCOPPER(ifindex) )
            {
                port_info[ifindex-1].ingress_rate_limit = SYS_DFLT_10GE_INGRESS_RATE_LIMIT;
                ingress_10ge_rate_limit[byte] |= ((0x01) << (7 - shift));
            }
            else /* if( SWCTRL_IS_40GFIBER(ifindex) ) */
            {
                port_info[ifindex-1].ingress_rate_limit = SYS_DFLT_40GE_INGRESS_RATE_LIMIT;
                ingress_40ge_rate_limit[byte] |= ((0x01) << (7 - shift));
            }

            if (port_info[ifindex-1].ingress_rate_limit_status == TRUE)
            {
                ports_default1[byte] |= ((0x01) << (7 - shift));
            }
            else
            {
                ports_default2[byte] |= ((0x01) << (7 - shift));
            }

            SWCTRL_UNLOCK();
        }

        SWDRV_SetPortListIngressRateLimit (ingress_fe_rate_limit, SYS_DFLT_FE_INGRESS_RATE_LIMIT);
        SWDRV_SetPortListIngressRateLimit (ingress_ge_rate_limit, SYS_DFLT_GE_INGRESS_RATE_LIMIT);
        SWDRV_SetPortListIngressRateLimit (ingress_10ge_rate_limit, SYS_DFLT_10GE_INGRESS_RATE_LIMIT);
        SWDRV_SetPortListIngressRateLimit (ingress_40ge_rate_limit, SYS_DFLT_40GE_INGRESS_RATE_LIMIT);

        SWDRV_EnablePortListIngressRateLimit (ports_default1);
        SWDRV_DisablePortListIngressRateLimit (ports_default2);

    }

#endif

#if (SYS_CPNT_EGRESS_RATE_LIMIT == TRUE)
    /* egress rate limit
     */
    {
        UI8_T   egress_fe_rate_limit[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST];
        UI8_T   egress_10ge_rate_limit[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST];
        UI8_T   egress_40ge_rate_limit[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST];
        UI8_T   egress_ge_rate_limit[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST];

        memset(ports_default1,0,sizeof(ports_default1));
        memset(ports_default2,0,sizeof(ports_default2));
        memset(egress_fe_rate_limit,0,sizeof(egress_fe_rate_limit));
        memset(egress_10ge_rate_limit,0,sizeof(egress_10ge_rate_limit));
        memset(egress_40ge_rate_limit,0,sizeof(egress_40ge_rate_limit));
        memset(egress_ge_rate_limit,0,sizeof(egress_ge_rate_limit));

        for(ifindex =  start_ifindex;ifindex <= end_ifindex; ifindex ++)
        {
            if (STKTPLG_PORT_TYPE_STACKING == port_info[ifindex-1].port_entry.port_type  ||
                 STKTPLG_PORT_TYPE_NOT_EXIST == port_info[ifindex-1].port_entry.port_type )
            {
                port_info[ifindex-1].link_oper_status = VAL_ifOperStatus_notPresent;
                continue;
            }
            port_type =port_info[ifindex-1].port_entry.port_type;
            unit = SWCTRL_IFINDEX_TO_UNIT(ifindex);
            port = SWCTRL_IFINDEX_TO_PORT(ifindex);
            SWCTRL_GetPosition(ifindex, &byte, &shift);
            /* egress rate limit
             */
            SWCTRL_LOCK();
            port_info[ifindex-1].egress_rate_limit_status = SYS_DFLT_EGRESS_RATE_LIMIT_STATUS;

            if( SWCTRL_IS_100TX(ifindex) || SWCTRL_IS_100FIBER(ifindex) )
            {
                port_info[ifindex-1].egress_rate_limit = SYS_DFLT_FE_EGRESS_RATE_LIMIT;
                egress_fe_rate_limit[byte] |= ((0x01) << (7 - shift));
            }
            else if( SWCTRL_IS_1000T(ifindex) || SWCTRL_IS_1000FIBER(ifindex) )
            {
                port_info[ifindex-1].egress_rate_limit = SYS_DFLT_GE_EGRESS_RATE_LIMIT;
                egress_ge_rate_limit[byte] |= ((0x01) << (7 - shift));
            }
            else if( SWCTRL_IS_10GFIBER(ifindex) || SWCTRL_IS_10GCOPPER(ifindex) )
            {
                port_info[ifindex-1].egress_rate_limit = SYS_DFLT_10GE_EGRESS_RATE_LIMIT;
                egress_10ge_rate_limit[byte] |= ((0x01) << (7 - shift));
            }
            else /* if( SWCTRL_IS_40GFIBER(ifindex) ) */
            {
                port_info[ifindex-1].egress_rate_limit = SYS_DFLT_40GE_EGRESS_RATE_LIMIT;
                egress_40ge_rate_limit[byte] |= ((0x01) << (7 - shift));
            }

            if (port_info[ifindex-1].egress_rate_limit_status == TRUE)
            {
                ports_default1[byte] |= ((0x01) << (7 - shift));
            }
            else
            {
                ports_default2[byte] |= ((0x01) << (7 - shift));
            }
            SWCTRL_UNLOCK();

        }
        SWDRV_SetPortListEgressRateLimit (egress_fe_rate_limit, SYS_DFLT_FE_EGRESS_RATE_LIMIT);
        SWDRV_SetPortListEgressRateLimit (egress_ge_rate_limit, SYS_DFLT_GE_EGRESS_RATE_LIMIT);
        SWDRV_SetPortListEgressRateLimit (egress_10ge_rate_limit, SYS_DFLT_10GE_EGRESS_RATE_LIMIT);
        SWDRV_SetPortListEgressRateLimit (egress_40ge_rate_limit, SYS_DFLT_40GE_EGRESS_RATE_LIMIT);
        SWDRV_EnablePortListEgressRateLimit (ports_default1);
        SWDRV_DisablePortListEgressRateLimit (ports_default2);
    }

#endif

     /* set egress scheduler mode
      */

{

               memset(ports_default1,0,sizeof(ports_default1));

               for(ifindex =  start_ifindex;ifindex <= end_ifindex; ifindex ++)
               {
                   if (STKTPLG_PORT_TYPE_STACKING == port_info[ifindex-1].port_entry.port_type  ||
                        STKTPLG_PORT_TYPE_NOT_EXIST == port_info[ifindex-1].port_entry.port_type )
                    {
                        port_info[ifindex-1].link_oper_status = VAL_ifOperStatus_notPresent;
                        continue;
                    }
                 port_type =port_info[ifindex-1].port_entry.port_type;
                 unit = SWCTRL_IFINDEX_TO_UNIT(ifindex);
                 port = SWCTRL_IFINDEX_TO_PORT(ifindex);
                 SWCTRL_GetPosition(ifindex, &byte, &shift);

                 ports_default1[byte] |= ((0x01) << (7 - shift));
                  SWCTRL_LOCK();
                 if (default_egress_scheduler_mode == SWCTRL_WEIGHT_ROUND_ROBIN_METHOD)
                 {
                     port_info[ifindex-1].egress_scheduler_method = SWCTRL_WEIGHT_ROUND_ROBIN_METHOD;
                     for (q_id=0; q_id<SYS_ADPT_MAX_NBR_OF_PRIORITY_QUEUE; q_id++)
                      {
                         port_info[ifindex-1].wrr_weight[q_id] = wrr_queue_default[q_id];
                      }
                 }
                 else
                 {
                     port_info[ifindex-1].egress_scheduler_method = SWCTRL_STRICT_PRIORITY_METHOD;

                 }
                 SWCTRL_UNLOCK();

                  /* set attributes to fixed value    */
                 SWCTRL_SetServerBladePortFixAttributes (unit, port);
                     /* link_oper_status_last_change    */
                 SWCTRL_UPDATE_LINK_OPER_STATUS_LAST_CHANGE_TIME(ifindex);

                 #if (SYS_CPNT_PORT_TRAFFIC_SEGMENTATION == TRUE)
                 #if (SYS_DFLT_TRAFFIC_SEG_METHOD == SYS_DFLT_TRAFFIC_SEG_METHOD_PORT_PRIVATE_MODE)
                     if(is_enter_master_mode == TRUE)
                     {
                         SWCTRL_LOCK();
                         port_info[ifindex-1].private_vlan_uplink_port = TRUE;
                         SWCTRL_UNLOCK();
                     }
                 #endif
                 #endif



                     /* these 4 database entries jsut for user port
                      */

                     {
                         SYS_TYPE_Uport_T    unit_port;

                         unit_port.unit = (UI16_T) unit;
                         unit_port.port = (UI16_T) port;

                         if (is_enter_master_mode == TRUE)
                         {
                             /* LACP_state
                              */
#if (SYS_CPNT_STATIC_TRUNK_CONFIG_ALLOWED_ON_LACP_PORT == TRUE)
                             /* From now on, LACP should tell SWCTRL admin/oper status, When LACP
                              * enter master mode, so, it's not necessary for SWCTRL to set this
                              * 2 variable: 1) lacp_admin_status, and 2) lacp_oper_status
                              */
#else
                             user_ext_port_info[ifindex-1].lacp_status = SYS_DFLT_PORT_LACP_PORT_STATUS;
#endif

                             /* Dot1x_state
                              */
                             user_ext_port_info[ifindex-1].dot1x_status = SWCTRL_DOT1X_PORT_DEFAULT_STATE;
                         }

                         /* mirroring
                          */
                         /* if analyzer => delete all entry
                          */
                         if(SWCTRL_IsAnalyzerPort(unit_port))
                         {
                             UI32_T src;

                             for(src = 1; src<=SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK*SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT; src++)
                             {
                                 SWCTRL_SetMirrorStatus(src, ifindex, VAL_mirrorStatus_invalid);
                             }
                         }
                         /* if monitored => delete all entry
                          */

                         if(SWCTRL_IsMonitoredPort(unit_port))
                         {
                             UI32_T dest;

                             for(dest = 1; dest <= SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK*SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT; dest++)
                             {
                                 SWCTRL_SetMirrorStatus(ifindex , dest, VAL_mirrorStatus_invalid);
                             }
                         }
                         user_ext_port_info[ifindex-1].mirroring_tx_dest_port = 0;
                         user_ext_port_info[ifindex-1].mirroring_rx_dest_port = 0;
                     }

             }
        if (default_egress_scheduler_mode == SWCTRL_WEIGHT_ROUND_ROBIN_METHOD)
         {

             SWDRV_SetPortListEgressSchedulingMethod(ports_default1, SWCTRL_WEIGHT_ROUND_ROBIN_METHOD);
              for (q_id=0; q_id<SYS_ADPT_MAX_NBR_OF_PRIORITY_QUEUE; q_id++)
              {
                 SWDRV_SetPortListWrrQueueWeight(ports_default1, q_id, wrr_queue_default[q_id]);

              }
         }
         else
         {

             SWDRV_SetPortListEgressSchedulingMethod(ports_default1, SWCTRL_STRICT_PRIORITY_METHOD);
         }


}

}
#endif

BOOL_T SWCTRL_IsAvailableConfiguredPort(UI32_T   ifindex)
{
    if (!SWCTRL_IS_EXIST(ifindex))
       return FALSE;

    /* SWCTRL_LPORT_TRUNK_PORT_MEMBER
     */
    if (SWCTRL_IS_TRUNK_MEMBER(ifindex))
       return FALSE;

    return TRUE;

}
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_IsManagementPort
 * -------------------------------------------------------------------------
 * FUNCTION: This function will check the ifindex is management port
 *           or not.
 * INPUT   : ifindex -- which ifindex port.
 * OUTPUT  : None
 * RETURN  : TRUE    -- is management port.
 *           FALSE   -- not management port.
 * NOTE    : None.
 * -------------------------------------------------------------------------
 */
BOOL_T SWCTRL_IsManagementPort(UI32_T ifindex)
{
#if (SYS_CPNT_MGMT_PORT == TRUE)
    UI32_T  port;
#endif

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

#if (SYS_CPNT_MGMT_PORT == TRUE)
    if (SWCTRL_IS_TRUNK(ifindex))
    {
        SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
    }
    else
    {
        port = SWCTRL_IFINDEX_TO_PORT(ifindex);

        if (port == SYS_ADPT_MGMT_PORT)
        {
            SWCTRL_RETURN_AND_RELEASE_CSC(TRUE);
        }
        else
        {
            SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
        }
    }
#endif

    SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);

}


#if (SYS_CPNT_SWCTRL_MDIX_CONFIG == TRUE)
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetUPortMDIXMode
 * -------------------------------------------------------------------------
 * FUNCTION: This function will set port MDIX mode.
 * INPUT   : unit           -- which unit
 *           port           -- which port to set
 *           mode           -- Mode to set.
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
static BOOL_T SWCTRL_SetUPortMDIXMode(UI32_T unit, UI32_T port, UI32_T mode)
{
    UI32_T ifindex;
    //UI32_T port_mode;
    BOOL_T retval = FALSE;
    //BOOL_T retval2 = FALSE;

    ifindex = SWCTRL_UPORT_TO_IFINDEX (unit, port);

    if (port_info[ifindex-1].port_entry.port_MDIX_mode == mode)
    {
        return TRUE;
    }

    /* When auto-negotiation is enabled and operation speed is 1000, do not accept user to configure the MDIX setting.
     * User only can set auto-MDIX.
     */
    if (SWCTRL_IS_OPER_UP(ifindex)
        && (port_info[ifindex-1].port_entry.port_speed_dpx_status == VAL_portSpeedDpxCfg_fullDuplex1000)
    )
    {
        if (mode != VAL_portMdixMode_auto)
        {
            return FALSE;
        }
    }


    return SWDRV_SetMDIXMode(unit, port, mode);
} /* End of SWCTRL_SetUPortMDIXMode () */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetMDIXMode
 * -------------------------------------------------------------------------
 * FUNCTION: This function will set port MDIX mode
 * INPUT   : ifindex     -- which port to set
 *           mode        -- which mode of media
 *                       - VAL_portMdixMode_auto                  1L
 *                       - VAL_portMdixMode_straight              2L
 *                       - VAL_portMdixMode_crossover             3L
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : For trunk port , mode can't setting
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetMDIXMode(UI32_T ifindex, UI32_T mode)
{
    UI32_T                       unit, port, i;
    UI32_T                       logical_port_ifindex;
    BOOL_T                       retval = FALSE;
    SWCTRL_TrunkPortExtInfo_T    trunk_ext_p_info;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (!SWCTRL_IS_LPORT(ifindex))
    {
        /*UIMSG_MGR_SetErrorCode(); */ /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (SWCTRL_IsManagementPort(ifindex) == TRUE)
    {
        EH_MGR_Handle_Exception1(SYS_MODULE_SWCTRL,
                                 SWCTRL_NO_USE_FUNC_NO,
                                 EH_TYPE_MSG_DEB_MSG,
                                 EH_MGR_FOR_DEBUG_MSG_PURPOSE | SYSLOG_LEVEL_ERR,
                                 "Interface is the management port.");
        SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
    }

    if (SWCTRL_IS_1000FIBER(ifindex) || SWCTRL_IS_10GFIBER(ifindex) || SWCTRL_IS_40GFIBER(ifindex))/* only support 10/100/1000 port*/
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (!SWCTRL_IS_TRUNK (ifindex))
    {
        unit = SWCTRL_IFINDEX_TO_UNIT(ifindex);
        port = SWCTRL_IFINDEX_TO_PORT(ifindex);
        if ((retval = SWCTRL_SetUPortMDIXMode(unit, port, mode)) == TRUE)
        {
            SWCTRL_LOCK();
            port_info[ifindex-1].MDIX_mode = mode;
            port_info[ifindex-1].port_entry.port_MDIX_mode = mode;
            SWCTRL_UNLOCK();

        }

    }
    else /* trunk */
    {
        retval = FALSE;

        /* trunk port
         */
       SWCTRL_GetTrunkPortExtInfo (ifindex, &trunk_ext_p_info);

        /* It only support 10/100M port */
        for(i = 0; i < trunk_ext_p_info.member_number; i++)
        {
            unit = (UI32_T) trunk_ext_p_info.member_list[i].unit;
            port = (UI32_T) trunk_ext_p_info.member_list[i].port;
            logical_port_ifindex = SWCTRL_UPORT_TO_IFINDEX (unit, port);
            if (!SWCTRL_IS_100TX(logical_port_ifindex))
            {
                SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
            }
        }

        for(i = 0; i < trunk_ext_p_info.member_number; i++)
        {
            unit = (UI32_T) trunk_ext_p_info.member_list[i].unit;
            port = (UI32_T) trunk_ext_p_info.member_list[i].port;

            if (!(retval = SWCTRL_SetUPortMDIXMode(unit, port, mode)))
                break;
        }

        /* The database maintained here is just for trunk.
         */
        if (retval)
        {
            SWCTRL_LOCK();
            port_info[ifindex-1].MDIX_mode = mode;
            port_info[ifindex-1].port_entry.port_MDIX_mode = mode;
            SWCTRL_UNLOCK();
        }
    } /* End of if (trunk) */

    SWCTRL_UPDATE_SYSTEM_LAST_CHANGE_TIME ();
    SWCTRL_RETURN_AND_RELEASE_CSC( retval );
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetMDIXMode
 * -------------------------------------------------------------------------
 * FUNCTION: This function will get port MDIX mode
 * INPUT   : ifindex       -- which port to get
 * OUTPUT  : mode    -- which mode of medium
 *                       - VAL_portMdixMode_auto                  1L
 *                       - VAL_portMdixMode_straight              2L
 *                       - VAL_portMdixMode_crossover             3L
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : For trunk port , mode can't getting
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_GetMDIXMode(UI32_T ifindex, UI32_T *mode)
{
    /* LOCAL VARIABLES
     */

    /* BODY
     */
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if ( ifindex == 0                          ||
         ifindex > SYS_ADPT_TOTAL_NBR_OF_LPORT )
    {
#if (SYS_CPNT_EH == TRUE)
        UI8_T buff[32] = {0};

        sprintf(buff, "Logical Port ID (1-%d)", SYS_ADPT_TOTAL_NBR_OF_LPORT);

        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  buff);  /*SWCTRL_ENO_OUT_OF_RANGE_LOGICAL_PORT_ID*/
#endif

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (!SWCTRL_IS_EXIST (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Interface");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    SWCTRL_LOCK();
    *mode = port_info[ifindex-1].port_entry.port_MDIX_mode;
    if (SWCTRL_BACKDOOR_IsDebugFlagOn (SWCTRL_BACKDOOR_DEBUG_FLAG_MDIX))
    {
        printf("\n\r Get  [ifindex = %2ld    ][mode = %d             ][Notify_MDIX]",ifindex,port_info[ifindex-1].MDIX_mode);
    }
    SWCTRL_UNLOCK();

    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
}

/*--------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetNextMDIXMode
 *---------------------------------------------------------------------------
 * PURPOSE:  This function will get next port and MDIX mode
 * INPUT   : ifindex   -- which port to get
 * OUTPUT  : ifindex   -- the next existing port
 *           mode   -- mode of the next port
 *                       - VAL_portMdixMode_auto                  1L
 *                       - VAL_portMdixMode_straight                2L
 *                       - VAL_portMdixMode_crossover             3L
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 *---------------------------------------------------------------------------*/
BOOL_T SWCTRL_GetNextMDIXMode(UI32_T *ifindex, UI32_T *mode)
{
    /* BODY
     */
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if( ifindex == 0 )
    {
        EH_MGR_Handle_Exception (SYS_MODULE_SWCTRL,
                                 SWCTRL_NO_USE_FUNC_NO,
                                 EH_TYPE_MSG_NULL_POINTER,
                                 EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_CRIT); /*SWCTRL_ENO_NULL_POINTER*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if( mode == 0 )
    {
        EH_MGR_Handle_Exception (SYS_MODULE_SWCTRL,
                                 SWCTRL_NO_USE_FUNC_NO,
                                 EH_TYPE_MSG_NULL_POINTER,
                                 EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_CRIT); /*SWCTRL_ENO_NULL_POINTER*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    while( ++(*ifindex) <= SYS_ADPT_TOTAL_NBR_OF_LPORT )
    {
        if (SWCTRL_IS_EXIST (*ifindex))
        {
            SWCTRL_RETURN_AND_RELEASE_CSC( SWCTRL_GetMDIXMode(*ifindex, mode) );
        }
    }

    SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
} /* End of SWCTRL_GetNextMDIXMode() */

/*------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetRunningMDIXMode
 *------------------------------------------------------------------------
 * FUNCTION: This function will get the port MDIX mode running config
 * INPUT   : ifindex       -- which port to get
 * OUTPUT  : mode    -- which mode of medium
 *                       - VAL_portMdixMode_auto                  1L
 *                       - VAL_portMdixMode_straight                2L
 *                       - VAL_portMdixMode_crossover             3L
 * RETURN  : SYS_TYPE_Get_Running_Cfg_T
 * NOTE    : None
 *------------------------------------------------------------------------*/
SYS_TYPE_Get_Running_Cfg_T SWCTRL_GetRunningMDIXMode(UI32_T ifindex, UI32_T *mode)
{
    /* LOCAL VARIABLES
     */

    /* BODY
     */
   SWCTRL_USE_CSC_CHECK_OPER_MODE(SYS_TYPE_GET_RUNNING_CFG_FAIL);

    if (mode == 0)
    {
        /*UIMSG_MGR_SetErrorCode(); */ /*SWCTRL_ENO_NULL_POINTER*/
        SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_FAIL );
    }
    if ( ifindex == 0 || ifindex > SYS_ADPT_TOTAL_NBR_OF_LPORT)
    {
        /*UIMSG_MGR_SetErrorCode(); */ /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/
        SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_FAIL );
    }

    if (SWCTRL_GetMDIXMode(ifindex, mode))
    {
       if ((*mode) != SYS_DFLT_MDIX_MODE)
            SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_SUCCESS );

       SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_NO_CHANGE );
    }

    /* Error code was set in SWCTRL_GetPortComboForcedMode(); */
    SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_FAIL );
}

/*------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetNextRunningMDIXMode
 *------------------------------------------------------------------------
 * FUNCTION: This function will get the port MDIX mode running config
 * INPUT   : ifindex       -- which port to get
 * OUTPUT  : ifindex   -- the next existing port
 *           mode   -- mode of the next port
 *                       - VAL_portMdixMode_auto                  1L
 *                       - VAL_portMdixMode_straight                2L
 *                       - VAL_portMdixMode_crossover             3L
 * RETURN  : SYS_TYPE_Get_Running_Cfg_T
 * NOTE    : None
 *------------------------------------------------------------------------*/
SYS_TYPE_Get_Running_Cfg_T SWCTRL_GetNextRunningMDIXMode(UI32_T *ifindex, UI32_T *mode)
{
    /* LOCAL VARIABLES
     */

    /* BODY
     */
    SWCTRL_USE_CSC_CHECK_OPER_MODE(SYS_TYPE_GET_RUNNING_CFG_FAIL);

    if((ifindex == 0) || (mode == 0))
    {
        EH_MGR_Handle_Exception (SYS_MODULE_SWCTRL,
                                 SWCTRL_NO_USE_FUNC_NO,
                                 EH_TYPE_MSG_NULL_POINTER,
                                 EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_CRIT); /*SWCTRL_ENO_NULL_POINTER*/

        SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_FAIL );
    }

    if(*ifindex > SYS_ADPT_TOTAL_NBR_OF_LPORT)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_FAIL );
    }

    if (SWCTRL_GetNextMDIXMode(ifindex, mode))
    {
       if ((*mode) != SYS_DFLT_MDIX_MODE)
       {
           SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_SUCCESS );
       }

       SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_NO_CHANGE );
    }

    /* Error code was set in SWCTRL_GetNextMDIXMode(); */
    SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_FAIL );
}
#endif

#if (SYS_CPNT_MAC_VLAN == TRUE)
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetMacVlanEntry
 * -------------------------------------------------------------------------
 * PURPOSE  : Set the MAC VLAN entry
 * INPUT    : mac_address   - only allow unitcast address
 *            vid           - the VLAN ID
 *                            the valid value is 1 ~ SYS_DFLT_DOT1QMAXVLANID
 *            priority      - the priority
 *                            the valid value is 0 ~ 7
 * OUTPUT   : None
 * RETURN   : TRUE/FALSE    - TRUE if successful;FALSE if failed
 * NOTES    : if SYS_CPNT_MAC_VLAN_WITH_PRIORITY == FALSE, it's recommanded
 *            that set input priority to 0.
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetMacVlanEntry(UI8_T *mac_address, UI8_T *mask, UI16_T vid, UI8_T priority)
{
    BOOL_T  retval = FALSE;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    SWCTRL_LOCK ();
    retval = SWDRV_SetMacVlanEntry(mac_address, mask, vid, priority);
    SWCTRL_UNLOCK ();

    SWCTRL_RETURN_AND_RELEASE_CSC(retval);
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_DeleteMacVlanEntry
 * -------------------------------------------------------------------------
 * PURPOSE  : Delete Mac Vlan entry
 * INPUT    : mac_address   - only allow unitcast address
 * OUTPUT   : None
 * RETURN   : TRUE/FALSE    - TRUE if successful;FALSE if failed
 * NOTES    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_DeleteMacVlanEntry(UI8_T *mac_address, UI8_T *mask)
{
    BOOL_T  retval = FALSE;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    SWCTRL_LOCK ();
    retval = SWDRV_DeleteMacVlanEntry(mac_address, mask);
    SWCTRL_UNLOCK ();

    SWCTRL_RETURN_AND_RELEASE_CSC(retval);
}
#endif /* end of #if (SYS_CPNT_MAC_VLAN == TRUE) */

#if (SYS_CPNT_DOT1X_EAPOL_PASS_THROUGH == TRUE)
/* -------------------------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetEapolFramePassThrough
 * -------------------------------------------------------------------------------------------
 * PURPOSE : To set EAPOL frames pass through (pass through means not trapped to CPU)
 * INPUT   : state (TRUE/FALSE)
 * OUTPUT  : None
 * RETURN  : TRUE
 * NOTE    : None
 * -------------------------------------------------------------------------------------------
 */
BOOL_T SWCTRL_SetEapolFramePassThrough(BOOL_T state)
{
    BOOL_T  retval = FALSE;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    retval = SWDRV_SetEapolFramePassThrough(state);

    SWCTRL_RETURN_AND_RELEASE_CSC(retval);
}
#endif /* #if (SYS_CPNT_DOT1X_EAPOL_PASS_THROUGH == TRUE) */

#if (SYS_CPNT_INGRESS_RATE_LIMIT == TRUE) || (SYS_CPNT_EGRESS_RATE_LIMIT == TRUE)
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_CheckRateLimitRange
 * -------------------------------------------------------------------------
 * FUNCTION: This function will validate the rate limit range
 * INPUT   : port_type -- port type
 *           rate      -- rate limit value
 * OUTPUT  : None
 * RETURN  : True: Successfully, FALSE: Failed
 * NOTE    : None
 * -------------------------------------------------------------------------*/
static BOOL_T SWCTRL_CheckRateLimitRange(UI32_T port_type, UI32_T rate)
{
    if (rate < SYS_ADPT_MIN_RATE_LIMIT * SYS_ADPT_UI_RATE_LIMIT_FACTOR)
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  "Ingress Rate Limit (1-1000 Mbps)");

        return FALSE;
    }

    if (rate > SYS_ADPT_MAX_RATE_LIMIT * SYS_ADPT_UI_RATE_LIMIT_FACTOR)
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_VALUE_OUT_OF_RANGE,
                                  SYSLOG_LEVEL_INFO,
                                  "Ingress Rate Limit (1-1000 Mbps)");

        return FALSE;
    }

#if 0 /* obsolete. don't check range by port type */
    if ( port_type == VAL_portType_thousandBaseT     ||
         port_type == VAL_portType_thousandBaseSX    ||
         port_type == VAL_portType_thousandBaseLX    ||
         port_type == VAL_portType_thousandBaseGBIC  ||
         port_type == VAL_portType_thousandBaseSfp   )
    {
        if ( rate > 1000000)  /* 1000k kbis */
        {
            EH_MGR_Handle_Exception2 (SYS_MODULE_SWCTRL,
                                      SWCTRL_NO_USE_FUNC_NO,
                                      EH_TYPE_MSG_MAX_ALLOW_RATE_LIMIT,
                                      SYSLOG_LEVEL_INFO,
                                      "1000 Mbps",
                                      "whose port type is 1000 Copper or 1000 Fiber");

            return FALSE;
        }
    }
    else if ( port_type == VAL_portType_fortyGBaseQSFP )
    {
        if ( rate > 40000000)  /* 40M kbis */
        {
            EH_MGR_Handle_Exception2 (SYS_MODULE_SWCTRL,
                                      SWCTRL_NO_USE_FUNC_NO,
                                      EH_TYPE_MSG_MAX_ALLOW_RATE_LIMIT,
                                      SYSLOG_LEVEL_INFO,
                                      "40 Gbps",
                                      "whose port type is 40G Copper or 40G Fiber");

            return FALSE;
        }
    }
    else if ( port_type == VAL_portType_tenG        ||
              port_type == VAL_portType_tenGBaseT   ||
              port_type == VAL_portType_tenGBaseXFP ||
              port_type == VAL_portType_tenGBaseSFP)
    {
        if ( rate > 10000000)  /* 10M kbis */
        {
            EH_MGR_Handle_Exception2 (SYS_MODULE_SWCTRL,
                                      SWCTRL_NO_USE_FUNC_NO,
                                      EH_TYPE_MSG_MAX_ALLOW_RATE_LIMIT,
                                      SYSLOG_LEVEL_INFO,
                                      "10 Gbps",
                                      "whose port type is 10G Copper or 10G Fiber");

            return FALSE;
        }
    }
    else
    {
        if (rate > 100000)    /* 100k kbits */
        {
            EH_MGR_Handle_Exception2 (SYS_MODULE_SWCTRL,
                                      SWCTRL_NO_USE_FUNC_NO,
                                      EH_TYPE_MSG_MAX_ALLOW_RATE_LIMIT,
                                      SYSLOG_LEVEL_INFO,
                                      "100 Mbps",
                                      "whose port type is 100 Copper or 100 Fiber");

            return FALSE;
        }
    }
#endif /* obsolete. don't check range by port type */

    return TRUE;
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_ConvertUserRateLimitToPhy
 * -------------------------------------------------------------------------
 * FUNCTION: This function will convert user rate limit to phyicals
 *           port
 * INPUT   : port_type  -- port type
 *           rate       -- rate limit value
 * OUTPUT  : None
 * RETURN  : rate limit
 * NOTE    : None
 * -------------------------------------------------------------------------*/
static UI32_T SWCTRL_ConvertUserRateLimitToPhy(UI32_T port_type, UI32_T rate)
{
    if (rate == 0)
    {
        rate = SWCTRL_GetDefaultRateLimit(port_type);
    }

    if( port_type == VAL_portType_thousandBaseT    ||
        port_type == VAL_portType_thousandBaseSX   ||
        port_type == VAL_portType_thousandBaseLX   ||
        port_type == VAL_portType_thousandBaseGBIC ||
        port_type == VAL_portType_thousandBaseSfp  ||
        port_type == VAL_portType_tenG)
    {
#ifdef SYS_ADPT_PACKETCELL_INTERVAL
        rate = (rate / SYS_ADPT_PACKETCELL_INTERVAL) * SYS_ADPT_PACKETCELL_INTERVAL;
#elif defined(SYS_ADPT_PACKETCELL_RESOLUTION)
        rate = (rate / SYS_ADPT_PACKETCELL_RESOLUTION) * SYS_ADPT_PACKETCELL_RESOLUTION;
#elif defined(MARVELL)
        rate = (rate / 64) * 64;
#elif defined(STRATA_SWITCH)
        rate = (rate / 8000) * 8000;
#elif defined(XGS_SWITCH)
        rate = (rate / 1000) * 1000;
#endif
    }

    return rate;
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetDefaultRateLimit
 * -------------------------------------------------------------------------
 * FUNCTION: This function will get default rate limit
 * INPUT   : port_type
 * OUTPUT  : None
 * RETURN  : rate limit
 * NOTE    : None
 * -------------------------------------------------------------------------*/
static UI32_T SWCTRL_GetDefaultRateLimit(UI32_T port_type)
{
    UI32_T default_rate = 0;

    /* suppose default ingress rate is equal to egress rate
     *
     */
    if (SWCTRL_IS_FE_FAMILY_PORT_TYPE(port_type))
    {
        default_rate = SYS_DFLT_FE_INGRESS_RATE_LIMIT;
    }
    else if (SWCTRL_IS_10GE_FAMILY_PORT_TYPE(port_type))
    {
        default_rate = SYS_DFLT_10GE_INGRESS_RATE_LIMIT;
    }
#ifdef SYS_DFLT_25GE_INGRESS_RATE_LIMIT
    else if (SWCTRL_IS_25GE_FAMILY_PORT_TYPE(port_type))
    {
        default_rate = SYS_DFLT_25GE_INGRESS_RATE_LIMIT;
    }
#endif
    else if (SWCTRL_IS_40GE_FAMILY_PORT_TYPE(port_type))
    {
        default_rate = SYS_DFLT_40GE_INGRESS_RATE_LIMIT;
    }
#ifdef SYS_DFLT_100GE_INGRESS_RATE_LIMIT
    else if (SWCTRL_IS_100GE_FAMILY_PORT_TYPE(port_type))
    {
        default_rate = SYS_DFLT_100GE_INGRESS_RATE_LIMIT;
    }
#endif
    else /* if (SWCTRL_IS_GE_FAMILY_PORT_TYPE(port_type)) */
    {
        default_rate = SYS_DFLT_GE_INGRESS_RATE_LIMIT;
    }

    return default_rate;
}
#endif /* (SYS_CPNT_INGRESS_RATE_LIMIT == TRUE) || (SYS_CPNT_EGRESS_RATE_LIMIT == TRUE) */

#if (SYS_CPNT_INGRESS_RATE_LIMIT == TRUE)

#if (SYS_CPNT_NETACCESS_DYNAMIC_QOS == TRUE)

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_LocalSetDynamicPortIngressRateLimit
 * -------------------------------------------------------------------------
 * FUNCTION: This function will set the port ingress rate limit for dynamic qos
 * INPUT   : ifindex -- which port to set
 *           rate -- port ingress rate limit
 * OUTPUT  : None
 * RETURN  : True: Successfully, FALSE: Failed
 * NOTE    : 1. Unit of rate limit is kbits.
 *           2. When apply dynamic port ingress rate limit, the user configured
 *              setting should be saved.
 *           3. The ingress rate limit satus should be enabled, if this function
 *              successed.
 *           4. If rate is 0, restore the dynamic rate limit to user configured.
 * -------------------------------------------------------------------------*/
static BOOL_T SWCTRL_LocalSetDynamicPortIngressRateLimit(UI32_T ifindex, UI32_T rate)
{
    enum {RESTORE_TO_MANUAL_CONFIG = 0};

    UI32_T unit, port, trunk_id;
    UI32_T ingress_rate_limit_status;
    BOOL_T retval;

    if (rate == RESTORE_TO_MANUAL_CONFIG)
    {
        if (port_info[ifindex-1].ingress_rate_limit_dynamic_cfg == FALSE)
        {
            return TRUE;
        }
    }
    else
    {
        /* range check : lowest number is 1000 for FE and 8000 for GE for BroadCom chip.
         *               8 level from 1 to 8 for ACD chip.
         */
        if (SWCTRL_CheckRateLimitRange(port_info[ifindex-1].port_entry.port_type, rate) == FALSE)
            SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );

        /* The original setting is the same caller wish
         */
        if (port_info[ifindex-1].ingress_rate_limit_dynamic_cfg == TRUE)
        {
            if(     (port_info[ifindex-1].ingress_rate_limit_status == VAL_rlPortInputStatus_enabled)
                &&  (port_info[ifindex-1].ingress_rate_limit == rate )
              )
            {
                return TRUE;
            }
        }
    }

    SWCTRL_LogicalPortToUserPort(ifindex, &unit, &port, &trunk_id);
    /*unit = SWCTRL_IFINDEX_TO_UNIT(ifindex);
    port = SWCTRL_IFINDEX_TO_PORT(ifindex);
    */

    if (rate == RESTORE_TO_MANUAL_CONFIG)
    {
        if (port_info[ifindex-1].ingress_rate_limit_status_user_cfg == VAL_rlPortInputStatus_enabled)
            retval = SWDRV_EnablePortIngressRateLimit(unit, port);
        else
            retval = SWDRV_DisablePortIngressRateLimit(unit, port, trunk_id);

        retval &= SWDRV_SetPortIngressRateLimit(unit, port, trunk_id,
                    SWCTRL_ConvertUserRateLimitToPhy(port_info[ifindex-1].port_entry.port_type,
                        port_info[ifindex-1].ingress_rate_limit_user_cfg)
                    );
    }
    else
    {
        /* save the old rate limit status
         */
        ingress_rate_limit_status = port_info[ifindex-1].ingress_rate_limit_status;

    #if (SYS_CPNT_INGRESS_RATELIMIT_BSTORM_MSTORM_XOR_EACH_OTHER == TRUE)
        if (FALSE == SWCTRL_DisableAllRateLimitAndStormsStatus(ifindex))
        {
            SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
        }
    #endif

        retval =  SWDRV_EnablePortIngressRateLimit(unit, port);
        retval &= SWDRV_SetPortIngressRateLimit(unit, port, trunk_id,
                        SWCTRL_ConvertUserRateLimitToPhy(port_info[ifindex-1].port_entry.port_type, rate)
                        );
    }

    if (retval == FALSE)
    {
        return FALSE;
    }

    if (rate == RESTORE_TO_MANUAL_CONFIG)
    {
        port_info[ifindex-1].ingress_rate_limit_status =
        port_info[ifindex-1].ingress_rate_limit_status_user_cfg;
        port_info[ifindex-1].ingress_rate_limit =
        port_info[ifindex-1].ingress_rate_limit_user_cfg;

        port_info[ifindex-1].ingress_rate_limit_dynamic_cfg = FALSE;
    }
    else
    {
        /* backup ingress rate limit status and value
         */
        if(port_info[ifindex-1].ingress_rate_limit_dynamic_cfg == FALSE)
        {
            port_info[ifindex-1].ingress_rate_limit_status_user_cfg =
            /*port_info[ifindex-1].ingress_rate_limit_status*/ingress_rate_limit_status;
            port_info[ifindex-1].ingress_rate_limit_user_cfg =
            port_info[ifindex-1].ingress_rate_limit;

            port_info[ifindex-1].ingress_rate_limit_dynamic_cfg = TRUE;
        }

        port_info[ifindex-1].ingress_rate_limit_status = VAL_rlPortInputStatus_enabled;
        port_info[ifindex-1].ingress_rate_limit = rate;
    }

    return TRUE;
}

#endif /* #if (SYS_CPNT_NETACCESS_DYNAMIC_QOS == TRUE) */

#endif /* #if (SYS_CPNT_INGRESS_RATE_LIMIT == TRUE) */

#if (SYS_CPNT_POWER_SAVE == TRUE)
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetUPortPowerSave
 * -------------------------------------------------------------------------
 * FUNCTION: This function will set the port power saving status to driver
 *           and update oper status.
 * INPUT   : unit
 *           port
 *           status    - status to config
 *           is_forced - TRUE: config regardless of oper status
 *                       FALSE: do nothing if specified status == oper status
 * OUTPUT  : None
 * RETURN  : True: Successfully, False: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
static BOOL_T SWCTRL_SetUPortPowerSave(UI32_T unit, UI32_T port, UI32_T status, BOOL_T is_forced)
{
    UI32_T ifindex;
    BOOL_T drv_status;
    BOOL_T ret = TRUE;

    ifindex = SWCTRL_UPORT_TO_IFINDEX(unit, port);

    drv_status = status == VAL_portPowerSave_enabled;

    if (is_forced || user_ext_port_info[ifindex-1].power_save_oper_status != status)
    {
        /* driver might fail to enable and return FALSE
         * if current speed or cable length doesn't support power saving.
         * to make OM is consistent with chip config,
         * always disable it first then re-enable when oper is changed from enabled to enabled.
         */
        if (drv_status && user_ext_port_info[ifindex-1].power_save_oper_status == VAL_portPowerSave_enabled)
        {
            SWDRV_SetPortPowerSave(unit, port, FALSE);
        }

        ret = SWDRV_SetPortPowerSave(unit, port, drv_status);

        if (ret)
        {
            user_ext_port_info[ifindex-1].power_save_oper_status = status;
        }
        else
        {
            user_ext_port_info[ifindex-1].power_save_oper_status = VAL_portPowerSave_disabled;
        }

        user_ext_port_info[ifindex-1].power_save_speed_duplex = port_info[ifindex-1].port_entry.port_speed_dpx_status;
    }

    return ret;
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_PortPowerSaveDeferredCheck
 * -------------------------------------------------------------------------
 * FUNCTION: This function will check if need to disable power save or not
 *           when check_ticks expires.
 * INPUT   : ifindex
 * OUTPUT  : None
 * RETURN  : True: Successfully, False: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
static void SWCTRL_PortPowerSaveDeferredCheck(void *arg)
{
    BOOL_T *task_is_created_p = arg;
    UI32_T ifindex;
    UI32_T sys_tick;
    UI32_T wait_events = 0;
    UI32_T received_events = 0;
    UI32_T num_of_ports_to_check;
    void *timer_id;

    if ((timer_id = SYSFUN_PeriodicTimer_Create()) == NULL)
    {
        return;
    }

    SYSFUN_PeriodicTimer_Start(timer_id, SYS_BLD_TICKS_PER_SECOND, BIT_0);
    wait_events |= BIT_0;

    do
    {
        SYSFUN_ReceiveEvent(
            wait_events,
            SYSFUN_EVENT_WAIT_ANY,
            SYSFUN_TIMEOUT_WAIT_FOREVER,
            &received_events);

        if (SYSFUN_GET_CSC_OPERATING_MODE() != SYS_TYPE_STACKING_MASTER_MODE)
        {
            break;
        }

        sys_tick = SYSFUN_GetSysTick();
        num_of_ports_to_check = 0;

        /* NOTE:
         *   this lock/unlock is necessay for power_save_check_ticks.
         *   it maybe lead to performance issue if too many ports
         *   need to be checked.
         */
        SWCTRL_LOCK();

        for (ifindex = 1; ifindex <= SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK * SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT; ifindex++)
        {
            if (!SWCTRL_IS_EXIST(ifindex))
            {
                continue;
            }

            if (user_ext_port_info[ifindex-1].power_save_check_ticks == 0)
            {
                continue;
            }

            if (!L_MATH_TimeOut32(sys_tick, user_ext_port_info[ifindex-1].power_save_check_ticks))
            {
                num_of_ports_to_check++;
                continue;
            }

            if (!SWCTRL_IS_LINK_UP(ifindex))
            {
                if (user_ext_port_info[ifindex-1].power_save_admin_status == VAL_portPowerSave_enabled &&
                    user_ext_port_info[ifindex-1].power_save_oper_status == VAL_portPowerSave_enabled)
                {
                    SWCTRL_SetUPortPowerSave(SWCTRL_IFINDEX_TO_UNIT(ifindex), SWCTRL_IFINDEX_TO_PORT(ifindex), VAL_portPowerSave_disabled, TRUE);
                }
            }

            user_ext_port_info[ifindex-1].power_save_check_ticks = 0;
        }

        SWCTRL_UNLOCK();
    }
    while (num_of_ports_to_check > 0);

    SYSFUN_PeriodicTimer_Destroy(timer_id);

    SWCTRL_LOCK();
    *task_is_created_p = FALSE;
    SWCTRL_UNLOCK();
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_ProcessPortLinkDownForPowerSave
 * -------------------------------------------------------------------------
 * FUNCTION: This function will handle link down for power save
 * INPUT   : ifindex
 * OUTPUT  : None
 * RETURN  : True: Successfully, False: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
static BOOL_T SWCTRL_ProcessPortLinkDownForPowerSave(UI32_T ifindex)
{
    static BOOL_T task_is_created = FALSE;
    BOOL_T ret = TRUE;

    /* Some phy of link partner will re-autonego when power saving is enabled
     * It will lead to infinite looping of link-up-and-down.
     * So our solution is that after link-down, don't disable chip-level power saving right now.
     * After delay 5 sec(autonego done), if the interface can link up with power saving, don't disable it then.
     */
    SWCTRL_LOCK();

    user_ext_port_info[ifindex-1].power_save_check_ticks =
        SYSFUN_GetSysTick() + SYS_ADPT_POWER_SAVE_PHY_REAUTONEGO_TIME;

    if (!task_is_created)
    {
        UI32_T task_id;

        ret = SYSFUN_SpawnThread(
                SYS_BLD_PROCESS_DEFAULT_PRIORITY,
                SYS_BLD_PROCESS_DEFAULT_SCHED_POLICY,
                "PowerSave",
                SYS_BLD_TASK_COMMON_STACK_SIZE,
                SYSFUN_TASK_NO_FP,
                SWCTRL_PortPowerSaveDeferredCheck,
                &task_is_created,
                &task_id) == SYSFUN_OK;

        if (ret)
        {
            task_is_created = TRUE;
        }
    }

    SWCTRL_UNLOCK();

    return ret;
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_IsPortPowerSaveSupported
 * -------------------------------------------------------------------------
 * FUNCTION: This function will check if the port supports power save or not
 * INPUT   : ifindex
 * OUTPUT  : None
 * RETURN  : True: The port supports power save
 * NOTE    : None
 * -------------------------------------------------------------------------*/
static BOOL_T SWCTRL_IsPortPowerSaveSupported(UI32_T ifindex)
{
    if (!SWCTRL_IS_1000T(ifindex))
    {
        return FALSE;
    }

    return TRUE;
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetPortPowerSave
 * -------------------------------------------------------------------------
 * FUNCTION: This function will set the port power saving status
 * INPUT   : ifindex
 *           status  - VAL_portPowerSave_enabled
 *                     VAL_portPowerSave_disabled
 * OUTPUT  : None
 * RETURN  : True: Successfully, False: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetPortPowerSave(UI32_T ifindex, BOOL_T status)
{
    UI32_T unit, port;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (!SWCTRL_IS_USER_PORT(ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Interface");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (!SWCTRL_IS_EXIST (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Interface");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (!SWCTRL_IsPortPowerSaveSupported(ifindex))
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (user_ext_port_info[ifindex-1].power_save_admin_status == status)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
    }

    SWCTRL_LOCK();

    unit = SWCTRL_IFINDEX_TO_UNIT(ifindex);
    port = SWCTRL_IFINDEX_TO_PORT(ifindex);

    SWCTRL_SetUPortPowerSave(unit, port, status, FALSE);

    user_ext_port_info[ifindex-1].power_save_admin_status = status;

#if (SYS_CPNT_SWCTRL_PORT_PENDING_LINK_UP == TRUE)
    if (user_ext_port_info[ifindex-1].power_save_admin_status == VAL_portPowerSave_enabled)
    {
        port_info[ifindex-1].link_status_pending_up_status |= SWCTRL_PORT_PENDING_LINKUP_OWNER__POWER_SAVE;
    }
    else
    {
        port_info[ifindex-1].link_status_pending_up_status &= ~SWCTRL_PORT_PENDING_LINKUP_OWNER__POWER_SAVE;
    }
#endif

    SWCTRL_UNLOCK();

    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetPortPowerSaveStatus
 * -------------------------------------------------------------------------
 * FUNCTION: This function will get the port power saving status
 * INPUT   : ifindex
 * OUTPUT  : status  - VAL_portPowerSave_enabled
 *                     VAL_portPowerSave_disabled
 * RETURN  : True: Successfully, False: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_GetPortPowerSaveStatus(UI32_T ifindex, BOOL_T *status)
{
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (!SWCTRL_IS_USER_PORT(ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Interface");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (!SWCTRL_IS_EXIST (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Interface");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (!SWCTRL_IsPortPowerSaveSupported(ifindex))
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    *status = user_ext_port_info[ifindex-1].power_save_admin_status;

    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
}/* end of SWCTRL_GetPortPowerSaveStatus()*/

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetRunningPortPowerSaveStatus
 * -------------------------------------------------------------------------
 * FUNCTION: This function will get the port power saving status
 * INPUT   : ifindex
 * OUTPUT  : status  - VAL_portPowerSave_enabled
 *                     VAL_portPowerSave_disabled
 * RETURN  : SYS_TYPE_Get_Running_Cfg_T
 * NOTE    : None
 * -------------------------------------------------------------------------*/
SYS_TYPE_Get_Running_Cfg_T SWCTRL_GetRunningPortPowerSaveStatus(UI32_T ifindex, BOOL_T *status)
{
    SWCTRL_USE_CSC_CHECK_OPER_MODE(SYS_TYPE_GET_RUNNING_CFG_FAIL);

    if (!SWCTRL_IS_USER_PORT(ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Interface");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_FAIL );
    }

    if (!SWCTRL_IS_EXIST (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Interface");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_FAIL );
    }

    if (!SWCTRL_IsPortPowerSaveSupported(ifindex))
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_FAIL );
    }

    *status = user_ext_port_info[ifindex-1].power_save_admin_status;

    if (*status != SYS_DFLT_POWER_SAVE_STATUS)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_SUCCESS );
    }

    SWCTRL_RETURN_AND_RELEASE_CSC( SYS_TYPE_GET_RUNNING_CFG_NO_CHANGE );
}/* end of SWCTRL_GetRunningPortPowerSaveStatus()*/
#endif /* (SYS_CPNT_POWER_SAVE == TRUE) */

#if (SYS_CPNT_RSPAN == TRUE)
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_RspanSettingValidation
 * -------------------------------------------------------------------------
 * FUNCTION: Validate if the target port is a existed port or trunk (member).
 * INPUT   : target_port -- the port to get
 * OUTPUT  : None
 * RETURN  :
 * NOTE    : None
 * -------------------------------------------------------------------------
 */
BOOL_T SWCTRL_RspanSettingValidation ( UI8_T target_port )
{
   /* LACP enabled port can't be set port mirroring */
#if (SYS_CPNT_STATIC_TRUNK_CONFIG_ALLOWED_ON_LACP_PORT == TRUE)
    if (   user_ext_port_info[target_port-1].lacp_admin_status  == VAL_lacpPortStatus_enabled )
#else
    if (   user_ext_port_info[target_port-1].lacp_status  == VAL_lacpPortStatus_enabled )
#endif
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Set RSPAN for LACP enabled port");

        return FALSE;
    }

    /* RSPAN doesn't support Trunk. */
    if ( SWCTRL_IS_TRUNK_MEMBER(target_port))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_MIRROR_NOT_SUPPORT,
                                  SYSLOG_LEVEL_INFO,
                                  "RSPAN Port for Trunk member");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        return FALSE;
    }

    /* RSPAN port should exist and be a user port. */
    if (!SWCTRL_IS_USER_PORT(target_port)    ||
        !SWCTRL_IS_EXIST(target_port)        )
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Interface");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        return FALSE;
    }

    return TRUE;
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_ModifyMaxFrameSizeForRspan
 * -------------------------------------------------------------------------
 * FUNCTION: This function will modify maximum fram size of RSPAN
 * INPUT   : ifindex
 *           is_increase
 * OUTPUT  : None
 * RETURN  : TRUE/FALSE
 * NOTE    : None
 * -------------------------------------------------------------------------
 */
BOOL_T SWCTRL_ModifyMaxFrameSizeForRspan(UI32_T ifindex, BOOL_T is_increase)
{
    UI32_T unit, port;
    BOOL_T is_increase_to_set = is_increase;

    if (!SWCTRL_IS_LPORT(ifindex))
    {
        return FALSE;
    }

#if (SYS_CPNT_SWCTRL_MTU_CONFIG_MODE == SYS_CPNT_SWCTRL_MTU_PER_PORT )
    unit = SWCTRL_IFINDEX_TO_UNIT(ifindex);
    port = SWCTRL_IFINDEX_TO_PORT(ifindex);
#else
    /* restore max frame size only when all port are requested to disable
     * max frame size modification.
     */
    if (!is_increase)
    {
        UI32_T tmp_ifindex;

        for (tmp_ifindex = 1; tmp_ifindex <= SYS_ADPT_TOTAL_NBR_OF_LPORT; tmp_ifindex++)
        {
            if (tmp_ifindex == ifindex)
            {
                continue;
            }

            if (port_info[tmp_ifindex-1].rspan_frame_sz_is_modified)
            {
                is_increase_to_set = TRUE;
                break;
            }
        }
    }

    /* unit = 0 to specify driver layer to set all ports.
     */
    unit = 0;
    port = 0;
#endif

    if (!SWDRV_ModifyMaxFrameSize(unit, port, is_increase_to_set))
    {
        return FALSE;
    }

    SWCTRL_SyncUPortMaxFrameSize(unit, port);

    port_info[ifindex-1].rspan_frame_sz_is_modified = is_increase;

    return TRUE;
}
#endif  /* SYS_CPNT_RSPAN */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_TrapUnknownIpMcastToCPU
 * -------------------------------------------------------------------------
 * FUNCTION: This function will trap unknown ip multicast packet to CPU
 * INPUT   : to_cpu -- trap to cpu or not.
 *           flood  -- TRUE to flood to other ports; FLASE to discard the traffic.
 *           owner  -- who want the trap
 *           vid = 0 -- global setting, vid = else -- which VLAN ID to set
 * OUTPUT  : None
 * RETURN  : True: Successfully, False: If not available
 * NOTE    : to_cpu = 1 means trap to CPU
 *               to_cpu = 0 mans don't trap to CPU
 *               to_cpu = else means modify flood
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_TrapUnknownIpMcastToCPU(UI8_T to_cpu, BOOL_T flood, SWCTRL_TrapPktOwner_T owner, UI32_T vid)
{
    if (vid == 0)
{
    return SWCTRL_SetPktTrapStatus(SWCTRL_PKTTYPE_IPMC, owner, to_cpu, !flood);
}
    else
    {
        return SWDRV_TrapUnknownIpMcastToCPU(to_cpu, flood, vid);
    }
}

#if (SYS_CPNT_MLDSNP == TRUE)
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_TrapUnknownIpv6McastToCPU
 * -------------------------------------------------------------------------
 * FUNCTION: This function will trap unknown ipv6 multicast packet to CPU
 * INPUT   : to_cpu -- trap to cpu or not.
 *           flood  -- TRUE to flood to other ports; FLASE to discard the traffic.
 *           owner  -- who want the trap.
 * OUTPUT  : None
 * RETURN  : True: Successfully, False: If not available
 * NOTE    : to_cpu = 1 means trap to CPU
 *               to_cpu = 0 mans don't trap to CPU
 *               to_cpu = else means modify flood
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_TrapUnknownIpv6McastToCPU(UI8_T to_cpu, BOOL_T flood, SWCTRL_TrapPktOwner_T owner)
{
    return SWCTRL_SetPktTrapStatus(SWCTRL_PKTTYPE_IPMC6, owner, to_cpu, !flood);
}
#endif

#if (SYS_CPNT_MLDSNP == TRUE)
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_TrapIpv6PIMToCPU
 * -------------------------------------------------------------------------
 * FUNCTION: This function will trap ipv6 PIM packet to CPU
 * INPUT   : to_cpu -- trap to cpu or not.
 * OUTPUT  : None
 * RETURN  : True: Successfully, False: If not available
 * NOTE    :
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_TrapIpv6PIMToCPU(UI8_T to_cpu, SWCTRL_TrapPktOwner_T owner)
{
    BOOL_T status = FALSE;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    status = SWCTRL_SetPktTrapStatus(SWCTRL_PKTTYPE_PIM6, owner, to_cpu, to_cpu);

    if (status == FALSE)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
}
#endif

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_IsSupportedStormType
 * -------------------------------------------------------------------------
 * FUNCTION: This function will convert rate by specified mode.
 * INPUT   : mode
 * OUTPUT  : None
 * RETURN  : TRUE: the mode is supported; FALSE: not supported.
 * NOTE    : None
 * -------------------------------------------------------------------------*/
static BOOL_T SWCTRL_IsSupportedStormType(UI32_T mode)
{
#if (SYS_CPNT_SWCTRL_GLOBAL_STORM_SAMPLE_TYPE == TRUE)
    return (mode == swctrl_global_storm_sample_type);
#endif

    return (FALSE
        #if (SYS_CPNT_STORM_SAMPLE_TYPE_PACKET == TRUE)
        || mode == SWCTRL_STORM_SAMPLE_TYPE_PKT_RATE
        #endif
        #if (SYS_CPNT_STORM_SAMPLE_TYPE_OCTET == TRUE)
        || mode == SWCTRL_STORM_SAMPLE_TYPE_OCTET_RATE
        #endif
        #if (SYS_CPNT_STORM_SAMPLE_TYPE_PERCENT == TRUE)
        || mode == SWCTRL_STORM_SAMPLE_TYPE_PERCENT_RATE
        #endif
       );
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_ConvertRateByStormType
 * -------------------------------------------------------------------------
 * FUNCTION: This function will convert rate by specified mode.
 * INPUT   : ifindex
 *           in_mode    -- original mode
 *           in_rate    -- original rate
 *           out_mode   -- mode to convert
 * OUTPUT  : out_rate_p -- rate after conversion
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
static BOOL_T SWCTRL_ConvertRateByStormType(UI32_T ifindex, UI32_T in_mode, UI32_T in_rate, UI32_T out_mode, UI32_T *out_rate_p)
{
    UI32_T out_rate;
    UI32_T kbit_per_pkt;
    UI32_T max_kbit_rate, max_pkt_rate;

    if (SWCTRL_IS_100TX (ifindex) || SWCTRL_IS_100FIBER (ifindex))
    {
        max_kbit_rate = SWCTRL_100MB_PORT_MAX_RATE;
    }
    else if (SWCTRL_IS_1000T (ifindex) ||SWCTRL_IS_1000FIBER (ifindex))
    {
        max_kbit_rate = SWCTRL_1GB_PORT_MAX_RATE;
    }
    else if (SWCTRL_IS_10GSFP(ifindex) || SWCTRL_IS_10GCOPPER(ifindex))
    {
        max_kbit_rate = SWCTRL_10GB_PORT_MAX_RATE;
    }
    else /* 40G */
    {
        max_kbit_rate = SWCTRL_40GB_PORT_MAX_RATE;
    }

    kbit_per_pkt = SWCTRL_STORM_SAMPLE_TYPE_AVERAGE_BYTE_PER_PKT * 8 / 1000;
    max_pkt_rate = max_kbit_rate / kbit_per_pkt;

    if (in_mode == out_mode)
    {
        out_rate = in_rate;
    }
    else
    {
        if (out_mode == SWCTRL_STORM_SAMPLE_TYPE_PKT_RATE)
        {
            if (in_mode == SWCTRL_STORM_SAMPLE_TYPE_OCTET_RATE)
            {
                out_rate = in_rate / kbit_per_pkt;
            }
            else /* (in_mode == SWCTRL_STORM_SAMPLE_TYPE_PERCENT_RATE) */
            {
                out_rate =  max_pkt_rate / 100 * in_rate;
            }
            if (out_rate > max_pkt_rate)
            {
                out_rate = max_pkt_rate;
            }
#ifdef SYS_ADPT_PACKETCELL_INTERVAL
            else
            {
                out_rate = out_rate / SYS_ADPT_PACKETCELL_INTERVAL * SYS_ADPT_PACKETCELL_INTERVAL;
            }
#endif
        }
        else if (out_mode == SWCTRL_STORM_SAMPLE_TYPE_OCTET_RATE)
        {
            if (in_mode == SWCTRL_STORM_SAMPLE_TYPE_PKT_RATE)
            {
                out_rate = in_rate * kbit_per_pkt;
            }
            else /* (in_mode == SWCTRL_STORM_SAMPLE_TYPE_PERCENT_RATE) */
            {
                out_rate = max_kbit_rate / 100 * in_rate;
            }
            if (out_rate > max_kbit_rate)
            {
                out_rate = max_kbit_rate;
            }
#ifdef SYS_ADPT_PACKETCELL_INTERVAL
            else
            {
                out_rate = out_rate / SYS_ADPT_PACKETCELL_INTERVAL * SYS_ADPT_PACKETCELL_INTERVAL;
            }
#endif
        }
        else /* (out_mode == SWCTRL_STORM_SAMPLE_TYPE_PERCENT_RATE) */
        {
            if (in_mode == SWCTRL_STORM_SAMPLE_TYPE_PKT_RATE)
            {
                out_rate = in_rate / (max_pkt_rate / 100);
            }
            else /* (in_mode == SWCTRL_STORM_SAMPLE_TYPE_OCTET_RATE) */
            {
                out_rate = in_rate / (max_kbit_rate / 100);
            }
            if (out_rate > 100)
            {
                out_rate = 100;
            }
        }
    }

    *out_rate_p = out_rate;

    return TRUE;
}

#if 0 /* wakka: this API may be used for rate conversion in the future. */
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_ConvertRateByStormType
 * -------------------------------------------------------------------------
 * FUNCTION: This function will convert rate to most appropriate mode.
 * INPUT   : ifindex
 *           in_mode    -- original mode
 *           in_rate    -- original rate
 * OUTPUT  : out_mode   -- mode after conversion
 *           out_rate_p -- rate after conversion
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
static BOOL_T SWCTRL_AutoConvertRateWithStormType(UI32_T ifindex, UI32_T in_mode, UI32_T in_rate, UI32_T *out_mode_p, UI32_T *out_rate_p)
{
    UI32_T out_mode;

    out_mode = in_mode;

    if (SWCTRL_IsSupportedStormType(in_mode))
    {
        out_mode = in_mode;
    }
    else
    {
        #if (SYS_CPNT_STORM_SAMPLE_TYPE_PERCENT == TRUE)
        out_mode = SWCTRL_STORM_SAMPLE_TYPE_PERCENT_RATE;
        #endif
        #if (SYS_CPNT_STORM_SAMPLE_TYPE_PACKET == TRUE)
        out_mode = SWCTRL_STORM_SAMPLE_TYPE_PKT_RATE;
        #endif
        #if (SYS_CPNT_STORM_SAMPLE_TYPE_OCTET == TRUE)
        out_mode = SWCTRL_STORM_SAMPLE_TYPE_OCTET_RATE;
        #endif
    }

    if (!SWCTRL_ConvertRateByStormType(ifindex, in_mode, in_rate, out_mode, out_rate_p))
    {
        return FALSE;
    }

    *out_mode_p = out_mode;

    return TRUE;
}
#endif

#if (SYS_CPNT_SWCTRL_COMBO_PORT_CONFIG_KEEP==TRUE)
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_ReInitCfgComboPortChanged
 * -------------------------------------------------------------------------
 * FUNCTION: Re-init combo port config to set capability and speed to default value.
 *           and disable autonego for 100fiber and 10G fiber(currently assume they can
 *           not support autonego)
 * INPUT   : unit
 *           port
 * OUTPUT  : None
 * RETURN  : None
 * NOTE    :
 *           Because port type change for combo port. The capability and speed of
 *           copper and fiber are different.  If not call SWCTRL_ConfigUserPortToDefaultState(),
 *           must  handle capability and speed in this api. Otherwise port cfg will
 *           get error setting(ex:fiber use the speed of copper ).
 * -------------------------------------------------------------------------*/

static void SWCTRL_ReInitCfgComboPortChanged(UI32_T unit, UI32_T port)
{
#if (SWCTRL_UPDATE_PORT_ABILITY == TRUE)
    UI32_T ifindex = SWCTRL_UPORT_TO_IFINDEX(unit, port);
    SWCTRL_PortEntry_T *port_entry_p = &port_info[ifindex-1].port_entry;
    UI32_T org_flow_ctrl_cfg;
    UI32_T org_port_capabilities, check_port_capabilities;

    SWCTRL_LOCK();

    org_flow_ctrl_cfg = port_entry_p->port_flow_ctrl_cfg;
    org_port_capabilities = port_entry_p->port_capabilities;

    port_entry_p->port_speed_dpx_cfg = SWCTRL_GetPortCfgSpeedDuplexDfltCfg(unit, port);
    port_entry_p->port_flow_ctrl_cfg = SWCTRL_GetPortCfgFlowCtrlDfltCfg(unit, port);
    port_entry_p->port_capabilities = SWCTRL_GetPortAutoNegCapabilityDfltCfg(unit, port);
    port_entry_p->port_autonegotiation = SWCTRL_GetPortAutoNegStatusDfltCfg(unit, port);
#if (SYS_CPNT_SWCTRL_FEC == TRUE)
    user_ext_port_info[ifindex-1].port_fec_mode = SWCTRL_GetPortFecDfltCfg(unit, port);
    user_ext_port_info[ifindex-1].port_fec_status = VAL_portFecMode_disabled;
#endif

    /* preserve flow setting
     */
    if (SWCTRL_IsPortCfgFlowCtrlSupported(ifindex, org_flow_ctrl_cfg))
    {
        port_entry_p->port_flow_ctrl_cfg = org_flow_ctrl_cfg;
    }

    check_port_capabilities =
        (port_entry_p->port_capabilities &
            ~(SYS_VAL_portCapabilities_portCapFlowCtrl | SYS_VAL_portCapabilities_portCapSym)) |
        (org_port_capabilities &
            (SYS_VAL_portCapabilities_portCapFlowCtrl | SYS_VAL_portCapabilities_portCapSym));

    if (SWCTRL_IsPortAutoNegCapabilitySupported(ifindex, check_port_capabilities))
    {
        port_entry_p->port_capabilities = check_port_capabilities;
    }

    SWCTRL_UNLOCK();
#else /* (SWCTRL_UPDATE_PORT_ABILITY == TRUE) */
    UI32_T ifindex = SWCTRL_UPORT_TO_IFINDEX(unit, port);
    SWCTRL_PortEntry_T *cmbo_entry = &port_info[ifindex-1].port_entry;
    UI32_T port_type=cmbo_entry->port_type;

    SWCTRL_LOCK();

    /* 1.Handle the case of capability
     */
    if (port_type == VAL_portType_hundredBaseTX)       /*100 copper*/
    {
        cmbo_entry->port_capabilities = SYS_DFLT_10_100_PORT_CAPABILITIES;
    }
    else if (port_type == VAL_portType_hundredBaseFX             ||
             port_type == VAL_portType_hundredBaseFxScSingleMode ||
             port_type == VAL_portType_hundredBaseFxScMultiMode  )  /*100 fiber*/
    {
        cmbo_entry->port_capabilities = SYS_DFLT_100_FIBER_PORT_CAPABILITIES;
        cmbo_entry->port_autonegotiation = VAL_portAutonegotiation_disabled;
    }
    else if (port_type == VAL_portType_thousandBaseSX   ||
             port_type == VAL_portType_thousandBaseLX   ||
             port_type == VAL_portType_thousandBaseGBIC ||
             port_type == VAL_portType_thousandBaseSfp  )       /*1000 fiber*/
    {
        cmbo_entry->port_capabilities = SYS_DFLT_1000_FIBER_PORT_CAPABILITIES ;
    }
#ifdef SYS_DFLT_40G_FIBER_PORT_CAPABILITIES
    else if (port_type == VAL_portType_fortyGBaseQSFP)   /* 40G fiber */
    {
        cmbo_entry->port_capabilities = SYS_DFLT_40G_FIBER_PORT_CAPABILITIES;
        cmbo_entry->port_autonegotiation = VAL_portAutonegotiation_disabled;
    }
#endif
#ifdef SYS_DFLT_10G_FIBER_PORT_CAPABILITIES
    else if (port_type == VAL_portType_tenG             ||
             port_type == VAL_portType_tenGBaseXFP      ||
             port_type == VAL_portType_tenGBaseSFP      )   /*10G fiber*/
    {
        cmbo_entry->port_capabilities = SYS_DFLT_10G_FIBER_PORT_CAPABILITIES;
        cmbo_entry->port_autonegotiation = VAL_portAutonegotiation_disabled;
    }
#endif
#ifdef SYS_DFLT_10G_COPPER_PORT_CAPABILITIES
    /* 10G Copper */
    else if (port_type == VAL_portType_tenGBaseT)
    {
        cmbo_entry->port_capabilities = SYS_DFLT_10G_COPPER_PORT_CAPABILITIES;
        cmbo_entry->port_autonegotiation = VAL_portAutonegotiation_enabled;
    }
#endif
    else if (port_type = VAL_portType_thousandBaseT)
    {
        cmbo_entry->port_capabilities = SYS_DFLT_10_100_1000_PORT_CAPABILITIES ;
    }
    else
    {
        cmbo_entry->port_capabilities = 0;
        cmbo_entry->port_autonegotiation = VAL_portAutonegotiation_disabled;
    }

    /* 2.Handle the case of speed_dpx_cfg
      */
    if( port_type == VAL_portType_hundredBaseTX )   /*FE_COPPER*/
    {
        cmbo_entry->port_speed_dpx_cfg = SYS_DFLT_FE_COPPER_PORT_FORCE_MODE_SPDDPX;
    }
    else if( port_type == VAL_portType_hundredBaseFX             ||
             port_type == VAL_portType_hundredBaseFxScSingleMode ||
             port_type == VAL_portType_hundredBaseFxScMultiMode  )    /*FE_FIBER*/
    {
        cmbo_entry->port_speed_dpx_cfg = SYS_DFLT_FE_FIBER_PORT_FORCE_MODE_SPDDPX;
    }
    else if( port_type == VAL_portType_thousandBaseSX   ||
             port_type == VAL_portType_thousandBaseLX   ||
             port_type == VAL_portType_thousandBaseGBIC ||
             port_type == VAL_portType_thousandBaseSfp  )    /*GE_FIBER*/
    {
        cmbo_entry->port_speed_dpx_cfg = SYS_DFLT_GE_FIBER_PORT_FORCE_MODE_SPDDPX;

    }
#ifdef SYS_DFLT_40GE_FIBER_PORT_FORCE_MODE_SPDDPX
    else if( port_type == VAL_portType_fortyGBaseQSFP ) /* 40G Port */
    {
        cmbo_entry->port_speed_dpx_cfg = SYS_DFLT_40GE_FIBER_PORT_FORCE_MODE_SPDDPX;
    }
#endif
#ifdef SYS_DFLT_10GE_FIBER_PORT_FORCE_MODE_SPDDPX
    else if (port_type == VAL_portType_tenG             ||
             port_type == VAL_portType_tenGBaseXFP      ||
             port_type == VAL_portType_tenGBaseSFP      )   /*10G Port fiber*/
    {
        cmbo_entry->port_speed_dpx_cfg = SYS_DFLT_10GE_FIBER_PORT_FORCE_MODE_SPDDPX;
    }
#endif
#ifdef SYS_DFLT_10GE_COPPER_PORT_FORCE_MODE_SPDDPX
    else if( port_type == VAL_portType_tenGBaseT )          /*10G Port COPPER*/
    {
        cmbo_entry->port_speed_dpx_cfg = SYS_DFLT_10GE_COPPER_PORT_FORCE_MODE_SPDDPX;
    }
#endif
    else  /*GE_COPPER*/
        cmbo_entry->port_speed_dpx_cfg = SYS_DFLT_GE_COPPER_PORT_FORCE_MODE_SPDDPX;

    /* 3.Handle the case of flow_ctrl_cfg
      */
    cmbo_entry->port_flow_ctrl_cfg = SYS_DFLT_PORT_FLOW_CONTROL;

    SWCTRL_UNLOCK();
#endif /* (SWCTRL_UPDATE_PORT_ABILITY == TRUE) */
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_ReInitComboPortEntry
 * -------------------------------------------------------------------------
 * FUNCTION: Re-init combo port config
 * INPUT   : unit,
 *           port,
 *           port_type
 * OUTPUT  : None
 * RETURN  : None
 * NOTE    :
 *           Due to port type change for combo port. Speed and capibility is reset to
 *           to default. So need to call swdrv api. Or copper port maybe use fiber
 *           setting when port changed.
 *           This api is setting as below,
 *            1. nego,
 *            2. flow control,
 *            3. speed duplex.
 *            4. link_oper_status_last_change
 * -------------------------------------------------------------------------*/
static void SWCTRL_ReInitPhyComboPortChanged(UI32_T unit, UI32_T port, UI32_T port_type)
{
    UI32_T             ifindex;


    ifindex = SWCTRL_UPORT_TO_IFINDEX(unit, port);
    /* port_capabilities
      */
    /* Setting SWDRV_SetPortAutoNegCapability() will not make chip to run force or auto mode,
     * so, set this API here.
     */

    SWDRV_SetPortAutoNegCapability (unit, port, port_info[ifindex-1].port_entry.port_capabilities);

    if(port_info[ifindex-1].port_entry.port_autonegotiation == VAL_portAutonegotiation_enabled)
    {
        SWDRV_EnablePortAutoNeg(unit, port);
    }
    else
    {
         SWDRV_DisablePortAutoNeg(unit, port);  /* force mode*/
         /* force mode speed-duplex config
           */
         SWDRV_SetPortCfgSpeedDuplex(unit, port, port_info[ifindex-1].port_entry.port_speed_dpx_cfg);
         /* flowcontrol state
           */
         if(port_info[ifindex-1].port_entry.port_flow_ctrl_cfg == VAL_portFlowCtrlCfg_enabled )
         {
            SWDRV_EnablePortCfgFlowCtrl(unit, port);
         }
         else /* VAL_portFlowCtrlCfg_disable */
         {
            SWDRV_DisablePortCfgFlowCtrl(unit, port);
         }

#if (SYS_CPNT_SWCTRL_FEC == TRUE)
        SWDRV_SetPortFec(unit, port, user_ext_port_info[ifindex-1].port_fec_mode);
        SWDRV_GetPortFecStatus(unit, port, &user_ext_port_info[ifindex-1].port_fec_status);
#endif
    }

#if (SYS_CPNT_POWER_SAVE == TRUE)
    if (SWCTRL_IsPortPowerSaveSupported(ifindex))
    {
        user_ext_port_info[ifindex-1].power_save_admin_status = SYS_DFLT_POWER_SAVE_STATUS;
    }
    else
    {
        user_ext_port_info[ifindex-1].power_save_admin_status = VAL_portPowerSave_disabled;
    }
#if (SYS_CPNT_SWCTRL_PORT_PENDING_LINK_UP == TRUE)
    if (user_ext_port_info[ifindex-1].power_save_admin_status == VAL_portPowerSave_enabled)
    {
        port_info[ifindex-1].link_status_pending_up_status |= SWCTRL_PORT_PENDING_LINKUP_OWNER__POWER_SAVE;
    }
    else
    {
        port_info[ifindex-1].link_status_pending_up_status &= ~SWCTRL_PORT_PENDING_LINKUP_OWNER__POWER_SAVE;
    }
#endif
    {
        BOOL_T power_save_oper_status = user_ext_port_info[ifindex-1].power_save_admin_status;

        if (!SWCTRL_IS_LINK_UP(ifindex))
        {
            power_save_oper_status = VAL_portPowerSave_disabled;
        }

        SWCTRL_SetUPortPowerSave(unit, port, power_save_oper_status, TRUE);
    }
#endif
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_IsComboPort
 * -------------------------------------------------------------------------
 * FUNCTION: For check this port whether is combo port or not.
 * INPUT   : unit --  which unit
 *                port -- which port
 * OUTPUT  : None
 * RETURN  : If this port is combo port, return code is TRUE. Or return code is FALSE.
 * NOTE    :
 * -------------------------------------------------------------------------*/
static BOOL_T SWCTRL_IsComboPort(UI32_T unit, UI32_T port)
{
    return STKTPLG_OM_IsComboPort(unit, port);
}

#if (SYS_CPNT_COMBO_PORT_FORCE_MODE == TRUE)
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_ReInitPortComboForcedMode
 * -------------------------------------------------------------------------
 * FUNCTION: reinit combo force mode
 * INPUT   : unit --  which unit
 *           port -- which port
 * OUTPUT  : None
 * RETURN  : None
 * NOTE    :
 * -------------------------------------------------------------------------*/
static void SWCTRL_ReInitPortComboForcedMode(UI32_T unit, UI32_T port)
{
#if (SWCTRL_UPDATE_PORT_ABILITY == TRUE)
    UI32_T ifindex = SWCTRL_UPORT_TO_IFINDEX(unit, port);
    UI32_T forcedmode, fiber_speed;

    SWCTRL_GetPortComboForcedModeDfltCfg(unit, port, &forcedmode, &fiber_speed);

#if (SYS_CPNT_COMBO_PORT_FORCED_MODE_SFP_SPEED == TRUE)
    SWDRV_SetPortComboForcedMode(unit, port, forcedmode, fiber_speed);
    port_info[ifindex-1].port_entry.port_combo_force_mode_speed_cfg = fiber_speed;
#else
    SWDRV_SetPortComboForcedMode(unit, port, forcedmode);
#endif
    port_info[ifindex-1].port_entry.port_forced_mode = forcedmode;
#else /* (SWCTRL_UPDATE_PORT_ABILITY == TRUE) */
    static UI32_T forcemode_list[] = {
        SYS_DFLT_COMBO_PORT_FORCED_MODE,
        VAL_portComboForcedMode_sfpPreferredAuto,
        VAL_portComboForcedMode_none,
        VAL_portComboForcedMode_copperForced,
        VAL_portComboForcedMode_sfpForced,
    };

    UI32_T ifindex;
    UI32_T forcemode_bmp, forcemode;
    int i;

    ifindex = SWCTRL_UPORT_TO_IFINDEX(unit, port);

    /* port config forced mode : active which medium
     */
    SWCTRL_LOCK();

    forcemode_bmp = SWCTRL_GetSupportedPortComboForcedMode_Local(ifindex);
    forcemode = SYS_DFLT_COMBO_PORT_FORCED_MODE;

    for (i = 0; i < sizeof(forcemode_list)/sizeof(*forcemode_list); i++)
    {
        if (forcemode_bmp & BIT_VALUE(forcemode_list[i]))
        {
            forcemode = forcemode_list[i];
            break;
        }
    }

#if (SYS_CPNT_COMBO_PORT_FORCED_MODE_SFP_SPEED == TRUE)
    SWDRV_SetPortComboForcedMode(unit, port, forcemode, SYS_DFLT_COMBO_PORT_FORCED_MODE_SFP_SPEED);
    port_info[ifindex-1].port_entry.port_combo_force_mode_speed_cfg = SYS_DFLT_COMBO_PORT_FORCED_MODE_SFP_SPEED;
#else
    SWDRV_SetPortComboForcedMode(unit, port, forcemode);
#endif
    port_info[ifindex-1].port_entry.port_forced_mode = forcemode;

    SWCTRL_UNLOCK();
#endif /* (SWCTRL_UPDATE_PORT_ABILITY == TRUE) */
}
#endif /* (SYS_CPNT_COMBO_PORT_FORCE_MODE == TRUE) */

#endif

#if (SYS_CPNT_IPV6_MULTICAST_DATA_DROP== TRUE)
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_DropIpv6MulticastData
 * -------------------------------------------------------------------------
 * FUNCTION: Set port drop ip multicast data
 * INPUT   : lport - logical port
 * OUTPUT  : None
 * RETURN  :
 * NOTE    : if this port is trunk port, it will set all trunk member
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_DropIpv6MulticastData(UI32_T lport, BOOL_T enabled)
{
    SWCTRL_Lport_Type_T  type;
    SWCTRL_TrunkPortExtInfo_T    trunk_ext_info;
    UI32_T unit, port, trunk_id, i;

    type = SWCTRL_LogicalPortToUserPort(lport, &unit, &port, &trunk_id);

    if(SWCTRL_LPORT_TRUNK_PORT == type)
    {
#if (SYS_CPNT_IP_MULTICAST_DATA_DROP_SET_RULE_BY_LPORT == TRUE)

        SWDRV_DropIpv6MulticastData(0, lport, enabled);
#else
        SWCTRL_GetTrunkPortExtInfo (lport, &trunk_ext_info);

        for(i = 0; i < trunk_ext_info.member_number; i++)
        {
            unit = (UI32_T) trunk_ext_info.member_list[i].unit;
            port = (UI32_T) trunk_ext_info.member_list[i].port;

            SWDRV_DropIpv6MulticastData(unit, port, enabled);
        }
#endif
    }
    else
    {
        SWDRV_DropIpv6MulticastData(unit, port, enabled);
    }
    return TRUE;
}
#endif

#if (SYS_CPNT_ITRI_MIM == TRUE)
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_ITRI_MIM_SetStatus
 * -------------------------------------------------------------------------
 * FUNCTION: Set status of ITRI MAC-in-MAC
 * INPUT   : ifindex
 *           status
 * OUTPUT  : None
 * RETURN  : TRUE/FALSE
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_ITRI_MIM_SetStatus(UI32_T ifindex, BOOL_T status)
{
    BOOL_T retval = TRUE;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (!SWCTRL_IS_LPORT(ifindex))
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (SWCTRL_IS_TRUNK(ifindex))
    {
        UI32_T trunk_id = SWCTRL_IFINDEX_TO_TRUNKID(ifindex);

        if (trunk_ext_port_info[trunk_id-1].member_number == 0)
        {
            SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
        }
        else
        {
            SWCTRL_TrunkPortExtInfo_T trunk_ext_info;
            int i;

            SWCTRL_GetTrunkPortExtInfo(ifindex, &trunk_ext_info);

            for (i = 0; retval && i < trunk_ext_info.member_number; i++)
            {
                UI32_T unit, port, ifindex;

                unit = trunk_ext_info.member_list[i].unit;
                port = trunk_ext_info.member_list[i].port;
                ifindex = SWCTRL_UPORT_TO_IFINDEX(unit, port);

                retval = retval &&
                    L2MUX_MGR_ITRI_MIM_SetStatus(ifindex, status);
            }
        }
    }

    if (retval)
    {
        retval = L2MUX_MGR_ITRI_MIM_SetStatus(ifindex, status);
    }

    SWCTRL_RETURN_AND_RELEASE_CSC( retval );
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_ITRI_MIM_GetStatus
 * -------------------------------------------------------------------------
 * FUNCTION: Set status of ITRI MAC-in-MAC
 * INPUT   : ifindex
 * OUTPUT  : status_p
 * RETURN  : TRUE/FALSE
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_ITRI_MIM_GetStatus(UI32_T ifindex, BOOL_T *status_p)
{
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (!status_p)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (!SWCTRL_IS_LPORT(ifindex))
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (SWCTRL_IS_TRUNK(ifindex))
    {
        UI32_T trunk_id = SWCTRL_IFINDEX_TO_TRUNKID(ifindex);

        if (trunk_ext_port_info[trunk_id-1].member_number == 0)
        {
            SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
        }
    }

    if (!L2MUX_MGR_ITRI_MIM_GetStatus(ifindex, status_p))
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_ITRI_MIM_GetNextStatus
 * -------------------------------------------------------------------------
 * FUNCTION: Set status of ITRI MAC-in-MAC
 * INPUT   : ifindex_p
 * OUTPUT  : ifindex_p
 *           status_p
 * RETURN  : TRUE/FALSE
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_ITRI_MIM_GetNextStatus(UI32_T *ifindex_p, BOOL_T *status_p)
{
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (!ifindex_p || !status_p)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    while (++(*ifindex_p) <= SYS_ADPT_TOTAL_NBR_OF_LPORT)
    {
        if (SWCTRL_ITRI_MIM_GetStatus(*ifindex_p, status_p))
        {
            SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
        }
    }

    SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_ITRI_MIM_GetRunningStatus
 * -------------------------------------------------------------------------
 * FUNCTION: Set status of ITRI MAC-in-MAC
 * INPUT   : ifindex
 * OUTPUT  : status_p
 * RETURN  : SYS_TYPE_Get_Running_Cfg_T
 * NOTE    : None
 * -------------------------------------------------------------------------*/
SYS_TYPE_Get_Running_Cfg_T SWCTRL_ITRI_MIM_GetRunningStatus(UI32_T ifindex, BOOL_T *status_p)
{
    SWCTRL_USE_CSC_CHECK_OPER_MODE(SYS_TYPE_GET_RUNNING_CFG_FAIL);

    if (!status_p)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC(SYS_TYPE_GET_RUNNING_CFG_FAIL);
    }

    if (!SWCTRL_IS_USER_PORT(ifindex) || !SWCTRL_IS_EXIST(ifindex))
    {
        SWCTRL_RETURN_AND_RELEASE_CSC(SYS_TYPE_GET_RUNNING_CFG_FAIL);
    }

    if (!L2MUX_MGR_ITRI_MIM_GetStatus(ifindex, status_p))
    {
        SWCTRL_RETURN_AND_RELEASE_CSC(SYS_TYPE_GET_RUNNING_CFG_FAIL);
    }

    if (*status_p)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC(SYS_TYPE_GET_RUNNING_CFG_SUCCESS);
    }

    SWCTRL_RETURN_AND_RELEASE_CSC(SYS_TYPE_GET_RUNNING_CFG_NO_CHANGE);
}
#endif /* (SYS_CPNT_ITRI_MIM == TRUE) */

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_EnableDhcpPacketTrap
 * -------------------------------------------------------------------------
 * FUNCTION: This function will trap dhcp packet to CPU
 * INPUT   : owner  -- who want the trap
 * OUTPUT  : None
 * RETURN  : True: Successfully, False: If not available
 * NOTE    :
 *   CSC      | Client packet action  |  Server packet action
 * ===========|=======================|=========================
 *  Client    |        flood          |     copy to cpu
 * L2 relay   |     copy to cpu       |     copy to cpu
 * L3 relay   |     copy to cpu       |     copy to cpu
 * Snooping   |   redirect to cpu     |   redirect to cpu
 *  Server    |     copy to cpu       |        flood
 *UDPhelper 68|        flood          |    copy to cpu
 *UDPhelper 67|     copy to cpu       |        flood
 *  NONE      |        flood          |        flood
 * ===========|=======================|=========================
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_EnableDhcpPacketTrap(SWCTRL_TrapPktOwner_T owner)
{
    BOOL_T ret;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    switch (owner)
    {
        case SWCTRL_DHCP_TRAP_BY_DHCP_CLIENT:
        case SWCTRL_DHCP_TRAP_BY_UDP_HELPER_68:
            ret =
                SWCTRL_SetPktTrapStatus(SWCTRL_PKTTYPE_DHCP_SERVER, owner, TRUE, FALSE) &&
                SWCTRL_SetPktTrapStatus(SWCTRL_PKTTYPE_DHCP_CLIENT, owner, FALSE, FALSE);
            break;
        case SWCTRL_DHCP_TRAP_BY_L2_RELAY:
        case SWCTRL_DHCP_TRAP_BY_L3_RELAY:
            ret =
                SWCTRL_SetPktTrapStatus(SWCTRL_PKTTYPE_DHCP_SERVER, owner, TRUE, FALSE) &&
                SWCTRL_SetPktTrapStatus(SWCTRL_PKTTYPE_DHCP_CLIENT, owner, TRUE, FALSE);
            break;
        case SWCTRL_DHCP_TRAP_BY_DHCP_SERVER:
        case SWCTRL_DHCP_TRAP_BY_UDP_HELPER_67:
            ret =
                SWCTRL_SetPktTrapStatus(SWCTRL_PKTTYPE_DHCP_SERVER, owner, FALSE, FALSE) &&
                SWCTRL_SetPktTrapStatus(SWCTRL_PKTTYPE_DHCP_CLIENT, owner, TRUE, FALSE);
            break;
        case SWCTRL_DHCP_TRAP_BY_DHCPSNP:
            ret =
                SWCTRL_SetPktTrapStatus(SWCTRL_PKTTYPE_DHCP_SERVER, owner, TRUE, TRUE) &&
                SWCTRL_SetPktTrapStatus(SWCTRL_PKTTYPE_DHCP_CLIENT, owner, TRUE, TRUE);
            break;
        default:
            ret = FALSE;
    }

    SWCTRL_RETURN_AND_RELEASE_CSC( ret );
}


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_DisableDhcpPacketTrap
 * -------------------------------------------------------------------------
 * FUNCTION: This function will trap dhcp packet to CPU
 * INPUT   : owner  -- who want the trap
 * OUTPUT  : None
 * RETURN  : True: Successfully, False: If not available
 * NOTE    :
 *   CSC      | Client packet action  |  Server packet action
 * ===========|=======================|=========================
 *  Client    |        flood          |     copy to cpu
 * L2 relay   |     copy to cpu       |     copy to cpu
 * L3 relay   |     copy to cpu       |     copy to cpu
 * Snooping   |   redirect to cpu     |   redirect to cpu
 *  Server    |        copy           |        flood
 *UDPhelper 68|        flood          |    copy to cpu
 *UDPhelper 67|     copy to cpu       |        flood
 *  NONE      |        flood          |        flood
 * ===========|=======================|=========================
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_DisableDhcpPacketTrap(SWCTRL_TrapPktOwner_T owner)
{
    BOOL_T ret;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    ret =
        SWCTRL_SetPktTrapStatus(SWCTRL_PKTTYPE_DHCP_SERVER, owner, FALSE, FALSE) &&
        SWCTRL_SetPktTrapStatus(SWCTRL_PKTTYPE_DHCP_CLIENT, owner, FALSE, FALSE);

    SWCTRL_RETURN_AND_RELEASE_CSC( ret );
}

#if (SYS_CPNT_CLUSTER == TRUE)
/* -------------------------------------------------------------------------
 * FUNCTION NAME - SWCTRL_SetOrgSpecificTrapStatus
 * -------------------------------------------------------------------------
 * PURPOSE : Set whether organization specific frames are trapped to CPU.
 * INPUT   : owner - who set the status
 *           status  - TRUE / FALSE
 * OUTPUT  : None
 * RETURN  : TRUE / FALSE
 * NOTE    : None
 * -------------------------------------------------------------------------
 */
BOOL_T SWCTRL_SetOrgSpecificTrapStatus(SWCTRL_TrapPktOwner_T owner, BOOL_T status)
{
    return SWCTRL_SetPktTrapStatus(SWCTRL_PKTTYPE_ORG_SPECIFIC, owner, status, FALSE);
} /* End of SWCTRL_SetOrgSpecificTrapStatus */
#endif /* #if (SYS_CPNT_CLUSTER == TRUE) */

#if (SYS_CPNT_PPPOE_IA == TRUE)
/*-------------------------------------------------------------------------
 * FUNCTION NAME - SWCTRL_SetPPPoEDPktToCpu
 *-------------------------------------------------------------------------
 * PURPOSE: This function will enable/disable traping
 *          PPPoE discover packets to cpu for specified ifindex.
 * INPUT  : ifindex   - ifindex to enable/disable
 *          is_enable - the packet trapping is enabled or disabled
 * OUTPUT : None
 * RETURN : TRUE  - success
 *          FALSE - fail
 * NOTE   : 1. if ifindex is trunk, apply to all member ports
 *          2. if ifindex is normal/trunk member, apply to this port
 *          3. for projects who can install rule on trunk's member ports.
 *-------------------------------------------------------------------------
 */
BOOL_T SWCTRL_SetPPPoEDPktToCpu(UI32_T ifindex, BOOL_T is_enable)
{
    UI32_T  i, trunk_id;
    UI16_T  unit, port;
    BOOL_T  asic_status = FALSE;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (!(ifindex != 0
          && ifindex <= SYS_ADPT_TOTAL_NBR_OF_LPORT)
          || !SWCTRL_IS_EXIST(ifindex)
       )
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    SWCTRL_LOCK();
    /* normal/trunk member, apply to this port
     */
    if (!SWCTRL_IS_TRUNK (ifindex))
    {
        unit = SWCTRL_IFINDEX_TO_UNIT(ifindex);
        port = SWCTRL_IFINDEX_TO_PORT(ifindex);

        asic_status = SWDRV_SetPPPoEDPktToCpu (unit, port, is_enable);
    }

    /* trunk, apply to all member ports
     */
    if (SWCTRL_IS_TRUNK (ifindex))
    {
        trunk_id = SWCTRL_IFINDEX_TO_TRUNKID (ifindex);

        for(i=0; i<trunk_ext_port_info[trunk_id-1].member_number; i++)
        {
            unit = trunk_ext_port_info[trunk_id-1].member_list[i].unit;
            port = trunk_ext_port_info[trunk_id-1].member_list[i].port;
            asic_status = SWDRV_SetPPPoEDPktToCpu (unit, port, is_enable);
        }
    } /* End of if */
    SWCTRL_UNLOCK();

    SWCTRL_RETURN_AND_RELEASE_CSC( asic_status );
}/*End of SWCTRL_SetPPPoEDPktToCpu*/

/*-------------------------------------------------------------------------
 * FUNCTION NAME - SWCTRL_SetPPPoEDPktToCpuPerSystem
 *-------------------------------------------------------------------------
 * PURPOSE: This function will enable/disable traping
 *          PPPoE discover packets to cpu for per system.
 * INPUT  : is_enable - the packet trapping is enabled or disabled
 * OUTPUT : None
 * RETURN : TRUE  - success
 *          FALSE - fail
 * NOTE   : 1. for projects who encounter problems to install rule on
 *             trunk's member ports.
 *-------------------------------------------------------------------------
 */
BOOL_T SWCTRL_SetPPPoEDPktToCpuPerSystem(BOOL_T is_enable)
{
    BOOL_T  asic_status = FALSE;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    SWCTRL_LOCK();
    asic_status = SWDRV_SetPPPoEDPktToCpuPerSystem(is_enable);
    SWCTRL_UNLOCK();

    SWCTRL_RETURN_AND_RELEASE_CSC( asic_status );
}/*End of SWCTRL_SetPPPoEDPktToCpuPerSystem*/

#endif /* #if (SYS_CPNT_PPPOE_IA == TRUE) */

#if (SYS_CPNT_DOS == TRUE)
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetDosProtectionFilter
 * -------------------------------------------------------------------------
 * FUNCTION: This function will config DoS protection
 * INPUT   : type   - the type of DOS protection to config
 *           enable - TRUE to enable; FALSE to disable.
 * OUTPUT  : None
 * RETURN  : TRUE/FALSE
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetDosProtectionFilter(SWCTRL_DosProtectionFilter_T type, BOOL_T enable)
{
    BOOL_T retval = FALSE;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    retval = SWDRV_SetDosProtectionFilter(type, enable);

    SWCTRL_RETURN_AND_RELEASE_CSC(retval);
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetDosProtectionRateLimit
 * -------------------------------------------------------------------------
 * FUNCTION: This function will config DoS protection
 * INPUT   : type   - the type of DOS protection to config
 *           rate   - rate in kbps. 0 to disable.
 * OUTPUT  : None
 * RETURN  : TRUE/FALSE
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetDosProtectionRateLimit(SWCTRL_DosProtectionRateLimit_T type, UI32_T rate)
{
    BOOL_T retval = FALSE;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    retval = SWDRV_SetDosProtectionRateLimit(type, rate);

    SWCTRL_RETURN_AND_RELEASE_CSC(retval);
}
#endif /* (SYS_CPNT_DOS == TRUE) */


#if ((SYS_CPNT_DHCPV6 == TRUE)||(SYS_CPNT_DHCPV6SNP == TRUE))
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_EnableDhcp6PacketTrap
 * -------------------------------------------------------------------------
 * FUNCTION: This function will trap dhcpv6 packet to CPU
 * INPUT   : owner  -- who want the trap
 * OUTPUT  : None
 * RETURN  : True: Successfully, False: If not available
 * NOTE    :
 *   CSC    | Client packet action  |  Server packet action
 * =========|=======================|=========================
 *  Client  |        flood          |     copy to cpu
 *  relay   |     copy to cpu       |     copy to cpu
 * Snooping |   redirect to cpu     |   redirect to cpu
 *  Server  |     copy to cpu       |        flood
 *  NONE    |        flood          |        flood
 * =========|=======================|=========================
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_EnableDhcp6PacketTrap(SWCTRL_TrapPktOwner_T owner)
{
    BOOL_T ret;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    switch (owner)
    {
        case SWCTRL_DHCP6_TRAP_BY_DHCP6_CLIENT:
            ret =
                SWCTRL_SetPktTrapStatus(SWCTRL_PKTTYPE_DHCP6_SERVER, owner, TRUE, FALSE) &&
                SWCTRL_SetPktTrapStatus(SWCTRL_PKTTYPE_DHCP6_CLIENT, owner, FALSE, FALSE);
            break;
        case SWCTRL_DHCP6_TRAP_BY_DHCP6_RELAY:
            ret =
                SWCTRL_SetPktTrapStatus(SWCTRL_PKTTYPE_DHCP6_SERVER, owner, TRUE, FALSE) &&
                SWCTRL_SetPktTrapStatus(SWCTRL_PKTTYPE_DHCP6_CLIENT, owner, TRUE, FALSE);
            break;
        case SWCTRL_DHCP6_TRAP_BY_DHCP6_SERVER:
            ret =
                SWCTRL_SetPktTrapStatus(SWCTRL_PKTTYPE_DHCP6_SERVER, owner, FALSE, FALSE) &&
                SWCTRL_SetPktTrapStatus(SWCTRL_PKTTYPE_DHCP6_CLIENT, owner, TRUE, FALSE);
            break;
        case SWCTRL_DHCP6_TRAP_BY_DHCP6SNP:
            ret =
                SWCTRL_SetPktTrapStatus(SWCTRL_PKTTYPE_DHCP6_SERVER, owner, TRUE, TRUE) &&
                SWCTRL_SetPktTrapStatus(SWCTRL_PKTTYPE_DHCP6_CLIENT, owner, TRUE, TRUE);
            break;
        default:
            ret = FALSE;
    }

    SWCTRL_RETURN_AND_RELEASE_CSC( ret );
}


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_DisableDhcp6PacketTrap
 * -------------------------------------------------------------------------
 * FUNCTION: This function will trap dhcpv6 packet to CPU
 * INPUT   : owner  -- who want the trap
 * OUTPUT  : None
 * RETURN  : True: Successfully, False: If not available
 * NOTE    :
 *   CSC   | Client packet action  |  Server packet action
 * ========|=======================|=========================
 *  Client |        flood          |     copy to cpu
 *  relay  |     copy to cpu       |     copy to cpu
 * Snooping|   redirect to cpu     |   redirect to cpu
 *  Server |     copy to cpu       |        flood
 *  NONE   |        flood          |        flood
 * ========|=======================|=========================
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_DisableDhcp6PacketTrap(SWCTRL_TrapPktOwner_T owner)
{
    BOOL_T ret;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    ret =
        SWCTRL_SetPktTrapStatus(SWCTRL_PKTTYPE_DHCP6_SERVER, owner, FALSE, FALSE) &&
        SWCTRL_SetPktTrapStatus(SWCTRL_PKTTYPE_DHCP6_CLIENT, owner, FALSE, FALSE);

    SWCTRL_RETURN_AND_RELEASE_CSC( ret );
}
#endif

/* -------------------------------------------------------------------------
 * FUNCTION NAME - SWCTRL_SetUPortPktTrapStatus
 * -------------------------------------------------------------------------
 * PURPOSE : configure lower layer to trap packet
 * INPUT   : unit      - 0 for all unit
 *           port      - 0 for all port
 *           pkt_type  - which packet to trap
 *           to_cpu    - trap to cpu or not
 *           drop      - drop packet or not
 * OUTPUT  : None
 * RETURN  : TRUE / FALSE
 * NOTE    : None
 * -------------------------------------------------------------------------
 */
static BOOL_T SWCTRL_SetUPortPktTrapStatus(UI32_T unit, UI32_T port, SWCTRL_PktType_T pkt_type, BOOL_T to_cpu, BOOL_T drop)
{
    UI32_T start_unit, end_unit, start_port, end_port;
    BOOL_T ret = TRUE;

    if (!SWDRV_SetPktTrapStatus(unit, port, pkt_type, to_cpu, drop))
    {
        return FALSE;
    }

    /* some API support per-port configure only,
     * do it as below.
     */
    if (unit == 0)
    {
        start_unit = 1;
        end_unit = SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK;
    }
    else
    {
        start_unit = end_unit = unit;
    }

    if (port == 0)
    {
        start_port = 1;
        end_port = SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT;
    }
    else
    {
        start_port = end_port = port;
    }

    for (unit = start_unit; unit <= end_unit; unit++)
    {
        for (port = start_port; port <= end_port; port++)
        {
            if (!SWCTRL_IS_EXIST(SWCTRL_UPORT_TO_IFINDEX(unit, port)))
            {
                continue;
            }

            switch (pkt_type)
            {
                case SWCTRL_PKTTYPE_INTRUDER:
                    {
                        BOOL_T security_is_enabled = (to_cpu || drop);

                        if (!security_is_enabled)
                        {
                            ret = SWCTRL_SetUPortLearningStatus(unit, port, !user_ext_port_info[SWCTRL_UPORT_TO_IFINDEX(unit, port)-1].learning_disabled_status, FALSE);
                        }
                        if (ret)
                        {
                            ret = LAN_SetPortSecurity(unit, port, security_is_enabled);
                        }
                    }
                    break;

                default:
                    ;
            }
        }
    }

    return ret;
}

#if (SYS_CPNT_NDSNP == TRUE)
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_EnableNdPacketTrap
 * -------------------------------------------------------------------------
 * FUNCTION: This function will trap nd packet to CPU
 * INPUT   : owner  -- who want the trap
 * OUTPUT  : None
 * RETURN  : True: Successfully, False: If not available
 * NOTE    :
 *   CSC    | Client packet action
 * =========|=======================
 *  NDSNP   |    redirect to cpu
 *  NETCFG  |     copy to cpu
 * =========|=======================
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_EnableNdPacketTrap(SWCTRL_TrapPktOwner_T owner)
{
    BOOL_T ret;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);
    switch (owner)
    {
        case SWCTRL_ND_TRAP_BY_NETCFG_ND:
            ret =
                SWCTRL_SetPktTrapStatus(SWCTRL_PKTTYPE_ND, owner, TRUE, FALSE);
            break;
        case SWCTRL_ND_TRAP_BY_NDSNP:
            ret =
                SWCTRL_SetPktTrapStatus(SWCTRL_PKTTYPE_ND, owner, TRUE, TRUE);
            break;
        default:
            ret = FALSE;
    }

    SWCTRL_RETURN_AND_RELEASE_CSC(ret );
}


/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_DisableNdPacketTrap
 * -------------------------------------------------------------------------
 * FUNCTION: This function will trap nd packet to CPU
 * INPUT   : owner  -- who want the trap
 * OUTPUT  : None
 * RETURN  : True: Successfully, False: If not available
 * NOTE    :
 *   CSC    | Client packet action
 * =========|=======================
 *  NDSNP   |    redirect to cpu
 *  NETCFG  |    copy to cpu
 * =========|=======================
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_DisableNdPacketTrap(SWCTRL_TrapPktOwner_T owner)
{
   BOOL_T ret;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);
    switch (owner)
    {
        case SWCTRL_ND_TRAP_BY_NETCFG_ND:
            ret =
                SWCTRL_SetPktTrapStatus(SWCTRL_PKTTYPE_ND, owner, FALSE, FALSE);
            break;
        case SWCTRL_ND_TRAP_BY_NDSNP:
            ret =
                SWCTRL_SetPktTrapStatus(SWCTRL_PKTTYPE_ND, owner, TRUE, FALSE);
            break;
        default:
            ret = FALSE;
    }

    SWCTRL_RETURN_AND_RELEASE_CSC(ret );
}
#endif


/* -------------------------------------------------------------------------
 * FUNCTION NAME - SWCTRL_SetPktTrapStatus
 * -------------------------------------------------------------------------
 * PURPOSE : to trap packet
 * INPUT   : pkt_type  - which packet to trap
 *           owner     - who set the status
 *           to_cpu    - trap to cpu or not
 *           drop      - drop packet or not
 * OUTPUT  : None
 * RETURN  : TRUE / FALSE
 * NOTE    : None
 * -------------------------------------------------------------------------
 */
BOOL_T SWCTRL_SetPktTrapStatus(SWCTRL_PktType_T pkt_type, SWCTRL_TrapPktOwner_T owner, BOOL_T to_cpu, BOOL_T drop)
{
    UI32_T new_trap_status;
    UI32_T new_drop_status;
    BOOL_T ret;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (pkt_type < 0 || pkt_type >= SWCTRL_PKTTYPE_MAX)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    SWCTRL_LOCK();

    new_trap_status = swctrl_pkt_trap_status[pkt_type];
    new_drop_status = swctrl_pkt_drop_status[pkt_type];

    if (to_cpu)
    {
        new_trap_status |= owner;
    }
    else
    {
        new_trap_status &= ~owner;
    }

    if (drop)
    {
        new_drop_status |= owner;
    }
    else
    {
        new_drop_status &= ~owner;
    }

    /* to avoid to add duplicate rule,
     * if the rule existed and this transaction might cause rule add,
     * remove rule first.
     */
    {
        BOOL_T old_is_flood_only = !swctrl_pkt_trap_status[pkt_type] && !swctrl_pkt_drop_status[pkt_type];
        BOOL_T new_is_flood_only = !new_trap_status && !new_drop_status;

        if (!old_is_flood_only && !new_is_flood_only)
        {
            SWCTRL_SetUPortPktTrapStatus(0, 0, pkt_type, FALSE, FALSE);
        }
    }

    ret = SWCTRL_SetUPortPktTrapStatus(0, 0, pkt_type, !!new_trap_status, !!new_drop_status);

    if (ret)
    {
        swctrl_pkt_trap_status[pkt_type] = new_trap_status;
        swctrl_pkt_drop_status[pkt_type] = new_drop_status;
    }

    SWCTRL_UNLOCK();

    SWCTRL_RETURN_AND_RELEASE_CSC( ret );
} /* End of SWCTRL_SetPktTrapStatus */

/* -------------------------------------------------------------------------
 * FUNCTION NAME - SWCTRL_GetPktTrapStatus
 * -------------------------------------------------------------------------
 * PURPOSE : to trap packet
 * INPUT   : pkt_type  - which packet to trap
 *           owner     - who set the status
 * OUTPUT  : to_cpu_p  - trap to cpu or not
 *           drop_p    - drop packet or not
 * RETURN  : TRUE / FALSE
 * NOTE    : None
 * -------------------------------------------------------------------------
 */
BOOL_T SWCTRL_GetPktTrapStatus(SWCTRL_PktType_T pkt_type, SWCTRL_TrapPktOwner_T owner, BOOL_T *to_cpu_p, BOOL_T *drop_p)
{
    if (pkt_type < 0 || pkt_type >= SWCTRL_PKTTYPE_MAX)
    {
        return FALSE;
    }

    *to_cpu_p = !!(swctrl_pkt_trap_status[pkt_type] & owner);
    *drop_p = !!(swctrl_pkt_drop_status[pkt_type] & owner);

    return TRUE;
}

/* -------------------------------------------------------------------------
 * FUNCTION NAME - SWCTRL_GetPktTrapStatusEx
 * -------------------------------------------------------------------------
 * PURPOSE : to trap packet
 * INPUT   : pkt_type  - which packet to trap
 * OUTPUT  : trap_owners_p - owners to trap packet
 *           drop_owners_p  - owners to drop packet
 * RETURN  : TRUE / FALSE
 * NOTE    : None
 * -------------------------------------------------------------------------
 */
BOOL_T SWCTRL_GetPktTrapStatusEx(SWCTRL_PktType_T pkt_type, UI32_T *trap_owners_p, UI32_T *drop_owners_p)
{
    if (pkt_type < 0 || pkt_type >= SWCTRL_PKTTYPE_MAX)
    {
        return FALSE;
    }

    *trap_owners_p = swctrl_pkt_trap_status[pkt_type];
    *drop_owners_p = swctrl_pkt_drop_status[pkt_type];

    return TRUE;
}

static BOOL_T SWCTRL_SetPortPktTrapStatus_Local(UI32_T ifindex, SWCTRL_PktType_T pkt_type, SWCTRL_TrapPktOwner_T owner, BOOL_T to_cpu, BOOL_T drop)
{
    UI32_T unit, port;
    UI32_T new_trap_status;
    UI32_T new_drop_status;
    BOOL_T ret;

    unit = SWCTRL_IFINDEX_TO_UNIT(ifindex);
    port = SWCTRL_IFINDEX_TO_PORT(ifindex);

    new_trap_status = swctrl_pkt_trap_status_per_port[unit-1][port-1][pkt_type];
    new_drop_status = swctrl_pkt_drop_status_per_port[unit-1][port-1][pkt_type];

    if (to_cpu)
    {
        new_trap_status |= owner;
    }
    else
    {
        new_trap_status &= ~owner;
    }

    if (drop)
    {
        new_drop_status |= owner;
    }
    else
    {
        new_drop_status &= ~owner;
    }

    /* to avoid to add duplicate rule,
     * if the rule existed and this transaction might cause rule add,
     * remove rule first.
     */
    {
        BOOL_T old_is_flood_only = !swctrl_pkt_trap_status_per_port[unit-1][port-1][pkt_type] && !swctrl_pkt_drop_status_per_port[unit-1][port-1][pkt_type];
        BOOL_T new_is_flood_only = !new_trap_status && !new_drop_status;

        if (!old_is_flood_only && !new_is_flood_only)
        {
            SWCTRL_SetUPortPktTrapStatus(unit, port, pkt_type, FALSE, FALSE);
        }
    }

    ret = SWCTRL_SetUPortPktTrapStatus(unit, port, pkt_type, !!new_trap_status, !!new_drop_status);

    if (ret)
    {
        swctrl_pkt_trap_status_per_port[unit-1][port-1][pkt_type] = new_trap_status;
        swctrl_pkt_drop_status_per_port[unit-1][port-1][pkt_type] = new_drop_status;
    }

    return ret;
}

/* -------------------------------------------------------------------------
 * FUNCTION NAME - SWCTRL_SetPortPktTrapStatus
 * -------------------------------------------------------------------------
 * PURPOSE : to trap packet
 * INPUT   : ifindex
 *           pkt_type  - which packet to trap
 *           owner     - who set the status
 *           to_cpu    - trap to cpu or not
 *           drop      - drop packet or not
 * OUTPUT  : None
 * RETURN  : TRUE / FALSE
 * NOTE    : None
 * -------------------------------------------------------------------------
 */
BOOL_T SWCTRL_SetPortPktTrapStatus(UI32_T ifindex, SWCTRL_PktType_T pkt_type, SWCTRL_TrapPktOwner_T owner, BOOL_T to_cpu, BOOL_T drop)
{
    BOOL_T ret;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (pkt_type < 0 || pkt_type >= SWCTRL_PKTTYPE_MAX)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (!SWCTRL_IS_USER_PORT(ifindex) ||
        !SWCTRL_IS_EXIST(ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  SYSLOG_LEVEL_INFO,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    SWCTRL_LOCK();

    ret = SWCTRL_SetPortPktTrapStatus_Local(ifindex, pkt_type, owner, to_cpu, drop);

    SWCTRL_UNLOCK();

    SWCTRL_RETURN_AND_RELEASE_CSC( ret );
} /* End of SWCTRL_SetPktTrapStatus */

/* -------------------------------------------------------------------------
 * FUNCTION NAME - SWCTRL_GetPortPktTrapStatus
 * -------------------------------------------------------------------------
 * PURPOSE : to trap packet
 * INPUT   : ifindex
 *           pkt_type  - which packet to trap
 *           owner     - who set the status
 * OUTPUT  : to_cpu_p  - trap to cpu or not
 *           drop_p    - drop packet or not
 * RETURN  : TRUE / FALSE
 * NOTE    : None
 * -------------------------------------------------------------------------
 */
BOOL_T SWCTRL_GetPortPktTrapStatus(UI32_T ifindex, SWCTRL_PktType_T pkt_type, SWCTRL_TrapPktOwner_T owner, BOOL_T *to_cpu_p, BOOL_T *drop_p)
{
    UI32_T unit, port;

    if (pkt_type < 0 || pkt_type >= SWCTRL_PKTTYPE_MAX)
    {
        return FALSE;
    }

    if (!SWCTRL_IS_USER_PORT(ifindex) ||
        !SWCTRL_IS_EXIST(ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  SYSLOG_LEVEL_INFO,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        return FALSE;
    }

    unit = SWCTRL_IFINDEX_TO_UNIT(ifindex);
    port = SWCTRL_IFINDEX_TO_PORT(ifindex);

    *to_cpu_p = !!(swctrl_pkt_trap_status_per_port[unit-1][port-1][pkt_type] & owner);
    *drop_p = !!(swctrl_pkt_drop_status_per_port[unit-1][port-1][pkt_type] & owner);

    return TRUE;
}

/* -------------------------------------------------------------------------
 * FUNCTION NAME - SWCTRL_GetPortPktTrapStatusEx
 * -------------------------------------------------------------------------
 * PURPOSE : to trap packet
 * INPUT   : ifindex
 *           pkt_type  - which packet to trap
 * OUTPUT  : trap_owners_p - owners to trap packet
 *           drop_owners_p  - owners to drop packet
 * RETURN  : TRUE / FALSE
 * NOTE    : None
 * -------------------------------------------------------------------------
 */
BOOL_T SWCTRL_GetPortPktTrapStatusEx(UI32_T ifindex, SWCTRL_PktType_T pkt_type, UI32_T *trap_owners_p, UI32_T *drop_owners_p)
{
    UI32_T unit, port;

    if (pkt_type < 0 || pkt_type >= SWCTRL_PKTTYPE_MAX)
    {
        return FALSE;
    }

    if (!SWCTRL_IS_USER_PORT(ifindex) ||
        !SWCTRL_IS_EXIST(ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  SYSLOG_LEVEL_INFO,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        return FALSE;
    }

    unit = SWCTRL_IFINDEX_TO_UNIT(ifindex);
    port = SWCTRL_IFINDEX_TO_PORT(ifindex);

    *trap_owners_p = swctrl_pkt_trap_status_per_port[unit-1][port-1][pkt_type];
    *drop_owners_p = swctrl_pkt_drop_status_per_port[unit-1][port-1][pkt_type];

    return TRUE;
}

#if (SYS_HWCFG_SUPPORT_PD==TRUE)
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetPDPortStatus
 * -------------------------------------------------------------------------
 * FUNCTION: Get PD port status
 * INPUT   : entry_p->port_pd_ifindex
 * OUTPUT  : entry_p->port_pd_status --- SWDRV_POWER_SOURCE_NONE:None
 *                                       SWDRV_POWER_SOURCE_UP:Up
 *                                       SWDRV_POWER_SOURCE_DOWN:Down
 *           entry_p->port_pd_mode   --- SWDRV_POWERED_DEVICE_MODE_NONE
 *                                       SWDRV_POWERED_DEVICE_MODE_AF
 *                                       SWDRV_POWERED_DEVICE_MODE_AT
 * RETURN  : TRUE -- Sucess, FALSE -- Failed
 * NOTE    : The status of the ports with POE PD capability would show "UP"
 *           when the link partner is a PSE port.
 * -------------------------------------------------------------------------
 */
BOOL_T SWCTRL_GetPDPortStatus(SWCTRL_PortPD_T *entry_p)
{
    UI8_T status = 0, mode = 0;
    UI32_T unit, port;

    if(entry_p->port_pd_ifindex <= 0 || entry_p->port_pd_ifindex >= SYS_ADPT_TRUNK_1_IF_INDEX_NUMBER)
        return FALSE;

    unit = SWCTRL_IFINDEX_TO_UNIT(entry_p->port_pd_ifindex);
    port = SWCTRL_IFINDEX_TO_PORT(entry_p->port_pd_ifindex);

    SWCTRL_LOCK();
    SWDRV_GetPDPortStatus(unit, port, &status, &mode);
    SWCTRL_UNLOCK();

    entry_p->port_pd_status = status;
    entry_p->port_pd_mode = mode;
    return TRUE;
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetNextPDPortStatus
 * -------------------------------------------------------------------------
 * FUNCTION: Get next PD port status
 * INPUT   : entry_p->port_pd_ifindex
 * OUTPUT  : entry_p->port_pd_ifindex
 *           entry_p->port_pd_status --- SWDRV_POWER_SOURCE_NONE:None
 *                                       SWDRV_POWER_SOURCE_UP:Up
 *                                       SWDRV_POWER_SOURCE_DOWN:Down
 *           entry_p->port_pd_mode   --- SWDRV_POWERED_DEVICE_MODE_NONE
 *                                       SWDRV_POWERED_DEVICE_MODE_AF
 *                                       SWDRV_POWERED_DEVICE_MODE_AT
 * RETURN  : TRUE -- Sucess, FALSE -- Failed
 * NOTE    : The status of the ports with POE PD capability would show "UP"
 *           when the link partner is a PSE port.
 * -------------------------------------------------------------------------
 */
BOOL_T SWCTRL_GetNextPDPortStatus(SWCTRL_PortPD_T *entry_p)
{
    UI8_T status = 0, mode = 0;
    UI32_T unit, port, ifindex;

    for(ifindex = entry_p->port_pd_ifindex+1; ifindex < SYS_ADPT_TRUNK_1_IF_INDEX_NUMBER; ifindex++)
    {
        unit = SWCTRL_IFINDEX_TO_UNIT(ifindex);
        port = SWCTRL_IFINDEX_TO_PORT(ifindex);
        if(STKTPLG_OM_IsPoEPDPort(unit, port)==FALSE)
        {
           continue;
        }
        else
        {
            SWCTRL_LOCK();
            SWDRV_GetPDPortStatus(unit, port, &status, &mode);
            SWCTRL_UNLOCK();

            entry_p->port_pd_ifindex = ifindex;
            entry_p->port_pd_status = status;
            entry_p->port_pd_mode = mode;
            return TRUE;
        }
    }
    return FALSE;
}
#endif

#if ((SYS_HWCFG_SUPPORT_PD==TRUE) && (SYS_CPNT_SWDRV_ONLY_ALLOW_PD_PORT_LINKUP_WITH_PSE_PORT==TRUE))
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetPSECheckStatus
 * -------------------------------------------------------------------------
 * FUNCTION: Get PSE check status
 * INPUT   : None
 * OUTPUT  : pse_check_status_p --- TRUE: PSE check enabled, FALSE: PSE check disabled
 * RETURN  : TRUE -- Sucess, FALSE -- Failed
 * NOTE    : When PSE check status is enabled, all of the ports with POE PD
 *           capability are able to link up when the link partner is a PSE port.
 *           When PSE check status is disabled, all of the ports with POE PD
 *           capability will not be blocked by SWDRV to link up. However, if
 *           upper layer CSC shutdown the port, the port is never link up.
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_GetPSECheckStatus(BOOL_T* pse_check_status_p)
{
    SWCTRL_LOCK();
    *pse_check_status_p=SWCTRL_OM_GetPSECheckStatus();
    SWCTRL_UNLOCK();
    return TRUE;
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetPSECheckStatus
 * -------------------------------------------------------------------------
 * FUNCTION: Set PSE check status
 * INPUT   : pse_check_status --- TRUE: PSE check enabled, FALSE: PSE check disabled
 * OUTPUT  : None
 * RETURN  : TRUE -- Sucess, FALSE -- Failed
 * NOTE    : When PSE check status is enabled, all of the ports with POE PD
 *           capability are able to link up when the link partner is a PSE port.
 *           When PSE check status is disabled, all of the ports with POE PD
 *           capability will not be blocked by SWDRV to link up. However, if
 *           upper layer CSC shutdown the port, the port is never link up.
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetPSECheckStatus(BOOL_T pse_check_status)
{
    BOOL_T ret=TRUE;
    BOOL_T current_pse_check_status;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    SWCTRL_LOCK();
    current_pse_check_status=SWCTRL_OM_GetPSECheckStatus();
    if(current_pse_check_status!=pse_check_status)
    {
        ret=SWDRV_SetPSECheckStatus(pse_check_status);
        if(ret==TRUE)
        {
            SWCTRL_OM_SetPSECheckStatus(pse_check_status);
        }
    }
    SWCTRL_UNLOCK();

    SWCTRL_RETURN_AND_RELEASE_CSC(ret);
}
#endif

#if (SYS_CPNT_PFC == TRUE)
/* -------------------------------------------------------------------------
 * FUNCTION NAME - SWCTRL_SetPortPfcStatus
 * -------------------------------------------------------------------------
 * PURPOSE: To set the PFC port status by specified ifidx.
 * INPUT  : ifidx      -- ifindex to set
 *          rx_en      -- enable/disable PFC response
 *          tx_en      -- enable/disable PFC triggering
 *          pri_en_vec -- bitmap of enable status per priority
 *                         set bit to enable PFC; clear to disable.
 * OUTPUT : None
 * RETURN : TRUE/FALSE
 * NOTE   : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetPortPfcStatus(
    UI32_T  ifidx,
    BOOL_T  rx_en,
    BOOL_T  tx_en,
    UI16_T  pri_en_vec)
{
    UI32_T  i, trunk_id;
    UI16_T  unit, port;
    BOOL_T  asic_status = FALSE;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (!(ifidx != 0
          && ifidx <= SYS_ADPT_TOTAL_NBR_OF_LPORT)
          || !SWCTRL_IS_EXIST(ifidx)
       )
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    SWCTRL_LOCK();
    if (!SWCTRL_IS_TRUNK (ifidx))
    {
        /* normal/trunk member, apply to this port
         */
        unit = SWCTRL_IFINDEX_TO_UNIT(ifidx);
        port = SWCTRL_IFINDEX_TO_PORT(ifidx);

        asic_status = SWDRV_SetPortPfcStatus(unit, port, tx_en, rx_en, pri_en_vec);
    }
    else
    {
        /* trunk, apply to all member ports
         */
        trunk_id = SWCTRL_IFINDEX_TO_TRUNKID (ifidx);

        for(i=0; i<trunk_ext_port_info[trunk_id-1].member_number; i++)
        {
            unit = trunk_ext_port_info[trunk_id-1].member_list[i].unit;
            port = trunk_ext_port_info[trunk_id-1].member_list[i].port;
            asic_status = SWDRV_SetPortPfcStatus(unit, port, tx_en, rx_en, pri_en_vec);
        }
    } /* End of if */
    SWCTRL_UNLOCK();

    SWCTRL_RETURN_AND_RELEASE_CSC( asic_status );
}

/* -------------------------------------------------------------------------
 * FUNCTION NAME - SWCTRL_UpdatePfcPriMap
 * -------------------------------------------------------------------------
 * PURPOSE : This function update PFC priority to queue mapping.
 * INPUT   : None
 * OUTPUT : None
 * RETURN : TRUE/FALSE
 * NOTE   : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_UpdatePfcPriMap(void)
{
    BOOL_T ret = FALSE;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    SWCTRL_LOCK();

    ret = SWDRV_UpdatePfcPriMap();

    SWCTRL_UNLOCK();

    SWCTRL_RETURN_AND_RELEASE_CSC( ret );
}
#endif /* #if (SYS_CPNT_PFC == TRUE) */

#if (SYS_CPNT_ETS == TRUE)
/*------------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetPortCosGroupMapping
 *------------------------------------------------------------------------------
 * FUNCTION: This function sets mapping between CoS Queue and CoS group
 * INPUT   : ifindex
 *           cosq2group -- array of cos groups.
 *                         element 0 is cos group of cosq 0,
 *                         element 1 is cos group of cosq 1, ...
 *                         NULL to map all cos to single cos group
 * OUTPUT  : None
 * RETURN  : True: Successfully, FALSE: failed
 * NOTE    : None
 *------------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetPortCosGroupMapping(
    UI32_T ifindex,
    UI32_T cosq2group[SYS_ADPT_MAX_NBR_OF_PRIORITY_QUEUE])
{
    UI32_T unit, port;
    BOOL_T ret = TRUE;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (!SWCTRL_IS_LPORT(ifindex) && !SWCTRL_IS_TRUNK_MEMBER(ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    SWCTRL_LOCK();

    if (SWCTRL_IS_TRUNK (ifindex))
    {
        SWCTRL_TrunkPortExtInfo_T trunk_ext_info;
        UI32_T i;
        UI32_T trunk_id = SWCTRL_IFINDEX_TO_TRUNKID(ifindex);

        if (trunk_ext_port_info[trunk_id-1].member_number == 0)
        {
            EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                      SWCTRL_NO_USE_FUNC_NO,
                                      EH_TYPE_MSG_TRUNK_CNFG_ERR,
                                      SYSLOG_LEVEL_INFO,
                                      "Trunk contains no members");  /*SWCTRL_ENO_NO_MEMBER_IN_TRUNK*/

            SWCTRL_UNLOCK();
            SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
        }

        if (!SWCTRL_GetTrunkPortExtInfo(ifindex, &trunk_ext_info))
        {
            SWCTRL_UNLOCK();
            SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
        }

        for (i = 0; ret && i < trunk_ext_info.member_number; i++)
        {
            unit = trunk_ext_info.member_list[i].unit;
            port = trunk_ext_info.member_list[i].port;
            ret = SWDRV_SetPortCosGroupMapping(unit, port, cosq2group);
        }
    }
    else
    {
        unit = SWCTRL_IFINDEX_TO_UNIT(ifindex);
        port = SWCTRL_IFINDEX_TO_PORT(ifindex);
        ret = SWDRV_SetPortCosGroupMapping(unit, port, cosq2group);
    }

    SWCTRL_UNLOCK();

    SWCTRL_RETURN_AND_RELEASE_CSC( ret );
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetPortCosGroupSchedulingMethod
 *------------------------------------------------------------------------------
 * FUNCTION: This function sets scheduling method for CoS groups
 * INPUT   : ifindex
 *           method  -- SWCTRL_Egress_Scheduling_Method_E
 *           weights -- weights for cos groups.
 *                      NULL if method is STRICT
 * OUTPUT  : None
 * RETURN  : True: Successfully, FALSE: failed
 * NOTE    : None
 *------------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetPortCosGroupSchedulingMethod(
    UI32_T ifindex,
    UI32_T method,
    UI32_T weights[SYS_ADPT_ETS_MAX_NBR_OF_TRAFFIC_CLASS])
{
    UI32_T unit, port;
    BOOL_T ret = TRUE;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (!SWCTRL_IS_LPORT(ifindex) && !SWCTRL_IS_TRUNK_MEMBER(ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    SWCTRL_LOCK();

    if (SWCTRL_IS_TRUNK (ifindex))
    {
        SWCTRL_TrunkPortExtInfo_T trunk_ext_info;
        UI32_T i;
        UI32_T trunk_id = SWCTRL_IFINDEX_TO_TRUNKID(ifindex);

        if (trunk_ext_port_info[trunk_id-1].member_number == 0)
        {
            EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                      SWCTRL_NO_USE_FUNC_NO,
                                      EH_TYPE_MSG_TRUNK_CNFG_ERR,
                                      SYSLOG_LEVEL_INFO,
                                      "Trunk contains no members");  /*SWCTRL_ENO_NO_MEMBER_IN_TRUNK*/

            SWCTRL_UNLOCK();
            SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
        }

        if (!SWCTRL_GetTrunkPortExtInfo(ifindex, &trunk_ext_info))
        {
            SWCTRL_UNLOCK();
            SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
        }

        for (i = 0; ret && i < trunk_ext_info.member_number; i++)
        {
            unit = trunk_ext_info.member_list[i].unit;
            port = trunk_ext_info.member_list[i].port;
            ret = SWDRV_SetPortCosGroupSchedulingMethod(unit, port, method, weights);
        }
    }
    else
    {
        unit = SWCTRL_IFINDEX_TO_UNIT(ifindex);
        port = SWCTRL_IFINDEX_TO_PORT(ifindex);
        ret = SWDRV_SetPortCosGroupSchedulingMethod(unit, port, method, weights);
    }

    SWCTRL_UNLOCK();

    SWCTRL_RETURN_AND_RELEASE_CSC( ret );
}
#endif /* (SYS_CPNT_ETS == TRUE) */

#if (SYS_CPNT_CN == TRUE)
/*------------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetQcnCnmPriority
 *------------------------------------------------------------------------------
 * FUNCTION: This function sets 802.1p priority of egress QCN CNM
 * INPUT   : pri -- 802.1p priority of egress QCN CNM
 * OUTPUT  : None
 * RETURN  : True: Successfully, FALSE: failed
 * NOTE    : None
 *------------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetQcnCnmPriority(UI32_T pri)
{
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (!SWDRV_SetQcnCnmPriority(pri))
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetPortQcnCpq
 *------------------------------------------------------------------------------
 * FUNCTION: This function sets CP Queue of the CoS Queue
 * INPUT   : ifindex
 *           cosq -- CoS Queue
 *           cpq  -- CP Queue. SWCTRL_QCN_CPQ_INVALID means to disable QCN
 * OUTPUT  : None
 * RETURN  : True: Successfully, FALSE: failed
 * NOTE    : None
 *------------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetPortQcnCpq(
    UI32_T ifindex,
    UI32_T cosq,
    UI32_T cpq)
{
    UI32_T unit, port;
    BOOL_T ret = TRUE;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (!SWCTRL_IS_LPORT(ifindex) && !SWCTRL_IS_TRUNK_MEMBER(ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    SWCTRL_LOCK();

    if (SWCTRL_IS_TRUNK (ifindex))
    {
        SWCTRL_TrunkPortExtInfo_T trunk_ext_info;
        UI32_T i;
        UI32_T trunk_id = SWCTRL_IFINDEX_TO_TRUNKID(ifindex);

        if (trunk_ext_port_info[trunk_id-1].member_number == 0)
        {
            EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                      SWCTRL_NO_USE_FUNC_NO,
                                      EH_TYPE_MSG_TRUNK_CNFG_ERR,
                                      SYSLOG_LEVEL_INFO,
                                      "Trunk contains no members");  /*SWCTRL_ENO_NO_MEMBER_IN_TRUNK*/

            SWCTRL_UNLOCK();
            SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
        }

        if (!SWCTRL_GetTrunkPortExtInfo(ifindex, &trunk_ext_info))
        {
            SWCTRL_UNLOCK();
            SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
        }

        for (i = 0; ret && i < trunk_ext_info.member_number; i++)
        {
            unit = trunk_ext_info.member_list[i].unit;
            port = trunk_ext_info.member_list[i].port;
            ret = SWDRV_SetPortQcnCpq(unit, port, cosq, cpq);
        }
    }
    else
    {
        unit = SWCTRL_IFINDEX_TO_UNIT(ifindex);
        port = SWCTRL_IFINDEX_TO_PORT(ifindex);
        ret = SWDRV_SetPortQcnCpq(unit, port, cosq, cpq);
    }

    SWCTRL_UNLOCK();

    SWCTRL_RETURN_AND_RELEASE_CSC( ret );
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetPortQcnEgrCnTagRemoval
 *------------------------------------------------------------------------------
 * FUNCTION: This function sets removal of CN-Tag of egress pkts
 * INPUT   : ifindex
 *           no_cntag_bitmap - bit 0 for pri 0, and so on.
 *                             set the bit to remove CN-tag of packets with the pri.
 * OUTPUT  : None
 * RETURN  : True: Successfully, FALSE: failed
 * NOTE    : None
 *------------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetPortQcnEgrCnTagRemoval(
    UI32_T ifindex,
    UI8_T no_cntag_bitmap)
{
    UI32_T unit, port;
    BOOL_T ret = TRUE;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (!SWCTRL_IS_LPORT(ifindex) && !SWCTRL_IS_TRUNK_MEMBER(ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    SWCTRL_LOCK();

    if (SWCTRL_IS_TRUNK (ifindex))
    {
        SWCTRL_TrunkPortExtInfo_T trunk_ext_info;
        UI32_T i;
        UI32_T trunk_id = SWCTRL_IFINDEX_TO_TRUNKID(ifindex);

        if (trunk_ext_port_info[trunk_id-1].member_number == 0)
        {
            EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                      SWCTRL_NO_USE_FUNC_NO,
                                      EH_TYPE_MSG_TRUNK_CNFG_ERR,
                                      SYSLOG_LEVEL_INFO,
                                      "Trunk contains no members");  /*SWCTRL_ENO_NO_MEMBER_IN_TRUNK*/

            SWCTRL_UNLOCK();
            SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
        }

        if (!SWCTRL_GetTrunkPortExtInfo(ifindex, &trunk_ext_info))
        {
            SWCTRL_UNLOCK();
            SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
        }

        for (i = 0; ret && i < trunk_ext_info.member_number; i++)
        {
            unit = trunk_ext_info.member_list[i].unit;
            port = trunk_ext_info.member_list[i].port;
            ret = SWDRV_SetPortQcnEgrCnTagRemoval(unit, port, no_cntag_bitmap);
        }
    }
    else
    {
        unit = SWCTRL_IFINDEX_TO_UNIT(ifindex);
        port = SWCTRL_IFINDEX_TO_PORT(ifindex);
        ret = SWDRV_SetPortQcnEgrCnTagRemoval(unit, port, no_cntag_bitmap);
    }

    SWCTRL_UNLOCK();

    SWCTRL_RETURN_AND_RELEASE_CSC( ret );
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetPortQcnCpid
 *------------------------------------------------------------------------------
 * FUNCTION: This function gets CPID
 * INPUT   : ifindex
 *           cosq -- CoS Queue
 *           cpid -- CPID
 * OUTPUT  : None
 * RETURN  : True: Successfully, FALSE: failed
 * NOTE    : None
 *------------------------------------------------------------------------------*/
BOOL_T SWCTRL_GetPortQcnCpid(
    UI32_T ifindex,
    UI32_T cosq,
    UI8_T cpid[8])
{
    UI32_T unit, port;
    BOOL_T ret = TRUE;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (!SWCTRL_IS_LPORT(ifindex) && !SWCTRL_IS_TRUNK_MEMBER(ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    SWCTRL_LOCK();

    if (SWCTRL_IS_TRUNK (ifindex))
    {
        UI32_T primary_ifindex;

        if (!SWCTRL_GetTrunkPrimaryPort(ifindex, &primary_ifindex))
        {
            SWCTRL_UNLOCK();
            SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
        }

        unit = SWCTRL_IFINDEX_TO_UNIT(primary_ifindex);
        port = SWCTRL_IFINDEX_TO_PORT(primary_ifindex);
    }
    else
    {
        unit = SWCTRL_IFINDEX_TO_UNIT(ifindex);
        port = SWCTRL_IFINDEX_TO_PORT(ifindex);
    }

    ret = SWDRV_GetPortQcnCpid(unit, port, cosq, cpid);

    SWCTRL_UNLOCK();

    SWCTRL_RETURN_AND_RELEASE_CSC( ret );
}
#endif /* (SYS_CPNT_CN == TRUE) */

#if (SYS_CPNT_MAC_IN_MAC == TRUE)
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetMimService
 * -------------------------------------------------------------------------
 * FUNCTION: This function will create/destroy a MiM service instance.
 * INPUT   : mim_p            -- MiM service instance info.
 *           is_valid         -- TRUE to create/update; FALSE to destroy.
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetMimService(SWCTRL_MimServiceInfo_T *mim_p, BOOL_T is_valid)
{
    SWDRV_MimServiceInfo_T drv_mim;
    BOOL_T ret;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    memset(&drv_mim, 0, sizeof(drv_mim));
    drv_mim.isid = mim_p->isid;
    drv_mim.hw_idx = mim_p->hw_idx;

    SWCTRL_LOCK();

    ret = SWDRV_SetMimService(&drv_mim, is_valid);

    SWCTRL_UNLOCK();

    if (ret)
    {
        mim_p->hw_idx = drv_mim.hw_idx;
    }

    SWCTRL_RETURN_AND_RELEASE_CSC( ret );
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetMimServicePort
 * -------------------------------------------------------------------------
 * FUNCTION: This function will add/delete member port to a MiM service instance.
 * INPUT   : mim_port_p       -- MiM port info.
 *           is_valid         -- TRUE to add; FALSE to delete.
 * OUTPUT  : None
 * RETURN  : TRUE: Successfully, FALSE: If not available
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetMimServicePort(SWCTRL_MimPortInfo_T *mim_port_p, BOOL_T is_valid)
{
    SWDRV_MimPortInfo_T drv_mim_port;
    UI32_T ifindex = mim_port_p->lport;
    BOOL_T del_by_hw_idx;
    BOOL_T ret = TRUE;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    del_by_hw_idx = !is_valid && mim_port_p->port_type == SWCTRL_MIM_PORT_TYPE_HWIDX;

    if (!del_by_hw_idx && !SWCTRL_IS_LPORT(ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_ERR,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    memset(&drv_mim_port, 0, sizeof(drv_mim_port));

    drv_mim_port.isid = mim_port_p->isid;
    drv_mim_port.port_type = mim_port_p->port_type;

    assert(sizeof(drv_mim_port.ext) == sizeof(mim_port_p->ext));

    switch (mim_port_p->port_type)
    {
        case SWCTRL_MIM_PORT_TYPE_ACCESS:
            memcpy(&drv_mim_port.ext.access, &mim_port_p->ext.access, sizeof(drv_mim_port.ext.access));
            break;

        case SWCTRL_MIM_PORT_TYPE_BACKBONE:
            memcpy(&drv_mim_port.ext.backbone, &mim_port_p->ext.backbone, sizeof(drv_mim_port.ext.backbone));
            break;

        case SWCTRL_MIM_PORT_TYPE_HWIDX:
            drv_mim_port.hw_idx = mim_port_p->hw_idx;
            break;

        default:
            return FALSE;
    }

    SWCTRL_LOCK();

    if (del_by_hw_idx)
    {
        ret = SWDRV_SetMimServicePort(&drv_mim_port, is_valid);
    }
    else if (SWCTRL_IS_TRUNK (ifindex))
    {
        SWCTRL_TrunkPortExtInfo_T trunk_ext_info;
        UI32_T i;
        UI32_T trunk_id = SWCTRL_IFINDEX_TO_TRUNKID(ifindex);

        if (trunk_ext_port_info[trunk_id-1].member_number == 0)
        {
            EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                      SWCTRL_NO_USE_FUNC_NO,
                                      EH_TYPE_MSG_TRUNK_CNFG_ERR,
                                      SYSLOG_LEVEL_INFO,
                                      "Trunk contains no members");  /*SWCTRL_ENO_NO_MEMBER_IN_TRUNK*/

            SWCTRL_UNLOCK();
            SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
        }

        if (!SWCTRL_GetTrunkPortExtInfo(ifindex, &trunk_ext_info))
        {
            SWCTRL_UNLOCK();
            SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
        }

        for (i = 0; ret && i < trunk_ext_info.member_number; i++)
        {
            drv_mim_port.unit = trunk_ext_info.member_list[i].unit;
            drv_mim_port.port = trunk_ext_info.member_list[i].port;
            ret = SWDRV_SetMimServicePort(&drv_mim_port, is_valid);
        }
    }
    else
    {
        drv_mim_port.unit = SWCTRL_IFINDEX_TO_UNIT(ifindex);
        drv_mim_port.port = SWCTRL_IFINDEX_TO_PORT(ifindex);

        ret = SWDRV_SetMimServicePort(&drv_mim_port, is_valid);
    }

    SWCTRL_UNLOCK();

    if (ret)
    {
        mim_port_p->hw_idx = drv_mim_port.hw_idx;
    }

    SWCTRL_RETURN_AND_RELEASE_CSC( ret );
}

#if (SYS_CPNT_IAAS == TRUE)
/*-------------------------------------------------------------------------
 * FUNCTION NAME - SWCTRL_SetMimServicePortLearningStatusForStationMove
 * ------------------------------------------------------------------------
 * PURPOSE  :   This funtion will set MiM port learning status
 *              for station move handling only
 * INPUT    :   learning
 *              to_cpu
 *              drop
 * OUTPUT   :   None
 * RETURN   :   TRUE/FALSE
 * NOTES    :   None
 * ------------------------------------------------------------------------
 */
BOOL_T SWCTRL_SetMimServicePortLearningStatusForStationMove(BOOL_T learning, BOOL_T to_cpu, BOOL_T drop)
{
    BOOL_T ret;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    SWCTRL_LOCK();

    ret = SWDRV_SetMimServicePortLearningStatusForStationMove(learning, to_cpu, drop);

    SWCTRL_UNLOCK();

    SWCTRL_RETURN_AND_RELEASE_CSC( ret );
}
#endif /* (SYS_CPNT_IAAS == TRUE) */
#endif /* (SYS_CPNT_MAC_IN_MAC == TRUE) */

/* -------------------------------------------------------------------------
 * FUNCTION NAME - SWCTRL_SetCpuRateLimit
 * -------------------------------------------------------------------------
 * PURPOSE : To configure CPU rate limit
 * INPUT   : pkt_type  -- SWDRV_PKTTYPE_XXX
 *           rate      -- in pkt/s. 0 to disable.
 * OUTPUT  : None
 * RETURN  : TRUE / FALSE
 * NOTE    : None
 * -------------------------------------------------------------------------
 */
BOOL_T SWCTRL_SetCpuRateLimit(UI32_T pkt_type, UI32_T rate)
{
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (pkt_type < 0 || pkt_type >= SWCTRL_PKTTYPE_MAX)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (swctrl_pkt_cpu_rate[pkt_type] == rate)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
    }

    SWCTRL_LOCK();

    if (!SWDRV_SetCpuRateLimit(pkt_type, rate))
    {
        SWCTRL_UNLOCK();
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    swctrl_pkt_cpu_rate[pkt_type] = rate;

    SWCTRL_UNLOCK();

    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
}

/* -------------------------------------------------------------------------
 * FUNCTION NAME - SWCTRL_GetCpuRateLimit
 * -------------------------------------------------------------------------
 * PURPOSE : To get configured CPU rate limit
 * INPUT   : pkt_type  -- SWDRV_PKTTYPE_XXX
 * OUTPUT  : rate_p    -- in pkt/s. 0 to disable.
 * RETURN  : TRUE / FALSE
 * NOTE    : None
 * -------------------------------------------------------------------------
 */
BOOL_T SWCTRL_GetCpuRateLimit(UI32_T pkt_type, UI32_T *rate_p)
{
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (pkt_type < 0 || pkt_type >= SWCTRL_PKTTYPE_MAX)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    *rate_p = swctrl_pkt_cpu_rate[pkt_type];

    SWCTRL_RETURN_AND_RELEASE_CSC( TRUE );
}

#if (SWCTRL_UPDATE_PORT_ABILITY == TRUE)
/* -------------------------------------------------------------------------
 * FUNCTION NAME - SWCTRL_GetPortAbilityFromDrv
 * -------------------------------------------------------------------------
 * PURPOSE : To get port abilities
 * INPUT   : unit
 *           port
 * OUTPUT  : ability_p  -- SWCTRL_PortAbility_T
 * RETURN  : TRUE / FALSE
 * NOTE    : None
 * -------------------------------------------------------------------------
 */
static BOOL_T SWCTRL_GetPortAbilityFromDrv(UI32_T unit, UI32_T port, SWCTRL_PortAbility_T *ability_p)
{
    UI32_T ifindex = SWCTRL_UPORT_TO_IFINDEX(unit, port);
    SWDRV_PortAbility_T port_ability;

    if (!SWDRV_GetPortAbility(unit, port, &port_ability))
    {
        return FALSE;
    }

    /* TODO:
     *   Current projects don't support half duplex for speed >= 1000,
     *   shall be enhanced later (for UI and document).
     *
     *   For backward compatibility,
     *   overwrite these abilities with 0.
     */
    port_ability.spd_1000m_hd = 0;
    port_ability.spd_10g_hd = 0;
    port_ability.spd_40g_hd = 0;

    /* medium type
     */
    {
        UI32_T medium_forced_mode_supported = BIT_VALUE(VAL_portComboForcedMode_none);
        UI32_T medium_fiber_type_supported = 0;
        UI32_T medium_fiber_type_num = 0;
        UI32_T media_cap;
        UI32_T i;

        if (STKTPLG_POM_GetPortMediaCapability(unit, port, &media_cap))
        {
            if (port_ability.medium_fiber_100m)
                medium_fiber_type_supported |= BIT_VALUE(VAL_portType_hundredBaseFX);
            if (port_ability.medium_fiber_1000m)
                medium_fiber_type_supported |= BIT_VALUE(VAL_portType_thousandBaseSfp);
            if (port_ability.medium_fiber_10g)
                medium_fiber_type_supported |= BIT_VALUE(VAL_portType_tenGBaseSFP);
            if (port_ability.medium_fiber_25g)
                medium_fiber_type_supported |= BIT_VALUE(VAL_portType_twentyFiveGBaseSFP);
            if (port_ability.medium_fiber_40g)
                medium_fiber_type_supported |= BIT_VALUE(VAL_portType_fortyGBaseQSFP);
            if (port_ability.medium_fiber_100g)
                medium_fiber_type_supported |= BIT_VALUE(VAL_portType_hundredGBaseQSFP);

            for (i = medium_fiber_type_supported; i != 0; i >>= 1)
            {
                medium_fiber_type_num += i & 0x1;
            }

            if ((media_cap & STKTPLG_TYPE_PORT_MEDIA_CAP_COPPER) &&
                (media_cap & STKTPLG_TYPE_PORT_MEDIA_CAP_FIBER) &&
                medium_fiber_type_num > 0)
            {
                medium_forced_mode_supported =
                    BIT_VALUE(VAL_portComboForcedMode_copperForced) |
                    BIT_VALUE(VAL_portComboForcedMode_sfpForced) |
                    BIT_VALUE(VAL_portComboForcedMode_sfpPreferredAuto);
            }
#if (SYS_CPNT_COMBO_PORT_FORCED_MODE_SFP_SPEED == TRUE)
            else if ((media_cap & STKTPLG_TYPE_PORT_MEDIA_CAP_FIBER) &&
                     medium_fiber_type_num > 1)
            {
                medium_forced_mode_supported =
                    BIT_VALUE(VAL_portComboForcedMode_none) |
                    BIT_VALUE(VAL_portComboForcedMode_sfpForced);
            }
#endif
            else
            {
                medium_forced_mode_supported =
                    BIT_VALUE(VAL_portComboForcedMode_none);
                medium_fiber_type_supported = 0;
            }
        }

        if (port_info[ifindex-1].port_entry.port_type == VAL_portType_tenGBaseXFP)
        {
            medium_forced_mode_supported =
                BIT_VALUE(VAL_portComboForcedMode_none);
            medium_fiber_type_supported = 0;
        }

        ability_p->medium_forced_mode_supported = medium_forced_mode_supported;
        ability_p->medium_fiber_type_supported = medium_fiber_type_supported;
    }

    /* speed duplex
     */
    {
        UI32_T port_speed_duplex_supported = 0;

        if (port_ability.spd_10m_hd)
            port_speed_duplex_supported |= BIT_VALUE(VAL_portSpeedDpxCfg_halfDuplex10);
        if (port_ability.spd_10m_fd)
            port_speed_duplex_supported |= BIT_VALUE(VAL_portSpeedDpxCfg_fullDuplex10);
        if (port_ability.spd_100m_hd)
            port_speed_duplex_supported |= BIT_VALUE(VAL_portSpeedDpxCfg_halfDuplex100);
        if (port_ability.spd_100m_fd)
            port_speed_duplex_supported |= BIT_VALUE(VAL_portSpeedDpxCfg_fullDuplex100);
        if (port_ability.spd_1000m_hd)
            port_speed_duplex_supported |= BIT_VALUE(VAL_portSpeedDpxCfg_halfDuplex1000);
        if (port_ability.spd_1000m_fd)
            port_speed_duplex_supported |= BIT_VALUE(VAL_portSpeedDpxCfg_fullDuplex1000);
        if (port_ability.spd_10g_hd)
            port_speed_duplex_supported |= BIT_VALUE(VAL_portSpeedDpxCfg_halfDuplex10g);
        if (port_ability.spd_10g_fd)
            port_speed_duplex_supported |= BIT_VALUE(VAL_portSpeedDpxCfg_fullDuplex10g);
        if (port_ability.spd_25g_fd)
            port_speed_duplex_supported |= BIT_VALUE(VAL_portSpeedDpxCfg_fullDuplex25g);
        if (port_ability.spd_40g_hd)
            port_speed_duplex_supported |= BIT_VALUE(VAL_portSpeedDpxCfg_halfDuplex40g);
        if (port_ability.spd_40g_fd)
            port_speed_duplex_supported |= BIT_VALUE(VAL_portSpeedDpxCfg_fullDuplex40g);
        if (port_ability.spd_100g_fd)
            port_speed_duplex_supported |= BIT_VALUE(VAL_portSpeedDpxCfg_fullDuplex100g);

#if (SYS_CPNT_SUPPORT_FORCED_1000BASE_T_MODE != TRUE)
        /* Some speed can't link up on forced mode without correct MASTER/SLAVE config.
         *
         * If doesn't allowed users to config MASTER/SLAVE config,
         * set these speed to unsupported.
         */
        if (port_info[ifindex-1].port_entry.port_type == VAL_portType_thousandBaseT ||
            port_info[ifindex-1].port_entry.port_type == VAL_portType_tenGBaseT)
        {
            port_speed_duplex_supported &= ~ BIT_VALUE(VAL_portSpeedDpxCfg_halfDuplex1000);
            port_speed_duplex_supported &= ~ BIT_VALUE(VAL_portSpeedDpxCfg_fullDuplex1000);
            port_speed_duplex_supported &= ~ BIT_VALUE(VAL_portSpeedDpxCfg_halfDuplex10g);
            port_speed_duplex_supported &= ~ BIT_VALUE(VAL_portSpeedDpxCfg_fullDuplex10g);
        }
#endif

        ability_p->port_speed_duplex_supported = port_speed_duplex_supported;
    }

    /* flowctrl
     */
    {
        UI32_T port_flow_ctrl_cfg_supported = BIT_VALUE(VAL_portFlowCtrlCfg_disabled);

        if (port_ability.pause)
            port_flow_ctrl_cfg_supported |= BIT_VALUE(VAL_portFlowCtrlCfg_enabled);
        if (port_ability.pause_asymm)
            port_flow_ctrl_cfg_supported |= BIT_VALUE(VAL_portFlowCtrlCfg_tx) |
                                            BIT_VALUE(VAL_portFlowCtrlCfg_rx);

        ability_p->port_flow_ctrl_cfg_supported = port_flow_ctrl_cfg_supported;
    }

    /* autoneg
     */
    {
        UI32_T port_capabilities_supported = 0;
        UI32_T port_autoneg_supported = 0;

        if (port_ability.spd_10m_hd)
            port_capabilities_supported |= SYS_VAL_portCapabilities_portCap10half;
        if (port_ability.spd_10m_fd)
            port_capabilities_supported |= SYS_VAL_portCapabilities_portCap10full;
        if (port_ability.spd_100m_hd)
            port_capabilities_supported |= SYS_VAL_portCapabilities_portCap100half;
        if (port_ability.spd_100m_fd)
            port_capabilities_supported |= SYS_VAL_portCapabilities_portCap100full;
        if (port_ability.spd_1000m_hd)
            port_capabilities_supported |= SYS_VAL_portCapabilities_portCap1000half;
        if (port_ability.spd_1000m_fd)
            port_capabilities_supported |= SYS_VAL_portCapabilities_portCap1000full;
        if (port_ability.spd_10g_hd)
            port_capabilities_supported |= SYS_VAL_portCapabilities_portCap10gHalf;
        if (port_ability.spd_10g_fd)
            port_capabilities_supported |= SYS_VAL_portCapabilities_portCap10gFull;
        if (port_ability.spd_40g_hd)
            port_capabilities_supported |= SYS_VAL_portCapabilities_portCap40gHalf;
        if (port_ability.spd_40g_fd)
            port_capabilities_supported |= SYS_VAL_portCapabilities_portCap40gFull;
        if (port_ability.spd_100g_fd)
            port_capabilities_supported |= SYS_VAL_portCapabilities_portCap100gFull;

        if (port_ability.pause)
            port_capabilities_supported |= SYS_VAL_portCapabilities_portCapFlowCtrl;
        if (port_ability.pause_asymm)
            port_capabilities_supported |= SYS_VAL_portCapabilities_portCapSym;

        if (ability_p->port_speed_duplex_supported != 0)
            port_autoneg_supported |= BIT_VALUE(VAL_portAutonegotiation_disabled);
        if (port_ability.autoneg)
            port_autoneg_supported |= BIT_VALUE(VAL_portAutonegotiation_enabled);

        ability_p->port_capabilities_supported = port_capabilities_supported;
        ability_p->port_autoneg_supported = port_autoneg_supported;
    }

    /* fec */
    {
        UI32_T port_fec_supported = BIT_VALUE(VAL_portFecMode_disabled);

        if (port_ability.fec_baser)
            port_fec_supported |= BIT_VALUE(VAL_portFecMode_baseR);
        if (port_ability.fec_rs)
            port_fec_supported |= BIT_VALUE(VAL_portFecMode_rs);

        ability_p->port_fec_supported = port_fec_supported;
    }

    return TRUE;
}

/* -------------------------------------------------------------------------
 * FUNCTION NAME - SWCTRL_UpdatePortAbility
 * -------------------------------------------------------------------------
 * PURPOSE : To update port abilities to db from driver
 * INPUT   : unit
 *           port
 * OUTPUT  : None
 * RETURN  : None
 * NOTE    : TRUE if port ability is changed; FALSE if not changed.
 * -------------------------------------------------------------------------
 */
static BOOL_T SWCTRL_UpdatePortAbility(UI32_T unit, UI32_T port)
{
    UI32_T ifindex = SWCTRL_UPORT_TO_IFINDEX(unit, port);
    SWCTRL_PortAbility_T ability;
    BOOL_T is_changed = FALSE;

    SWCTRL_LOCK();

    if (!SWCTRL_GetPortAbilityFromDrv(unit, port, &ability))
    {
        /* if driver doesn't implement GetPortAbility,
         * call SWCTRL_GetPortAbilityByPortType instead.
         */
        SWCTRL_GetPortAbilityByPortType(unit, port, &ability);
    }

    if (memcmp(&user_ext_port_info[ifindex-1].port_abililty, &ability, sizeof(ability)) != 0)
    {
        user_ext_port_info[ifindex-1].port_abililty = ability;
        is_changed = TRUE;
    }

    SWCTRL_UNLOCK();

    if (SWCTRL_BACKDOOR_IsDebugFlagOn(SWCTRL_BACKDOOR_DEBUG_FLAG_ABIL))
    {
        BACKDOOR_MGR_Printf("\r\n %s: port: %lu/%lu is_changed: %u", __func__, unit, port, is_changed);
        BACKDOOR_MGR_Printf("\r\n  medium_forced_mode_supported: 0x%08lx",
            user_ext_port_info[ifindex-1].port_abililty.medium_forced_mode_supported);
        BACKDOOR_MGR_Printf("\r\n  medium_fiber_type_supported: 0x%08lx",
            user_ext_port_info[ifindex-1].port_abililty.medium_fiber_type_supported);
        BACKDOOR_MGR_Printf("\r\n  port_speed_duplex_supported: 0x%08lx",
            user_ext_port_info[ifindex-1].port_abililty.port_speed_duplex_supported);
        BACKDOOR_MGR_Printf("\r\n  port_flow_ctrl_cfg_supported: 0x%08lx",
            user_ext_port_info[ifindex-1].port_abililty.port_flow_ctrl_cfg_supported);
        BACKDOOR_MGR_Printf("\r\n  port_capabilities_supported: 0x%08lx",
            user_ext_port_info[ifindex-1].port_abililty.port_capabilities_supported);
        BACKDOOR_MGR_Printf("\r\n  port_autoneg_supported: 0x%08lx",
            user_ext_port_info[ifindex-1].port_abililty.port_autoneg_supported);
    }

    return is_changed;
}

/* -------------------------------------------------------------------------
 * FUNCTION NAME - SWCTRL_GetPortComboForcedModeDfltCfg
 * -------------------------------------------------------------------------
 * PURPOSE : To get default value of media type forced mode/fiber speed.
 * INPUT   : unit
 *           port
 * OUTPUT  : forcedmode_p
 *           fiber_speed_p
 * RETURN  : None
 * NOTE    : None
 * -------------------------------------------------------------------------
 */
static void SWCTRL_GetPortComboForcedModeDfltCfg(UI32_T unit, UI32_T port, UI32_T *forcedmode_p, UI32_T *fiber_speed_p)
{
    static UI32_T forcemode_list[] = {
        SYS_DFLT_COMBO_PORT_FORCED_MODE,
        VAL_portComboForcedMode_sfpPreferredAuto,
        VAL_portComboForcedMode_none,
        VAL_portComboForcedMode_copperForced,
        VAL_portComboForcedMode_sfpForced,
    };

    static UI32_T fiber_speed_list[] = {
#ifdef SYS_DFLT_COMBO_PORT_FORCED_MODE_SFP_SPEED
        SYS_DFLT_COMBO_PORT_FORCED_MODE_SFP_SPEED,
#endif
        VAL_portType_hundredGBaseQSFP,
        VAL_portType_fortyGBaseQSFP,
        VAL_portType_twentyFiveGBaseSFP,
        VAL_portType_tenGBaseSFP,
        VAL_portType_thousandBaseSfp,
        VAL_portType_hundredBaseFX,
    };

    UI32_T ifindex;
    UI32_T medium_forced_mode_supported;
    UI32_T medium_fiber_type_supported;
    UI32_T forcedmode, fiber_speed;
    int i;

    ifindex = SWCTRL_UPORT_TO_IFINDEX(unit, port);

    forcedmode = SYS_DFLT_COMBO_PORT_FORCED_MODE;
#ifdef SYS_DFLT_COMBO_PORT_FORCED_MODE_SFP_SPEED
    fiber_speed = SYS_DFLT_COMBO_PORT_FORCED_MODE_SFP_SPEED;
#else
    fiber_speed = VAL_portType_other;
#endif

    medium_forced_mode_supported = user_ext_port_info[ifindex-1].port_abililty.medium_forced_mode_supported;
    medium_fiber_type_supported = user_ext_port_info[ifindex-1].port_abililty.medium_fiber_type_supported;

    for (i = 0; i < sizeof(forcemode_list)/sizeof(*forcemode_list); i++)
    {
        if (medium_forced_mode_supported & BIT_VALUE(forcemode_list[i]))
        {
            forcedmode = forcemode_list[i];
            break;
        }
    }

    for (i = 0; i < sizeof(fiber_speed_list)/sizeof(*fiber_speed_list); i++)
    {
        if (medium_fiber_type_supported & BIT_VALUE(fiber_speed_list[i]))
        {
            fiber_speed = fiber_speed_list[i];
            break;
        }
    }

    if (forcedmode_p)
        *forcedmode_p = forcedmode;
    if (fiber_speed_p)
        *fiber_speed_p = fiber_speed;
}

/* -------------------------------------------------------------------------
 * FUNCTION NAME - SWCTRL_GetPortOptimumOperSpeedDuplex
 * -------------------------------------------------------------------------
 * PURPOSE : To get optimum speed duplex for default display.
 * INPUT   : unit
 *           port
 * OUTPUT  : forcedmode_p
 *           fiber_speed_p
 * RETURN  : None
 * NOTE    : None
 * -------------------------------------------------------------------------
 */
static UI32_T SWCTRL_GetPortOptimumOperSpeedDuplex(UI32_T unit, UI32_T port)
{
    UI32_T ifindex = SWCTRL_UPORT_TO_IFINDEX(unit, port);
    UI32_T port_type = port_info[ifindex-1].port_entry.port_type;
    UI32_T optimum_oper_port_speed_dpx_cfg = VAL_portSpeedDpxCfg_reserved;

    /* move from SWCTRL_ConfigUserPortToDefaultState
     */
    if( port_type == VAL_portType_hundredBaseTX )                  /*FE_COPPER*/
    {
        optimum_oper_port_speed_dpx_cfg = VAL_portSpeedDpxCfg_fullDuplex100;
    }
    else if( port_type == VAL_portType_hundredBaseFX             || /*FE_FIBER*/
             port_type == VAL_portType_hundredBaseFxScSingleMode ||
             port_type == VAL_portType_hundredBaseFxScMultiMode  )
    {
        optimum_oper_port_speed_dpx_cfg = VAL_portSpeedDpxCfg_fullDuplex100;
    }
    else if( port_type == VAL_portType_thousandBaseSX   ||         /*GE_FIBER*/
             port_type == VAL_portType_thousandBaseLX   ||
             port_type == VAL_portType_thousandBaseGBIC ||
             port_type == VAL_portType_thousandBaseSfp  )
    {
        optimum_oper_port_speed_dpx_cfg = VAL_portSpeedDpxCfg_fullDuplex1000;
    }
    else if( port_type == VAL_portType_tenG         ||
             port_type == VAL_portType_tenGBaseT    ||
             port_type == VAL_portType_tenGBaseXFP  ||
             port_type == VAL_portType_tenGBaseSFP    )                      /*10G port*/
    {
        optimum_oper_port_speed_dpx_cfg = VAL_portSpeedDpxStatus_fullDuplex10g;
    }
    else if( port_type == VAL_portType_twentyFiveGBaseSFP ) /* 25G port */
    {
        optimum_oper_port_speed_dpx_cfg = VAL_portSpeedDpxStatus_fullDuplex25g;
    }
    else if( port_type == VAL_portType_fortyGBaseQSFP ) /* 40G port */
    {
        optimum_oper_port_speed_dpx_cfg = VAL_portSpeedDpxStatus_fullDuplex40g;
    }
    else if( port_type == VAL_portType_hundredGBaseQSFP ) /* 100G port */
    {
        optimum_oper_port_speed_dpx_cfg = VAL_portSpeedDpxStatus_fullDuplex100g;
    }
    else                                                           /*GE_COPPER*/
    {
        optimum_oper_port_speed_dpx_cfg = VAL_portSpeedDpxCfg_fullDuplex1000;
    }

    return optimum_oper_port_speed_dpx_cfg;
}

/* -------------------------------------------------------------------------
 * FUNCTION NAME - SWCTRL_GetPortCfgSpeedDuplexDfltCfg
 * -------------------------------------------------------------------------
 * PURPOSE : To get default value of speed duplex.
 * INPUT   : unit
 *           port
 * OUTPUT  : None
 * RETURN  : default value of speed duplex
 * NOTE    : None
 * -------------------------------------------------------------------------
 */
static UI32_T SWCTRL_GetPortCfgSpeedDuplexDfltCfg(UI32_T unit, UI32_T port)
{
    UI32_T ifindex = SWCTRL_UPORT_TO_IFINDEX(unit, port);
    UI32_T port_type = port_info[ifindex-1].port_entry.port_type;
    UI32_T dflt_port_speed_dpx_cfg;

    if (port_type == VAL_portType_hundredBaseTX)
    {
        dflt_port_speed_dpx_cfg = SYS_DFLT_FE_COPPER_PORT_FORCE_MODE_SPDDPX;
    }
    else if (port_type == VAL_portType_thousandBaseT)
    {
        dflt_port_speed_dpx_cfg = SYS_DFLT_GE_COPPER_PORT_FORCE_MODE_SPDDPX;
    }
    else if (port_type == VAL_portType_hundredBaseFX             ||
             port_type == VAL_portType_hundredBaseFxScSingleMode ||
             port_type == VAL_portType_hundredBaseFxScMultiMode  )
    {
        dflt_port_speed_dpx_cfg = SYS_DFLT_FE_FIBER_PORT_FORCE_MODE_SPDDPX;
    }
    else if (port_type == VAL_portType_thousandBaseSX   ||
             port_type == VAL_portType_thousandBaseLX   ||
             port_type == VAL_portType_thousandBaseGBIC ||
             port_type == VAL_portType_thousandBaseSfp  )
    {
        dflt_port_speed_dpx_cfg = SYS_DFLT_GE_FIBER_PORT_FORCE_MODE_SPDDPX;
    }
#ifdef SYS_DFLT_40GE_FIBER_PORT_FORCE_MODE_SPDDPX
    else if (port_type == VAL_portType_fortyGBaseQSFP)
    {
        dflt_port_speed_dpx_cfg = SYS_DFLT_40GE_FIBER_PORT_FORCE_MODE_SPDDPX;
    }
#endif
#ifdef SYS_DFLT_10GE_FIBER_PORT_FORCE_MODE_SPDDPX
    else if (port_type == VAL_portType_tenG         ||
             port_type == VAL_portType_tenGBaseXFP  ||
             port_type == VAL_portType_tenGBaseSFP  )
    {
        dflt_port_speed_dpx_cfg = SYS_DFLT_10GE_FIBER_PORT_FORCE_MODE_SPDDPX;
    }
#endif
#ifdef SYS_DFLT_10GE_COPPER_PORT_FORCE_MODE_SPDDPX
    else if (port_type == VAL_portType_tenGBaseT)
    {
        dflt_port_speed_dpx_cfg = SYS_DFLT_10GE_COPPER_PORT_FORCE_MODE_SPDDPX;
    }
#endif
    else
    {
        dflt_port_speed_dpx_cfg = VAL_portSpeedDpxCfg_reserved;
    }

    if (BIT_VALUE(dflt_port_speed_dpx_cfg) & ~user_ext_port_info[ifindex-1].port_abililty.port_speed_duplex_supported)
    {
        UI32_T port_speed_duplex_supported = user_ext_port_info[ifindex-1].port_abililty.port_speed_duplex_supported;

        dflt_port_speed_dpx_cfg =
            ((port_speed_duplex_supported & BIT_VALUE(VAL_portSpeedDpxCfg_fullDuplex100g)) ? VAL_portSpeedDpxCfg_fullDuplex100g :
            ((port_speed_duplex_supported & BIT_VALUE(VAL_portSpeedDpxCfg_fullDuplex40g)) ? VAL_portSpeedDpxCfg_fullDuplex40g :
            ((port_speed_duplex_supported & BIT_VALUE(VAL_portSpeedDpxCfg_fullDuplex25g)) ? VAL_portSpeedDpxCfg_fullDuplex25g :
            ((port_speed_duplex_supported & BIT_VALUE(VAL_portSpeedDpxCfg_fullDuplex10g)) ? VAL_portSpeedDpxCfg_fullDuplex10g :
            ((port_speed_duplex_supported & BIT_VALUE(VAL_portSpeedDpxCfg_fullDuplex1000)) ? VAL_portSpeedDpxCfg_fullDuplex1000 :
            ((port_speed_duplex_supported & BIT_VALUE(VAL_portSpeedDpxCfg_fullDuplex100)) ? VAL_portSpeedDpxCfg_fullDuplex100 :
            ((port_speed_duplex_supported & BIT_VALUE(VAL_portSpeedDpxCfg_fullDuplex10)) ? VAL_portSpeedDpxCfg_fullDuplex10 :
            ((port_speed_duplex_supported & BIT_VALUE(VAL_portSpeedDpxCfg_halfDuplex100g)) ? VAL_portSpeedDpxCfg_halfDuplex100g :
            ((port_speed_duplex_supported & BIT_VALUE(VAL_portSpeedDpxCfg_halfDuplex40g)) ? VAL_portSpeedDpxCfg_halfDuplex40g :
            ((port_speed_duplex_supported & BIT_VALUE(VAL_portSpeedDpxCfg_halfDuplex10g)) ? VAL_portSpeedDpxCfg_halfDuplex10g :
            ((port_speed_duplex_supported & BIT_VALUE(VAL_portSpeedDpxCfg_halfDuplex1000)) ? VAL_portSpeedDpxCfg_halfDuplex1000 :
            ((port_speed_duplex_supported & BIT_VALUE(VAL_portSpeedDpxCfg_halfDuplex100)) ? VAL_portSpeedDpxCfg_halfDuplex100 :
            ((port_speed_duplex_supported & BIT_VALUE(VAL_portSpeedDpxCfg_halfDuplex10)) ? VAL_portSpeedDpxCfg_halfDuplex10 :
            VAL_portSpeedDpxCfg_reserved)))))))))))));
    }

    if (dflt_port_speed_dpx_cfg == VAL_portSpeedDpxCfg_reserved)
    {
        dflt_port_speed_dpx_cfg = SWCTRL_GetPortOptimumOperSpeedDuplex(unit, port);
    }

    return dflt_port_speed_dpx_cfg;
}

/* -------------------------------------------------------------------------
 * FUNCTION NAME - SWCTRL_GetPortCfgFlowCtrlDfltCfg
 * -------------------------------------------------------------------------
 * PURPOSE : To get default value of flow ctrl.
 * INPUT   : unit
 *           port
 * OUTPUT  : None
 * RETURN  : default value of flow ctrl
 * NOTE    : None
 * -------------------------------------------------------------------------
 */
static UI32_T SWCTRL_GetPortCfgFlowCtrlDfltCfg(UI32_T unit, UI32_T port)
{
    UI32_T ifindex = SWCTRL_UPORT_TO_IFINDEX(unit, port);
    UI32_T dflt_port_flow_ctrl_cfg;

    if (user_ext_port_info[ifindex-1].port_abililty.port_flow_ctrl_cfg_supported & BIT_VALUE(SYS_DFLT_PORT_FLOW_CONTROL))
    {
        dflt_port_flow_ctrl_cfg = SYS_DFLT_PORT_FLOW_CONTROL;
    }
    else
    {
        dflt_port_flow_ctrl_cfg = VAL_portAutonegotiation_disabled;
    }

    return dflt_port_flow_ctrl_cfg;
}

/* -------------------------------------------------------------------------
 * FUNCTION NAME - SWCTRL_GetPortAutoNegCapabilityDfltCfg
 * -------------------------------------------------------------------------
 * PURPOSE : To get default value of autoneg capabilities.
 * INPUT   : unit
 *           port
 * OUTPUT  : None
 * RETURN  : default value of autoneg capabilities
 * NOTE    : None
 * -------------------------------------------------------------------------
 */
static UI32_T SWCTRL_GetPortAutoNegCapabilityDfltCfg(UI32_T unit, UI32_T port)
{
    UI32_T ifindex = SWCTRL_UPORT_TO_IFINDEX(unit, port);
    UI32_T port_type = port_info[ifindex-1].port_entry.port_type;
    UI32_T dflt_port_capabilities = 0;

    /* 100 Copper */
    if (port_type == VAL_portType_hundredBaseTX)
    {
        dflt_port_capabilities = SYS_DFLT_10_100_PORT_CAPABILITIES;
    }
    /* 1000 Copper */
    else if (port_type == VAL_portType_thousandBaseSfp)
    {
        dflt_port_capabilities = SYS_DFLT_10_100_1000_PORT_CAPABILITIES;
    }
    /* 100 Fiber */
    else if (port_type == VAL_portType_hundredBaseFX             ||
             port_type == VAL_portType_hundredBaseFxScSingleMode ||
             port_type == VAL_portType_hundredBaseFxScMultiMode  )
    {
        dflt_port_capabilities = SYS_DFLT_100_FIBER_PORT_CAPABILITIES;
    }
    /* 1000 Fiber */
    else if (port_type == VAL_portType_thousandBaseSX   ||
             port_type == VAL_portType_thousandBaseLX   ||
             port_type == VAL_portType_thousandBaseGBIC ||
             port_type == VAL_portType_thousandBaseSfp  )
    {
        dflt_port_capabilities = SYS_DFLT_1000_FIBER_PORT_CAPABILITIES ;
    }
#ifdef SYS_DFLT_10G_FIBER_PORT_CAPABILITIES
    /* 10G Fiber */
    else if (port_type == VAL_portType_tenG         ||
             port_type == VAL_portType_tenGBaseXFP  ||
             port_type == VAL_portType_tenGBaseSFP  )
    {
        dflt_port_capabilities = SYS_DFLT_10G_FIBER_PORT_CAPABILITIES;
    }
#endif
#ifdef SYS_DFLT_10G_COPPER_PORT_CAPABILITIES
    /* 10G Copper */
    else if (port_type == VAL_portType_tenGBaseT)
    {
        dflt_port_capabilities = SYS_DFLT_10G_COPPER_PORT_CAPABILITIES;
    }
#endif
#ifdef SYS_DFLT_40G_FIBER_PORT_CAPABILITIES
    /* 40G Fiber */
    else if (port_type == VAL_portType_fortyGBaseQSFP)
    {
        dflt_port_capabilities = SYS_DFLT_40G_FIBER_PORT_CAPABILITIES;
    }
#endif
    else /* for new type */
    {
        dflt_port_capabilities = 0;
    }

    if (dflt_port_capabilities == 0 ||
        (dflt_port_capabilities & ~user_ext_port_info[ifindex-1].port_abililty.port_speed_duplex_supported))
    {
        if (user_ext_port_info[ifindex-1].port_abililty.port_autoneg_supported & BIT_VALUE(VAL_portAutonegotiation_enabled))
        {
            dflt_port_capabilities = user_ext_port_info[ifindex-1].port_abililty.port_capabilities_supported;

            if (SYS_DFLT_PORT_FLOW_CONTROL == VAL_portFlowCtrlCfg_disabled)
            {
                dflt_port_capabilities &= ~ SYS_VAL_portCapabilities_portCapFlowCtrl;
                dflt_port_capabilities &= ~ SYS_VAL_portCapabilities_portCapSym;
            }
        }
        else
        {
            UI32_T port_capabilities_supported = user_ext_port_info[ifindex-1].port_abililty.port_capabilities_supported;

            dflt_port_capabilities =
                ((port_capabilities_supported & SYS_VAL_portCapabilities_portCap40gFull) ? SYS_VAL_portCapabilities_portCap40gFull :
                ((port_capabilities_supported & SYS_VAL_portCapabilities_portCap10gFull) ? SYS_VAL_portCapabilities_portCap10gFull :
                ((port_capabilities_supported & SYS_VAL_portCapabilities_portCap1000full) ? SYS_VAL_portCapabilities_portCap1000full :
                ((port_capabilities_supported & SYS_VAL_portCapabilities_portCap100full) ? SYS_VAL_portCapabilities_portCap100full :
                ((port_capabilities_supported & SYS_VAL_portCapabilities_portCap10full) ? SYS_VAL_portCapabilities_portCap10full :
                ((port_capabilities_supported & SYS_VAL_portCapabilities_portCap40gHalf) ? SYS_VAL_portCapabilities_portCap40gHalf :
                ((port_capabilities_supported & SYS_VAL_portCapabilities_portCap10gHalf) ? SYS_VAL_portCapabilities_portCap10gHalf :
                ((port_capabilities_supported & SYS_VAL_portCapabilities_portCap1000half) ? SYS_VAL_portCapabilities_portCap1000half :
                ((port_capabilities_supported & SYS_VAL_portCapabilities_portCap100half) ? SYS_VAL_portCapabilities_portCap100half :
                SYS_VAL_portCapabilities_portCap10half)))))))));
        }
    }

    dflt_port_capabilities &= user_ext_port_info[ifindex-1].port_abililty.port_capabilities_supported;

    return dflt_port_capabilities;
}

/* -------------------------------------------------------------------------
 * FUNCTION NAME - SWCTRL_GetPortAutoNegStatusDfltCfg
 * -------------------------------------------------------------------------
 * PURPOSE : To get default value of autoneg status.
 * INPUT   : unit
 *           port
 * OUTPUT  : None
 * RETURN  : default value of autoneg status
 * NOTE    : None
 * -------------------------------------------------------------------------
 */
static UI32_T SWCTRL_GetPortAutoNegStatusDfltCfg(UI32_T unit, UI32_T port)
{
    UI32_T ifindex = SWCTRL_UPORT_TO_IFINDEX(unit, port);
    UI32_T dflt_port_autonegotiation;

    if (user_ext_port_info[ifindex-1].port_abililty.port_autoneg_supported & BIT_VALUE(SYS_DFLT_PORT_AUTONEGOTIATION))
    {
        dflt_port_autonegotiation = SYS_DFLT_PORT_AUTONEGOTIATION;
    }
    else if (user_ext_port_info[ifindex-1].port_abililty.port_autoneg_supported & BIT_VALUE(VAL_portAutonegotiation_enabled))
    {
        dflt_port_autonegotiation = VAL_portAutonegotiation_enabled;
    }
    else
    {
        dflt_port_autonegotiation = VAL_portAutonegotiation_disabled;
    }

    return dflt_port_autonegotiation;
}

#if (SYS_CPNT_SWCTRL_FEC == TRUE)
/* -------------------------------------------------------------------------
 * FUNCTION NAME - SWCTRL_GetPortFecDfltCfg
 * -------------------------------------------------------------------------
 * PURPOSE : To get default value of FEC mode.
 * INPUT   : unit
 *           port
 * OUTPUT  : None
 * RETURN  : default value of FEC mode
 * NOTE    : None
 * -------------------------------------------------------------------------
 */
static UI32_T SWCTRL_GetPortFecDfltCfg(UI32_T unit, UI32_T port)
{
    return VAL_portFecMode_disabled;
}
#endif
#endif /* (SWCTRL_UPDATE_PORT_ABILITY == TRUE) */

/* -------------------------------------------------------------------------
 * FUNCTION NAME - SWCTRL_GetPortAbilityByPortType
 * -------------------------------------------------------------------------
 * PURPOSE : To get port abilities by port type
 * INPUT   : unit
 *           port
 * OUTPUT  : ability_p  -- SWCTRL_PortAbility_T
 * RETURN  : None
 * NOTE    : For backward compatibility only,
 *           it is used when devdrv is not ready for SWCTRL_UpdatePortAbility
 *           and would not be maintained for new project/hardware.
 * -------------------------------------------------------------------------
 */
static void SWCTRL_GetPortAbilityByPortType(UI32_T unit, UI32_T port, SWCTRL_PortAbility_T *ability_p)
{
    UI32_T ifindex = SWCTRL_UPORT_TO_IFINDEX(unit, port);

    memset(ability_p, 0, sizeof(SWCTRL_PortAbility_T));

    /* medium type
     */
    {
        UI32_T medium_forced_mode_supported = BIT_VALUE(VAL_portComboForcedMode_none);
        UI32_T medium_fiber_type_supported = 0;

#if (SYS_CPNT_COMBO_PORT_FORCE_MODE == TRUE)
        medium_forced_mode_supported = SWCTRL_GetSupportedPortComboForcedMode_Local(ifindex);

        if (medium_forced_mode_supported & VAL_portComboForcedMode_sfpForced)
        {
            medium_fiber_type_supported =
                VAL_portType_hundredBaseFX |
                VAL_portType_thousandBaseSfp;
        }
#endif

        ability_p->medium_forced_mode_supported = medium_forced_mode_supported;
        ability_p->medium_fiber_type_supported = medium_fiber_type_supported;
    }

    /* speed duplex
     * flowctrl
     * autoneg
     */
    {
        UI32_T port_speed_duplex_supported = 0;
        UI32_T port_flow_ctrl_cfg_supported = BIT_VALUE(VAL_portFlowCtrlCfg_disabled) | BIT_VALUE(VAL_portFlowCtrlCfg_enabled);
        UI32_T port_capabilities_supported = 0;
        UI32_T port_autoneg_supported = 0;

        switch (port_info[ifindex-1].port_entry.port_type)
        {
            case VAL_portType_hundredBaseTX:
                port_speed_duplex_supported |=
                    BIT_VALUE(VAL_portSpeedDpxCfg_halfDuplex10) |
                    BIT_VALUE(VAL_portSpeedDpxCfg_fullDuplex10) |
                    BIT_VALUE(VAL_portSpeedDpxCfg_halfDuplex100) |
                    BIT_VALUE(VAL_portSpeedDpxCfg_fullDuplex100);
                port_capabilities_supported |=
                    SYS_VAL_portCapabilities_portCap10half |
                    SYS_VAL_portCapabilities_portCap10full |
                    SYS_VAL_portCapabilities_portCap100half |
                    SYS_VAL_portCapabilities_portCap100full |
                    SYS_VAL_portCapabilities_portCapFlowCtrl;
                port_autoneg_supported |=
                    BIT_VALUE(VAL_portAutonegotiation_disabled) |
                    BIT_VALUE(VAL_portAutonegotiation_enabled);
                break;

            case VAL_portType_thousandBaseT:
                port_speed_duplex_supported |=
                    BIT_VALUE(VAL_portSpeedDpxCfg_halfDuplex10) |
                    BIT_VALUE(VAL_portSpeedDpxCfg_fullDuplex10) |
                    BIT_VALUE(VAL_portSpeedDpxCfg_halfDuplex100) |
                    BIT_VALUE(VAL_portSpeedDpxCfg_fullDuplex100);
                port_capabilities_supported |=
                    SYS_VAL_portCapabilities_portCap10half |
                    SYS_VAL_portCapabilities_portCap10full |
                    SYS_VAL_portCapabilities_portCap100half |
                    SYS_VAL_portCapabilities_portCap100full |
                    SYS_VAL_portCapabilities_portCap1000full |
                    SYS_VAL_portCapabilities_portCapSym;
                port_autoneg_supported |=
                    BIT_VALUE(VAL_portAutonegotiation_disabled) |
                    BIT_VALUE(VAL_portAutonegotiation_enabled);
                break;

            case VAL_portType_tenGBaseT:
                port_capabilities_supported |=
                    SYS_VAL_portCapabilities_portCap10gFull |
                    SYS_VAL_portCapabilities_portCapFlowCtrl |
                    SYS_VAL_portCapabilities_portCapSym;
                port_autoneg_supported |=
                    BIT_VALUE(VAL_portAutonegotiation_enabled);
                break;

            case VAL_portType_hundredBaseFX:
                port_speed_duplex_supported |=
                    BIT_VALUE(VAL_portSpeedDpxCfg_halfDuplex100) |
                    BIT_VALUE(VAL_portSpeedDpxCfg_fullDuplex100);
                port_capabilities_supported |=
                    SYS_VAL_portCapabilities_portCap100half |
                    SYS_VAL_portCapabilities_portCap100full |
                    SYS_VAL_portCapabilities_portCapFlowCtrl;
                port_autoneg_supported |=
                    BIT_VALUE(VAL_portAutonegotiation_disabled);
                break;

            case VAL_portType_thousandBaseSfp:
                port_speed_duplex_supported |=
                    BIT_VALUE(VAL_portSpeedDpxCfg_fullDuplex1000);
                port_capabilities_supported |=
                    SYS_VAL_portCapabilities_portCap1000full |
                    SYS_VAL_portCapabilities_portCapFlowCtrl |
                    SYS_VAL_portCapabilities_portCapSym;
                port_autoneg_supported |=
                    BIT_VALUE(VAL_portAutonegotiation_disabled) |
                    BIT_VALUE(VAL_portAutonegotiation_enabled);
                break;

            case VAL_portType_tenGBaseSFP:
            case VAL_portType_tenGBaseXFP:
                port_speed_duplex_supported |=
                    BIT_VALUE(VAL_portSpeedDpxCfg_fullDuplex10g);
                port_capabilities_supported |=
                    SYS_VAL_portCapabilities_portCap10gFull |
                    SYS_VAL_portCapabilities_portCapFlowCtrl |
                    SYS_VAL_portCapabilities_portCapSym;
                port_autoneg_supported |=
                    BIT_VALUE(VAL_portAutonegotiation_disabled);
                break;

            case VAL_portType_twentyFiveGBaseSFP:
                port_speed_duplex_supported |=
                    BIT_VALUE(VAL_portSpeedDpxCfg_fullDuplex25g);
                port_capabilities_supported = 0;
                port_autoneg_supported |=
                    BIT_VALUE(VAL_portAutonegotiation_disabled);
                break;

            case VAL_portType_fortyGBaseQSFP:
                port_speed_duplex_supported |=
                    BIT_VALUE(VAL_portSpeedDpxCfg_fullDuplex40g);
                port_capabilities_supported |=
                    SYS_VAL_portCapabilities_portCap40gFull |
                    SYS_VAL_portCapabilities_portCapFlowCtrl |
                    SYS_VAL_portCapabilities_portCapSym;
                port_autoneg_supported |=
                    BIT_VALUE(VAL_portAutonegotiation_disabled);
                break;

            case VAL_portType_hundredGBaseQSFP:
                port_speed_duplex_supported |=
                    BIT_VALUE(VAL_portSpeedDpxCfg_fullDuplex100g);
                port_capabilities_supported = 0;
                port_autoneg_supported |=
                    BIT_VALUE(VAL_portAutonegotiation_disabled);
                break;

            default:
                if (SWCTRL_BACKDOOR_IsDebugFlagOn (SWCTRL_BACKDOOR_DEBUG_FLAG_ERRMSG))
                {
                    BACKDOOR_MGR_Printf("\r\n%s(%d):", __FUNCTION__, __LINE__);
                    BACKDOOR_MGR_Printf("Failed: unit: %lu port: %lu port_type: %lu\r\n",
                           unit, port, port_info[ifindex-1].port_entry.port_type);
                }
        }

        ability_p->port_speed_duplex_supported = port_speed_duplex_supported;
        ability_p->port_flow_ctrl_cfg_supported = port_flow_ctrl_cfg_supported;
        ability_p->port_capabilities_supported = port_capabilities_supported;
        ability_p->port_autoneg_supported = port_autoneg_supported;
    }
}

#if (SYS_CPNT_SFP_DDM_ALARMWARN_TRAP == TRUE)
static void SWCTRL_SendPortSfpDdmTrap(UI32_T unit, UI32_T sfp_index, UI32_T trap_type)
{
    TRAP_EVENT_TrapData_T       trap_data;
    UI32_T port, ifindex;

    trap_data.trap_type           = trap_type;
    trap_data.community_specified = FALSE;

    /* get unit/port
     */
    STKTPLG_OM_SfpIndexToUserPort(unit, sfp_index, &port);
    ifindex = STKTPLG_OM_UPORT_TO_IFINDEX(unit, port);

    /* trapSfpThresholdAlarmWarnIfIndex
     */
    trap_data.u.sfp_ddm_alarmwarn_trap.sfp_ddm_alarmwarn_ifindex = ifindex;

    /* trapSfpThresholdAlarmWarnType
     */
    switch(trap_type)
    {
         /* rx power
          */
         case TRAP_EVENT_SFP_RX_POWER_HIGH_ALARM:
             trap_data.u.sfp_ddm_alarmwarn_trap.sfp_ddm_alarmwarn_type = VAL_trapSfpThresholdAlarmWarnType_rxPowerHighAlarm;
             break;
         case TRAP_EVENT_SFP_RX_POWER_LOW_ALARM:
             trap_data.u.sfp_ddm_alarmwarn_trap.sfp_ddm_alarmwarn_type = VAL_trapSfpThresholdAlarmWarnType_rxPowerLowAlarm;
             break;
         case TRAP_EVENT_SFP_RX_POWER_HIGH_WARNING:
             trap_data.u.sfp_ddm_alarmwarn_trap.sfp_ddm_alarmwarn_type = VAL_trapSfpThresholdAlarmWarnType_rxPowerHighWarning;
             break;
         case TRAP_EVENT_SFP_RX_POWER_LOW_WARNING:
             trap_data.u.sfp_ddm_alarmwarn_trap.sfp_ddm_alarmwarn_type = VAL_trapSfpThresholdAlarmWarnType_rxPowerLowWarning;
             break;
         case TRAP_EVENT_SFP_RX_POWER_ALARMWARN_CEASE:
             trap_data.u.sfp_ddm_alarmwarn_trap.sfp_ddm_alarmwarn_type = VAL_trapSfpThresholdAlarmWarnType_rxPowerAlarmWarnCease;
             break;

         /* tx power
          */
         case TRAP_EVENT_SFP_TX_POWER_HIGH_ALARM:
             trap_data.u.sfp_ddm_alarmwarn_trap.sfp_ddm_alarmwarn_type = VAL_trapSfpThresholdAlarmWarnType_txPowerHighAlarm;
             break;
         case TRAP_EVENT_SFP_TX_POWER_LOW_ALARM:
             trap_data.u.sfp_ddm_alarmwarn_trap.sfp_ddm_alarmwarn_type = VAL_trapSfpThresholdAlarmWarnType_txPowerLowAlarm;
             break;
         case TRAP_EVENT_SFP_TX_POWER_HIGH_WARNING:
             trap_data.u.sfp_ddm_alarmwarn_trap.sfp_ddm_alarmwarn_type = VAL_trapSfpThresholdAlarmWarnType_txPowerHighWarning;
             break;
         case TRAP_EVENT_SFP_TX_POWER_LOW_WARNING:
             trap_data.u.sfp_ddm_alarmwarn_trap.sfp_ddm_alarmwarn_type = VAL_trapSfpThresholdAlarmWarnType_txPowerLowWarning;
             break;
         case TRAP_EVENT_SFP_TX_POWER_ALARMWARN_CEASE:
             trap_data.u.sfp_ddm_alarmwarn_trap.sfp_ddm_alarmwarn_type = VAL_trapSfpThresholdAlarmWarnType_txPowerAlarmWarnCease;
             break;

         /* temperature
          */
         case TRAP_EVENT_SFP_TEMP_HIGH_ALARM:
             trap_data.u.sfp_ddm_alarmwarn_trap.sfp_ddm_alarmwarn_type = VAL_trapSfpThresholdAlarmWarnType_temperatureHighAlarm;
             break;
         case TRAP_EVENT_SFP_TEMP_LOW_ALARM:
             trap_data.u.sfp_ddm_alarmwarn_trap.sfp_ddm_alarmwarn_type = VAL_trapSfpThresholdAlarmWarnType_temperatureLowAlarm;
             break;
         case TRAP_EVENT_SFP_TEMP_HIGH_WARNING:
             trap_data.u.sfp_ddm_alarmwarn_trap.sfp_ddm_alarmwarn_type = VAL_trapSfpThresholdAlarmWarnType_temperatureHighWarning;
             break;
         case TRAP_EVENT_SFP_TEMP_LOW_WARNING:
             trap_data.u.sfp_ddm_alarmwarn_trap.sfp_ddm_alarmwarn_type = VAL_trapSfpThresholdAlarmWarnType_temperatureLowWarning;
             break;
         case TRAP_EVENT_SFP_TEMP_ALARMWARN_CEASE:
             trap_data.u.sfp_ddm_alarmwarn_trap.sfp_ddm_alarmwarn_type = VAL_trapSfpThresholdAlarmWarnType_temperatureAlarmWarnCease;
             break;

         /* voltage
          */
         case TRAP_EVENT_SFP_VOLTAGE_HIGH_ALARM:
             trap_data.u.sfp_ddm_alarmwarn_trap.sfp_ddm_alarmwarn_type = VAL_trapSfpThresholdAlarmWarnType_voltageHighAlarm;
             break;
         case TRAP_EVENT_SFP_VOLTAGE_LOW_ALARM:
             trap_data.u.sfp_ddm_alarmwarn_trap.sfp_ddm_alarmwarn_type = VAL_trapSfpThresholdAlarmWarnType_voltageLowAlarm;
             break;
         case TRAP_EVENT_SFP_VOLTAGE_HIGH_WARNING:
             trap_data.u.sfp_ddm_alarmwarn_trap.sfp_ddm_alarmwarn_type = VAL_trapSfpThresholdAlarmWarnType_voltageHighWarning;
             break;
         case TRAP_EVENT_SFP_VOLTAGE_LOW_WARNING:
             trap_data.u.sfp_ddm_alarmwarn_trap.sfp_ddm_alarmwarn_type = VAL_trapSfpThresholdAlarmWarnType_voltageLowWarning;
             break;
         case TRAP_EVENT_SFP_VOLTAGE_ALARMWARN_CEASE:
             trap_data.u.sfp_ddm_alarmwarn_trap.sfp_ddm_alarmwarn_type = VAL_trapSfpThresholdAlarmWarnType_voltageAlarmWarnCease;
             break;

         /* current
          */
         case TRAP_EVENT_SFP_CURRENT_HIGH_ALARM:
             trap_data.u.sfp_ddm_alarmwarn_trap.sfp_ddm_alarmwarn_type = VAL_trapSfpThresholdAlarmWarnType_currentHighAlarm;
             break;
         case TRAP_EVENT_SFP_CURRENT_LOW_ALARM:
             trap_data.u.sfp_ddm_alarmwarn_trap.sfp_ddm_alarmwarn_type = VAL_trapSfpThresholdAlarmWarnType_currentLowAlarm;
             break;
         case TRAP_EVENT_SFP_CURRENT_HIGH_WARNING:
             trap_data.u.sfp_ddm_alarmwarn_trap.sfp_ddm_alarmwarn_type = VAL_trapSfpThresholdAlarmWarnType_currentHighWarning;
             break;
         case TRAP_EVENT_SFP_CURRENT_LOW_WARNING:
             trap_data.u.sfp_ddm_alarmwarn_trap.sfp_ddm_alarmwarn_type = VAL_trapSfpThresholdAlarmWarnType_currentLowWarning;
             break;
         case TRAP_EVENT_SFP_CURRENT_ALARMWARN_CEASE:
             trap_data.u.sfp_ddm_alarmwarn_trap.sfp_ddm_alarmwarn_type = VAL_trapSfpThresholdAlarmWarnType_currentAlarmWarnCease;
             break;
    }

#if (SYS_CPNT_TRAPMGMT == TRUE)
    TRAP_MGR_ReqSendTrapOptional(&trap_data, TRAP_EVENT_SEND_TRAP_OPTION_LOG_AND_TRAP);
#else
    SNMP_PMGR_ReqSendTrapOptional(&trap_data, TRAP_EVENT_SEND_TRAP_OPTION_LOG_AND_TRAP);
#endif

    return;
}
#endif

/* -------------------------------------------------------------------------
 * FUNCTION NAME - SWCTRL_GetPortAbility
 * -------------------------------------------------------------------------
 * PURPOSE : To get port abilities
 * INPUT   : ifindex
 * OUTPUT  : ability_p  -- SWCTRL_PortAbility_T
 * RETURN  : TRUE / FALSE
 * NOTE    : None
 * -------------------------------------------------------------------------
 */
BOOL_T SWCTRL_GetPortAbility(UI32_T ifindex, SWCTRL_PortAbility_T *ability_p)
{
    UI32_T unit, port;
    BOOL_T ret = TRUE;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (!(ifindex != 0 && ifindex <= SYS_ADPT_TOTAL_NBR_OF_LPORT) ||
        !SWCTRL_IS_EXIST(ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_DEB_MSG,
                                  SYSLOG_LEVEL_INFO,
                                  "Port is not a logical port.");  /*SWCTRL_ENO_NOT_A_LOGICAL_PORT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    SWCTRL_LOCK();

    memset(ability_p, 0, sizeof(SWCTRL_PortAbility_T));

    if (SWCTRL_IS_TRUNK(ifindex))
    {
        UI32_T primary_ifindex;

        if (!SWCTRL_GetTrunkPrimaryPort(ifindex, &primary_ifindex))
        {
            SWCTRL_UNLOCK();
            SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
        }

        unit = SWCTRL_IFINDEX_TO_UNIT(primary_ifindex);
        port = SWCTRL_IFINDEX_TO_PORT(primary_ifindex);
    }
    else
    {
        unit = SWCTRL_IFINDEX_TO_UNIT(ifindex);
        port = SWCTRL_IFINDEX_TO_PORT(ifindex);
    }

#if (SWCTRL_UPDATE_PORT_ABILITY == TRUE)
    *ability_p = user_ext_port_info[SWCTRL_UPORT_TO_IFINDEX(unit, port)-1].port_abililty;
#else
    ret = SWCTRL_GetPortAbilityByPortType(unit, port, ability_p);
#endif

    if (SWCTRL_IS_TRUNK(ifindex))
    {
        ability_p->medium_forced_mode_supported = 0;
        ability_p->medium_fiber_type_supported = 0;
    }

    SWCTRL_UNLOCK();

    if (SWCTRL_BACKDOOR_IsDebugFlagOn(SWCTRL_BACKDOOR_DEBUG_FLAG_ABIL))
    {
        BACKDOOR_MGR_Printf("\r\n %s: port: %lu/%lu", __func__, unit, port);
        BACKDOOR_MGR_Printf("\r\n  medium_forced_mode_supported: 0x%08lx",
            ability_p->medium_forced_mode_supported);
        BACKDOOR_MGR_Printf("\r\n  medium_fiber_type_supported: 0x%08lx",
            ability_p->medium_fiber_type_supported);
        BACKDOOR_MGR_Printf("\r\n  port_speed_duplex_supported: 0x%08lx",
            ability_p->port_speed_duplex_supported);
        BACKDOOR_MGR_Printf("\r\n  port_flow_ctrl_cfg_supported: 0x%08lx",
            ability_p->port_flow_ctrl_cfg_supported);
        BACKDOOR_MGR_Printf("\r\n  port_capabilities_supported: 0x%08lx",
            ability_p->port_capabilities_supported);
        BACKDOOR_MGR_Printf("\r\n  port_autoneg_supported: 0x%08lx",
            ability_p->port_autoneg_supported);
    }

    SWCTRL_RETURN_AND_RELEASE_CSC( ret );
}

#if (SYS_CPNT_SWDRV_MONITOR_SFP_DDM == TRUE)
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetPortSfpPresent
 * -------------------------------------------------------------------------
 * FUNCTION: Get port sfp present status
 *
 * INPUT   : unit
 *           sfp_index
 * OUTPUT  : is_present_p
 * RETURN  : TRUE/FALSE
 * NOTE    : None
 * -------------------------------------------------------------------------
 */
BOOL_T SWCTRL_GetPortSfpPresent(UI32_T unit, UI32_T sfp_index, BOOL_T *is_present_p)
{
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (   unit < 1
        || unit > SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK
        || sfp_index < 1
        || sfp_index > SYS_ADPT_NBR_OF_SFP_PORT_PER_UNIT)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
    }

    SWCTRL_LOCK();
    *is_present_p = SWCTRL_OM_GetPortSfpPresent(unit, sfp_index);
    SWCTRL_UNLOCK();

    SWCTRL_RETURN_AND_RELEASE_CSC(TRUE);
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetPortSfpPresent
 * -------------------------------------------------------------------------
 * FUNCTION: Set port sfp eeprom info
 *
 * INPUT   : unit
 *           sfp_index
 *           is_present
 * OUTPUT  : None
 * RETURN  : TRUE/FALSE
 * NOTE    : None
 * -------------------------------------------------------------------------
 */
BOOL_T SWCTRL_SetPortSfpPresent(UI32_T unit, UI32_T sfp_index, BOOL_T is_present)
{
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (   unit < 1
        || unit > SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK
        || sfp_index < 1
        || sfp_index > SYS_ADPT_NBR_OF_SFP_PORT_PER_UNIT)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
    }

    SWCTRL_LOCK();
    SWCTRL_OM_SetPortSfpPresent(unit, sfp_index, is_present);
    SWCTRL_UNLOCK();

    SWCTRL_RETURN_AND_RELEASE_CSC(TRUE);
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetPortSfpInfo
 * -------------------------------------------------------------------------
 * FUNCTION: Get port sfp eeprom info
 *
 * INPUT   : unit
 *           sfp_index
 * OUTPUT  : sfp_info_p
 * RETURN  : TRUE/FALSE
 * NOTE    : None
 * -------------------------------------------------------------------------
 */
BOOL_T SWCTRL_GetPortSfpInfo(UI32_T unit, UI32_T sfp_index, SWCTRL_OM_SfpInfo_T *sfp_info_p)
{
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if(sfp_index < 1 || sfp_index > SYS_ADPT_NBR_OF_SFP_PORT_PER_UNIT)
        SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);

    SWCTRL_LOCK();
    SWCTRL_OM_GetPortSfpInfo(unit, sfp_index, sfp_info_p);
    SWCTRL_UNLOCK();

    SWCTRL_RETURN_AND_RELEASE_CSC(TRUE);
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetPortSfpInfo
 * -------------------------------------------------------------------------
 * FUNCTION: Set port sfp eeprom info
 *
 * INPUT   : unit
 *           sfp_index
 *           sfp_info_p
 * OUTPUT  : None
 * RETURN  : TRUE/FALSE
 * NOTE    : None
 * -------------------------------------------------------------------------
 */
BOOL_T SWCTRL_SetPortSfpInfo(UI32_T unit, UI32_T sfp_index, SWCTRL_OM_SfpInfo_T *sfp_info_p)
{
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if(sfp_index < 1 || sfp_index > SYS_ADPT_NBR_OF_SFP_PORT_PER_UNIT)
        SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);

    SWCTRL_LOCK();
    SWCTRL_OM_SetPortSfpInfo(unit, sfp_index, sfp_info_p);
    SWCTRL_UNLOCK();

    SWCTRL_RETURN_AND_RELEASE_CSC(TRUE);
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetPortSfpDdmInfo
 * -------------------------------------------------------------------------
 * FUNCTION: Get port sfp ddm eeprom info
 *
 * INPUT   : unit
 *           sfp_index
 * OUTPUT  : sfp_ddm_info_p
 * RETURN  : TRUE/FALSE
 * NOTE    : None
 * -------------------------------------------------------------------------
 */
BOOL_T SWCTRL_GetPortSfpDdmInfo(UI32_T unit, UI32_T sfp_index, SWCTRL_OM_SfpDdmInfo_T *sfp_ddm_info_p)
{
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if(sfp_index < 1 || sfp_index > SYS_ADPT_NBR_OF_SFP_PORT_PER_UNIT)
        SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);

    SWCTRL_LOCK();
    SWCTRL_OM_GetPortSfpDdmInfo(unit, sfp_index, sfp_ddm_info_p);
    SWCTRL_UNLOCK();

    SWCTRL_RETURN_AND_RELEASE_CSC(TRUE);
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetPortSfpDdmInfo
 * -------------------------------------------------------------------------
 * FUNCTION: Set port sfp ddm eeprom info
 *
 * INPUT   : unit
 *           sfp_index
 *           sfp_ddm_info_p
 * OUTPUT  : None
 * RETURN  : TRUE/FALSE
 * NOTE    : None
 * -------------------------------------------------------------------------
 */
BOOL_T SWCTRL_SetPortSfpDdmInfo(UI32_T unit, UI32_T sfp_index, SWCTRL_OM_SfpDdmInfo_T *sfp_ddm_info_p)
{
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if(sfp_index < 1 || sfp_index > SYS_ADPT_NBR_OF_SFP_PORT_PER_UNIT)
        SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);

    SWCTRL_LOCK();
    SWCTRL_OM_SetPortSfpDdmInfo(unit, sfp_index, sfp_ddm_info_p);
    SWCTRL_UNLOCK();

    SWCTRL_RETURN_AND_RELEASE_CSC(TRUE);
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetPortSfpDdmInfoMeasured
 * -------------------------------------------------------------------------
 * FUNCTION: Get port sfp ddm measured eeprom info
 *
 * INPUT   : unit
 *           sfp_index
 * OUTPUT  : sfp_ddm_info_measured_p
 * RETURN  : TRUE/FALSE
 * NOTE    : None
 * -------------------------------------------------------------------------
 */
BOOL_T SWCTRL_GetPortSfpDdmInfoMeasured(UI32_T unit, UI32_T sfp_index, SWCTRL_OM_SfpDdmInfoMeasured_T *sfp_ddm_info_measured_p)
{
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if(sfp_index < 1 || sfp_index > SYS_ADPT_NBR_OF_SFP_PORT_PER_UNIT)
        SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);

    SWCTRL_LOCK();
    SWCTRL_OM_GetPortSfpDdmInfoMeasured(unit, sfp_index, sfp_ddm_info_measured_p);
    SWCTRL_UNLOCK();

    SWCTRL_RETURN_AND_RELEASE_CSC(TRUE);
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetPortSfpDdmInfoMeasured
 * -------------------------------------------------------------------------
 * FUNCTION: Set port sfp ddm measured eeprom info
 *
 * INPUT   : unit
 *           sfp_index
 *           sfp_ddm_info_measured_p
 * OUTPUT  : None
 * RETURN  : TRUE/FALSE
 * NOTE    : None
 * -------------------------------------------------------------------------
 */
BOOL_T SWCTRL_SetPortSfpDdmInfoMeasured(UI32_T unit, UI32_T sfp_index, SWCTRL_OM_SfpDdmInfoMeasured_T *sfp_ddm_info_measured_p)
{
    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if(sfp_index < 1 || sfp_index > SYS_ADPT_NBR_OF_SFP_PORT_PER_UNIT)
        SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);

    SWCTRL_LOCK();
    SWCTRL_OM_SetPortSfpDdmInfoMeasured(unit, sfp_index, sfp_ddm_info_measured_p);
    SWCTRL_UNLOCK();

    SWCTRL_RETURN_AND_RELEASE_CSC(TRUE);
}
#endif /* #if (SYS_CPNT_SWDRV_MONITOR_SFP_DDM == TRUE) */

#if (SYS_CPNT_SFLOW == TRUE)
/*-------------------------------------------------------------------------
 * FUNCTION NAME - SWCTRL_SetSflowPortPacketSamplingRate
 *-------------------------------------------------------------------------
 * PURPOSE  : Set port sampling rate.
 * INPUT    : ifindex  -- interface index
 *            rate     -- sampling rate
 * OUTPUT   : None
 * RETUEN   : TRUE/FALSE
 * NOTES    : None
 * ------------------------------------------------------------------------
 */
BOOL_T
SWCTRL_SetSflowPortPacketSamplingRate(
    UI32_T ifindex,
    UI32_T rate)
{
    BOOL_T retval = FALSE;
    UI32_T unit = 0;
    UI32_T port = 0;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (!SWCTRL_IS_LPORT(ifindex))
    {
        SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
    }

    /* the ifindex is normal port
     */
    if (!SWCTRL_IS_TRUNK (ifindex))
    {
        unit = SWCTRL_IFINDEX_TO_UNIT(ifindex);
        port = SWCTRL_IFINDEX_TO_PORT(ifindex);

#if (SYS_CPNT_MGMT_PORT == TRUE)
        if (port == SYS_ADPT_MGMT_PORT)
        {
            SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
        }
#endif

        if (rate != SFLOW_MGR_SAMPLING_RATE_DISABLE &&
           (rate < SYS_ADPT_SFLOW_MIN_SAMPLING_RATE ||
            rate > SYS_ADPT_SFLOW_MAX_SAMPLING_RATE))
        {
            SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
        }

        retval = SWDRV_SetPortSflowRate(unit, port, rate);
        retval = TRUE;
    }

    SWCTRL_RETURN_AND_RELEASE_CSC(retval);
} /* End of SWCTRL_SetSflowPortPacketSamplingRate */
#endif /* #if (SYS_CPNT_SFLOW == TRUE) */

#if (TRUE == SYS_CPNT_APP_FILTER)
/* -------------------------------------------------------------------------
 * FUNCTION NAME - SWCTRL_DropPortCdpPacket
 * -------------------------------------------------------------------------
 * PURPOSE : Drop CDP packet
 * INPUT   : enable  -- enabled/disabled this feature
 *           ifindex -- interface index
 * OUTPUT  : None
 * RETURN  : TRUE/FALSE
 * NOTE    : None
 * -------------------------------------------------------------------------
 */
BOOL_T
SWCTRL_DropPortCdpPacket(
    BOOL_T enable,
    UI32_T ifindex)
{
    BOOL_T re_val = FALSE;
    UI32_T unit;
    UI32_T port;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (!SWCTRL_IS_LPORT(ifindex))
    {
        SWCTRL_RETURN_AND_RELEASE_CSC(re_val);
    }

    SWCTRL_LOCK();
    if (!SWCTRL_IS_TRUNK (ifindex))
    {
        /* normal member, apply to this port
         */
        unit = SWCTRL_IFINDEX_TO_UNIT(ifindex);
        port = SWCTRL_IFINDEX_TO_PORT(ifindex);

        re_val =  SWDRV_DropCdpPacketByPort(enable, unit, port);
    }
    else
    {
        /* trunk, apply to all member ports
         */
        int trunk_id, i;
        trunk_id = SWCTRL_IFINDEX_TO_TRUNKID (ifindex);

        for(i = 0; i < trunk_ext_port_info[trunk_id-1].member_number; i++)
        {
            unit = trunk_ext_port_info[trunk_id-1].member_list[i].unit;
            port = trunk_ext_port_info[trunk_id-1].member_list[i].port;

            re_val =  SWDRV_DropCdpPacketByPort(enable, unit, port);
            if (FALSE == re_val)
            {
                if (SWCTRL_BACKDOOR_IsDebugFlagOn (SWCTRL_BACKDOOR_DEBUG_FLAG_ERRMSG))
                {
                    BACKDOOR_MGR_Printf("\r\n%s(%d):", __FUNCTION__, __LINE__);
                    BACKDOOR_MGR_Printf("\n\r  Fail set to trunk %lu , member.unit %lu member.port %lu \r\n",
                           trunk_id, unit, port);
                }
            }
        }
    } /* End of if */
    SWCTRL_UNLOCK();

    SWCTRL_RETURN_AND_RELEASE_CSC(re_val);
}

/* -------------------------------------------------------------------------
 * FUNCTION NAME - SWCTRL_DropPortPvstPacket
 * -------------------------------------------------------------------------
 * PURPOSE : Drop CDP packet
 * INPUT   : enable  -- enabled/disabled this feature
 *           ifindex -- interface index
 * OUTPUT  : None
 * RETURN  : TRUE/FALSE
 * NOTE    : None
 * -------------------------------------------------------------------------
 */
BOOL_T
SWCTRL_DropPortPvstPacket(
    BOOL_T enable,
    UI32_T ifindex)
{
    BOOL_T re_val = FALSE;
    UI32_T unit;
    UI32_T port;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (!SWCTRL_IS_LPORT(ifindex))
    {
        SWCTRL_RETURN_AND_RELEASE_CSC(re_val);
    }

    SWCTRL_LOCK();
    if (!SWCTRL_IS_TRUNK (ifindex))
    {
        /* normal member, apply to this port
         */
        unit = SWCTRL_IFINDEX_TO_UNIT(ifindex);
        port = SWCTRL_IFINDEX_TO_PORT(ifindex);

        re_val =  SWDRV_DropPvstPacketByPort(enable, unit, port);
    }
    else
    {
        /* trunk, apply to all member ports
         */
        int trunk_id, i;
        trunk_id = SWCTRL_IFINDEX_TO_TRUNKID (ifindex);

        for(i = 0; i < trunk_ext_port_info[trunk_id-1].member_number; i++)
        {
            unit = trunk_ext_port_info[trunk_id-1].member_list[i].unit;
            port = trunk_ext_port_info[trunk_id-1].member_list[i].port;

            re_val =  SWDRV_DropPvstPacketByPort(enable, unit, port);
            if (FALSE == re_val)
            {
                if (SWCTRL_BACKDOOR_IsDebugFlagOn (SWCTRL_BACKDOOR_DEBUG_FLAG_ERRMSG))
                {
                    BACKDOOR_MGR_Printf("\r\n%s(%d):", __FUNCTION__, __LINE__);
                    BACKDOOR_MGR_Printf("\r\n  Fail set to trunk %lu , member.unit %lu member.port %lu \r\n",
                           trunk_id, unit, port);
                }
            }
        }
    } /* End of if */
    SWCTRL_UNLOCK();

    SWCTRL_RETURN_AND_RELEASE_CSC(re_val);
}
#endif /* #if (TRUE == SYS_CPNT_APP_FILTER) */

static void SWCTRL_PortEgressBlock_Lportlist_2_Uportlist(
    UI8_T lport_list[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST],
    UI8_T uport_list[SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK * SYS_ADPT_NBR_OF_BYTE_FOR_1BIT_UPORT_LIST])
{
    const UI32_T uport_list_sz = sizeof(UI8_T [SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK * SYS_ADPT_NBR_OF_BYTE_FOR_1BIT_UPORT_LIST]);

    UI32_T unit, port;
    UI32_T trunk_ifindex;
    UI32_T trunk_id;
    UI32_T member_ifindex;
    UI32_T byte_index;
    UI8_T bit_value;
    BOOL_T is_block;
    int i;

    memcpy(uport_list, lport_list, uport_list_sz);

    for (trunk_id = 1; trunk_id <= SYS_ADPT_MAX_NBR_OF_TRUNK_PER_SYSTEM; trunk_id++)
    {
        trunk_ifindex = SWCTRL_TRUNKID_TO_IFINDEX(trunk_id);

        byte_index = SWCTRL_BYTE_IN_BITMAP(trunk_ifindex);
        bit_value = SWCTRL_BIT_IN_BITMAP(trunk_ifindex);

        is_block = !!(lport_list[byte_index] & bit_value);

        for (i = 0; i < trunk_ext_port_info[trunk_id-1].member_number; i++)
        {
            unit = trunk_ext_port_info[trunk_id-1].member_list[i].unit;
            port = trunk_ext_port_info[trunk_id-1].member_list[i].port;

            member_ifindex = SWCTRL_UPORT_TO_IFINDEX(unit, port);

            if (!SWCTRL_IS_USER_PORT(member_ifindex))
            {
                break;
            }

            byte_index =
                (unit - 1) * SYS_ADPT_NBR_OF_BYTE_FOR_1BIT_UPORT_LIST +
                SWCTRL_BYTE_IN_BITMAP(port);
            bit_value = SWCTRL_BIT_IN_BITMAP(port);

            if (is_block)
            {
                uport_list[byte_index] |= bit_value;
            }
            else
            {
                uport_list[byte_index] &= ~ bit_value;
            }
        }
    }
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_UpdateTrunkEgressBlock
 * -------------------------------------------------------------------------
 * FUNCTION: To re-setup egress block when trunk member changed
 * INPUT   : trunk_ifindex
 * OUTPUT  : None
 * RETURN  : TRUE/FALSE
 * NOTE    : None.
 * -------------------------------------------------------------------------*/
static BOOL_T SWCTRL_UpdateTrunkEgressBlock(UI32_T trunk_ifindex)
{
    UI32_T lport;
    BOOL_T ret = TRUE;

    for (lport = 1; lport <= SYS_ADPT_TOTAL_NBR_OF_LPORT; lport++)
    {
        ret = SWCTRL_SetPortEgressBlock_Local(
                lport,
                port_info[lport-1].egr_blk_lport_list);

        if (!ret)
        {
            break;
        }
    }

    return ret;
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetPortEgressBlock_Local
 * -------------------------------------------------------------------------
 * FUNCTION: To set egress block ports.
 * INPUT   : lport              - source lport
 *           egr_blk_lport_list - lport list to block.
 *                                NULL to indicate empty lport list.
 * OUTPUT  : None
 * RETURN  : TRUE/FALSE
 * NOTE    : None.
 * -------------------------------------------------------------------------*/
static BOOL_T SWCTRL_SetPortEgressBlock_Local(
    UI32_T lport,
    UI8_T egr_blk_lport_list[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST])
{
    UI8_T egr_blk_uport_list[SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK * SYS_ADPT_NBR_OF_BYTE_FOR_1BIT_UPORT_LIST];
    UI32_T unit, port;
    BOOL_T ret = TRUE;

    if (SWCTRL_IS_TRUNK(lport))
    {
        unit = 0;
        port = SWCTRL_IFINDEX_TO_TRUNKID(lport);
    }
    else
    {
        unit = SWCTRL_IFINDEX_TO_UNIT(lport);
        port = SWCTRL_IFINDEX_TO_PORT(lport);
    }

    SWCTRL_PortEgressBlock_Lportlist_2_Uportlist(
        egr_blk_lport_list,
        egr_blk_uport_list);

    ret = SWDRV_SetPortEgressBlock(unit, port, egr_blk_uport_list);

    /* Sync to all trunk members
     *
     * Not all HW have egress block for trunk, so
     * 1) always sync trunk egress block to all members and
     * 2) restore member setting when remove it from trunk.
     */
    if (SWCTRL_IS_TRUNK(lport))
    {
        UI32_T trunk_id;
        UI32_T member_ifindex;
        int i;

        trunk_id = SWCTRL_IFINDEX_TO_TRUNKID(lport);

        for(i = 0; ret && i < trunk_ext_port_info[trunk_id-1].member_number; i++)
        {
            unit = trunk_ext_port_info[trunk_id-1].member_list[i].unit;
            port = trunk_ext_port_info[trunk_id-1].member_list[i].port;

            member_ifindex = SWCTRL_UPORT_TO_IFINDEX(unit, port);

            if (!SWCTRL_IS_USER_PORT(member_ifindex))
            {
                break;
            }

            ret = SWDRV_SetPortEgressBlock(unit, port, egr_blk_uport_list);
        }
    }

    return ret;
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetPortEgressBlock
 * -------------------------------------------------------------------------
 * FUNCTION: To set egress block port.
 * INPUT   : lport              - source lport
 *           egr_lport          - lport to block
 *           is_block           - TRUE to enable egress block status
 *                                FALSE to disable egress block status
 * OUTPUT  : None
 * RETURN  : TRUE/FALSE
 * NOTE    : None.
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetPortEgressBlock(
    UI32_T lport,
    UI32_T egr_lport,
    BOOL_T is_block)
{
    UI8_T new_egr_blk_lport_list[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST];
    UI32_T byte_index;
    UI8_T bit_value;
    BOOL_T ret = TRUE;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (!SWCTRL_IS_USER_PORT(lport) && !SWCTRL_IS_TRUNK(lport))
    {
        SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
    }

    if (!SWCTRL_IS_EXIST(lport))
    {
        SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
    }

    if (!SWCTRL_IS_USER_PORT(egr_lport) && !SWCTRL_IS_TRUNK(egr_lport))
    {
        SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
    }

    if (!SWCTRL_IS_EXIST(egr_lport))
    {
        SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
    }

    byte_index = SWCTRL_BYTE_IN_BITMAP(egr_lport);
    bit_value = SWCTRL_BIT_IN_BITMAP(egr_lport);

    if (is_block == !!(port_info[lport-1].egr_blk_lport_list[byte_index] & bit_value))
    {
        SWCTRL_RETURN_AND_RELEASE_CSC(TRUE);
    }

    memcpy(new_egr_blk_lport_list, port_info[lport-1].egr_blk_lport_list, sizeof(new_egr_blk_lport_list));

    if (is_block)
    {
        new_egr_blk_lport_list[byte_index] |= bit_value;
    }
    else
    {
        new_egr_blk_lport_list[byte_index] &= ~ bit_value;
    }

    ret = SWCTRL_SetPortEgressBlock_Local(lport, new_egr_blk_lport_list);

    if (ret)
    {
        memcpy(
            port_info[lport-1].egr_blk_lport_list,
            new_egr_blk_lport_list,
            sizeof(port_info[lport-1].egr_blk_lport_list));
    }

    SWCTRL_RETURN_AND_RELEASE_CSC(ret);
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetPortEgressBlockEx
 * -------------------------------------------------------------------------
 * FUNCTION: To set egress block ports.
 * INPUT   : lport               - source lport
 *           egr_lport_list      - lport list to update egress block status.
 *                                 NULL to indicate all lport list.
 *           blk_lport_list      - lport list to specify egress block status.
 *                                 set bit to enable egress block status, clear bit to disable.
 *                                 NULL to indicate empty lport list.
 * OUTPUT  : None
 * RETURN  : TRUE/FALSE
 * NOTE    : None.
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetPortEgressBlockEx(
    UI32_T lport,
    UI8_T egr_lport_list[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST],
    UI8_T blk_lport_list[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST])
{
    UI8_T new_egr_blk_lport_list[SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST];
    UI32_T byte_idx;
    UI8_T val, mask;
    BOOL_T ret = TRUE;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (!SWCTRL_IS_USER_PORT(lport) && !SWCTRL_IS_TRUNK(lport))
    {
        SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
    }

    if (!SWCTRL_IS_EXIST(lport))
    {
        SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
    }

    memcpy(new_egr_blk_lport_list, port_info[lport-1].egr_blk_lport_list, sizeof(new_egr_blk_lport_list));

    for (byte_idx = 0; byte_idx < SYS_ADPT_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST; byte_idx++)
    {
        val = blk_lport_list ? blk_lport_list[byte_idx] : 0x00;
        mask = egr_lport_list ? egr_lport_list[byte_idx] : 0xff;

        new_egr_blk_lport_list[byte_idx] &= ~mask;
        new_egr_blk_lport_list[byte_idx] |= val & mask;
    }

    if (memcmp(
            port_info[lport-1].egr_blk_lport_list,
            new_egr_blk_lport_list,
            sizeof(port_info[lport-1].egr_blk_lport_list)) == 0)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC(TRUE);
    }

    ret = SWCTRL_SetPortEgressBlock_Local(lport, new_egr_blk_lport_list);

    if (ret)
    {
        memcpy(
            port_info[lport-1].egr_blk_lport_list,
            new_egr_blk_lport_list,
            sizeof(port_info[lport-1].egr_blk_lport_list));
    }

    SWCTRL_RETURN_AND_RELEASE_CSC(ret);
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_IsPortEgressBlock
 * -------------------------------------------------------------------------
 * FUNCTION: To set egress block ports.
 * INPUT   : lport               - source lport
 *           egr_lport           - egress lport
 * OUTPUT  : None
 * RETURN  : TRUE/FALSE - egress lport is block or not
 * NOTE    : None.
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_IsPortEgressBlock(
    UI32_T lport,
    UI32_T egr_lport)
{
    UI32_T byte_index;
    UI8_T bit_value;
    BOOL_T is_block;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (!SWCTRL_IS_USER_PORT(lport) && !SWCTRL_IS_TRUNK(lport))
    {
        SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
    }

    if (!SWCTRL_IS_EXIST(lport))
    {
        SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
    }

    byte_index = SWCTRL_BYTE_IN_BITMAP(egr_lport);
    bit_value = SWCTRL_BIT_IN_BITMAP(egr_lport);

    is_block = !!(port_info[lport-1].egr_blk_lport_list[byte_index] & bit_value);

    if (SWCTRL_IS_TRUNK_MEMBER(egr_lport))
    {
        UI32_T trunk_id, trunk_ifindex;

        trunk_id = port_info[egr_lport-1].port_entry.port_trunk_index;
        trunk_ifindex = SWCTRL_TRUNKID_TO_IFINDEX(trunk_id);

        byte_index = SWCTRL_BYTE_IN_BITMAP(trunk_ifindex);
        bit_value = SWCTRL_BIT_IN_BITMAP(trunk_ifindex);

        is_block = is_block || !!(port_info[lport-1].egr_blk_lport_list[byte_index] & bit_value);
    }

    SWCTRL_RETURN_AND_RELEASE_CSC(is_block);
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetActiveUportListByPortEgressBlock
 * -------------------------------------------------------------------------
 * FUNCTION: To set egress block ports.
 * INPUT   : lport               - source lport
 *           active_uport_count_per_unit
 *           uport_list
 * OUTPUT  : active_uport_count_per_unit
 *           uport_list
 * RETURN  : TRUE/FALSE - uport_list is modified or not
 * NOTE    : None.
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_GetActiveUportListByPortEgressBlock(
    UI32_T lport,
    UI8_T active_uport_count_per_unit[SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK],
    UI8_T *uport_list)
{
    static const int bit_count[] = { 0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4 };

    UI8_T egr_blk_uport_list[SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK * SYS_ADPT_NBR_OF_BYTE_FOR_1BIT_UPORT_LIST];
    UI8_T block_mask;
    int i, count;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (!SWCTRL_IS_USER_PORT(lport) && !SWCTRL_IS_TRUNK(lport))
    {
        SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
    }

    if (!SWCTRL_IS_EXIST(lport))
    {
        SWCTRL_RETURN_AND_RELEASE_CSC(FALSE);
    }

    SWCTRL_PortEgressBlock_Lportlist_2_Uportlist(
        port_info[lport-1].egr_blk_lport_list,
        egr_blk_uport_list);

    count = 0;

    for (i = 0; i < sizeof(egr_blk_uport_list); i++)
    {
        block_mask = uport_list[i] & egr_blk_uport_list[i];

        active_uport_count_per_unit[i/SYS_ADPT_NBR_OF_BYTE_FOR_1BIT_UPORT_LIST] -= bit_count[block_mask];
        count += bit_count[block_mask];

        uport_list[i] ^= block_mask;
    }

    SWCTRL_RETURN_AND_RELEASE_CSC(count > 0);
}

#if (SYS_CPNT_HASH_SELECTION == TRUE)
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_BindHashSelForService
 * -------------------------------------------------------------------------
 * FUNCTION: add service reference of the hash-selection list
 * INPUT   : service     - SWCTRL_OM_HASH_SEL_SERVICE_ECMP,
 *                         SWCTRL_OM_HASH_SEL_SERVICE_TRUNK
 *           list_index - the index of hash-selection list
 * OUTPUT  : None
 * RETURN  : TRUE/FALSE
 * NOTE    : None.
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_BindHashSelForService(SWCTRL_OM_HashSelService_T service, UI8_T list_index)
{
    BOOL_T ret;
    SWCTRL_OM_HashSelBlockInfo_T block_info;
    SWDRV_HashSelBlockInfo_T     dev_block;
    UI8_T original_list_index;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    SWCTRL_LOCK();

    ret = SWCTRL_OM_IsHashSelBindForTheService(service, &original_list_index);
    if (ret == TRUE)
    {
        if (original_list_index == list_index)
        {
            SWCTRL_UNLOCK();
            SWCTRL_RETURN_AND_RELEASE_CSC(TRUE);
        }
        else
        {
            /*unbind old*/
            ret = SWCTRL_OM_UnBindHashSelForService(service, original_list_index);
            if (ret == FALSE)
            {
                SWCTRL_UNLOCK();
                SWCTRL_RETURN_AND_RELEASE_CSC(ret);
            }

            ret = SWDRV_UnBindHashSelForService(service, original_list_index);
            if (ret == FALSE)
            {
                SWCTRL_UNLOCK();
                SWCTRL_RETURN_AND_RELEASE_CSC(ret);
            }
        }
    }

    ret = SWCTRL_OM_GetHashBlockInfo(list_index, &block_info);
    if (ret == FALSE)
    {
        SWCTRL_UNLOCK();
        SWCTRL_RETURN_AND_RELEASE_CSC(ret);
    }

    dev_block.list_index = list_index;
    memcpy(&dev_block.pkt_l2, &block_info.pkt_l2, sizeof(DEV_SWDRV_HashSelection_L2_T));
    memcpy(&dev_block.pkt_ipv4, &block_info.pkt_ipv4, sizeof(DEV_SWDRV_HashSelection_IPv4_T));
    memcpy(&dev_block.pkt_ipv6, &block_info.pkt_ipv6, sizeof(DEV_SWDRV_HashSelection_IPv6_T));

    ret = SWDRV_BindHashSelForService(service, &dev_block);
    if (ret == FALSE)
    {
        SWCTRL_UNLOCK();
        SWCTRL_RETURN_AND_RELEASE_CSC(ret);
    }

    ret = SWCTRL_OM_BindHashSelForService(service, list_index);
    SWCTRL_UNLOCK();

    SWCTRL_RETURN_AND_RELEASE_CSC(ret);
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_UnBindHashSelForService
 * -------------------------------------------------------------------------
 * FUNCTION: remove service reference of the hash-selection list
 * INPUT   : service     - SWCTRL_OM_HASH_SEL_SERVICE_ECMP,
 *                         SWCTRL_OM_HASH_SEL_SERVICE_TRUNK
 *           list_index - the index of hash-selection list
 * OUTPUT  : None
 * RETURN  : TRUE/FALSE
 * NOTE    : None.
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_UnBindHashSelForService(SWCTRL_OM_HashSelService_T service, UI8_T list_index)
{
    BOOL_T ret;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    ret = SWDRV_UnBindHashSelForService(service, list_index);
    if (ret == FALSE)
    {
        SWCTRL_RETURN_AND_RELEASE_CSC(ret);
    }

    SWCTRL_LOCK();
    ret = SWCTRL_OM_UnBindHashSelForService(service, list_index);
    SWCTRL_UNLOCK();

    SWCTRL_RETURN_AND_RELEASE_CSC(ret);
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_AddHashSelection
 * -------------------------------------------------------------------------
 * FUNCTION: add hash-selection field
 * INPUT   : list_index - the index of hash-selection list
 *           selection_p - hash-selection field
 * OUTPUT  : None
 * RETURN  : TRUE/FALSE
 * NOTE    : If the hash-selection list has been bound, then it can't be modified
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_AddHashSelection(
    UI8_T list_index ,
    SWCTRL_OM_HashSelection_T *selection_p)
{
    BOOL_T ret = TRUE;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    SWCTRL_LOCK();

    if (TRUE != SWCTRL_OM_AddHashSelection(list_index, selection_p))
    {
        ret = FALSE;
    }

    SWCTRL_UNLOCK();

    SWCTRL_RETURN_AND_RELEASE_CSC(ret);
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_RemoveHashSelection
 * -------------------------------------------------------------------------
 * FUNCTION: remove hash-selection field
 * INPUT   : list_index - the index of hash-selection list
 *           selection_p - hash-selection field
 * OUTPUT  : None
 * RETURN  : TRUE/FALSE
 * NOTE    : If the hash-selection list has been bound, then it can't be modified
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_RemoveHashSelection(
    UI8_T list_index ,
    SWCTRL_OM_HashSelection_T *selection_p)
{
    BOOL_T ret = TRUE;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    SWCTRL_LOCK();

    if (TRUE != SWCTRL_OM_RemoveHashSelection(list_index, selection_p))
    {
        ret = FALSE;
    }

    SWCTRL_UNLOCK();

    SWCTRL_RETURN_AND_RELEASE_CSC(ret);
}

/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_GetHashBlockInfo
 * -------------------------------------------------------------------------
 * FUNCTION: get hash-selection block info
 * INPUT   : list_index - the index of hash-selection list
 * OUTPUT  : block_info_p - the hash-selection block info
 * RETURN  : TRUE/FALSE
 * NOTE    : None.
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_GetHashBlockInfo(
    UI8_T list_index,
    SWCTRL_OM_HashSelBlockInfo_T *block_info_p)
{
    BOOL_T ret = TRUE;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    SWCTRL_LOCK();

    if (TRUE != SWCTRL_OM_GetHashBlockInfo(list_index, block_info_p))
    {
        ret = FALSE;
    }

    SWCTRL_UNLOCK();

    SWCTRL_RETURN_AND_RELEASE_CSC(ret);
}
#endif /*#if (SYS_CPNT_HASH_SELECTION == TRUE)*/

#if (SYS_CPNT_SWCTRL_SWITCH_MODE_CONFIGURABLE == TRUE)
/* -------------------------------------------------------------------------
 * ROUTINE NAME - SWCTRL_SetSwitchingMode
 * -------------------------------------------------------------------------
 * FUNCTION: To set switching mode
 * INPUT   : ifindex - which port to configure.
 *           mode    - VAL_swctrlSwitchModeSF
 *                     VAL_swctrlSwitchModeCT
 * OUTPUT  : None
 * RETURN  : TRUE/FALSE
 * NOTE    : None
 * -------------------------------------------------------------------------*/
BOOL_T SWCTRL_SetSwitchingMode(UI32_T ifindex, UI32_T mode)
{
    UI32_T unit, port;
    BOOL_T ret = TRUE;

    SWCTRL_USE_CSC_CHECK_OPER_MODE(FALSE);

    if (!SWCTRL_IS_EXIST (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_NOT_EXIST,
                                  EH_MGR_FOR_DEBUG_MSG_PURPOSE|SYSLOG_LEVEL_INFO,
                                  "Interface");  /*SWCTRL_ENO_PORT_NOT_PRESENT*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if (SWCTRL_IS_TRUNK_MEMBER (ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_TRUNK_MEMBER_CNFG_ERR,
                                  SYSLOG_LEVEL_INFO|EH_MGR_FOR_DEBUG_MSG_PURPOSE,
                                  "Trunk member can't configure switching-mode");  /*SWCTRL_ENO_NOT_TRUNK_MEMBER*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    if(SWCTRL_IS_TRUNK(ifindex))
    {
        EH_MGR_Handle_Exception1 (SYS_MODULE_SWCTRL,
                                  SWCTRL_NO_USE_FUNC_NO,
                                  EH_TYPE_MSG_TRUNK_CNFG_ERR,
                                  SYSLOG_LEVEL_INFO|EH_MGR_FOR_DEBUG_MSG_PURPOSE,
                                  "Trunk can't configure switching-mode");  /*SWCTRL_ENO_NOT_TRUNK*/

        SWCTRL_RETURN_AND_RELEASE_CSC( FALSE );
    }

    unit = SWCTRL_IFINDEX_TO_UNIT(ifindex);
    port = SWCTRL_IFINDEX_TO_PORT(ifindex);

    ret = SWDRV_SetSwitchingMode(unit, port, mode);
    if (ret == FALSE)
    {
       SWCTRL_RETURN_AND_RELEASE_CSC(ret);
    }

    SWCTRL_LOCK();

    port_info[ifindex-1].port_entry.switch_mode = mode;

    SWCTRL_UNLOCK();

    SWCTRL_RETURN_AND_RELEASE_CSC(ret);
}
#endif /*#if (SYS_CPNT_SWCTRL_SWITCH_MODE_CONFIGURABLE == TRUE)*/

