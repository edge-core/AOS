/******************************************************************************
 ******************************************************************************
 **** This file was automatically generated by Epilogue Technology's
 **** Emissary SNMP MIB Compiler, version 6.3.
 **** This file was generated using the -trap.c switch.
 **** 
 **** This file contains functions to generate SNMP TRAP PDUs for all the
 **** trap definitions that Emissary encountered.  To use the functions in
 **** this file, run Emissary with the -trap.h switch to generate a header
 **** file with the corresponding function declarations.
 **** 
 **** DO NOT MODIFY THIS FILE BY HAND.
 **** 
 **** Last build date: Wed Nov 25 19:25:34 1998
 **** from files:
 ****  rfc1213.mib, rfc1493.mib, ctl1493.mib
 ******************************************************************************
 ******************************************************************************
 */

#include <asn1.h>
#include <buffer.h>
#include <snmpdefs.h>



static OIDC_T ID_dot1dBridge[] = { 1, 3, 6, 1, 2, 1, 17 };
static int len_dot1dBridge = 7;

/*****************************************************************************
 ****
 ****
 **** Trap creation function for newRoot trap
 ****
 **** DESCRIPTION:
 **** The newRoot trap indicates that the sending agent has become the new root
 **** of the Spanning Tree; the trap is sent by a bridge soon after its
 **** election as the new root, e.g., upon expiration of the Topology Change
 **** Timer immediately subsequent to its election. Implementation of this trap
 **** is optional.
 ****
 **** Returns length of encoded packet, 0 on SNMP failure,
 **** or -1 if an instance is too long.
 ****
 ****
 *****************************************************************************
 */

int crt_newRoot_trap(
	EBUFFER_T	*ebuff,
	OCTET_T		*local_ip,
	char		*community,
	unsigned	comlen,
	UINT_32_T	timestamp)
{
	SNMP_PKT_T	*trap_pkt;

	/* Create the SNMP packet structure. */
	trap_pkt = SNMP_Create_Trap(VERSION_RFC1157, comlen, community,
				    len_dot1dBridge, ID_dot1dBridge,
				    local_ip,
				    6,	/* enterpriseSpecific(6) */
				    1,
				    timestamp,
				    0);

	/* Verify that SNMP_Create_Trap succeeded. */
	if (trap_pkt == (SNMP_PKT_T*)0)
		return 0;

	/* Encode the packet as bytes into the user-supplied buffer. */
	if (SNMP_Encode_Packet(trap_pkt, ebuff) == -1)
		goto fail;

	/* Free the SNMP packet structure. */
	SNMP_Free(trap_pkt);

	/* Return the number of bytes used in the buffer. */
	return EBufferUsed(ebuff);

fail:
	/* Come here on failure during bind or encode. */
	SNMP_Free(trap_pkt);
	return 0;
}





/*Topology change Trap V1*/

/*****************************************************************************
 ****
 ****
 **** Trap creation function for topologyChange trap
 ****
 **** DESCRIPTION:
 **** A topologyChange trap is sent by a bridge when any of its configured
 **** ports transitions from the Learning state to the Forwarding state, or
 **** from the Forwarding state to the Blocking state. The trap is not sent if
 **** a newRoot trap is sent for the same transition. Implementation of this
 **** trap is optional.
 ****
 **** Returns length of encoded packet, 0 on SNMP failure,
 **** or -1 if an instance is too long.
 ****
 ****
 *****************************************************************************
 */

int crt_topologyChange_trap(
	EBUFFER_T	*ebuff,
	OCTET_T		*local_ip,
	char		*community,
	unsigned	comlen,
	UINT_32_T	timestamp)
{
	SNMP_PKT_T	*trap_pkt;

	/* Create the SNMP packet structure. */
	trap_pkt = SNMP_Create_Trap(VERSION_RFC1157, comlen, community,
				    len_dot1dBridge, ID_dot1dBridge,
				    local_ip,
				    6,	/* enterpriseSpecific(6) */
				    2,
				    timestamp,
				    0);

	/* Verify that SNMP_Create_Trap succeeded. */
	if (trap_pkt == (SNMP_PKT_T*)0)
		return 0;

	/* Encode the packet as bytes into the user-supplied buffer. */
	if (SNMP_Encode_Packet(trap_pkt, ebuff) == -1)
		goto fail;

	/* Free the SNMP packet structure. */
	SNMP_Free(trap_pkt);

	/* Return the number of bytes used in the buffer. */
	return EBufferUsed(ebuff);

fail:
	/* Come here on failure during bind or encode. */
	SNMP_Free(trap_pkt);
	return 0;
}


