/******************************************************************************
 ******************************************************************************
 **** This file was automatically generated by Epilogue Technology's
 **** Emissary SNMP MIB Compiler, version 6.3.
 **** This file was generated using the -trap.c switch.
 **** 
 **** This file contains functions to generate SNMP TRAP PDUs for all the
 **** trap definitions that Emissary encountered.  To use the functions in
 **** this file, run Emissary with the -trap.h switch to generate a header
 **** file with the corresponding function declarations.
 **** 
 **** DO NOT MODIFY THIS FILE BY HAND.
 **** 
 **** Last build date: Wed Nov 25 19:25:37 1998
 **** from files:
 ****  rfc1213.mib, rfc1757.mib, ctl1757.mib
 ******************************************************************************
 ******************************************************************************
 */

#include <asn1.h>
#include <buffer.h>
#include <snmpdefs.h>

/* Rising Alarm Trap V1 */

static OIDC_T ID_rmon[] = { 1, 3, 6, 1, 2, 1, 16 };
static int len_rmon = 7;
static OIDC_T ID_alarmIndex[] = { 1, 3, 6, 1, 2, 1, 16, 3, 1, 1, 1, 0 };
static int len_alarmIndex = 11;

static OIDC_T ID_alarmVariable[] = { 1, 3, 6, 1, 2, 1, 16, 3, 1, 1, 3, 0 };
static int len_alarmVariable = 11;

static OIDC_T ID_alarmSampleType[] = { 1, 3, 6, 1, 2, 1, 16, 3, 1, 1, 4, 0 };
static int len_alarmSampleType = 11;

static OIDC_T ID_alarmValue[] = { 1, 3, 6, 1, 2, 1, 16, 3, 1, 1, 5, 0 };
static int len_alarmValue = 11;

static OIDC_T ID_alarmRisingThreshold[] = { 1, 3, 6, 1, 2, 1, 16, 3, 1, 1, 7, 0 };
static int len_alarmRisingThreshold = 11;


/*****************************************************************************
 ****
 ****
 **** Trap creation function for risingAlarm trap
 ****
 **** DESCRIPTION:
 **** The SNMP trap that is generated when an alarm entry crosses its rising
 **** threshold and generates an event that is configured for sending SNMP
 **** traps.
 ****
 **** Returns length of encoded packet, 0 on SNMP failure,
 **** or -1 if an instance is too long.
 ****
 ****
 *****************************************************************************
 */

int crt_risingAlarm_trap(
	EBUFFER_T	*ebuff,
	OCTET_T		*local_ip,
	char		*community,
	unsigned	comlen,
	UINT_32_T	timestamp,
	INT_32_T	AalarmIndex,	/* INTEGER */
	OIDC_T		*IalarmIndex,	/* Instance */
	int		ILalarmIndex,	/* Instance length */
	OBJ_ID_T*	AalarmVariable,	/* OBJECT IDENTIFIER */
	OIDC_T		*IalarmVariable,	/* Instance */
	int		ILalarmVariable,	/* Instance length */
	INT_32_T	AalarmSampleType,	/* INTEGER */
	OIDC_T		*IalarmSampleType,	/* Instance */
	int		ILalarmSampleType,	/* Instance length */
	INT_32_T	AalarmValue,	/* INTEGER */
	OIDC_T		*IalarmValue,	/* Instance */
	int		ILalarmValue,	/* Instance length */
	INT_32_T	AalarmRisingThreshold,	/* INTEGER */
	OIDC_T		*IalarmRisingThreshold,	/* Instance */
	int		ILalarmRisingThreshold)	/* Instance length */
{
	SNMP_PKT_T	*trap_pkt;

	/*
	 * Check the instance lengths, copy the instance IDs,
	 * and increase local copies of the lengths for later.
	 */
	if (ILalarmIndex != 1)
		return -1;
	memcpy((char*)(ID_alarmIndex + len_alarmIndex), (char*)IalarmIndex, ILalarmIndex * sizeof(OIDC_T));
	ILalarmIndex += len_alarmIndex;

	if (ILalarmVariable != 1)
		return -1;
	memcpy((char*)(ID_alarmVariable + len_alarmVariable), (char*)IalarmVariable, ILalarmVariable * sizeof(OIDC_T));
	ILalarmVariable += len_alarmVariable;

	if (ILalarmSampleType != 1)
		return -1;
	memcpy((char*)(ID_alarmSampleType + len_alarmSampleType), (char*)IalarmSampleType, ILalarmSampleType * sizeof(OIDC_T));
	ILalarmSampleType += len_alarmSampleType;

	if (ILalarmValue != 1)
		return -1;
	memcpy((char*)(ID_alarmValue + len_alarmValue), (char*)IalarmValue, ILalarmValue * sizeof(OIDC_T));
	ILalarmValue += len_alarmValue;

	if (ILalarmRisingThreshold != 1)
		return -1;
	memcpy((char*)(ID_alarmRisingThreshold + len_alarmRisingThreshold), (char*)IalarmRisingThreshold, ILalarmRisingThreshold * sizeof(OIDC_T));
	ILalarmRisingThreshold += len_alarmRisingThreshold;


	/* Create the SNMP packet structure. */
	trap_pkt = SNMP_Create_Trap(VERSION_RFC1157, comlen, community,
				    len_rmon, ID_rmon,
				    local_ip,
				    6,	/* enterpriseSpecific(6) */
				    1,
				    timestamp,
				    5);

	/* Verify that SNMP_Create_Trap succeeded. */
	if (trap_pkt == (SNMP_PKT_T*)0)
		return 0;

	/* Bind the variables in the trap. */
	if (SNMP_Bind_Integer(trap_pkt, 0, ILalarmIndex, ID_alarmIndex, AalarmIndex) == -1)
		goto fail;

	if (SNMP_Bind_Object_ID(trap_pkt, 1, ILalarmVariable, ID_alarmVariable, AalarmVariable->num_components, AalarmVariable->component_list) == -1)
		goto fail;

	if (SNMP_Bind_Integer(trap_pkt, 2, ILalarmSampleType, ID_alarmSampleType, AalarmSampleType) == -1)
		goto fail;

	if (SNMP_Bind_Integer(trap_pkt, 3, ILalarmValue, ID_alarmValue, AalarmValue) == -1)
		goto fail;

	if (SNMP_Bind_Integer(trap_pkt, 4, ILalarmRisingThreshold, ID_alarmRisingThreshold, AalarmRisingThreshold) == -1)
		goto fail;

	/* Encode the packet as bytes into the user-supplied buffer. */
	if (SNMP_Encode_Packet(trap_pkt, ebuff) == -1)
		goto fail;

	/* Free the SNMP packet structure. */
	SNMP_Free(trap_pkt);

	/* Return the number of bytes used in the buffer. */
	return EBufferUsed(ebuff);

fail:
	/* Come here on failure during bind or encode. */
	SNMP_Free(trap_pkt);
	return 0;
}

/* Rising Alarm Trap v2 */

static OIDC_T ID_sysUpTime[] = { 1, 3, 6, 1, 2, 1, 1, 3, 0 };
static int len_sysUpTime = 9;
static OIDC_T ID_snmpTrapOID[] = { 1, 3, 6, 1, 6, 3, 1, 1, 4, 1, 0 };
static int len_snmpTrapOID = 11;
static OIDC_T ID_risingAlarm[] = { 1, 3, 6, 1, 2, 1, 16, 0, 1 };
static int len_risingAlarm = 9;









/*****************************************************************************
 ****
 ****
 **** Trap creation function for risingAlarm trap
 ****
 **** DESCRIPTION:
 **** The SNMP trap that is generated when an alarm entry crosses its rising
 **** threshold and generates an event that is configured for sending SNMP
 **** traps.
 ****
 **** Returns length of encoded packet, 0 on SNMP failure,
 **** or -1 if an instance is too long.
 ****
 ****
 *****************************************************************************
 */

int crt_risingAlarm_trapv2(
	EBUFFER_T	*ebuff,
	char		*community,
	int		comlen,
	INT_32_T	request_id,
	UINT_32_T	timestamp,
	INT_32_T	AalarmIndex,	/* INTEGER */
	OIDC_T		*IalarmIndex,	/* Instance */
	int		ILalarmIndex,	/* Instance length */
	OBJ_ID_T*	AalarmVariable,	/* OBJECT IDENTIFIER */
	OIDC_T		*IalarmVariable,	/* Instance */
	int		ILalarmVariable,	/* Instance length */
	INT_32_T	AalarmSampleType,	/* INTEGER */
	OIDC_T		*IalarmSampleType,	/* Instance */
	int		ILalarmSampleType,	/* Instance length */
	INT_32_T	AalarmValue,	/* INTEGER */
	OIDC_T		*IalarmValue,	/* Instance */
	int		ILalarmValue,	/* Instance length */
	INT_32_T	AalarmRisingThreshold,	/* INTEGER */
	OIDC_T		*IalarmRisingThreshold,	/* Instance */
	int		ILalarmRisingThreshold)	/* Instance length */
{
	SNMP_PKT_T	*trap_pkt;

	/*
	 * Check the instance lengths, copy the instance IDs,
	 * and increase local copies of the lengths for later.
	 */
	if (ILalarmIndex != 1)
		return -1;
	memcpy((char*)(ID_alarmIndex + len_alarmIndex), (char*)IalarmIndex, ILalarmIndex * sizeof(OIDC_T));
	ILalarmIndex += len_alarmIndex;

	if (ILalarmVariable != 1)
		return -1;
	memcpy((char*)(ID_alarmVariable + len_alarmVariable), (char*)IalarmVariable, ILalarmVariable * sizeof(OIDC_T));
	ILalarmVariable += len_alarmVariable;

	if (ILalarmSampleType != 1)
		return -1;
	memcpy((char*)(ID_alarmSampleType + len_alarmSampleType), (char*)IalarmSampleType, ILalarmSampleType * sizeof(OIDC_T));
	ILalarmSampleType += len_alarmSampleType;

	if (ILalarmValue != 1)
		return -1;
	memcpy((char*)(ID_alarmValue + len_alarmValue), (char*)IalarmValue, ILalarmValue * sizeof(OIDC_T));
	ILalarmValue += len_alarmValue;

	if (ILalarmRisingThreshold != 1)
		return -1;
	memcpy((char*)(ID_alarmRisingThreshold + len_alarmRisingThreshold), (char*)IalarmRisingThreshold, ILalarmRisingThreshold * sizeof(OIDC_T));
	ILalarmRisingThreshold += len_alarmRisingThreshold;


	/* Create the SNMP packet structure. */
	trap_pkt = SNMP_Create_Request2(TRAP2_PDU, SNMP_VERSION_2,
				   comlen, community, request_id,
				   7, 0, 0);

	/* Verify that SNMP_Create_V2_Request succeeded. */
	if (trap_pkt == (SNMP_PKT_T*)0)
		return 0;

	/* Bind the variables in the trap. */
	if (SNMP_Bind_Unsigned_Integer(trap_pkt, 0, len_sysUpTime, ID_sysUpTime, VT_TIMETICKS, timestamp) == -1)
		goto fail;

	if (SNMP_Bind_Object_ID(trap_pkt, 1, len_snmpTrapOID, ID_snmpTrapOID, len_risingAlarm, ID_risingAlarm) == -1)
		goto fail;

	if (SNMP_Bind_Integer(trap_pkt, 2, ILalarmIndex, ID_alarmIndex, AalarmIndex) == -1)
		goto fail;

	if (SNMP_Bind_Object_ID(trap_pkt, 3, ILalarmVariable, ID_alarmVariable, AalarmVariable->num_components, AalarmVariable->component_list) == -1)
		goto fail;

	if (SNMP_Bind_Integer(trap_pkt, 4, ILalarmSampleType, ID_alarmSampleType, AalarmSampleType) == -1)
		goto fail;

	if (SNMP_Bind_Integer(trap_pkt, 5, ILalarmValue, ID_alarmValue, AalarmValue) == -1)
		goto fail;

	if (SNMP_Bind_Integer(trap_pkt, 6, ILalarmRisingThreshold, ID_alarmRisingThreshold, AalarmRisingThreshold) == -1)
		goto fail;

	/* Encode the packet as bytes into the user-supplied buffer. */
	if (SNMP_Encode_Packet(trap_pkt, ebuff) == -1)
		goto fail;

	/* Free the SNMP packet structure. */
	SNMP_Free(trap_pkt);

	/* Return the number of bytes used in the buffer. */
	return EBufferUsed(ebuff);

fail:
	/* Come here on failure during bind or encode. */
	SNMP_Free(trap_pkt);
	return 0;
}



/* Falling Alarm Alarm Trap v1 */

static OIDC_T ID_alarmFallingThreshold[] = { 1, 3, 6, 1, 2, 1, 16, 3, 1, 1, 8, 0 };
static int len_alarmFallingThreshold = 11;


/*****************************************************************************
 ****
 ****
 **** Trap creation function for fallingAlarm trap
 ****
 **** DESCRIPTION:
 **** The SNMP trap that is generated when an alarm entry crosses its falling
 **** threshold and generates an event that is configured for sending SNMP
 **** traps.
 ****
 **** Returns length of encoded packet, 0 on SNMP failure,
 **** or -1 if an instance is too long.
 ****
 ****
 *****************************************************************************
 */

int crt_fallingAlarm_trap(
	EBUFFER_T	*ebuff,
	OCTET_T		*local_ip,
	char		*community,
	unsigned	comlen,
	UINT_32_T	timestamp,
	INT_32_T	AalarmIndex,	/* INTEGER */
	OIDC_T		*IalarmIndex,	/* Instance */
	int		ILalarmIndex,	/* Instance length */
	OBJ_ID_T*	AalarmVariable,	/* OBJECT IDENTIFIER */
	OIDC_T		*IalarmVariable,	/* Instance */
	int		ILalarmVariable,	/* Instance length */
	INT_32_T	AalarmSampleType,	/* INTEGER */
	OIDC_T		*IalarmSampleType,	/* Instance */
	int		ILalarmSampleType,	/* Instance length */
	INT_32_T	AalarmValue,	/* INTEGER */
	OIDC_T		*IalarmValue,	/* Instance */
	int		ILalarmValue,	/* Instance length */
	INT_32_T	AalarmFallingThreshold,	/* INTEGER */
	OIDC_T		*IalarmFallingThreshold,	/* Instance */
	int		ILalarmFallingThreshold)	/* Instance length */
{
	SNMP_PKT_T	*trap_pkt;

	/*
	 * Check the instance lengths, copy the instance IDs,
	 * and increase local copies of the lengths for later.
	 */
	if (ILalarmIndex != 1)
		return -1;
	memcpy((char*)(ID_alarmIndex + len_alarmIndex), (char*)IalarmIndex, ILalarmIndex * sizeof(OIDC_T));
	ILalarmIndex += len_alarmIndex;

	if (ILalarmVariable != 1)
		return -1;
	memcpy((char*)(ID_alarmVariable + len_alarmVariable), (char*)IalarmVariable, ILalarmVariable * sizeof(OIDC_T));
	ILalarmVariable += len_alarmVariable;

	if (ILalarmSampleType != 1)
		return -1;
	memcpy((char*)(ID_alarmSampleType + len_alarmSampleType), (char*)IalarmSampleType, ILalarmSampleType * sizeof(OIDC_T));
	ILalarmSampleType += len_alarmSampleType;

	if (ILalarmValue != 1)
		return -1;
	memcpy((char*)(ID_alarmValue + len_alarmValue), (char*)IalarmValue, ILalarmValue * sizeof(OIDC_T));
	ILalarmValue += len_alarmValue;

	if (ILalarmFallingThreshold != 1)
		return -1;
	memcpy((char*)(ID_alarmFallingThreshold + len_alarmFallingThreshold), (char*)IalarmFallingThreshold, ILalarmFallingThreshold * sizeof(OIDC_T));
	ILalarmFallingThreshold += len_alarmFallingThreshold;


	/* Create the SNMP packet structure. */
	trap_pkt = SNMP_Create_Trap(VERSION_RFC1157, comlen, community,
				    len_rmon, ID_rmon,
				    local_ip,
				    6,	/* enterpriseSpecific(6) */
				    2,
				    timestamp,
				    5);

	/* Verify that SNMP_Create_Trap succeeded. */
	if (trap_pkt == (SNMP_PKT_T*)0)
		return 0;

	/* Bind the variables in the trap. */
	if (SNMP_Bind_Integer(trap_pkt, 0, ILalarmIndex, ID_alarmIndex, AalarmIndex) == -1)
		goto fail;

	if (SNMP_Bind_Object_ID(trap_pkt, 1, ILalarmVariable, ID_alarmVariable, AalarmVariable->num_components, AalarmVariable->component_list) == -1)
		goto fail;

	if (SNMP_Bind_Integer(trap_pkt, 2, ILalarmSampleType, ID_alarmSampleType, AalarmSampleType) == -1)
		goto fail;

	if (SNMP_Bind_Integer(trap_pkt, 3, ILalarmValue, ID_alarmValue, AalarmValue) == -1)
		goto fail;

	if (SNMP_Bind_Integer(trap_pkt, 4, ILalarmFallingThreshold, ID_alarmFallingThreshold, AalarmFallingThreshold) == -1)
		goto fail;

	/* Encode the packet as bytes into the user-supplied buffer. */
	if (SNMP_Encode_Packet(trap_pkt, ebuff) == -1)
		goto fail;

	/* Free the SNMP packet structure. */
	SNMP_Free(trap_pkt);

	/* Return the number of bytes used in the buffer. */
	return EBufferUsed(ebuff);

fail:
	/* Come here on failure during bind or encode. */
	SNMP_Free(trap_pkt);
	return 0;
}


/*Falling Alarm Trap V2*/

static OIDC_T ID_fallingAlarm[] = { 1, 3, 6, 1, 2, 1, 16, 0, 2 };
static int len_fallingAlarm = 9;



/*****************************************************************************
 ****
 ****
 **** Trap creation function for fallingAlarm trap
 ****
 **** DESCRIPTION:
 **** The SNMP trap that is generated when an alarm entry crosses its falling
 **** threshold and generates an event that is configured for sending SNMP
 **** traps.
 ****
 **** Returns length of encoded packet, 0 on SNMP failure,
 **** or -1 if an instance is too long.
 ****
 ****
 *****************************************************************************
 */

int crt_fallingAlarm_trapv2(
	EBUFFER_T	*ebuff,
	char		*community,
	int		comlen,
	INT_32_T	request_id,
	UINT_32_T	timestamp,
	INT_32_T	AalarmIndex,	/* INTEGER */
	OIDC_T		*IalarmIndex,	/* Instance */
	int		ILalarmIndex,	/* Instance length */
	OBJ_ID_T*	AalarmVariable,	/* OBJECT IDENTIFIER */
	OIDC_T		*IalarmVariable,	/* Instance */
	int		ILalarmVariable,	/* Instance length */
	INT_32_T	AalarmSampleType,	/* INTEGER */
	OIDC_T		*IalarmSampleType,	/* Instance */
	int		ILalarmSampleType,	/* Instance length */
	INT_32_T	AalarmValue,	/* INTEGER */
	OIDC_T		*IalarmValue,	/* Instance */
	int		ILalarmValue,	/* Instance length */
	INT_32_T	AalarmFallingThreshold,	/* INTEGER */
	OIDC_T		*IalarmFallingThreshold,	/* Instance */
	int		ILalarmFallingThreshold)	/* Instance length */
{
	SNMP_PKT_T	*trap_pkt;

	/*
	 * Check the instance lengths, copy the instance IDs,
	 * and increase local copies of the lengths for later.
	 */
	if (ILalarmIndex != 1)
		return -1;
	memcpy((char*)(ID_alarmIndex + len_alarmIndex), (char*)IalarmIndex, ILalarmIndex * sizeof(OIDC_T));
	ILalarmIndex += len_alarmIndex;

	if (ILalarmVariable != 1)
		return -1;
	memcpy((char*)(ID_alarmVariable + len_alarmVariable), (char*)IalarmVariable, ILalarmVariable * sizeof(OIDC_T));
	ILalarmVariable += len_alarmVariable;

	if (ILalarmSampleType != 1)
		return -1;
	memcpy((char*)(ID_alarmSampleType + len_alarmSampleType), (char*)IalarmSampleType, ILalarmSampleType * sizeof(OIDC_T));
	ILalarmSampleType += len_alarmSampleType;

	if (ILalarmValue != 1)
		return -1;
	memcpy((char*)(ID_alarmValue + len_alarmValue), (char*)IalarmValue, ILalarmValue * sizeof(OIDC_T));
	ILalarmValue += len_alarmValue;

	if (ILalarmFallingThreshold != 1)
		return -1;
	memcpy((char*)(ID_alarmFallingThreshold + len_alarmFallingThreshold), (char*)IalarmFallingThreshold, ILalarmFallingThreshold * sizeof(OIDC_T));
	ILalarmFallingThreshold += len_alarmFallingThreshold;


	/* Create the SNMP packet structure. */
	trap_pkt = SNMP_Create_Request2(TRAP2_PDU, SNMP_VERSION_2,
				   comlen, community, request_id,
				   7, 0, 0);

	/* Verify that SNMP_Create_V2_Request succeeded. */
	if (trap_pkt == (SNMP_PKT_T*)0)
		return 0;

	/* Bind the variables in the trap. */
	if (SNMP_Bind_Unsigned_Integer(trap_pkt, 0, len_sysUpTime, ID_sysUpTime, VT_TIMETICKS, timestamp) == -1)
		goto fail;

	if (SNMP_Bind_Object_ID(trap_pkt, 1, len_snmpTrapOID, ID_snmpTrapOID, len_fallingAlarm, ID_fallingAlarm) == -1)
		goto fail;

	if (SNMP_Bind_Integer(trap_pkt, 2, ILalarmIndex, ID_alarmIndex, AalarmIndex) == -1)
		goto fail;

	if (SNMP_Bind_Object_ID(trap_pkt, 3, ILalarmVariable, ID_alarmVariable, AalarmVariable->num_components, AalarmVariable->component_list) == -1)
		goto fail;

	if (SNMP_Bind_Integer(trap_pkt, 4, ILalarmSampleType, ID_alarmSampleType, AalarmSampleType) == -1)
		goto fail;

	if (SNMP_Bind_Integer(trap_pkt, 5, ILalarmValue, ID_alarmValue, AalarmValue) == -1)
		goto fail;

	if (SNMP_Bind_Integer(trap_pkt, 6, ILalarmFallingThreshold, ID_alarmFallingThreshold, AalarmFallingThreshold) == -1)
		goto fail;

	/* Encode the packet as bytes into the user-supplied buffer. */
	if (SNMP_Encode_Packet(trap_pkt, ebuff) == -1)
		goto fail;

	/* Free the SNMP packet structure. */
	SNMP_Free(trap_pkt);

	/* Return the number of bytes used in the buffer. */
	return EBufferUsed(ebuff);

fail:
	/* Come here on failure during bind or encode. */
	SNMP_Free(trap_pkt);
	return 0;
}
