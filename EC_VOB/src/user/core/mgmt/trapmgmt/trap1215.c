/******************************************************************************
 ******************************************************************************
 **** This file was automatically generated by Epilogue Technology's
 **** Emissary SNMP MIB Compiler, version 6.3.
 **** This file was generated using the -trap.c switch.
 **** 
 **** This file contains functions to generate SNMP TRAP PDUs for all the
 **** trap definitions that Emissary encountered.  To use the functions in
 **** this file, run Emissary with the -trap.h switch to generate a header
 **** file with the corresponding function declarations.
 **** 
 **** DO NOT MODIFY THIS FILE BY HAND.
 **** 
 **** Last build date: Wed Nov 25 19:25:33 1998
 **** from files:
 ****  rfc1213.mib, rfc1215.mib
 ******************************************************************************
 ******************************************************************************
 */

#include <envoy/h/asn1.h>
#include <envoy/h/buffer.h>
#include <envoy/h/snmpdefs.h>
#include "sys_type.h"
#include "sys_adpt.h"
#include "sys_mgr.h"
#include "leaf_sys.h"
#include "trap_mgr.h"

/* NAMING CONSTANT DECLARATIONS 
 */



/* STATIC VARIABLE DECLARATIONS
 */
static OBJ_ID_T   system_oid;
static OIDC_T     oid_buf[SYS_ADPT_MAX_OID_COUNT];

 /* LOCAL SUBPROGRAM DECLARATIONS
  */


/* EXPORTED SUBPROGRAM BODIES
 */

/* Cold Start V1 Trap */

/*****************************************************************************
 ****
 ****
 **** Trap creation function for coldStart trap
 ****
 **** DESCRIPTION:
 **** A coldStart trap signifies that the sending protocol entity is
 **** reinitializing itself such that the agent's configuration or the rotocol
 **** entity implementation may be altered.
 ****
 **** Returns length of encoded packet, 0 on SNMP failure,
 **** or -1 if an instance is too long.
 ****
 ****
 *****************************************************************************
 */
int crt_coldStart_trap(
	EBUFFER_T	*ebuff,
	OCTET_T		*local_ip,
	char		*community,
	unsigned	comlen,
	UINT_32_T	timestamp)
{
   /* LOCAL VARIABLE DECLARATIONS */
   
	SNMP_PKT_T	      *trap_pkt;

   /* BODY */
   	   
   /* Get system object ID.
    * Note: 1. The system OID will return from sys-mgmt.c
    *       2. The system OID will be used by RFC1215.C
    *       3. The system OID will be set up once during the cold start trap.
    *          For other traps defined by RFC1215 will use the system OID setup in here.
	 */

	/* Create the SNMP packet structure. 
	 */
	trap_pkt = SNMP_Create_Trap(VERSION_RFC1157, comlen, community,
				    system_oid.num_components, system_oid.component_list,
				    local_ip,
				    0,
				    0,
				    timestamp,
				    0);

	/* Verify that SNMP_Create_Trap succeeded. */
	if (trap_pkt == (SNMP_PKT_T*)0)
		return 0;

	/* Encode the packet as bytes into the user-supplied buffer. */
	if (SNMP_Encode_Packet(trap_pkt, ebuff) == -1)
		goto fail;

	/* Free the SNMP packet structure. */
	SNMP_Free(trap_pkt);

	/* Return the number of bytes used in the buffer. */
	return EBufferUsed(ebuff);

fail:
	/* Come here on failure during bind or encode. */
	SNMP_Free(trap_pkt);
	return 0;
}



/* ColdStart V2 Trap */

static OIDC_T ID_sysUpTime[] = { 1, 3, 6, 1, 2, 1, 1, 3, 0 };
static int len_sysUpTime = 9;
static OIDC_T ID_snmpTrapOID[] = { 1, 3, 6, 1, 6, 3, 1, 1, 4, 1, 0 };
static int len_snmpTrapOID = 11;
static OIDC_T ID_coldStart[] = { 1, 3, 6, 1, 6, 3, 1, 1, 5, 1 };
static int len_coldStart = 10;



/*****************************************************************************
 ****
 ****
 **** Trap creation function for coldStart trap 
 ****
 **** DESCRIPTION:
 **** A coldStart trap signifies that the SNMPv2 entity, acting in an agent
 **** role, is reinitializing itself and that its configuration may have been
 **** altered.
 ****
 **** Returns length of encoded packet, 0 on SNMP failure,
 **** or -1 if an instance is too long.
 ****
 ****
 *****************************************************************************
 */

int crt_coldStart_trapv2(
	EBUFFER_T	*ebuff,
	char		*community,
	int		comlen,
	INT_32_T	request_id,
	UINT_32_T	timestamp)
{
	SNMP_PKT_T	*trap_pkt;

	/* Create the SNMP packet structure. */
	trap_pkt = SNMP_Create_Request2(TRAP2_PDU, SNMP_VERSION_2,
				   comlen, community, request_id,
				   2, 0, 0);

	/* Verify that SNMP_Create_V2_Request succeeded. */
	if (trap_pkt == (SNMP_PKT_T*)0)
		return 0;

	/* Bind the variables in the trap. */
	if (SNMP_Bind_Unsigned_Integer(trap_pkt, 0, len_sysUpTime, ID_sysUpTime, VT_TIMETICKS, timestamp) == -1)
		goto fail;

	if (SNMP_Bind_Object_ID(trap_pkt, 1, len_snmpTrapOID, ID_snmpTrapOID, len_coldStart, ID_coldStart) == -1)
		goto fail;

	/* Encode the packet as bytes into the user-supplied buffer. */
	if (SNMP_Encode_Packet(trap_pkt, ebuff) == -1)
		goto fail;

	/* Free the SNMP packet structure. */
	SNMP_Free(trap_pkt);

	/* Return the number of bytes used in the buffer. */
	return EBufferUsed(ebuff);

fail:
	/* Come here on failure during bind or encode. */
	SNMP_Free(trap_pkt);
	return 0;
}

/* Warm Start V1 Trap*/

/*****************************************************************************
 ****
 ****
 **** Trap creation function for warmStart trap
 ****
 **** DESCRIPTION:
 **** A warmStart trap signifies that the sending protocol entity is
 **** reinitializing itself such that neither the agent configuration nor the
 **** protocol entity implementation is altered.
 ****
 **** Returns length of encoded packet, 0 on SNMP failure,
 **** or -1 if an instance is too long.
 ****
 ****
 *****************************************************************************
 */

int crt_warmStart_trap(
	EBUFFER_T	*ebuff,
	OCTET_T		*local_ip,
	char		*community,
	unsigned	comlen,
	UINT_32_T	timestamp)
{
	SNMP_PKT_T	*trap_pkt;

	/* Create the SNMP packet structure. */
	trap_pkt = SNMP_Create_Trap(VERSION_RFC1157, comlen, community,
				    system_oid.num_components, system_oid.component_list,
				    local_ip,
				    1,
				    0,
				    timestamp,
				    0);

	/* Verify that SNMP_Create_Trap succeeded. */
	if (trap_pkt == (SNMP_PKT_T*)0)
		return 0;

	/* Encode the packet as bytes into the user-supplied buffer. */
	if (SNMP_Encode_Packet(trap_pkt, ebuff) == -1)
		goto fail;

	/* Free the SNMP packet structure. */
	SNMP_Free(trap_pkt);

	/* Return the number of bytes used in the buffer. */
	return EBufferUsed(ebuff);

fail:
	/* Come here on failure during bind or encode. */
	SNMP_Free(trap_pkt);
	return 0;
}


/* Warm Start V2 Trap */
static OIDC_T ID_warmStart[] = { 1, 3, 6, 1, 6, 3, 1, 1, 5, 2 };
static int len_warmStart = 10;

/*****************************************************************************
 ****
 ****
 **** Trap creation function for warmStart trap
 ****
 **** DESCRIPTION:
 **** A warmStart trap signifies that the SNMPv2 entity, acting in an agent
 **** role, is reinitializing itself such that its configuration is unaltered.
 ****
 **** Returns length of encoded packet, 0 on SNMP failure,
 **** or -1 if an instance is too long.
 ****
 ****
 *****************************************************************************
 */

int crt_warmStart_trapv2(
	EBUFFER_T	*ebuff,
	char		*community,
	int		comlen,
	INT_32_T	request_id,
	UINT_32_T	timestamp)
{
	SNMP_PKT_T	*trap_pkt;

	/* Create the SNMP packet structure. */
	trap_pkt = SNMP_Create_Request2(TRAP2_PDU, SNMP_VERSION_2,
				   comlen, community, request_id,
				   2, 0, 0);

	/* Verify that SNMP_Create_V2_Request succeeded. */
	if (trap_pkt == (SNMP_PKT_T*)0)
		return 0;

	/* Bind the variables in the trap. */
	if (SNMP_Bind_Unsigned_Integer(trap_pkt, 0, len_sysUpTime, ID_sysUpTime, VT_TIMETICKS, timestamp) == -1)
		goto fail;

	if (SNMP_Bind_Object_ID(trap_pkt, 1, len_snmpTrapOID, ID_snmpTrapOID, len_warmStart, ID_warmStart) == -1)
		goto fail;

	/* Encode the packet as bytes into the user-supplied buffer. */
	if (SNMP_Encode_Packet(trap_pkt, ebuff) == -1)
		goto fail;

	/* Free the SNMP packet structure. */
	SNMP_Free(trap_pkt);

	/* Return the number of bytes used in the buffer. */
	return EBufferUsed(ebuff);

fail:
	/* Come here on failure during bind or encode. */
	SNMP_Free(trap_pkt);
	return 0;
}



/* Link Down V1 Trap*/

static OIDC_T ID_ifIndex[] = { 1, 3, 6, 1, 2, 1, 2, 2, 1, 1, 0 };
static int len_ifIndex = 10;


/*****************************************************************************
 ****
 ****
 **** Trap creation function for linkDown trap
 ****
 **** DESCRIPTION:
 **** A linkDown trap signifies that the sending protocol entity recognizes a
 **** failure in one of the communication links represented in the agent's
 **** configuration.
 ****
 **** Returns length of encoded packet, 0 on SNMP failure,
 **** or -1 if an instance is too long.
 ****
 ****
 *****************************************************************************
 */

int crt_linkDown_trap(
	EBUFFER_T	*ebuff,
	OCTET_T		*local_ip,
	char		*community,
	unsigned	comlen,
	UINT_32_T	timestamp,
	INT_32_T	AifIndex,	/* INTEGER */
	OIDC_T		*IifIndex,	/* Instance */
	int		ILifIndex)	/* Instance length */
{
	SNMP_PKT_T	*trap_pkt;

	/*
	 * Check the instance lengths, copy the instance IDs,
	 * and increase local copies of the lengths for later.
	 */
	if (ILifIndex != 1)
		return -1;
	memcpy((char*)(ID_ifIndex + len_ifIndex), (char*)IifIndex, ILifIndex * sizeof(OIDC_T));
	ILifIndex += len_ifIndex;


	/* Create the SNMP packet structure. */
	trap_pkt = SNMP_Create_Trap(VERSION_RFC1157, comlen, community,
				    system_oid.num_components, system_oid.component_list,
				    local_ip,
				    2,
				    0,
				    timestamp,
				    1);

	/* Verify that SNMP_Create_Trap succeeded. */
	if (trap_pkt == (SNMP_PKT_T*)0)
		return 0;

	/* Bind the variables in the trap. */
	if (SNMP_Bind_Integer(trap_pkt, 0, ILifIndex, ID_ifIndex, AifIndex) == -1)
		goto fail;

	/* Encode the packet as bytes into the user-supplied buffer. */
	if (SNMP_Encode_Packet(trap_pkt, ebuff) == -1)
		goto fail;

	/* Free the SNMP packet structure. */
	SNMP_Free(trap_pkt);

	/* Return the number of bytes used in the buffer. */
	return EBufferUsed(ebuff);

fail:
	/* Come here on failure during bind or encode. */
	SNMP_Free(trap_pkt);
	return 0;
}

/* Link Down V2 Trap*/

static OIDC_T ID_linkDown[] = { 1, 3, 6, 1, 6, 3, 1, 1, 5, 3 };
static int len_linkDown = 10;

static OIDC_T ID_ifAdminStatus[] = { 1, 3, 6, 1, 2, 1, 2, 2, 1, 7, 0 };
static int len_ifAdminStatus = 10;

static OIDC_T ID_ifOperStatus[] = { 1, 3, 6, 1, 2, 1, 2, 2, 1, 8, 0 };
static int len_ifOperStatus = 10;

/*****************************************************************************
 ****
 ****
 **** Trap creation function for linkDown trap
 ****
 **** DESCRIPTION:
 **** A linkDown trap signifies that the SNMP entity, acting in an agent role,
 **** has detected that the ifOperStatus object for one of its communication
 **** links is about to enter the down state from some other state (but not
 **** from the notPresent state). This other state is indicated by the included
 **** value of ifOperStatus.
 ****
 **** Returns length of encoded packet, 0 on SNMP failure,
 **** or -1 if an instance is too long.
 ****
 ****
 *****************************************************************************
 */
int crt_linkDown_trapV2(
	EBUFFER_T	*ebuff,
	char		*community,
	int		comlen,
	INT_32_T	request_id,
	UINT_32_T	timestamp,
	INT_32_T	AifIndex,	/* INTEGER */
	OIDC_T		*IifIndex,	/* Instance */
	int		ILifIndex,	/* Instance length */
	INT_32_T	AifAdminStatus,	/* INTEGER */
	OIDC_T		*IifAdminStatus,	/* Instance */
	int		ILifAdminStatus,	/* Instance length */
	INT_32_T	AifOperStatus,	/* INTEGER */
	OIDC_T		*IifOperStatus,	/* Instance */
	int		ILifOperStatus)	/* Instance length */
{
	SNMP_PKT_T	*trap_pkt;

	/*
	 * Check the instance lengths, copy the instance IDs,
	 * and increase local copies of the lengths for later.
	 */
	if (ILifIndex != 1)
		return -1;
	memcpy((char*)(ID_ifIndex + len_ifIndex), (char*)IifIndex, ILifIndex * sizeof(OIDC_T));
	ILifIndex += len_ifIndex;

	if (ILifAdminStatus != 1)
		return -1;
	memcpy((char*)(ID_ifAdminStatus + len_ifAdminStatus), (char*)IifAdminStatus, ILifAdminStatus * sizeof(OIDC_T));
	ILifAdminStatus += len_ifAdminStatus;

	if (ILifOperStatus != 1)
		return -1;
	memcpy((char*)(ID_ifOperStatus + len_ifOperStatus), (char*)IifOperStatus, ILifOperStatus * sizeof(OIDC_T));
	ILifOperStatus += len_ifOperStatus;


	/* Create the SNMP packet structure. */
	trap_pkt = SNMP_Create_Request2(TRAP2_PDU, SNMP_VERSION_2,
				   comlen, community, request_id,
				   5, 0, 0);

	/* Verify that SNMP_Create_V2_Request succeeded. */
	if (trap_pkt == (SNMP_PKT_T*)0)
		return 0;

	/* Bind the variables in the trap. */
	if (SNMP_Bind_Unsigned_Integer(trap_pkt, 0, len_sysUpTime, ID_sysUpTime, VT_TIMETICKS, timestamp) == -1)
		goto fail;

	if (SNMP_Bind_Object_ID(trap_pkt, 1, len_snmpTrapOID, ID_snmpTrapOID, len_linkDown, ID_linkDown) == -1)
		goto fail;

	if (SNMP_Bind_Integer(trap_pkt, 2, ILifIndex, ID_ifIndex, AifIndex) == -1)
		goto fail;

	if (SNMP_Bind_Integer(trap_pkt, 3, ILifAdminStatus, ID_ifAdminStatus, AifAdminStatus) == -1)
		goto fail;

	if (SNMP_Bind_Integer(trap_pkt, 4, ILifOperStatus, ID_ifOperStatus, AifOperStatus) == -1)
		goto fail;

	/* Encode the packet as bytes into the user-supplied buffer. */
	if (SNMP_Encode_Packet(trap_pkt, ebuff) == -1)
		goto fail;

	/* Free the SNMP packet structure. */
	SNMP_Free(trap_pkt);

	/* Return the number of bytes used in the buffer. */
	return EBufferUsed(ebuff);

fail:
	/* Come here on failure during bind or encode. */
	SNMP_Free(trap_pkt);
	return 0;
}

/* Link Up V1 Trap*/


/*****************************************************************************
 ****
 ****
 **** Trap creation function for linkUp trap
 ****
 **** DESCRIPTION:
 **** A linkUp trap signifies that the sending protocol entity recognizes that
 **** one of the communication links represented in the agent's configuration
 **** has come up.
 ****
 **** Returns length of encoded packet, 0 on SNMP failure,
 **** or -1 if an instance is too long.
 ****
 ****
 *****************************************************************************
 */

int crt_linkUp_trap(
	EBUFFER_T	*ebuff,
	OCTET_T		*local_ip,
	char		*community,
	unsigned	comlen,
	UINT_32_T	timestamp,
	INT_32_T	AifIndex,	/* INTEGER */
	OIDC_T		*IifIndex,	/* Instance */
	int		ILifIndex)	/* Instance length */
{
	SNMP_PKT_T	*trap_pkt;

	/*
	 * Check the instance lengths, copy the instance IDs,
	 * and increase local copies of the lengths for later.
	 */
	if (ILifIndex != 1)
		return -1;
	memcpy((char*)(ID_ifIndex + len_ifIndex), (char*)IifIndex, ILifIndex * sizeof(OIDC_T));
	ILifIndex += len_ifIndex;


	/* Create the SNMP packet structure. */
	trap_pkt = SNMP_Create_Trap(VERSION_RFC1157, comlen, community,
				    system_oid.num_components, system_oid.component_list,
				    local_ip,
				    3,
				    0,
				    timestamp,
				    1);

	/* Verify that SNMP_Create_Trap succeeded. */
	if (trap_pkt == (SNMP_PKT_T*)0)
		return 0;

	/* Bind the variables in the trap. */
	if (SNMP_Bind_Integer(trap_pkt, 0, ILifIndex, ID_ifIndex, AifIndex) == -1)
		goto fail;

	/* Encode the packet as bytes into the user-supplied buffer. */
	if (SNMP_Encode_Packet(trap_pkt, ebuff) == -1)
		goto fail;

	/* Free the SNMP packet structure. */
	SNMP_Free(trap_pkt);

	/* Return the number of bytes used in the buffer. */
	return EBufferUsed(ebuff);

fail:
	/* Come here on failure during bind or encode. */
	SNMP_Free(trap_pkt);
	return 0;
}

/* Link UP V2 Trap*/
static OIDC_T ID_linkUp[] = { 1, 3, 6, 1, 6, 3, 1, 1, 5, 4 };
static int len_linkUp = 10;

/*****************************************************************************
 ****
 ****
 **** Trap creation function for linkUp trap
 ****
 **** DESCRIPTION:
 **** A linkUp trap signifies that the SNMP entity, acting in an agent role,
 **** has detected that the ifOperStatus object for one of its communication
 **** links left the down state and transitioned into some other state (but not
 **** into the notPresent state). This other state is indicated by the included
 **** value of ifOperStatus.
 ****
 **** Returns length of encoded packet, 0 on SNMP failure,
 **** or -1 if an instance is too long.
 ****
 ****
 *****************************************************************************
 */
int crt_linkUp_trapV2(
	EBUFFER_T	*ebuff,
	char		*community,
	int		comlen,
	INT_32_T	request_id,
	UINT_32_T	timestamp,
	INT_32_T	AifIndex,	/* INTEGER */
	OIDC_T		*IifIndex,	/* Instance */
	int		ILifIndex,	/* Instance length */
	INT_32_T	AifAdminStatus,	/* INTEGER */
	OIDC_T		*IifAdminStatus,	/* Instance */
	int		ILifAdminStatus,	/* Instance length */
	INT_32_T	AifOperStatus,	/* INTEGER */
	OIDC_T		*IifOperStatus,	/* Instance */
	int		ILifOperStatus)	/* Instance length */
{
	SNMP_PKT_T	*trap_pkt;

	/*
	 * Check the instance lengths, copy the instance IDs,
	 * and increase local copies of the lengths for later.
	 */
	if (ILifIndex != 1)
		return -1;
	memcpy((char*)(ID_ifIndex + len_ifIndex), (char*)IifIndex, ILifIndex * sizeof(OIDC_T));
	ILifIndex += len_ifIndex;

	if (ILifAdminStatus != 1)
		return -1;
	memcpy((char*)(ID_ifAdminStatus + len_ifAdminStatus), (char*)IifAdminStatus, ILifAdminStatus * sizeof(OIDC_T));
	ILifAdminStatus += len_ifAdminStatus;

	if (ILifOperStatus != 1)
		return -1;
	memcpy((char*)(ID_ifOperStatus + len_ifOperStatus), (char*)IifOperStatus, ILifOperStatus * sizeof(OIDC_T));
	ILifOperStatus += len_ifOperStatus;


	/* Create the SNMP packet structure. */
	trap_pkt = SNMP_Create_Request2(TRAP2_PDU, SNMP_VERSION_2,
				   comlen, community, request_id,
				   5, 0, 0);

	/* Verify that SNMP_Create_V2_Request succeeded. */
	if (trap_pkt == (SNMP_PKT_T*)0)
		return 0;

	/* Bind the variables in the trap. */
	if (SNMP_Bind_Unsigned_Integer(trap_pkt, 0, len_sysUpTime, ID_sysUpTime, VT_TIMETICKS, timestamp) == -1)
		goto fail;

	if (SNMP_Bind_Object_ID(trap_pkt, 1, len_snmpTrapOID, ID_snmpTrapOID, len_linkUp, ID_linkUp) == -1)
		goto fail;

	if (SNMP_Bind_Integer(trap_pkt, 2, ILifIndex, ID_ifIndex, AifIndex) == -1)
		goto fail;

	if (SNMP_Bind_Integer(trap_pkt, 3, ILifAdminStatus, ID_ifAdminStatus, AifAdminStatus) == -1)
		goto fail;

	if (SNMP_Bind_Integer(trap_pkt, 4, ILifOperStatus, ID_ifOperStatus, AifOperStatus) == -1)
		goto fail;

	/* Encode the packet as bytes into the user-supplied buffer. */
	if (SNMP_Encode_Packet(trap_pkt, ebuff) == -1)
		goto fail;

	/* Free the SNMP packet structure. */
	SNMP_Free(trap_pkt);

	/* Return the number of bytes used in the buffer. */
	return EBufferUsed(ebuff);

fail:
	/* Come here on failure during bind or encode. */
	SNMP_Free(trap_pkt);
	return 0;
}

/*  authenticationFailure V1 Trap*/
/*****************************************************************************
 ****
 ****
 **** Trap creation function for authenticationFailure trap
 ****
 **** DESCRIPTION:
 **** An authenticationFailure trap signifies that the sending protocol entity
 **** is the addressee of a protocol message that is not properly
 **** authenticated. While implementations of the SNMP must be capable of
 **** generating this trap, they must also be capable of suppressing the
 **** emission of such traps via an implementation- specific mechanism.
 ****
 **** Returns length of encoded packet, 0 on SNMP failure,
 **** or -1 if an instance is too long.
 ****
 ****
 *****************************************************************************
 */

int crt_authenticationFailure_trap(
	EBUFFER_T	*ebuff,
	OCTET_T		*local_ip,
	char		*community,
	unsigned	comlen,
	UINT_32_T	timestamp)
{
	SNMP_PKT_T	*trap_pkt;

	/* Create the SNMP packet structure. */
	trap_pkt = SNMP_Create_Trap(VERSION_RFC1157, comlen, community,
				    system_oid.num_components, system_oid.component_list,
				    local_ip,
				    4,
				    0,
				    timestamp,
				    0);

	/* Verify that SNMP_Create_Trap succeeded. */
	if (trap_pkt == (SNMP_PKT_T*)0)
		return 0;

	/* Encode the packet as bytes into the user-supplied buffer. */
	if (SNMP_Encode_Packet(trap_pkt, ebuff) == -1)
		goto fail;

	/* Free the SNMP packet structure. */
	SNMP_Free(trap_pkt);

	/* Return the number of bytes used in the buffer. */
	return EBufferUsed(ebuff);

fail:
	/* Come here on failure during bind or encode. */
	SNMP_Free(trap_pkt);
	return 0;
}


/* authenticationFailure v2Trap*/
static OIDC_T ID_authenticationFailure[] = { 1, 3, 6, 1, 6, 3, 1, 1, 5, 5 };
static int len_authenticationFailure = 10;

/*****************************************************************************
 ****
 ****
 **** Trap creation function for authenticationFailure trap
 ****
 **** DESCRIPTION:
 **** An authenticationFailure trap signifies that the SNMPv2 entity, acting in
 **** an agent role, has received a protocol message that is not properly
 **** authenticated. While all implementations of the SNMPv2 must be capable of
 **** generating this trap, the snmpEnableAuthenTraps object indicates whether
 **** this trap will be generated.
 ****
 **** Returns length of encoded packet, 0 on SNMP failure,
 **** or -1 if an instance is too long.
 ****
 ****
 *****************************************************************************
 */

int crt_authenticationFailure_trapv2(
	EBUFFER_T	*ebuff,
	char		*community,
	int		comlen,
	INT_32_T	request_id,
	UINT_32_T	timestamp)
{
	SNMP_PKT_T	*trap_pkt;

	/* Create the SNMP packet structure. */
	trap_pkt = SNMP_Create_Request2(TRAP2_PDU, SNMP_VERSION_2,
				   comlen, community, request_id,
				   2, 0, 0);

	/* Verify that SNMP_Create_V2_Request succeeded. */
	if (trap_pkt == (SNMP_PKT_T*)0)
		return 0;

	/* Bind the variables in the trap. */
	if (SNMP_Bind_Unsigned_Integer(trap_pkt, 0, len_sysUpTime, ID_sysUpTime, VT_TIMETICKS, timestamp) == -1)
		goto fail;

	if (SNMP_Bind_Object_ID(trap_pkt, 1, len_snmpTrapOID, ID_snmpTrapOID, len_authenticationFailure, ID_authenticationFailure) == -1)
		goto fail;

	/* Encode the packet as bytes into the user-supplied buffer. */
	if (SNMP_Encode_Packet(trap_pkt, ebuff) == -1)
		goto fail;

	/* Free the SNMP packet structure. */
	SNMP_Free(trap_pkt);

	/* Return the number of bytes used in the buffer. */
	return EBufferUsed(ebuff);

fail:
	/* Come here on failure during bind or encode. */
	SNMP_Free(trap_pkt);
	return 0;
}



/* We does not support the egpNeighborLoss Trap, so no V2 code,
   somehow, we remain the code here,James*/
static OIDC_T ID_egpNeighAddr[] = { 1, 3, 6, 1, 2, 1, 8, 5, 1, 2, 0, 0, 0, 0 };
static int len_egpNeighAddr = 10;


/*****************************************************************************
 ****
 ****
 **** Trap creation function for egpNeighborLoss trap
 ****
 **** DESCRIPTION:
 **** An egpNeighborLoss trap signifies that an EGP neighbor for whom the
 **** sending protocol entity was an EGP peer has been marked down and the peer
 **** relationship no longer obtains.
 ****
 **** Returns length of encoded packet, 0 on SNMP failure,
 **** or -1 if an instance is too long.
 ****
 ****
 *****************************************************************************
 */

int crt_egpNeighborLoss_trap(
	EBUFFER_T	*ebuff,
	OCTET_T		*local_ip,
	char		*community,
	unsigned	comlen,
	UINT_32_T	timestamp,
	OCTET_T*	AegpNeighAddr,	/* IpAddress */
	OIDC_T		*IegpNeighAddr,	/* Instance */
	int		ILegpNeighAddr)	/* Instance length */
{
	SNMP_PKT_T	*trap_pkt;

	/*
	 * Check the instance lengths, copy the instance IDs,
	 * and increase local copies of the lengths for later.
	 */
	if (ILegpNeighAddr != 4)
		return -1;
	memcpy((char*)(ID_egpNeighAddr + len_egpNeighAddr), (char*)IegpNeighAddr, ILegpNeighAddr * sizeof(OIDC_T));
	ILegpNeighAddr += len_egpNeighAddr;


	/* Create the SNMP packet structure. */
	trap_pkt = SNMP_Create_Trap(VERSION_RFC1157, comlen, community,
				    system_oid.num_components, system_oid.component_list,
				    local_ip,
				    5,
				    0,
				    timestamp,
				    1);

	/* Verify that SNMP_Create_Trap succeeded. */
	if (trap_pkt == (SNMP_PKT_T*)0)
		return 0;

	/* Bind the variables in the trap. */
	if (SNMP_Bind_IP_Address(trap_pkt, 0, ILegpNeighAddr, ID_egpNeighAddr, AegpNeighAddr) == -1)
		goto fail;

	/* Encode the packet as bytes into the user-supplied buffer. */
	if (SNMP_Encode_Packet(trap_pkt, ebuff) == -1)
		goto fail;

	/* Free the SNMP packet structure. */
	SNMP_Free(trap_pkt);

	/* Return the number of bytes used in the buffer. */
	return EBufferUsed(ebuff);

fail:
	/* Come here on failure during bind or encode. */
	SNMP_Free(trap_pkt);
	return 0;
}


BOOL_T Sys_Object_ID_Init()
{
    if (!system_oid.component_list)
    {
        UI32_T idx = 0;
        UI8_T *buffer;          
        memset(oid_buf, 0, sizeof(oid_buf));
        buffer= (UI8_T*)SNMP_memory_alloc(SYS_ADPT_MAX_OID_STRING_LEN+1);
        if (buffer == 0)
        {            
            printf("Sys_Object_ID_Init:mem alloc err ,sys oid\n");
            TRAP_MGR_Make_Oid_From_Dot_String(oid_buf, "");
        }
        else
        {
            if (SYS_MGR_GetSysObjectID(SYS_VAL_LOCAL_UNIT_ID, buffer))
            {
                TRAP_MGR_Make_Oid_From_Dot_String(oid_buf, buffer);
            }
            else
            {
                printf("Sys_Object_ID_Init:SYS_MGR_GetSysObjectID return false\n");
                TRAP_MGR_Make_Oid_From_Dot_String(oid_buf, "");
            }
            SNMP_memory_free(buffer);
        }                
        system_oid.component_list = oid_buf;
        system_oid.num_components = 0;

        while (oid_buf[idx++])
            system_oid.num_components += 1;
    }

    return TRUE;
}

